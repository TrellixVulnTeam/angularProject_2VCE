{"ast":null,"code":"var Module = require('./module');\n\nvar autoAnnotate = require('./annotation').parse;\n\nvar Injector = function Injector(modules, parent) {\n  parent = parent || {\n    get: function get(name) {\n      currentlyResolving.push(name);\n      throw error('No provider for \"' + name + '\"!');\n    }\n  };\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n  instances.injector = this;\n\n  var error = function error(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  var get = function get(name) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while (parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (Object.hasOwnProperty.call(instances, name)) {\n      return instances[name];\n    }\n\n    if (Object.hasOwnProperty.call(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Can not resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n      return instances[name];\n    }\n\n    return parent.get(name);\n  };\n\n  var instantiate = function instantiate(Type) {\n    var instance = Object.create(Type.prototype);\n    var returned = invoke(Type, instance);\n    return typeof returned === 'object' ? returned : instance;\n  };\n\n  var invoke = function invoke(fn, context) {\n    if (typeof fn !== 'function') {\n      throw error('Can not invoke \"' + fn + '\". Expected a function!');\n    }\n\n    var inject = fn.$inject && fn.$inject || autoAnnotate(fn);\n    var dependencies = inject.map(function (dep) {\n      return get(dep);\n    }); // TODO(vojta): optimize without apply\n\n    return fn.apply(context, dependencies);\n  };\n\n  var createChild = function createChild(modules, providersFromParent) {\n    if (providersFromParent && providersFromParent.length) {\n      var fromParentModule = Object.create(null);\n      providersFromParent.forEach(function (name) {\n        if (!providers[name]) {\n          throw new Error('No provider for \"' + name + '\". Can not use provider from the parent!');\n        }\n\n        fromParentModule[name] = [providers[name][2], providers[name][1]];\n      });\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, this);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function value(_value) {\n      return _value;\n    }\n  };\n  modules.forEach(function (module) {\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function (provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n        providers[name] = [factoryMap[type], value, type];\n      });\n    } else if (typeof module === 'object') {\n      Object.keys(module).forEach(function (name) {\n        var type = module[name][0];\n        var value = module[name][1];\n        providers[name] = [factoryMap[type], value, type];\n      });\n    }\n  }); // public API\n\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n};\n\nmodule.exports = Injector;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/di/lib/injector.js"],"names":["Module","require","autoAnnotate","parse","Injector","modules","parent","get","name","currentlyResolving","push","error","providers","_providers","Object","create","instances","_instances","injector","msg","stack","join","length","Error","indexOf","parts","split","pivot","shift","hasOwnProperty","call","pop","instantiate","Type","instance","prototype","returned","invoke","fn","context","inject","$inject","dependencies","map","dep","apply","createChild","providersFromParent","fromParentModule","forEach","unshift","factoryMap","factory","type","value","module","provider","keys","exports"],"mappings":"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","sourcesContent":["var Module = require('./module');\nvar autoAnnotate = require('./annotation').parse;\n\n\nvar Injector = function(modules, parent) {\n  parent = parent || {\n    get: function(name) {\n      currentlyResolving.push(name);\n      throw error('No provider for \"' + name + '\"!');\n    }\n  };\n\n  var currentlyResolving = [];\n  var providers = this._providers = Object.create(parent._providers || null);\n  var instances = this._instances = Object.create(null);\n\n  instances.injector = this;\n\n  var error = function(msg) {\n    var stack = currentlyResolving.join(' -> ');\n    currentlyResolving.length = 0;\n    return new Error(stack ? msg + ' (Resolving: ' + stack + ')' : msg);\n  };\n\n  var get = function(name) {\n    if (!providers[name] && name.indexOf('.') !== -1) {\n      var parts = name.split('.');\n      var pivot = get(parts.shift());\n\n      while(parts.length) {\n        pivot = pivot[parts.shift()];\n      }\n\n      return pivot;\n    }\n\n    if (Object.hasOwnProperty.call(instances, name)) {\n      return instances[name];\n    }\n\n    if (Object.hasOwnProperty.call(providers, name)) {\n      if (currentlyResolving.indexOf(name) !== -1) {\n        currentlyResolving.push(name);\n        throw error('Can not resolve circular dependency!');\n      }\n\n      currentlyResolving.push(name);\n      instances[name] = providers[name][0](providers[name][1]);\n      currentlyResolving.pop();\n\n      return instances[name];\n    }\n\n    return parent.get(name);\n  };\n\n  var instantiate = function(Type) {\n    var instance = Object.create(Type.prototype);\n    var returned = invoke(Type, instance);\n\n    return typeof returned === 'object' ? returned : instance;\n  };\n\n  var invoke = function(fn, context) {\n    if (typeof fn !== 'function') {\n      throw error('Can not invoke \"' + fn + '\". Expected a function!');\n    }\n\n    var inject = fn.$inject && fn.$inject || autoAnnotate(fn);\n    var dependencies = inject.map(function(dep) {\n      return get(dep);\n    });\n\n    // TODO(vojta): optimize without apply\n    return fn.apply(context, dependencies);\n  };\n\n  var createChild = function(modules, providersFromParent) {\n    if (providersFromParent && providersFromParent.length) {\n      var fromParentModule = Object.create(null);\n\n      providersFromParent.forEach(function(name) {\n        if (!providers[name]) {\n          throw new Error('No provider for \"' + name + '\". Can not use provider from the parent!');\n        }\n\n        fromParentModule[name] = [providers[name][2], providers[name][1]];\n      });\n\n      modules.unshift(fromParentModule);\n    }\n\n    return new Injector(modules, this);\n  };\n\n  var factoryMap = {\n    factory: invoke,\n    type: instantiate,\n    value: function(value) {\n      return value;\n    }\n  };\n\n  modules.forEach(function(module) {\n    // TODO(vojta): handle wrong inputs (modules)\n    if (module instanceof Module) {\n      module.forEach(function(provider) {\n        var name = provider[0];\n        var type = provider[1];\n        var value = provider[2];\n\n        providers[name] = [factoryMap[type], value, type];\n      });\n    } else if (typeof module === 'object') {\n      Object.keys(module).forEach(function(name) {\n        var type = module[name][0];\n        var value = module[name][1];\n\n        providers[name] = [factoryMap[type], value, type];\n      });\n    }\n  });\n\n  // public API\n  this.get = get;\n  this.invoke = invoke;\n  this.instantiate = instantiate;\n  this.createChild = createChild;\n};\n\nmodule.exports = Injector;\n"]},"metadata":{},"sourceType":"script"}