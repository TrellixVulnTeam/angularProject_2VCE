{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/directive_resolver\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/core\", \"@angular/compiler/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.findLast = exports.DirectiveResolver = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var QUERY_METADATA_IDENTIFIERS = [core_1.createViewChild, core_1.createViewChildren, core_1.createContentChild, core_1.createContentChildren];\n  /*\n   * Resolve a `Type` for {@link Directive}.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}\n   */\n\n  var DirectiveResolver =\n  /** @class */\n  function () {\n    function DirectiveResolver(_reflector) {\n      this._reflector = _reflector;\n    }\n\n    DirectiveResolver.prototype.isDirective = function (type) {\n      var typeMetadata = this._reflector.annotations(util_1.resolveForwardRef(type));\n\n      return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    };\n\n    DirectiveResolver.prototype.resolve = function (type, throwIfNotFound) {\n      if (throwIfNotFound === void 0) {\n        throwIfNotFound = true;\n      }\n\n      var typeMetadata = this._reflector.annotations(util_1.resolveForwardRef(type));\n\n      if (typeMetadata) {\n        var metadata = findLast(typeMetadata, isDirectiveMetadata);\n\n        if (metadata) {\n          var propertyMetadata = this._reflector.propMetadata(type);\n\n          var guards = this._reflector.guards(type);\n\n          return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\n        }\n      }\n\n      if (throwIfNotFound) {\n        throw new Error(\"No Directive annotation found on \" + util_1.stringify(type));\n      }\n\n      return null;\n    };\n\n    DirectiveResolver.prototype._mergeWithPropertyMetadata = function (dm, propertyMetadata, guards, directiveType) {\n      var inputs = [];\n      var outputs = [];\n      var host = {};\n      var queries = {};\n      Object.keys(propertyMetadata).forEach(function (propName) {\n        var input = findLast(propertyMetadata[propName], function (a) {\n          return core_1.createInput.isTypeOf(a);\n        });\n\n        if (input) {\n          if (input.bindingPropertyName) {\n            inputs.push(propName + \": \" + input.bindingPropertyName);\n          } else {\n            inputs.push(propName);\n          }\n        }\n\n        var output = findLast(propertyMetadata[propName], function (a) {\n          return core_1.createOutput.isTypeOf(a);\n        });\n\n        if (output) {\n          if (output.bindingPropertyName) {\n            outputs.push(propName + \": \" + output.bindingPropertyName);\n          } else {\n            outputs.push(propName);\n          }\n        }\n\n        var hostBindings = propertyMetadata[propName].filter(function (a) {\n          return core_1.createHostBinding.isTypeOf(a);\n        });\n        hostBindings.forEach(function (hostBinding) {\n          if (hostBinding.hostPropertyName) {\n            var startWith = hostBinding.hostPropertyName[0];\n\n            if (startWith === '(') {\n              throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n            } else if (startWith === '[') {\n              throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n            }\n\n            host[\"[\" + hostBinding.hostPropertyName + \"]\"] = propName;\n          } else {\n            host[\"[\" + propName + \"]\"] = propName;\n          }\n        });\n        var hostListeners = propertyMetadata[propName].filter(function (a) {\n          return core_1.createHostListener.isTypeOf(a);\n        });\n        hostListeners.forEach(function (hostListener) {\n          var args = hostListener.args || [];\n          host[\"(\" + hostListener.eventName + \")\"] = propName + \"(\" + args.join(',') + \")\";\n        });\n        var query = findLast(propertyMetadata[propName], function (a) {\n          return QUERY_METADATA_IDENTIFIERS.some(function (i) {\n            return i.isTypeOf(a);\n          });\n        });\n\n        if (query) {\n          queries[propName] = query;\n        }\n      });\n      return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\n    };\n\n    DirectiveResolver.prototype._extractPublicName = function (def) {\n      return util_1.splitAtColon(def, [null, def])[1].trim();\n    };\n\n    DirectiveResolver.prototype._dedupeBindings = function (bindings) {\n      var names = new Set();\n      var publicNames = new Set();\n      var reversedResult = []; // go last to first to allow later entries to overwrite previous entries\n\n      for (var i = bindings.length - 1; i >= 0; i--) {\n        var binding = bindings[i];\n\n        var name_1 = this._extractPublicName(binding);\n\n        publicNames.add(name_1);\n\n        if (!names.has(name_1)) {\n          names.add(name_1);\n          reversedResult.push(binding);\n        }\n      }\n\n      return reversedResult.reverse();\n    };\n\n    DirectiveResolver.prototype._merge = function (directive, inputs, outputs, host, queries, guards, directiveType) {\n      var mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n\n      var mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n\n      var mergedHost = directive.host ? tslib_1.__assign(tslib_1.__assign({}, directive.host), host) : host;\n      var mergedQueries = directive.queries ? tslib_1.__assign(tslib_1.__assign({}, directive.queries), queries) : queries;\n\n      if (core_1.createComponent.isTypeOf(directive)) {\n        var comp = directive;\n        return core_1.createComponent({\n          selector: comp.selector,\n          inputs: mergedInputs,\n          outputs: mergedOutputs,\n          host: mergedHost,\n          exportAs: comp.exportAs,\n          moduleId: comp.moduleId,\n          queries: mergedQueries,\n          changeDetection: comp.changeDetection,\n          providers: comp.providers,\n          viewProviders: comp.viewProviders,\n          entryComponents: comp.entryComponents,\n          template: comp.template,\n          templateUrl: comp.templateUrl,\n          styles: comp.styles,\n          styleUrls: comp.styleUrls,\n          encapsulation: comp.encapsulation,\n          animations: comp.animations,\n          interpolation: comp.interpolation,\n          preserveWhitespaces: directive.preserveWhitespaces\n        });\n      } else {\n        return core_1.createDirective({\n          selector: directive.selector,\n          inputs: mergedInputs,\n          outputs: mergedOutputs,\n          host: mergedHost,\n          exportAs: directive.exportAs,\n          queries: mergedQueries,\n          providers: directive.providers,\n          guards: guards\n        });\n      }\n    };\n\n    return DirectiveResolver;\n  }();\n\n  exports.DirectiveResolver = DirectiveResolver;\n\n  function isDirectiveMetadata(type) {\n    return core_1.createDirective.isTypeOf(type) || core_1.createComponent.isTypeOf(type);\n  }\n\n  function findLast(arr, condition) {\n    for (var i = arr.length - 1; i >= 0; i--) {\n      if (condition(arr[i])) {\n        return arr[i];\n      }\n    }\n\n    return null;\n  }\n\n  exports.findLast = findLast;\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/directive_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileReflector} from './compile_reflector';\nimport {Component, createComponent, createContentChild, createContentChildren, createDirective, createHostBinding, createHostListener, createInput, createOutput, createViewChild, createViewChildren, Directive, Type} from './core';\nimport {resolveForwardRef, splitAtColon, stringify} from './util';\n\nconst QUERY_METADATA_IDENTIFIERS = [\n  createViewChild,\n  createViewChildren,\n  createContentChild,\n  createContentChildren,\n];\n\n/*\n * Resolve a `Type` for {@link Directive}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n */\nexport class DirectiveResolver {\n  constructor(private _reflector: CompileReflector) {}\n\n  isDirective(type: Type) {\n    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n    return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n  }\n\n  /**\n   * Return {@link Directive} for a given `Type`.\n   */\n  resolve(type: Type): Directive;\n  resolve(type: Type, throwIfNotFound: true): Directive;\n  resolve(type: Type, throwIfNotFound: boolean): Directive|null;\n  resolve(type: Type, throwIfNotFound = true): Directive|null {\n    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n    if (typeMetadata) {\n      const metadata = findLast(typeMetadata, isDirectiveMetadata);\n      if (metadata) {\n        const propertyMetadata = this._reflector.propMetadata(type);\n        const guards = this._reflector.guards(type);\n        return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\n      }\n    }\n\n    if (throwIfNotFound) {\n      throw new Error(`No Directive annotation found on ${stringify(type)}`);\n    }\n\n    return null;\n  }\n\n  private _mergeWithPropertyMetadata(\n      dm: Directive, propertyMetadata: {[key: string]: any[]}, guards: {[key: string]: any},\n      directiveType: Type): Directive {\n    const inputs: string[] = [];\n    const outputs: string[] = [];\n    const host: {[key: string]: string} = {};\n    const queries: {[key: string]: any} = {};\n    Object.keys(propertyMetadata).forEach((propName: string) => {\n      const input = findLast(propertyMetadata[propName], (a) => createInput.isTypeOf(a));\n      if (input) {\n        if (input.bindingPropertyName) {\n          inputs.push(`${propName}: ${input.bindingPropertyName}`);\n        } else {\n          inputs.push(propName);\n        }\n      }\n      const output = findLast(propertyMetadata[propName], (a) => createOutput.isTypeOf(a));\n      if (output) {\n        if (output.bindingPropertyName) {\n          outputs.push(`${propName}: ${output.bindingPropertyName}`);\n        } else {\n          outputs.push(propName);\n        }\n      }\n      const hostBindings = propertyMetadata[propName].filter(a => createHostBinding.isTypeOf(a));\n      hostBindings.forEach(hostBinding => {\n        if (hostBinding.hostPropertyName) {\n          const startWith = hostBinding.hostPropertyName[0];\n          if (startWith === '(') {\n            throw new Error(`@HostBinding can not bind to events. Use @HostListener instead.`);\n          } else if (startWith === '[') {\n            throw new Error(\n                `@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);\n          }\n          host[`[${hostBinding.hostPropertyName}]`] = propName;\n        } else {\n          host[`[${propName}]`] = propName;\n        }\n      });\n      const hostListeners = propertyMetadata[propName].filter(a => createHostListener.isTypeOf(a));\n      hostListeners.forEach(hostListener => {\n        const args = hostListener.args || [];\n        host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;\n      });\n      const query = findLast(\n          propertyMetadata[propName], (a) => QUERY_METADATA_IDENTIFIERS.some(i => i.isTypeOf(a)));\n      if (query) {\n        queries[propName] = query;\n      }\n    });\n    return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\n  }\n\n  private _extractPublicName(def: string) {\n    return splitAtColon(def, [null!, def])[1].trim();\n  }\n\n  private _dedupeBindings(bindings: string[]): string[] {\n    const names = new Set<string>();\n    const publicNames = new Set<string>();\n    const reversedResult: string[] = [];\n    // go last to first to allow later entries to overwrite previous entries\n    for (let i = bindings.length - 1; i >= 0; i--) {\n      const binding = bindings[i];\n      const name = this._extractPublicName(binding);\n      publicNames.add(name);\n      if (!names.has(name)) {\n        names.add(name);\n        reversedResult.push(binding);\n      }\n    }\n    return reversedResult.reverse();\n  }\n\n  private _merge(\n      directive: Directive, inputs: string[], outputs: string[], host: {[key: string]: string},\n      queries: {[key: string]: any}, guards: {[key: string]: any}, directiveType: Type): Directive {\n    const mergedInputs =\n        this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n    const mergedOutputs =\n        this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n    const mergedHost = directive.host ? {...directive.host, ...host} : host;\n    const mergedQueries = directive.queries ? {...directive.queries, ...queries} : queries;\n    if (createComponent.isTypeOf(directive)) {\n      const comp = directive as Component;\n      return createComponent({\n        selector: comp.selector,\n        inputs: mergedInputs,\n        outputs: mergedOutputs,\n        host: mergedHost,\n        exportAs: comp.exportAs,\n        moduleId: comp.moduleId,\n        queries: mergedQueries,\n        changeDetection: comp.changeDetection,\n        providers: comp.providers,\n        viewProviders: comp.viewProviders,\n        entryComponents: comp.entryComponents,\n        template: comp.template,\n        templateUrl: comp.templateUrl,\n        styles: comp.styles,\n        styleUrls: comp.styleUrls,\n        encapsulation: comp.encapsulation,\n        animations: comp.animations,\n        interpolation: comp.interpolation,\n        preserveWhitespaces: directive.preserveWhitespaces,\n      });\n    } else {\n      return createDirective({\n        selector: directive.selector,\n        inputs: mergedInputs,\n        outputs: mergedOutputs,\n        host: mergedHost,\n        exportAs: directive.exportAs,\n        queries: mergedQueries,\n        providers: directive.providers,\n        guards\n      });\n    }\n  }\n}\n\nfunction isDirectiveMetadata(type: any): type is Directive {\n  return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\n}\n\nexport function findLast<T>(arr: T[], condition: (value: T) => boolean): T|null {\n  for (let i = arr.length - 1; i >= 0; i--) {\n    if (condition(arr[i])) {\n      return arr[i];\n    }\n  }\n  return null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}