{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar chownr = util.promisify(require('chownr'));\n\nvar mkdirp = require('mkdirp');\n\nvar inflight = require('promise-inflight');\n\nvar inferOwner = require('infer-owner'); // Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\n\n\nvar self = {\n  uid: null,\n  gid: null\n};\n\nvar getSelf = function getSelf() {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid();\n    var setuid = process.setuid;\n\n    process.setuid = function (uid) {\n      self.uid = null;\n      process.setuid = setuid;\n      return process.setuid(uid);\n    };\n  }\n\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid();\n    var setgid = process.setgid;\n\n    process.setgid = function (gid) {\n      self.gid = null;\n      process.setgid = setgid;\n      return process.setgid(gid);\n    };\n  }\n};\n\nmodule.exports.chownr = fixOwner;\n\nfunction fixOwner(cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return Promise.resolve();\n  }\n\n  getSelf();\n\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return Promise.resolve();\n  }\n\n  return Promise.resolve(inferOwner(cache)).then(function (owner) {\n    var uid = owner.uid,\n        gid = owner.gid; // No need to override if it's already what we used.\n\n    if (self.uid === uid && self.gid === gid) {\n      return;\n    }\n\n    return inflight('fixOwner: fixing ownership on ' + filepath, function () {\n      return chownr(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid).catch(function (err) {\n        if (err.code === 'ENOENT') {\n          return null;\n        }\n\n        throw err;\n      });\n    });\n  });\n}\n\nmodule.exports.chownr.sync = fixOwnerSync;\n\nfunction fixOwnerSync(cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return;\n  }\n\n  var _inferOwner$sync = inferOwner.sync(cache),\n      uid = _inferOwner$sync.uid,\n      gid = _inferOwner$sync.gid;\n\n  getSelf();\n\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return;\n  }\n\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return;\n  }\n\n  try {\n    chownr.sync(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid);\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT') {\n      return null;\n    }\n\n    throw err;\n  }\n}\n\nmodule.exports.mkdirfix = mkdirfix;\n\nfunction mkdirfix(cache, p, cb) {\n  // we have to infer the owner _before_ making the directory, even though\n  // we aren't going to use the results, since the cache itself might not\n  // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n  // to be correct if it creates the cache folder in the process.\n  return Promise.resolve(inferOwner(cache)).then(function () {\n    return mkdirp(p).then(function (made) {\n      if (made) {\n        return fixOwner(cache, made).then(function () {\n          return made;\n        });\n      }\n    }).catch(function (err) {\n      if (err.code === 'EEXIST') {\n        return fixOwner(cache, p).then(function () {\n          return null;\n        });\n      }\n\n      throw err;\n    });\n  });\n}\n\nmodule.exports.mkdirfix.sync = mkdirfixSync;\n\nfunction mkdirfixSync(cache, p) {\n  try {\n    inferOwner.sync(cache);\n    var made = mkdirp.sync(p);\n\n    if (made) {\n      fixOwnerSync(cache, made);\n      return made;\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p);\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/cacache/lib/util/fix-owner.js"],"names":["util","require","chownr","promisify","mkdirp","inflight","inferOwner","self","uid","gid","getSelf","process","getuid","setuid","getgid","setgid","module","exports","fixOwner","cache","filepath","Promise","resolve","then","owner","catch","err","code","sync","fixOwnerSync","mkdirfix","p","cb","made","mkdirfixSync"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst chownr = util.promisify(require('chownr'))\nconst mkdirp = require('mkdirp')\nconst inflight = require('promise-inflight')\nconst inferOwner = require('infer-owner')\n\n// Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\nconst self = { uid: null, gid: null }\nconst getSelf = () => {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid()\n    const setuid = process.setuid\n    process.setuid = (uid) => {\n      self.uid = null\n      process.setuid = setuid\n      return process.setuid(uid)\n    }\n  }\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid()\n    const setgid = process.setgid\n    process.setgid = (gid) => {\n      self.gid = null\n      process.setgid = setgid\n      return process.setgid(gid)\n    }\n  }\n}\n\nmodule.exports.chownr = fixOwner\n\nfunction fixOwner (cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return Promise.resolve()\n  }\n\n  getSelf()\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return Promise.resolve()\n  }\n\n  return Promise.resolve(inferOwner(cache)).then((owner) => {\n    const { uid, gid } = owner\n\n    // No need to override if it's already what we used.\n    if (self.uid === uid && self.gid === gid) {\n      return\n    }\n\n    return inflight('fixOwner: fixing ownership on ' + filepath, () =>\n      chownr(\n        filepath,\n        typeof uid === 'number' ? uid : self.uid,\n        typeof gid === 'number' ? gid : self.gid\n      ).catch((err) => {\n        if (err.code === 'ENOENT') {\n          return null\n        }\n        throw err\n      })\n    )\n  })\n}\n\nmodule.exports.chownr.sync = fixOwnerSync\n\nfunction fixOwnerSync (cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return\n  }\n  const { uid, gid } = inferOwner.sync(cache)\n  getSelf()\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return\n  }\n\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return\n  }\n  try {\n    chownr.sync(\n      filepath,\n      typeof uid === 'number' ? uid : self.uid,\n      typeof gid === 'number' ? gid : self.gid\n    )\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT') {\n      return null\n    }\n    throw err\n  }\n}\n\nmodule.exports.mkdirfix = mkdirfix\n\nfunction mkdirfix (cache, p, cb) {\n  // we have to infer the owner _before_ making the directory, even though\n  // we aren't going to use the results, since the cache itself might not\n  // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n  // to be correct if it creates the cache folder in the process.\n  return Promise.resolve(inferOwner(cache)).then(() => {\n    return mkdirp(p)\n      .then((made) => {\n        if (made) {\n          return fixOwner(cache, made).then(() => made)\n        }\n      })\n      .catch((err) => {\n        if (err.code === 'EEXIST') {\n          return fixOwner(cache, p).then(() => null)\n        }\n        throw err\n      })\n  })\n}\n\nmodule.exports.mkdirfix.sync = mkdirfixSync\n\nfunction mkdirfixSync (cache, p) {\n  try {\n    inferOwner.sync(cache)\n    const made = mkdirp.sync(p)\n    if (made) {\n      fixOwnerSync(cache, made)\n      return made\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p)\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}