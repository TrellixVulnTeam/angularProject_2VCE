{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/inline_resources\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/metadata/index\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getInlineResourcesTransformFactory = exports.InlineResourcesMetadataTransformer = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var index_1 = require(\"@angular/compiler-cli/src/metadata/index\");\n\n  var PRECONDITIONS_TEXT = 'angularCompilerOptions.enableResourceInlining requires all resources to be statically resolvable.';\n\n  function getResourceLoader(host, containingFileName) {\n    return {\n      get: function get(url) {\n        if (typeof url !== 'string') {\n          throw new Error('templateUrl and stylesUrl must be string literals. ' + PRECONDITIONS_TEXT);\n        }\n\n        var fileName = host.resourceNameToFileName(url, containingFileName);\n\n        if (fileName) {\n          var content = host.loadResource(fileName);\n\n          if (typeof content !== 'string') {\n            throw new Error('Cannot handle async resource. ' + PRECONDITIONS_TEXT);\n          }\n\n          return content;\n        }\n\n        throw new Error(\"Failed to resolve \" + url + \" from \" + containingFileName + \". \" + PRECONDITIONS_TEXT);\n      }\n    };\n  }\n\n  var InlineResourcesMetadataTransformer =\n  /** @class */\n  function () {\n    function InlineResourcesMetadataTransformer(host) {\n      this.host = host;\n    }\n\n    InlineResourcesMetadataTransformer.prototype.start = function (sourceFile) {\n      var _this = this;\n\n      var loader = getResourceLoader(this.host, sourceFile.fileName);\n      return function (value, node) {\n        if (index_1.isClassMetadata(value) && ts.isClassDeclaration(node) && value.decorators) {\n          value.decorators.forEach(function (d) {\n            if (index_1.isMetadataSymbolicCallExpression(d) && index_1.isMetadataImportedSymbolReferenceExpression(d.expression) && d.expression.module === '@angular/core' && d.expression.name === 'Component' && d.arguments) {\n              // Arguments to an @Component that was compiled successfully are always\n              // MetadataObject(s).\n              d.arguments = d.arguments.map(_this.updateDecoratorMetadata.bind(_this, loader));\n            }\n          });\n        }\n\n        return value;\n      };\n    };\n\n    InlineResourcesMetadataTransformer.prototype.updateDecoratorMetadata = function (loader, arg) {\n      if (arg['templateUrl']) {\n        arg['template'] = loader.get(arg['templateUrl']);\n        delete arg['templateUrl'];\n      }\n\n      var styles = arg['styles'] || [];\n      var styleUrls = arg['styleUrls'] || [];\n      if (!Array.isArray(styles)) throw new Error('styles should be an array');\n      if (!Array.isArray(styleUrls)) throw new Error('styleUrls should be an array');\n      styles.push.apply(styles, tslib_1.__spread(styleUrls.map(function (styleUrl) {\n        return loader.get(styleUrl);\n      })));\n\n      if (styles.length > 0) {\n        arg['styles'] = styles;\n        delete arg['styleUrls'];\n      }\n\n      return arg;\n    };\n\n    return InlineResourcesMetadataTransformer;\n  }();\n\n  exports.InlineResourcesMetadataTransformer = InlineResourcesMetadataTransformer;\n\n  function getInlineResourcesTransformFactory(program, host) {\n    return function (context) {\n      return function (sourceFile) {\n        var loader = getResourceLoader(host, sourceFile.fileName);\n\n        var visitor = function visitor(node) {\n          // Components are always classes; skip any other node\n          if (!ts.isClassDeclaration(node)) {\n            return node;\n          } // Decorator case - before or without decorator downleveling\n          // @Component()\n\n\n          var newDecorators = ts.visitNodes(node.decorators, function (node) {\n            if (ts.isDecorator(node) && isComponentDecorator(node, program.getTypeChecker())) {\n              return updateDecorator(node, loader);\n            }\n\n            return node;\n          }); // Annotation case - after decorator downleveling\n          // static decorators: {type: Function, args?: any[]}[]\n\n          var newMembers = ts.visitNodes(node.members, function (node) {\n            if (ts.isClassElement(node)) {\n              return updateAnnotations(node, loader, program.getTypeChecker());\n            } else {\n              return node;\n            }\n          }); // Create a new AST subtree with our modifications\n\n          return ts.updateClassDeclaration(node, newDecorators, node.modifiers, node.name, node.typeParameters, node.heritageClauses || [], newMembers);\n        };\n\n        return ts.visitEachChild(sourceFile, visitor, context);\n      };\n    };\n  }\n\n  exports.getInlineResourcesTransformFactory = getInlineResourcesTransformFactory;\n  /**\n   * Update a Decorator AST node to inline the resources\n   * @param node the @Component decorator\n   * @param loader provides access to load resources\n   */\n\n  function updateDecorator(node, loader) {\n    if (!ts.isCallExpression(node.expression)) {\n      // User will get an error somewhere else with bare @Component\n      return node;\n    }\n\n    var expr = node.expression;\n    var newArguments = updateComponentProperties(expr.arguments, loader);\n    return ts.updateDecorator(node, ts.updateCall(expr, expr.expression, expr.typeArguments, newArguments));\n  }\n  /**\n   * Update an Annotations AST node to inline the resources\n   * @param node the static decorators property\n   * @param loader provides access to load resources\n   * @param typeChecker provides access to symbol table\n   */\n\n\n  function updateAnnotations(node, loader, typeChecker) {\n    // Looking for a member of this shape:\n    // PropertyDeclaration called decorators, with static modifier\n    // Initializer is ArrayLiteralExpression\n    // One element is the Component type, its initializer is the @angular/core Component symbol\n    // One element is the component args, its initializer is the Component arguments to change\n    // e.g.\n    //   static decorators: {type: Function, args?: any[]}[] =\n    //   [{\n    //     type: Component,\n    //     args: [{\n    //       templateUrl: './my.component.html',\n    //       styleUrls: ['./my.component.css'],\n    //     }],\n    //   }];\n    if (!ts.isPropertyDeclaration(node) || // ts.ModifierFlags.Static &&\n    !ts.isIdentifier(node.name) || node.name.text !== 'decorators' || !node.initializer || !ts.isArrayLiteralExpression(node.initializer)) {\n      return node;\n    }\n\n    var newAnnotations = node.initializer.elements.map(function (annotation) {\n      // No-op if there's a non-object-literal mixed in the decorators values\n      if (!ts.isObjectLiteralExpression(annotation)) return annotation;\n      var decoratorType = annotation.properties.find(function (p) {\n        return isIdentifierNamed(p, 'type');\n      }); // No-op if there's no 'type' property, or if it's not initialized to the Component symbol\n\n      if (!decoratorType || !ts.isPropertyAssignment(decoratorType) || !ts.isIdentifier(decoratorType.initializer) || !isComponentSymbol(decoratorType.initializer, typeChecker)) {\n        return annotation;\n      }\n\n      var newAnnotation = annotation.properties.map(function (prop) {\n        // No-op if this isn't the 'args' property or if it's not initialized to an array\n        if (!isIdentifierNamed(prop, 'args') || !ts.isPropertyAssignment(prop) || !ts.isArrayLiteralExpression(prop.initializer)) return prop;\n        var newDecoratorArgs = ts.updatePropertyAssignment(prop, prop.name, ts.createArrayLiteral(updateComponentProperties(prop.initializer.elements, loader)));\n        return newDecoratorArgs;\n      });\n      return ts.updateObjectLiteral(annotation, newAnnotation);\n    });\n    return ts.updateProperty(node, node.decorators, node.modifiers, node.name, node.questionToken, node.type, ts.updateArrayLiteral(node.initializer, newAnnotations));\n  }\n\n  function isIdentifierNamed(p, name) {\n    return !!p.name && ts.isIdentifier(p.name) && p.name.text === name;\n  }\n  /**\n   * Check that the node we are visiting is the actual Component decorator defined in @angular/core.\n   */\n\n\n  function isComponentDecorator(node, typeChecker) {\n    if (!ts.isCallExpression(node.expression)) {\n      return false;\n    }\n\n    var callExpr = node.expression;\n    var identifier;\n\n    if (ts.isIdentifier(callExpr.expression)) {\n      identifier = callExpr.expression;\n    } else {\n      return false;\n    }\n\n    return isComponentSymbol(identifier, typeChecker);\n  }\n\n  function isComponentSymbol(identifier, typeChecker) {\n    // Only handle identifiers, not expressions\n    if (!ts.isIdentifier(identifier)) return false; // NOTE: resolver.getReferencedImportDeclaration would work as well but is internal\n\n    var symbol = typeChecker.getSymbolAtLocation(identifier);\n\n    if (!symbol || !symbol.declarations || !symbol.declarations.length) {\n      console.error(\"Unable to resolve symbol '\" + identifier.text + \"' in the program, does it type-check?\");\n      return false;\n    }\n\n    var declaration = symbol.declarations[0];\n\n    if (!declaration || !ts.isImportSpecifier(declaration)) {\n      return false;\n    }\n\n    var name = (declaration.propertyName || declaration.name).text; // We know that parent pointers are set because we created the SourceFile ourselves.\n    // The number of parent references here match the recursion depth at this point.\n\n    var moduleId = declaration.parent.parent.parent.moduleSpecifier.text;\n    return moduleId === '@angular/core' && name === 'Component';\n  }\n  /**\n   * For each property in the object literal, if it's templateUrl or styleUrls, replace it\n   * with content.\n   * @param node the arguments to @Component() or args property of decorators: [{type:Component}]\n   * @param loader provides access to the loadResource method of the host\n   * @returns updated arguments\n   */\n\n\n  function updateComponentProperties(args, loader) {\n    if (args.length !== 1) {\n      // User should have gotten a type-check error because @Component takes one argument\n      return args;\n    }\n\n    var componentArg = args[0];\n\n    if (!ts.isObjectLiteralExpression(componentArg)) {\n      // User should have gotten a type-check error because @Component takes an object literal\n      // argument\n      return args;\n    }\n\n    var newProperties = [];\n    var newStyleExprs = [];\n    componentArg.properties.forEach(function (prop) {\n      if (!ts.isPropertyAssignment(prop) || ts.isComputedPropertyName(prop.name)) {\n        newProperties.push(prop);\n        return;\n      }\n\n      switch (prop.name.text) {\n        case 'styles':\n          if (!ts.isArrayLiteralExpression(prop.initializer)) {\n            throw new Error('styles takes an array argument');\n          }\n\n          newStyleExprs.push.apply(newStyleExprs, tslib_1.__spread(prop.initializer.elements));\n          break;\n\n        case 'styleUrls':\n          if (!ts.isArrayLiteralExpression(prop.initializer)) {\n            throw new Error('styleUrls takes an array argument');\n          }\n\n          newStyleExprs.push.apply(newStyleExprs, tslib_1.__spread(prop.initializer.elements.map(function (expr) {\n            if (!ts.isStringLiteral(expr) && !ts.isNoSubstitutionTemplateLiteral(expr)) {\n              throw new Error('Can only accept string literal arguments to styleUrls. ' + PRECONDITIONS_TEXT);\n            }\n\n            var styles = loader.get(expr.text);\n            return ts.createLiteral(styles);\n          })));\n          break;\n\n        case 'templateUrl':\n          if (!ts.isStringLiteral(prop.initializer) && !ts.isNoSubstitutionTemplateLiteral(prop.initializer)) {\n            throw new Error('Can only accept a string literal argument to templateUrl. ' + PRECONDITIONS_TEXT);\n          }\n\n          var template = loader.get(prop.initializer.text);\n          newProperties.push(ts.updatePropertyAssignment(prop, ts.createIdentifier('template'), ts.createLiteral(template)));\n          break;\n\n        default:\n          newProperties.push(prop);\n      }\n    }); // Add the non-inline styles\n\n    if (newStyleExprs.length > 0) {\n      var newStyles = ts.createPropertyAssignment(ts.createIdentifier('styles'), ts.createArrayLiteral(newStyleExprs));\n      newProperties.push(newStyles);\n    }\n\n    return ts.createNodeArray([ts.updateObjectLiteral(componentArg, newProperties)]);\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/inline_resources.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {isClassMetadata, isMetadataImportedSymbolReferenceExpression, isMetadataSymbolicCallExpression, MetadataObject, MetadataValue} from '../metadata/index';\n\nimport {MetadataTransformer, ValueTransform} from './metadata_cache';\n\nconst PRECONDITIONS_TEXT =\n    'angularCompilerOptions.enableResourceInlining requires all resources to be statically resolvable.';\n\n/** A subset of members from AotCompilerHost */\nexport type ResourcesHost = {\n  resourceNameToFileName(resourceName: string, containingFileName: string): string|null;\n  loadResource(path: string): Promise<string>| string;\n};\n\nexport type StaticResourceLoader = {\n  get(url: string|MetadataValue): string;\n};\n\nfunction getResourceLoader(host: ResourcesHost, containingFileName: string): StaticResourceLoader {\n  return {\n    get(url: string|MetadataValue): string {\n      if (typeof url !== 'string') {\n        throw new Error('templateUrl and stylesUrl must be string literals. ' + PRECONDITIONS_TEXT);\n      }\n      const fileName = host.resourceNameToFileName(url, containingFileName);\n      if (fileName) {\n        const content = host.loadResource(fileName);\n        if (typeof content !== 'string') {\n          throw new Error('Cannot handle async resource. ' + PRECONDITIONS_TEXT);\n        }\n        return content;\n      }\n      throw new Error(`Failed to resolve ${url} from ${containingFileName}. ${PRECONDITIONS_TEXT}`);\n    }\n  };\n}\n\nexport class InlineResourcesMetadataTransformer implements MetadataTransformer {\n  constructor(private host: ResourcesHost) {}\n\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n    const loader = getResourceLoader(this.host, sourceFile.fileName);\n    return (value: MetadataValue, node: ts.Node): MetadataValue => {\n      if (isClassMetadata(value) && ts.isClassDeclaration(node) && value.decorators) {\n        value.decorators.forEach(d => {\n          if (isMetadataSymbolicCallExpression(d) &&\n              isMetadataImportedSymbolReferenceExpression(d.expression) &&\n              d.expression.module === '@angular/core' && d.expression.name === 'Component' &&\n              d.arguments) {\n            // Arguments to an @Component that was compiled successfully are always\n            // MetadataObject(s).\n            d.arguments = (d.arguments as MetadataObject[])\n                              .map(this.updateDecoratorMetadata.bind(this, loader));\n          }\n        });\n      }\n      return value;\n    };\n  }\n\n  updateDecoratorMetadata(loader: StaticResourceLoader, arg: MetadataObject): MetadataObject {\n    if (arg['templateUrl']) {\n      arg['template'] = loader.get(arg['templateUrl']);\n      delete arg['templateUrl'];\n    }\n\n    const styles = arg['styles'] || [];\n    const styleUrls = arg['styleUrls'] || [];\n    if (!Array.isArray(styles)) throw new Error('styles should be an array');\n    if (!Array.isArray(styleUrls)) throw new Error('styleUrls should be an array');\n\n    styles.push(...styleUrls.map(styleUrl => loader.get(styleUrl)));\n    if (styles.length > 0) {\n      arg['styles'] = styles;\n      delete arg['styleUrls'];\n    }\n\n    return arg;\n  }\n}\n\nexport function getInlineResourcesTransformFactory(\n    program: ts.Program, host: ResourcesHost): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile) => {\n    const loader = getResourceLoader(host, sourceFile.fileName);\n    const visitor: ts.Visitor = node => {\n      // Components are always classes; skip any other node\n      if (!ts.isClassDeclaration(node)) {\n        return node;\n      }\n\n      // Decorator case - before or without decorator downleveling\n      // @Component()\n      const newDecorators = ts.visitNodes(node.decorators, (node: ts.Node) => {\n        if (ts.isDecorator(node) && isComponentDecorator(node, program.getTypeChecker())) {\n          return updateDecorator(node, loader);\n        }\n        return node;\n      });\n\n      // Annotation case - after decorator downleveling\n      // static decorators: {type: Function, args?: any[]}[]\n      const newMembers = ts.visitNodes(node.members, (node: ts.Node) => {\n        if (ts.isClassElement(node)) {\n          return updateAnnotations(node, loader, program.getTypeChecker());\n        } else {\n          return node;\n        }\n      });\n\n      // Create a new AST subtree with our modifications\n      return ts.updateClassDeclaration(\n          node, newDecorators, node.modifiers, node.name, node.typeParameters,\n          node.heritageClauses || [], newMembers);\n    };\n\n    return ts.visitEachChild(sourceFile, visitor, context);\n  };\n}\n\n/**\n * Update a Decorator AST node to inline the resources\n * @param node the @Component decorator\n * @param loader provides access to load resources\n */\nfunction updateDecorator(node: ts.Decorator, loader: StaticResourceLoader): ts.Decorator {\n  if (!ts.isCallExpression(node.expression)) {\n    // User will get an error somewhere else with bare @Component\n    return node;\n  }\n  const expr = node.expression;\n  const newArguments = updateComponentProperties(expr.arguments, loader);\n  return ts.updateDecorator(\n      node, ts.updateCall(expr, expr.expression, expr.typeArguments, newArguments));\n}\n\n/**\n * Update an Annotations AST node to inline the resources\n * @param node the static decorators property\n * @param loader provides access to load resources\n * @param typeChecker provides access to symbol table\n */\nfunction updateAnnotations(\n    node: ts.ClassElement, loader: StaticResourceLoader,\n    typeChecker: ts.TypeChecker): ts.ClassElement {\n  // Looking for a member of this shape:\n  // PropertyDeclaration called decorators, with static modifier\n  // Initializer is ArrayLiteralExpression\n  // One element is the Component type, its initializer is the @angular/core Component symbol\n  // One element is the component args, its initializer is the Component arguments to change\n  // e.g.\n  //   static decorators: {type: Function, args?: any[]}[] =\n  //   [{\n  //     type: Component,\n  //     args: [{\n  //       templateUrl: './my.component.html',\n  //       styleUrls: ['./my.component.css'],\n  //     }],\n  //   }];\n  if (!ts.isPropertyDeclaration(node) ||  // ts.ModifierFlags.Static &&\n      !ts.isIdentifier(node.name) || node.name.text !== 'decorators' || !node.initializer ||\n      !ts.isArrayLiteralExpression(node.initializer)) {\n    return node;\n  }\n\n  const newAnnotations = node.initializer.elements.map(annotation => {\n    // No-op if there's a non-object-literal mixed in the decorators values\n    if (!ts.isObjectLiteralExpression(annotation)) return annotation;\n\n    const decoratorType = annotation.properties.find(p => isIdentifierNamed(p, 'type'));\n\n    // No-op if there's no 'type' property, or if it's not initialized to the Component symbol\n    if (!decoratorType || !ts.isPropertyAssignment(decoratorType) ||\n        !ts.isIdentifier(decoratorType.initializer) ||\n        !isComponentSymbol(decoratorType.initializer, typeChecker)) {\n      return annotation;\n    }\n\n    const newAnnotation = annotation.properties.map(prop => {\n      // No-op if this isn't the 'args' property or if it's not initialized to an array\n      if (!isIdentifierNamed(prop, 'args') || !ts.isPropertyAssignment(prop) ||\n          !ts.isArrayLiteralExpression(prop.initializer))\n        return prop;\n\n      const newDecoratorArgs = ts.updatePropertyAssignment(\n          prop, prop.name,\n          ts.createArrayLiteral(updateComponentProperties(prop.initializer.elements, loader)));\n\n      return newDecoratorArgs;\n    });\n\n    return ts.updateObjectLiteral(annotation, newAnnotation);\n  });\n\n  return ts.updateProperty(\n      node, node.decorators, node.modifiers, node.name, node.questionToken, node.type,\n      ts.updateArrayLiteral(node.initializer, newAnnotations));\n}\n\nfunction isIdentifierNamed(p: ts.ObjectLiteralElementLike, name: string): boolean {\n  return !!p.name && ts.isIdentifier(p.name) && p.name.text === name;\n}\n\n/**\n * Check that the node we are visiting is the actual Component decorator defined in @angular/core.\n */\nfunction isComponentDecorator(node: ts.Decorator, typeChecker: ts.TypeChecker): boolean {\n  if (!ts.isCallExpression(node.expression)) {\n    return false;\n  }\n  const callExpr = node.expression;\n\n  let identifier: ts.Node;\n\n  if (ts.isIdentifier(callExpr.expression)) {\n    identifier = callExpr.expression;\n  } else {\n    return false;\n  }\n  return isComponentSymbol(identifier, typeChecker);\n}\n\nfunction isComponentSymbol(identifier: ts.Node, typeChecker: ts.TypeChecker) {\n  // Only handle identifiers, not expressions\n  if (!ts.isIdentifier(identifier)) return false;\n\n  // NOTE: resolver.getReferencedImportDeclaration would work as well but is internal\n  const symbol = typeChecker.getSymbolAtLocation(identifier);\n\n  if (!symbol || !symbol.declarations || !symbol.declarations.length) {\n    console.error(\n        `Unable to resolve symbol '${identifier.text}' in the program, does it type-check?`);\n    return false;\n  }\n\n  const declaration = symbol.declarations[0];\n\n  if (!declaration || !ts.isImportSpecifier(declaration)) {\n    return false;\n  }\n\n  const name = (declaration.propertyName || declaration.name).text;\n  // We know that parent pointers are set because we created the SourceFile ourselves.\n  // The number of parent references here match the recursion depth at this point.\n  const moduleId = (declaration.parent!.parent!.parent!.moduleSpecifier as ts.StringLiteral).text;\n  return moduleId === '@angular/core' && name === 'Component';\n}\n\n/**\n * For each property in the object literal, if it's templateUrl or styleUrls, replace it\n * with content.\n * @param node the arguments to @Component() or args property of decorators: [{type:Component}]\n * @param loader provides access to the loadResource method of the host\n * @returns updated arguments\n */\nfunction updateComponentProperties(\n    args: ts.NodeArray<ts.Expression>, loader: StaticResourceLoader): ts.NodeArray<ts.Expression> {\n  if (args.length !== 1) {\n    // User should have gotten a type-check error because @Component takes one argument\n    return args;\n  }\n  const componentArg = args[0];\n  if (!ts.isObjectLiteralExpression(componentArg)) {\n    // User should have gotten a type-check error because @Component takes an object literal\n    // argument\n    return args;\n  }\n\n  const newProperties: ts.ObjectLiteralElementLike[] = [];\n  const newStyleExprs: ts.Expression[] = [];\n  componentArg.properties.forEach(prop => {\n    if (!ts.isPropertyAssignment(prop) || ts.isComputedPropertyName(prop.name)) {\n      newProperties.push(prop);\n      return;\n    }\n\n    switch (prop.name.text) {\n      case 'styles':\n        if (!ts.isArrayLiteralExpression(prop.initializer)) {\n          throw new Error('styles takes an array argument');\n        }\n        newStyleExprs.push(...prop.initializer.elements);\n        break;\n\n      case 'styleUrls':\n        if (!ts.isArrayLiteralExpression(prop.initializer)) {\n          throw new Error('styleUrls takes an array argument');\n        }\n        newStyleExprs.push(...prop.initializer.elements.map((expr: ts.Expression) => {\n          if (!ts.isStringLiteral(expr) && !ts.isNoSubstitutionTemplateLiteral(expr)) {\n            throw new Error(\n                'Can only accept string literal arguments to styleUrls. ' + PRECONDITIONS_TEXT);\n          }\n          const styles = loader.get(expr.text);\n          return ts.createLiteral(styles);\n        }));\n        break;\n\n      case 'templateUrl':\n        if (!ts.isStringLiteral(prop.initializer) &&\n            !ts.isNoSubstitutionTemplateLiteral(prop.initializer)) {\n          throw new Error(\n              'Can only accept a string literal argument to templateUrl. ' + PRECONDITIONS_TEXT);\n        }\n        const template = loader.get(prop.initializer.text);\n        newProperties.push(ts.updatePropertyAssignment(\n            prop, ts.createIdentifier('template'), ts.createLiteral(template)));\n        break;\n\n      default:\n        newProperties.push(prop);\n    }\n  });\n\n  // Add the non-inline styles\n  if (newStyleExprs.length > 0) {\n    const newStyles = ts.createPropertyAssignment(\n        ts.createIdentifier('styles'), ts.createArrayLiteral(newStyleExprs));\n    newProperties.push(newStyles);\n  }\n\n  return ts.createNodeArray([ts.updateObjectLiteral(componentArg, newProperties)]);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}