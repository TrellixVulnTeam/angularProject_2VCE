{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/metadata_reader\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/metadata/index\", \"@angular/compiler-cli/src/transformers/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.readMetadata = exports.createMetadataReaderCache = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/metadata/index\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/transformers/util\");\n\n  function createMetadataReaderCache() {\n    var data = new Map();\n    return {\n      data: data\n    };\n  }\n\n  exports.createMetadataReaderCache = createMetadataReaderCache;\n\n  function readMetadata(filePath, host, cache) {\n    var metadatas = cache && cache.data.get(filePath);\n\n    if (metadatas) {\n      return metadatas;\n    }\n\n    if (host.fileExists(filePath)) {\n      // If the file doesn't exists then we cannot return metadata for the file.\n      // This will occur if the user referenced a declared module for which no file\n      // exists for the module (i.e. jQuery or angularjs).\n      if (util_1.DTS.test(filePath)) {\n        metadatas = readMetadataFile(host, filePath);\n\n        if (!metadatas) {\n          // If there is a .d.ts file but no metadata file we need to produce a\n          // metadata from the .d.ts file as metadata files capture reexports\n          // (starting with v3).\n          metadatas = [upgradeMetadataWithDtsData(host, {\n            '__symbolic': 'module',\n            'version': 1,\n            'metadata': {}\n          }, filePath)];\n        }\n      } else {\n        var metadata = host.getSourceFileMetadata(filePath);\n        metadatas = metadata ? [metadata] : [];\n      }\n    }\n\n    if (cache && (!host.cacheMetadata || host.cacheMetadata(filePath))) {\n      cache.data.set(filePath, metadatas);\n    }\n\n    return metadatas;\n  }\n\n  exports.readMetadata = readMetadata;\n\n  function readMetadataFile(host, dtsFilePath) {\n    var metadataPath = dtsFilePath.replace(util_1.DTS, '.metadata.json');\n\n    if (!host.fileExists(metadataPath)) {\n      return undefined;\n    }\n\n    try {\n      var metadataOrMetadatas = JSON.parse(host.readFile(metadataPath));\n      var metadatas = metadataOrMetadatas ? Array.isArray(metadataOrMetadatas) ? metadataOrMetadatas : [metadataOrMetadatas] : [];\n\n      if (metadatas.length) {\n        var maxMetadata = metadatas.reduce(function (p, c) {\n          return p.version > c.version ? p : c;\n        });\n\n        if (maxMetadata.version < metadata_1.METADATA_VERSION) {\n          metadatas.push(upgradeMetadataWithDtsData(host, maxMetadata, dtsFilePath));\n        }\n      }\n\n      return metadatas;\n    } catch (e) {\n      console.error(\"Failed to read JSON file \" + metadataPath);\n      throw e;\n    }\n  }\n\n  function upgradeMetadataWithDtsData(host, oldMetadata, dtsFilePath) {\n    // patch v1 to v3 by adding exports and the `extends` clause.\n    // patch v3 to v4 by adding `interface` symbols for TypeAlias\n    var newMetadata = {\n      '__symbolic': 'module',\n      'version': metadata_1.METADATA_VERSION,\n      'metadata': tslib_1.__assign({}, oldMetadata.metadata)\n    };\n\n    if (oldMetadata.exports) {\n      newMetadata.exports = oldMetadata.exports;\n    }\n\n    if (oldMetadata.importAs) {\n      newMetadata.importAs = oldMetadata.importAs;\n    }\n\n    if (oldMetadata.origins) {\n      newMetadata.origins = oldMetadata.origins;\n    }\n\n    var dtsMetadata = host.getSourceFileMetadata(dtsFilePath);\n\n    if (dtsMetadata) {\n      for (var prop in dtsMetadata.metadata) {\n        if (!newMetadata.metadata[prop]) {\n          newMetadata.metadata[prop] = dtsMetadata.metadata[prop];\n        }\n      }\n\n      if (dtsMetadata['importAs']) newMetadata['importAs'] = dtsMetadata['importAs']; // Only copy exports from exports from metadata prior to version 3.\n      // Starting with version 3 the collector began collecting exports and\n      // this should be redundant. Also, with bundler will rewrite the exports\n      // which will hoist the exports from modules referenced indirectly causing\n      // the imports to be different than the .d.ts files and using the .d.ts file\n      // exports would cause the StaticSymbolResolver to redirect symbols to the\n      // incorrect location.\n\n      if ((!oldMetadata.version || oldMetadata.version < 3) && dtsMetadata.exports) {\n        newMetadata.exports = dtsMetadata.exports;\n      }\n    }\n\n    return newMetadata;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/metadata_reader.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {METADATA_VERSION, ModuleMetadata} from '../metadata';\n\nimport {DTS} from './util';\n\nexport interface MetadataReaderHost {\n  getSourceFileMetadata(filePath: string): ModuleMetadata|undefined;\n  cacheMetadata?(fileName: string): boolean;\n  fileExists(filePath: string): boolean;\n  readFile(filePath: string): string;\n}\n\nexport interface MetadataReaderCache {\n  /**\n   * @internal\n   */\n  data: Map<string, ModuleMetadata[]|undefined>;\n}\n\nexport function createMetadataReaderCache(): MetadataReaderCache {\n  const data = new Map<string, ModuleMetadata[]|undefined>();\n  return {data};\n}\n\nexport function readMetadata(\n    filePath: string, host: MetadataReaderHost, cache?: MetadataReaderCache): ModuleMetadata[]|\n    undefined {\n  let metadatas = cache && cache.data.get(filePath);\n  if (metadatas) {\n    return metadatas;\n  }\n  if (host.fileExists(filePath)) {\n    // If the file doesn't exists then we cannot return metadata for the file.\n    // This will occur if the user referenced a declared module for which no file\n    // exists for the module (i.e. jQuery or angularjs).\n    if (DTS.test(filePath)) {\n      metadatas = readMetadataFile(host, filePath);\n      if (!metadatas) {\n        // If there is a .d.ts file but no metadata file we need to produce a\n        // metadata from the .d.ts file as metadata files capture reexports\n        // (starting with v3).\n        metadatas = [upgradeMetadataWithDtsData(\n            host, {'__symbolic': 'module', 'version': 1, 'metadata': {}}, filePath)];\n      }\n    } else {\n      const metadata = host.getSourceFileMetadata(filePath);\n      metadatas = metadata ? [metadata] : [];\n    }\n  }\n  if (cache && (!host.cacheMetadata || host.cacheMetadata(filePath))) {\n    cache.data.set(filePath, metadatas);\n  }\n  return metadatas;\n}\n\n\nfunction readMetadataFile(host: MetadataReaderHost, dtsFilePath: string): ModuleMetadata[]|\n    undefined {\n  const metadataPath = dtsFilePath.replace(DTS, '.metadata.json');\n  if (!host.fileExists(metadataPath)) {\n    return undefined;\n  }\n  try {\n    const metadataOrMetadatas =\n        JSON.parse(host.readFile(metadataPath)) as ModuleMetadata | ModuleMetadata[] | undefined;\n    const metadatas = metadataOrMetadatas ?\n        (Array.isArray(metadataOrMetadatas) ? metadataOrMetadatas : [metadataOrMetadatas]) :\n        [];\n    if (metadatas.length) {\n      let maxMetadata = metadatas.reduce((p, c) => p.version > c.version ? p : c);\n      if (maxMetadata.version < METADATA_VERSION) {\n        metadatas.push(upgradeMetadataWithDtsData(host, maxMetadata, dtsFilePath));\n      }\n    }\n    return metadatas;\n  } catch (e) {\n    console.error(`Failed to read JSON file ${metadataPath}`);\n    throw e;\n  }\n}\n\nfunction upgradeMetadataWithDtsData(\n    host: MetadataReaderHost, oldMetadata: ModuleMetadata, dtsFilePath: string): ModuleMetadata {\n  // patch v1 to v3 by adding exports and the `extends` clause.\n  // patch v3 to v4 by adding `interface` symbols for TypeAlias\n  let newMetadata: ModuleMetadata = {\n    '__symbolic': 'module',\n    'version': METADATA_VERSION,\n    'metadata': {...oldMetadata.metadata},\n  };\n  if (oldMetadata.exports) {\n    newMetadata.exports = oldMetadata.exports;\n  }\n  if (oldMetadata.importAs) {\n    newMetadata.importAs = oldMetadata.importAs;\n  }\n  if (oldMetadata.origins) {\n    newMetadata.origins = oldMetadata.origins;\n  }\n  const dtsMetadata = host.getSourceFileMetadata(dtsFilePath);\n  if (dtsMetadata) {\n    for (let prop in dtsMetadata.metadata) {\n      if (!newMetadata.metadata[prop]) {\n        newMetadata.metadata[prop] = dtsMetadata.metadata[prop];\n      }\n    }\n    if (dtsMetadata['importAs']) newMetadata['importAs'] = dtsMetadata['importAs'];\n\n    // Only copy exports from exports from metadata prior to version 3.\n    // Starting with version 3 the collector began collecting exports and\n    // this should be redundant. Also, with bundler will rewrite the exports\n    // which will hoist the exports from modules referenced indirectly causing\n    // the imports to be different than the .d.ts files and using the .d.ts file\n    // exports would cause the StaticSymbolResolver to redirect symbols to the\n    // incorrect location.\n    if ((!oldMetadata.version || oldMetadata.version < 3) && dtsMetadata.exports) {\n      newMetadata.exports = dtsMetadata.exports;\n    }\n  }\n  return newMetadata;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}