{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/util\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.partitionArray = exports.newArray = exports.global = exports.Version = exports.isPromise = exports.resolveForwardRef = exports.stringify = exports.utf8Encode = exports.escapeRegExp = exports.getParseErrors = exports.isSyntaxError = exports.syntaxError = exports.error = exports.SyncAsync = exports.ValueTransformer = exports.noUndefined = exports.isDefined = exports.visitValue = exports.splitAtPeriod = exports.splitAtColon = exports.dashCaseToCamelCase = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\n  function dashCaseToCamelCase(input) {\n    return input.replace(DASH_CASE_REGEXP, function () {\n      var m = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        m[_i] = arguments[_i];\n      }\n\n      return m[1].toUpperCase();\n    });\n  }\n\n  exports.dashCaseToCamelCase = dashCaseToCamelCase;\n\n  function splitAtColon(input, defaultValues) {\n    return _splitAt(input, ':', defaultValues);\n  }\n\n  exports.splitAtColon = splitAtColon;\n\n  function splitAtPeriod(input, defaultValues) {\n    return _splitAt(input, '.', defaultValues);\n  }\n\n  exports.splitAtPeriod = splitAtPeriod;\n\n  function _splitAt(input, character, defaultValues) {\n    var characterIndex = input.indexOf(character);\n    if (characterIndex == -1) return defaultValues;\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n  }\n\n  function visitValue(value, visitor, context) {\n    if (Array.isArray(value)) {\n      return visitor.visitArray(value, context);\n    }\n\n    if (isStrictStringMap(value)) {\n      return visitor.visitStringMap(value, context);\n    }\n\n    if (value == null || typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean') {\n      return visitor.visitPrimitive(value, context);\n    }\n\n    return visitor.visitOther(value, context);\n  }\n\n  exports.visitValue = visitValue;\n\n  function isDefined(val) {\n    return val !== null && val !== undefined;\n  }\n\n  exports.isDefined = isDefined;\n\n  function noUndefined(val) {\n    return val === undefined ? null : val;\n  }\n\n  exports.noUndefined = noUndefined;\n\n  var ValueTransformer =\n  /** @class */\n  function () {\n    function ValueTransformer() {}\n\n    ValueTransformer.prototype.visitArray = function (arr, context) {\n      var _this = this;\n\n      return arr.map(function (value) {\n        return visitValue(value, _this, context);\n      });\n    };\n\n    ValueTransformer.prototype.visitStringMap = function (map, context) {\n      var _this = this;\n\n      var result = {};\n      Object.keys(map).forEach(function (key) {\n        result[key] = visitValue(map[key], _this, context);\n      });\n      return result;\n    };\n\n    ValueTransformer.prototype.visitPrimitive = function (value, context) {\n      return value;\n    };\n\n    ValueTransformer.prototype.visitOther = function (value, context) {\n      return value;\n    };\n\n    return ValueTransformer;\n  }();\n\n  exports.ValueTransformer = ValueTransformer;\n  exports.SyncAsync = {\n    assertSync: function assertSync(value) {\n      if (isPromise(value)) {\n        throw new Error(\"Illegal state: value cannot be a promise\");\n      }\n\n      return value;\n    },\n    then: function then(value, cb) {\n      return isPromise(value) ? value.then(cb) : cb(value);\n    },\n    all: function all(syncAsyncValues) {\n      return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;\n    }\n  };\n\n  function error(msg) {\n    throw new Error(\"Internal Error: \" + msg);\n  }\n\n  exports.error = error;\n\n  function syntaxError(msg, parseErrors) {\n    var error = Error(msg);\n    error[ERROR_SYNTAX_ERROR] = true;\n    if (parseErrors) error[ERROR_PARSE_ERRORS] = parseErrors;\n    return error;\n  }\n\n  exports.syntaxError = syntaxError;\n  var ERROR_SYNTAX_ERROR = 'ngSyntaxError';\n  var ERROR_PARSE_ERRORS = 'ngParseErrors';\n\n  function isSyntaxError(error) {\n    return error[ERROR_SYNTAX_ERROR];\n  }\n\n  exports.isSyntaxError = isSyntaxError;\n\n  function getParseErrors(error) {\n    return error[ERROR_PARSE_ERRORS] || [];\n  }\n\n  exports.getParseErrors = getParseErrors; // Escape characters that have a special meaning in Regular Expressions\n\n  function escapeRegExp(s) {\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n  }\n\n  exports.escapeRegExp = escapeRegExp;\n  var STRING_MAP_PROTO = Object.getPrototypeOf({});\n\n  function isStrictStringMap(obj) {\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n  }\n\n  function utf8Encode(str) {\n    var encoded = [];\n\n    for (var index = 0; index < str.length; index++) {\n      var codePoint = str.charCodeAt(index); // decode surrogate\n      // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\n      if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n        var low = str.charCodeAt(index + 1);\n\n        if (low >= 0xdc00 && low <= 0xdfff) {\n          index++;\n          codePoint = (codePoint - 0xd800 << 10) + low - 0xdc00 + 0x10000;\n        }\n      }\n\n      if (codePoint <= 0x7f) {\n        encoded.push(codePoint);\n      } else if (codePoint <= 0x7ff) {\n        encoded.push(codePoint >> 6 & 0x1F | 0xc0, codePoint & 0x3f | 0x80);\n      } else if (codePoint <= 0xffff) {\n        encoded.push(codePoint >> 12 | 0xe0, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n      } else if (codePoint <= 0x1fffff) {\n        encoded.push(codePoint >> 18 & 0x07 | 0xf0, codePoint >> 12 & 0x3f | 0x80, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n      }\n    }\n\n    return encoded;\n  }\n\n  exports.utf8Encode = utf8Encode;\n\n  function stringify(token) {\n    if (typeof token === 'string') {\n      return token;\n    }\n\n    if (Array.isArray(token)) {\n      return '[' + token.map(stringify).join(', ') + ']';\n    }\n\n    if (token == null) {\n      return '' + token;\n    }\n\n    if (token.overriddenName) {\n      return \"\" + token.overriddenName;\n    }\n\n    if (token.name) {\n      return \"\" + token.name;\n    }\n\n    if (!token.toString) {\n      return 'object';\n    } // WARNING: do not try to `JSON.stringify(token)` here\n    // see https://github.com/angular/angular/issues/23440\n\n\n    var res = token.toString();\n\n    if (res == null) {\n      return '' + res;\n    }\n\n    var newLineIndex = res.indexOf('\\n');\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n  }\n\n  exports.stringify = stringify;\n  /**\n   * Lazily retrieves the reference value from a forwardRef.\n   */\n\n  function resolveForwardRef(type) {\n    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n      return type();\n    } else {\n      return type;\n    }\n  }\n\n  exports.resolveForwardRef = resolveForwardRef;\n  /**\n   * Determine if the argument is shaped like a Promise\n   */\n\n  function isPromise(obj) {\n    // allow any Promise/A+ compliant thenable.\n    // It's up to the caller to ensure that obj.then conforms to the spec\n    return !!obj && typeof obj.then === 'function';\n  }\n\n  exports.isPromise = isPromise;\n\n  var Version =\n  /** @class */\n  function () {\n    function Version(full) {\n      this.full = full;\n      var splits = full.split('.');\n      this.major = splits[0];\n      this.minor = splits[1];\n      this.patch = splits.slice(2).join('.');\n    }\n\n    return Version;\n  }();\n\n  exports.Version = Version;\n\n  var __window = typeof window !== 'undefined' && window;\n\n  var __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;\n\n  var __global = typeof global !== 'undefined' && global; // Check __global first, because in Node tests both __global and __window may be defined and _global\n  // should be __global in that case.\n\n\n  var _global = __global || __window || __self;\n\n  exports.global = _global;\n\n  function newArray(size, value) {\n    var list = [];\n\n    for (var i = 0; i < size; i++) {\n      list.push(value);\n    }\n\n    return list;\n  }\n\n  exports.newArray = newArray;\n  /**\n   * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n   * function.\n   *\n   * @param arr Input array that should be partitioned\n   * @param conditionFn Condition function that is called for each item in a given array and returns a\n   * boolean value.\n   */\n\n  function partitionArray(arr, conditionFn) {\n    var e_1, _a;\n\n    var truthy = [];\n    var falsy = [];\n\n    try {\n      for (var arr_1 = tslib_1.__values(arr), arr_1_1 = arr_1.next(); !arr_1_1.done; arr_1_1 = arr_1.next()) {\n        var item = arr_1_1.value;\n        (conditionFn(item) ? truthy : falsy).push(item);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (arr_1_1 && !arr_1_1.done && (_a = arr_1.return)) _a.call(arr_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return [truthy, falsy];\n  }\n\n  exports.partitionArray = partitionArray;\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from './constant_pool';\n\nimport * as o from './output/output_ast';\nimport {ParseError} from './parse_util';\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function splitAtColon(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, ':', defaultValues);\n}\n\nexport function splitAtPeriod(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(input: string, character: string, defaultValues: string[]): string[] {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nexport function visitValue(value: any, visitor: ValueVisitor, context: any): any {\n  if (Array.isArray(value)) {\n    return visitor.visitArray(<any[]>value, context);\n  }\n\n  if (isStrictStringMap(value)) {\n    return visitor.visitStringMap(<{[key: string]: any}>value, context);\n  }\n\n  if (value == null || typeof value == 'string' || typeof value == 'number' ||\n      typeof value == 'boolean') {\n    return visitor.visitPrimitive(value, context);\n  }\n\n  return visitor.visitOther(value, context);\n}\n\nexport function isDefined(val: any): boolean {\n  return val !== null && val !== undefined;\n}\n\nexport function noUndefined<T>(val: T|undefined): T {\n  return val === undefined ? null! : val;\n}\n\nexport interface ValueVisitor {\n  visitArray(arr: any[], context: any): any;\n  visitStringMap(map: {[key: string]: any}, context: any): any;\n  visitPrimitive(value: any, context: any): any;\n  visitOther(value: any, context: any): any;\n}\n\nexport class ValueTransformer implements ValueVisitor {\n  visitArray(arr: any[], context: any): any {\n    return arr.map(value => visitValue(value, this, context));\n  }\n  visitStringMap(map: {[key: string]: any}, context: any): any {\n    const result: {[key: string]: any} = {};\n    Object.keys(map).forEach(key => {\n      result[key] = visitValue(map[key], this, context);\n    });\n    return result;\n  }\n  visitPrimitive(value: any, context: any): any {\n    return value;\n  }\n  visitOther(value: any, context: any): any {\n    return value;\n  }\n}\n\nexport type SyncAsync<T> = T|Promise<T>;\n\nexport const SyncAsync = {\n  assertSync: <T>(value: SyncAsync<T>): T => {\n    if (isPromise(value)) {\n      throw new Error(`Illegal state: value cannot be a promise`);\n    }\n    return value;\n  },\n  then: <T, R>(value: SyncAsync<T>, cb: (value: T) => R | Promise<R>| SyncAsync<R>):\n      SyncAsync<R> => {\n        return isPromise(value) ? value.then(cb) : cb(value);\n      },\n  all: <T>(syncAsyncValues: SyncAsync<T>[]): SyncAsync<T[]> => {\n    return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues as T[];\n  }\n};\n\nexport function error(msg: string): never {\n  throw new Error(`Internal Error: ${msg}`);\n}\n\nexport function syntaxError(msg: string, parseErrors?: ParseError[]): Error {\n  const error = Error(msg);\n  (error as any)[ERROR_SYNTAX_ERROR] = true;\n  if (parseErrors) (error as any)[ERROR_PARSE_ERRORS] = parseErrors;\n  return error;\n}\n\nconst ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nconst ERROR_PARSE_ERRORS = 'ngParseErrors';\n\nexport function isSyntaxError(error: Error): boolean {\n  return (error as any)[ERROR_SYNTAX_ERROR];\n}\n\nexport function getParseErrors(error: Error): ParseError[] {\n  return (error as any)[ERROR_PARSE_ERRORS] || [];\n}\n\n// Escape characters that have a special meaning in Regular Expressions\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nconst STRING_MAP_PROTO = Object.getPrototypeOf({});\nfunction isStrictStringMap(obj: any): boolean {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n\nexport type Byte = number;\n\nexport function utf8Encode(str: string): Byte[] {\n  let encoded: Byte[] = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(\n          (codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(\n          ((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80,\n          ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    }\n  }\n\n  return encoded;\n}\n\nexport interface OutputContext {\n  genFilePath: string;\n  statements: o.Statement[];\n  constantPool: ConstantPool;\n  importExpr(reference: any, typeParams?: o.Type[]|null, useSummaries?: boolean): o.Expression;\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  if (!token.toString) {\n    return 'object';\n  }\n\n  // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n */\nexport function resolveForwardRef(type: any): any {\n  if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n    return type();\n  } else {\n    return type;\n  }\n}\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport function isPromise<T = any>(obj: any): obj is Promise<T> {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\n\nexport interface Console {\n  log(message: string): void;\n  warn(message: string): void;\n}\n\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n\n// Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\nconst _global: {[name: string]: any} = __global || __window || __self;\nexport {_global as global};\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value!);\n  }\n  return list;\n}\n\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nexport function partitionArray<T, F = T>(\n    arr: (T|F)[], conditionFn: (value: T|F) => boolean): [T[], F[]] {\n  const truthy: T[] = [];\n  const falsy: F[] = [];\n  for (const item of arr) {\n    (conditionFn(item) ? truthy : falsy).push(item as any);\n  }\n  return [truthy, falsy];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}