{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_constructor\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.requiresInlineTypeCtor = exports.generateInlineTypeCtor = exports.generateTypeCtorDeclarationFn = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var tcb_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\");\n\n  var ts_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\");\n\n  function generateTypeCtorDeclarationFn(node, meta, nodeTypeRef, typeParams, reflector) {\n    if (requiresInlineTypeCtor(node, reflector)) {\n      throw new Error(node.name.text + \" requires an inline type constructor\");\n    }\n\n    var rawTypeArgs = typeParams !== undefined ? generateGenericArgs(typeParams) : undefined;\n    var rawType = ts.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);\n    var initParam = constructTypeCtorParameter(node, meta, rawType);\n    var typeParameters = typeParametersWithDefaultTypes(typeParams);\n\n    if (meta.body) {\n      var fnType = ts.createFunctionTypeNode(\n      /* typeParameters */\n      typeParameters,\n      /* parameters */\n      [initParam],\n      /* type */\n      rawType);\n      var decl = ts.createVariableDeclaration(\n      /* name */\n      meta.fnName,\n      /* type */\n      fnType,\n      /* body */\n      ts.createNonNullExpression(ts.createNull()));\n      var declList = ts.createVariableDeclarationList([decl], ts.NodeFlags.Const);\n      return ts.createVariableStatement(\n      /* modifiers */\n      undefined,\n      /* declarationList */\n      declList);\n    } else {\n      return ts.createFunctionDeclaration(\n      /* decorators */\n      undefined,\n      /* modifiers */\n      [ts.createModifier(ts.SyntaxKind.DeclareKeyword)],\n      /* asteriskToken */\n      undefined,\n      /* name */\n      meta.fnName,\n      /* typeParameters */\n      typeParameters,\n      /* parameters */\n      [initParam],\n      /* type */\n      rawType,\n      /* body */\n      undefined);\n    }\n  }\n\n  exports.generateTypeCtorDeclarationFn = generateTypeCtorDeclarationFn;\n  /**\n   * Generate an inline type constructor for the given class and metadata.\n   *\n   * An inline type constructor is a specially shaped TypeScript static method, intended to be placed\n   * within a directive class itself, that permits type inference of any generic type parameters of\n   * the class from the types of expressions bound to inputs or outputs, and the types of elements\n   * that match queries performed by the directive. It also catches any errors in the types of these\n   * expressions. This method is never called at runtime, but is used in type-check blocks to\n   * construct directive types.\n   *\n   * An inline type constructor for NgFor looks like:\n   *\n   * static ngTypeCtor<T>(init: Pick<NgForOf<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>):\n   *   NgForOf<T>;\n   *\n   * A typical constructor would be:\n   *\n   * NgForOf.ngTypeCtor(init: {\n   *   ngForOf: ['foo', 'bar'],\n   *   ngForTrackBy: null as any,\n   *   ngForTemplate: null as any,\n   * }); // Infers a type of NgForOf<string>.\n   *\n   * Any inputs declared on the type for which no property binding is present are assigned a value of\n   * type `any`, to avoid producing any type errors for unset inputs.\n   *\n   * Inline type constructors are used when the type being created has bounded generic types which\n   * make writing a declared type constructor (via `generateTypeCtorDeclarationFn`) difficult or\n   * impossible.\n   *\n   * @param node the `ClassDeclaration<ts.ClassDeclaration>` for which a type constructor will be\n   * generated.\n   * @param meta additional metadata required to generate the type constructor.\n   * @returns a `ts.MethodDeclaration` for the type constructor.\n   */\n\n  function generateInlineTypeCtor(node, meta) {\n    // Build rawType, a `ts.TypeNode` of the class with its generic parameters passed through from\n    // the definition without any type bounds. For example, if the class is\n    // `FooDirective<T extends Bar>`, its rawType would be `FooDirective<T>`.\n    var rawTypeArgs = node.typeParameters !== undefined ? generateGenericArgs(node.typeParameters) : undefined;\n    var rawType = ts.createTypeReferenceNode(node.name, rawTypeArgs);\n    var initParam = constructTypeCtorParameter(node, meta, rawType); // If this constructor is being generated into a .ts file, then it needs a fake body. The body\n    // is set to a return of `null!`. If the type constructor is being generated into a .d.ts file,\n    // it needs no body.\n\n    var body = undefined;\n\n    if (meta.body) {\n      body = ts.createBlock([ts.createReturn(ts.createNonNullExpression(ts.createNull()))]);\n    } // Create the type constructor method declaration.\n\n\n    return ts.createMethod(\n    /* decorators */\n    undefined,\n    /* modifiers */\n    [ts.createModifier(ts.SyntaxKind.StaticKeyword)],\n    /* asteriskToken */\n    undefined,\n    /* name */\n    meta.fnName,\n    /* questionToken */\n    undefined,\n    /* typeParameters */\n    typeParametersWithDefaultTypes(node.typeParameters),\n    /* parameters */\n    [initParam],\n    /* type */\n    rawType,\n    /* body */\n    body);\n  }\n\n  exports.generateInlineTypeCtor = generateInlineTypeCtor;\n\n  function constructTypeCtorParameter(node, meta, rawType) {\n    var e_1, _a; // initType is the type of 'init', the single argument to the type constructor method.\n    // If the Directive has any inputs, its initType will be:\n    //\n    // Pick<rawType, 'inputA'|'inputB'>\n    //\n    // Pick here is used to select only those fields from which the generic type parameters of the\n    // directive will be inferred.\n    //\n    // In the special case there are no inputs, initType is set to {}.\n\n\n    var initType = null;\n    var keys = meta.fields.inputs;\n    var plainKeys = [];\n    var coercedKeys = [];\n\n    try {\n      for (var keys_1 = tslib_1.__values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {\n        var key = keys_1_1.value;\n\n        if (!meta.coercedInputFields.has(key)) {\n          plainKeys.push(ts.createLiteralTypeNode(ts.createStringLiteral(key)));\n        } else {\n          coercedKeys.push(ts.createPropertySignature(\n          /* modifiers */\n          undefined,\n          /* name */\n          key,\n          /* questionToken */\n          undefined,\n          /* type */\n          ts_util_1.tsCreateTypeQueryForCoercedInput(rawType.typeName, key),\n          /* initializer */\n          undefined));\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    if (plainKeys.length > 0) {\n      // Construct a union of all the field names.\n      var keyTypeUnion = ts.createUnionTypeNode(plainKeys); // Construct the Pick<rawType, keyTypeUnion>.\n\n      initType = ts.createTypeReferenceNode('Pick', [rawType, keyTypeUnion]);\n    }\n\n    if (coercedKeys.length > 0) {\n      var coercedLiteral = ts.createTypeLiteralNode(coercedKeys);\n      initType = initType !== null ? ts.createIntersectionTypeNode([initType, coercedLiteral]) : coercedLiteral;\n    }\n\n    if (initType === null) {\n      // Special case - no inputs, outputs, or other fields which could influence the result type.\n      initType = ts.createTypeLiteralNode([]);\n    } // Create the 'init' parameter itself.\n\n\n    return ts.createParameter(\n    /* decorators */\n    undefined,\n    /* modifiers */\n    undefined,\n    /* dotDotDotToken */\n    undefined,\n    /* name */\n    'init',\n    /* questionToken */\n    undefined,\n    /* type */\n    initType,\n    /* initializer */\n    undefined);\n  }\n\n  function generateGenericArgs(params) {\n    return params.map(function (param) {\n      return ts.createTypeReferenceNode(param.name, undefined);\n    });\n  }\n\n  function requiresInlineTypeCtor(node, host) {\n    // The class requires an inline type constructor if it has generic type bounds that can not be\n    // emitted into a different context.\n    return !tcb_util_1.checkIfGenericTypeBoundsAreContextFree(node, host);\n  }\n\n  exports.requiresInlineTypeCtor = requiresInlineTypeCtor;\n  /**\n   * Add a default `= any` to type parameters that don't have a default value already.\n   *\n   * TypeScript uses the default type of a type parameter whenever inference of that parameter fails.\n   * This can happen when inferring a complex type from 'any'. For example, if `NgFor`'s inference is\n   * done with the TCB code:\n   *\n   * ```\n   * class NgFor<T> {\n   *   ngForOf: T[];\n   * }\n   *\n   * declare function ctor<T>(o: Pick<NgFor<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>): NgFor<T>;\n   * ```\n   *\n   * An invocation looks like:\n   *\n   * ```\n   * var _t1 = ctor({ngForOf: [1, 2], ngForTrackBy: null as any, ngForTemplate: null as any});\n   * ```\n   *\n   * This correctly infers the type `NgFor<number>` for `_t1`, since `T` is inferred from the\n   * assignment of type `number[]` to `ngForOf`'s type `T[]`. However, if `any` is passed instead:\n   *\n   * ```\n   * var _t2 = ctor({ngForOf: [1, 2] as any, ngForTrackBy: null as any, ngForTemplate: null as any});\n   * ```\n   *\n   * then inference for `T` fails (it cannot be inferred from `T[] = any`). In this case, `T` takes\n   * the type `{}`, and so `_t2` is inferred as `NgFor<{}>`. This is obviously wrong.\n   *\n   * Adding a default type to the generic declaration in the constructor solves this problem, as the\n   * default type will be used in the event that inference fails.\n   *\n   * ```\n   * declare function ctor<T = any>(o: Pick<NgFor<T>, 'ngForOf'>): NgFor<T>;\n   *\n   * var _t3 = ctor({ngForOf: [1, 2] as any});\n   * ```\n   *\n   * This correctly infers `T` as `any`, and therefore `_t3` as `NgFor<any>`.\n   */\n\n  function typeParametersWithDefaultTypes(params) {\n    if (params === undefined) {\n      return undefined;\n    }\n\n    return params.map(function (param) {\n      if (param.default === undefined) {\n        return ts.updateTypeParameterDeclaration(\n        /* node */\n        param,\n        /* name */\n        param.name,\n        /* constraint */\n        param.constraint,\n        /* defaultType */\n        ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n      } else {\n        return param;\n      }\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_constructor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {TypeCtorMetadata} from '../api';\nimport {checkIfGenericTypeBoundsAreContextFree} from './tcb_util';\n\nimport {tsCreateTypeQueryForCoercedInput} from './ts_util';\n\nexport function generateTypeCtorDeclarationFn(\n    node: ClassDeclaration<ts.ClassDeclaration>, meta: TypeCtorMetadata, nodeTypeRef: ts.EntityName,\n    typeParams: ts.TypeParameterDeclaration[]|undefined, reflector: ReflectionHost): ts.Statement {\n  if (requiresInlineTypeCtor(node, reflector)) {\n    throw new Error(`${node.name.text} requires an inline type constructor`);\n  }\n\n  const rawTypeArgs = typeParams !== undefined ? generateGenericArgs(typeParams) : undefined;\n  const rawType = ts.createTypeReferenceNode(nodeTypeRef, rawTypeArgs);\n\n  const initParam = constructTypeCtorParameter(node, meta, rawType);\n\n  const typeParameters = typeParametersWithDefaultTypes(typeParams);\n\n  if (meta.body) {\n    const fnType = ts.createFunctionTypeNode(\n        /* typeParameters */ typeParameters,\n        /* parameters */[initParam],\n        /* type */ rawType,\n    );\n\n    const decl = ts.createVariableDeclaration(\n        /* name */ meta.fnName,\n        /* type */ fnType,\n        /* body */ ts.createNonNullExpression(ts.createNull()));\n    const declList = ts.createVariableDeclarationList([decl], ts.NodeFlags.Const);\n    return ts.createVariableStatement(\n        /* modifiers */ undefined,\n        /* declarationList */ declList);\n  } else {\n    return ts.createFunctionDeclaration(\n        /* decorators */ undefined,\n        /* modifiers */[ts.createModifier(ts.SyntaxKind.DeclareKeyword)],\n        /* asteriskToken */ undefined,\n        /* name */ meta.fnName,\n        /* typeParameters */ typeParameters,\n        /* parameters */[initParam],\n        /* type */ rawType,\n        /* body */ undefined);\n  }\n}\n\n/**\n * Generate an inline type constructor for the given class and metadata.\n *\n * An inline type constructor is a specially shaped TypeScript static method, intended to be placed\n * within a directive class itself, that permits type inference of any generic type parameters of\n * the class from the types of expressions bound to inputs or outputs, and the types of elements\n * that match queries performed by the directive. It also catches any errors in the types of these\n * expressions. This method is never called at runtime, but is used in type-check blocks to\n * construct directive types.\n *\n * An inline type constructor for NgFor looks like:\n *\n * static ngTypeCtor<T>(init: Pick<NgForOf<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>):\n *   NgForOf<T>;\n *\n * A typical constructor would be:\n *\n * NgForOf.ngTypeCtor(init: {\n *   ngForOf: ['foo', 'bar'],\n *   ngForTrackBy: null as any,\n *   ngForTemplate: null as any,\n * }); // Infers a type of NgForOf<string>.\n *\n * Any inputs declared on the type for which no property binding is present are assigned a value of\n * type `any`, to avoid producing any type errors for unset inputs.\n *\n * Inline type constructors are used when the type being created has bounded generic types which\n * make writing a declared type constructor (via `generateTypeCtorDeclarationFn`) difficult or\n * impossible.\n *\n * @param node the `ClassDeclaration<ts.ClassDeclaration>` for which a type constructor will be\n * generated.\n * @param meta additional metadata required to generate the type constructor.\n * @returns a `ts.MethodDeclaration` for the type constructor.\n */\nexport function generateInlineTypeCtor(\n    node: ClassDeclaration<ts.ClassDeclaration>, meta: TypeCtorMetadata): ts.MethodDeclaration {\n  // Build rawType, a `ts.TypeNode` of the class with its generic parameters passed through from\n  // the definition without any type bounds. For example, if the class is\n  // `FooDirective<T extends Bar>`, its rawType would be `FooDirective<T>`.\n  const rawTypeArgs =\n      node.typeParameters !== undefined ? generateGenericArgs(node.typeParameters) : undefined;\n  const rawType = ts.createTypeReferenceNode(node.name, rawTypeArgs);\n\n  const initParam = constructTypeCtorParameter(node, meta, rawType);\n\n  // If this constructor is being generated into a .ts file, then it needs a fake body. The body\n  // is set to a return of `null!`. If the type constructor is being generated into a .d.ts file,\n  // it needs no body.\n  let body: ts.Block|undefined = undefined;\n  if (meta.body) {\n    body = ts.createBlock([\n      ts.createReturn(ts.createNonNullExpression(ts.createNull())),\n    ]);\n  }\n\n  // Create the type constructor method declaration.\n  return ts.createMethod(\n      /* decorators */ undefined,\n      /* modifiers */[ts.createModifier(ts.SyntaxKind.StaticKeyword)],\n      /* asteriskToken */ undefined,\n      /* name */ meta.fnName,\n      /* questionToken */ undefined,\n      /* typeParameters */ typeParametersWithDefaultTypes(node.typeParameters),\n      /* parameters */[initParam],\n      /* type */ rawType,\n      /* body */ body,\n  );\n}\n\nfunction constructTypeCtorParameter(\n    node: ClassDeclaration<ts.ClassDeclaration>, meta: TypeCtorMetadata,\n    rawType: ts.TypeReferenceNode): ts.ParameterDeclaration {\n  // initType is the type of 'init', the single argument to the type constructor method.\n  // If the Directive has any inputs, its initType will be:\n  //\n  // Pick<rawType, 'inputA'|'inputB'>\n  //\n  // Pick here is used to select only those fields from which the generic type parameters of the\n  // directive will be inferred.\n  //\n  // In the special case there are no inputs, initType is set to {}.\n  let initType: ts.TypeNode|null = null;\n\n  const keys: string[] = meta.fields.inputs;\n  const plainKeys: ts.LiteralTypeNode[] = [];\n  const coercedKeys: ts.PropertySignature[] = [];\n  for (const key of keys) {\n    if (!meta.coercedInputFields.has(key)) {\n      plainKeys.push(ts.createLiteralTypeNode(ts.createStringLiteral(key)));\n    } else {\n      coercedKeys.push(ts.createPropertySignature(\n          /* modifiers */ undefined,\n          /* name */ key,\n          /* questionToken */ undefined,\n          /* type */ tsCreateTypeQueryForCoercedInput(rawType.typeName, key),\n          /* initializer */ undefined));\n    }\n  }\n  if (plainKeys.length > 0) {\n    // Construct a union of all the field names.\n    const keyTypeUnion = ts.createUnionTypeNode(plainKeys);\n\n    // Construct the Pick<rawType, keyTypeUnion>.\n    initType = ts.createTypeReferenceNode('Pick', [rawType, keyTypeUnion]);\n  }\n  if (coercedKeys.length > 0) {\n    const coercedLiteral = ts.createTypeLiteralNode(coercedKeys);\n\n    initType = initType !== null ? ts.createIntersectionTypeNode([initType, coercedLiteral]) :\n                                   coercedLiteral;\n  }\n\n  if (initType === null) {\n    // Special case - no inputs, outputs, or other fields which could influence the result type.\n    initType = ts.createTypeLiteralNode([]);\n  }\n\n  // Create the 'init' parameter itself.\n  return ts.createParameter(\n      /* decorators */ undefined,\n      /* modifiers */ undefined,\n      /* dotDotDotToken */ undefined,\n      /* name */ 'init',\n      /* questionToken */ undefined,\n      /* type */ initType,\n      /* initializer */ undefined);\n}\n\nfunction generateGenericArgs(params: ReadonlyArray<ts.TypeParameterDeclaration>): ts.TypeNode[] {\n  return params.map(param => ts.createTypeReferenceNode(param.name, undefined));\n}\n\nexport function requiresInlineTypeCtor(\n    node: ClassDeclaration<ts.ClassDeclaration>, host: ReflectionHost): boolean {\n  // The class requires an inline type constructor if it has generic type bounds that can not be\n  // emitted into a different context.\n  return !checkIfGenericTypeBoundsAreContextFree(node, host);\n}\n\n/**\n * Add a default `= any` to type parameters that don't have a default value already.\n *\n * TypeScript uses the default type of a type parameter whenever inference of that parameter fails.\n * This can happen when inferring a complex type from 'any'. For example, if `NgFor`'s inference is\n * done with the TCB code:\n *\n * ```\n * class NgFor<T> {\n *   ngForOf: T[];\n * }\n *\n * declare function ctor<T>(o: Pick<NgFor<T>, 'ngForOf'|'ngForTrackBy'|'ngForTemplate'>): NgFor<T>;\n * ```\n *\n * An invocation looks like:\n *\n * ```\n * var _t1 = ctor({ngForOf: [1, 2], ngForTrackBy: null as any, ngForTemplate: null as any});\n * ```\n *\n * This correctly infers the type `NgFor<number>` for `_t1`, since `T` is inferred from the\n * assignment of type `number[]` to `ngForOf`'s type `T[]`. However, if `any` is passed instead:\n *\n * ```\n * var _t2 = ctor({ngForOf: [1, 2] as any, ngForTrackBy: null as any, ngForTemplate: null as any});\n * ```\n *\n * then inference for `T` fails (it cannot be inferred from `T[] = any`). In this case, `T` takes\n * the type `{}`, and so `_t2` is inferred as `NgFor<{}>`. This is obviously wrong.\n *\n * Adding a default type to the generic declaration in the constructor solves this problem, as the\n * default type will be used in the event that inference fails.\n *\n * ```\n * declare function ctor<T = any>(o: Pick<NgFor<T>, 'ngForOf'>): NgFor<T>;\n *\n * var _t3 = ctor({ngForOf: [1, 2] as any});\n * ```\n *\n * This correctly infers `T` as `any`, and therefore `_t3` as `NgFor<any>`.\n */\nfunction typeParametersWithDefaultTypes(params: ReadonlyArray<ts.TypeParameterDeclaration>|\n                                        undefined): ts.TypeParameterDeclaration[]|undefined {\n  if (params === undefined) {\n    return undefined;\n  }\n\n  return params.map(param => {\n    if (param.default === undefined) {\n      return ts.updateTypeParameterDeclaration(\n          /* node */ param,\n          /* name */ param.name,\n          /* constraint */ param.constraint,\n          /* defaultType */ ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n    } else {\n      return param;\n    }\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}