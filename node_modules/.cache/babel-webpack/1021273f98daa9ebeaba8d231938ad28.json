{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/core/src/compiler\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/annotations\", \"@angular/compiler-cli/src/ngtsc/cycles\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/entry_point\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/incremental\", \"@angular/compiler-cli/src/ngtsc/indexer\", \"@angular/compiler-cli/src/ngtsc/metadata\", \"@angular/compiler-cli/src/ngtsc/modulewithproviders\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/perf/src/api\", \"@angular/compiler-cli/src/ngtsc/perf/src/recorder\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/resource\", \"@angular/compiler-cli/src/ngtsc/routing\", \"@angular/compiler-cli/src/ngtsc/scope\", \"@angular/compiler-cli/src/ngtsc/shims\", \"@angular/compiler-cli/src/ngtsc/switch\", \"@angular/compiler-cli/src/ngtsc/transform\", \"@angular/compiler-cli/src/ngtsc/typecheck\", \"@angular/compiler-cli/src/ngtsc/typecheck/api\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/core/src/config\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isAngularCorePackage = exports.NgCompiler = exports.resourceChangeTicket = exports.incrementalFromDriverTicket = exports.incrementalFromCompilerTicket = exports.freshCompilationTicket = exports.CompilationTicketKind = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var annotations_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations\");\n\n  var cycles_1 = require(\"@angular/compiler-cli/src/ngtsc/cycles\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/src/ngtsc/entry_point\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var incremental_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental\");\n\n  var indexer_1 = require(\"@angular/compiler-cli/src/ngtsc/indexer\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata\");\n\n  var modulewithproviders_1 = require(\"@angular/compiler-cli/src/ngtsc/modulewithproviders\");\n\n  var partial_evaluator_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/perf/src/api\");\n\n  var recorder_1 = require(\"@angular/compiler-cli/src/ngtsc/perf/src/recorder\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var resource_1 = require(\"@angular/compiler-cli/src/ngtsc/resource\");\n\n  var routing_1 = require(\"@angular/compiler-cli/src/ngtsc/routing\");\n\n  var scope_1 = require(\"@angular/compiler-cli/src/ngtsc/scope\");\n\n  var shims_1 = require(\"@angular/compiler-cli/src/ngtsc/shims\");\n\n  var switch_1 = require(\"@angular/compiler-cli/src/ngtsc/switch\");\n\n  var transform_1 = require(\"@angular/compiler-cli/src/ngtsc/transform\");\n\n  var typecheck_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck\");\n\n  var api_2 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/api\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var config_1 = require(\"@angular/compiler-cli/src/ngtsc/core/src/config\");\n  /**\n   * Discriminant type for a `CompilationTicket`.\n   */\n\n\n  var CompilationTicketKind;\n\n  (function (CompilationTicketKind) {\n    CompilationTicketKind[CompilationTicketKind[\"Fresh\"] = 0] = \"Fresh\";\n    CompilationTicketKind[CompilationTicketKind[\"IncrementalTypeScript\"] = 1] = \"IncrementalTypeScript\";\n    CompilationTicketKind[CompilationTicketKind[\"IncrementalResource\"] = 2] = \"IncrementalResource\";\n  })(CompilationTicketKind = exports.CompilationTicketKind || (exports.CompilationTicketKind = {}));\n  /**\n   * Create a `CompilationTicket` for a brand new compilation, using no prior state.\n   */\n\n\n  function freshCompilationTicket(tsProgram, options, incrementalBuildStrategy, typeCheckingProgramStrategy, perfRecorder, enableTemplateTypeChecker, usePoisonedData) {\n    return {\n      kind: CompilationTicketKind.Fresh,\n      tsProgram: tsProgram,\n      options: options,\n      incrementalBuildStrategy: incrementalBuildStrategy,\n      typeCheckingProgramStrategy: typeCheckingProgramStrategy,\n      enableTemplateTypeChecker: enableTemplateTypeChecker,\n      usePoisonedData: usePoisonedData,\n      perfRecorder: perfRecorder !== null && perfRecorder !== void 0 ? perfRecorder : perf_1.ActivePerfRecorder.zeroedToNow()\n    };\n  }\n\n  exports.freshCompilationTicket = freshCompilationTicket;\n  /**\n   * Create a `CompilationTicket` as efficiently as possible, based on a previous `NgCompiler`\n   * instance and a new `ts.Program`.\n   */\n\n  function incrementalFromCompilerTicket(oldCompiler, newProgram, incrementalBuildStrategy, typeCheckingProgramStrategy, modifiedResourceFiles, perfRecorder) {\n    var oldProgram = oldCompiler.getNextProgram();\n    var oldDriver = oldCompiler.incrementalStrategy.getIncrementalDriver(oldProgram);\n\n    if (oldDriver === null) {\n      // No incremental step is possible here, since no IncrementalDriver was found for the old\n      // program.\n      return freshCompilationTicket(newProgram, oldCompiler.options, incrementalBuildStrategy, typeCheckingProgramStrategy, perfRecorder, oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);\n    }\n\n    if (perfRecorder === null) {\n      perfRecorder = perf_1.ActivePerfRecorder.zeroedToNow();\n    }\n\n    var newDriver = incremental_1.IncrementalDriver.reconcile(oldProgram, oldDriver, newProgram, modifiedResourceFiles, perfRecorder);\n    return {\n      kind: CompilationTicketKind.IncrementalTypeScript,\n      enableTemplateTypeChecker: oldCompiler.enableTemplateTypeChecker,\n      usePoisonedData: oldCompiler.usePoisonedData,\n      options: oldCompiler.options,\n      incrementalBuildStrategy: incrementalBuildStrategy,\n      typeCheckingProgramStrategy: typeCheckingProgramStrategy,\n      newDriver: newDriver,\n      oldProgram: oldProgram,\n      newProgram: newProgram,\n      perfRecorder: perfRecorder\n    };\n  }\n\n  exports.incrementalFromCompilerTicket = incrementalFromCompilerTicket;\n  /**\n   * Create a `CompilationTicket` directly from an old `ts.Program` and associated Angular compilation\n   * state, along with a new `ts.Program`.\n   */\n\n  function incrementalFromDriverTicket(oldProgram, oldDriver, newProgram, options, incrementalBuildStrategy, typeCheckingProgramStrategy, modifiedResourceFiles, perfRecorder, enableTemplateTypeChecker, usePoisonedData) {\n    if (perfRecorder === null) {\n      perfRecorder = perf_1.ActivePerfRecorder.zeroedToNow();\n    }\n\n    var newDriver = incremental_1.IncrementalDriver.reconcile(oldProgram, oldDriver, newProgram, modifiedResourceFiles, perfRecorder);\n    return {\n      kind: CompilationTicketKind.IncrementalTypeScript,\n      oldProgram: oldProgram,\n      newProgram: newProgram,\n      options: options,\n      incrementalBuildStrategy: incrementalBuildStrategy,\n      newDriver: newDriver,\n      typeCheckingProgramStrategy: typeCheckingProgramStrategy,\n      enableTemplateTypeChecker: enableTemplateTypeChecker,\n      usePoisonedData: usePoisonedData,\n      perfRecorder: perfRecorder\n    };\n  }\n\n  exports.incrementalFromDriverTicket = incrementalFromDriverTicket;\n\n  function resourceChangeTicket(compiler, modifiedResourceFiles) {\n    return {\n      kind: CompilationTicketKind.IncrementalResource,\n      compiler: compiler,\n      modifiedResourceFiles: modifiedResourceFiles,\n      perfRecorder: perf_1.ActivePerfRecorder.zeroedToNow()\n    };\n  }\n\n  exports.resourceChangeTicket = resourceChangeTicket;\n  /**\n   * The heart of the Angular Ivy compiler.\n   *\n   * The `NgCompiler` provides an API for performing Angular compilation within a custom TypeScript\n   * compiler. Each instance of `NgCompiler` supports a single compilation, which might be\n   * incremental.\n   *\n   * `NgCompiler` is lazy, and does not perform any of the work of the compilation until one of its\n   * output methods (e.g. `getDiagnostics`) is called.\n   *\n   * See the README.md for more information.\n   */\n\n  var NgCompiler =\n  /** @class */\n  function () {\n    function NgCompiler(adapter, options, tsProgram, typeCheckingProgramStrategy, incrementalStrategy, incrementalDriver, enableTemplateTypeChecker, usePoisonedData, livePerfRecorder) {\n      var _a, e_1, _b;\n\n      var _this = this;\n\n      this.adapter = adapter;\n      this.options = options;\n      this.tsProgram = tsProgram;\n      this.typeCheckingProgramStrategy = typeCheckingProgramStrategy;\n      this.incrementalStrategy = incrementalStrategy;\n      this.incrementalDriver = incrementalDriver;\n      this.enableTemplateTypeChecker = enableTemplateTypeChecker;\n      this.usePoisonedData = usePoisonedData;\n      this.livePerfRecorder = livePerfRecorder;\n      /**\n       * Lazily evaluated state of the compilation.\n       *\n       * This is created on demand by calling `ensureAnalyzed`.\n       */\n\n      this.compilation = null;\n      /**\n       * Any diagnostics related to the construction of the compilation.\n       *\n       * These are diagnostics which arose during setup of the host and/or program.\n       */\n\n      this.constructionDiagnostics = [];\n      /**\n       * Non-template diagnostics related to the program itself. Does not include template\n       * diagnostics because the template type checker memoizes them itself.\n       *\n       * This is set by (and memoizes) `getNonTemplateDiagnostics`.\n       */\n\n      this.nonTemplateDiagnostics = null;\n      /**\n       * `NgCompiler` can be reused for multiple compilations (for resource-only changes), and each\n       * new compilation uses a fresh `PerfRecorder`. Thus, classes created with a lifespan of the\n       * `NgCompiler` use a `DelegatingPerfRecorder` so the `PerfRecorder` they write to can be updated\n       * with each fresh compilation.\n       */\n\n      this.delegatingPerfRecorder = new recorder_1.DelegatingPerfRecorder(this.perfRecorder);\n\n      (_a = this.constructionDiagnostics).push.apply(_a, tslib_1.__spread(this.adapter.constructionDiagnostics));\n\n      var incompatibleTypeCheckOptionsDiagnostic = verifyCompatibleTypeCheckOptions(this.options);\n\n      if (incompatibleTypeCheckOptionsDiagnostic !== null) {\n        this.constructionDiagnostics.push(incompatibleTypeCheckOptionsDiagnostic);\n      }\n\n      this.nextProgram = tsProgram;\n      this.closureCompilerEnabled = !!this.options.annotateForClosureCompiler;\n      this.entryPoint = adapter.entryPoint !== null ? typescript_1.getSourceFileOrNull(tsProgram, adapter.entryPoint) : null;\n      var moduleResolutionCache = ts.createModuleResolutionCache(this.adapter.getCurrentDirectory(), // doen't retain a reference to `this`, if other closures in the constructor here reference\n      // `this` internally then a closure created here would retain them. This can cause major\n      // memory leak issues since the `moduleResolutionCache` is a long-lived object and finds its\n      // way into all kinds of places inside TS internal objects.\n      this.adapter.getCanonicalFileName.bind(this.adapter));\n      this.moduleResolver = new imports_1.ModuleResolver(tsProgram, this.options, this.adapter, moduleResolutionCache);\n      this.resourceManager = new resource_1.AdapterResourceLoader(adapter, this.options);\n      this.cycleAnalyzer = new cycles_1.CycleAnalyzer(new cycles_1.ImportGraph(tsProgram.getTypeChecker(), this.delegatingPerfRecorder));\n      this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, tsProgram);\n      this.ignoreForDiagnostics = new Set(tsProgram.getSourceFiles().filter(function (sf) {\n        return _this.adapter.isShim(sf);\n      }));\n      this.ignoreForEmit = this.adapter.ignoreForEmit;\n      var dtsFileCount = 0;\n      var nonDtsFileCount = 0;\n\n      try {\n        for (var _c = tslib_1.__values(tsProgram.getSourceFiles()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var sf = _d.value;\n\n          if (sf.isDeclarationFile) {\n            dtsFileCount++;\n          } else {\n            nonDtsFileCount++;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      livePerfRecorder.eventCount(api_1.PerfEvent.InputDtsFile, dtsFileCount);\n      livePerfRecorder.eventCount(api_1.PerfEvent.InputTsFile, nonDtsFileCount);\n    }\n    /**\n     * Convert a `CompilationTicket` into an `NgCompiler` instance for the requested compilation.\n     *\n     * Depending on the nature of the compilation request, the `NgCompiler` instance may be reused\n     * from a previous compilation and updated with any changes, it may be a new instance which\n     * incrementally reuses state from a previous compilation, or it may represent a fresh\n     * compilation entirely.\n     */\n\n\n    NgCompiler.fromTicket = function (ticket, adapter) {\n      switch (ticket.kind) {\n        case CompilationTicketKind.Fresh:\n          return new NgCompiler(adapter, ticket.options, ticket.tsProgram, ticket.typeCheckingProgramStrategy, ticket.incrementalBuildStrategy, incremental_1.IncrementalDriver.fresh(ticket.tsProgram), ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);\n\n        case CompilationTicketKind.IncrementalTypeScript:\n          return new NgCompiler(adapter, ticket.options, ticket.newProgram, ticket.typeCheckingProgramStrategy, ticket.incrementalBuildStrategy, ticket.newDriver, ticket.enableTemplateTypeChecker, ticket.usePoisonedData, ticket.perfRecorder);\n\n        case CompilationTicketKind.IncrementalResource:\n          var compiler = ticket.compiler;\n          compiler.updateWithChangedResources(ticket.modifiedResourceFiles, ticket.perfRecorder);\n          return compiler;\n      }\n    };\n\n    Object.defineProperty(NgCompiler.prototype, \"perfRecorder\", {\n      get: function get() {\n        return this.livePerfRecorder;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    NgCompiler.prototype.updateWithChangedResources = function (changedResources, perfRecorder) {\n      var _this = this;\n\n      this.livePerfRecorder = perfRecorder;\n      this.delegatingPerfRecorder.target = perfRecorder;\n      perfRecorder.inPhase(api_1.PerfPhase.ResourceUpdate, function () {\n        var e_2, _a, e_3, _b, e_4, _c, e_5, _d;\n\n        if (_this.compilation === null) {\n          // Analysis hasn't happened yet, so no update is necessary - any changes to resources will\n          // be captured by the inital analysis pass itself.\n          return;\n        }\n\n        _this.resourceManager.invalidate();\n\n        var classesToUpdate = new Set();\n\n        try {\n          for (var changedResources_1 = tslib_1.__values(changedResources), changedResources_1_1 = changedResources_1.next(); !changedResources_1_1.done; changedResources_1_1 = changedResources_1.next()) {\n            var resourceFile = changedResources_1_1.value;\n\n            try {\n              for (var _e = (e_3 = void 0, tslib_1.__values(_this.getComponentsWithTemplateFile(resourceFile))), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var templateClass = _f.value;\n                classesToUpdate.add(templateClass);\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n\n            try {\n              for (var _g = (e_4 = void 0, tslib_1.__values(_this.getComponentsWithStyleFile(resourceFile))), _h = _g.next(); !_h.done; _h = _g.next()) {\n                var styleClass = _h.value;\n                classesToUpdate.add(styleClass);\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (_h && !_h.done && (_c = _g.return)) _c.call(_g);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (changedResources_1_1 && !changedResources_1_1.done && (_a = changedResources_1.return)) _a.call(changedResources_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        try {\n          for (var classesToUpdate_1 = tslib_1.__values(classesToUpdate), classesToUpdate_1_1 = classesToUpdate_1.next(); !classesToUpdate_1_1.done; classesToUpdate_1_1 = classesToUpdate_1.next()) {\n            var clazz = classesToUpdate_1_1.value;\n\n            _this.compilation.traitCompiler.updateResources(clazz);\n\n            if (!ts.isClassDeclaration(clazz)) {\n              continue;\n            }\n\n            _this.compilation.templateTypeChecker.invalidateClass(clazz);\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (classesToUpdate_1_1 && !classesToUpdate_1_1.done && (_d = classesToUpdate_1.return)) _d.call(classesToUpdate_1);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n      });\n    };\n    /**\n     * Get the resource dependencies of a file.\n     *\n     * If the file is not part of the compilation, an empty array will be returned.\n     */\n\n\n    NgCompiler.prototype.getResourceDependencies = function (file) {\n      this.ensureAnalyzed();\n      return this.incrementalDriver.depGraph.getResourceDependencies(file);\n    };\n    /**\n     * Get all Angular-related diagnostics for this compilation.\n     */\n\n\n    NgCompiler.prototype.getDiagnostics = function () {\n      return this.addMessageTextDetails(tslib_1.__spread(this.getNonTemplateDiagnostics(), this.getTemplateDiagnostics()));\n    };\n    /**\n     * Get all Angular-related diagnostics for this compilation.\n     *\n     * If a `ts.SourceFile` is passed, only diagnostics related to that file are returned.\n     */\n\n\n    NgCompiler.prototype.getDiagnosticsForFile = function (file, optimizeFor) {\n      return this.addMessageTextDetails(tslib_1.__spread(this.getNonTemplateDiagnostics().filter(function (diag) {\n        return diag.file === file;\n      }), this.getTemplateDiagnosticsForFile(file, optimizeFor)));\n    };\n    /**\n     * Add Angular.io error guide links to diagnostics for this compilation.\n     */\n\n\n    NgCompiler.prototype.addMessageTextDetails = function (diagnostics) {\n      return diagnostics.map(function (diag) {\n        if (diag.code && diagnostics_1.COMPILER_ERRORS_WITH_GUIDES.has(diagnostics_1.ngErrorCode(diag.code))) {\n          return tslib_1.__assign(tslib_1.__assign({}, diag), {\n            messageText: diag.messageText + (\". Find more at \" + diagnostics_1.ERROR_DETAILS_PAGE_BASE_URL + \"/NG\" + diagnostics_1.ngErrorCode(diag.code))\n          });\n        }\n\n        return diag;\n      });\n    };\n    /**\n     * Get all setup-related diagnostics for this compilation.\n     */\n\n\n    NgCompiler.prototype.getOptionDiagnostics = function () {\n      return this.constructionDiagnostics;\n    };\n    /**\n     * Get the `ts.Program` to use as a starting point when spawning a subsequent incremental\n     * compilation.\n     *\n     * The `NgCompiler` spawns an internal incremental TypeScript compilation (inheriting the\n     * consumer's `ts.Program` into a new one for the purposes of template type-checking). After this\n     * operation, the consumer's `ts.Program` is no longer usable for starting a new incremental\n     * compilation. `getNextProgram` retrieves the `ts.Program` which can be used instead.\n     */\n\n\n    NgCompiler.prototype.getNextProgram = function () {\n      return this.nextProgram;\n    };\n\n    NgCompiler.prototype.getTemplateTypeChecker = function () {\n      if (!this.enableTemplateTypeChecker) {\n        throw new Error('The `TemplateTypeChecker` does not work without `enableTemplateTypeChecker`.');\n      }\n\n      return this.ensureAnalyzed().templateTypeChecker;\n    };\n    /**\n     * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.\n     */\n\n\n    NgCompiler.prototype.getComponentsWithTemplateFile = function (templateFilePath) {\n      var resourceRegistry = this.ensureAnalyzed().resourceRegistry;\n      return resourceRegistry.getComponentsWithTemplate(file_system_1.resolve(templateFilePath));\n    };\n    /**\n     * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.\n     */\n\n\n    NgCompiler.prototype.getComponentsWithStyleFile = function (styleFilePath) {\n      var resourceRegistry = this.ensureAnalyzed().resourceRegistry;\n      return resourceRegistry.getComponentsWithStyle(file_system_1.resolve(styleFilePath));\n    };\n    /**\n     * Retrieves external resources for the given component.\n     */\n\n\n    NgCompiler.prototype.getComponentResources = function (classDecl) {\n      if (!reflection_1.isNamedClassDeclaration(classDecl)) {\n        return null;\n      }\n\n      var resourceRegistry = this.ensureAnalyzed().resourceRegistry;\n      var styles = resourceRegistry.getStyles(classDecl);\n      var template = resourceRegistry.getTemplate(classDecl);\n\n      if (template === null) {\n        return null;\n      }\n\n      return {\n        styles: styles,\n        template: template\n      };\n    };\n    /**\n     * Perform Angular's analysis step (as a precursor to `getDiagnostics` or `prepareEmit`)\n     * asynchronously.\n     *\n     * Normally, this operation happens lazily whenever `getDiagnostics` or `prepareEmit` are called.\n     * However, certain consumers may wish to allow for an asynchronous phase of analysis, where\n     * resources such as `styleUrls` are resolved asynchonously. In these cases `analyzeAsync` must be\n     * called first, and its `Promise` awaited prior to calling any other APIs of `NgCompiler`.\n     */\n\n\n    NgCompiler.prototype.analyzeAsync = function () {\n      return tslib_1.__awaiter(this, void 0, void 0, function () {\n        var _this = this;\n\n        return tslib_1.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (this.compilation !== null) {\n                return [2\n                /*return*/\n                ];\n              }\n\n              return [4\n              /*yield*/\n              , this.perfRecorder.inPhase(api_1.PerfPhase.Analysis, function () {\n                return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                  var promises, _a, _b, sf, analysisPromise;\n\n                  var e_6, _c;\n\n                  return tslib_1.__generator(this, function (_d) {\n                    switch (_d.label) {\n                      case 0:\n                        this.compilation = this.makeCompilation();\n                        promises = [];\n\n                        try {\n                          for (_a = tslib_1.__values(this.tsProgram.getSourceFiles()), _b = _a.next(); !_b.done; _b = _a.next()) {\n                            sf = _b.value;\n\n                            if (sf.isDeclarationFile) {\n                              continue;\n                            }\n\n                            analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);\n                            this.scanForMwp(sf);\n\n                            if (analysisPromise !== undefined) {\n                              promises.push(analysisPromise);\n                            }\n                          }\n                        } catch (e_6_1) {\n                          e_6 = {\n                            error: e_6_1\n                          };\n                        } finally {\n                          try {\n                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                          } finally {\n                            if (e_6) throw e_6.error;\n                          }\n                        }\n\n                        return [4\n                        /*yield*/\n                        , Promise.all(promises)];\n\n                      case 1:\n                        _d.sent();\n\n                        this.perfRecorder.memory(api_1.PerfCheckpoint.Analysis);\n                        this.resolveCompilation(this.compilation.traitCompiler);\n                        return [2\n                        /*return*/\n                        ];\n                    }\n                  });\n                });\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * List lazy routes detected during analysis.\n     *\n     * This can be called for one specific route, or to retrieve all top-level routes.\n     */\n\n\n    NgCompiler.prototype.listLazyRoutes = function (entryRoute) {\n      if (entryRoute) {\n        // htts://github.com/angular/angular/blob/50732e156/packages/compiler-cli/src/transformers/compiler_host.ts#L175-L188).\n        //\n        // `@angular/cli` will always call this API with an absolute path, so the resolution step is\n        // not necessary, but keeping it backwards compatible in case someone else is using the API.\n        // Relative entry paths are disallowed.\n        if (entryRoute.startsWith('.')) {\n          throw new Error(\"Failed to list lazy routes: Resolution of relative paths (\" + entryRoute + \") is not supported.\");\n        } // Non-relative entry paths fall into one of the following categories:\n        // - Absolute system paths (e.g. `/foo/bar/my-project/my-module`), which are unaffected by the\n        //   logic below.\n        // - Paths to enternal modules (e.g. `some-lib`).\n        // - Paths mapped to directories in `tsconfig.json` (e.g. `shared/my-module`).\n        //   (See https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping.)\n        //\n        // In all cases above, the `containingFile` argument is ignored, so we can just take the first\n        // of the root files.\n\n\n        var containingFile = this.tsProgram.getRootFileNames()[0];\n\n        var _a = tslib_1.__read(entryRoute.split('#'), 2),\n            entryPath = _a[0],\n            moduleName = _a[1];\n\n        var resolvedModule = typescript_1.resolveModuleName(entryPath, containingFile, this.options, this.adapter, null);\n\n        if (resolvedModule) {\n          entryRoute = routing_1.entryPointKeyFor(resolvedModule.resolvedFileName, moduleName);\n        }\n      }\n\n      var compilation = this.ensureAnalyzed();\n      return compilation.routeAnalyzer.listLazyRoutes(entryRoute);\n    };\n    /**\n     * Fetch transformers and other information which is necessary for a consumer to `emit` the\n     * program with Angular-added definitions.\n     */\n\n\n    NgCompiler.prototype.prepareEmit = function () {\n      var compilation = this.ensureAnalyzed();\n      var coreImportsFrom = compilation.isCore ? getR3SymbolsFile(this.tsProgram) : null;\n      var importRewriter;\n\n      if (coreImportsFrom !== null) {\n        importRewriter = new imports_1.R3SymbolsImportRewriter(coreImportsFrom.fileName);\n      } else {\n        importRewriter = new imports_1.NoopImportRewriter();\n      }\n\n      var defaultImportTracker = new imports_1.DefaultImportTracker();\n      var before = [transform_1.ivyTransformFactory(compilation.traitCompiler, compilation.reflector, importRewriter, defaultImportTracker, this.delegatingPerfRecorder, compilation.isCore, this.closureCompilerEnabled), transform_1.aliasTransformFactory(compilation.traitCompiler.exportStatements), defaultImportTracker.importPreservingTransformer()];\n      var afterDeclarations = [];\n\n      if (compilation.dtsTransforms !== null) {\n        afterDeclarations.push(transform_1.declarationTransformFactory(compilation.dtsTransforms, importRewriter));\n      } // Only add aliasing re-exports to the .d.ts output if the `AliasingHost` requests it.\n\n\n      if (compilation.aliasingHost !== null && compilation.aliasingHost.aliasExportsInDts) {\n        afterDeclarations.push(transform_1.aliasTransformFactory(compilation.traitCompiler.exportStatements));\n      }\n\n      if (this.adapter.factoryTracker !== null) {\n        before.push(shims_1.generatedFactoryTransform(this.adapter.factoryTracker.sourceInfo, importRewriter));\n      }\n\n      before.push(switch_1.ivySwitchTransform);\n      return {\n        transformers: {\n          before: before,\n          afterDeclarations: afterDeclarations\n        }\n      };\n    };\n    /**\n     * Run the indexing process and return a `Map` of all indexed components.\n     *\n     * See the `indexing` package for more details.\n     */\n\n\n    NgCompiler.prototype.getIndexedComponents = function () {\n      var compilation = this.ensureAnalyzed();\n      var context = new indexer_1.IndexingContext();\n      compilation.traitCompiler.index(context);\n      return indexer_1.generateAnalysis(context);\n    };\n\n    NgCompiler.prototype.ensureAnalyzed = function () {\n      if (this.compilation === null) {\n        this.analyzeSync();\n      }\n\n      return this.compilation;\n    };\n\n    NgCompiler.prototype.analyzeSync = function () {\n      var _this = this;\n\n      this.perfRecorder.inPhase(api_1.PerfPhase.Analysis, function () {\n        var e_7, _a;\n\n        _this.compilation = _this.makeCompilation();\n\n        try {\n          for (var _b = tslib_1.__values(_this.tsProgram.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var sf = _c.value;\n\n            if (sf.isDeclarationFile) {\n              continue;\n            }\n\n            _this.compilation.traitCompiler.analyzeSync(sf);\n\n            _this.scanForMwp(sf);\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n\n        _this.perfRecorder.memory(api_1.PerfCheckpoint.Analysis);\n\n        _this.resolveCompilation(_this.compilation.traitCompiler);\n      });\n    };\n\n    NgCompiler.prototype.resolveCompilation = function (traitCompiler) {\n      var _this = this;\n\n      this.perfRecorder.inPhase(api_1.PerfPhase.Resolve, function () {\n        traitCompiler.resolve(); // At this point, analysis is complete and the compiler can now calculate which files need to\n        // be emitted, so do that.\n\n        _this.incrementalDriver.recordSuccessfulAnalysis(traitCompiler);\n\n        _this.perfRecorder.memory(api_1.PerfCheckpoint.Resolve);\n      });\n    };\n\n    Object.defineProperty(NgCompiler.prototype, \"fullTemplateTypeCheck\", {\n      get: function get() {\n        // Determine the strictness level of type checking based on compiler options. As\n        // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.\n        // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`\n        // is not disabled when `strictTemplates` is enabled.\n        var strictTemplates = !!this.options.strictTemplates;\n        return strictTemplates || !!this.options.fullTemplateTypeCheck;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    NgCompiler.prototype.getTypeCheckingConfig = function () {\n      // Determine the strictness level of type checking based on compiler options. As\n      // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.\n      // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`\n      // is not disabled when `strictTemplates` is enabled.\n      var strictTemplates = !!this.options.strictTemplates;\n      var useInlineTypeConstructors = this.typeCheckingProgramStrategy.supportsInlineOperations; // First select a type-checking configuration, based on whether full template type-checking is\n      // requested.\n\n      var typeCheckingConfig;\n\n      if (this.fullTemplateTypeCheck) {\n        typeCheckingConfig = {\n          applyTemplateContextGuards: strictTemplates,\n          checkQueries: false,\n          checkTemplateBodies: true,\n          alwaysCheckSchemaInTemplateBodies: true,\n          checkTypeOfInputBindings: strictTemplates,\n          honorAccessModifiersForInputBindings: false,\n          strictNullInputBindings: strictTemplates,\n          checkTypeOfAttributes: strictTemplates,\n          // Even in full template type-checking mode, DOM binding checks are not quite ready yet.\n          checkTypeOfDomBindings: false,\n          checkTypeOfOutputEvents: strictTemplates,\n          checkTypeOfAnimationEvents: strictTemplates,\n          // Checking of DOM events currently has an adverse effect on developer experience,\n          // e.g. for `<input (blur)=\"update($event.target.value)\">` enabling this check results in:\n          // - error TS2531: Object is possibly 'null'.\n          // - error TS2339: Property 'value' does not exist on type 'EventTarget'.\n          checkTypeOfDomEvents: strictTemplates,\n          checkTypeOfDomReferences: strictTemplates,\n          // Non-DOM references have the correct type in View Engine so there is no strictness flag.\n          checkTypeOfNonDomReferences: true,\n          // Pipes are checked in View Engine so there is no strictness flag.\n          checkTypeOfPipes: true,\n          strictSafeNavigationTypes: strictTemplates,\n          useContextGenericType: strictTemplates,\n          strictLiteralTypes: true,\n          enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n          useInlineTypeConstructors: useInlineTypeConstructors,\n          // Warnings for suboptimal type inference are only enabled if in Language Service mode\n          // (providing the full TemplateTypeChecker API) and if strict mode is not enabled. In strict\n          // mode, the user is in full control of type inference.\n          suggestionsForSuboptimalTypeInference: this.enableTemplateTypeChecker && !strictTemplates\n        };\n      } else {\n        typeCheckingConfig = {\n          applyTemplateContextGuards: false,\n          checkQueries: false,\n          checkTemplateBodies: false,\n          // Enable deep schema checking in \"basic\" template type-checking mode only if Closure\n          // compilation is requested, which is a good proxy for \"only in google3\".\n          alwaysCheckSchemaInTemplateBodies: this.closureCompilerEnabled,\n          checkTypeOfInputBindings: false,\n          strictNullInputBindings: false,\n          honorAccessModifiersForInputBindings: false,\n          checkTypeOfAttributes: false,\n          checkTypeOfDomBindings: false,\n          checkTypeOfOutputEvents: false,\n          checkTypeOfAnimationEvents: false,\n          checkTypeOfDomEvents: false,\n          checkTypeOfDomReferences: false,\n          checkTypeOfNonDomReferences: false,\n          checkTypeOfPipes: false,\n          strictSafeNavigationTypes: false,\n          useContextGenericType: false,\n          strictLiteralTypes: false,\n          enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n          useInlineTypeConstructors: useInlineTypeConstructors,\n          // In \"basic\" template type-checking mode, no warnings are produced since most things are\n          // not checked anyways.\n          suggestionsForSuboptimalTypeInference: false\n        };\n      } // Apply explicitly configured strictness flags on top of the default configuration\n      // based on \"fullTemplateTypeCheck\".\n\n\n      if (this.options.strictInputTypes !== undefined) {\n        typeCheckingConfig.checkTypeOfInputBindings = this.options.strictInputTypes;\n        typeCheckingConfig.applyTemplateContextGuards = this.options.strictInputTypes;\n      }\n\n      if (this.options.strictInputAccessModifiers !== undefined) {\n        typeCheckingConfig.honorAccessModifiersForInputBindings = this.options.strictInputAccessModifiers;\n      }\n\n      if (this.options.strictNullInputTypes !== undefined) {\n        typeCheckingConfig.strictNullInputBindings = this.options.strictNullInputTypes;\n      }\n\n      if (this.options.strictOutputEventTypes !== undefined) {\n        typeCheckingConfig.checkTypeOfOutputEvents = this.options.strictOutputEventTypes;\n        typeCheckingConfig.checkTypeOfAnimationEvents = this.options.strictOutputEventTypes;\n      }\n\n      if (this.options.strictDomEventTypes !== undefined) {\n        typeCheckingConfig.checkTypeOfDomEvents = this.options.strictDomEventTypes;\n      }\n\n      if (this.options.strictSafeNavigationTypes !== undefined) {\n        typeCheckingConfig.strictSafeNavigationTypes = this.options.strictSafeNavigationTypes;\n      }\n\n      if (this.options.strictDomLocalRefTypes !== undefined) {\n        typeCheckingConfig.checkTypeOfDomReferences = this.options.strictDomLocalRefTypes;\n      }\n\n      if (this.options.strictAttributeTypes !== undefined) {\n        typeCheckingConfig.checkTypeOfAttributes = this.options.strictAttributeTypes;\n      }\n\n      if (this.options.strictContextGenerics !== undefined) {\n        typeCheckingConfig.useContextGenericType = this.options.strictContextGenerics;\n      }\n\n      if (this.options.strictLiteralTypes !== undefined) {\n        typeCheckingConfig.strictLiteralTypes = this.options.strictLiteralTypes;\n      }\n\n      return typeCheckingConfig;\n    };\n\n    NgCompiler.prototype.getTemplateDiagnostics = function () {\n      var e_8, _a;\n\n      var compilation = this.ensureAnalyzed(); // Get the diagnostics.\n\n      var diagnostics = [];\n\n      try {\n        for (var _b = tslib_1.__values(this.tsProgram.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var sf = _c.value;\n\n          if (sf.isDeclarationFile || this.adapter.isShim(sf)) {\n            continue;\n          }\n\n          diagnostics.push.apply(diagnostics, tslib_1.__spread(compilation.templateTypeChecker.getDiagnosticsForFile(sf, api_2.OptimizeFor.WholeProgram)));\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n\n      var program = this.typeCheckingProgramStrategy.getProgram();\n      this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n      this.nextProgram = program;\n      return diagnostics;\n    };\n\n    NgCompiler.prototype.getTemplateDiagnosticsForFile = function (sf, optimizeFor) {\n      var compilation = this.ensureAnalyzed(); // Get the diagnostics.\n\n      var diagnostics = [];\n\n      if (!sf.isDeclarationFile && !this.adapter.isShim(sf)) {\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(compilation.templateTypeChecker.getDiagnosticsForFile(sf, optimizeFor)));\n      }\n\n      var program = this.typeCheckingProgramStrategy.getProgram();\n      this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n      this.nextProgram = program;\n      return diagnostics;\n    };\n\n    NgCompiler.prototype.getNonTemplateDiagnostics = function () {\n      var _a;\n\n      if (this.nonTemplateDiagnostics === null) {\n        var compilation = this.ensureAnalyzed();\n        this.nonTemplateDiagnostics = tslib_1.__spread(compilation.traitCompiler.diagnostics);\n\n        if (this.entryPoint !== null && compilation.exportReferenceGraph !== null) {\n          (_a = this.nonTemplateDiagnostics).push.apply(_a, tslib_1.__spread(entry_point_1.checkForPrivateExports(this.entryPoint, this.tsProgram.getTypeChecker(), compilation.exportReferenceGraph)));\n        }\n      }\n\n      return this.nonTemplateDiagnostics;\n    };\n\n    NgCompiler.prototype.scanForMwp = function (sf) {\n      var _this = this;\n\n      this.compilation.mwpScanner.scan(sf, {\n        addTypeReplacement: function addTypeReplacement(node, type) {\n          // Only obtain the return type transform for the source file once there's a type to replace,\n          // so that no transform is allocated when there's nothing to do.\n          _this.compilation.dtsTransforms.getReturnTypeTransform(sf).addTypeReplacement(node, type);\n        }\n      });\n    };\n\n    NgCompiler.prototype.makeCompilation = function () {\n      var checker = this.tsProgram.getTypeChecker();\n      var reflector = new reflection_1.TypeScriptReflectionHost(checker); // Construct the ReferenceEmitter.\n\n      var refEmitter;\n      var aliasingHost = null;\n\n      if (this.adapter.unifiedModulesHost === null || !this.options._useHostForImportGeneration) {\n        var localImportStrategy = void 0; // The strategy used for local, in-project imports depends on whether TS has been configured\n        // with rootDirs. If so, then multiple directories may be mapped in the same \"module\n        // namespace\" and the logic of `LogicalProjectStrategy` is required to generate correct\n        // imports which may cross these multiple directories. Otherwise, plain relative imports are\n        // sufficient.\n\n        if (this.options.rootDir !== undefined || this.options.rootDirs !== undefined && this.options.rootDirs.length > 0) {\n          // rootDirs logic is in effect - use the `LogicalProjectStrategy` for in-project relative\n          // imports.\n          localImportStrategy = new imports_1.LogicalProjectStrategy(reflector, new file_system_1.LogicalFileSystem(tslib_1.__spread(this.adapter.rootDirs), this.adapter));\n        } else {\n          // Plain relative imports are all that's needed.\n          localImportStrategy = new imports_1.RelativePathStrategy(reflector);\n        } // The CompilerHost doesn't have fileNameToModuleName, so build an NPM-centric reference\n        // resolution strategy.\n\n\n        refEmitter = new imports_1.ReferenceEmitter([// First, try to use local identifiers if available.\n        new imports_1.LocalIdentifierStrategy(), // Next, attempt to use an absolute import.\n        new imports_1.AbsoluteModuleStrategy(this.tsProgram, checker, this.moduleResolver, reflector), // Finally, check if the reference is being written into a file within the project's .ts\n        // sources, and use a relative import if so. If this fails, ReferenceEmitter will throw\n        // an error.\n        localImportStrategy]); // If an entrypoint is present, then all user imports should be directed through the\n        // entrypoint and private exports are not needed. The compiler will validate that all publicly\n        // visible directives/pipes are importable via this entrypoint.\n\n        if (this.entryPoint === null && this.options.generateDeepReexports === true) {\n          // No entrypoint is present and deep re-exports were requested, so configure the aliasing\n          // system to generate them.\n          aliasingHost = new imports_1.PrivateExportAliasingHost(reflector);\n        }\n      } else {\n        // The CompilerHost supports fileNameToModuleName, so use that to emit imports.\n        refEmitter = new imports_1.ReferenceEmitter([// First, try to use local identifiers if available.\n        new imports_1.LocalIdentifierStrategy(), // Then use aliased references (this is a workaround to StrictDeps checks).\n        new imports_1.AliasStrategy(), // Then use fileNameToModuleName to emit imports.\n        new imports_1.UnifiedModulesStrategy(reflector, this.adapter.unifiedModulesHost)]);\n        aliasingHost = new imports_1.UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);\n      }\n\n      var evaluator = new partial_evaluator_1.PartialEvaluator(reflector, checker, this.incrementalDriver.depGraph);\n      var dtsReader = new metadata_1.DtsMetadataReader(checker, reflector);\n      var localMetaRegistry = new metadata_1.LocalMetadataRegistry();\n      var localMetaReader = localMetaRegistry;\n      var depScopeReader = new scope_1.MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);\n      var scopeRegistry = new scope_1.LocalModuleScopeRegistry(localMetaReader, depScopeReader, refEmitter, aliasingHost);\n      var scopeReader = scopeRegistry;\n      var semanticDepGraphUpdater = this.incrementalDriver.getSemanticDepGraphUpdater();\n      var metaRegistry = new metadata_1.CompoundMetadataRegistry([localMetaRegistry, scopeRegistry]);\n      var injectableRegistry = new metadata_1.InjectableClassRegistry(reflector);\n      var metaReader = new metadata_1.CompoundMetadataReader([localMetaReader, dtsReader]);\n      var typeCheckScopeRegistry = new scope_1.TypeCheckScopeRegistry(scopeReader, metaReader); // If a flat module entrypoint was specified, then track references via a `ReferenceGraph` in\n      // order to produce proper diagnostics for incorrectly exported directives/pipes/etc. If there\n      // is no flat module entrypoint then don't pay the cost of tracking references.\n\n      var referencesRegistry;\n      var exportReferenceGraph = null;\n\n      if (this.entryPoint !== null) {\n        exportReferenceGraph = new entry_point_1.ReferenceGraph();\n        referencesRegistry = new ReferenceGraphAdapter(exportReferenceGraph);\n      } else {\n        referencesRegistry = new annotations_1.NoopReferencesRegistry();\n      }\n\n      var routeAnalyzer = new routing_1.NgModuleRouteAnalyzer(this.moduleResolver, evaluator);\n      var dtsTransforms = new transform_1.DtsTransformRegistry();\n      var mwpScanner = new modulewithproviders_1.ModuleWithProvidersScanner(reflector, evaluator, refEmitter);\n      var isCore = isAngularCorePackage(this.tsProgram);\n      var resourceRegistry = new metadata_1.ResourceRegistry();\n      var compilationMode = this.options.compilationMode === 'partial' ? transform_1.CompilationMode.PARTIAL : transform_1.CompilationMode.FULL; // Cycles are handled in full compilation mode by \"remote scoping\".\n      // \"Remote scoping\" does not work well with tree shaking for libraries.\n      // So in partial compilation mode, when building a library, a cycle will cause an error.\n\n      var cycleHandlingStrategy = compilationMode === transform_1.CompilationMode.FULL ? 0\n      /* UseRemoteScoping */\n      : 1\n      /* Error */\n      ; // Set up the IvyCompilation, which manages state for the Ivy transformer.\n\n      var handlers = [new annotations_1.ComponentDecoratorHandler(reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, this.resourceManager, this.adapter.rootDirs, this.options.preserveWhitespaces || false, this.options.i18nUseExternalIds !== false, this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData, this.options.i18nNormalizeLineEndingsInICUs, this.moduleResolver, this.cycleAnalyzer, cycleHandlingStrategy, refEmitter, this.incrementalDriver.depGraph, injectableRegistry, semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder), // TODO(alxhub): understand why the cast here is necessary (something to do with `null`\n      // not being assignable to `unknown` when wrapped in `Readonly`).\n      // clang-format off\n      new annotations_1.DirectiveDecoratorHandler(reflector, evaluator, metaRegistry, scopeRegistry, metaReader, injectableRegistry, isCore, semanticDepGraphUpdater, this.closureCompilerEnabled, config_1.compileUndecoratedClassesWithAngularFeatures, this.delegatingPerfRecorder), // clang-format on\n      // Pipe handler must be before injectable handler in list so pipe factories are printed\n      // before injectable factories (so injectable factories can delegate to them)\n      new annotations_1.PipeDecoratorHandler(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, this.delegatingPerfRecorder), new annotations_1.InjectableDecoratorHandler(reflector, isCore, this.options.strictInjectionParameters || false, injectableRegistry, this.delegatingPerfRecorder), new annotations_1.NgModuleDecoratorHandler(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore, routeAnalyzer, refEmitter, this.adapter.factoryTracker, this.closureCompilerEnabled, injectableRegistry, this.delegatingPerfRecorder, this.options.i18nInLocale)];\n      var traitCompiler = new transform_1.TraitCompiler(handlers, reflector, this.delegatingPerfRecorder, this.incrementalDriver, this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms, semanticDepGraphUpdater);\n      var templateTypeChecker = new typecheck_1.TemplateTypeCheckerImpl(this.tsProgram, this.typeCheckingProgramStrategy, traitCompiler, this.getTypeCheckingConfig(), refEmitter, reflector, this.adapter, this.incrementalDriver, scopeRegistry, typeCheckScopeRegistry, this.delegatingPerfRecorder);\n      return {\n        isCore: isCore,\n        traitCompiler: traitCompiler,\n        reflector: reflector,\n        scopeRegistry: scopeRegistry,\n        dtsTransforms: dtsTransforms,\n        exportReferenceGraph: exportReferenceGraph,\n        routeAnalyzer: routeAnalyzer,\n        mwpScanner: mwpScanner,\n        metaReader: metaReader,\n        typeCheckScopeRegistry: typeCheckScopeRegistry,\n        aliasingHost: aliasingHost,\n        refEmitter: refEmitter,\n        templateTypeChecker: templateTypeChecker,\n        resourceRegistry: resourceRegistry\n      };\n    };\n\n    return NgCompiler;\n  }();\n\n  exports.NgCompiler = NgCompiler;\n  /**\n   * Determine if the given `Program` is @angular/core.\n   */\n\n  function isAngularCorePackage(program) {\n    // Look for its_just_angular.ts somewhere in the program.\n    var r3Symbols = getR3SymbolsFile(program);\n\n    if (r3Symbols === null) {\n      return false;\n    } // Look for the constant ITS_JUST_ANGULAR in that file.\n\n\n    return r3Symbols.statements.some(function (stmt) {\n      // The statement must be a variable declaration statement.\n      if (!ts.isVariableStatement(stmt)) {\n        return false;\n      } // It must be exported.\n\n\n      if (stmt.modifiers === undefined || !stmt.modifiers.some(function (mod) {\n        return mod.kind === ts.SyntaxKind.ExportKeyword;\n      })) {\n        return false;\n      } // It must declare ITS_JUST_ANGULAR.\n\n\n      return stmt.declarationList.declarations.some(function (decl) {\n        // The declaration must match the name.\n        if (!ts.isIdentifier(decl.name) || decl.name.text !== 'ITS_JUST_ANGULAR') {\n          return false;\n        } // It must initialize the variable to true.\n\n\n        if (decl.initializer === undefined || decl.initializer.kind !== ts.SyntaxKind.TrueKeyword) {\n          return false;\n        } // This definition matches.\n\n\n        return true;\n      });\n    });\n  }\n\n  exports.isAngularCorePackage = isAngularCorePackage;\n  /**\n   * Find the 'r3_symbols.ts' file in the given `Program`, or return `null` if it wasn't there.\n   */\n\n  function getR3SymbolsFile(program) {\n    return program.getSourceFiles().find(function (file) {\n      return file.fileName.indexOf('r3_symbols.ts') >= 0;\n    }) || null;\n  }\n  /**\n   * Since \"strictTemplates\" is a true superset of type checking capabilities compared to\n   * \"fullTemplateTypeCheck\", it is required that the latter is not explicitly disabled if the\n   * former is enabled.\n   */\n\n\n  function verifyCompatibleTypeCheckOptions(options) {\n    if (options.fullTemplateTypeCheck === false && options.strictTemplates === true) {\n      return {\n        category: ts.DiagnosticCategory.Error,\n        code: diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK),\n        file: undefined,\n        start: undefined,\n        length: undefined,\n        messageText: \"Angular compiler option \\\"strictTemplates\\\" is enabled, however \\\"fullTemplateTypeCheck\\\" is disabled.\\n\\nHaving the \\\"strictTemplates\\\" flag enabled implies that \\\"fullTemplateTypeCheck\\\" is also enabled, so\\nthe latter can not be explicitly disabled.\\n\\nOne of the following actions is required:\\n1. Remove the \\\"fullTemplateTypeCheck\\\" option.\\n2. Remove \\\"strictTemplates\\\" or set it to 'false'.\\n\\nMore information about the template type checking compiler options can be found in the documentation:\\nhttps://v9.angular.io/guide/template-typecheck#template-type-checking\"\n      };\n    }\n\n    return null;\n  }\n\n  var ReferenceGraphAdapter =\n  /** @class */\n  function () {\n    function ReferenceGraphAdapter(graph) {\n      this.graph = graph;\n    }\n\n    ReferenceGraphAdapter.prototype.add = function (source) {\n      var e_9, _a;\n\n      var references = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        references[_i - 1] = arguments[_i];\n      }\n\n      try {\n        for (var references_1 = tslib_1.__values(references), references_1_1 = references_1.next(); !references_1_1.done; references_1_1 = references_1.next()) {\n          var node = references_1_1.value.node;\n          var sourceFile = node.getSourceFile();\n\n          if (sourceFile === undefined) {\n            sourceFile = ts.getOriginalNode(node).getSourceFile();\n          } // Only record local references (not references into .d.ts files).\n\n\n          if (sourceFile === undefined || !typescript_1.isDtsPath(sourceFile.fileName)) {\n            this.graph.add(source, node);\n          }\n        }\n      } catch (e_9_1) {\n        e_9 = {\n          error: e_9_1\n        };\n      } finally {\n        try {\n          if (references_1_1 && !references_1_1.done && (_a = references_1.return)) _a.call(references_1);\n        } finally {\n          if (e_9) throw e_9.error;\n        }\n      }\n    };\n\n    return ReferenceGraphAdapter;\n  }();\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/core/src/compiler.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAGH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,wCAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,0CAAA,CAAA;;AACA,MAAA,qBAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AACA,MAAA,mBAAA,GAAA,OAAA,CAAA,mDAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,sCAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,mDAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,4CAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,0CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,wCAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,2CAAA,CAAA;;AACA,MAAA,WAAA,GAAA,OAAA,CAAA,2CAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,+CAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AAGA,MAAA,QAAA,GAAA,OAAA,CAAA,iDAAA,CAAA;AAyBA;;AAEG;;;AACH,MAAY,qBAAZ;;AAAA,GAAA,UAAY,qBAAZ,EAAiC;AAC/B,IAAA,qBAAA,CAAA,qBAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACA,IAAA,qBAAA,CAAA,qBAAA,CAAA,uBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,uBAAA;AACA,IAAA,qBAAA,CAAA,qBAAA,CAAA,qBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,qBAAA;AACD,GAJD,EAAY,qBAAqB,GAArB,OAAA,CAAA,qBAAA,KAAA,OAAA,CAAA,qBAAA,GAAqB,EAArB,CAAZ;AAqDA;;AAEG;;;AACH,WAAgB,sBAAhB,CACI,SADJ,EAC2B,OAD3B,EAEI,wBAFJ,EAGI,2BAHJ,EAG8D,YAH9D,EAII,yBAJJ,EAIwC,eAJxC,EAIgE;AAC9D,WAAO;AACL,MAAA,IAAI,EAAE,qBAAqB,CAAC,KADvB;AAEL,MAAA,SAAS,EAAA,SAFJ;AAGL,MAAA,OAAO,EAAA,OAHF;AAIL,MAAA,wBAAwB,EAAA,wBAJnB;AAKL,MAAA,2BAA2B,EAAA,2BALtB;AAML,MAAA,yBAAyB,EAAA,yBANpB;AAOL,MAAA,eAAe,EAAA,eAPV;AAQL,MAAA,YAAY,EAAE,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAA,YAAA,GAAgB,MAAA,CAAA,kBAAA,CAAmB,WAAnB;AARzB,KAAP;AAUD;;AAfD,EAAA,OAAA,CAAA,sBAAA,GAAA,sBAAA;AAiBA;;;AAGG;;AACH,WAAgB,6BAAhB,CACI,WADJ,EAC6B,UAD7B,EAEI,wBAFJ,EAGI,2BAHJ,EAG8D,qBAH9D,EAII,YAJJ,EAIyC;AACvC,QAAM,UAAU,GAAG,WAAW,CAAC,cAAZ,EAAnB;AACA,QAAM,SAAS,GAAG,WAAW,CAAC,mBAAZ,CAAgC,oBAAhC,CAAqD,UAArD,CAAlB;;AACA,QAAI,SAAS,KAAK,IAAlB,EAAwB;AACtB;AACA;AACA,aAAO,sBAAsB,CACzB,UADyB,EACb,WAAW,CAAC,OADC,EACQ,wBADR,EACkC,2BADlC,EAEzB,YAFyB,EAEX,WAAW,CAAC,yBAFD,EAE4B,WAAW,CAAC,eAFxC,CAA7B;AAGD;;AAED,QAAI,YAAY,KAAK,IAArB,EAA2B;AACzB,MAAA,YAAY,GAAG,MAAA,CAAA,kBAAA,CAAmB,WAAnB,EAAf;AACD;;AAED,QAAM,SAAS,GAAG,aAAA,CAAA,iBAAA,CAAkB,SAAlB,CACd,UADc,EACF,SADE,EACS,UADT,EACqB,qBADrB,EAC4C,YAD5C,CAAlB;AAGA,WAAO;AACL,MAAA,IAAI,EAAE,qBAAqB,CAAC,qBADvB;AAEL,MAAA,yBAAyB,EAAE,WAAW,CAAC,yBAFlC;AAGL,MAAA,eAAe,EAAE,WAAW,CAAC,eAHxB;AAIL,MAAA,OAAO,EAAE,WAAW,CAAC,OAJhB;AAKL,MAAA,wBAAwB,EAAA,wBALnB;AAML,MAAA,2BAA2B,EAAA,2BANtB;AAOL,MAAA,SAAS,EAAA,SAPJ;AAQL,MAAA,UAAU,EAAA,UARL;AASL,MAAA,UAAU,EAAA,UATL;AAUL,MAAA,YAAY,EAAA;AAVP,KAAP;AAYD;;AAlCD,EAAA,OAAA,CAAA,6BAAA,GAAA,6BAAA;AAoCA;;;AAGG;;AACH,WAAgB,2BAAhB,CACI,UADJ,EAC4B,SAD5B,EAC0D,UAD1D,EAEI,OAFJ,EAEgC,wBAFhC,EAGI,2BAHJ,EAG8D,qBAH9D,EAII,YAJJ,EAI2C,yBAJ3C,EAKI,eALJ,EAK4B;AAC1B,QAAI,YAAY,KAAK,IAArB,EAA2B;AACzB,MAAA,YAAY,GAAG,MAAA,CAAA,kBAAA,CAAmB,WAAnB,EAAf;AACD;;AAED,QAAM,SAAS,GAAG,aAAA,CAAA,iBAAA,CAAkB,SAAlB,CACd,UADc,EACF,SADE,EACS,UADT,EACqB,qBADrB,EAC4C,YAD5C,CAAlB;AAEA,WAAO;AACL,MAAA,IAAI,EAAE,qBAAqB,CAAC,qBADvB;AAEL,MAAA,UAAU,EAAA,UAFL;AAGL,MAAA,UAAU,EAAA,UAHL;AAIL,MAAA,OAAO,EAAA,OAJF;AAKL,MAAA,wBAAwB,EAAA,wBALnB;AAML,MAAA,SAAS,EAAA,SANJ;AAOL,MAAA,2BAA2B,EAAA,2BAPtB;AAQL,MAAA,yBAAyB,EAAA,yBARpB;AASL,MAAA,eAAe,EAAA,eATV;AAUL,MAAA,YAAY,EAAA;AAVP,KAAP;AAYD;;AAxBD,EAAA,OAAA,CAAA,2BAAA,GAAA,2BAAA;;AA0BA,WAAgB,oBAAhB,CAAqC,QAArC,EAA2D,qBAA3D,EAA6F;AAE3F,WAAO;AACL,MAAA,IAAI,EAAE,qBAAqB,CAAC,mBADvB;AAEL,MAAA,QAAQ,EAAA,QAFH;AAGL,MAAA,qBAAqB,EAAA,qBAHhB;AAIL,MAAA,YAAY,EAAE,MAAA,CAAA,kBAAA,CAAmB,WAAnB;AAJT,KAAP;AAMD;;AARD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA;AAWA;;;;;;;;;;;AAWG;;AACH,MAAA,UAAA;AAAA;AAAA,cAAA;AAiFE,aAAA,UAAA,CACY,OADZ,EAEa,OAFb,EAGY,SAHZ,EAIa,2BAJb,EAKa,mBALb,EAMa,iBANb,EAOa,yBAPb,EAQa,eARb,EASY,gBATZ,EASgD;;;AAThD,UAAA,KAAA,GAAA,IAAA;;AACY,WAAA,OAAA,GAAA,OAAA;AACC,WAAA,OAAA,GAAA,OAAA;AACD,WAAA,SAAA,GAAA,SAAA;AACC,WAAA,2BAAA,GAAA,2BAAA;AACA,WAAA,mBAAA,GAAA,mBAAA;AACA,WAAA,iBAAA,GAAA,iBAAA;AACA,WAAA,yBAAA,GAAA,yBAAA;AACA,WAAA,eAAA,GAAA,eAAA;AACD,WAAA,gBAAA,GAAA,gBAAA;AAzFZ;;;;AAIG;;AACK,WAAA,WAAA,GAAyC,IAAzC;AAER;;;;AAIG;;AACK,WAAA,uBAAA,GAA2C,EAA3C;AAER;;;;;AAKG;;AACK,WAAA,sBAAA,GAA+C,IAA/C;AAWR;;;;;AAKG;;AACK,WAAA,sBAAA,GAAyB,IAAI,UAAA,CAAA,sBAAJ,CAA2B,KAAK,YAAhC,CAAzB;;AAsDN,OAAA,EAAA,GAAA,KAAK,uBAAL,EAA6B,IAA7B,CAAiC,KAAjC,CAAiC,EAAjC,EAAiC,OAAA,CAAA,QAAA,CAAI,KAAK,OAAL,CAAa,uBAAjB,CAAjC;;AACA,UAAM,sCAAsC,GAAG,gCAAgC,CAAC,KAAK,OAAN,CAA/E;;AACA,UAAI,sCAAsC,KAAK,IAA/C,EAAqD;AACnD,aAAK,uBAAL,CAA6B,IAA7B,CAAkC,sCAAlC;AACD;;AAED,WAAK,WAAL,GAAmB,SAAnB;AACA,WAAK,sBAAL,GAA8B,CAAC,CAAC,KAAK,OAAL,CAAa,0BAA7C;AAEA,WAAK,UAAL,GACI,OAAO,CAAC,UAAR,KAAuB,IAAvB,GAA8B,YAAA,CAAA,mBAAA,CAAoB,SAApB,EAA+B,OAAO,CAAC,UAAvC,CAA9B,GAAmF,IADvF;AAGA,UAAM,qBAAqB,GAAG,EAAE,CAAC,2BAAH,CAC1B,KAAK,OAAL,CAAa,mBAAb,EAD0B,EAE1B;AACA;AACA;AACA;AACA,WAAK,OAAL,CAAa,oBAAb,CAAkC,IAAlC,CAAuC,KAAK,OAA5C,CAN0B,CAA9B;AAOA,WAAK,cAAL,GACI,IAAI,SAAA,CAAA,cAAJ,CAAmB,SAAnB,EAA8B,KAAK,OAAnC,EAA4C,KAAK,OAAjD,EAA0D,qBAA1D,CADJ;AAEA,WAAK,eAAL,GAAuB,IAAI,UAAA,CAAA,qBAAJ,CAA0B,OAA1B,EAAmC,KAAK,OAAxC,CAAvB;AACA,WAAK,aAAL,GACI,IAAI,QAAA,CAAA,aAAJ,CAAkB,IAAI,QAAA,CAAA,WAAJ,CAAgB,SAAS,CAAC,cAAV,EAAhB,EAA4C,KAAK,sBAAjD,CAAlB,CADJ;AAEA,WAAK,mBAAL,CAAyB,oBAAzB,CAA8C,KAAK,iBAAnD,EAAsE,SAAtE;AAEA,WAAK,oBAAL,GACI,IAAI,GAAJ,CAAQ,SAAS,CAAC,cAAV,GAA2B,MAA3B,CAAkC,UAAA,EAAA,EAAE;AAAI,eAAA,KAAI,CAAC,OAAL,CAAa,MAAb,CAAA,EAAA,CAAA;AAAuB,OAA/D,CAAR,CADJ;AAEA,WAAK,aAAL,GAAqB,KAAK,OAAL,CAAa,aAAlC;AAEA,UAAI,YAAY,GAAG,CAAnB;AACA,UAAI,eAAe,GAAG,CAAtB;;;AACA,aAAiB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,SAAS,CAAC,cAAV,EAAA,CAAA,EAA0B,EAAA,GAAA,EAAA,CAAA,IAAA,EAA3C,EAA2C,CAAA,EAAA,CAAA,IAA3C,EAA2C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA3C,EAA6C;AAAxC,cAAM,EAAE,GAAA,EAAA,CAAA,KAAR;;AACH,cAAI,EAAE,CAAC,iBAAP,EAA0B;AACxB,YAAA,YAAY;AACb,WAFD,MAEO;AACL,YAAA,eAAe;AAChB;AACF;;;;;;;;;;;;;AAED,MAAA,gBAAgB,CAAC,UAAjB,CAA4B,KAAA,CAAA,SAAA,CAAU,YAAtC,EAAoD,YAApD;AACA,MAAA,gBAAgB,CAAC,UAAjB,CAA4B,KAAA,CAAA,SAAA,CAAU,WAAtC,EAAmD,eAAnD;AACD;AA9FD;;;;;;;AAOG;;;AACI,IAAA,UAAA,CAAA,UAAA,GAAP,UAAkB,MAAlB,EAA6C,OAA7C,EAAuE;AACrE,cAAQ,MAAM,CAAC,IAAf;AACE,aAAK,qBAAqB,CAAC,KAA3B;AACE,iBAAO,IAAI,UAAJ,CACH,OADG,EAEH,MAAM,CAAC,OAFJ,EAGH,MAAM,CAAC,SAHJ,EAIH,MAAM,CAAC,2BAJJ,EAKH,MAAM,CAAC,wBALJ,EAMH,aAAA,CAAA,iBAAA,CAAkB,KAAlB,CAAwB,MAAM,CAAC,SAA/B,CANG,EAOH,MAAM,CAAC,yBAPJ,EAQH,MAAM,CAAC,eARJ,EASH,MAAM,CAAC,YATJ,CAAP;;AAWF,aAAK,qBAAqB,CAAC,qBAA3B;AACE,iBAAO,IAAI,UAAJ,CACH,OADG,EAEH,MAAM,CAAC,OAFJ,EAGH,MAAM,CAAC,UAHJ,EAIH,MAAM,CAAC,2BAJJ,EAKH,MAAM,CAAC,wBALJ,EAMH,MAAM,CAAC,SANJ,EAOH,MAAM,CAAC,yBAPJ,EAQH,MAAM,CAAC,eARJ,EASH,MAAM,CAAC,YATJ,CAAP;;AAWF,aAAK,qBAAqB,CAAC,mBAA3B;AACE,cAAM,QAAQ,GAAG,MAAM,CAAC,QAAxB;AACA,UAAA,QAAQ,CAAC,0BAAT,CAAoC,MAAM,CAAC,qBAA3C,EAAkE,MAAM,CAAC,YAAzE;AACA,iBAAO,QAAP;AA5BJ;AA8BD,KA/BM;;AAwFP,IAAA,MAAA,CAAA,cAAA,CAAI,UAAA,CAAA,SAAJ,EAAI,cAAJ,EAAgB;WAAhB,eAAA;AACE,eAAO,KAAK,gBAAZ;AACD,OAFe;uBAAA;;AAAA,KAAhB;;AAIQ,IAAA,UAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,UACI,gBADJ,EACmC,YADnC,EACmE;AADnE,UAAA,KAAA,GAAA,IAAA;;AAEE,WAAK,gBAAL,GAAwB,YAAxB;AACA,WAAK,sBAAL,CAA4B,MAA5B,GAAqC,YAArC;AAEA,MAAA,YAAY,CAAC,OAAb,CAAqB,KAAA,CAAA,SAAA,CAAU,cAA/B,EAA+C,YAAA;;;AAC7C,YAAI,KAAI,CAAC,WAAL,KAAqB,IAAzB,EAA+B;AAC7B;AACA;AACA;AACD;;AAED,QAAA,KAAI,CAAC,eAAL,CAAqB,UAArB;;AAEA,YAAM,eAAe,GAAG,IAAI,GAAJ,EAAxB;;;AACA,eAA2B,IAAA,kBAAA,GAAA,OAAA,CAAA,QAAA,CAAA,gBAAA,CAAA,EAAgB,oBAAA,GAAA,kBAAA,CAAA,IAAA,EAA3C,EAA2C,CAAA,oBAAA,CAAA,IAA3C,EAA2C,oBAAA,GAAA,kBAAA,CAAA,IAAA,EAA3C,EAA6C;AAAxC,gBAAM,YAAY,GAAA,oBAAA,CAAA,KAAlB;;;AACH,mBAA4B,IAAA,EAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,KAAI,CAAC,6BAAL,CAAmC,YAAnC,CAAA,CAAA,CAAA,EAAgD,EAAA,GAAA,EAAA,CAAA,IAAA,EAA5E,EAA4E,CAAA,EAAA,CAAA,IAA5E,EAA4E,EAAA,GAAA,EAAA,CAAA,IAAA,EAA5E,EAA8E;AAAzE,oBAAM,aAAa,GAAA,EAAA,CAAA,KAAnB;AACH,gBAAA,eAAe,CAAC,GAAhB,CAAoB,aAApB;AACD;;;;;;;;;;;;;;AAED,mBAAyB,IAAA,EAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,KAAI,CAAC,0BAAL,CAAgC,YAAhC,CAAA,CAAA,CAAA,EAA6C,EAAA,GAAA,EAAA,CAAA,IAAA,EAAtE,EAAsE,CAAA,EAAA,CAAA,IAAtE,EAAsE,EAAA,GAAA,EAAA,CAAA,IAAA,EAAtE,EAAwE;AAAnE,oBAAM,UAAU,GAAA,EAAA,CAAA,KAAhB;AACH,gBAAA,eAAe,CAAC,GAAhB,CAAoB,UAApB;AACD;;;;;;;;;;;;AACF;;;;;;;;;;;;;;AAED,eAAoB,IAAA,iBAAA,GAAA,OAAA,CAAA,QAAA,CAAA,eAAA,CAAA,EAAe,mBAAA,GAAA,iBAAA,CAAA,IAAA,EAAnC,EAAmC,CAAA,mBAAA,CAAA,IAAnC,EAAmC,mBAAA,GAAA,iBAAA,CAAA,IAAA,EAAnC,EAAqC;AAAhC,gBAAM,KAAK,GAAA,mBAAA,CAAA,KAAX;;AACH,YAAA,KAAI,CAAC,WAAL,CAAiB,aAAjB,CAA+B,eAA/B,CAA+C,KAA/C;;AACA,gBAAI,CAAC,EAAE,CAAC,kBAAH,CAAsB,KAAtB,CAAL,EAAmC;AACjC;AACD;;AAED,YAAA,KAAI,CAAC,WAAL,CAAiB,mBAAjB,CAAqC,eAArC,CAAqD,KAArD;AACD;;;;;;;;;;;;AACF,OA5BD;AA6BD,KAlCO;AAoCR;;;;AAIG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UAAwB,IAAxB,EAA2C;AACzC,WAAK,cAAL;AAEA,aAAO,KAAK,iBAAL,CAAuB,QAAvB,CAAgC,uBAAhC,CAAwD,IAAxD,CAAP;AACD,KAJD;AAMA;;AAEG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AACE,aAAO,KAAK,qBAAL,CAA0B,OAAA,CAAA,QAAA,CACzB,KAAK,yBAAL,EADyB,EACY,KAAK,sBAAL,EADZ,CAA1B,CAAP;AAED,KAHD;AAKA;;;;AAIG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,IAAtB,EAA2C,WAA3C,EAAmE;AACjE,aAAO,KAAK,qBAAL,CAA0B,OAAA,CAAA,QAAA,CAC5B,KAAK,yBAAL,GAAiC,MAAjC,CAAwC,UAAA,IAAA,EAAI;AAAI,eAAA,IAAI,CAAC,IAAL,KAAA,IAAA;AAAkB,OAAlE,CAD4B,EAE5B,KAAK,6BAAL,CAAmC,IAAnC,EAAyC,WAAzC,CAF4B,CAA1B,CAAP;AAID,KALD;AAOA;;AAEG;;;AACK,IAAA,UAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,UAA8B,WAA9B,EAA0D;AACxD,aAAO,WAAW,CAAC,GAAZ,CAAgB,UAAA,IAAA,EAAI;AACzB,YAAI,IAAI,CAAC,IAAL,IAAa,aAAA,CAAA,2BAAA,CAA4B,GAA5B,CAAgC,aAAA,CAAA,WAAA,CAAY,IAAI,CAAC,IAAjB,CAAhC,CAAjB,EAA0E;AACxE,iBAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACK,IADL,CAAA,EACS;AACP,YAAA,WAAW,EAAE,IAAI,CAAC,WAAL,IACT,oBAAkB,aAAA,CAAA,2BAAlB,GAA6C,KAA7C,GAAmD,aAAA,CAAA,WAAA,CAAY,IAAI,CAAC,IAAjB,CAD1C;AADN,WADT,CAAA;AAKD;;AACD,eAAO,IAAP;AACD,OATM,CAAP;AAUD,KAXO;AAaR;;AAEG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;AACE,aAAO,KAAK,uBAAZ;AACD,KAFD;AAIA;;;;;;;;AAQG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AACE,aAAO,KAAK,WAAZ;AACD,KAFD;;AAIA,IAAA,UAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,YAAA;AACE,UAAI,CAAC,KAAK,yBAAV,EAAqC;AACnC,cAAM,IAAI,KAAJ,CACF,8EADE,CAAN;AAED;;AACD,aAAO,KAAK,cAAL,GAAsB,mBAA7B;AACD,KAND;AAQA;;AAEG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,6BAAA,GAAA,UAA8B,gBAA9B,EAAsD;AAC7C,UAAA,gBAAgB,GAAI,KAAK,cAAL,GAAJ,gBAAhB;AACP,aAAO,gBAAgB,CAAC,yBAAjB,CAA2C,aAAA,CAAA,OAAA,CAAQ,gBAAR,CAA3C,CAAP;AACD,KAHD;AAKA;;AAEG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,0BAAA,GAAA,UAA2B,aAA3B,EAAgD;AACvC,UAAA,gBAAgB,GAAI,KAAK,cAAL,GAAJ,gBAAhB;AACP,aAAO,gBAAgB,CAAC,sBAAjB,CAAwC,aAAA,CAAA,OAAA,CAAQ,aAAR,CAAxC,CAAP;AACD,KAHD;AAKA;;AAEG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,SAAtB,EAAgD;AAC9C,UAAI,CAAC,YAAA,CAAA,uBAAA,CAAwB,SAAxB,CAAL,EAAyC;AACvC,eAAO,IAAP;AACD;;AACM,UAAA,gBAAgB,GAAI,KAAK,cAAL,GAAJ,gBAAhB;AACP,UAAM,MAAM,GAAG,gBAAgB,CAAC,SAAjB,CAA2B,SAA3B,CAAf;AACA,UAAM,QAAQ,GAAG,gBAAgB,CAAC,WAAjB,CAA6B,SAA7B,CAAjB;;AACA,UAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,eAAO,IAAP;AACD;;AAED,aAAO;AAAC,QAAA,MAAM,EAAA,MAAP;AAAS,QAAA,QAAQ,EAAA;AAAjB,OAAP;AACD,KAZD;AAcA;;;;;;;;AAQG;;;AACG,IAAA,UAAA,CAAA,SAAA,CAAA,YAAA,GAAN,YAAA;;;;;;;AACE,kBAAI,KAAK,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,uBAAA,CAAA;AAAA;AAAA,iBAAA;AACD;;AAED,qBAAA,CAAA;AAAA;AAAA,gBAAM,KAAK,YAAL,CAAkB,OAAlB,CAA0B,KAAA,CAAA,SAAA,CAAU,QAApC,EAA8C,YAAA;AAAA,uBAAA,OAAA,CAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;;;;AAClD,6BAAK,WAAL,GAAmB,KAAK,eAAL,EAAnB;AAEM,wBAAA,QAAQ,GAAoB,EAA5B;;;AACN,+BAAiB,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,SAAL,CAAe,cAAf,EAAA,CAAA,EAA+B,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhD,EAAgD,CAAA,EAAA,CAAA,IAAhD,EAAgD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhD,EAAkD;AAAvC,4BAAA,EAAE,GAAA,EAAA,CAAA,KAAF;;AACT,gCAAI,EAAE,CAAC,iBAAP,EAA0B;AACxB;AACD;;AAEG,4BAAA,eAAe,GAAG,KAAK,WAAL,CAAiB,aAAjB,CAA+B,YAA/B,CAA4C,EAA5C,CAAlB;AACJ,iCAAK,UAAL,CAAgB,EAAhB;;AACA,gCAAI,eAAe,KAAK,SAAxB,EAAmC;AACjC,8BAAA,QAAQ,CAAC,IAAT,CAAc,eAAd;AACD;AACF;;;;;;;;;;;;;AAED,+BAAA,CAAA;AAAA;AAAA,0BAAM,OAAO,CAAC,GAAR,CAAY,QAAZ,CAAN,CAAA;;;AAAA,wBAAA,EAAA,CAAA,IAAA;;AAEA,6BAAK,YAAL,CAAkB,MAAlB,CAAyB,KAAA,CAAA,cAAA,CAAe,QAAxC;AACA,6BAAK,kBAAL,CAAwB,KAAK,WAAL,CAAiB,aAAzC;;;;;;iBAnBkD,CAAA;AAoBnD,eApBK,CAAN,CAAA;;;AAAA,cAAA,EAAA,CAAA,IAAA;;;;;;;;AAqBD,KA1BK;AA4BN;;;;AAIG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,UAAf,EAAkC;AAChC,UAAI,UAAJ,EAAgB;AACd;AACA;AACA;AACA;AAEA;AACA,YAAI,UAAU,CAAC,UAAX,CAAsB,GAAtB,CAAJ,EAAgC;AAC9B,gBAAM,IAAI,KAAJ,CAAU,+DACZ,UADY,GACF,qBADR,CAAN;AAED,SAVa,CAYd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,YAAM,cAAc,GAAG,KAAK,SAAL,CAAe,gBAAf,GAAkC,CAAlC,CAAvB;;AACM,YAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAA0B,UAAU,CAAC,KAAX,CAAiB,GAAjB,CAA1B,EAA+C,CAA/C,CAAA;AAAA,YAAC,SAAS,GAAA,EAAA,CAAA,CAAA,CAAV;AAAA,YAAY,UAAU,GAAA,EAAA,CAAA,CAAA,CAAtB;;AACN,YAAM,cAAc,GAChB,YAAA,CAAA,iBAAA,CAAkB,SAAlB,EAA6B,cAA7B,EAA6C,KAAK,OAAlD,EAA2D,KAAK,OAAhE,EAAyE,IAAzE,CADJ;;AAGA,YAAI,cAAJ,EAAoB;AAClB,UAAA,UAAU,GAAG,SAAA,CAAA,gBAAA,CAAiB,cAAc,CAAC,gBAAhC,EAAkD,UAAlD,CAAb;AACD;AACF;;AAED,UAAM,WAAW,GAAG,KAAK,cAAL,EAApB;AACA,aAAO,WAAW,CAAC,aAAZ,CAA0B,cAA1B,CAAyC,UAAzC,CAAP;AACD,KAlCD;AAoCA;;;AAGG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AAGE,UAAM,WAAW,GAAG,KAAK,cAAL,EAApB;AAEA,UAAM,eAAe,GAAG,WAAW,CAAC,MAAZ,GAAqB,gBAAgB,CAAC,KAAK,SAAN,CAArC,GAAwD,IAAhF;AACA,UAAI,cAAJ;;AACA,UAAI,eAAe,KAAK,IAAxB,EAA8B;AAC5B,QAAA,cAAc,GAAG,IAAI,SAAA,CAAA,uBAAJ,CAA4B,eAAe,CAAC,QAA5C,CAAjB;AACD,OAFD,MAEO;AACL,QAAA,cAAc,GAAG,IAAI,SAAA,CAAA,kBAAJ,EAAjB;AACD;;AAED,UAAM,oBAAoB,GAAG,IAAI,SAAA,CAAA,oBAAJ,EAA7B;AAEA,UAAM,MAAM,GAAG,CACb,WAAA,CAAA,mBAAA,CACI,WAAW,CAAC,aADhB,EAC+B,WAAW,CAAC,SAD3C,EACsD,cADtD,EACsE,oBADtE,EAEI,KAAK,sBAFT,EAEiC,WAAW,CAAC,MAF7C,EAEqD,KAAK,sBAF1D,CADa,EAIb,WAAA,CAAA,qBAAA,CAAsB,WAAW,CAAC,aAAZ,CAA0B,gBAAhD,CAJa,EAKb,oBAAoB,CAAC,2BAArB,EALa,CAAf;AAQA,UAAM,iBAAiB,GAA2C,EAAlE;;AACA,UAAI,WAAW,CAAC,aAAZ,KAA8B,IAAlC,EAAwC;AACtC,QAAA,iBAAiB,CAAC,IAAlB,CACI,WAAA,CAAA,2BAAA,CAA4B,WAAW,CAAC,aAAxC,EAAuD,cAAvD,CADJ;AAED,OA3BH,CA6BE;;;AACA,UAAI,WAAW,CAAC,YAAZ,KAA6B,IAA7B,IAAqC,WAAW,CAAC,YAAZ,CAAyB,iBAAlE,EAAqF;AACnF,QAAA,iBAAiB,CAAC,IAAlB,CAAuB,WAAA,CAAA,qBAAA,CAAsB,WAAW,CAAC,aAAZ,CAA0B,gBAAhD,CAAvB;AACD;;AAED,UAAI,KAAK,OAAL,CAAa,cAAb,KAAgC,IAApC,EAA0C;AACxC,QAAA,MAAM,CAAC,IAAP,CACI,OAAA,CAAA,yBAAA,CAA0B,KAAK,OAAL,CAAa,cAAb,CAA4B,UAAtD,EAAkE,cAAlE,CADJ;AAED;;AACD,MAAA,MAAM,CAAC,IAAP,CAAY,QAAA,CAAA,kBAAZ;AAEA,aAAO;AAAC,QAAA,YAAY,EAAE;AAAC,UAAA,MAAM,EAAA,MAAP;AAAS,UAAA,iBAAiB,EAAA;AAA1B;AAAf,OAAP;AACD,KAzCD;AA2CA;;;;AAIG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;AACE,UAAM,WAAW,GAAG,KAAK,cAAL,EAApB;AACA,UAAM,OAAO,GAAG,IAAI,SAAA,CAAA,eAAJ,EAAhB;AACA,MAAA,WAAW,CAAC,aAAZ,CAA0B,KAA1B,CAAgC,OAAhC;AACA,aAAO,SAAA,CAAA,gBAAA,CAAiB,OAAjB,CAAP;AACD,KALD;;AAOQ,IAAA,UAAA,CAAA,SAAA,CAAA,cAAA,GAAR,YAAA;AACE,UAAI,KAAK,WAAL,KAAqB,IAAzB,EAA+B;AAC7B,aAAK,WAAL;AACD;;AACD,aAAO,KAAK,WAAZ;AACD,KALO;;AAOA,IAAA,UAAA,CAAA,SAAA,CAAA,WAAA,GAAR,YAAA;AAAA,UAAA,KAAA,GAAA,IAAA;;AACE,WAAK,YAAL,CAAkB,OAAlB,CAA0B,KAAA,CAAA,SAAA,CAAU,QAApC,EAA8C,YAAA;;;AAC5C,QAAA,KAAI,CAAC,WAAL,GAAmB,KAAI,CAAC,eAAL,EAAnB;;;AACA,eAAiB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAI,CAAC,SAAL,CAAe,cAAf,EAAA,CAAA,EAA+B,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhD,EAAgD,CAAA,EAAA,CAAA,IAAhD,EAAgD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhD,EAAkD;AAA7C,gBAAM,EAAE,GAAA,EAAA,CAAA,KAAR;;AACH,gBAAI,EAAE,CAAC,iBAAP,EAA0B;AACxB;AACD;;AACD,YAAA,KAAI,CAAC,WAAL,CAAiB,aAAjB,CAA+B,WAA/B,CAA2C,EAA3C;;AACA,YAAA,KAAI,CAAC,UAAL,CAAgB,EAAhB;AACD;;;;;;;;;;;;;AAED,QAAA,KAAI,CAAC,YAAL,CAAkB,MAAlB,CAAyB,KAAA,CAAA,cAAA,CAAe,QAAxC;;AAEA,QAAA,KAAI,CAAC,kBAAL,CAAwB,KAAI,CAAC,WAAL,CAAiB,aAAzC;AACD,OAbD;AAcD,KAfO;;AAiBA,IAAA,UAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,aAA3B,EAAuD;AAAvD,UAAA,KAAA,GAAA,IAAA;;AACE,WAAK,YAAL,CAAkB,OAAlB,CAA0B,KAAA,CAAA,SAAA,CAAU,OAApC,EAA6C,YAAA;AAC3C,QAAA,aAAa,CAAC,OAAd,GAD2C,CAG3C;AACA;;AACA,QAAA,KAAI,CAAC,iBAAL,CAAuB,wBAAvB,CAAgD,aAAhD;;AAEA,QAAA,KAAI,CAAC,YAAL,CAAkB,MAAlB,CAAyB,KAAA,CAAA,cAAA,CAAe,OAAxC;AACD,OARD;AASD,KAVO;;AAYR,IAAA,MAAA,CAAA,cAAA,CAAY,UAAA,CAAA,SAAZ,EAAY,uBAAZ,EAAiC;WAAjC,eAAA;AACE;AACA;AACA;AACA;AACA,YAAM,eAAe,GAAG,CAAC,CAAC,KAAK,OAAL,CAAa,eAAvC;AACA,eAAO,eAAe,IAAI,CAAC,CAAC,KAAK,OAAL,CAAa,qBAAzC;AACD,OAPgC;uBAAA;;AAAA,KAAjC;;AASQ,IAAA,UAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,YAAA;AACE;AACA;AACA;AACA;AACA,UAAM,eAAe,GAAG,CAAC,CAAC,KAAK,OAAL,CAAa,eAAvC;AAEA,UAAM,yBAAyB,GAAG,KAAK,2BAAL,CAAiC,wBAAnE,CAPF,CASE;AACA;;AACA,UAAI,kBAAJ;;AACA,UAAI,KAAK,qBAAT,EAAgC;AAC9B,QAAA,kBAAkB,GAAG;AACnB,UAAA,0BAA0B,EAAE,eADT;AAEnB,UAAA,YAAY,EAAE,KAFK;AAGnB,UAAA,mBAAmB,EAAE,IAHF;AAInB,UAAA,iCAAiC,EAAE,IAJhB;AAKnB,UAAA,wBAAwB,EAAE,eALP;AAMnB,UAAA,oCAAoC,EAAE,KANnB;AAOnB,UAAA,uBAAuB,EAAE,eAPN;AAQnB,UAAA,qBAAqB,EAAE,eARJ;AASnB;AACA,UAAA,sBAAsB,EAAE,KAVL;AAWnB,UAAA,uBAAuB,EAAE,eAXN;AAYnB,UAAA,0BAA0B,EAAE,eAZT;AAanB;AACA;AACA;AACA;AACA,UAAA,oBAAoB,EAAE,eAjBH;AAkBnB,UAAA,wBAAwB,EAAE,eAlBP;AAmBnB;AACA,UAAA,2BAA2B,EAAE,IApBV;AAqBnB;AACA,UAAA,gBAAgB,EAAE,IAtBC;AAuBnB,UAAA,yBAAyB,EAAE,eAvBR;AAwBnB,UAAA,qBAAqB,EAAE,eAxBJ;AAyBnB,UAAA,kBAAkB,EAAE,IAzBD;AA0BnB,UAAA,yBAAyB,EAAE,KAAK,yBA1Bb;AA2BnB,UAAA,yBAAyB,EAAA,yBA3BN;AA4BnB;AACA;AACA;AACA,UAAA,qCAAqC,EAAE,KAAK,yBAAL,IAAkC,CAAC;AA/BvD,SAArB;AAiCD,OAlCD,MAkCO;AACL,QAAA,kBAAkB,GAAG;AACnB,UAAA,0BAA0B,EAAE,KADT;AAEnB,UAAA,YAAY,EAAE,KAFK;AAGnB,UAAA,mBAAmB,EAAE,KAHF;AAInB;AACA;AACA,UAAA,iCAAiC,EAAE,KAAK,sBANrB;AAOnB,UAAA,wBAAwB,EAAE,KAPP;AAQnB,UAAA,uBAAuB,EAAE,KARN;AASnB,UAAA,oCAAoC,EAAE,KATnB;AAUnB,UAAA,qBAAqB,EAAE,KAVJ;AAWnB,UAAA,sBAAsB,EAAE,KAXL;AAYnB,UAAA,uBAAuB,EAAE,KAZN;AAanB,UAAA,0BAA0B,EAAE,KAbT;AAcnB,UAAA,oBAAoB,EAAE,KAdH;AAenB,UAAA,wBAAwB,EAAE,KAfP;AAgBnB,UAAA,2BAA2B,EAAE,KAhBV;AAiBnB,UAAA,gBAAgB,EAAE,KAjBC;AAkBnB,UAAA,yBAAyB,EAAE,KAlBR;AAmBnB,UAAA,qBAAqB,EAAE,KAnBJ;AAoBnB,UAAA,kBAAkB,EAAE,KApBD;AAqBnB,UAAA,yBAAyB,EAAE,KAAK,yBArBb;AAsBnB,UAAA,yBAAyB,EAAA,yBAtBN;AAuBnB;AACA;AACA,UAAA,qCAAqC,EAAE;AAzBpB,SAArB;AA2BD,OA1EH,CA4EE;AACA;;;AACA,UAAI,KAAK,OAAL,CAAa,gBAAb,KAAkC,SAAtC,EAAiD;AAC/C,QAAA,kBAAkB,CAAC,wBAAnB,GAA8C,KAAK,OAAL,CAAa,gBAA3D;AACA,QAAA,kBAAkB,CAAC,0BAAnB,GAAgD,KAAK,OAAL,CAAa,gBAA7D;AACD;;AACD,UAAI,KAAK,OAAL,CAAa,0BAAb,KAA4C,SAAhD,EAA2D;AACzD,QAAA,kBAAkB,CAAC,oCAAnB,GACI,KAAK,OAAL,CAAa,0BADjB;AAED;;AACD,UAAI,KAAK,OAAL,CAAa,oBAAb,KAAsC,SAA1C,EAAqD;AACnD,QAAA,kBAAkB,CAAC,uBAAnB,GAA6C,KAAK,OAAL,CAAa,oBAA1D;AACD;;AACD,UAAI,KAAK,OAAL,CAAa,sBAAb,KAAwC,SAA5C,EAAuD;AACrD,QAAA,kBAAkB,CAAC,uBAAnB,GAA6C,KAAK,OAAL,CAAa,sBAA1D;AACA,QAAA,kBAAkB,CAAC,0BAAnB,GAAgD,KAAK,OAAL,CAAa,sBAA7D;AACD;;AACD,UAAI,KAAK,OAAL,CAAa,mBAAb,KAAqC,SAAzC,EAAoD;AAClD,QAAA,kBAAkB,CAAC,oBAAnB,GAA0C,KAAK,OAAL,CAAa,mBAAvD;AACD;;AACD,UAAI,KAAK,OAAL,CAAa,yBAAb,KAA2C,SAA/C,EAA0D;AACxD,QAAA,kBAAkB,CAAC,yBAAnB,GAA+C,KAAK,OAAL,CAAa,yBAA5D;AACD;;AACD,UAAI,KAAK,OAAL,CAAa,sBAAb,KAAwC,SAA5C,EAAuD;AACrD,QAAA,kBAAkB,CAAC,wBAAnB,GAA8C,KAAK,OAAL,CAAa,sBAA3D;AACD;;AACD,UAAI,KAAK,OAAL,CAAa,oBAAb,KAAsC,SAA1C,EAAqD;AACnD,QAAA,kBAAkB,CAAC,qBAAnB,GAA2C,KAAK,OAAL,CAAa,oBAAxD;AACD;;AACD,UAAI,KAAK,OAAL,CAAa,qBAAb,KAAuC,SAA3C,EAAsD;AACpD,QAAA,kBAAkB,CAAC,qBAAnB,GAA2C,KAAK,OAAL,CAAa,qBAAxD;AACD;;AACD,UAAI,KAAK,OAAL,CAAa,kBAAb,KAAoC,SAAxC,EAAmD;AACjD,QAAA,kBAAkB,CAAC,kBAAnB,GAAwC,KAAK,OAAL,CAAa,kBAArD;AACD;;AAED,aAAO,kBAAP;AACD,KAjHO;;AAmHA,IAAA,UAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,YAAA;;;AACE,UAAM,WAAW,GAAG,KAAK,cAAL,EAApB,CADF,CAGE;;AACA,UAAM,WAAW,GAAoB,EAArC;;;AACA,aAAiB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,SAAL,CAAe,cAAf,EAAA,CAAA,EAA+B,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhD,EAAgD,CAAA,EAAA,CAAA,IAAhD,EAAgD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhD,EAAkD;AAA7C,cAAM,EAAE,GAAA,EAAA,CAAA,KAAR;;AACH,cAAI,EAAE,CAAC,iBAAH,IAAwB,KAAK,OAAL,CAAa,MAAb,CAAoB,EAApB,CAA5B,EAAqD;AACnD;AACD;;AAED,UAAA,WAAW,CAAC,IAAZ,CAAgB,KAAhB,CAAA,WAAA,EAAW,OAAA,CAAA,QAAA,CACJ,WAAW,CAAC,mBAAZ,CAAgC,qBAAhC,CAAsD,EAAtD,EAA0D,KAAA,CAAA,WAAA,CAAY,YAAtE,CADI,CAAX;AAED;;;;;;;;;;;;;AAED,UAAM,OAAO,GAAG,KAAK,2BAAL,CAAiC,UAAjC,EAAhB;AACA,WAAK,mBAAL,CAAyB,oBAAzB,CAA8C,KAAK,iBAAnD,EAAsE,OAAtE;AACA,WAAK,WAAL,GAAmB,OAAnB;AAEA,aAAO,WAAP;AACD,KAnBO;;AAqBA,IAAA,UAAA,CAAA,SAAA,CAAA,6BAAA,GAAR,UAAsC,EAAtC,EAAyD,WAAzD,EAAiF;AAE/E,UAAM,WAAW,GAAG,KAAK,cAAL,EAApB,CAF+E,CAI/E;;AACA,UAAM,WAAW,GAAoB,EAArC;;AACA,UAAI,CAAC,EAAE,CAAC,iBAAJ,IAAyB,CAAC,KAAK,OAAL,CAAa,MAAb,CAAoB,EAApB,CAA9B,EAAuD;AACrD,QAAA,WAAW,CAAC,IAAZ,CAAgB,KAAhB,CAAA,WAAA,EAAW,OAAA,CAAA,QAAA,CAAS,WAAW,CAAC,mBAAZ,CAAgC,qBAAhC,CAAsD,EAAtD,EAA0D,WAA1D,CAAT,CAAX;AACD;;AAED,UAAM,OAAO,GAAG,KAAK,2BAAL,CAAiC,UAAjC,EAAhB;AACA,WAAK,mBAAL,CAAyB,oBAAzB,CAA8C,KAAK,iBAAnD,EAAsE,OAAtE;AACA,WAAK,WAAL,GAAmB,OAAnB;AAEA,aAAO,WAAP;AACD,KAfO;;AAiBA,IAAA,UAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,YAAA;;;AACE,UAAI,KAAK,sBAAL,KAAgC,IAApC,EAA0C;AACxC,YAAM,WAAW,GAAG,KAAK,cAAL,EAApB;AACA,aAAK,sBAAL,GAA2B,OAAA,CAAA,QAAA,CAAO,WAAW,CAAC,aAAZ,CAA0B,WAAjC,CAA3B;;AACA,YAAI,KAAK,UAAL,KAAoB,IAApB,IAA4B,WAAW,CAAC,oBAAZ,KAAqC,IAArE,EAA2E;AACzE,WAAA,EAAA,GAAA,KAAK,sBAAL,EAA4B,IAA5B,CAAgC,KAAhC,CAAgC,EAAhC,EAAgC,OAAA,CAAA,QAAA,CAAI,aAAA,CAAA,sBAAA,CAChC,KAAK,UAD2B,EACf,KAAK,SAAL,CAAe,cAAf,EADe,EACkB,WAAW,CAAC,oBAD9B,CAAJ,CAAhC;AAED;AACF;;AACD,aAAO,KAAK,sBAAZ;AACD,KAVO;;AAYA,IAAA,UAAA,CAAA,SAAA,CAAA,UAAA,GAAR,UAAmB,EAAnB,EAAoC;AAApC,UAAA,KAAA,GAAA,IAAA;;AACE,WAAK,WAAL,CAAkB,UAAlB,CAA6B,IAA7B,CAAkC,EAAlC,EAAsC;AACpC,QAAA,kBAAkB,EAAE,4BAAC,IAAD,EAAuB,IAAvB,EAAiC;AACnD;AACA;AACA,UAAA,KAAI,CAAC,WAAL,CAAkB,aAAlB,CAAiC,sBAAjC,CAAwD,EAAxD,EAA4D,kBAA5D,CAA+E,IAA/E,EAAqF,IAArF;AACD;AALmC,OAAtC;AAOD,KARO;;AAUA,IAAA,UAAA,CAAA,SAAA,CAAA,eAAA,GAAR,YAAA;AACE,UAAM,OAAO,GAAG,KAAK,SAAL,CAAe,cAAf,EAAhB;AAEA,UAAM,SAAS,GAAG,IAAI,YAAA,CAAA,wBAAJ,CAA6B,OAA7B,CAAlB,CAHF,CAKE;;AACA,UAAI,UAAJ;AACA,UAAI,YAAY,GAAsB,IAAtC;;AACA,UAAI,KAAK,OAAL,CAAa,kBAAb,KAAoC,IAApC,IAA4C,CAAC,KAAK,OAAL,CAAa,2BAA9D,EAA2F;AACzF,YAAI,mBAAmB,GAAA,KAAA,CAAvB,CADyF,CAGzF;AACA;AACA;AACA;AACA;;AACA,YAAI,KAAK,OAAL,CAAa,OAAb,KAAyB,SAAzB,IACC,KAAK,OAAL,CAAa,QAAb,KAA0B,SAA1B,IAAuC,KAAK,OAAL,CAAa,QAAb,CAAsB,MAAtB,GAA+B,CAD3E,EAC+E;AAC7E;AACA;AACA,UAAA,mBAAmB,GAAG,IAAI,SAAA,CAAA,sBAAJ,CAClB,SADkB,EACP,IAAI,aAAA,CAAA,iBAAJ,CAAqB,OAAA,CAAA,QAAA,CAAK,KAAK,OAAL,CAAa,QAAlB,CAArB,EAAkD,KAAK,OAAvD,CADO,CAAtB;AAED,SAND,MAMO;AACL;AACA,UAAA,mBAAmB,GAAG,IAAI,SAAA,CAAA,oBAAJ,CAAyB,SAAzB,CAAtB;AACD,SAjBwF,CAmBzF;AACA;;;AACA,QAAA,UAAU,GAAG,IAAI,SAAA,CAAA,gBAAJ,CAAqB,CAChC;AACA,YAAI,SAAA,CAAA,uBAAJ,EAFgC,EAGhC;AACA,YAAI,SAAA,CAAA,sBAAJ,CAA2B,KAAK,SAAhC,EAA2C,OAA3C,EAAoD,KAAK,cAAzD,EAAyE,SAAzE,CAJgC,EAKhC;AACA;AACA;AACA,QAAA,mBARgC,CAArB,CAAb,CArByF,CAgCzF;AACA;AACA;;AACA,YAAI,KAAK,UAAL,KAAoB,IAApB,IAA4B,KAAK,OAAL,CAAa,qBAAb,KAAuC,IAAvE,EAA6E;AAC3E;AACA;AACA,UAAA,YAAY,GAAG,IAAI,SAAA,CAAA,yBAAJ,CAA8B,SAA9B,CAAf;AACD;AACF,OAxCD,MAwCO;AACL;AACA,QAAA,UAAU,GAAG,IAAI,SAAA,CAAA,gBAAJ,CAAqB,CAChC;AACA,YAAI,SAAA,CAAA,uBAAJ,EAFgC,EAGhC;AACA,YAAI,SAAA,CAAA,aAAJ,EAJgC,EAKhC;AACA,YAAI,SAAA,CAAA,sBAAJ,CAA2B,SAA3B,EAAsC,KAAK,OAAL,CAAa,kBAAnD,CANgC,CAArB,CAAb;AAQA,QAAA,YAAY,GAAG,IAAI,SAAA,CAAA,0BAAJ,CAA+B,KAAK,OAAL,CAAa,kBAA5C,CAAf;AACD;;AAED,UAAM,SAAS,GAAG,IAAI,mBAAA,CAAA,gBAAJ,CAAqB,SAArB,EAAgC,OAAhC,EAAyC,KAAK,iBAAL,CAAuB,QAAhE,CAAlB;AACA,UAAM,SAAS,GAAG,IAAI,UAAA,CAAA,iBAAJ,CAAsB,OAAtB,EAA+B,SAA/B,CAAlB;AACA,UAAM,iBAAiB,GAAG,IAAI,UAAA,CAAA,qBAAJ,EAA1B;AACA,UAAM,eAAe,GAAmB,iBAAxC;AACA,UAAM,cAAc,GAAG,IAAI,OAAA,CAAA,8BAAJ,CAAmC,SAAnC,EAA8C,YAA9C,CAAvB;AACA,UAAM,aAAa,GACf,IAAI,OAAA,CAAA,wBAAJ,CAA6B,eAA7B,EAA8C,cAA9C,EAA8D,UAA9D,EAA0E,YAA1E,CADJ;AAEA,UAAM,WAAW,GAAyB,aAA1C;AACA,UAAM,uBAAuB,GAAG,KAAK,iBAAL,CAAuB,0BAAvB,EAAhC;AACA,UAAM,YAAY,GAAG,IAAI,UAAA,CAAA,wBAAJ,CAA6B,CAAC,iBAAD,EAAoB,aAApB,CAA7B,CAArB;AACA,UAAM,kBAAkB,GAAG,IAAI,UAAA,CAAA,uBAAJ,CAA4B,SAA5B,CAA3B;AAEA,UAAM,UAAU,GAAG,IAAI,UAAA,CAAA,sBAAJ,CAA2B,CAAC,eAAD,EAAkB,SAAlB,CAA3B,CAAnB;AACA,UAAM,sBAAsB,GAAG,IAAI,OAAA,CAAA,sBAAJ,CAA2B,WAA3B,EAAwC,UAAxC,CAA/B,CA1EF,CA6EE;AACA;AACA;;AACA,UAAI,kBAAJ;AACA,UAAI,oBAAoB,GAAwB,IAAhD;;AACA,UAAI,KAAK,UAAL,KAAoB,IAAxB,EAA8B;AAC5B,QAAA,oBAAoB,GAAG,IAAI,aAAA,CAAA,cAAJ,EAAvB;AACA,QAAA,kBAAkB,GAAG,IAAI,qBAAJ,CAA0B,oBAA1B,CAArB;AACD,OAHD,MAGO;AACL,QAAA,kBAAkB,GAAG,IAAI,aAAA,CAAA,sBAAJ,EAArB;AACD;;AAED,UAAM,aAAa,GAAG,IAAI,SAAA,CAAA,qBAAJ,CAA0B,KAAK,cAA/B,EAA+C,SAA/C,CAAtB;AAEA,UAAM,aAAa,GAAG,IAAI,WAAA,CAAA,oBAAJ,EAAtB;AAEA,UAAM,UAAU,GAAG,IAAI,qBAAA,CAAA,0BAAJ,CAA+B,SAA/B,EAA0C,SAA1C,EAAqD,UAArD,CAAnB;AAEA,UAAM,MAAM,GAAG,oBAAoB,CAAC,KAAK,SAAN,CAAnC;AAEA,UAAM,gBAAgB,GAAG,IAAI,UAAA,CAAA,gBAAJ,EAAzB;AAEA,UAAM,eAAe,GACjB,KAAK,OAAL,CAAa,eAAb,KAAiC,SAAjC,GAA6C,WAAA,CAAA,eAAA,CAAgB,OAA7D,GAAuE,WAAA,CAAA,eAAA,CAAgB,IAD3F,CAnGF,CAsGE;AACA;AACA;;AACA,UAAM,qBAAqB,GAAG,eAAe,KAAK,WAAA,CAAA,eAAA,CAAgB,IAApC,G;AACa;AADb,Q;AAEC;AAF/B,OAzGF,CA6GE;;AACA,UAAM,QAAQ,GAAuE,CACnF,IAAI,aAAA,CAAA,yBAAJ,CACI,SADJ,EACe,SADf,EAC0B,YAD1B,EACwC,UADxC,EACoD,WADpD,EACiE,aADjE,EAEI,sBAFJ,EAE4B,gBAF5B,EAE8C,MAF9C,EAEsD,KAAK,eAF3D,EAGI,KAAK,OAAL,CAAa,QAHjB,EAG2B,KAAK,OAAL,CAAa,mBAAb,IAAoC,KAH/D,EAII,KAAK,OAAL,CAAa,kBAAb,KAAoC,KAJxC,EAKI,KAAK,OAAL,CAAa,+BAAb,KAAiD,KALrD,EAK4D,KAAK,eALjE,EAMI,KAAK,OAAL,CAAa,8BANjB,EAMiD,KAAK,cANtD,EAMsE,KAAK,aAN3E,EAOI,qBAPJ,EAO2B,UAP3B,EAOuC,KAAK,iBAAL,CAAuB,QAP9D,EAOwE,kBAPxE,EAQI,uBARJ,EAQ6B,KAAK,sBARlC,EAQ0D,KAAK,sBAR/D,CADmF,EAWnF;AACA;AACA;AACE,UAAI,aAAA,CAAA,yBAAJ,CACI,SADJ,EACe,SADf,EAC0B,YAD1B,EACwC,aADxC,EACuD,UADvD,EAEI,kBAFJ,EAEwB,MAFxB,EAEgC,uBAFhC,EAGE,KAAK,sBAHP,EAG+B,QAAA,CAAA,4CAH/B,EAIE,KAAK,sBAJP,CAdiF,EAoBnF;AACA;AACA;AACA,UAAI,aAAA,CAAA,oBAAJ,CACI,SADJ,EACe,SADf,EAC0B,YAD1B,EACwC,aADxC,EACuD,kBADvD,EAC2E,MAD3E,EAEI,KAAK,sBAFT,CAvBmF,EA0BnF,IAAI,aAAA,CAAA,0BAAJ,CACI,SADJ,EACe,MADf,EACuB,KAAK,OAAL,CAAa,yBAAb,IAA0C,KADjE,EACwE,kBADxE,EAEI,KAAK,sBAFT,CA1BmF,EA6BnF,IAAI,aAAA,CAAA,wBAAJ,CACI,SADJ,EACe,SADf,EAC0B,UAD1B,EACsC,YADtC,EACoD,aADpD,EACmE,kBADnE,EACuF,MADvF,EAEI,aAFJ,EAEmB,UAFnB,EAE+B,KAAK,OAAL,CAAa,cAF5C,EAE4D,KAAK,sBAFjE,EAGI,kBAHJ,EAGwB,KAAK,sBAH7B,EAGqD,KAAK,OAAL,CAAa,YAHlE,CA7BmF,CAArF;AAmCA,UAAM,aAAa,GAAG,IAAI,WAAA,CAAA,aAAJ,CAClB,QADkB,EACR,SADQ,EACG,KAAK,sBADR,EACgC,KAAK,iBADrC,EAElB,KAAK,OAAL,CAAa,yBAAb,KAA2C,KAFzB,EAEgC,eAFhC,EAEiD,aAFjD,EAGlB,uBAHkB,CAAtB;AAKA,UAAM,mBAAmB,GAAG,IAAI,WAAA,CAAA,uBAAJ,CACxB,KAAK,SADmB,EACR,KAAK,2BADG,EAC0B,aAD1B,EAExB,KAAK,qBAAL,EAFwB,EAEM,UAFN,EAEkB,SAFlB,EAE6B,KAAK,OAFlC,EAE2C,KAAK,iBAFhD,EAGxB,aAHwB,EAGT,sBAHS,EAGe,KAAK,sBAHpB,CAA5B;AAKA,aAAO;AACL,QAAA,MAAM,EAAA,MADD;AAEL,QAAA,aAAa,EAAA,aAFR;AAGL,QAAA,SAAS,EAAA,SAHJ;AAIL,QAAA,aAAa,EAAA,aAJR;AAKL,QAAA,aAAa,EAAA,aALR;AAML,QAAA,oBAAoB,EAAA,oBANf;AAOL,QAAA,aAAa,EAAA,aAPR;AAQL,QAAA,UAAU,EAAA,UARL;AASL,QAAA,UAAU,EAAA,UATL;AAUL,QAAA,sBAAsB,EAAA,sBAVjB;AAWL,QAAA,YAAY,EAAA,YAXP;AAYL,QAAA,UAAU,EAAA,UAZL;AAaL,QAAA,mBAAmB,EAAA,mBAbd;AAcL,QAAA,gBAAgB,EAAA;AAdX,OAAP;AAgBD,KA3KO;;AA4KV,WAAA,UAAA;AAAC,GA7yBD,EAAA;;AAAa,EAAA,OAAA,CAAA,UAAA,GAAA,UAAA;AA+yBb;;AAEG;;AACH,WAAgB,oBAAhB,CAAqC,OAArC,EAAwD;AACtD;AACA,QAAM,SAAS,GAAG,gBAAgB,CAAC,OAAD,CAAlC;;AACA,QAAI,SAAS,KAAK,IAAlB,EAAwB;AACtB,aAAO,KAAP;AACD,KALqD,CAOtD;;;AACA,WAAO,SAAS,CAAC,UAAV,CAAqB,IAArB,CAA0B,UAAA,IAAA,EAAI;AACnC;AACA,UAAI,CAAC,EAAE,CAAC,mBAAH,CAAuB,IAAvB,CAAL,EAAmC;AACjC,eAAO,KAAP;AACD,OAJkC,CAKnC;;;AACA,UAAI,IAAI,CAAC,SAAL,KAAmB,SAAnB,IACA,CAAC,IAAI,CAAC,SAAL,CAAe,IAAf,CAAoB,UAAA,GAAA,EAAG;AAAI,eAAA,GAAG,CAAC,IAAJ,KAAa,EAAE,CAAC,UAAH,CAAb,aAAA;AAAwC,OAAnE,CADL,EAC2E;AACzE,eAAO,KAAP;AACD,OATkC,CAUnC;;;AACA,aAAO,IAAI,CAAC,eAAL,CAAqB,YAArB,CAAkC,IAAlC,CAAuC,UAAA,IAAA,EAAI;AAChD;AACA,YAAI,CAAC,EAAE,CAAC,YAAH,CAAgB,IAAI,CAAC,IAArB,CAAD,IAA+B,IAAI,CAAC,IAAL,CAAU,IAAV,KAAmB,kBAAtD,EAA0E;AACxE,iBAAO,KAAP;AACD,SAJ+C,CAKhD;;;AACA,YAAI,IAAI,CAAC,WAAL,KAAqB,SAArB,IAAkC,IAAI,CAAC,WAAL,CAAiB,IAAjB,KAA0B,EAAE,CAAC,UAAH,CAAc,WAA9E,EAA2F;AACzF,iBAAO,KAAP;AACD,SAR+C,CAShD;;;AACA,eAAO,IAAP;AACD,OAXM,CAAP;AAYD,KAvBM,CAAP;AAwBD;;AAhCD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA;AAkCA;;AAEG;;AACH,WAAS,gBAAT,CAA0B,OAA1B,EAA6C;AAC3C,WAAO,OAAO,CAAC,cAAR,GAAyB,IAAzB,CAA8B,UAAA,IAAA,EAAI;AAAI,aAAA,IAAI,CAAC,QAAL,CAAc,OAAd,CAAsB,eAAtB,KAAA,CAAA;AAA2C,KAAjF,KAAsF,IAA7F;AACD;AAED;;;;AAIG;;;AACH,WAAS,gCAAT,CAA0C,OAA1C,EAAoE;AAClE,QAAI,OAAO,CAAC,qBAAR,KAAkC,KAAlC,IAA2C,OAAO,CAAC,eAAR,KAA4B,IAA3E,EAAiF;AAC/E,aAAO;AACL,QAAA,QAAQ,EAAE,EAAE,CAAC,kBAAH,CAAsB,KAD3B;AAEL,QAAA,IAAI,EAAE,aAAA,CAAA,WAAA,CAAY,aAAA,CAAA,SAAA,CAAU,uDAAtB,CAFD;AAGL,QAAA,IAAI,EAAE,SAHD;AAIL,QAAA,KAAK,EAAE,SAJF;AAKL,QAAA,MAAM,EAAE,SALH;AAML,QAAA,WAAW,EACP;AAPC,OAAP;AAmBD;;AAED,WAAO,IAAP;AACD;;AAED,MAAA,qBAAA;AAAA;AAAA,cAAA;AACE,aAAA,qBAAA,CAAoB,KAApB,EAAyC;AAArB,WAAA,KAAA,GAAA,KAAA;AAAyB;;AAE7C,IAAA,qBAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,MAAJ,EAA2B;;;AAAE,UAAA,UAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAA2C;AAA3C,QAAA,UAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;;AAC3B,aAAqB,IAAA,YAAA,GAAA,OAAA,CAAA,QAAA,CAAA,UAAA,CAAA,EAAU,cAAA,GAAA,YAAA,CAAA,IAAA,EAA/B,EAA+B,CAAA,cAAA,CAAA,IAA/B,EAA+B,cAAA,GAAA,YAAA,CAAA,IAAA,EAA/B,EAAiC;AAArB,cAAA,IAAI,GAAA,cAAA,CAAA,KAAA,CAAA,IAAJ;AACV,cAAI,UAAU,GAAG,IAAI,CAAC,aAAL,EAAjB;;AACA,cAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B,YAAA,UAAU,GAAG,EAAE,CAAC,eAAH,CAAmB,IAAnB,EAAyB,aAAzB,EAAb;AACD,WAJ8B,CAM/B;;;AACA,cAAI,UAAU,KAAK,SAAf,IAA4B,CAAC,YAAA,CAAA,SAAA,CAAU,UAAU,CAAC,QAArB,CAAjC,EAAiE;AAC/D,iBAAK,KAAL,CAAW,GAAX,CAAe,MAAf,EAAuB,IAAvB;AACD;AACF;;;;;;;;;;;;AACF,KAZD;;AAaF,WAAA,qBAAA;AAAC,GAhBD,EAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ComponentDecoratorHandler, DirectiveDecoratorHandler, InjectableDecoratorHandler, NgModuleDecoratorHandler, NoopReferencesRegistry, PipeDecoratorHandler, ReferencesRegistry} from '../../annotations';\nimport {CycleAnalyzer, CycleHandlingStrategy, ImportGraph} from '../../cycles';\nimport {COMPILER_ERRORS_WITH_GUIDES, ERROR_DETAILS_PAGE_BASE_URL, ErrorCode, ngErrorCode} from '../../diagnostics';\nimport {checkForPrivateExports, ReferenceGraph} from '../../entry_point';\nimport {LogicalFileSystem, resolve} from '../../file_system';\nimport {AbsoluteModuleStrategy, AliasingHost, AliasStrategy, DefaultImportTracker, ImportRewriter, LocalIdentifierStrategy, LogicalProjectStrategy, ModuleResolver, NoopImportRewriter, PrivateExportAliasingHost, R3SymbolsImportRewriter, Reference, ReferenceEmitStrategy, ReferenceEmitter, RelativePathStrategy, UnifiedModulesAliasingHost, UnifiedModulesStrategy} from '../../imports';\nimport {IncrementalBuildStrategy, IncrementalDriver} from '../../incremental';\nimport {SemanticSymbol} from '../../incremental/semantic_graph';\nimport {generateAnalysis, IndexedComponent, IndexingContext} from '../../indexer';\nimport {ComponentResources, CompoundMetadataReader, CompoundMetadataRegistry, DtsMetadataReader, InjectableClassRegistry, LocalMetadataRegistry, MetadataReader, ResourceRegistry} from '../../metadata';\nimport {ModuleWithProvidersScanner} from '../../modulewithproviders';\nimport {PartialEvaluator} from '../../partial_evaluator';\nimport {ActivePerfRecorder} from '../../perf';\nimport {PerfCheckpoint, PerfEvent, PerfPhase} from '../../perf/src/api';\nimport {DelegatingPerfRecorder} from '../../perf/src/recorder';\nimport {DeclarationNode, isNamedClassDeclaration, TypeScriptReflectionHost} from '../../reflection';\nimport {AdapterResourceLoader} from '../../resource';\nimport {entryPointKeyFor, NgModuleRouteAnalyzer} from '../../routing';\nimport {ComponentScopeReader, LocalModuleScopeRegistry, MetadataDtsModuleScopeResolver, TypeCheckScopeRegistry} from '../../scope';\nimport {generatedFactoryTransform} from '../../shims';\nimport {ivySwitchTransform} from '../../switch';\nimport {aliasTransformFactory, CompilationMode, declarationTransformFactory, DecoratorHandler, DtsTransformRegistry, ivyTransformFactory, TraitCompiler} from '../../transform';\nimport {TemplateTypeCheckerImpl} from '../../typecheck';\nimport {OptimizeFor, TemplateTypeChecker, TypeCheckingConfig, TypeCheckingProgramStrategy} from '../../typecheck/api';\nimport {getSourceFileOrNull, isDtsPath, resolveModuleName} from '../../util/src/typescript';\nimport {LazyRoute, NgCompilerAdapter, NgCompilerOptions} from '../api';\n\nimport {compileUndecoratedClassesWithAngularFeatures} from './config';\n\n/**\n * State information about a compilation which is only generated once some data is requested from\n * the `NgCompiler` (for example, by calling `getDiagnostics`).\n */\ninterface LazyCompilationState {\n  isCore: boolean;\n  traitCompiler: TraitCompiler;\n  reflector: TypeScriptReflectionHost;\n  metaReader: MetadataReader;\n  scopeRegistry: LocalModuleScopeRegistry;\n  typeCheckScopeRegistry: TypeCheckScopeRegistry;\n  exportReferenceGraph: ReferenceGraph|null;\n  routeAnalyzer: NgModuleRouteAnalyzer;\n  dtsTransforms: DtsTransformRegistry;\n  mwpScanner: ModuleWithProvidersScanner;\n  aliasingHost: AliasingHost|null;\n  refEmitter: ReferenceEmitter;\n  templateTypeChecker: TemplateTypeChecker;\n  resourceRegistry: ResourceRegistry;\n}\n\n\n\n/**\n * Discriminant type for a `CompilationTicket`.\n */\nexport enum CompilationTicketKind {\n  Fresh,\n  IncrementalTypeScript,\n  IncrementalResource,\n}\n\n/**\n * Begin an Angular compilation operation from scratch.\n */\nexport interface FreshCompilationTicket {\n  kind: CompilationTicketKind.Fresh;\n  options: NgCompilerOptions;\n  incrementalBuildStrategy: IncrementalBuildStrategy;\n  typeCheckingProgramStrategy: TypeCheckingProgramStrategy;\n  enableTemplateTypeChecker: boolean;\n  usePoisonedData: boolean;\n  tsProgram: ts.Program;\n  perfRecorder: ActivePerfRecorder;\n}\n\n/**\n * Begin an Angular compilation operation that incorporates changes to TypeScript code.\n */\nexport interface IncrementalTypeScriptCompilationTicket {\n  kind: CompilationTicketKind.IncrementalTypeScript;\n  options: NgCompilerOptions;\n  oldProgram: ts.Program;\n  newProgram: ts.Program;\n  incrementalBuildStrategy: IncrementalBuildStrategy;\n  typeCheckingProgramStrategy: TypeCheckingProgramStrategy;\n  newDriver: IncrementalDriver;\n  enableTemplateTypeChecker: boolean;\n  usePoisonedData: boolean;\n  perfRecorder: ActivePerfRecorder;\n}\n\nexport interface IncrementalResourceCompilationTicket {\n  kind: CompilationTicketKind.IncrementalResource;\n  compiler: NgCompiler;\n  modifiedResourceFiles: Set<string>;\n  perfRecorder: ActivePerfRecorder;\n}\n\n/**\n * A request to begin Angular compilation, either starting from scratch or from a known prior state.\n *\n * `CompilationTicket`s are used to initialize (or update) an `NgCompiler` instance, the core of the\n * Angular compiler. They abstract the starting state of compilation and allow `NgCompiler` to be\n * managed independently of any incremental compilation lifecycle.\n */\nexport type CompilationTicket = FreshCompilationTicket|IncrementalTypeScriptCompilationTicket|\n    IncrementalResourceCompilationTicket;\n\n/**\n * Create a `CompilationTicket` for a brand new compilation, using no prior state.\n */\nexport function freshCompilationTicket(\n    tsProgram: ts.Program, options: NgCompilerOptions,\n    incrementalBuildStrategy: IncrementalBuildStrategy,\n    typeCheckingProgramStrategy: TypeCheckingProgramStrategy, perfRecorder: ActivePerfRecorder|null,\n    enableTemplateTypeChecker: boolean, usePoisonedData: boolean): CompilationTicket {\n  return {\n    kind: CompilationTicketKind.Fresh,\n    tsProgram,\n    options,\n    incrementalBuildStrategy,\n    typeCheckingProgramStrategy,\n    enableTemplateTypeChecker,\n    usePoisonedData,\n    perfRecorder: perfRecorder ?? ActivePerfRecorder.zeroedToNow(),\n  };\n}\n\n/**\n * Create a `CompilationTicket` as efficiently as possible, based on a previous `NgCompiler`\n * instance and a new `ts.Program`.\n */\nexport function incrementalFromCompilerTicket(\n    oldCompiler: NgCompiler, newProgram: ts.Program,\n    incrementalBuildStrategy: IncrementalBuildStrategy,\n    typeCheckingProgramStrategy: TypeCheckingProgramStrategy, modifiedResourceFiles: Set<string>,\n    perfRecorder: ActivePerfRecorder|null): CompilationTicket {\n  const oldProgram = oldCompiler.getNextProgram();\n  const oldDriver = oldCompiler.incrementalStrategy.getIncrementalDriver(oldProgram);\n  if (oldDriver === null) {\n    // No incremental step is possible here, since no IncrementalDriver was found for the old\n    // program.\n    return freshCompilationTicket(\n        newProgram, oldCompiler.options, incrementalBuildStrategy, typeCheckingProgramStrategy,\n        perfRecorder, oldCompiler.enableTemplateTypeChecker, oldCompiler.usePoisonedData);\n  }\n\n  if (perfRecorder === null) {\n    perfRecorder = ActivePerfRecorder.zeroedToNow();\n  }\n\n  const newDriver = IncrementalDriver.reconcile(\n      oldProgram, oldDriver, newProgram, modifiedResourceFiles, perfRecorder);\n\n  return {\n    kind: CompilationTicketKind.IncrementalTypeScript,\n    enableTemplateTypeChecker: oldCompiler.enableTemplateTypeChecker,\n    usePoisonedData: oldCompiler.usePoisonedData,\n    options: oldCompiler.options,\n    incrementalBuildStrategy,\n    typeCheckingProgramStrategy,\n    newDriver,\n    oldProgram,\n    newProgram,\n    perfRecorder,\n  };\n}\n\n/**\n * Create a `CompilationTicket` directly from an old `ts.Program` and associated Angular compilation\n * state, along with a new `ts.Program`.\n */\nexport function incrementalFromDriverTicket(\n    oldProgram: ts.Program, oldDriver: IncrementalDriver, newProgram: ts.Program,\n    options: NgCompilerOptions, incrementalBuildStrategy: IncrementalBuildStrategy,\n    typeCheckingProgramStrategy: TypeCheckingProgramStrategy, modifiedResourceFiles: Set<string>,\n    perfRecorder: ActivePerfRecorder|null, enableTemplateTypeChecker: boolean,\n    usePoisonedData: boolean): CompilationTicket {\n  if (perfRecorder === null) {\n    perfRecorder = ActivePerfRecorder.zeroedToNow();\n  }\n\n  const newDriver = IncrementalDriver.reconcile(\n      oldProgram, oldDriver, newProgram, modifiedResourceFiles, perfRecorder);\n  return {\n    kind: CompilationTicketKind.IncrementalTypeScript,\n    oldProgram,\n    newProgram,\n    options,\n    incrementalBuildStrategy,\n    newDriver,\n    typeCheckingProgramStrategy,\n    enableTemplateTypeChecker,\n    usePoisonedData,\n    perfRecorder,\n  };\n}\n\nexport function resourceChangeTicket(compiler: NgCompiler, modifiedResourceFiles: Set<string>):\n    IncrementalResourceCompilationTicket {\n  return {\n    kind: CompilationTicketKind.IncrementalResource,\n    compiler,\n    modifiedResourceFiles,\n    perfRecorder: ActivePerfRecorder.zeroedToNow(),\n  };\n}\n\n\n/**\n * The heart of the Angular Ivy compiler.\n *\n * The `NgCompiler` provides an API for performing Angular compilation within a custom TypeScript\n * compiler. Each instance of `NgCompiler` supports a single compilation, which might be\n * incremental.\n *\n * `NgCompiler` is lazy, and does not perform any of the work of the compilation until one of its\n * output methods (e.g. `getDiagnostics`) is called.\n *\n * See the README.md for more information.\n */\nexport class NgCompiler {\n  /**\n   * Lazily evaluated state of the compilation.\n   *\n   * This is created on demand by calling `ensureAnalyzed`.\n   */\n  private compilation: LazyCompilationState|null = null;\n\n  /**\n   * Any diagnostics related to the construction of the compilation.\n   *\n   * These are diagnostics which arose during setup of the host and/or program.\n   */\n  private constructionDiagnostics: ts.Diagnostic[] = [];\n\n  /**\n   * Non-template diagnostics related to the program itself. Does not include template\n   * diagnostics because the template type checker memoizes them itself.\n   *\n   * This is set by (and memoizes) `getNonTemplateDiagnostics`.\n   */\n  private nonTemplateDiagnostics: ts.Diagnostic[]|null = null;\n\n  private closureCompilerEnabled: boolean;\n  private nextProgram: ts.Program;\n  private entryPoint: ts.SourceFile|null;\n  private moduleResolver: ModuleResolver;\n  private resourceManager: AdapterResourceLoader;\n  private cycleAnalyzer: CycleAnalyzer;\n  readonly ignoreForDiagnostics: Set<ts.SourceFile>;\n  readonly ignoreForEmit: Set<ts.SourceFile>;\n\n  /**\n   * `NgCompiler` can be reused for multiple compilations (for resource-only changes), and each\n   * new compilation uses a fresh `PerfRecorder`. Thus, classes created with a lifespan of the\n   * `NgCompiler` use a `DelegatingPerfRecorder` so the `PerfRecorder` they write to can be updated\n   * with each fresh compilation.\n   */\n  private delegatingPerfRecorder = new DelegatingPerfRecorder(this.perfRecorder);\n\n  /**\n   * Convert a `CompilationTicket` into an `NgCompiler` instance for the requested compilation.\n   *\n   * Depending on the nature of the compilation request, the `NgCompiler` instance may be reused\n   * from a previous compilation and updated with any changes, it may be a new instance which\n   * incrementally reuses state from a previous compilation, or it may represent a fresh\n   * compilation entirely.\n   */\n  static fromTicket(ticket: CompilationTicket, adapter: NgCompilerAdapter) {\n    switch (ticket.kind) {\n      case CompilationTicketKind.Fresh:\n        return new NgCompiler(\n            adapter,\n            ticket.options,\n            ticket.tsProgram,\n            ticket.typeCheckingProgramStrategy,\n            ticket.incrementalBuildStrategy,\n            IncrementalDriver.fresh(ticket.tsProgram),\n            ticket.enableTemplateTypeChecker,\n            ticket.usePoisonedData,\n            ticket.perfRecorder,\n        );\n      case CompilationTicketKind.IncrementalTypeScript:\n        return new NgCompiler(\n            adapter,\n            ticket.options,\n            ticket.newProgram,\n            ticket.typeCheckingProgramStrategy,\n            ticket.incrementalBuildStrategy,\n            ticket.newDriver,\n            ticket.enableTemplateTypeChecker,\n            ticket.usePoisonedData,\n            ticket.perfRecorder,\n        );\n      case CompilationTicketKind.IncrementalResource:\n        const compiler = ticket.compiler;\n        compiler.updateWithChangedResources(ticket.modifiedResourceFiles, ticket.perfRecorder);\n        return compiler;\n    }\n  }\n\n  private constructor(\n      private adapter: NgCompilerAdapter,\n      readonly options: NgCompilerOptions,\n      private tsProgram: ts.Program,\n      readonly typeCheckingProgramStrategy: TypeCheckingProgramStrategy,\n      readonly incrementalStrategy: IncrementalBuildStrategy,\n      readonly incrementalDriver: IncrementalDriver,\n      readonly enableTemplateTypeChecker: boolean,\n      readonly usePoisonedData: boolean,\n      private livePerfRecorder: ActivePerfRecorder,\n  ) {\n    this.constructionDiagnostics.push(...this.adapter.constructionDiagnostics);\n    const incompatibleTypeCheckOptionsDiagnostic = verifyCompatibleTypeCheckOptions(this.options);\n    if (incompatibleTypeCheckOptionsDiagnostic !== null) {\n      this.constructionDiagnostics.push(incompatibleTypeCheckOptionsDiagnostic);\n    }\n\n    this.nextProgram = tsProgram;\n    this.closureCompilerEnabled = !!this.options.annotateForClosureCompiler;\n\n    this.entryPoint =\n        adapter.entryPoint !== null ? getSourceFileOrNull(tsProgram, adapter.entryPoint) : null;\n\n    const moduleResolutionCache = ts.createModuleResolutionCache(\n        this.adapter.getCurrentDirectory(),\n        // doen't retain a reference to `this`, if other closures in the constructor here reference\n        // `this` internally then a closure created here would retain them. This can cause major\n        // memory leak issues since the `moduleResolutionCache` is a long-lived object and finds its\n        // way into all kinds of places inside TS internal objects.\n        this.adapter.getCanonicalFileName.bind(this.adapter));\n    this.moduleResolver =\n        new ModuleResolver(tsProgram, this.options, this.adapter, moduleResolutionCache);\n    this.resourceManager = new AdapterResourceLoader(adapter, this.options);\n    this.cycleAnalyzer =\n        new CycleAnalyzer(new ImportGraph(tsProgram.getTypeChecker(), this.delegatingPerfRecorder));\n    this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, tsProgram);\n\n    this.ignoreForDiagnostics =\n        new Set(tsProgram.getSourceFiles().filter(sf => this.adapter.isShim(sf)));\n    this.ignoreForEmit = this.adapter.ignoreForEmit;\n\n    let dtsFileCount = 0;\n    let nonDtsFileCount = 0;\n    for (const sf of tsProgram.getSourceFiles()) {\n      if (sf.isDeclarationFile) {\n        dtsFileCount++;\n      } else {\n        nonDtsFileCount++;\n      }\n    }\n\n    livePerfRecorder.eventCount(PerfEvent.InputDtsFile, dtsFileCount);\n    livePerfRecorder.eventCount(PerfEvent.InputTsFile, nonDtsFileCount);\n  }\n\n  get perfRecorder(): ActivePerfRecorder {\n    return this.livePerfRecorder;\n  }\n\n  private updateWithChangedResources(\n      changedResources: Set<string>, perfRecorder: ActivePerfRecorder): void {\n    this.livePerfRecorder = perfRecorder;\n    this.delegatingPerfRecorder.target = perfRecorder;\n\n    perfRecorder.inPhase(PerfPhase.ResourceUpdate, () => {\n      if (this.compilation === null) {\n        // Analysis hasn't happened yet, so no update is necessary - any changes to resources will\n        // be captured by the inital analysis pass itself.\n        return;\n      }\n\n      this.resourceManager.invalidate();\n\n      const classesToUpdate = new Set<DeclarationNode>();\n      for (const resourceFile of changedResources) {\n        for (const templateClass of this.getComponentsWithTemplateFile(resourceFile)) {\n          classesToUpdate.add(templateClass);\n        }\n\n        for (const styleClass of this.getComponentsWithStyleFile(resourceFile)) {\n          classesToUpdate.add(styleClass);\n        }\n      }\n\n      for (const clazz of classesToUpdate) {\n        this.compilation.traitCompiler.updateResources(clazz);\n        if (!ts.isClassDeclaration(clazz)) {\n          continue;\n        }\n\n        this.compilation.templateTypeChecker.invalidateClass(clazz);\n      }\n    });\n  }\n\n  /**\n   * Get the resource dependencies of a file.\n   *\n   * If the file is not part of the compilation, an empty array will be returned.\n   */\n  getResourceDependencies(file: ts.SourceFile): string[] {\n    this.ensureAnalyzed();\n\n    return this.incrementalDriver.depGraph.getResourceDependencies(file);\n  }\n\n  /**\n   * Get all Angular-related diagnostics for this compilation.\n   */\n  getDiagnostics(): ts.Diagnostic[] {\n    return this.addMessageTextDetails(\n        [...this.getNonTemplateDiagnostics(), ...this.getTemplateDiagnostics()]);\n  }\n\n  /**\n   * Get all Angular-related diagnostics for this compilation.\n   *\n   * If a `ts.SourceFile` is passed, only diagnostics related to that file are returned.\n   */\n  getDiagnosticsForFile(file: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[] {\n    return this.addMessageTextDetails([\n      ...this.getNonTemplateDiagnostics().filter(diag => diag.file === file),\n      ...this.getTemplateDiagnosticsForFile(file, optimizeFor)\n    ]);\n  }\n\n  /**\n   * Add Angular.io error guide links to diagnostics for this compilation.\n   */\n  private addMessageTextDetails(diagnostics: ts.Diagnostic[]): ts.Diagnostic[] {\n    return diagnostics.map(diag => {\n      if (diag.code && COMPILER_ERRORS_WITH_GUIDES.has(ngErrorCode(diag.code))) {\n        return {\n          ...diag,\n          messageText: diag.messageText +\n              `. Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/NG${ngErrorCode(diag.code)}`\n        };\n      }\n      return diag;\n    });\n  }\n\n  /**\n   * Get all setup-related diagnostics for this compilation.\n   */\n  getOptionDiagnostics(): ts.Diagnostic[] {\n    return this.constructionDiagnostics;\n  }\n\n  /**\n   * Get the `ts.Program` to use as a starting point when spawning a subsequent incremental\n   * compilation.\n   *\n   * The `NgCompiler` spawns an internal incremental TypeScript compilation (inheriting the\n   * consumer's `ts.Program` into a new one for the purposes of template type-checking). After this\n   * operation, the consumer's `ts.Program` is no longer usable for starting a new incremental\n   * compilation. `getNextProgram` retrieves the `ts.Program` which can be used instead.\n   */\n  getNextProgram(): ts.Program {\n    return this.nextProgram;\n  }\n\n  getTemplateTypeChecker(): TemplateTypeChecker {\n    if (!this.enableTemplateTypeChecker) {\n      throw new Error(\n          'The `TemplateTypeChecker` does not work without `enableTemplateTypeChecker`.');\n    }\n    return this.ensureAnalyzed().templateTypeChecker;\n  }\n\n  /**\n   * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.\n   */\n  getComponentsWithTemplateFile(templateFilePath: string): ReadonlySet<DeclarationNode> {\n    const {resourceRegistry} = this.ensureAnalyzed();\n    return resourceRegistry.getComponentsWithTemplate(resolve(templateFilePath));\n  }\n\n  /**\n   * Retrieves the `ts.Declaration`s for any component(s) which use the given template file.\n   */\n  getComponentsWithStyleFile(styleFilePath: string): ReadonlySet<DeclarationNode> {\n    const {resourceRegistry} = this.ensureAnalyzed();\n    return resourceRegistry.getComponentsWithStyle(resolve(styleFilePath));\n  }\n\n  /**\n   * Retrieves external resources for the given component.\n   */\n  getComponentResources(classDecl: DeclarationNode): ComponentResources|null {\n    if (!isNamedClassDeclaration(classDecl)) {\n      return null;\n    }\n    const {resourceRegistry} = this.ensureAnalyzed();\n    const styles = resourceRegistry.getStyles(classDecl);\n    const template = resourceRegistry.getTemplate(classDecl);\n    if (template === null) {\n      return null;\n    }\n\n    return {styles, template};\n  }\n\n  /**\n   * Perform Angular's analysis step (as a precursor to `getDiagnostics` or `prepareEmit`)\n   * asynchronously.\n   *\n   * Normally, this operation happens lazily whenever `getDiagnostics` or `prepareEmit` are called.\n   * However, certain consumers may wish to allow for an asynchronous phase of analysis, where\n   * resources such as `styleUrls` are resolved asynchonously. In these cases `analyzeAsync` must be\n   * called first, and its `Promise` awaited prior to calling any other APIs of `NgCompiler`.\n   */\n  async analyzeAsync(): Promise<void> {\n    if (this.compilation !== null) {\n      return;\n    }\n\n    await this.perfRecorder.inPhase(PerfPhase.Analysis, async () => {\n      this.compilation = this.makeCompilation();\n\n      const promises: Promise<void>[] = [];\n      for (const sf of this.tsProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile) {\n          continue;\n        }\n\n        let analysisPromise = this.compilation.traitCompiler.analyzeAsync(sf);\n        this.scanForMwp(sf);\n        if (analysisPromise !== undefined) {\n          promises.push(analysisPromise);\n        }\n      }\n\n      await Promise.all(promises);\n\n      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n      this.resolveCompilation(this.compilation.traitCompiler);\n    });\n  }\n\n  /**\n   * List lazy routes detected during analysis.\n   *\n   * This can be called for one specific route, or to retrieve all top-level routes.\n   */\n  listLazyRoutes(entryRoute?: string): LazyRoute[] {\n    if (entryRoute) {\n      // htts://github.com/angular/angular/blob/50732e156/packages/compiler-cli/src/transformers/compiler_host.ts#L175-L188).\n      //\n      // `@angular/cli` will always call this API with an absolute path, so the resolution step is\n      // not necessary, but keeping it backwards compatible in case someone else is using the API.\n\n      // Relative entry paths are disallowed.\n      if (entryRoute.startsWith('.')) {\n        throw new Error(`Failed to list lazy routes: Resolution of relative paths (${\n            entryRoute}) is not supported.`);\n      }\n\n      // Non-relative entry paths fall into one of the following categories:\n      // - Absolute system paths (e.g. `/foo/bar/my-project/my-module`), which are unaffected by the\n      //   logic below.\n      // - Paths to enternal modules (e.g. `some-lib`).\n      // - Paths mapped to directories in `tsconfig.json` (e.g. `shared/my-module`).\n      //   (See https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping.)\n      //\n      // In all cases above, the `containingFile` argument is ignored, so we can just take the first\n      // of the root files.\n      const containingFile = this.tsProgram.getRootFileNames()[0];\n      const [entryPath, moduleName] = entryRoute.split('#');\n      const resolvedModule =\n          resolveModuleName(entryPath, containingFile, this.options, this.adapter, null);\n\n      if (resolvedModule) {\n        entryRoute = entryPointKeyFor(resolvedModule.resolvedFileName, moduleName);\n      }\n    }\n\n    const compilation = this.ensureAnalyzed();\n    return compilation.routeAnalyzer.listLazyRoutes(entryRoute);\n  }\n\n  /**\n   * Fetch transformers and other information which is necessary for a consumer to `emit` the\n   * program with Angular-added definitions.\n   */\n  prepareEmit(): {\n    transformers: ts.CustomTransformers,\n  } {\n    const compilation = this.ensureAnalyzed();\n\n    const coreImportsFrom = compilation.isCore ? getR3SymbolsFile(this.tsProgram) : null;\n    let importRewriter: ImportRewriter;\n    if (coreImportsFrom !== null) {\n      importRewriter = new R3SymbolsImportRewriter(coreImportsFrom.fileName);\n    } else {\n      importRewriter = new NoopImportRewriter();\n    }\n\n    const defaultImportTracker = new DefaultImportTracker();\n\n    const before = [\n      ivyTransformFactory(\n          compilation.traitCompiler, compilation.reflector, importRewriter, defaultImportTracker,\n          this.delegatingPerfRecorder, compilation.isCore, this.closureCompilerEnabled),\n      aliasTransformFactory(compilation.traitCompiler.exportStatements),\n      defaultImportTracker.importPreservingTransformer(),\n    ];\n\n    const afterDeclarations: ts.TransformerFactory<ts.SourceFile>[] = [];\n    if (compilation.dtsTransforms !== null) {\n      afterDeclarations.push(\n          declarationTransformFactory(compilation.dtsTransforms, importRewriter));\n    }\n\n    // Only add aliasing re-exports to the .d.ts output if the `AliasingHost` requests it.\n    if (compilation.aliasingHost !== null && compilation.aliasingHost.aliasExportsInDts) {\n      afterDeclarations.push(aliasTransformFactory(compilation.traitCompiler.exportStatements));\n    }\n\n    if (this.adapter.factoryTracker !== null) {\n      before.push(\n          generatedFactoryTransform(this.adapter.factoryTracker.sourceInfo, importRewriter));\n    }\n    before.push(ivySwitchTransform);\n\n    return {transformers: {before, afterDeclarations} as ts.CustomTransformers};\n  }\n\n  /**\n   * Run the indexing process and return a `Map` of all indexed components.\n   *\n   * See the `indexing` package for more details.\n   */\n  getIndexedComponents(): Map<DeclarationNode, IndexedComponent> {\n    const compilation = this.ensureAnalyzed();\n    const context = new IndexingContext();\n    compilation.traitCompiler.index(context);\n    return generateAnalysis(context);\n  }\n\n  private ensureAnalyzed(this: NgCompiler): LazyCompilationState {\n    if (this.compilation === null) {\n      this.analyzeSync();\n    }\n    return this.compilation!;\n  }\n\n  private analyzeSync(): void {\n    this.perfRecorder.inPhase(PerfPhase.Analysis, () => {\n      this.compilation = this.makeCompilation();\n      for (const sf of this.tsProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile) {\n          continue;\n        }\n        this.compilation.traitCompiler.analyzeSync(sf);\n        this.scanForMwp(sf);\n      }\n\n      this.perfRecorder.memory(PerfCheckpoint.Analysis);\n\n      this.resolveCompilation(this.compilation.traitCompiler);\n    });\n  }\n\n  private resolveCompilation(traitCompiler: TraitCompiler): void {\n    this.perfRecorder.inPhase(PerfPhase.Resolve, () => {\n      traitCompiler.resolve();\n\n      // At this point, analysis is complete and the compiler can now calculate which files need to\n      // be emitted, so do that.\n      this.incrementalDriver.recordSuccessfulAnalysis(traitCompiler);\n\n      this.perfRecorder.memory(PerfCheckpoint.Resolve);\n    });\n  }\n\n  private get fullTemplateTypeCheck(): boolean {\n    // Determine the strictness level of type checking based on compiler options. As\n    // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.\n    // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`\n    // is not disabled when `strictTemplates` is enabled.\n    const strictTemplates = !!this.options.strictTemplates;\n    return strictTemplates || !!this.options.fullTemplateTypeCheck;\n  }\n\n  private getTypeCheckingConfig(): TypeCheckingConfig {\n    // Determine the strictness level of type checking based on compiler options. As\n    // `strictTemplates` is a superset of `fullTemplateTypeCheck`, the former implies the latter.\n    // Also see `verifyCompatibleTypeCheckOptions` where it is verified that `fullTemplateTypeCheck`\n    // is not disabled when `strictTemplates` is enabled.\n    const strictTemplates = !!this.options.strictTemplates;\n\n    const useInlineTypeConstructors = this.typeCheckingProgramStrategy.supportsInlineOperations;\n\n    // First select a type-checking configuration, based on whether full template type-checking is\n    // requested.\n    let typeCheckingConfig: TypeCheckingConfig;\n    if (this.fullTemplateTypeCheck) {\n      typeCheckingConfig = {\n        applyTemplateContextGuards: strictTemplates,\n        checkQueries: false,\n        checkTemplateBodies: true,\n        alwaysCheckSchemaInTemplateBodies: true,\n        checkTypeOfInputBindings: strictTemplates,\n        honorAccessModifiersForInputBindings: false,\n        strictNullInputBindings: strictTemplates,\n        checkTypeOfAttributes: strictTemplates,\n        // Even in full template type-checking mode, DOM binding checks are not quite ready yet.\n        checkTypeOfDomBindings: false,\n        checkTypeOfOutputEvents: strictTemplates,\n        checkTypeOfAnimationEvents: strictTemplates,\n        // Checking of DOM events currently has an adverse effect on developer experience,\n        // e.g. for `<input (blur)=\"update($event.target.value)\">` enabling this check results in:\n        // - error TS2531: Object is possibly 'null'.\n        // - error TS2339: Property 'value' does not exist on type 'EventTarget'.\n        checkTypeOfDomEvents: strictTemplates,\n        checkTypeOfDomReferences: strictTemplates,\n        // Non-DOM references have the correct type in View Engine so there is no strictness flag.\n        checkTypeOfNonDomReferences: true,\n        // Pipes are checked in View Engine so there is no strictness flag.\n        checkTypeOfPipes: true,\n        strictSafeNavigationTypes: strictTemplates,\n        useContextGenericType: strictTemplates,\n        strictLiteralTypes: true,\n        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n        useInlineTypeConstructors,\n        // Warnings for suboptimal type inference are only enabled if in Language Service mode\n        // (providing the full TemplateTypeChecker API) and if strict mode is not enabled. In strict\n        // mode, the user is in full control of type inference.\n        suggestionsForSuboptimalTypeInference: this.enableTemplateTypeChecker && !strictTemplates,\n      };\n    } else {\n      typeCheckingConfig = {\n        applyTemplateContextGuards: false,\n        checkQueries: false,\n        checkTemplateBodies: false,\n        // Enable deep schema checking in \"basic\" template type-checking mode only if Closure\n        // compilation is requested, which is a good proxy for \"only in google3\".\n        alwaysCheckSchemaInTemplateBodies: this.closureCompilerEnabled,\n        checkTypeOfInputBindings: false,\n        strictNullInputBindings: false,\n        honorAccessModifiersForInputBindings: false,\n        checkTypeOfAttributes: false,\n        checkTypeOfDomBindings: false,\n        checkTypeOfOutputEvents: false,\n        checkTypeOfAnimationEvents: false,\n        checkTypeOfDomEvents: false,\n        checkTypeOfDomReferences: false,\n        checkTypeOfNonDomReferences: false,\n        checkTypeOfPipes: false,\n        strictSafeNavigationTypes: false,\n        useContextGenericType: false,\n        strictLiteralTypes: false,\n        enableTemplateTypeChecker: this.enableTemplateTypeChecker,\n        useInlineTypeConstructors,\n        // In \"basic\" template type-checking mode, no warnings are produced since most things are\n        // not checked anyways.\n        suggestionsForSuboptimalTypeInference: false,\n      };\n    }\n\n    // Apply explicitly configured strictness flags on top of the default configuration\n    // based on \"fullTemplateTypeCheck\".\n    if (this.options.strictInputTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfInputBindings = this.options.strictInputTypes;\n      typeCheckingConfig.applyTemplateContextGuards = this.options.strictInputTypes;\n    }\n    if (this.options.strictInputAccessModifiers !== undefined) {\n      typeCheckingConfig.honorAccessModifiersForInputBindings =\n          this.options.strictInputAccessModifiers;\n    }\n    if (this.options.strictNullInputTypes !== undefined) {\n      typeCheckingConfig.strictNullInputBindings = this.options.strictNullInputTypes;\n    }\n    if (this.options.strictOutputEventTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfOutputEvents = this.options.strictOutputEventTypes;\n      typeCheckingConfig.checkTypeOfAnimationEvents = this.options.strictOutputEventTypes;\n    }\n    if (this.options.strictDomEventTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfDomEvents = this.options.strictDomEventTypes;\n    }\n    if (this.options.strictSafeNavigationTypes !== undefined) {\n      typeCheckingConfig.strictSafeNavigationTypes = this.options.strictSafeNavigationTypes;\n    }\n    if (this.options.strictDomLocalRefTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfDomReferences = this.options.strictDomLocalRefTypes;\n    }\n    if (this.options.strictAttributeTypes !== undefined) {\n      typeCheckingConfig.checkTypeOfAttributes = this.options.strictAttributeTypes;\n    }\n    if (this.options.strictContextGenerics !== undefined) {\n      typeCheckingConfig.useContextGenericType = this.options.strictContextGenerics;\n    }\n    if (this.options.strictLiteralTypes !== undefined) {\n      typeCheckingConfig.strictLiteralTypes = this.options.strictLiteralTypes;\n    }\n\n    return typeCheckingConfig;\n  }\n\n  private getTemplateDiagnostics(): ReadonlyArray<ts.Diagnostic> {\n    const compilation = this.ensureAnalyzed();\n\n    // Get the diagnostics.\n    const diagnostics: ts.Diagnostic[] = [];\n    for (const sf of this.tsProgram.getSourceFiles()) {\n      if (sf.isDeclarationFile || this.adapter.isShim(sf)) {\n        continue;\n      }\n\n      diagnostics.push(\n          ...compilation.templateTypeChecker.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram));\n    }\n\n    const program = this.typeCheckingProgramStrategy.getProgram();\n    this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n    this.nextProgram = program;\n\n    return diagnostics;\n  }\n\n  private getTemplateDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor):\n      ReadonlyArray<ts.Diagnostic> {\n    const compilation = this.ensureAnalyzed();\n\n    // Get the diagnostics.\n    const diagnostics: ts.Diagnostic[] = [];\n    if (!sf.isDeclarationFile && !this.adapter.isShim(sf)) {\n      diagnostics.push(...compilation.templateTypeChecker.getDiagnosticsForFile(sf, optimizeFor));\n    }\n\n    const program = this.typeCheckingProgramStrategy.getProgram();\n    this.incrementalStrategy.setIncrementalDriver(this.incrementalDriver, program);\n    this.nextProgram = program;\n\n    return diagnostics;\n  }\n\n  private getNonTemplateDiagnostics(): ts.Diagnostic[] {\n    if (this.nonTemplateDiagnostics === null) {\n      const compilation = this.ensureAnalyzed();\n      this.nonTemplateDiagnostics = [...compilation.traitCompiler.diagnostics];\n      if (this.entryPoint !== null && compilation.exportReferenceGraph !== null) {\n        this.nonTemplateDiagnostics.push(...checkForPrivateExports(\n            this.entryPoint, this.tsProgram.getTypeChecker(), compilation.exportReferenceGraph));\n      }\n    }\n    return this.nonTemplateDiagnostics;\n  }\n\n  private scanForMwp(sf: ts.SourceFile): void {\n    this.compilation!.mwpScanner.scan(sf, {\n      addTypeReplacement: (node: ts.Declaration, type: Type): void => {\n        // Only obtain the return type transform for the source file once there's a type to replace,\n        // so that no transform is allocated when there's nothing to do.\n        this.compilation!.dtsTransforms!.getReturnTypeTransform(sf).addTypeReplacement(node, type);\n      }\n    });\n  }\n\n  private makeCompilation(): LazyCompilationState {\n    const checker = this.tsProgram.getTypeChecker();\n\n    const reflector = new TypeScriptReflectionHost(checker);\n\n    // Construct the ReferenceEmitter.\n    let refEmitter: ReferenceEmitter;\n    let aliasingHost: AliasingHost|null = null;\n    if (this.adapter.unifiedModulesHost === null || !this.options._useHostForImportGeneration) {\n      let localImportStrategy: ReferenceEmitStrategy;\n\n      // The strategy used for local, in-project imports depends on whether TS has been configured\n      // with rootDirs. If so, then multiple directories may be mapped in the same \"module\n      // namespace\" and the logic of `LogicalProjectStrategy` is required to generate correct\n      // imports which may cross these multiple directories. Otherwise, plain relative imports are\n      // sufficient.\n      if (this.options.rootDir !== undefined ||\n          (this.options.rootDirs !== undefined && this.options.rootDirs.length > 0)) {\n        // rootDirs logic is in effect - use the `LogicalProjectStrategy` for in-project relative\n        // imports.\n        localImportStrategy = new LogicalProjectStrategy(\n            reflector, new LogicalFileSystem([...this.adapter.rootDirs], this.adapter));\n      } else {\n        // Plain relative imports are all that's needed.\n        localImportStrategy = new RelativePathStrategy(reflector);\n      }\n\n      // The CompilerHost doesn't have fileNameToModuleName, so build an NPM-centric reference\n      // resolution strategy.\n      refEmitter = new ReferenceEmitter([\n        // First, try to use local identifiers if available.\n        new LocalIdentifierStrategy(),\n        // Next, attempt to use an absolute import.\n        new AbsoluteModuleStrategy(this.tsProgram, checker, this.moduleResolver, reflector),\n        // Finally, check if the reference is being written into a file within the project's .ts\n        // sources, and use a relative import if so. If this fails, ReferenceEmitter will throw\n        // an error.\n        localImportStrategy,\n      ]);\n\n      // If an entrypoint is present, then all user imports should be directed through the\n      // entrypoint and private exports are not needed. The compiler will validate that all publicly\n      // visible directives/pipes are importable via this entrypoint.\n      if (this.entryPoint === null && this.options.generateDeepReexports === true) {\n        // No entrypoint is present and deep re-exports were requested, so configure the aliasing\n        // system to generate them.\n        aliasingHost = new PrivateExportAliasingHost(reflector);\n      }\n    } else {\n      // The CompilerHost supports fileNameToModuleName, so use that to emit imports.\n      refEmitter = new ReferenceEmitter([\n        // First, try to use local identifiers if available.\n        new LocalIdentifierStrategy(),\n        // Then use aliased references (this is a workaround to StrictDeps checks).\n        new AliasStrategy(),\n        // Then use fileNameToModuleName to emit imports.\n        new UnifiedModulesStrategy(reflector, this.adapter.unifiedModulesHost),\n      ]);\n      aliasingHost = new UnifiedModulesAliasingHost(this.adapter.unifiedModulesHost);\n    }\n\n    const evaluator = new PartialEvaluator(reflector, checker, this.incrementalDriver.depGraph);\n    const dtsReader = new DtsMetadataReader(checker, reflector);\n    const localMetaRegistry = new LocalMetadataRegistry();\n    const localMetaReader: MetadataReader = localMetaRegistry;\n    const depScopeReader = new MetadataDtsModuleScopeResolver(dtsReader, aliasingHost);\n    const scopeRegistry =\n        new LocalModuleScopeRegistry(localMetaReader, depScopeReader, refEmitter, aliasingHost);\n    const scopeReader: ComponentScopeReader = scopeRegistry;\n    const semanticDepGraphUpdater = this.incrementalDriver.getSemanticDepGraphUpdater();\n    const metaRegistry = new CompoundMetadataRegistry([localMetaRegistry, scopeRegistry]);\n    const injectableRegistry = new InjectableClassRegistry(reflector);\n\n    const metaReader = new CompoundMetadataReader([localMetaReader, dtsReader]);\n    const typeCheckScopeRegistry = new TypeCheckScopeRegistry(scopeReader, metaReader);\n\n\n    // If a flat module entrypoint was specified, then track references via a `ReferenceGraph` in\n    // order to produce proper diagnostics for incorrectly exported directives/pipes/etc. If there\n    // is no flat module entrypoint then don't pay the cost of tracking references.\n    let referencesRegistry: ReferencesRegistry;\n    let exportReferenceGraph: ReferenceGraph|null = null;\n    if (this.entryPoint !== null) {\n      exportReferenceGraph = new ReferenceGraph();\n      referencesRegistry = new ReferenceGraphAdapter(exportReferenceGraph);\n    } else {\n      referencesRegistry = new NoopReferencesRegistry();\n    }\n\n    const routeAnalyzer = new NgModuleRouteAnalyzer(this.moduleResolver, evaluator);\n\n    const dtsTransforms = new DtsTransformRegistry();\n\n    const mwpScanner = new ModuleWithProvidersScanner(reflector, evaluator, refEmitter);\n\n    const isCore = isAngularCorePackage(this.tsProgram);\n\n    const resourceRegistry = new ResourceRegistry();\n\n    const compilationMode =\n        this.options.compilationMode === 'partial' ? CompilationMode.PARTIAL : CompilationMode.FULL;\n\n    // Cycles are handled in full compilation mode by \"remote scoping\".\n    // \"Remote scoping\" does not work well with tree shaking for libraries.\n    // So in partial compilation mode, when building a library, a cycle will cause an error.\n    const cycleHandlingStrategy = compilationMode === CompilationMode.FULL ?\n        CycleHandlingStrategy.UseRemoteScoping :\n        CycleHandlingStrategy.Error;\n\n    // Set up the IvyCompilation, which manages state for the Ivy transformer.\n    const handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[] = [\n      new ComponentDecoratorHandler(\n          reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry,\n          typeCheckScopeRegistry, resourceRegistry, isCore, this.resourceManager,\n          this.adapter.rootDirs, this.options.preserveWhitespaces || false,\n          this.options.i18nUseExternalIds !== false,\n          this.options.enableI18nLegacyMessageIdFormat !== false, this.usePoisonedData,\n          this.options.i18nNormalizeLineEndingsInICUs, this.moduleResolver, this.cycleAnalyzer,\n          cycleHandlingStrategy, refEmitter, this.incrementalDriver.depGraph, injectableRegistry,\n          semanticDepGraphUpdater, this.closureCompilerEnabled, this.delegatingPerfRecorder),\n\n      // TODO(alxhub): understand why the cast here is necessary (something to do with `null`\n      // not being assignable to `unknown` when wrapped in `Readonly`).\n      // clang-format off\n        new DirectiveDecoratorHandler(\n            reflector, evaluator, metaRegistry, scopeRegistry, metaReader,\n            injectableRegistry, isCore, semanticDepGraphUpdater,\n          this.closureCompilerEnabled, compileUndecoratedClassesWithAngularFeatures,\n          this.delegatingPerfRecorder,\n        ) as Readonly<DecoratorHandler<unknown, unknown, SemanticSymbol | null,unknown>>,\n      // clang-format on\n      // Pipe handler must be before injectable handler in list so pipe factories are printed\n      // before injectable factories (so injectable factories can delegate to them)\n      new PipeDecoratorHandler(\n          reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore,\n          this.delegatingPerfRecorder),\n      new InjectableDecoratorHandler(\n          reflector, isCore, this.options.strictInjectionParameters || false, injectableRegistry,\n          this.delegatingPerfRecorder),\n      new NgModuleDecoratorHandler(\n          reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore,\n          routeAnalyzer, refEmitter, this.adapter.factoryTracker, this.closureCompilerEnabled,\n          injectableRegistry, this.delegatingPerfRecorder, this.options.i18nInLocale),\n    ];\n\n    const traitCompiler = new TraitCompiler(\n        handlers, reflector, this.delegatingPerfRecorder, this.incrementalDriver,\n        this.options.compileNonExportedClasses !== false, compilationMode, dtsTransforms,\n        semanticDepGraphUpdater);\n\n    const templateTypeChecker = new TemplateTypeCheckerImpl(\n        this.tsProgram, this.typeCheckingProgramStrategy, traitCompiler,\n        this.getTypeCheckingConfig(), refEmitter, reflector, this.adapter, this.incrementalDriver,\n        scopeRegistry, typeCheckScopeRegistry, this.delegatingPerfRecorder);\n\n    return {\n      isCore,\n      traitCompiler,\n      reflector,\n      scopeRegistry,\n      dtsTransforms,\n      exportReferenceGraph,\n      routeAnalyzer,\n      mwpScanner,\n      metaReader,\n      typeCheckScopeRegistry,\n      aliasingHost,\n      refEmitter,\n      templateTypeChecker,\n      resourceRegistry,\n    };\n  }\n}\n\n/**\n * Determine if the given `Program` is @angular/core.\n */\nexport function isAngularCorePackage(program: ts.Program): boolean {\n  // Look for its_just_angular.ts somewhere in the program.\n  const r3Symbols = getR3SymbolsFile(program);\n  if (r3Symbols === null) {\n    return false;\n  }\n\n  // Look for the constant ITS_JUST_ANGULAR in that file.\n  return r3Symbols.statements.some(stmt => {\n    // The statement must be a variable declaration statement.\n    if (!ts.isVariableStatement(stmt)) {\n      return false;\n    }\n    // It must be exported.\n    if (stmt.modifiers === undefined ||\n        !stmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword)) {\n      return false;\n    }\n    // It must declare ITS_JUST_ANGULAR.\n    return stmt.declarationList.declarations.some(decl => {\n      // The declaration must match the name.\n      if (!ts.isIdentifier(decl.name) || decl.name.text !== 'ITS_JUST_ANGULAR') {\n        return false;\n      }\n      // It must initialize the variable to true.\n      if (decl.initializer === undefined || decl.initializer.kind !== ts.SyntaxKind.TrueKeyword) {\n        return false;\n      }\n      // This definition matches.\n      return true;\n    });\n  });\n}\n\n/**\n * Find the 'r3_symbols.ts' file in the given `Program`, or return `null` if it wasn't there.\n */\nfunction getR3SymbolsFile(program: ts.Program): ts.SourceFile|null {\n  return program.getSourceFiles().find(file => file.fileName.indexOf('r3_symbols.ts') >= 0) || null;\n}\n\n/**\n * Since \"strictTemplates\" is a true superset of type checking capabilities compared to\n * \"fullTemplateTypeCheck\", it is required that the latter is not explicitly disabled if the\n * former is enabled.\n */\nfunction verifyCompatibleTypeCheckOptions(options: NgCompilerOptions): ts.Diagnostic|null {\n  if (options.fullTemplateTypeCheck === false && options.strictTemplates === true) {\n    return {\n      category: ts.DiagnosticCategory.Error,\n      code: ngErrorCode(ErrorCode.CONFIG_STRICT_TEMPLATES_IMPLIES_FULL_TEMPLATE_TYPECHECK),\n      file: undefined,\n      start: undefined,\n      length: undefined,\n      messageText:\n          `Angular compiler option \"strictTemplates\" is enabled, however \"fullTemplateTypeCheck\" is disabled.\n\nHaving the \"strictTemplates\" flag enabled implies that \"fullTemplateTypeCheck\" is also enabled, so\nthe latter can not be explicitly disabled.\n\nOne of the following actions is required:\n1. Remove the \"fullTemplateTypeCheck\" option.\n2. Remove \"strictTemplates\" or set it to 'false'.\n\nMore information about the template type checking compiler options can be found in the documentation:\nhttps://v9.angular.io/guide/template-typecheck#template-type-checking`,\n    };\n  }\n\n  return null;\n}\n\nclass ReferenceGraphAdapter implements ReferencesRegistry {\n  constructor(private graph: ReferenceGraph) {}\n\n  add(source: DeclarationNode, ...references: Reference<DeclarationNode>[]): void {\n    for (const {node} of references) {\n      let sourceFile = node.getSourceFile();\n      if (sourceFile === undefined) {\n        sourceFile = ts.getOriginalNode(node).getSourceFile();\n      }\n\n      // Only record local references (not references into .d.ts files).\n      if (sourceFile === undefined || !isDtsPath(sourceFile.fileName)) {\n        this.graph.add(source, node);\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}