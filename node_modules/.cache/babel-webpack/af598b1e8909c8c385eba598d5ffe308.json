{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.areTypeParametersEqual = exports.extractSemanticTypeParameters = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ts = require(\"typescript\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util\");\n  /**\n   * Converts the type parameters of the given class into their semantic representation. If the class\n   * does not have any type parameters, then `null` is returned.\n   */\n\n\n  function extractSemanticTypeParameters(node) {\n    if (!ts.isClassDeclaration(node) || node.typeParameters === undefined) {\n      return null;\n    }\n\n    return node.typeParameters.map(function (typeParam) {\n      return {\n        hasGenericTypeBound: typeParam.constraint !== undefined\n      };\n    });\n  }\n\n  exports.extractSemanticTypeParameters = extractSemanticTypeParameters;\n  /**\n   * Compares the list of type parameters to determine if they can be considered equal.\n   */\n\n  function areTypeParametersEqual(current, previous) {\n    // First compare all type parameters one-to-one; any differences mean that the list of type\n    // parameters has changed.\n    if (!util_1.isArrayEqual(current, previous, isTypeParameterEqual)) {\n      return false;\n    } // If there is a current list of type parameters and if any of them has a generic type constraint,\n    // then the meaning of that type parameter may have changed without us being aware; as such we\n    // have to assume that the type parameters have in fact changed.\n\n\n    if (current !== null && current.some(function (typeParam) {\n      return typeParam.hasGenericTypeBound;\n    })) {\n      return false;\n    }\n\n    return true;\n  }\n\n  exports.areTypeParametersEqual = areTypeParametersEqual;\n\n  function isTypeParameterEqual(a, b) {\n    return a.hasGenericTypeBound === b.hasGenericTypeBound;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/type_parameters.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;;;;;AAMG;;AACH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAGA,MAAA,MAAA,GAAA,OAAA,CAAA,qEAAA,CAAA;AAsBA;;;AAGG;;;AACH,WAAgB,6BAAhB,CAA8C,IAA9C,EAAoE;AAElE,QAAI,CAAC,EAAE,CAAC,kBAAH,CAAsB,IAAtB,CAAD,IAAgC,IAAI,CAAC,cAAL,KAAwB,SAA5D,EAAuE;AACrE,aAAO,IAAP;AACD;;AAED,WAAO,IAAI,CAAC,cAAL,CAAoB,GAApB,CACH,UAAA,SAAA,EAAS;AAAI,aAAC;AAAC,QAAA,mBAAmB,EAAE,SAAS,CAAC,UAAV,KAAvB;AAAC,OAAD;AAA2D,KADrE,CAAP;AAED;;AARD,EAAA,OAAA,CAAA,6BAAA,GAAA,6BAAA;AAUA;;AAEG;;AACH,WAAgB,sBAAhB,CACI,OADJ,EAC2C,QAD3C,EACiF;AAC/E;AACA;AACA,QAAI,CAAC,MAAA,CAAA,YAAA,CAAa,OAAb,EAAsB,QAAtB,EAAgC,oBAAhC,CAAL,EAA4D;AAC1D,aAAO,KAAP;AACD,KAL8E,CAO/E;AACA;AACA;;;AACA,QAAI,OAAO,KAAK,IAAZ,IAAoB,OAAO,CAAC,IAAR,CAAa,UAAA,SAAA,EAAS;AAAI,aAAA,SAAS,CAAT,mBAAA;AAA6B,KAAvD,CAAxB,EAAkF;AAChF,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD;;AAhBD,EAAA,OAAA,CAAA,sBAAA,GAAA,sBAAA;;AAkBA,WAAS,oBAAT,CAA8B,CAA9B,EAAwD,CAAxD,EAAgF;AAC9E,WAAO,CAAC,CAAC,mBAAF,KAA0B,CAAC,CAAC,mBAAnC;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {ClassDeclaration} from '../../../reflection';\nimport {isArrayEqual} from './util';\n\n/**\n * Describes a generic type parameter of a semantic symbol. A class declaration with type parameters\n * needs special consideration in certain contexts. For example, template type-check blocks may\n * contain type constructors of used directives which include the type parameters of the directive.\n * As a consequence, if a change is made that affects the type parameters of said directive, any\n * template type-check blocks that use the directive need to be regenerated.\n *\n * This type represents a single generic type parameter. It currently only tracks whether the\n * type parameter has a constraint, i.e. has an `extends` clause. When a constraint is present, we\n * currently assume that the type parameter is affected in each incremental rebuild; proving that\n * a type parameter with constraint is not affected is non-trivial as it requires full semantic\n * understanding of the type constraint.\n */\nexport interface SemanticTypeParameter {\n  /**\n   * Whether a type constraint, i.e. an `extends` clause is present on the type parameter.\n   */\n  hasGenericTypeBound: boolean;\n}\n\n/**\n * Converts the type parameters of the given class into their semantic representation. If the class\n * does not have any type parameters, then `null` is returned.\n */\nexport function extractSemanticTypeParameters(node: ClassDeclaration): SemanticTypeParameter[]|\n    null {\n  if (!ts.isClassDeclaration(node) || node.typeParameters === undefined) {\n    return null;\n  }\n\n  return node.typeParameters.map(\n      typeParam => ({hasGenericTypeBound: typeParam.constraint !== undefined}));\n}\n\n/**\n * Compares the list of type parameters to determine if they can be considered equal.\n */\nexport function areTypeParametersEqual(\n    current: SemanticTypeParameter[]|null, previous: SemanticTypeParameter[]|null): boolean {\n  // First compare all type parameters one-to-one; any differences mean that the list of type\n  // parameters has changed.\n  if (!isArrayEqual(current, previous, isTypeParameterEqual)) {\n    return false;\n  }\n\n  // If there is a current list of type parameters and if any of them has a generic type constraint,\n  // then the meaning of that type parameter may have changed without us being aware; as such we\n  // have to assume that the type parameters have in fact changed.\n  if (current !== null && current.some(typeParam => typeParam.hasGenericTypeBound)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isTypeParameterEqual(a: SemanticTypeParameter, b: SemanticTypeParameter): boolean {\n  return a.hasGenericTypeBound === b.hasGenericTypeBound;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}