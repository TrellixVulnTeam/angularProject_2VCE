{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/locking/lock_file_with_child_process/index\", [\"require\", \"exports\", \"child_process\", \"@angular/compiler-cli/src/ngtsc/logging\", \"@angular/compiler-cli/ngcc/src/locking/lock_file\", \"@angular/compiler-cli/ngcc/src/locking/lock_file_with_child_process/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.LockFileWithChildProcess = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var child_process_1 = require(\"child_process\");\n\n  var logging_1 = require(\"@angular/compiler-cli/src/ngtsc/logging\");\n\n  var lock_file_1 = require(\"@angular/compiler-cli/ngcc/src/locking/lock_file\");\n\n  var util_1 = require(\"@angular/compiler-cli/ngcc/src/locking/lock_file_with_child_process/util\"); /// <reference types=\"node\" />\n\n  /**\n   * This `LockFile` implementation uses a child-process to remove the lock file when the main process\n   * exits (for whatever reason).\n   *\n   * There are a few milliseconds between the child-process being forked and it registering its\n   * `disconnect` event, which is responsible for tidying up the lock-file in the event that the main\n   * process exits unexpectedly.\n   *\n   * We eagerly create the unlocker child-process so that it maximizes the time before the lock-file\n   * is actually written, which makes it very unlikely that the unlocker would not be ready in the\n   * case that the developer hits Ctrl-C or closes the terminal within a fraction of a second of the\n   * lock-file being created.\n   *\n   * The worst case scenario is that ngcc is killed too quickly and leaves behind an orphaned\n   * lock-file. In which case the next ngcc run will display a helpful error message about deleting\n   * the lock-file.\n   */\n\n\n  var LockFileWithChildProcess =\n  /** @class */\n  function () {\n    function LockFileWithChildProcess(fs, logger) {\n      this.fs = fs;\n      this.logger = logger;\n      this.path = lock_file_1.getLockFilePath(fs);\n      this.unlocker = this.createUnlocker(this.path);\n    }\n\n    LockFileWithChildProcess.prototype.write = function () {\n      if (this.unlocker === null) {\n        // In case we already disconnected the previous unlocker child-process, perhaps by calling\n        // `remove()`. Normally the LockFile should only be used once per instance.\n        this.unlocker = this.createUnlocker(this.path);\n      }\n\n      this.logger.debug(\"Attemping to write lock-file at \" + this.path + \" with PID \" + process.pid); // To avoid race conditions, check for existence of the lock-file by trying to create it.\n      // This will throw an error if the file already exists.\n\n      this.fs.writeFile(this.path, process.pid.toString(),\n      /* exclusive */\n      true);\n      this.logger.debug(\"Written lock-file at \" + this.path + \" with PID \" + process.pid);\n    };\n\n    LockFileWithChildProcess.prototype.read = function () {\n      try {\n        return this.fs.readFile(this.path);\n      } catch (_a) {\n        return '{unknown}';\n      }\n    };\n\n    LockFileWithChildProcess.prototype.remove = function () {\n      util_1.removeLockFile(this.fs, this.logger, this.path, process.pid.toString());\n\n      if (this.unlocker !== null) {\n        // If there is an unlocker child-process then disconnect from it so that it can exit itself.\n        this.unlocker.disconnect();\n        this.unlocker = null;\n      }\n    };\n\n    LockFileWithChildProcess.prototype.createUnlocker = function (path) {\n      var _a, _b;\n\n      this.logger.debug('Forking unlocker child-process');\n      var logLevel = this.logger.level !== undefined ? this.logger.level.toString() : logging_1.LogLevel.info.toString();\n      var isWindows = process.platform === 'win32';\n      var unlocker = child_process_1.fork(__dirname + '/unlocker.js', [path, logLevel], {\n        detached: true,\n        stdio: isWindows ? 'pipe' : 'inherit'\n      });\n\n      if (isWindows) {\n        (_a = unlocker.stdout) === null || _a === void 0 ? void 0 : _a.on('data', process.stdout.write.bind(process.stdout));\n        (_b = unlocker.stderr) === null || _b === void 0 ? void 0 : _b.on('data', process.stderr.write.bind(process.stderr));\n      }\n\n      return unlocker;\n    };\n\n    return LockFileWithChildProcess;\n  }();\n\n  exports.LockFileWithChildProcess = LockFileWithChildProcess;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/ngcc/src/locking/lock_file_with_child_process/index.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ChildProcess, fork} from 'child_process';\n\nimport {AbsoluteFsPath, FileSystem} from '../../../../src/ngtsc/file_system';\nimport {Logger, LogLevel} from '../../../../src/ngtsc/logging';\nimport {getLockFilePath, LockFile} from '../lock_file';\n\nimport {removeLockFile} from './util';\n\n/// <reference types=\"node\" />\n\n/**\n * This `LockFile` implementation uses a child-process to remove the lock file when the main process\n * exits (for whatever reason).\n *\n * There are a few milliseconds between the child-process being forked and it registering its\n * `disconnect` event, which is responsible for tidying up the lock-file in the event that the main\n * process exits unexpectedly.\n *\n * We eagerly create the unlocker child-process so that it maximizes the time before the lock-file\n * is actually written, which makes it very unlikely that the unlocker would not be ready in the\n * case that the developer hits Ctrl-C or closes the terminal within a fraction of a second of the\n * lock-file being created.\n *\n * The worst case scenario is that ngcc is killed too quickly and leaves behind an orphaned\n * lock-file. In which case the next ngcc run will display a helpful error message about deleting\n * the lock-file.\n */\nexport class LockFileWithChildProcess implements LockFile {\n  path: AbsoluteFsPath;\n  private unlocker: ChildProcess|null;\n\n  constructor(protected fs: FileSystem, protected logger: Logger) {\n    this.path = getLockFilePath(fs);\n    this.unlocker = this.createUnlocker(this.path);\n  }\n\n\n  write(): void {\n    if (this.unlocker === null) {\n      // In case we already disconnected the previous unlocker child-process, perhaps by calling\n      // `remove()`. Normally the LockFile should only be used once per instance.\n      this.unlocker = this.createUnlocker(this.path);\n    }\n    this.logger.debug(`Attemping to write lock-file at ${this.path} with PID ${process.pid}`);\n    // To avoid race conditions, check for existence of the lock-file by trying to create it.\n    // This will throw an error if the file already exists.\n    this.fs.writeFile(this.path, process.pid.toString(), /* exclusive */ true);\n    this.logger.debug(`Written lock-file at ${this.path} with PID ${process.pid}`);\n  }\n\n  read(): string {\n    try {\n      return this.fs.readFile(this.path);\n    } catch {\n      return '{unknown}';\n    }\n  }\n\n  remove() {\n    removeLockFile(this.fs, this.logger, this.path, process.pid.toString());\n    if (this.unlocker !== null) {\n      // If there is an unlocker child-process then disconnect from it so that it can exit itself.\n      this.unlocker.disconnect();\n      this.unlocker = null;\n    }\n  }\n\n  protected createUnlocker(path: AbsoluteFsPath): ChildProcess {\n    this.logger.debug('Forking unlocker child-process');\n    const logLevel =\n        this.logger.level !== undefined ? this.logger.level.toString() : LogLevel.info.toString();\n    const isWindows = process.platform === 'win32';\n    const unlocker = fork(\n        __dirname + '/unlocker.js', [path, logLevel],\n        {detached: true, stdio: isWindows ? 'pipe' : 'inherit'});\n    if (isWindows) {\n      unlocker.stdout?.on('data', process.stdout.write.bind(process.stdout));\n      unlocker.stderr?.on('data', process.stderr.write.bind(process.stderr));\n    }\n    return unlocker;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}