{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/metadata/src/registry\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/metadata/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.InjectableClassRegistry = exports.CompoundMetadataRegistry = exports.LocalMetadataRegistry = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata/src/util\");\n  /**\n   * A registry of directive, pipe, and module metadata for types defined in the current compilation\n   * unit, which supports both reading and registering.\n   */\n\n\n  var LocalMetadataRegistry =\n  /** @class */\n  function () {\n    function LocalMetadataRegistry() {\n      this.directives = new Map();\n      this.ngModules = new Map();\n      this.pipes = new Map();\n    }\n\n    LocalMetadataRegistry.prototype.getDirectiveMetadata = function (ref) {\n      return this.directives.has(ref.node) ? this.directives.get(ref.node) : null;\n    };\n\n    LocalMetadataRegistry.prototype.getNgModuleMetadata = function (ref) {\n      return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node) : null;\n    };\n\n    LocalMetadataRegistry.prototype.getPipeMetadata = function (ref) {\n      return this.pipes.has(ref.node) ? this.pipes.get(ref.node) : null;\n    };\n\n    LocalMetadataRegistry.prototype.registerDirectiveMetadata = function (meta) {\n      this.directives.set(meta.ref.node, meta);\n    };\n\n    LocalMetadataRegistry.prototype.registerNgModuleMetadata = function (meta) {\n      this.ngModules.set(meta.ref.node, meta);\n    };\n\n    LocalMetadataRegistry.prototype.registerPipeMetadata = function (meta) {\n      this.pipes.set(meta.ref.node, meta);\n    };\n\n    return LocalMetadataRegistry;\n  }();\n\n  exports.LocalMetadataRegistry = LocalMetadataRegistry;\n  /**\n   * A `MetadataRegistry` which registers metdata with multiple delegate `MetadataRegistry` instances.\n   */\n\n  var CompoundMetadataRegistry =\n  /** @class */\n  function () {\n    function CompoundMetadataRegistry(registries) {\n      this.registries = registries;\n    }\n\n    CompoundMetadataRegistry.prototype.registerDirectiveMetadata = function (meta) {\n      var e_1, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.registries), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var registry = _c.value;\n          registry.registerDirectiveMetadata(meta);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    CompoundMetadataRegistry.prototype.registerNgModuleMetadata = function (meta) {\n      var e_2, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.registries), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var registry = _c.value;\n          registry.registerNgModuleMetadata(meta);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    };\n\n    CompoundMetadataRegistry.prototype.registerPipeMetadata = function (meta) {\n      var e_3, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.registries), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var registry = _c.value;\n          registry.registerPipeMetadata(meta);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    };\n\n    return CompoundMetadataRegistry;\n  }();\n\n  exports.CompoundMetadataRegistry = CompoundMetadataRegistry;\n  /**\n   * Registry that keeps track of classes that can be constructed via dependency injection (e.g.\n   * injectables, directives, pipes).\n   */\n\n  var InjectableClassRegistry =\n  /** @class */\n  function () {\n    function InjectableClassRegistry(host) {\n      this.host = host;\n      this.classes = new Set();\n    }\n\n    InjectableClassRegistry.prototype.registerInjectable = function (declaration) {\n      this.classes.add(declaration);\n    };\n\n    InjectableClassRegistry.prototype.isInjectable = function (declaration) {\n      // Figure out whether the class is injectable based on the registered classes, otherwise\n      // fall back to looking at its members since we might not have been able register the class\n      // if it was compiled already.\n      return this.classes.has(declaration) || util_1.hasInjectableFields(declaration, this.host);\n    };\n\n    return InjectableClassRegistry;\n  }();\n\n  exports.InjectableClassRegistry = InjectableClassRegistry;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/registry.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\n\nimport {DirectiveMeta, MetadataReader, MetadataRegistry, NgModuleMeta, PipeMeta} from './api';\nimport {hasInjectableFields} from './util';\n\n/**\n * A registry of directive, pipe, and module metadata for types defined in the current compilation\n * unit, which supports both reading and registering.\n */\nexport class LocalMetadataRegistry implements MetadataRegistry, MetadataReader {\n  private directives = new Map<ClassDeclaration, DirectiveMeta>();\n  private ngModules = new Map<ClassDeclaration, NgModuleMeta>();\n  private pipes = new Map<ClassDeclaration, PipeMeta>();\n\n  getDirectiveMetadata(ref: Reference<ClassDeclaration>): DirectiveMeta|null {\n    return this.directives.has(ref.node) ? this.directives.get(ref.node)! : null;\n  }\n  getNgModuleMetadata(ref: Reference<ClassDeclaration>): NgModuleMeta|null {\n    return this.ngModules.has(ref.node) ? this.ngModules.get(ref.node)! : null;\n  }\n  getPipeMetadata(ref: Reference<ClassDeclaration>): PipeMeta|null {\n    return this.pipes.has(ref.node) ? this.pipes.get(ref.node)! : null;\n  }\n\n  registerDirectiveMetadata(meta: DirectiveMeta): void {\n    this.directives.set(meta.ref.node, meta);\n  }\n  registerNgModuleMetadata(meta: NgModuleMeta): void {\n    this.ngModules.set(meta.ref.node, meta);\n  }\n  registerPipeMetadata(meta: PipeMeta): void {\n    this.pipes.set(meta.ref.node, meta);\n  }\n}\n\n/**\n * A `MetadataRegistry` which registers metdata with multiple delegate `MetadataRegistry` instances.\n */\nexport class CompoundMetadataRegistry implements MetadataRegistry {\n  constructor(private registries: MetadataRegistry[]) {}\n\n  registerDirectiveMetadata(meta: DirectiveMeta): void {\n    for (const registry of this.registries) {\n      registry.registerDirectiveMetadata(meta);\n    }\n  }\n\n  registerNgModuleMetadata(meta: NgModuleMeta): void {\n    for (const registry of this.registries) {\n      registry.registerNgModuleMetadata(meta);\n    }\n  }\n\n  registerPipeMetadata(meta: PipeMeta): void {\n    for (const registry of this.registries) {\n      registry.registerPipeMetadata(meta);\n    }\n  }\n}\n\n/**\n * Registry that keeps track of classes that can be constructed via dependency injection (e.g.\n * injectables, directives, pipes).\n */\nexport class InjectableClassRegistry {\n  private classes = new Set<ClassDeclaration>();\n\n  constructor(private host: ReflectionHost) {}\n\n  registerInjectable(declaration: ClassDeclaration): void {\n    this.classes.add(declaration);\n  }\n\n  isInjectable(declaration: ClassDeclaration): boolean {\n    // Figure out whether the class is injectable based on the registered classes, otherwise\n    // fall back to looking at its members since we might not have been able register the class\n    // if it was compiled already.\n    return this.classes.has(declaration) || hasInjectableFields(declaration, this.host);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}