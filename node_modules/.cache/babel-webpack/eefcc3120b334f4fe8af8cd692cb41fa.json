{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Hook = /*#__PURE__*/function () {\n  function Hook(args) {\n    _classCallCheck(this, Hook);\n\n    if (!Array.isArray(args)) args = [];\n    this._args = args;\n    this.taps = [];\n    this.interceptors = [];\n    this.call = this._call;\n    this.promise = this._promise;\n    this.callAsync = this._callAsync;\n    this._x = undefined;\n  }\n\n  _createClass(Hook, [{\n    key: \"compile\",\n    value: function compile(options) {\n      throw new Error(\"Abstract: should be overriden\");\n    }\n  }, {\n    key: \"_createCall\",\n    value: function _createCall(type) {\n      return this.compile({\n        taps: this.taps,\n        interceptors: this.interceptors,\n        args: this._args,\n        type: type\n      });\n    }\n  }, {\n    key: \"tap\",\n    value: function tap(options, fn) {\n      if (typeof options === \"string\") options = {\n        name: options\n      };\n      if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tap(options: Object, fn: function)\");\n      options = Object.assign({\n        type: \"sync\",\n        fn: fn\n      }, options);\n      if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tap\");\n      options = this._runRegisterInterceptors(options);\n\n      this._insert(options);\n    }\n  }, {\n    key: \"tapAsync\",\n    value: function tapAsync(options, fn) {\n      if (typeof options === \"string\") options = {\n        name: options\n      };\n      if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tapAsync(options: Object, fn: function)\");\n      options = Object.assign({\n        type: \"async\",\n        fn: fn\n      }, options);\n      if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tapAsync\");\n      options = this._runRegisterInterceptors(options);\n\n      this._insert(options);\n    }\n  }, {\n    key: \"tapPromise\",\n    value: function tapPromise(options, fn) {\n      if (typeof options === \"string\") options = {\n        name: options\n      };\n      if (typeof options !== \"object\" || options === null) throw new Error(\"Invalid arguments to tapPromise(options: Object, fn: function)\");\n      options = Object.assign({\n        type: \"promise\",\n        fn: fn\n      }, options);\n      if (typeof options.name !== \"string\" || options.name === \"\") throw new Error(\"Missing name for tapPromise\");\n      options = this._runRegisterInterceptors(options);\n\n      this._insert(options);\n    }\n  }, {\n    key: \"_runRegisterInterceptors\",\n    value: function _runRegisterInterceptors(options) {\n      var _iterator = _createForOfIteratorHelper(this.interceptors),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var interceptor = _step.value;\n\n          if (interceptor.register) {\n            var newOptions = interceptor.register(options);\n            if (newOptions !== undefined) options = newOptions;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return options;\n    }\n  }, {\n    key: \"withOptions\",\n    value: function withOptions(options) {\n      var mergeOptions = function mergeOptions(opt) {\n        return Object.assign({}, options, typeof opt === \"string\" ? {\n          name: opt\n        } : opt);\n      }; // Prevent creating endless prototype chains\n\n\n      options = Object.assign({}, options, this._withOptions);\n      var base = this._withOptionsBase || this;\n      var newHook = Object.create(base);\n      newHook.tapAsync = function (opt, fn) {\n        return base.tapAsync(mergeOptions(opt), fn);\n      }, newHook.tap = function (opt, fn) {\n        return base.tap(mergeOptions(opt), fn);\n      };\n\n      newHook.tapPromise = function (opt, fn) {\n        return base.tapPromise(mergeOptions(opt), fn);\n      };\n\n      newHook._withOptions = options;\n      newHook._withOptionsBase = base;\n      return newHook;\n    }\n  }, {\n    key: \"isUsed\",\n    value: function isUsed() {\n      return this.taps.length > 0 || this.interceptors.length > 0;\n    }\n  }, {\n    key: \"intercept\",\n    value: function intercept(interceptor) {\n      this._resetCompilation();\n\n      this.interceptors.push(Object.assign({}, interceptor));\n\n      if (interceptor.register) {\n        for (var i = 0; i < this.taps.length; i++) {\n          this.taps[i] = interceptor.register(this.taps[i]);\n        }\n      }\n    }\n  }, {\n    key: \"_resetCompilation\",\n    value: function _resetCompilation() {\n      this.call = this._call;\n      this.callAsync = this._callAsync;\n      this.promise = this._promise;\n    }\n  }, {\n    key: \"_insert\",\n    value: function _insert(item) {\n      this._resetCompilation();\n\n      var before;\n      if (typeof item.before === \"string\") before = new Set([item.before]);else if (Array.isArray(item.before)) {\n        before = new Set(item.before);\n      }\n      var stage = 0;\n      if (typeof item.stage === \"number\") stage = item.stage;\n      var i = this.taps.length;\n\n      while (i > 0) {\n        i--;\n        var x = this.taps[i];\n        this.taps[i + 1] = x;\n        var xStage = x.stage || 0;\n\n        if (before) {\n          if (before.has(x.name)) {\n            before.delete(x.name);\n            continue;\n          }\n\n          if (before.size > 0) {\n            continue;\n          }\n        }\n\n        if (xStage > stage) {\n          continue;\n        }\n\n        i++;\n        break;\n      }\n\n      this.taps[i] = item;\n    }\n  }]);\n\n  return Hook;\n}();\n\nfunction createCompileDelegate(name, type) {\n  return function lazyCompileHook() {\n    this[name] = this._createCall(type);\n    return this[name].apply(this, arguments);\n  };\n}\n\nObject.defineProperties(Hook.prototype, {\n  _call: {\n    value: createCompileDelegate(\"call\", \"sync\"),\n    configurable: true,\n    writable: true\n  },\n  _promise: {\n    value: createCompileDelegate(\"promise\", \"promise\"),\n    configurable: true,\n    writable: true\n  },\n  _callAsync: {\n    value: createCompileDelegate(\"callAsync\", \"async\"),\n    configurable: true,\n    writable: true\n  }\n});\nmodule.exports = Hook;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/tapable/lib/Hook.js"],"names":["Hook","args","Array","isArray","_args","taps","interceptors","call","_call","promise","_promise","callAsync","_callAsync","_x","undefined","options","Error","type","compile","fn","name","Object","assign","_runRegisterInterceptors","_insert","interceptor","register","newOptions","mergeOptions","opt","_withOptions","base","_withOptionsBase","newHook","create","tapAsync","tap","tapPromise","length","_resetCompilation","push","i","item","before","Set","stage","x","xStage","has","delete","size","createCompileDelegate","lazyCompileHook","_createCall","defineProperties","prototype","value","configurable","writable","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass Hook {\n\tconstructor(args) {\n\t\tif (!Array.isArray(args)) args = [];\n\t\tthis._args = args;\n\t\tthis.taps = [];\n\t\tthis.interceptors = [];\n\t\tthis.call = this._call;\n\t\tthis.promise = this._promise;\n\t\tthis.callAsync = this._callAsync;\n\t\tthis._x = undefined;\n\t}\n\n\tcompile(options) {\n\t\tthrow new Error(\"Abstract: should be overriden\");\n\t}\n\n\t_createCall(type) {\n\t\treturn this.compile({\n\t\t\ttaps: this.taps,\n\t\t\tinterceptors: this.interceptors,\n\t\t\targs: this._args,\n\t\t\ttype: type\n\t\t});\n\t}\n\n\ttap(options, fn) {\n\t\tif (typeof options === \"string\") options = { name: options };\n\t\tif (typeof options !== \"object\" || options === null)\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid arguments to tap(options: Object, fn: function)\"\n\t\t\t);\n\t\toptions = Object.assign({ type: \"sync\", fn: fn }, options);\n\t\tif (typeof options.name !== \"string\" || options.name === \"\")\n\t\t\tthrow new Error(\"Missing name for tap\");\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\ttapAsync(options, fn) {\n\t\tif (typeof options === \"string\") options = { name: options };\n\t\tif (typeof options !== \"object\" || options === null)\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid arguments to tapAsync(options: Object, fn: function)\"\n\t\t\t);\n\t\toptions = Object.assign({ type: \"async\", fn: fn }, options);\n\t\tif (typeof options.name !== \"string\" || options.name === \"\")\n\t\t\tthrow new Error(\"Missing name for tapAsync\");\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\ttapPromise(options, fn) {\n\t\tif (typeof options === \"string\") options = { name: options };\n\t\tif (typeof options !== \"object\" || options === null)\n\t\t\tthrow new Error(\n\t\t\t\t\"Invalid arguments to tapPromise(options: Object, fn: function)\"\n\t\t\t);\n\t\toptions = Object.assign({ type: \"promise\", fn: fn }, options);\n\t\tif (typeof options.name !== \"string\" || options.name === \"\")\n\t\t\tthrow new Error(\"Missing name for tapPromise\");\n\t\toptions = this._runRegisterInterceptors(options);\n\t\tthis._insert(options);\n\t}\n\n\t_runRegisterInterceptors(options) {\n\t\tfor (const interceptor of this.interceptors) {\n\t\t\tif (interceptor.register) {\n\t\t\t\tconst newOptions = interceptor.register(options);\n\t\t\t\tif (newOptions !== undefined) options = newOptions;\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\n\twithOptions(options) {\n\t\tconst mergeOptions = opt =>\n\t\t\tObject.assign({}, options, typeof opt === \"string\" ? { name: opt } : opt);\n\n\t\t// Prevent creating endless prototype chains\n\t\toptions = Object.assign({}, options, this._withOptions);\n\t\tconst base = this._withOptionsBase || this;\n\t\tconst newHook = Object.create(base);\n\n\t\t(newHook.tapAsync = (opt, fn) => base.tapAsync(mergeOptions(opt), fn)),\n\t\t\t(newHook.tap = (opt, fn) => base.tap(mergeOptions(opt), fn));\n\t\tnewHook.tapPromise = (opt, fn) => base.tapPromise(mergeOptions(opt), fn);\n\t\tnewHook._withOptions = options;\n\t\tnewHook._withOptionsBase = base;\n\t\treturn newHook;\n\t}\n\n\tisUsed() {\n\t\treturn this.taps.length > 0 || this.interceptors.length > 0;\n\t}\n\n\tintercept(interceptor) {\n\t\tthis._resetCompilation();\n\t\tthis.interceptors.push(Object.assign({}, interceptor));\n\t\tif (interceptor.register) {\n\t\t\tfor (let i = 0; i < this.taps.length; i++)\n\t\t\t\tthis.taps[i] = interceptor.register(this.taps[i]);\n\t\t}\n\t}\n\n\t_resetCompilation() {\n\t\tthis.call = this._call;\n\t\tthis.callAsync = this._callAsync;\n\t\tthis.promise = this._promise;\n\t}\n\n\t_insert(item) {\n\t\tthis._resetCompilation();\n\t\tlet before;\n\t\tif (typeof item.before === \"string\") before = new Set([item.before]);\n\t\telse if (Array.isArray(item.before)) {\n\t\t\tbefore = new Set(item.before);\n\t\t}\n\t\tlet stage = 0;\n\t\tif (typeof item.stage === \"number\") stage = item.stage;\n\t\tlet i = this.taps.length;\n\t\twhile (i > 0) {\n\t\t\ti--;\n\t\t\tconst x = this.taps[i];\n\t\t\tthis.taps[i + 1] = x;\n\t\t\tconst xStage = x.stage || 0;\n\t\t\tif (before) {\n\t\t\t\tif (before.has(x.name)) {\n\t\t\t\t\tbefore.delete(x.name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (before.size > 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (xStage > stage) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti++;\n\t\t\tbreak;\n\t\t}\n\t\tthis.taps[i] = item;\n\t}\n}\n\nfunction createCompileDelegate(name, type) {\n\treturn function lazyCompileHook(...args) {\n\t\tthis[name] = this._createCall(type);\n\t\treturn this[name](...args);\n\t};\n}\n\nObject.defineProperties(Hook.prototype, {\n\t_call: {\n\t\tvalue: createCompileDelegate(\"call\", \"sync\"),\n\t\tconfigurable: true,\n\t\twritable: true\n\t},\n\t_promise: {\n\t\tvalue: createCompileDelegate(\"promise\", \"promise\"),\n\t\tconfigurable: true,\n\t\twritable: true\n\t},\n\t_callAsync: {\n\t\tvalue: createCompileDelegate(\"callAsync\", \"async\"),\n\t\tconfigurable: true,\n\t\twritable: true\n\t}\n});\n\nmodule.exports = Hook;\n"]},"metadata":{},"sourceType":"script"}