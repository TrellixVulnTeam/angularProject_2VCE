{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/shims/src/adapter\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/shims/src/expando\", \"@angular/compiler-cli/src/ngtsc/shims/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ShimAdapter = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var expando_1 = require(\"@angular/compiler-cli/src/ngtsc/shims/src/expando\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/shims/src/util\");\n  /**\n   * Generates and tracks shim files for each original `ts.SourceFile`.\n   *\n   * The `ShimAdapter` provides an API that's designed to be used by a `ts.CompilerHost`\n   * implementation and allows it to include synthetic \"shim\" files in the program that's being\n   * created. It works for both freshly created programs as well as with reuse of an older program\n   * (which already may contain shim files and thus have a different creation flow).\n   */\n\n\n  var ShimAdapter =\n  /** @class */\n  function () {\n    function ShimAdapter(delegate, tsRootFiles, topLevelGenerators, perFileGenerators, oldProgram) {\n      var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;\n\n      this.delegate = delegate;\n      /**\n       * A map of shim file names to the `ts.SourceFile` generated for those shims.\n       */\n\n      this.shims = new Map();\n      /**\n       * A map of shim file names to existing shims which were part of a previous iteration of this\n       * program.\n       *\n       * Not all of these shims will be inherited into this program.\n       */\n\n      this.priorShims = new Map();\n      /**\n       * File names which are already known to not be shims.\n       *\n       * This allows for short-circuit returns without the expense of running regular expressions\n       * against the filename repeatedly.\n       */\n\n      this.notShims = new Set();\n      /**\n       * The shim generators supported by this adapter as well as extra precalculated data facilitating\n       * their use.\n       */\n\n      this.generators = [];\n      /**\n       * A `Set` of shim `ts.SourceFile`s which should not be emitted.\n       */\n\n      this.ignoreForEmit = new Set();\n      /**\n       * Extension prefixes of all installed per-file shims.\n       */\n\n      this.extensionPrefixes = [];\n\n      try {\n        // Initialize `this.generators` with a regex that matches each generator's paths.\n        for (var perFileGenerators_1 = tslib_1.__values(perFileGenerators), perFileGenerators_1_1 = perFileGenerators_1.next(); !perFileGenerators_1_1.done; perFileGenerators_1_1 = perFileGenerators_1.next()) {\n          var gen = perFileGenerators_1_1.value; // This regex matches paths for shims from this generator. The first (and only) capture group\n          // extracts the filename prefix, which can be used to find the original file that was used to\n          // generate this shim.\n\n          var pattern = \"^(.*)\\\\.\" + gen.extensionPrefix + \"\\\\.ts$\";\n          var regexp = new RegExp(pattern, 'i');\n          this.generators.push({\n            generator: gen,\n            test: regexp,\n            suffix: \".\" + gen.extensionPrefix + \".ts\"\n          });\n          this.extensionPrefixes.push(gen.extensionPrefix);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (perFileGenerators_1_1 && !perFileGenerators_1_1.done && (_a = perFileGenerators_1.return)) _a.call(perFileGenerators_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Process top-level generators and pre-generate their shims. Accumulate the list of filenames\n      // as extra input files.\n\n\n      var extraInputFiles = [];\n\n      try {\n        for (var topLevelGenerators_1 = tslib_1.__values(topLevelGenerators), topLevelGenerators_1_1 = topLevelGenerators_1.next(); !topLevelGenerators_1_1.done; topLevelGenerators_1_1 = topLevelGenerators_1.next()) {\n          var gen = topLevelGenerators_1_1.value;\n          var sf = gen.makeTopLevelShim();\n          expando_1.sfExtensionData(sf).isTopLevelShim = true;\n\n          if (!gen.shouldEmit) {\n            this.ignoreForEmit.add(sf);\n          }\n\n          var fileName = file_system_1.absoluteFromSourceFile(sf);\n          this.shims.set(fileName, sf);\n          extraInputFiles.push(fileName);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (topLevelGenerators_1_1 && !topLevelGenerators_1_1.done && (_b = topLevelGenerators_1.return)) _b.call(topLevelGenerators_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      try {\n        // Add to that list the per-file shims associated with each root file. This is needed because\n        // reference tagging alone may not work in TS compilations that have `noResolve` set. Such\n        // compilations rely on the list of input files completely describing the program.\n        for (var tsRootFiles_1 = tslib_1.__values(tsRootFiles), tsRootFiles_1_1 = tsRootFiles_1.next(); !tsRootFiles_1_1.done; tsRootFiles_1_1 = tsRootFiles_1.next()) {\n          var rootFile = tsRootFiles_1_1.value;\n\n          try {\n            for (var _f = (e_4 = void 0, tslib_1.__values(this.generators)), _g = _f.next(); !_g.done; _g = _f.next()) {\n              var gen = _g.value;\n              extraInputFiles.push(util_1.makeShimFileName(rootFile, gen.suffix));\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_g && !_g.done && (_d = _f.return)) _d.call(_f);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (tsRootFiles_1_1 && !tsRootFiles_1_1.done && (_c = tsRootFiles_1.return)) _c.call(tsRootFiles_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      this.extraInputFiles = extraInputFiles; // If an old program is present, extract all per-file shims into a map, which will be used to\n      // generate new versions of those shims.\n\n      if (oldProgram !== null) {\n        try {\n          for (var _h = tslib_1.__values(oldProgram.getSourceFiles()), _j = _h.next(); !_j.done; _j = _h.next()) {\n            var oldSf = _j.value;\n\n            if (oldSf.isDeclarationFile || !expando_1.isFileShimSourceFile(oldSf)) {\n              continue;\n            }\n\n            this.priorShims.set(file_system_1.absoluteFromSourceFile(oldSf), oldSf);\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (_j && !_j.done && (_e = _h.return)) _e.call(_h);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n      }\n    }\n    /**\n     * Produce a shim `ts.SourceFile` if `fileName` refers to a shim file which should exist in the\n     * program.\n     *\n     * If `fileName` does not refer to a potential shim file, `null` is returned. If a corresponding\n     * base file could not be determined, `undefined` is returned instead.\n     */\n\n\n    ShimAdapter.prototype.maybeGenerate = function (fileName) {\n      var e_6, _a; // Fast path: either this filename has been proven not to be a shim before, or it is a known\n      // shim and no generation is required.\n\n\n      if (this.notShims.has(fileName)) {\n        return null;\n      } else if (this.shims.has(fileName)) {\n        return this.shims.get(fileName);\n      } // .d.ts files can't be shims.\n\n\n      if (typescript_1.isDtsPath(fileName)) {\n        this.notShims.add(fileName);\n        return null;\n      }\n\n      try {\n        // This is the first time seeing this path. Try to match it against a shim generator.\n        for (var _b = tslib_1.__values(this.generators), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var record = _c.value;\n          var match = record.test.exec(fileName);\n\n          if (match === null) {\n            continue;\n          } // The path matched. Extract the filename prefix without the extension.\n\n\n          var prefix = match[1]; // This _might_ be a shim, if an underlying base file exists. The base file might be .ts or\n          // .tsx.\n\n          var baseFileName = file_system_1.absoluteFrom(prefix + '.ts');\n\n          if (!this.delegate.fileExists(baseFileName)) {\n            // No .ts file by that name - try .tsx.\n            baseFileName = file_system_1.absoluteFrom(prefix + '.tsx');\n\n            if (!this.delegate.fileExists(baseFileName)) {\n              // This isn't a shim after all since there is no original file which would have triggered\n              // its generation, even though the path is right. There are a few reasons why this could\n              // occur:\n              //\n              // * when resolving an import to an .ngfactory.d.ts file, the module resolution algorithm\n              //   will first look for an .ngfactory.ts file in its place, which will be requested here.\n              // * when the user writes a bad import.\n              // * when a file is present in one compilation and removed in the next incremental step.\n              //\n              // Note that this does not add the filename to `notShims`, so this path is not cached.\n              // That's okay as these cases above are edge cases and do not occur regularly in normal\n              // operations.\n              return undefined;\n            }\n          } // Retrieve the original file for which the shim will be generated.\n\n\n          var inputFile = this.delegate.getSourceFile(baseFileName, ts.ScriptTarget.Latest);\n\n          if (inputFile === undefined || expando_1.isShim(inputFile)) {\n            // Something strange happened here. This case is also not cached in `notShims`, but this\n            // path is not expected to occur in reality so this shouldn't be a problem.\n            return undefined;\n          } // Actually generate and cache the shim.\n\n\n          return this.generateSpecific(fileName, record.generator, inputFile);\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      } // No generator matched.\n\n\n      this.notShims.add(fileName);\n      return null;\n    };\n\n    ShimAdapter.prototype.generateSpecific = function (fileName, generator, inputFile) {\n      var priorShimSf = null;\n\n      if (this.priorShims.has(fileName)) {\n        // In the previous program a shim with this name already existed. It's passed to the shim\n        // generator which may reuse it instead of generating a fresh shim.\n        priorShimSf = this.priorShims.get(fileName);\n        this.priorShims.delete(fileName);\n      }\n\n      var shimSf = generator.generateShimForFile(inputFile, fileName, priorShimSf); // Mark the new generated source file as a shim that originated from this generator.\n\n      expando_1.sfExtensionData(shimSf).fileShim = {\n        extension: generator.extensionPrefix,\n        generatedFrom: file_system_1.absoluteFromSourceFile(inputFile)\n      };\n\n      if (!generator.shouldEmit) {\n        this.ignoreForEmit.add(shimSf);\n      }\n\n      this.shims.set(fileName, shimSf);\n      return shimSf;\n    };\n\n    return ShimAdapter;\n  }();\n\n  exports.ShimAdapter = ShimAdapter;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/adapter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\nimport {isDtsPath} from '../../util/src/typescript';\nimport {PerFileShimGenerator, TopLevelShimGenerator} from '../api';\n\nimport {isFileShimSourceFile, isShim, sfExtensionData} from './expando';\nimport {makeShimFileName} from './util';\n\ninterface ShimGeneratorData {\n  generator: PerFileShimGenerator;\n  test: RegExp;\n  suffix: string;\n}\n\n/**\n * Generates and tracks shim files for each original `ts.SourceFile`.\n *\n * The `ShimAdapter` provides an API that's designed to be used by a `ts.CompilerHost`\n * implementation and allows it to include synthetic \"shim\" files in the program that's being\n * created. It works for both freshly created programs as well as with reuse of an older program\n * (which already may contain shim files and thus have a different creation flow).\n */\nexport class ShimAdapter {\n  /**\n   * A map of shim file names to the `ts.SourceFile` generated for those shims.\n   */\n  private shims = new Map<AbsoluteFsPath, ts.SourceFile>();\n\n  /**\n   * A map of shim file names to existing shims which were part of a previous iteration of this\n   * program.\n   *\n   * Not all of these shims will be inherited into this program.\n   */\n  private priorShims = new Map<AbsoluteFsPath, ts.SourceFile>();\n\n  /**\n   * File names which are already known to not be shims.\n   *\n   * This allows for short-circuit returns without the expense of running regular expressions\n   * against the filename repeatedly.\n   */\n  private notShims = new Set<AbsoluteFsPath>();\n\n  /**\n   * The shim generators supported by this adapter as well as extra precalculated data facilitating\n   * their use.\n   */\n  private generators: ShimGeneratorData[] = [];\n\n  /**\n   * A `Set` of shim `ts.SourceFile`s which should not be emitted.\n   */\n  readonly ignoreForEmit = new Set<ts.SourceFile>();\n\n  /**\n   * A list of extra filenames which should be considered inputs to program creation.\n   *\n   * This includes any top-level shims generated for the program, as well as per-file shim names for\n   * those files which are included in the root files of the program.\n   */\n  readonly extraInputFiles: ReadonlyArray<AbsoluteFsPath>;\n\n  /**\n   * Extension prefixes of all installed per-file shims.\n   */\n  readonly extensionPrefixes: string[] = [];\n\n  constructor(\n      private delegate: Pick<ts.CompilerHost, 'getSourceFile'|'fileExists'>,\n      tsRootFiles: AbsoluteFsPath[], topLevelGenerators: TopLevelShimGenerator[],\n      perFileGenerators: PerFileShimGenerator[], oldProgram: ts.Program|null) {\n    // Initialize `this.generators` with a regex that matches each generator's paths.\n    for (const gen of perFileGenerators) {\n      // This regex matches paths for shims from this generator. The first (and only) capture group\n      // extracts the filename prefix, which can be used to find the original file that was used to\n      // generate this shim.\n      const pattern = `^(.*)\\\\.${gen.extensionPrefix}\\\\.ts$`;\n      const regexp = new RegExp(pattern, 'i');\n      this.generators.push({\n        generator: gen,\n        test: regexp,\n        suffix: `.${gen.extensionPrefix}.ts`,\n      });\n      this.extensionPrefixes.push(gen.extensionPrefix);\n    }\n    // Process top-level generators and pre-generate their shims. Accumulate the list of filenames\n    // as extra input files.\n    const extraInputFiles: AbsoluteFsPath[] = [];\n\n    for (const gen of topLevelGenerators) {\n      const sf = gen.makeTopLevelShim();\n      sfExtensionData(sf).isTopLevelShim = true;\n\n      if (!gen.shouldEmit) {\n        this.ignoreForEmit.add(sf);\n      }\n\n      const fileName = absoluteFromSourceFile(sf);\n      this.shims.set(fileName, sf);\n      extraInputFiles.push(fileName);\n    }\n\n    // Add to that list the per-file shims associated with each root file. This is needed because\n    // reference tagging alone may not work in TS compilations that have `noResolve` set. Such\n    // compilations rely on the list of input files completely describing the program.\n    for (const rootFile of tsRootFiles) {\n      for (const gen of this.generators) {\n        extraInputFiles.push(makeShimFileName(rootFile, gen.suffix));\n      }\n    }\n\n    this.extraInputFiles = extraInputFiles;\n\n    // If an old program is present, extract all per-file shims into a map, which will be used to\n    // generate new versions of those shims.\n    if (oldProgram !== null) {\n      for (const oldSf of oldProgram.getSourceFiles()) {\n        if (oldSf.isDeclarationFile || !isFileShimSourceFile(oldSf)) {\n          continue;\n        }\n\n        this.priorShims.set(absoluteFromSourceFile(oldSf), oldSf);\n      }\n    }\n  }\n\n  /**\n   * Produce a shim `ts.SourceFile` if `fileName` refers to a shim file which should exist in the\n   * program.\n   *\n   * If `fileName` does not refer to a potential shim file, `null` is returned. If a corresponding\n   * base file could not be determined, `undefined` is returned instead.\n   */\n  maybeGenerate(fileName: AbsoluteFsPath): ts.SourceFile|null|undefined {\n    // Fast path: either this filename has been proven not to be a shim before, or it is a known\n    // shim and no generation is required.\n    if (this.notShims.has(fileName)) {\n      return null;\n    } else if (this.shims.has(fileName)) {\n      return this.shims.get(fileName)!;\n    }\n\n    // .d.ts files can't be shims.\n    if (isDtsPath(fileName)) {\n      this.notShims.add(fileName);\n      return null;\n    }\n\n    // This is the first time seeing this path. Try to match it against a shim generator.\n    for (const record of this.generators) {\n      const match = record.test.exec(fileName);\n      if (match === null) {\n        continue;\n      }\n\n      // The path matched. Extract the filename prefix without the extension.\n      const prefix = match[1];\n      // This _might_ be a shim, if an underlying base file exists. The base file might be .ts or\n      // .tsx.\n      let baseFileName = absoluteFrom(prefix + '.ts');\n      if (!this.delegate.fileExists(baseFileName)) {\n        // No .ts file by that name - try .tsx.\n        baseFileName = absoluteFrom(prefix + '.tsx');\n        if (!this.delegate.fileExists(baseFileName)) {\n          // This isn't a shim after all since there is no original file which would have triggered\n          // its generation, even though the path is right. There are a few reasons why this could\n          // occur:\n          //\n          // * when resolving an import to an .ngfactory.d.ts file, the module resolution algorithm\n          //   will first look for an .ngfactory.ts file in its place, which will be requested here.\n          // * when the user writes a bad import.\n          // * when a file is present in one compilation and removed in the next incremental step.\n          //\n          // Note that this does not add the filename to `notShims`, so this path is not cached.\n          // That's okay as these cases above are edge cases and do not occur regularly in normal\n          // operations.\n          return undefined;\n        }\n      }\n\n      // Retrieve the original file for which the shim will be generated.\n      const inputFile = this.delegate.getSourceFile(baseFileName, ts.ScriptTarget.Latest);\n      if (inputFile === undefined || isShim(inputFile)) {\n        // Something strange happened here. This case is also not cached in `notShims`, but this\n        // path is not expected to occur in reality so this shouldn't be a problem.\n        return undefined;\n      }\n\n      // Actually generate and cache the shim.\n      return this.generateSpecific(fileName, record.generator, inputFile);\n    }\n\n    // No generator matched.\n    this.notShims.add(fileName);\n    return null;\n  }\n\n  private generateSpecific(\n      fileName: AbsoluteFsPath, generator: PerFileShimGenerator,\n      inputFile: ts.SourceFile): ts.SourceFile {\n    let priorShimSf: ts.SourceFile|null = null;\n    if (this.priorShims.has(fileName)) {\n      // In the previous program a shim with this name already existed. It's passed to the shim\n      // generator which may reuse it instead of generating a fresh shim.\n\n      priorShimSf = this.priorShims.get(fileName)!;\n      this.priorShims.delete(fileName);\n    }\n\n    const shimSf = generator.generateShimForFile(inputFile, fileName, priorShimSf);\n\n    // Mark the new generated source file as a shim that originated from this generator.\n    sfExtensionData(shimSf).fileShim = {\n      extension: generator.extensionPrefix,\n      generatedFrom: absoluteFromSourceFile(inputFile),\n    };\n\n    if (!generator.shouldEmit) {\n      this.ignoreForEmit.add(shimSf);\n    }\n\n    this.shims.set(fileName, shimSf);\n    return shimSf;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}