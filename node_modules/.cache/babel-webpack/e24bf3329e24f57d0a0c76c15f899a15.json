{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/tasks/queues/parallel_task_queue\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/execution/tasks/utils\", \"@angular/compiler-cli/ngcc/src/execution/tasks/queues/base_task_queue\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ParallelTaskQueue = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/utils\");\n\n  var base_task_queue_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/queues/base_task_queue\");\n  /**\n   * A `TaskQueue` implementation that assumes tasks are processed in parallel, thus has to ensure a\n   * task's dependencies have been processed before processing the task.\n   */\n\n\n  var ParallelTaskQueue =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ParallelTaskQueue, _super);\n\n    function ParallelTaskQueue(logger, tasks, dependencies) {\n      var _this = _super.call(this, logger, utils_1.sortTasksByPriority(tasks, dependencies), dependencies) || this;\n\n      _this.blockedTasks = utils_1.getBlockedTasks(dependencies);\n      return _this;\n    }\n\n    ParallelTaskQueue.prototype.computeNextTask = function () {\n      var _this = this; // Look for the first available (i.e. not blocked) task.\n      // (NOTE: Since tasks are sorted by priority, the first available one is the best choice.)\n\n\n      var nextTaskIdx = this.tasks.findIndex(function (task) {\n        return !_this.blockedTasks.has(task);\n      });\n      if (nextTaskIdx === -1) return null; // Remove the task from the list of available tasks and add it to the list of in-progress tasks.\n\n      var nextTask = this.tasks[nextTaskIdx];\n      this.tasks.splice(nextTaskIdx, 1);\n      this.inProgressTasks.add(nextTask);\n      return nextTask;\n    };\n\n    ParallelTaskQueue.prototype.markAsCompleted = function (task) {\n      var e_1, _a;\n\n      _super.prototype.markAsCompleted.call(this, task);\n\n      if (!this.dependencies.has(task)) {\n        return;\n      }\n\n      try {\n        // Unblock the tasks that are dependent upon `task`\n        for (var _b = tslib_1.__values(this.dependencies.get(task)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var dependentTask = _c.value;\n\n          if (this.blockedTasks.has(dependentTask)) {\n            var blockingTasks = this.blockedTasks.get(dependentTask); // Remove the completed task from the lists of tasks blocking other tasks.\n\n            blockingTasks.delete(task);\n\n            if (blockingTasks.size === 0) {\n              // If the dependent task is not blocked any more, mark it for unblocking.\n              this.blockedTasks.delete(dependentTask);\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    ParallelTaskQueue.prototype.toString = function () {\n      return _super.prototype.toString.call(this) + \"\\n\" + (\"  Blocked tasks (\" + this.blockedTasks.size + \"): \" + this.stringifyBlockedTasks('    '));\n    };\n\n    ParallelTaskQueue.prototype.stringifyBlockedTasks = function (indentation) {\n      var _this = this;\n\n      return Array.from(this.blockedTasks).map(function (_a) {\n        var _b = tslib_1.__read(_a, 2),\n            task = _b[0],\n            blockingTasks = _b[1];\n\n        return \"\\n\" + indentation + \"- \" + utils_1.stringifyTask(task) + \" (\" + blockingTasks.size + \"): \" + _this.stringifyTasks(Array.from(blockingTasks), indentation + \"    \");\n      }).join('');\n    };\n\n    return ParallelTaskQueue;\n  }(base_task_queue_1.BaseTaskQueue);\n\n  exports.ParallelTaskQueue = ParallelTaskQueue;\n});","map":{"version":3,"sources":["../../../../../../../../../../packages/compiler-cli/ngcc/src/execution/tasks/queues/parallel_task_queue.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Logger} from '../../../../../src/ngtsc/logging';\nimport {PartiallyOrderedTasks, Task, TaskDependencies} from '../api';\nimport {getBlockedTasks, sortTasksByPriority, stringifyTask} from '../utils';\nimport {BaseTaskQueue} from './base_task_queue';\n\n/**\n * A `TaskQueue` implementation that assumes tasks are processed in parallel, thus has to ensure a\n * task's dependencies have been processed before processing the task.\n */\nexport class ParallelTaskQueue extends BaseTaskQueue {\n  /**\n   * A map from Tasks to the Tasks that it depends upon.\n   *\n   * This is the reverse mapping of `TaskDependencies`.\n   */\n  private blockedTasks: Map<Task, Set<Task>>;\n\n  constructor(logger: Logger, tasks: PartiallyOrderedTasks, dependencies: TaskDependencies) {\n    super(logger, sortTasksByPriority(tasks, dependencies), dependencies);\n    this.blockedTasks = getBlockedTasks(dependencies);\n  }\n\n  computeNextTask(): Task|null {\n    // Look for the first available (i.e. not blocked) task.\n    // (NOTE: Since tasks are sorted by priority, the first available one is the best choice.)\n    const nextTaskIdx = this.tasks.findIndex(task => !this.blockedTasks.has(task));\n    if (nextTaskIdx === -1) return null;\n\n    // Remove the task from the list of available tasks and add it to the list of in-progress tasks.\n    const nextTask = this.tasks[nextTaskIdx];\n    this.tasks.splice(nextTaskIdx, 1);\n    this.inProgressTasks.add(nextTask);\n\n    return nextTask;\n  }\n\n  markAsCompleted(task: Task): void {\n    super.markAsCompleted(task);\n\n    if (!this.dependencies.has(task)) {\n      return;\n    }\n\n    // Unblock the tasks that are dependent upon `task`\n    for (const dependentTask of this.dependencies.get(task)!) {\n      if (this.blockedTasks.has(dependentTask)) {\n        const blockingTasks = this.blockedTasks.get(dependentTask)!;\n        // Remove the completed task from the lists of tasks blocking other tasks.\n        blockingTasks.delete(task);\n        if (blockingTasks.size === 0) {\n          // If the dependent task is not blocked any more, mark it for unblocking.\n          this.blockedTasks.delete(dependentTask);\n        }\n      }\n    }\n  }\n\n  toString(): string {\n    return `${super.toString()}\\n` +\n        `  Blocked tasks (${this.blockedTasks.size}): ${this.stringifyBlockedTasks('    ')}`;\n  }\n\n  private stringifyBlockedTasks(indentation: string): string {\n    return Array.from(this.blockedTasks)\n        .map(\n            ([task, blockingTasks]) =>\n                `\\n${indentation}- ${stringifyTask(task)} (${blockingTasks.size}): ` +\n                this.stringifyTasks(Array.from(blockingTasks), `${indentation}    `))\n        .join('');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}