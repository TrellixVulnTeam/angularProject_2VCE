{"ast":null,"code":"var debug = require(\"debug\")(\"streamroller:fileNameParser\");\n\nvar FILENAME_SEP = \".\";\nvar ZIP_EXT = \".gz\";\n\nvar format = require(\"date-format\");\n\nmodule.exports = function (_ref) {\n  var file = _ref.file,\n      keepFileExt = _ref.keepFileExt,\n      pattern = _ref.pattern;\n\n  // All these functions take two arguments: f, the filename, and p, the result placeholder\n  // They return the filename with any matching parts removed.\n  // The \"zip\" function, for instance, removes the \".gz\" part of the filename (if present)\n  var zip = function zip(f, p) {\n    if (f.endsWith(ZIP_EXT)) {\n      debug(\"it is gzipped\");\n      p.isCompressed = true;\n      return f.slice(0, -1 * ZIP_EXT.length);\n    }\n\n    return f;\n  };\n\n  var __NOT_MATCHING__ = \"__NOT_MATCHING__\";\n\n  var extAtEnd = function extAtEnd(f) {\n    if (f.startsWith(file.name) && f.endsWith(file.ext)) {\n      debug(\"it starts and ends with the right things\");\n      return f.slice(file.name.length + 1, -1 * file.ext.length);\n    }\n\n    return __NOT_MATCHING__;\n  };\n\n  var extInMiddle = function extInMiddle(f) {\n    if (f.startsWith(file.base)) {\n      debug(\"it starts with the right things\");\n      return f.slice(file.base.length + 1);\n    }\n\n    return __NOT_MATCHING__;\n  };\n\n  var dateAndIndex = function dateAndIndex(f, p) {\n    var items = f.split(FILENAME_SEP);\n    var indexStr = items[items.length - 1];\n    debug(\"items: \", items, \", indexStr: \", indexStr);\n    var dateStr = f;\n\n    if (indexStr !== undefined && indexStr.match(/^\\d+$/)) {\n      dateStr = f.slice(0, -1 * (indexStr.length + 1));\n      debug(\"dateStr is \".concat(dateStr));\n\n      if (pattern && !dateStr) {\n        dateStr = indexStr;\n        indexStr = \"0\";\n      }\n    } else {\n      indexStr = \"0\";\n    }\n\n    try {\n      // Two arguments for new Date() are intentional. This will set other date\n      // components to minimal values in the current timezone instead of UTC,\n      // as new Date(0) will do.\n      var date = format.parse(pattern, dateStr, new Date(0, 0));\n      if (format.asString(pattern, date) !== dateStr) return f;\n      p.index = parseInt(indexStr, 10);\n      p.date = dateStr;\n      p.timestamp = date.getTime();\n      return \"\";\n    } catch (e) {\n      //not a valid date, don't panic.\n      debug(\"Problem parsing \".concat(dateStr, \" as \").concat(pattern, \", error was: \"), e);\n      return f;\n    }\n  };\n\n  var index = function index(f, p) {\n    if (f.match(/^\\d+$/)) {\n      debug(\"it has an index\");\n      p.index = parseInt(f, 10);\n      return \"\";\n    }\n\n    return f;\n  };\n\n  var parts = [zip, keepFileExt ? extAtEnd : extInMiddle, pattern ? dateAndIndex : index];\n  return function (filename) {\n    var result = {\n      filename: filename,\n      index: 0,\n      isCompressed: false\n    }; // pass the filename through each of the file part parsers\n\n    var whatsLeftOver = parts.reduce(function (remains, part) {\n      return part(remains, result);\n    }, filename); // if there's anything left after parsing, then it wasn't a valid filename\n\n    return whatsLeftOver ? null : result;\n  };\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/streamroller/lib/fileNameParser.js"],"names":["debug","require","FILENAME_SEP","ZIP_EXT","format","module","exports","file","keepFileExt","pattern","zip","f","p","endsWith","isCompressed","slice","length","__NOT_MATCHING__","extAtEnd","startsWith","name","ext","extInMiddle","base","dateAndIndex","items","split","indexStr","dateStr","undefined","match","date","parse","Date","asString","index","parseInt","timestamp","getTime","e","parts","filename","result","whatsLeftOver","reduce","remains","part"],"mappings":"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","sourcesContent":["const debug = require(\"debug\")(\"streamroller:fileNameParser\");\nconst FILENAME_SEP = \".\";\nconst ZIP_EXT = \".gz\";\nconst format = require(\"date-format\");\n\nmodule.exports = ({ file, keepFileExt, pattern }) => {\n  // All these functions take two arguments: f, the filename, and p, the result placeholder\n  // They return the filename with any matching parts removed.\n  // The \"zip\" function, for instance, removes the \".gz\" part of the filename (if present)\n  const zip = (f, p) => {\n    if (f.endsWith(ZIP_EXT)) {\n      debug(\"it is gzipped\");\n      p.isCompressed = true;\n      return f.slice(0, -1 * ZIP_EXT.length);\n    }\n    return f;\n  };\n\n  const __NOT_MATCHING__ = \"__NOT_MATCHING__\";\n\n  const extAtEnd = f => {\n    if (f.startsWith(file.name) && f.endsWith(file.ext)) {\n      debug(\"it starts and ends with the right things\");\n      return f.slice(file.name.length + 1, -1 * file.ext.length);\n    }\n    return __NOT_MATCHING__;\n  };\n\n  const extInMiddle = f => {\n    if (f.startsWith(file.base)) {\n      debug(\"it starts with the right things\");\n      return f.slice(file.base.length + 1);\n    }\n    return __NOT_MATCHING__;\n  };\n\n  const dateAndIndex = (f, p) => {\n    const items = f.split(FILENAME_SEP);\n    let indexStr = items[items.length - 1];\n    debug(\"items: \", items, \", indexStr: \", indexStr);\n    let dateStr = f;\n    if (indexStr !== undefined && indexStr.match(/^\\d+$/)) {\n      dateStr = f.slice(0, -1 * (indexStr.length + 1));\n      debug(`dateStr is ${dateStr}`);\n      if (pattern && !dateStr) {\n        dateStr = indexStr;\n        indexStr = \"0\";\n      }\n    } else {\n      indexStr = \"0\";\n    }\n\n    try {\n      // Two arguments for new Date() are intentional. This will set other date\n      // components to minimal values in the current timezone instead of UTC,\n      // as new Date(0) will do.\n      const date = format.parse(pattern, dateStr, new Date(0, 0));\n      if (format.asString(pattern, date) !== dateStr) return f;\n      p.index = parseInt(indexStr, 10);\n      p.date = dateStr;\n      p.timestamp = date.getTime();\n      return \"\";\n    } catch (e) {\n      //not a valid date, don't panic.\n      debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);\n      return f;\n    }\n  };\n\n  const index = (f, p) => {\n    if (f.match(/^\\d+$/)) {\n      debug(\"it has an index\");\n      p.index = parseInt(f, 10);\n      return \"\";\n    }\n    return f;\n  };\n\n  let parts = [\n    zip,\n    keepFileExt ? extAtEnd : extInMiddle,\n    pattern ? dateAndIndex : index\n  ];\n\n  return filename => {\n    let result = { filename, index: 0, isCompressed: false };\n    // pass the filename through each of the file part parsers\n    let whatsLeftOver = parts.reduce(\n      (remains, part) => part(remains, result),\n      filename\n    );\n    // if there's anything left after parsing, then it wasn't a valid filename\n    return whatsLeftOver ? null : result;\n  };\n};\n"]},"metadata":{},"sourceType":"script"}