{"ast":null,"code":"\"use strict\"; // builtin tooling\n\nvar path = require(\"path\"); // external tooling\n\n\nvar postcss = require(\"postcss\"); // internal tooling\n\n\nvar joinMedia = require(\"./lib/join-media\");\n\nvar resolveId = require(\"./lib/resolve-id\");\n\nvar loadContent = require(\"./lib/load-content\");\n\nvar processContent = require(\"./lib/process-content\");\n\nvar parseStatements = require(\"./lib/parse-statements\");\n\nfunction AtImport(options) {\n  options = Object.assign({\n    root: process.cwd(),\n    path: [],\n    skipDuplicates: true,\n    resolve: resolveId,\n    load: loadContent,\n    plugins: [],\n    addModulesDirectories: []\n  }, options);\n  options.root = path.resolve(options.root); // convert string to an array of a single element\n\n  if (typeof options.path === \"string\") options.path = [options.path];\n  if (!Array.isArray(options.path)) options.path = [];\n  options.path = options.path.map(function (p) {\n    return path.resolve(options.root, p);\n  });\n  return function (styles, result) {\n    var state = {\n      importedFiles: {},\n      hashFiles: {}\n    };\n\n    if (styles.source && styles.source.input && styles.source.input.file) {\n      state.importedFiles[styles.source.input.file] = {};\n    }\n\n    if (options.plugins && !Array.isArray(options.plugins)) {\n      throw new Error(\"plugins option must be an array\");\n    }\n\n    return parseStyles(result, styles, options, state, []).then(function (bundle) {\n      applyRaws(bundle);\n      applyMedia(bundle);\n      applyStyles(bundle, styles);\n    });\n  };\n}\n\nfunction applyRaws(bundle) {\n  bundle.forEach(function (stmt, index) {\n    if (index === 0) return;\n\n    if (stmt.parent) {\n      var before = stmt.parent.node.raws.before;\n      if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before;else stmt.node.raws.before = before;\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\";\n    }\n  });\n}\n\nfunction applyMedia(bundle) {\n  bundle.forEach(function (stmt) {\n    if (!stmt.media.length) return;\n\n    if (stmt.type === \"import\") {\n      stmt.node.params = \"\".concat(stmt.fullUri, \" \").concat(stmt.media.join(\", \"));\n    } else if (stmt.type === \"media\") stmt.node.params = stmt.media.join(\", \");else {\n      var nodes = stmt.nodes;\n      var parent = nodes[0].parent;\n      var mediaNode = postcss.atRule({\n        name: \"media\",\n        params: stmt.media.join(\", \"),\n        source: parent.source\n      });\n      parent.insertBefore(nodes[0], mediaNode); // remove nodes\n\n      nodes.forEach(function (node) {\n        node.parent = undefined;\n      }); // better output\n\n      nodes[0].raws.before = nodes[0].raws.before || \"\\n\"; // wrap new rules with media query\n\n      mediaNode.append(nodes);\n      stmt.type = \"media\";\n      stmt.node = mediaNode;\n      delete stmt.nodes;\n    }\n  });\n}\n\nfunction applyStyles(bundle, styles) {\n  styles.nodes = []; // Strip additional statements.\n\n  bundle.forEach(function (stmt) {\n    if (stmt.type === \"import\") {\n      stmt.node.parent = undefined;\n      styles.append(stmt.node);\n    } else if (stmt.type === \"media\") {\n      stmt.node.parent = undefined;\n      styles.append(stmt.node);\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes.forEach(function (node) {\n        node.parent = undefined;\n        styles.append(node);\n      });\n    }\n  });\n}\n\nfunction parseStyles(result, styles, options, state, media) {\n  var statements = parseStatements(result, styles);\n  return Promise.resolve(statements).then(function (stmts) {\n    // process each statement in series\n    return stmts.reduce(function (promise, stmt) {\n      return promise.then(function () {\n        stmt.media = joinMedia(media, stmt.media || []); // skip protocol base uri (protocol://url) or protocol-relative\n\n        if (stmt.type !== \"import\" || /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)) {\n          return;\n        }\n\n        if (options.filter && !options.filter(stmt.uri)) {\n          // rejected by filter\n          return;\n        }\n\n        return resolveImportId(result, stmt, options, state);\n      });\n    }, Promise.resolve());\n  }).then(function () {\n    var imports = [];\n    var bundle = []; // squash statements and their children\n\n    statements.forEach(function (stmt) {\n      if (stmt.type === \"import\") {\n        if (stmt.children) {\n          stmt.children.forEach(function (child, index) {\n            if (child.type === \"import\") imports.push(child);else bundle.push(child); // For better output\n\n            if (index === 0) child.parent = stmt;\n          });\n        } else imports.push(stmt);\n      } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n        bundle.push(stmt);\n      }\n    });\n    return imports.concat(bundle);\n  });\n}\n\nfunction resolveImportId(result, stmt, options, state) {\n  var atRule = stmt.node;\n  var sourceFile;\n\n  if (atRule.source && atRule.source.input && atRule.source.input.file) {\n    sourceFile = atRule.source.input.file;\n  }\n\n  var base = sourceFile ? path.dirname(atRule.source.input.file) : options.root;\n  return Promise.resolve(options.resolve(stmt.uri, base, options)).then(function (paths) {\n    if (!Array.isArray(paths)) paths = [paths]; // Ensure that each path is absolute:\n\n    return Promise.all(paths.map(function (file) {\n      return !path.isAbsolute(file) ? resolveId(file, base, options) : file;\n    }));\n  }).then(function (resolved) {\n    // Add dependency messages:\n    resolved.forEach(function (file) {\n      result.messages.push({\n        type: \"dependency\",\n        plugin: \"postcss-import\",\n        file: file,\n        parent: sourceFile\n      });\n    });\n    return Promise.all(resolved.map(function (file) {\n      return loadImportContent(result, stmt, file, options, state);\n    }));\n  }).then(function (result) {\n    // Merge loaded statements\n    stmt.children = result.reduce(function (result, statements) {\n      return statements ? result.concat(statements) : result;\n    }, []);\n  });\n}\n\nfunction loadImportContent(result, stmt, filename, options, state) {\n  var atRule = stmt.node;\n  var media = stmt.media;\n\n  if (options.skipDuplicates) {\n    // skip files already imported at the same scope\n    if (state.importedFiles[filename] && state.importedFiles[filename][media]) {\n      return;\n    } // save imported files to skip them next time\n\n\n    if (!state.importedFiles[filename]) state.importedFiles[filename] = {};\n    state.importedFiles[filename][media] = true;\n  }\n\n  return Promise.resolve(options.load(filename, options)).then(function (content) {\n    if (content.trim() === \"\") {\n      result.warn(\"\".concat(filename, \" is empty\"), {\n        node: atRule\n      });\n      return;\n    } // skip previous imported files not containing @import rules\n\n\n    if (state.hashFiles[content] && state.hashFiles[content][media]) return;\n    return processContent(result, content, filename, options).then(function (importedResult) {\n      var styles = importedResult.root;\n      result.messages = result.messages.concat(importedResult.messages);\n\n      if (options.skipDuplicates) {\n        var hasImport = styles.some(function (child) {\n          return child.type === \"atrule\" && child.name === \"import\";\n        });\n\n        if (!hasImport) {\n          // save hash files to skip them next time\n          if (!state.hashFiles[content]) state.hashFiles[content] = {};\n          state.hashFiles[content][media] = true;\n        }\n      } // recursion: import @import from imported file\n\n\n      return parseStyles(result, styles, options, state, media);\n    });\n  });\n}\n\nmodule.exports = postcss.plugin(\"postcss-import\", AtImport);","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/postcss-import/index.js"],"names":["path","require","postcss","joinMedia","resolveId","loadContent","processContent","parseStatements","AtImport","options","Object","assign","root","process","cwd","skipDuplicates","resolve","load","plugins","addModulesDirectories","Array","isArray","map","p","styles","result","state","importedFiles","hashFiles","source","input","file","Error","parseStyles","then","bundle","applyRaws","applyMedia","applyStyles","forEach","stmt","index","parent","before","node","raws","type","nodes","media","length","params","fullUri","join","mediaNode","atRule","name","insertBefore","undefined","append","statements","Promise","stmts","reduce","promise","test","uri","filter","resolveImportId","imports","children","child","push","concat","sourceFile","base","dirname","paths","all","isAbsolute","resolved","messages","plugin","loadImportContent","filename","content","trim","warn","importedResult","hasImport","some","module","exports"],"mappings":"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","sourcesContent":["\"use strict\"\n// builtin tooling\nconst path = require(\"path\")\n\n// external tooling\nconst postcss = require(\"postcss\")\n\n// internal tooling\nconst joinMedia = require(\"./lib/join-media\")\nconst resolveId = require(\"./lib/resolve-id\")\nconst loadContent = require(\"./lib/load-content\")\nconst processContent = require(\"./lib/process-content\")\nconst parseStatements = require(\"./lib/parse-statements\")\n\nfunction AtImport(options) {\n  options = Object.assign(\n    {\n      root: process.cwd(),\n      path: [],\n      skipDuplicates: true,\n      resolve: resolveId,\n      load: loadContent,\n      plugins: [],\n      addModulesDirectories: [],\n    },\n    options\n  )\n\n  options.root = path.resolve(options.root)\n\n  // convert string to an array of a single element\n  if (typeof options.path === \"string\") options.path = [options.path]\n\n  if (!Array.isArray(options.path)) options.path = []\n\n  options.path = options.path.map(p => path.resolve(options.root, p))\n\n  return function(styles, result) {\n    const state = {\n      importedFiles: {},\n      hashFiles: {},\n    }\n\n    if (styles.source && styles.source.input && styles.source.input.file) {\n      state.importedFiles[styles.source.input.file] = {}\n    }\n\n    if (options.plugins && !Array.isArray(options.plugins)) {\n      throw new Error(\"plugins option must be an array\")\n    }\n\n    return parseStyles(result, styles, options, state, []).then(bundle => {\n      applyRaws(bundle)\n      applyMedia(bundle)\n      applyStyles(bundle, styles)\n    })\n  }\n}\n\nfunction applyRaws(bundle) {\n  bundle.forEach((stmt, index) => {\n    if (index === 0) return\n\n    if (stmt.parent) {\n      const before = stmt.parent.node.raws.before\n      if (stmt.type === \"nodes\") stmt.nodes[0].raws.before = before\n      else stmt.node.raws.before = before\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || \"\\n\"\n    }\n  })\n}\n\nfunction applyMedia(bundle) {\n  bundle.forEach(stmt => {\n    if (!stmt.media.length) return\n    if (stmt.type === \"import\") {\n      stmt.node.params = `${stmt.fullUri} ${stmt.media.join(\", \")}`\n    } else if (stmt.type === \"media\") stmt.node.params = stmt.media.join(\", \")\n    else {\n      const nodes = stmt.nodes\n      const parent = nodes[0].parent\n      const mediaNode = postcss.atRule({\n        name: \"media\",\n        params: stmt.media.join(\", \"),\n        source: parent.source,\n      })\n\n      parent.insertBefore(nodes[0], mediaNode)\n\n      // remove nodes\n      nodes.forEach(node => {\n        node.parent = undefined\n      })\n\n      // better output\n      nodes[0].raws.before = nodes[0].raws.before || \"\\n\"\n\n      // wrap new rules with media query\n      mediaNode.append(nodes)\n\n      stmt.type = \"media\"\n      stmt.node = mediaNode\n      delete stmt.nodes\n    }\n  })\n}\n\nfunction applyStyles(bundle, styles) {\n  styles.nodes = []\n\n  // Strip additional statements.\n  bundle.forEach(stmt => {\n    if (stmt.type === \"import\") {\n      stmt.node.parent = undefined\n      styles.append(stmt.node)\n    } else if (stmt.type === \"media\") {\n      stmt.node.parent = undefined\n      styles.append(stmt.node)\n    } else if (stmt.type === \"nodes\") {\n      stmt.nodes.forEach(node => {\n        node.parent = undefined\n        styles.append(node)\n      })\n    }\n  })\n}\n\nfunction parseStyles(result, styles, options, state, media) {\n  const statements = parseStatements(result, styles)\n\n  return Promise.resolve(statements)\n    .then(stmts => {\n      // process each statement in series\n      return stmts.reduce((promise, stmt) => {\n        return promise.then(() => {\n          stmt.media = joinMedia(media, stmt.media || [])\n\n          // skip protocol base uri (protocol://url) or protocol-relative\n          if (stmt.type !== \"import\" || /^(?:[a-z]+:)?\\/\\//i.test(stmt.uri)) {\n            return\n          }\n\n          if (options.filter && !options.filter(stmt.uri)) {\n            // rejected by filter\n            return\n          }\n\n          return resolveImportId(result, stmt, options, state)\n        })\n      }, Promise.resolve())\n    })\n    .then(() => {\n      const imports = []\n      const bundle = []\n\n      // squash statements and their children\n      statements.forEach(stmt => {\n        if (stmt.type === \"import\") {\n          if (stmt.children) {\n            stmt.children.forEach((child, index) => {\n              if (child.type === \"import\") imports.push(child)\n              else bundle.push(child)\n              // For better output\n              if (index === 0) child.parent = stmt\n            })\n          } else imports.push(stmt)\n        } else if (stmt.type === \"media\" || stmt.type === \"nodes\") {\n          bundle.push(stmt)\n        }\n      })\n\n      return imports.concat(bundle)\n    })\n}\n\nfunction resolveImportId(result, stmt, options, state) {\n  const atRule = stmt.node\n  let sourceFile\n  if (atRule.source && atRule.source.input && atRule.source.input.file) {\n    sourceFile = atRule.source.input.file\n  }\n  const base = sourceFile\n    ? path.dirname(atRule.source.input.file)\n    : options.root\n\n  return Promise.resolve(options.resolve(stmt.uri, base, options))\n    .then(paths => {\n      if (!Array.isArray(paths)) paths = [paths]\n      // Ensure that each path is absolute:\n      return Promise.all(\n        paths.map(file => {\n          return !path.isAbsolute(file) ? resolveId(file, base, options) : file\n        })\n      )\n    })\n    .then(resolved => {\n      // Add dependency messages:\n      resolved.forEach(file => {\n        result.messages.push({\n          type: \"dependency\",\n          plugin: \"postcss-import\",\n          file: file,\n          parent: sourceFile,\n        })\n      })\n\n      return Promise.all(\n        resolved.map(file => {\n          return loadImportContent(result, stmt, file, options, state)\n        })\n      )\n    })\n    .then(result => {\n      // Merge loaded statements\n      stmt.children = result.reduce((result, statements) => {\n        return statements ? result.concat(statements) : result\n      }, [])\n    })\n}\n\nfunction loadImportContent(result, stmt, filename, options, state) {\n  const atRule = stmt.node\n  const media = stmt.media\n  if (options.skipDuplicates) {\n    // skip files already imported at the same scope\n    if (state.importedFiles[filename] && state.importedFiles[filename][media]) {\n      return\n    }\n\n    // save imported files to skip them next time\n    if (!state.importedFiles[filename]) state.importedFiles[filename] = {}\n    state.importedFiles[filename][media] = true\n  }\n\n  return Promise.resolve(options.load(filename, options)).then(content => {\n    if (content.trim() === \"\") {\n      result.warn(`${filename} is empty`, { node: atRule })\n      return\n    }\n\n    // skip previous imported files not containing @import rules\n    if (state.hashFiles[content] && state.hashFiles[content][media]) return\n\n    return processContent(result, content, filename, options).then(\n      importedResult => {\n        const styles = importedResult.root\n        result.messages = result.messages.concat(importedResult.messages)\n\n        if (options.skipDuplicates) {\n          const hasImport = styles.some(child => {\n            return child.type === \"atrule\" && child.name === \"import\"\n          })\n          if (!hasImport) {\n            // save hash files to skip them next time\n            if (!state.hashFiles[content]) state.hashFiles[content] = {}\n            state.hashFiles[content][media] = true\n          }\n        }\n\n        // recursion: import @import from imported file\n        return parseStyles(result, styles, options, state, media)\n      }\n    )\n  })\n}\n\nmodule.exports = postcss.plugin(\"postcss-import\", AtImport)\n"]},"metadata":{},"sourceType":"script"}