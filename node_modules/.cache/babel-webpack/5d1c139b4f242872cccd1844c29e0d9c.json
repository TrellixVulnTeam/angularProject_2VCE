{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/api/checker\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.OptimizeFor = void 0;\n  /**\n   * Describes the scope of the caller's interest in template type-checking results.\n   */\n\n  var OptimizeFor;\n\n  (function (OptimizeFor) {\n    /**\n     * Indicates that a consumer of a `TemplateTypeChecker` is only interested in results for a given\n     * file, and wants them as fast as possible.\n     *\n     * Calling `TemplateTypeChecker` methods successively for multiple files while specifying\n     * `OptimizeFor.SingleFile` can result in significant unnecessary overhead overall.\n     */\n    OptimizeFor[OptimizeFor[\"SingleFile\"] = 0] = \"SingleFile\";\n    /**\n     * Indicates that a consumer of a `TemplateTypeChecker` intends to query for results pertaining to\n     * the entire user program, and so the type-checker should internally optimize for this case.\n     *\n     * Initial calls to retrieve type-checking information may take longer, but repeated calls to\n     * gather information for the whole user program will be significantly faster with this mode of\n     * optimization.\n     */\n\n    OptimizeFor[OptimizeFor[\"WholeProgram\"] = 1] = \"WholeProgram\";\n  })(OptimizeFor = exports.OptimizeFor || (exports.OptimizeFor = {}));\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/api/checker.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;AAwJH;;AAEG;;AACH,MAAY,WAAZ;;AAAA,GAAA,UAAY,WAAZ,EAAuB;AACrB;;;;;;AAMG;AACH,IAAA,WAAA,CAAA,WAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AAEA;;;;;;;AAOG;;AACH,IAAA,WAAA,CAAA,WAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA;AACD,GAnBD,EAAY,WAAW,GAAX,OAAA,CAAA,WAAA,KAAA,OAAA,CAAA,WAAA,GAAW,EAAX,CAAZ","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, MethodCall, ParseError, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstTemplate} from '@angular/compiler';\nimport {AbsoluteFsPath} from '@angular/compiler-cli/src/ngtsc/file_system';\nimport * as ts from 'typescript';\n\nimport {FullTemplateMapping, TypeCheckableDirectiveMeta} from './api';\nimport {GlobalCompletion} from './completion';\nimport {DirectiveInScope, PipeInScope} from './scope';\nimport {DirectiveSymbol, ElementSymbol, ShimLocation, Symbol, TemplateSymbol} from './symbols';\n\n/**\n * Interface to the Angular Template Type Checker to extract diagnostics and intelligence from the\n * compiler's understanding of component templates.\n *\n * This interface is analogous to TypeScript's own `ts.TypeChecker` API.\n *\n * In general, this interface supports two kinds of operations:\n *  - updating Type Check Blocks (TCB)s that capture the template in the form of TypeScript code\n *  - querying information about available TCBs, including diagnostics\n *\n * Once a TCB is available, information about it can be queried. If no TCB is available to answer a\n * query, depending on the method either `null` will be returned or an error will be thrown.\n */\nexport interface TemplateTypeChecker {\n  /**\n   * Retrieve the template in use for the given component.\n   */\n  getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null;\n\n  /**\n   * Get all `ts.Diagnostic`s currently available for the given `ts.SourceFile`.\n   *\n   * This method will fail (throw) if there are components within the `ts.SourceFile` that do not\n   * have TCBs available.\n   *\n   * Generating a template type-checking program is expensive, and in some workflows (e.g. checking\n   * an entire program before emit), it should ideally only be done once. The `optimizeFor` flag\n   * allows the caller to hint to `getDiagnosticsForFile` (which internally will create a template\n   * type-checking program if needed) whether the caller is interested in just the results of the\n   * single file, or whether they plan to query about other files in the program. Based on this\n   * flag, `getDiagnosticsForFile` will determine how much of the user's program to prepare for\n   * checking as part of the template type-checking program it creates.\n   */\n  getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[];\n\n  /**\n   * Given a `shim` and position within the file, returns information for mapping back to a template\n   * location.\n   */\n  getTemplateMappingAtShimLocation(shimLocation: ShimLocation): FullTemplateMapping|null;\n\n  /**\n   * Get all `ts.Diagnostic`s currently available that pertain to the given component.\n   *\n   * This method always runs in `OptimizeFor.SingleFile` mode.\n   */\n  getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[];\n\n  /**\n   * Ensures shims for the whole program are generated. This type of operation would be required by\n   * operations like \"find references\" and \"refactor/rename\" because references may appear in type\n   * check blocks generated from templates anywhere in the program.\n   */\n  generateAllTypeCheckBlocks(): void;\n\n  /**\n   * Returns `true` if the given file is in the record of known shims generated by the compiler,\n   * `false` if we cannot find the file in the shim records.\n   */\n  isTrackedTypeCheckFile(filePath: AbsoluteFsPath): boolean;\n\n  /**\n   * Retrieve the top-level node representing the TCB for the given component.\n   *\n   * This can return `null` if there is no TCB available for the component.\n   *\n   * This method always runs in `OptimizeFor.SingleFile` mode.\n   */\n  getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null;\n\n  /**\n   * Retrieves a `Symbol` for the node in a component's template.\n   *\n   * This method can return `null` if a valid `Symbol` cannot be determined for the node.\n   *\n   * @see Symbol\n   */\n  getSymbolOfNode(node: TmplAstElement, component: ts.ClassDeclaration): ElementSymbol|null;\n  getSymbolOfNode(node: TmplAstTemplate, component: ts.ClassDeclaration): TemplateSymbol|null;\n  getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null;\n\n  /**\n   * Get \"global\" `Completion`s in the given context.\n   *\n   * Global completions are completions in the global context, as opposed to completions within an\n   * existing expression. For example, completing inside a new interpolation expression (`{{|}}`) or\n   * inside a new property binding `[input]=\"|\" should retrieve global completions, which will\n   * include completions from the template's context component, as well as any local references or\n   * template variables which are in scope for that expression.\n   */\n  getGlobalCompletions(\n      context: TmplAstTemplate|null, component: ts.ClassDeclaration,\n      node: AST|TmplAstNode): GlobalCompletion|null;\n\n\n  /**\n   * For the given expression node, retrieve a `ShimLocation` that can be used to perform\n   * autocompletion at that point in the expression, if such a location exists.\n   */\n  getExpressionCompletionLocation(\n      expr: PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall,\n      component: ts.ClassDeclaration): ShimLocation|null;\n\n  /**\n   * Get basic metadata on the directives which are in scope for the given component.\n   */\n  getDirectivesInScope(component: ts.ClassDeclaration): DirectiveInScope[]|null;\n\n  /**\n   * Get basic metadata on the pipes which are in scope for the given component.\n   */\n  getPipesInScope(component: ts.ClassDeclaration): PipeInScope[]|null;\n\n  /**\n   * Retrieve a `Map` of potential template element tags, to either the `DirectiveInScope` that\n   * declares them (if the tag is from a directive/component), or `null` if the tag originates from\n   * the DOM schema.\n   */\n  getPotentialElementTags(component: ts.ClassDeclaration): Map<string, DirectiveInScope|null>;\n\n  /**\n   * Retrieve any potential DOM bindings for the given element.\n   *\n   * This returns an array of objects which list both the attribute and property names of each\n   * binding, which are usually identical but can vary if the HTML attribute name is for example a\n   * reserved keyword in JS, like the `for` attribute which corresponds to the `htmlFor` property.\n   */\n  getPotentialDomBindings(tagName: string): {attribute: string, property: string}[];\n\n  /**\n   * Retrieve the type checking engine's metadata for the given directive class, if available.\n   */\n  getDirectiveMetadata(dir: ts.ClassDeclaration): TypeCheckableDirectiveMeta|null;\n\n  /**\n   * Reset the `TemplateTypeChecker`'s state for the given class, so that it will be recomputed on\n   * the next request.\n   */\n  invalidateClass(clazz: ts.ClassDeclaration): void;\n}\n\n/**\n * Describes the scope of the caller's interest in template type-checking results.\n */\nexport enum OptimizeFor {\n  /**\n   * Indicates that a consumer of a `TemplateTypeChecker` is only interested in results for a given\n   * file, and wants them as fast as possible.\n   *\n   * Calling `TemplateTypeChecker` methods successively for multiple files while specifying\n   * `OptimizeFor.SingleFile` can result in significant unnecessary overhead overall.\n   */\n  SingleFile,\n\n  /**\n   * Indicates that a consumer of a `TemplateTypeChecker` intends to query for results pertaining to\n   * the entire user program, and so the type-checker should internally optimize for this case.\n   *\n   * Initial calls to retrieve type-checking information may take longer, but repeated calls to\n   * gather information for the whole user program will be significantly faster with this mode of\n   * optimization.\n   */\n  WholeProgram,\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}