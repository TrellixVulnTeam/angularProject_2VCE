{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\n\nvar AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\n\nvar ConstDependency = require(\"./ConstDependency\");\n\nvar AMDDefineDependency = require(\"./AMDDefineDependency\");\n\nvar AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\n\nvar LocalModuleDependency = require(\"./LocalModuleDependency\");\n\nvar ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\n\nvar LocalModulesHelpers = require(\"./LocalModulesHelpers\");\n\nvar isBoundFunctionExpression = function isBoundFunctionExpression(expr) {\n  if (expr.type !== \"CallExpression\") return false;\n  if (expr.callee.type !== \"MemberExpression\") return false;\n  if (expr.callee.computed) return false;\n  if (expr.callee.object.type !== \"FunctionExpression\") return false;\n  if (expr.callee.property.type !== \"Identifier\") return false;\n  if (expr.callee.property.name !== \"bind\") return false;\n  return true;\n};\n\nvar isUnboundFunctionExpression = function isUnboundFunctionExpression(expr) {\n  if (expr.type === \"FunctionExpression\") return true;\n  if (expr.type === \"ArrowFunctionExpression\") return true;\n  return false;\n};\n\nvar isCallable = function isCallable(expr) {\n  if (isUnboundFunctionExpression(expr)) return true;\n  if (isBoundFunctionExpression(expr)) return true;\n  return false;\n};\n\nvar AMDDefineDependencyParserPlugin = /*#__PURE__*/function () {\n  function AMDDefineDependencyParserPlugin(options) {\n    _classCallCheck(this, AMDDefineDependencyParserPlugin);\n\n    this.options = options;\n  }\n\n  _createClass(AMDDefineDependencyParserPlugin, [{\n    key: \"apply\",\n    value: function apply(parser) {\n      parser.hooks.call.for(\"define\").tap(\"AMDDefineDependencyParserPlugin\", this.processCallDefine.bind(this, parser));\n    }\n  }, {\n    key: \"processArray\",\n    value: function processArray(parser, expr, param, identifiers, namedModule) {\n      var _this = this;\n\n      if (param.isArray()) {\n        param.items.forEach(function (param, idx) {\n          if (param.isString() && [\"require\", \"module\", \"exports\"].includes(param.string)) identifiers[idx] = param.string;\n\n          var result = _this.processItem(parser, expr, param, namedModule);\n\n          if (result === undefined) {\n            _this.processContext(parser, expr, param);\n          }\n        });\n        return true;\n      } else if (param.isConstArray()) {\n        var deps = [];\n        param.array.forEach(function (request, idx) {\n          var dep;\n          var localModule;\n\n          if (request === \"require\") {\n            identifiers[idx] = request;\n            dep = \"__webpack_require__\";\n          } else if ([\"exports\", \"module\"].includes(request)) {\n            identifiers[idx] = request;\n            dep = request;\n          } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, request)) {\n            dep = new LocalModuleDependency(localModule, undefined, false);\n            dep.loc = expr.loc;\n            parser.state.current.addDependency(dep);\n          } else {\n            dep = _this.newRequireItemDependency(request);\n            dep.loc = expr.loc;\n            dep.optional = !!parser.scope.inTry;\n            parser.state.current.addDependency(dep);\n          }\n\n          deps.push(dep);\n        });\n        var dep = this.newRequireArrayDependency(deps, param.range);\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    }\n  }, {\n    key: \"processItem\",\n    value: function processItem(parser, expr, param, namedModule) {\n      var _this2 = this;\n\n      if (param.isConditional()) {\n        param.options.forEach(function (param) {\n          var result = _this2.processItem(parser, expr, param);\n\n          if (result === undefined) {\n            _this2.processContext(parser, expr, param);\n          }\n        });\n        return true;\n      } else if (param.isString()) {\n        var dep, localModule;\n\n        if (param.string === \"require\") {\n          dep = new ConstDependency(\"__webpack_require__\", param.range);\n        } else if ([\"require\", \"exports\", \"module\"].includes(param.string)) {\n          dep = new ConstDependency(param.string, param.range);\n        } else if (localModule = LocalModulesHelpers.getLocalModule(parser.state, param.string, namedModule)) {\n          dep = new LocalModuleDependency(localModule, param.range, false);\n        } else {\n          dep = this.newRequireItemDependency(param.string, param.range);\n        }\n\n        dep.loc = expr.loc;\n        dep.optional = !!parser.scope.inTry;\n        parser.state.current.addDependency(dep);\n        return true;\n      }\n    }\n  }, {\n    key: \"processContext\",\n    value: function processContext(parser, expr, param) {\n      var dep = ContextDependencyHelpers.create(AMDRequireContextDependency, param.range, param, expr, this.options, {}, parser);\n      if (!dep) return;\n      dep.loc = expr.loc;\n      dep.optional = !!parser.scope.inTry;\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }, {\n    key: \"processCallDefine\",\n    value: function processCallDefine(parser, expr) {\n      var array, fn, obj, namedModule;\n\n      switch (expr.arguments.length) {\n        case 1:\n          if (isCallable(expr.arguments[0])) {\n            // define(f() {…})\n            fn = expr.arguments[0];\n          } else if (expr.arguments[0].type === \"ObjectExpression\") {\n            // define({…})\n            obj = expr.arguments[0];\n          } else {\n            // define(expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[0];\n          }\n\n          break;\n\n        case 2:\n          if (expr.arguments[0].type === \"Literal\") {\n            namedModule = expr.arguments[0].value; // define(\"…\", …)\n\n            if (isCallable(expr.arguments[1])) {\n              // define(\"…\", f() {…})\n              fn = expr.arguments[1];\n            } else if (expr.arguments[1].type === \"ObjectExpression\") {\n              // define(\"…\", {…})\n              obj = expr.arguments[1];\n            } else {\n              // define(\"…\", expr)\n              // unclear if function or object\n              obj = fn = expr.arguments[1];\n            }\n          } else {\n            array = expr.arguments[0];\n\n            if (isCallable(expr.arguments[1])) {\n              // define([…], f() {})\n              fn = expr.arguments[1];\n            } else if (expr.arguments[1].type === \"ObjectExpression\") {\n              // define([…], {…})\n              obj = expr.arguments[1];\n            } else {\n              // define([…], expr)\n              // unclear if function or object\n              obj = fn = expr.arguments[1];\n            }\n          }\n\n          break;\n\n        case 3:\n          // define(\"…\", […], f() {…})\n          namedModule = expr.arguments[0].value;\n          array = expr.arguments[1];\n\n          if (isCallable(expr.arguments[2])) {\n            // define(\"…\", […], f() {})\n            fn = expr.arguments[2];\n          } else if (expr.arguments[2].type === \"ObjectExpression\") {\n            // define(\"…\", […], {…})\n            obj = expr.arguments[2];\n          } else {\n            // define(\"…\", […], expr)\n            // unclear if function or object\n            obj = fn = expr.arguments[2];\n          }\n\n          break;\n\n        default:\n          return;\n      }\n\n      var fnParams = null;\n      var fnParamsOffset = 0;\n\n      if (fn) {\n        if (isUnboundFunctionExpression(fn)) {\n          fnParams = fn.params;\n        } else if (isBoundFunctionExpression(fn)) {\n          fnParams = fn.callee.object.params;\n          fnParamsOffset = fn.arguments.length - 1;\n\n          if (fnParamsOffset < 0) {\n            fnParamsOffset = 0;\n          }\n        }\n      }\n\n      var fnRenames = parser.scope.renames.createChild();\n\n      if (array) {\n        var identifiers = {};\n        var param = parser.evaluateExpression(array);\n        var result = this.processArray(parser, expr, param, identifiers, namedModule);\n        if (!result) return;\n\n        if (fnParams) {\n          fnParams = fnParams.slice(fnParamsOffset).filter(function (param, idx) {\n            if (identifiers[idx]) {\n              fnRenames.set(param.name, identifiers[idx]);\n              return false;\n            }\n\n            return true;\n          });\n        }\n      } else {\n        var _identifiers = [\"require\", \"exports\", \"module\"];\n\n        if (fnParams) {\n          fnParams = fnParams.slice(fnParamsOffset).filter(function (param, idx) {\n            if (_identifiers[idx]) {\n              fnRenames.set(param.name, _identifiers[idx]);\n              return false;\n            }\n\n            return true;\n          });\n        }\n      }\n\n      var inTry;\n\n      if (fn && isUnboundFunctionExpression(fn)) {\n        inTry = parser.scope.inTry;\n        parser.inScope(fnParams, function () {\n          parser.scope.renames = fnRenames;\n          parser.scope.inTry = inTry;\n\n          if (fn.body.type === \"BlockStatement\") {\n            parser.walkStatement(fn.body);\n          } else {\n            parser.walkExpression(fn.body);\n          }\n        });\n      } else if (fn && isBoundFunctionExpression(fn)) {\n        inTry = parser.scope.inTry;\n        parser.inScope(fn.callee.object.params.filter(function (i) {\n          return ![\"require\", \"module\", \"exports\"].includes(i.name);\n        }), function () {\n          parser.scope.renames = fnRenames;\n          parser.scope.inTry = inTry;\n\n          if (fn.callee.object.body.type === \"BlockStatement\") {\n            parser.walkStatement(fn.callee.object.body);\n          } else {\n            parser.walkExpression(fn.callee.object.body);\n          }\n        });\n\n        if (fn.arguments) {\n          parser.walkExpressions(fn.arguments);\n        }\n      } else if (fn || obj) {\n        parser.walkExpression(fn || obj);\n      }\n\n      var dep = this.newDefineDependency(expr.range, array ? array.range : null, fn ? fn.range : null, obj ? obj.range : null, namedModule ? namedModule : null);\n      dep.loc = expr.loc;\n\n      if (namedModule) {\n        dep.localModule = LocalModulesHelpers.addLocalModule(parser.state, namedModule);\n      }\n\n      parser.state.current.addDependency(dep);\n      return true;\n    }\n  }, {\n    key: \"newDefineDependency\",\n    value: function newDefineDependency(range, arrayRange, functionRange, objectRange, namedModule) {\n      return new AMDDefineDependency(range, arrayRange, functionRange, objectRange, namedModule);\n    }\n  }, {\n    key: \"newRequireArrayDependency\",\n    value: function newRequireArrayDependency(depsArray, range) {\n      return new AMDRequireArrayDependency(depsArray, range);\n    }\n  }, {\n    key: \"newRequireItemDependency\",\n    value: function newRequireItemDependency(request, range) {\n      return new AMDRequireItemDependency(request, range);\n    }\n  }]);\n\n  return AMDDefineDependencyParserPlugin;\n}();\n\nmodule.exports = AMDDefineDependencyParserPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/dependencies/AMDDefineDependencyParserPlugin.js"],"names":["AMDRequireItemDependency","require","AMDRequireContextDependency","ConstDependency","AMDDefineDependency","AMDRequireArrayDependency","LocalModuleDependency","ContextDependencyHelpers","LocalModulesHelpers","isBoundFunctionExpression","expr","type","callee","computed","object","property","name","isUnboundFunctionExpression","isCallable","AMDDefineDependencyParserPlugin","options","parser","hooks","call","for","tap","processCallDefine","bind","param","identifiers","namedModule","isArray","items","forEach","idx","isString","includes","string","result","processItem","undefined","processContext","isConstArray","deps","array","request","dep","localModule","getLocalModule","state","loc","current","addDependency","newRequireItemDependency","optional","scope","inTry","push","newRequireArrayDependency","range","isConditional","create","fn","obj","arguments","length","value","fnParams","fnParamsOffset","params","fnRenames","renames","createChild","evaluateExpression","processArray","slice","filter","set","inScope","body","walkStatement","walkExpression","i","walkExpressions","newDefineDependency","addLocalModule","arrayRange","functionRange","objectRange","depsArray","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst AMDRequireItemDependency = require(\"./AMDRequireItemDependency\");\nconst AMDRequireContextDependency = require(\"./AMDRequireContextDependency\");\nconst ConstDependency = require(\"./ConstDependency\");\nconst AMDDefineDependency = require(\"./AMDDefineDependency\");\nconst AMDRequireArrayDependency = require(\"./AMDRequireArrayDependency\");\nconst LocalModuleDependency = require(\"./LocalModuleDependency\");\nconst ContextDependencyHelpers = require(\"./ContextDependencyHelpers\");\nconst LocalModulesHelpers = require(\"./LocalModulesHelpers\");\n\nconst isBoundFunctionExpression = expr => {\n\tif (expr.type !== \"CallExpression\") return false;\n\tif (expr.callee.type !== \"MemberExpression\") return false;\n\tif (expr.callee.computed) return false;\n\tif (expr.callee.object.type !== \"FunctionExpression\") return false;\n\tif (expr.callee.property.type !== \"Identifier\") return false;\n\tif (expr.callee.property.name !== \"bind\") return false;\n\treturn true;\n};\n\nconst isUnboundFunctionExpression = expr => {\n\tif (expr.type === \"FunctionExpression\") return true;\n\tif (expr.type === \"ArrowFunctionExpression\") return true;\n\treturn false;\n};\n\nconst isCallable = expr => {\n\tif (isUnboundFunctionExpression(expr)) return true;\n\tif (isBoundFunctionExpression(expr)) return true;\n\treturn false;\n};\n\nclass AMDDefineDependencyParserPlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"define\")\n\t\t\t.tap(\n\t\t\t\t\"AMDDefineDependencyParserPlugin\",\n\t\t\t\tthis.processCallDefine.bind(this, parser)\n\t\t\t);\n\t}\n\n\tprocessArray(parser, expr, param, identifiers, namedModule) {\n\t\tif (param.isArray()) {\n\t\t\tparam.items.forEach((param, idx) => {\n\t\t\t\tif (\n\t\t\t\t\tparam.isString() &&\n\t\t\t\t\t[\"require\", \"module\", \"exports\"].includes(param.string)\n\t\t\t\t)\n\t\t\t\t\tidentifiers[idx] = param.string;\n\t\t\t\tconst result = this.processItem(parser, expr, param, namedModule);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, param);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else if (param.isConstArray()) {\n\t\t\tconst deps = [];\n\t\t\tparam.array.forEach((request, idx) => {\n\t\t\t\tlet dep;\n\t\t\t\tlet localModule;\n\t\t\t\tif (request === \"require\") {\n\t\t\t\t\tidentifiers[idx] = request;\n\t\t\t\t\tdep = \"__webpack_require__\";\n\t\t\t\t} else if ([\"exports\", \"module\"].includes(request)) {\n\t\t\t\t\tidentifiers[idx] = request;\n\t\t\t\t\tdep = request;\n\t\t\t\t} else if (\n\t\t\t\t\t(localModule = LocalModulesHelpers.getLocalModule(\n\t\t\t\t\t\tparser.state,\n\t\t\t\t\t\trequest\n\t\t\t\t\t))\n\t\t\t\t) {\n\t\t\t\t\tdep = new LocalModuleDependency(localModule, undefined, false);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t} else {\n\t\t\t\t\tdep = this.newRequireItemDependency(request);\n\t\t\t\t\tdep.loc = expr.loc;\n\t\t\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t}\n\t\t\t\tdeps.push(dep);\n\t\t\t});\n\t\t\tconst dep = this.newRequireArrayDependency(deps, param.range);\n\t\t\tdep.loc = expr.loc;\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.current.addDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessItem(parser, expr, param, namedModule) {\n\t\tif (param.isConditional()) {\n\t\t\tparam.options.forEach(param => {\n\t\t\t\tconst result = this.processItem(parser, expr, param);\n\t\t\t\tif (result === undefined) {\n\t\t\t\t\tthis.processContext(parser, expr, param);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn true;\n\t\t} else if (param.isString()) {\n\t\t\tlet dep, localModule;\n\t\t\tif (param.string === \"require\") {\n\t\t\t\tdep = new ConstDependency(\"__webpack_require__\", param.range);\n\t\t\t} else if ([\"require\", \"exports\", \"module\"].includes(param.string)) {\n\t\t\t\tdep = new ConstDependency(param.string, param.range);\n\t\t\t} else if (\n\t\t\t\t(localModule = LocalModulesHelpers.getLocalModule(\n\t\t\t\t\tparser.state,\n\t\t\t\t\tparam.string,\n\t\t\t\t\tnamedModule\n\t\t\t\t))\n\t\t\t) {\n\t\t\t\tdep = new LocalModuleDependency(localModule, param.range, false);\n\t\t\t} else {\n\t\t\t\tdep = this.newRequireItemDependency(param.string, param.range);\n\t\t\t}\n\t\t\tdep.loc = expr.loc;\n\t\t\tdep.optional = !!parser.scope.inTry;\n\t\t\tparser.state.current.addDependency(dep);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprocessContext(parser, expr, param) {\n\t\tconst dep = ContextDependencyHelpers.create(\n\t\t\tAMDRequireContextDependency,\n\t\t\tparam.range,\n\t\t\tparam,\n\t\t\texpr,\n\t\t\tthis.options,\n\t\t\t{},\n\t\t\tparser\n\t\t);\n\t\tif (!dep) return;\n\t\tdep.loc = expr.loc;\n\t\tdep.optional = !!parser.scope.inTry;\n\t\tparser.state.current.addDependency(dep);\n\t\treturn true;\n\t}\n\n\tprocessCallDefine(parser, expr) {\n\t\tlet array, fn, obj, namedModule;\n\t\tswitch (expr.arguments.length) {\n\t\t\tcase 1:\n\t\t\t\tif (isCallable(expr.arguments[0])) {\n\t\t\t\t\t// define(f() {…})\n\t\t\t\t\tfn = expr.arguments[0];\n\t\t\t\t} else if (expr.arguments[0].type === \"ObjectExpression\") {\n\t\t\t\t\t// define({…})\n\t\t\t\t\tobj = expr.arguments[0];\n\t\t\t\t} else {\n\t\t\t\t\t// define(expr)\n\t\t\t\t\t// unclear if function or object\n\t\t\t\t\tobj = fn = expr.arguments[0];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (expr.arguments[0].type === \"Literal\") {\n\t\t\t\t\tnamedModule = expr.arguments[0].value;\n\t\t\t\t\t// define(\"…\", …)\n\t\t\t\t\tif (isCallable(expr.arguments[1])) {\n\t\t\t\t\t\t// define(\"…\", f() {…})\n\t\t\t\t\t\tfn = expr.arguments[1];\n\t\t\t\t\t} else if (expr.arguments[1].type === \"ObjectExpression\") {\n\t\t\t\t\t\t// define(\"…\", {…})\n\t\t\t\t\t\tobj = expr.arguments[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// define(\"…\", expr)\n\t\t\t\t\t\t// unclear if function or object\n\t\t\t\t\t\tobj = fn = expr.arguments[1];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tarray = expr.arguments[0];\n\t\t\t\t\tif (isCallable(expr.arguments[1])) {\n\t\t\t\t\t\t// define([…], f() {})\n\t\t\t\t\t\tfn = expr.arguments[1];\n\t\t\t\t\t} else if (expr.arguments[1].type === \"ObjectExpression\") {\n\t\t\t\t\t\t// define([…], {…})\n\t\t\t\t\t\tobj = expr.arguments[1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// define([…], expr)\n\t\t\t\t\t\t// unclear if function or object\n\t\t\t\t\t\tobj = fn = expr.arguments[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t// define(\"…\", […], f() {…})\n\t\t\t\tnamedModule = expr.arguments[0].value;\n\t\t\t\tarray = expr.arguments[1];\n\t\t\t\tif (isCallable(expr.arguments[2])) {\n\t\t\t\t\t// define(\"…\", […], f() {})\n\t\t\t\t\tfn = expr.arguments[2];\n\t\t\t\t} else if (expr.arguments[2].type === \"ObjectExpression\") {\n\t\t\t\t\t// define(\"…\", […], {…})\n\t\t\t\t\tobj = expr.arguments[2];\n\t\t\t\t} else {\n\t\t\t\t\t// define(\"…\", […], expr)\n\t\t\t\t\t// unclear if function or object\n\t\t\t\t\tobj = fn = expr.arguments[2];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\t\tlet fnParams = null;\n\t\tlet fnParamsOffset = 0;\n\t\tif (fn) {\n\t\t\tif (isUnboundFunctionExpression(fn)) {\n\t\t\t\tfnParams = fn.params;\n\t\t\t} else if (isBoundFunctionExpression(fn)) {\n\t\t\t\tfnParams = fn.callee.object.params;\n\t\t\t\tfnParamsOffset = fn.arguments.length - 1;\n\t\t\t\tif (fnParamsOffset < 0) {\n\t\t\t\t\tfnParamsOffset = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet fnRenames = parser.scope.renames.createChild();\n\t\tif (array) {\n\t\t\tconst identifiers = {};\n\t\t\tconst param = parser.evaluateExpression(array);\n\t\t\tconst result = this.processArray(\n\t\t\t\tparser,\n\t\t\t\texpr,\n\t\t\t\tparam,\n\t\t\t\tidentifiers,\n\t\t\t\tnamedModule\n\t\t\t);\n\t\t\tif (!result) return;\n\t\t\tif (fnParams) {\n\t\t\t\tfnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n\t\t\t\t\tif (identifiers[idx]) {\n\t\t\t\t\t\tfnRenames.set(param.name, identifiers[idx]);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tconst identifiers = [\"require\", \"exports\", \"module\"];\n\t\t\tif (fnParams) {\n\t\t\t\tfnParams = fnParams.slice(fnParamsOffset).filter((param, idx) => {\n\t\t\t\t\tif (identifiers[idx]) {\n\t\t\t\t\t\tfnRenames.set(param.name, identifiers[idx]);\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tlet inTry;\n\t\tif (fn && isUnboundFunctionExpression(fn)) {\n\t\t\tinTry = parser.scope.inTry;\n\t\t\tparser.inScope(fnParams, () => {\n\t\t\t\tparser.scope.renames = fnRenames;\n\t\t\t\tparser.scope.inTry = inTry;\n\t\t\t\tif (fn.body.type === \"BlockStatement\") {\n\t\t\t\t\tparser.walkStatement(fn.body);\n\t\t\t\t} else {\n\t\t\t\t\tparser.walkExpression(fn.body);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (fn && isBoundFunctionExpression(fn)) {\n\t\t\tinTry = parser.scope.inTry;\n\t\t\tparser.inScope(\n\t\t\t\tfn.callee.object.params.filter(\n\t\t\t\t\ti => ![\"require\", \"module\", \"exports\"].includes(i.name)\n\t\t\t\t),\n\t\t\t\t() => {\n\t\t\t\t\tparser.scope.renames = fnRenames;\n\t\t\t\t\tparser.scope.inTry = inTry;\n\t\t\t\t\tif (fn.callee.object.body.type === \"BlockStatement\") {\n\t\t\t\t\t\tparser.walkStatement(fn.callee.object.body);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparser.walkExpression(fn.callee.object.body);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tif (fn.arguments) {\n\t\t\t\tparser.walkExpressions(fn.arguments);\n\t\t\t}\n\t\t} else if (fn || obj) {\n\t\t\tparser.walkExpression(fn || obj);\n\t\t}\n\n\t\tconst dep = this.newDefineDependency(\n\t\t\texpr.range,\n\t\t\tarray ? array.range : null,\n\t\t\tfn ? fn.range : null,\n\t\t\tobj ? obj.range : null,\n\t\t\tnamedModule ? namedModule : null\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tif (namedModule) {\n\t\t\tdep.localModule = LocalModulesHelpers.addLocalModule(\n\t\t\t\tparser.state,\n\t\t\t\tnamedModule\n\t\t\t);\n\t\t}\n\t\tparser.state.current.addDependency(dep);\n\t\treturn true;\n\t}\n\n\tnewDefineDependency(\n\t\trange,\n\t\tarrayRange,\n\t\tfunctionRange,\n\t\tobjectRange,\n\t\tnamedModule\n\t) {\n\t\treturn new AMDDefineDependency(\n\t\t\trange,\n\t\t\tarrayRange,\n\t\t\tfunctionRange,\n\t\t\tobjectRange,\n\t\t\tnamedModule\n\t\t);\n\t}\n\tnewRequireArrayDependency(depsArray, range) {\n\t\treturn new AMDRequireArrayDependency(depsArray, range);\n\t}\n\tnewRequireItemDependency(request, range) {\n\t\treturn new AMDRequireItemDependency(request, range);\n\t}\n}\nmodule.exports = AMDDefineDependencyParserPlugin;\n"]},"metadata":{},"sourceType":"script"}