{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\n\nvar GraphHelpers = require(\"./GraphHelpers\");\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\n\n\nvar bySetSize = function bySetSize(a, b) {\n  return b.size - a.size;\n};\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\n\n\nvar extraceBlockInfoMap = function extraceBlockInfoMap(compilation) {\n  /** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n  var blockInfoMap = new Map();\n  /**\n   * @param {Dependency} d dependency to iterate over\n   * @returns {void}\n   */\n\n  var iteratorDependency = function iteratorDependency(d) {\n    // We skip Dependencies without Reference\n    var ref = compilation.getDependencyReference(currentModule, d);\n\n    if (!ref) {\n      return;\n    } // We skip Dependencies without Module pointer\n\n\n    var refModule = ref.module;\n\n    if (!refModule) {\n      return;\n    } // We skip weak Dependencies\n\n\n    if (ref.weak) {\n      return;\n    }\n\n    blockInfoModules.add(refModule);\n  };\n  /**\n   * @param {AsyncDependenciesBlock} b blocks to prepare\n   * @returns {void}\n   */\n\n\n  var iteratorBlockPrepare = function iteratorBlockPrepare(b) {\n    blockInfoBlocks.push(b);\n    blockQueue.push(b);\n  };\n  /** @type {Module} */\n\n\n  var currentModule;\n  /** @type {DependenciesBlock} */\n\n  var block;\n  /** @type {DependenciesBlock[]} */\n\n  var blockQueue;\n  /** @type {Set<Module>} */\n\n  var blockInfoModules;\n  /** @type {AsyncDependenciesBlock[]} */\n\n  var blockInfoBlocks;\n\n  var _iterator = _createForOfIteratorHelper(compilation.modules),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _module = _step.value;\n      blockQueue = [_module];\n      currentModule = _module;\n\n      while (blockQueue.length > 0) {\n        block = blockQueue.pop();\n        blockInfoModules = new Set();\n        blockInfoBlocks = [];\n\n        if (block.variables) {\n          var _iterator2 = _createForOfIteratorHelper(block.variables),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var variable = _step2.value;\n\n              var _iterator3 = _createForOfIteratorHelper(variable.dependencies),\n                  _step3;\n\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  var dep = _step3.value;\n                  iteratorDependency(dep);\n                }\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        if (block.dependencies) {\n          var _iterator4 = _createForOfIteratorHelper(block.dependencies),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _dep = _step4.value;\n              iteratorDependency(_dep);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n\n        if (block.blocks) {\n          var _iterator5 = _createForOfIteratorHelper(block.blocks),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var b = _step5.value;\n              iteratorBlockPrepare(b);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n\n        var blockInfo = {\n          modules: blockInfoModules,\n          blocks: blockInfoBlocks\n        };\n        blockInfoMap.set(block, blockInfo);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return blockInfoMap;\n};\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\n\n\nvar visitModules = function visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups) {\n  var logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n  var namedChunkGroups = compilation.namedChunkGroups;\n  logger.time(\"prepare\");\n  var blockInfoMap = extraceBlockInfoMap(compilation);\n  /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\n  var chunkGroupCounters = new Map();\n\n  var _iterator6 = _createForOfIteratorHelper(inputChunkGroups),\n      _step6;\n\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var _chunkGroup3 = _step6.value;\n      chunkGroupCounters.set(_chunkGroup3, {\n        index: 0,\n        index2: 0\n      });\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n\n  var nextFreeModuleIndex = 0;\n  var nextFreeModuleIndex2 = 0;\n  /** @type {Map<DependenciesBlock, ChunkGroup>} */\n\n  var blockChunkGroups = new Map();\n  var ADD_AND_ENTER_MODULE = 0;\n  var ENTER_MODULE = 1;\n  var PROCESS_BLOCK = 2;\n  var LEAVE_MODULE = 3;\n  /**\n   * @param {QueueItem[]} queue the queue array (will be mutated)\n   * @param {ChunkGroup} chunkGroup chunk group\n   * @returns {QueueItem[]} the queue array again\n   */\n\n  var reduceChunkGroupToQueueItem = function reduceChunkGroupToQueueItem(queue, chunkGroup) {\n    var _iterator7 = _createForOfIteratorHelper(chunkGroup.chunks),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _chunk = _step7.value;\n        var _module2 = _chunk.entryModule;\n        queue.push({\n          action: ENTER_MODULE,\n          block: _module2,\n          module: _module2,\n          chunk: _chunk,\n          chunkGroup: chunkGroup\n        });\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    chunkGroupInfoMap.set(chunkGroup, {\n      chunkGroup: chunkGroup,\n      minAvailableModules: new Set(),\n      minAvailableModulesOwned: true,\n      availableModulesToBeMerged: [],\n      skippedItems: [],\n      resultingAvailableModules: undefined,\n      children: undefined\n    });\n    return queue;\n  }; // Start with the provided modules/chunks\n\n  /** @type {QueueItem[]} */\n\n\n  var queue = inputChunkGroups.reduce(reduceChunkGroupToQueueItem, []).reverse();\n  /** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\n  var queueConnect = new Map();\n  /** @type {Set<ChunkGroupInfo>} */\n\n  var outdatedChunkGroupInfo = new Set();\n  /** @type {QueueItem[]} */\n\n  var queueDelayed = [];\n  logger.timeEnd(\"prepare\");\n  /** @type {Module} */\n\n  var module;\n  /** @type {Chunk} */\n\n  var chunk;\n  /** @type {ChunkGroup} */\n\n  var chunkGroup;\n  /** @type {ChunkGroupInfo} */\n\n  var chunkGroupInfo;\n  /** @type {DependenciesBlock} */\n\n  var block;\n  /** @type {Set<Module>} */\n\n  var minAvailableModules;\n  /** @type {QueueItem[]} */\n\n  var skippedItems; // For each async Block in graph\n\n  /**\n   * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n   * @returns {void}\n   */\n\n  var iteratorBlock = function iteratorBlock(b) {\n    // 1. We create a chunk for this Block\n    // but only once (blockChunkGroups map)\n    var c = blockChunkGroups.get(b);\n\n    if (c === undefined) {\n      c = namedChunkGroups.get(b.chunkName);\n\n      if (c && c.isInitial()) {\n        compilation.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n        c = chunkGroup;\n      } else {\n        c = compilation.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n        chunkGroupCounters.set(c, {\n          index: 0,\n          index2: 0\n        });\n        blockChunkGroups.set(b, c);\n        allCreatedChunkGroups.add(c);\n      }\n\n      blockConnections.set(b, []);\n    } else {\n      // TODO webpack 5 remove addOptions check\n      if (c.addOptions) c.addOptions(b.groupOptions);\n      c.addOrigin(module, b.loc, b.request);\n    } // 2. We store the connection for the block\n    // to connect it later if needed\n\n\n    blockConnections.get(b).push({\n      originChunkGroupInfo: chunkGroupInfo,\n      chunkGroup: c\n    }); // 3. We create/update the chunk group info\n\n    var connectList = queueConnect.get(chunkGroup);\n\n    if (connectList === undefined) {\n      connectList = new Set();\n      queueConnect.set(chunkGroup, connectList);\n    }\n\n    connectList.add(c); // 4. We enqueue the DependenciesBlock for traversal\n\n    queueDelayed.push({\n      action: PROCESS_BLOCK,\n      block: b,\n      module: module,\n      chunk: c.chunks[0],\n      chunkGroup: c\n    });\n  }; // Iterative traversal of the Module graph\n  // Recursive would be simpler to write but could result in Stack Overflows\n\n\n  while (queue.length) {\n    logger.time(\"visiting\");\n\n    while (queue.length) {\n      var queueItem = queue.pop();\n      module = queueItem.module;\n      block = queueItem.block;\n      chunk = queueItem.chunk;\n\n      if (chunkGroup !== queueItem.chunkGroup) {\n        chunkGroup = queueItem.chunkGroup;\n        chunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n        minAvailableModules = chunkGroupInfo.minAvailableModules;\n        skippedItems = chunkGroupInfo.skippedItems;\n      }\n\n      switch (queueItem.action) {\n        case ADD_AND_ENTER_MODULE:\n          {\n            if (minAvailableModules.has(module)) {\n              // already in parent chunks\n              // skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n              skippedItems.push(queueItem);\n              break;\n            } // We connect Module and Chunk when not already done\n\n\n            if (chunk.addModule(module)) {\n              module.addChunk(chunk);\n            } else {\n              // already connected, skip it\n              break;\n            }\n          }\n        // fallthrough\n\n        case ENTER_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              var index = chunkGroup.getModuleIndex(module);\n\n              if (index === undefined) {\n                chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n              }\n            }\n\n            if (module.index === null) {\n              module.index = nextFreeModuleIndex++;\n            }\n\n            queue.push({\n              action: LEAVE_MODULE,\n              block: block,\n              module: module,\n              chunk: chunk,\n              chunkGroup: chunkGroup\n            });\n          }\n        // fallthrough\n\n        case PROCESS_BLOCK:\n          {\n            // get prepared block info\n            var blockInfo = blockInfoMap.get(block); // Buffer items because order need to be reverse to get indicies correct\n\n            var skipBuffer = [];\n            var queueBuffer = []; // Traverse all referenced modules\n\n            var _iterator8 = _createForOfIteratorHelper(blockInfo.modules),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var refModule = _step8.value;\n\n                if (chunk.containsModule(refModule)) {\n                  // skip early if already connected\n                  continue;\n                }\n\n                if (minAvailableModules.has(refModule)) {\n                  // already in parent chunks, skip it for now\n                  skipBuffer.push({\n                    action: ADD_AND_ENTER_MODULE,\n                    block: refModule,\n                    module: refModule,\n                    chunk: chunk,\n                    chunkGroup: chunkGroup\n                  });\n                  continue;\n                } // enqueue the add and enter to enter in the correct order\n                // this is relevant with circular dependencies\n\n\n                queueBuffer.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk: chunk,\n                  chunkGroup: chunkGroup\n                });\n              } // Add buffered items in reversed order\n\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n\n            for (var i = skipBuffer.length - 1; i >= 0; i--) {\n              skippedItems.push(skipBuffer[i]);\n            }\n\n            for (var _i = queueBuffer.length - 1; _i >= 0; _i--) {\n              queue.push(queueBuffer[_i]);\n            } // Traverse all Blocks\n\n\n            var _iterator9 = _createForOfIteratorHelper(blockInfo.blocks),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _block = _step9.value;\n                iteratorBlock(_block);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n\n            if (blockInfo.blocks.length > 0 && module !== block) {\n              blocksWithNestedBlocks.add(block);\n            }\n\n            break;\n          }\n\n        case LEAVE_MODULE:\n          {\n            if (chunkGroup !== undefined) {\n              var _index = chunkGroup.getModuleIndex2(module);\n\n              if (_index === undefined) {\n                chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n              }\n            }\n\n            if (module.index2 === null) {\n              module.index2 = nextFreeModuleIndex2++;\n            }\n\n            break;\n          }\n      }\n    }\n\n    logger.timeEnd(\"visiting\");\n\n    while (queueConnect.size > 0) {\n      logger.time(\"calculating available modules\"); // Figure out new parents for chunk groups\n      // to get new available modules for these children\n\n      var _iterator10 = _createForOfIteratorHelper(queueConnect),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _step10$value = _slicedToArray(_step10.value, 2),\n              _chunkGroup2 = _step10$value[0],\n              targets = _step10$value[1];\n\n          var _info = chunkGroupInfoMap.get(_chunkGroup2);\n\n          var _minAvailableModules = _info.minAvailableModules; // 1. Create a new Set of available modules at this points\n\n          var resultingAvailableModules = new Set(_minAvailableModules);\n\n          var _iterator17 = _createForOfIteratorHelper(_chunkGroup2.chunks),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _chunk2 = _step17.value;\n\n              var _iterator20 = _createForOfIteratorHelper(_chunk2.modulesIterable),\n                  _step20;\n\n              try {\n                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                  var _m2 = _step20.value;\n                  resultingAvailableModules.add(_m2);\n                }\n              } catch (err) {\n                _iterator20.e(err);\n              } finally {\n                _iterator20.f();\n              }\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n\n          _info.resultingAvailableModules = resultingAvailableModules;\n\n          if (_info.children === undefined) {\n            _info.children = targets;\n          } else {\n            var _iterator18 = _createForOfIteratorHelper(targets),\n                _step18;\n\n            try {\n              for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                var target = _step18.value;\n\n                _info.children.add(target);\n              }\n            } catch (err) {\n              _iterator18.e(err);\n            } finally {\n              _iterator18.f();\n            }\n          } // 2. Update chunk group info\n\n\n          var _iterator19 = _createForOfIteratorHelper(targets),\n              _step19;\n\n          try {\n            for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n              var _target = _step19.value;\n\n              var _chunkGroupInfo = chunkGroupInfoMap.get(_target);\n\n              if (_chunkGroupInfo === undefined) {\n                _chunkGroupInfo = {\n                  chunkGroup: _target,\n                  minAvailableModules: undefined,\n                  minAvailableModulesOwned: undefined,\n                  availableModulesToBeMerged: [],\n                  skippedItems: [],\n                  resultingAvailableModules: undefined,\n                  children: undefined\n                };\n                chunkGroupInfoMap.set(_target, _chunkGroupInfo);\n              }\n\n              _chunkGroupInfo.availableModulesToBeMerged.push(resultingAvailableModules);\n\n              outdatedChunkGroupInfo.add(_chunkGroupInfo);\n            }\n          } catch (err) {\n            _iterator19.e(err);\n          } finally {\n            _iterator19.f();\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      queueConnect.clear();\n      logger.timeEnd(\"calculating available modules\");\n\n      if (outdatedChunkGroupInfo.size > 0) {\n        logger.time(\"merging available modules\"); // Execute the merge\n\n        var _iterator11 = _createForOfIteratorHelper(outdatedChunkGroupInfo),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var info = _step11.value;\n            var availableModulesToBeMerged = info.availableModulesToBeMerged;\n            var cachedMinAvailableModules = info.minAvailableModules; // 1. Get minimal available modules\n            // It doesn't make sense to traverse a chunk again with more available modules.\n            // This step calculates the minimal available modules and skips traversal when\n            // the list didn't shrink.\n\n            if (availableModulesToBeMerged.length > 1) {\n              availableModulesToBeMerged.sort(bySetSize);\n            }\n\n            var changed = false;\n\n            var _iterator12 = _createForOfIteratorHelper(availableModulesToBeMerged),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var availableModules = _step12.value;\n\n                if (cachedMinAvailableModules === undefined) {\n                  cachedMinAvailableModules = availableModules;\n                  info.minAvailableModules = cachedMinAvailableModules;\n                  info.minAvailableModulesOwned = false;\n                  changed = true;\n                } else {\n                  if (info.minAvailableModulesOwned) {\n                    // We own it and can modify it\n                    var _iterator15 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                        _step15;\n\n                    try {\n                      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                        var m = _step15.value;\n\n                        if (!availableModules.has(m)) {\n                          cachedMinAvailableModules.delete(m);\n                          changed = true;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator15.e(err);\n                    } finally {\n                      _iterator15.f();\n                    }\n                  } else {\n                    var _iterator16 = _createForOfIteratorHelper(cachedMinAvailableModules),\n                        _step16;\n\n                    try {\n                      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                        var _m = _step16.value;\n\n                        if (!availableModules.has(_m)) {\n                          // cachedMinAvailableModules need to be modified\n                          // but we don't own it\n                          // construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\n                          /** @type {Set<Module>} */\n                          var newSet = new Set();\n                          var iterator = cachedMinAvailableModules[Symbol.iterator]();\n                          /** @type {IteratorResult<Module>} */\n\n                          var it = void 0;\n\n                          while (!(it = iterator.next()).done) {\n                            var _module3 = it.value;\n                            if (_module3 === _m) break;\n                            newSet.add(_module3);\n                          }\n\n                          while (!(it = iterator.next()).done) {\n                            var _module4 = it.value;\n\n                            if (availableModules.has(_module4)) {\n                              newSet.add(_module4);\n                            }\n                          }\n\n                          cachedMinAvailableModules = newSet;\n                          info.minAvailableModulesOwned = true;\n                          info.minAvailableModules = newSet; // Update the cache from the first queue\n                          // if the chunkGroup is currently cached\n\n                          if (chunkGroup === info.chunkGroup) {\n                            minAvailableModules = cachedMinAvailableModules;\n                          }\n\n                          changed = true;\n                          break;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator16.e(err);\n                    } finally {\n                      _iterator16.f();\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n\n            availableModulesToBeMerged.length = 0;\n            if (!changed) continue; // 2. Reconsider skipped items\n\n            var _iterator13 = _createForOfIteratorHelper(info.skippedItems),\n                _step13;\n\n            try {\n              for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                var _queueItem = _step13.value;\n                queue.push(_queueItem);\n              }\n            } catch (err) {\n              _iterator13.e(err);\n            } finally {\n              _iterator13.f();\n            }\n\n            info.skippedItems.length = 0; // 3. Reconsider children chunk groups\n\n            if (info.children !== undefined) {\n              var _chunkGroup = info.chunkGroup;\n\n              var _iterator14 = _createForOfIteratorHelper(info.children),\n                  _step14;\n\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var c = _step14.value;\n                  var connectList = queueConnect.get(_chunkGroup);\n\n                  if (connectList === undefined) {\n                    connectList = new Set();\n                    queueConnect.set(_chunkGroup, connectList);\n                  }\n\n                  connectList.add(c);\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n            }\n          }\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n\n        outdatedChunkGroupInfo.clear();\n        logger.timeEnd(\"merging available modules\");\n      }\n    } // Run queueDelayed when all items of the queue are processed\n    // This is important to get the global indicing correct\n    // Async blocks should be processed after all sync blocks are processed\n\n\n    if (queue.length === 0) {\n      var tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n  }\n};\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\n\n\nvar connectChunkGroups = function connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap) {\n  /**\n   * Helper function to check if all modules of a chunk are available\n   *\n   * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n   * @param {Set<Module>} availableModules the comparitor set\n   * @returns {boolean} return true if all modules of a chunk are available\n   */\n  var areModulesAvailable = function areModulesAvailable(chunkGroup, availableModules) {\n    var _iterator21 = _createForOfIteratorHelper(chunkGroup.chunks),\n        _step21;\n\n    try {\n      for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n        var chunk = _step21.value;\n\n        var _iterator22 = _createForOfIteratorHelper(chunk.modulesIterable),\n            _step22;\n\n        try {\n          for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n            var _module5 = _step22.value;\n            if (!availableModules.has(_module5)) return false;\n          }\n        } catch (err) {\n          _iterator22.e(err);\n        } finally {\n          _iterator22.f();\n        }\n      }\n    } catch (err) {\n      _iterator21.e(err);\n    } finally {\n      _iterator21.f();\n    }\n\n    return true;\n  }; // For each edge in the basic chunk graph\n\n\n  var _iterator23 = _createForOfIteratorHelper(blockConnections),\n      _step23;\n\n  try {\n    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n      var _step23$value = _slicedToArray(_step23.value, 2),\n          block = _step23$value[0],\n          connections = _step23$value[1];\n\n      // 1. Check if connection is needed\n      // When none of the dependencies need to be connected\n      // we can skip all of them\n      // It's not possible to filter each item so it doesn't create inconsistent\n      // connections and modules can only create one version\n      // TODO maybe decide this per runtime\n      if ( // TODO is this needed?\n      !blocksWithNestedBlocks.has(block) && connections.every(function (_ref) {\n        var chunkGroup = _ref.chunkGroup,\n            originChunkGroupInfo = _ref.originChunkGroupInfo;\n        return areModulesAvailable(chunkGroup, originChunkGroupInfo.resultingAvailableModules);\n      })) {\n        continue;\n      } // 2. Foreach edge\n\n\n      for (var i = 0; i < connections.length; i++) {\n        var _connections$i = connections[i],\n            chunkGroup = _connections$i.chunkGroup,\n            originChunkGroupInfo = _connections$i.originChunkGroupInfo; // 3. Connect block with chunk\n\n        GraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup); // 4. Connect chunk with parent\n\n        GraphHelpers.connectChunkGroupParentAndChild(originChunkGroupInfo.chunkGroup, chunkGroup);\n      }\n    }\n  } catch (err) {\n    _iterator23.e(err);\n  } finally {\n    _iterator23.f();\n  }\n};\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\n\n\nvar cleanupUnconnectedGroups = function cleanupUnconnectedGroups(compilation, allCreatedChunkGroups) {\n  var _iterator24 = _createForOfIteratorHelper(allCreatedChunkGroups),\n      _step24;\n\n  try {\n    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n      var chunkGroup = _step24.value;\n\n      if (chunkGroup.getNumberOfParents() === 0) {\n        var _iterator25 = _createForOfIteratorHelper(chunkGroup.chunks),\n            _step25;\n\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var chunk = _step25.value;\n            var idx = compilation.chunks.indexOf(chunk);\n            if (idx >= 0) compilation.chunks.splice(idx, 1);\n            chunk.remove(\"unconnected\");\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n\n        chunkGroup.remove(\"unconnected\");\n      }\n    }\n  } catch (err) {\n    _iterator24.e(err);\n  } finally {\n    _iterator24.f();\n  }\n};\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\n\n\nvar buildChunkGraph = function buildChunkGraph(compilation, inputChunkGroups) {\n  // SHARED STATE\n\n  /** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n  var blockConnections = new Map();\n  /** @type {Set<ChunkGroup>} */\n\n  var allCreatedChunkGroups = new Set();\n  /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\n  var chunkGroupInfoMap = new Map();\n  /** @type {Set<DependenciesBlock>} */\n\n  var blocksWithNestedBlocks = new Set(); // PART ONE\n\n  visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, blockConnections, blocksWithNestedBlocks, allCreatedChunkGroups); // PART TWO\n\n  connectChunkGroups(blocksWithNestedBlocks, blockConnections, chunkGroupInfoMap); // Cleaup work\n\n  cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/buildChunkGraph.js"],"names":["AsyncDependencyToInitialChunkError","require","GraphHelpers","bySetSize","a","b","size","extraceBlockInfoMap","compilation","blockInfoMap","Map","iteratorDependency","d","ref","getDependencyReference","currentModule","refModule","module","weak","blockInfoModules","add","iteratorBlockPrepare","blockInfoBlocks","push","blockQueue","block","modules","length","pop","Set","variables","variable","dependencies","dep","blocks","blockInfo","set","visitModules","inputChunkGroups","chunkGroupInfoMap","blockConnections","blocksWithNestedBlocks","allCreatedChunkGroups","logger","getLogger","namedChunkGroups","time","chunkGroupCounters","chunkGroup","index","index2","nextFreeModuleIndex","nextFreeModuleIndex2","blockChunkGroups","ADD_AND_ENTER_MODULE","ENTER_MODULE","PROCESS_BLOCK","LEAVE_MODULE","reduceChunkGroupToQueueItem","queue","chunks","chunk","entryModule","action","minAvailableModules","minAvailableModulesOwned","availableModulesToBeMerged","skippedItems","resultingAvailableModules","undefined","children","reduce","reverse","queueConnect","outdatedChunkGroupInfo","queueDelayed","timeEnd","chunkGroupInfo","iteratorBlock","c","get","chunkName","isInitial","errors","loc","addChunkInGroup","groupOptions","request","addOptions","addOrigin","originChunkGroupInfo","connectList","queueItem","has","addModule","addChunk","getModuleIndex","setModuleIndex","skipBuffer","queueBuffer","containsModule","i","getModuleIndex2","setModuleIndex2","targets","info","modulesIterable","m","target","clear","cachedMinAvailableModules","sort","changed","availableModules","delete","newSet","iterator","Symbol","it","next","done","value","tempQueue","connectChunkGroups","areModulesAvailable","connections","every","connectDependenciesBlockAndChunkGroup","connectChunkGroupParentAndChild","cleanupUnconnectedGroups","getNumberOfParents","idx","indexOf","splice","remove","buildChunkGraph","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst GraphHelpers = require(\"./GraphHelpers\");\n\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Entrypoint\")} Entrypoint */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} QueueItem\n * @property {number} action\n * @property {DependenciesBlock} block\n * @property {Module} module\n * @property {Chunk} chunk\n * @property {ChunkGroup} chunkGroup\n */\n\n/**\n * @typedef {Object} ChunkGroupInfo\n * @property {ChunkGroup} chunkGroup the chunk group\n * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n * @property {boolean} minAvailableModulesOwned true, if minAvailableModules is owned and can be modified\n * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n * @property {QueueItem[]} skippedItems queue items that were skipped because module is already available in parent chunks (need to reconsider when minAvailableModules is shrinking)\n * @property {Set<Module>} resultingAvailableModules set of modules available including modules from this chunk group\n * @property {Set<ChunkGroup>} children set of children chunk groups, that will be revisited when availableModules shrink\n */\n\n/**\n * @typedef {Object} BlockChunkGroupConnection\n * @property {ChunkGroupInfo} originChunkGroupInfo origin chunk group\n * @property {ChunkGroup} chunkGroup referenced chunk group\n */\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n\treturn b.size - a.size;\n};\n\n/**\n * Extracts simplified info from the modules and their dependencies\n * @param {Compilation} compilation the compilation\n * @returns {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} the mapping block to modules and inner blocks\n */\nconst extraceBlockInfoMap = compilation => {\n\t/** @type {Map<DependenciesBlock, { modules: Iterable<Module>, blocks: AsyncDependenciesBlock[]}>} */\n\tconst blockInfoMap = new Map();\n\n\t/**\n\t * @param {Dependency} d dependency to iterate over\n\t * @returns {void}\n\t */\n\tconst iteratorDependency = d => {\n\t\t// We skip Dependencies without Reference\n\t\tconst ref = compilation.getDependencyReference(currentModule, d);\n\t\tif (!ref) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip Dependencies without Module pointer\n\t\tconst refModule = ref.module;\n\t\tif (!refModule) {\n\t\t\treturn;\n\t\t}\n\t\t// We skip weak Dependencies\n\t\tif (ref.weak) {\n\t\t\treturn;\n\t\t}\n\n\t\tblockInfoModules.add(refModule);\n\t};\n\n\t/**\n\t * @param {AsyncDependenciesBlock} b blocks to prepare\n\t * @returns {void}\n\t */\n\tconst iteratorBlockPrepare = b => {\n\t\tblockInfoBlocks.push(b);\n\t\tblockQueue.push(b);\n\t};\n\n\t/** @type {Module} */\n\tlet currentModule;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {DependenciesBlock[]} */\n\tlet blockQueue;\n\t/** @type {Set<Module>} */\n\tlet blockInfoModules;\n\t/** @type {AsyncDependenciesBlock[]} */\n\tlet blockInfoBlocks;\n\n\tfor (const module of compilation.modules) {\n\t\tblockQueue = [module];\n\t\tcurrentModule = module;\n\t\twhile (blockQueue.length > 0) {\n\t\t\tblock = blockQueue.pop();\n\t\t\tblockInfoModules = new Set();\n\t\t\tblockInfoBlocks = [];\n\n\t\t\tif (block.variables) {\n\t\t\t\tfor (const variable of block.variables) {\n\t\t\t\t\tfor (const dep of variable.dependencies) iteratorDependency(dep);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (block.dependencies) {\n\t\t\t\tfor (const dep of block.dependencies) iteratorDependency(dep);\n\t\t\t}\n\n\t\t\tif (block.blocks) {\n\t\t\t\tfor (const b of block.blocks) iteratorBlockPrepare(b);\n\t\t\t}\n\n\t\t\tconst blockInfo = {\n\t\t\t\tmodules: blockInfoModules,\n\t\t\t\tblocks: blockInfoBlocks\n\t\t\t};\n\t\t\tblockInfoMap.set(block, blockInfo);\n\t\t}\n\t}\n\n\treturn blockInfoMap;\n};\n\n/**\n *\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups input groups\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Set<ChunkGroup>} allCreatedChunkGroups filled with all chunk groups that are created here\n */\nconst visitModules = (\n\tcompilation,\n\tinputChunkGroups,\n\tchunkGroupInfoMap,\n\tblockConnections,\n\tblocksWithNestedBlocks,\n\tallCreatedChunkGroups\n) => {\n\tconst logger = compilation.getLogger(\"webpack.buildChunkGraph.visitModules\");\n\tconst { namedChunkGroups } = compilation;\n\n\tlogger.time(\"prepare\");\n\tconst blockInfoMap = extraceBlockInfoMap(compilation);\n\n\t/** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n\tconst chunkGroupCounters = new Map();\n\tfor (const chunkGroup of inputChunkGroups) {\n\t\tchunkGroupCounters.set(chunkGroup, {\n\t\t\tindex: 0,\n\t\t\tindex2: 0\n\t\t});\n\t}\n\n\tlet nextFreeModuleIndex = 0;\n\tlet nextFreeModuleIndex2 = 0;\n\n\t/** @type {Map<DependenciesBlock, ChunkGroup>} */\n\tconst blockChunkGroups = new Map();\n\n\tconst ADD_AND_ENTER_MODULE = 0;\n\tconst ENTER_MODULE = 1;\n\tconst PROCESS_BLOCK = 2;\n\tconst LEAVE_MODULE = 3;\n\n\t/**\n\t * @param {QueueItem[]} queue the queue array (will be mutated)\n\t * @param {ChunkGroup} chunkGroup chunk group\n\t * @returns {QueueItem[]} the queue array again\n\t */\n\tconst reduceChunkGroupToQueueItem = (queue, chunkGroup) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tconst module = chunk.entryModule;\n\t\t\tqueue.push({\n\t\t\t\taction: ENTER_MODULE,\n\t\t\t\tblock: module,\n\t\t\t\tmodule,\n\t\t\t\tchunk,\n\t\t\t\tchunkGroup\n\t\t\t});\n\t\t}\n\t\tchunkGroupInfoMap.set(chunkGroup, {\n\t\t\tchunkGroup,\n\t\t\tminAvailableModules: new Set(),\n\t\t\tminAvailableModulesOwned: true,\n\t\t\tavailableModulesToBeMerged: [],\n\t\t\tskippedItems: [],\n\t\t\tresultingAvailableModules: undefined,\n\t\t\tchildren: undefined\n\t\t});\n\t\treturn queue;\n\t};\n\n\t// Start with the provided modules/chunks\n\t/** @type {QueueItem[]} */\n\tlet queue = inputChunkGroups\n\t\t.reduce(reduceChunkGroupToQueueItem, [])\n\t\t.reverse();\n\t/** @type {Map<ChunkGroup, Set<ChunkGroup>>} */\n\tconst queueConnect = new Map();\n\t/** @type {Set<ChunkGroupInfo>} */\n\tconst outdatedChunkGroupInfo = new Set();\n\t/** @type {QueueItem[]} */\n\tlet queueDelayed = [];\n\n\tlogger.timeEnd(\"prepare\");\n\n\t/** @type {Module} */\n\tlet module;\n\t/** @type {Chunk} */\n\tlet chunk;\n\t/** @type {ChunkGroup} */\n\tlet chunkGroup;\n\t/** @type {ChunkGroupInfo} */\n\tlet chunkGroupInfo;\n\t/** @type {DependenciesBlock} */\n\tlet block;\n\t/** @type {Set<Module>} */\n\tlet minAvailableModules;\n\t/** @type {QueueItem[]} */\n\tlet skippedItems;\n\n\t// For each async Block in graph\n\t/**\n\t * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n\t * @returns {void}\n\t */\n\tconst iteratorBlock = b => {\n\t\t// 1. We create a chunk for this Block\n\t\t// but only once (blockChunkGroups map)\n\t\tlet c = blockChunkGroups.get(b);\n\t\tif (c === undefined) {\n\t\t\tc = namedChunkGroups.get(b.chunkName);\n\t\t\tif (c && c.isInitial()) {\n\t\t\t\tcompilation.errors.push(\n\t\t\t\t\tnew AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc)\n\t\t\t\t);\n\t\t\t\tc = chunkGroup;\n\t\t\t} else {\n\t\t\t\tc = compilation.addChunkInGroup(\n\t\t\t\t\tb.groupOptions || b.chunkName,\n\t\t\t\t\tmodule,\n\t\t\t\t\tb.loc,\n\t\t\t\t\tb.request\n\t\t\t\t);\n\t\t\t\tchunkGroupCounters.set(c, { index: 0, index2: 0 });\n\t\t\t\tblockChunkGroups.set(b, c);\n\t\t\t\tallCreatedChunkGroups.add(c);\n\t\t\t}\n\t\t\tblockConnections.set(b, []);\n\t\t} else {\n\t\t\t// TODO webpack 5 remove addOptions check\n\t\t\tif (c.addOptions) c.addOptions(b.groupOptions);\n\t\t\tc.addOrigin(module, b.loc, b.request);\n\t\t}\n\n\t\t// 2. We store the connection for the block\n\t\t// to connect it later if needed\n\t\tblockConnections.get(b).push({\n\t\t\toriginChunkGroupInfo: chunkGroupInfo,\n\t\t\tchunkGroup: c\n\t\t});\n\n\t\t// 3. We create/update the chunk group info\n\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\tif (connectList === undefined) {\n\t\t\tconnectList = new Set();\n\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t}\n\t\tconnectList.add(c);\n\n\t\t// 4. We enqueue the DependenciesBlock for traversal\n\t\tqueueDelayed.push({\n\t\t\taction: PROCESS_BLOCK,\n\t\t\tblock: b,\n\t\t\tmodule: module,\n\t\t\tchunk: c.chunks[0],\n\t\t\tchunkGroup: c\n\t\t});\n\t};\n\n\t// Iterative traversal of the Module graph\n\t// Recursive would be simpler to write but could result in Stack Overflows\n\twhile (queue.length) {\n\t\tlogger.time(\"visiting\");\n\t\twhile (queue.length) {\n\t\t\tconst queueItem = queue.pop();\n\t\t\tmodule = queueItem.module;\n\t\t\tblock = queueItem.block;\n\t\t\tchunk = queueItem.chunk;\n\t\t\tif (chunkGroup !== queueItem.chunkGroup) {\n\t\t\t\tchunkGroup = queueItem.chunkGroup;\n\t\t\t\tchunkGroupInfo = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tminAvailableModules = chunkGroupInfo.minAvailableModules;\n\t\t\t\tskippedItems = chunkGroupInfo.skippedItems;\n\t\t\t}\n\n\t\t\tswitch (queueItem.action) {\n\t\t\t\tcase ADD_AND_ENTER_MODULE: {\n\t\t\t\t\tif (minAvailableModules.has(module)) {\n\t\t\t\t\t\t// already in parent chunks\n\t\t\t\t\t\t// skip it for now, but enqueue for rechecking when minAvailableModules shrinks\n\t\t\t\t\t\tskippedItems.push(queueItem);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// We connect Module and Chunk when not already done\n\t\t\t\t\tif (chunk.addModule(module)) {\n\t\t\t\t\t\tmodule.addChunk(chunk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// already connected, skip it\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase ENTER_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index === null) {\n\t\t\t\t\t\tmodule.index = nextFreeModuleIndex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tqueue.push({\n\t\t\t\t\t\taction: LEAVE_MODULE,\n\t\t\t\t\t\tblock,\n\t\t\t\t\t\tmodule,\n\t\t\t\t\t\tchunk,\n\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\t\tcase PROCESS_BLOCK: {\n\t\t\t\t\t// get prepared block info\n\t\t\t\t\tconst blockInfo = blockInfoMap.get(block);\n\n\t\t\t\t\t// Buffer items because order need to be reverse to get indicies correct\n\t\t\t\t\tconst skipBuffer = [];\n\t\t\t\t\tconst queueBuffer = [];\n\t\t\t\t\t// Traverse all referenced modules\n\t\t\t\t\tfor (const refModule of blockInfo.modules) {\n\t\t\t\t\t\tif (chunk.containsModule(refModule)) {\n\t\t\t\t\t\t\t// skip early if already connected\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (minAvailableModules.has(refModule)) {\n\t\t\t\t\t\t\t// already in parent chunks, skip it for now\n\t\t\t\t\t\t\tskipBuffer.push({\n\t\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// enqueue the add and enter to enter in the correct order\n\t\t\t\t\t\t// this is relevant with circular dependencies\n\t\t\t\t\t\tqueueBuffer.push({\n\t\t\t\t\t\t\taction: ADD_AND_ENTER_MODULE,\n\t\t\t\t\t\t\tblock: refModule,\n\t\t\t\t\t\t\tmodule: refModule,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tchunkGroup\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t// Add buffered items in reversed order\n\t\t\t\t\tfor (let i = skipBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tskippedItems.push(skipBuffer[i]);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = queueBuffer.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tqueue.push(queueBuffer[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Traverse all Blocks\n\t\t\t\t\tfor (const block of blockInfo.blocks) iteratorBlock(block);\n\n\t\t\t\t\tif (blockInfo.blocks.length > 0 && module !== block) {\n\t\t\t\t\t\tblocksWithNestedBlocks.add(block);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase LEAVE_MODULE: {\n\t\t\t\t\tif (chunkGroup !== undefined) {\n\t\t\t\t\t\tconst index = chunkGroup.getModuleIndex2(module);\n\t\t\t\t\t\tif (index === undefined) {\n\t\t\t\t\t\t\tchunkGroup.setModuleIndex2(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\tchunkGroupCounters.get(chunkGroup).index2++\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (module.index2 === null) {\n\t\t\t\t\t\tmodule.index2 = nextFreeModuleIndex2++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlogger.timeEnd(\"visiting\");\n\n\t\twhile (queueConnect.size > 0) {\n\t\t\tlogger.time(\"calculating available modules\");\n\n\t\t\t// Figure out new parents for chunk groups\n\t\t\t// to get new available modules for these children\n\t\t\tfor (const [chunkGroup, targets] of queueConnect) {\n\t\t\t\tconst info = chunkGroupInfoMap.get(chunkGroup);\n\t\t\t\tlet minAvailableModules = info.minAvailableModules;\n\n\t\t\t\t// 1. Create a new Set of available modules at this points\n\t\t\t\tconst resultingAvailableModules = new Set(minAvailableModules);\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\tresultingAvailableModules.add(m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinfo.resultingAvailableModules = resultingAvailableModules;\n\t\t\t\tif (info.children === undefined) {\n\t\t\t\t\tinfo.children = targets;\n\t\t\t\t} else {\n\t\t\t\t\tfor (const target of targets) {\n\t\t\t\t\t\tinfo.children.add(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// 2. Update chunk group info\n\t\t\t\tfor (const target of targets) {\n\t\t\t\t\tlet chunkGroupInfo = chunkGroupInfoMap.get(target);\n\t\t\t\t\tif (chunkGroupInfo === undefined) {\n\t\t\t\t\t\tchunkGroupInfo = {\n\t\t\t\t\t\t\tchunkGroup: target,\n\t\t\t\t\t\t\tminAvailableModules: undefined,\n\t\t\t\t\t\t\tminAvailableModulesOwned: undefined,\n\t\t\t\t\t\t\tavailableModulesToBeMerged: [],\n\t\t\t\t\t\t\tskippedItems: [],\n\t\t\t\t\t\t\tresultingAvailableModules: undefined,\n\t\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t\t};\n\t\t\t\t\t\tchunkGroupInfoMap.set(target, chunkGroupInfo);\n\t\t\t\t\t}\n\t\t\t\t\tchunkGroupInfo.availableModulesToBeMerged.push(\n\t\t\t\t\t\tresultingAvailableModules\n\t\t\t\t\t);\n\t\t\t\t\toutdatedChunkGroupInfo.add(chunkGroupInfo);\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueueConnect.clear();\n\t\t\tlogger.timeEnd(\"calculating available modules\");\n\n\t\t\tif (outdatedChunkGroupInfo.size > 0) {\n\t\t\t\tlogger.time(\"merging available modules\");\n\t\t\t\t// Execute the merge\n\t\t\t\tfor (const info of outdatedChunkGroupInfo) {\n\t\t\t\t\tconst availableModulesToBeMerged = info.availableModulesToBeMerged;\n\t\t\t\t\tlet cachedMinAvailableModules = info.minAvailableModules;\n\n\t\t\t\t\t// 1. Get minimal available modules\n\t\t\t\t\t// It doesn't make sense to traverse a chunk again with more available modules.\n\t\t\t\t\t// This step calculates the minimal available modules and skips traversal when\n\t\t\t\t\t// the list didn't shrink.\n\t\t\t\t\tif (availableModulesToBeMerged.length > 1) {\n\t\t\t\t\t\tavailableModulesToBeMerged.sort(bySetSize);\n\t\t\t\t\t}\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const availableModules of availableModulesToBeMerged) {\n\t\t\t\t\t\tif (cachedMinAvailableModules === undefined) {\n\t\t\t\t\t\t\tcachedMinAvailableModules = availableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = false;\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (info.minAvailableModulesOwned) {\n\t\t\t\t\t\t\t\t// We own it and can modify it\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of cachedMinAvailableModules) {\n\t\t\t\t\t\t\t\t\tif (!availableModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\t// cachedMinAvailableModules need to be modified\n\t\t\t\t\t\t\t\t\t\t// but we don't own it\n\t\t\t\t\t\t\t\t\t\t// construct a new Set as intersection of cachedMinAvailableModules and availableModules\n\t\t\t\t\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\t\t\t\t\tconst newSet = new Set();\n\t\t\t\t\t\t\t\t\t\tconst iterator = cachedMinAvailableModules[\n\t\t\t\t\t\t\t\t\t\t\tSymbol.iterator\n\t\t\t\t\t\t\t\t\t\t]();\n\t\t\t\t\t\t\t\t\t\t/** @type {IteratorResult<Module>} */\n\t\t\t\t\t\t\t\t\t\tlet it;\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (module === m) break;\n\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\twhile (!(it = iterator.next()).done) {\n\t\t\t\t\t\t\t\t\t\t\tconst module = it.value;\n\t\t\t\t\t\t\t\t\t\t\tif (availableModules.has(module)) {\n\t\t\t\t\t\t\t\t\t\t\t\tnewSet.add(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcachedMinAvailableModules = newSet;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModulesOwned = true;\n\t\t\t\t\t\t\t\t\t\tinfo.minAvailableModules = newSet;\n\n\t\t\t\t\t\t\t\t\t\t// Update the cache from the first queue\n\t\t\t\t\t\t\t\t\t\t// if the chunkGroup is currently cached\n\t\t\t\t\t\t\t\t\t\tif (chunkGroup === info.chunkGroup) {\n\t\t\t\t\t\t\t\t\t\t\tminAvailableModules = cachedMinAvailableModules;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tavailableModulesToBeMerged.length = 0;\n\t\t\t\t\tif (!changed) continue;\n\n\t\t\t\t\t// 2. Reconsider skipped items\n\t\t\t\t\tfor (const queueItem of info.skippedItems) {\n\t\t\t\t\t\tqueue.push(queueItem);\n\t\t\t\t\t}\n\t\t\t\t\tinfo.skippedItems.length = 0;\n\n\t\t\t\t\t// 3. Reconsider children chunk groups\n\t\t\t\t\tif (info.children !== undefined) {\n\t\t\t\t\t\tconst chunkGroup = info.chunkGroup;\n\t\t\t\t\t\tfor (const c of info.children) {\n\t\t\t\t\t\t\tlet connectList = queueConnect.get(chunkGroup);\n\t\t\t\t\t\t\tif (connectList === undefined) {\n\t\t\t\t\t\t\t\tconnectList = new Set();\n\t\t\t\t\t\t\t\tqueueConnect.set(chunkGroup, connectList);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconnectList.add(c);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\toutdatedChunkGroupInfo.clear();\n\t\t\t\tlogger.timeEnd(\"merging available modules\");\n\t\t\t}\n\t\t}\n\n\t\t// Run queueDelayed when all items of the queue are processed\n\t\t// This is important to get the global indicing correct\n\t\t// Async blocks should be processed after all sync blocks are processed\n\t\tif (queue.length === 0) {\n\t\t\tconst tempQueue = queue;\n\t\t\tqueue = queueDelayed.reverse();\n\t\t\tqueueDelayed = tempQueue;\n\t\t}\n\t}\n};\n\n/**\n *\n * @param {Set<DependenciesBlock>} blocksWithNestedBlocks flag for blocks that have nested blocks\n * @param {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} blockConnections connection for blocks\n * @param {Map<ChunkGroup, ChunkGroupInfo>} chunkGroupInfoMap mapping from chunk group to available modules\n */\nconst connectChunkGroups = (\n\tblocksWithNestedBlocks,\n\tblockConnections,\n\tchunkGroupInfoMap\n) => {\n\t/**\n\t * Helper function to check if all modules of a chunk are available\n\t *\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n\t * @param {Set<Module>} availableModules the comparitor set\n\t * @returns {boolean} return true if all modules of a chunk are available\n\t */\n\tconst areModulesAvailable = (chunkGroup, availableModules) => {\n\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\tif (!availableModules.has(module)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\n\t// For each edge in the basic chunk graph\n\tfor (const [block, connections] of blockConnections) {\n\t\t// 1. Check if connection is needed\n\t\t// When none of the dependencies need to be connected\n\t\t// we can skip all of them\n\t\t// It's not possible to filter each item so it doesn't create inconsistent\n\t\t// connections and modules can only create one version\n\t\t// TODO maybe decide this per runtime\n\t\tif (\n\t\t\t// TODO is this needed?\n\t\t\t!blocksWithNestedBlocks.has(block) &&\n\t\t\tconnections.every(({ chunkGroup, originChunkGroupInfo }) =>\n\t\t\t\tareModulesAvailable(\n\t\t\t\t\tchunkGroup,\n\t\t\t\t\toriginChunkGroupInfo.resultingAvailableModules\n\t\t\t\t)\n\t\t\t)\n\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// 2. Foreach edge\n\t\tfor (let i = 0; i < connections.length; i++) {\n\t\t\tconst { chunkGroup, originChunkGroupInfo } = connections[i];\n\n\t\t\t// 3. Connect block with chunk\n\t\t\tGraphHelpers.connectDependenciesBlockAndChunkGroup(block, chunkGroup);\n\n\t\t\t// 4. Connect chunk with parent\n\t\t\tGraphHelpers.connectChunkGroupParentAndChild(\n\t\t\t\toriginChunkGroupInfo.chunkGroup,\n\t\t\t\tchunkGroup\n\t\t\t);\n\t\t}\n\t}\n};\n\n/**\n * Remove all unconnected chunk groups\n * @param {Compilation} compilation the compilation\n * @param {Iterable<ChunkGroup>} allCreatedChunkGroups all chunk groups that where created before\n */\nconst cleanupUnconnectedGroups = (compilation, allCreatedChunkGroups) => {\n\tfor (const chunkGroup of allCreatedChunkGroups) {\n\t\tif (chunkGroup.getNumberOfParents() === 0) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tconst idx = compilation.chunks.indexOf(chunk);\n\t\t\t\tif (idx >= 0) compilation.chunks.splice(idx, 1);\n\t\t\t\tchunk.remove(\"unconnected\");\n\t\t\t}\n\t\t\tchunkGroup.remove(\"unconnected\");\n\t\t}\n\t}\n};\n\n/**\n * This method creates the Chunk graph from the Module graph\n * @param {Compilation} compilation the compilation\n * @param {Entrypoint[]} inputChunkGroups chunk groups which are processed\n * @returns {void}\n */\nconst buildChunkGraph = (compilation, inputChunkGroups) => {\n\t// SHARED STATE\n\n\t/** @type {Map<AsyncDependenciesBlock, BlockChunkGroupConnection[]>} */\n\tconst blockConnections = new Map();\n\n\t/** @type {Set<ChunkGroup>} */\n\tconst allCreatedChunkGroups = new Set();\n\n\t/** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n\tconst chunkGroupInfoMap = new Map();\n\n\t/** @type {Set<DependenciesBlock>} */\n\tconst blocksWithNestedBlocks = new Set();\n\n\t// PART ONE\n\n\tvisitModules(\n\t\tcompilation,\n\t\tinputChunkGroups,\n\t\tchunkGroupInfoMap,\n\t\tblockConnections,\n\t\tblocksWithNestedBlocks,\n\t\tallCreatedChunkGroups\n\t);\n\n\t// PART TWO\n\n\tconnectChunkGroups(\n\t\tblocksWithNestedBlocks,\n\t\tblockConnections,\n\t\tchunkGroupInfoMap\n\t);\n\n\t// Cleaup work\n\n\tcleanupUnconnectedGroups(compilation, allCreatedChunkGroups);\n};\n\nmodule.exports = buildChunkGraph;\n"]},"metadata":{},"sourceType":"script"}