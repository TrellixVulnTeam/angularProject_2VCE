{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findLazyRoutes = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar path_1 = require(\"path\");\n\nvar ts = require(\"typescript\");\n\nvar refactor_1 = require(\"./refactor\");\n\nvar utils_1 = require(\"./utils\");\n\nfunction _getContentOfKeyLiteral(_source, node) {\n  if (node.kind == ts.SyntaxKind.Identifier) {\n    return node.text;\n  } else if (node.kind == ts.SyntaxKind.StringLiteral) {\n    return node.text;\n  } else {\n    return null;\n  }\n}\n\nfunction findLazyRoutes(filePath, host, program, compilerOptions) {\n  if (!compilerOptions) {\n    if (!program) {\n      throw new Error('Must pass either program or compilerOptions to findLazyRoutes.');\n    }\n\n    compilerOptions = program.getCompilerOptions();\n  }\n\n  var fileName = utils_1.forwardSlashPath(refactor_1.resolve(filePath, host, compilerOptions));\n  var sourceFile;\n\n  if (program) {\n    sourceFile = program.getSourceFile(fileName);\n  }\n\n  if (!sourceFile) {\n    var content = host.readFile(fileName);\n\n    if (content) {\n      sourceFile = ts.createSourceFile(fileName, content, ts.ScriptTarget.Latest, true);\n    }\n  }\n\n  if (!sourceFile) {\n    throw new Error(\"Source file not found: '\".concat(fileName, \"'.\"));\n  }\n\n  var sf = sourceFile;\n  return refactor_1.findAstNodes(null, sourceFile, ts.isObjectLiteralExpression, true) // Get all their property assignments.\n  .map(function (node) {\n    return refactor_1.findAstNodes(node, sf, ts.isPropertyAssignment, false);\n  }) // Take all `loadChildren` elements.\n  .reduce(function (acc, props) {\n    return acc.concat(props.filter(function (literal) {\n      return _getContentOfKeyLiteral(sf, literal.name) == 'loadChildren';\n    }));\n  }, []) // Get only string values.\n  .map(function (node) {\n    return node.initializer;\n  }).filter(ts.isStringLiteral) // Map those to either [path, absoluteModulePath], or [path, null] if the module pointing to\n  // does not exist.\n  .map(function (_ref) {\n    var routePath = _ref.text;\n    var moduleName = routePath.split('#')[0];\n    var compOptions = program && program.getCompilerOptions() || compilerOptions || {};\n    var resolvedModuleName = moduleName[0] == '.' ? {\n      resolvedModule: {\n        resolvedFileName: path_1.join(path_1.dirname(filePath), moduleName) + '.ts'\n      }\n    } : ts.resolveModuleName(moduleName, filePath, compOptions, host);\n\n    if (resolvedModuleName.resolvedModule && resolvedModuleName.resolvedModule.resolvedFileName && host.fileExists(resolvedModuleName.resolvedModule.resolvedFileName)) {\n      return [routePath, resolvedModuleName.resolvedModule.resolvedFileName];\n    } else {\n      return [routePath, null];\n    }\n  }) // Reduce to the LazyRouteMap map.\n  .reduce(function (acc, _ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        routePath = _ref3[0],\n        resolvedModuleName = _ref3[1];\n\n    if (resolvedModuleName) {\n      acc[routePath] = resolvedModuleName;\n    }\n\n    return acc;\n  }, {});\n}\n\nexports.findLazyRoutes = findLazyRoutes;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/lazy_routes.js"],"names":["Object","defineProperty","exports","value","findLazyRoutes","path_1","require","ts","refactor_1","utils_1","_getContentOfKeyLiteral","_source","node","kind","SyntaxKind","Identifier","text","StringLiteral","filePath","host","program","compilerOptions","Error","getCompilerOptions","fileName","forwardSlashPath","resolve","sourceFile","getSourceFile","content","readFile","createSourceFile","ScriptTarget","Latest","sf","findAstNodes","isObjectLiteralExpression","map","isPropertyAssignment","reduce","acc","props","concat","filter","literal","name","initializer","isStringLiteral","routePath","moduleName","split","compOptions","resolvedModuleName","resolvedModule","resolvedFileName","join","dirname","resolveModuleName","fileExists"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findLazyRoutes = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst path_1 = require(\"path\");\nconst ts = require(\"typescript\");\nconst refactor_1 = require(\"./refactor\");\nconst utils_1 = require(\"./utils\");\nfunction _getContentOfKeyLiteral(_source, node) {\n    if (node.kind == ts.SyntaxKind.Identifier) {\n        return node.text;\n    }\n    else if (node.kind == ts.SyntaxKind.StringLiteral) {\n        return node.text;\n    }\n    else {\n        return null;\n    }\n}\nfunction findLazyRoutes(filePath, host, program, compilerOptions) {\n    if (!compilerOptions) {\n        if (!program) {\n            throw new Error('Must pass either program or compilerOptions to findLazyRoutes.');\n        }\n        compilerOptions = program.getCompilerOptions();\n    }\n    const fileName = utils_1.forwardSlashPath(refactor_1.resolve(filePath, host, compilerOptions));\n    let sourceFile;\n    if (program) {\n        sourceFile = program.getSourceFile(fileName);\n    }\n    if (!sourceFile) {\n        const content = host.readFile(fileName);\n        if (content) {\n            sourceFile = ts.createSourceFile(fileName, content, ts.ScriptTarget.Latest, true);\n        }\n    }\n    if (!sourceFile) {\n        throw new Error(`Source file not found: '${fileName}'.`);\n    }\n    const sf = sourceFile;\n    return refactor_1.findAstNodes(null, sourceFile, ts.isObjectLiteralExpression, true)\n        // Get all their property assignments.\n        .map((node) => refactor_1.findAstNodes(node, sf, ts.isPropertyAssignment, false))\n        // Take all `loadChildren` elements.\n        .reduce((acc, props) => {\n        return acc.concat(props.filter(literal => {\n            return _getContentOfKeyLiteral(sf, literal.name) == 'loadChildren';\n        }));\n    }, [])\n        // Get only string values.\n        .map((node) => node.initializer)\n        .filter(ts.isStringLiteral)\n        // Map those to either [path, absoluteModulePath], or [path, null] if the module pointing to\n        // does not exist.\n        .map(({ text: routePath }) => {\n        const moduleName = routePath.split('#')[0];\n        const compOptions = (program && program.getCompilerOptions()) || compilerOptions || {};\n        const resolvedModuleName = moduleName[0] == '.'\n            ? {\n                resolvedModule: { resolvedFileName: path_1.join(path_1.dirname(filePath), moduleName) + '.ts' },\n            }\n            : ts.resolveModuleName(moduleName, filePath, compOptions, host);\n        if (resolvedModuleName.resolvedModule\n            && resolvedModuleName.resolvedModule.resolvedFileName\n            && host.fileExists(resolvedModuleName.resolvedModule.resolvedFileName)) {\n            return [routePath, resolvedModuleName.resolvedModule.resolvedFileName];\n        }\n        else {\n            return [routePath, null];\n        }\n    })\n        // Reduce to the LazyRouteMap map.\n        .reduce((acc, [routePath, resolvedModuleName]) => {\n        if (resolvedModuleName) {\n            acc[routePath] = resolvedModuleName;\n        }\n        return acc;\n    }, {});\n}\nexports.findLazyRoutes = findLazyRoutes;\n"]},"metadata":{},"sourceType":"script"}