{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/compiler_host\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"path\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/transformers/metadata_reader\", \"@angular/compiler-cli/src/transformers/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getOriginalReferences = exports.TsCompilerAotCompilerTypeCheckHostAdapter = exports.createCompilerHost = exports.setWrapHostForTest = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var path = require(\"path\");\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var metadata_reader_1 = require(\"@angular/compiler-cli/src/transformers/metadata_reader\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/transformers/util\");\n\n  var NODE_MODULES_PACKAGE_NAME = /node_modules\\/((\\w|-|\\.)+|(@(\\w|-|\\.)+\\/(\\w|-|\\.)+))/;\n  var EXT = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\n  var CSS_PREPROCESSOR_EXT = /(\\.scss|\\.sass|\\.less|\\.styl)$/;\n  var wrapHostForTest = null;\n\n  function setWrapHostForTest(wrapFn) {\n    wrapHostForTest = wrapFn;\n  }\n\n  exports.setWrapHostForTest = setWrapHostForTest;\n\n  function createCompilerHost(_a) {\n    var options = _a.options,\n        _b = _a.tsHost,\n        tsHost = _b === void 0 ? ts.createCompilerHost(options, true) : _b;\n\n    if (wrapHostForTest !== null) {\n      tsHost = wrapHostForTest(tsHost);\n    }\n\n    return tsHost;\n  }\n\n  exports.createCompilerHost = createCompilerHost;\n\n  function assert(condition) {\n    if (!condition) {// TODO(chuckjaz): do the right thing\n    }\n\n    return condition;\n  }\n  /**\n   * Implements the following hosts based on an api.CompilerHost:\n   * - ts.CompilerHost to be consumed by a ts.Program\n   * - AotCompilerHost for @angular/compiler\n   * - TypeCheckHost for mapping ts errors to ng errors (via translateDiagnostics)\n   */\n\n\n  var TsCompilerAotCompilerTypeCheckHostAdapter =\n  /** @class */\n  function () {\n    function TsCompilerAotCompilerTypeCheckHostAdapter(rootFiles, options, context, metadataProvider, codeGenerator, librarySummaries) {\n      var _this = this;\n\n      if (librarySummaries === void 0) {\n        librarySummaries = new Map();\n      }\n\n      this.rootFiles = rootFiles;\n      this.options = options;\n      this.context = context;\n      this.metadataProvider = metadataProvider;\n      this.codeGenerator = codeGenerator;\n      this.librarySummaries = librarySummaries;\n      this.metadataReaderCache = metadata_reader_1.createMetadataReaderCache();\n      this.fileNameToModuleNameCache = new Map();\n      this.flatModuleIndexCache = new Map();\n      this.flatModuleIndexNames = new Set();\n      this.flatModuleIndexRedirectNames = new Set();\n      this.originalSourceFiles = new Map();\n      this.originalFileExistsCache = new Map();\n      this.generatedSourceFiles = new Map();\n      this.generatedCodeFor = new Map();\n      this.emitter = new compiler_1.TypeScriptEmitter();\n\n      this.getDefaultLibFileName = function (options) {\n        return _this.context.getDefaultLibFileName(options);\n      };\n\n      this.getCurrentDirectory = function () {\n        return _this.context.getCurrentDirectory();\n      };\n\n      this.getCanonicalFileName = function (fileName) {\n        return _this.context.getCanonicalFileName(fileName);\n      };\n\n      this.useCaseSensitiveFileNames = function () {\n        return _this.context.useCaseSensitiveFileNames();\n      };\n\n      this.getNewLine = function () {\n        return _this.context.getNewLine();\n      }; // Make sure we do not `host.realpath()` from TS as we do not want to resolve symlinks.\n      // https://github.com/Microsoft/TypeScript/issues/9552\n\n\n      this.realpath = function (p) {\n        return p;\n      };\n\n      this.writeFile = this.context.writeFile.bind(this.context);\n      this.moduleResolutionCache = ts.createModuleResolutionCache(this.context.getCurrentDirectory(), this.context.getCanonicalFileName.bind(this.context));\n      var basePath = this.options.basePath;\n      this.rootDirs = (this.options.rootDirs || [this.options.basePath]).map(function (p) {\n        return path.resolve(basePath, p);\n      });\n\n      if (context.getDirectories) {\n        this.getDirectories = function (path) {\n          return context.getDirectories(path);\n        };\n      }\n\n      if (context.directoryExists) {\n        this.directoryExists = function (directoryName) {\n          return context.directoryExists(directoryName);\n        };\n      }\n\n      if (context.getCancellationToken) {\n        this.getCancellationToken = function () {\n          return context.getCancellationToken();\n        };\n      }\n\n      if (context.getDefaultLibLocation) {\n        this.getDefaultLibLocation = function () {\n          return context.getDefaultLibLocation();\n        };\n      }\n\n      if (context.resolveTypeReferenceDirectives) {\n        this.resolveTypeReferenceDirectives = function (names, containingFile) {\n          return context.resolveTypeReferenceDirectives(names, containingFile);\n        };\n      }\n\n      if (context.trace) {\n        this.trace = function (s) {\n          return context.trace(s);\n        };\n      }\n\n      if (context.fileNameToModuleName) {\n        this.fileNameToModuleName = context.fileNameToModuleName.bind(context);\n      } // Note: don't copy over context.moduleNameToFileName as we first\n      // normalize undefined containingFile to a filled containingFile.\n\n\n      if (context.resourceNameToFileName) {\n        this.resourceNameToFileName = context.resourceNameToFileName.bind(context);\n      }\n\n      if (context.toSummaryFileName) {\n        this.toSummaryFileName = context.toSummaryFileName.bind(context);\n      }\n\n      if (context.fromSummaryFileName) {\n        this.fromSummaryFileName = context.fromSummaryFileName.bind(context);\n      }\n\n      this.metadataReaderHost = {\n        cacheMetadata: function cacheMetadata() {\n          return true;\n        },\n        getSourceFileMetadata: function getSourceFileMetadata(filePath) {\n          var sf = _this.getOriginalSourceFile(filePath);\n\n          return sf ? _this.metadataProvider.getMetadata(sf) : undefined;\n        },\n        fileExists: function fileExists(filePath) {\n          return _this.originalFileExists(filePath);\n        },\n        readFile: function readFile(filePath) {\n          return assert(_this.context.readFile(filePath));\n        }\n      };\n    }\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.resolveModuleName = function (moduleName, containingFile) {\n      var rm = ts.resolveModuleName(moduleName, containingFile.replace(/\\\\/g, '/'), this.options, this, this.moduleResolutionCache).resolvedModule;\n\n      if (rm && this.isSourceFile(rm.resolvedFileName) && util_1.DTS.test(rm.resolvedFileName)) {\n        // Case: generateCodeForLibraries = true and moduleName is\n        // a .d.ts file in a node_modules folder.\n        // Need to set isExternalLibraryImport to false so that generated files for that file\n        // are emitted.\n        rm.isExternalLibraryImport = false;\n      }\n\n      return rm;\n    }; // Note: We implement this method so that TypeScript and Angular share the same\n    // ts.ModuleResolutionCache\n    // and that we can tell ts.Program about our different opinion about\n    // ResolvedModule.isExternalLibraryImport\n    // (see our isSourceFile method).\n\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.resolveModuleNames = function (moduleNames, containingFile) {\n      var _this = this; // TODO(tbosch): this seems to be a typing error in TypeScript,\n      // as it contains assertions that the result contains the same number of entries\n      // as the given module names.\n\n\n      return moduleNames.map(function (moduleName) {\n        return _this.resolveModuleName(moduleName, containingFile);\n      });\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.moduleNameToFileName = function (m, containingFile) {\n      if (!containingFile) {\n        if (m.indexOf('.') === 0) {\n          throw new Error('Resolution of relative paths requires a containing file.');\n        } // Any containing file gives the same result for absolute imports\n\n\n        containingFile = this.rootFiles[0];\n      }\n\n      if (this.context.moduleNameToFileName) {\n        return this.context.moduleNameToFileName(m, containingFile);\n      }\n\n      var resolved = this.resolveModuleName(m, containingFile);\n      return resolved ? resolved.resolvedFileName : null;\n    };\n    /**\n     * We want a moduleId that will appear in import statements in the generated code\n     * which will be written to `containingFile`.\n     *\n     * Note that we also generate files for files in node_modules, as libraries\n     * only ship .metadata.json files but not the generated code.\n     *\n     * Logic:\n     * 1. if the importedFile and the containingFile are from the project sources\n     *    or from the same node_modules package, use a relative path\n     * 2. if the importedFile is in a node_modules package,\n     *    use a path that starts with the package name.\n     * 3. Error if the containingFile is in the node_modules package\n     *    and the importedFile is in the project soures,\n     *    as that is a violation of the principle that node_modules packages cannot\n     *    import project sources.\n     */\n\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.fileNameToModuleName = function (importedFile, containingFile) {\n      var cacheKey = importedFile + \":\" + containingFile;\n      var moduleName = this.fileNameToModuleNameCache.get(cacheKey);\n\n      if (moduleName != null) {\n        return moduleName;\n      }\n\n      var originalImportedFile = importedFile;\n\n      if (this.options.traceResolution) {\n        console.error('fileNameToModuleName from containingFile', containingFile, 'to importedFile', importedFile);\n      } // drop extension\n\n\n      importedFile = importedFile.replace(EXT, '');\n      var importedFilePackageName = getPackageName(importedFile);\n      var containingFilePackageName = getPackageName(containingFile);\n\n      if (importedFilePackageName === containingFilePackageName || util_1.GENERATED_FILES.test(originalImportedFile)) {\n        var rootedContainingFile = util_1.relativeToRootDirs(containingFile, this.rootDirs);\n        var rootedImportedFile = util_1.relativeToRootDirs(importedFile, this.rootDirs);\n\n        if (rootedContainingFile !== containingFile && rootedImportedFile !== importedFile) {\n          // if both files are contained in the `rootDirs`, then strip the rootDirs\n          containingFile = rootedContainingFile;\n          importedFile = rootedImportedFile;\n        }\n\n        moduleName = dotRelative(path.dirname(containingFile), importedFile);\n      } else if (importedFilePackageName) {\n        moduleName = stripNodeModulesPrefix(importedFile);\n\n        if (originalImportedFile.endsWith('.d.ts')) {\n          // the moduleName for these typings could be shortented to the npm package name\n          // if the npm package typings matches the importedFile\n          try {\n            var modulePath = importedFile.substring(0, importedFile.length - moduleName.length) + importedFilePackageName;\n\n            var packageJson = require(modulePath + '/package.json');\n\n            var packageTypings = file_system_1.join(modulePath, packageJson.typings);\n\n            if (packageTypings === originalImportedFile) {\n              moduleName = importedFilePackageName;\n            }\n          } catch (_a) {// the above require() will throw if there is no package.json file\n            // and this is safe to ignore and correct to keep the longer\n            // moduleName in this case\n          }\n        }\n      } else {\n        throw new Error(\"Trying to import a source file from a node_modules package: import \" + originalImportedFile + \" from \" + containingFile);\n      }\n\n      this.fileNameToModuleNameCache.set(cacheKey, moduleName);\n      return moduleName;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.resourceNameToFileName = function (resourceName, containingFile) {\n      // Note: we convert package paths into relative paths to be compatible with the the\n      // previous implementation of UrlResolver.\n      var firstChar = resourceName[0];\n\n      if (firstChar === '/') {\n        resourceName = resourceName.slice(1);\n      } else if (firstChar !== '.') {\n        resourceName = \"./\" + resourceName;\n      }\n\n      var filePathWithNgResource = this.moduleNameToFileName(addNgResourceSuffix(resourceName), containingFile); // If the user specified styleUrl pointing to *.scss, but the Sass compiler was run before\n      // Angular, then the resource may have been generated as *.css. Simply try the resolution again.\n\n      if (!filePathWithNgResource && CSS_PREPROCESSOR_EXT.test(resourceName)) {\n        var fallbackResourceName = resourceName.replace(CSS_PREPROCESSOR_EXT, '.css');\n        filePathWithNgResource = this.moduleNameToFileName(addNgResourceSuffix(fallbackResourceName), containingFile);\n      }\n\n      var result = filePathWithNgResource ? stripNgResourceSuffix(filePathWithNgResource) : null; // Used under Bazel to report more specific error with remediation advice\n\n      if (!result && this.context.reportMissingResource) {\n        this.context.reportMissingResource(resourceName);\n      }\n\n      return result;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.toSummaryFileName = function (fileName, referringSrcFileName) {\n      return this.fileNameToModuleName(fileName, referringSrcFileName);\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.fromSummaryFileName = function (fileName, referringLibFileName) {\n      var resolved = this.moduleNameToFileName(fileName, referringLibFileName);\n\n      if (!resolved) {\n        throw new Error(\"Could not resolve \" + fileName + \" from \" + referringLibFileName);\n      }\n\n      return resolved;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.parseSourceSpanOf = function (fileName, line, character) {\n      var data = this.generatedSourceFiles.get(fileName);\n\n      if (data && data.emitCtx) {\n        return data.emitCtx.spanOf(line, character);\n      }\n\n      return null;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.getOriginalSourceFile = function (filePath, languageVersion, onError) {\n      // Note: we need the explicit check via `has` as we also cache results\n      // that were null / undefined.\n      if (this.originalSourceFiles.has(filePath)) {\n        return this.originalSourceFiles.get(filePath);\n      }\n\n      if (!languageVersion) {\n        languageVersion = this.options.target || ts.ScriptTarget.Latest;\n      } // Note: This can also return undefined,\n      // as the TS typings are not correct!\n\n\n      var sf = this.context.getSourceFile(filePath, languageVersion, onError) || null;\n      this.originalSourceFiles.set(filePath, sf);\n      return sf;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.updateGeneratedFile = function (genFile) {\n      if (!genFile.stmts) {\n        throw new Error(\"Invalid Argument: Expected a GenerateFile with statements. \" + genFile.genFileUrl);\n      }\n\n      var oldGenFile = this.generatedSourceFiles.get(genFile.genFileUrl);\n\n      if (!oldGenFile) {\n        throw new Error(\"Illegal State: previous GeneratedFile not found for \" + genFile.genFileUrl + \".\");\n      }\n\n      var newRefs = genFileExternalReferences(genFile);\n      var oldRefs = oldGenFile.externalReferences;\n      var refsAreEqual = oldRefs.size === newRefs.size;\n\n      if (refsAreEqual) {\n        newRefs.forEach(function (r) {\n          return refsAreEqual = refsAreEqual && oldRefs.has(r);\n        });\n      }\n\n      if (!refsAreEqual) {\n        throw new Error(\"Illegal State: external references changed in \" + genFile.genFileUrl + \".\\nOld: \" + Array.from(oldRefs) + \".\\nNew: \" + Array.from(newRefs));\n      }\n\n      return this.addGeneratedFile(genFile, newRefs);\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.addGeneratedFile = function (genFile, externalReferences) {\n      if (!genFile.stmts) {\n        throw new Error(\"Invalid Argument: Expected a GenerateFile with statements. \" + genFile.genFileUrl);\n      }\n\n      var _a = this.emitter.emitStatementsAndContext(genFile.genFileUrl, genFile.stmts,\n      /* preamble */\n      '',\n      /* emitSourceMaps */\n      false),\n          sourceText = _a.sourceText,\n          context = _a.context;\n\n      var sf = ts.createSourceFile(genFile.genFileUrl, sourceText, this.options.target || ts.ScriptTarget.Latest);\n\n      if (this.options.module === ts.ModuleKind.AMD || this.options.module === ts.ModuleKind.UMD) {\n        if (this.context.amdModuleName) {\n          var moduleName = this.context.amdModuleName(sf);\n          if (moduleName) sf.moduleName = moduleName;\n        } else if (/node_modules/.test(genFile.genFileUrl)) {\n          // If we are generating an ngModule file under node_modules, we know the right module name\n          // We don't need the host to supply a function in this case.\n          sf.moduleName = stripNodeModulesPrefix(genFile.genFileUrl.replace(EXT, ''));\n        }\n      }\n\n      this.generatedSourceFiles.set(genFile.genFileUrl, {\n        sourceFile: sf,\n        emitCtx: context,\n        externalReferences: externalReferences\n      });\n      return sf;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.shouldGenerateFile = function (fileName) {\n      var _this = this; // TODO(tbosch): allow generating files that are not in the rootDir\n      // See https://github.com/angular/angular/issues/19337\n\n\n      if (!util_1.isInRootDir(fileName, this.options)) {\n        return {\n          generate: false\n        };\n      }\n\n      var genMatch = util_1.GENERATED_FILES.exec(fileName);\n\n      if (!genMatch) {\n        return {\n          generate: false\n        };\n      }\n\n      var _a = tslib_1.__read(genMatch, 4),\n          base = _a[1],\n          genSuffix = _a[2],\n          suffix = _a[3];\n\n      if (suffix !== 'ts' && suffix !== 'tsx') {\n        return {\n          generate: false\n        };\n      }\n\n      var baseFileName;\n\n      if (genSuffix.indexOf('ngstyle') >= 0) {\n        // Note: ngstyle files have names like `afile.css.ngstyle.ts`\n        if (!this.originalFileExists(base)) {\n          return {\n            generate: false\n          };\n        }\n      } else {\n        // Note: on-the-fly generated files always have a `.ts` suffix,\n        // but the file from which we generated it can be a `.ts`/ `.tsx`/ `.d.ts`\n        // (see options.generateCodeForLibraries).\n        baseFileName = [base + \".ts\", base + \".tsx\", base + \".d.ts\"].find(function (baseFileName) {\n          return _this.isSourceFile(baseFileName) && _this.originalFileExists(baseFileName);\n        });\n\n        if (!baseFileName) {\n          return {\n            generate: false\n          };\n        }\n      }\n\n      return {\n        generate: true,\n        baseFileName: baseFileName\n      };\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.shouldGenerateFilesFor = function (fileName) {\n      // TODO(tbosch): allow generating files that are not in the rootDir\n      // See https://github.com/angular/angular/issues/19337\n      return !util_1.GENERATED_FILES.test(fileName) && this.isSourceFile(fileName) && util_1.isInRootDir(fileName, this.options);\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.getSourceFile = function (fileName, languageVersion, onError) {\n      var _this = this; // Note: Don't exit early in this method to make sure\n      // we always have up to date references on the file!\n\n\n      var genFileNames = [];\n      var sf = this.getGeneratedFile(fileName);\n\n      if (!sf) {\n        var summary = this.librarySummaries.get(fileName);\n\n        if (summary) {\n          if (!summary.sourceFile) {\n            summary.sourceFile = ts.createSourceFile(fileName, summary.text, this.options.target || ts.ScriptTarget.Latest);\n          }\n\n          sf = summary.sourceFile; // TypeScript doesn't allow returning redirect source files. To avoid unforseen errors we\n          // return the original source file instead of the redirect target.\n\n          var redirectInfo = sf.redirectInfo;\n\n          if (redirectInfo !== undefined) {\n            sf = redirectInfo.unredirected;\n          }\n\n          genFileNames = [];\n        }\n      }\n\n      if (!sf) {\n        sf = this.getOriginalSourceFile(fileName);\n        var cachedGenFiles = this.generatedCodeFor.get(fileName);\n\n        if (cachedGenFiles) {\n          genFileNames = cachedGenFiles;\n        } else {\n          if (!this.options.noResolve && this.shouldGenerateFilesFor(fileName)) {\n            genFileNames = this.codeGenerator.findGeneratedFileNames(fileName).filter(function (fileName) {\n              return _this.shouldGenerateFile(fileName).generate;\n            });\n          }\n\n          this.generatedCodeFor.set(fileName, genFileNames);\n        }\n      }\n\n      if (sf) {\n        addReferencesToSourceFile(sf, genFileNames);\n      } // TODO(tbosch): TypeScript's typings for getSourceFile are incorrect,\n      // as it can very well return undefined.\n\n\n      return sf;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.getGeneratedFile = function (fileName) {\n      var genSrcFile = this.generatedSourceFiles.get(fileName);\n\n      if (genSrcFile) {\n        return genSrcFile.sourceFile;\n      }\n\n      var _a = this.shouldGenerateFile(fileName),\n          generate = _a.generate,\n          baseFileName = _a.baseFileName;\n\n      if (generate) {\n        var genFile = this.codeGenerator.generateFile(fileName, baseFileName);\n        return this.addGeneratedFile(genFile, genFileExternalReferences(genFile));\n      }\n\n      return null;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.originalFileExists = function (fileName) {\n      var fileExists = this.originalFileExistsCache.get(fileName);\n\n      if (fileExists == null) {\n        fileExists = this.context.fileExists(fileName);\n        this.originalFileExistsCache.set(fileName, fileExists);\n      }\n\n      return fileExists;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.fileExists = function (fileName) {\n      fileName = stripNgResourceSuffix(fileName);\n\n      if (this.librarySummaries.has(fileName) || this.generatedSourceFiles.has(fileName)) {\n        return true;\n      }\n\n      if (this.shouldGenerateFile(fileName).generate) {\n        return true;\n      }\n\n      return this.originalFileExists(fileName);\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.loadSummary = function (filePath) {\n      var summary = this.librarySummaries.get(filePath);\n\n      if (summary) {\n        return summary.text;\n      }\n\n      if (this.originalFileExists(filePath)) {\n        return assert(this.context.readFile(filePath));\n      }\n\n      return null;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.isSourceFile = function (filePath) {\n      // Don't generate any files nor typecheck them\n      // if skipTemplateCodegen is set and fullTemplateTypeCheck is not yet set,\n      // for backwards compatibility.\n      if (this.options.skipTemplateCodegen && !this.options.fullTemplateTypeCheck) {\n        return false;\n      } // If we have a summary from a previous compilation,\n      // treat the file never as a source file.\n\n\n      if (this.librarySummaries.has(filePath)) {\n        return false;\n      }\n\n      if (util_1.GENERATED_FILES.test(filePath)) {\n        return false;\n      }\n\n      if (this.options.generateCodeForLibraries === false && util_1.DTS.test(filePath)) {\n        return false;\n      }\n\n      if (util_1.DTS.test(filePath)) {\n        // Check for a bundle index.\n        if (this.hasBundleIndex(filePath)) {\n          var normalFilePath = path.normalize(filePath);\n          return this.flatModuleIndexNames.has(normalFilePath) || this.flatModuleIndexRedirectNames.has(normalFilePath);\n        }\n      }\n\n      return true;\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.readFile = function (fileName) {\n      var summary = this.librarySummaries.get(fileName);\n\n      if (summary) {\n        return summary.text;\n      }\n\n      return this.context.readFile(fileName);\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.getMetadataFor = function (filePath) {\n      return metadata_reader_1.readMetadata(filePath, this.metadataReaderHost, this.metadataReaderCache);\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.loadResource = function (filePath) {\n      if (this.context.readResource) return this.context.readResource(filePath);\n\n      if (!this.originalFileExists(filePath)) {\n        throw compiler_1.syntaxError(\"Error: Resource file not found: \" + filePath);\n      }\n\n      return assert(this.context.readFile(filePath));\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.getOutputName = function (filePath) {\n      return path.relative(this.getCurrentDirectory(), filePath);\n    };\n\n    TsCompilerAotCompilerTypeCheckHostAdapter.prototype.hasBundleIndex = function (filePath) {\n      var _this = this;\n\n      var checkBundleIndex = function checkBundleIndex(directory) {\n        var result = _this.flatModuleIndexCache.get(directory);\n\n        if (result == null) {\n          if (path.basename(directory) == 'node_module') {\n            // Don't look outside the node_modules this package is installed in.\n            result = false;\n          } else {\n            // A bundle index exists if the typings .d.ts file has a metadata.json that has an\n            // importAs.\n            try {\n              var packageFile = path.join(directory, 'package.json');\n\n              if (_this.originalFileExists(packageFile)) {\n                // Once we see a package.json file, assume false until it we find the bundle index.\n                result = false;\n                var packageContent = JSON.parse(assert(_this.context.readFile(packageFile)));\n\n                if (packageContent.typings) {\n                  var typings = path.normalize(path.join(directory, packageContent.typings));\n\n                  if (util_1.DTS.test(typings)) {\n                    var metadataFile = typings.replace(util_1.DTS, '.metadata.json');\n\n                    if (_this.originalFileExists(metadataFile)) {\n                      var metadata = JSON.parse(assert(_this.context.readFile(metadataFile)));\n\n                      if (metadata.flatModuleIndexRedirect) {\n                        _this.flatModuleIndexRedirectNames.add(typings); // Note: don't set result = true,\n                        // as this would mark this folder\n                        // as having a bundleIndex too early without\n                        // filling the bundleIndexNames.\n\n                      } else if (metadata.importAs) {\n                        _this.flatModuleIndexNames.add(typings);\n\n                        result = true;\n                      }\n                    }\n                  }\n                }\n              } else {\n                var parent = path.dirname(directory);\n\n                if (parent != directory) {\n                  // Try the parent directory.\n                  result = checkBundleIndex(parent);\n                } else {\n                  result = false;\n                }\n              }\n            } catch (_a) {\n              // If we encounter any errors assume we this isn't a bundle index.\n              result = false;\n            }\n          }\n\n          _this.flatModuleIndexCache.set(directory, result);\n        }\n\n        return result;\n      };\n\n      return checkBundleIndex(path.dirname(filePath));\n    };\n\n    return TsCompilerAotCompilerTypeCheckHostAdapter;\n  }();\n\n  exports.TsCompilerAotCompilerTypeCheckHostAdapter = TsCompilerAotCompilerTypeCheckHostAdapter;\n\n  function genFileExternalReferences(genFile) {\n    return new Set(compiler_1.collectExternalReferences(genFile.stmts).map(function (er) {\n      return er.moduleName;\n    }));\n  }\n\n  function addReferencesToSourceFile(sf, genFileNames) {\n    // Note: as we modify ts.SourceFiles we need to keep the original\n    // value for `referencedFiles` around in cache the original host is caching ts.SourceFiles.\n    // Note: cloning the ts.SourceFile is expensive as the nodes in have parent pointers,\n    // i.e. we would also need to clone and adjust all nodes.\n    var originalReferencedFiles = sf.originalReferencedFiles;\n\n    if (!originalReferencedFiles) {\n      originalReferencedFiles = sf.referencedFiles;\n      sf.originalReferencedFiles = originalReferencedFiles;\n    }\n\n    var newReferencedFiles = tslib_1.__spread(originalReferencedFiles);\n\n    genFileNames.forEach(function (gf) {\n      return newReferencedFiles.push({\n        fileName: gf,\n        pos: 0,\n        end: 0\n      });\n    });\n    sf.referencedFiles = newReferencedFiles;\n  }\n\n  function getOriginalReferences(sourceFile) {\n    return sourceFile && sourceFile.originalReferencedFiles;\n  }\n\n  exports.getOriginalReferences = getOriginalReferences;\n\n  function dotRelative(from, to) {\n    var rPath = path.relative(from, to).replace(/\\\\/g, '/');\n    return rPath.startsWith('.') ? rPath : './' + rPath;\n  }\n  /**\n   * Moves the path into `genDir` folder while preserving the `node_modules` directory.\n   */\n\n\n  function getPackageName(filePath) {\n    var match = NODE_MODULES_PACKAGE_NAME.exec(filePath);\n    return match ? match[1] : null;\n  }\n\n  function stripNodeModulesPrefix(filePath) {\n    return filePath.replace(/.*node_modules\\//, '');\n  }\n\n  function getNodeModulesPrefix(filePath) {\n    var match = /.*node_modules\\//.exec(filePath);\n    return match ? match[1] : null;\n  }\n\n  function stripNgResourceSuffix(fileName) {\n    return fileName.replace(/\\.\\$ngresource\\$.*/, '');\n  }\n\n  function addNgResourceSuffix(fileName) {\n    return fileName + \".$ngresource$\";\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/compiler_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompilerHost, collectExternalReferences, EmitterVisitorContext, GeneratedFile, ParseSourceSpan, syntaxError, TypeScriptEmitter} from '@angular/compiler';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {TypeCheckHost} from '../diagnostics/translate_diagnostics';\nimport {ModuleMetadata} from '../metadata/index';\nimport {join} from '../ngtsc/file_system';\n\nimport {CompilerHost, CompilerOptions, LibrarySummary} from './api';\nimport {createMetadataReaderCache, MetadataReaderHost, readMetadata} from './metadata_reader';\nimport {DTS, GENERATED_FILES, isInRootDir, relativeToRootDirs} from './util';\n\nconst NODE_MODULES_PACKAGE_NAME = /node_modules\\/((\\w|-|\\.)+|(@(\\w|-|\\.)+\\/(\\w|-|\\.)+))/;\nconst EXT = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nconst CSS_PREPROCESSOR_EXT = /(\\.scss|\\.sass|\\.less|\\.styl)$/;\n\nlet wrapHostForTest: ((host: ts.CompilerHost) => ts.CompilerHost)|null = null;\n\nexport function setWrapHostForTest(wrapFn: ((host: ts.CompilerHost) => ts.CompilerHost)|\n                                   null): void {\n  wrapHostForTest = wrapFn;\n}\n\nexport function createCompilerHost(\n    {options, tsHost = ts.createCompilerHost(options, true)}:\n        {options: CompilerOptions, tsHost?: ts.CompilerHost}): CompilerHost {\n  if (wrapHostForTest !== null) {\n    tsHost = wrapHostForTest(tsHost);\n  }\n  return tsHost;\n}\n\nexport interface MetadataProvider {\n  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined;\n}\n\ninterface GenSourceFile {\n  externalReferences: Set<string>;\n  sourceFile: ts.SourceFile;\n  emitCtx: EmitterVisitorContext;\n}\n\nexport interface CodeGenerator {\n  generateFile(genFileName: string, baseFileName?: string): GeneratedFile;\n  findGeneratedFileNames(fileName: string): string[];\n}\n\nfunction assert<T>(condition: T|null|undefined) {\n  if (!condition) {\n    // TODO(chuckjaz): do the right thing\n  }\n  return condition!;\n}\n\n/**\n * Implements the following hosts based on an api.CompilerHost:\n * - ts.CompilerHost to be consumed by a ts.Program\n * - AotCompilerHost for @angular/compiler\n * - TypeCheckHost for mapping ts errors to ng errors (via translateDiagnostics)\n */\nexport class TsCompilerAotCompilerTypeCheckHostAdapter implements ts.CompilerHost, AotCompilerHost,\n                                                                  TypeCheckHost {\n  private metadataReaderCache = createMetadataReaderCache();\n  private fileNameToModuleNameCache = new Map<string, string>();\n  private flatModuleIndexCache = new Map<string, boolean>();\n  private flatModuleIndexNames = new Set<string>();\n  private flatModuleIndexRedirectNames = new Set<string>();\n  private rootDirs: string[];\n  private moduleResolutionCache: ts.ModuleResolutionCache;\n  private originalSourceFiles = new Map<string, ts.SourceFile|null>();\n  private originalFileExistsCache = new Map<string, boolean>();\n  private generatedSourceFiles = new Map<string, GenSourceFile>();\n  private generatedCodeFor = new Map<string, string[]>();\n  private emitter = new TypeScriptEmitter();\n  private metadataReaderHost: MetadataReaderHost;\n\n  // TODO(issue/24571): remove '!'.\n  getCancellationToken!: () => ts.CancellationToken;\n  // TODO(issue/24571): remove '!'.\n  getDefaultLibLocation!: () => string;\n  // TODO(issue/24571): remove '!'.\n  trace!: (s: string) => void;\n  // TODO(issue/24571): remove '!'.\n  getDirectories!: (path: string) => string[];\n  resolveTypeReferenceDirectives?:\n      (names: string[], containingFile: string) => ts.ResolvedTypeReferenceDirective[];\n  directoryExists?: (directoryName: string) => boolean;\n\n  constructor(\n      private rootFiles: ReadonlyArray<string>, private options: CompilerOptions,\n      private context: CompilerHost, private metadataProvider: MetadataProvider,\n      private codeGenerator: CodeGenerator,\n      private librarySummaries = new Map<string, LibrarySummary>()) {\n    this.moduleResolutionCache = ts.createModuleResolutionCache(\n        this.context.getCurrentDirectory!(), this.context.getCanonicalFileName.bind(this.context));\n    const basePath = this.options.basePath!;\n    this.rootDirs =\n        (this.options.rootDirs || [this.options.basePath!]).map(p => path.resolve(basePath, p));\n    if (context.getDirectories) {\n      this.getDirectories = path => context.getDirectories!(path);\n    }\n    if (context.directoryExists) {\n      this.directoryExists = directoryName => context.directoryExists!(directoryName);\n    }\n    if (context.getCancellationToken) {\n      this.getCancellationToken = () => context.getCancellationToken!();\n    }\n    if (context.getDefaultLibLocation) {\n      this.getDefaultLibLocation = () => context.getDefaultLibLocation!();\n    }\n    if (context.resolveTypeReferenceDirectives) {\n      // Backward compatibility with TypeScript 2.9 and older since return\n      // type has changed from (ts.ResolvedTypeReferenceDirective | undefined)[]\n      // to ts.ResolvedTypeReferenceDirective[] in Typescript 3.0\n      type ts3ResolveTypeReferenceDirectives = (names: string[], containingFile: string) =>\n          ts.ResolvedTypeReferenceDirective[];\n      this.resolveTypeReferenceDirectives = (names: string[], containingFile: string) =>\n          (context.resolveTypeReferenceDirectives as ts3ResolveTypeReferenceDirectives)!\n          (names, containingFile);\n    }\n    if (context.trace) {\n      this.trace = s => context.trace!(s);\n    }\n    if (context.fileNameToModuleName) {\n      this.fileNameToModuleName = context.fileNameToModuleName.bind(context);\n    }\n    // Note: don't copy over context.moduleNameToFileName as we first\n    // normalize undefined containingFile to a filled containingFile.\n    if (context.resourceNameToFileName) {\n      this.resourceNameToFileName = context.resourceNameToFileName.bind(context);\n    }\n    if (context.toSummaryFileName) {\n      this.toSummaryFileName = context.toSummaryFileName.bind(context);\n    }\n    if (context.fromSummaryFileName) {\n      this.fromSummaryFileName = context.fromSummaryFileName.bind(context);\n    }\n    this.metadataReaderHost = {\n      cacheMetadata: () => true,\n      getSourceFileMetadata: (filePath) => {\n        const sf = this.getOriginalSourceFile(filePath);\n        return sf ? this.metadataProvider.getMetadata(sf) : undefined;\n      },\n      fileExists: (filePath) => this.originalFileExists(filePath),\n      readFile: (filePath) => assert(this.context.readFile(filePath)),\n    };\n  }\n\n  private resolveModuleName(moduleName: string, containingFile: string): ts.ResolvedModule\n      |undefined {\n    const rm = ts.resolveModuleName(\n                     moduleName, containingFile.replace(/\\\\/g, '/'), this.options, this,\n                     this.moduleResolutionCache)\n                   .resolvedModule;\n    if (rm && this.isSourceFile(rm.resolvedFileName) && DTS.test(rm.resolvedFileName)) {\n      // Case: generateCodeForLibraries = true and moduleName is\n      // a .d.ts file in a node_modules folder.\n      // Need to set isExternalLibraryImport to false so that generated files for that file\n      // are emitted.\n      rm.isExternalLibraryImport = false;\n    }\n    return rm;\n  }\n\n  // Note: We implement this method so that TypeScript and Angular share the same\n  // ts.ModuleResolutionCache\n  // and that we can tell ts.Program about our different opinion about\n  // ResolvedModule.isExternalLibraryImport\n  // (see our isSourceFile method).\n  resolveModuleNames(moduleNames: string[], containingFile: string): ts.ResolvedModule[] {\n    // TODO(tbosch): this seems to be a typing error in TypeScript,\n    // as it contains assertions that the result contains the same number of entries\n    // as the given module names.\n    return <ts.ResolvedModule[]>moduleNames.map(\n        moduleName => this.resolveModuleName(moduleName, containingFile));\n  }\n\n  moduleNameToFileName(m: string, containingFile?: string): string|null {\n    if (!containingFile) {\n      if (m.indexOf('.') === 0) {\n        throw new Error('Resolution of relative paths requires a containing file.');\n      }\n      // Any containing file gives the same result for absolute imports\n      containingFile = this.rootFiles[0];\n    }\n    if (this.context.moduleNameToFileName) {\n      return this.context.moduleNameToFileName(m, containingFile);\n    }\n    const resolved = this.resolveModuleName(m, containingFile);\n    return resolved ? resolved.resolvedFileName : null;\n  }\n\n  /**\n   * We want a moduleId that will appear in import statements in the generated code\n   * which will be written to `containingFile`.\n   *\n   * Note that we also generate files for files in node_modules, as libraries\n   * only ship .metadata.json files but not the generated code.\n   *\n   * Logic:\n   * 1. if the importedFile and the containingFile are from the project sources\n   *    or from the same node_modules package, use a relative path\n   * 2. if the importedFile is in a node_modules package,\n   *    use a path that starts with the package name.\n   * 3. Error if the containingFile is in the node_modules package\n   *    and the importedFile is in the project soures,\n   *    as that is a violation of the principle that node_modules packages cannot\n   *    import project sources.\n   */\n  fileNameToModuleName(importedFile: string, containingFile: string): string {\n    const cacheKey = `${importedFile}:${containingFile}`;\n    let moduleName = this.fileNameToModuleNameCache.get(cacheKey);\n    if (moduleName != null) {\n      return moduleName;\n    }\n\n    const originalImportedFile = importedFile;\n    if (this.options.traceResolution) {\n      console.error(\n          'fileNameToModuleName from containingFile', containingFile, 'to importedFile',\n          importedFile);\n    }\n\n    // drop extension\n    importedFile = importedFile.replace(EXT, '');\n    const importedFilePackageName = getPackageName(importedFile);\n    const containingFilePackageName = getPackageName(containingFile);\n\n    if (importedFilePackageName === containingFilePackageName ||\n        GENERATED_FILES.test(originalImportedFile)) {\n      const rootedContainingFile = relativeToRootDirs(containingFile, this.rootDirs);\n      const rootedImportedFile = relativeToRootDirs(importedFile, this.rootDirs);\n\n      if (rootedContainingFile !== containingFile && rootedImportedFile !== importedFile) {\n        // if both files are contained in the `rootDirs`, then strip the rootDirs\n        containingFile = rootedContainingFile;\n        importedFile = rootedImportedFile;\n      }\n      moduleName = dotRelative(path.dirname(containingFile), importedFile);\n    } else if (importedFilePackageName) {\n      moduleName = stripNodeModulesPrefix(importedFile);\n      if (originalImportedFile.endsWith('.d.ts')) {\n        // the moduleName for these typings could be shortented to the npm package name\n        // if the npm package typings matches the importedFile\n        try {\n          const modulePath = importedFile.substring(0, importedFile.length - moduleName.length) +\n              importedFilePackageName;\n          const packageJson = require(modulePath + '/package.json');\n          const packageTypings = join(modulePath, packageJson.typings);\n          if (packageTypings === originalImportedFile) {\n            moduleName = importedFilePackageName;\n          }\n        } catch {\n          // the above require() will throw if there is no package.json file\n          // and this is safe to ignore and correct to keep the longer\n          // moduleName in this case\n        }\n      }\n    } else {\n      throw new Error(`Trying to import a source file from a node_modules package: import ${\n          originalImportedFile} from ${containingFile}`);\n    }\n\n    this.fileNameToModuleNameCache.set(cacheKey, moduleName);\n    return moduleName;\n  }\n\n  resourceNameToFileName(resourceName: string, containingFile: string): string|null {\n    // Note: we convert package paths into relative paths to be compatible with the the\n    // previous implementation of UrlResolver.\n    const firstChar = resourceName[0];\n    if (firstChar === '/') {\n      resourceName = resourceName.slice(1);\n    } else if (firstChar !== '.') {\n      resourceName = `./${resourceName}`;\n    }\n    let filePathWithNgResource =\n        this.moduleNameToFileName(addNgResourceSuffix(resourceName), containingFile);\n    // If the user specified styleUrl pointing to *.scss, but the Sass compiler was run before\n    // Angular, then the resource may have been generated as *.css. Simply try the resolution again.\n    if (!filePathWithNgResource && CSS_PREPROCESSOR_EXT.test(resourceName)) {\n      const fallbackResourceName = resourceName.replace(CSS_PREPROCESSOR_EXT, '.css');\n      filePathWithNgResource =\n          this.moduleNameToFileName(addNgResourceSuffix(fallbackResourceName), containingFile);\n    }\n    const result = filePathWithNgResource ? stripNgResourceSuffix(filePathWithNgResource) : null;\n    // Used under Bazel to report more specific error with remediation advice\n    if (!result && (this.context as any).reportMissingResource) {\n      (this.context as any).reportMissingResource(resourceName);\n    }\n    return result;\n  }\n\n  toSummaryFileName(fileName: string, referringSrcFileName: string): string {\n    return this.fileNameToModuleName(fileName, referringSrcFileName);\n  }\n\n  fromSummaryFileName(fileName: string, referringLibFileName: string): string {\n    const resolved = this.moduleNameToFileName(fileName, referringLibFileName);\n    if (!resolved) {\n      throw new Error(`Could not resolve ${fileName} from ${referringLibFileName}`);\n    }\n    return resolved;\n  }\n\n  parseSourceSpanOf(fileName: string, line: number, character: number): ParseSourceSpan|null {\n    const data = this.generatedSourceFiles.get(fileName);\n    if (data && data.emitCtx) {\n      return data.emitCtx.spanOf(line, character);\n    }\n    return null;\n  }\n\n  private getOriginalSourceFile(\n      filePath: string, languageVersion?: ts.ScriptTarget,\n      onError?: ((message: string) => void)|undefined): ts.SourceFile|null {\n    // Note: we need the explicit check via `has` as we also cache results\n    // that were null / undefined.\n    if (this.originalSourceFiles.has(filePath)) {\n      return this.originalSourceFiles.get(filePath)!;\n    }\n    if (!languageVersion) {\n      languageVersion = this.options.target || ts.ScriptTarget.Latest;\n    }\n    // Note: This can also return undefined,\n    // as the TS typings are not correct!\n    const sf = this.context.getSourceFile(filePath, languageVersion, onError) || null;\n    this.originalSourceFiles.set(filePath, sf);\n    return sf;\n  }\n\n  updateGeneratedFile(genFile: GeneratedFile): ts.SourceFile {\n    if (!genFile.stmts) {\n      throw new Error(\n          `Invalid Argument: Expected a GenerateFile with statements. ${genFile.genFileUrl}`);\n    }\n    const oldGenFile = this.generatedSourceFiles.get(genFile.genFileUrl);\n    if (!oldGenFile) {\n      throw new Error(`Illegal State: previous GeneratedFile not found for ${genFile.genFileUrl}.`);\n    }\n    const newRefs = genFileExternalReferences(genFile);\n    const oldRefs = oldGenFile.externalReferences;\n    let refsAreEqual = oldRefs.size === newRefs.size;\n    if (refsAreEqual) {\n      newRefs.forEach(r => refsAreEqual = refsAreEqual && oldRefs.has(r));\n    }\n    if (!refsAreEqual) {\n      throw new Error(`Illegal State: external references changed in ${genFile.genFileUrl}.\\nOld: ${\n          Array.from(oldRefs)}.\\nNew: ${Array.from(newRefs)}`);\n    }\n    return this.addGeneratedFile(genFile, newRefs);\n  }\n\n  private addGeneratedFile(genFile: GeneratedFile, externalReferences: Set<string>): ts.SourceFile {\n    if (!genFile.stmts) {\n      throw new Error(\n          `Invalid Argument: Expected a GenerateFile with statements. ${genFile.genFileUrl}`);\n    }\n    const {sourceText, context} = this.emitter.emitStatementsAndContext(\n        genFile.genFileUrl, genFile.stmts, /* preamble */ '',\n        /* emitSourceMaps */ false);\n    const sf = ts.createSourceFile(\n        genFile.genFileUrl, sourceText, this.options.target || ts.ScriptTarget.Latest);\n    if (this.options.module === ts.ModuleKind.AMD || this.options.module === ts.ModuleKind.UMD) {\n      if (this.context.amdModuleName) {\n        const moduleName = this.context.amdModuleName(sf);\n        if (moduleName) sf.moduleName = moduleName;\n      } else if (/node_modules/.test(genFile.genFileUrl)) {\n        // If we are generating an ngModule file under node_modules, we know the right module name\n        // We don't need the host to supply a function in this case.\n        sf.moduleName = stripNodeModulesPrefix(genFile.genFileUrl.replace(EXT, ''));\n      }\n    }\n    this.generatedSourceFiles.set(genFile.genFileUrl, {\n      sourceFile: sf,\n      emitCtx: context,\n      externalReferences,\n    });\n    return sf;\n  }\n\n  shouldGenerateFile(fileName: string): {generate: boolean, baseFileName?: string} {\n    // TODO(tbosch): allow generating files that are not in the rootDir\n    // See https://github.com/angular/angular/issues/19337\n    if (!isInRootDir(fileName, this.options)) {\n      return {generate: false};\n    }\n    const genMatch = GENERATED_FILES.exec(fileName);\n    if (!genMatch) {\n      return {generate: false};\n    }\n    const [, base, genSuffix, suffix] = genMatch;\n    if (suffix !== 'ts' && suffix !== 'tsx') {\n      return {generate: false};\n    }\n    let baseFileName: string|undefined;\n    if (genSuffix.indexOf('ngstyle') >= 0) {\n      // Note: ngstyle files have names like `afile.css.ngstyle.ts`\n      if (!this.originalFileExists(base)) {\n        return {generate: false};\n      }\n    } else {\n      // Note: on-the-fly generated files always have a `.ts` suffix,\n      // but the file from which we generated it can be a `.ts`/ `.tsx`/ `.d.ts`\n      // (see options.generateCodeForLibraries).\n      baseFileName = [`${base}.ts`, `${base}.tsx`, `${base}.d.ts`].find(\n          baseFileName => this.isSourceFile(baseFileName) && this.originalFileExists(baseFileName));\n      if (!baseFileName) {\n        return {generate: false};\n      }\n    }\n    return {generate: true, baseFileName};\n  }\n\n  shouldGenerateFilesFor(fileName: string) {\n    // TODO(tbosch): allow generating files that are not in the rootDir\n    // See https://github.com/angular/angular/issues/19337\n    return !GENERATED_FILES.test(fileName) && this.isSourceFile(fileName) &&\n        isInRootDir(fileName, this.options);\n  }\n\n  getSourceFile(\n      fileName: string, languageVersion: ts.ScriptTarget,\n      onError?: ((message: string) => void)|undefined): ts.SourceFile {\n    // Note: Don't exit early in this method to make sure\n    // we always have up to date references on the file!\n    let genFileNames: string[] = [];\n    let sf = this.getGeneratedFile(fileName);\n    if (!sf) {\n      const summary = this.librarySummaries.get(fileName);\n      if (summary) {\n        if (!summary.sourceFile) {\n          summary.sourceFile = ts.createSourceFile(\n              fileName, summary.text, this.options.target || ts.ScriptTarget.Latest);\n        }\n        sf = summary.sourceFile;\n        // TypeScript doesn't allow returning redirect source files. To avoid unforseen errors we\n        // return the original source file instead of the redirect target.\n        const redirectInfo = (sf as any).redirectInfo;\n        if (redirectInfo !== undefined) {\n          sf = redirectInfo.unredirected;\n        }\n        genFileNames = [];\n      }\n    }\n    if (!sf) {\n      sf = this.getOriginalSourceFile(fileName);\n      const cachedGenFiles = this.generatedCodeFor.get(fileName);\n      if (cachedGenFiles) {\n        genFileNames = cachedGenFiles;\n      } else {\n        if (!this.options.noResolve && this.shouldGenerateFilesFor(fileName)) {\n          genFileNames = this.codeGenerator.findGeneratedFileNames(fileName).filter(\n              fileName => this.shouldGenerateFile(fileName).generate);\n        }\n        this.generatedCodeFor.set(fileName, genFileNames);\n      }\n    }\n    if (sf) {\n      addReferencesToSourceFile(sf, genFileNames);\n    }\n    // TODO(tbosch): TypeScript's typings for getSourceFile are incorrect,\n    // as it can very well return undefined.\n    return sf!;\n  }\n\n  private getGeneratedFile(fileName: string): ts.SourceFile|null {\n    const genSrcFile = this.generatedSourceFiles.get(fileName);\n    if (genSrcFile) {\n      return genSrcFile.sourceFile;\n    }\n    const {generate, baseFileName} = this.shouldGenerateFile(fileName);\n    if (generate) {\n      const genFile = this.codeGenerator.generateFile(fileName, baseFileName);\n      return this.addGeneratedFile(genFile, genFileExternalReferences(genFile));\n    }\n    return null;\n  }\n\n  private originalFileExists(fileName: string): boolean {\n    let fileExists = this.originalFileExistsCache.get(fileName);\n    if (fileExists == null) {\n      fileExists = this.context.fileExists(fileName);\n      this.originalFileExistsCache.set(fileName, fileExists);\n    }\n    return fileExists;\n  }\n\n  fileExists(fileName: string): boolean {\n    fileName = stripNgResourceSuffix(fileName);\n    if (this.librarySummaries.has(fileName) || this.generatedSourceFiles.has(fileName)) {\n      return true;\n    }\n    if (this.shouldGenerateFile(fileName).generate) {\n      return true;\n    }\n    return this.originalFileExists(fileName);\n  }\n\n  loadSummary(filePath: string): string|null {\n    const summary = this.librarySummaries.get(filePath);\n    if (summary) {\n      return summary.text;\n    }\n    if (this.originalFileExists(filePath)) {\n      return assert(this.context.readFile(filePath));\n    }\n    return null;\n  }\n\n  isSourceFile(filePath: string): boolean {\n    // Don't generate any files nor typecheck them\n    // if skipTemplateCodegen is set and fullTemplateTypeCheck is not yet set,\n    // for backwards compatibility.\n    if (this.options.skipTemplateCodegen && !this.options.fullTemplateTypeCheck) {\n      return false;\n    }\n    // If we have a summary from a previous compilation,\n    // treat the file never as a source file.\n    if (this.librarySummaries.has(filePath)) {\n      return false;\n    }\n    if (GENERATED_FILES.test(filePath)) {\n      return false;\n    }\n    if (this.options.generateCodeForLibraries === false && DTS.test(filePath)) {\n      return false;\n    }\n    if (DTS.test(filePath)) {\n      // Check for a bundle index.\n      if (this.hasBundleIndex(filePath)) {\n        const normalFilePath = path.normalize(filePath);\n        return this.flatModuleIndexNames.has(normalFilePath) ||\n            this.flatModuleIndexRedirectNames.has(normalFilePath);\n      }\n    }\n    return true;\n  }\n\n  readFile(fileName: string) {\n    const summary = this.librarySummaries.get(fileName);\n    if (summary) {\n      return summary.text;\n    }\n    return this.context.readFile(fileName);\n  }\n\n  getMetadataFor(filePath: string): ModuleMetadata[]|undefined {\n    return readMetadata(filePath, this.metadataReaderHost, this.metadataReaderCache);\n  }\n\n  loadResource(filePath: string): Promise<string>|string {\n    if (this.context.readResource) return this.context.readResource(filePath);\n    if (!this.originalFileExists(filePath)) {\n      throw syntaxError(`Error: Resource file not found: ${filePath}`);\n    }\n    return assert(this.context.readFile(filePath));\n  }\n\n  getOutputName(filePath: string): string {\n    return path.relative(this.getCurrentDirectory(), filePath);\n  }\n\n  private hasBundleIndex(filePath: string): boolean {\n    const checkBundleIndex = (directory: string): boolean => {\n      let result = this.flatModuleIndexCache.get(directory);\n      if (result == null) {\n        if (path.basename(directory) == 'node_module') {\n          // Don't look outside the node_modules this package is installed in.\n          result = false;\n        } else {\n          // A bundle index exists if the typings .d.ts file has a metadata.json that has an\n          // importAs.\n          try {\n            const packageFile = path.join(directory, 'package.json');\n            if (this.originalFileExists(packageFile)) {\n              // Once we see a package.json file, assume false until it we find the bundle index.\n              result = false;\n              const packageContent =\n                  JSON.parse(assert(this.context.readFile(packageFile))) as {typings: string};\n              if (packageContent.typings) {\n                const typings = path.normalize(path.join(directory, packageContent.typings));\n                if (DTS.test(typings)) {\n                  const metadataFile = typings.replace(DTS, '.metadata.json');\n                  if (this.originalFileExists(metadataFile)) {\n                    const metadata = JSON.parse(assert(this.context.readFile(metadataFile))) as\n                        {flatModuleIndexRedirect: string, importAs: string};\n                    if (metadata.flatModuleIndexRedirect) {\n                      this.flatModuleIndexRedirectNames.add(typings);\n                      // Note: don't set result = true,\n                      // as this would mark this folder\n                      // as having a bundleIndex too early without\n                      // filling the bundleIndexNames.\n                    } else if (metadata.importAs) {\n                      this.flatModuleIndexNames.add(typings);\n                      result = true;\n                    }\n                  }\n                }\n              }\n            } else {\n              const parent = path.dirname(directory);\n              if (parent != directory) {\n                // Try the parent directory.\n                result = checkBundleIndex(parent);\n              } else {\n                result = false;\n              }\n            }\n          } catch {\n            // If we encounter any errors assume we this isn't a bundle index.\n            result = false;\n          }\n        }\n        this.flatModuleIndexCache.set(directory, result);\n      }\n      return result;\n    };\n\n    return checkBundleIndex(path.dirname(filePath));\n  }\n\n  getDefaultLibFileName = (options: ts.CompilerOptions) =>\n      this.context.getDefaultLibFileName(options)\n  getCurrentDirectory = () => this.context.getCurrentDirectory();\n  getCanonicalFileName = (fileName: string) => this.context.getCanonicalFileName(fileName);\n  useCaseSensitiveFileNames = () => this.context.useCaseSensitiveFileNames();\n  getNewLine = () => this.context.getNewLine();\n  // Make sure we do not `host.realpath()` from TS as we do not want to resolve symlinks.\n  // https://github.com/Microsoft/TypeScript/issues/9552\n  realpath = (p: string) => p;\n  writeFile = this.context.writeFile.bind(this.context);\n}\n\nfunction genFileExternalReferences(genFile: GeneratedFile): Set<string> {\n  return new Set(collectExternalReferences(genFile.stmts!).map(er => er.moduleName!));\n}\n\nfunction addReferencesToSourceFile(sf: ts.SourceFile, genFileNames: string[]) {\n  // Note: as we modify ts.SourceFiles we need to keep the original\n  // value for `referencedFiles` around in cache the original host is caching ts.SourceFiles.\n  // Note: cloning the ts.SourceFile is expensive as the nodes in have parent pointers,\n  // i.e. we would also need to clone and adjust all nodes.\n  let originalReferencedFiles: ReadonlyArray<ts.FileReference> =\n      (sf as any).originalReferencedFiles;\n  if (!originalReferencedFiles) {\n    originalReferencedFiles = sf.referencedFiles;\n    (sf as any).originalReferencedFiles = originalReferencedFiles;\n  }\n  const newReferencedFiles = [...originalReferencedFiles];\n  genFileNames.forEach(gf => newReferencedFiles.push({fileName: gf, pos: 0, end: 0}));\n  sf.referencedFiles = newReferencedFiles;\n}\n\nexport function getOriginalReferences(sourceFile: ts.SourceFile): ts.FileReference[]|undefined {\n  return sourceFile && (sourceFile as any).originalReferencedFiles;\n}\n\nfunction dotRelative(from: string, to: string): string {\n  const rPath: string = path.relative(from, to).replace(/\\\\/g, '/');\n  return rPath.startsWith('.') ? rPath : './' + rPath;\n}\n\n/**\n * Moves the path into `genDir` folder while preserving the `node_modules` directory.\n */\nfunction getPackageName(filePath: string): string|null {\n  const match = NODE_MODULES_PACKAGE_NAME.exec(filePath);\n  return match ? match[1] : null;\n}\n\nfunction stripNodeModulesPrefix(filePath: string): string {\n  return filePath.replace(/.*node_modules\\//, '');\n}\n\nfunction getNodeModulesPrefix(filePath: string): string|null {\n  const match = /.*node_modules\\//.exec(filePath);\n  return match ? match[1] : null;\n}\n\nfunction stripNgResourceSuffix(fileName: string): string {\n  return fileName.replace(/\\.\\$ngresource\\$.*/, '');\n}\n\nfunction addNgResourceSuffix(fileName: string): string {\n  return `${fileName}.$ngresource$`;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}