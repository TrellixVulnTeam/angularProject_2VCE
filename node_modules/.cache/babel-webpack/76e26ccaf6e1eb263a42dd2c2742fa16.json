{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/shims/src/expando\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.retagTsFile = exports.untagTsFile = exports.retagAllTsFiles = exports.untagAllTsFiles = exports.copyFileShimData = exports.isShim = exports.isFileShimSourceFile = exports.sfExtensionData = exports.isExtended = exports.NgExtension = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * A `Symbol` which is used to patch extension data onto `ts.SourceFile`s.\n   */\n\n\n  exports.NgExtension = Symbol('NgExtension');\n  /**\n   * Narrows a `ts.SourceFile` if it has an `NgExtension` property.\n   */\n\n  function isExtended(sf) {\n    return sf[exports.NgExtension] !== undefined;\n  }\n\n  exports.isExtended = isExtended;\n  /**\n   * Returns the `NgExtensionData` for a given `ts.SourceFile`, adding it if none exists.\n   */\n\n  function sfExtensionData(sf) {\n    var extSf = sf;\n\n    if (extSf[exports.NgExtension] !== undefined) {\n      // The file already has extension data, so return it directly.\n      return extSf[exports.NgExtension];\n    } // The file has no existing extension data, so add it and return it.\n\n\n    var extension = {\n      isTopLevelShim: false,\n      fileShim: null,\n      originalReferencedFiles: null,\n      taggedReferenceFiles: null\n    };\n    extSf[exports.NgExtension] = extension;\n    return extension;\n  }\n\n  exports.sfExtensionData = sfExtensionData;\n  /**\n   * Check whether `sf` is a per-file shim `ts.SourceFile`.\n   */\n\n  function isFileShimSourceFile(sf) {\n    return isExtended(sf) && sf[exports.NgExtension].fileShim !== null;\n  }\n\n  exports.isFileShimSourceFile = isFileShimSourceFile;\n  /**\n   * Check whether `sf` is a shim `ts.SourceFile` (either a per-file shim or a top-level shim).\n   */\n\n  function isShim(sf) {\n    return isExtended(sf) && (sf[exports.NgExtension].fileShim !== null || sf[exports.NgExtension].isTopLevelShim);\n  }\n\n  exports.isShim = isShim;\n  /**\n   * Copy any shim data from one `ts.SourceFile` to another.\n   */\n\n  function copyFileShimData(from, to) {\n    if (!isFileShimSourceFile(from)) {\n      return;\n    }\n\n    sfExtensionData(to).fileShim = sfExtensionData(from).fileShim;\n  }\n\n  exports.copyFileShimData = copyFileShimData;\n  /**\n   * For those `ts.SourceFile`s in the `program` which have previously been tagged by a\n   * `ShimReferenceTagger`, restore the original `referencedFiles` array that does not have shim tags.\n   */\n\n  function untagAllTsFiles(program) {\n    var e_1, _a;\n\n    try {\n      for (var _b = tslib_1.__values(program.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var sf = _c.value;\n        untagTsFile(sf);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  exports.untagAllTsFiles = untagAllTsFiles;\n  /**\n   * For those `ts.SourceFile`s in the `program` which have previously been tagged by a\n   * `ShimReferenceTagger`, re-apply the effects of tagging by updating the `referencedFiles` array to\n   * the tagged version produced previously.\n   */\n\n  function retagAllTsFiles(program) {\n    var e_2, _a;\n\n    try {\n      for (var _b = tslib_1.__values(program.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var sf = _c.value;\n        retagTsFile(sf);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  }\n\n  exports.retagAllTsFiles = retagAllTsFiles;\n  /**\n   * Restore the original `referencedFiles` for the given `ts.SourceFile`.\n   */\n\n  function untagTsFile(sf) {\n    if (sf.isDeclarationFile || !isExtended(sf)) {\n      return;\n    }\n\n    var ext = sfExtensionData(sf);\n\n    if (ext.originalReferencedFiles !== null) {\n      sf.referencedFiles = ext.originalReferencedFiles;\n    }\n  }\n\n  exports.untagTsFile = untagTsFile;\n  /**\n   * Apply the previously tagged `referencedFiles` to the given `ts.SourceFile`, if it was previously\n   * tagged.\n   */\n\n  function retagTsFile(sf) {\n    if (sf.isDeclarationFile || !isExtended(sf)) {\n      return;\n    }\n\n    var ext = sfExtensionData(sf);\n\n    if (ext.taggedReferenceFiles !== null) {\n      sf.referencedFiles = ext.taggedReferenceFiles;\n    }\n  }\n\n  exports.retagTsFile = retagTsFile;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/expando.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\n\n/**\n * A `Symbol` which is used to patch extension data onto `ts.SourceFile`s.\n */\nexport const NgExtension = Symbol('NgExtension');\n\n/**\n * Contents of the `NgExtension` property of a `ts.SourceFile`.\n */\nexport interface NgExtensionData {\n  isTopLevelShim: boolean;\n  fileShim: NgFileShimData|null;\n\n  /**\n   * The contents of the `referencedFiles` array, before modification by a `ShimReferenceTagger`.\n   */\n  originalReferencedFiles: ReadonlyArray<ts.FileReference>|null;\n\n  /**\n   * The contents of the `referencedFiles` array, after modification by a `ShimReferenceTagger`.\n   */\n  taggedReferenceFiles: ReadonlyArray<ts.FileReference>|null;\n}\n\n/**\n * A `ts.SourceFile` which may or may not have `NgExtension` data.\n */\ninterface MaybeNgExtendedSourceFile extends ts.SourceFile {\n  [NgExtension]?: NgExtensionData;\n}\n\n/**\n * A `ts.SourceFile` which has `NgExtension` data.\n */\nexport interface NgExtendedSourceFile extends ts.SourceFile {\n  /**\n   * Overrides the type of `referencedFiles` to be writeable.\n   */\n  referencedFiles: ts.FileReference[];\n\n  [NgExtension]: NgExtensionData;\n}\n\n/**\n * Narrows a `ts.SourceFile` if it has an `NgExtension` property.\n */\nexport function isExtended(sf: ts.SourceFile): sf is NgExtendedSourceFile {\n  return (sf as MaybeNgExtendedSourceFile)[NgExtension] !== undefined;\n}\n\n/**\n * Returns the `NgExtensionData` for a given `ts.SourceFile`, adding it if none exists.\n */\nexport function sfExtensionData(sf: ts.SourceFile): NgExtensionData {\n  const extSf = sf as MaybeNgExtendedSourceFile;\n  if (extSf[NgExtension] !== undefined) {\n    // The file already has extension data, so return it directly.\n    return extSf[NgExtension]!;\n  }\n\n  // The file has no existing extension data, so add it and return it.\n  const extension: NgExtensionData = {\n    isTopLevelShim: false,\n    fileShim: null,\n    originalReferencedFiles: null,\n    taggedReferenceFiles: null,\n  };\n  extSf[NgExtension] = extension;\n  return extension;\n}\n\n/**\n * Data associated with a per-shim instance `ts.SourceFile`.\n */\nexport interface NgFileShimData {\n  generatedFrom: AbsoluteFsPath;\n  extension: string;\n}\n\n/**\n * An `NgExtendedSourceFile` that is a per-file shim and has `NgFileShimData`.\n */\nexport interface NgFileShimSourceFile extends NgExtendedSourceFile {\n  [NgExtension]: NgExtensionData&{\n    fileShim: NgFileShimData,\n  };\n}\n\n/**\n * Check whether `sf` is a per-file shim `ts.SourceFile`.\n */\nexport function isFileShimSourceFile(sf: ts.SourceFile): sf is NgFileShimSourceFile {\n  return isExtended(sf) && sf[NgExtension].fileShim !== null;\n}\n\n/**\n * Check whether `sf` is a shim `ts.SourceFile` (either a per-file shim or a top-level shim).\n */\nexport function isShim(sf: ts.SourceFile): boolean {\n  return isExtended(sf) && (sf[NgExtension].fileShim !== null || sf[NgExtension].isTopLevelShim);\n}\n\n/**\n * Copy any shim data from one `ts.SourceFile` to another.\n */\nexport function copyFileShimData(from: ts.SourceFile, to: ts.SourceFile): void {\n  if (!isFileShimSourceFile(from)) {\n    return;\n  }\n  sfExtensionData(to).fileShim = sfExtensionData(from).fileShim;\n}\n\n/**\n * For those `ts.SourceFile`s in the `program` which have previously been tagged by a\n * `ShimReferenceTagger`, restore the original `referencedFiles` array that does not have shim tags.\n */\nexport function untagAllTsFiles(program: ts.Program): void {\n  for (const sf of program.getSourceFiles()) {\n    untagTsFile(sf);\n  }\n}\n\n/**\n * For those `ts.SourceFile`s in the `program` which have previously been tagged by a\n * `ShimReferenceTagger`, re-apply the effects of tagging by updating the `referencedFiles` array to\n * the tagged version produced previously.\n */\nexport function retagAllTsFiles(program: ts.Program): void {\n  for (const sf of program.getSourceFiles()) {\n    retagTsFile(sf);\n  }\n}\n\n/**\n * Restore the original `referencedFiles` for the given `ts.SourceFile`.\n */\nexport function untagTsFile(sf: ts.SourceFile): void {\n  if (sf.isDeclarationFile || !isExtended(sf)) {\n    return;\n  }\n\n  const ext = sfExtensionData(sf);\n  if (ext.originalReferencedFiles !== null) {\n    sf.referencedFiles = ext.originalReferencedFiles as Array<ts.FileReference>;\n  }\n}\n\n/**\n * Apply the previously tagged `referencedFiles` to the given `ts.SourceFile`, if it was previously\n * tagged.\n */\nexport function retagTsFile(sf: ts.SourceFile): void {\n  if (sf.isDeclarationFile || !isExtended(sf)) {\n    return;\n  }\n\n  const ext = sfExtensionData(sf);\n  if (ext.taggedReferenceFiles !== null) {\n    sf.referencedFiles = ext.taggedReferenceFiles as Array<ts.FileReference>;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}