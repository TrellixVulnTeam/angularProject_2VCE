{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/aot/lazy_routes\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.parseLazyRoute = exports.listLazyRoutes = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  function listLazyRoutes(moduleMeta, reflector) {\n    var e_1, _a, e_2, _b;\n\n    var allLazyRoutes = [];\n\n    try {\n      for (var _c = tslib_1.__values(moduleMeta.transitiveModule.providers), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var _e = _d.value,\n            provider = _e.provider,\n            module = _e.module;\n\n        if (compile_metadata_1.tokenReference(provider.token) === reflector.ROUTES) {\n          var loadChildren = _collectLoadChildren(provider.useValue);\n\n          try {\n            for (var loadChildren_1 = (e_2 = void 0, tslib_1.__values(loadChildren)), loadChildren_1_1 = loadChildren_1.next(); !loadChildren_1_1.done; loadChildren_1_1 = loadChildren_1.next()) {\n              var route = loadChildren_1_1.value;\n              allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (loadChildren_1_1 && !loadChildren_1_1.done && (_b = loadChildren_1.return)) _b.call(loadChildren_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return allLazyRoutes;\n  }\n\n  exports.listLazyRoutes = listLazyRoutes;\n\n  function _collectLoadChildren(routes, target) {\n    var e_3, _a;\n\n    if (target === void 0) {\n      target = [];\n    }\n\n    if (typeof routes === 'string') {\n      target.push(routes);\n    } else if (Array.isArray(routes)) {\n      try {\n        for (var routes_1 = tslib_1.__values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {\n          var route = routes_1_1.value;\n\n          _collectLoadChildren(route, target);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    } else if (routes.loadChildren) {\n      _collectLoadChildren(routes.loadChildren, target);\n    } else if (routes.children) {\n      _collectLoadChildren(routes.children, target);\n    }\n\n    return target;\n  }\n\n  function parseLazyRoute(route, reflector, module) {\n    var _a = tslib_1.__read(route.split('#'), 2),\n        routePath = _a[0],\n        routeName = _a[1];\n\n    var referencedModule = reflector.resolveExternalReference({\n      moduleName: routePath,\n      name: routeName\n    }, module ? module.filePath : undefined);\n    return {\n      route: route,\n      module: module || referencedModule,\n      referencedModule: referencedModule\n    };\n  }\n\n  exports.parseLazyRoute = parseLazyRoute;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/lazy_routes.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileNgModuleMetadata, tokenReference} from '../compile_metadata';\nimport {Route} from '../core';\n\nimport {StaticReflector} from './static_reflector';\nimport {StaticSymbol} from './static_symbol';\n\nexport interface LazyRoute {\n  module: StaticSymbol;\n  route: string;\n  referencedModule: StaticSymbol;\n}\n\nexport function listLazyRoutes(\n    moduleMeta: CompileNgModuleMetadata, reflector: StaticReflector): LazyRoute[] {\n  const allLazyRoutes: LazyRoute[] = [];\n  for (const {provider, module} of moduleMeta.transitiveModule.providers) {\n    if (tokenReference(provider.token) === reflector.ROUTES) {\n      const loadChildren = _collectLoadChildren(provider.useValue);\n      for (const route of loadChildren) {\n        allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n      }\n    }\n  }\n  return allLazyRoutes;\n}\n\nfunction _collectLoadChildren(routes: string|Route|Route[], target: string[] = []): string[] {\n  if (typeof routes === 'string') {\n    target.push(routes);\n  } else if (Array.isArray(routes)) {\n    for (const route of routes) {\n      _collectLoadChildren(route, target);\n    }\n  } else if (routes.loadChildren) {\n    _collectLoadChildren(routes.loadChildren, target);\n  } else if (routes.children) {\n    _collectLoadChildren(routes.children, target);\n  }\n  return target;\n}\n\nexport function parseLazyRoute(\n    route: string, reflector: StaticReflector, module?: StaticSymbol): LazyRoute {\n  const [routePath, routeName] = route.split('#');\n  const referencedModule = reflector.resolveExternalReference(\n      {\n        moduleName: routePath,\n        name: routeName,\n      },\n      module ? module.filePath : undefined);\n  return {route: route, module: module || referencedModule, referencedModule};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}