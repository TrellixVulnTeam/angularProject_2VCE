{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndentLogger = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar logger_1 = require(\"./logger\");\n/**\n * Keep an map of indentation => array of indentations based on the level.\n * This is to optimize calculating the prefix based on the indentation itself. Since most logs\n * come from similar levels, and with similar indentation strings, this will be shared by all\n * loggers. Also, string concatenation is expensive so performing concats for every log entries\n * is expensive; this alleviates it.\n */\n\n\nvar indentationMap = {};\n\nvar IndentLogger = /*#__PURE__*/function (_logger_1$Logger) {\n  _inherits(IndentLogger, _logger_1$Logger);\n\n  var _super = _createSuper(IndentLogger);\n\n  function IndentLogger(name) {\n    var _this;\n\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var indentation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '  ';\n\n    _classCallCheck(this, IndentLogger);\n\n    _this = _super.call(this, name, parent);\n    indentationMap[indentation] = indentationMap[indentation] || [''];\n    var indentMap = indentationMap[indentation];\n    _this._observable = _this._observable.pipe(operators_1.map(function (entry) {\n      var l = entry.path.filter(function (x) {\n        return !!x;\n      }).length;\n\n      if (l >= indentMap.length) {\n        var current = indentMap[indentMap.length - 1];\n\n        while (l >= indentMap.length) {\n          current += indentation;\n          indentMap.push(current);\n        }\n      }\n\n      entry.message = indentMap[l] + entry.message.split(/\\n/).join('\\n' + indentMap[l]);\n      return entry;\n    }));\n    return _this;\n  }\n\n  return IndentLogger;\n}(logger_1.Logger);\n\nexports.IndentLogger = IndentLogger;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/logger/indent.js"],"names":["Object","defineProperty","exports","value","IndentLogger","operators_1","require","logger_1","indentationMap","name","parent","indentation","indentMap","_observable","pipe","map","entry","l","path","filter","x","length","current","push","message","split","join","Logger"],"mappings":"AAAA;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuB,KAAK,CAA5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,WAAW,GAAGC,OAAO,CAAC,gBAAD,CAA3B;;AACA,IAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAME,cAAc,GAAG,EAAvB;;IACMJ,Y;;;;;AACF,wBAAYK,IAAZ,EAAqD;AAAA;;AAAA,QAAnCC,MAAmC,uEAA1B,IAA0B;AAAA,QAApBC,WAAoB,uEAAN,IAAM;;AAAA;;AACjD,8BAAMF,IAAN,EAAYC,MAAZ;AACAF,IAAAA,cAAc,CAACG,WAAD,CAAd,GAA8BH,cAAc,CAACG,WAAD,CAAd,IAA+B,CAAC,EAAD,CAA7D;AACA,QAAMC,SAAS,GAAGJ,cAAc,CAACG,WAAD,CAAhC;AACA,UAAKE,WAAL,GAAmB,MAAKA,WAAL,CAAiBC,IAAjB,CAAsBT,WAAW,CAACU,GAAZ,CAAgB,UAAAC,KAAK,EAAI;AAC9D,UAAMC,CAAC,GAAGD,KAAK,CAACE,IAAN,CAAWC,MAAX,CAAkB,UAAAC,CAAC;AAAA,eAAI,CAAC,CAACA,CAAN;AAAA,OAAnB,EAA4BC,MAAtC;;AACA,UAAIJ,CAAC,IAAIL,SAAS,CAACS,MAAnB,EAA2B;AACvB,YAAIC,OAAO,GAAGV,SAAS,CAACA,SAAS,CAACS,MAAV,GAAmB,CAApB,CAAvB;;AACA,eAAOJ,CAAC,IAAIL,SAAS,CAACS,MAAtB,EAA8B;AAC1BC,UAAAA,OAAO,IAAIX,WAAX;AACAC,UAAAA,SAAS,CAACW,IAAV,CAAeD,OAAf;AACH;AACJ;;AACDN,MAAAA,KAAK,CAACQ,OAAN,GAAgBZ,SAAS,CAACK,CAAD,CAAT,GAAeD,KAAK,CAACQ,OAAN,CAAcC,KAAd,CAAoB,IAApB,EAA0BC,IAA1B,CAA+B,OAAOd,SAAS,CAACK,CAAD,CAA/C,CAA/B;AACA,aAAOD,KAAP;AACH,KAXwC,CAAtB,CAAnB;AAJiD;AAgBpD;;;EAjBsBT,QAAQ,CAACoB,M;;AAmBpCzB,OAAO,CAACE,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.IndentLogger = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst operators_1 = require(\"rxjs/operators\");\nconst logger_1 = require(\"./logger\");\n/**\n * Keep an map of indentation => array of indentations based on the level.\n * This is to optimize calculating the prefix based on the indentation itself. Since most logs\n * come from similar levels, and with similar indentation strings, this will be shared by all\n * loggers. Also, string concatenation is expensive so performing concats for every log entries\n * is expensive; this alleviates it.\n */\nconst indentationMap = {};\nclass IndentLogger extends logger_1.Logger {\n    constructor(name, parent = null, indentation = '  ') {\n        super(name, parent);\n        indentationMap[indentation] = indentationMap[indentation] || [''];\n        const indentMap = indentationMap[indentation];\n        this._observable = this._observable.pipe(operators_1.map(entry => {\n            const l = entry.path.filter(x => !!x).length;\n            if (l >= indentMap.length) {\n                let current = indentMap[indentMap.length - 1];\n                while (l >= indentMap.length) {\n                    current += indentation;\n                    indentMap.push(current);\n                }\n            }\n            entry.message = indentMap[l] + entry.message.split(/\\n/).join('\\n' + indentMap[l]);\n            return entry;\n        }));\n    }\n}\nexports.IndentLogger = IndentLogger;\n"]},"metadata":{},"sourceType":"script"}