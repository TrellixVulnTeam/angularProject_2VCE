{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/injectable_compiler\", [\"require\", \"exports\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/output/value_util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.InjectableCompiler = void 0;\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var value_util_1 = require(\"@angular/compiler/src/output/value_util\");\n\n  function mapEntry(key, value) {\n    return {\n      key: key,\n      value: value,\n      quoted: false\n    };\n  }\n\n  var InjectableCompiler =\n  /** @class */\n  function () {\n    function InjectableCompiler(reflector, alwaysGenerateDef) {\n      this.reflector = reflector;\n      this.alwaysGenerateDef = alwaysGenerateDef;\n      this.tokenInjector = reflector.resolveExternalReference(identifiers_1.Identifiers.Injector);\n    }\n\n    InjectableCompiler.prototype.depsArray = function (deps, ctx) {\n      var _this = this;\n\n      return deps.map(function (dep) {\n        var token = dep;\n        var args = [token];\n        var flags = 0\n        /* Default */\n        ;\n\n        if (Array.isArray(dep)) {\n          for (var i = 0; i < dep.length; i++) {\n            var v = dep[i];\n\n            if (v) {\n              if (v.ngMetadataName === 'Optional') {\n                flags |= 8\n                /* Optional */\n                ;\n              } else if (v.ngMetadataName === 'SkipSelf') {\n                flags |= 4\n                /* SkipSelf */\n                ;\n              } else if (v.ngMetadataName === 'Self') {\n                flags |= 2\n                /* Self */\n                ;\n              } else if (v.ngMetadataName === 'Inject') {\n                token = v.token;\n              } else {\n                token = v;\n              }\n            }\n          }\n        }\n\n        var tokenExpr;\n\n        if (typeof token === 'string') {\n          tokenExpr = o.literal(token);\n        } else if (token === _this.tokenInjector) {\n          tokenExpr = o.importExpr(identifiers_1.Identifiers.INJECTOR);\n        } else {\n          tokenExpr = ctx.importExpr(token);\n        }\n\n        if (flags !== 0\n        /* Default */\n        ) {\n            args = [tokenExpr, o.literal(flags)];\n          } else {\n          args = [tokenExpr];\n        }\n\n        return o.importExpr(identifiers_1.Identifiers.inject).callFn(args);\n      });\n    };\n\n    InjectableCompiler.prototype.factoryFor = function (injectable, ctx) {\n      var retValue;\n\n      if (injectable.useExisting) {\n        retValue = o.importExpr(identifiers_1.Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n      } else if (injectable.useFactory) {\n        var deps = injectable.deps || [];\n\n        if (deps.length > 0) {\n          retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n        } else {\n          return ctx.importExpr(injectable.useFactory);\n        }\n      } else if (injectable.useValue) {\n        retValue = value_util_1.convertValueToOutputAst(ctx, injectable.useValue);\n      } else {\n        var clazz = injectable.useClass || injectable.symbol;\n        var depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n        retValue = new o.InstantiateExpr(ctx.importExpr(clazz), depArgs);\n      }\n\n      return o.fn([], [new o.ReturnStatement(retValue)], undefined, undefined, injectable.symbol.name + '_Factory');\n    };\n\n    InjectableCompiler.prototype.injectableDef = function (injectable, ctx) {\n      var providedIn = o.NULL_EXPR;\n\n      if (injectable.providedIn !== undefined) {\n        if (injectable.providedIn === null) {\n          providedIn = o.NULL_EXPR;\n        } else if (typeof injectable.providedIn === 'string') {\n          providedIn = o.literal(injectable.providedIn);\n        } else {\n          providedIn = ctx.importExpr(injectable.providedIn);\n        }\n      }\n\n      var def = [mapEntry('factory', this.factoryFor(injectable, ctx)), mapEntry('token', ctx.importExpr(injectable.type.reference)), mapEntry('providedIn', providedIn)];\n      return o.importExpr(identifiers_1.Identifiers.ɵɵdefineInjectable).callFn([o.literalMap(def)]);\n    };\n\n    InjectableCompiler.prototype.compile = function (injectable, ctx) {\n      if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n        var className = compile_metadata_1.identifierName(injectable.type);\n        var clazz = new o.ClassStmt(className, null, [new o.ClassField('ɵprov', o.INFERRED_TYPE, [o.StmtModifier.Static], this.injectableDef(injectable, ctx))], [], new o.ClassMethod(null, [], []), []);\n        ctx.statements.push(clazz);\n      }\n    };\n\n    return InjectableCompiler;\n  }();\n\n  exports.InjectableCompiler = InjectableCompiler;\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/injectable_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from './aot/static_symbol';\nimport {CompileInjectableMetadata, CompileNgModuleMetadata, CompileProviderMetadata, identifierName} from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport {InjectFlags, NodeFlags} from './core';\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {convertValueToOutputAst} from './output/value_util';\nimport {typeSourceSpan} from './parse_util';\nimport {NgModuleProviderAnalyzer} from './provider_analyzer';\nimport {OutputContext} from './util';\nimport {componentFactoryResolverProviderDef, depDef, providerDef} from './view_compiler/provider_compiler';\n\ntype MapEntry = {\n  key: string,\n  quoted: boolean,\n  value: o.Expression\n};\ntype MapLiteral = MapEntry[];\n\nfunction mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport class InjectableCompiler {\n  private tokenInjector: StaticSymbol;\n  constructor(private reflector: CompileReflector, private alwaysGenerateDef: boolean) {\n    this.tokenInjector = reflector.resolveExternalReference(Identifiers.Injector);\n  }\n\n  private depsArray(deps: any[], ctx: OutputContext): o.Expression[] {\n    return deps.map(dep => {\n      let token = dep;\n      let args = [token];\n      let flags: InjectFlags = InjectFlags.Default;\n      if (Array.isArray(dep)) {\n        for (let i = 0; i < dep.length; i++) {\n          const v = dep[i];\n          if (v) {\n            if (v.ngMetadataName === 'Optional') {\n              flags |= InjectFlags.Optional;\n            } else if (v.ngMetadataName === 'SkipSelf') {\n              flags |= InjectFlags.SkipSelf;\n            } else if (v.ngMetadataName === 'Self') {\n              flags |= InjectFlags.Self;\n            } else if (v.ngMetadataName === 'Inject') {\n              token = v.token;\n            } else {\n              token = v;\n            }\n          }\n        }\n      }\n\n      let tokenExpr: o.Expression;\n      if (typeof token === 'string') {\n        tokenExpr = o.literal(token);\n      } else if (token === this.tokenInjector) {\n        tokenExpr = o.importExpr(Identifiers.INJECTOR);\n      } else {\n        tokenExpr = ctx.importExpr(token);\n      }\n\n      if (flags !== InjectFlags.Default) {\n        args = [tokenExpr, o.literal(flags)];\n      } else {\n        args = [tokenExpr];\n      }\n      return o.importExpr(Identifiers.inject).callFn(args);\n    });\n  }\n\n  factoryFor(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let retValue: o.Expression;\n    if (injectable.useExisting) {\n      retValue = o.importExpr(Identifiers.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n    } else if (injectable.useFactory) {\n      const deps = injectable.deps || [];\n      if (deps.length > 0) {\n        retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n      } else {\n        return ctx.importExpr(injectable.useFactory);\n      }\n    } else if (injectable.useValue) {\n      retValue = convertValueToOutputAst(ctx, injectable.useValue);\n    } else {\n      const clazz = injectable.useClass || injectable.symbol;\n      const depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n      retValue = new o.InstantiateExpr(ctx.importExpr(clazz), depArgs);\n    }\n    return o.fn(\n        [], [new o.ReturnStatement(retValue)], undefined, undefined,\n        injectable.symbol.name + '_Factory');\n  }\n\n  injectableDef(injectable: CompileInjectableMetadata, ctx: OutputContext): o.Expression {\n    let providedIn: o.Expression = o.NULL_EXPR;\n    if (injectable.providedIn !== undefined) {\n      if (injectable.providedIn === null) {\n        providedIn = o.NULL_EXPR;\n      } else if (typeof injectable.providedIn === 'string') {\n        providedIn = o.literal(injectable.providedIn);\n      } else {\n        providedIn = ctx.importExpr(injectable.providedIn);\n      }\n    }\n    const def: MapLiteral = [\n      mapEntry('factory', this.factoryFor(injectable, ctx)),\n      mapEntry('token', ctx.importExpr(injectable.type.reference)),\n      mapEntry('providedIn', providedIn),\n    ];\n    return o.importExpr(Identifiers.ɵɵdefineInjectable).callFn([o.literalMap(def)]);\n  }\n\n  compile(injectable: CompileInjectableMetadata, ctx: OutputContext): void {\n    if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n      const className = identifierName(injectable.type)!;\n      const clazz = new o.ClassStmt(\n          className, null,\n          [\n            new o.ClassField(\n                'ɵprov', o.INFERRED_TYPE, [o.StmtModifier.Static],\n                this.injectableDef(injectable, ctx)),\n          ],\n          [], new o.ClassMethod(null, [], []), []);\n      ctx.statements.push(clazz);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}