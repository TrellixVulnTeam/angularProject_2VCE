{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/scope/src/component_scope\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.CompoundComponentScopeReader = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * A `ComponentScopeReader` that reads from an ordered set of child readers until it obtains the\n   * requested scope.\n   *\n   * This is used to combine `ComponentScopeReader`s that read from different sources (e.g. from a\n   * registry and from the incremental state).\n   */\n\n\n  var CompoundComponentScopeReader =\n  /** @class */\n  function () {\n    function CompoundComponentScopeReader(readers) {\n      this.readers = readers;\n    }\n\n    CompoundComponentScopeReader.prototype.getScopeForComponent = function (clazz) {\n      var e_1, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var reader = _c.value;\n          var meta = reader.getScopeForComponent(clazz);\n\n          if (meta !== null) {\n            return meta;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return null;\n    };\n\n    CompoundComponentScopeReader.prototype.getRemoteScope = function (clazz) {\n      var e_2, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var reader = _c.value;\n          var remoteScope = reader.getRemoteScope(clazz);\n\n          if (remoteScope !== null) {\n            return remoteScope;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return null;\n    };\n\n    return CompoundComponentScopeReader;\n  }();\n\n  exports.CompoundComponentScopeReader = CompoundComponentScopeReader;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/component_scope.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AA0BA;;;;;;AAMG;;;AACH,MAAA,4BAAA;AAAA;AAAA,cAAA;AACE,aAAA,4BAAA,CAAoB,OAApB,EAAmD;AAA/B,WAAA,OAAA,GAAA,OAAA;AAAmC;;AAEvD,IAAA,4BAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,KAArB,EAA4C;;;;AAC1C,aAAqB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,OAAL,CAAA,EAAY,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC,CAAA,EAAA,CAAA,IAAjC,EAAiC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAmC;AAA9B,cAAM,MAAM,GAAA,EAAA,CAAA,KAAZ;AACH,cAAM,IAAI,GAAG,MAAM,CAAC,oBAAP,CAA4B,KAA5B,CAAb;;AACA,cAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,mBAAO,IAAP;AACD;AACF;;;;;;;;;;;;;AACD,aAAO,IAAP;AACD,KARD;;AAUA,IAAA,4BAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,KAAf,EAAsC;;;;AACpC,aAAqB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,OAAL,CAAA,EAAY,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC,CAAA,EAAA,CAAA,IAAjC,EAAiC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAmC;AAA9B,cAAM,MAAM,GAAA,EAAA,CAAA,KAAZ;AACH,cAAM,WAAW,GAAG,MAAM,CAAC,cAAP,CAAsB,KAAtB,CAApB;;AACA,cAAI,WAAW,KAAK,IAApB,EAA0B;AACxB,mBAAO,WAAP;AACD;AACF;;;;;;;;;;;;;AACD,aAAO,IAAP;AACD,KARD;;AASF,WAAA,4BAAA;AAAC,GAtBD,EAAA;;AAAa,EAAA,OAAA,CAAA,4BAAA,GAAA,4BAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {ClassDeclaration} from '../../reflection';\nimport {RemoteScope} from './api';\nimport {LocalModuleScope} from './local';\n\n/**\n * Read information about the compilation scope of components.\n */\nexport interface ComponentScopeReader {\n  getScopeForComponent(clazz: ClassDeclaration): LocalModuleScope|null;\n\n  /**\n   * Get the `RemoteScope` required for this component, if any.\n   *\n   * If the component requires remote scoping, then retrieve the directives/pipes registered for\n   * that component. If remote scoping is not required (the common case), returns `null`.\n   */\n  getRemoteScope(clazz: ClassDeclaration): RemoteScope|null;\n}\n\n/**\n * A `ComponentScopeReader` that reads from an ordered set of child readers until it obtains the\n * requested scope.\n *\n * This is used to combine `ComponentScopeReader`s that read from different sources (e.g. from a\n * registry and from the incremental state).\n */\nexport class CompoundComponentScopeReader implements ComponentScopeReader {\n  constructor(private readers: ComponentScopeReader[]) {}\n\n  getScopeForComponent(clazz: ClassDeclaration): LocalModuleScope|null {\n    for (const reader of this.readers) {\n      const meta = reader.getScopeForComponent(clazz);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n\n  getRemoteScope(clazz: ClassDeclaration): RemoteScope|null {\n    for (const reader of this.readers) {\n      const remoteScope = reader.getRemoteScope(clazz);\n      if (remoteScope !== null) {\n        return remoteScope;\n      }\n    }\n    return null;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}