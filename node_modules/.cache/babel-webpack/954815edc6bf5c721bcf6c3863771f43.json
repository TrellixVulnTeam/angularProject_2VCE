{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/lower_expressions\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/metadata/index\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.LowerMetadataTransform = exports.getExpressionLoweringTransformFactory = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var index_1 = require(\"@angular/compiler-cli/src/metadata/index\");\n\n  function toMap(items, select) {\n    return new Map(items.map(function (i) {\n      return [select(i), i];\n    }));\n  } // We will never lower expressions in a nested lexical scope so avoid entering them.\n  // This also avoids a bug in TypeScript 2.3 where the lexical scopes get out of sync\n  // when using visitEachChild.\n\n\n  function isLexicalScope(node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ArrowFunction:\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.ClassExpression:\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.FunctionType:\n      case ts.SyntaxKind.TypeLiteral:\n      case ts.SyntaxKind.ArrayType:\n        return true;\n    }\n\n    return false;\n  }\n\n  function transformSourceFile(sourceFile, requests, context) {\n    var inserts = []; // Calculate the range of interesting locations. The transform will only visit nodes in this\n    // range to improve the performance on large files.\n\n    var locations = Array.from(requests.keys());\n    var min = Math.min.apply(Math, tslib_1.__spread(locations));\n    var max = Math.max.apply(Math, tslib_1.__spread(locations)); // Visit nodes matching the request and synthetic nodes added by tsickle\n\n    function shouldVisit(pos, end) {\n      return pos <= max && end >= min || pos == -1;\n    }\n\n    function visitSourceFile(sourceFile) {\n      function topLevelStatement(node) {\n        var declarations = [];\n\n        function visitNode(node) {\n          // Get the original node before tsickle\n          var _a = ts.getOriginalNode(node),\n              pos = _a.pos,\n              end = _a.end,\n              kind = _a.kind,\n              originalParent = _a.parent;\n\n          var nodeRequest = requests.get(pos);\n\n          if (nodeRequest && nodeRequest.kind == kind && nodeRequest.end == end) {\n            // This node is requested to be rewritten as a reference to the exported name.\n            if (originalParent && originalParent.kind === ts.SyntaxKind.VariableDeclaration) {\n              // As the value represents the whole initializer of a variable declaration,\n              // just refer to that variable. This e.g. helps to preserve closure comments\n              // at the right place.\n              var varParent = originalParent;\n\n              if (varParent.name.kind === ts.SyntaxKind.Identifier) {\n                var varName = varParent.name.text;\n                var exportName_1 = nodeRequest.name;\n                declarations.push({\n                  name: exportName_1,\n                  node: ts.createIdentifier(varName),\n                  order: 1\n                  /* AfterStmt */\n\n                });\n                return node;\n              }\n            } // Record that the node needs to be moved to an exported variable with the given name\n\n\n            var exportName = nodeRequest.name;\n            declarations.push({\n              name: exportName,\n              node: node,\n              order: 0\n              /* BeforeStmt */\n\n            });\n            return ts.createIdentifier(exportName);\n          }\n\n          var result = node;\n\n          if (shouldVisit(pos, end) && !isLexicalScope(node)) {\n            result = ts.visitEachChild(node, visitNode, context);\n          }\n\n          return result;\n        } // Get the original node before tsickle\n\n\n        var _a = ts.getOriginalNode(node),\n            pos = _a.pos,\n            end = _a.end;\n\n        var resultStmt;\n\n        if (shouldVisit(pos, end)) {\n          resultStmt = ts.visitEachChild(node, visitNode, context);\n        } else {\n          resultStmt = node;\n        }\n\n        if (declarations.length) {\n          inserts.push({\n            relativeTo: resultStmt,\n            declarations: declarations\n          });\n        }\n\n        return resultStmt;\n      }\n\n      var newStatements = sourceFile.statements.map(topLevelStatement);\n\n      if (inserts.length) {\n        // Insert the declarations relative to the rewritten statement that references them.\n        var insertMap_1 = toMap(inserts, function (i) {\n          return i.relativeTo;\n        });\n        var tmpStatements_1 = [];\n        newStatements.forEach(function (statement) {\n          var insert = insertMap_1.get(statement);\n\n          if (insert) {\n            var before = insert.declarations.filter(function (d) {\n              return d.order === 0\n              /* BeforeStmt */\n              ;\n            });\n\n            if (before.length) {\n              tmpStatements_1.push(createVariableStatementForDeclarations(before));\n            }\n\n            tmpStatements_1.push(statement);\n            var after = insert.declarations.filter(function (d) {\n              return d.order === 1\n              /* AfterStmt */\n              ;\n            });\n\n            if (after.length) {\n              tmpStatements_1.push(createVariableStatementForDeclarations(after));\n            }\n          } else {\n            tmpStatements_1.push(statement);\n          }\n        }); // Insert an exports clause to export the declarations\n\n        tmpStatements_1.push(ts.createExportDeclaration(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        undefined, ts.createNamedExports(inserts.reduce(function (accumulator, insert) {\n          return tslib_1.__spread(accumulator, insert.declarations);\n        }, []).map(function (declaration) {\n          return ts.createExportSpecifier(\n          /* propertyName */\n          undefined, declaration.name);\n        }))));\n        newStatements = tmpStatements_1;\n      }\n\n      var newSf = ts.updateSourceFileNode(sourceFile, ts.setTextRange(ts.createNodeArray(newStatements), sourceFile.statements));\n\n      if (!(sourceFile.flags & ts.NodeFlags.Synthesized)) {\n        newSf.flags &= ~ts.NodeFlags.Synthesized;\n      }\n\n      return newSf;\n    }\n\n    return visitSourceFile(sourceFile);\n  }\n\n  function createVariableStatementForDeclarations(declarations) {\n    var varDecls = declarations.map(function (i) {\n      return ts.createVariableDeclaration(i.name,\n      /* type */\n      undefined, i.node);\n    });\n    return ts.createVariableStatement(\n    /* modifiers */\n    undefined, ts.createVariableDeclarationList(varDecls, ts.NodeFlags.Const));\n  }\n\n  function getExpressionLoweringTransformFactory(requestsMap, program) {\n    // Return the factory\n    return function (context) {\n      return function (sourceFile) {\n        // We need to use the original SourceFile for reading metadata, and not the transformed one.\n        var originalFile = program.getSourceFile(sourceFile.fileName);\n\n        if (originalFile) {\n          var requests = requestsMap.getRequests(originalFile);\n\n          if (requests && requests.size) {\n            return transformSourceFile(sourceFile, requests, context);\n          }\n        }\n\n        return sourceFile;\n      };\n    };\n  }\n\n  exports.getExpressionLoweringTransformFactory = getExpressionLoweringTransformFactory;\n\n  function isEligibleForLowering(node) {\n    if (node) {\n      switch (node.kind) {\n        case ts.SyntaxKind.SourceFile:\n        case ts.SyntaxKind.Decorator:\n          // Lower expressions that are local to the module scope or\n          // in a decorator.\n          return true;\n\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.InterfaceDeclaration:\n        case ts.SyntaxKind.EnumDeclaration:\n        case ts.SyntaxKind.FunctionDeclaration:\n          // Don't lower expressions in a declaration.\n          return false;\n\n        case ts.SyntaxKind.VariableDeclaration:\n          var isExported = (ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) == 0; // This might be unnecessary, as the variable might be exported and only used as a reference\n          // in another expression. However, the variable also might be involved in provider\n          // definitions. If that's the case, there is a specific token (`ROUTES`) which the compiler\n          // attempts to understand deeply. Sub-expressions within that token (`loadChildren` for\n          // example) might also require lowering even if the top-level declaration is already\n          // properly exported.\n\n          var varNode = node;\n          return isExported || varNode.initializer !== undefined && (ts.isObjectLiteralExpression(varNode.initializer) || ts.isArrayLiteralExpression(varNode.initializer) || ts.isCallExpression(varNode.initializer));\n      }\n\n      return isEligibleForLowering(node.parent);\n    }\n\n    return true;\n  }\n\n  function isPrimitive(value) {\n    return Object(value) !== value;\n  }\n\n  function isRewritten(value) {\n    return index_1.isMetadataGlobalReferenceExpression(value) && compiler_1.isLoweredSymbol(value.name);\n  }\n\n  function isLiteralFieldNamed(node, names) {\n    if (node.parent && node.parent.kind == ts.SyntaxKind.PropertyAssignment) {\n      var property = node.parent;\n\n      if (property.parent && property.parent.kind == ts.SyntaxKind.ObjectLiteralExpression && property.name && property.name.kind == ts.SyntaxKind.Identifier) {\n        var propertyName = property.name;\n        return names.has(propertyName.text);\n      }\n    }\n\n    return false;\n  }\n\n  var LowerMetadataTransform =\n  /** @class */\n  function () {\n    function LowerMetadataTransform(lowerableFieldNames) {\n      this.requests = new Map();\n      this.lowerableFieldNames = new Set(lowerableFieldNames);\n    } // RequestMap\n\n\n    LowerMetadataTransform.prototype.getRequests = function (sourceFile) {\n      var result = this.requests.get(sourceFile.fileName);\n\n      if (!result) {\n        // Force the metadata for this source file to be collected which\n        // will recursively call start() populating the request map;\n        this.cache.getMetadata(sourceFile); // If we still don't have the requested metadata, the file is not a module\n        // or is a declaration file so return an empty map.\n\n        result = this.requests.get(sourceFile.fileName) || new Map();\n      }\n\n      return result;\n    }; // MetadataTransformer\n\n\n    LowerMetadataTransform.prototype.connect = function (cache) {\n      this.cache = cache;\n    };\n\n    LowerMetadataTransform.prototype.start = function (sourceFile) {\n      var _this = this;\n\n      var identNumber = 0;\n\n      var freshIdent = function freshIdent() {\n        return compiler_1.createLoweredSymbol(identNumber++);\n      };\n\n      var requests = new Map();\n      this.requests.set(sourceFile.fileName, requests);\n\n      var replaceNode = function replaceNode(node) {\n        var name = freshIdent();\n        requests.set(node.pos, {\n          name: name,\n          kind: node.kind,\n          location: node.pos,\n          end: node.end\n        });\n        return {\n          __symbolic: 'reference',\n          name: name\n        };\n      };\n\n      var isExportedSymbol = function () {\n        var exportTable;\n        return function (node) {\n          if (node.kind == ts.SyntaxKind.Identifier) {\n            var ident = node;\n\n            if (!exportTable) {\n              exportTable = createExportTableFor(sourceFile);\n            }\n\n            return exportTable.has(ident.text);\n          }\n\n          return false;\n        };\n      }();\n\n      var isExportedPropertyAccess = function isExportedPropertyAccess(node) {\n        if (node.kind === ts.SyntaxKind.PropertyAccessExpression) {\n          var pae = node;\n\n          if (isExportedSymbol(pae.expression)) {\n            return true;\n          }\n        }\n\n        return false;\n      };\n\n      var hasLowerableParentCache = new Map();\n\n      var shouldBeLowered = function shouldBeLowered(node) {\n        if (node === undefined) {\n          return false;\n        }\n\n        var lowerable = false;\n\n        if ((node.kind === ts.SyntaxKind.ArrowFunction || node.kind === ts.SyntaxKind.FunctionExpression) && isEligibleForLowering(node)) {\n          lowerable = true;\n        } else if (isLiteralFieldNamed(node, _this.lowerableFieldNames) && isEligibleForLowering(node) && !isExportedSymbol(node) && !isExportedPropertyAccess(node)) {\n          lowerable = true;\n        }\n\n        return lowerable;\n      };\n\n      var hasLowerableParent = function hasLowerableParent(node) {\n        if (node === undefined) {\n          return false;\n        }\n\n        if (!hasLowerableParentCache.has(node)) {\n          hasLowerableParentCache.set(node, shouldBeLowered(node.parent) || hasLowerableParent(node.parent));\n        }\n\n        return hasLowerableParentCache.get(node);\n      };\n\n      var isLowerable = function isLowerable(node) {\n        if (node === undefined) {\n          return false;\n        }\n\n        return shouldBeLowered(node) && !hasLowerableParent(node);\n      };\n\n      return function (value, node) {\n        if (!isPrimitive(value) && !isRewritten(value) && isLowerable(node)) {\n          return replaceNode(node);\n        }\n\n        return value;\n      };\n    };\n\n    return LowerMetadataTransform;\n  }();\n\n  exports.LowerMetadataTransform = LowerMetadataTransform;\n\n  function createExportTableFor(sourceFile) {\n    var exportTable = new Set(); // Lazily collect all the exports from the source file\n\n    ts.forEachChild(sourceFile, function scan(node) {\n      var e_1, _a;\n\n      switch (node.kind) {\n        case ts.SyntaxKind.ClassDeclaration:\n        case ts.SyntaxKind.FunctionDeclaration:\n        case ts.SyntaxKind.InterfaceDeclaration:\n          if ((ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export) != 0) {\n            var classDeclaration = node;\n            var name = classDeclaration.name;\n            if (name) exportTable.add(name.text);\n          }\n\n          break;\n\n        case ts.SyntaxKind.VariableStatement:\n          var variableStatement = node;\n\n          try {\n            for (var _b = tslib_1.__values(variableStatement.declarationList.declarations), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var declaration = _c.value;\n              scan(declaration);\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n\n          break;\n\n        case ts.SyntaxKind.VariableDeclaration:\n          var variableDeclaration = node;\n\n          if ((ts.getCombinedModifierFlags(variableDeclaration) & ts.ModifierFlags.Export) != 0 && variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n            var name = variableDeclaration.name;\n            exportTable.add(name.text);\n          }\n\n          break;\n\n        case ts.SyntaxKind.ExportDeclaration:\n          var exportDeclaration = node;\n          var moduleSpecifier = exportDeclaration.moduleSpecifier,\n              exportClause = exportDeclaration.exportClause;\n\n          if (!moduleSpecifier && exportClause && ts.isNamedExports(exportClause)) {\n            exportClause.elements.forEach(function (spec) {\n              exportTable.add(spec.name.text);\n            });\n          }\n\n      }\n    });\n    return exportTable;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/lower_expressions.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {createLoweredSymbol, isLoweredSymbol} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {CollectorOptions, isMetadataGlobalReferenceExpression, MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n\nimport {MetadataCache, MetadataTransformer, ValueTransform} from './metadata_cache';\n\nexport interface LoweringRequest {\n  kind: ts.SyntaxKind;\n  location: number;\n  end: number;\n  name: string;\n}\n\nexport type RequestLocationMap = Map<number, LoweringRequest>;\n\nconst enum DeclarationOrder {\n  BeforeStmt,\n  AfterStmt\n}\n\ninterface Declaration {\n  name: string;\n  node: ts.Node;\n  order: DeclarationOrder;\n}\n\ninterface DeclarationInsert {\n  declarations: Declaration[];\n  relativeTo: ts.Node;\n}\n\nfunction toMap<T, K>(items: T[], select: (item: T) => K): Map<K, T> {\n  return new Map(items.map<[K, T]>(i => [select(i), i]));\n}\n\n// We will never lower expressions in a nested lexical scope so avoid entering them.\n// This also avoids a bug in TypeScript 2.3 where the lexical scopes get out of sync\n// when using visitEachChild.\nfunction isLexicalScope(node: ts.Node): boolean {\n  switch (node.kind) {\n    case ts.SyntaxKind.ArrowFunction:\n    case ts.SyntaxKind.FunctionExpression:\n    case ts.SyntaxKind.FunctionDeclaration:\n    case ts.SyntaxKind.ClassExpression:\n    case ts.SyntaxKind.ClassDeclaration:\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.TypeLiteral:\n    case ts.SyntaxKind.ArrayType:\n      return true;\n  }\n  return false;\n}\n\nfunction transformSourceFile(\n    sourceFile: ts.SourceFile, requests: RequestLocationMap,\n    context: ts.TransformationContext): ts.SourceFile {\n  const inserts: DeclarationInsert[] = [];\n\n  // Calculate the range of interesting locations. The transform will only visit nodes in this\n  // range to improve the performance on large files.\n  const locations = Array.from(requests.keys());\n  const min = Math.min(...locations);\n  const max = Math.max(...locations);\n\n  // Visit nodes matching the request and synthetic nodes added by tsickle\n  function shouldVisit(pos: number, end: number): boolean {\n    return (pos <= max && end >= min) || pos == -1;\n  }\n\n  function visitSourceFile(sourceFile: ts.SourceFile): ts.SourceFile {\n    function topLevelStatement(node: ts.Statement): ts.Statement {\n      const declarations: Declaration[] = [];\n\n      function visitNode(node: ts.Node): ts.Node {\n        // Get the original node before tsickle\n        const {pos, end, kind, parent: originalParent} = ts.getOriginalNode(node);\n        const nodeRequest = requests.get(pos);\n        if (nodeRequest && nodeRequest.kind == kind && nodeRequest.end == end) {\n          // This node is requested to be rewritten as a reference to the exported name.\n          if (originalParent && originalParent.kind === ts.SyntaxKind.VariableDeclaration) {\n            // As the value represents the whole initializer of a variable declaration,\n            // just refer to that variable. This e.g. helps to preserve closure comments\n            // at the right place.\n            const varParent = originalParent as ts.VariableDeclaration;\n            if (varParent.name.kind === ts.SyntaxKind.Identifier) {\n              const varName = varParent.name.text;\n              const exportName = nodeRequest.name;\n              declarations.push({\n                name: exportName,\n                node: ts.createIdentifier(varName),\n                order: DeclarationOrder.AfterStmt\n              });\n              return node;\n            }\n          }\n          // Record that the node needs to be moved to an exported variable with the given name\n          const exportName = nodeRequest.name;\n          declarations.push({name: exportName, node, order: DeclarationOrder.BeforeStmt});\n          return ts.createIdentifier(exportName);\n        }\n        let result = node;\n        if (shouldVisit(pos, end) && !isLexicalScope(node)) {\n          result = ts.visitEachChild(node, visitNode, context);\n        }\n        return result;\n      }\n\n      // Get the original node before tsickle\n      const {pos, end} = ts.getOriginalNode(node);\n      let resultStmt: ts.Statement;\n      if (shouldVisit(pos, end)) {\n        resultStmt = ts.visitEachChild(node, visitNode, context);\n      } else {\n        resultStmt = node;\n      }\n\n      if (declarations.length) {\n        inserts.push({relativeTo: resultStmt, declarations});\n      }\n      return resultStmt;\n    }\n\n    let newStatements = sourceFile.statements.map(topLevelStatement);\n\n    if (inserts.length) {\n      // Insert the declarations relative to the rewritten statement that references them.\n      const insertMap = toMap(inserts, i => i.relativeTo);\n      const tmpStatements: ts.Statement[] = [];\n      newStatements.forEach(statement => {\n        const insert = insertMap.get(statement);\n        if (insert) {\n          const before = insert.declarations.filter(d => d.order === DeclarationOrder.BeforeStmt);\n          if (before.length) {\n            tmpStatements.push(createVariableStatementForDeclarations(before));\n          }\n          tmpStatements.push(statement);\n          const after = insert.declarations.filter(d => d.order === DeclarationOrder.AfterStmt);\n          if (after.length) {\n            tmpStatements.push(createVariableStatementForDeclarations(after));\n          }\n        } else {\n          tmpStatements.push(statement);\n        }\n      });\n\n      // Insert an exports clause to export the declarations\n      tmpStatements.push(ts.createExportDeclaration(\n          /* decorators */ undefined,\n          /* modifiers */ undefined,\n          ts.createNamedExports(\n              inserts\n                  .reduce(\n                      (accumulator, insert) => [...accumulator, ...insert.declarations],\n                      [] as Declaration[])\n                  .map(\n                      declaration => ts.createExportSpecifier(\n                          /* propertyName */ undefined, declaration.name)))));\n\n      newStatements = tmpStatements;\n    }\n\n    const newSf = ts.updateSourceFileNode(\n        sourceFile, ts.setTextRange(ts.createNodeArray(newStatements), sourceFile.statements));\n    if (!(sourceFile.flags & ts.NodeFlags.Synthesized)) {\n      (newSf.flags as ts.NodeFlags) &= ~ts.NodeFlags.Synthesized;\n    }\n\n    return newSf;\n  }\n\n  return visitSourceFile(sourceFile);\n}\n\nfunction createVariableStatementForDeclarations(declarations: Declaration[]): ts.VariableStatement {\n  const varDecls = declarations.map(\n      i => ts.createVariableDeclaration(i.name, /* type */ undefined, i.node as ts.Expression));\n  return ts.createVariableStatement(\n      /* modifiers */ undefined, ts.createVariableDeclarationList(varDecls, ts.NodeFlags.Const));\n}\n\nexport function getExpressionLoweringTransformFactory(\n    requestsMap: RequestsMap, program: ts.Program): (context: ts.TransformationContext) =>\n    (sourceFile: ts.SourceFile) => ts.SourceFile {\n  // Return the factory\n  return (context: ts.TransformationContext) => (sourceFile: ts.SourceFile): ts.SourceFile => {\n    // We need to use the original SourceFile for reading metadata, and not the transformed one.\n    const originalFile = program.getSourceFile(sourceFile.fileName);\n    if (originalFile) {\n      const requests = requestsMap.getRequests(originalFile);\n      if (requests && requests.size) {\n        return transformSourceFile(sourceFile, requests, context);\n      }\n    }\n    return sourceFile;\n  };\n}\n\nexport interface RequestsMap {\n  getRequests(sourceFile: ts.SourceFile): RequestLocationMap;\n}\n\nfunction isEligibleForLowering(node: ts.Node|undefined): boolean {\n  if (node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.SourceFile:\n      case ts.SyntaxKind.Decorator:\n        // Lower expressions that are local to the module scope or\n        // in a decorator.\n        return true;\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n      case ts.SyntaxKind.EnumDeclaration:\n      case ts.SyntaxKind.FunctionDeclaration:\n        // Don't lower expressions in a declaration.\n        return false;\n      case ts.SyntaxKind.VariableDeclaration:\n        const isExported = (ts.getCombinedModifierFlags(node as ts.VariableDeclaration) &\n                            ts.ModifierFlags.Export) == 0;\n        // This might be unnecessary, as the variable might be exported and only used as a reference\n        // in another expression. However, the variable also might be involved in provider\n        // definitions. If that's the case, there is a specific token (`ROUTES`) which the compiler\n        // attempts to understand deeply. Sub-expressions within that token (`loadChildren` for\n        // example) might also require lowering even if the top-level declaration is already\n        // properly exported.\n        const varNode = node as ts.VariableDeclaration;\n        return isExported ||\n            (varNode.initializer !== undefined &&\n             (ts.isObjectLiteralExpression(varNode.initializer) ||\n              ts.isArrayLiteralExpression(varNode.initializer) ||\n              ts.isCallExpression(varNode.initializer)));\n    }\n    return isEligibleForLowering(node.parent);\n  }\n  return true;\n}\n\nfunction isPrimitive(value: any): boolean {\n  return Object(value) !== value;\n}\n\nfunction isRewritten(value: any): boolean {\n  return isMetadataGlobalReferenceExpression(value) && isLoweredSymbol(value.name);\n}\n\nfunction isLiteralFieldNamed(node: ts.Node, names: Set<string>): boolean {\n  if (node.parent && node.parent.kind == ts.SyntaxKind.PropertyAssignment) {\n    const property = node.parent as ts.PropertyAssignment;\n    if (property.parent && property.parent.kind == ts.SyntaxKind.ObjectLiteralExpression &&\n        property.name && property.name.kind == ts.SyntaxKind.Identifier) {\n      const propertyName = property.name as ts.Identifier;\n      return names.has(propertyName.text);\n    }\n  }\n  return false;\n}\n\nexport class LowerMetadataTransform implements RequestsMap, MetadataTransformer {\n  // TODO(issue/24571): remove '!'.\n  private cache!: MetadataCache;\n  private requests = new Map<string, RequestLocationMap>();\n  private lowerableFieldNames: Set<string>;\n\n  constructor(lowerableFieldNames: string[]) {\n    this.lowerableFieldNames = new Set<string>(lowerableFieldNames);\n  }\n\n  // RequestMap\n  getRequests(sourceFile: ts.SourceFile): RequestLocationMap {\n    let result = this.requests.get(sourceFile.fileName);\n    if (!result) {\n      // Force the metadata for this source file to be collected which\n      // will recursively call start() populating the request map;\n      this.cache.getMetadata(sourceFile);\n\n      // If we still don't have the requested metadata, the file is not a module\n      // or is a declaration file so return an empty map.\n      result = this.requests.get(sourceFile.fileName) || new Map<number, LoweringRequest>();\n    }\n    return result;\n  }\n\n  // MetadataTransformer\n  connect(cache: MetadataCache): void {\n    this.cache = cache;\n  }\n\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n    let identNumber = 0;\n    const freshIdent = () => createLoweredSymbol(identNumber++);\n    const requests = new Map<number, LoweringRequest>();\n    this.requests.set(sourceFile.fileName, requests);\n\n    const replaceNode = (node: ts.Node) => {\n      const name = freshIdent();\n      requests.set(node.pos, {name, kind: node.kind, location: node.pos, end: node.end});\n      return {__symbolic: 'reference', name};\n    };\n\n    const isExportedSymbol = (() => {\n      let exportTable: Set<string>;\n      return (node: ts.Node) => {\n        if (node.kind == ts.SyntaxKind.Identifier) {\n          const ident = node as ts.Identifier;\n\n          if (!exportTable) {\n            exportTable = createExportTableFor(sourceFile);\n          }\n          return exportTable.has(ident.text);\n        }\n        return false;\n      };\n    })();\n\n    const isExportedPropertyAccess = (node: ts.Node) => {\n      if (node.kind === ts.SyntaxKind.PropertyAccessExpression) {\n        const pae = node as ts.PropertyAccessExpression;\n        if (isExportedSymbol(pae.expression)) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    const hasLowerableParentCache = new Map<ts.Node, boolean>();\n\n    const shouldBeLowered = (node: ts.Node|undefined): boolean => {\n      if (node === undefined) {\n        return false;\n      }\n      let lowerable: boolean = false;\n      if ((node.kind === ts.SyntaxKind.ArrowFunction ||\n           node.kind === ts.SyntaxKind.FunctionExpression) &&\n          isEligibleForLowering(node)) {\n        lowerable = true;\n      } else if (\n          isLiteralFieldNamed(node, this.lowerableFieldNames) && isEligibleForLowering(node) &&\n          !isExportedSymbol(node) && !isExportedPropertyAccess(node)) {\n        lowerable = true;\n      }\n      return lowerable;\n    };\n\n    const hasLowerableParent = (node: ts.Node|undefined): boolean => {\n      if (node === undefined) {\n        return false;\n      }\n      if (!hasLowerableParentCache.has(node)) {\n        hasLowerableParentCache.set(\n            node, shouldBeLowered(node.parent) || hasLowerableParent(node.parent));\n      }\n      return hasLowerableParentCache.get(node)!;\n    };\n\n    const isLowerable = (node: ts.Node|undefined): boolean => {\n      if (node === undefined) {\n        return false;\n      }\n      return shouldBeLowered(node) && !hasLowerableParent(node);\n    };\n\n    return (value: MetadataValue, node: ts.Node): MetadataValue => {\n      if (!isPrimitive(value) && !isRewritten(value) && isLowerable(node)) {\n        return replaceNode(node);\n      }\n      return value;\n    };\n  }\n}\n\nfunction createExportTableFor(sourceFile: ts.SourceFile): Set<string> {\n  const exportTable = new Set<string>();\n  // Lazily collect all the exports from the source file\n  ts.forEachChild(sourceFile, function scan(node) {\n    switch (node.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n      case ts.SyntaxKind.FunctionDeclaration:\n      case ts.SyntaxKind.InterfaceDeclaration:\n        if ((ts.getCombinedModifierFlags(node as ts.Declaration) & ts.ModifierFlags.Export) != 0) {\n          const classDeclaration =\n              node as (ts.ClassDeclaration | ts.FunctionDeclaration | ts.InterfaceDeclaration);\n          const name = classDeclaration.name;\n          if (name) exportTable.add(name.text);\n        }\n        break;\n      case ts.SyntaxKind.VariableStatement:\n        const variableStatement = node as ts.VariableStatement;\n        for (const declaration of variableStatement.declarationList.declarations) {\n          scan(declaration);\n        }\n        break;\n      case ts.SyntaxKind.VariableDeclaration:\n        const variableDeclaration = node as ts.VariableDeclaration;\n        if ((ts.getCombinedModifierFlags(variableDeclaration) & ts.ModifierFlags.Export) != 0 &&\n            variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n          const name = variableDeclaration.name as ts.Identifier;\n          exportTable.add(name.text);\n        }\n        break;\n      case ts.SyntaxKind.ExportDeclaration:\n        const exportDeclaration = node as ts.ExportDeclaration;\n        const {moduleSpecifier, exportClause} = exportDeclaration;\n        if (!moduleSpecifier && exportClause && ts.isNamedExports(exportClause)) {\n          exportClause.elements.forEach(spec => {\n            exportTable.add(spec.name.text);\n          });\n        }\n    }\n  });\n  return exportTable;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}