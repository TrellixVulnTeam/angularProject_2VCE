{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.expect = exports.createScrubFileTransformerFactory = exports.testScrubFile = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ts = require(\"typescript\");\n\nvar ast_utils_1 = require(\"../helpers/ast-utils\");\n\nfunction testScrubFile(content) {\n  var markers = ['decorators', '__decorate', 'propDecorators', 'ctorParameters', 'ɵsetClassMetadata'];\n  return markers.some(function (marker) {\n    return content.includes(marker);\n  });\n}\n\nexports.testScrubFile = testScrubFile;\n\nfunction createScrubFileTransformerFactory(isAngularCoreFile) {\n  return function (program) {\n    return scrubFileTransformer(program, isAngularCoreFile);\n  };\n}\n\nexports.createScrubFileTransformerFactory = createScrubFileTransformerFactory;\n\nfunction scrubFileTransformer(program, isAngularCoreFile) {\n  if (!program) {\n    throw new Error('scrubFileTransformer requires a TypeScript Program.');\n  }\n\n  var checker = program.getTypeChecker();\n  return function (context) {\n    var transformer = function transformer(sf) {\n      var ngMetadata = findAngularMetadata(sf, isAngularCoreFile);\n      var tslibImports = findTslibImports(sf);\n      var nodes = [];\n      ts.forEachChild(sf, checkNodeForDecorators);\n\n      function checkNodeForDecorators(node) {\n        var _a;\n\n        if (!ts.isExpressionStatement(node)) {\n          return ts.forEachChild(node, checkNodeForDecorators);\n        }\n\n        var exprStmt = node;\n        var iife = (_a = getIifeStatement(exprStmt)) === null || _a === void 0 ? void 0 : _a.expression; // Do checks that don't need the typechecker first and bail early.\n\n        if (isCtorParamsAssignmentExpression(exprStmt)) {\n          nodes.push(node);\n        } else if (iife && isIvyPrivateCallExpression(iife, 'ɵsetClassMetadata')) {\n          nodes.push(node);\n        } else if (iife && ts.isBinaryExpression(iife) && isIvyPrivateCallExpression(iife.right, 'ɵsetClassMetadata')) {\n          nodes.push(node);\n        } else if (isDecoratorAssignmentExpression(exprStmt)) {\n          nodes.push.apply(nodes, _toConsumableArray(pickDecorationNodesToRemove(exprStmt, ngMetadata, checker)));\n        } else if (isDecorateAssignmentExpression(exprStmt, tslibImports, checker) || isAngularDecoratorExpression(exprStmt, ngMetadata, tslibImports, checker)) {\n          nodes.push.apply(nodes, _toConsumableArray(pickDecorateNodesToRemove(exprStmt, tslibImports, ngMetadata, checker)));\n        } else if (isPropDecoratorAssignmentExpression(exprStmt)) {\n          nodes.push.apply(nodes, _toConsumableArray(pickPropDecorationNodesToRemove(exprStmt, ngMetadata, checker)));\n        }\n      }\n\n      var visitor = function visitor(node) {\n        // Check if node is a statement to be dropped.\n        if (nodes.find(function (n) {\n          return n === node;\n        })) {\n          return undefined;\n        } // Otherwise return node as is.\n\n\n        return ts.visitEachChild(node, visitor, context);\n      };\n\n      return ts.visitNode(sf, visitor);\n    };\n\n    return transformer;\n  };\n}\n\nfunction expect(node, kind) {\n  if (node.kind !== kind) {\n    throw new Error('Invalid node type.');\n  }\n\n  return node;\n}\n\nexports.expect = expect;\n\nfunction findAngularMetadata(node, isAngularCoreFile) {\n  var specs = []; // Find all specifiers from imports of `@angular/core`.\n\n  ts.forEachChild(node, function (child) {\n    if (child.kind === ts.SyntaxKind.ImportDeclaration) {\n      var importDecl = child;\n\n      if (isAngularCoreImport(importDecl, isAngularCoreFile)) {\n        var _specs;\n\n        (_specs = specs).push.apply(_specs, _toConsumableArray(ast_utils_1.collectDeepNodes(importDecl, ts.SyntaxKind.ImportSpecifier)));\n      }\n    }\n  }); // If the current module is a Angular core file, we also consider all declarations in it to\n  // potentially be Angular metadata.\n\n  if (isAngularCoreFile) {\n    var localDecl = findAllDeclarations(node);\n    specs = specs.concat(localDecl);\n  }\n\n  return specs;\n}\n\nfunction findAllDeclarations(node) {\n  var nodes = [];\n  ts.forEachChild(node, function (child) {\n    if (child.kind === ts.SyntaxKind.VariableStatement) {\n      var vStmt = child;\n      vStmt.declarationList.declarations.forEach(function (decl) {\n        if (decl.name.kind !== ts.SyntaxKind.Identifier) {\n          return;\n        }\n\n        nodes.push(decl);\n      });\n    }\n  });\n  return nodes;\n}\n\nfunction isAngularCoreImport(node, isAngularCoreFile) {\n  if (!(node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier))) {\n    return false;\n  }\n\n  var importText = node.moduleSpecifier.text; // Imports to `@angular/core` are always core imports.\n\n  if (importText === '@angular/core') {\n    return true;\n  } // Relative imports from a Angular core file are also core imports.\n\n\n  if (isAngularCoreFile && importText.startsWith('.')) {\n    return true;\n  }\n\n  return false;\n} // Check if assignment is `Clazz.decorators = [...];`.\n\n\nfunction isDecoratorAssignmentExpression(exprStmt) {\n  if (!isAssignmentExpressionTo(exprStmt, 'decorators')) {\n    return false;\n  }\n\n  var expr = exprStmt.expression;\n\n  if (!ts.isArrayLiteralExpression(expr.right)) {\n    return false;\n  }\n\n  return true;\n} // Check if assignment is `Clazz = __decorate([...], Clazz)`.\n\n\nfunction isDecorateAssignmentExpression(exprStmt, tslibImports, checker) {\n  if (!ts.isBinaryExpression(exprStmt.expression)) {\n    return false;\n  }\n\n  var expr = exprStmt.expression;\n\n  if (!ts.isIdentifier(expr.left)) {\n    return false;\n  }\n\n  var classIdent = expr.left;\n  var callExpr;\n\n  if (ts.isCallExpression(expr.right)) {\n    callExpr = expr.right;\n  } else if (ts.isBinaryExpression(expr.right)) {\n    // `Clazz = Clazz_1 = __decorate([...], Clazz)` can be found when there are static property\n    // accesses.\n    var innerExpr = expr.right;\n\n    if (!ts.isIdentifier(innerExpr.left) || !ts.isCallExpression(innerExpr.right)) {\n      return false;\n    }\n\n    callExpr = innerExpr.right;\n  } else {\n    return false;\n  }\n\n  if (!isTslibHelper(callExpr, '__decorate', tslibImports, checker)) {\n    return false;\n  }\n\n  if (callExpr.arguments.length !== 2) {\n    return false;\n  }\n\n  var classArg = callExpr.arguments[1];\n\n  if (!ts.isIdentifier(classArg)) {\n    return false;\n  }\n\n  if (classIdent.text !== classArg.text) {\n    return false;\n  }\n\n  if (!ts.isArrayLiteralExpression(callExpr.arguments[0])) {\n    return false;\n  }\n\n  return true;\n} // Check if expression is `__decorate([smt, __metadata(\"design:type\", Object)], ...)`.\n\n\nfunction isAngularDecoratorExpression(exprStmt, ngMetadata, tslibImports, checker) {\n  if (!ts.isCallExpression(exprStmt.expression)) {\n    return false;\n  }\n\n  var callExpr = exprStmt.expression;\n\n  if (!isTslibHelper(callExpr, '__decorate', tslibImports, checker)) {\n    return false;\n  }\n\n  if (callExpr.arguments.length !== 4) {\n    return false;\n  }\n\n  var decorateArray = callExpr.arguments[0];\n\n  if (!ts.isArrayLiteralExpression(decorateArray)) {\n    return false;\n  } // Check first array entry for Angular decorators.\n\n\n  if (decorateArray.elements.length === 0 || !ts.isCallExpression(decorateArray.elements[0])) {\n    return false;\n  }\n\n  return decorateArray.elements.some(function (decoratorCall) {\n    if (!ts.isCallExpression(decoratorCall) || !ts.isIdentifier(decoratorCall.expression)) {\n      return false;\n    }\n\n    var decoratorId = decoratorCall.expression;\n    return identifierIsMetadata(decoratorId, ngMetadata, checker);\n  });\n} // Check if assignment is `Clazz.propDecorators = [...];`.\n\n\nfunction isPropDecoratorAssignmentExpression(exprStmt) {\n  if (!isAssignmentExpressionTo(exprStmt, 'propDecorators')) {\n    return false;\n  }\n\n  var expr = exprStmt.expression;\n\n  if (expr.right.kind !== ts.SyntaxKind.ObjectLiteralExpression) {\n    return false;\n  }\n\n  return true;\n} // Check if assignment is `Clazz.ctorParameters = [...];`.\n\n\nfunction isCtorParamsAssignmentExpression(exprStmt) {\n  if (!isAssignmentExpressionTo(exprStmt, 'ctorParameters')) {\n    return false;\n  }\n\n  var expr = exprStmt.expression;\n\n  if (expr.right.kind !== ts.SyntaxKind.FunctionExpression && expr.right.kind !== ts.SyntaxKind.ArrowFunction) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isAssignmentExpressionTo(exprStmt, name) {\n  if (!ts.isBinaryExpression(exprStmt.expression)) {\n    return false;\n  }\n\n  var expr = exprStmt.expression;\n\n  if (!ts.isPropertyAccessExpression(expr.left)) {\n    return false;\n  }\n\n  var propAccess = expr.left;\n\n  if (propAccess.name.text !== name) {\n    return false;\n  }\n\n  if (!ts.isIdentifier(propAccess.expression)) {\n    return false;\n  }\n\n  if (expr.operatorToken.kind !== ts.SyntaxKind.FirstAssignment) {\n    return false;\n  }\n\n  return true;\n} // Each Ivy private call expression is inside an IIFE\n\n\nfunction getIifeStatement(exprStmt) {\n  var expression = exprStmt.expression;\n\n  if (!expression || !ts.isCallExpression(expression) || expression.arguments.length !== 0) {\n    return null;\n  }\n\n  var parenExpr = expression;\n\n  if (!ts.isParenthesizedExpression(parenExpr.expression)) {\n    return null;\n  }\n\n  var funExpr = parenExpr.expression.expression;\n\n  if (!ts.isFunctionExpression(funExpr)) {\n    return null;\n  }\n\n  var innerStmts = funExpr.body.statements;\n\n  if (innerStmts.length !== 1) {\n    return null;\n  }\n\n  var innerExprStmt = innerStmts[0];\n\n  if (!ts.isExpressionStatement(innerExprStmt)) {\n    return null;\n  }\n\n  return innerExprStmt;\n}\n\nfunction isIvyPrivateCallExpression(expression, name) {\n  // Now we're in the IIFE and have the inner expression statement. We can check if it matches\n  // a private Ivy call.\n  if (!ts.isCallExpression(expression)) {\n    return false;\n  }\n\n  var propAccExpr = expression.expression;\n\n  if (!ts.isPropertyAccessExpression(propAccExpr)) {\n    return false;\n  }\n\n  if (propAccExpr.name.text != name) {\n    return false;\n  }\n\n  return true;\n} // Remove Angular decorators from`Clazz.decorators = [...];`, or expression itself if all are\n// removed.\n\n\nfunction pickDecorationNodesToRemove(exprStmt, ngMetadata, checker) {\n  var expr = expect(exprStmt.expression, ts.SyntaxKind.BinaryExpression);\n  var literal = expect(expr.right, ts.SyntaxKind.ArrayLiteralExpression);\n\n  if (!literal.elements.every(function (elem) {\n    return ts.isObjectLiteralExpression(elem);\n  })) {\n    return [];\n  }\n\n  var elements = literal.elements;\n  var ngDecorators = elements.filter(function (elem) {\n    return isAngularDecorator(elem, ngMetadata, checker);\n  });\n  return elements.length > ngDecorators.length ? ngDecorators : [exprStmt];\n} // Remove Angular decorators from `Clazz = __decorate([...], Clazz)`, or expression itself if all\n// are removed.\n\n\nfunction pickDecorateNodesToRemove(exprStmt, tslibImports, ngMetadata, checker) {\n  var callExpr;\n\n  if (ts.isCallExpression(exprStmt.expression)) {\n    callExpr = exprStmt.expression;\n  } else if (ts.isBinaryExpression(exprStmt.expression)) {\n    var expr = exprStmt.expression;\n\n    if (ts.isCallExpression(expr.right)) {\n      callExpr = expr.right;\n    } else if (ts.isBinaryExpression(expr.right) && ts.isCallExpression(expr.right.right)) {\n      callExpr = expr.right.right;\n    }\n  }\n\n  if (!callExpr) {\n    return [];\n  }\n\n  var arrLiteral = expect(callExpr.arguments[0], ts.SyntaxKind.ArrayLiteralExpression);\n\n  if (!arrLiteral.elements.every(function (elem) {\n    return ts.isCallExpression(elem);\n  })) {\n    return [];\n  }\n\n  var elements = arrLiteral.elements;\n  var ngDecoratorCalls = elements.filter(function (el) {\n    if (!ts.isIdentifier(el.expression)) {\n      return false;\n    }\n\n    return identifierIsMetadata(el.expression, ngMetadata, checker);\n  }); // Remove __metadata calls of type 'design:paramtypes'.\n\n  var metadataCalls = elements.filter(function (el) {\n    if (!isTslibHelper(el, '__metadata', tslibImports, checker)) {\n      return false;\n    }\n\n    if (el.arguments.length < 2 || !ts.isStringLiteral(el.arguments[0])) {\n      return false;\n    }\n\n    return true;\n  }); // Remove all __param calls.\n\n  var paramCalls = elements.filter(function (el) {\n    if (!isTslibHelper(el, '__param', tslibImports, checker)) {\n      return false;\n    }\n\n    if (el.arguments.length !== 2 || !ts.isNumericLiteral(el.arguments[0])) {\n      return false;\n    }\n\n    return true;\n  });\n\n  if (ngDecoratorCalls.length === 0) {\n    return [];\n  }\n\n  var callCount = ngDecoratorCalls.length + metadataCalls.length + paramCalls.length; // If all decorators are metadata decorators then return the whole `Class = __decorate([...])'`\n  // statement so that it is removed in entirety.\n  // If not then only remove the Angular decorators.\n  // The metadata and param calls may be used by the non-Angular decorators.\n\n  return elements.length === callCount ? [exprStmt] : ngDecoratorCalls;\n} // Remove Angular decorators from`Clazz.propDecorators = [...];`, or expression itself if all\n// are removed.\n\n\nfunction pickPropDecorationNodesToRemove(exprStmt, ngMetadata, checker) {\n  var expr = expect(exprStmt.expression, ts.SyntaxKind.BinaryExpression);\n  var literal = expect(expr.right, ts.SyntaxKind.ObjectLiteralExpression);\n\n  if (!literal.properties.every(function (elem) {\n    return ts.isPropertyAssignment(elem) && ts.isArrayLiteralExpression(elem.initializer);\n  })) {\n    return [];\n  }\n\n  var assignments = literal.properties; // Consider each assignment individually. Either the whole assignment will be removed or\n  // a particular decorator within will.\n\n  var toRemove = assignments.map(function (assign) {\n    var decorators = expect(assign.initializer, ts.SyntaxKind.ArrayLiteralExpression).elements;\n\n    if (!decorators.every(function (el) {\n      return ts.isObjectLiteralExpression(el);\n    })) {\n      return [];\n    }\n\n    var decsToRemove = decorators.filter(function (expression) {\n      var lit = expect(expression, ts.SyntaxKind.ObjectLiteralExpression);\n      return isAngularDecorator(lit, ngMetadata, checker);\n    });\n\n    if (decsToRemove.length === decorators.length) {\n      return [assign];\n    }\n\n    return decsToRemove;\n  }).reduce(function (accum, toRm) {\n    return accum.concat(toRm);\n  }, []); // If every node to be removed is a property assignment (full property's decorators) and\n  // all properties are accounted for, remove the whole assignment. Otherwise, remove the\n  // nodes which were marked as safe.\n\n  if (toRemove.length === assignments.length && toRemove.every(function (node) {\n    return ts.isPropertyAssignment(node);\n  })) {\n    return [exprStmt];\n  }\n\n  return toRemove;\n}\n\nfunction isAngularDecorator(literal, ngMetadata, checker) {\n  var types = literal.properties.filter(isTypeProperty);\n\n  if (types.length !== 1) {\n    return false;\n  }\n\n  var assign = expect(types[0], ts.SyntaxKind.PropertyAssignment);\n\n  if (!ts.isIdentifier(assign.initializer)) {\n    return false;\n  }\n\n  var id = assign.initializer;\n  var res = identifierIsMetadata(id, ngMetadata, checker);\n  return res;\n}\n\nfunction isTypeProperty(prop) {\n  if (!ts.isPropertyAssignment(prop)) {\n    return false;\n  }\n\n  if (!ts.isIdentifier(prop.name)) {\n    return false;\n  }\n\n  return prop.name.text === 'type';\n} // Check if an identifier is part of the known Angular Metadata.\n\n\nfunction identifierIsMetadata(id, metadata, checker) {\n  var symbol = checker.getSymbolAtLocation(id);\n\n  if (!symbol || !symbol.declarations || !symbol.declarations.length) {\n    return false;\n  }\n\n  return symbol.declarations.some(function (spec) {\n    return metadata.includes(spec);\n  });\n} // Find all named imports for `tslib`.\n\n\nfunction findTslibImports(node) {\n  var imports = [];\n  ts.forEachChild(node, function (child) {\n    var _a, _b;\n\n    if (ts.isImportDeclaration(child) && child.moduleSpecifier && ts.isStringLiteral(child.moduleSpecifier) && child.moduleSpecifier.text === 'tslib' && ((_a = child.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings) && ts.isNamedImports((_b = child.importClause) === null || _b === void 0 ? void 0 : _b.namedBindings)) {\n      imports.push(child.importClause.namedBindings);\n    }\n  });\n  return imports;\n} // Check if a function call is a tslib helper.\n\n\nfunction isTslibHelper(callExpr, helper, tslibImports, checker) {\n  var _a;\n\n  if (!ts.isIdentifier(callExpr.expression) || callExpr.expression.text !== helper) {\n    return false;\n  }\n\n  var symbol = checker.getSymbolAtLocation(callExpr.expression);\n\n  if (!((_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a.length)) {\n    return false;\n  }\n\n  var _iterator = _createForOfIteratorHelper(symbol.declarations),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var dec = _step.value;\n\n      if (ts.isImportSpecifier(dec) && tslibImports.some(function (name) {\n        return name.elements.includes(dec);\n      })) {\n        return {\n          v: true\n        };\n      } // Handle inline helpers `var __decorate = (this...`\n\n\n      if (ts.isVariableDeclaration(dec)) {\n        return {\n          v: true\n        };\n      }\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _ret = _loop();\n\n      if (typeof _ret === \"object\") return _ret.v;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-optimizer/src/transforms/scrub-file.js"],"names":["Object","defineProperty","exports","value","expect","createScrubFileTransformerFactory","testScrubFile","ts","require","ast_utils_1","content","markers","some","marker","includes","isAngularCoreFile","program","scrubFileTransformer","Error","checker","getTypeChecker","context","transformer","sf","ngMetadata","findAngularMetadata","tslibImports","findTslibImports","nodes","forEachChild","checkNodeForDecorators","node","_a","isExpressionStatement","exprStmt","iife","getIifeStatement","expression","isCtorParamsAssignmentExpression","push","isIvyPrivateCallExpression","isBinaryExpression","right","isDecoratorAssignmentExpression","pickDecorationNodesToRemove","isDecorateAssignmentExpression","isAngularDecoratorExpression","pickDecorateNodesToRemove","isPropDecoratorAssignmentExpression","pickPropDecorationNodesToRemove","visitor","find","n","undefined","visitEachChild","visitNode","kind","specs","child","SyntaxKind","ImportDeclaration","importDecl","isAngularCoreImport","collectDeepNodes","ImportSpecifier","localDecl","findAllDeclarations","concat","VariableStatement","vStmt","declarationList","declarations","forEach","decl","name","Identifier","moduleSpecifier","isStringLiteral","importText","text","startsWith","isAssignmentExpressionTo","expr","isArrayLiteralExpression","isIdentifier","left","classIdent","callExpr","isCallExpression","innerExpr","isTslibHelper","arguments","length","classArg","decorateArray","elements","decoratorCall","decoratorId","identifierIsMetadata","ObjectLiteralExpression","FunctionExpression","ArrowFunction","isPropertyAccessExpression","propAccess","operatorToken","FirstAssignment","parenExpr","isParenthesizedExpression","funExpr","isFunctionExpression","innerStmts","body","statements","innerExprStmt","propAccExpr","BinaryExpression","literal","ArrayLiteralExpression","every","elem","isObjectLiteralExpression","ngDecorators","filter","isAngularDecorator","arrLiteral","ngDecoratorCalls","el","metadataCalls","paramCalls","isNumericLiteral","callCount","properties","isPropertyAssignment","initializer","assignments","toRemove","map","assign","decorators","decsToRemove","lit","reduce","accum","toRm","types","isTypeProperty","PropertyAssignment","id","res","prop","metadata","symbol","getSymbolAtLocation","spec","imports","_b","isImportDeclaration","importClause","namedBindings","isNamedImports","helper","dec","isImportSpecifier","isVariableDeclaration"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expect = exports.createScrubFileTransformerFactory = exports.testScrubFile = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ts = require(\"typescript\");\nconst ast_utils_1 = require(\"../helpers/ast-utils\");\nfunction testScrubFile(content) {\n    const markers = [\n        'decorators',\n        '__decorate',\n        'propDecorators',\n        'ctorParameters',\n        'ɵsetClassMetadata',\n    ];\n    return markers.some((marker) => content.includes(marker));\n}\nexports.testScrubFile = testScrubFile;\nfunction createScrubFileTransformerFactory(isAngularCoreFile) {\n    return (program) => scrubFileTransformer(program, isAngularCoreFile);\n}\nexports.createScrubFileTransformerFactory = createScrubFileTransformerFactory;\nfunction scrubFileTransformer(program, isAngularCoreFile) {\n    if (!program) {\n        throw new Error('scrubFileTransformer requires a TypeScript Program.');\n    }\n    const checker = program.getTypeChecker();\n    return (context) => {\n        const transformer = (sf) => {\n            const ngMetadata = findAngularMetadata(sf, isAngularCoreFile);\n            const tslibImports = findTslibImports(sf);\n            const nodes = [];\n            ts.forEachChild(sf, checkNodeForDecorators);\n            function checkNodeForDecorators(node) {\n                var _a;\n                if (!ts.isExpressionStatement(node)) {\n                    return ts.forEachChild(node, checkNodeForDecorators);\n                }\n                const exprStmt = node;\n                const iife = (_a = getIifeStatement(exprStmt)) === null || _a === void 0 ? void 0 : _a.expression;\n                // Do checks that don't need the typechecker first and bail early.\n                if (isCtorParamsAssignmentExpression(exprStmt)) {\n                    nodes.push(node);\n                }\n                else if (iife && isIvyPrivateCallExpression(iife, 'ɵsetClassMetadata')) {\n                    nodes.push(node);\n                }\n                else if (iife &&\n                    ts.isBinaryExpression(iife) &&\n                    isIvyPrivateCallExpression(iife.right, 'ɵsetClassMetadata')) {\n                    nodes.push(node);\n                }\n                else if (isDecoratorAssignmentExpression(exprStmt)) {\n                    nodes.push(...pickDecorationNodesToRemove(exprStmt, ngMetadata, checker));\n                }\n                else if (isDecorateAssignmentExpression(exprStmt, tslibImports, checker) ||\n                    isAngularDecoratorExpression(exprStmt, ngMetadata, tslibImports, checker)) {\n                    nodes.push(...pickDecorateNodesToRemove(exprStmt, tslibImports, ngMetadata, checker));\n                }\n                else if (isPropDecoratorAssignmentExpression(exprStmt)) {\n                    nodes.push(...pickPropDecorationNodesToRemove(exprStmt, ngMetadata, checker));\n                }\n            }\n            const visitor = (node) => {\n                // Check if node is a statement to be dropped.\n                if (nodes.find((n) => n === node)) {\n                    return undefined;\n                }\n                // Otherwise return node as is.\n                return ts.visitEachChild(node, visitor, context);\n            };\n            return ts.visitNode(sf, visitor);\n        };\n        return transformer;\n    };\n}\nfunction expect(node, kind) {\n    if (node.kind !== kind) {\n        throw new Error('Invalid node type.');\n    }\n    return node;\n}\nexports.expect = expect;\nfunction findAngularMetadata(node, isAngularCoreFile) {\n    let specs = [];\n    // Find all specifiers from imports of `@angular/core`.\n    ts.forEachChild(node, (child) => {\n        if (child.kind === ts.SyntaxKind.ImportDeclaration) {\n            const importDecl = child;\n            if (isAngularCoreImport(importDecl, isAngularCoreFile)) {\n                specs.push(...ast_utils_1.collectDeepNodes(importDecl, ts.SyntaxKind.ImportSpecifier));\n            }\n        }\n    });\n    // If the current module is a Angular core file, we also consider all declarations in it to\n    // potentially be Angular metadata.\n    if (isAngularCoreFile) {\n        const localDecl = findAllDeclarations(node);\n        specs = specs.concat(localDecl);\n    }\n    return specs;\n}\nfunction findAllDeclarations(node) {\n    const nodes = [];\n    ts.forEachChild(node, (child) => {\n        if (child.kind === ts.SyntaxKind.VariableStatement) {\n            const vStmt = child;\n            vStmt.declarationList.declarations.forEach((decl) => {\n                if (decl.name.kind !== ts.SyntaxKind.Identifier) {\n                    return;\n                }\n                nodes.push(decl);\n            });\n        }\n    });\n    return nodes;\n}\nfunction isAngularCoreImport(node, isAngularCoreFile) {\n    if (!(node.moduleSpecifier && ts.isStringLiteral(node.moduleSpecifier))) {\n        return false;\n    }\n    const importText = node.moduleSpecifier.text;\n    // Imports to `@angular/core` are always core imports.\n    if (importText === '@angular/core') {\n        return true;\n    }\n    // Relative imports from a Angular core file are also core imports.\n    if (isAngularCoreFile && importText.startsWith('.')) {\n        return true;\n    }\n    return false;\n}\n// Check if assignment is `Clazz.decorators = [...];`.\nfunction isDecoratorAssignmentExpression(exprStmt) {\n    if (!isAssignmentExpressionTo(exprStmt, 'decorators')) {\n        return false;\n    }\n    const expr = exprStmt.expression;\n    if (!ts.isArrayLiteralExpression(expr.right)) {\n        return false;\n    }\n    return true;\n}\n// Check if assignment is `Clazz = __decorate([...], Clazz)`.\nfunction isDecorateAssignmentExpression(exprStmt, tslibImports, checker) {\n    if (!ts.isBinaryExpression(exprStmt.expression)) {\n        return false;\n    }\n    const expr = exprStmt.expression;\n    if (!ts.isIdentifier(expr.left)) {\n        return false;\n    }\n    const classIdent = expr.left;\n    let callExpr;\n    if (ts.isCallExpression(expr.right)) {\n        callExpr = expr.right;\n    }\n    else if (ts.isBinaryExpression(expr.right)) {\n        // `Clazz = Clazz_1 = __decorate([...], Clazz)` can be found when there are static property\n        // accesses.\n        const innerExpr = expr.right;\n        if (!ts.isIdentifier(innerExpr.left) || !ts.isCallExpression(innerExpr.right)) {\n            return false;\n        }\n        callExpr = innerExpr.right;\n    }\n    else {\n        return false;\n    }\n    if (!isTslibHelper(callExpr, '__decorate', tslibImports, checker)) {\n        return false;\n    }\n    if (callExpr.arguments.length !== 2) {\n        return false;\n    }\n    const classArg = callExpr.arguments[1];\n    if (!ts.isIdentifier(classArg)) {\n        return false;\n    }\n    if (classIdent.text !== classArg.text) {\n        return false;\n    }\n    if (!ts.isArrayLiteralExpression(callExpr.arguments[0])) {\n        return false;\n    }\n    return true;\n}\n// Check if expression is `__decorate([smt, __metadata(\"design:type\", Object)], ...)`.\nfunction isAngularDecoratorExpression(exprStmt, ngMetadata, tslibImports, checker) {\n    if (!ts.isCallExpression(exprStmt.expression)) {\n        return false;\n    }\n    const callExpr = exprStmt.expression;\n    if (!isTslibHelper(callExpr, '__decorate', tslibImports, checker)) {\n        return false;\n    }\n    if (callExpr.arguments.length !== 4) {\n        return false;\n    }\n    const decorateArray = callExpr.arguments[0];\n    if (!ts.isArrayLiteralExpression(decorateArray)) {\n        return false;\n    }\n    // Check first array entry for Angular decorators.\n    if (decorateArray.elements.length === 0 || !ts.isCallExpression(decorateArray.elements[0])) {\n        return false;\n    }\n    return decorateArray.elements.some(decoratorCall => {\n        if (!ts.isCallExpression(decoratorCall) || !ts.isIdentifier(decoratorCall.expression)) {\n            return false;\n        }\n        const decoratorId = decoratorCall.expression;\n        return identifierIsMetadata(decoratorId, ngMetadata, checker);\n    });\n}\n// Check if assignment is `Clazz.propDecorators = [...];`.\nfunction isPropDecoratorAssignmentExpression(exprStmt) {\n    if (!isAssignmentExpressionTo(exprStmt, 'propDecorators')) {\n        return false;\n    }\n    const expr = exprStmt.expression;\n    if (expr.right.kind !== ts.SyntaxKind.ObjectLiteralExpression) {\n        return false;\n    }\n    return true;\n}\n// Check if assignment is `Clazz.ctorParameters = [...];`.\nfunction isCtorParamsAssignmentExpression(exprStmt) {\n    if (!isAssignmentExpressionTo(exprStmt, 'ctorParameters')) {\n        return false;\n    }\n    const expr = exprStmt.expression;\n    if (expr.right.kind !== ts.SyntaxKind.FunctionExpression\n        && expr.right.kind !== ts.SyntaxKind.ArrowFunction) {\n        return false;\n    }\n    return true;\n}\nfunction isAssignmentExpressionTo(exprStmt, name) {\n    if (!ts.isBinaryExpression(exprStmt.expression)) {\n        return false;\n    }\n    const expr = exprStmt.expression;\n    if (!ts.isPropertyAccessExpression(expr.left)) {\n        return false;\n    }\n    const propAccess = expr.left;\n    if (propAccess.name.text !== name) {\n        return false;\n    }\n    if (!ts.isIdentifier(propAccess.expression)) {\n        return false;\n    }\n    if (expr.operatorToken.kind !== ts.SyntaxKind.FirstAssignment) {\n        return false;\n    }\n    return true;\n}\n// Each Ivy private call expression is inside an IIFE\nfunction getIifeStatement(exprStmt) {\n    const expression = exprStmt.expression;\n    if (!expression || !ts.isCallExpression(expression) || expression.arguments.length !== 0) {\n        return null;\n    }\n    const parenExpr = expression;\n    if (!ts.isParenthesizedExpression(parenExpr.expression)) {\n        return null;\n    }\n    const funExpr = parenExpr.expression.expression;\n    if (!ts.isFunctionExpression(funExpr)) {\n        return null;\n    }\n    const innerStmts = funExpr.body.statements;\n    if (innerStmts.length !== 1) {\n        return null;\n    }\n    const innerExprStmt = innerStmts[0];\n    if (!ts.isExpressionStatement(innerExprStmt)) {\n        return null;\n    }\n    return innerExprStmt;\n}\nfunction isIvyPrivateCallExpression(expression, name) {\n    // Now we're in the IIFE and have the inner expression statement. We can check if it matches\n    // a private Ivy call.\n    if (!ts.isCallExpression(expression)) {\n        return false;\n    }\n    const propAccExpr = expression.expression;\n    if (!ts.isPropertyAccessExpression(propAccExpr)) {\n        return false;\n    }\n    if (propAccExpr.name.text != name) {\n        return false;\n    }\n    return true;\n}\n// Remove Angular decorators from`Clazz.decorators = [...];`, or expression itself if all are\n// removed.\nfunction pickDecorationNodesToRemove(exprStmt, ngMetadata, checker) {\n    const expr = expect(exprStmt.expression, ts.SyntaxKind.BinaryExpression);\n    const literal = expect(expr.right, ts.SyntaxKind.ArrayLiteralExpression);\n    if (!literal.elements.every(elem => ts.isObjectLiteralExpression(elem))) {\n        return [];\n    }\n    const elements = literal.elements;\n    const ngDecorators = elements.filter((elem) => isAngularDecorator(elem, ngMetadata, checker));\n    return (elements.length > ngDecorators.length) ? ngDecorators : [exprStmt];\n}\n// Remove Angular decorators from `Clazz = __decorate([...], Clazz)`, or expression itself if all\n// are removed.\nfunction pickDecorateNodesToRemove(exprStmt, tslibImports, ngMetadata, checker) {\n    let callExpr;\n    if (ts.isCallExpression(exprStmt.expression)) {\n        callExpr = exprStmt.expression;\n    }\n    else if (ts.isBinaryExpression(exprStmt.expression)) {\n        const expr = exprStmt.expression;\n        if (ts.isCallExpression(expr.right)) {\n            callExpr = expr.right;\n        }\n        else if (ts.isBinaryExpression(expr.right) && ts.isCallExpression(expr.right.right)) {\n            callExpr = expr.right.right;\n        }\n    }\n    if (!callExpr) {\n        return [];\n    }\n    const arrLiteral = expect(callExpr.arguments[0], ts.SyntaxKind.ArrayLiteralExpression);\n    if (!arrLiteral.elements.every((elem) => ts.isCallExpression(elem))) {\n        return [];\n    }\n    const elements = arrLiteral.elements;\n    const ngDecoratorCalls = elements.filter((el) => {\n        if (!ts.isIdentifier(el.expression)) {\n            return false;\n        }\n        return identifierIsMetadata(el.expression, ngMetadata, checker);\n    });\n    // Remove __metadata calls of type 'design:paramtypes'.\n    const metadataCalls = elements.filter((el) => {\n        if (!isTslibHelper(el, '__metadata', tslibImports, checker)) {\n            return false;\n        }\n        if (el.arguments.length < 2 || !ts.isStringLiteral(el.arguments[0])) {\n            return false;\n        }\n        return true;\n    });\n    // Remove all __param calls.\n    const paramCalls = elements.filter((el) => {\n        if (!isTslibHelper(el, '__param', tslibImports, checker)) {\n            return false;\n        }\n        if (el.arguments.length !== 2 || !ts.isNumericLiteral(el.arguments[0])) {\n            return false;\n        }\n        return true;\n    });\n    if (ngDecoratorCalls.length === 0) {\n        return [];\n    }\n    const callCount = ngDecoratorCalls.length + metadataCalls.length + paramCalls.length;\n    // If all decorators are metadata decorators then return the whole `Class = __decorate([...])'`\n    // statement so that it is removed in entirety.\n    // If not then only remove the Angular decorators.\n    // The metadata and param calls may be used by the non-Angular decorators.\n    return (elements.length === callCount) ? [exprStmt] : ngDecoratorCalls;\n}\n// Remove Angular decorators from`Clazz.propDecorators = [...];`, or expression itself if all\n// are removed.\nfunction pickPropDecorationNodesToRemove(exprStmt, ngMetadata, checker) {\n    const expr = expect(exprStmt.expression, ts.SyntaxKind.BinaryExpression);\n    const literal = expect(expr.right, ts.SyntaxKind.ObjectLiteralExpression);\n    if (!literal.properties.every(elem => ts.isPropertyAssignment(elem)\n        && ts.isArrayLiteralExpression(elem.initializer))) {\n        return [];\n    }\n    const assignments = literal.properties;\n    // Consider each assignment individually. Either the whole assignment will be removed or\n    // a particular decorator within will.\n    const toRemove = assignments\n        .map((assign) => {\n        const decorators = expect(assign.initializer, ts.SyntaxKind.ArrayLiteralExpression).elements;\n        if (!decorators.every((el) => ts.isObjectLiteralExpression(el))) {\n            return [];\n        }\n        const decsToRemove = decorators.filter((expression) => {\n            const lit = expect(expression, ts.SyntaxKind.ObjectLiteralExpression);\n            return isAngularDecorator(lit, ngMetadata, checker);\n        });\n        if (decsToRemove.length === decorators.length) {\n            return [assign];\n        }\n        return decsToRemove;\n    })\n        .reduce((accum, toRm) => accum.concat(toRm), []);\n    // If every node to be removed is a property assignment (full property's decorators) and\n    // all properties are accounted for, remove the whole assignment. Otherwise, remove the\n    // nodes which were marked as safe.\n    if (toRemove.length === assignments.length && toRemove.every((node) => ts.isPropertyAssignment(node))) {\n        return [exprStmt];\n    }\n    return toRemove;\n}\nfunction isAngularDecorator(literal, ngMetadata, checker) {\n    const types = literal.properties.filter(isTypeProperty);\n    if (types.length !== 1) {\n        return false;\n    }\n    const assign = expect(types[0], ts.SyntaxKind.PropertyAssignment);\n    if (!ts.isIdentifier(assign.initializer)) {\n        return false;\n    }\n    const id = assign.initializer;\n    const res = identifierIsMetadata(id, ngMetadata, checker);\n    return res;\n}\nfunction isTypeProperty(prop) {\n    if (!ts.isPropertyAssignment(prop)) {\n        return false;\n    }\n    if (!ts.isIdentifier(prop.name)) {\n        return false;\n    }\n    return prop.name.text === 'type';\n}\n// Check if an identifier is part of the known Angular Metadata.\nfunction identifierIsMetadata(id, metadata, checker) {\n    const symbol = checker.getSymbolAtLocation(id);\n    if (!symbol || !symbol.declarations || !symbol.declarations.length) {\n        return false;\n    }\n    return symbol\n        .declarations\n        .some((spec) => metadata.includes(spec));\n}\n// Find all named imports for `tslib`.\nfunction findTslibImports(node) {\n    const imports = [];\n    ts.forEachChild(node, child => {\n        var _a, _b;\n        if (ts.isImportDeclaration(child) &&\n            child.moduleSpecifier &&\n            ts.isStringLiteral(child.moduleSpecifier) &&\n            child.moduleSpecifier.text === 'tslib' && ((_a = child.importClause) === null || _a === void 0 ? void 0 : _a.namedBindings) &&\n            ts.isNamedImports((_b = child.importClause) === null || _b === void 0 ? void 0 : _b.namedBindings)) {\n            imports.push(child.importClause.namedBindings);\n        }\n    });\n    return imports;\n}\n// Check if a function call is a tslib helper.\nfunction isTslibHelper(callExpr, helper, tslibImports, checker) {\n    var _a;\n    if (!ts.isIdentifier(callExpr.expression) || callExpr.expression.text !== helper) {\n        return false;\n    }\n    const symbol = checker.getSymbolAtLocation(callExpr.expression);\n    if (!((_a = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _a === void 0 ? void 0 : _a.length)) {\n        return false;\n    }\n    for (const dec of symbol.declarations) {\n        if (ts.isImportSpecifier(dec) && tslibImports.some(name => name.elements.includes(dec))) {\n            return true;\n        }\n        // Handle inline helpers `var __decorate = (this...`\n        if (ts.isVariableDeclaration(dec)) {\n            return true;\n        }\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}