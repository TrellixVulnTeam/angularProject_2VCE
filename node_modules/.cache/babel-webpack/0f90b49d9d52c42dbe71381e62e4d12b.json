{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/template\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/compiler_util/expression_converter\", \"@angular/compiler/src/core\", \"@angular/compiler/src/expression_parser/ast\", \"@angular/compiler/src/expression_parser/lexer\", \"@angular/compiler/src/expression_parser/parser\", \"@angular/compiler/src/ml_parser/ast\", \"@angular/compiler/src/ml_parser/html_parser\", \"@angular/compiler/src/ml_parser/html_whitespaces\", \"@angular/compiler/src/ml_parser/interpolation_config\", \"@angular/compiler/src/ml_parser/tags\", \"@angular/compiler/src/output/map_util\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/schema/dom_element_schema_registry\", \"@angular/compiler/src/schema/trusted_types_sinks\", \"@angular/compiler/src/selector\", \"@angular/compiler/src/template_parser/binding_parser\", \"@angular/compiler/src/util\", \"@angular/compiler/src/render3/r3_ast\", \"@angular/compiler/src/render3/r3_identifiers\", \"@angular/compiler/src/render3/r3_template_transform\", \"@angular/compiler/src/render3/util\", \"@angular/compiler/src/render3/view/i18n/context\", \"@angular/compiler/src/render3/view/i18n/get_msg_utils\", \"@angular/compiler/src/render3/view/i18n/localize_utils\", \"@angular/compiler/src/render3/view/i18n/meta\", \"@angular/compiler/src/render3/view/i18n/util\", \"@angular/compiler/src/render3/view/styling_builder\", \"@angular/compiler/src/render3/view/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getTranslationDeclStmts = exports.resolveSanitizationFn = exports.makeBindingParser = exports.parseTemplate = exports.createCssSelector = exports.BindingScope = exports.ValueConverter = exports.TemplateDefinitionBuilder = exports.prepareEventListenerParameters = exports.renderFlagCheckIfStmt = exports.LEADING_TRIVIA_CHARS = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var expression_converter_1 = require(\"@angular/compiler/src/compiler_util/expression_converter\");\n\n  var core = require(\"@angular/compiler/src/core\");\n\n  var ast_1 = require(\"@angular/compiler/src/expression_parser/ast\");\n\n  var lexer_1 = require(\"@angular/compiler/src/expression_parser/lexer\");\n\n  var parser_1 = require(\"@angular/compiler/src/expression_parser/parser\");\n\n  var html = require(\"@angular/compiler/src/ml_parser/ast\");\n\n  var html_parser_1 = require(\"@angular/compiler/src/ml_parser/html_parser\");\n\n  var html_whitespaces_1 = require(\"@angular/compiler/src/ml_parser/html_whitespaces\");\n\n  var interpolation_config_1 = require(\"@angular/compiler/src/ml_parser/interpolation_config\");\n\n  var tags_1 = require(\"@angular/compiler/src/ml_parser/tags\");\n\n  var map_util_1 = require(\"@angular/compiler/src/output/map_util\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var dom_element_schema_registry_1 = require(\"@angular/compiler/src/schema/dom_element_schema_registry\");\n\n  var trusted_types_sinks_1 = require(\"@angular/compiler/src/schema/trusted_types_sinks\");\n\n  var selector_1 = require(\"@angular/compiler/src/selector\");\n\n  var binding_parser_1 = require(\"@angular/compiler/src/template_parser/binding_parser\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var t = require(\"@angular/compiler/src/render3/r3_ast\");\n\n  var r3_identifiers_1 = require(\"@angular/compiler/src/render3/r3_identifiers\");\n\n  var r3_template_transform_1 = require(\"@angular/compiler/src/render3/r3_template_transform\");\n\n  var util_2 = require(\"@angular/compiler/src/render3/util\");\n\n  var context_1 = require(\"@angular/compiler/src/render3/view/i18n/context\");\n\n  var get_msg_utils_1 = require(\"@angular/compiler/src/render3/view/i18n/get_msg_utils\");\n\n  var localize_utils_1 = require(\"@angular/compiler/src/render3/view/i18n/localize_utils\");\n\n  var meta_1 = require(\"@angular/compiler/src/render3/view/i18n/meta\");\n\n  var util_3 = require(\"@angular/compiler/src/render3/view/i18n/util\");\n\n  var styling_builder_1 = require(\"@angular/compiler/src/render3/view/styling_builder\");\n\n  var util_4 = require(\"@angular/compiler/src/render3/view/util\"); // Selector attribute name of `<ng-content>`\n\n\n  var NG_CONTENT_SELECT_ATTR = 'select'; // Attribute name of `ngProjectAs`.\n\n  var NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs'; // Global symbols available only inside event bindings.\n\n  var EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']); // List of supported global targets for event listeners\n\n  var GLOBAL_TARGET_RESOLVERS = new Map([['window', r3_identifiers_1.Identifiers.resolveWindow], ['document', r3_identifiers_1.Identifiers.resolveDocument], ['body', r3_identifiers_1.Identifiers.resolveBody]]);\n  exports.LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t']; //  if (rf & flags) { .. }\n\n  function renderFlagCheckIfStmt(flags, statements) {\n    return o.ifStmt(o.variable(util_4.RENDER_FLAGS).bitwiseAnd(o.literal(flags), null, false), statements);\n  }\n\n  exports.renderFlagCheckIfStmt = renderFlagCheckIfStmt;\n\n  function prepareEventListenerParameters(eventAst, handlerName, scope) {\n    if (handlerName === void 0) {\n      handlerName = null;\n    }\n\n    if (scope === void 0) {\n      scope = null;\n    }\n\n    var type = eventAst.type,\n        name = eventAst.name,\n        target = eventAst.target,\n        phase = eventAst.phase,\n        handler = eventAst.handler;\n\n    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n      throw new Error(\"Unexpected global target '\" + target + \"' defined for '\" + name + \"' event.\\n        Supported list of global targets: \" + Array.from(GLOBAL_TARGET_RESOLVERS.keys()) + \".\");\n    }\n\n    var eventArgumentName = '$event';\n    var implicitReceiverAccesses = new Set();\n    var implicitReceiverExpr = scope === null || scope.bindingLevel === 0 ? o.variable(util_4.CONTEXT_NAME) : scope.getOrCreateSharedContextVar(0);\n    var bindingExpr = expression_converter_1.convertActionBinding(scope, implicitReceiverExpr, handler, 'b', function () {\n      return util_1.error('Unexpected interpolation');\n    }, eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);\n    var statements = [];\n\n    if (scope) {\n      statements.push.apply(statements, tslib_1.__spread(scope.restoreViewStatement()));\n      statements.push.apply(statements, tslib_1.__spread(scope.variableDeclarations()));\n    }\n\n    statements.push.apply(statements, tslib_1.__spread(bindingExpr.render3Stmts));\n    var eventName = type === 1\n    /* Animation */\n    ? util_2.prepareSyntheticListenerName(name, phase) : name;\n    var fnName = handlerName && compile_metadata_1.sanitizeIdentifier(handlerName);\n    var fnArgs = [];\n\n    if (implicitReceiverAccesses.has(eventArgumentName)) {\n      fnArgs.push(new o.FnParam(eventArgumentName, o.DYNAMIC_TYPE));\n    }\n\n    var handlerFn = o.fn(fnArgs, statements, o.INFERRED_TYPE, null, fnName);\n    var params = [o.literal(eventName), handlerFn];\n\n    if (target) {\n      params.push(o.literal(false), // `useCapture` flag, defaults to `false`\n      o.importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\n    }\n\n    return params;\n  }\n\n  exports.prepareEventListenerParameters = prepareEventListenerParameters;\n\n  function createComponentDefConsts() {\n    return {\n      prepareStatements: [],\n      constExpressions: [],\n      i18nVarRefsCache: new Map()\n    };\n  }\n\n  var TemplateDefinitionBuilder =\n  /** @class */\n  function () {\n    function TemplateDefinitionBuilder(constantPool, parentBindingScope, level, contextName, i18nContext, templateIndex, templateName, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants) {\n      var _this = this;\n\n      if (level === void 0) {\n        level = 0;\n      }\n\n      if (_constants === void 0) {\n        _constants = createComponentDefConsts();\n      }\n\n      this.constantPool = constantPool;\n      this.level = level;\n      this.contextName = contextName;\n      this.i18nContext = i18nContext;\n      this.templateIndex = templateIndex;\n      this.templateName = templateName;\n      this.directiveMatcher = directiveMatcher;\n      this.directives = directives;\n      this.pipeTypeByName = pipeTypeByName;\n      this.pipes = pipes;\n      this._namespace = _namespace;\n      this.i18nUseExternalIds = i18nUseExternalIds;\n      this._constants = _constants;\n      this._dataIndex = 0;\n      this._bindingContext = 0;\n      this._prefixCode = [];\n      /**\n       * List of callbacks to generate creation mode instructions. We store them here as we process\n       * the template so bindings in listeners are resolved only once all nodes have been visited.\n       * This ensures all local refs and context variables are available for matching.\n       */\n\n      this._creationCodeFns = [];\n      /**\n       * List of callbacks to generate update mode instructions. We store them here as we process\n       * the template so bindings are resolved only once all nodes have been visited. This ensures\n       * all local refs and context variables are available for matching.\n       */\n\n      this._updateCodeFns = [];\n      /** Index of the currently-selected node. */\n\n      this._currentIndex = 0;\n      /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n\n      this._tempVariables = [];\n      /**\n       * List of callbacks to build nested templates. Nested templates must not be visited until\n       * after the parent template has finished visiting all of its nodes. This ensures that all\n       * local ref bindings in nested templates are able to find local ref values if the refs\n       * are defined after the template declaration.\n       */\n\n      this._nestedTemplateFns = [];\n      this._unsupported = util_4.unsupported; // i18n context local to this template\n\n      this.i18n = null; // Number of slots to reserve for pureFunctions\n\n      this._pureFunctionSlots = 0; // Number of binding slots\n\n      this._bindingSlots = 0; // Projection slots found in the template. Projection slots can distribute projected\n      // nodes based on a selector, or can just use the wildcard selector to match\n      // all nodes which aren't matching any selector.\n\n      this._ngContentReservedSlots = []; // Number of non-default selectors found in all parent templates of this template. We need to\n      // track it to properly adjust projection slot index in the `projection` instruction.\n\n      this._ngContentSelectorsOffset = 0; // Expression that should be used as implicit receiver when converting template\n      // expressions to output AST.\n\n      this._implicitReceiverExpr = null; // These should be handled in the template or element directly.\n\n      this.visitReference = util_4.invalid;\n      this.visitVariable = util_4.invalid;\n      this.visitTextAttribute = util_4.invalid;\n      this.visitBoundAttribute = util_4.invalid;\n      this.visitBoundEvent = util_4.invalid;\n      this._bindingScope = parentBindingScope.nestedScope(level); // Turn the relative context file path into an identifier by replacing non-alphanumeric\n      // characters with underscores.\n\n      this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n      this._valueConverter = new ValueConverter(constantPool, function () {\n        return _this.allocateDataSlot();\n      }, function (numSlots) {\n        return _this.allocatePureFunctionSlots(numSlots);\n      }, function (name, localName, slot, value) {\n        var pipeType = pipeTypeByName.get(name);\n\n        if (pipeType) {\n          _this.pipes.add(pipeType);\n        }\n\n        _this._bindingScope.set(_this.level, localName, value);\n\n        _this.creationInstruction(null, r3_identifiers_1.Identifiers.pipe, [o.literal(slot), o.literal(name)]);\n      });\n    }\n\n    TemplateDefinitionBuilder.prototype.buildTemplateFunction = function (nodes, variables, ngContentSelectorsOffset, i18n) {\n      var _this = this;\n\n      if (ngContentSelectorsOffset === void 0) {\n        ngContentSelectorsOffset = 0;\n      }\n\n      this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n\n      if (this._namespace !== r3_identifiers_1.Identifiers.namespaceHTML) {\n        this.creationInstruction(null, this._namespace);\n      } // Create variable bindings\n\n\n      variables.forEach(function (v) {\n        return _this.registerContextVariables(v);\n      }); // Initiate i18n context in case:\n      // - this template has parent i18n context\n      // - or the template has i18n meta associated with it,\n      //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n\n      var initI18nContext = this.i18nContext || util_3.isI18nRootNode(i18n) && !util_3.isSingleI18nIcu(i18n) && !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n);\n      var selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n\n      if (initI18nContext) {\n        this.i18nStart(null, i18n, selfClosingI18nInstruction);\n      } // This is the initial pass through the nodes of this template. In this pass, we\n      // queue all creation mode and update mode instructions for generation in the second\n      // pass. It's necessary to separate the passes to ensure local refs are defined before\n      // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n\n\n      t.visitAll(this, nodes); // Add total binding count to pure function count so pure function instructions are\n      // generated with the correct slot offset when update instructions are processed.\n\n      this._pureFunctionSlots += this._bindingSlots; // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n      // `pipeBind` update instructions), so we have to update the slot offsets manually\n      // to account for bindings.\n\n      this._valueConverter.updatePipeSlotOffsets(this._bindingSlots); // Nested templates must be processed before creation instructions so template()\n      // instructions can be generated with the correct internal const count.\n\n\n      this._nestedTemplateFns.forEach(function (buildTemplateFn) {\n        return buildTemplateFn();\n      }); // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n      // The `projectionDef` instruction is only emitted for the component template and\n      // is skipped for nested templates (<ng-template> tags).\n\n\n      if (this.level === 0 && this._ngContentReservedSlots.length) {\n        var parameters = []; // By default the `projectionDef` instructions creates one slot for the wildcard\n        // selector if no parameters are passed. Therefore we only want to allocate a new\n        // array for the projection slots if the default projection slot is not sufficient.\n\n        if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n          var r3ReservedSlots = this._ngContentReservedSlots.map(function (s) {\n            return s !== '*' ? core.parseSelectorToR3Selector(s) : s;\n          });\n\n          parameters.push(this.constantPool.getConstLiteral(util_4.asLiteral(r3ReservedSlots), true));\n        } // Since we accumulate ngContent selectors while processing template elements,\n        // we *prepend* `projectionDef` to creation instructions block, to put it before\n        // any `projection` instructions\n\n\n        this.creationInstruction(null, r3_identifiers_1.Identifiers.projectionDef, parameters,\n        /* prepend */\n        true);\n      }\n\n      if (initI18nContext) {\n        this.i18nEnd(null, selfClosingI18nInstruction);\n      } // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n\n\n      var creationStatements = this._creationCodeFns.map(function (fn) {\n        return fn();\n      }); // Generate all the update mode instructions (e.g. resolve property or text bindings)\n\n\n      var updateStatements = this._updateCodeFns.map(function (fn) {\n        return fn();\n      }); //  Variable declaration must occur after binding resolution so we can generate context\n      //  instructions that build on each other.\n      // e.g. const b = nextContext().$implicit(); const b = nextContext();\n\n\n      var creationVariables = this._bindingScope.viewSnapshotStatements();\n\n      var updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n\n      var creationBlock = creationStatements.length > 0 ? [renderFlagCheckIfStmt(1\n      /* Create */\n      , creationVariables.concat(creationStatements))] : [];\n      var updateBlock = updateStatements.length > 0 ? [renderFlagCheckIfStmt(2\n      /* Update */\n      , updateVariables.concat(updateStatements))] : [];\n      return o.fn( // i.e. (rf: RenderFlags, ctx: any)\n      [new o.FnParam(util_4.RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(util_4.CONTEXT_NAME, null)], tslib_1.__spread(this._prefixCode, creationBlock, updateBlock), o.INFERRED_TYPE, null, this.templateName);\n    }; // LocalResolver\n\n\n    TemplateDefinitionBuilder.prototype.getLocal = function (name) {\n      return this._bindingScope.get(name);\n    }; // LocalResolver\n\n\n    TemplateDefinitionBuilder.prototype.notifyImplicitReceiverUse = function () {\n      this._bindingScope.notifyImplicitReceiverUse();\n    };\n\n    TemplateDefinitionBuilder.prototype.i18nTranslate = function (message, params, ref, transformFn) {\n      var _a;\n\n      if (params === void 0) {\n        params = {};\n      }\n\n      var _ref = ref || this.i18nGenerateMainBlockVar(); // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n      // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n\n\n      var closureVar = this.i18nGenerateClosureVar(message.id);\n      var statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n\n      (_a = this._constants.prepareStatements).push.apply(_a, tslib_1.__spread(statements));\n\n      return _ref;\n    };\n\n    TemplateDefinitionBuilder.prototype.registerContextVariables = function (variable) {\n      var scopedName = this._bindingScope.freshReferenceName();\n\n      var retrievalLevel = this.level;\n      var lhs = o.variable(variable.name + scopedName);\n\n      this._bindingScope.set(retrievalLevel, variable.name, lhs, 1\n      /* CONTEXT */\n      , function (scope, relativeLevel) {\n        var rhs;\n\n        if (scope.bindingLevel === retrievalLevel) {\n          // e.g. ctx\n          rhs = o.variable(util_4.CONTEXT_NAME);\n        } else {\n          var sharedCtxVar = scope.getSharedContextName(retrievalLevel); // e.g. ctx_r0   OR  x(2);\n\n          rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n        } // e.g. const $item$ = x(2).$implicit;\n\n\n        return [lhs.set(rhs.prop(variable.value || util_4.IMPLICIT_REFERENCE)).toConstDecl()];\n      });\n    };\n\n    TemplateDefinitionBuilder.prototype.i18nAppendBindings = function (expressions) {\n      var _this = this;\n\n      if (expressions.length > 0) {\n        expressions.forEach(function (expression) {\n          return _this.i18n.appendBinding(expression);\n        });\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.i18nBindProps = function (props) {\n      var _this = this;\n\n      var bound = {};\n      Object.keys(props).forEach(function (key) {\n        var prop = props[key];\n\n        if (prop instanceof t.Text) {\n          bound[key] = o.literal(prop.value);\n        } else {\n          var value = prop.value.visit(_this._valueConverter);\n\n          _this.allocateBindingSlots(value);\n\n          if (value instanceof ast_1.Interpolation) {\n            var strings = value.strings,\n                expressions = value.expressions;\n            var _a = _this.i18n,\n                id = _a.id,\n                bindings = _a.bindings;\n            var label = util_3.assembleI18nBoundString(strings, bindings.size, id);\n\n            _this.i18nAppendBindings(expressions);\n\n            bound[key] = o.literal(label);\n          }\n        }\n      });\n      return bound;\n    }; // Generates top level vars for i18n blocks (i.e. `i18n_N`).\n\n\n    TemplateDefinitionBuilder.prototype.i18nGenerateMainBlockVar = function () {\n      return o.variable(this.constantPool.uniqueName(util_3.TRANSLATION_VAR_PREFIX));\n    }; // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n\n\n    TemplateDefinitionBuilder.prototype.i18nGenerateClosureVar = function (messageId) {\n      var name;\n      var suffix = this.fileBasedI18nSuffix.toUpperCase();\n\n      if (this.i18nUseExternalIds) {\n        var prefix = util_3.getTranslationConstPrefix(\"EXTERNAL_\");\n        var uniqueSuffix = this.constantPool.uniqueName(suffix);\n        name = \"\" + prefix + compile_metadata_1.sanitizeIdentifier(messageId) + \"$$\" + uniqueSuffix;\n      } else {\n        var prefix = util_3.getTranslationConstPrefix(suffix);\n        name = this.constantPool.uniqueName(prefix);\n      }\n\n      return o.variable(name);\n    };\n\n    TemplateDefinitionBuilder.prototype.i18nUpdateRef = function (context) {\n      var icus = context.icus,\n          meta = context.meta,\n          isRoot = context.isRoot,\n          isResolved = context.isResolved,\n          isEmitted = context.isEmitted;\n\n      if (isRoot && isResolved && !isEmitted && !util_3.isSingleI18nIcu(meta)) {\n        context.isEmitted = true;\n        var placeholders = context.getSerializedPlaceholders();\n        var icuMapping_1 = {};\n        var params_1 = placeholders.size ? util_3.placeholdersToParams(placeholders) : {};\n\n        if (icus.size) {\n          icus.forEach(function (refs, key) {\n            if (refs.length === 1) {\n              // if we have one ICU defined for a given\n              // placeholder - just output its reference\n              params_1[key] = refs[0];\n            } else {\n              // ... otherwise we need to activate post-processing\n              // to replace ICU placeholders with proper values\n              var placeholder = util_3.wrapI18nPlaceholder(\"\" + util_3.I18N_ICU_MAPPING_PREFIX + key);\n              params_1[key] = o.literal(placeholder);\n              icuMapping_1[key] = o.literalArr(refs);\n            }\n          });\n        } // translation requires post processing in 2 cases:\n        // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])\n        // - if we have multiple ICUs that refer to the same placeholder name\n\n\n        var needsPostprocessing = Array.from(placeholders.values()).some(function (value) {\n          return value.length > 1;\n        }) || Object.keys(icuMapping_1).length;\n        var transformFn = void 0;\n\n        if (needsPostprocessing) {\n          transformFn = function transformFn(raw) {\n            var args = [raw];\n\n            if (Object.keys(icuMapping_1).length) {\n              args.push(map_util_1.mapLiteral(icuMapping_1, true));\n            }\n\n            return instruction(null, r3_identifiers_1.Identifiers.i18nPostprocess, args);\n          };\n        }\n\n        this.i18nTranslate(meta, params_1, context.ref, transformFn);\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.i18nStart = function (span, meta, selfClosing) {\n      if (span === void 0) {\n        span = null;\n      }\n\n      var index = this.allocateDataSlot();\n      this.i18n = this.i18nContext ? this.i18nContext.forkChildContext(index, this.templateIndex, meta) : new context_1.I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta); // generate i18nStart instruction\n\n      var _a = this.i18n,\n          id = _a.id,\n          ref = _a.ref;\n      var params = [o.literal(index), this.addToConsts(ref)];\n\n      if (id > 0) {\n        // do not push 3rd argument (sub-block id)\n        // into i18nStart call for top level i18n context\n        params.push(o.literal(id));\n      }\n\n      this.creationInstruction(span, selfClosing ? r3_identifiers_1.Identifiers.i18n : r3_identifiers_1.Identifiers.i18nStart, params);\n    };\n\n    TemplateDefinitionBuilder.prototype.i18nEnd = function (span, selfClosing) {\n      var _this = this;\n\n      if (span === void 0) {\n        span = null;\n      }\n\n      if (!this.i18n) {\n        throw new Error('i18nEnd is executed with no i18n context present');\n      }\n\n      if (this.i18nContext) {\n        this.i18nContext.reconcileChildContext(this.i18n);\n        this.i18nUpdateRef(this.i18nContext);\n      } else {\n        this.i18nUpdateRef(this.i18n);\n      } // setup accumulated bindings\n\n\n      var _a = this.i18n,\n          index = _a.index,\n          bindings = _a.bindings;\n\n      if (bindings.size) {\n        var chainBindings_1 = [];\n        bindings.forEach(function (binding) {\n          chainBindings_1.push({\n            sourceSpan: span,\n            value: function value() {\n              return _this.convertPropertyBinding(binding);\n            }\n          });\n        }); // for i18n block, advance to the most recent element index (by taking the current number of\n        // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n        // necessary lifecycle hooks of components/directives are properly flushed.\n\n        this.updateInstructionChainWithAdvance(this.getConstCount() - 1, r3_identifiers_1.Identifiers.i18nExp, chainBindings_1);\n        this.updateInstruction(span, r3_identifiers_1.Identifiers.i18nApply, [o.literal(index)]);\n      }\n\n      if (!selfClosing) {\n        this.creationInstruction(span, r3_identifiers_1.Identifiers.i18nEnd);\n      }\n\n      this.i18n = null; // reset local i18n context\n    };\n\n    TemplateDefinitionBuilder.prototype.i18nAttributesInstruction = function (nodeIndex, attrs, sourceSpan) {\n      var _this = this;\n\n      var hasBindings = false;\n      var i18nAttrArgs = [];\n      var bindings = [];\n      attrs.forEach(function (attr) {\n        var message = attr.i18n;\n        var converted = attr.value.visit(_this._valueConverter);\n\n        _this.allocateBindingSlots(converted);\n\n        if (converted instanceof ast_1.Interpolation) {\n          var placeholders = util_3.assembleBoundTextPlaceholders(message);\n          var params = util_3.placeholdersToParams(placeholders);\n          i18nAttrArgs.push(o.literal(attr.name), _this.i18nTranslate(message, params));\n          converted.expressions.forEach(function (expression) {\n            hasBindings = true;\n            bindings.push({\n              sourceSpan: sourceSpan,\n              value: function value() {\n                return _this.convertPropertyBinding(expression);\n              }\n            });\n          });\n        }\n      });\n\n      if (bindings.length > 0) {\n        this.updateInstructionChainWithAdvance(nodeIndex, r3_identifiers_1.Identifiers.i18nExp, bindings);\n      }\n\n      if (i18nAttrArgs.length > 0) {\n        var index = o.literal(this.allocateDataSlot());\n        var constIndex = this.addToConsts(o.literalArr(i18nAttrArgs));\n        this.creationInstruction(sourceSpan, r3_identifiers_1.Identifiers.i18nAttributes, [index, constIndex]);\n\n        if (hasBindings) {\n          this.updateInstruction(sourceSpan, r3_identifiers_1.Identifiers.i18nApply, [index]);\n        }\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.getNamespaceInstruction = function (namespaceKey) {\n      switch (namespaceKey) {\n        case 'math':\n          return r3_identifiers_1.Identifiers.namespaceMathML;\n\n        case 'svg':\n          return r3_identifiers_1.Identifiers.namespaceSVG;\n\n        default:\n          return r3_identifiers_1.Identifiers.namespaceHTML;\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.addNamespaceInstruction = function (nsInstruction, element) {\n      this._namespace = nsInstruction;\n      this.creationInstruction(element.startSourceSpan, nsInstruction);\n    };\n    /**\n     * Adds an update instruction for an interpolated property or attribute, such as\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n     */\n\n\n    TemplateDefinitionBuilder.prototype.interpolatedUpdateInstruction = function (instruction, elementIndex, attrName, input, value, params) {\n      var _this = this;\n\n      this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, function () {\n        return tslib_1.__spread([o.literal(attrName)], _this.getUpdateInstructionArguments(value), params);\n      });\n    };\n\n    TemplateDefinitionBuilder.prototype.visitContent = function (ngContent) {\n      var slot = this.allocateDataSlot();\n      var projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n      var parameters = [o.literal(slot)];\n\n      this._ngContentReservedSlots.push(ngContent.selector);\n\n      var nonContentSelectAttributes = ngContent.attributes.filter(function (attr) {\n        return attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR;\n      });\n      var attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\n\n      if (attributes.length > 0) {\n        parameters.push(o.literal(projectionSlotIdx), o.literalArr(attributes));\n      } else if (projectionSlotIdx !== 0) {\n        parameters.push(o.literal(projectionSlotIdx));\n      }\n\n      this.creationInstruction(ngContent.sourceSpan, r3_identifiers_1.Identifiers.projection, parameters);\n\n      if (this.i18n) {\n        this.i18n.appendProjection(ngContent.i18n, slot);\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.visitElement = function (element) {\n      var e_1, _a;\n\n      var _this = this;\n\n      var _b, _c;\n\n      var elementIndex = this.allocateDataSlot();\n      var stylingBuilder = new styling_builder_1.StylingBuilder(null);\n      var isNonBindableMode = false;\n      var isI18nRootElement = util_3.isI18nRootNode(element.i18n) && !util_3.isSingleI18nIcu(element.i18n);\n      var outputAttrs = [];\n\n      var _d = tslib_1.__read(tags_1.splitNsName(element.name), 2),\n          namespaceKey = _d[0],\n          elementName = _d[1];\n\n      var isNgContainer = tags_1.isNgContainer(element.name);\n\n      try {\n        // Handle styling, i18n, ngNonBindable attributes\n        for (var _e = tslib_1.__values(element.attributes), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var attr = _f.value;\n          var name_1 = attr.name,\n              value = attr.value;\n\n          if (name_1 === util_4.NON_BINDABLE_ATTR) {\n            isNonBindableMode = true;\n          } else if (name_1 === 'style') {\n            stylingBuilder.registerStyleAttr(value);\n          } else if (name_1 === 'class') {\n            stylingBuilder.registerClassAttr(value);\n          } else {\n            outputAttrs.push(attr);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Match directives on non i18n attributes\n\n\n      this.matchDirectives(element.name, element); // Regular element or ng-container creation mode\n\n      var parameters = [o.literal(elementIndex)];\n\n      if (!isNgContainer) {\n        parameters.push(o.literal(elementName));\n      } // Add the attributes\n\n\n      var allOtherInputs = [];\n      var boundI18nAttrs = [];\n      element.inputs.forEach(function (input) {\n        var stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n\n        if (!stylingInputWasSet) {\n          if (input.type === 0\n          /* Property */\n          && input.i18n) {\n            boundI18nAttrs.push(input);\n          } else {\n            allOtherInputs.push(input);\n          }\n        }\n      }); // add attributes for directive and projection matching purposes\n\n      var attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);\n      parameters.push(this.addAttrsToConsts(attributes)); // local refs (ex.: <div #foo #bar=\"baz\">)\n\n      var refs = this.prepareRefsArray(element.references);\n      parameters.push(this.addToConsts(refs));\n      var wasInNamespace = this._namespace;\n      var currentNamespace = this.getNamespaceInstruction(namespaceKey); // If the namespace is changing now, include an instruction to change it\n      // during element creation.\n\n      if (currentNamespace !== wasInNamespace) {\n        this.addNamespaceInstruction(currentNamespace, element);\n      }\n\n      if (this.i18n) {\n        this.i18n.appendElement(element.i18n, elementIndex);\n      } // Note that we do not append text node instructions and ICUs inside i18n section,\n      // so we exclude them while calculating whether current element has children\n\n\n      var hasChildren = !isI18nRootElement && this.i18n ? !hasTextChildrenOnly(element.children) : element.children.length > 0;\n      var createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes && element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\n      var createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n\n      if (createSelfClosingInstruction) {\n        this.creationInstruction(element.sourceSpan, isNgContainer ? r3_identifiers_1.Identifiers.elementContainer : r3_identifiers_1.Identifiers.element, util_4.trimTrailingNulls(parameters));\n      } else {\n        this.creationInstruction(element.startSourceSpan, isNgContainer ? r3_identifiers_1.Identifiers.elementContainerStart : r3_identifiers_1.Identifiers.elementStart, util_4.trimTrailingNulls(parameters));\n\n        if (isNonBindableMode) {\n          this.creationInstruction(element.startSourceSpan, r3_identifiers_1.Identifiers.disableBindings);\n        }\n\n        if (boundI18nAttrs.length > 0) {\n          this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_b = element.startSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan);\n        } // Generate Listeners (outputs)\n\n\n        if (element.outputs.length > 0) {\n          var listeners = element.outputs.map(function (outputAst) {\n            return {\n              sourceSpan: outputAst.sourceSpan,\n              params: _this.prepareListenerParameter(element.name, outputAst, elementIndex)\n            };\n          });\n          this.creationInstructionChain(r3_identifiers_1.Identifiers.listener, listeners);\n        } // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n        // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n\n\n        if (isI18nRootElement) {\n          this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);\n        }\n      } // the code here will collect all update-level styling instructions and add them to the\n      // update block of the template function AOT code. Instructions like `styleProp`,\n      // `styleMap`, `classMap`, `classProp`\n      // are all generated and assigned in the code below.\n\n\n      var stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n      var limit = stylingInstructions.length - 1;\n\n      for (var i = 0; i <= limit; i++) {\n        var instruction_1 = stylingInstructions[i];\n        this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction_1);\n      } // the reason why `undefined` is used is because the renderer understands this as a\n      // special value to symbolize that there is no RHS to this binding\n      // TODO (matsko): revisit this once FW-959 is approached\n\n\n      var emptyValueBindInstruction = o.literal(undefined);\n      var propertyBindings = [];\n      var attributeBindings = []; // Generate element input bindings\n\n      allOtherInputs.forEach(function (input) {\n        var inputType = input.type;\n\n        if (inputType === 4\n        /* Animation */\n        ) {\n            var value_1 = input.value.visit(_this._valueConverter); // animation bindings can be presented in the following formats:\n            // 1. [@binding]=\"fooExp\"\n            // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n            // 3. [@binding]\n            // 4. @binding\n            // All formats will be valid for when a synthetic binding is created.\n            // The reasoning for this is because the renderer should get each\n            // synthetic binding value in the order of the array that they are\n            // defined in...\n\n            var hasValue_1 = value_1 instanceof ast_1.LiteralPrimitive ? !!value_1.value : true;\n\n            _this.allocateBindingSlots(value_1);\n\n            propertyBindings.push({\n              name: util_2.prepareSyntheticPropertyName(input.name),\n              sourceSpan: input.sourceSpan,\n              value: function value() {\n                return hasValue_1 ? _this.convertPropertyBinding(value_1) : emptyValueBindInstruction;\n              }\n            });\n          } else {\n          // we must skip attributes with associated i18n context, since these attributes are handled\n          // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n          if (input.i18n) return;\n          var value_2 = input.value.visit(_this._valueConverter);\n\n          if (value_2 !== undefined) {\n            var params_2 = [];\n\n            var _a = tslib_1.__read(tags_1.splitNsName(input.name), 2),\n                attrNamespace = _a[0],\n                attrName_1 = _a[1];\n\n            var isAttributeBinding = inputType === 1\n            /* Attribute */\n            ;\n            var sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n            if (sanitizationRef) params_2.push(sanitizationRef);\n\n            if (attrNamespace) {\n              var namespaceLiteral = o.literal(attrNamespace);\n\n              if (sanitizationRef) {\n                params_2.push(namespaceLiteral);\n              } else {\n                // If there wasn't a sanitization ref, we need to add\n                // an extra param so that we can pass in the namespace.\n                params_2.push(o.literal(null), namespaceLiteral);\n              }\n            }\n\n            _this.allocateBindingSlots(value_2);\n\n            if (inputType === 0\n            /* Property */\n            ) {\n                if (value_2 instanceof ast_1.Interpolation) {\n                  // prop=\"{{value}}\" and friends\n                  _this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value_2), elementIndex, attrName_1, input, value_2, params_2);\n                } else {\n                  // [prop]=\"value\"\n                  // Collect all the properties so that we can chain into a single function at the end.\n                  propertyBindings.push({\n                    name: attrName_1,\n                    sourceSpan: input.sourceSpan,\n                    value: function value() {\n                      return _this.convertPropertyBinding(value_2);\n                    },\n                    params: params_2\n                  });\n                }\n              } else if (inputType === 1\n            /* Attribute */\n            ) {\n                if (value_2 instanceof ast_1.Interpolation && util_4.getInterpolationArgsLength(value_2) > 1) {\n                  // attr.name=\"text{{value}}\" and friends\n                  _this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value_2), elementIndex, attrName_1, input, value_2, params_2);\n                } else {\n                  var boundValue_1 = value_2 instanceof ast_1.Interpolation ? value_2.expressions[0] : value_2; // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n                  // Collect the attribute bindings so that they can be chained at the end.\n\n                  attributeBindings.push({\n                    name: attrName_1,\n                    sourceSpan: input.sourceSpan,\n                    value: function value() {\n                      return _this.convertPropertyBinding(boundValue_1);\n                    },\n                    params: params_2\n                  });\n                }\n              } else {\n              // class prop\n              _this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, r3_identifiers_1.Identifiers.classProp, function () {\n                return tslib_1.__spread([o.literal(elementIndex), o.literal(attrName_1), _this.convertPropertyBinding(value_2)], params_2);\n              });\n            }\n          }\n        }\n      });\n\n      if (propertyBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(elementIndex, r3_identifiers_1.Identifiers.property, propertyBindings);\n      }\n\n      if (attributeBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(elementIndex, r3_identifiers_1.Identifiers.attribute, attributeBindings);\n      } // Traverse element child nodes\n\n\n      t.visitAll(this, element.children);\n\n      if (!isI18nRootElement && this.i18n) {\n        this.i18n.appendElement(element.i18n, elementIndex, true);\n      }\n\n      if (!createSelfClosingInstruction) {\n        // Finish element construction mode.\n        var span = (_c = element.endSourceSpan) !== null && _c !== void 0 ? _c : element.sourceSpan;\n\n        if (isI18nRootElement) {\n          this.i18nEnd(span, createSelfClosingI18nInstruction);\n        }\n\n        if (isNonBindableMode) {\n          this.creationInstruction(span, r3_identifiers_1.Identifiers.enableBindings);\n        }\n\n        this.creationInstruction(span, isNgContainer ? r3_identifiers_1.Identifiers.elementContainerEnd : r3_identifiers_1.Identifiers.elementEnd);\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.visitTemplate = function (template) {\n      var _this = this;\n\n      var _a;\n\n      var NG_TEMPLATE_TAG_NAME = 'ng-template';\n      var templateIndex = this.allocateDataSlot();\n\n      if (this.i18n) {\n        this.i18n.appendTemplate(template.i18n, templateIndex);\n      }\n\n      var tagName = compile_metadata_1.sanitizeIdentifier(template.tagName || '');\n      var contextName = \"\" + this.contextName + (tagName ? '_' + tagName : '') + \"_\" + templateIndex;\n      var templateName = contextName + \"_Template\";\n      var parameters = [o.literal(templateIndex), o.variable(templateName), // We don't care about the tag's namespace here, because we infer\n      // it based on the parent nodes inside the template instruction.\n      o.literal(template.tagName ? tags_1.splitNsName(template.tagName)[1] : template.tagName)]; // find directives matching on a given <ng-template> node\n\n      this.matchDirectives(NG_TEMPLATE_TAG_NAME, template); // prepare attributes parameter (including attributes used for directive matching)\n\n      var attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined\n      /* styles */\n      , template.templateAttrs);\n      parameters.push(this.addAttrsToConsts(attrsExprs)); // local refs (ex.: <ng-template #foo>)\n\n      if (template.references && template.references.length) {\n        var refs = this.prepareRefsArray(template.references);\n        parameters.push(this.addToConsts(refs));\n        parameters.push(o.importExpr(r3_identifiers_1.Identifiers.templateRefExtractor));\n      } // Create the template function\n\n\n      var templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants); // Nested templates must not be visited until after their parent templates have completed\n      // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n      // be able to support bindings in nested templates to local refs that occur after the\n      // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n\n      this._nestedTemplateFns.push(function () {\n        var _a;\n\n        var templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, _this._ngContentReservedSlots.length + _this._ngContentSelectorsOffset, template.i18n);\n\n        _this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n\n        if (templateVisitor._ngContentReservedSlots.length) {\n          (_a = _this._ngContentReservedSlots).push.apply(_a, tslib_1.__spread(templateVisitor._ngContentReservedSlots));\n        }\n      }); // e.g. template(1, MyComp_Template_1)\n\n\n      this.creationInstruction(template.sourceSpan, r3_identifiers_1.Identifiers.templateCreate, function () {\n        parameters.splice(2, 0, o.literal(templateVisitor.getConstCount()), o.literal(templateVisitor.getVarCount()));\n        return util_4.trimTrailingNulls(parameters);\n      }); // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;\n\n      this.templatePropertyBindings(templateIndex, template.templateAttrs); // Only add normal input/output binding instructions on explicit <ng-template> elements.\n\n      if (template.tagName === NG_TEMPLATE_TAG_NAME) {\n        var _b = tslib_1.__read(util_1.partitionArray(template.inputs, util_3.hasI18nMeta), 2),\n            i18nInputs = _b[0],\n            inputs = _b[1]; // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n        // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n        // elements, in case of inline templates, corresponding instructions will be generated in the\n        // nested template function.\n\n\n        if (i18nInputs.length > 0) {\n          this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);\n        } // Add the input bindings\n\n\n        if (inputs.length > 0) {\n          this.templatePropertyBindings(templateIndex, inputs);\n        } // Generate listeners for directive output\n\n\n        if (template.outputs.length > 0) {\n          var listeners = template.outputs.map(function (outputAst) {\n            return {\n              sourceSpan: outputAst.sourceSpan,\n              params: _this.prepareListenerParameter('ng_template', outputAst, templateIndex)\n            };\n          });\n          this.creationInstructionChain(r3_identifiers_1.Identifiers.listener, listeners);\n        }\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.visitBoundText = function (text) {\n      var _this = this;\n\n      if (this.i18n) {\n        var value_3 = text.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value_3);\n\n        if (value_3 instanceof ast_1.Interpolation) {\n          this.i18n.appendBoundText(text.i18n);\n          this.i18nAppendBindings(value_3.expressions);\n        }\n\n        return;\n      }\n\n      var nodeIndex = this.allocateDataSlot();\n      this.creationInstruction(text.sourceSpan, r3_identifiers_1.Identifiers.text, [o.literal(nodeIndex)]);\n      var value = text.value.visit(this._valueConverter);\n      this.allocateBindingSlots(value);\n\n      if (value instanceof ast_1.Interpolation) {\n        this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), function () {\n          return _this.getUpdateInstructionArguments(value);\n        });\n      } else {\n        util_1.error('Text nodes should be interpolated and never bound directly.');\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.visitText = function (text) {\n      // when a text element is located within a translatable\n      // block, we exclude this text element from instructions set,\n      // since it will be captured in i18n content and processed at runtime\n      if (!this.i18n) {\n        this.creationInstruction(text.sourceSpan, r3_identifiers_1.Identifiers.text, [o.literal(this.allocateDataSlot()), o.literal(text.value)]);\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.visitIcu = function (icu) {\n      var initWasInvoked = false; // if an ICU was created outside of i18n block, we still treat\n      // it as a translatable entity and invoke i18nStart and i18nEnd\n      // to generate i18n context and the necessary instructions\n\n      if (!this.i18n) {\n        initWasInvoked = true;\n        this.i18nStart(null, icu.i18n, true);\n      }\n\n      var i18n = this.i18n;\n      var vars = this.i18nBindProps(icu.vars);\n      var placeholders = this.i18nBindProps(icu.placeholders); // output ICU directly and keep ICU reference in context\n\n      var message = icu.i18n; // we always need post-processing function for ICUs, to make sure that:\n      // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n      // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n      // inside ICUs)\n      // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n\n      var transformFn = function transformFn(raw) {\n        var params = tslib_1.__assign(tslib_1.__assign({}, vars), placeholders);\n\n        var formatted = util_3.i18nFormatPlaceholderNames(params,\n        /* useCamelCase */\n        false);\n        return instruction(null, r3_identifiers_1.Identifiers.i18nPostprocess, [raw, map_util_1.mapLiteral(formatted, true)]);\n      }; // in case the whole i18n message is a single ICU - we do not need to\n      // create a separate top-level translation, we can use the root ref instead\n      // and make this ICU a top-level translation\n      // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n      // separately, so we do not pass placeholders into `i18nTranslate` function.\n\n\n      if (util_3.isSingleI18nIcu(i18n.meta)) {\n        this.i18nTranslate(message,\n        /* placeholders */\n        {}, i18n.ref, transformFn);\n      } else {\n        // output ICU directly and keep ICU reference in context\n        var ref = this.i18nTranslate(message,\n        /* placeholders */\n        {},\n        /* ref */\n        undefined, transformFn);\n        i18n.appendIcu(util_3.icuFromI18nMessage(message).name, ref);\n      }\n\n      if (initWasInvoked) {\n        this.i18nEnd(null, true);\n      }\n\n      return null;\n    };\n\n    TemplateDefinitionBuilder.prototype.allocateDataSlot = function () {\n      return this._dataIndex++;\n    };\n\n    TemplateDefinitionBuilder.prototype.getConstCount = function () {\n      return this._dataIndex;\n    };\n\n    TemplateDefinitionBuilder.prototype.getVarCount = function () {\n      return this._pureFunctionSlots;\n    };\n\n    TemplateDefinitionBuilder.prototype.getConsts = function () {\n      return this._constants;\n    };\n\n    TemplateDefinitionBuilder.prototype.getNgContentSelectors = function () {\n      return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(util_4.asLiteral(this._ngContentReservedSlots), true) : null;\n    };\n\n    TemplateDefinitionBuilder.prototype.bindingContext = function () {\n      return \"\" + this._bindingContext++;\n    };\n\n    TemplateDefinitionBuilder.prototype.templatePropertyBindings = function (templateIndex, attrs) {\n      var _this = this;\n\n      var propertyBindings = [];\n      attrs.forEach(function (input) {\n        if (input instanceof t.BoundAttribute) {\n          var value_4 = input.value.visit(_this._valueConverter);\n\n          if (value_4 !== undefined) {\n            _this.allocateBindingSlots(value_4);\n\n            if (value_4 instanceof ast_1.Interpolation) {\n              // Params typically contain attribute namespace and value sanitizer, which is applicable\n              // for regular HTML elements, but not applicable for <ng-template> (since props act as\n              // inputs to directives), so keep params array empty.\n              var params = []; // prop=\"{{value}}\" case\n\n              _this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value_4), templateIndex, input.name, input, value_4, params);\n            } else {\n              // [prop]=\"value\" case\n              propertyBindings.push({\n                name: input.name,\n                sourceSpan: input.sourceSpan,\n                value: function value() {\n                  return _this.convertPropertyBinding(value_4);\n                }\n              });\n            }\n          }\n        }\n      });\n\n      if (propertyBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(templateIndex, r3_identifiers_1.Identifiers.property, propertyBindings);\n      }\n    }; // Bindings must only be resolved after all local refs have been visited, so all\n    // instructions are queued in callbacks that execute once the initial pass has completed.\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\n    // bindings. e.g. {{ foo }} <div #foo></div>\n\n\n    TemplateDefinitionBuilder.prototype.instructionFn = function (fns, span, reference, paramsOrFn, prepend) {\n      if (prepend === void 0) {\n        prepend = false;\n      }\n\n      fns[prepend ? 'unshift' : 'push'](function () {\n        var params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\n        return instruction(span, reference, params).toStmt();\n      });\n    };\n\n    TemplateDefinitionBuilder.prototype.processStylingUpdateInstruction = function (elementIndex, instruction) {\n      var _this = this;\n\n      var allocateBindingSlots = 0;\n\n      if (instruction) {\n        var calls_1 = [];\n        instruction.calls.forEach(function (call) {\n          allocateBindingSlots += call.allocateBindingSlots;\n          calls_1.push({\n            sourceSpan: call.sourceSpan,\n            value: function value() {\n              return call.params(function (value) {\n                return call.supportsInterpolation && value instanceof ast_1.Interpolation ? _this.getUpdateInstructionArguments(value) : _this.convertPropertyBinding(value);\n              });\n            }\n          });\n        });\n        this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls_1);\n      }\n\n      return allocateBindingSlots;\n    };\n\n    TemplateDefinitionBuilder.prototype.creationInstruction = function (span, reference, paramsOrFn, prepend) {\n      this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n    };\n\n    TemplateDefinitionBuilder.prototype.creationInstructionChain = function (reference, calls) {\n      var span = calls.length ? calls[0].sourceSpan : null;\n\n      this._creationCodeFns.push(function () {\n        return util_4.chainedInstruction(reference, calls.map(function (call) {\n          return call.params();\n        }), span).toStmt();\n      });\n    };\n\n    TemplateDefinitionBuilder.prototype.updateInstructionWithAdvance = function (nodeIndex, span, reference, paramsOrFn) {\n      this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n      this.updateInstruction(span, reference, paramsOrFn);\n    };\n\n    TemplateDefinitionBuilder.prototype.updateInstruction = function (span, reference, paramsOrFn) {\n      this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n    };\n\n    TemplateDefinitionBuilder.prototype.updateInstructionChain = function (reference, bindings) {\n      var span = bindings.length ? bindings[0].sourceSpan : null;\n\n      this._updateCodeFns.push(function () {\n        var calls = bindings.map(function (property) {\n          var value = property.value();\n          var fnParams = Array.isArray(value) ? value : [value];\n\n          if (property.params) {\n            fnParams.push.apply(fnParams, tslib_1.__spread(property.params));\n          }\n\n          if (property.name) {\n            // We want the property name to always be the first function parameter.\n            fnParams.unshift(o.literal(property.name));\n          }\n\n          return fnParams;\n        });\n        return util_4.chainedInstruction(reference, calls, span).toStmt();\n      });\n    };\n\n    TemplateDefinitionBuilder.prototype.updateInstructionChainWithAdvance = function (nodeIndex, reference, bindings) {\n      this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);\n      this.updateInstructionChain(reference, bindings);\n    };\n\n    TemplateDefinitionBuilder.prototype.addAdvanceInstructionIfNecessary = function (nodeIndex, span) {\n      if (nodeIndex !== this._currentIndex) {\n        var delta = nodeIndex - this._currentIndex;\n\n        if (delta < 1) {\n          throw new Error('advance instruction can only go forwards');\n        }\n\n        this.instructionFn(this._updateCodeFns, span, r3_identifiers_1.Identifiers.advance, [o.literal(delta)]);\n        this._currentIndex = nodeIndex;\n      }\n    };\n\n    TemplateDefinitionBuilder.prototype.allocatePureFunctionSlots = function (numSlots) {\n      var originalSlots = this._pureFunctionSlots;\n      this._pureFunctionSlots += numSlots;\n      return originalSlots;\n    };\n\n    TemplateDefinitionBuilder.prototype.allocateBindingSlots = function (value) {\n      this._bindingSlots += value instanceof ast_1.Interpolation ? value.expressions.length : 1;\n    };\n    /**\n     * Gets an expression that refers to the implicit receiver. The implicit\n     * receiver is always the root level context.\n     */\n\n\n    TemplateDefinitionBuilder.prototype.getImplicitReceiverExpr = function () {\n      if (this._implicitReceiverExpr) {\n        return this._implicitReceiverExpr;\n      }\n\n      return this._implicitReceiverExpr = this.level === 0 ? o.variable(util_4.CONTEXT_NAME) : this._bindingScope.getOrCreateSharedContextVar(0);\n    };\n\n    TemplateDefinitionBuilder.prototype.convertPropertyBinding = function (value) {\n      var _a;\n\n      var convertedPropertyBinding = expression_converter_1.convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), expression_converter_1.BindingForm.Expression, function () {\n        return util_1.error('Unexpected interpolation');\n      });\n      var valExpr = convertedPropertyBinding.currValExpr;\n\n      (_a = this._tempVariables).push.apply(_a, tslib_1.__spread(convertedPropertyBinding.stmts));\n\n      return valExpr;\n    };\n    /**\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n     * the temp variables state with temp variables that were identified as needing to be created\n     * while visiting the arguments.\n     * @param value The original expression we will be resolving an arguments list from.\n     */\n\n\n    TemplateDefinitionBuilder.prototype.getUpdateInstructionArguments = function (value) {\n      var _a;\n\n      var _b = expression_converter_1.convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext()),\n          args = _b.args,\n          stmts = _b.stmts;\n\n      (_a = this._tempVariables).push.apply(_a, tslib_1.__spread(stmts));\n\n      return args;\n    };\n\n    TemplateDefinitionBuilder.prototype.matchDirectives = function (elementName, elOrTpl) {\n      var _this = this;\n\n      if (this.directiveMatcher) {\n        var selector = createCssSelector(elementName, util_4.getAttrsForDirectiveMatching(elOrTpl));\n        this.directiveMatcher.match(selector, function (cssSelector, staticType) {\n          _this.directives.add(staticType);\n        });\n      }\n    };\n    /**\n     * Prepares all attribute expression values for the `TAttributes` array.\n     *\n     * The purpose of this function is to properly construct an attributes array that\n     * is passed into the `elementStart` (or just `element`) functions. Because there\n     * are many different types of attributes, the array needs to be constructed in a\n     * special way so that `elementStart` can properly evaluate them.\n     *\n     * The format looks like this:\n     *\n     * ```\n     * attrs = [prop, value, prop2, value2,\n     *   PROJECT_AS, selector,\n     *   CLASSES, class1, class2,\n     *   STYLES, style1, value1, style2, value2,\n     *   BINDINGS, name1, name2, name3,\n     *   TEMPLATE, name4, name5, name6,\n     *   I18N, name7, name8, ...]\n     * ```\n     *\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\n     * because those values are intended to always be generated as property instructions.\n     */\n\n\n    TemplateDefinitionBuilder.prototype.getAttributeExpressions = function (elementName, renderAttributes, inputs, outputs, styles, templateAttrs, boundI18nAttrs) {\n      var e_2, _a;\n\n      if (templateAttrs === void 0) {\n        templateAttrs = [];\n      }\n\n      if (boundI18nAttrs === void 0) {\n        boundI18nAttrs = [];\n      }\n\n      var alreadySeen = new Set();\n      var attrExprs = [];\n      var ngProjectAsAttr;\n\n      try {\n        for (var renderAttributes_1 = tslib_1.__values(renderAttributes), renderAttributes_1_1 = renderAttributes_1.next(); !renderAttributes_1_1.done; renderAttributes_1_1 = renderAttributes_1.next()) {\n          var attr = renderAttributes_1_1.value;\n\n          if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n            ngProjectAsAttr = attr;\n          } // Note that static i18n attributes aren't in the i18n array,\n          // because they're treated in the same way as regular attributes.\n\n\n          if (attr.i18n) {\n            // When i18n attributes are present on elements with structural directives\n            // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\n            // duplicate i18n translation blocks for `ɵɵtemplate` and `ɵɵelement` instruction\n            // attributes. So we do a cache lookup to see if suitable i18n translation block\n            // already exists.\n            var i18nVarRefsCache = this._constants.i18nVarRefsCache;\n            var i18nVarRef = void 0;\n\n            if (i18nVarRefsCache.has(attr.i18n)) {\n              i18nVarRef = i18nVarRefsCache.get(attr.i18n);\n            } else {\n              i18nVarRef = this.i18nTranslate(attr.i18n);\n              i18nVarRefsCache.set(attr.i18n, i18nVarRef);\n            }\n\n            attrExprs.push(o.literal(attr.name), i18nVarRef);\n          } else {\n            attrExprs.push.apply(attrExprs, tslib_1.__spread(getAttributeNameLiterals(attr.name), [trustedConstAttribute(elementName, attr)]));\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (renderAttributes_1_1 && !renderAttributes_1_1.done && (_a = renderAttributes_1.return)) _a.call(renderAttributes_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      } // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n      // ngProjectAs marker in the attribute name slot.\n\n\n      if (ngProjectAsAttr) {\n        attrExprs.push.apply(attrExprs, tslib_1.__spread(getNgProjectAsLiteral(ngProjectAsAttr)));\n      }\n\n      function addAttrExpr(key, value) {\n        if (typeof key === 'string') {\n          if (!alreadySeen.has(key)) {\n            attrExprs.push.apply(attrExprs, tslib_1.__spread(getAttributeNameLiterals(key)));\n            value !== undefined && attrExprs.push(value);\n            alreadySeen.add(key);\n          }\n        } else {\n          attrExprs.push(o.literal(key));\n        }\n      } // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n      // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n      // as single property value cell by cell.\n\n\n      if (styles) {\n        styles.populateInitialStylingAttrs(attrExprs);\n      }\n\n      if (inputs.length || outputs.length) {\n        var attrsLengthBeforeInputs = attrExprs.length;\n\n        for (var i = 0; i < inputs.length; i++) {\n          var input = inputs[i]; // We don't want the animation and attribute bindings in the\n          // attributes array since they aren't used for directive matching.\n\n          if (input.type !== 4\n          /* Animation */\n          && input.type !== 1\n          /* Attribute */\n          ) {\n              addAttrExpr(input.name);\n            }\n        }\n\n        for (var i = 0; i < outputs.length; i++) {\n          var output = outputs[i];\n\n          if (output.type !== 1\n          /* Animation */\n          ) {\n              addAttrExpr(output.name);\n            }\n        } // this is a cheap way of adding the marker only after all the input/output\n        // values have been filtered (by not including the animation ones) and added\n        // to the expressions. The marker is important because it tells the runtime\n        // code that this is where attributes without values start...\n\n\n        if (attrExprs.length !== attrsLengthBeforeInputs) {\n          attrExprs.splice(attrsLengthBeforeInputs, 0, o.literal(3\n          /* Bindings */\n          ));\n        }\n      }\n\n      if (templateAttrs.length) {\n        attrExprs.push(o.literal(4\n        /* Template */\n        ));\n        templateAttrs.forEach(function (attr) {\n          return addAttrExpr(attr.name);\n        });\n      }\n\n      if (boundI18nAttrs.length) {\n        attrExprs.push(o.literal(6\n        /* I18n */\n        ));\n        boundI18nAttrs.forEach(function (attr) {\n          return addAttrExpr(attr.name);\n        });\n      }\n\n      return attrExprs;\n    };\n\n    TemplateDefinitionBuilder.prototype.addToConsts = function (expression) {\n      if (o.isNull(expression)) {\n        return o.TYPED_NULL_EXPR;\n      }\n\n      var consts = this._constants.constExpressions; // Try to reuse a literal that's already in the array, if possible.\n\n      for (var i = 0; i < consts.length; i++) {\n        if (consts[i].isEquivalent(expression)) {\n          return o.literal(i);\n        }\n      }\n\n      return o.literal(consts.push(expression) - 1);\n    };\n\n    TemplateDefinitionBuilder.prototype.addAttrsToConsts = function (attrs) {\n      return attrs.length > 0 ? this.addToConsts(o.literalArr(attrs)) : o.TYPED_NULL_EXPR;\n    };\n\n    TemplateDefinitionBuilder.prototype.prepareRefsArray = function (references) {\n      var _this = this;\n\n      if (!references || references.length === 0) {\n        return o.TYPED_NULL_EXPR;\n      }\n\n      var refsParam = compile_metadata_1.flatten(references.map(function (reference) {\n        var slot = _this.allocateDataSlot(); // Generate the update temporary.\n\n\n        var variableName = _this._bindingScope.freshReferenceName();\n\n        var retrievalLevel = _this.level;\n        var lhs = o.variable(variableName);\n\n        _this._bindingScope.set(retrievalLevel, reference.name, lhs, 0\n        /* DEFAULT */\n        , function (scope, relativeLevel) {\n          // e.g. nextContext(2);\n          var nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : []; // e.g. const $foo$ = reference(1);\n\n          var refExpr = lhs.set(o.importExpr(r3_identifiers_1.Identifiers.reference).callFn([o.literal(slot)]));\n          return nextContextStmt.concat(refExpr.toConstDecl());\n        }, true);\n\n        return [reference.name, reference.value];\n      }));\n      return util_4.asLiteral(refsParam);\n    };\n\n    TemplateDefinitionBuilder.prototype.prepareListenerParameter = function (tagName, outputAst, index) {\n      var _this = this;\n\n      return function () {\n        var eventName = outputAst.name;\n        var bindingFnName = outputAst.type === 1\n        /* Animation */\n        ? // synthetic @listener.foo values are treated the exact same as are standard listeners\n        util_2.prepareSyntheticListenerFunctionName(eventName, outputAst.phase) : compile_metadata_1.sanitizeIdentifier(eventName);\n        var handlerName = _this.templateName + \"_\" + tagName + \"_\" + bindingFnName + \"_\" + index + \"_listener\";\n\n        var scope = _this._bindingScope.nestedScope(_this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\n\n        return prepareEventListenerParameters(outputAst, handlerName, scope);\n      };\n    };\n\n    return TemplateDefinitionBuilder;\n  }();\n\n  exports.TemplateDefinitionBuilder = TemplateDefinitionBuilder;\n\n  var ValueConverter =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ValueConverter, _super);\n\n    function ValueConverter(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\n      var _this = _super.call(this) || this;\n\n      _this.constantPool = constantPool;\n      _this.allocateSlot = allocateSlot;\n      _this.allocatePureFunctionSlots = allocatePureFunctionSlots;\n      _this.definePipe = definePipe;\n      _this._pipeBindExprs = [];\n      return _this;\n    } // AstMemoryEfficientTransformer\n\n\n    ValueConverter.prototype.visitPipe = function (pipe, context) {\n      // Allocate a slot to create the pipe\n      var slot = this.allocateSlot();\n      var slotPseudoLocal = \"PIPE:\" + slot; // Allocate one slot for the result plus one slot per pipe argument\n\n      var pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n      var target = new ast_1.PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ast_1.ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);\n\n      var _a = pipeBindingCallInfo(pipe.args),\n          identifier = _a.identifier,\n          isVarLength = _a.isVarLength;\n\n      this.definePipe(pipe.name, slotPseudoLocal, slot, o.importExpr(identifier));\n\n      var args = tslib_1.__spread([pipe.exp], pipe.args);\n\n      var convertedArgs = isVarLength ? this.visitAll([new ast_1.LiteralArray(pipe.span, pipe.sourceSpan, args)]) : this.visitAll(args);\n      var pipeBindExpr = new ast_1.FunctionCall(pipe.span, pipe.sourceSpan, target, tslib_1.__spread([new ast_1.LiteralPrimitive(pipe.span, pipe.sourceSpan, slot), new ast_1.LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot)], convertedArgs));\n\n      this._pipeBindExprs.push(pipeBindExpr);\n\n      return pipeBindExpr;\n    };\n\n    ValueConverter.prototype.updatePipeSlotOffsets = function (bindingSlots) {\n      this._pipeBindExprs.forEach(function (pipe) {\n        // update the slot offset arg (index 1) to account for binding slots\n        var slotOffset = pipe.args[1];\n        slotOffset.value += bindingSlots;\n      });\n    };\n\n    ValueConverter.prototype.visitLiteralArray = function (array, context) {\n      var _this = this;\n\n      return new expression_converter_1.BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), function (values) {\n        // If the literal has calculated (non-literal) elements transform it into\n        // calls to literal factories that compose the literal and will cache intermediate\n        // values.\n        var literal = o.literalArr(values);\n        return getLiteralFactory(_this.constantPool, literal, _this.allocatePureFunctionSlots);\n      });\n    };\n\n    ValueConverter.prototype.visitLiteralMap = function (map, context) {\n      var _this = this;\n\n      return new expression_converter_1.BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), function (values) {\n        // If the literal has calculated (non-literal) elements  transform it into\n        // calls to literal factories that compose the literal and will cache intermediate\n        // values.\n        var literal = o.literalMap(values.map(function (value, index) {\n          return {\n            key: map.keys[index].key,\n            value: value,\n            quoted: map.keys[index].quoted\n          };\n        }));\n        return getLiteralFactory(_this.constantPool, literal, _this.allocatePureFunctionSlots);\n      });\n    };\n\n    return ValueConverter;\n  }(ast_1.AstMemoryEfficientTransformer);\n\n  exports.ValueConverter = ValueConverter; // Pipes always have at least one parameter, the value they operate on\n\n  var pipeBindingIdentifiers = [r3_identifiers_1.Identifiers.pipeBind1, r3_identifiers_1.Identifiers.pipeBind2, r3_identifiers_1.Identifiers.pipeBind3, r3_identifiers_1.Identifiers.pipeBind4];\n\n  function pipeBindingCallInfo(args) {\n    var identifier = pipeBindingIdentifiers[args.length];\n    return {\n      identifier: identifier || r3_identifiers_1.Identifiers.pipeBindV,\n      isVarLength: !identifier\n    };\n  }\n\n  var pureFunctionIdentifiers = [r3_identifiers_1.Identifiers.pureFunction0, r3_identifiers_1.Identifiers.pureFunction1, r3_identifiers_1.Identifiers.pureFunction2, r3_identifiers_1.Identifiers.pureFunction3, r3_identifiers_1.Identifiers.pureFunction4, r3_identifiers_1.Identifiers.pureFunction5, r3_identifiers_1.Identifiers.pureFunction6, r3_identifiers_1.Identifiers.pureFunction7, r3_identifiers_1.Identifiers.pureFunction8];\n\n  function pureFunctionCallInfo(args) {\n    var identifier = pureFunctionIdentifiers[args.length];\n    return {\n      identifier: identifier || r3_identifiers_1.Identifiers.pureFunctionV,\n      isVarLength: !identifier\n    };\n  }\n\n  function instruction(span, reference, params) {\n    return o.importExpr(reference, null, span).callFn(params, span);\n  } // e.g. x(2);\n\n\n  function generateNextContextExpr(relativeLevelDiff) {\n    return o.importExpr(r3_identifiers_1.Identifiers.nextContext).callFn(relativeLevelDiff > 1 ? [o.literal(relativeLevelDiff)] : []);\n  }\n\n  function getLiteralFactory(constantPool, literal, allocateSlots) {\n    var _a = constantPool.getLiteralFactory(literal),\n        literalFactory = _a.literalFactory,\n        literalFactoryArguments = _a.literalFactoryArguments; // Allocate 1 slot for the result plus 1 per argument\n\n\n    var startSlot = allocateSlots(1 + literalFactoryArguments.length);\n\n    var _b = pureFunctionCallInfo(literalFactoryArguments),\n        identifier = _b.identifier,\n        isVarLength = _b.isVarLength; // Literal factories are pure functions that only need to be re-invoked when the parameters\n    // change.\n\n\n    var args = [o.literal(startSlot), literalFactory];\n\n    if (isVarLength) {\n      args.push(o.literalArr(literalFactoryArguments));\n    } else {\n      args.push.apply(args, tslib_1.__spread(literalFactoryArguments));\n    }\n\n    return o.importExpr(identifier).callFn(args);\n  }\n  /**\n   * Gets an array of literals that can be added to an expression\n   * to represent the name and namespace of an attribute. E.g.\n   * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n   *\n   * @param name Name of the attribute, including the namespace.\n   */\n\n\n  function getAttributeNameLiterals(name) {\n    var _a = tslib_1.__read(tags_1.splitNsName(name), 2),\n        attributeNamespace = _a[0],\n        attributeName = _a[1];\n\n    var nameLiteral = o.literal(attributeName);\n\n    if (attributeNamespace) {\n      return [o.literal(0\n      /* NamespaceURI */\n      ), o.literal(attributeNamespace), nameLiteral];\n    }\n\n    return [nameLiteral];\n  }\n  /** The prefix used to get a shared context in BindingScope's map. */\n\n\n  var SHARED_CONTEXT_KEY = '$$shared_ctx$$';\n\n  var BindingScope =\n  /** @class */\n  function () {\n    function BindingScope(bindingLevel, parent, globals) {\n      var e_3, _a;\n\n      if (bindingLevel === void 0) {\n        bindingLevel = 0;\n      }\n\n      if (parent === void 0) {\n        parent = null;\n      }\n\n      this.bindingLevel = bindingLevel;\n      this.parent = parent;\n      this.globals = globals;\n      /** Keeps a map from local variables to their BindingData. */\n\n      this.map = new Map();\n      this.referenceNameIndex = 0;\n      this.restoreViewVariable = null;\n\n      if (globals !== undefined) {\n        try {\n          for (var globals_1 = tslib_1.__values(globals), globals_1_1 = globals_1.next(); !globals_1_1.done; globals_1_1 = globals_1.next()) {\n            var name_2 = globals_1_1.value;\n            this.set(0, name_2, o.variable(name_2));\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (globals_1_1 && !globals_1_1.done && (_a = globals_1.return)) _a.call(globals_1);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n    }\n\n    BindingScope.createRootScope = function () {\n      return new BindingScope();\n    };\n\n    BindingScope.prototype.get = function (name) {\n      var current = this;\n\n      while (current) {\n        var value = current.map.get(name);\n\n        if (value != null) {\n          if (current !== this) {\n            // make a local copy and reset the `declare` state\n            value = {\n              retrievalLevel: value.retrievalLevel,\n              lhs: value.lhs,\n              declareLocalCallback: value.declareLocalCallback,\n              declare: false,\n              priority: value.priority,\n              localRef: value.localRef\n            }; // Cache the value locally.\n\n            this.map.set(name, value); // Possibly generate a shared context var\n\n            this.maybeGenerateSharedContextVar(value);\n            this.maybeRestoreView(value.retrievalLevel, value.localRef);\n          }\n\n          if (value.declareLocalCallback && !value.declare) {\n            value.declare = true;\n          }\n\n          return value.lhs;\n        }\n\n        current = current.parent;\n      } // If we get to this point, we are looking for a property on the top level component\n      // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n      // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n      // local var we used to store the component context, e.g. const $comp$ = x();\n\n\n      return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n    };\n    /**\n     * Create a local variable for later reference.\n     *\n     * @param retrievalLevel The level from which this value can be retrieved\n     * @param name Name of the variable.\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n     * @param priority The sorting priority of this var\n     * @param declareLocalCallback The callback to invoke when declaring this local var\n     * @param localRef Whether or not this is a local ref\n     */\n\n\n    BindingScope.prototype.set = function (retrievalLevel, name, lhs, priority, declareLocalCallback, localRef) {\n      if (priority === void 0) {\n        priority = 0\n        /* DEFAULT */\n        ;\n      }\n\n      if (this.map.has(name)) {\n        if (localRef) {\n          // Do not throw an error if it's a local ref and do not update existing value,\n          // so the first defined ref is always returned.\n          return this;\n        }\n\n        util_1.error(\"The name \" + name + \" is already defined in scope to be \" + this.map.get(name));\n      }\n\n      this.map.set(name, {\n        retrievalLevel: retrievalLevel,\n        lhs: lhs,\n        declare: false,\n        declareLocalCallback: declareLocalCallback,\n        priority: priority,\n        localRef: localRef || false\n      });\n      return this;\n    }; // Implemented as part of LocalResolver.\n\n\n    BindingScope.prototype.getLocal = function (name) {\n      return this.get(name);\n    }; // Implemented as part of LocalResolver.\n\n\n    BindingScope.prototype.notifyImplicitReceiverUse = function () {\n      if (this.bindingLevel !== 0) {\n        // Since the implicit receiver is accessed in an embedded view, we need to\n        // ensure that we declare a shared context variable for the current template\n        // in the update variables.\n        this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;\n      }\n    };\n\n    BindingScope.prototype.nestedScope = function (level, globals) {\n      var newScope = new BindingScope(level, this, globals);\n      if (level > 0) newScope.generateSharedContextVar(0);\n      return newScope;\n    };\n    /**\n     * Gets or creates a shared context variable and returns its expression. Note that\n     * this does not mean that the shared variable will be declared. Variables in the\n     * binding scope will be only declared if they are used.\n     */\n\n\n    BindingScope.prototype.getOrCreateSharedContextVar = function (retrievalLevel) {\n      var bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n\n      if (!this.map.has(bindingKey)) {\n        this.generateSharedContextVar(retrievalLevel);\n      } // Shared context variables are always generated as \"ReadVarExpr\".\n\n\n      return this.map.get(bindingKey).lhs;\n    };\n\n    BindingScope.prototype.getSharedContextName = function (retrievalLevel) {\n      var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel); // Shared context variables are always generated as \"ReadVarExpr\".\n\n      return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\n    };\n\n    BindingScope.prototype.maybeGenerateSharedContextVar = function (value) {\n      if (value.priority === 1\n      /* CONTEXT */\n      && value.retrievalLevel < this.bindingLevel) {\n        var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n\n        if (sharedCtxObj) {\n          sharedCtxObj.declare = true;\n        } else {\n          this.generateSharedContextVar(value.retrievalLevel);\n        }\n      }\n    };\n\n    BindingScope.prototype.generateSharedContextVar = function (retrievalLevel) {\n      var lhs = o.variable(util_4.CONTEXT_NAME + this.freshReferenceName());\n      this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n        retrievalLevel: retrievalLevel,\n        lhs: lhs,\n        declareLocalCallback: function declareLocalCallback(scope, relativeLevel) {\n          // const ctx_r0 = nextContext(2);\n          return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n        },\n        declare: false,\n        priority: 2\n        /* SHARED_CONTEXT */\n        ,\n        localRef: false\n      });\n    };\n\n    BindingScope.prototype.getComponentProperty = function (name) {\n      var componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);\n      componentValue.declare = true;\n      this.maybeRestoreView(0, false);\n      return componentValue.lhs.prop(name);\n    };\n\n    BindingScope.prototype.maybeRestoreView = function (retrievalLevel, localRefLookup) {\n      // We want to restore the current view in listener fns if:\n      // 1 - we are accessing a value in a parent view, which requires walking the view tree rather\n      // than using the ctx arg. In this case, the retrieval and binding level will be different.\n      // 2 - we are looking up a local ref, which requires restoring the view where the local\n      // ref is stored\n      if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {\n        if (!this.parent.restoreViewVariable) {\n          // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n          this.parent.restoreViewVariable = o.variable(this.parent.freshReferenceName());\n        }\n\n        this.restoreViewVariable = this.parent.restoreViewVariable;\n      }\n    };\n\n    BindingScope.prototype.restoreViewStatement = function () {\n      // restoreView($state$);\n      return this.restoreViewVariable ? [instruction(null, r3_identifiers_1.Identifiers.restoreView, [this.restoreViewVariable]).toStmt()] : [];\n    };\n\n    BindingScope.prototype.viewSnapshotStatements = function () {\n      // const $state$ = getCurrentView();\n      var getCurrentViewInstruction = instruction(null, r3_identifiers_1.Identifiers.getCurrentView, []);\n      return this.restoreViewVariable ? [this.restoreViewVariable.set(getCurrentViewInstruction).toConstDecl()] : [];\n    };\n\n    BindingScope.prototype.isListenerScope = function () {\n      return this.parent && this.parent.bindingLevel === this.bindingLevel;\n    };\n\n    BindingScope.prototype.variableDeclarations = function () {\n      var _this = this;\n\n      var currentContextLevel = 0;\n      return Array.from(this.map.values()).filter(function (value) {\n        return value.declare;\n      }).sort(function (a, b) {\n        return b.retrievalLevel - a.retrievalLevel || b.priority - a.priority;\n      }).reduce(function (stmts, value) {\n        var levelDiff = _this.bindingLevel - value.retrievalLevel;\n        var currStmts = value.declareLocalCallback(_this, levelDiff - currentContextLevel);\n        currentContextLevel = levelDiff;\n        return stmts.concat(currStmts);\n      }, []);\n    };\n\n    BindingScope.prototype.freshReferenceName = function () {\n      var current = this; // Find the top scope as it maintains the global reference count\n\n      while (current.parent) {\n        current = current.parent;\n      }\n\n      var ref = \"\" + util_4.REFERENCE_PREFIX + current.referenceNameIndex++;\n      return ref;\n    };\n\n    return BindingScope;\n  }();\n\n  exports.BindingScope = BindingScope;\n  /**\n   * Creates a `CssSelector` given a tag name and a map of attributes\n   */\n\n  function createCssSelector(elementName, attributes) {\n    var cssSelector = new selector_1.CssSelector();\n    var elementNameNoNs = tags_1.splitNsName(elementName)[1];\n    cssSelector.setElement(elementNameNoNs);\n    Object.getOwnPropertyNames(attributes).forEach(function (name) {\n      var nameNoNs = tags_1.splitNsName(name)[1];\n      var value = attributes[name];\n      cssSelector.addAttribute(nameNoNs, value);\n\n      if (name.toLowerCase() === 'class') {\n        var classes = value.trim().split(/\\s+/);\n        classes.forEach(function (className) {\n          return cssSelector.addClassName(className);\n        });\n      }\n    });\n    return cssSelector;\n  }\n\n  exports.createCssSelector = createCssSelector;\n  /**\n   * Creates an array of expressions out of an `ngProjectAs` attributes\n   * which can be added to the instruction parameters.\n   */\n\n  function getNgProjectAsLiteral(attribute) {\n    // Parse the attribute value into a CssSelectorList. Note that we only take the\n    // first selector, because we don't support multiple selectors in ngProjectAs.\n    var parsedR3Selector = core.parseSelectorToR3Selector(attribute.value)[0];\n    return [o.literal(5\n    /* ProjectAs */\n    ), util_4.asLiteral(parsedR3Selector)];\n  }\n  /**\n   * Gets the instruction to generate for an interpolated property\n   * @param interpolation An Interpolation AST\n   */\n\n\n  function getPropertyInterpolationExpression(interpolation) {\n    switch (util_4.getInterpolationArgsLength(interpolation)) {\n      case 1:\n        return r3_identifiers_1.Identifiers.propertyInterpolate;\n\n      case 3:\n        return r3_identifiers_1.Identifiers.propertyInterpolate1;\n\n      case 5:\n        return r3_identifiers_1.Identifiers.propertyInterpolate2;\n\n      case 7:\n        return r3_identifiers_1.Identifiers.propertyInterpolate3;\n\n      case 9:\n        return r3_identifiers_1.Identifiers.propertyInterpolate4;\n\n      case 11:\n        return r3_identifiers_1.Identifiers.propertyInterpolate5;\n\n      case 13:\n        return r3_identifiers_1.Identifiers.propertyInterpolate6;\n\n      case 15:\n        return r3_identifiers_1.Identifiers.propertyInterpolate7;\n\n      case 17:\n        return r3_identifiers_1.Identifiers.propertyInterpolate8;\n\n      default:\n        return r3_identifiers_1.Identifiers.propertyInterpolateV;\n    }\n  }\n  /**\n   * Gets the instruction to generate for an interpolated attribute\n   * @param interpolation An Interpolation AST\n   */\n\n\n  function getAttributeInterpolationExpression(interpolation) {\n    switch (util_4.getInterpolationArgsLength(interpolation)) {\n      case 3:\n        return r3_identifiers_1.Identifiers.attributeInterpolate1;\n\n      case 5:\n        return r3_identifiers_1.Identifiers.attributeInterpolate2;\n\n      case 7:\n        return r3_identifiers_1.Identifiers.attributeInterpolate3;\n\n      case 9:\n        return r3_identifiers_1.Identifiers.attributeInterpolate4;\n\n      case 11:\n        return r3_identifiers_1.Identifiers.attributeInterpolate5;\n\n      case 13:\n        return r3_identifiers_1.Identifiers.attributeInterpolate6;\n\n      case 15:\n        return r3_identifiers_1.Identifiers.attributeInterpolate7;\n\n      case 17:\n        return r3_identifiers_1.Identifiers.attributeInterpolate8;\n\n      default:\n        return r3_identifiers_1.Identifiers.attributeInterpolateV;\n    }\n  }\n  /**\n   * Gets the instruction to generate for interpolated text.\n   * @param interpolation An Interpolation AST\n   */\n\n\n  function getTextInterpolationExpression(interpolation) {\n    switch (util_4.getInterpolationArgsLength(interpolation)) {\n      case 1:\n        return r3_identifiers_1.Identifiers.textInterpolate;\n\n      case 3:\n        return r3_identifiers_1.Identifiers.textInterpolate1;\n\n      case 5:\n        return r3_identifiers_1.Identifiers.textInterpolate2;\n\n      case 7:\n        return r3_identifiers_1.Identifiers.textInterpolate3;\n\n      case 9:\n        return r3_identifiers_1.Identifiers.textInterpolate4;\n\n      case 11:\n        return r3_identifiers_1.Identifiers.textInterpolate5;\n\n      case 13:\n        return r3_identifiers_1.Identifiers.textInterpolate6;\n\n      case 15:\n        return r3_identifiers_1.Identifiers.textInterpolate7;\n\n      case 17:\n        return r3_identifiers_1.Identifiers.textInterpolate8;\n\n      default:\n        return r3_identifiers_1.Identifiers.textInterpolateV;\n    }\n  }\n  /**\n   * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n   *\n   * @param template text of the template to parse\n   * @param templateUrl URL to use for source mapping of the parsed template\n   * @param options options to modify how the template is parsed\n   */\n\n\n  function parseTemplate(template, templateUrl, options) {\n    var _a;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var interpolationConfig = options.interpolationConfig,\n        preserveWhitespaces = options.preserveWhitespaces,\n        enableI18nLegacyMessageIdFormat = options.enableI18nLegacyMessageIdFormat;\n    var isInline = (_a = options.isInline) !== null && _a !== void 0 ? _a : false;\n    var bindingParser = makeBindingParser(interpolationConfig);\n    var htmlParser = new html_parser_1.HtmlParser();\n    var parseResult = htmlParser.parse(template, templateUrl, tslib_1.__assign(tslib_1.__assign({\n      leadingTriviaChars: exports.LEADING_TRIVIA_CHARS\n    }, options), {\n      tokenizeExpansionForms: true\n    }));\n\n    if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {\n      var parsedTemplate_1 = {\n        interpolationConfig: interpolationConfig,\n        preserveWhitespaces: preserveWhitespaces,\n        template: template,\n        templateUrl: templateUrl,\n        isInline: isInline,\n        errors: parseResult.errors,\n        nodes: [],\n        styleUrls: [],\n        styles: [],\n        ngContentSelectors: []\n      };\n\n      if (options.collectCommentNodes) {\n        parsedTemplate_1.commentNodes = [];\n      }\n\n      return parsedTemplate_1;\n    }\n\n    var rootNodes = parseResult.rootNodes; // process i18n meta information (scan attributes, generate ids)\n    // before we run whitespace removal process, because existing i18n\n    // extraction process (ng extract-i18n) relies on a raw content to generate\n    // message ids\n\n    var i18nMetaVisitor = new meta_1.I18nMetaVisitor(interpolationConfig,\n    /* keepI18nAttrs */\n    !preserveWhitespaces, enableI18nLegacyMessageIdFormat);\n    var i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n\n    if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {\n      var parsedTemplate_2 = {\n        interpolationConfig: interpolationConfig,\n        preserveWhitespaces: preserveWhitespaces,\n        template: template,\n        templateUrl: templateUrl,\n        isInline: isInline,\n        errors: i18nMetaResult.errors,\n        nodes: [],\n        styleUrls: [],\n        styles: [],\n        ngContentSelectors: []\n      };\n\n      if (options.collectCommentNodes) {\n        parsedTemplate_2.commentNodes = [];\n      }\n\n      return parsedTemplate_2;\n    }\n\n    rootNodes = i18nMetaResult.rootNodes;\n\n    if (!preserveWhitespaces) {\n      rootNodes = html.visitAll(new html_whitespaces_1.WhitespaceVisitor(), rootNodes); // run i18n meta visitor again in case whitespaces are removed (because that might affect\n      // generated i18n message content) and first pass indicated that i18n content is present in a\n      // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n      // mimic existing extraction process (ng extract-i18n)\n\n      if (i18nMetaVisitor.hasI18nMeta) {\n        rootNodes = html.visitAll(new meta_1.I18nMetaVisitor(interpolationConfig,\n        /* keepI18nAttrs */\n        false), rootNodes);\n      }\n    }\n\n    var _b = r3_template_transform_1.htmlAstToRender3Ast(rootNodes, bindingParser, {\n      collectCommentNodes: !!options.collectCommentNodes\n    }),\n        nodes = _b.nodes,\n        errors = _b.errors,\n        styleUrls = _b.styleUrls,\n        styles = _b.styles,\n        ngContentSelectors = _b.ngContentSelectors,\n        commentNodes = _b.commentNodes;\n\n    errors.push.apply(errors, tslib_1.__spread(parseResult.errors, i18nMetaResult.errors));\n    var parsedTemplate = {\n      interpolationConfig: interpolationConfig,\n      preserveWhitespaces: preserveWhitespaces,\n      errors: errors.length > 0 ? errors : null,\n      template: template,\n      templateUrl: templateUrl,\n      isInline: isInline,\n      nodes: nodes,\n      styleUrls: styleUrls,\n      styles: styles,\n      ngContentSelectors: ngContentSelectors\n    };\n\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = commentNodes;\n    }\n\n    return parsedTemplate;\n  }\n\n  exports.parseTemplate = parseTemplate;\n  var elementRegistry = new dom_element_schema_registry_1.DomElementSchemaRegistry();\n  /**\n   * Construct a `BindingParser` with a default configuration.\n   */\n\n  function makeBindingParser(interpolationConfig) {\n    if (interpolationConfig === void 0) {\n      interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;\n    }\n\n    return new binding_parser_1.BindingParser(new parser_1.IvyParser(new lexer_1.Lexer()), interpolationConfig, elementRegistry, null, []);\n  }\n\n  exports.makeBindingParser = makeBindingParser;\n\n  function resolveSanitizationFn(context, isAttribute) {\n    switch (context) {\n      case core.SecurityContext.HTML:\n        return o.importExpr(r3_identifiers_1.Identifiers.sanitizeHtml);\n\n      case core.SecurityContext.SCRIPT:\n        return o.importExpr(r3_identifiers_1.Identifiers.sanitizeScript);\n\n      case core.SecurityContext.STYLE:\n        // the compiler does not fill in an instruction for [style.prop?] binding\n        // values because the style algorithm knows internally what props are subject\n        // to sanitization (only [attr.style] values are explicitly sanitized)\n        return isAttribute ? o.importExpr(r3_identifiers_1.Identifiers.sanitizeStyle) : null;\n\n      case core.SecurityContext.URL:\n        return o.importExpr(r3_identifiers_1.Identifiers.sanitizeUrl);\n\n      case core.SecurityContext.RESOURCE_URL:\n        return o.importExpr(r3_identifiers_1.Identifiers.sanitizeResourceUrl);\n\n      default:\n        return null;\n    }\n  }\n\n  exports.resolveSanitizationFn = resolveSanitizationFn;\n\n  function trustedConstAttribute(tagName, attr) {\n    var value = util_4.asLiteral(attr.value);\n\n    if (trusted_types_sinks_1.isTrustedTypesSink(tagName, attr.name)) {\n      switch (elementRegistry.securityContext(tagName, attr.name,\n      /* isAttribute */\n      true)) {\n        case core.SecurityContext.HTML:\n          return o.taggedTemplate(o.importExpr(r3_identifiers_1.Identifiers.trustConstantHtml), new o.TemplateLiteral([new o.TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n        // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\n\n        case core.SecurityContext.RESOURCE_URL:\n          return o.taggedTemplate(o.importExpr(r3_identifiers_1.Identifiers.trustConstantResourceUrl), new o.TemplateLiteral([new o.TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n\n        default:\n          return value;\n      }\n    } else {\n      return value;\n    }\n  }\n\n  function isSingleElementTemplate(children) {\n    return children.length === 1 && children[0] instanceof t.Element;\n  }\n\n  function isTextNode(node) {\n    return node instanceof t.Text || node instanceof t.BoundText || node instanceof t.Icu;\n  }\n\n  function hasTextChildrenOnly(children) {\n    return children.every(isTextNode);\n  }\n  /** Name of the global variable that is used to determine if we use Closure translations or not */\n\n\n  var NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n  /**\n   * Generate statements that define a given translation message.\n   *\n   * ```\n   * var I18N_1;\n   * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n   *     var MSG_EXTERNAL_XXX = goog.getMsg(\n   *          \"Some message with {$interpolation}!\",\n   *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n   *     );\n   *     I18N_1 = MSG_EXTERNAL_XXX;\n   * }\n   * else {\n   *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n   * }\n   * ```\n   *\n   * @param message The original i18n AST message node\n   * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n   * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n   * @param params Object mapping placeholder names to their values (e.g.\n   * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n   * @param transformFn Optional transformation function that will be applied to the translation (e.g.\n   * post-processing).\n   * @returns An array of statements that defined a given translation.\n   */\n\n  function getTranslationDeclStmts(message, variable, closureVar, params, transformFn) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    var statements = [util_3.declareI18nVariable(variable), o.ifStmt(createClosureModeGuard(), get_msg_utils_1.createGoogleGetMsgStatements(variable, message, closureVar, util_3.i18nFormatPlaceholderNames(params,\n    /* useCamelCase */\n    true)), localize_utils_1.createLocalizeStatements(variable, message, util_3.i18nFormatPlaceholderNames(params,\n    /* useCamelCase */\n    false)))];\n\n    if (transformFn) {\n      statements.push(new o.ExpressionStatement(variable.set(transformFn(variable))));\n    }\n\n    return statements;\n  }\n\n  exports.getTranslationDeclStmts = getTranslationDeclStmts;\n  /**\n   * Create the expression that will be used to guard the closure mode block\n   * It is equivalent to:\n   *\n   * ```\n   * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n   * ```\n   */\n\n  function createClosureModeGuard() {\n    return o.typeofExpr(o.variable(NG_I18N_CLOSURE_MODE)).notIdentical(o.literal('undefined', o.STRING_TYPE)).and(o.variable(NG_I18N_CLOSURE_MODE));\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/view/template.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,kBAAA,GAAA,OAAA,CAAA,wCAAA,CAAA;;AACA,MAAA,sBAAA,GAAA,OAAA,CAAA,0DAAA,CAAA;;AAEA,MAAA,IAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,+CAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,gDAAA,CAAA;;AAEA,MAAA,IAAA,GAAA,OAAA,CAAA,qCAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,kBAAA,GAAA,OAAA,CAAA,kDAAA,CAAA;;AACA,MAAA,sBAAA,GAAA,OAAA,CAAA,sDAAA,CAAA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,sCAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AAEA,MAAA,6BAAA,GAAA,OAAA,CAAA,0DAAA,CAAA;;AACA,MAAA,qBAAA,GAAA,OAAA,CAAA,kDAAA,CAAA;;AACA,MAAA,UAAA,GAAA,OAAA,CAAA,gCAAA,CAAA;;AACA,MAAA,gBAAA,GAAA,OAAA,CAAA,sDAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,sCAAA,CAAA;;AACA,MAAA,gBAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AACA,MAAA,uBAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,oCAAA,CAAA;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,iDAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,uDAAA,CAAA;;AACA,MAAA,gBAAA,GAAA,OAAA,CAAA,wDAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,oDAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,yCAAA,CAAA,C,CAIA;;;AACA,MAAM,sBAAsB,GAAG,QAA/B,C,CAEA;;AACA,MAAM,uBAAuB,GAAG,aAAhC,C,CAEA;;AACA,MAAM,2BAA2B,GAAG,IAAI,GAAJ,CAAgB,CAAC,QAAD,CAAhB,CAApC,C,CAEA;;AACA,MAAM,uBAAuB,GAAG,IAAI,GAAJ,CAC5B,CAAC,CAAC,QAAD,EAAW,gBAAA,CAAA,WAAA,CAAG,aAAd,CAAD,EAA+B,CAAC,UAAD,EAAa,gBAAA,CAAA,WAAA,CAAG,eAAhB,CAA/B,EAAiE,CAAC,MAAD,EAAS,gBAAA,CAAA,WAAA,CAAG,WAAZ,CAAjE,CAD4B,CAAhC;AAGa,EAAA,OAAA,CAAA,oBAAA,GAAuB,CAAC,GAAD,EAAM,IAAN,EAAY,IAAZ,EAAkB,IAAlB,CAAvB,C,CAEb;;AACA,WAAgB,qBAAhB,CACI,KADJ,EAC6B,UAD7B,EACsD;AACpD,WAAO,CAAC,CAAC,MAAF,CAAS,CAAC,CAAC,QAAF,CAAW,MAAA,CAAA,YAAX,EAAyB,UAAzB,CAAoC,CAAC,CAAC,OAAF,CAAU,KAAV,CAApC,EAAsD,IAAtD,EAA4D,KAA5D,CAAT,EAA6E,UAA7E,CAAP;AACD;;AAHD,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AAKA,WAAgB,8BAAhB,CACI,QADJ,EAC4B,WAD5B,EAEI,KAFJ,EAEmC;AADP,QAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,WAAA,GAAA,IAAA;AAA+B;;AACvD,QAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,KAAA,GAAA,IAAA;AAA+B;;AAC1B,QAAA,IAAI,GAAkC,QAAQ,CAA1C,IAAJ;AAAA,QAAM,IAAI,GAA4B,QAAQ,CAApC,IAAV;AAAA,QAAY,MAAM,GAAoB,QAAQ,CAA5B,MAAlB;AAAA,QAAoB,KAAK,GAAa,QAAQ,CAArB,KAAzB;AAAA,QAA2B,OAAO,GAAI,QAAQ,CAAZ,OAAlC;;AACP,QAAI,MAAM,IAAI,CAAC,uBAAuB,CAAC,GAAxB,CAA4B,MAA5B,CAAf,EAAoD;AAClD,YAAM,IAAI,KAAJ,CAAU,+BAA6B,MAA7B,GAAmC,iBAAnC,GAAqD,IAArD,GAAyD,sDAAzD,GACwB,KAAK,CAAC,IAAN,CAAW,uBAAuB,CAAC,IAAxB,EAAX,CADxB,GACkE,GAD5E,CAAN;AAED;;AAED,QAAM,iBAAiB,GAAG,QAA1B;AACA,QAAM,wBAAwB,GAAG,IAAI,GAAJ,EAAjC;AACA,QAAM,oBAAoB,GAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,CAAC,YAAN,KAAuB,CAA1C,GACzB,CAAC,CAAC,QAAF,CAAW,MAAA,CAAA,YAAX,CADyB,GAEzB,KAAK,CAAC,2BAAN,CAAkC,CAAlC,CAFJ;AAGA,QAAM,WAAW,GAAG,sBAAA,CAAA,oBAAA,CAChB,KADgB,EACT,oBADS,EACa,OADb,EACsB,GADtB,EAC2B,YAAA;AAAM,aAAA,MAAA,CAAA,KAAA,CAAA,0BAAA,CAAA;AAAiC,KADlE,EAEhB,QAAQ,CAAC,WAFO,EAEM,wBAFN,EAEgC,2BAFhC,CAApB;AAGA,QAAM,UAAU,GAAG,EAAnB;;AACA,QAAI,KAAJ,EAAW;AACT,MAAA,UAAU,CAAC,IAAX,CAAe,KAAf,CAAA,UAAA,EAAU,OAAA,CAAA,QAAA,CAAS,KAAK,CAAC,oBAAN,EAAT,CAAV;AACA,MAAA,UAAU,CAAC,IAAX,CAAe,KAAf,CAAA,UAAA,EAAU,OAAA,CAAA,QAAA,CAAS,KAAK,CAAC,oBAAN,EAAT,CAAV;AACD;;AACD,IAAA,UAAU,CAAC,IAAX,CAAe,KAAf,CAAA,UAAA,EAAU,OAAA,CAAA,QAAA,CAAS,WAAW,CAAC,YAArB,CAAV;AAEA,QAAM,SAAS,GACX,IAAI,KAAA;AAAA;AAAJ,MAAqC,MAAA,CAAA,4BAAA,CAA6B,IAA7B,EAAmC,KAAnC,CAArC,GAAkF,IADtF;AAEA,QAAM,MAAM,GAAG,WAAW,IAAI,kBAAA,CAAA,kBAAA,CAAmB,WAAnB,CAA9B;AACA,QAAM,MAAM,GAAgB,EAA5B;;AAEA,QAAI,wBAAwB,CAAC,GAAzB,CAA6B,iBAA7B,CAAJ,EAAqD;AACnD,MAAA,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,CAAC,OAAN,CAAc,iBAAd,EAAiC,CAAC,CAAC,YAAnC,CAAZ;AACD;;AAED,QAAM,SAAS,GAAG,CAAC,CAAC,EAAF,CAAK,MAAL,EAAa,UAAb,EAAyB,CAAC,CAAC,aAA3B,EAA0C,IAA1C,EAAgD,MAAhD,CAAlB;AACA,QAAM,MAAM,GAAmB,CAAC,CAAC,CAAC,OAAF,CAAU,SAAV,CAAD,EAAuB,SAAvB,CAA/B;;AACA,QAAI,MAAJ,EAAY;AACV,MAAA,MAAM,CAAC,IAAP,CACI,CAAC,CAAC,OAAF,CAAU,KAAV,CADJ,EACuB;AACnB,MAAA,CAAC,CAAC,UAAF,CAAa,uBAAuB,CAAC,GAAxB,CAA4B,MAA5B,CAAb,CAFJ;AAGD;;AACD,WAAO,MAAP;AACD;;AAzCD,EAAA,OAAA,CAAA,8BAAA,GAAA,8BAAA;;AA+DA,WAAS,wBAAT,GAAiC;AAC/B,WAAO;AACL,MAAA,iBAAiB,EAAE,EADd;AAEL,MAAA,gBAAgB,EAAE,EAFb;AAGL,MAAA,gBAAgB,EAAE,IAAI,GAAJ;AAHb,KAAP;AAKD;;AAED,MAAA,yBAAA;AAAA;AAAA,cAAA;AA6DE,aAAA,yBAAA,CACY,YADZ,EACwC,kBADxC,EACkF,KADlF,EAEY,WAFZ,EAE8C,WAF9C,EAGY,aAHZ,EAGgD,YAHhD,EAIY,gBAJZ,EAI4D,UAJ5D,EAKY,cALZ,EAK+D,KAL/D,EAMY,UANZ,EAM6C,uBAN7C,EAOY,kBAPZ,EAQY,UARZ,EAQuE;AARvE,UAAA,KAAA,GAAA,IAAA;;AACkF,UAAA,KAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,KAAA,GAAA,CAAA;AAAS;;AAO/E,UAAA,UAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,UAAA,GAAiC,wBAAwB,EAAzD;AAA2D;;AAP3D,WAAA,YAAA,GAAA,YAAA;AAAsE,WAAA,KAAA,GAAA,KAAA;AACtE,WAAA,WAAA,GAAA,WAAA;AAAkC,WAAA,WAAA,GAAA,WAAA;AAClC,WAAA,aAAA,GAAA,aAAA;AAAoC,WAAA,YAAA,GAAA,YAAA;AACpC,WAAA,gBAAA,GAAA,gBAAA;AAAgD,WAAA,UAAA,GAAA,UAAA;AAChD,WAAA,cAAA,GAAA,cAAA;AAAmD,WAAA,KAAA,GAAA,KAAA;AACnD,WAAA,UAAA,GAAA,UAAA;AACA,WAAA,kBAAA,GAAA,kBAAA;AACA,WAAA,UAAA,GAAA,UAAA;AApEJ,WAAA,UAAA,GAAa,CAAb;AACA,WAAA,eAAA,GAAkB,CAAlB;AACA,WAAA,WAAA,GAA6B,EAA7B;AACR;;;;AAIG;;AACK,WAAA,gBAAA,GAA0C,EAA1C;AACR;;;;AAIG;;AACK,WAAA,cAAA,GAAwC,EAAxC;AAER;;AACQ,WAAA,aAAA,GAAwB,CAAxB;AAER;;AACQ,WAAA,cAAA,GAAgC,EAAhC;AACR;;;;;AAKG;;AACK,WAAA,kBAAA,GAAqC,EAArC;AAOA,WAAA,YAAA,GAAe,MAAA,CAAA,WAAf,CAkC+D,CAhCvE;;AACQ,WAAA,IAAA,GAAyB,IAAzB,CA+B+D,CA7BvE;;AACQ,WAAA,kBAAA,GAAqB,CAArB,CA4B+D,CA1BvE;;AACQ,WAAA,aAAA,GAAgB,CAAhB,CAyB+D,CArBvE;AACA;AACA;;AACQ,WAAA,uBAAA,GAA0C,EAA1C,CAkB+D,CAhBvE;AACA;;AACQ,WAAA,yBAAA,GAA4B,CAA5B,CAc+D,CAZvE;AACA;;AACQ,WAAA,qBAAA,GAA4C,IAA5C,CAU+D,CAgvBvE;;AACS,WAAA,cAAA,GAAiB,MAAA,CAAA,OAAjB;AACA,WAAA,aAAA,GAAgB,MAAA,CAAA,OAAhB;AACA,WAAA,kBAAA,GAAqB,MAAA,CAAA,OAArB;AACA,WAAA,mBAAA,GAAsB,MAAA,CAAA,OAAtB;AACA,WAAA,eAAA,GAAkB,MAAA,CAAA,OAAlB;AApvBP,WAAK,aAAL,GAAqB,kBAAkB,CAAC,WAAnB,CAA+B,KAA/B,CAArB,CADqE,CAGrE;AACA;;AACA,WAAK,mBAAL,GAA2B,uBAAuB,CAAC,OAAxB,CAAgC,eAAhC,EAAiD,GAAjD,IAAwD,GAAnF;AAEA,WAAK,eAAL,GAAuB,IAAI,cAAJ,CACnB,YADmB,EACL,YAAA;AAAM,eAAA,KAAI,CAAJ,gBAAA,EAAA;AAAuB,OADxB,EAEnB,UAAC,QAAD,EAAiB;AAAK,eAAA,KAAI,CAAC,yBAAL,CAAA,QAAA,CAAA;AAAwC,OAF3C,EAGnB,UAAC,IAAD,EAAO,SAAP,EAAkB,IAAlB,EAAwB,KAAxB,EAA2C;AACzC,YAAM,QAAQ,GAAG,cAAc,CAAC,GAAf,CAAmB,IAAnB,CAAjB;;AACA,YAAI,QAAJ,EAAc;AACZ,UAAA,KAAI,CAAC,KAAL,CAAW,GAAX,CAAe,QAAf;AACD;;AACD,QAAA,KAAI,CAAC,aAAL,CAAmB,GAAnB,CAAuB,KAAI,CAAC,KAA5B,EAAmC,SAAnC,EAA8C,KAA9C;;AACA,QAAA,KAAI,CAAC,mBAAL,CAAyB,IAAzB,EAA+B,gBAAA,CAAA,WAAA,CAAG,IAAlC,EAAwC,CAAC,CAAC,CAAC,OAAF,CAAU,IAAV,CAAD,EAAkB,CAAC,CAAC,OAAF,CAAU,IAAV,CAAlB,CAAxC;AACD,OAVkB,CAAvB;AAWD;;AAED,IAAA,yBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UACI,KADJ,EACqB,SADrB,EAC8C,wBAD9C,EAEI,IAFJ,EAEwB;AAFxB,UAAA,KAAA,GAAA,IAAA;;AAC8C,UAAA,wBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,wBAAA,GAAA,CAAA;AAAoC;;AAEhF,WAAK,yBAAL,GAAiC,wBAAjC;;AAEA,UAAI,KAAK,UAAL,KAAoB,gBAAA,CAAA,WAAA,CAAG,aAA3B,EAA0C;AACxC,aAAK,mBAAL,CAAyB,IAAzB,EAA+B,KAAK,UAApC;AACD,OALqB,CAOtB;;;AACA,MAAA,SAAS,CAAC,OAAV,CAAkB,UAAA,CAAA,EAAC;AAAI,eAAA,KAAI,CAAC,wBAAL,CAAA,CAAA,CAAA;AAAgC,OAAvD,EARsB,CAUtB;AACA;AACA;AACA;;AACA,UAAM,eAAe,GAAG,KAAK,WAAL,IACnB,MAAA,CAAA,cAAA,CAAe,IAAf,KAAwB,CAAC,MAAA,CAAA,eAAA,CAAgB,IAAhB,CAAzB,IACA,EAAE,uBAAuB,CAAC,KAAD,CAAvB,IAAkC,KAAK,CAAC,CAAD,CAAL,CAAS,IAAT,KAAkB,IAAtD,CAFL;AAGA,UAAM,0BAA0B,GAAG,mBAAmB,CAAC,KAAD,CAAtD;;AACA,UAAI,eAAJ,EAAqB;AACnB,aAAK,SAAL,CAAe,IAAf,EAAqB,IAArB,EAA4B,0BAA5B;AACD,OApBqB,CAsBtB;AACA;AACA;AACA;;;AACA,MAAA,CAAC,CAAC,QAAF,CAAW,IAAX,EAAiB,KAAjB,EA1BsB,CA4BtB;AACA;;AACA,WAAK,kBAAL,IAA2B,KAAK,aAAhC,CA9BsB,CAgCtB;AACA;AACA;;AACA,WAAK,eAAL,CAAqB,qBAArB,CAA2C,KAAK,aAAhD,EAnCsB,CAqCtB;AACA;;;AACA,WAAK,kBAAL,CAAwB,OAAxB,CAAgC,UAAA,eAAA,EAAe;AAAI,eAAA,eAAA,EAAA;AAAiB,OAApE,EAvCsB,CAyCtB;AACA;AACA;;;AACA,UAAI,KAAK,KAAL,KAAe,CAAf,IAAoB,KAAK,uBAAL,CAA6B,MAArD,EAA6D;AAC3D,YAAM,UAAU,GAAmB,EAAnC,CAD2D,CAG3D;AACA;AACA;;AACA,YAAI,KAAK,uBAAL,CAA6B,MAA7B,GAAsC,CAAtC,IAA2C,KAAK,uBAAL,CAA6B,CAA7B,MAAoC,GAAnF,EAAwF;AACtF,cAAM,eAAe,GAAG,KAAK,uBAAL,CAA6B,GAA7B,CACpB,UAAA,CAAA,EAAC;AAAI,mBAAA,CAAC,KAAK,GAAN,GAAY,IAAI,CAAC,yBAAL,CAA+B,CAA/B,CAAZ,GAAA,CAAA;AAAiD,WADlC,CAAxB;;AAEA,UAAA,UAAU,CAAC,IAAX,CAAgB,KAAK,YAAL,CAAkB,eAAlB,CAAkC,MAAA,CAAA,SAAA,CAAU,eAAV,CAAlC,EAA8D,IAA9D,CAAhB;AACD,SAV0D,CAY3D;AACA;AACA;;;AACA,aAAK,mBAAL,CAAyB,IAAzB,EAA+B,gBAAA,CAAA,WAAA,CAAG,aAAlC,EAAiD,UAAjD;AAA6D;AAAc,YAA3E;AACD;;AAED,UAAI,eAAJ,EAAqB;AACnB,aAAK,OAAL,CAAa,IAAb,EAAmB,0BAAnB;AACD,OAhEqB,CAkEtB;;;AACA,UAAM,kBAAkB,GAAG,KAAK,gBAAL,CAAsB,GAAtB,CAA0B,UAAC,EAAD,EAAsB;AAAK,eAAA,EAAA,EAAA;AAAI,OAAzD,CAA3B,CAnEsB,CAqEtB;;;AACA,UAAM,gBAAgB,GAAG,KAAK,cAAL,CAAoB,GAApB,CAAwB,UAAC,EAAD,EAAsB;AAAK,eAAA,EAAA,EAAA;AAAI,OAAvD,CAAzB,CAtEsB,CAwEtB;AACA;AACA;;;AACA,UAAM,iBAAiB,GAAG,KAAK,aAAL,CAAmB,sBAAnB,EAA1B;;AACA,UAAM,eAAe,GAAG,KAAK,aAAL,CAAmB,oBAAnB,GAA0C,MAA1C,CAAiD,KAAK,cAAtD,CAAxB;;AAEA,UAAM,aAAa,GAAG,kBAAkB,CAAC,MAAnB,GAA4B,CAA5B,GAClB,CAAC,qBAAqB,CAAA;AAAA;AAAA,QACO,iBAAiB,CAAC,MAAlB,CAAyB,kBAAzB,CADP,CAAtB,CADkB,GAGlB,EAHJ;AAKA,UAAM,WAAW,GAAG,gBAAgB,CAAC,MAAjB,GAA0B,CAA1B,GAChB,CAAC,qBAAqB,CAAA;AAAA;AAAA,QAA0B,eAAe,CAAC,MAAhB,CAAuB,gBAAvB,CAA1B,CAAtB,CADgB,GAEhB,EAFJ;AAIA,aAAO,CAAC,CAAC,EAAF,EACH;AACA,OAAC,IAAI,CAAC,CAAC,OAAN,CAAc,MAAA,CAAA,YAAd,EAA4B,CAAC,CAAC,WAA9B,CAAD,EAA6C,IAAI,CAAC,CAAC,OAAN,CAAc,MAAA,CAAA,YAAd,EAA4B,IAA5B,CAA7C,CAFG,EAE4E,OAAA,CAAA,QAAA,CAG1E,KAAK,WAHqE,EAK1E,aAL0E,EAO1E,WAP0E,CAF5E,EAWH,CAAC,CAAC,aAXC,EAWc,IAXd,EAWoB,KAAK,YAXzB,CAAP;AAYD,KArGD,CAzFF,CAgME;;;AACA,IAAA,yBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,IAAT,EAAqB;AACnB,aAAO,KAAK,aAAL,CAAmB,GAAnB,CAAuB,IAAvB,CAAP;AACD,KAFD,CAjMF,CAqME;;;AACA,IAAA,yBAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,YAAA;AACE,WAAK,aAAL,CAAmB,yBAAnB;AACD,KAFD;;AAIQ,IAAA,yBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UACI,OADJ,EAC2B,MAD3B,EACwE,GADxE,EAEI,WAFJ,EAEsD;;;AAD3B,UAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,MAAA,GAAA,EAAA;AAA2C;;AAEpE,UAAM,IAAI,GAAG,GAAG,IAAI,KAAK,wBAAL,EAApB,CADoD,CAEpD;AACA;;;AACA,UAAM,UAAU,GAAG,KAAK,sBAAL,CAA4B,OAAO,CAAC,EAApC,CAAnB;AACA,UAAM,UAAU,GAAG,uBAAuB,CAAC,OAAD,EAAU,IAAV,EAAgB,UAAhB,EAA4B,MAA5B,EAAoC,WAApC,CAA1C;;AACA,OAAA,EAAA,GAAA,KAAK,UAAL,CAAgB,iBAAhB,EAAkC,IAAlC,CAAsC,KAAtC,CAAsC,EAAtC,EAAsC,OAAA,CAAA,QAAA,CAAI,UAAJ,CAAtC;;AACA,aAAO,IAAP;AACD,KAVO;;AAYA,IAAA,yBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,QAAjC,EAAqD;AACnD,UAAM,UAAU,GAAG,KAAK,aAAL,CAAmB,kBAAnB,EAAnB;;AACA,UAAM,cAAc,GAAG,KAAK,KAA5B;AACA,UAAM,GAAG,GAAG,CAAC,CAAC,QAAF,CAAW,QAAQ,CAAC,IAAT,GAAgB,UAA3B,CAAZ;;AACA,WAAK,aAAL,CAAmB,GAAnB,CACI,cADJ,EACoB,QAAQ,CAAC,IAD7B,EACmC,GADnC,EACsC;AAAA;AADtC,QAEI,UAAC,KAAD,EAAsB,aAAtB,EAA2C;AACzC,YAAI,GAAJ;;AACA,YAAI,KAAK,CAAC,YAAN,KAAuB,cAA3B,EAA2C;AACzC;AACA,UAAA,GAAG,GAAG,CAAC,CAAC,QAAF,CAAW,MAAA,CAAA,YAAX,CAAN;AACD,SAHD,MAGO;AACL,cAAM,YAAY,GAAG,KAAK,CAAC,oBAAN,CAA2B,cAA3B,CAArB,CADK,CAEL;;AACA,UAAA,GAAG,GAAG,YAAY,GAAG,YAAH,GAAkB,uBAAuB,CAAC,aAAD,CAA3D;AACD,SATwC,CAUzC;;;AACA,eAAO,CAAC,GAAG,CAAC,GAAJ,CAAQ,GAAG,CAAC,IAAJ,CAAS,QAAQ,CAAC,KAAT,IAAkB,MAAA,CAAA,kBAA3B,CAAR,EAAwD,WAAxD,EAAD,CAAP;AACD,OAdL;AAeD,KAnBO;;AAqBA,IAAA,yBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,WAA3B,EAA6C;AAA7C,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,WAAW,CAAC,MAAZ,GAAqB,CAAzB,EAA4B;AAC1B,QAAA,WAAW,CAAC,OAAZ,CAAoB,UAAA,UAAA,EAAU;AAAI,iBAAA,KAAI,CAAC,IAAL,CAAW,aAAX,CAAA,UAAA,CAAA;AAAoC,SAAtE;AACD;AACF,KAJO;;AAMA,IAAA,yBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,KAAtB,EAAgE;AAAhE,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,KAAK,GAAkC,EAA7C;AACA,MAAA,MAAM,CAAC,IAAP,CAAY,KAAZ,EAAmB,OAAnB,CAA2B,UAAA,GAAA,EAAG;AAC5B,YAAM,IAAI,GAAG,KAAK,CAAC,GAAD,CAAlB;;AACA,YAAI,IAAI,YAAY,CAAC,CAAC,IAAtB,EAA4B;AAC1B,UAAA,KAAK,CAAC,GAAD,CAAL,GAAa,CAAC,CAAC,OAAF,CAAU,IAAI,CAAC,KAAf,CAAb;AACD,SAFD,MAEO;AACL,cAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,KAAI,CAAC,eAAtB,CAAd;;AACA,UAAA,KAAI,CAAC,oBAAL,CAA0B,KAA1B;;AACA,cAAI,KAAK,YAAY,KAAA,CAAA,aAArB,EAAoC;AAC3B,gBAAA,OAAO,GAAiB,KAAK,CAAtB,OAAP;AAAA,gBAAS,WAAW,GAAI,KAAK,CAAT,WAApB;AACD,gBAAA,EAAA,GAAiB,KAAI,CAAC,IAAtB;AAAA,gBAAC,EAAE,GAAA,EAAA,CAAA,EAAH;AAAA,gBAAK,QAAQ,GAAA,EAAA,CAAA,QAAb;AACN,gBAAM,KAAK,GAAG,MAAA,CAAA,uBAAA,CAAwB,OAAxB,EAAiC,QAAQ,CAAC,IAA1C,EAAgD,EAAhD,CAAd;;AACA,YAAA,KAAI,CAAC,kBAAL,CAAwB,WAAxB;;AACA,YAAA,KAAK,CAAC,GAAD,CAAL,GAAa,CAAC,CAAC,OAAF,CAAU,KAAV,CAAb;AACD;AACF;AACF,OAfD;AAgBA,aAAO,KAAP;AACD,KAnBO,CAjPV,CAsQE;;;AACQ,IAAA,yBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,YAAA;AACE,aAAO,CAAC,CAAC,QAAF,CAAW,KAAK,YAAL,CAAkB,UAAlB,CAA6B,MAAA,CAAA,sBAA7B,CAAX,CAAP;AACD,KAFO,CAvQV,CA2QE;;;AACQ,IAAA,yBAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B,SAA/B,EAAgD;AAC9C,UAAI,IAAJ;AACA,UAAM,MAAM,GAAG,KAAK,mBAAL,CAAyB,WAAzB,EAAf;;AACA,UAAI,KAAK,kBAAT,EAA6B;AAC3B,YAAM,MAAM,GAAG,MAAA,CAAA,yBAAA,CAA0B,WAA1B,CAAf;AACA,YAAM,YAAY,GAAG,KAAK,YAAL,CAAkB,UAAlB,CAA6B,MAA7B,CAArB;AACA,QAAA,IAAI,GAAG,KAAG,MAAH,GAAY,kBAAA,CAAA,kBAAA,CAAmB,SAAnB,CAAZ,GAAyC,IAAzC,GAA8C,YAArD;AACD,OAJD,MAIO;AACL,YAAM,MAAM,GAAG,MAAA,CAAA,yBAAA,CAA0B,MAA1B,CAAf;AACA,QAAA,IAAI,GAAG,KAAK,YAAL,CAAkB,UAAlB,CAA6B,MAA7B,CAAP;AACD;;AACD,aAAO,CAAC,CAAC,QAAF,CAAW,IAAX,CAAP;AACD,KAZO;;AAcA,IAAA,yBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,OAAtB,EAA0C;AACjC,UAAA,IAAI,GAAyC,OAAO,CAAhD,IAAJ;AAAA,UAAM,IAAI,GAAmC,OAAO,CAA1C,IAAV;AAAA,UAAY,MAAM,GAA2B,OAAO,CAAlC,MAAlB;AAAA,UAAoB,UAAU,GAAe,OAAO,CAAtB,UAA9B;AAAA,UAAgC,SAAS,GAAI,OAAO,CAAX,SAAzC;;AACP,UAAI,MAAM,IAAI,UAAV,IAAwB,CAAC,SAAzB,IAAsC,CAAC,MAAA,CAAA,eAAA,CAAgB,IAAhB,CAA3C,EAAkE;AAChE,QAAA,OAAO,CAAC,SAAR,GAAoB,IAApB;AACA,YAAM,YAAY,GAAG,OAAO,CAAC,yBAAR,EAArB;AACA,YAAI,YAAU,GAAmC,EAAjD;AACA,YAAI,QAAM,GACN,YAAY,CAAC,IAAb,GAAoB,MAAA,CAAA,oBAAA,CAAqB,YAArB,CAApB,GAAyD,EAD7D;;AAEA,YAAI,IAAI,CAAC,IAAT,EAAe;AACb,UAAA,IAAI,CAAC,OAAL,CAAa,UAAC,IAAD,EAAuB,GAAvB,EAAkC;AAC7C,gBAAI,IAAI,CAAC,MAAL,KAAgB,CAApB,EAAuB;AACrB;AACA;AACA,cAAA,QAAM,CAAC,GAAD,CAAN,GAAc,IAAI,CAAC,CAAD,CAAlB;AACD,aAJD,MAIO;AACL;AACA;AACA,kBAAM,WAAW,GAAW,MAAA,CAAA,mBAAA,CAAoB,KAAG,MAAA,CAAA,uBAAH,GAA6B,GAAjD,CAA5B;AACA,cAAA,QAAM,CAAC,GAAD,CAAN,GAAc,CAAC,CAAC,OAAF,CAAU,WAAV,CAAd;AACA,cAAA,YAAU,CAAC,GAAD,CAAV,GAAkB,CAAC,CAAC,UAAF,CAAa,IAAb,CAAlB;AACD;AACF,WAZD;AAaD,SApB+D,CAsBhE;AACA;AACA;;;AACA,YAAM,mBAAmB,GACrB,KAAK,CAAC,IAAN,CAAW,YAAY,CAAC,MAAb,EAAX,EAAkC,IAAlC,CAAuC,UAAC,KAAD,EAAgB;AAAK,iBAAA,KAAK,CAAC,MAAN,GAAA,CAAA;AAAgB,SAA5E,KACA,MAAM,CAAC,IAAP,CAAY,YAAZ,EAAwB,MAF5B;AAIA,YAAI,WAAW,GAAA,KAAA,CAAf;;AACA,YAAI,mBAAJ,EAAyB;AACvB,UAAA,WAAW,GAAG,qBAAC,GAAD,EAAmB;AAC/B,gBAAM,IAAI,GAAmB,CAAC,GAAD,CAA7B;;AACA,gBAAI,MAAM,CAAC,IAAP,CAAY,YAAZ,EAAwB,MAA5B,EAAoC;AAClC,cAAA,IAAI,CAAC,IAAL,CAAU,UAAA,CAAA,UAAA,CAAW,YAAX,EAAuB,IAAvB,CAAV;AACD;;AACD,mBAAO,WAAW,CAAC,IAAD,EAAO,gBAAA,CAAA,WAAA,CAAG,eAAV,EAA2B,IAA3B,CAAlB;AACD,WAND;AAOD;;AACD,aAAK,aAAL,CAAmB,IAAnB,EAAyC,QAAzC,EAAiD,OAAO,CAAC,GAAzD,EAA8D,WAA9D;AACD;AACF,KA3CO;;AA6CA,IAAA,yBAAA,CAAA,SAAA,CAAA,SAAA,GAAR,UAAkB,IAAlB,EAAqD,IAArD,EAA0E,WAA1E,EAA+F;AAA7E,UAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,IAAA,GAAA,IAAA;AAAiC;;AAEjD,UAAM,KAAK,GAAG,KAAK,gBAAL,EAAd;AACA,WAAK,IAAL,GAAY,KAAK,WAAL,GACR,KAAK,WAAL,CAAiB,gBAAjB,CAAkC,KAAlC,EAAyC,KAAK,aAA9C,EAA8D,IAA9D,CADQ,GAER,IAAI,SAAA,CAAA,WAAJ,CAAgB,KAAhB,EAAuB,KAAK,wBAAL,EAAvB,EAAwD,CAAxD,EAA2D,KAAK,aAAhE,EAA+E,IAA/E,CAFJ,CAH6F,CAO7F;;AACM,UAAA,EAAA,GAAY,KAAK,IAAjB;AAAA,UAAC,EAAE,GAAA,EAAA,CAAA,EAAH;AAAA,UAAK,GAAG,GAAA,EAAA,CAAA,GAAR;AACN,UAAM,MAAM,GAAmB,CAAC,CAAC,CAAC,OAAF,CAAU,KAAV,CAAD,EAAmB,KAAK,WAAL,CAAiB,GAAjB,CAAnB,CAA/B;;AACA,UAAI,EAAE,GAAG,CAAT,EAAY;AACV;AACA;AACA,QAAA,MAAM,CAAC,IAAP,CAAY,CAAC,CAAC,OAAF,CAAU,EAAV,CAAZ;AACD;;AACD,WAAK,mBAAL,CAAyB,IAAzB,EAA+B,WAAW,GAAG,gBAAA,CAAA,WAAA,CAAG,IAAN,GAAa,gBAAA,CAAA,WAAA,CAAG,SAA1D,EAAqE,MAArE;AACD,KAhBO;;AAkBA,IAAA,yBAAA,CAAA,SAAA,CAAA,OAAA,GAAR,UAAgB,IAAhB,EAAmD,WAAnD,EAAwE;AAAxE,UAAA,KAAA,GAAA,IAAA;;AAAgB,UAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,IAAA,GAAA,IAAA;AAAiC;;AAC/C,UAAI,CAAC,KAAK,IAAV,EAAgB;AACd,cAAM,IAAI,KAAJ,CAAU,kDAAV,CAAN;AACD;;AAED,UAAI,KAAK,WAAT,EAAsB;AACpB,aAAK,WAAL,CAAiB,qBAAjB,CAAuC,KAAK,IAA5C;AACA,aAAK,aAAL,CAAmB,KAAK,WAAxB;AACD,OAHD,MAGO;AACL,aAAK,aAAL,CAAmB,KAAK,IAAxB;AACD,OAVqE,CAYtE;;;AACM,UAAA,EAAA,GAAoB,KAAK,IAAzB;AAAA,UAAC,KAAK,GAAA,EAAA,CAAA,KAAN;AAAA,UAAQ,QAAQ,GAAA,EAAA,CAAA,QAAhB;;AACN,UAAI,QAAQ,CAAC,IAAb,EAAmB;AACjB,YAAM,eAAa,GAAkC,EAArD;AACA,QAAA,QAAQ,CAAC,OAAT,CAAiB,UAAA,OAAA,EAAO;AACtB,UAAA,eAAa,CAAC,IAAd,CAAmB;AAAC,YAAA,UAAU,EAAE,IAAb;AAAmB,YAAA,KAAK,EAAE,iBAAA;AAAM,qBAAA,KAAI,CAAC,sBAAL,CAAA,OAAA,CAAA;AAAoC;AAApE,WAAnB;AACD,SAFD,EAFiB,CAKjB;AACA;AACA;;AACA,aAAK,iCAAL,CAAuC,KAAK,aAAL,KAAuB,CAA9D,EAAiE,gBAAA,CAAA,WAAA,CAAG,OAApE,EAA6E,eAA7E;AACA,aAAK,iBAAL,CAAuB,IAAvB,EAA6B,gBAAA,CAAA,WAAA,CAAG,SAAhC,EAA2C,CAAC,CAAC,CAAC,OAAF,CAAU,KAAV,CAAD,CAA3C;AACD;;AACD,UAAI,CAAC,WAAL,EAAkB;AAChB,aAAK,mBAAL,CAAyB,IAAzB,EAA+B,gBAAA,CAAA,WAAA,CAAG,OAAlC;AACD;;AACD,WAAK,IAAL,GAAY,IAAZ,CA5BsE,CA4BnD;AACpB,KA7BO;;AA+BA,IAAA,yBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UACI,SADJ,EACuB,KADvB,EACkD,UADlD,EAC6E;AAD7E,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAI,WAAW,GAAY,KAA3B;AACA,UAAM,YAAY,GAAmB,EAArC;AACA,UAAM,QAAQ,GAAkC,EAAhD;AACA,MAAA,KAAK,CAAC,OAAN,CAAc,UAAA,IAAA,EAAI;AAChB,YAAM,OAAO,GAAG,IAAI,CAAC,IAArB;AACA,YAAM,SAAS,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,KAAI,CAAC,eAAtB,CAAlB;;AACA,QAAA,KAAI,CAAC,oBAAL,CAA0B,SAA1B;;AACA,YAAI,SAAS,YAAY,KAAA,CAAA,aAAzB,EAAwC;AACtC,cAAM,YAAY,GAAG,MAAA,CAAA,6BAAA,CAA8B,OAA9B,CAArB;AACA,cAAM,MAAM,GAAG,MAAA,CAAA,oBAAA,CAAqB,YAArB,CAAf;AACA,UAAA,YAAY,CAAC,IAAb,CAAkB,CAAC,CAAC,OAAF,CAAU,IAAI,CAAC,IAAf,CAAlB,EAAwC,KAAI,CAAC,aAAL,CAAmB,OAAnB,EAA4B,MAA5B,CAAxC;AACA,UAAA,SAAS,CAAC,WAAV,CAAsB,OAAtB,CAA8B,UAAA,UAAA,EAAU;AACtC,YAAA,WAAW,GAAG,IAAd;AACA,YAAA,QAAQ,CAAC,IAAT,CAAc;AACZ,cAAA,UAAU,EAAA,UADE;AAEZ,cAAA,KAAK,EAAE,iBAAA;AAAM,uBAAA,KAAI,CAAC,sBAAL,CAAA,UAAA,CAAA;AAAuC;AAFxC,aAAd;AAID,WAND;AAOD;AACF,OAhBD;;AAiBA,UAAI,QAAQ,CAAC,MAAT,GAAkB,CAAtB,EAAyB;AACvB,aAAK,iCAAL,CAAuC,SAAvC,EAAkD,gBAAA,CAAA,WAAA,CAAG,OAArD,EAA8D,QAA9D;AACD;;AACD,UAAI,YAAY,CAAC,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,YAAM,KAAK,GAAiB,CAAC,CAAC,OAAF,CAAU,KAAK,gBAAL,EAAV,CAA5B;AACA,YAAM,UAAU,GAAG,KAAK,WAAL,CAAiB,CAAC,CAAC,UAAF,CAAa,YAAb,CAAjB,CAAnB;AACA,aAAK,mBAAL,CAAyB,UAAzB,EAAqC,gBAAA,CAAA,WAAA,CAAG,cAAxC,EAAwD,CAAC,KAAD,EAAQ,UAAR,CAAxD;;AACA,YAAI,WAAJ,EAAiB;AACf,eAAK,iBAAL,CAAuB,UAAvB,EAAmC,gBAAA,CAAA,WAAA,CAAG,SAAtC,EAAiD,CAAC,KAAD,CAAjD;AACD;AACF;AACF,KAjCO;;AAmCA,IAAA,yBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,UAAgC,YAAhC,EAAyD;AACvD,cAAQ,YAAR;AACE,aAAK,MAAL;AACE,iBAAO,gBAAA,CAAA,WAAA,CAAG,eAAV;;AACF,aAAK,KAAL;AACE,iBAAO,gBAAA,CAAA,WAAA,CAAG,YAAV;;AACF;AACE,iBAAO,gBAAA,CAAA,WAAA,CAAG,aAAV;AANJ;AAQD,KATO;;AAWA,IAAA,yBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,UAAgC,aAAhC,EAAoE,OAApE,EAAsF;AACpF,WAAK,UAAL,GAAkB,aAAlB;AACA,WAAK,mBAAL,CAAyB,OAAO,CAAC,eAAjC,EAAkD,aAAlD;AACD,KAHO;AAKR;;;AAGG;;;AACK,IAAA,yBAAA,CAAA,SAAA,CAAA,6BAAA,GAAR,UACI,WADJ,EACsC,YADtC,EAC4D,QAD5D,EAEI,KAFJ,EAE6B,KAF7B,EAEyC,MAFzC,EAEsD;AAFtD,UAAA,KAAA,GAAA,IAAA;;AAGE,WAAK,4BAAL,CACI,YADJ,EACkB,KAAK,CAAC,UADxB,EACoC,WADpC,EAEI,YAAA;AAAM,eAAA,OAAA,CAAA,QAAA,CAAA,CAAC,CAAC,CAAC,OAAF,CAAU,QAAV,CAAD,CAAA,EAAyB,KAAI,CAAC,6BAAL,CAAmC,KAAnC,CAAzB,EAAA,MAAA,CAAA;AAA8E,OAFxF;AAGD,KANO;;AAQR,IAAA,yBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,SAAb,EAAiC;AAC/B,UAAM,IAAI,GAAG,KAAK,gBAAL,EAAb;AACA,UAAM,iBAAiB,GAAG,KAAK,yBAAL,GAAiC,KAAK,uBAAL,CAA6B,MAAxF;AACA,UAAM,UAAU,GAAmB,CAAC,CAAC,CAAC,OAAF,CAAU,IAAV,CAAD,CAAnC;;AAEA,WAAK,uBAAL,CAA6B,IAA7B,CAAkC,SAAS,CAAC,QAA5C;;AAEA,UAAM,0BAA0B,GAC5B,SAAS,CAAC,UAAV,CAAqB,MAArB,CAA4B,UAAA,IAAA,EAAI;AAAI,eAAA,IAAI,CAAC,IAAL,CAAU,WAAV,OAAA,sBAAA;AAAkD,OAAtF,CADJ;AAEA,UAAM,UAAU,GACZ,KAAK,uBAAL,CAA6B,SAAS,CAAC,IAAvC,EAA6C,0BAA7C,EAAyE,EAAzE,EAA6E,EAA7E,CADJ;;AAGA,UAAI,UAAU,CAAC,MAAX,GAAoB,CAAxB,EAA2B;AACzB,QAAA,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAC,OAAF,CAAU,iBAAV,CAAhB,EAA8C,CAAC,CAAC,UAAF,CAAa,UAAb,CAA9C;AACD,OAFD,MAEO,IAAI,iBAAiB,KAAK,CAA1B,EAA6B;AAClC,QAAA,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAC,OAAF,CAAU,iBAAV,CAAhB;AACD;;AAED,WAAK,mBAAL,CAAyB,SAAS,CAAC,UAAnC,EAA+C,gBAAA,CAAA,WAAA,CAAG,UAAlD,EAA8D,UAA9D;;AACA,UAAI,KAAK,IAAT,EAAe;AACb,aAAK,IAAL,CAAU,gBAAV,CAA2B,SAAS,CAAC,IAArC,EAA4C,IAA5C;AACD;AACF,KAtBD;;AAwBA,IAAA,yBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,OAAb,EAA+B;;;AAA/B,UAAA,KAAA,GAAA,IAAA;;;;AACE,UAAM,YAAY,GAAG,KAAK,gBAAL,EAArB;AACA,UAAM,cAAc,GAAG,IAAI,iBAAA,CAAA,cAAJ,CAAmB,IAAnB,CAAvB;AAEA,UAAI,iBAAiB,GAAY,KAAjC;AACA,UAAM,iBAAiB,GACnB,MAAA,CAAA,cAAA,CAAe,OAAO,CAAC,IAAvB,KAAgC,CAAC,MAAA,CAAA,eAAA,CAAgB,OAAO,CAAC,IAAxB,CADrC;AAGA,UAAM,WAAW,GAAsB,EAAvC;;AACM,UAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAA8B,MAAA,CAAA,WAAA,CAAY,OAAO,CAAC,IAApB,CAA9B,EAAuD,CAAvD,CAAA;AAAA,UAAC,YAAY,GAAA,EAAA,CAAA,CAAA,CAAb;AAAA,UAAe,WAAW,GAAA,EAAA,CAAA,CAAA,CAA1B;;AACN,UAAM,aAAa,GAAG,MAAA,CAAA,aAAA,CAAmB,OAAO,CAAC,IAA3B,CAAtB;;;AAEA;AACA,aAAmB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,OAAO,CAAC,UAAR,CAAA,EAAkB,EAAA,GAAA,EAAA,CAAA,IAAA,EAArC,EAAqC,CAAA,EAAA,CAAA,IAArC,EAAqC,EAAA,GAAA,EAAA,CAAA,IAAA,EAArC,EAAuC;AAAlC,cAAM,IAAI,GAAA,EAAA,CAAA,KAAV;AACI,cAAA,MAAI,GAAW,IAAI,CAAf,IAAJ;AAAA,cAAM,KAAK,GAAI,IAAI,CAAR,KAAX;;AACP,cAAI,MAAI,KAAK,MAAA,CAAA,iBAAb,EAAgC;AAC9B,YAAA,iBAAiB,GAAG,IAApB;AACD,WAFD,MAEO,IAAI,MAAI,KAAK,OAAb,EAAsB;AAC3B,YAAA,cAAc,CAAC,iBAAf,CAAiC,KAAjC;AACD,WAFM,MAEA,IAAI,MAAI,KAAK,OAAb,EAAsB;AAC3B,YAAA,cAAc,CAAC,iBAAf,CAAiC,KAAjC;AACD,WAFM,MAEA;AACL,YAAA,WAAW,CAAC,IAAZ,CAAiB,IAAjB;AACD;AACF;;;;;;;;;;;OAxB4B,CA0B7B;;;AACA,WAAK,eAAL,CAAqB,OAAO,CAAC,IAA7B,EAAmC,OAAnC,EA3B6B,CA6B7B;;AACA,UAAM,UAAU,GAAmB,CAAC,CAAC,CAAC,OAAF,CAAU,YAAV,CAAD,CAAnC;;AACA,UAAI,CAAC,aAAL,EAAoB;AAClB,QAAA,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAC,OAAF,CAAU,WAAV,CAAhB;AACD,OAjC4B,CAmC7B;;;AACA,UAAM,cAAc,GAAuB,EAA3C;AACA,UAAM,cAAc,GAAuB,EAA3C;AAEA,MAAA,OAAO,CAAC,MAAR,CAAe,OAAf,CAAuB,UAAA,KAAA,EAAK;AAC1B,YAAM,kBAAkB,GAAG,cAAc,CAAC,kBAAf,CAAkC,KAAlC,CAA3B;;AACA,YAAI,CAAC,kBAAL,EAAyB;AACvB,cAAI,KAAK,CAAC,IAAN,KAAU;AAAA;AAAV,aAAuC,KAAK,CAAC,IAAjD,EAAuD;AACrD,YAAA,cAAc,CAAC,IAAf,CAAoB,KAApB;AACD,WAFD,MAEO;AACL,YAAA,cAAc,CAAC,IAAf,CAAoB,KAApB;AACD;AACF;AACF,OATD,EAvC6B,CAkD7B;;AACA,UAAM,UAAU,GAAmB,KAAK,uBAAL,CAC/B,OAAO,CAAC,IADuB,EACjB,WADiB,EACJ,cADI,EACY,OAAO,CAAC,OADpB,EAC6B,cAD7B,EAC6C,EAD7C,EAE/B,cAF+B,CAAnC;AAGA,MAAA,UAAU,CAAC,IAAX,CAAgB,KAAK,gBAAL,CAAsB,UAAtB,CAAhB,EAtD6B,CAwD7B;;AACA,UAAM,IAAI,GAAG,KAAK,gBAAL,CAAsB,OAAO,CAAC,UAA9B,CAAb;AACA,MAAA,UAAU,CAAC,IAAX,CAAgB,KAAK,WAAL,CAAiB,IAAjB,CAAhB;AAEA,UAAM,cAAc,GAAG,KAAK,UAA5B;AACA,UAAM,gBAAgB,GAAG,KAAK,uBAAL,CAA6B,YAA7B,CAAzB,CA7D6B,CA+D7B;AACA;;AACA,UAAI,gBAAgB,KAAK,cAAzB,EAAyC;AACvC,aAAK,uBAAL,CAA6B,gBAA7B,EAA+C,OAA/C;AACD;;AAED,UAAI,KAAK,IAAT,EAAe;AACb,aAAK,IAAL,CAAU,aAAV,CAAwB,OAAO,CAAC,IAAhC,EAAuC,YAAvC;AACD,OAvE4B,CAyE7B;AACA;;;AACA,UAAM,WAAW,GAAI,CAAC,iBAAD,IAAsB,KAAK,IAA5B,GAAoC,CAAC,mBAAmB,CAAC,OAAO,CAAC,QAAT,CAAxD,GACoC,OAAO,CAAC,QAAR,CAAiB,MAAjB,GAA0B,CADlF;AAGA,UAAM,4BAA4B,GAAG,CAAC,cAAc,CAAC,oBAAhB,IACjC,OAAO,CAAC,OAAR,CAAgB,MAAhB,KAA2B,CADM,IACD,cAAc,CAAC,MAAf,KAA0B,CADzB,IAC8B,CAAC,WADpE;AAEA,UAAM,gCAAgC,GAClC,CAAC,4BAAD,IAAiC,mBAAmB,CAAC,OAAO,CAAC,QAAT,CADxD;;AAGA,UAAI,4BAAJ,EAAkC;AAChC,aAAK,mBAAL,CACI,OAAO,CAAC,UADZ,EACwB,aAAa,GAAG,gBAAA,CAAA,WAAA,CAAG,gBAAN,GAAyB,gBAAA,CAAA,WAAA,CAAG,OADjE,EAEI,MAAA,CAAA,iBAAA,CAAkB,UAAlB,CAFJ;AAGD,OAJD,MAIO;AACL,aAAK,mBAAL,CACI,OAAO,CAAC,eADZ,EAC6B,aAAa,GAAG,gBAAA,CAAA,WAAA,CAAG,qBAAN,GAA8B,gBAAA,CAAA,WAAA,CAAG,YAD3E,EAEI,MAAA,CAAA,iBAAA,CAAkB,UAAlB,CAFJ;;AAIA,YAAI,iBAAJ,EAAuB;AACrB,eAAK,mBAAL,CAAyB,OAAO,CAAC,eAAjC,EAAkD,gBAAA,CAAA,WAAA,CAAG,eAArD;AACD;;AAED,YAAI,cAAc,CAAC,MAAf,GAAwB,CAA5B,EAA+B;AAC7B,eAAK,yBAAL,CACI,YADJ,EACkB,cADlB,EACgC,CAAA,EAAA,GAAE,OAAO,CAAC,eAAV,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,EAAzB,GAA6B,OAAO,CAAC,UADrE;AAED,SAZI,CAcL;;;AACA,YAAI,OAAO,CAAC,OAAR,CAAgB,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B,cAAM,SAAS,GAAG,OAAO,CAAC,OAAR,CAAgB,GAAhB,CACd,UAAC,SAAD,EAAwB;AAAK,mBAAC;AAC5B,cAAA,UAAU,EAAE,SAAS,CAAC,UADM;AAE5B,cAAA,MAAM,EAAE,KAAI,CAAC,wBAAL,CAA8B,OAAO,CAAC,IAAtC,EAA4C,SAA5C,EAAuD,YAAvD;AAFoB,aAAD;AAG3B,WAJY,CAAlB;AAKA,eAAK,wBAAL,CAA8B,gBAAA,CAAA,WAAA,CAAG,QAAjC,EAA2C,SAA3C;AACD,SAtBI,CAwBL;AACA;;;AACA,YAAI,iBAAJ,EAAuB;AACrB,eAAK,SAAL,CAAe,OAAO,CAAC,eAAvB,EAAwC,OAAO,CAAC,IAAhD,EAAuD,gCAAvD;AACD;AACF,OApH4B,CAsH7B;AACA;AACA;AACA;;;AACA,UAAM,mBAAmB,GAAG,cAAc,CAAC,4BAAf,CAA4C,KAAK,eAAjD,CAA5B;AACA,UAAM,KAAK,GAAG,mBAAmB,CAAC,MAApB,GAA6B,CAA3C;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,IAAI,KAArB,EAA4B,CAAC,EAA7B,EAAiC;AAC/B,YAAM,aAAW,GAAG,mBAAmB,CAAC,CAAD,CAAvC;AACA,aAAK,aAAL,IAAsB,KAAK,+BAAL,CAAqC,YAArC,EAAmD,aAAnD,CAAtB;AACD,OA/H4B,CAiI7B;AACA;AACA;;;AACA,UAAM,yBAAyB,GAAG,CAAC,CAAC,OAAF,CAAU,SAAV,CAAlC;AACA,UAAM,gBAAgB,GAAkC,EAAxD;AACA,UAAM,iBAAiB,GAAkC,EAAzD,CAtI6B,CAwI7B;;AACA,MAAA,cAAc,CAAC,OAAf,CAAuB,UAAA,KAAA,EAAK;AAC1B,YAAM,SAAS,GAAG,KAAK,CAAC,IAAxB;;AACA,YAAI,SAAS,KAAA;AAAA;AAAb,UAAyC;AACvC,gBAAM,OAAK,GAAG,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAkB,KAAI,CAAC,eAAvB,CAAd,CADuC,CAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,gBAAM,UAAQ,GAAG,OAAK,YAAY,KAAA,CAAA,gBAAjB,GAAoC,CAAC,CAAC,OAAK,CAAC,KAA5C,GAAoD,IAArE;;AACA,YAAA,KAAI,CAAC,oBAAL,CAA0B,OAA1B;;AAEA,YAAA,gBAAgB,CAAC,IAAjB,CAAsB;AACpB,cAAA,IAAI,EAAE,MAAA,CAAA,4BAAA,CAA6B,KAAK,CAAC,IAAnC,CADc;AAEpB,cAAA,UAAU,EAAE,KAAK,CAAC,UAFE;AAGpB,cAAA,KAAK,EAAE,iBAAA;AAAM,uBAAA,UAAQ,GAAG,KAAI,CAAC,sBAAL,CAA4B,OAA5B,CAAH,GAAR,yBAAA;AAAyE;AAHlE,aAAtB;AAKD,WAnBD,MAmBO;AACL;AACA;AACA,cAAI,KAAK,CAAC,IAAV,EAAgB;AAEhB,cAAM,OAAK,GAAG,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAkB,KAAI,CAAC,eAAvB,CAAd;;AACA,cAAI,OAAK,KAAK,SAAd,EAAyB;AACvB,gBAAM,QAAM,GAAU,EAAtB;;AACM,gBAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAA4B,MAAA,CAAA,WAAA,CAAY,KAAK,CAAC,IAAlB,CAA5B,EAAmD,CAAnD,CAAA;AAAA,gBAAC,aAAa,GAAA,EAAA,CAAA,CAAA,CAAd;AAAA,gBAAgB,UAAQ,GAAA,EAAA,CAAA,CAAA,CAAxB;;AACN,gBAAM,kBAAkB,GAAG,SAAS,KAAA;AAAA;AAApC;AACA,gBAAM,eAAe,GAAG,qBAAqB,CAAC,KAAK,CAAC,eAAP,EAAwB,kBAAxB,CAA7C;AACA,gBAAI,eAAJ,EAAqB,QAAM,CAAC,IAAP,CAAY,eAAZ;;AACrB,gBAAI,aAAJ,EAAmB;AACjB,kBAAM,gBAAgB,GAAG,CAAC,CAAC,OAAF,CAAU,aAAV,CAAzB;;AAEA,kBAAI,eAAJ,EAAqB;AACnB,gBAAA,QAAM,CAAC,IAAP,CAAY,gBAAZ;AACD,eAFD,MAEO;AACL;AACA;AACA,gBAAA,QAAM,CAAC,IAAP,CAAY,CAAC,CAAC,OAAF,CAAU,IAAV,CAAZ,EAA6B,gBAA7B;AACD;AACF;;AACD,YAAA,KAAI,CAAC,oBAAL,CAA0B,OAA1B;;AAEA,gBAAI,SAAS,KAAA;AAAA;AAAb,cAAwC;AACtC,oBAAI,OAAK,YAAY,KAAA,CAAA,aAArB,EAAoC;AAClC;AACA,kBAAA,KAAI,CAAC,6BAAL,CACI,kCAAkC,CAAC,OAAD,CADtC,EAC+C,YAD/C,EAC6D,UAD7D,EACuE,KADvE,EAC8E,OAD9E,EAEI,QAFJ;AAGD,iBALD,MAKO;AACL;AACA;AACA,kBAAA,gBAAgB,CAAC,IAAjB,CAAsB;AACpB,oBAAA,IAAI,EAAE,UADc;AAEpB,oBAAA,UAAU,EAAE,KAAK,CAAC,UAFE;AAGpB,oBAAA,KAAK,EAAE,iBAAA;AAAM,6BAAA,KAAI,CAAC,sBAAL,CAAA,OAAA,CAAA;AAAkC,qBAH3B;AAIpB,oBAAA,MAAM,EAAA;AAJc,mBAAtB;AAMD;AACF,eAhBD,MAgBO,IAAI,SAAS,KAAA;AAAA;AAAb,cAAyC;AAC9C,oBAAI,OAAK,YAAY,KAAA,CAAA,aAAjB,IAAkC,MAAA,CAAA,0BAAA,CAA2B,OAA3B,IAAoC,CAA1E,EAA6E;AAC3E;AACA,kBAAA,KAAI,CAAC,6BAAL,CACI,mCAAmC,CAAC,OAAD,CADvC,EACgD,YADhD,EAC8D,UAD9D,EACwE,KADxE,EAC+E,OAD/E,EAEI,QAFJ;AAGD,iBALD,MAKO;AACL,sBAAM,YAAU,GAAG,OAAK,YAAY,KAAA,CAAA,aAAjB,GAAiC,OAAK,CAAC,WAAN,CAAkB,CAAlB,CAAjC,GAAwD,OAA3E,CADK,CAEL;AACA;;AACA,kBAAA,iBAAiB,CAAC,IAAlB,CAAuB;AACrB,oBAAA,IAAI,EAAE,UADe;AAErB,oBAAA,UAAU,EAAE,KAAK,CAAC,UAFG;AAGrB,oBAAA,KAAK,EAAE,iBAAA;AAAM,6BAAA,KAAI,CAAC,sBAAL,CAAA,YAAA,CAAA;AAAuC,qBAH/B;AAIrB,oBAAA,MAAM,EAAA;AAJe,mBAAvB;AAMD;AACF,eAjBM,MAiBA;AACL;AACA,cAAA,KAAI,CAAC,4BAAL,CAAkC,YAAlC,EAAgD,KAAK,CAAC,UAAtD,EAAkE,gBAAA,CAAA,WAAA,CAAG,SAArE,EAAgF,YAAA;AAC9E,uBAAA,OAAA,CAAA,QAAA,CAAA,CACE,CAAC,CAAC,OAAF,CAAU,YAAV,CADF,EAC2B,CAAC,CAAC,OAAF,CAAU,UAAV,CAD3B,EACgD,KAAI,CAAC,sBAAL,CAA4B,OAA5B,CADhD,CAAA,EAEK,QAFL,CAAA;AAID,eALD;AAMD;AACF;AACF;AACF,OA1FD;;AA4FA,UAAI,gBAAgB,CAAC,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,aAAK,iCAAL,CAAuC,YAAvC,EAAqD,gBAAA,CAAA,WAAA,CAAG,QAAxD,EAAkE,gBAAlE;AACD;;AAED,UAAI,iBAAiB,CAAC,MAAlB,GAA2B,CAA/B,EAAkC;AAChC,aAAK,iCAAL,CAAuC,YAAvC,EAAqD,gBAAA,CAAA,WAAA,CAAG,SAAxD,EAAmE,iBAAnE;AACD,OA3O4B,CA6O7B;;;AACA,MAAA,CAAC,CAAC,QAAF,CAAW,IAAX,EAAiB,OAAO,CAAC,QAAzB;;AAEA,UAAI,CAAC,iBAAD,IAAsB,KAAK,IAA/B,EAAqC;AACnC,aAAK,IAAL,CAAU,aAAV,CAAwB,OAAO,CAAC,IAAhC,EAAuC,YAAvC,EAAqD,IAArD;AACD;;AAED,UAAI,CAAC,4BAAL,EAAmC;AACjC;AACA,YAAM,IAAI,GAAA,CAAA,EAAA,GAAG,OAAO,CAAC,aAAX,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,EAAxB,GAA4B,OAAO,CAAC,UAA9C;;AACA,YAAI,iBAAJ,EAAuB;AACrB,eAAK,OAAL,CAAa,IAAb,EAAmB,gCAAnB;AACD;;AACD,YAAI,iBAAJ,EAAuB;AACrB,eAAK,mBAAL,CAAyB,IAAzB,EAA+B,gBAAA,CAAA,WAAA,CAAG,cAAlC;AACD;;AACD,aAAK,mBAAL,CAAyB,IAAzB,EAA+B,aAAa,GAAG,gBAAA,CAAA,WAAA,CAAG,mBAAN,GAA4B,gBAAA,CAAA,WAAA,CAAG,UAA3E;AACD;AACF,KA/PD;;AAkQA,IAAA,yBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,QAAd,EAAkC;AAAlC,UAAA,KAAA,GAAA,IAAA;;;;AACE,UAAM,oBAAoB,GAAG,aAA7B;AACA,UAAM,aAAa,GAAG,KAAK,gBAAL,EAAtB;;AAEA,UAAI,KAAK,IAAT,EAAe;AACb,aAAK,IAAL,CAAU,cAAV,CAAyB,QAAQ,CAAC,IAAlC,EAAyC,aAAzC;AACD;;AAED,UAAM,OAAO,GAAG,kBAAA,CAAA,kBAAA,CAAmB,QAAQ,CAAC,OAAT,IAAoB,EAAvC,CAAhB;AACA,UAAM,WAAW,GAAG,KAAG,KAAK,WAAR,IAAsB,OAAO,GAAG,MAAM,OAAT,GAAmB,EAAhD,IAAkD,GAAlD,GAAsD,aAA1E;AACA,UAAM,YAAY,GAAM,WAAW,GAAA,WAAnC;AAEA,UAAM,UAAU,GAAmB,CACjC,CAAC,CAAC,OAAF,CAAU,aAAV,CADiC,EAEjC,CAAC,CAAC,QAAF,CAAW,YAAX,CAFiC,EAIjC;AACA;AACA,MAAA,CAAC,CAAC,OAAF,CAAU,QAAQ,CAAC,OAAT,GAAmB,MAAA,CAAA,WAAA,CAAY,QAAQ,CAAC,OAArB,EAA8B,CAA9B,CAAnB,GAAsD,QAAQ,CAAC,OAAzE,CANiC,CAAnC,CAZgC,CAqBhC;;AACA,WAAK,eAAL,CAAqB,oBAArB,EAA2C,QAA3C,EAtBgC,CAwBhC;;AACA,UAAM,UAAU,GAAmB,KAAK,uBAAL,CAC/B,oBAD+B,EACT,QAAQ,CAAC,UADA,EACY,QAAQ,CAAC,MADrB,EAC6B,QAAQ,CAAC,OADtC,EAE/B;AAAU;AAFqB,QAEP,QAAQ,CAAC,aAFF,CAAnC;AAGA,MAAA,UAAU,CAAC,IAAX,CAAgB,KAAK,gBAAL,CAAsB,UAAtB,CAAhB,EA5BgC,CA8BhC;;AACA,UAAI,QAAQ,CAAC,UAAT,IAAuB,QAAQ,CAAC,UAAT,CAAoB,MAA/C,EAAuD;AACrD,YAAM,IAAI,GAAG,KAAK,gBAAL,CAAsB,QAAQ,CAAC,UAA/B,CAAb;AACA,QAAA,UAAU,CAAC,IAAX,CAAgB,KAAK,WAAL,CAAiB,IAAjB,CAAhB;AACA,QAAA,UAAU,CAAC,IAAX,CAAgB,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,oBAAhB,CAAhB;AACD,OAnC+B,CAqChC;;;AACA,UAAM,eAAe,GAAG,IAAI,yBAAJ,CACpB,KAAK,YADe,EACD,KAAK,aADJ,EACmB,KAAK,KAAL,GAAa,CADhC,EACmC,WADnC,EACgD,KAAK,IADrD,EAEpB,aAFoB,EAEL,YAFK,EAES,KAAK,gBAFd,EAEgC,KAAK,UAFrC,EAEiD,KAAK,cAFtD,EAGpB,KAAK,KAHe,EAGR,KAAK,UAHG,EAGS,KAAK,mBAHd,EAGmC,KAAK,kBAHxC,EAIpB,KAAK,UAJe,CAAxB,CAtCgC,CA4ChC;AACA;AACA;AACA;;AACA,WAAK,kBAAL,CAAwB,IAAxB,CAA6B,YAAA;;;AAC3B,YAAM,oBAAoB,GAAG,eAAe,CAAC,qBAAhB,CACzB,QAAQ,CAAC,QADgB,EACN,QAAQ,CAAC,SADH,EAEzB,KAAI,CAAC,uBAAL,CAA6B,MAA7B,GAAsC,KAAI,CAAC,yBAFlB,EAE6C,QAAQ,CAAC,IAFtD,CAA7B;;AAGA,QAAA,KAAI,CAAC,YAAL,CAAkB,UAAlB,CAA6B,IAA7B,CAAkC,oBAAoB,CAAC,UAArB,CAAgC,YAAhC,CAAlC;;AACA,YAAI,eAAe,CAAC,uBAAhB,CAAwC,MAA5C,EAAoD;AAClD,WAAA,EAAA,GAAA,KAAI,CAAC,uBAAL,EAA6B,IAA7B,CAAiC,KAAjC,CAAiC,EAAjC,EAAiC,OAAA,CAAA,QAAA,CAAI,eAAe,CAAC,uBAApB,CAAjC;AACD;AACF,OARD,EAhDgC,CA0DhC;;;AACA,WAAK,mBAAL,CAAyB,QAAQ,CAAC,UAAlC,EAA8C,gBAAA,CAAA,WAAA,CAAG,cAAjD,EAAiE,YAAA;AAC/D,QAAA,UAAU,CAAC,MAAX,CACI,CADJ,EACO,CADP,EACU,CAAC,CAAC,OAAF,CAAU,eAAe,CAAC,aAAhB,EAAV,CADV,EAEI,CAAC,CAAC,OAAF,CAAU,eAAe,CAAC,WAAhB,EAAV,CAFJ;AAGA,eAAO,MAAA,CAAA,iBAAA,CAAkB,UAAlB,CAAP;AACD,OALD,EA3DgC,CAkEhC;;AACA,WAAK,wBAAL,CAA8B,aAA9B,EAA6C,QAAQ,CAAC,aAAtD,EAnEgC,CAqEhC;;AACA,UAAI,QAAQ,CAAC,OAAT,KAAqB,oBAAzB,EAA+C;AACvC,YAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CACF,MAAA,CAAA,cAAA,CAAmD,QAAQ,CAAC,MAA5D,EAAoE,MAAA,CAAA,WAApE,CADE,EAC8E,CAD9E,CAAA;AAAA,YAAC,UAAU,GAAA,EAAA,CAAA,CAAA,CAAX;AAAA,YAAa,MAAM,GAAA,EAAA,CAAA,CAAA,CAAnB,CADuC,CAI7C;AACA;AACA;AACA;;;AACA,YAAI,UAAU,CAAC,MAAX,GAAoB,CAAxB,EAA2B;AACzB,eAAK,yBAAL,CACI,aADJ,EACmB,UADnB,EAC6B,CAAA,EAAA,GAAE,QAAQ,CAAC,eAAX,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,EAA1B,GAA8B,QAAQ,CAAC,UADpE;AAED,SAX4C,CAa7C;;;AACA,YAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;AACrB,eAAK,wBAAL,CAA8B,aAA9B,EAA6C,MAA7C;AACD,SAhB4C,CAkB7C;;;AACA,YAAI,QAAQ,CAAC,OAAT,CAAiB,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,cAAM,SAAS,GAAG,QAAQ,CAAC,OAAT,CAAiB,GAAjB,CACd,UAAC,SAAD,EAAwB;AAAK,mBAAC;AAC5B,cAAA,UAAU,EAAE,SAAS,CAAC,UADM;AAE5B,cAAA,MAAM,EAAE,KAAI,CAAC,wBAAL,CAA8B,aAA9B,EAA6C,SAA7C,EAAwD,aAAxD;AAFoB,aAAD;AAG3B,WAJY,CAAlB;AAKA,eAAK,wBAAL,CAA8B,gBAAA,CAAA,WAAA,CAAG,QAAjC,EAA2C,SAA3C;AACD;AACF;AACF,KAlGD;;AA2GA,IAAA,yBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,IAAf,EAAgC;AAAhC,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,KAAK,IAAT,EAAe;AACb,YAAM,OAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,KAAK,eAAtB,CAAd;AACA,aAAK,oBAAL,CAA0B,OAA1B;;AACA,YAAI,OAAK,YAAY,KAAA,CAAA,aAArB,EAAoC;AAClC,eAAK,IAAL,CAAU,eAAV,CAA0B,IAAI,CAAC,IAA/B;AACA,eAAK,kBAAL,CAAwB,OAAK,CAAC,WAA9B;AACD;;AACD;AACD;;AAED,UAAM,SAAS,GAAG,KAAK,gBAAL,EAAlB;AAEA,WAAK,mBAAL,CAAyB,IAAI,CAAC,UAA9B,EAA0C,gBAAA,CAAA,WAAA,CAAG,IAA7C,EAAmD,CAAC,CAAC,CAAC,OAAF,CAAU,SAAV,CAAD,CAAnD;AAEA,UAAM,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,KAAK,eAAtB,CAAd;AACA,WAAK,oBAAL,CAA0B,KAA1B;;AAEA,UAAI,KAAK,YAAY,KAAA,CAAA,aAArB,EAAoC;AAClC,aAAK,4BAAL,CACI,SADJ,EACe,IAAI,CAAC,UADpB,EACgC,8BAA8B,CAAC,KAAD,CAD9D,EAEI,YAAA;AAAM,iBAAA,KAAI,CAAC,6BAAL,CAAA,KAAA,CAAA;AAAyC,SAFnD;AAGD,OAJD,MAIO;AACL,QAAA,MAAA,CAAA,KAAA,CAAM,6DAAN;AACD;AACF,KAzBD;;AA2BA,IAAA,yBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,IAAV,EAAsB;AACpB;AACA;AACA;AACA,UAAI,CAAC,KAAK,IAAV,EAAgB;AACd,aAAK,mBAAL,CACI,IAAI,CAAC,UADT,EACqB,gBAAA,CAAA,WAAA,CAAG,IADxB,EAC8B,CAAC,CAAC,CAAC,OAAF,CAAU,KAAK,gBAAL,EAAV,CAAD,EAAqC,CAAC,CAAC,OAAF,CAAU,IAAI,CAAC,KAAf,CAArC,CAD9B;AAED;AACF,KARD;;AAUA,IAAA,yBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,GAAT,EAAmB;AACjB,UAAI,cAAc,GAAG,KAArB,CADiB,CAGjB;AACA;AACA;;AACA,UAAI,CAAC,KAAK,IAAV,EAAgB;AACd,QAAA,cAAc,GAAG,IAAjB;AACA,aAAK,SAAL,CAAe,IAAf,EAAqB,GAAG,CAAC,IAAzB,EAAgC,IAAhC;AACD;;AAED,UAAM,IAAI,GAAG,KAAK,IAAlB;AACA,UAAM,IAAI,GAAG,KAAK,aAAL,CAAmB,GAAG,CAAC,IAAvB,CAAb;AACA,UAAM,YAAY,GAAG,KAAK,aAAL,CAAmB,GAAG,CAAC,YAAvB,CAArB,CAbiB,CAejB;;AACA,UAAM,OAAO,GAAG,GAAG,CAAC,IAApB,CAhBiB,CAkBjB;AACA;AACA;AACA;AACA;;AACA,UAAM,WAAW,GAAG,SAAd,WAAc,CAAC,GAAD,EAAmB;AACrC,YAAM,MAAM,GAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAAO,IAAP,CAAA,EAAgB,YAAhB,CAAZ;;AACA,YAAM,SAAS,GAAG,MAAA,CAAA,0BAAA,CAA2B,MAA3B;AAAmC;AAAmB,aAAtD,CAAlB;AACA,eAAO,WAAW,CAAC,IAAD,EAAO,gBAAA,CAAA,WAAA,CAAG,eAAV,EAA2B,CAAC,GAAD,EAAM,UAAA,CAAA,UAAA,CAAW,SAAX,EAAsB,IAAtB,CAAN,CAA3B,CAAlB;AACD,OAJD,CAvBiB,CA6BjB;AACA;AACA;AACA;AACA;;;AACA,UAAI,MAAA,CAAA,eAAA,CAAgB,IAAI,CAAC,IAArB,CAAJ,EAAgC;AAC9B,aAAK,aAAL,CAAmB,OAAnB;AAA4B;AAAmB,UAA/C,EAAmD,IAAI,CAAC,GAAxD,EAA6D,WAA7D;AACD,OAFD,MAEO;AACL;AACA,YAAM,GAAG,GACL,KAAK,aAAL,CAAmB,OAAnB;AAA4B;AAAmB,UAA/C;AAAmD;AAAU,QAAA,SAA7D,EAAwE,WAAxE,CADJ;AAEA,QAAA,IAAI,CAAC,SAAL,CAAe,MAAA,CAAA,kBAAA,CAAmB,OAAnB,EAA4B,IAA3C,EAAiD,GAAjD;AACD;;AAED,UAAI,cAAJ,EAAoB;AAClB,aAAK,OAAL,CAAa,IAAb,EAAmB,IAAnB;AACD;;AACD,aAAO,IAAP;AACD,KA/CD;;AAiDQ,IAAA,yBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,YAAA;AACE,aAAO,KAAK,UAAL,EAAP;AACD,KAFO;;AAIR,IAAA,yBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA;AACE,aAAO,KAAK,UAAZ;AACD,KAFD;;AAIA,IAAA,yBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,aAAO,KAAK,kBAAZ;AACD,KAFD;;AAIA,IAAA,yBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;AACE,aAAO,KAAK,UAAZ;AACD,KAFD;;AAIA,IAAA,yBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,YAAA;AACE,aAAO,KAAK,uBAAL,CAA6B,MAA7B,GACH,KAAK,YAAL,CAAkB,eAAlB,CAAkC,MAAA,CAAA,SAAA,CAAU,KAAK,uBAAf,CAAlC,EAA2E,IAA3E,CADG,GAEH,IAFJ;AAGD,KAJD;;AAMQ,IAAA,yBAAA,CAAA,SAAA,CAAA,cAAA,GAAR,YAAA;AACE,aAAO,KAAG,KAAK,eAAL,EAAV;AACD,KAFO;;AAIA,IAAA,yBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UACI,aADJ,EAC2B,KAD3B,EACsE;AADtE,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAM,gBAAgB,GAAkC,EAAxD;AACA,MAAA,KAAK,CAAC,OAAN,CAAc,UAAA,KAAA,EAAK;AACjB,YAAI,KAAK,YAAY,CAAC,CAAC,cAAvB,EAAuC;AACrC,cAAM,OAAK,GAAG,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAkB,KAAI,CAAC,eAAvB,CAAd;;AAEA,cAAI,OAAK,KAAK,SAAd,EAAyB;AACvB,YAAA,KAAI,CAAC,oBAAL,CAA0B,OAA1B;;AACA,gBAAI,OAAK,YAAY,KAAA,CAAA,aAArB,EAAoC;AAClC;AACA;AACA;AACA,kBAAM,MAAM,GAAU,EAAtB,CAJkC,CAMlC;;AACA,cAAA,KAAI,CAAC,6BAAL,CACI,kCAAkC,CAAC,OAAD,CADtC,EAC+C,aAD/C,EAC8D,KAAK,CAAC,IADpE,EAC0E,KAD1E,EACiF,OADjF,EAEI,MAFJ;AAGD,aAVD,MAUO;AACL;AACA,cAAA,gBAAgB,CAAC,IAAjB,CAAsB;AACpB,gBAAA,IAAI,EAAE,KAAK,CAAC,IADQ;AAEpB,gBAAA,UAAU,EAAE,KAAK,CAAC,UAFE;AAGpB,gBAAA,KAAK,EAAE,iBAAA;AAAM,yBAAA,KAAI,CAAC,sBAAL,CAAA,OAAA,CAAA;AAAkC;AAH3B,eAAtB;AAKD;AACF;AACF;AACF,OA1BD;;AA4BA,UAAI,gBAAgB,CAAC,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B,aAAK,iCAAL,CAAuC,aAAvC,EAAsD,gBAAA,CAAA,WAAA,CAAG,QAAzD,EAAmE,gBAAnE;AACD;AACF,KAlCO,CA56BV,CAg9BE;AACA;AACA;AACA;;;AACQ,IAAA,yBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UACI,GADJ,EACgC,IADhC,EAC4D,SAD5D,EAEI,UAFJ,EAEuD,OAFvD,EAE+E;AAAxB,UAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,OAAA,GAAA,KAAA;AAAwB;;AAC7E,MAAA,GAAG,CAAC,OAAO,GAAG,SAAH,GAAe,MAAvB,CAAH,CAAkC,YAAA;AAChC,YAAM,MAAM,GAAG,KAAK,CAAC,OAAN,CAAc,UAAd,IAA4B,UAA5B,GAAyC,UAAU,EAAlE;AACA,eAAO,WAAW,CAAC,IAAD,EAAO,SAAP,EAAkB,MAAlB,CAAX,CAAqC,MAArC,EAAP;AACD,OAHD;AAID,KAPO;;AASA,IAAA,yBAAA,CAAA,SAAA,CAAA,+BAAA,GAAR,UACI,YADJ,EAC0B,WAD1B,EAC8D;AAD9D,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAI,oBAAoB,GAAG,CAA3B;;AACA,UAAI,WAAJ,EAAiB;AACf,YAAM,OAAK,GAAkC,EAA7C;AAEA,QAAA,WAAW,CAAC,KAAZ,CAAkB,OAAlB,CAA0B,UAAA,IAAA,EAAI;AAC5B,UAAA,oBAAoB,IAAI,IAAI,CAAC,oBAA7B;AACA,UAAA,OAAK,CAAC,IAAN,CAAW;AACT,YAAA,UAAU,EAAE,IAAI,CAAC,UADR;AAET,YAAA,KAAK,EAAE,iBAAA;AACL,qBAAO,IAAI,CAAC,MAAL,CACI,UAAA,KAAA,EAAK;AAAI,uBAAC,IAAI,CAAC,qBAAL,IAA8B,KAAK,YAAY,KAAA,CAAA,aAAhD,GACL,KAAI,CAAC,6BAAL,CAAmC,KAAnC,CADK,GAEL,KAAI,CAAC,sBAAL,CAFK,KAEL,CAFK;AAE6B,eAH1C,CAAP;AAID;AAPQ,WAAX;AASD,SAXD;AAaA,aAAK,iCAAL,CAAuC,YAAvC,EAAqD,WAAW,CAAC,SAAjE,EAA4E,OAA5E;AACD;;AAED,aAAO,oBAAP;AACD,KAvBO;;AAyBA,IAAA,yBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UACI,IADJ,EACgC,SADhC,EAEI,UAFJ,EAEwD,OAFxD,EAEyE;AACvE,WAAK,aAAL,CAAmB,KAAK,gBAAxB,EAA0C,IAA1C,EAAgD,SAAhD,EAA2D,UAAU,IAAI,EAAzE,EAA6E,OAA7E;AACD,KAJO;;AAMA,IAAA,yBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,SAAjC,EAAiE,KAAjE,EAGG;AACD,UAAM,IAAI,GAAG,KAAK,CAAC,MAAN,GAAe,KAAK,CAAC,CAAD,CAAL,CAAS,UAAxB,GAAqC,IAAlD;;AACA,WAAK,gBAAL,CAAsB,IAAtB,CAA2B,YAAA;AACzB,eAAO,MAAA,CAAA,kBAAA,CAAmB,SAAnB,EAA8B,KAAK,CAAC,GAAN,CAAU,UAAA,IAAA,EAAI;AAAI,iBAAA,IAAI,CAAJ,MAAA,EAAA;AAAa,SAA/B,CAA9B,EAAgE,IAAhE,EAAsE,MAAtE,EAAP;AACD,OAFD;AAGD,KARO;;AAUA,IAAA,yBAAA,CAAA,SAAA,CAAA,4BAAA,GAAR,UACI,SADJ,EACuB,IADvB,EACmD,SADnD,EAEI,UAFJ,EAEsD;AACpD,WAAK,gCAAL,CAAsC,SAAtC,EAAiD,IAAjD;AACA,WAAK,iBAAL,CAAuB,IAAvB,EAA6B,SAA7B,EAAwC,UAAxC;AACD,KALO;;AAOA,IAAA,yBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UACI,IADJ,EACgC,SADhC,EAEI,UAFJ,EAEsD;AACpD,WAAK,aAAL,CAAmB,KAAK,cAAxB,EAAwC,IAAxC,EAA8C,SAA9C,EAAyD,UAAU,IAAI,EAAvE;AACD,KAJO;;AAMA,IAAA,yBAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UACI,SADJ,EACoC,QADpC,EAC2E;AACzE,UAAM,IAAI,GAAG,QAAQ,CAAC,MAAT,GAAkB,QAAQ,CAAC,CAAD,CAAR,CAAY,UAA9B,GAA2C,IAAxD;;AAEA,WAAK,cAAL,CAAoB,IAApB,CAAyB,YAAA;AACvB,YAAM,KAAK,GAAG,QAAQ,CAAC,GAAT,CAAa,UAAA,QAAA,EAAQ;AACjC,cAAM,KAAK,GAAG,QAAQ,CAAC,KAAT,EAAd;AACA,cAAM,QAAQ,GAAG,KAAK,CAAC,OAAN,CAAc,KAAd,IAAuB,KAAvB,GAA+B,CAAC,KAAD,CAAhD;;AACA,cAAI,QAAQ,CAAC,MAAb,EAAqB;AACnB,YAAA,QAAQ,CAAC,IAAT,CAAa,KAAb,CAAA,QAAA,EAAQ,OAAA,CAAA,QAAA,CAAS,QAAQ,CAAC,MAAlB,CAAR;AACD;;AACD,cAAI,QAAQ,CAAC,IAAb,EAAmB;AACjB;AACA,YAAA,QAAQ,CAAC,OAAT,CAAiB,CAAC,CAAC,OAAF,CAAU,QAAQ,CAAC,IAAnB,CAAjB;AACD;;AACD,iBAAO,QAAP;AACD,SAXa,CAAd;AAaA,eAAO,MAAA,CAAA,kBAAA,CAAmB,SAAnB,EAA8B,KAA9B,EAAqC,IAArC,EAA2C,MAA3C,EAAP;AACD,OAfD;AAgBD,KApBO;;AAsBA,IAAA,yBAAA,CAAA,SAAA,CAAA,iCAAA,GAAR,UACI,SADJ,EACuB,SADvB,EACuD,QADvD,EAC8F;AAC5F,WAAK,gCAAL,CACI,SADJ,EACe,QAAQ,CAAC,MAAT,GAAkB,QAAQ,CAAC,CAAD,CAAR,CAAY,UAA9B,GAA2C,IAD1D;AAEA,WAAK,sBAAL,CAA4B,SAA5B,EAAuC,QAAvC;AACD,KALO;;AAOA,IAAA,yBAAA,CAAA,SAAA,CAAA,gCAAA,GAAR,UAAyC,SAAzC,EAA4D,IAA5D,EAAsF;AACpF,UAAI,SAAS,KAAK,KAAK,aAAvB,EAAsC;AACpC,YAAM,KAAK,GAAG,SAAS,GAAG,KAAK,aAA/B;;AAEA,YAAI,KAAK,GAAG,CAAZ,EAAe;AACb,gBAAM,IAAI,KAAJ,CAAU,0CAAV,CAAN;AACD;;AAED,aAAK,aAAL,CAAmB,KAAK,cAAxB,EAAwC,IAAxC,EAA8C,gBAAA,CAAA,WAAA,CAAG,OAAjD,EAA0D,CAAC,CAAC,CAAC,OAAF,CAAU,KAAV,CAAD,CAA1D;AACA,aAAK,aAAL,GAAqB,SAArB;AACD;AACF,KAXO;;AAaA,IAAA,yBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,QAAlC,EAAkD;AAChD,UAAM,aAAa,GAAG,KAAK,kBAA3B;AACA,WAAK,kBAAL,IAA2B,QAA3B;AACA,aAAO,aAAP;AACD,KAJO;;AAMA,IAAA,yBAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UAA6B,KAA7B,EAA4C;AAC1C,WAAK,aAAL,IAAsB,KAAK,YAAY,KAAA,CAAA,aAAjB,GAAiC,KAAK,CAAC,WAAN,CAAkB,MAAnD,GAA4D,CAAlF;AACD,KAFO;AAIR;;;AAGG;;;AACK,IAAA,yBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,YAAA;AACE,UAAI,KAAK,qBAAT,EAAgC;AAC9B,eAAO,KAAK,qBAAZ;AACD;;AAED,aAAO,KAAK,qBAAL,GAA6B,KAAK,KAAL,KAAe,CAAf,GAChC,CAAC,CAAC,QAAF,CAAW,MAAA,CAAA,YAAX,CADgC,GAEhC,KAAK,aAAL,CAAmB,2BAAnB,CAA+C,CAA/C,CAFJ;AAGD,KARO;;AAUA,IAAA,yBAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B,KAA/B,EAAyC;;;AACvC,UAAM,wBAAwB,GAAG,sBAAA,CAAA,sBAAA,CAC7B,IAD6B,EACvB,KAAK,uBAAL,EADuB,EACS,KADT,EACgB,KAAK,cAAL,EADhB,EACuC,sBAAA,CAAA,WAAA,CAAY,UADnD,EAE7B,YAAA;AAAM,eAAA,MAAA,CAAA,KAAA,CAAA,0BAAA,CAAA;AAAiC,OAFV,CAAjC;AAGA,UAAM,OAAO,GAAG,wBAAwB,CAAC,WAAzC;;AACA,OAAA,EAAA,GAAA,KAAK,cAAL,EAAoB,IAApB,CAAwB,KAAxB,CAAwB,EAAxB,EAAwB,OAAA,CAAA,QAAA,CAAI,wBAAwB,CAAC,KAA7B,CAAxB;;AACA,aAAO,OAAP;AACD,KAPO;AASR;;;;;AAKG;;;AACK,IAAA,yBAAA,CAAA,SAAA,CAAA,6BAAA,GAAR,UAAsC,KAAtC,EAAgD;;;AACxC,UAAA,EAAA,GACF,sBAAA,CAAA,sBAAA,CAAuB,IAAvB,EAA6B,KAAK,uBAAL,EAA7B,EAA6D,KAA7D,EAAoE,KAAK,cAAL,EAApE,CADE;AAAA,UAAC,IAAI,GAAA,EAAA,CAAA,IAAL;AAAA,UAAO,KAAK,GAAA,EAAA,CAAA,KAAZ;;AAGN,OAAA,EAAA,GAAA,KAAK,cAAL,EAAoB,IAApB,CAAwB,KAAxB,CAAwB,EAAxB,EAAwB,OAAA,CAAA,QAAA,CAAI,KAAJ,CAAxB;;AACA,aAAO,IAAP;AACD,KANO;;AAQA,IAAA,yBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,WAAxB,EAA6C,OAA7C,EAA0E;AAA1E,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,KAAK,gBAAT,EAA2B;AACzB,YAAM,QAAQ,GAAG,iBAAiB,CAAC,WAAD,EAAc,MAAA,CAAA,4BAAA,CAA6B,OAA7B,CAAd,CAAlC;AACA,aAAK,gBAAL,CAAsB,KAAtB,CAA4B,QAA5B,EAAsC,UAAC,WAAD,EAAc,UAAd,EAAwB;AAC5D,UAAA,KAAI,CAAC,UAAL,CAAgB,GAAhB,CAAoB,UAApB;AACD,SAFD;AAGD;AACF,KAPO;AASR;;;;;;;;;;;;;;;;;;;;;;AAsBG;;;AACK,IAAA,yBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,UACI,WADJ,EACyB,gBADzB,EAC8D,MAD9D,EAEI,OAFJ,EAE6B,MAF7B,EAGI,aAHJ,EAII,cAJJ,EAI2C;;;AADvC,UAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,aAAA,GAAA,EAAA;AAAwD;;AACxD,UAAA,cAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,cAAA,GAAA,EAAA;AAAuC;;AACzC,UAAM,WAAW,GAAG,IAAI,GAAJ,EAApB;AACA,UAAM,SAAS,GAAmB,EAAlC;AACA,UAAI,eAAJ;;;AAEA,aAAmB,IAAA,kBAAA,GAAA,OAAA,CAAA,QAAA,CAAA,gBAAA,CAAA,EAAgB,oBAAA,GAAA,kBAAA,CAAA,IAAA,EAAnC,EAAmC,CAAA,oBAAA,CAAA,IAAnC,EAAmC,oBAAA,GAAA,kBAAA,CAAA,IAAA,EAAnC,EAAqC;AAAhC,cAAM,IAAI,GAAA,oBAAA,CAAA,KAAV;;AACH,cAAI,IAAI,CAAC,IAAL,KAAc,uBAAlB,EAA2C;AACzC,YAAA,eAAe,GAAG,IAAlB;AACD,WAHkC,CAKnC;AACA;;;AACA,cAAI,IAAI,CAAC,IAAT,EAAe;AACb;AACA;AACA;AACA;AACA;AACO,gBAAA,gBAAgB,GAAI,KAAK,UAAL,CAAJ,gBAAhB;AACP,gBAAI,UAAU,GAAA,KAAA,CAAd;;AACA,gBAAI,gBAAgB,CAAC,GAAjB,CAAqB,IAAI,CAAC,IAA1B,CAAJ,EAAqC;AACnC,cAAA,UAAU,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,IAAI,CAAC,IAA1B,CAAb;AACD,aAFD,MAEO;AACL,cAAA,UAAU,GAAG,KAAK,aAAL,CAAmB,IAAI,CAAC,IAAxB,CAAb;AACA,cAAA,gBAAgB,CAAC,GAAjB,CAAqB,IAAI,CAAC,IAA1B,EAAgC,UAAhC;AACD;;AACD,YAAA,SAAS,CAAC,IAAV,CAAe,CAAC,CAAC,OAAF,CAAU,IAAI,CAAC,IAAf,CAAf,EAAqC,UAArC;AACD,WAfD,MAeO;AACL,YAAA,SAAS,CAAC,IAAV,CAAc,KAAd,CAAA,SAAA,EAAS,OAAA,CAAA,QAAA,CACF,wBAAwB,CAAC,IAAI,CAAC,IAAN,CADtB,EACiC,CAAE,qBAAqB,CAAC,WAAD,EAAc,IAAd,CAAvB,CADjC,CAAT;AAED;AACF;;;;;;;;;;;OA/BwC,CAiCzC;AACA;;;AACA,UAAI,eAAJ,EAAqB;AACnB,QAAA,SAAS,CAAC,IAAV,CAAc,KAAd,CAAA,SAAA,EAAS,OAAA,CAAA,QAAA,CAAS,qBAAqB,CAAC,eAAD,CAA9B,CAAT;AACD;;AAED,eAAS,WAAT,CAAqB,GAArB,EAAyC,KAAzC,EAA6D;AAC3D,YAAI,OAAO,GAAP,KAAe,QAAnB,EAA6B;AAC3B,cAAI,CAAC,WAAW,CAAC,GAAZ,CAAgB,GAAhB,CAAL,EAA2B;AACzB,YAAA,SAAS,CAAC,IAAV,CAAc,KAAd,CAAA,SAAA,EAAS,OAAA,CAAA,QAAA,CAAS,wBAAwB,CAAC,GAAD,CAAjC,CAAT;AACA,YAAA,KAAK,KAAK,SAAV,IAAuB,SAAS,CAAC,IAAV,CAAe,KAAf,CAAvB;AACA,YAAA,WAAW,CAAC,GAAZ,CAAgB,GAAhB;AACD;AACF,SAND,MAMO;AACL,UAAA,SAAS,CAAC,IAAV,CAAe,CAAC,CAAC,OAAF,CAAU,GAAV,CAAf;AACD;AACF,OAjDwC,CAmDzC;AACA;AACA;;;AACA,UAAI,MAAJ,EAAY;AACV,QAAA,MAAM,CAAC,2BAAP,CAAmC,SAAnC;AACD;;AAED,UAAI,MAAM,CAAC,MAAP,IAAiB,OAAO,CAAC,MAA7B,EAAqC;AACnC,YAAM,uBAAuB,GAAG,SAAS,CAAC,MAA1C;;AAEA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,cAAM,KAAK,GAAG,MAAM,CAAC,CAAD,CAApB,CADsC,CAEtC;AACA;;AACA,cAAI,KAAK,CAAC,IAAN,KAAU;AAAA;AAAV,aAAwC,KAAK,CAAC,IAAN,KAAU;AAAA;AAAtD,YAAkF;AAChF,cAAA,WAAW,CAAC,KAAK,CAAC,IAAP,CAAX;AACD;AACF;;AAED,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,EAArC,EAAyC;AACvC,cAAM,MAAM,GAAG,OAAO,CAAC,CAAD,CAAtB;;AACA,cAAI,MAAM,CAAC,IAAP,KAAW;AAAA;AAAf,YAA+C;AAC7C,cAAA,WAAW,CAAC,MAAM,CAAC,IAAR,CAAX;AACD;AACF,SAjBkC,CAmBnC;AACA;AACA;AACA;;;AACA,YAAI,SAAS,CAAC,MAAV,KAAqB,uBAAzB,EAAkD;AAChD,UAAA,SAAS,CAAC,MAAV,CAAiB,uBAAjB,EAA0C,CAA1C,EAA6C,CAAC,CAAC,OAAF,CAAS;AAAA;AAAT,WAA7C;AACD;AACF;;AAED,UAAI,aAAa,CAAC,MAAlB,EAA0B;AACxB,QAAA,SAAS,CAAC,IAAV,CAAe,CAAC,CAAC,OAAF,CAAS;AAAA;AAAT,SAAf;AACA,QAAA,aAAa,CAAC,OAAd,CAAsB,UAAA,IAAA,EAAI;AAAI,iBAAA,WAAW,CAAC,IAAI,CAAhB,IAAW,CAAX;AAAsB,SAApD;AACD;;AAED,UAAI,cAAc,CAAC,MAAnB,EAA2B;AACzB,QAAA,SAAS,CAAC,IAAV,CAAe,CAAC,CAAC,OAAF,CAAS;AAAA;AAAT,SAAf;AACA,QAAA,cAAc,CAAC,OAAf,CAAuB,UAAA,IAAA,EAAI;AAAI,iBAAA,WAAW,CAAC,IAAI,CAAhB,IAAW,CAAX;AAAsB,SAArD;AACD;;AAED,aAAO,SAAP;AACD,KArGO;;AAuGA,IAAA,yBAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,UAApB,EAA4C;AAC1C,UAAI,CAAC,CAAC,MAAF,CAAS,UAAT,CAAJ,EAA0B;AACxB,eAAO,CAAC,CAAC,eAAT;AACD;;AAED,UAAM,MAAM,GAAG,KAAK,UAAL,CAAgB,gBAA/B,CAL0C,CAO1C;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACtC,YAAI,MAAM,CAAC,CAAD,CAAN,CAAU,YAAV,CAAuB,UAAvB,CAAJ,EAAwC;AACtC,iBAAO,CAAC,CAAC,OAAF,CAAU,CAAV,CAAP;AACD;AACF;;AAED,aAAO,CAAC,CAAC,OAAF,CAAU,MAAM,CAAC,IAAP,CAAY,UAAZ,IAA0B,CAApC,CAAP;AACD,KAfO;;AAiBA,IAAA,yBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,KAAzB,EAA8C;AAC5C,aAAO,KAAK,CAAC,MAAN,GAAe,CAAf,GAAmB,KAAK,WAAL,CAAiB,CAAC,CAAC,UAAF,CAAa,KAAb,CAAjB,CAAnB,GAA2D,CAAC,CAAC,eAApE;AACD,KAFO;;AAIA,IAAA,yBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,UAAzB,EAAkD;AAAlD,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,CAAC,UAAD,IAAe,UAAU,CAAC,MAAX,KAAsB,CAAzC,EAA4C;AAC1C,eAAO,CAAC,CAAC,eAAT;AACD;;AAED,UAAM,SAAS,GAAG,kBAAA,CAAA,OAAA,CAAQ,UAAU,CAAC,GAAX,CAAe,UAAA,SAAA,EAAS;AAChD,YAAM,IAAI,GAAG,KAAI,CAAC,gBAAL,EAAb,CADgD,CAEhD;;;AACA,YAAM,YAAY,GAAG,KAAI,CAAC,aAAL,CAAmB,kBAAnB,EAArB;;AACA,YAAM,cAAc,GAAG,KAAI,CAAC,KAA5B;AACA,YAAM,GAAG,GAAG,CAAC,CAAC,QAAF,CAAW,YAAX,CAAZ;;AACA,QAAA,KAAI,CAAC,aAAL,CAAmB,GAAnB,CACI,cADJ,EACoB,SAAS,CAAC,IAD9B,EACoC,GADpC,EACuC;AAAA;AADvC,UAEiC,UAAC,KAAD,EAAsB,aAAtB,EAA2C;AACtE;AACA,cAAM,eAAe,GACjB,aAAa,GAAG,CAAhB,GAAoB,CAAC,uBAAuB,CAAC,aAAD,CAAvB,CAAuC,MAAvC,EAAD,CAApB,GAAwE,EAD5E,CAFsE,CAKtE;;AACA,cAAM,OAAO,GAAG,GAAG,CAAC,GAAJ,CAAQ,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,SAAhB,EAA2B,MAA3B,CAAkC,CAAC,CAAC,CAAC,OAAF,CAAU,IAAV,CAAD,CAAlC,CAAR,CAAhB;AACA,iBAAO,eAAe,CAAC,MAAhB,CAAuB,OAAO,CAAC,WAAR,EAAvB,CAAP;AACD,SAVL,EAUO,IAVP;;AAWA,eAAO,CAAC,SAAS,CAAC,IAAX,EAAiB,SAAS,CAAC,KAA3B,CAAP;AACD,OAlByB,CAAR,CAAlB;AAoBA,aAAO,MAAA,CAAA,SAAA,CAAU,SAAV,CAAP;AACD,KA1BO;;AA4BA,IAAA,yBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,OAAjC,EAAkD,SAAlD,EAA2E,KAA3E,EAAwF;AAAxF,UAAA,KAAA,GAAA,IAAA;;AAEE,aAAO,YAAA;AACL,YAAM,SAAS,GAAW,SAAS,CAAC,IAApC;AACA,YAAM,aAAa,GAAG,SAAS,CAAC,IAAV,KAAc;AAAA;AAAd,UAClB;AACA,QAAA,MAAA,CAAA,oCAAA,CAAqC,SAArC,EAAgD,SAAS,CAAC,KAA1D,CAFkB,GAGlB,kBAAA,CAAA,kBAAA,CAAmB,SAAnB,CAHJ;AAIA,YAAM,WAAW,GAAM,KAAI,CAAC,YAAL,GAAiB,GAAjB,GAAqB,OAArB,GAA4B,GAA5B,GAAgC,aAAhC,GAA6C,GAA7C,GAAiD,KAAjD,GAAsD,WAA7E;;AACA,YAAM,KAAK,GAAG,KAAI,CAAC,aAAL,CAAmB,WAAnB,CACV,KAAI,CAAC,aAAL,CAAmB,YADT,EACuB,2BADvB,CAAd;;AAEA,eAAO,8BAA8B,CAAC,SAAD,EAAY,WAAZ,EAAyB,KAAzB,CAArC;AACD,OAVD;AAWD,KAbO;;AAcV,WAAA,yBAAA;AAAC,GAlzCD,EAAA;;AAAa,EAAA,OAAA,CAAA,yBAAA,GAAA,yBAAA;;AAozCb,MAAA,cAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAoC,IAAA,OAAA,CAAA,SAAA,CAAA,cAAA,EAAA,MAAA;;AAGlC,aAAA,cAAA,CACY,YADZ,EACgD,YADhD,EAEY,yBAFZ,EAGY,UAHZ,EAIoF;AAJpF,UAAA,KAAA,GAKE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IALT;;AACY,MAAA,KAAA,CAAA,YAAA,GAAA,YAAA;AAAoC,MAAA,KAAA,CAAA,YAAA,GAAA,YAAA;AACpC,MAAA,KAAA,CAAA,yBAAA,GAAA,yBAAA;AACA,MAAA,KAAA,CAAA,UAAA,GAAA,UAAA;AALJ,MAAA,KAAA,CAAA,cAAA,GAAiC,EAAjC;;AAQP,KATH,CAWE;;;AACA,IAAA,cAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,IAAV,EAA6B,OAA7B,EAAyC;AACvC;AACA,UAAM,IAAI,GAAG,KAAK,YAAL,EAAb;AACA,UAAM,eAAe,GAAG,UAAQ,IAAhC,CAHuC,CAIvC;;AACA,UAAM,gBAAgB,GAAG,KAAK,yBAAL,CAA+B,IAAI,IAAI,CAAC,IAAL,CAAU,MAA7C,CAAzB;AACA,UAAM,MAAM,GAAG,IAAI,KAAA,CAAA,YAAJ,CACX,IAAI,CAAC,IADM,EACA,IAAI,CAAC,UADL,EACiB,IAAI,CAAC,QADtB,EACgC,IAAI,KAAA,CAAA,gBAAJ,CAAqB,IAAI,CAAC,IAA1B,EAAgC,IAAI,CAAC,UAArC,CADhC,EAEX,eAFW,CAAf;;AAGM,UAAA,EAAA,GAA4B,mBAAmB,CAAC,IAAI,CAAC,IAAN,CAA/C;AAAA,UAAC,UAAU,GAAA,EAAA,CAAA,UAAX;AAAA,UAAa,WAAW,GAAA,EAAA,CAAA,WAAxB;;AACN,WAAK,UAAL,CAAgB,IAAI,CAAC,IAArB,EAA2B,eAA3B,EAA4C,IAA5C,EAAkD,CAAC,CAAC,UAAF,CAAa,UAAb,CAAlD;;AACA,UAAM,IAAI,GAAA,OAAA,CAAA,QAAA,CAAA,CAAW,IAAI,CAAC,GAAhB,CAAA,EAAwB,IAAI,CAAC,IAA7B,CAAV;;AACA,UAAM,aAAa,GAAU,WAAW,GACpC,KAAK,QAAL,CAAc,CAAC,IAAI,KAAA,CAAA,YAAJ,CAAiB,IAAI,CAAC,IAAtB,EAA4B,IAAI,CAAC,UAAjC,EAA6C,IAA7C,CAAD,CAAd,CADoC,GAEpC,KAAK,QAAL,CAAc,IAAd,CAFJ;AAIA,UAAM,YAAY,GAAG,IAAI,KAAA,CAAA,YAAJ,CAAiB,IAAI,CAAC,IAAtB,EAA4B,IAAI,CAAC,UAAjC,EAA6C,MAA7C,EAAmD,OAAA,CAAA,QAAA,CAAA,CACtE,IAAI,KAAA,CAAA,gBAAJ,CAAqB,IAAI,CAAC,IAA1B,EAAgC,IAAI,CAAC,UAArC,EAAiD,IAAjD,CADsE,EAEtE,IAAI,KAAA,CAAA,gBAAJ,CAAqB,IAAI,CAAC,IAA1B,EAAgC,IAAI,CAAC,UAArC,EAAiD,gBAAjD,CAFsE,CAAA,EAGnE,aAHmE,CAAnD,CAArB;;AAKA,WAAK,cAAL,CAAoB,IAApB,CAAyB,YAAzB;;AACA,aAAO,YAAP;AACD,KAvBD;;AAyBA,IAAA,cAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,YAAtB,EAA0C;AACxC,WAAK,cAAL,CAAoB,OAApB,CAA4B,UAAC,IAAD,EAAmB;AAC7C;AACA,YAAM,UAAU,GAAG,IAAI,CAAC,IAAL,CAAU,CAAV,CAAnB;AACC,QAAA,UAAU,CAAC,KAAX,IAA+B,YAA/B;AACF,OAJD;AAKD,KAND;;AAQA,IAAA,cAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,KAAlB,EAAuC,OAAvC,EAAmD;AAAnD,UAAA,KAAA,GAAA,IAAA;;AACE,aAAO,IAAI,sBAAA,CAAA,mBAAJ,CACH,KAAK,CAAC,IADH,EACS,KAAK,CAAC,UADf,EAC2B,KAAK,QAAL,CAAc,KAAK,CAAC,WAApB,CAD3B,EAC6D,UAAA,MAAA,EAAM;AACpE;AACA;AACA;AACA,YAAM,OAAO,GAAG,CAAC,CAAC,UAAF,CAAa,MAAb,CAAhB;AACA,eAAO,iBAAiB,CAAC,KAAI,CAAC,YAAN,EAAoB,OAApB,EAA6B,KAAI,CAAC,yBAAlC,CAAxB;AACD,OAPE,CAAP;AAQD,KATD;;AAWA,IAAA,cAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,GAAhB,EAAiC,OAAjC,EAA6C;AAA7C,UAAA,KAAA,GAAA,IAAA;;AACE,aAAO,IAAI,sBAAA,CAAA,mBAAJ,CAAwB,GAAG,CAAC,IAA5B,EAAkC,GAAG,CAAC,UAAtC,EAAkD,KAAK,QAAL,CAAc,GAAG,CAAC,MAAlB,CAAlD,EAA6E,UAAA,MAAA,EAAM;AACxF;AACA;AACA;AACA,YAAM,OAAO,GAAG,CAAC,CAAC,UAAF,CAAa,MAAM,CAAC,GAAP,CACzB,UAAC,KAAD,EAAQ,KAAR,EAAa;AAAK,iBAAC;AAAC,YAAA,GAAG,EAAE,GAAG,CAAC,IAAJ,CAAS,KAAT,EAAgB,GAAtB;AAA2B,YAAA,KAAK,EAAA,KAAhC;AAAkC,YAAA,MAAM,EAAE,GAAG,CAAC,IAAJ,CAAS,KAAT,EAA3C;AAAC,WAAD;AAAmE,SAD5D,CAAb,CAAhB;AAEA,eAAO,iBAAiB,CAAC,KAAI,CAAC,YAAN,EAAoB,OAApB,EAA6B,KAAI,CAAC,yBAAlC,CAAxB;AACD,OAPM,CAAP;AAQD,KATD;;AAUF,WAAA,cAAA;AAAC,GAlED,CAAoC,KAAA,CAAA,6BAApC,CAAA;;AAAa,EAAA,OAAA,CAAA,cAAA,GAAA,cAAA,C,CAoEb;;AACA,MAAM,sBAAsB,GAAG,CAAC,gBAAA,CAAA,WAAA,CAAG,SAAJ,EAAe,gBAAA,CAAA,WAAA,CAAG,SAAlB,EAA6B,gBAAA,CAAA,WAAA,CAAG,SAAhC,EAA2C,gBAAA,CAAA,WAAA,CAAG,SAA9C,CAA/B;;AAEA,WAAS,mBAAT,CAA6B,IAA7B,EAAiD;AAC/C,QAAM,UAAU,GAAG,sBAAsB,CAAC,IAAI,CAAC,MAAN,CAAzC;AACA,WAAO;AACL,MAAA,UAAU,EAAE,UAAU,IAAI,gBAAA,CAAA,WAAA,CAAG,SADxB;AAEL,MAAA,WAAW,EAAE,CAAC;AAFT,KAAP;AAID;;AAED,MAAM,uBAAuB,GAAG,CAC9B,gBAAA,CAAA,WAAA,CAAG,aAD2B,EACZ,gBAAA,CAAA,WAAA,CAAG,aADS,EACM,gBAAA,CAAA,WAAA,CAAG,aADT,EACwB,gBAAA,CAAA,WAAA,CAAG,aAD3B,EAC0C,gBAAA,CAAA,WAAA,CAAG,aAD7C,EAE9B,gBAAA,CAAA,WAAA,CAAG,aAF2B,EAEZ,gBAAA,CAAA,WAAA,CAAG,aAFS,EAEM,gBAAA,CAAA,WAAA,CAAG,aAFT,EAEwB,gBAAA,CAAA,WAAA,CAAG,aAF3B,CAAhC;;AAKA,WAAS,oBAAT,CAA8B,IAA9B,EAAkD;AAChD,QAAM,UAAU,GAAG,uBAAuB,CAAC,IAAI,CAAC,MAAN,CAA1C;AACA,WAAO;AACL,MAAA,UAAU,EAAE,UAAU,IAAI,gBAAA,CAAA,WAAA,CAAG,aADxB;AAEL,MAAA,WAAW,EAAE,CAAC;AAFT,KAAP;AAID;;AAED,WAAS,WAAT,CACI,IADJ,EACgC,SADhC,EAEI,MAFJ,EAE0B;AACxB,WAAO,CAAC,CAAC,UAAF,CAAa,SAAb,EAAwB,IAAxB,EAA8B,IAA9B,EAAoC,MAApC,CAA2C,MAA3C,EAAmD,IAAnD,CAAP;AACD,G,CAED;;;AACA,WAAS,uBAAT,CAAiC,iBAAjC,EAA0D;AACxD,WAAO,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,WAAhB,EACF,MADE,CACK,iBAAiB,GAAG,CAApB,GAAwB,CAAC,CAAC,CAAC,OAAF,CAAU,iBAAV,CAAD,CAAxB,GAAyD,EAD9D,CAAP;AAED;;AAED,WAAS,iBAAT,CACI,YADJ,EACgC,OADhC,EAEI,aAFJ,EAE+C;AACvC,QAAA,EAAA,GAA4C,YAAY,CAAC,iBAAb,CAA+B,OAA/B,CAA5C;AAAA,QAAC,cAAc,GAAA,EAAA,CAAA,cAAf;AAAA,QAAiB,uBAAuB,GAAA,EAAA,CAAA,uBAAxC,CADuC,CAE7C;;;AACA,QAAM,SAAS,GAAG,aAAa,CAAC,IAAI,uBAAuB,CAAC,MAA7B,CAA/B;;AACM,QAAA,EAAA,GAA4B,oBAAoB,CAAC,uBAAD,CAAhD;AAAA,QAAC,UAAU,GAAA,EAAA,CAAA,UAAX;AAAA,QAAa,WAAW,GAAA,EAAA,CAAA,WAAxB,CAJuC,CAM7C;AACA;;;AACA,QAAM,IAAI,GAAG,CAAC,CAAC,CAAC,OAAF,CAAU,SAAV,CAAD,EAAuB,cAAvB,CAAb;;AAEA,QAAI,WAAJ,EAAiB;AACf,MAAA,IAAI,CAAC,IAAL,CAAU,CAAC,CAAC,UAAF,CAAa,uBAAb,CAAV;AACD,KAFD,MAEO;AACL,MAAA,IAAI,CAAC,IAAL,CAAS,KAAT,CAAA,IAAA,EAAI,OAAA,CAAA,QAAA,CAAS,uBAAT,CAAJ;AACD;;AAED,WAAO,CAAC,CAAC,UAAF,CAAa,UAAb,EAAyB,MAAzB,CAAgC,IAAhC,CAAP;AACD;AAED;;;;;;AAMG;;;AACH,WAAS,wBAAT,CAAkC,IAAlC,EAA8C;AACtC,QAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAAsC,MAAA,CAAA,WAAA,CAAY,IAAZ,CAAtC,EAAuD,CAAvD,CAAA;AAAA,QAAC,kBAAkB,GAAA,EAAA,CAAA,CAAA,CAAnB;AAAA,QAAqB,aAAa,GAAA,EAAA,CAAA,CAAA,CAAlC;;AACN,QAAM,WAAW,GAAG,CAAC,CAAC,OAAF,CAAU,aAAV,CAApB;;AAEA,QAAI,kBAAJ,EAAwB;AACtB,aAAO,CACL,CAAC,CAAC,OAAF,CAAS;AAAA;AAAT,OADK,EACyC,CAAC,CAAC,OAAF,CAAU,kBAAV,CADzC,EACwE,WADxE,CAAP;AAGD;;AAED,WAAO,CAAC,WAAD,CAAP;AACD;AAUD;;;AACA,MAAM,kBAAkB,GAAG,gBAA3B;;AAgCA,MAAA,YAAA;AAAA;AAAA,cAAA;AASE,aAAA,YAAA,CACW,YADX,EAC6C,MAD7C,EAEW,OAFX,EAEgC;;;AADrB,UAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,YAAA,GAAA,CAAA;AAAwB;;AAAU,UAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,MAAA,GAAA,IAAA;AAAgC;;AAAlE,WAAA,YAAA,GAAA,YAAA;AAAkC,WAAA,MAAA,GAAA,MAAA;AAClC,WAAA,OAAA,GAAA,OAAA;AAVX;;AACQ,WAAA,GAAA,GAAM,IAAI,GAAJ,EAAN;AACA,WAAA,kBAAA,GAAqB,CAArB;AACA,WAAA,mBAAA,GAA0C,IAA1C;;AAQN,UAAI,OAAO,KAAK,SAAhB,EAA2B;;AACzB,eAAmB,IAAA,SAAA,GAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,EAAO,WAAA,GAAA,SAAA,CAAA,IAAA,EAA1B,EAA0B,CAAA,WAAA,CAAA,IAA1B,EAA0B,WAAA,GAAA,SAAA,CAAA,IAAA,EAA1B,EAA4B;AAAvB,gBAAM,MAAI,GAAA,WAAA,CAAA,KAAV;AACH,iBAAK,GAAL,CAAS,CAAT,EAAY,MAAZ,EAAkB,CAAC,CAAC,QAAF,CAAW,MAAX,CAAlB;AACD;;;;;;;;;;;;AACF;AACF;;AAZM,IAAA,YAAA,CAAA,eAAA,GAAP,YAAA;AACE,aAAO,IAAI,YAAJ,EAAP;AACD,KAFM;;AAcP,IAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,IAAJ,EAAgB;AACd,UAAI,OAAO,GAAsB,IAAjC;;AACA,aAAO,OAAP,EAAgB;AACd,YAAI,KAAK,GAAG,OAAO,CAAC,GAAR,CAAY,GAAZ,CAAgB,IAAhB,CAAZ;;AACA,YAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAI,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACA,YAAA,KAAK,GAAG;AACN,cAAA,cAAc,EAAE,KAAK,CAAC,cADhB;AAEN,cAAA,GAAG,EAAE,KAAK,CAAC,GAFL;AAGN,cAAA,oBAAoB,EAAE,KAAK,CAAC,oBAHtB;AAIN,cAAA,OAAO,EAAE,KAJH;AAKN,cAAA,QAAQ,EAAE,KAAK,CAAC,QALV;AAMN,cAAA,QAAQ,EAAE,KAAK,CAAC;AANV,aAAR,CAFoB,CAWpB;;AACA,iBAAK,GAAL,CAAS,GAAT,CAAa,IAAb,EAAmB,KAAnB,EAZoB,CAapB;;AACA,iBAAK,6BAAL,CAAmC,KAAnC;AACA,iBAAK,gBAAL,CAAsB,KAAK,CAAC,cAA5B,EAA4C,KAAK,CAAC,QAAlD;AACD;;AAED,cAAI,KAAK,CAAC,oBAAN,IAA8B,CAAC,KAAK,CAAC,OAAzC,EAAkD;AAChD,YAAA,KAAK,CAAC,OAAN,GAAgB,IAAhB;AACD;;AACD,iBAAO,KAAK,CAAC,GAAb;AACD;;AACD,QAAA,OAAO,GAAG,OAAO,CAAC,MAAlB;AACD,OA7Ba,CA+Bd;AACA;AACA;AACA;;;AACA,aAAO,KAAK,YAAL,KAAsB,CAAtB,GAA0B,IAA1B,GAAiC,KAAK,oBAAL,CAA0B,IAA1B,CAAxC;AACD,KApCD;AAsCA;;;;;;;;;AASG;;;AACH,IAAA,YAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,cAAJ,EAA4B,IAA5B,EAA0C,GAA1C,EACI,QADJ,EAEI,oBAFJ,EAEoD,QAFpD,EAEmE;AAD/D,UAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,QAAA,GAAA;AAAA;AAAA;AAA8C;;AAEhD,UAAI,KAAK,GAAL,CAAS,GAAT,CAAa,IAAb,CAAJ,EAAwB;AACtB,YAAI,QAAJ,EAAc;AACZ;AACA;AACA,iBAAO,IAAP;AACD;;AACD,QAAA,MAAA,CAAA,KAAA,CAAM,cAAY,IAAZ,GAAgB,qCAAhB,GAAsD,KAAK,GAAL,CAAS,GAAT,CAAa,IAAb,CAA5D;AACD;;AACD,WAAK,GAAL,CAAS,GAAT,CAAa,IAAb,EAAmB;AACjB,QAAA,cAAc,EAAE,cADC;AAEjB,QAAA,GAAG,EAAE,GAFY;AAGjB,QAAA,OAAO,EAAE,KAHQ;AAIjB,QAAA,oBAAoB,EAAE,oBAJL;AAKjB,QAAA,QAAQ,EAAE,QALO;AAMjB,QAAA,QAAQ,EAAE,QAAQ,IAAI;AANL,OAAnB;AAQA,aAAO,IAAP;AACD,KApBD,CAnEF,CAyFE;;;AACA,IAAA,YAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,IAAT,EAAqB;AACnB,aAAO,KAAK,GAAL,CAAS,IAAT,CAAP;AACD,KAFD,CA1FF,CA8FE;;;AACA,IAAA,YAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,YAAA;AACE,UAAI,KAAK,YAAL,KAAsB,CAA1B,EAA6B;AAC3B;AACA;AACA;AACA,aAAK,GAAL,CAAS,GAAT,CAAa,kBAAkB,GAAG,CAAlC,EAAsC,OAAtC,GAAgD,IAAhD;AACD;AACF,KAPD;;AASA,IAAA,YAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,KAAZ,EAA2B,OAA3B,EAAgD;AAC9C,UAAM,QAAQ,GAAG,IAAI,YAAJ,CAAiB,KAAjB,EAAwB,IAAxB,EAA8B,OAA9B,CAAjB;AACA,UAAI,KAAK,GAAG,CAAZ,EAAe,QAAQ,CAAC,wBAAT,CAAkC,CAAlC;AACf,aAAO,QAAP;AACD,KAJD;AAMA;;;;AAIG;;;AACH,IAAA,YAAA,CAAA,SAAA,CAAA,2BAAA,GAAA,UAA4B,cAA5B,EAAkD;AAChD,UAAM,UAAU,GAAG,kBAAkB,GAAG,cAAxC;;AACA,UAAI,CAAC,KAAK,GAAL,CAAS,GAAT,CAAa,UAAb,CAAL,EAA+B;AAC7B,aAAK,wBAAL,CAA8B,cAA9B;AACD,OAJ+C,CAKhD;;;AACA,aAAO,KAAK,GAAL,CAAS,GAAT,CAAa,UAAb,EAA0B,GAAjC;AACD,KAPD;;AASA,IAAA,YAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,cAArB,EAA2C;AACzC,UAAM,YAAY,GAAG,KAAK,GAAL,CAAS,GAAT,CAAa,kBAAkB,GAAG,cAAlC,CAArB,CADyC,CAEzC;;AACA,aAAO,YAAY,IAAI,YAAY,CAAC,OAA7B,GAAuC,YAAY,CAAC,GAApD,GAA2E,IAAlF;AACD,KAJD;;AAMA,IAAA,YAAA,CAAA,SAAA,CAAA,6BAAA,GAAA,UAA8B,KAA9B,EAAgD;AAC9C,UAAI,KAAK,CAAC,QAAN,KAAc;AAAA;AAAd,SACA,KAAK,CAAC,cAAN,GAAuB,KAAK,YADhC,EAC8C;AAC5C,YAAM,YAAY,GAAG,KAAK,GAAL,CAAS,GAAT,CAAa,kBAAkB,GAAG,KAAK,CAAC,cAAxC,CAArB;;AACA,YAAI,YAAJ,EAAkB;AAChB,UAAA,YAAY,CAAC,OAAb,GAAuB,IAAvB;AACD,SAFD,MAEO;AACL,eAAK,wBAAL,CAA8B,KAAK,CAAC,cAApC;AACD;AACF;AACF,KAVD;;AAYA,IAAA,YAAA,CAAA,SAAA,CAAA,wBAAA,GAAA,UAAyB,cAAzB,EAA+C;AAC7C,UAAM,GAAG,GAAG,CAAC,CAAC,QAAF,CAAW,MAAA,CAAA,YAAA,GAAe,KAAK,kBAAL,EAA1B,CAAZ;AACA,WAAK,GAAL,CAAS,GAAT,CAAa,kBAAkB,GAAG,cAAlC,EAAkD;AAChD,QAAA,cAAc,EAAE,cADgC;AAEhD,QAAA,GAAG,EAAE,GAF2C;AAGhD,QAAA,oBAAoB,EAAE,8BAAC,KAAD,EAAsB,aAAtB,EAA2C;AAC/D;AACA,iBAAO,CAAC,GAAG,CAAC,GAAJ,CAAQ,uBAAuB,CAAC,aAAD,CAA/B,EAAgD,WAAhD,EAAD,CAAP;AACD,SAN+C;AAOhD,QAAA,OAAO,EAAE,KAPuC;AAQhD,QAAA,QAAQ,EAAA;AAAA;AARwC;AAShD,QAAA,QAAQ,EAAE;AATsC,OAAlD;AAWD,KAbD;;AAeA,IAAA,YAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,IAArB,EAAiC;AAC/B,UAAM,cAAc,GAAG,KAAK,GAAL,CAAS,GAAT,CAAa,kBAAkB,GAAG,CAAlC,CAAvB;AACA,MAAA,cAAc,CAAC,OAAf,GAAyB,IAAzB;AACA,WAAK,gBAAL,CAAsB,CAAtB,EAAyB,KAAzB;AACA,aAAO,cAAc,CAAC,GAAf,CAAmB,IAAnB,CAAwB,IAAxB,CAAP;AACD,KALD;;AAOA,IAAA,YAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,cAAjB,EAAyC,cAAzC,EAAgE;AAC9D;AACA;AACA;AACA;AACA;AACA,UAAI,KAAK,eAAL,OAA2B,cAAc,GAAG,KAAK,YAAtB,IAAsC,cAAjE,CAAJ,EAAsF;AACpF,YAAI,CAAC,KAAK,MAAL,CAAa,mBAAlB,EAAuC;AACrC;AACA,eAAK,MAAL,CAAa,mBAAb,GAAmC,CAAC,CAAC,QAAF,CAAW,KAAK,MAAL,CAAa,kBAAb,EAAX,CAAnC;AACD;;AACD,aAAK,mBAAL,GAA2B,KAAK,MAAL,CAAa,mBAAxC;AACD;AACF,KAbD;;AAeA,IAAA,YAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;AACE;AACA,aAAO,KAAK,mBAAL,GACH,CAAC,WAAW,CAAC,IAAD,EAAO,gBAAA,CAAA,WAAA,CAAG,WAAV,EAAuB,CAAC,KAAK,mBAAN,CAAvB,CAAX,CAA8D,MAA9D,EAAD,CADG,GAEH,EAFJ;AAGD,KALD;;AAOA,IAAA,YAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,YAAA;AACE;AACA,UAAM,yBAAyB,GAAG,WAAW,CAAC,IAAD,EAAO,gBAAA,CAAA,WAAA,CAAG,cAAV,EAA0B,EAA1B,CAA7C;AACA,aAAO,KAAK,mBAAL,GACH,CAAC,KAAK,mBAAL,CAAyB,GAAzB,CAA6B,yBAA7B,EAAwD,WAAxD,EAAD,CADG,GAEH,EAFJ;AAGD,KAND;;AAQA,IAAA,YAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,aAAO,KAAK,MAAL,IAAe,KAAK,MAAL,CAAY,YAAZ,KAA6B,KAAK,YAAxD;AACD,KAFD;;AAIA,IAAA,YAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;AAAA,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,mBAAmB,GAAG,CAA1B;AACA,aAAO,KAAK,CAAC,IAAN,CAAW,KAAK,GAAL,CAAS,MAAT,EAAX,EACK,MADL,CACY,UAAA,KAAA,EAAK;AAAI,eAAA,KAAK,CAAL,OAAA;AAAa,OADlC,EAEK,IAFL,CAEU,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,eAAA,CAAC,CAAC,cAAF,GAAmB,CAAC,CAAC,cAArB,IAAuC,CAAC,CAAC,QAAF,GAAa,CAAC,CAArD,QAAA;AAA8D,OAFlF,EAGK,MAHL,CAGY,UAAC,KAAD,EAAuB,KAAvB,EAAyC;AAC/C,YAAM,SAAS,GAAG,KAAI,CAAC,YAAL,GAAoB,KAAK,CAAC,cAA5C;AACA,YAAM,SAAS,GACX,KAAK,CAAC,oBAAN,CAA4B,KAA5B,EAAkC,SAAS,GAAG,mBAA9C,CADJ;AAEA,QAAA,mBAAmB,GAAG,SAAtB;AACA,eAAO,KAAK,CAAC,MAAN,CAAa,SAAb,CAAP;AACD,OATL,EASO,EATP,CAAP;AAUD,KAZD;;AAeA,IAAA,YAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,YAAA;AACE,UAAI,OAAO,GAAiB,IAA5B,CADF,CAEE;;AACA,aAAO,OAAO,CAAC,MAAf;AAAuB,QAAA,OAAO,GAAG,OAAO,CAAC,MAAlB;AAAvB;;AACA,UAAM,GAAG,GAAG,KAAG,MAAA,CAAA,gBAAH,GAAsB,OAAO,CAAC,kBAAR,EAAlC;AACA,aAAO,GAAP;AACD,KAND;;AAOF,WAAA,YAAA;AAAC,GA5ND,EAAA;;AAAa,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA;AA8Nb;;AAEG;;AACH,WAAgB,iBAAhB,CACI,WADJ,EACyB,UADzB,EAC6D;AAC3D,QAAM,WAAW,GAAG,IAAI,UAAA,CAAA,WAAJ,EAApB;AACA,QAAM,eAAe,GAAG,MAAA,CAAA,WAAA,CAAY,WAAZ,EAAyB,CAAzB,CAAxB;AAEA,IAAA,WAAW,CAAC,UAAZ,CAAuB,eAAvB;AAEA,IAAA,MAAM,CAAC,mBAAP,CAA2B,UAA3B,EAAuC,OAAvC,CAA+C,UAAC,IAAD,EAAK;AAClD,UAAM,QAAQ,GAAG,MAAA,CAAA,WAAA,CAAY,IAAZ,EAAkB,CAAlB,CAAjB;AACA,UAAM,KAAK,GAAG,UAAU,CAAC,IAAD,CAAxB;AAEA,MAAA,WAAW,CAAC,YAAZ,CAAyB,QAAzB,EAAmC,KAAnC;;AACA,UAAI,IAAI,CAAC,WAAL,OAAuB,OAA3B,EAAoC;AAClC,YAAM,OAAO,GAAG,KAAK,CAAC,IAAN,GAAa,KAAb,CAAmB,KAAnB,CAAhB;AACA,QAAA,OAAO,CAAC,OAAR,CAAgB,UAAA,SAAA,EAAS;AAAI,iBAAA,WAAW,CAAC,YAAZ,CAAA,SAAA,CAAA;AAAmC,SAAhE;AACD;AACF,KATD;AAWA,WAAO,WAAP;AACD;;AAnBD,EAAA,OAAA,CAAA,iBAAA,GAAA,iBAAA;AAqBA;;;AAGG;;AACH,WAAS,qBAAT,CAA+B,SAA/B,EAAyD;AACvD;AACA;AACA,QAAM,gBAAgB,GAAG,IAAI,CAAC,yBAAL,CAA+B,SAAS,CAAC,KAAzC,EAAgD,CAAhD,CAAzB;AACA,WAAO,CAAC,CAAC,CAAC,OAAF,CAAS;AAAA;AAAT,KAAD,EAA4C,MAAA,CAAA,SAAA,CAAU,gBAAV,CAA5C,CAAP;AACD;AAED;;;AAGG;;;AACH,WAAS,kCAAT,CAA4C,aAA5C,EAAwE;AACtE,YAAQ,MAAA,CAAA,0BAAA,CAA2B,aAA3B,CAAR;AACE,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,mBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;;AACF;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,oBAAV;AApBJ;AAsBD;AAED;;;AAGG;;;AACH,WAAS,mCAAT,CAA6C,aAA7C,EAAyE;AACvE,YAAQ,MAAA,CAAA,0BAAA,CAA2B,aAA3B,CAAR;AACE,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;;AACF;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,qBAAV;AAlBJ;AAoBD;AAED;;;AAGG;;;AACH,WAAS,8BAAT,CAAwC,aAAxC,EAAoE;AAClE,YAAQ,MAAA,CAAA,0BAAA,CAA2B,aAA3B,CAAR;AACE,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,eAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;;AACF,WAAK,CAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;;AACF,WAAK,EAAL;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;;AACF;AACE,eAAO,gBAAA,CAAA,WAAA,CAAG,gBAAV;AApBJ;AAsBD;AAyGD;;;;;;AAMG;;;AACH,WAAgB,aAAhB,CACI,QADJ,EACsB,WADtB,EAC2C,OAD3C,EAC6E;;;AAAlC,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,EAAA;AAAkC;;AACpE,QAAA,mBAAmB,GAA0D,OAAO,CAAjE,mBAAnB;AAAA,QAAqB,mBAAmB,GAAqC,OAAO,CAA5C,mBAAxC;AAAA,QAA0C,+BAA+B,GAAI,OAAO,CAAX,+BAAzE;AACP,QAAM,QAAQ,GAAA,CAAA,EAAA,GAAG,OAAO,CAAC,QAAX,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,EAAnB,GAAuB,KAArC;AACA,QAAM,aAAa,GAAG,iBAAiB,CAAC,mBAAD,CAAvC;AACA,QAAM,UAAU,GAAG,IAAI,aAAA,CAAA,UAAJ,EAAnB;AACA,QAAM,WAAW,GAAG,UAAU,CAAC,KAAX,CAChB,QADgB,EACN,WADM,EACK,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA;AACpB,MAAA,kBAAkB,EAAE,OAAA,CAAA;AADA,KAAA,EACyB,OADzB,CAAA,EACgC;AAAE,MAAA,sBAAsB,EAAE;AAA1B,KADhC,CADL,CAApB;;AAIA,QAAI,CAAC,OAAO,CAAC,kCAAT,IAA+C,WAAW,CAAC,MAA3D,IACA,WAAW,CAAC,MAAZ,CAAmB,MAAnB,GAA4B,CADhC,EACmC;AACjC,UAAM,gBAAc,GAAmB;AACrC,QAAA,mBAAmB,EAAA,mBADkB;AAErC,QAAA,mBAAmB,EAAA,mBAFkB;AAGrC,QAAA,QAAQ,EAAA,QAH6B;AAIrC,QAAA,WAAW,EAAA,WAJ0B;AAKrC,QAAA,QAAQ,EAAA,QAL6B;AAMrC,QAAA,MAAM,EAAE,WAAW,CAAC,MANiB;AAOrC,QAAA,KAAK,EAAE,EAP8B;AAQrC,QAAA,SAAS,EAAE,EAR0B;AASrC,QAAA,MAAM,EAAE,EAT6B;AAUrC,QAAA,kBAAkB,EAAE;AAViB,OAAvC;;AAYA,UAAI,OAAO,CAAC,mBAAZ,EAAiC;AAC/B,QAAA,gBAAc,CAAC,YAAf,GAA8B,EAA9B;AACD;;AACD,aAAO,gBAAP;AACD;;AAED,QAAI,SAAS,GAAgB,WAAW,CAAC,SAAzC,CA7B2E,CA+B3E;AACA;AACA;AACA;;AACA,QAAM,eAAe,GAAG,IAAI,MAAA,CAAA,eAAJ,CACpB,mBADoB;AACC;AAAoB,KAAC,mBADtB,EAEpB,+BAFoB,CAAxB;AAGA,QAAM,cAAc,GAAG,eAAe,CAAC,kBAAhB,CAAmC,SAAnC,CAAvB;;AAEA,QAAI,CAAC,OAAO,CAAC,kCAAT,IAA+C,cAAc,CAAC,MAA9D,IACA,cAAc,CAAC,MAAf,CAAsB,MAAtB,GAA+B,CADnC,EACsC;AACpC,UAAM,gBAAc,GAAmB;AACrC,QAAA,mBAAmB,EAAA,mBADkB;AAErC,QAAA,mBAAmB,EAAA,mBAFkB;AAGrC,QAAA,QAAQ,EAAA,QAH6B;AAIrC,QAAA,WAAW,EAAA,WAJ0B;AAKrC,QAAA,QAAQ,EAAA,QAL6B;AAMrC,QAAA,MAAM,EAAE,cAAc,CAAC,MANc;AAOrC,QAAA,KAAK,EAAE,EAP8B;AAQrC,QAAA,SAAS,EAAE,EAR0B;AASrC,QAAA,MAAM,EAAE,EAT6B;AAUrC,QAAA,kBAAkB,EAAE;AAViB,OAAvC;;AAYA,UAAI,OAAO,CAAC,mBAAZ,EAAiC;AAC/B,QAAA,gBAAc,CAAC,YAAf,GAA8B,EAA9B;AACD;;AACD,aAAO,gBAAP;AACD;;AAED,IAAA,SAAS,GAAG,cAAc,CAAC,SAA3B;;AAEA,QAAI,CAAC,mBAAL,EAA0B;AACxB,MAAA,SAAS,GAAG,IAAI,CAAC,QAAL,CAAc,IAAI,kBAAA,CAAA,iBAAJ,EAAd,EAAuC,SAAvC,CAAZ,CADwB,CAGxB;AACA;AACA;AACA;;AACA,UAAI,eAAe,CAAC,WAApB,EAAiC;AAC/B,QAAA,SAAS,GAAG,IAAI,CAAC,QAAL,CACR,IAAI,MAAA,CAAA,eAAJ,CAAoB,mBAApB;AAAyC;AAAoB,aAA7D,CADQ,EAC6D,SAD7D,CAAZ;AAED;AACF;;AAEK,QAAA,EAAA,GAAuE,uBAAA,CAAA,mBAAA,CACzE,SADyE,EAC9D,aAD8D,EAC/C;AAAC,MAAA,mBAAmB,EAAE,CAAC,CAAC,OAAO,CAAC;AAAhC,KAD+C,CAAvE;AAAA,QAAC,KAAK,GAAA,EAAA,CAAA,KAAN;AAAA,QAAQ,MAAM,GAAA,EAAA,CAAA,MAAd;AAAA,QAAgB,SAAS,GAAA,EAAA,CAAA,SAAzB;AAAA,QAA2B,MAAM,GAAA,EAAA,CAAA,MAAjC;AAAA,QAAmC,kBAAkB,GAAA,EAAA,CAAA,kBAArD;AAAA,QAAuD,YAAY,GAAA,EAAA,CAAA,YAAnE;;AAEN,IAAA,MAAM,CAAC,IAAP,CAAW,KAAX,CAAA,MAAA,EAAM,OAAA,CAAA,QAAA,CAAS,WAAW,CAAC,MAArB,EAAgC,cAAc,CAAC,MAA/C,CAAN;AAEA,QAAM,cAAc,GAAmB;AACrC,MAAA,mBAAmB,EAAA,mBADkB;AAErC,MAAA,mBAAmB,EAAA,mBAFkB;AAGrC,MAAA,MAAM,EAAE,MAAM,CAAC,MAAP,GAAgB,CAAhB,GAAoB,MAApB,GAA6B,IAHA;AAIrC,MAAA,QAAQ,EAAA,QAJ6B;AAKrC,MAAA,WAAW,EAAA,WAL0B;AAMrC,MAAA,QAAQ,EAAA,QAN6B;AAOrC,MAAA,KAAK,EAAA,KAPgC;AAQrC,MAAA,SAAS,EAAA,SAR4B;AASrC,MAAA,MAAM,EAAA,MAT+B;AAUrC,MAAA,kBAAkB,EAAA;AAVmB,KAAvC;;AAYA,QAAI,OAAO,CAAC,mBAAZ,EAAiC;AAC/B,MAAA,cAAc,CAAC,YAAf,GAA8B,YAA9B;AACD;;AACD,WAAO,cAAP;AACD;;AAhGD,EAAA,OAAA,CAAA,aAAA,GAAA,aAAA;AAkGA,MAAM,eAAe,GAAG,IAAI,6BAAA,CAAA,wBAAJ,EAAxB;AAEA;;AAEG;;AACH,WAAgB,iBAAhB,CACI,mBADJ,EAC2E;AAAvE,QAAA,mBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,mBAAA,GAA2C,sBAAA,CAAA,4BAA3C;AAAuE;;AACzE,WAAO,IAAI,gBAAA,CAAA,aAAJ,CACH,IAAI,QAAA,CAAA,SAAJ,CAAc,IAAI,OAAA,CAAA,KAAJ,EAAd,CADG,EACyB,mBADzB,EAC8C,eAD9C,EAC+D,IAD/D,EACqE,EADrE,CAAP;AAED;;AAJD,EAAA,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAMA,WAAgB,qBAAhB,CAAsC,OAAtC,EAAqE,WAArE,EAA0F;AACxF,YAAQ,OAAR;AACE,WAAK,IAAI,CAAC,eAAL,CAAqB,IAA1B;AACE,eAAO,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,YAAhB,CAAP;;AACF,WAAK,IAAI,CAAC,eAAL,CAAqB,MAA1B;AACE,eAAO,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,cAAhB,CAAP;;AACF,WAAK,IAAI,CAAC,eAAL,CAAqB,KAA1B;AACE;AACA;AACA;AACA,eAAO,WAAW,GAAG,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,aAAhB,CAAH,GAAoC,IAAtD;;AACF,WAAK,IAAI,CAAC,eAAL,CAAqB,GAA1B;AACE,eAAO,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,WAAhB,CAAP;;AACF,WAAK,IAAI,CAAC,eAAL,CAAqB,YAA1B;AACE,eAAO,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,mBAAhB,CAAP;;AACF;AACE,eAAO,IAAP;AAfJ;AAiBD;;AAlBD,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AAoBA,WAAS,qBAAT,CAA+B,OAA/B,EAAgD,IAAhD,EAAqE;AACnE,QAAM,KAAK,GAAG,MAAA,CAAA,SAAA,CAAU,IAAI,CAAC,KAAf,CAAd;;AACA,QAAI,qBAAA,CAAA,kBAAA,CAAmB,OAAnB,EAA4B,IAAI,CAAC,IAAjC,CAAJ,EAA4C;AAC1C,cAAQ,eAAe,CAAC,eAAhB,CAAgC,OAAhC,EAAyC,IAAI,CAAC,IAA9C;AAAoD;AAAkB,UAAtE,CAAR;AACE,aAAK,IAAI,CAAC,eAAL,CAAqB,IAA1B;AACE,iBAAO,CAAC,CAAC,cAAF,CACH,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,iBAAhB,CADG,EAEH,IAAI,CAAC,CAAC,eAAN,CAAsB,CAAC,IAAI,CAAC,CAAC,sBAAN,CAA6B,IAAI,CAAC,KAAlC,CAAD,CAAtB,EAAkE,EAAlE,CAFG,EAEoE,SAFpE,EAGH,IAAI,CAAC,SAHF,CAAP;AAIF;;AACA,aAAK,IAAI,CAAC,eAAL,CAAqB,YAA1B;AACE,iBAAO,CAAC,CAAC,cAAF,CACH,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,wBAAhB,CADG,EAEH,IAAI,CAAC,CAAC,eAAN,CAAsB,CAAC,IAAI,CAAC,CAAC,sBAAN,CAA6B,IAAI,CAAC,KAAlC,CAAD,CAAtB,EAAkE,EAAlE,CAFG,EAEoE,SAFpE,EAGH,IAAI,CAAC,SAHF,CAAP;;AAIF;AACE,iBAAO,KAAP;AAbJ;AAeD,KAhBD,MAgBO;AACL,aAAO,KAAP;AACD;AACF;;AAED,WAAS,uBAAT,CAAiC,QAAjC,EAAmD;AACjD,WAAO,QAAQ,CAAC,MAAT,KAAoB,CAApB,IAAyB,QAAQ,CAAC,CAAD,CAAR,YAAuB,CAAC,CAAC,OAAzD;AACD;;AAED,WAAS,UAAT,CAAoB,IAApB,EAAgC;AAC9B,WAAO,IAAI,YAAY,CAAC,CAAC,IAAlB,IAA0B,IAAI,YAAY,CAAC,CAAC,SAA5C,IAAyD,IAAI,YAAY,CAAC,CAAC,GAAlF;AACD;;AAED,WAAS,mBAAT,CAA6B,QAA7B,EAA+C;AAC7C,WAAO,QAAQ,CAAC,KAAT,CAAe,UAAf,CAAP;AACD;AASD;;;AACA,MAAM,oBAAoB,GAAG,mBAA7B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBG;;AACH,WAAgB,uBAAhB,CACI,OADJ,EAC2B,QAD3B,EACoD,UADpD,EAEI,MAFJ,EAGI,WAHJ,EAGsD;AADlD,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAA,EAAA;AAA2C;;AAE7C,QAAM,UAAU,GAAkB,CAChC,MAAA,CAAA,mBAAA,CAAoB,QAApB,CADgC,EAEhC,CAAC,CAAC,MAAF,CACI,sBAAsB,EAD1B,EAEI,eAAA,CAAA,4BAAA,CACI,QADJ,EACc,OADd,EACuB,UADvB,EAEI,MAAA,CAAA,0BAAA,CAA2B,MAA3B;AAAmC;AAAmB,QAAtD,CAFJ,CAFJ,EAKI,gBAAA,CAAA,wBAAA,CACI,QADJ,EACc,OADd,EACuB,MAAA,CAAA,0BAAA,CAA2B,MAA3B;AAAmC;AAAmB,SAAtD,CADvB,CALJ,CAFgC,CAAlC;;AAWA,QAAI,WAAJ,EAAiB;AACf,MAAA,UAAU,CAAC,IAAX,CAAgB,IAAI,CAAC,CAAC,mBAAN,CAA0B,QAAQ,CAAC,GAAT,CAAa,WAAW,CAAC,QAAD,CAAxB,CAA1B,CAAhB;AACD;;AAED,WAAO,UAAP;AACD;;AApBD,EAAA,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAsBA;;;;;;;AAOG;;AACH,WAAS,sBAAT,GAA+B;AAC7B,WAAO,CAAC,CAAC,UAAF,CAAa,CAAC,CAAC,QAAF,CAAW,oBAAX,CAAb,EACF,YADE,CACW,CAAC,CAAC,OAAF,CAAU,WAAV,EAAuB,CAAC,CAAC,WAAzB,CADX,EAEF,GAFE,CAEE,CAAC,CAAC,QAAF,CAAW,oBAAX,CAFF,CAAP;AAGD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {flatten, sanitizeIdentifier} from '../../compile_metadata';\nimport {BindingForm, BuiltinFunctionCall, convertActionBinding, convertPropertyBinding, convertUpdateArguments, LocalResolver} from '../../compiler_util/expression_converter';\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport {AST, AstMemoryEfficientTransformer, BindingPipe, BindingType, FunctionCall, ImplicitReceiver, Interpolation, LiteralArray, LiteralMap, LiteralPrimitive, ParsedEventType, PropertyRead, ThisReceiver} from '../../expression_parser/ast';\nimport {Lexer} from '../../expression_parser/lexer';\nimport {IvyParser} from '../../expression_parser/parser';\nimport * as i18n from '../../i18n/i18n_ast';\nimport * as html from '../../ml_parser/ast';\nimport {HtmlParser} from '../../ml_parser/html_parser';\nimport {WhitespaceVisitor} from '../../ml_parser/html_whitespaces';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../ml_parser/interpolation_config';\nimport {LexerRange} from '../../ml_parser/lexer';\nimport {isNgContainer as checkIsNgContainer, splitNsName} from '../../ml_parser/tags';\nimport {mapLiteral} from '../../output/map_util';\nimport * as o from '../../output/output_ast';\nimport {ParseError, ParseSourceSpan} from '../../parse_util';\nimport {DomElementSchemaRegistry} from '../../schema/dom_element_schema_registry';\nimport {isTrustedTypesSink} from '../../schema/trusted_types_sinks';\nimport {CssSelector, SelectorMatcher} from '../../selector';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport {error, partitionArray} from '../../util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {htmlAstToRender3Ast} from '../r3_template_transform';\nimport {prepareSyntheticListenerFunctionName, prepareSyntheticListenerName, prepareSyntheticPropertyName} from '../util';\n\nimport {I18nContext} from './i18n/context';\nimport {createGoogleGetMsgStatements} from './i18n/get_msg_utils';\nimport {createLocalizeStatements} from './i18n/localize_utils';\nimport {I18nMetaVisitor} from './i18n/meta';\nimport {assembleBoundTextPlaceholders, assembleI18nBoundString, declareI18nVariable, getTranslationConstPrefix, hasI18nMeta, I18N_ICU_MAPPING_PREFIX, i18nFormatPlaceholderNames, icuFromI18nMessage, isI18nRootNode, isSingleI18nIcu, placeholdersToParams, TRANSLATION_VAR_PREFIX, wrapI18nPlaceholder} from './i18n/util';\nimport {StylingBuilder, StylingInstruction} from './styling_builder';\nimport {asLiteral, chainedInstruction, CONTEXT_NAME, getAttrsForDirectiveMatching, getInterpolationArgsLength, IMPLICIT_REFERENCE, invalid, NON_BINDABLE_ATTR, REFERENCE_PREFIX, RENDER_FLAGS, trimTrailingNulls, unsupported} from './util';\n\n\n\n// Selector attribute name of `<ng-content>`\nconst NG_CONTENT_SELECT_ATTR = 'select';\n\n// Attribute name of `ngProjectAs`.\nconst NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\n\n// Global symbols available only inside event bindings.\nconst EVENT_BINDING_SCOPE_GLOBALS = new Set<string>(['$event']);\n\n// List of supported global targets for event listeners\nconst GLOBAL_TARGET_RESOLVERS = new Map<string, o.ExternalReference>(\n    [['window', R3.resolveWindow], ['document', R3.resolveDocument], ['body', R3.resolveBody]]);\n\nexport const LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\n\n//  if (rf & flags) { .. }\nexport function renderFlagCheckIfStmt(\n    flags: core.RenderFlags, statements: o.Statement[]): o.IfStmt {\n  return o.ifStmt(o.variable(RENDER_FLAGS).bitwiseAnd(o.literal(flags), null, false), statements);\n}\n\nexport function prepareEventListenerParameters(\n    eventAst: t.BoundEvent, handlerName: string|null = null,\n    scope: BindingScope|null = null): o.Expression[] {\n  const {type, name, target, phase, handler} = eventAst;\n  if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n    throw new Error(`Unexpected global target '${target}' defined for '${name}' event.\n        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);\n  }\n\n  const eventArgumentName = '$event';\n  const implicitReceiverAccesses = new Set<string>();\n  const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\n      o.variable(CONTEXT_NAME) :\n      scope.getOrCreateSharedContextVar(0);\n  const bindingExpr = convertActionBinding(\n      scope, implicitReceiverExpr, handler, 'b', () => error('Unexpected interpolation'),\n      eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);\n  const statements = [];\n  if (scope) {\n    statements.push(...scope.restoreViewStatement());\n    statements.push(...scope.variableDeclarations());\n  }\n  statements.push(...bindingExpr.render3Stmts);\n\n  const eventName: string =\n      type === ParsedEventType.Animation ? prepareSyntheticListenerName(name, phase!) : name;\n  const fnName = handlerName && sanitizeIdentifier(handlerName);\n  const fnArgs: o.FnParam[] = [];\n\n  if (implicitReceiverAccesses.has(eventArgumentName)) {\n    fnArgs.push(new o.FnParam(eventArgumentName, o.DYNAMIC_TYPE));\n  }\n\n  const handlerFn = o.fn(fnArgs, statements, o.INFERRED_TYPE, null, fnName);\n  const params: o.Expression[] = [o.literal(eventName), handlerFn];\n  if (target) {\n    params.push(\n        o.literal(false),  // `useCapture` flag, defaults to `false`\n        o.importExpr(GLOBAL_TARGET_RESOLVERS.get(target)!));\n  }\n  return params;\n}\n\n// Collects information needed to generate `consts` field of the ComponentDef.\nexport interface ComponentDefConsts {\n  /**\n   * When a constant requires some pre-processing (e.g. i18n translation block that includes\n   * goog.getMsg and $localize calls), the `prepareStatements` section contains corresponding\n   * statements.\n   */\n  prepareStatements: o.Statement[];\n\n  /**\n   * Actual expressions that represent constants.\n   */\n  constExpressions: o.Expression[];\n\n  /**\n   * Cache to avoid generating duplicated i18n translation blocks.\n   */\n  i18nVarRefsCache: Map<i18n.I18nMeta, o.ReadVarExpr>;\n}\n\nfunction createComponentDefConsts(): ComponentDefConsts {\n  return {\n    prepareStatements: [],\n    constExpressions: [],\n    i18nVarRefsCache: new Map(),\n  };\n}\n\nexport class TemplateDefinitionBuilder implements t.Visitor<void>, LocalResolver {\n  private _dataIndex = 0;\n  private _bindingContext = 0;\n  private _prefixCode: o.Statement[] = [];\n  /**\n   * List of callbacks to generate creation mode instructions. We store them here as we process\n   * the template so bindings in listeners are resolved only once all nodes have been visited.\n   * This ensures all local refs and context variables are available for matching.\n   */\n  private _creationCodeFns: (() => o.Statement)[] = [];\n  /**\n   * List of callbacks to generate update mode instructions. We store them here as we process\n   * the template so bindings are resolved only once all nodes have been visited. This ensures\n   * all local refs and context variables are available for matching.\n   */\n  private _updateCodeFns: (() => o.Statement)[] = [];\n\n  /** Index of the currently-selected node. */\n  private _currentIndex: number = 0;\n\n  /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n  private _tempVariables: o.Statement[] = [];\n  /**\n   * List of callbacks to build nested templates. Nested templates must not be visited until\n   * after the parent template has finished visiting all of its nodes. This ensures that all\n   * local ref bindings in nested templates are able to find local ref values if the refs\n   * are defined after the template declaration.\n   */\n  private _nestedTemplateFns: (() => void)[] = [];\n  /**\n   * This scope contains local variables declared in the update mode block of the template.\n   * (e.g. refs and context vars in bindings)\n   */\n  private _bindingScope: BindingScope;\n  private _valueConverter: ValueConverter;\n  private _unsupported = unsupported;\n\n  // i18n context local to this template\n  private i18n: I18nContext|null = null;\n\n  // Number of slots to reserve for pureFunctions\n  private _pureFunctionSlots = 0;\n\n  // Number of binding slots\n  private _bindingSlots = 0;\n\n  private fileBasedI18nSuffix: string;\n\n  // Projection slots found in the template. Projection slots can distribute projected\n  // nodes based on a selector, or can just use the wildcard selector to match\n  // all nodes which aren't matching any selector.\n  private _ngContentReservedSlots: (string|'*')[] = [];\n\n  // Number of non-default selectors found in all parent templates of this template. We need to\n  // track it to properly adjust projection slot index in the `projection` instruction.\n  private _ngContentSelectorsOffset = 0;\n\n  // Expression that should be used as implicit receiver when converting template\n  // expressions to output AST.\n  private _implicitReceiverExpr: o.ReadVarExpr|null = null;\n\n  constructor(\n      private constantPool: ConstantPool, parentBindingScope: BindingScope, private level = 0,\n      private contextName: string|null, private i18nContext: I18nContext|null,\n      private templateIndex: number|null, private templateName: string|null,\n      private directiveMatcher: SelectorMatcher|null, private directives: Set<o.Expression>,\n      private pipeTypeByName: Map<string, o.Expression>, private pipes: Set<o.Expression>,\n      private _namespace: o.ExternalReference, relativeContextFilePath: string,\n      private i18nUseExternalIds: boolean,\n      private _constants: ComponentDefConsts = createComponentDefConsts()) {\n    this._bindingScope = parentBindingScope.nestedScope(level);\n\n    // Turn the relative context file path into an identifier by replacing non-alphanumeric\n    // characters with underscores.\n    this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n\n    this._valueConverter = new ValueConverter(\n        constantPool, () => this.allocateDataSlot(),\n        (numSlots: number) => this.allocatePureFunctionSlots(numSlots),\n        (name, localName, slot, value: o.Expression) => {\n          const pipeType = pipeTypeByName.get(name);\n          if (pipeType) {\n            this.pipes.add(pipeType);\n          }\n          this._bindingScope.set(this.level, localName, value);\n          this.creationInstruction(null, R3.pipe, [o.literal(slot), o.literal(name)]);\n        });\n  }\n\n  buildTemplateFunction(\n      nodes: t.Node[], variables: t.Variable[], ngContentSelectorsOffset: number = 0,\n      i18n?: i18n.I18nMeta): o.FunctionExpr {\n    this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n\n    if (this._namespace !== R3.namespaceHTML) {\n      this.creationInstruction(null, this._namespace);\n    }\n\n    // Create variable bindings\n    variables.forEach(v => this.registerContextVariables(v));\n\n    // Initiate i18n context in case:\n    // - this template has parent i18n context\n    // - or the template has i18n meta associated with it,\n    //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n    const initI18nContext = this.i18nContext ||\n        (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\n         !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\n    const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n    if (initI18nContext) {\n      this.i18nStart(null, i18n!, selfClosingI18nInstruction);\n    }\n\n    // This is the initial pass through the nodes of this template. In this pass, we\n    // queue all creation mode and update mode instructions for generation in the second\n    // pass. It's necessary to separate the passes to ensure local refs are defined before\n    // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n    t.visitAll(this, nodes);\n\n    // Add total binding count to pure function count so pure function instructions are\n    // generated with the correct slot offset when update instructions are processed.\n    this._pureFunctionSlots += this._bindingSlots;\n\n    // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n    // `pipeBind` update instructions), so we have to update the slot offsets manually\n    // to account for bindings.\n    this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\n\n    // Nested templates must be processed before creation instructions so template()\n    // instructions can be generated with the correct internal const count.\n    this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());\n\n    // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n    // The `projectionDef` instruction is only emitted for the component template and\n    // is skipped for nested templates (<ng-template> tags).\n    if (this.level === 0 && this._ngContentReservedSlots.length) {\n      const parameters: o.Expression[] = [];\n\n      // By default the `projectionDef` instructions creates one slot for the wildcard\n      // selector if no parameters are passed. Therefore we only want to allocate a new\n      // array for the projection slots if the default projection slot is not sufficient.\n      if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n        const r3ReservedSlots = this._ngContentReservedSlots.map(\n            s => s !== '*' ? core.parseSelectorToR3Selector(s) : s);\n        parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n      }\n\n      // Since we accumulate ngContent selectors while processing template elements,\n      // we *prepend* `projectionDef` to creation instructions block, to put it before\n      // any `projection` instructions\n      this.creationInstruction(null, R3.projectionDef, parameters, /* prepend */ true);\n    }\n\n    if (initI18nContext) {\n      this.i18nEnd(null, selfClosingI18nInstruction);\n    }\n\n    // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n    const creationStatements = this._creationCodeFns.map((fn: () => o.Statement) => fn());\n\n    // Generate all the update mode instructions (e.g. resolve property or text bindings)\n    const updateStatements = this._updateCodeFns.map((fn: () => o.Statement) => fn());\n\n    //  Variable declaration must occur after binding resolution so we can generate context\n    //  instructions that build on each other.\n    // e.g. const b = nextContext().$implicit(); const b = nextContext();\n    const creationVariables = this._bindingScope.viewSnapshotStatements();\n    const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n\n    const creationBlock = creationStatements.length > 0 ?\n        [renderFlagCheckIfStmt(\n            core.RenderFlags.Create, creationVariables.concat(creationStatements))] :\n        [];\n\n    const updateBlock = updateStatements.length > 0 ?\n        [renderFlagCheckIfStmt(core.RenderFlags.Update, updateVariables.concat(updateStatements))] :\n        [];\n\n    return o.fn(\n        // i.e. (rf: RenderFlags, ctx: any)\n        [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)],\n        [\n          // Temporary variable declarations for query refresh (i.e. let _t: any;)\n          ...this._prefixCode,\n          // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })\n          ...creationBlock,\n          // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})\n          ...updateBlock,\n        ],\n        o.INFERRED_TYPE, null, this.templateName);\n  }\n\n  // LocalResolver\n  getLocal(name: string): o.Expression|null {\n    return this._bindingScope.get(name);\n  }\n\n  // LocalResolver\n  notifyImplicitReceiverUse(): void {\n    this._bindingScope.notifyImplicitReceiverUse();\n  }\n\n  private i18nTranslate(\n      message: i18n.Message, params: {[name: string]: o.Expression} = {}, ref?: o.ReadVarExpr,\n      transformFn?: (raw: o.ReadVarExpr) => o.Expression): o.ReadVarExpr {\n    const _ref = ref || this.i18nGenerateMainBlockVar();\n    // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n    // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n    const closureVar = this.i18nGenerateClosureVar(message.id);\n    const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n    this._constants.prepareStatements.push(...statements);\n    return _ref;\n  }\n\n  private registerContextVariables(variable: t.Variable) {\n    const scopedName = this._bindingScope.freshReferenceName();\n    const retrievalLevel = this.level;\n    const lhs = o.variable(variable.name + scopedName);\n    this._bindingScope.set(\n        retrievalLevel, variable.name, lhs, DeclarationPriority.CONTEXT,\n        (scope: BindingScope, relativeLevel: number) => {\n          let rhs: o.Expression;\n          if (scope.bindingLevel === retrievalLevel) {\n            // e.g. ctx\n            rhs = o.variable(CONTEXT_NAME);\n          } else {\n            const sharedCtxVar = scope.getSharedContextName(retrievalLevel);\n            // e.g. ctx_r0   OR  x(2);\n            rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n          }\n          // e.g. const $item$ = x(2).$implicit;\n          return [lhs.set(rhs.prop(variable.value || IMPLICIT_REFERENCE)).toConstDecl()];\n        });\n  }\n\n  private i18nAppendBindings(expressions: AST[]) {\n    if (expressions.length > 0) {\n      expressions.forEach(expression => this.i18n!.appendBinding(expression));\n    }\n  }\n\n  private i18nBindProps(props: {[key: string]: t.Text|t.BoundText}): {[key: string]: o.Expression} {\n    const bound: {[key: string]: o.Expression} = {};\n    Object.keys(props).forEach(key => {\n      const prop = props[key];\n      if (prop instanceof t.Text) {\n        bound[key] = o.literal(prop.value);\n      } else {\n        const value = prop.value.visit(this._valueConverter);\n        this.allocateBindingSlots(value);\n        if (value instanceof Interpolation) {\n          const {strings, expressions} = value;\n          const {id, bindings} = this.i18n!;\n          const label = assembleI18nBoundString(strings, bindings.size, id);\n          this.i18nAppendBindings(expressions);\n          bound[key] = o.literal(label);\n        }\n      }\n    });\n    return bound;\n  }\n\n  // Generates top level vars for i18n blocks (i.e. `i18n_N`).\n  private i18nGenerateMainBlockVar(): o.ReadVarExpr {\n    return o.variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));\n  }\n\n  // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n  private i18nGenerateClosureVar(messageId: string): o.ReadVarExpr {\n    let name: string;\n    const suffix = this.fileBasedI18nSuffix.toUpperCase();\n    if (this.i18nUseExternalIds) {\n      const prefix = getTranslationConstPrefix(`EXTERNAL_`);\n      const uniqueSuffix = this.constantPool.uniqueName(suffix);\n      name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\n    } else {\n      const prefix = getTranslationConstPrefix(suffix);\n      name = this.constantPool.uniqueName(prefix);\n    }\n    return o.variable(name);\n  }\n\n  private i18nUpdateRef(context: I18nContext): void {\n    const {icus, meta, isRoot, isResolved, isEmitted} = context;\n    if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n      context.isEmitted = true;\n      const placeholders = context.getSerializedPlaceholders();\n      let icuMapping: {[name: string]: o.Expression} = {};\n      let params: {[name: string]: o.Expression} =\n          placeholders.size ? placeholdersToParams(placeholders) : {};\n      if (icus.size) {\n        icus.forEach((refs: o.Expression[], key: string) => {\n          if (refs.length === 1) {\n            // if we have one ICU defined for a given\n            // placeholder - just output its reference\n            params[key] = refs[0];\n          } else {\n            // ... otherwise we need to activate post-processing\n            // to replace ICU placeholders with proper values\n            const placeholder: string = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);\n            params[key] = o.literal(placeholder);\n            icuMapping[key] = o.literalArr(refs);\n          }\n        });\n      }\n\n      // translation requires post processing in 2 cases:\n      // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])\n      // - if we have multiple ICUs that refer to the same placeholder name\n      const needsPostprocessing =\n          Array.from(placeholders.values()).some((value: string[]) => value.length > 1) ||\n          Object.keys(icuMapping).length;\n\n      let transformFn;\n      if (needsPostprocessing) {\n        transformFn = (raw: o.ReadVarExpr) => {\n          const args: o.Expression[] = [raw];\n          if (Object.keys(icuMapping).length) {\n            args.push(mapLiteral(icuMapping, true));\n          }\n          return instruction(null, R3.i18nPostprocess, args);\n        };\n      }\n      this.i18nTranslate(meta as i18n.Message, params, context.ref, transformFn);\n    }\n  }\n\n  private i18nStart(span: ParseSourceSpan|null = null, meta: i18n.I18nMeta, selfClosing?: boolean):\n      void {\n    const index = this.allocateDataSlot();\n    this.i18n = this.i18nContext ?\n        this.i18nContext.forkChildContext(index, this.templateIndex!, meta) :\n        new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);\n\n    // generate i18nStart instruction\n    const {id, ref} = this.i18n;\n    const params: o.Expression[] = [o.literal(index), this.addToConsts(ref)];\n    if (id > 0) {\n      // do not push 3rd argument (sub-block id)\n      // into i18nStart call for top level i18n context\n      params.push(o.literal(id));\n    }\n    this.creationInstruction(span, selfClosing ? R3.i18n : R3.i18nStart, params);\n  }\n\n  private i18nEnd(span: ParseSourceSpan|null = null, selfClosing?: boolean): void {\n    if (!this.i18n) {\n      throw new Error('i18nEnd is executed with no i18n context present');\n    }\n\n    if (this.i18nContext) {\n      this.i18nContext.reconcileChildContext(this.i18n);\n      this.i18nUpdateRef(this.i18nContext);\n    } else {\n      this.i18nUpdateRef(this.i18n);\n    }\n\n    // setup accumulated bindings\n    const {index, bindings} = this.i18n;\n    if (bindings.size) {\n      const chainBindings: ChainableBindingInstruction[] = [];\n      bindings.forEach(binding => {\n        chainBindings.push({sourceSpan: span, value: () => this.convertPropertyBinding(binding)});\n      });\n      // for i18n block, advance to the most recent element index (by taking the current number of\n      // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n      // necessary lifecycle hooks of components/directives are properly flushed.\n      this.updateInstructionChainWithAdvance(this.getConstCount() - 1, R3.i18nExp, chainBindings);\n      this.updateInstruction(span, R3.i18nApply, [o.literal(index)]);\n    }\n    if (!selfClosing) {\n      this.creationInstruction(span, R3.i18nEnd);\n    }\n    this.i18n = null;  // reset local i18n context\n  }\n\n  private i18nAttributesInstruction(\n      nodeIndex: number, attrs: t.BoundAttribute[], sourceSpan: ParseSourceSpan): void {\n    let hasBindings: boolean = false;\n    const i18nAttrArgs: o.Expression[] = [];\n    const bindings: ChainableBindingInstruction[] = [];\n    attrs.forEach(attr => {\n      const message = attr.i18n! as i18n.Message;\n      const converted = attr.value.visit(this._valueConverter);\n      this.allocateBindingSlots(converted);\n      if (converted instanceof Interpolation) {\n        const placeholders = assembleBoundTextPlaceholders(message);\n        const params = placeholdersToParams(placeholders);\n        i18nAttrArgs.push(o.literal(attr.name), this.i18nTranslate(message, params));\n        converted.expressions.forEach(expression => {\n          hasBindings = true;\n          bindings.push({\n            sourceSpan,\n            value: () => this.convertPropertyBinding(expression),\n          });\n        });\n      }\n    });\n    if (bindings.length > 0) {\n      this.updateInstructionChainWithAdvance(nodeIndex, R3.i18nExp, bindings);\n    }\n    if (i18nAttrArgs.length > 0) {\n      const index: o.Expression = o.literal(this.allocateDataSlot());\n      const constIndex = this.addToConsts(o.literalArr(i18nAttrArgs));\n      this.creationInstruction(sourceSpan, R3.i18nAttributes, [index, constIndex]);\n      if (hasBindings) {\n        this.updateInstruction(sourceSpan, R3.i18nApply, [index]);\n      }\n    }\n  }\n\n  private getNamespaceInstruction(namespaceKey: string|null) {\n    switch (namespaceKey) {\n      case 'math':\n        return R3.namespaceMathML;\n      case 'svg':\n        return R3.namespaceSVG;\n      default:\n        return R3.namespaceHTML;\n    }\n  }\n\n  private addNamespaceInstruction(nsInstruction: o.ExternalReference, element: t.Element) {\n    this._namespace = nsInstruction;\n    this.creationInstruction(element.startSourceSpan, nsInstruction);\n  }\n\n  /**\n   * Adds an update instruction for an interpolated property or attribute, such as\n   * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n   */\n  private interpolatedUpdateInstruction(\n      instruction: o.ExternalReference, elementIndex: number, attrName: string,\n      input: t.BoundAttribute, value: any, params: any[]) {\n    this.updateInstructionWithAdvance(\n        elementIndex, input.sourceSpan, instruction,\n        () => [o.literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);\n  }\n\n  visitContent(ngContent: t.Content) {\n    const slot = this.allocateDataSlot();\n    const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n    const parameters: o.Expression[] = [o.literal(slot)];\n\n    this._ngContentReservedSlots.push(ngContent.selector);\n\n    const nonContentSelectAttributes =\n        ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR);\n    const attributes =\n        this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\n\n    if (attributes.length > 0) {\n      parameters.push(o.literal(projectionSlotIdx), o.literalArr(attributes));\n    } else if (projectionSlotIdx !== 0) {\n      parameters.push(o.literal(projectionSlotIdx));\n    }\n\n    this.creationInstruction(ngContent.sourceSpan, R3.projection, parameters);\n    if (this.i18n) {\n      this.i18n.appendProjection(ngContent.i18n!, slot);\n    }\n  }\n\n  visitElement(element: t.Element) {\n    const elementIndex = this.allocateDataSlot();\n    const stylingBuilder = new StylingBuilder(null);\n\n    let isNonBindableMode: boolean = false;\n    const isI18nRootElement: boolean =\n        isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n\n    const outputAttrs: t.TextAttribute[] = [];\n    const [namespaceKey, elementName] = splitNsName(element.name);\n    const isNgContainer = checkIsNgContainer(element.name);\n\n    // Handle styling, i18n, ngNonBindable attributes\n    for (const attr of element.attributes) {\n      const {name, value} = attr;\n      if (name === NON_BINDABLE_ATTR) {\n        isNonBindableMode = true;\n      } else if (name === 'style') {\n        stylingBuilder.registerStyleAttr(value);\n      } else if (name === 'class') {\n        stylingBuilder.registerClassAttr(value);\n      } else {\n        outputAttrs.push(attr);\n      }\n    }\n\n    // Match directives on non i18n attributes\n    this.matchDirectives(element.name, element);\n\n    // Regular element or ng-container creation mode\n    const parameters: o.Expression[] = [o.literal(elementIndex)];\n    if (!isNgContainer) {\n      parameters.push(o.literal(elementName));\n    }\n\n    // Add the attributes\n    const allOtherInputs: t.BoundAttribute[] = [];\n    const boundI18nAttrs: t.BoundAttribute[] = [];\n\n    element.inputs.forEach(input => {\n      const stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n      if (!stylingInputWasSet) {\n        if (input.type === BindingType.Property && input.i18n) {\n          boundI18nAttrs.push(input);\n        } else {\n          allOtherInputs.push(input);\n        }\n      }\n    });\n\n    // add attributes for directive and projection matching purposes\n    const attributes: o.Expression[] = this.getAttributeExpressions(\n        element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [],\n        boundI18nAttrs);\n    parameters.push(this.addAttrsToConsts(attributes));\n\n    // local refs (ex.: <div #foo #bar=\"baz\">)\n    const refs = this.prepareRefsArray(element.references);\n    parameters.push(this.addToConsts(refs));\n\n    const wasInNamespace = this._namespace;\n    const currentNamespace = this.getNamespaceInstruction(namespaceKey);\n\n    // If the namespace is changing now, include an instruction to change it\n    // during element creation.\n    if (currentNamespace !== wasInNamespace) {\n      this.addNamespaceInstruction(currentNamespace, element);\n    }\n\n    if (this.i18n) {\n      this.i18n.appendElement(element.i18n!, elementIndex);\n    }\n\n    // Note that we do not append text node instructions and ICUs inside i18n section,\n    // so we exclude them while calculating whether current element has children\n    const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\n                                                            element.children.length > 0;\n\n    const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&\n        element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\n    const createSelfClosingI18nInstruction =\n        !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n\n    if (createSelfClosingInstruction) {\n      this.creationInstruction(\n          element.sourceSpan, isNgContainer ? R3.elementContainer : R3.element,\n          trimTrailingNulls(parameters));\n    } else {\n      this.creationInstruction(\n          element.startSourceSpan, isNgContainer ? R3.elementContainerStart : R3.elementStart,\n          trimTrailingNulls(parameters));\n\n      if (isNonBindableMode) {\n        this.creationInstruction(element.startSourceSpan, R3.disableBindings);\n      }\n\n      if (boundI18nAttrs.length > 0) {\n        this.i18nAttributesInstruction(\n            elementIndex, boundI18nAttrs, element.startSourceSpan ?? element.sourceSpan);\n      }\n\n      // Generate Listeners (outputs)\n      if (element.outputs.length > 0) {\n        const listeners = element.outputs.map(\n            (outputAst: t.BoundEvent) => ({\n              sourceSpan: outputAst.sourceSpan,\n              params: this.prepareListenerParameter(element.name, outputAst, elementIndex)\n            }));\n        this.creationInstructionChain(R3.listener, listeners);\n      }\n\n      // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n      // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n      if (isI18nRootElement) {\n        this.i18nStart(element.startSourceSpan, element.i18n!, createSelfClosingI18nInstruction);\n      }\n    }\n\n    // the code here will collect all update-level styling instructions and add them to the\n    // update block of the template function AOT code. Instructions like `styleProp`,\n    // `styleMap`, `classMap`, `classProp`\n    // are all generated and assigned in the code below.\n    const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n    const limit = stylingInstructions.length - 1;\n    for (let i = 0; i <= limit; i++) {\n      const instruction = stylingInstructions[i];\n      this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);\n    }\n\n    // the reason why `undefined` is used is because the renderer understands this as a\n    // special value to symbolize that there is no RHS to this binding\n    // TODO (matsko): revisit this once FW-959 is approached\n    const emptyValueBindInstruction = o.literal(undefined);\n    const propertyBindings: ChainableBindingInstruction[] = [];\n    const attributeBindings: ChainableBindingInstruction[] = [];\n\n    // Generate element input bindings\n    allOtherInputs.forEach(input => {\n      const inputType = input.type;\n      if (inputType === BindingType.Animation) {\n        const value = input.value.visit(this._valueConverter);\n        // animation bindings can be presented in the following formats:\n        // 1. [@binding]=\"fooExp\"\n        // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n        // 3. [@binding]\n        // 4. @binding\n        // All formats will be valid for when a synthetic binding is created.\n        // The reasoning for this is because the renderer should get each\n        // synthetic binding value in the order of the array that they are\n        // defined in...\n        const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;\n        this.allocateBindingSlots(value);\n\n        propertyBindings.push({\n          name: prepareSyntheticPropertyName(input.name),\n          sourceSpan: input.sourceSpan,\n          value: () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction\n        });\n      } else {\n        // we must skip attributes with associated i18n context, since these attributes are handled\n        // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n        if (input.i18n) return;\n\n        const value = input.value.visit(this._valueConverter);\n        if (value !== undefined) {\n          const params: any[] = [];\n          const [attrNamespace, attrName] = splitNsName(input.name);\n          const isAttributeBinding = inputType === BindingType.Attribute;\n          const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n          if (sanitizationRef) params.push(sanitizationRef);\n          if (attrNamespace) {\n            const namespaceLiteral = o.literal(attrNamespace);\n\n            if (sanitizationRef) {\n              params.push(namespaceLiteral);\n            } else {\n              // If there wasn't a sanitization ref, we need to add\n              // an extra param so that we can pass in the namespace.\n              params.push(o.literal(null), namespaceLiteral);\n            }\n          }\n          this.allocateBindingSlots(value);\n\n          if (inputType === BindingType.Property) {\n            if (value instanceof Interpolation) {\n              // prop=\"{{value}}\" and friends\n              this.interpolatedUpdateInstruction(\n                  getPropertyInterpolationExpression(value), elementIndex, attrName, input, value,\n                  params);\n            } else {\n              // [prop]=\"value\"\n              // Collect all the properties so that we can chain into a single function at the end.\n              propertyBindings.push({\n                name: attrName,\n                sourceSpan: input.sourceSpan,\n                value: () => this.convertPropertyBinding(value),\n                params\n              });\n            }\n          } else if (inputType === BindingType.Attribute) {\n            if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {\n              // attr.name=\"text{{value}}\" and friends\n              this.interpolatedUpdateInstruction(\n                  getAttributeInterpolationExpression(value), elementIndex, attrName, input, value,\n                  params);\n            } else {\n              const boundValue = value instanceof Interpolation ? value.expressions[0] : value;\n              // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n              // Collect the attribute bindings so that they can be chained at the end.\n              attributeBindings.push({\n                name: attrName,\n                sourceSpan: input.sourceSpan,\n                value: () => this.convertPropertyBinding(boundValue),\n                params\n              });\n            }\n          } else {\n            // class prop\n            this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, R3.classProp, () => {\n              return [\n                o.literal(elementIndex), o.literal(attrName), this.convertPropertyBinding(value),\n                ...params\n              ];\n            });\n          }\n        }\n      }\n    });\n\n    if (propertyBindings.length > 0) {\n      this.updateInstructionChainWithAdvance(elementIndex, R3.property, propertyBindings);\n    }\n\n    if (attributeBindings.length > 0) {\n      this.updateInstructionChainWithAdvance(elementIndex, R3.attribute, attributeBindings);\n    }\n\n    // Traverse element child nodes\n    t.visitAll(this, element.children);\n\n    if (!isI18nRootElement && this.i18n) {\n      this.i18n.appendElement(element.i18n!, elementIndex, true);\n    }\n\n    if (!createSelfClosingInstruction) {\n      // Finish element construction mode.\n      const span = element.endSourceSpan ?? element.sourceSpan;\n      if (isI18nRootElement) {\n        this.i18nEnd(span, createSelfClosingI18nInstruction);\n      }\n      if (isNonBindableMode) {\n        this.creationInstruction(span, R3.enableBindings);\n      }\n      this.creationInstruction(span, isNgContainer ? R3.elementContainerEnd : R3.elementEnd);\n    }\n  }\n\n\n  visitTemplate(template: t.Template) {\n    const NG_TEMPLATE_TAG_NAME = 'ng-template';\n    const templateIndex = this.allocateDataSlot();\n\n    if (this.i18n) {\n      this.i18n.appendTemplate(template.i18n!, templateIndex);\n    }\n\n    const tagName = sanitizeIdentifier(template.tagName || '');\n    const contextName = `${this.contextName}${tagName ? '_' + tagName : ''}_${templateIndex}`;\n    const templateName = `${contextName}_Template`;\n\n    const parameters: o.Expression[] = [\n      o.literal(templateIndex),\n      o.variable(templateName),\n\n      // We don't care about the tag's namespace here, because we infer\n      // it based on the parent nodes inside the template instruction.\n      o.literal(template.tagName ? splitNsName(template.tagName)[1] : template.tagName),\n    ];\n\n    // find directives matching on a given <ng-template> node\n    this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);\n\n    // prepare attributes parameter (including attributes used for directive matching)\n    const attrsExprs: o.Expression[] = this.getAttributeExpressions(\n        NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs,\n        undefined /* styles */, template.templateAttrs);\n    parameters.push(this.addAttrsToConsts(attrsExprs));\n\n    // local refs (ex.: <ng-template #foo>)\n    if (template.references && template.references.length) {\n      const refs = this.prepareRefsArray(template.references);\n      parameters.push(this.addToConsts(refs));\n      parameters.push(o.importExpr(R3.templateRefExtractor));\n    }\n\n    // Create the template function\n    const templateVisitor = new TemplateDefinitionBuilder(\n        this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n,\n        templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName,\n        this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds,\n        this._constants);\n\n    // Nested templates must not be visited until after their parent templates have completed\n    // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n    // be able to support bindings in nested templates to local refs that occur after the\n    // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n    this._nestedTemplateFns.push(() => {\n      const templateFunctionExpr = templateVisitor.buildTemplateFunction(\n          template.children, template.variables,\n          this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);\n      this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n      if (templateVisitor._ngContentReservedSlots.length) {\n        this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);\n      }\n    });\n\n    // e.g. template(1, MyComp_Template_1)\n    this.creationInstruction(template.sourceSpan, R3.templateCreate, () => {\n      parameters.splice(\n          2, 0, o.literal(templateVisitor.getConstCount()),\n          o.literal(templateVisitor.getVarCount()));\n      return trimTrailingNulls(parameters);\n    });\n\n    // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;\n    this.templatePropertyBindings(templateIndex, template.templateAttrs);\n\n    // Only add normal input/output binding instructions on explicit <ng-template> elements.\n    if (template.tagName === NG_TEMPLATE_TAG_NAME) {\n      const [i18nInputs, inputs] =\n          partitionArray<t.BoundAttribute, t.BoundAttribute>(template.inputs, hasI18nMeta);\n\n      // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n      // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n      // elements, in case of inline templates, corresponding instructions will be generated in the\n      // nested template function.\n      if (i18nInputs.length > 0) {\n        this.i18nAttributesInstruction(\n            templateIndex, i18nInputs, template.startSourceSpan ?? template.sourceSpan);\n      }\n\n      // Add the input bindings\n      if (inputs.length > 0) {\n        this.templatePropertyBindings(templateIndex, inputs);\n      }\n\n      // Generate listeners for directive output\n      if (template.outputs.length > 0) {\n        const listeners = template.outputs.map(\n            (outputAst: t.BoundEvent) => ({\n              sourceSpan: outputAst.sourceSpan,\n              params: this.prepareListenerParameter('ng_template', outputAst, templateIndex)\n            }));\n        this.creationInstructionChain(R3.listener, listeners);\n      }\n    }\n  }\n\n  // These should be handled in the template or element directly.\n  readonly visitReference = invalid;\n  readonly visitVariable = invalid;\n  readonly visitTextAttribute = invalid;\n  readonly visitBoundAttribute = invalid;\n  readonly visitBoundEvent = invalid;\n\n  visitBoundText(text: t.BoundText) {\n    if (this.i18n) {\n      const value = text.value.visit(this._valueConverter);\n      this.allocateBindingSlots(value);\n      if (value instanceof Interpolation) {\n        this.i18n.appendBoundText(text.i18n!);\n        this.i18nAppendBindings(value.expressions);\n      }\n      return;\n    }\n\n    const nodeIndex = this.allocateDataSlot();\n\n    this.creationInstruction(text.sourceSpan, R3.text, [o.literal(nodeIndex)]);\n\n    const value = text.value.visit(this._valueConverter);\n    this.allocateBindingSlots(value);\n\n    if (value instanceof Interpolation) {\n      this.updateInstructionWithAdvance(\n          nodeIndex, text.sourceSpan, getTextInterpolationExpression(value),\n          () => this.getUpdateInstructionArguments(value));\n    } else {\n      error('Text nodes should be interpolated and never bound directly.');\n    }\n  }\n\n  visitText(text: t.Text) {\n    // when a text element is located within a translatable\n    // block, we exclude this text element from instructions set,\n    // since it will be captured in i18n content and processed at runtime\n    if (!this.i18n) {\n      this.creationInstruction(\n          text.sourceSpan, R3.text, [o.literal(this.allocateDataSlot()), o.literal(text.value)]);\n    }\n  }\n\n  visitIcu(icu: t.Icu) {\n    let initWasInvoked = false;\n\n    // if an ICU was created outside of i18n block, we still treat\n    // it as a translatable entity and invoke i18nStart and i18nEnd\n    // to generate i18n context and the necessary instructions\n    if (!this.i18n) {\n      initWasInvoked = true;\n      this.i18nStart(null, icu.i18n!, true);\n    }\n\n    const i18n = this.i18n!;\n    const vars = this.i18nBindProps(icu.vars);\n    const placeholders = this.i18nBindProps(icu.placeholders);\n\n    // output ICU directly and keep ICU reference in context\n    const message = icu.i18n! as i18n.Message;\n\n    // we always need post-processing function for ICUs, to make sure that:\n    // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n    // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n    // inside ICUs)\n    // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n    const transformFn = (raw: o.ReadVarExpr) => {\n      const params = {...vars, ...placeholders};\n      const formatted = i18nFormatPlaceholderNames(params, /* useCamelCase */ false);\n      return instruction(null, R3.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n    };\n\n    // in case the whole i18n message is a single ICU - we do not need to\n    // create a separate top-level translation, we can use the root ref instead\n    // and make this ICU a top-level translation\n    // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n    // separately, so we do not pass placeholders into `i18nTranslate` function.\n    if (isSingleI18nIcu(i18n.meta)) {\n      this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\n    } else {\n      // output ICU directly and keep ICU reference in context\n      const ref =\n          this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\n      i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n    }\n\n    if (initWasInvoked) {\n      this.i18nEnd(null, true);\n    }\n    return null;\n  }\n\n  private allocateDataSlot() {\n    return this._dataIndex++;\n  }\n\n  getConstCount() {\n    return this._dataIndex;\n  }\n\n  getVarCount() {\n    return this._pureFunctionSlots;\n  }\n\n  getConsts(): ComponentDefConsts {\n    return this._constants;\n  }\n\n  getNgContentSelectors(): o.Expression|null {\n    return this._ngContentReservedSlots.length ?\n        this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\n        null;\n  }\n\n  private bindingContext() {\n    return `${this._bindingContext++}`;\n  }\n\n  private templatePropertyBindings(\n      templateIndex: number, attrs: (t.BoundAttribute|t.TextAttribute)[]) {\n    const propertyBindings: ChainableBindingInstruction[] = [];\n    attrs.forEach(input => {\n      if (input instanceof t.BoundAttribute) {\n        const value = input.value.visit(this._valueConverter);\n\n        if (value !== undefined) {\n          this.allocateBindingSlots(value);\n          if (value instanceof Interpolation) {\n            // Params typically contain attribute namespace and value sanitizer, which is applicable\n            // for regular HTML elements, but not applicable for <ng-template> (since props act as\n            // inputs to directives), so keep params array empty.\n            const params: any[] = [];\n\n            // prop=\"{{value}}\" case\n            this.interpolatedUpdateInstruction(\n                getPropertyInterpolationExpression(value), templateIndex, input.name, input, value,\n                params);\n          } else {\n            // [prop]=\"value\" case\n            propertyBindings.push({\n              name: input.name,\n              sourceSpan: input.sourceSpan,\n              value: () => this.convertPropertyBinding(value)\n            });\n          }\n        }\n      }\n    });\n\n    if (propertyBindings.length > 0) {\n      this.updateInstructionChainWithAdvance(templateIndex, R3.property, propertyBindings);\n    }\n  }\n\n  // Bindings must only be resolved after all local refs have been visited, so all\n  // instructions are queued in callbacks that execute once the initial pass has completed.\n  // Otherwise, we wouldn't be able to support local refs that are defined after their\n  // bindings. e.g. {{ foo }} <div #foo></div>\n  private instructionFn(\n      fns: (() => o.Statement)[], span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn: o.Expression[]|(() => o.Expression[]), prepend: boolean = false): void {\n    fns[prepend ? 'unshift' : 'push'](() => {\n      const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\n      return instruction(span, reference, params).toStmt();\n    });\n  }\n\n  private processStylingUpdateInstruction(\n      elementIndex: number, instruction: StylingInstruction|null) {\n    let allocateBindingSlots = 0;\n    if (instruction) {\n      const calls: ChainableBindingInstruction[] = [];\n\n      instruction.calls.forEach(call => {\n        allocateBindingSlots += call.allocateBindingSlots;\n        calls.push({\n          sourceSpan: call.sourceSpan,\n          value: () => {\n            return call.params(\n                       value => (call.supportsInterpolation && value instanceof Interpolation) ?\n                           this.getUpdateInstructionArguments(value) :\n                           this.convertPropertyBinding(value)) as o.Expression[];\n          }\n        });\n      });\n\n      this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);\n    }\n\n    return allocateBindingSlots;\n  }\n\n  private creationInstruction(\n      span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn?: o.Expression[]|(() => o.Expression[]), prepend?: boolean) {\n    this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n  }\n\n  private creationInstructionChain(reference: o.ExternalReference, calls: {\n    sourceSpan: ParseSourceSpan|null,\n    params: () => o.Expression[]\n  }[]) {\n    const span = calls.length ? calls[0].sourceSpan : null;\n    this._creationCodeFns.push(() => {\n      return chainedInstruction(reference, calls.map(call => call.params()), span).toStmt();\n    });\n  }\n\n  private updateInstructionWithAdvance(\n      nodeIndex: number, span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn?: o.Expression[]|(() => o.Expression[])) {\n    this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n    this.updateInstruction(span, reference, paramsOrFn);\n  }\n\n  private updateInstruction(\n      span: ParseSourceSpan|null, reference: o.ExternalReference,\n      paramsOrFn?: o.Expression[]|(() => o.Expression[])) {\n    this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n  }\n\n  private updateInstructionChain(\n      reference: o.ExternalReference, bindings: ChainableBindingInstruction[]) {\n    const span = bindings.length ? bindings[0].sourceSpan : null;\n\n    this._updateCodeFns.push(() => {\n      const calls = bindings.map(property => {\n        const value = property.value();\n        const fnParams = Array.isArray(value) ? value : [value];\n        if (property.params) {\n          fnParams.push(...property.params);\n        }\n        if (property.name) {\n          // We want the property name to always be the first function parameter.\n          fnParams.unshift(o.literal(property.name));\n        }\n        return fnParams;\n      });\n\n      return chainedInstruction(reference, calls, span).toStmt();\n    });\n  }\n\n  private updateInstructionChainWithAdvance(\n      nodeIndex: number, reference: o.ExternalReference, bindings: ChainableBindingInstruction[]) {\n    this.addAdvanceInstructionIfNecessary(\n        nodeIndex, bindings.length ? bindings[0].sourceSpan : null);\n    this.updateInstructionChain(reference, bindings);\n  }\n\n  private addAdvanceInstructionIfNecessary(nodeIndex: number, span: ParseSourceSpan|null) {\n    if (nodeIndex !== this._currentIndex) {\n      const delta = nodeIndex - this._currentIndex;\n\n      if (delta < 1) {\n        throw new Error('advance instruction can only go forwards');\n      }\n\n      this.instructionFn(this._updateCodeFns, span, R3.advance, [o.literal(delta)]);\n      this._currentIndex = nodeIndex;\n    }\n  }\n\n  private allocatePureFunctionSlots(numSlots: number): number {\n    const originalSlots = this._pureFunctionSlots;\n    this._pureFunctionSlots += numSlots;\n    return originalSlots;\n  }\n\n  private allocateBindingSlots(value: AST|null) {\n    this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n  }\n\n  /**\n   * Gets an expression that refers to the implicit receiver. The implicit\n   * receiver is always the root level context.\n   */\n  private getImplicitReceiverExpr(): o.ReadVarExpr {\n    if (this._implicitReceiverExpr) {\n      return this._implicitReceiverExpr;\n    }\n\n    return this._implicitReceiverExpr = this.level === 0 ?\n        o.variable(CONTEXT_NAME) :\n        this._bindingScope.getOrCreateSharedContextVar(0);\n  }\n\n  private convertPropertyBinding(value: AST): o.Expression {\n    const convertedPropertyBinding = convertPropertyBinding(\n        this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.Expression,\n        () => error('Unexpected interpolation'));\n    const valExpr = convertedPropertyBinding.currValExpr;\n    this._tempVariables.push(...convertedPropertyBinding.stmts);\n    return valExpr;\n  }\n\n  /**\n   * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n   * the temp variables state with temp variables that were identified as needing to be created\n   * while visiting the arguments.\n   * @param value The original expression we will be resolving an arguments list from.\n   */\n  private getUpdateInstructionArguments(value: AST): o.Expression[] {\n    const {args, stmts} =\n        convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\n\n    this._tempVariables.push(...stmts);\n    return args;\n  }\n\n  private matchDirectives(elementName: string, elOrTpl: t.Element|t.Template) {\n    if (this.directiveMatcher) {\n      const selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));\n      this.directiveMatcher.match(selector, (cssSelector, staticType) => {\n        this.directives.add(staticType);\n      });\n    }\n  }\n\n  /**\n   * Prepares all attribute expression values for the `TAttributes` array.\n   *\n   * The purpose of this function is to properly construct an attributes array that\n   * is passed into the `elementStart` (or just `element`) functions. Because there\n   * are many different types of attributes, the array needs to be constructed in a\n   * special way so that `elementStart` can properly evaluate them.\n   *\n   * The format looks like this:\n   *\n   * ```\n   * attrs = [prop, value, prop2, value2,\n   *   PROJECT_AS, selector,\n   *   CLASSES, class1, class2,\n   *   STYLES, style1, value1, style2, value2,\n   *   BINDINGS, name1, name2, name3,\n   *   TEMPLATE, name4, name5, name6,\n   *   I18N, name7, name8, ...]\n   * ```\n   *\n   * Note that this function will fully ignore all synthetic (@foo) attribute values\n   * because those values are intended to always be generated as property instructions.\n   */\n  private getAttributeExpressions(\n      elementName: string, renderAttributes: t.TextAttribute[], inputs: t.BoundAttribute[],\n      outputs: t.BoundEvent[], styles?: StylingBuilder,\n      templateAttrs: (t.BoundAttribute|t.TextAttribute)[] = [],\n      boundI18nAttrs: t.BoundAttribute[] = []): o.Expression[] {\n    const alreadySeen = new Set<string>();\n    const attrExprs: o.Expression[] = [];\n    let ngProjectAsAttr: t.TextAttribute|undefined;\n\n    for (const attr of renderAttributes) {\n      if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n        ngProjectAsAttr = attr;\n      }\n\n      // Note that static i18n attributes aren't in the i18n array,\n      // because they're treated in the same way as regular attributes.\n      if (attr.i18n) {\n        // When i18n attributes are present on elements with structural directives\n        // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\n        // duplicate i18n translation blocks for `ɵɵtemplate` and `ɵɵelement` instruction\n        // attributes. So we do a cache lookup to see if suitable i18n translation block\n        // already exists.\n        const {i18nVarRefsCache} = this._constants;\n        let i18nVarRef: o.ReadVarExpr;\n        if (i18nVarRefsCache.has(attr.i18n)) {\n          i18nVarRef = i18nVarRefsCache.get(attr.i18n)!;\n        } else {\n          i18nVarRef = this.i18nTranslate(attr.i18n as i18n.Message);\n          i18nVarRefsCache.set(attr.i18n, i18nVarRef);\n        }\n        attrExprs.push(o.literal(attr.name), i18nVarRef);\n      } else {\n        attrExprs.push(\n            ...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));\n      }\n    }\n\n    // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n    // ngProjectAs marker in the attribute name slot.\n    if (ngProjectAsAttr) {\n      attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));\n    }\n\n    function addAttrExpr(key: string|number, value?: o.Expression): void {\n      if (typeof key === 'string') {\n        if (!alreadySeen.has(key)) {\n          attrExprs.push(...getAttributeNameLiterals(key));\n          value !== undefined && attrExprs.push(value);\n          alreadySeen.add(key);\n        }\n      } else {\n        attrExprs.push(o.literal(key));\n      }\n    }\n\n    // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n    // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n    // as single property value cell by cell.\n    if (styles) {\n      styles.populateInitialStylingAttrs(attrExprs);\n    }\n\n    if (inputs.length || outputs.length) {\n      const attrsLengthBeforeInputs = attrExprs.length;\n\n      for (let i = 0; i < inputs.length; i++) {\n        const input = inputs[i];\n        // We don't want the animation and attribute bindings in the\n        // attributes array since they aren't used for directive matching.\n        if (input.type !== BindingType.Animation && input.type !== BindingType.Attribute) {\n          addAttrExpr(input.name);\n        }\n      }\n\n      for (let i = 0; i < outputs.length; i++) {\n        const output = outputs[i];\n        if (output.type !== ParsedEventType.Animation) {\n          addAttrExpr(output.name);\n        }\n      }\n\n      // this is a cheap way of adding the marker only after all the input/output\n      // values have been filtered (by not including the animation ones) and added\n      // to the expressions. The marker is important because it tells the runtime\n      // code that this is where attributes without values start...\n      if (attrExprs.length !== attrsLengthBeforeInputs) {\n        attrExprs.splice(attrsLengthBeforeInputs, 0, o.literal(core.AttributeMarker.Bindings));\n      }\n    }\n\n    if (templateAttrs.length) {\n      attrExprs.push(o.literal(core.AttributeMarker.Template));\n      templateAttrs.forEach(attr => addAttrExpr(attr.name));\n    }\n\n    if (boundI18nAttrs.length) {\n      attrExprs.push(o.literal(core.AttributeMarker.I18n));\n      boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));\n    }\n\n    return attrExprs;\n  }\n\n  private addToConsts(expression: o.Expression): o.LiteralExpr {\n    if (o.isNull(expression)) {\n      return o.TYPED_NULL_EXPR;\n    }\n\n    const consts = this._constants.constExpressions;\n\n    // Try to reuse a literal that's already in the array, if possible.\n    for (let i = 0; i < consts.length; i++) {\n      if (consts[i].isEquivalent(expression)) {\n        return o.literal(i);\n      }\n    }\n\n    return o.literal(consts.push(expression) - 1);\n  }\n\n  private addAttrsToConsts(attrs: o.Expression[]): o.LiteralExpr {\n    return attrs.length > 0 ? this.addToConsts(o.literalArr(attrs)) : o.TYPED_NULL_EXPR;\n  }\n\n  private prepareRefsArray(references: t.Reference[]): o.Expression {\n    if (!references || references.length === 0) {\n      return o.TYPED_NULL_EXPR;\n    }\n\n    const refsParam = flatten(references.map(reference => {\n      const slot = this.allocateDataSlot();\n      // Generate the update temporary.\n      const variableName = this._bindingScope.freshReferenceName();\n      const retrievalLevel = this.level;\n      const lhs = o.variable(variableName);\n      this._bindingScope.set(\n          retrievalLevel, reference.name, lhs,\n          DeclarationPriority.DEFAULT, (scope: BindingScope, relativeLevel: number) => {\n            // e.g. nextContext(2);\n            const nextContextStmt =\n                relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\n\n            // e.g. const $foo$ = reference(1);\n            const refExpr = lhs.set(o.importExpr(R3.reference).callFn([o.literal(slot)]));\n            return nextContextStmt.concat(refExpr.toConstDecl());\n          }, true);\n      return [reference.name, reference.value];\n    }));\n\n    return asLiteral(refsParam);\n  }\n\n  private prepareListenerParameter(tagName: string, outputAst: t.BoundEvent, index: number):\n      () => o.Expression[] {\n    return () => {\n      const eventName: string = outputAst.name;\n      const bindingFnName = outputAst.type === ParsedEventType.Animation ?\n          // synthetic @listener.foo values are treated the exact same as are standard listeners\n          prepareSyntheticListenerFunctionName(eventName, outputAst.phase!) :\n          sanitizeIdentifier(eventName);\n      const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;\n      const scope = this._bindingScope.nestedScope(\n          this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\n      return prepareEventListenerParameters(outputAst, handlerName, scope);\n    };\n  }\n}\n\nexport class ValueConverter extends AstMemoryEfficientTransformer {\n  private _pipeBindExprs: FunctionCall[] = [];\n\n  constructor(\n      private constantPool: ConstantPool, private allocateSlot: () => number,\n      private allocatePureFunctionSlots: (numSlots: number) => number,\n      private definePipe:\n          (name: string, localName: string, slot: number, value: o.Expression) => void) {\n    super();\n  }\n\n  // AstMemoryEfficientTransformer\n  visitPipe(pipe: BindingPipe, context: any): AST {\n    // Allocate a slot to create the pipe\n    const slot = this.allocateSlot();\n    const slotPseudoLocal = `PIPE:${slot}`;\n    // Allocate one slot for the result plus one slot per pipe argument\n    const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n    const target = new PropertyRead(\n        pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan),\n        slotPseudoLocal);\n    const {identifier, isVarLength} = pipeBindingCallInfo(pipe.args);\n    this.definePipe(pipe.name, slotPseudoLocal, slot, o.importExpr(identifier));\n    const args: AST[] = [pipe.exp, ...pipe.args];\n    const convertedArgs: AST[] = isVarLength ?\n        this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\n        this.visitAll(args);\n\n    const pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [\n      new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\n      new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\n      ...convertedArgs,\n    ]);\n    this._pipeBindExprs.push(pipeBindExpr);\n    return pipeBindExpr;\n  }\n\n  updatePipeSlotOffsets(bindingSlots: number) {\n    this._pipeBindExprs.forEach((pipe: FunctionCall) => {\n      // update the slot offset arg (index 1) to account for binding slots\n      const slotOffset = pipe.args[1] as LiteralPrimitive;\n      (slotOffset.value as number) += bindingSlots;\n    });\n  }\n\n  visitLiteralArray(array: LiteralArray, context: any): AST {\n    return new BuiltinFunctionCall(\n        array.span, array.sourceSpan, this.visitAll(array.expressions), values => {\n          // If the literal has calculated (non-literal) elements transform it into\n          // calls to literal factories that compose the literal and will cache intermediate\n          // values.\n          const literal = o.literalArr(values);\n          return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n        });\n  }\n\n  visitLiteralMap(map: LiteralMap, context: any): AST {\n    return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {\n      // If the literal has calculated (non-literal) elements  transform it into\n      // calls to literal factories that compose the literal and will cache intermediate\n      // values.\n      const literal = o.literalMap(values.map(\n          (value, index) => ({key: map.keys[index].key, value, quoted: map.keys[index].quoted})));\n      return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\n    });\n  }\n}\n\n// Pipes always have at least one parameter, the value they operate on\nconst pipeBindingIdentifiers = [R3.pipeBind1, R3.pipeBind2, R3.pipeBind3, R3.pipeBind4];\n\nfunction pipeBindingCallInfo(args: o.Expression[]) {\n  const identifier = pipeBindingIdentifiers[args.length];\n  return {\n    identifier: identifier || R3.pipeBindV,\n    isVarLength: !identifier,\n  };\n}\n\nconst pureFunctionIdentifiers = [\n  R3.pureFunction0, R3.pureFunction1, R3.pureFunction2, R3.pureFunction3, R3.pureFunction4,\n  R3.pureFunction5, R3.pureFunction6, R3.pureFunction7, R3.pureFunction8\n];\n\nfunction pureFunctionCallInfo(args: o.Expression[]) {\n  const identifier = pureFunctionIdentifiers[args.length];\n  return {\n    identifier: identifier || R3.pureFunctionV,\n    isVarLength: !identifier,\n  };\n}\n\nfunction instruction(\n    span: ParseSourceSpan|null, reference: o.ExternalReference,\n    params: o.Expression[]): o.Expression {\n  return o.importExpr(reference, null, span).callFn(params, span);\n}\n\n// e.g. x(2);\nfunction generateNextContextExpr(relativeLevelDiff: number): o.Expression {\n  return o.importExpr(R3.nextContext)\n      .callFn(relativeLevelDiff > 1 ? [o.literal(relativeLevelDiff)] : []);\n}\n\nfunction getLiteralFactory(\n    constantPool: ConstantPool, literal: o.LiteralArrayExpr|o.LiteralMapExpr,\n    allocateSlots: (numSlots: number) => number): o.Expression {\n  const {literalFactory, literalFactoryArguments} = constantPool.getLiteralFactory(literal);\n  // Allocate 1 slot for the result plus 1 per argument\n  const startSlot = allocateSlots(1 + literalFactoryArguments.length);\n  const {identifier, isVarLength} = pureFunctionCallInfo(literalFactoryArguments);\n\n  // Literal factories are pure functions that only need to be re-invoked when the parameters\n  // change.\n  const args = [o.literal(startSlot), literalFactory];\n\n  if (isVarLength) {\n    args.push(o.literalArr(literalFactoryArguments));\n  } else {\n    args.push(...literalFactoryArguments);\n  }\n\n  return o.importExpr(identifier).callFn(args);\n}\n\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\nfunction getAttributeNameLiterals(name: string): o.LiteralExpr[] {\n  const [attributeNamespace, attributeName] = splitNsName(name);\n  const nameLiteral = o.literal(attributeName);\n\n  if (attributeNamespace) {\n    return [\n      o.literal(core.AttributeMarker.NamespaceURI), o.literal(attributeNamespace), nameLiteral\n    ];\n  }\n\n  return [nameLiteral];\n}\n\n/**\n * Function which is executed whenever a variable is referenced for the first time in a given\n * scope.\n *\n * It is expected that the function creates the `const localName = expression`; statement.\n */\nexport type DeclareLocalVarCallback = (scope: BindingScope, relativeLevel: number) => o.Statement[];\n\n/** The prefix used to get a shared context in BindingScope's map. */\nconst SHARED_CONTEXT_KEY = '$$shared_ctx$$';\n\n/**\n * This is used when one refers to variable such as: 'let abc = nextContext(2).$implicit`.\n * - key to the map is the string literal `\"abc\"`.\n * - value `retrievalLevel` is the level from which this value can be retrieved, which is 2 levels\n * up in example.\n * - value `lhs` is the left hand side which is an AST representing `abc`.\n * - value `declareLocalCallback` is a callback that is invoked when declaring the local.\n * - value `declare` is true if this value needs to be declared.\n * - value `localRef` is true if we are storing a local reference\n * - value `priority` dictates the sorting priority of this var declaration compared\n * to other var declarations on the same retrieval level. For example, if there is a\n * context variable and a local ref accessing the same parent view, the context var\n * declaration should always come before the local ref declaration.\n */\ntype BindingData = {\n  retrievalLevel: number; lhs: o.Expression;\n  declareLocalCallback?: DeclareLocalVarCallback; declare: boolean; priority: number;\n  localRef: boolean;\n};\n\n/**\n * The sorting priority of a local variable declaration. Higher numbers\n * mean the declaration will appear first in the generated code.\n */\nconst enum DeclarationPriority {\n  DEFAULT = 0,\n  CONTEXT = 1,\n  SHARED_CONTEXT = 2\n}\n\nexport class BindingScope implements LocalResolver {\n  /** Keeps a map from local variables to their BindingData. */\n  private map = new Map<string, BindingData>();\n  private referenceNameIndex = 0;\n  private restoreViewVariable: o.ReadVarExpr|null = null;\n  static createRootScope(): BindingScope {\n    return new BindingScope();\n  }\n\n  private constructor(\n      public bindingLevel: number = 0, private parent: BindingScope|null = null,\n      public globals?: Set<string>) {\n    if (globals !== undefined) {\n      for (const name of globals) {\n        this.set(0, name, o.variable(name));\n      }\n    }\n  }\n\n  get(name: string): o.Expression|null {\n    let current: BindingScope|null = this;\n    while (current) {\n      let value = current.map.get(name);\n      if (value != null) {\n        if (current !== this) {\n          // make a local copy and reset the `declare` state\n          value = {\n            retrievalLevel: value.retrievalLevel,\n            lhs: value.lhs,\n            declareLocalCallback: value.declareLocalCallback,\n            declare: false,\n            priority: value.priority,\n            localRef: value.localRef\n          };\n\n          // Cache the value locally.\n          this.map.set(name, value);\n          // Possibly generate a shared context var\n          this.maybeGenerateSharedContextVar(value);\n          this.maybeRestoreView(value.retrievalLevel, value.localRef);\n        }\n\n        if (value.declareLocalCallback && !value.declare) {\n          value.declare = true;\n        }\n        return value.lhs;\n      }\n      current = current.parent;\n    }\n\n    // If we get to this point, we are looking for a property on the top level component\n    // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n    // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n    // local var we used to store the component context, e.g. const $comp$ = x();\n    return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n  }\n\n  /**\n   * Create a local variable for later reference.\n   *\n   * @param retrievalLevel The level from which this value can be retrieved\n   * @param name Name of the variable.\n   * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\n   * @param priority The sorting priority of this var\n   * @param declareLocalCallback The callback to invoke when declaring this local var\n   * @param localRef Whether or not this is a local ref\n   */\n  set(retrievalLevel: number, name: string, lhs: o.Expression,\n      priority: number = DeclarationPriority.DEFAULT,\n      declareLocalCallback?: DeclareLocalVarCallback, localRef?: true): BindingScope {\n    if (this.map.has(name)) {\n      if (localRef) {\n        // Do not throw an error if it's a local ref and do not update existing value,\n        // so the first defined ref is always returned.\n        return this;\n      }\n      error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);\n    }\n    this.map.set(name, {\n      retrievalLevel: retrievalLevel,\n      lhs: lhs,\n      declare: false,\n      declareLocalCallback: declareLocalCallback,\n      priority: priority,\n      localRef: localRef || false\n    });\n    return this;\n  }\n\n  // Implemented as part of LocalResolver.\n  getLocal(name: string): (o.Expression|null) {\n    return this.get(name);\n  }\n\n  // Implemented as part of LocalResolver.\n  notifyImplicitReceiverUse(): void {\n    if (this.bindingLevel !== 0) {\n      // Since the implicit receiver is accessed in an embedded view, we need to\n      // ensure that we declare a shared context variable for the current template\n      // in the update variables.\n      this.map.get(SHARED_CONTEXT_KEY + 0)!.declare = true;\n    }\n  }\n\n  nestedScope(level: number, globals?: Set<string>): BindingScope {\n    const newScope = new BindingScope(level, this, globals);\n    if (level > 0) newScope.generateSharedContextVar(0);\n    return newScope;\n  }\n\n  /**\n   * Gets or creates a shared context variable and returns its expression. Note that\n   * this does not mean that the shared variable will be declared. Variables in the\n   * binding scope will be only declared if they are used.\n   */\n  getOrCreateSharedContextVar(retrievalLevel: number): o.ReadVarExpr {\n    const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n    if (!this.map.has(bindingKey)) {\n      this.generateSharedContextVar(retrievalLevel);\n    }\n    // Shared context variables are always generated as \"ReadVarExpr\".\n    return this.map.get(bindingKey)!.lhs as o.ReadVarExpr;\n  }\n\n  getSharedContextName(retrievalLevel: number): o.ReadVarExpr|null {\n    const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\n    // Shared context variables are always generated as \"ReadVarExpr\".\n    return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs as o.ReadVarExpr : null;\n  }\n\n  maybeGenerateSharedContextVar(value: BindingData) {\n    if (value.priority === DeclarationPriority.CONTEXT &&\n        value.retrievalLevel < this.bindingLevel) {\n      const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n      if (sharedCtxObj) {\n        sharedCtxObj.declare = true;\n      } else {\n        this.generateSharedContextVar(value.retrievalLevel);\n      }\n    }\n  }\n\n  generateSharedContextVar(retrievalLevel: number) {\n    const lhs = o.variable(CONTEXT_NAME + this.freshReferenceName());\n    this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n      retrievalLevel: retrievalLevel,\n      lhs: lhs,\n      declareLocalCallback: (scope: BindingScope, relativeLevel: number) => {\n        // const ctx_r0 = nextContext(2);\n        return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n      },\n      declare: false,\n      priority: DeclarationPriority.SHARED_CONTEXT,\n      localRef: false\n    });\n  }\n\n  getComponentProperty(name: string): o.Expression {\n    const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0)!;\n    componentValue.declare = true;\n    this.maybeRestoreView(0, false);\n    return componentValue.lhs.prop(name);\n  }\n\n  maybeRestoreView(retrievalLevel: number, localRefLookup: boolean) {\n    // We want to restore the current view in listener fns if:\n    // 1 - we are accessing a value in a parent view, which requires walking the view tree rather\n    // than using the ctx arg. In this case, the retrieval and binding level will be different.\n    // 2 - we are looking up a local ref, which requires restoring the view where the local\n    // ref is stored\n    if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {\n      if (!this.parent!.restoreViewVariable) {\n        // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n        this.parent!.restoreViewVariable = o.variable(this.parent!.freshReferenceName());\n      }\n      this.restoreViewVariable = this.parent!.restoreViewVariable;\n    }\n  }\n\n  restoreViewStatement(): o.Statement[] {\n    // restoreView($state$);\n    return this.restoreViewVariable ?\n        [instruction(null, R3.restoreView, [this.restoreViewVariable]).toStmt()] :\n        [];\n  }\n\n  viewSnapshotStatements(): o.Statement[] {\n    // const $state$ = getCurrentView();\n    const getCurrentViewInstruction = instruction(null, R3.getCurrentView, []);\n    return this.restoreViewVariable ?\n        [this.restoreViewVariable.set(getCurrentViewInstruction).toConstDecl()] :\n        [];\n  }\n\n  isListenerScope() {\n    return this.parent && this.parent.bindingLevel === this.bindingLevel;\n  }\n\n  variableDeclarations(): o.Statement[] {\n    let currentContextLevel = 0;\n    return Array.from(this.map.values())\n               .filter(value => value.declare)\n               .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)\n               .reduce((stmts: o.Statement[], value: BindingData) => {\n                 const levelDiff = this.bindingLevel - value.retrievalLevel;\n                 const currStmts =\n                     value.declareLocalCallback!(this, levelDiff - currentContextLevel);\n                 currentContextLevel = levelDiff;\n                 return stmts.concat(currStmts);\n               }, []) as o.Statement[];\n  }\n\n\n  freshReferenceName(): string {\n    let current: BindingScope = this;\n    // Find the top scope as it maintains the global reference count\n    while (current.parent) current = current.parent;\n    const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;\n    return ref;\n  }\n}\n\n/**\n * Creates a `CssSelector` given a tag name and a map of attributes\n */\nexport function createCssSelector(\n    elementName: string, attributes: {[name: string]: string}): CssSelector {\n  const cssSelector = new CssSelector();\n  const elementNameNoNs = splitNsName(elementName)[1];\n\n  cssSelector.setElement(elementNameNoNs);\n\n  Object.getOwnPropertyNames(attributes).forEach((name) => {\n    const nameNoNs = splitNsName(name)[1];\n    const value = attributes[name];\n\n    cssSelector.addAttribute(nameNoNs, value);\n    if (name.toLowerCase() === 'class') {\n      const classes = value.trim().split(/\\s+/);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  });\n\n  return cssSelector;\n}\n\n/**\n * Creates an array of expressions out of an `ngProjectAs` attributes\n * which can be added to the instruction parameters.\n */\nfunction getNgProjectAsLiteral(attribute: t.TextAttribute): o.Expression[] {\n  // Parse the attribute value into a CssSelectorList. Note that we only take the\n  // first selector, because we don't support multiple selectors in ngProjectAs.\n  const parsedR3Selector = core.parseSelectorToR3Selector(attribute.value)[0];\n  return [o.literal(core.AttributeMarker.ProjectAs), asLiteral(parsedR3Selector)];\n}\n\n/**\n * Gets the instruction to generate for an interpolated property\n * @param interpolation An Interpolation AST\n */\nfunction getPropertyInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.propertyInterpolate;\n    case 3:\n      return R3.propertyInterpolate1;\n    case 5:\n      return R3.propertyInterpolate2;\n    case 7:\n      return R3.propertyInterpolate3;\n    case 9:\n      return R3.propertyInterpolate4;\n    case 11:\n      return R3.propertyInterpolate5;\n    case 13:\n      return R3.propertyInterpolate6;\n    case 15:\n      return R3.propertyInterpolate7;\n    case 17:\n      return R3.propertyInterpolate8;\n    default:\n      return R3.propertyInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated attribute\n * @param interpolation An Interpolation AST\n */\nfunction getAttributeInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 3:\n      return R3.attributeInterpolate1;\n    case 5:\n      return R3.attributeInterpolate2;\n    case 7:\n      return R3.attributeInterpolate3;\n    case 9:\n      return R3.attributeInterpolate4;\n    case 11:\n      return R3.attributeInterpolate5;\n    case 13:\n      return R3.attributeInterpolate6;\n    case 15:\n      return R3.attributeInterpolate7;\n    case 17:\n      return R3.attributeInterpolate8;\n    default:\n      return R3.attributeInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for interpolated text.\n * @param interpolation An Interpolation AST\n */\nfunction getTextInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.textInterpolate;\n    case 3:\n      return R3.textInterpolate1;\n    case 5:\n      return R3.textInterpolate2;\n    case 7:\n      return R3.textInterpolate3;\n    case 9:\n      return R3.textInterpolate4;\n    case 11:\n      return R3.textInterpolate5;\n    case 13:\n      return R3.textInterpolate6;\n    case 15:\n      return R3.textInterpolate7;\n    case 17:\n      return R3.textInterpolate8;\n    default:\n      return R3.textInterpolateV;\n  }\n}\n\n/**\n * Options that can be used to modify how a template is parsed by `parseTemplate()`.\n */\nexport interface ParseTemplateOptions {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n  /**\n   * Preserve original line endings instead of normalizing '\\r\\n' endings to '\\n'.\n   */\n  preserveLineEndings?: boolean;\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n\n  /**\n   * Render `$localize` message ids with additional legacy message ids.\n   *\n   * This option defaults to `true` but in the future the defaul will be flipped.\n   *\n   * For now set this option to false if you have migrated the translation files to use the new\n   * `$localize` message id format and you are not using compile time translation merging.\n   */\n  enableI18nLegacyMessageIdFormat?: boolean;\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n\n  /**\n   * Whether the template was inline.\n   */\n  isInline?: boolean;\n\n  /**\n   * Whether to always attempt to convert the parsed HTML AST to an R3 AST, despite HTML or i18n\n   * Meta parse errors.\n   *\n   *\n   * This option is useful in the context of the language service, where we want to get as much\n   * information as possible, despite any errors in the HTML. As an example, a user may be adding\n   * a new tag and expecting autocomplete on that tag. In this scenario, the HTML is in an errored\n   * state, as there is an incomplete open tag. However, we're still able to convert the HTML AST\n   * nodes to R3 AST nodes in order to provide information for the language service.\n   *\n   * Note that even when `true` the HTML parse and i18n errors are still appended to the errors\n   * output, but this is done after converting the HTML AST to R3 AST.\n   */\n  alwaysAttemptHtmlToR3AstConversion?: boolean;\n\n  /**\n   * Include HTML Comment nodes in a top-level comments array on the returned R3 AST.\n   *\n   * This option is required by tooling that needs to know the location of comment nodes within the\n   * AST. A concrete example is @angular-eslint which requires this in order to enable\n   * \"eslint-disable\" comments within HTML templates, which then allows users to turn off specific\n   * rules on a case by case basis, instead of for their whole project within a configuration file.\n   */\n  collectCommentNodes?: boolean;\n}\n\n/**\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\n *\n * @param template text of the template to parse\n * @param templateUrl URL to use for source mapping of the parsed template\n * @param options options to modify how the template is parsed\n */\nexport function parseTemplate(\n    template: string, templateUrl: string, options: ParseTemplateOptions = {}): ParsedTemplate {\n  const {interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat} = options;\n  const isInline = options.isInline ?? false;\n  const bindingParser = makeBindingParser(interpolationConfig);\n  const htmlParser = new HtmlParser();\n  const parseResult = htmlParser.parse(\n      template, templateUrl,\n      {leadingTriviaChars: LEADING_TRIVIA_CHARS, ...options, tokenizeExpansionForms: true});\n\n  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&\n      parseResult.errors.length > 0) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      template,\n      templateUrl,\n      isInline,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  let rootNodes: html.Node[] = parseResult.rootNodes;\n\n  // process i18n meta information (scan attributes, generate ids)\n  // before we run whitespace removal process, because existing i18n\n  // extraction process (ng extract-i18n) relies on a raw content to generate\n  // message ids\n  const i18nMetaVisitor = new I18nMetaVisitor(\n      interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces,\n      enableI18nLegacyMessageIdFormat);\n  const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n\n  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&\n      i18nMetaResult.errors.length > 0) {\n    const parsedTemplate: ParsedTemplate = {\n      interpolationConfig,\n      preserveWhitespaces,\n      template,\n      templateUrl,\n      isInline,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n    if (options.collectCommentNodes) {\n      parsedTemplate.commentNodes = [];\n    }\n    return parsedTemplate;\n  }\n\n  rootNodes = i18nMetaResult.rootNodes;\n\n  if (!preserveWhitespaces) {\n    rootNodes = html.visitAll(new WhitespaceVisitor(), rootNodes);\n\n    // run i18n meta visitor again in case whitespaces are removed (because that might affect\n    // generated i18n message content) and first pass indicated that i18n content is present in a\n    // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n    // mimic existing extraction process (ng extract-i18n)\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = html.visitAll(\n          new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\n    }\n  }\n\n  const {nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes} = htmlAstToRender3Ast(\n      rootNodes, bindingParser, {collectCommentNodes: !!options.collectCommentNodes});\n  errors.push(...parseResult.errors, ...i18nMetaResult.errors);\n\n  const parsedTemplate: ParsedTemplate = {\n    interpolationConfig,\n    preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    template,\n    templateUrl,\n    isInline,\n    nodes,\n    styleUrls,\n    styles,\n    ngContentSelectors\n  };\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n  return parsedTemplate;\n}\n\nconst elementRegistry = new DomElementSchemaRegistry();\n\n/**\n * Construct a `BindingParser` with a default configuration.\n */\nexport function makeBindingParser(\n    interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): BindingParser {\n  return new BindingParser(\n      new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);\n}\n\nexport function resolveSanitizationFn(context: core.SecurityContext, isAttribute?: boolean) {\n  switch (context) {\n    case core.SecurityContext.HTML:\n      return o.importExpr(R3.sanitizeHtml);\n    case core.SecurityContext.SCRIPT:\n      return o.importExpr(R3.sanitizeScript);\n    case core.SecurityContext.STYLE:\n      // the compiler does not fill in an instruction for [style.prop?] binding\n      // values because the style algorithm knows internally what props are subject\n      // to sanitization (only [attr.style] values are explicitly sanitized)\n      return isAttribute ? o.importExpr(R3.sanitizeStyle) : null;\n    case core.SecurityContext.URL:\n      return o.importExpr(R3.sanitizeUrl);\n    case core.SecurityContext.RESOURCE_URL:\n      return o.importExpr(R3.sanitizeResourceUrl);\n    default:\n      return null;\n  }\n}\n\nfunction trustedConstAttribute(tagName: string, attr: t.TextAttribute): o.Expression {\n  const value = asLiteral(attr.value);\n  if (isTrustedTypesSink(tagName, attr.name)) {\n    switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {\n      case core.SecurityContext.HTML:\n        return o.taggedTemplate(\n            o.importExpr(R3.trustConstantHtml),\n            new o.TemplateLiteral([new o.TemplateLiteralElement(attr.value)], []), undefined,\n            attr.valueSpan);\n      // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\n      case core.SecurityContext.RESOURCE_URL:\n        return o.taggedTemplate(\n            o.importExpr(R3.trustConstantResourceUrl),\n            new o.TemplateLiteral([new o.TemplateLiteralElement(attr.value)], []), undefined,\n            attr.valueSpan);\n      default:\n        return value;\n    }\n  } else {\n    return value;\n  }\n}\n\nfunction isSingleElementTemplate(children: t.Node[]): children is[t.Element] {\n  return children.length === 1 && children[0] instanceof t.Element;\n}\n\nfunction isTextNode(node: t.Node): boolean {\n  return node instanceof t.Text || node instanceof t.BoundText || node instanceof t.Icu;\n}\n\nfunction hasTextChildrenOnly(children: t.Node[]): boolean {\n  return children.every(isTextNode);\n}\n\ninterface ChainableBindingInstruction {\n  name?: string;\n  sourceSpan: ParseSourceSpan|null;\n  value: () => o.Expression | o.Expression[];\n  params?: any[];\n}\n\n/** Name of the global variable that is used to determine if we use Closure translations or not */\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n\n/**\n * Generate statements that define a given translation message.\n *\n * ```\n * var I18N_1;\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\n *          \"Some message with {$interpolation}!\",\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\n *     );\n *     I18N_1 = MSG_EXTERNAL_XXX;\n * }\n * else {\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\n * }\n * ```\n *\n * @param message The original i18n AST message node\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\n * @param params Object mapping placeholder names to their values (e.g.\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\n * post-processing).\n * @returns An array of statements that defined a given translation.\n */\nexport function getTranslationDeclStmts(\n    message: i18n.Message, variable: o.ReadVarExpr, closureVar: o.ReadVarExpr,\n    params: {[name: string]: o.Expression} = {},\n    transformFn?: (raw: o.ReadVarExpr) => o.Expression): o.Statement[] {\n  const statements: o.Statement[] = [\n    declareI18nVariable(variable),\n    o.ifStmt(\n        createClosureModeGuard(),\n        createGoogleGetMsgStatements(\n            variable, message, closureVar,\n            i18nFormatPlaceholderNames(params, /* useCamelCase */ true)),\n        createLocalizeStatements(\n            variable, message, i18nFormatPlaceholderNames(params, /* useCamelCase */ false))),\n  ];\n\n  if (transformFn) {\n    statements.push(new o.ExpressionStatement(variable.set(transformFn(variable))));\n  }\n\n  return statements;\n}\n\n/**\n * Create the expression that will be used to guard the closure mode block\n * It is equivalent to:\n *\n * ```\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\n * ```\n */\nfunction createClosureModeGuard(): o.BinaryOperatorExpr {\n  return o.typeofExpr(o.variable(NG_I18N_CLOSURE_MODE))\n      .notIdentical(o.literal('undefined', o.STRING_TYPE))\n      .and(o.variable(NG_I18N_CLOSURE_MODE));\n}\n\n/**\n * Information about the template which was extracted during parsing.\n *\n * This contains the actual parsed template as well as any metadata collected during its parsing,\n * some of which might be useful for re-parsing the template with different options.\n */\nexport interface ParsedTemplate {\n  /**\n   * Include whitespace nodes in the parsed output.\n   */\n  preserveWhitespaces?: boolean;\n\n  /**\n   * How to parse interpolation markers.\n   */\n  interpolationConfig?: InterpolationConfig;\n\n  /**\n   * The string contents of the template, or an expression that represents the string/template\n   * literal as it occurs in the source.\n   *\n   * This is the \"logical\" template string, after expansion of any escaped characters (for inline\n   * templates). This may differ from the actual template bytes as they appear in the .ts file.\n   */\n  template: string|o.Expression;\n\n  /**\n   * A full path to the file which contains the template.\n   *\n   * This can be either the original .ts file if the template is inline, or the .html file if an\n   * external file was used.\n   */\n  templateUrl: string;\n\n  /**\n   * Whether the template was inline (using `template`) or external (using `templateUrl`).\n   */\n  isInline: boolean;\n\n  /**\n   * Any errors from parsing the template the first time.\n   *\n   * `null` if there are no errors. Otherwise, the array of errors is guaranteed to be non-empty.\n   */\n  errors: ParseError[]|null;\n\n  /**\n   * The template AST, parsed from the template.\n   */\n  nodes: t.Node[];\n\n  /**\n   * Any styleUrls extracted from the metadata.\n   */\n  styleUrls: string[];\n\n  /**\n   * Any inline styles extracted from the metadata.\n   */\n  styles: string[];\n\n  /**\n   * Any ng-content selectors extracted from the template.\n   */\n  ngContentSelectors: string[];\n\n  /**\n   * Any R3 Comment Nodes extracted from the template when the `collectCommentNodes` parse template\n   * option is enabled.\n   */\n  commentNodes?: t.Comment[];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}