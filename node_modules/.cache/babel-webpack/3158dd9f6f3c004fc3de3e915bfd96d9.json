{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/entry_point_finder/directory_walker_entry_point_finder\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/entry_point_finder/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.DirectoryWalkerEntryPointFinder = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/entry_point_finder/utils\");\n  /**\n   * An EntryPointFinder that searches for all entry-points that can be found given a `basePath` and\n   * `pathMappings`.\n   */\n\n\n  var DirectoryWalkerEntryPointFinder =\n  /** @class */\n  function () {\n    function DirectoryWalkerEntryPointFinder(logger, resolver, entryPointCollector, entryPointManifest, sourceDirectory, pathMappings) {\n      this.logger = logger;\n      this.resolver = resolver;\n      this.entryPointCollector = entryPointCollector;\n      this.entryPointManifest = entryPointManifest;\n      this.sourceDirectory = sourceDirectory;\n      this.pathMappings = pathMappings;\n      this.basePaths = utils_1.getBasePaths(this.logger, this.sourceDirectory, this.pathMappings);\n    }\n    /**\n     * Search the `sourceDirectory`, and sub-directories, using `pathMappings` as necessary, to find\n     * all package entry-points.\n     */\n\n\n    DirectoryWalkerEntryPointFinder.prototype.findEntryPoints = function () {\n      var e_1, _a;\n\n      var unsortedEntryPoints = [];\n\n      try {\n        for (var _b = tslib_1.__values(this.basePaths), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var basePath = _c.value;\n          var entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) || this.walkBasePathForPackages(basePath);\n          entryPoints.forEach(function (e) {\n            return unsortedEntryPoints.push(e);\n          });\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return this.resolver.sortEntryPointsByDependency(unsortedEntryPoints);\n    };\n    /**\n     * Search the `basePath` for possible Angular packages and entry-points.\n     *\n     * @param basePath The path at which to start the search.\n     * @returns an array of `EntryPoint`s that were found within `basePath`.\n     */\n\n\n    DirectoryWalkerEntryPointFinder.prototype.walkBasePathForPackages = function (basePath) {\n      var _this = this;\n\n      this.logger.debug(\"No manifest found for \" + basePath + \" so walking the directories for entry-points.\");\n      var entryPoints = utils_1.trackDuration(function () {\n        return _this.entryPointCollector.walkDirectoryForPackages(basePath);\n      }, function (duration) {\n        return _this.logger.debug(\"Walking \" + basePath + \" for entry-points took \" + duration + \"s.\");\n      });\n      this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);\n      return entryPoints;\n    };\n\n    return DirectoryWalkerEntryPointFinder;\n  }();\n\n  exports.DirectoryWalkerEntryPointFinder = DirectoryWalkerEntryPointFinder;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/entry_point_finder/directory_walker_entry_point_finder.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAgBA,MAAA,OAAA,GAAA,OAAA,CAAA,yDAAA,CAAA;AAEA;;;AAGG;;;AACH,MAAA,+BAAA;AAAA;AAAA,cAAA;AAEE,aAAA,+BAAA,CACY,MADZ,EACoC,QADpC,EAEY,mBAFZ,EAGY,kBAHZ,EAG4D,eAH5D,EAIY,YAJZ,EAIgD;AAHpC,WAAA,MAAA,GAAA,MAAA;AAAwB,WAAA,QAAA,GAAA,QAAA;AACxB,WAAA,mBAAA,GAAA,mBAAA;AACA,WAAA,kBAAA,GAAA,kBAAA;AAAgD,WAAA,eAAA,GAAA,eAAA;AAChD,WAAA,YAAA,GAAA,YAAA;AALJ,WAAA,SAAA,GAAY,OAAA,CAAA,YAAA,CAAa,KAAK,MAAlB,EAA0B,KAAK,eAA/B,EAAgD,KAAK,YAArD,CAAZ;AAK4C;AAEpD;;;AAGG;;;AACH,IAAA,+BAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;;;AACE,UAAM,mBAAmB,GAAiC,EAA1D;;;AACA,aAAuB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,SAAL,CAAA,EAAc,EAAA,GAAA,EAAA,CAAA,IAAA,EAArC,EAAqC,CAAA,EAAA,CAAA,IAArC,EAAqC,EAAA,GAAA,EAAA,CAAA,IAAA,EAArC,EAAuC;AAAlC,cAAM,QAAQ,GAAA,EAAA,CAAA,KAAd;AACH,cAAM,WAAW,GAAG,KAAK,kBAAL,CAAwB,4BAAxB,CAAqD,QAArD,KAChB,KAAK,uBAAL,CAA6B,QAA7B,CADJ;AAEA,UAAA,WAAW,CAAC,OAAZ,CAAoB,UAAA,CAAA,EAAC;AAAI,mBAAA,mBAAmB,CAAC,IAApB,CAAA,CAAA,CAAA;AAA2B,WAApD;AACD;;;;;;;;;;;;;AACD,aAAO,KAAK,QAAL,CAAc,2BAAd,CAA0C,mBAA1C,CAAP;AACD,KARD;AAUA;;;;;AAKG;;;AACH,IAAA,+BAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UAAwB,QAAxB,EAAgD;AAAhD,UAAA,KAAA,GAAA,IAAA;;AACE,WAAK,MAAL,CAAY,KAAZ,CACI,2BAAyB,QAAzB,GAAiC,+CADrC;AAEA,UAAM,WAAW,GAAG,OAAA,CAAA,aAAA,CAChB,YAAA;AAAM,eAAA,KAAI,CAAC,mBAAL,CAAyB,wBAAzB,CAAA,QAAA,CAAA;AAA2D,OADjD,EAEhB,UAAA,QAAA,EAAQ;AAAI,eAAA,KAAI,CAAC,MAAL,CAAY,KAAZ,CAAkB,aAAW,QAAX,GAAmB,yBAAnB,GAA6C,QAA7C,GAAlB,IAAA,CAAA;AAA4E,OAFxE,CAApB;AAGA,WAAK,kBAAL,CAAwB,uBAAxB,CAAgD,QAAhD,EAA0D,WAA1D;AACA,aAAO,WAAP;AACD,KARD;;AASF,WAAA,+BAAA;AAAC,GArCD,EAAA;;AAAa,EAAA,OAAA,CAAA,+BAAA,GAAA,+BAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {EntryPointWithDependencies} from '../dependencies/dependency_host';\nimport {DependencyResolver, SortedEntryPointsInfo} from '../dependencies/dependency_resolver';\nimport {EntryPointManifest} from '../packages/entry_point_manifest';\nimport {PathMappings} from '../path_mappings';\n\nimport {EntryPointCollector} from './entry_point_collector';\nimport {EntryPointFinder} from './interface';\nimport {getBasePaths, trackDuration} from './utils';\n\n/**\n * An EntryPointFinder that searches for all entry-points that can be found given a `basePath` and\n * `pathMappings`.\n */\nexport class DirectoryWalkerEntryPointFinder implements EntryPointFinder {\n  private basePaths = getBasePaths(this.logger, this.sourceDirectory, this.pathMappings);\n  constructor(\n      private logger: Logger, private resolver: DependencyResolver,\n      private entryPointCollector: EntryPointCollector,\n      private entryPointManifest: EntryPointManifest, private sourceDirectory: AbsoluteFsPath,\n      private pathMappings: PathMappings|undefined) {}\n\n  /**\n   * Search the `sourceDirectory`, and sub-directories, using `pathMappings` as necessary, to find\n   * all package entry-points.\n   */\n  findEntryPoints(): SortedEntryPointsInfo {\n    const unsortedEntryPoints: EntryPointWithDependencies[] = [];\n    for (const basePath of this.basePaths) {\n      const entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) ||\n          this.walkBasePathForPackages(basePath);\n      entryPoints.forEach(e => unsortedEntryPoints.push(e));\n    }\n    return this.resolver.sortEntryPointsByDependency(unsortedEntryPoints);\n  }\n\n  /**\n   * Search the `basePath` for possible Angular packages and entry-points.\n   *\n   * @param basePath The path at which to start the search.\n   * @returns an array of `EntryPoint`s that were found within `basePath`.\n   */\n  walkBasePathForPackages(basePath: AbsoluteFsPath): EntryPointWithDependencies[] {\n    this.logger.debug(\n        `No manifest found for ${basePath} so walking the directories for entry-points.`);\n    const entryPoints = trackDuration(\n        () => this.entryPointCollector.walkDirectoryForPackages(basePath),\n        duration => this.logger.debug(`Walking ${basePath} for entry-points took ${duration}s.`));\n    this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);\n    return entryPoints;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}