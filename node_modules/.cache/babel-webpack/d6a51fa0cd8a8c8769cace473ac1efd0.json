{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar log = require('./logger').create();\n\nvar Executor = /*#__PURE__*/function () {\n  function Executor(capturedBrowsers, config, emitter) {\n    var _this = this;\n\n    _classCallCheck(this, Executor);\n\n    this.capturedBrowsers = capturedBrowsers;\n    this.config = config;\n    this.emitter = emitter;\n    this.executionScheduled = false;\n    this.errorsScheduled = [];\n    this.pendingCount = 0;\n    this.runningBrowsers = null;\n    this.emitter.on('run_complete', function () {\n      return _this.onRunComplete();\n    });\n    this.emitter.on('browser_complete', function () {\n      return _this.onBrowserComplete();\n    });\n  }\n\n  _createClass(Executor, [{\n    key: \"schedule\",\n    value: function schedule() {\n      if (this.capturedBrowsers.length === 0) {\n        log.warn(\"No captured browser, open \".concat(this.config.protocol, \"//\").concat(this.config.hostname, \":\").concat(this.config.port).concat(this.config.urlRoot));\n        return false;\n      } else if (this.capturedBrowsers.areAllReady()) {\n        log.debug('All browsers are ready, executing');\n        log.debug(\"Captured \".concat(this.capturedBrowsers.length, \" browsers\"));\n        this.executionScheduled = false;\n        this.capturedBrowsers.clearResults();\n        this.pendingCount = this.capturedBrowsers.length;\n        this.runningBrowsers = this.capturedBrowsers.clone();\n        this.emitter.emit('run_start', this.runningBrowsers);\n        this.socketIoSockets.emit('execute', this.config.client);\n        return true;\n      } else {\n        log.info('Delaying execution, these browsers are not ready: ' + this.capturedBrowsers.getNonReady().join(', '));\n        this.executionScheduled = true;\n        return false;\n      }\n    }\n    /**\n     * Schedule an error to be reported\n     * @param {string} errorMessage\n     * @returns {boolean} a boolean indicating whether or not the error was handled synchronously\n     */\n\n  }, {\n    key: \"scheduleError\",\n    value: function scheduleError(errorMessage) {\n      // We don't want to interfere with any running test.\n      // Verify that no test is running before reporting the error.\n      if (this.capturedBrowsers.areAllReady()) {\n        log.warn(errorMessage);\n        var errorResult = {\n          success: 0,\n          failed: 0,\n          skipped: 0,\n          error: errorMessage,\n          exitCode: 1\n        };\n        var noBrowsersStartedTests = [];\n        this.emitter.emit('run_start', noBrowsersStartedTests); // A run cannot complete without being started\n\n        this.emitter.emit('run_complete', noBrowsersStartedTests, errorResult);\n        return true;\n      } else {\n        this.errorsScheduled.push(errorMessage);\n        return false;\n      }\n    }\n  }, {\n    key: \"onRunComplete\",\n    value: function onRunComplete() {\n      var _this2 = this;\n\n      if (this.executionScheduled) {\n        this.schedule();\n      }\n\n      if (this.errorsScheduled.length) {\n        var errorsToReport = this.errorsScheduled;\n        this.errorsScheduled = [];\n        errorsToReport.forEach(function (error) {\n          return _this2.scheduleError(error);\n        });\n      }\n    }\n  }, {\n    key: \"onBrowserComplete\",\n    value: function onBrowserComplete() {\n      var _this3 = this;\n\n      this.pendingCount--;\n\n      if (!this.pendingCount) {\n        // Ensure run_complete is emitted in the next tick\n        // so it is never emitted before browser_complete\n        setTimeout(function () {\n          _this3.emitter.emit('run_complete', _this3.runningBrowsers, _this3.runningBrowsers.getResults());\n        });\n      }\n    }\n  }]);\n\n  return Executor;\n}();\n\nExecutor.factory = function (capturedBrowsers, config, emitter) {\n  return new Executor(capturedBrowsers, config, emitter);\n};\n\nmodule.exports = Executor;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/karma/lib/executor.js"],"names":["log","require","create","Executor","capturedBrowsers","config","emitter","executionScheduled","errorsScheduled","pendingCount","runningBrowsers","on","onRunComplete","onBrowserComplete","length","warn","protocol","hostname","port","urlRoot","areAllReady","debug","clearResults","clone","emit","socketIoSockets","client","info","getNonReady","join","errorMessage","errorResult","success","failed","skipped","error","exitCode","noBrowsersStartedTests","push","schedule","errorsToReport","forEach","scheduleError","setTimeout","getResults","factory","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst log = require('./logger').create()\n\nclass Executor {\n  constructor (capturedBrowsers, config, emitter) {\n    this.capturedBrowsers = capturedBrowsers\n    this.config = config\n    this.emitter = emitter\n\n    this.executionScheduled = false\n    this.errorsScheduled = []\n    this.pendingCount = 0\n    this.runningBrowsers = null\n\n    this.emitter.on('run_complete', () => this.onRunComplete())\n    this.emitter.on('browser_complete', () => this.onBrowserComplete())\n  }\n\n  schedule () {\n    if (this.capturedBrowsers.length === 0) {\n      log.warn(`No captured browser, open ${this.config.protocol}//${this.config.hostname}:${this.config.port}${this.config.urlRoot}`)\n      return false\n    } else if (this.capturedBrowsers.areAllReady()) {\n      log.debug('All browsers are ready, executing')\n      log.debug(`Captured ${this.capturedBrowsers.length} browsers`)\n      this.executionScheduled = false\n      this.capturedBrowsers.clearResults()\n      this.pendingCount = this.capturedBrowsers.length\n      this.runningBrowsers = this.capturedBrowsers.clone()\n      this.emitter.emit('run_start', this.runningBrowsers)\n      this.socketIoSockets.emit('execute', this.config.client)\n      return true\n    } else {\n      log.info('Delaying execution, these browsers are not ready: ' + this.capturedBrowsers.getNonReady().join(', '))\n      this.executionScheduled = true\n      return false\n    }\n  }\n\n  /**\n   * Schedule an error to be reported\n   * @param {string} errorMessage\n   * @returns {boolean} a boolean indicating whether or not the error was handled synchronously\n   */\n  scheduleError (errorMessage) {\n    // We don't want to interfere with any running test.\n    // Verify that no test is running before reporting the error.\n    if (this.capturedBrowsers.areAllReady()) {\n      log.warn(errorMessage)\n      const errorResult = {\n        success: 0,\n        failed: 0,\n        skipped: 0,\n        error: errorMessage,\n        exitCode: 1\n      }\n      const noBrowsersStartedTests = []\n      this.emitter.emit('run_start', noBrowsersStartedTests) // A run cannot complete without being started\n      this.emitter.emit('run_complete', noBrowsersStartedTests, errorResult)\n      return true\n    } else {\n      this.errorsScheduled.push(errorMessage)\n      return false\n    }\n  }\n\n  onRunComplete () {\n    if (this.executionScheduled) {\n      this.schedule()\n    }\n    if (this.errorsScheduled.length) {\n      const errorsToReport = this.errorsScheduled\n      this.errorsScheduled = []\n      errorsToReport.forEach((error) => this.scheduleError(error))\n    }\n  }\n\n  onBrowserComplete () {\n    this.pendingCount--\n\n    if (!this.pendingCount) {\n      // Ensure run_complete is emitted in the next tick\n      // so it is never emitted before browser_complete\n      setTimeout(() => {\n        this.emitter.emit('run_complete', this.runningBrowsers, this.runningBrowsers.getResults())\n      })\n    }\n  }\n}\n\nExecutor.factory = function (capturedBrowsers, config, emitter) {\n  return new Executor(capturedBrowsers, config, emitter)\n}\n\nmodule.exports = Executor\n"]},"metadata":{},"sourceType":"script"}