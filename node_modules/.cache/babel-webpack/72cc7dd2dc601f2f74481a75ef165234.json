{"ast":null,"code":"var _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\n/* eslint no-underscore-dangle:0 */\nvar debug = require(\"debug\")(\"log4js:logger\");\n\nvar LoggingEvent = require(\"./LoggingEvent\");\n\nvar levels = require(\"./levels\");\n\nvar clustering = require(\"./clustering\");\n\nvar categories = require(\"./categories\");\n\nvar configuration = require(\"./configuration\");\n\nvar stackReg = /at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\n\nfunction defaultParseCallStack(data) {\n  var skipIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4;\n  var stacklines = data.stack.split(\"\\n\").slice(skipIdx);\n  var lineMatch = stackReg.exec(stacklines[0]);\n\n  if (lineMatch && lineMatch.length === 6) {\n    return {\n      functionName: lineMatch[1],\n      fileName: lineMatch[2],\n      lineNumber: parseInt(lineMatch[3], 10),\n      columnNumber: parseInt(lineMatch[4], 10),\n      callStack: stacklines.join(\"\\n\")\n    };\n  }\n\n  return null;\n}\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\n\n\nvar Logger = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Logger(name) {\n    _classCallCheck(this, Logger);\n\n    if (!name) {\n      throw new Error(\"No category provided.\");\n    }\n\n    this.category = name;\n    this.context = {};\n    this.parseCallStack = defaultParseCallStack;\n    debug(\"Logger created (\".concat(this.category, \", \").concat(this.level, \")\"));\n  }\n\n  _createClass(Logger, [{\n    key: \"level\",\n    get: function get() {\n      return levels.getLevel(categories.getLevelForCategory(this.category), levels.TRACE);\n    },\n    set: function set(level) {\n      categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));\n    }\n  }, {\n    key: \"useCallStack\",\n    get: function get() {\n      return categories.getEnableCallStackForCategory(this.category);\n    },\n    set: function set(bool) {\n      categories.setEnableCallStackForCategory(this.category, bool === true);\n    }\n  }, {\n    key: \"log\",\n    value: function log(level) {\n      var logLevel = levels.getLevel(level, levels.INFO);\n\n      if (this.isLevelEnabled(logLevel)) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        this._log(logLevel, args);\n      }\n    }\n  }, {\n    key: \"isLevelEnabled\",\n    value: function isLevelEnabled(otherLevel) {\n      return this.level.isLessThanOrEqualTo(otherLevel);\n    }\n  }, {\n    key: \"_log\",\n    value: function _log(level, data) {\n      debug(\"sending log data (\".concat(level, \") to appenders\"));\n      var loggingEvent = new LoggingEvent(this.category, level, data, this.context, this.useCallStack && this.parseCallStack(new Error()));\n      clustering.send(loggingEvent);\n    }\n  }, {\n    key: \"addContext\",\n    value: function addContext(key, value) {\n      this.context[key] = value;\n    }\n  }, {\n    key: \"removeContext\",\n    value: function removeContext(key) {\n      delete this.context[key];\n    }\n  }, {\n    key: \"clearContext\",\n    value: function clearContext() {\n      this.context = {};\n    }\n  }, {\n    key: \"setParseCallStackFunction\",\n    value: function setParseCallStackFunction(parseFunction) {\n      this.parseCallStack = parseFunction;\n    }\n  }]);\n\n  return Logger;\n}();\n\nfunction addLevelMethods(target) {\n  var level = levels.getLevel(target);\n  var levelStrLower = level.toString().toLowerCase();\n  var levelMethod = levelStrLower.replace(/_([a-z])/g, function (g) {\n    return g[1].toUpperCase();\n  });\n  var isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[\"is\".concat(isLevelMethod, \"Enabled\")] = function () {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    this.log.apply(this, [level].concat(args));\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\nconfiguration.addListener(function () {\n  levels.levels.forEach(addLevelMethods);\n});\nmodule.exports = Logger;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/log4js/lib/logger.js"],"names":["debug","require","LoggingEvent","levels","clustering","categories","configuration","stackReg","defaultParseCallStack","data","skipIdx","stacklines","stack","split","slice","lineMatch","exec","length","functionName","fileName","lineNumber","parseInt","columnNumber","callStack","join","Logger","name","Error","category","context","parseCallStack","level","getLevel","getLevelForCategory","TRACE","setLevelForCategory","getEnableCallStackForCategory","bool","setEnableCallStackForCategory","logLevel","INFO","isLevelEnabled","args","_log","otherLevel","isLessThanOrEqualTo","loggingEvent","useCallStack","send","key","value","parseFunction","addLevelMethods","target","levelStrLower","toString","toLowerCase","levelMethod","replace","g","toUpperCase","isLevelMethod","prototype","log","forEach","addListener","module","exports"],"mappings":"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","sourcesContent":["/* eslint no-underscore-dangle:0 */\nconst debug = require(\"debug\")(\"log4js:logger\");\nconst LoggingEvent = require(\"./LoggingEvent\");\nconst levels = require(\"./levels\");\nconst clustering = require(\"./clustering\");\nconst categories = require(\"./categories\");\nconst configuration = require(\"./configuration\");\n\nconst stackReg = /at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/;\nfunction defaultParseCallStack(data, skipIdx = 4) {\n  const stacklines = data.stack.split(\"\\n\").slice(skipIdx);\n  const lineMatch = stackReg.exec(stacklines[0]);\n  if (lineMatch && lineMatch.length === 6) {\n    return {\n      functionName: lineMatch[1],\n      fileName: lineMatch[2],\n      lineNumber: parseInt(lineMatch[3], 10),\n      columnNumber: parseInt(lineMatch[4], 10),\n      callStack: stacklines.join(\"\\n\")\n    };\n  }\n  return null;\n}\n\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error(\"No category provided.\");\n    }\n    this.category = name;\n    this.context = {};\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n\n  get level() {\n    return levels.getLevel(\n      categories.getLevelForCategory(this.category),\n      levels.TRACE\n    );\n  }\n\n  set level(level) {\n    categories.setLevelForCategory(\n      this.category,\n      levels.getLevel(level, this.level)\n    );\n  }\n\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level, levels.INFO);\n    if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const loggingEvent = new LoggingEvent(\n      this.category,\n      level,\n      data,\n      this.context,\n      this.useCallStack && this.parseCallStack(new Error())\n    );\n    clustering.send(loggingEvent);\n  }\n\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n\n  removeContext(key) {\n    delete this.context[key];\n  }\n\n  clearContext() {\n    this.context = {};\n  }\n\n  setParseCallStackFunction(parseFunction) {\n    this.parseCallStack = parseFunction;\n  }\n}\n\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, g =>\n    g[1].toUpperCase()\n  );\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function() {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function(...args) {\n    this.log(level, ...args);\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\n\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\n\nmodule.exports = Logger;\n"]},"metadata":{},"sourceType":"script"}