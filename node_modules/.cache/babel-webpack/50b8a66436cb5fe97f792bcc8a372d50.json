{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/annotations/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.checkInheritanceOfDirective = exports.getUndecoratedClassWithAngularFeaturesDiagnostic = exports.getDirectiveDiagnostics = exports.getProviderDiagnostics = exports.createValueHasWrongTypeError = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var partial_evaluator_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/util\");\n  /**\n   * Creates a `FatalDiagnosticError` for a node that did not evaluate to the expected type. The\n   * diagnostic that is created will include details on why the value is incorrect, i.e. it includes\n   * a representation of the actual type that was unsupported, or in the case of a dynamic value the\n   * trace to the node where the dynamic value originated.\n   *\n   * @param node The node for which the diagnostic should be produced.\n   * @param value The evaluated value that has the wrong type.\n   * @param messageText The message text of the error.\n   */\n\n\n  function createValueHasWrongTypeError(node, value, messageText) {\n    var _a;\n\n    var chainedMessage;\n    var relatedInformation;\n\n    if (value instanceof partial_evaluator_1.DynamicValue) {\n      chainedMessage = 'Value could not be determined statically.';\n      relatedInformation = partial_evaluator_1.traceDynamicValue(node, value);\n    } else if (value instanceof imports_1.Reference) {\n      var target = value.debugName !== null ? \"'\" + value.debugName + \"'\" : 'an anonymous declaration';\n      chainedMessage = \"Value is a reference to \" + target + \".\";\n      var referenceNode = (_a = typescript_1.identifierOfNode(value.node)) !== null && _a !== void 0 ? _a : value.node;\n      relatedInformation = [diagnostics_1.makeRelatedInformation(referenceNode, 'Reference is declared here.')];\n    } else {\n      chainedMessage = \"Value is of type '\" + partial_evaluator_1.describeResolvedType(value) + \"'.\";\n    }\n\n    var chain = {\n      messageText: messageText,\n      category: ts.DiagnosticCategory.Error,\n      code: 0,\n      next: [{\n        messageText: chainedMessage,\n        category: ts.DiagnosticCategory.Message,\n        code: 0\n      }]\n    };\n    return new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);\n  }\n\n  exports.createValueHasWrongTypeError = createValueHasWrongTypeError;\n  /**\n   * Gets the diagnostics for a set of provider classes.\n   * @param providerClasses Classes that should be checked.\n   * @param providersDeclaration Node that declares the providers array.\n   * @param registry Registry that keeps track of the registered injectable classes.\n   */\n\n  function getProviderDiagnostics(providerClasses, providersDeclaration, registry) {\n    var e_1, _a;\n\n    var diagnostics = [];\n\n    try {\n      for (var providerClasses_1 = tslib_1.__values(providerClasses), providerClasses_1_1 = providerClasses_1.next(); !providerClasses_1_1.done; providerClasses_1_1 = providerClasses_1.next()) {\n        var provider = providerClasses_1_1.value;\n\n        if (registry.isInjectable(provider.node)) {\n          continue;\n        }\n\n        var contextNode = provider.getOriginForDiagnostics(providersDeclaration);\n        diagnostics.push(diagnostics_1.makeDiagnostic(diagnostics_1.ErrorCode.UNDECORATED_PROVIDER, contextNode, \"The class '\" + provider.node.name.text + \"' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.\\n\\nEither add the @Injectable() decorator to '\" + provider.node.name.text + \"', or configure a different provider (such as a provider with 'useFactory').\\n\", [diagnostics_1.makeRelatedInformation(provider.node, \"'\" + provider.node.name.text + \"' is declared here.\")]));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (providerClasses_1_1 && !providerClasses_1_1.done && (_a = providerClasses_1.return)) _a.call(providerClasses_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return diagnostics;\n  }\n\n  exports.getProviderDiagnostics = getProviderDiagnostics;\n\n  function getDirectiveDiagnostics(node, reader, evaluator, reflector, scopeRegistry, kind) {\n    var diagnostics = [];\n\n    var addDiagnostics = function addDiagnostics(more) {\n      if (more === null) {\n        return;\n      } else if (diagnostics === null) {\n        diagnostics = Array.isArray(more) ? more : [more];\n      } else if (Array.isArray(more)) {\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(more));\n      } else {\n        diagnostics.push(more);\n      }\n    };\n\n    var duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);\n\n    if (duplicateDeclarations !== null) {\n      addDiagnostics(util_1.makeDuplicateDeclarationError(node, duplicateDeclarations, kind));\n    }\n\n    addDiagnostics(checkInheritanceOfDirective(node, reader, reflector, evaluator));\n    return diagnostics;\n  }\n\n  exports.getDirectiveDiagnostics = getDirectiveDiagnostics;\n\n  function getUndecoratedClassWithAngularFeaturesDiagnostic(node) {\n    return diagnostics_1.makeDiagnostic(diagnostics_1.ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name, \"Class is using Angular features but is not decorated. Please add an explicit \" + \"Angular decorator.\");\n  }\n\n  exports.getUndecoratedClassWithAngularFeaturesDiagnostic = getUndecoratedClassWithAngularFeaturesDiagnostic;\n\n  function checkInheritanceOfDirective(node, reader, reflector, evaluator) {\n    if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {\n      // We should skip nodes that aren't classes. If a constructor exists, then no base class\n      // definition is required on the runtime side - it's legal to inherit from any class.\n      return null;\n    } // The extends clause is an expression which can be as dynamic as the user wants. Try to\n    // evaluate it, but fall back on ignoring the clause if it can't be understood. This is a View\n    // Engine compatibility hack: View Engine ignores 'extends' expressions that it cannot understand.\n\n\n    var baseClass = util_1.readBaseClass(node, reflector, evaluator);\n\n    while (baseClass !== null) {\n      if (baseClass === 'dynamic') {\n        return null;\n      } // We can skip the base class if it has metadata.\n\n\n      var baseClassMeta = reader.getDirectiveMetadata(baseClass);\n\n      if (baseClassMeta !== null) {\n        return null;\n      } // If the base class has a blank constructor we can skip it since it can't be using DI.\n\n\n      var baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);\n      var newParentClass = util_1.readBaseClass(baseClass.node, reflector, evaluator);\n\n      if (baseClassConstructorParams !== null && baseClassConstructorParams.length > 0) {\n        // This class has a non-trivial constructor, that's an error!\n        return getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader);\n      } else if (baseClassConstructorParams !== null || newParentClass === null) {\n        // This class has a trivial constructor, or no constructor + is the\n        // top of the inheritance chain, so it's okay.\n        return null;\n      } // Go up the chain and continue\n\n\n      baseClass = newParentClass;\n    }\n\n    return null;\n  }\n\n  exports.checkInheritanceOfDirective = checkInheritanceOfDirective;\n\n  function getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader) {\n    var subclassMeta = reader.getDirectiveMetadata(new imports_1.Reference(node));\n    var dirOrComp = subclassMeta.isComponent ? 'Component' : 'Directive';\n    var baseClassName = baseClass.debugName;\n    return diagnostics_1.makeDiagnostic(diagnostics_1.ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name, \"The \" + dirOrComp.toLowerCase() + \" \" + node.name.text + \" inherits its constructor from \" + baseClassName + \", \" + \"but the latter does not have an Angular decorator of its own. Dependency injection will not be able to \" + (\"resolve the parameters of \" + baseClassName + \"'s constructor. Either add a @Directive decorator \") + (\"to \" + baseClassName + \", or add an explicit constructor to \" + node.name.text + \".\"));\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/diagnostics.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\nimport {Reference} from '../../imports';\nimport {InjectableClassRegistry, MetadataReader} from '../../metadata';\nimport {describeResolvedType, DynamicValue, PartialEvaluator, ResolvedValue, traceDynamicValue} from '../../partial_evaluator';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {LocalModuleScopeRegistry} from '../../scope';\nimport {identifierOfNode} from '../../util/src/typescript';\n\nimport {makeDuplicateDeclarationError, readBaseClass} from './util';\n\n/**\n * Creates a `FatalDiagnosticError` for a node that did not evaluate to the expected type. The\n * diagnostic that is created will include details on why the value is incorrect, i.e. it includes\n * a representation of the actual type that was unsupported, or in the case of a dynamic value the\n * trace to the node where the dynamic value originated.\n *\n * @param node The node for which the diagnostic should be produced.\n * @param value The evaluated value that has the wrong type.\n * @param messageText The message text of the error.\n */\nexport function createValueHasWrongTypeError(\n    node: ts.Node, value: ResolvedValue, messageText: string): FatalDiagnosticError {\n  let chainedMessage: string;\n  let relatedInformation: ts.DiagnosticRelatedInformation[]|undefined;\n  if (value instanceof DynamicValue) {\n    chainedMessage = 'Value could not be determined statically.';\n    relatedInformation = traceDynamicValue(node, value);\n  } else if (value instanceof Reference) {\n    const target = value.debugName !== null ? `'${value.debugName}'` : 'an anonymous declaration';\n    chainedMessage = `Value is a reference to ${target}.`;\n\n    const referenceNode = identifierOfNode(value.node) ?? value.node;\n    relatedInformation = [makeRelatedInformation(referenceNode, 'Reference is declared here.')];\n  } else {\n    chainedMessage = `Value is of type '${describeResolvedType(value)}'.`;\n  }\n\n  const chain: ts.DiagnosticMessageChain = {\n    messageText,\n    category: ts.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainedMessage,\n      category: ts.DiagnosticCategory.Message,\n      code: 0,\n    }]\n  };\n\n  return new FatalDiagnosticError(ErrorCode.VALUE_HAS_WRONG_TYPE, node, chain, relatedInformation);\n}\n\n/**\n * Gets the diagnostics for a set of provider classes.\n * @param providerClasses Classes that should be checked.\n * @param providersDeclaration Node that declares the providers array.\n * @param registry Registry that keeps track of the registered injectable classes.\n */\nexport function getProviderDiagnostics(\n    providerClasses: Set<Reference<ClassDeclaration>>, providersDeclaration: ts.Expression,\n    registry: InjectableClassRegistry): ts.Diagnostic[] {\n  const diagnostics: ts.Diagnostic[] = [];\n\n  for (const provider of providerClasses) {\n    if (registry.isInjectable(provider.node)) {\n      continue;\n    }\n\n    const contextNode = provider.getOriginForDiagnostics(providersDeclaration);\n    diagnostics.push(makeDiagnostic(\n        ErrorCode.UNDECORATED_PROVIDER, contextNode,\n        `The class '${\n            provider.node.name\n                .text}' cannot be created via dependency injection, as it does not have an Angular decorator. This will result in an error at runtime.\n\nEither add the @Injectable() decorator to '${\n            provider.node.name\n                .text}', or configure a different provider (such as a provider with 'useFactory').\n`,\n        [makeRelatedInformation(provider.node, `'${provider.node.name.text}' is declared here.`)]));\n  }\n\n  return diagnostics;\n}\n\nexport function getDirectiveDiagnostics(\n    node: ClassDeclaration, reader: MetadataReader, evaluator: PartialEvaluator,\n    reflector: ReflectionHost, scopeRegistry: LocalModuleScopeRegistry,\n    kind: string): ts.Diagnostic[]|null {\n  let diagnostics: ts.Diagnostic[]|null = [];\n\n  const addDiagnostics = (more: ts.Diagnostic|ts.Diagnostic[]|null) => {\n    if (more === null) {\n      return;\n    } else if (diagnostics === null) {\n      diagnostics = Array.isArray(more) ? more : [more];\n    } else if (Array.isArray(more)) {\n      diagnostics.push(...more);\n    } else {\n      diagnostics.push(more);\n    }\n  };\n\n  const duplicateDeclarations = scopeRegistry.getDuplicateDeclarations(node);\n\n  if (duplicateDeclarations !== null) {\n    addDiagnostics(makeDuplicateDeclarationError(node, duplicateDeclarations, kind));\n  }\n\n  addDiagnostics(checkInheritanceOfDirective(node, reader, reflector, evaluator));\n  return diagnostics;\n}\n\nexport function getUndecoratedClassWithAngularFeaturesDiagnostic(node: ClassDeclaration):\n    ts.Diagnostic {\n  return makeDiagnostic(\n      ErrorCode.UNDECORATED_CLASS_USING_ANGULAR_FEATURES, node.name,\n      `Class is using Angular features but is not decorated. Please add an explicit ` +\n          `Angular decorator.`);\n}\n\nexport function checkInheritanceOfDirective(\n    node: ClassDeclaration, reader: MetadataReader, reflector: ReflectionHost,\n    evaluator: PartialEvaluator): ts.Diagnostic|null {\n  if (!reflector.isClass(node) || reflector.getConstructorParameters(node) !== null) {\n    // We should skip nodes that aren't classes. If a constructor exists, then no base class\n    // definition is required on the runtime side - it's legal to inherit from any class.\n    return null;\n  }\n\n  // The extends clause is an expression which can be as dynamic as the user wants. Try to\n  // evaluate it, but fall back on ignoring the clause if it can't be understood. This is a View\n  // Engine compatibility hack: View Engine ignores 'extends' expressions that it cannot understand.\n  let baseClass = readBaseClass(node, reflector, evaluator);\n\n  while (baseClass !== null) {\n    if (baseClass === 'dynamic') {\n      return null;\n    }\n\n    // We can skip the base class if it has metadata.\n    const baseClassMeta = reader.getDirectiveMetadata(baseClass);\n    if (baseClassMeta !== null) {\n      return null;\n    }\n\n    // If the base class has a blank constructor we can skip it since it can't be using DI.\n    const baseClassConstructorParams = reflector.getConstructorParameters(baseClass.node);\n    const newParentClass = readBaseClass(baseClass.node, reflector, evaluator);\n\n    if (baseClassConstructorParams !== null && baseClassConstructorParams.length > 0) {\n      // This class has a non-trivial constructor, that's an error!\n      return getInheritedUndecoratedCtorDiagnostic(node, baseClass, reader);\n    } else if (baseClassConstructorParams !== null || newParentClass === null) {\n      // This class has a trivial constructor, or no constructor + is the\n      // top of the inheritance chain, so it's okay.\n      return null;\n    }\n\n    // Go up the chain and continue\n    baseClass = newParentClass;\n  }\n\n  return null;\n}\n\nfunction getInheritedUndecoratedCtorDiagnostic(\n    node: ClassDeclaration, baseClass: Reference, reader: MetadataReader) {\n  const subclassMeta = reader.getDirectiveMetadata(new Reference(node))!;\n  const dirOrComp = subclassMeta.isComponent ? 'Component' : 'Directive';\n  const baseClassName = baseClass.debugName;\n\n  return makeDiagnostic(\n      ErrorCode.DIRECTIVE_INHERITS_UNDECORATED_CTOR, node.name,\n      `The ${dirOrComp.toLowerCase()} ${node.name.text} inherits its constructor from ${\n          baseClassName}, ` +\n          `but the latter does not have an Angular decorator of its own. Dependency injection will not be able to ` +\n          `resolve the parameters of ${\n              baseClassName}'s constructor. Either add a @Directive decorator ` +\n          `to ${baseClassName}, or add an explicit constructor to ${node.name.text}.`);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}