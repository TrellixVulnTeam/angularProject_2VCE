{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/core/src/host\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/entry_point\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/shims\", \"@angular/compiler-cli/src/ngtsc/typecheck\", \"@angular/compiler-cli/src/ngtsc/util/src/path\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NgCompilerHost = exports.DelegatingCompilerHost = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/src/ngtsc/entry_point\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var shims_1 = require(\"@angular/compiler-cli/src/ngtsc/shims\");\n\n  var typecheck_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck\");\n\n  var path_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/path\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\"); // A persistent source of bugs in CompilerHost delegation has been the addition by TS of new,\n  // optional methods on ts.CompilerHost. Since these methods are optional, it's not a type error that\n  // the delegating host doesn't implement or delegate them. This causes subtle runtime failures. No\n  // more. This infrastructure ensures that failing to delegate a method is a compile-time error.\n\n  /**\n   * Delegates all methods of `ExtendedTsCompilerHost` to a delegate, with the exception of\n   * `getSourceFile` and `fileExists` which are implemented in `NgCompilerHost`.\n   *\n   * If a new method is added to `ts.CompilerHost` which is not delegated, a type error will be\n   * generated for this class.\n   */\n\n\n  var DelegatingCompilerHost =\n  /** @class */\n  function () {\n    function DelegatingCompilerHost(delegate) {\n      this.delegate = delegate; // Excluded are 'getSourceFile' and 'fileExists', which are actually implemented by NgCompilerHost\n      // below.\n\n      this.createHash = this.delegateMethod('createHash');\n      this.directoryExists = this.delegateMethod('directoryExists');\n      this.fileNameToModuleName = this.delegateMethod('fileNameToModuleName');\n      this.getCancellationToken = this.delegateMethod('getCancellationToken');\n      this.getCanonicalFileName = this.delegateMethod('getCanonicalFileName');\n      this.getCurrentDirectory = this.delegateMethod('getCurrentDirectory');\n      this.getDefaultLibFileName = this.delegateMethod('getDefaultLibFileName');\n      this.getDefaultLibLocation = this.delegateMethod('getDefaultLibLocation');\n      this.getDirectories = this.delegateMethod('getDirectories');\n      this.getEnvironmentVariable = this.delegateMethod('getEnvironmentVariable');\n      this.getModifiedResourceFiles = this.delegateMethod('getModifiedResourceFiles');\n      this.getNewLine = this.delegateMethod('getNewLine');\n      this.getParsedCommandLine = this.delegateMethod('getParsedCommandLine');\n      this.getSourceFileByPath = this.delegateMethod('getSourceFileByPath');\n      this.readDirectory = this.delegateMethod('readDirectory');\n      this.readFile = this.delegateMethod('readFile');\n      this.readResource = this.delegateMethod('readResource');\n      this.realpath = this.delegateMethod('realpath');\n      this.resolveModuleNames = this.delegateMethod('resolveModuleNames');\n      this.resolveTypeReferenceDirectives = this.delegateMethod('resolveTypeReferenceDirectives');\n      this.resourceNameToFileName = this.delegateMethod('resourceNameToFileName');\n      this.trace = this.delegateMethod('trace');\n      this.useCaseSensitiveFileNames = this.delegateMethod('useCaseSensitiveFileNames');\n      this.writeFile = this.delegateMethod('writeFile');\n    }\n\n    DelegatingCompilerHost.prototype.delegateMethod = function (name) {\n      return this.delegate[name] !== undefined ? this.delegate[name].bind(this.delegate) : undefined;\n    };\n\n    return DelegatingCompilerHost;\n  }();\n\n  exports.DelegatingCompilerHost = DelegatingCompilerHost;\n  /**\n   * A wrapper around `ts.CompilerHost` (plus any extension methods from `ExtendedTsCompilerHost`).\n   *\n   * In order for a consumer to include Angular compilation in their TypeScript compiler, the\n   * `ts.Program` must be created with a host that adds Angular-specific files (e.g. factories,\n   * summaries, the template type-checking file, etc) to the compilation. `NgCompilerHost` is the\n   * host implementation which supports this.\n   *\n   * The interface implementations here ensure that `NgCompilerHost` fully delegates to\n   * `ExtendedTsCompilerHost` methods whenever present.\n   */\n\n  var NgCompilerHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(NgCompilerHost, _super);\n\n    function NgCompilerHost(delegate, inputFiles, rootDirs, shimAdapter, shimTagger, entryPoint, factoryTracker, diagnostics) {\n      var _this = _super.call(this, delegate) || this;\n\n      _this.shimAdapter = shimAdapter;\n      _this.shimTagger = shimTagger;\n      _this.factoryTracker = null;\n      _this.entryPoint = null;\n      _this.factoryTracker = factoryTracker;\n      _this.entryPoint = entryPoint;\n      _this.constructionDiagnostics = diagnostics;\n      _this.inputFiles = tslib_1.__spread(inputFiles, shimAdapter.extraInputFiles);\n      _this.rootDirs = rootDirs;\n\n      if (_this.resolveModuleNames === undefined) {\n        // In order to reuse the module resolution cache during the creation of the type-check\n        // program, we'll need to provide `resolveModuleNames` if the delegate did not provide one.\n        _this.resolveModuleNames = _this.createCachedResolveModuleNamesFunction();\n      }\n\n      return _this;\n    }\n\n    Object.defineProperty(NgCompilerHost.prototype, \"ignoreForEmit\", {\n      /**\n       * Retrieves a set of `ts.SourceFile`s which should not be emitted as JS files.\n       *\n       * Available after this host is used to create a `ts.Program` (which causes all the files in the\n       * program to be enumerated).\n       */\n      get: function get() {\n        return this.shimAdapter.ignoreForEmit;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(NgCompilerHost.prototype, \"shimExtensionPrefixes\", {\n      /**\n       * Retrieve the array of shim extension prefixes for which shims were created for each original\n       * file.\n       */\n      get: function get() {\n        return this.shimAdapter.extensionPrefixes;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    /**\n     * Performs cleanup that needs to happen after a `ts.Program` has been created using this host.\n     */\n\n    NgCompilerHost.prototype.postProgramCreationCleanup = function () {\n      this.shimTagger.finalize();\n    };\n    /**\n     * Create an `NgCompilerHost` from a delegate host, an array of input filenames, and the full set\n     * of TypeScript and Angular compiler options.\n     */\n\n\n    NgCompilerHost.wrap = function (delegate, inputFiles, options, oldProgram) {\n      var e_1, _a; // TODO(alxhub): remove the fallback to allowEmptyCodegenFiles after verifying that the rest of\n      // our build tooling is no longer relying on it.\n\n\n      var allowEmptyCodegenFiles = options.allowEmptyCodegenFiles || false;\n      var shouldGenerateFactoryShims = options.generateNgFactoryShims !== undefined ? options.generateNgFactoryShims : allowEmptyCodegenFiles;\n      var shouldGenerateSummaryShims = options.generateNgSummaryShims !== undefined ? options.generateNgSummaryShims : allowEmptyCodegenFiles;\n      var topLevelShimGenerators = [];\n      var perFileShimGenerators = [];\n\n      if (shouldGenerateSummaryShims) {\n        // Summary generation.\n        perFileShimGenerators.push(new shims_1.SummaryGenerator());\n      }\n\n      var factoryTracker = null;\n\n      if (shouldGenerateFactoryShims) {\n        var factoryGenerator = new shims_1.FactoryGenerator();\n        perFileShimGenerators.push(factoryGenerator);\n        factoryTracker = factoryGenerator;\n      }\n\n      var rootDirs = typescript_1.getRootDirs(delegate, options);\n      perFileShimGenerators.push(new typecheck_1.TypeCheckShimGenerator());\n      var diagnostics = [];\n      var normalizedTsInputFiles = [];\n\n      try {\n        for (var inputFiles_1 = tslib_1.__values(inputFiles), inputFiles_1_1 = inputFiles_1.next(); !inputFiles_1_1.done; inputFiles_1_1 = inputFiles_1.next()) {\n          var inputFile = inputFiles_1_1.value;\n\n          if (!typescript_1.isNonDeclarationTsPath(inputFile)) {\n            continue;\n          }\n\n          normalizedTsInputFiles.push(file_system_1.resolve(inputFile));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (inputFiles_1_1 && !inputFiles_1_1.done && (_a = inputFiles_1.return)) _a.call(inputFiles_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var entryPoint = null;\n\n      if (options.flatModuleOutFile != null && options.flatModuleOutFile !== '') {\n        entryPoint = entry_point_1.findFlatIndexEntryPoint(normalizedTsInputFiles);\n\n        if (entryPoint === null) {\n          // This error message talks specifically about having a single .ts file in \"files\". However\n          // the actual logic is a bit more permissive. If a single file exists, that will be taken,\n          // otherwise the highest level (shortest path) \"index.ts\" file will be used as the flat\n          // module entry point instead. If neither of these conditions apply, the error below is\n          // given.\n          //\n          // The user is not informed about the \"index.ts\" option as this behavior is deprecated -\n          // an explicit entrypoint should always be specified.\n          diagnostics.push({\n            category: ts.DiagnosticCategory.Error,\n            code: diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.CONFIG_FLAT_MODULE_NO_INDEX),\n            file: undefined,\n            start: undefined,\n            length: undefined,\n            messageText: 'Angular compiler option \"flatModuleOutFile\" requires one and only one .ts file in the \"files\" field.'\n          });\n        } else {\n          var flatModuleId = options.flatModuleId || null;\n          var flatModuleOutFile = path_1.normalizeSeparators(options.flatModuleOutFile);\n          var flatIndexGenerator = new entry_point_1.FlatIndexGenerator(entryPoint, flatModuleOutFile, flatModuleId);\n          topLevelShimGenerators.push(flatIndexGenerator);\n        }\n      }\n\n      var shimAdapter = new shims_1.ShimAdapter(delegate, normalizedTsInputFiles, topLevelShimGenerators, perFileShimGenerators, oldProgram);\n      var shimTagger = new shims_1.ShimReferenceTagger(perFileShimGenerators.map(function (gen) {\n        return gen.extensionPrefix;\n      }));\n      return new NgCompilerHost(delegate, inputFiles, rootDirs, shimAdapter, shimTagger, entryPoint, factoryTracker, diagnostics);\n    };\n    /**\n     * Check whether the given `ts.SourceFile` is a shim file.\n     *\n     * If this returns false, the file is user-provided.\n     */\n\n\n    NgCompilerHost.prototype.isShim = function (sf) {\n      return shims_1.isShim(sf);\n    };\n\n    NgCompilerHost.prototype.getSourceFile = function (fileName, languageVersion, onError, shouldCreateNewSourceFile) {\n      // Is this a previously known shim?\n      var shimSf = this.shimAdapter.maybeGenerate(file_system_1.resolve(fileName));\n\n      if (shimSf !== null) {\n        // Yes, so return it.\n        return shimSf;\n      } // No, so it's a file which might need shims (or a file which doesn't exist).\n\n\n      var sf = this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n\n      if (sf === undefined) {\n        return undefined;\n      }\n\n      this.shimTagger.tag(sf);\n      return sf;\n    };\n\n    NgCompilerHost.prototype.fileExists = function (fileName) {\n      // Consider the file as existing whenever\n      //  1) it really does exist in the delegate host, or\n      //  2) at least one of the shim generators recognizes it\n      // Note that we can pass the file name as branded absolute fs path because TypeScript\n      // internally only passes POSIX-like paths.\n      //\n      // Also note that the `maybeGenerate` check below checks for both `null` and `undefined`.\n      return this.delegate.fileExists(fileName) || this.shimAdapter.maybeGenerate(file_system_1.resolve(fileName)) != null;\n    };\n\n    Object.defineProperty(NgCompilerHost.prototype, \"unifiedModulesHost\", {\n      get: function get() {\n        return this.fileNameToModuleName !== undefined ? this : null;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    NgCompilerHost.prototype.createCachedResolveModuleNamesFunction = function () {\n      var _this = this;\n\n      var moduleResolutionCache = ts.createModuleResolutionCache(this.getCurrentDirectory(), this.getCanonicalFileName.bind(this));\n      return function (moduleNames, containingFile, reusedNames, redirectedReference, options) {\n        return moduleNames.map(function (moduleName) {\n          var module = ts.resolveModuleName(moduleName, containingFile, options, _this, moduleResolutionCache, redirectedReference);\n          return module.resolvedModule;\n        });\n      };\n    };\n\n    return NgCompilerHost;\n  }(DelegatingCompilerHost);\n\n  exports.NgCompilerHost = NgCompilerHost;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/core/src/host.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,2CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,+CAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,qDAAA,CAAA,C,CAGA;AACA;AACA;AACA;;AAEA;;;;;;AAMG;;;AACH,MAAA,sBAAA;AAAA;AAAA,cAAA;AAEE,aAAA,sBAAA,CAAsB,QAAtB,EAAsD;AAAhC,WAAA,QAAA,GAAA,QAAA,CAAgC,CAQtD;AACA;;AACA,WAAA,UAAA,GAAa,KAAK,cAAL,CAAoB,YAApB,CAAb;AACA,WAAA,eAAA,GAAkB,KAAK,cAAL,CAAoB,iBAApB,CAAlB;AACA,WAAA,oBAAA,GAAuB,KAAK,cAAL,CAAoB,sBAApB,CAAvB;AACA,WAAA,oBAAA,GAAuB,KAAK,cAAL,CAAoB,sBAApB,CAAvB;AACA,WAAA,oBAAA,GAAuB,KAAK,cAAL,CAAoB,sBAApB,CAAvB;AACA,WAAA,mBAAA,GAAsB,KAAK,cAAL,CAAoB,qBAApB,CAAtB;AACA,WAAA,qBAAA,GAAwB,KAAK,cAAL,CAAoB,uBAApB,CAAxB;AACA,WAAA,qBAAA,GAAwB,KAAK,cAAL,CAAoB,uBAApB,CAAxB;AACA,WAAA,cAAA,GAAiB,KAAK,cAAL,CAAoB,gBAApB,CAAjB;AACA,WAAA,sBAAA,GAAyB,KAAK,cAAL,CAAoB,wBAApB,CAAzB;AACA,WAAA,wBAAA,GAA2B,KAAK,cAAL,CAAoB,0BAApB,CAA3B;AACA,WAAA,UAAA,GAAa,KAAK,cAAL,CAAoB,YAApB,CAAb;AACA,WAAA,oBAAA,GAAuB,KAAK,cAAL,CAAoB,sBAApB,CAAvB;AACA,WAAA,mBAAA,GAAsB,KAAK,cAAL,CAAoB,qBAApB,CAAtB;AACA,WAAA,aAAA,GAAgB,KAAK,cAAL,CAAoB,eAApB,CAAhB;AACA,WAAA,QAAA,GAAW,KAAK,cAAL,CAAoB,UAApB,CAAX;AACA,WAAA,YAAA,GAAe,KAAK,cAAL,CAAoB,cAApB,CAAf;AACA,WAAA,QAAA,GAAW,KAAK,cAAL,CAAoB,UAApB,CAAX;AACA,WAAA,kBAAA,GAAqB,KAAK,cAAL,CAAoB,oBAApB,CAArB;AACA,WAAA,8BAAA,GAAiC,KAAK,cAAL,CAAoB,gCAApB,CAAjC;AACA,WAAA,sBAAA,GAAyB,KAAK,cAAL,CAAoB,wBAApB,CAAzB;AACA,WAAA,KAAA,GAAQ,KAAK,cAAL,CAAoB,OAApB,CAAR;AACA,WAAA,yBAAA,GAA4B,KAAK,cAAL,CAAoB,2BAApB,CAA5B;AACA,WAAA,SAAA,GAAY,KAAK,cAAL,CAAoB,WAApB,CAAZ;AAjC0D;;AAElD,IAAA,sBAAA,CAAA,SAAA,CAAA,cAAA,GAAR,UAA+D,IAA/D,EAAsE;AAEpE,aAAO,KAAK,QAAL,CAAc,IAAd,MAAwB,SAAxB,GAAqC,KAAK,QAAL,CAAc,IAAd,EAA4B,IAA5B,CAAiC,KAAK,QAAtC,CAArC,GACoC,SAD3C;AAED,KAJO;;AAgCV,WAAA,sBAAA;AAAC,GApCD,EAAA;;AAAa,EAAA,OAAA,CAAA,sBAAA,GAAA,sBAAA;AAsCb;;;;;;;;;;AAUG;;AACH,MAAA,cAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAoC,IAAA,OAAA,CAAA,SAAA,CAAA,cAAA,EAAA,MAAA;;AAUlC,aAAA,cAAA,CACI,QADJ,EACsC,UADtC,EAEI,QAFJ,EAEqD,WAFrD,EAGY,UAHZ,EAG6C,UAH7C,EAII,cAJJ,EAIyC,WAJzC,EAIqE;AAJrE,UAAA,KAAA,GAKE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,QAAN,KAAe,IALjB;;AAEqD,MAAA,KAAA,CAAA,WAAA,GAAA,WAAA;AACzC,MAAA,KAAA,CAAA,UAAA,GAAA,UAAA;AAXH,MAAA,KAAA,CAAA,cAAA,GAAsC,IAAtC;AACA,MAAA,KAAA,CAAA,UAAA,GAAkC,IAAlC;AAcP,MAAA,KAAI,CAAC,cAAL,GAAsB,cAAtB;AACA,MAAA,KAAI,CAAC,UAAL,GAAkB,UAAlB;AACA,MAAA,KAAI,CAAC,uBAAL,GAA+B,WAA/B;AACA,MAAA,KAAI,CAAC,UAAL,GAAe,OAAA,CAAA,QAAA,CAAO,UAAP,EAAsB,WAAW,CAAC,eAAlC,CAAf;AACA,MAAA,KAAI,CAAC,QAAL,GAAgB,QAAhB;;AAEA,UAAI,KAAI,CAAC,kBAAL,KAA4B,SAAhC,EAA2C;AACzC;AACA;AACA,QAAA,KAAI,CAAC,kBAAL,GAA0B,KAAI,CAAC,sCAAL,EAA1B;AACD;;;AACF;;AAQD,IAAA,MAAA,CAAA,cAAA,CAAI,cAAA,CAAA,SAAJ,EAAI,eAAJ,EAAiB;AANjB;;;;;AAKG;WACH,eAAA;AACE,eAAO,KAAK,WAAL,CAAiB,aAAxB;AACD,OAFgB;uBAAA;;AAAA,KAAjB;AAQA,IAAA,MAAA,CAAA,cAAA,CAAI,cAAA,CAAA,SAAJ,EAAI,uBAAJ,EAAyB;AAJzB;;;AAGG;WACH,eAAA;AACE,eAAO,KAAK,WAAL,CAAiB,iBAAxB;AACD,OAFwB;uBAAA;;AAAA,KAAzB;AAIA;;AAEG;;AACH,IAAA,cAAA,CAAA,SAAA,CAAA,0BAAA,GAAA,YAAA;AACE,WAAK,UAAL,CAAgB,QAAhB;AACD,KAFD;AAIA;;;AAGG;;;AACI,IAAA,cAAA,CAAA,IAAA,GAAP,UACI,QADJ,EAC+B,UAD/B,EACkE,OADlE,EAEI,UAFJ,EAE+B;kBAAA,CAC7B;AACA;;;AACA,UAAM,sBAAsB,GAAG,OAAO,CAAC,sBAAR,IAAkC,KAAjE;AACA,UAAM,0BAA0B,GAAG,OAAO,CAAC,sBAAR,KAAmC,SAAnC,GAC/B,OAAO,CAAC,sBADuB,GAE/B,sBAFJ;AAIA,UAAM,0BAA0B,GAAG,OAAO,CAAC,sBAAR,KAAmC,SAAnC,GAC/B,OAAO,CAAC,sBADuB,GAE/B,sBAFJ;AAKA,UAAM,sBAAsB,GAA4B,EAAxD;AACA,UAAM,qBAAqB,GAA2B,EAAtD;;AAEA,UAAI,0BAAJ,EAAgC;AAC9B;AACA,QAAA,qBAAqB,CAAC,IAAtB,CAA2B,IAAI,OAAA,CAAA,gBAAJ,EAA3B;AACD;;AAED,UAAI,cAAc,GAAwB,IAA1C;;AACA,UAAI,0BAAJ,EAAgC;AAC9B,YAAM,gBAAgB,GAAG,IAAI,OAAA,CAAA,gBAAJ,EAAzB;AACA,QAAA,qBAAqB,CAAC,IAAtB,CAA2B,gBAA3B;AAEA,QAAA,cAAc,GAAG,gBAAjB;AACD;;AAED,UAAM,QAAQ,GAAG,YAAA,CAAA,WAAA,CAAY,QAAZ,EAAsB,OAAtB,CAAjB;AAEA,MAAA,qBAAqB,CAAC,IAAtB,CAA2B,IAAI,WAAA,CAAA,sBAAJ,EAA3B;AAEA,UAAI,WAAW,GAAoB,EAAnC;AAEA,UAAM,sBAAsB,GAAqB,EAAjD;;;AACA,aAAwB,IAAA,YAAA,GAAA,OAAA,CAAA,QAAA,CAAA,UAAA,CAAA,EAAU,cAAA,GAAA,YAAA,CAAA,IAAA,EAAlC,EAAkC,CAAA,cAAA,CAAA,IAAlC,EAAkC,cAAA,GAAA,YAAA,CAAA,IAAA,EAAlC,EAAoC;AAA/B,cAAM,SAAS,GAAA,cAAA,CAAA,KAAf;;AACH,cAAI,CAAC,YAAA,CAAA,sBAAA,CAAuB,SAAvB,CAAL,EAAwC;AACtC;AACD;;AACD,UAAA,sBAAsB,CAAC,IAAvB,CAA4B,aAAA,CAAA,OAAA,CAAQ,SAAR,CAA5B;AACD;;;;;;;;;;;;;AAED,UAAI,UAAU,GAAwB,IAAtC;;AACA,UAAI,OAAO,CAAC,iBAAR,IAA6B,IAA7B,IAAqC,OAAO,CAAC,iBAAR,KAA8B,EAAvE,EAA2E;AACzE,QAAA,UAAU,GAAG,aAAA,CAAA,uBAAA,CAAwB,sBAAxB,CAAb;;AACA,YAAI,UAAU,KAAK,IAAnB,EAAyB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAA,WAAW,CAAC,IAAZ,CAAiB;AACf,YAAA,QAAQ,EAAE,EAAE,CAAC,kBAAH,CAAsB,KADjB;AAEf,YAAA,IAAI,EAAE,aAAA,CAAA,WAAA,CAAY,aAAA,CAAA,SAAA,CAAU,2BAAtB,CAFS;AAGf,YAAA,IAAI,EAAE,SAHS;AAIf,YAAA,KAAK,EAAE,SAJQ;AAKf,YAAA,MAAM,EAAE,SALO;AAMf,YAAA,WAAW,EACP;AAPW,WAAjB;AASD,SAlBD,MAkBO;AACL,cAAM,YAAY,GAAG,OAAO,CAAC,YAAR,IAAwB,IAA7C;AACA,cAAM,iBAAiB,GAAG,MAAA,CAAA,mBAAA,CAAoB,OAAO,CAAC,iBAA5B,CAA1B;AACA,cAAM,kBAAkB,GACpB,IAAI,aAAA,CAAA,kBAAJ,CAAuB,UAAvB,EAAmC,iBAAnC,EAAsD,YAAtD,CADJ;AAEA,UAAA,sBAAsB,CAAC,IAAvB,CAA4B,kBAA5B;AACD;AACF;;AAED,UAAM,WAAW,GAAG,IAAI,OAAA,CAAA,WAAJ,CAChB,QADgB,EACN,sBADM,EACkB,sBADlB,EAC0C,qBAD1C,EAEhB,UAFgB,CAApB;AAGA,UAAM,UAAU,GACZ,IAAI,OAAA,CAAA,mBAAJ,CAAwB,qBAAqB,CAAC,GAAtB,CAA0B,UAAA,GAAA,EAAG;AAAI,eAAA,GAAG,CAAH,eAAA;AAAmB,OAApD,CAAxB,CADJ;AAEA,aAAO,IAAI,cAAJ,CACH,QADG,EACO,UADP,EACmB,QADnB,EAC6B,WAD7B,EAC0C,UAD1C,EACsD,UADtD,EACkE,cADlE,EAEH,WAFG,CAAP;AAGD,KAnFM;AAqFP;;;;AAIG;;;AACH,IAAA,cAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,EAAP,EAAwB;AACtB,aAAO,OAAA,CAAA,MAAA,CAAO,EAAP,CAAP;AACD,KAFD;;AAIA,IAAA,cAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UACI,QADJ,EACsB,eADtB,EAEI,OAFJ,EAGI,yBAHJ,EAGiD;AAC/C;AACA,UAAM,MAAM,GAAG,KAAK,WAAL,CAAiB,aAAjB,CAA+B,aAAA,CAAA,OAAA,CAAQ,QAAR,CAA/B,CAAf;;AACA,UAAI,MAAM,KAAK,IAAf,EAAqB;AACnB;AACA,eAAO,MAAP;AACD,OAN8C,CAQ/C;;;AACA,UAAM,EAAE,GACJ,KAAK,QAAL,CAAc,aAAd,CAA4B,QAA5B,EAAsC,eAAtC,EAAuD,OAAvD,EAAgE,yBAAhE,CADJ;;AAEA,UAAI,EAAE,KAAK,SAAX,EAAsB;AACpB,eAAO,SAAP;AACD;;AAED,WAAK,UAAL,CAAgB,GAAhB,CAAoB,EAApB;AACA,aAAO,EAAP;AACD,KApBD;;AAsBA,IAAA,cAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,QAAX,EAA2B;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAO,KAAK,QAAL,CAAc,UAAd,CAAyB,QAAzB,KACH,KAAK,WAAL,CAAiB,aAAjB,CAA+B,aAAA,CAAA,OAAA,CAAQ,QAAR,CAA/B,KAAqD,IADzD;AAED,KAVD;;AAYA,IAAA,MAAA,CAAA,cAAA,CAAI,cAAA,CAAA,SAAJ,EAAI,oBAAJ,EAAsB;WAAtB,eAAA;AACE,eAAO,KAAK,oBAAL,KAA8B,SAA9B,GAA0C,IAA1C,GAAuE,IAA9E;AACD,OAFqB;uBAAA;;AAAA,KAAtB;;AAIQ,IAAA,cAAA,CAAA,SAAA,CAAA,sCAAA,GAAR,YAAA;AAAA,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,qBAAqB,GAAG,EAAE,CAAC,2BAAH,CAC1B,KAAK,mBAAL,EAD0B,EACE,KAAK,oBAAL,CAA0B,IAA1B,CAA+B,IAA/B,CADF,CAA9B;AAGA,aAAO,UAAC,WAAD,EAAc,cAAd,EAA8B,WAA9B,EAA2C,mBAA3C,EAAgE,OAAhE,EAAuE;AAC5E,eAAO,WAAW,CAAC,GAAZ,CAAgB,UAAA,UAAA,EAAU;AAC/B,cAAM,MAAM,GAAG,EAAE,CAAC,iBAAH,CACX,UADW,EACC,cADD,EACiB,OADjB,EAC0B,KAD1B,EACgC,qBADhC,EACuD,mBADvD,CAAf;AAEA,iBAAO,MAAM,CAAC,cAAd;AACD,SAJM,CAAP;AAKD,OAND;AAOD,KAXO;;AAYV,WAAA,cAAA;AAAC,GA3MD,CAAoC,sBAApC,CAAA;;AAAa,EAAA,OAAA,CAAA,cAAA,GAAA,cAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ErrorCode, ngErrorCode} from '../../diagnostics';\nimport {findFlatIndexEntryPoint, FlatIndexGenerator} from '../../entry_point';\nimport {AbsoluteFsPath, resolve} from '../../file_system';\nimport {FactoryGenerator, isShim, ShimAdapter, ShimReferenceTagger, SummaryGenerator} from '../../shims';\nimport {FactoryTracker, PerFileShimGenerator, TopLevelShimGenerator} from '../../shims/api';\nimport {TypeCheckShimGenerator} from '../../typecheck';\nimport {normalizeSeparators} from '../../util/src/path';\nimport {getRootDirs, isNonDeclarationTsPath, RequiredDelegations} from '../../util/src/typescript';\nimport {ExtendedTsCompilerHost, NgCompilerAdapter, NgCompilerOptions, UnifiedModulesHost} from '../api';\n\n// A persistent source of bugs in CompilerHost delegation has been the addition by TS of new,\n// optional methods on ts.CompilerHost. Since these methods are optional, it's not a type error that\n// the delegating host doesn't implement or delegate them. This causes subtle runtime failures. No\n// more. This infrastructure ensures that failing to delegate a method is a compile-time error.\n\n/**\n * Delegates all methods of `ExtendedTsCompilerHost` to a delegate, with the exception of\n * `getSourceFile` and `fileExists` which are implemented in `NgCompilerHost`.\n *\n * If a new method is added to `ts.CompilerHost` which is not delegated, a type error will be\n * generated for this class.\n */\nexport class DelegatingCompilerHost implements\n    Omit<RequiredDelegations<ExtendedTsCompilerHost>, 'getSourceFile'|'fileExists'> {\n  constructor(protected delegate: ExtendedTsCompilerHost) {}\n\n  private delegateMethod<M extends keyof ExtendedTsCompilerHost>(name: M):\n      ExtendedTsCompilerHost[M] {\n    return this.delegate[name] !== undefined ? (this.delegate[name] as any).bind(this.delegate) :\n                                               undefined;\n  }\n\n  // Excluded are 'getSourceFile' and 'fileExists', which are actually implemented by NgCompilerHost\n  // below.\n  createHash = this.delegateMethod('createHash');\n  directoryExists = this.delegateMethod('directoryExists');\n  fileNameToModuleName = this.delegateMethod('fileNameToModuleName');\n  getCancellationToken = this.delegateMethod('getCancellationToken');\n  getCanonicalFileName = this.delegateMethod('getCanonicalFileName');\n  getCurrentDirectory = this.delegateMethod('getCurrentDirectory');\n  getDefaultLibFileName = this.delegateMethod('getDefaultLibFileName');\n  getDefaultLibLocation = this.delegateMethod('getDefaultLibLocation');\n  getDirectories = this.delegateMethod('getDirectories');\n  getEnvironmentVariable = this.delegateMethod('getEnvironmentVariable');\n  getModifiedResourceFiles = this.delegateMethod('getModifiedResourceFiles');\n  getNewLine = this.delegateMethod('getNewLine');\n  getParsedCommandLine = this.delegateMethod('getParsedCommandLine');\n  getSourceFileByPath = this.delegateMethod('getSourceFileByPath');\n  readDirectory = this.delegateMethod('readDirectory');\n  readFile = this.delegateMethod('readFile');\n  readResource = this.delegateMethod('readResource');\n  realpath = this.delegateMethod('realpath');\n  resolveModuleNames = this.delegateMethod('resolveModuleNames');\n  resolveTypeReferenceDirectives = this.delegateMethod('resolveTypeReferenceDirectives');\n  resourceNameToFileName = this.delegateMethod('resourceNameToFileName');\n  trace = this.delegateMethod('trace');\n  useCaseSensitiveFileNames = this.delegateMethod('useCaseSensitiveFileNames');\n  writeFile = this.delegateMethod('writeFile');\n}\n\n/**\n * A wrapper around `ts.CompilerHost` (plus any extension methods from `ExtendedTsCompilerHost`).\n *\n * In order for a consumer to include Angular compilation in their TypeScript compiler, the\n * `ts.Program` must be created with a host that adds Angular-specific files (e.g. factories,\n * summaries, the template type-checking file, etc) to the compilation. `NgCompilerHost` is the\n * host implementation which supports this.\n *\n * The interface implementations here ensure that `NgCompilerHost` fully delegates to\n * `ExtendedTsCompilerHost` methods whenever present.\n */\nexport class NgCompilerHost extends DelegatingCompilerHost implements\n    RequiredDelegations<ExtendedTsCompilerHost>, ExtendedTsCompilerHost, NgCompilerAdapter {\n  readonly factoryTracker: FactoryTracker|null = null;\n  readonly entryPoint: AbsoluteFsPath|null = null;\n  readonly constructionDiagnostics: ts.Diagnostic[];\n\n  readonly inputFiles: ReadonlyArray<string>;\n  readonly rootDirs: ReadonlyArray<AbsoluteFsPath>;\n\n\n  constructor(\n      delegate: ExtendedTsCompilerHost, inputFiles: ReadonlyArray<string>,\n      rootDirs: ReadonlyArray<AbsoluteFsPath>, private shimAdapter: ShimAdapter,\n      private shimTagger: ShimReferenceTagger, entryPoint: AbsoluteFsPath|null,\n      factoryTracker: FactoryTracker|null, diagnostics: ts.Diagnostic[]) {\n    super(delegate);\n\n    this.factoryTracker = factoryTracker;\n    this.entryPoint = entryPoint;\n    this.constructionDiagnostics = diagnostics;\n    this.inputFiles = [...inputFiles, ...shimAdapter.extraInputFiles];\n    this.rootDirs = rootDirs;\n\n    if (this.resolveModuleNames === undefined) {\n      // In order to reuse the module resolution cache during the creation of the type-check\n      // program, we'll need to provide `resolveModuleNames` if the delegate did not provide one.\n      this.resolveModuleNames = this.createCachedResolveModuleNamesFunction();\n    }\n  }\n\n  /**\n   * Retrieves a set of `ts.SourceFile`s which should not be emitted as JS files.\n   *\n   * Available after this host is used to create a `ts.Program` (which causes all the files in the\n   * program to be enumerated).\n   */\n  get ignoreForEmit(): Set<ts.SourceFile> {\n    return this.shimAdapter.ignoreForEmit;\n  }\n\n  /**\n   * Retrieve the array of shim extension prefixes for which shims were created for each original\n   * file.\n   */\n  get shimExtensionPrefixes(): string[] {\n    return this.shimAdapter.extensionPrefixes;\n  }\n\n  /**\n   * Performs cleanup that needs to happen after a `ts.Program` has been created using this host.\n   */\n  postProgramCreationCleanup(): void {\n    this.shimTagger.finalize();\n  }\n\n  /**\n   * Create an `NgCompilerHost` from a delegate host, an array of input filenames, and the full set\n   * of TypeScript and Angular compiler options.\n   */\n  static wrap(\n      delegate: ts.CompilerHost, inputFiles: ReadonlyArray<string>, options: NgCompilerOptions,\n      oldProgram: ts.Program|null): NgCompilerHost {\n    // TODO(alxhub): remove the fallback to allowEmptyCodegenFiles after verifying that the rest of\n    // our build tooling is no longer relying on it.\n    const allowEmptyCodegenFiles = options.allowEmptyCodegenFiles || false;\n    const shouldGenerateFactoryShims = options.generateNgFactoryShims !== undefined ?\n        options.generateNgFactoryShims :\n        allowEmptyCodegenFiles;\n\n    const shouldGenerateSummaryShims = options.generateNgSummaryShims !== undefined ?\n        options.generateNgSummaryShims :\n        allowEmptyCodegenFiles;\n\n\n    const topLevelShimGenerators: TopLevelShimGenerator[] = [];\n    const perFileShimGenerators: PerFileShimGenerator[] = [];\n\n    if (shouldGenerateSummaryShims) {\n      // Summary generation.\n      perFileShimGenerators.push(new SummaryGenerator());\n    }\n\n    let factoryTracker: FactoryTracker|null = null;\n    if (shouldGenerateFactoryShims) {\n      const factoryGenerator = new FactoryGenerator();\n      perFileShimGenerators.push(factoryGenerator);\n\n      factoryTracker = factoryGenerator;\n    }\n\n    const rootDirs = getRootDirs(delegate, options as ts.CompilerOptions);\n\n    perFileShimGenerators.push(new TypeCheckShimGenerator());\n\n    let diagnostics: ts.Diagnostic[] = [];\n\n    const normalizedTsInputFiles: AbsoluteFsPath[] = [];\n    for (const inputFile of inputFiles) {\n      if (!isNonDeclarationTsPath(inputFile)) {\n        continue;\n      }\n      normalizedTsInputFiles.push(resolve(inputFile));\n    }\n\n    let entryPoint: AbsoluteFsPath|null = null;\n    if (options.flatModuleOutFile != null && options.flatModuleOutFile !== '') {\n      entryPoint = findFlatIndexEntryPoint(normalizedTsInputFiles);\n      if (entryPoint === null) {\n        // This error message talks specifically about having a single .ts file in \"files\". However\n        // the actual logic is a bit more permissive. If a single file exists, that will be taken,\n        // otherwise the highest level (shortest path) \"index.ts\" file will be used as the flat\n        // module entry point instead. If neither of these conditions apply, the error below is\n        // given.\n        //\n        // The user is not informed about the \"index.ts\" option as this behavior is deprecated -\n        // an explicit entrypoint should always be specified.\n        diagnostics.push({\n          category: ts.DiagnosticCategory.Error,\n          code: ngErrorCode(ErrorCode.CONFIG_FLAT_MODULE_NO_INDEX),\n          file: undefined,\n          start: undefined,\n          length: undefined,\n          messageText:\n              'Angular compiler option \"flatModuleOutFile\" requires one and only one .ts file in the \"files\" field.',\n        });\n      } else {\n        const flatModuleId = options.flatModuleId || null;\n        const flatModuleOutFile = normalizeSeparators(options.flatModuleOutFile);\n        const flatIndexGenerator =\n            new FlatIndexGenerator(entryPoint, flatModuleOutFile, flatModuleId);\n        topLevelShimGenerators.push(flatIndexGenerator);\n      }\n    }\n\n    const shimAdapter = new ShimAdapter(\n        delegate, normalizedTsInputFiles, topLevelShimGenerators, perFileShimGenerators,\n        oldProgram);\n    const shimTagger =\n        new ShimReferenceTagger(perFileShimGenerators.map(gen => gen.extensionPrefix));\n    return new NgCompilerHost(\n        delegate, inputFiles, rootDirs, shimAdapter, shimTagger, entryPoint, factoryTracker,\n        diagnostics);\n  }\n\n  /**\n   * Check whether the given `ts.SourceFile` is a shim file.\n   *\n   * If this returns false, the file is user-provided.\n   */\n  isShim(sf: ts.SourceFile): boolean {\n    return isShim(sf);\n  }\n\n  getSourceFile(\n      fileName: string, languageVersion: ts.ScriptTarget,\n      onError?: ((message: string) => void)|undefined,\n      shouldCreateNewSourceFile?: boolean|undefined): ts.SourceFile|undefined {\n    // Is this a previously known shim?\n    const shimSf = this.shimAdapter.maybeGenerate(resolve(fileName));\n    if (shimSf !== null) {\n      // Yes, so return it.\n      return shimSf;\n    }\n\n    // No, so it's a file which might need shims (or a file which doesn't exist).\n    const sf =\n        this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n    if (sf === undefined) {\n      return undefined;\n    }\n\n    this.shimTagger.tag(sf);\n    return sf;\n  }\n\n  fileExists(fileName: string): boolean {\n    // Consider the file as existing whenever\n    //  1) it really does exist in the delegate host, or\n    //  2) at least one of the shim generators recognizes it\n    // Note that we can pass the file name as branded absolute fs path because TypeScript\n    // internally only passes POSIX-like paths.\n    //\n    // Also note that the `maybeGenerate` check below checks for both `null` and `undefined`.\n    return this.delegate.fileExists(fileName) ||\n        this.shimAdapter.maybeGenerate(resolve(fileName)) != null;\n  }\n\n  get unifiedModulesHost(): UnifiedModulesHost|null {\n    return this.fileNameToModuleName !== undefined ? this as UnifiedModulesHost : null;\n  }\n\n  private createCachedResolveModuleNamesFunction(): ts.CompilerHost['resolveModuleNames'] {\n    const moduleResolutionCache = ts.createModuleResolutionCache(\n        this.getCurrentDirectory(), this.getCanonicalFileName.bind(this));\n\n    return (moduleNames, containingFile, reusedNames, redirectedReference, options) => {\n      return moduleNames.map(moduleName => {\n        const module = ts.resolveModuleName(\n            moduleName, containingFile, options, this, moduleResolutionCache, redirectedReference);\n        return module.resolvedModule;\n      });\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}