{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/jit_compiler_facade\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/constant_pool\", \"@angular/compiler/src/core\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/injectable_compiler_2\", \"@angular/compiler/src/ml_parser/interpolation_config\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/output/output_jit\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/render3/r3_factory\", \"@angular/compiler/src/render3/r3_jit\", \"@angular/compiler/src/render3/r3_module_compiler\", \"@angular/compiler/src/render3/r3_pipe_compiler\", \"@angular/compiler/src/render3/util\", \"@angular/compiler/src/render3/view/compiler\", \"@angular/compiler/src/render3/view/template\", \"@angular/compiler/src/resource_loader\", \"@angular/compiler/src/schema/dom_element_schema_registry\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.publishFacade = exports.CompilerFacadeImpl = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var constant_pool_1 = require(\"@angular/compiler/src/constant_pool\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var injectable_compiler_2_1 = require(\"@angular/compiler/src/injectable_compiler_2\");\n\n  var interpolation_config_1 = require(\"@angular/compiler/src/ml_parser/interpolation_config\");\n\n  var output_ast_1 = require(\"@angular/compiler/src/output/output_ast\");\n\n  var output_jit_1 = require(\"@angular/compiler/src/output/output_jit\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var r3_factory_1 = require(\"@angular/compiler/src/render3/r3_factory\");\n\n  var r3_jit_1 = require(\"@angular/compiler/src/render3/r3_jit\");\n\n  var r3_module_compiler_1 = require(\"@angular/compiler/src/render3/r3_module_compiler\");\n\n  var r3_pipe_compiler_1 = require(\"@angular/compiler/src/render3/r3_pipe_compiler\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/util\");\n\n  var compiler_1 = require(\"@angular/compiler/src/render3/view/compiler\");\n\n  var template_1 = require(\"@angular/compiler/src/render3/view/template\");\n\n  var resource_loader_1 = require(\"@angular/compiler/src/resource_loader\");\n\n  var dom_element_schema_registry_1 = require(\"@angular/compiler/src/schema/dom_element_schema_registry\");\n\n  var CompilerFacadeImpl =\n  /** @class */\n  function () {\n    function CompilerFacadeImpl(jitEvaluator) {\n      if (jitEvaluator === void 0) {\n        jitEvaluator = new output_jit_1.JitEvaluator();\n      }\n\n      this.jitEvaluator = jitEvaluator;\n      this.R3ResolvedDependencyType = r3_factory_1.R3ResolvedDependencyType;\n      this.R3FactoryTarget = r3_factory_1.R3FactoryTarget;\n      this.ResourceLoader = resource_loader_1.ResourceLoader;\n      this.elementSchemaRegistry = new dom_element_schema_registry_1.DomElementSchemaRegistry();\n    }\n\n    CompilerFacadeImpl.prototype.compilePipe = function (angularCoreEnv, sourceMapUrl, facade) {\n      var metadata = {\n        name: facade.name,\n        type: wrapReference(facade.type),\n        internalType: new output_ast_1.WrappedNodeExpr(facade.type),\n        typeArgumentCount: facade.typeArgumentCount,\n        deps: convertR3DependencyMetadataArray(facade.deps),\n        pipeName: facade.pipeName,\n        pure: facade.pure\n      };\n      var res = r3_pipe_compiler_1.compilePipeFromMetadata(metadata);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    };\n\n    CompilerFacadeImpl.prototype.compilePipeDeclaration = function (angularCoreEnv, sourceMapUrl, declaration) {\n      var meta = convertDeclarePipeFacadeToMetadata(declaration);\n      var res = r3_pipe_compiler_1.compilePipeFromMetadata(meta);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    };\n\n    CompilerFacadeImpl.prototype.compileInjectable = function (angularCoreEnv, sourceMapUrl, facade) {\n      var _a = injectable_compiler_2_1.compileInjectable({\n        name: facade.name,\n        type: wrapReference(facade.type),\n        internalType: new output_ast_1.WrappedNodeExpr(facade.type),\n        typeArgumentCount: facade.typeArgumentCount,\n        providedIn: computeProvidedIn(facade.providedIn),\n        useClass: wrapExpression(facade, USE_CLASS),\n        useFactory: wrapExpression(facade, USE_FACTORY),\n        useValue: wrapExpression(facade, USE_VALUE),\n        useExisting: wrapExpression(facade, USE_EXISTING),\n        userDeps: convertR3DependencyMetadataArray(facade.userDeps) || undefined\n      }),\n          expression = _a.expression,\n          statements = _a.statements;\n\n      return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    };\n\n    CompilerFacadeImpl.prototype.compileInjector = function (angularCoreEnv, sourceMapUrl, facade) {\n      var meta = {\n        name: facade.name,\n        type: wrapReference(facade.type),\n        internalType: new output_ast_1.WrappedNodeExpr(facade.type),\n        providers: new output_ast_1.WrappedNodeExpr(facade.providers),\n        imports: facade.imports.map(function (i) {\n          return new output_ast_1.WrappedNodeExpr(i);\n        })\n      };\n      var res = r3_module_compiler_1.compileInjector(meta);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    };\n\n    CompilerFacadeImpl.prototype.compileNgModule = function (angularCoreEnv, sourceMapUrl, facade) {\n      var meta = {\n        type: wrapReference(facade.type),\n        internalType: new output_ast_1.WrappedNodeExpr(facade.type),\n        adjacentType: new output_ast_1.WrappedNodeExpr(facade.type),\n        bootstrap: facade.bootstrap.map(wrapReference),\n        declarations: facade.declarations.map(wrapReference),\n        imports: facade.imports.map(wrapReference),\n        exports: facade.exports.map(wrapReference),\n        emitInline: true,\n        containsForwardDecls: false,\n        schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n        id: facade.id ? new output_ast_1.WrappedNodeExpr(facade.id) : null\n      };\n      var res = r3_module_compiler_1.compileNgModule(meta);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    };\n\n    CompilerFacadeImpl.prototype.compileDirective = function (angularCoreEnv, sourceMapUrl, facade) {\n      var meta = convertDirectiveFacadeToMetadata(facade);\n      return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    };\n\n    CompilerFacadeImpl.prototype.compileDirectiveDeclaration = function (angularCoreEnv, sourceMapUrl, declaration) {\n      var typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n      var meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n      return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    };\n\n    CompilerFacadeImpl.prototype.compileDirectiveFromMeta = function (angularCoreEnv, sourceMapUrl, meta) {\n      var constantPool = new constant_pool_1.ConstantPool();\n      var bindingParser = template_1.makeBindingParser();\n      var res = compiler_1.compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    };\n\n    CompilerFacadeImpl.prototype.compileComponent = function (angularCoreEnv, sourceMapUrl, facade) {\n      // Parse the template and check for errors.\n      var _a = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation),\n          template = _a.template,\n          interpolation = _a.interpolation; // Compile the component metadata, including template, into an expression.\n\n\n      var meta = tslib_1.__assign(tslib_1.__assign(tslib_1.__assign({}, facade), convertDirectiveFacadeToMetadata(facade)), {\n        selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n        template: template,\n        declarationListEmitMode: 0\n        /* Direct */\n        ,\n        styles: tslib_1.__spread(facade.styles, template.styles),\n        encapsulation: facade.encapsulation,\n        interpolation: interpolation,\n        changeDetection: facade.changeDetection,\n        animations: facade.animations != null ? new output_ast_1.WrappedNodeExpr(facade.animations) : null,\n        viewProviders: facade.viewProviders != null ? new output_ast_1.WrappedNodeExpr(facade.viewProviders) : null,\n        relativeContextFilePath: '',\n        i18nUseExternalIds: true\n      });\n\n      var jitExpressionSourceMap = \"ng:///\" + facade.name + \".js\";\n      return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n    };\n\n    CompilerFacadeImpl.prototype.compileComponentDeclaration = function (angularCoreEnv, sourceMapUrl, declaration) {\n      var typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n      var meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n      return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    };\n\n    CompilerFacadeImpl.prototype.compileComponentFromMeta = function (angularCoreEnv, sourceMapUrl, meta) {\n      var constantPool = new constant_pool_1.ConstantPool();\n      var bindingParser = template_1.makeBindingParser(meta.interpolation);\n      var res = compiler_1.compileComponentFromMetadata(meta, constantPool, bindingParser);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    };\n\n    CompilerFacadeImpl.prototype.compileFactory = function (angularCoreEnv, sourceMapUrl, meta) {\n      var factoryRes = r3_factory_1.compileFactoryFunction({\n        name: meta.name,\n        type: wrapReference(meta.type),\n        internalType: new output_ast_1.WrappedNodeExpr(meta.type),\n        typeArgumentCount: meta.typeArgumentCount,\n        deps: convertR3DependencyMetadataArray(meta.deps),\n        injectFn: meta.injectFn === 'directiveInject' ? identifiers_1.Identifiers.directiveInject : identifiers_1.Identifiers.inject,\n        target: meta.target\n      });\n      return this.jitExpression(factoryRes.factory, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    };\n\n    CompilerFacadeImpl.prototype.createParseSourceSpan = function (kind, typeName, sourceUrl) {\n      return parse_util_1.r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n    };\n    /**\n     * JIT compiles an expression and returns the result of executing that expression.\n     *\n     * @param def the definition which will be compiled and executed to get the value to patch\n     * @param context an object map of @angular/core symbol names to symbols which will be available\n     * in the context of the compiled expression\n     * @param sourceUrl a URL to use for the source map of the compiled expression\n     * @param preStatements a collection of statements that should be evaluated before the expression.\n     */\n\n\n    CompilerFacadeImpl.prototype.jitExpression = function (def, context, sourceUrl, preStatements) {\n      // The ConstantPool may contain Statements which declare variables used in the final expression.\n      // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n      // declaration of $def which is set to the expression being compiled.\n      var statements = tslib_1.__spread(preStatements, [new output_ast_1.DeclareVarStmt('$def', def, undefined, [output_ast_1.StmtModifier.Exported])]);\n\n      var res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new r3_jit_1.R3JitReflector(context),\n      /* enableSourceMaps */\n      true);\n      return res['$def'];\n    };\n\n    return CompilerFacadeImpl;\n  }();\n\n  exports.CompilerFacadeImpl = CompilerFacadeImpl;\n  var USE_CLASS = Object.keys({\n    useClass: null\n  })[0];\n  var USE_FACTORY = Object.keys({\n    useFactory: null\n  })[0];\n  var USE_VALUE = Object.keys({\n    useValue: null\n  })[0];\n  var USE_EXISTING = Object.keys({\n    useExisting: null\n  })[0];\n\n  var wrapReference = function wrapReference(value) {\n    var wrapped = new output_ast_1.WrappedNodeExpr(value);\n    return {\n      value: wrapped,\n      type: wrapped\n    };\n  };\n\n  function convertToR3QueryMetadata(facade) {\n    return tslib_1.__assign(tslib_1.__assign({}, facade), {\n      predicate: Array.isArray(facade.predicate) ? facade.predicate : new output_ast_1.WrappedNodeExpr(facade.predicate),\n      read: facade.read ? new output_ast_1.WrappedNodeExpr(facade.read) : null,\n      static: facade.static,\n      emitDistinctChangesOnly: facade.emitDistinctChangesOnly\n    });\n  }\n\n  function convertQueryDeclarationToMetadata(declaration) {\n    var _a, _b, _c, _d;\n\n    return {\n      propertyName: declaration.propertyName,\n      first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,\n      predicate: Array.isArray(declaration.predicate) ? declaration.predicate : new output_ast_1.WrappedNodeExpr(declaration.predicate),\n      descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,\n      read: declaration.read ? new output_ast_1.WrappedNodeExpr(declaration.read) : null,\n      static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,\n      emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true\n    };\n  }\n\n  function convertDirectiveFacadeToMetadata(facade) {\n    var inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n    var outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n    var propMetadata = facade.propMetadata;\n    var inputsFromType = {};\n    var outputsFromType = {};\n\n    var _loop_1 = function _loop_1(field) {\n      if (propMetadata.hasOwnProperty(field)) {\n        propMetadata[field].forEach(function (ann) {\n          if (isInput(ann)) {\n            inputsFromType[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n          } else if (isOutput(ann)) {\n            outputsFromType[field] = ann.bindingPropertyName || field;\n          }\n        });\n      }\n    };\n\n    for (var field in propMetadata) {\n      _loop_1(field);\n    }\n\n    return tslib_1.__assign(tslib_1.__assign({}, facade), {\n      typeSourceSpan: facade.typeSourceSpan,\n      type: wrapReference(facade.type),\n      internalType: new output_ast_1.WrappedNodeExpr(facade.type),\n      deps: convertR3DependencyMetadataArray(facade.deps),\n      host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),\n      inputs: tslib_1.__assign(tslib_1.__assign({}, inputsFromMetadata), inputsFromType),\n      outputs: tslib_1.__assign(tslib_1.__assign({}, outputsFromMetadata), outputsFromType),\n      queries: facade.queries.map(convertToR3QueryMetadata),\n      providers: facade.providers != null ? new output_ast_1.WrappedNodeExpr(facade.providers) : null,\n      viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n      fullInheritance: false\n    });\n  }\n\n  function convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n\n    return {\n      name: declaration.type.name,\n      type: wrapReference(declaration.type),\n      typeSourceSpan: typeSourceSpan,\n      internalType: new output_ast_1.WrappedNodeExpr(declaration.type),\n      selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,\n      inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},\n      outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},\n      host: convertHostDeclarationToMetadata(declaration.host),\n      queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),\n      viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),\n      providers: declaration.providers !== undefined ? new output_ast_1.WrappedNodeExpr(declaration.providers) : null,\n      exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,\n      usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,\n      lifecycle: {\n        usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false\n      },\n      deps: null,\n      typeArgumentCount: 0,\n      fullInheritance: false\n    };\n  }\n\n  function convertHostDeclarationToMetadata(host) {\n    var _a, _b, _c;\n\n    if (host === void 0) {\n      host = {};\n    }\n\n    return {\n      attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),\n      listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},\n      properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},\n      specialAttributes: {\n        classAttr: host.classAttribute,\n        styleAttr: host.styleAttribute\n      }\n    };\n  }\n\n  function convertOpaqueValuesToExpressions(obj) {\n    var e_1, _a;\n\n    var result = {};\n\n    try {\n      for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        result[key] = new output_ast_1.WrappedNodeExpr(obj[key]);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return result;\n  }\n\n  function convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl) {\n    var _a, _b, _c, _d, _e;\n\n    var _f = parseJitTemplate(declaration.template, declaration.type.name, sourceMapUrl, (_a = declaration.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, declaration.interpolation),\n        template = _f.template,\n        interpolation = _f.interpolation;\n\n    return tslib_1.__assign(tslib_1.__assign({}, convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan)), {\n      template: template,\n      styles: (_b = declaration.styles) !== null && _b !== void 0 ? _b : [],\n      directives: ((_c = declaration.directives) !== null && _c !== void 0 ? _c : []).map(convertUsedDirectiveDeclarationToMetadata),\n      pipes: convertUsedPipesToMetadata(declaration.pipes),\n      viewProviders: declaration.viewProviders !== undefined ? new output_ast_1.WrappedNodeExpr(declaration.viewProviders) : null,\n      animations: declaration.animations !== undefined ? new output_ast_1.WrappedNodeExpr(declaration.animations) : null,\n      changeDetection: (_d = declaration.changeDetection) !== null && _d !== void 0 ? _d : core_1.ChangeDetectionStrategy.Default,\n      encapsulation: (_e = declaration.encapsulation) !== null && _e !== void 0 ? _e : core_1.ViewEncapsulation.Emulated,\n      interpolation: interpolation,\n      declarationListEmitMode: 2\n      /* ClosureResolved */\n      ,\n      relativeContextFilePath: '',\n      i18nUseExternalIds: true\n    });\n  }\n\n  function convertUsedDirectiveDeclarationToMetadata(declaration) {\n    var _a, _b, _c;\n\n    return {\n      selector: declaration.selector,\n      type: new output_ast_1.WrappedNodeExpr(declaration.type),\n      inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],\n      outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],\n      exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null\n    };\n  }\n\n  function convertUsedPipesToMetadata(declaredPipes) {\n    var e_2, _a;\n\n    var pipes = new Map();\n\n    if (declaredPipes === undefined) {\n      return pipes;\n    }\n\n    try {\n      for (var _b = tslib_1.__values(Object.keys(declaredPipes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var pipeName = _c.value;\n        var pipeType = declaredPipes[pipeName];\n        pipes.set(pipeName, new output_ast_1.WrappedNodeExpr(pipeType));\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return pipes;\n  }\n\n  function parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {\n    var interpolationConfig = interpolation ? interpolation_config_1.InterpolationConfig.fromArray(interpolation) : interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG; // Parse the template and check for errors.\n\n    var parsed = template_1.parseTemplate(template, sourceMapUrl, {\n      preserveWhitespaces: preserveWhitespaces,\n      interpolationConfig: interpolationConfig\n    });\n\n    if (parsed.errors !== null) {\n      var errors = parsed.errors.map(function (err) {\n        return err.toString();\n      }).join(', ');\n      throw new Error(\"Errors during JIT compilation of template for \" + typeName + \": \" + errors);\n    }\n\n    return {\n      template: parsed,\n      interpolation: interpolationConfig\n    };\n  }\n\n  function wrapExpression(obj, property) {\n    if (obj.hasOwnProperty(property)) {\n      return new output_ast_1.WrappedNodeExpr(obj[property]);\n    } else {\n      return undefined;\n    }\n  }\n\n  function computeProvidedIn(providedIn) {\n    if (providedIn == null || typeof providedIn === 'string') {\n      return new output_ast_1.LiteralExpr(providedIn);\n    } else {\n      return new output_ast_1.WrappedNodeExpr(providedIn);\n    }\n  }\n\n  function convertR3DependencyMetadata(facade) {\n    var tokenExpr;\n\n    if (facade.token === null) {\n      tokenExpr = new output_ast_1.LiteralExpr(null);\n    } else if (facade.resolved === r3_factory_1.R3ResolvedDependencyType.Attribute) {\n      tokenExpr = new output_ast_1.LiteralExpr(facade.token);\n    } else {\n      tokenExpr = new output_ast_1.WrappedNodeExpr(facade.token);\n    }\n\n    return {\n      token: tokenExpr,\n      attribute: null,\n      resolved: facade.resolved,\n      host: facade.host,\n      optional: facade.optional,\n      self: facade.self,\n      skipSelf: facade.skipSelf\n    };\n  }\n\n  function convertR3DependencyMetadataArray(facades) {\n    return facades == null ? null : facades.map(convertR3DependencyMetadata);\n  }\n\n  function extractHostBindings(propMetadata, sourceSpan, host) {\n    // First parse the declarations from the metadata.\n    var bindings = compiler_1.parseHostBindings(host || {}); // After that check host bindings for errors\n\n    var errors = compiler_1.verifyHostBindings(bindings, sourceSpan);\n\n    if (errors.length) {\n      throw new Error(errors.map(function (error) {\n        return error.msg;\n      }).join('\\n'));\n    }\n\n    var _loop_2 = function _loop_2(field) {\n      if (propMetadata.hasOwnProperty(field)) {\n        propMetadata[field].forEach(function (ann) {\n          if (isHostBinding(ann)) {\n            // Since this is a decorator, we know that the value is a class member. Always access it\n            // through `this` so that further down the line it can't be confused for a literal value\n            // (e.g. if there's a property called `true`).\n            bindings.properties[ann.hostPropertyName || field] = util_1.getSafePropertyAccessString('this', field);\n          } else if (isHostListener(ann)) {\n            bindings.listeners[ann.eventName || field] = field + \"(\" + (ann.args || []).join(',') + \")\";\n          }\n        });\n      }\n    }; // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n\n\n    for (var field in propMetadata) {\n      _loop_2(field);\n    }\n\n    return bindings;\n  }\n\n  function isHostBinding(value) {\n    return value.ngMetadataName === 'HostBinding';\n  }\n\n  function isHostListener(value) {\n    return value.ngMetadataName === 'HostListener';\n  }\n\n  function isInput(value) {\n    return value.ngMetadataName === 'Input';\n  }\n\n  function isOutput(value) {\n    return value.ngMetadataName === 'Output';\n  }\n\n  function parseInputOutputs(values) {\n    return values.reduce(function (map, value) {\n      var _a = tslib_1.__read(value.split(',').map(function (piece) {\n        return piece.trim();\n      }), 2),\n          field = _a[0],\n          property = _a[1];\n\n      map[field] = property || field;\n      return map;\n    }, {});\n  }\n\n  function convertDeclarePipeFacadeToMetadata(declaration) {\n    var _a;\n\n    return {\n      name: declaration.type.name,\n      type: wrapReference(declaration.type),\n      internalType: new output_ast_1.WrappedNodeExpr(declaration.type),\n      typeArgumentCount: 0,\n      pipeName: declaration.name,\n      deps: null,\n      pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true\n    };\n  }\n\n  function publishFacade(global) {\n    var ng = global.ng || (global.ng = {});\n    ng.ɵcompilerFacade = new CompilerFacadeImpl();\n  }\n\n  exports.publishFacade = publishFacade;\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/jit_compiler_facade.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {CompilerFacade, CoreEnvironment, ExportedCompilerFacade, OpaqueValue, R3ComponentMetadataFacade, R3DeclareComponentFacade, R3DeclareDirectiveFacade, R3DeclarePipeFacade, R3DeclareQueryMetadataFacade, R3DependencyMetadataFacade, R3DirectiveMetadataFacade, R3FactoryDefMetadataFacade, R3InjectableMetadataFacade, R3InjectorMetadataFacade, R3NgModuleMetadataFacade, R3PipeMetadataFacade, R3QueryMetadataFacade, StringMap, StringMapWithRename} from './compiler_facade_interface';\nimport {ConstantPool} from './constant_pool';\nimport {ChangeDetectionStrategy, HostBinding, HostListener, Input, Output, Type, ViewEncapsulation} from './core';\nimport {Identifiers} from './identifiers';\nimport {compileInjectable} from './injectable_compiler_2';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './ml_parser/interpolation_config';\nimport {DeclareVarStmt, Expression, LiteralExpr, Statement, StmtModifier, WrappedNodeExpr} from './output/output_ast';\nimport {JitEvaluator} from './output/output_jit';\nimport {ParseError, ParseSourceSpan, r3JitTypeSourceSpan} from './parse_util';\nimport {compileFactoryFunction, R3DependencyMetadata, R3FactoryTarget, R3ResolvedDependencyType} from './render3/r3_factory';\nimport {R3JitReflector} from './render3/r3_jit';\nimport {compileInjector, compileNgModule, R3InjectorMetadata, R3NgModuleMetadata} from './render3/r3_module_compiler';\nimport {compilePipeFromMetadata, R3PipeMetadata} from './render3/r3_pipe_compiler';\nimport {getSafePropertyAccessString, R3Reference} from './render3/util';\nimport {DeclarationListEmitMode, R3ComponentMetadata, R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata, R3UsedDirectiveMetadata} from './render3/view/api';\nimport {compileComponentFromMetadata, compileDirectiveFromMetadata, ParsedHostBindings, parseHostBindings, verifyHostBindings} from './render3/view/compiler';\nimport {makeBindingParser, parseTemplate} from './render3/view/template';\nimport {ResourceLoader} from './resource_loader';\nimport {DomElementSchemaRegistry} from './schema/dom_element_schema_registry';\n\nexport class CompilerFacadeImpl implements CompilerFacade {\n  R3ResolvedDependencyType = R3ResolvedDependencyType as any;\n  R3FactoryTarget = R3FactoryTarget as any;\n  ResourceLoader = ResourceLoader;\n  private elementSchemaRegistry = new DomElementSchemaRegistry();\n\n  constructor(private jitEvaluator = new JitEvaluator()) {}\n\n  compilePipe(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, facade: R3PipeMetadataFacade):\n      any {\n    const metadata: R3PipeMetadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      internalType: new WrappedNodeExpr(facade.type),\n      typeArgumentCount: facade.typeArgumentCount,\n      deps: convertR3DependencyMetadataArray(facade.deps),\n      pipeName: facade.pipeName,\n      pure: facade.pure,\n    };\n    const res = compilePipeFromMetadata(metadata);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compilePipeDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclarePipeFacade): any {\n    const meta = convertDeclarePipeFacadeToMetadata(declaration);\n    const res = compilePipeFromMetadata(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileInjectable(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3InjectableMetadataFacade): any {\n    const {expression, statements} = compileInjectable({\n      name: facade.name,\n      type: wrapReference(facade.type),\n      internalType: new WrappedNodeExpr(facade.type),\n      typeArgumentCount: facade.typeArgumentCount,\n      providedIn: computeProvidedIn(facade.providedIn),\n      useClass: wrapExpression(facade, USE_CLASS),\n      useFactory: wrapExpression(facade, USE_FACTORY),\n      useValue: wrapExpression(facade, USE_VALUE),\n      useExisting: wrapExpression(facade, USE_EXISTING),\n      userDeps: convertR3DependencyMetadataArray(facade.userDeps) || undefined,\n    });\n\n    return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n  }\n\n  compileInjector(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3InjectorMetadataFacade): any {\n    const meta: R3InjectorMetadata = {\n      name: facade.name,\n      type: wrapReference(facade.type),\n      internalType: new WrappedNodeExpr(facade.type),\n      providers: new WrappedNodeExpr(facade.providers),\n      imports: facade.imports.map(i => new WrappedNodeExpr(i)),\n    };\n    const res = compileInjector(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileNgModule(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3NgModuleMetadataFacade): any {\n    const meta: R3NgModuleMetadata = {\n      type: wrapReference(facade.type),\n      internalType: new WrappedNodeExpr(facade.type),\n      adjacentType: new WrappedNodeExpr(facade.type),\n      bootstrap: facade.bootstrap.map(wrapReference),\n      declarations: facade.declarations.map(wrapReference),\n      imports: facade.imports.map(wrapReference),\n      exports: facade.exports.map(wrapReference),\n      emitInline: true,\n      containsForwardDecls: false,\n      schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n      id: facade.id ? new WrappedNodeExpr(facade.id) : null,\n    };\n    const res = compileNgModule(meta);\n    return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n  }\n\n  compileDirective(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3DirectiveMetadataFacade): any {\n    const meta: R3DirectiveMetadata = convertDirectiveFacadeToMetadata(facade);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  compileDirectiveDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareDirectiveFacade): any {\n    const typeSourceSpan =\n        this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n    return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  private compileDirectiveFromMeta(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DirectiveMetadata): any {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser();\n    const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(\n        res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n\n  compileComponent(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      facade: R3ComponentMetadataFacade): any {\n    // Parse the template and check for errors.\n    const {template, interpolation} = parseJitTemplate(\n        facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces,\n        facade.interpolation);\n\n    // Compile the component metadata, including template, into an expression.\n    const meta: R3ComponentMetadata = {\n      ...facade as R3ComponentMetadataFacadeNoPropAndWhitespace,\n      ...convertDirectiveFacadeToMetadata(facade),\n      selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n      template,\n      declarationListEmitMode: DeclarationListEmitMode.Direct,\n      styles: [...facade.styles, ...template.styles],\n      encapsulation: facade.encapsulation as any,\n      interpolation,\n      changeDetection: facade.changeDetection,\n      animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n      viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\n                                                    null,\n      relativeContextFilePath: '',\n      i18nUseExternalIds: true,\n    };\n    const jitExpressionSourceMap = `ng:///${facade.name}.js`;\n    return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n  }\n\n  compileComponentDeclaration(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string,\n      declaration: R3DeclareComponentFacade): any {\n    const typeSourceSpan =\n        this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n    const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n    return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n  }\n\n  private compileComponentFromMeta(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3ComponentMetadata): any {\n    const constantPool = new ConstantPool();\n    const bindingParser = makeBindingParser(meta.interpolation);\n    const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n    return this.jitExpression(\n        res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n  }\n\n  compileFactory(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3FactoryDefMetadataFacade) {\n    const factoryRes = compileFactoryFunction({\n      name: meta.name,\n      type: wrapReference(meta.type),\n      internalType: new WrappedNodeExpr(meta.type),\n      typeArgumentCount: meta.typeArgumentCount,\n      deps: convertR3DependencyMetadataArray(meta.deps),\n      injectFn: meta.injectFn === 'directiveInject' ? Identifiers.directiveInject :\n                                                      Identifiers.inject,\n      target: meta.target,\n    });\n    return this.jitExpression(\n        factoryRes.factory, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n  }\n\n  createParseSourceSpan(kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n    return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n  }\n\n  /**\n   * JIT compiles an expression and returns the result of executing that expression.\n   *\n   * @param def the definition which will be compiled and executed to get the value to patch\n   * @param context an object map of @angular/core symbol names to symbols which will be available\n   * in the context of the compiled expression\n   * @param sourceUrl a URL to use for the source map of the compiled expression\n   * @param preStatements a collection of statements that should be evaluated before the expression.\n   */\n  private jitExpression(\n      def: Expression, context: {[key: string]: any}, sourceUrl: string,\n      preStatements: Statement[]): any {\n    // The ConstantPool may contain Statements which declare variables used in the final expression.\n    // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n    // declaration of $def which is set to the expression being compiled.\n    const statements: Statement[] = [\n      ...preStatements,\n      new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported]),\n    ];\n\n    const res = this.jitEvaluator.evaluateStatements(\n        sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\n    return res['$def'];\n  }\n}\n\n// This seems to be needed to placate TS v3.0 only\ntype R3ComponentMetadataFacadeNoPropAndWhitespace = Pick<\n    R3ComponentMetadataFacade,\n    Exclude<Exclude<keyof R3ComponentMetadataFacade, 'preserveWhitespaces'>, 'propMetadata'>>;\n\nconst USE_CLASS = Object.keys({useClass: null})[0];\nconst USE_FACTORY = Object.keys({useFactory: null})[0];\nconst USE_VALUE = Object.keys({useValue: null})[0];\nconst USE_EXISTING = Object.keys({useExisting: null})[0];\n\nconst wrapReference = function(value: any): R3Reference {\n  const wrapped = new WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n};\n\nfunction convertToR3QueryMetadata(facade: R3QueryMetadataFacade): R3QueryMetadata {\n  return {\n    ...facade,\n    predicate: Array.isArray(facade.predicate) ? facade.predicate :\n                                                 new WrappedNodeExpr(facade.predicate),\n    read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n    static: facade.static,\n    emitDistinctChangesOnly: facade.emitDistinctChangesOnly,\n  };\n}\n\nfunction convertQueryDeclarationToMetadata(declaration: R3DeclareQueryMetadataFacade):\n    R3QueryMetadata {\n  return {\n    propertyName: declaration.propertyName,\n    first: declaration.first ?? false,\n    predicate: Array.isArray(declaration.predicate) ? declaration.predicate :\n                                                      new WrappedNodeExpr(declaration.predicate),\n    descendants: declaration.descendants ?? false,\n    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n    static: declaration.static ?? false,\n    emitDistinctChangesOnly: declaration.emitDistinctChangesOnly ?? true,\n  };\n}\n\nfunction convertDirectiveFacadeToMetadata(facade: R3DirectiveMetadataFacade): R3DirectiveMetadata {\n  const inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n  const outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n  const propMetadata = facade.propMetadata;\n  const inputsFromType: StringMapWithRename = {};\n  const outputsFromType: StringMap = {};\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isInput(ann)) {\n          inputsFromType[field] =\n              ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.bindingPropertyName || field;\n        }\n      });\n    }\n  }\n\n  return {\n    ...facade as R3DirectiveMetadataFacadeNoPropAndWhitespace,\n    typeSourceSpan: facade.typeSourceSpan,\n    type: wrapReference(facade.type),\n    internalType: new WrappedNodeExpr(facade.type),\n    deps: convertR3DependencyMetadataArray(facade.deps),\n    host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),\n    inputs: {...inputsFromMetadata, ...inputsFromType},\n    outputs: {...outputsFromMetadata, ...outputsFromType},\n    queries: facade.queries.map(convertToR3QueryMetadata),\n    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n    fullInheritance: false,\n  };\n}\n\nfunction convertDeclareDirectiveFacadeToMetadata(\n    declaration: R3DeclareDirectiveFacade, typeSourceSpan: ParseSourceSpan): R3DirectiveMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeSourceSpan,\n    internalType: new WrappedNodeExpr(declaration.type),\n    selector: declaration.selector ?? null,\n    inputs: declaration.inputs ?? {},\n    outputs: declaration.outputs ?? {},\n    host: convertHostDeclarationToMetadata(declaration.host),\n    queries: (declaration.queries ?? []).map(convertQueryDeclarationToMetadata),\n    viewQueries: (declaration.viewQueries ?? []).map(convertQueryDeclarationToMetadata),\n    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\n                                                     null,\n    exportAs: declaration.exportAs ?? null,\n    usesInheritance: declaration.usesInheritance ?? false,\n    lifecycle: {usesOnChanges: declaration.usesOnChanges ?? false},\n    deps: null,\n    typeArgumentCount: 0,\n    fullInheritance: false,\n  };\n}\n\nfunction convertHostDeclarationToMetadata(host: R3DeclareDirectiveFacade['host'] = {}):\n    R3HostMetadata {\n  return {\n    attributes: convertOpaqueValuesToExpressions(host.attributes ?? {}),\n    listeners: host.listeners ?? {},\n    properties: host.properties ?? {},\n    specialAttributes: {\n      classAttr: host.classAttribute,\n      styleAttr: host.styleAttribute,\n    },\n  };\n}\n\nfunction convertOpaqueValuesToExpressions(obj: {[key: string]: OpaqueValue}):\n    {[key: string]: WrappedNodeExpr<unknown>} {\n  const result: {[key: string]: WrappedNodeExpr<unknown>} = {};\n  for (const key of Object.keys(obj)) {\n    result[key] = new WrappedNodeExpr(obj[key]);\n  }\n  return result;\n}\n\nfunction convertDeclareComponentFacadeToMetadata(\n    declaration: R3DeclareComponentFacade, typeSourceSpan: ParseSourceSpan,\n    sourceMapUrl: string): R3ComponentMetadata {\n  const {template, interpolation} = parseJitTemplate(\n      declaration.template, declaration.type.name, sourceMapUrl,\n      declaration.preserveWhitespaces ?? false, declaration.interpolation);\n\n  return {\n    ...convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan),\n    template,\n    styles: declaration.styles ?? [],\n    directives: (declaration.directives ?? []).map(convertUsedDirectiveDeclarationToMetadata),\n    pipes: convertUsedPipesToMetadata(declaration.pipes),\n    viewProviders: declaration.viewProviders !== undefined ?\n        new WrappedNodeExpr(declaration.viewProviders) :\n        null,\n    animations: declaration.animations !== undefined ? new WrappedNodeExpr(declaration.animations) :\n                                                       null,\n    changeDetection: declaration.changeDetection ?? ChangeDetectionStrategy.Default,\n    encapsulation: declaration.encapsulation ?? ViewEncapsulation.Emulated,\n    interpolation,\n    declarationListEmitMode: DeclarationListEmitMode.ClosureResolved,\n    relativeContextFilePath: '',\n    i18nUseExternalIds: true,\n  };\n}\n\nfunction convertUsedDirectiveDeclarationToMetadata(\n    declaration: NonNullable<R3DeclareComponentFacade['directives']>[number]):\n    R3UsedDirectiveMetadata {\n  return {\n    selector: declaration.selector,\n    type: new WrappedNodeExpr(declaration.type),\n    inputs: declaration.inputs ?? [],\n    outputs: declaration.outputs ?? [],\n    exportAs: declaration.exportAs ?? null,\n  };\n}\n\nfunction convertUsedPipesToMetadata(declaredPipes: R3DeclareComponentFacade['pipes']):\n    Map<string, Expression> {\n  const pipes = new Map<string, Expression>();\n  if (declaredPipes === undefined) {\n    return pipes;\n  }\n\n  for (const pipeName of Object.keys(declaredPipes)) {\n    const pipeType = declaredPipes[pipeName];\n    pipes.set(pipeName, new WrappedNodeExpr(pipeType));\n  }\n  return pipes;\n}\n\nfunction parseJitTemplate(\n    template: string, typeName: string, sourceMapUrl: string, preserveWhitespaces: boolean,\n    interpolation: [string, string]|undefined) {\n  const interpolationConfig =\n      interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;\n  // Parse the template and check for errors.\n  const parsed = parseTemplate(\n      template, sourceMapUrl, {preserveWhitespaces: preserveWhitespaces, interpolationConfig});\n  if (parsed.errors !== null) {\n    const errors = parsed.errors.map(err => err.toString()).join(', ');\n    throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\n  }\n  return {template: parsed, interpolation: interpolationConfig};\n}\n\n// This seems to be needed to placate TS v3.0 only\ntype R3DirectiveMetadataFacadeNoPropAndWhitespace =\n    Pick<R3DirectiveMetadataFacade, Exclude<keyof R3DirectiveMetadataFacade, 'propMetadata'>>;\n\nfunction wrapExpression(obj: any, property: string): WrappedNodeExpr<any>|undefined {\n  if (obj.hasOwnProperty(property)) {\n    return new WrappedNodeExpr(obj[property]);\n  } else {\n    return undefined;\n  }\n}\n\nfunction computeProvidedIn(providedIn: Type|string|null|undefined): Expression {\n  if (providedIn == null || typeof providedIn === 'string') {\n    return new LiteralExpr(providedIn);\n  } else {\n    return new WrappedNodeExpr(providedIn);\n  }\n}\n\nfunction convertR3DependencyMetadata(facade: R3DependencyMetadataFacade): R3DependencyMetadata {\n  let tokenExpr;\n  if (facade.token === null) {\n    tokenExpr = new LiteralExpr(null);\n  } else if (facade.resolved === R3ResolvedDependencyType.Attribute) {\n    tokenExpr = new LiteralExpr(facade.token);\n  } else {\n    tokenExpr = new WrappedNodeExpr(facade.token);\n  }\n  return {\n    token: tokenExpr,\n    attribute: null,\n    resolved: facade.resolved,\n    host: facade.host,\n    optional: facade.optional,\n    self: facade.self,\n    skipSelf: facade.skipSelf,\n  };\n}\n\nfunction convertR3DependencyMetadataArray(facades: R3DependencyMetadataFacade[]|null|\n                                          undefined): R3DependencyMetadata[]|null {\n  return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\n\nfunction extractHostBindings(\n    propMetadata: {[key: string]: any[]}, sourceSpan: ParseSourceSpan,\n    host?: {[key: string]: string}): ParsedHostBindings {\n  // First parse the declarations from the metadata.\n  const bindings = parseHostBindings(host || {});\n\n  // After that check host bindings for errors\n  const errors = verifyHostBindings(bindings, sourceSpan);\n  if (errors.length) {\n    throw new Error(errors.map((error: ParseError) => error.msg).join('\\n'));\n  }\n\n  // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(ann => {\n        if (isHostBinding(ann)) {\n          // Since this is a decorator, we know that the value is a class member. Always access it\n          // through `this` so that further down the line it can't be confused for a literal value\n          // (e.g. if there's a property called `true`).\n          bindings.properties[ann.hostPropertyName || field] =\n              getSafePropertyAccessString('this', field);\n        } else if (isHostListener(ann)) {\n          bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\n        }\n      });\n    }\n  }\n\n  return bindings;\n}\n\nfunction isHostBinding(value: any): value is HostBinding {\n  return value.ngMetadataName === 'HostBinding';\n}\n\nfunction isHostListener(value: any): value is HostListener {\n  return value.ngMetadataName === 'HostListener';\n}\n\n\nfunction isInput(value: any): value is Input {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction isOutput(value: any): value is Output {\n  return value.ngMetadataName === 'Output';\n}\n\nfunction parseInputOutputs(values: string[]): StringMap {\n  return values.reduce((map, value) => {\n    const [field, property] = value.split(',').map(piece => piece.trim());\n    map[field] = property || field;\n    return map;\n  }, {} as StringMap);\n}\n\nfunction convertDeclarePipeFacadeToMetadata(declaration: R3DeclarePipeFacade): R3PipeMetadata {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    internalType: new WrappedNodeExpr(declaration.type),\n    typeArgumentCount: 0,\n    pipeName: declaration.name,\n    deps: null,\n    pure: declaration.pure ?? true,\n  };\n}\n\n\nexport function publishFacade(global: any) {\n  const ng: ExportedCompilerFacade = global.ng || (global.ng = {});\n  ng.ɵcompilerFacade = new CompilerFacadeImpl();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}