{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPrefixClassesTransformer = exports.testPrefixClasses = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ts = require(\"typescript\");\n\nvar ast_utils_1 = require(\"../helpers/ast-utils\");\n\nfunction testPrefixClasses(content) {\n  var exportVarSetter = /(?:export )?(?:var|const)\\s+(?:\\S+)\\s*=\\s*/;\n  var multiLineComment = /\\s*(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*/;\n  var newLine = /\\s*\\r?\\n\\s*/;\n  var regexes = [[/^/, exportVarSetter, multiLineComment, /\\(/, multiLineComment, /\\s*function \\(\\) {/, newLine, multiLineComment, /function (?:\\S+)\\([^\\)]*\\) \\{/, newLine], [/^/, exportVarSetter, multiLineComment, /\\(/, multiLineComment, /\\s*function \\(_super\\) {/, newLine, /\\S*\\.?__extends\\(\\S+, _super\\);/]].map(function (arr) {\n    return new RegExp(arr.map(function (x) {\n      return x.source;\n    }).join(''), 'm');\n  });\n  return regexes.some(function (regex) {\n    return regex.test(content);\n  });\n}\n\nexports.testPrefixClasses = testPrefixClasses;\nvar superParameterName = '_super';\nvar extendsHelperName = '__extends';\n\nfunction getPrefixClassesTransformer() {\n  return function (context) {\n    var transformer = function transformer(sf) {\n      var visitor = function visitor(node) {\n        // Add pure comment to downleveled classes.\n        if (ts.isVariableStatement(node) && isDownleveledClass(node)) {\n          var varDecl = node.declarationList.declarations[0];\n          var varInitializer = varDecl.initializer; // Update node with the pure comment before the variable declaration initializer.\n\n          var newNode = ts.updateVariableStatement(node, node.modifiers, ts.updateVariableDeclarationList(node.declarationList, [ts.updateVariableDeclaration(varDecl, varDecl.name, varDecl.type, ast_utils_1.addPureComment(varInitializer))])); // Replace node with modified one.\n\n          return ts.visitEachChild(newNode, visitor, context);\n        } // Otherwise return node as is.\n\n\n        return ts.visitEachChild(node, visitor, context);\n      };\n\n      return ts.visitEachChild(sf, visitor, context);\n    };\n\n    return transformer;\n  };\n}\n\nexports.getPrefixClassesTransformer = getPrefixClassesTransformer; // Determine if a node matched the structure of a downleveled TS class.\n\nfunction isDownleveledClass(node) {\n  if (!ts.isVariableStatement(node)) {\n    return false;\n  }\n\n  if (node.declarationList.declarations.length !== 1) {\n    return false;\n  }\n\n  var variableDeclaration = node.declarationList.declarations[0];\n\n  if (!ts.isIdentifier(variableDeclaration.name) || !variableDeclaration.initializer) {\n    return false;\n  }\n\n  var potentialClass = variableDeclaration.initializer; // TS 2.3 has an unwrapped class IIFE\n  // TS 2.4 uses a function expression wrapper\n  // TS 2.5 uses an arrow function wrapper\n\n  if (ts.isParenthesizedExpression(potentialClass)) {\n    potentialClass = potentialClass.expression;\n  }\n\n  if (!ts.isCallExpression(potentialClass) || potentialClass.arguments.length > 1) {\n    return false;\n  }\n\n  var wrapperBody;\n\n  if (ts.isFunctionExpression(potentialClass.expression)) {\n    wrapperBody = potentialClass.expression.body;\n  } else if (ts.isArrowFunction(potentialClass.expression) && ts.isBlock(potentialClass.expression.body)) {\n    wrapperBody = potentialClass.expression.body;\n  } else {\n    return false;\n  }\n\n  if (wrapperBody.statements.length === 0) {\n    return false;\n  }\n\n  var functionExpression = potentialClass.expression;\n  var functionStatements = wrapperBody.statements; // need a minimum of two for a function declaration and return statement\n\n  if (functionStatements.length < 2) {\n    return false;\n  }\n\n  var firstStatement = functionStatements[0]; // find return statement - may not be last statement\n\n  var returnStatement;\n\n  for (var i = functionStatements.length - 1; i > 0; i--) {\n    if (ts.isReturnStatement(functionStatements[i])) {\n      returnStatement = functionStatements[i];\n      break;\n    }\n  }\n\n  if (returnStatement == undefined || returnStatement.expression == undefined || !ts.isIdentifier(returnStatement.expression)) {\n    return false;\n  }\n\n  if (functionExpression.parameters.length === 0) {\n    // potential non-extended class or wrapped es2015 class\n    return (ts.isFunctionDeclaration(firstStatement) || ts.isClassDeclaration(firstStatement)) && firstStatement.name !== undefined && returnStatement.expression.text === firstStatement.name.text;\n  } else if (functionExpression.parameters.length !== 1) {\n    return false;\n  } // Potential extended class\n\n\n  var functionParameter = functionExpression.parameters[0];\n\n  if (!ts.isIdentifier(functionParameter.name) || functionParameter.name.text !== superParameterName) {\n    return false;\n  }\n\n  if (functionStatements.length < 3 || !ts.isExpressionStatement(firstStatement)) {\n    return false;\n  }\n\n  if (!ts.isCallExpression(firstStatement.expression)) {\n    return false;\n  }\n\n  var extendCallExpression = firstStatement.expression;\n  var functionName;\n\n  if (ts.isIdentifier(extendCallExpression.expression)) {\n    functionName = extendCallExpression.expression.text;\n  } else if (ts.isPropertyAccessExpression(extendCallExpression.expression)) {\n    functionName = extendCallExpression.expression.name.text;\n  }\n\n  if (!functionName || !functionName.endsWith(extendsHelperName)) {\n    return false;\n  }\n\n  if (extendCallExpression.arguments.length === 0) {\n    return false;\n  }\n\n  var lastArgument = extendCallExpression.arguments[extendCallExpression.arguments.length - 1];\n\n  if (!ts.isIdentifier(lastArgument) || lastArgument.text !== functionParameter.name.text) {\n    return false;\n  }\n\n  var secondStatement = functionStatements[1];\n  return ts.isFunctionDeclaration(secondStatement) && secondStatement.name !== undefined && returnStatement.expression.text === secondStatement.name.text;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-optimizer/src/transforms/prefix-classes.js"],"names":["Object","defineProperty","exports","value","getPrefixClassesTransformer","testPrefixClasses","ts","require","ast_utils_1","content","exportVarSetter","multiLineComment","newLine","regexes","map","arr","RegExp","x","source","join","some","regex","test","superParameterName","extendsHelperName","context","transformer","sf","visitor","node","isVariableStatement","isDownleveledClass","varDecl","declarationList","declarations","varInitializer","initializer","newNode","updateVariableStatement","modifiers","updateVariableDeclarationList","updateVariableDeclaration","name","type","addPureComment","visitEachChild","length","variableDeclaration","isIdentifier","potentialClass","isParenthesizedExpression","expression","isCallExpression","arguments","wrapperBody","isFunctionExpression","body","isArrowFunction","isBlock","statements","functionExpression","functionStatements","firstStatement","returnStatement","i","isReturnStatement","undefined","parameters","isFunctionDeclaration","isClassDeclaration","text","functionParameter","isExpressionStatement","extendCallExpression","functionName","isPropertyAccessExpression","endsWith","lastArgument","secondStatement"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getPrefixClassesTransformer = exports.testPrefixClasses = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ts = require(\"typescript\");\nconst ast_utils_1 = require(\"../helpers/ast-utils\");\nfunction testPrefixClasses(content) {\n    const exportVarSetter = /(?:export )?(?:var|const)\\s+(?:\\S+)\\s*=\\s*/;\n    const multiLineComment = /\\s*(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*/;\n    const newLine = /\\s*\\r?\\n\\s*/;\n    const regexes = [\n        [\n            /^/,\n            exportVarSetter, multiLineComment,\n            /\\(/, multiLineComment,\n            /\\s*function \\(\\) {/, newLine,\n            multiLineComment,\n            /function (?:\\S+)\\([^\\)]*\\) \\{/, newLine,\n        ],\n        [\n            /^/,\n            exportVarSetter, multiLineComment,\n            /\\(/, multiLineComment,\n            /\\s*function \\(_super\\) {/, newLine,\n            /\\S*\\.?__extends\\(\\S+, _super\\);/,\n        ],\n    ].map(arr => new RegExp(arr.map(x => x.source).join(''), 'm'));\n    return regexes.some((regex) => regex.test(content));\n}\nexports.testPrefixClasses = testPrefixClasses;\nconst superParameterName = '_super';\nconst extendsHelperName = '__extends';\nfunction getPrefixClassesTransformer() {\n    return (context) => {\n        const transformer = (sf) => {\n            const visitor = (node) => {\n                // Add pure comment to downleveled classes.\n                if (ts.isVariableStatement(node) && isDownleveledClass(node)) {\n                    const varDecl = node.declarationList.declarations[0];\n                    const varInitializer = varDecl.initializer;\n                    // Update node with the pure comment before the variable declaration initializer.\n                    const newNode = ts.updateVariableStatement(node, node.modifiers, ts.updateVariableDeclarationList(node.declarationList, [\n                        ts.updateVariableDeclaration(varDecl, varDecl.name, varDecl.type, ast_utils_1.addPureComment(varInitializer)),\n                    ]));\n                    // Replace node with modified one.\n                    return ts.visitEachChild(newNode, visitor, context);\n                }\n                // Otherwise return node as is.\n                return ts.visitEachChild(node, visitor, context);\n            };\n            return ts.visitEachChild(sf, visitor, context);\n        };\n        return transformer;\n    };\n}\nexports.getPrefixClassesTransformer = getPrefixClassesTransformer;\n// Determine if a node matched the structure of a downleveled TS class.\nfunction isDownleveledClass(node) {\n    if (!ts.isVariableStatement(node)) {\n        return false;\n    }\n    if (node.declarationList.declarations.length !== 1) {\n        return false;\n    }\n    const variableDeclaration = node.declarationList.declarations[0];\n    if (!ts.isIdentifier(variableDeclaration.name)\n        || !variableDeclaration.initializer) {\n        return false;\n    }\n    let potentialClass = variableDeclaration.initializer;\n    // TS 2.3 has an unwrapped class IIFE\n    // TS 2.4 uses a function expression wrapper\n    // TS 2.5 uses an arrow function wrapper\n    if (ts.isParenthesizedExpression(potentialClass)) {\n        potentialClass = potentialClass.expression;\n    }\n    if (!ts.isCallExpression(potentialClass) || potentialClass.arguments.length > 1) {\n        return false;\n    }\n    let wrapperBody;\n    if (ts.isFunctionExpression(potentialClass.expression)) {\n        wrapperBody = potentialClass.expression.body;\n    }\n    else if (ts.isArrowFunction(potentialClass.expression)\n        && ts.isBlock(potentialClass.expression.body)) {\n        wrapperBody = potentialClass.expression.body;\n    }\n    else {\n        return false;\n    }\n    if (wrapperBody.statements.length === 0) {\n        return false;\n    }\n    const functionExpression = potentialClass.expression;\n    const functionStatements = wrapperBody.statements;\n    // need a minimum of two for a function declaration and return statement\n    if (functionStatements.length < 2) {\n        return false;\n    }\n    const firstStatement = functionStatements[0];\n    // find return statement - may not be last statement\n    let returnStatement;\n    for (let i = functionStatements.length - 1; i > 0; i--) {\n        if (ts.isReturnStatement(functionStatements[i])) {\n            returnStatement = functionStatements[i];\n            break;\n        }\n    }\n    if (returnStatement == undefined\n        || returnStatement.expression == undefined\n        || !ts.isIdentifier(returnStatement.expression)) {\n        return false;\n    }\n    if (functionExpression.parameters.length === 0) {\n        // potential non-extended class or wrapped es2015 class\n        return (ts.isFunctionDeclaration(firstStatement) || ts.isClassDeclaration(firstStatement))\n            && firstStatement.name !== undefined\n            && returnStatement.expression.text === firstStatement.name.text;\n    }\n    else if (functionExpression.parameters.length !== 1) {\n        return false;\n    }\n    // Potential extended class\n    const functionParameter = functionExpression.parameters[0];\n    if (!ts.isIdentifier(functionParameter.name)\n        || functionParameter.name.text !== superParameterName) {\n        return false;\n    }\n    if (functionStatements.length < 3 || !ts.isExpressionStatement(firstStatement)) {\n        return false;\n    }\n    if (!ts.isCallExpression(firstStatement.expression)) {\n        return false;\n    }\n    const extendCallExpression = firstStatement.expression;\n    let functionName;\n    if (ts.isIdentifier(extendCallExpression.expression)) {\n        functionName = extendCallExpression.expression.text;\n    }\n    else if (ts.isPropertyAccessExpression(extendCallExpression.expression)) {\n        functionName = extendCallExpression.expression.name.text;\n    }\n    if (!functionName || !functionName.endsWith(extendsHelperName)) {\n        return false;\n    }\n    if (extendCallExpression.arguments.length === 0) {\n        return false;\n    }\n    const lastArgument = extendCallExpression.arguments[extendCallExpression.arguments.length - 1];\n    if (!ts.isIdentifier(lastArgument) || lastArgument.text !== functionParameter.name.text) {\n        return false;\n    }\n    const secondStatement = functionStatements[1];\n    return ts.isFunctionDeclaration(secondStatement)\n        && secondStatement.name !== undefined\n        && returnStatement.expression.text === secondStatement.name.text;\n}\n"]},"metadata":{},"sourceType":"script"}