{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/diagnostics\", [\"require\", \"exports\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.translateDiagnostic = exports.shouldReportDiagnostic = exports.addTemplateId = exports.addParseSpanInfo = exports.wrapForTypeChecker = exports.wrapForDiagnostics = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\");\n\n  var tcb_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\");\n  /**\n   * Wraps the node in parenthesis such that inserted span comments become attached to the proper\n   * node. This is an alias for `ts.createParen` with the benefit that it signifies that the\n   * inserted parenthesis are for diagnostic purposes, not for correctness of the rendered TCB code.\n   *\n   * Note that it is important that nodes and its attached comment are not wrapped into parenthesis\n   * by default, as it prevents correct translation of e.g. diagnostics produced for incorrect method\n   * arguments. Such diagnostics would then be produced for the parenthesised node whereas the\n   * positional comment would be located within that node, resulting in a mismatch.\n   */\n\n\n  function wrapForDiagnostics(expr) {\n    return ts.createParen(expr);\n  }\n\n  exports.wrapForDiagnostics = wrapForDiagnostics;\n  /**\n   * Wraps the node in parenthesis such that inserted span comments become attached to the proper\n   * node. This is an alias for `ts.createParen` with the benefit that it signifies that the\n   * inserted parenthesis are for use by the type checker, not for correctness of the rendered TCB\n   * code.\n   */\n\n  function wrapForTypeChecker(expr) {\n    return ts.createParen(expr);\n  }\n\n  exports.wrapForTypeChecker = wrapForTypeChecker;\n  /**\n   * Adds a synthetic comment to the expression that represents the parse span of the provided node.\n   * This comment can later be retrieved as trivia of a node to recover original source locations.\n   */\n\n  function addParseSpanInfo(node, span) {\n    var commentText;\n\n    if (span instanceof compiler_1.AbsoluteSourceSpan) {\n      commentText = span.start + \",\" + span.end;\n    } else {\n      commentText = span.start.offset + \",\" + span.end.offset;\n    }\n\n    ts.addSyntheticTrailingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, commentText,\n    /* hasTrailingNewLine */\n    false);\n  }\n\n  exports.addParseSpanInfo = addParseSpanInfo;\n  /**\n   * Adds a synthetic comment to the function declaration that contains the template id\n   * of the class declaration.\n   */\n\n  function addTemplateId(tcb, id) {\n    ts.addSyntheticLeadingComment(tcb, ts.SyntaxKind.MultiLineCommentTrivia, id, true);\n  }\n\n  exports.addTemplateId = addTemplateId;\n  /**\n   * Determines if the diagnostic should be reported. Some diagnostics are produced because of the\n   * way TCBs are generated; those diagnostics should not be reported as type check errors of the\n   * template.\n   */\n\n  function shouldReportDiagnostic(diagnostic) {\n    var code = diagnostic.code;\n\n    if (code === 6133\n    /* $var is declared but its value is never read. */\n    ) {\n        return false;\n      } else if (code === 6199\n    /* All variables are unused. */\n    ) {\n        return false;\n      } else if (code === 2695\n    /* Left side of comma operator is unused and has no side effects. */\n    ) {\n        return false;\n      } else if (code === 7006\n    /* Parameter '$event' implicitly has an 'any' type. */\n    ) {\n        return false;\n      }\n\n    return true;\n  }\n\n  exports.shouldReportDiagnostic = shouldReportDiagnostic;\n  /**\n   * Attempts to translate a TypeScript diagnostic produced during template type-checking to their\n   * location of origin, based on the comments that are emitted in the TCB code.\n   *\n   * If the diagnostic could not be translated, `null` is returned to indicate that the diagnostic\n   * should not be reported at all. This prevents diagnostics from non-TCB code in a user's source\n   * file from being reported as type-check errors.\n   */\n\n  function translateDiagnostic(diagnostic, resolver) {\n    if (diagnostic.file === undefined || diagnostic.start === undefined) {\n      return null;\n    }\n\n    var fullMapping = tcb_util_1.getTemplateMapping(diagnostic.file, diagnostic.start, resolver,\n    /*isDiagnosticsRequest*/\n    true);\n\n    if (fullMapping === null) {\n      return null;\n    }\n\n    var sourceLocation = fullMapping.sourceLocation,\n        templateSourceMapping = fullMapping.templateSourceMapping,\n        span = fullMapping.span;\n    return diagnostics_1.makeTemplateDiagnostic(sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code, diagnostic.messageText);\n  }\n\n  exports.translateDiagnostic = translateDiagnostic;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/diagnostics.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\nimport * as ts from 'typescript';\nimport {TemplateId} from '../api';\nimport {makeTemplateDiagnostic, TemplateDiagnostic} from '../diagnostics';\nimport {getTemplateMapping, TemplateSourceResolver} from './tcb_util';\n\n\n/**\n * Wraps the node in parenthesis such that inserted span comments become attached to the proper\n * node. This is an alias for `ts.createParen` with the benefit that it signifies that the\n * inserted parenthesis are for diagnostic purposes, not for correctness of the rendered TCB code.\n *\n * Note that it is important that nodes and its attached comment are not wrapped into parenthesis\n * by default, as it prevents correct translation of e.g. diagnostics produced for incorrect method\n * arguments. Such diagnostics would then be produced for the parenthesised node whereas the\n * positional comment would be located within that node, resulting in a mismatch.\n */\nexport function wrapForDiagnostics(expr: ts.Expression): ts.Expression {\n  return ts.createParen(expr);\n}\n\n/**\n * Wraps the node in parenthesis such that inserted span comments become attached to the proper\n * node. This is an alias for `ts.createParen` with the benefit that it signifies that the\n * inserted parenthesis are for use by the type checker, not for correctness of the rendered TCB\n * code.\n */\nexport function wrapForTypeChecker(expr: ts.Expression): ts.Expression {\n  return ts.createParen(expr);\n}\n\n/**\n * Adds a synthetic comment to the expression that represents the parse span of the provided node.\n * This comment can later be retrieved as trivia of a node to recover original source locations.\n */\nexport function addParseSpanInfo(node: ts.Node, span: AbsoluteSourceSpan|ParseSourceSpan): void {\n  let commentText: string;\n  if (span instanceof AbsoluteSourceSpan) {\n    commentText = `${span.start},${span.end}`;\n  } else {\n    commentText = `${span.start.offset},${span.end.offset}`;\n  }\n  ts.addSyntheticTrailingComment(\n      node, ts.SyntaxKind.MultiLineCommentTrivia, commentText, /* hasTrailingNewLine */ false);\n}\n\n/**\n * Adds a synthetic comment to the function declaration that contains the template id\n * of the class declaration.\n */\nexport function addTemplateId(tcb: ts.FunctionDeclaration, id: TemplateId): void {\n  ts.addSyntheticLeadingComment(tcb, ts.SyntaxKind.MultiLineCommentTrivia, id, true);\n}\n\n/**\n * Determines if the diagnostic should be reported. Some diagnostics are produced because of the\n * way TCBs are generated; those diagnostics should not be reported as type check errors of the\n * template.\n */\nexport function shouldReportDiagnostic(diagnostic: ts.Diagnostic): boolean {\n  const {code} = diagnostic;\n  if (code === 6133 /* $var is declared but its value is never read. */) {\n    return false;\n  } else if (code === 6199 /* All variables are unused. */) {\n    return false;\n  } else if (code === 2695 /* Left side of comma operator is unused and has no side effects. */) {\n    return false;\n  } else if (code === 7006 /* Parameter '$event' implicitly has an 'any' type. */) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Attempts to translate a TypeScript diagnostic produced during template type-checking to their\n * location of origin, based on the comments that are emitted in the TCB code.\n *\n * If the diagnostic could not be translated, `null` is returned to indicate that the diagnostic\n * should not be reported at all. This prevents diagnostics from non-TCB code in a user's source\n * file from being reported as type-check errors.\n */\nexport function translateDiagnostic(\n    diagnostic: ts.Diagnostic, resolver: TemplateSourceResolver): TemplateDiagnostic|null {\n  if (diagnostic.file === undefined || diagnostic.start === undefined) {\n    return null;\n  }\n  const fullMapping = getTemplateMapping(\n      diagnostic.file, diagnostic.start, resolver, /*isDiagnosticsRequest*/ true);\n  if (fullMapping === null) {\n    return null;\n  }\n\n  const {sourceLocation, templateSourceMapping, span} = fullMapping;\n  return makeTemplateDiagnostic(\n      sourceLocation.id, templateSourceMapping, span, diagnostic.category, diagnostic.code,\n      diagnostic.messageText);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}