{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runModuleAsObservableFork = void 0;\n\nvar child_process_1 = require(\"child_process\");\n\nvar path_1 = require(\"path\");\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar treeKill = require('tree-kill');\n\nfunction runModuleAsObservableFork(cwd, modulePath, exportName, // tslint:disable-next-line:no-any\nargs) {\n  return new rxjs_1.Observable(function (obs) {\n    var workerPath = path_1.resolve(__dirname, './run-module-worker.js');\n    var debugArgRegex = /--inspect(?:-brk|-port)?|--debug(?:-brk|-port)/;\n    var execArgv = process.execArgv.filter(function (arg) {\n      // Remove debug args.\n      // Workaround for https://github.com/nodejs/node/issues/9435\n      return !debugArgRegex.test(arg);\n    });\n    var forkOptions = {\n      cwd: cwd,\n      execArgv: execArgv\n    }; // TODO: support passing in a logger to use as stdio streams\n    // if (logger) {\n    //   (forkOptions as any).stdio = [\n    //     'ignore',\n    //     logger.info, // make it a stream\n    //     logger.error, // make it a stream\n    //   ];\n    // }\n\n    var forkedProcess = child_process_1.fork(workerPath, undefined, forkOptions); // Cleanup.\n\n    var killForkedProcess = function killForkedProcess() {\n      if (forkedProcess && forkedProcess.pid) {\n        treeKill(forkedProcess.pid, 'SIGTERM');\n      }\n    }; // Handle child process exit.\n\n\n    var handleChildProcessExit = function handleChildProcessExit(code) {\n      killForkedProcess();\n\n      if (code && code !== 0) {\n        obs.error();\n      }\n\n      obs.next({\n        success: true\n      });\n      obs.complete();\n    };\n\n    forkedProcess.once('exit', handleChildProcessExit);\n    forkedProcess.once('SIGINT', handleChildProcessExit);\n    forkedProcess.once('uncaughtException', handleChildProcessExit); // Handle parent process exit.\n\n    var handleParentProcessExit = function handleParentProcessExit() {\n      killForkedProcess();\n    };\n\n    process.once('exit', handleParentProcessExit);\n    process.once('SIGINT', handleParentProcessExit);\n    process.once('uncaughtException', handleParentProcessExit); // Run module.\n\n    forkedProcess.send({\n      hash: '5d4b9a5c0a4e0f9977598437b0e85bcc',\n      modulePath: modulePath,\n      exportName: exportName,\n      args: args\n    }); // Teardown logic. When unsubscribing, kill the forked process.\n\n    return killForkedProcess;\n  });\n}\n\nexports.runModuleAsObservableFork = runModuleAsObservableFork;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/src/utils/run-module-as-observable-fork.js"],"names":["Object","defineProperty","exports","value","runModuleAsObservableFork","child_process_1","require","path_1","rxjs_1","treeKill","cwd","modulePath","exportName","args","Observable","obs","workerPath","resolve","__dirname","debugArgRegex","execArgv","process","filter","arg","test","forkOptions","forkedProcess","fork","undefined","killForkedProcess","pid","handleChildProcessExit","code","error","next","success","complete","once","handleParentProcessExit","send","hash"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.runModuleAsObservableFork = void 0;\nconst child_process_1 = require(\"child_process\");\nconst path_1 = require(\"path\");\nconst rxjs_1 = require(\"rxjs\");\nconst treeKill = require('tree-kill');\nfunction runModuleAsObservableFork(cwd, modulePath, exportName, \n// tslint:disable-next-line:no-any\nargs) {\n    return new rxjs_1.Observable(obs => {\n        const workerPath = path_1.resolve(__dirname, './run-module-worker.js');\n        const debugArgRegex = /--inspect(?:-brk|-port)?|--debug(?:-brk|-port)/;\n        const execArgv = process.execArgv.filter((arg) => {\n            // Remove debug args.\n            // Workaround for https://github.com/nodejs/node/issues/9435\n            return !debugArgRegex.test(arg);\n        });\n        const forkOptions = {\n            cwd,\n            execArgv,\n        };\n        // TODO: support passing in a logger to use as stdio streams\n        // if (logger) {\n        //   (forkOptions as any).stdio = [\n        //     'ignore',\n        //     logger.info, // make it a stream\n        //     logger.error, // make it a stream\n        //   ];\n        // }\n        const forkedProcess = child_process_1.fork(workerPath, undefined, forkOptions);\n        // Cleanup.\n        const killForkedProcess = () => {\n            if (forkedProcess && forkedProcess.pid) {\n                treeKill(forkedProcess.pid, 'SIGTERM');\n            }\n        };\n        // Handle child process exit.\n        const handleChildProcessExit = (code) => {\n            killForkedProcess();\n            if (code && code !== 0) {\n                obs.error();\n            }\n            obs.next({ success: true });\n            obs.complete();\n        };\n        forkedProcess.once('exit', handleChildProcessExit);\n        forkedProcess.once('SIGINT', handleChildProcessExit);\n        forkedProcess.once('uncaughtException', handleChildProcessExit);\n        // Handle parent process exit.\n        const handleParentProcessExit = () => {\n            killForkedProcess();\n        };\n        process.once('exit', handleParentProcessExit);\n        process.once('SIGINT', handleParentProcessExit);\n        process.once('uncaughtException', handleParentProcessExit);\n        // Run module.\n        forkedProcess.send({\n            hash: '5d4b9a5c0a4e0f9977598437b0e85bcc',\n            modulePath,\n            exportName,\n            args,\n        });\n        // Teardown logic. When unsubscribing, kill the forked process.\n        return killForkedProcess;\n    });\n}\nexports.runModuleAsObservableFork = runModuleAsObservableFork;\n"]},"metadata":{},"sourceType":"script"}