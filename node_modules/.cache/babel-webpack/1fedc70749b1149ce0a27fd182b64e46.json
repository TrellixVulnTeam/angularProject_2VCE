{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/shims/src/factory_generator\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/shims/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.generatedFactoryTransform = exports.FactoryGenerator = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/shims/src/util\");\n\n  var TS_DTS_SUFFIX = /(\\.d)?\\.ts$/;\n  var STRIP_NG_FACTORY = /(.*)NgFactory$/;\n  /**\n   * Generates ts.SourceFiles which contain variable declarations for NgFactories for every exported\n   * class of an input ts.SourceFile.\n   */\n\n  var FactoryGenerator =\n  /** @class */\n  function () {\n    function FactoryGenerator() {\n      this.sourceInfo = new Map();\n      this.sourceToFactorySymbols = new Map();\n      this.shouldEmit = true;\n      this.extensionPrefix = 'ngfactory';\n    }\n\n    FactoryGenerator.prototype.generateShimForFile = function (sf, genFilePath) {\n      var absoluteSfPath = file_system_1.absoluteFromSourceFile(sf);\n      var relativePathToSource = './' + file_system_1.basename(sf.fileName).replace(TS_DTS_SUFFIX, ''); // Collect a list of classes that need to have factory types emitted for them. This list is\n      // overly broad as at this point the ts.TypeChecker hasn't been created, and can't be used to\n      // semantically understand which decorated types are actually decorated with Angular decorators.\n      //\n      // The exports generated here are pruned in the factory transform during emit.\n\n      var symbolNames = sf.statements // Pick out top level class declarations...\n      .filter(ts.isClassDeclaration) // which are named, exported, and have decorators.\n      .filter(function (decl) {\n        return isExported(decl) && decl.decorators !== undefined && decl.name !== undefined;\n      }) // Grab the symbol name.\n      .map(function (decl) {\n        return decl.name.text;\n      });\n      var sourceText = ''; // If there is a top-level comment in the original file, copy it over at the top of the\n      // generated factory file. This is important for preserving any load-bearing jsdoc comments.\n\n      var leadingComment = getFileoverviewComment(sf);\n\n      if (leadingComment !== null) {\n        // Leading comments must be separated from the rest of the contents by a blank line.\n        sourceText = leadingComment + '\\n\\n';\n      }\n\n      if (symbolNames.length > 0) {\n        // For each symbol name, generate a constant export of the corresponding NgFactory.\n        // This will encompass a lot of symbols which don't need factories, but that's okay\n        // because it won't miss any that do.\n        var varLines = symbolNames.map(function (name) {\n          return \"export const \" + name + \"NgFactory: i0.\\u0275NgModuleFactory<any> = new i0.\\u0275NgModuleFactory(\" + name + \");\";\n        });\n        sourceText += tslib_1.__spread([// This might be incorrect if the current package being compiled is Angular core, but it's\n        // okay to leave in at type checking time. TypeScript can handle this reference via its path\n        // mapping, but downstream bundlers can't. If the current package is core itself, this will\n        // be replaced in the factory transformer before emit.\n        \"import * as i0 from '@angular/core';\", \"import {\" + symbolNames.join(', ') + \"} from '\" + relativePathToSource + \"';\"], varLines).join('\\n');\n      } // Add an extra export to ensure this module has at least one. It'll be removed later in the\n      // factory transformer if it ends up not being needed.\n\n\n      sourceText += '\\nexport const ɵNonEmptyModule = true;';\n      var genFile = ts.createSourceFile(genFilePath, sourceText, sf.languageVersion, true, ts.ScriptKind.TS);\n\n      if (sf.moduleName !== undefined) {\n        genFile.moduleName = util_1.generatedModuleName(sf.moduleName, sf.fileName, '.ngfactory');\n      }\n\n      var moduleSymbols = new Map();\n      this.sourceToFactorySymbols.set(absoluteSfPath, moduleSymbols);\n      this.sourceInfo.set(genFilePath, {\n        sourceFilePath: absoluteSfPath,\n        moduleSymbols: moduleSymbols\n      });\n      return genFile;\n    };\n\n    FactoryGenerator.prototype.track = function (sf, moduleInfo) {\n      if (this.sourceToFactorySymbols.has(sf.fileName)) {\n        this.sourceToFactorySymbols.get(sf.fileName).set(moduleInfo.name, moduleInfo);\n      }\n    };\n\n    return FactoryGenerator;\n  }();\n\n  exports.FactoryGenerator = FactoryGenerator;\n\n  function isExported(decl) {\n    return decl.modifiers !== undefined && decl.modifiers.some(function (mod) {\n      return mod.kind == ts.SyntaxKind.ExportKeyword;\n    });\n  }\n\n  function generatedFactoryTransform(factoryMap, importRewriter) {\n    return function (context) {\n      return function (file) {\n        return transformFactorySourceFile(factoryMap, context, importRewriter, file);\n      };\n    };\n  }\n\n  exports.generatedFactoryTransform = generatedFactoryTransform;\n\n  function transformFactorySourceFile(factoryMap, context, importRewriter, file) {\n    var e_1, _a; // If this is not a generated file, it won't have factory info associated with it.\n\n\n    if (!factoryMap.has(file.fileName)) {\n      // Don't transform non-generated code.\n      return file;\n    }\n\n    var _b = factoryMap.get(file.fileName),\n        moduleSymbols = _b.moduleSymbols,\n        sourceFilePath = _b.sourceFilePath; // Not every exported factory statement is valid. They were generated before the program was\n    // analyzed, and before ngtsc knew which symbols were actually NgModules. factoryMap contains\n    // that knowledge now, so this transform filters the statement list and removes exported factories\n    // that aren't actually factories.\n    //\n    // This could leave the generated factory file empty. To prevent this (it causes issues with\n    // closure compiler) a 'ɵNonEmptyModule' export was added when the factory shim was created.\n    // Preserve that export if needed, and remove it otherwise.\n    //\n    // Additionally, an import to @angular/core is generated, but the current compilation unit could\n    // actually be @angular/core, in which case such an import is invalid and should be replaced with\n    // the proper path to access Ivy symbols in core.\n    // The filtered set of statements.\n\n\n    var transformedStatements = []; // The statement identified as the ɵNonEmptyModule export.\n\n    var nonEmptyExport = null; // Extracted identifiers which refer to import statements from @angular/core.\n\n    var coreImportIdentifiers = new Set();\n\n    try {\n      // Consider all the statements.\n      for (var _c = tslib_1.__values(file.statements), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var stmt = _d.value; // Look for imports to @angular/core.\n\n        if (ts.isImportDeclaration(stmt) && ts.isStringLiteral(stmt.moduleSpecifier) && stmt.moduleSpecifier.text === '@angular/core') {\n          // Update the import path to point to the correct file using the ImportRewriter.\n          var rewrittenModuleSpecifier = importRewriter.rewriteSpecifier('@angular/core', sourceFilePath);\n\n          if (rewrittenModuleSpecifier !== stmt.moduleSpecifier.text) {\n            transformedStatements.push(ts.updateImportDeclaration(stmt, stmt.decorators, stmt.modifiers, stmt.importClause, ts.createStringLiteral(rewrittenModuleSpecifier))); // Record the identifier by which this imported module goes, so references to its symbols\n            // can be discovered later.\n\n            if (stmt.importClause !== undefined && stmt.importClause.namedBindings !== undefined && ts.isNamespaceImport(stmt.importClause.namedBindings)) {\n              coreImportIdentifiers.add(stmt.importClause.namedBindings.name.text);\n            }\n          } else {\n            transformedStatements.push(stmt);\n          }\n        } else if (ts.isVariableStatement(stmt) && stmt.declarationList.declarations.length === 1) {\n          var decl = stmt.declarationList.declarations[0]; // If this is the ɵNonEmptyModule export, then save it for later.\n\n          if (ts.isIdentifier(decl.name)) {\n            if (decl.name.text === 'ɵNonEmptyModule') {\n              nonEmptyExport = stmt;\n              continue;\n            } // Otherwise, check if this export is a factory for a known NgModule, and retain it if so.\n\n\n            var match = STRIP_NG_FACTORY.exec(decl.name.text);\n            var module_1 = match ? moduleSymbols.get(match[1]) : null;\n\n            if (module_1) {\n              // If the module can be tree shaken, then the factory should be wrapped in a\n              // `noSideEffects()` call which tells Closure to treat the expression as pure, allowing\n              // it to be removed if the result is not used.\n              //\n              // `NgModule`s with an `id` property will be lazy loaded. Google-internal lazy loading\n              // infra relies on a side effect from the `new NgModuleFactory()` call, which registers\n              // the module globally. Because of this, we **cannot** tree shake any module which has\n              // an `id` property. Doing so would cause lazy loaded modules to never be registered.\n              var moduleIsTreeShakable = !module_1.hasId;\n              var newStmt = !moduleIsTreeShakable ? stmt : updateInitializers(stmt, function (init) {\n                return init ? wrapInNoSideEffects(init) : undefined;\n              });\n              transformedStatements.push(newStmt);\n            }\n          } else {\n            // Leave the statement alone, as it can't be understood.\n            transformedStatements.push(stmt);\n          }\n        } else {\n          // Include non-variable statements (imports, etc).\n          transformedStatements.push(stmt);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    } // Check whether the empty module export is still needed.\n\n\n    if (!transformedStatements.some(ts.isVariableStatement) && nonEmptyExport !== null) {\n      // If the resulting file has no factories, include an empty export to\n      // satisfy closure compiler.\n      transformedStatements.push(nonEmptyExport);\n    }\n\n    file = ts.updateSourceFileNode(file, transformedStatements); // If any imports to @angular/core were detected and rewritten (which happens when compiling\n    // @angular/core), go through the SourceFile and rewrite references to symbols imported from core.\n\n    if (coreImportIdentifiers.size > 0) {\n      var visit_1 = function visit_1(node) {\n        node = ts.visitEachChild(node, function (child) {\n          return visit_1(child);\n        }, context); // Look for expressions of the form \"i.s\" where 'i' is a detected name for an @angular/core\n        // import that was changed above. Rewrite 's' using the ImportResolver.\n\n        if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.expression) && coreImportIdentifiers.has(node.expression.text)) {\n          // This is an import of a symbol from @angular/core. Transform it with the importRewriter.\n          var rewrittenSymbol = importRewriter.rewriteSymbol(node.name.text, '@angular/core');\n\n          if (rewrittenSymbol !== node.name.text) {\n            var updated = ts.updatePropertyAccess(node, node.expression, ts.createIdentifier(rewrittenSymbol));\n            node = updated;\n          }\n        }\n\n        return node;\n      };\n\n      file = visit_1(file);\n    }\n\n    return file;\n  }\n  /**\n   * Parses and returns the comment text of a \\@fileoverview comment in the given source file.\n   */\n\n\n  function getFileoverviewComment(sourceFile) {\n    var text = sourceFile.getFullText();\n    var trivia = text.substring(0, sourceFile.getStart());\n    var leadingComments = ts.getLeadingCommentRanges(trivia, 0);\n\n    if (!leadingComments || leadingComments.length === 0) {\n      return null;\n    }\n\n    var comment = leadingComments[0];\n\n    if (comment.kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    } // Only comments separated with a \\n\\n from the file contents are considered file-level comments\n    // in TypeScript.\n\n\n    if (text.substring(comment.end, comment.end + 2) !== '\\n\\n') {\n      return null;\n    }\n\n    var commentText = text.substring(comment.pos, comment.end); // Closure Compiler ignores @suppress and similar if the comment contains @license.\n\n    if (commentText.indexOf('@license') !== -1) {\n      return null;\n    }\n\n    return commentText;\n  }\n  /**\n   * Wraps the given expression in a call to `ɵnoSideEffects()`, which tells\n   * Closure we don't care about the side effects of this expression and it should\n   * be treated as \"pure\". Closure is free to tree shake this expression if its\n   * result is not used.\n   *\n   * Example: Takes `1 + 2` and returns `i0.ɵnoSideEffects(() => 1 + 2)`.\n   */\n\n\n  function wrapInNoSideEffects(expr) {\n    var noSideEffects = ts.createPropertyAccess(ts.createIdentifier('i0'), 'ɵnoSideEffects');\n    return ts.createCall(noSideEffects,\n    /* typeArguments */\n    [],\n    /* arguments */\n    [ts.createFunctionExpression(\n    /* modifiers */\n    [],\n    /* asteriskToken */\n    undefined,\n    /* name */\n    undefined,\n    /* typeParameters */\n    [],\n    /* parameters */\n    [],\n    /* type */\n    undefined,\n    /* body */\n    ts.createBlock([ts.createReturn(expr)]))]);\n  }\n  /**\n   * Clones and updates the initializers for a given statement to use the new\n   * expression provided. Does not mutate the input statement.\n   */\n\n\n  function updateInitializers(stmt, update) {\n    return ts.updateVariableStatement(stmt, stmt.modifiers, ts.updateVariableDeclarationList(stmt.declarationList, stmt.declarationList.declarations.map(function (decl) {\n      return ts.updateVariableDeclaration(decl, decl.name, decl.type, update(decl.initializer));\n    })));\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/factory_generator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {absoluteFromSourceFile, AbsoluteFsPath, basename} from '../../file_system';\nimport {ImportRewriter} from '../../imports';\nimport {FactoryInfo, FactoryTracker, ModuleInfo, PerFileShimGenerator} from '../api';\n\nimport {generatedModuleName} from './util';\n\nconst TS_DTS_SUFFIX = /(\\.d)?\\.ts$/;\nconst STRIP_NG_FACTORY = /(.*)NgFactory$/;\n\n/**\n * Generates ts.SourceFiles which contain variable declarations for NgFactories for every exported\n * class of an input ts.SourceFile.\n */\nexport class FactoryGenerator implements PerFileShimGenerator, FactoryTracker {\n  readonly sourceInfo = new Map<string, FactoryInfo>();\n  private sourceToFactorySymbols = new Map<string, Map<string, ModuleInfo>>();\n\n  readonly shouldEmit = true;\n  readonly extensionPrefix = 'ngfactory';\n\n  generateShimForFile(sf: ts.SourceFile, genFilePath: AbsoluteFsPath): ts.SourceFile {\n    const absoluteSfPath = absoluteFromSourceFile(sf);\n\n    const relativePathToSource = './' + basename(sf.fileName).replace(TS_DTS_SUFFIX, '');\n    // Collect a list of classes that need to have factory types emitted for them. This list is\n    // overly broad as at this point the ts.TypeChecker hasn't been created, and can't be used to\n    // semantically understand which decorated types are actually decorated with Angular decorators.\n    //\n    // The exports generated here are pruned in the factory transform during emit.\n    const symbolNames = sf.statements\n                            // Pick out top level class declarations...\n                            .filter(ts.isClassDeclaration)\n                            // which are named, exported, and have decorators.\n                            .filter(\n                                decl => isExported(decl) && decl.decorators !== undefined &&\n                                    decl.name !== undefined)\n                            // Grab the symbol name.\n                            .map(decl => decl.name!.text);\n\n\n    let sourceText = '';\n\n    // If there is a top-level comment in the original file, copy it over at the top of the\n    // generated factory file. This is important for preserving any load-bearing jsdoc comments.\n    const leadingComment = getFileoverviewComment(sf);\n    if (leadingComment !== null) {\n      // Leading comments must be separated from the rest of the contents by a blank line.\n      sourceText = leadingComment + '\\n\\n';\n    }\n\n    if (symbolNames.length > 0) {\n      // For each symbol name, generate a constant export of the corresponding NgFactory.\n      // This will encompass a lot of symbols which don't need factories, but that's okay\n      // because it won't miss any that do.\n      const varLines = symbolNames.map(\n          name => `export const ${\n              name}NgFactory: i0.ɵNgModuleFactory<any> = new i0.ɵNgModuleFactory(${name});`);\n      sourceText += [\n        // This might be incorrect if the current package being compiled is Angular core, but it's\n        // okay to leave in at type checking time. TypeScript can handle this reference via its path\n        // mapping, but downstream bundlers can't. If the current package is core itself, this will\n        // be replaced in the factory transformer before emit.\n        `import * as i0 from '@angular/core';`,\n        `import {${symbolNames.join(', ')}} from '${relativePathToSource}';`,\n        ...varLines,\n      ].join('\\n');\n    }\n\n    // Add an extra export to ensure this module has at least one. It'll be removed later in the\n    // factory transformer if it ends up not being needed.\n    sourceText += '\\nexport const ɵNonEmptyModule = true;';\n\n    const genFile =\n        ts.createSourceFile(genFilePath, sourceText, sf.languageVersion, true, ts.ScriptKind.TS);\n    if (sf.moduleName !== undefined) {\n      genFile.moduleName = generatedModuleName(sf.moduleName, sf.fileName, '.ngfactory');\n    }\n\n    const moduleSymbols = new Map<string, ModuleInfo>();\n    this.sourceToFactorySymbols.set(absoluteSfPath, moduleSymbols);\n    this.sourceInfo.set(genFilePath, {\n      sourceFilePath: absoluteSfPath,\n      moduleSymbols,\n    });\n\n    return genFile;\n  }\n\n  track(sf: ts.SourceFile, moduleInfo: ModuleInfo): void {\n    if (this.sourceToFactorySymbols.has(sf.fileName)) {\n      this.sourceToFactorySymbols.get(sf.fileName)!.set(moduleInfo.name, moduleInfo);\n    }\n  }\n}\n\nfunction isExported(decl: ts.Declaration): boolean {\n  return decl.modifiers !== undefined &&\n      decl.modifiers.some(mod => mod.kind == ts.SyntaxKind.ExportKeyword);\n}\n\nexport function generatedFactoryTransform(\n    factoryMap: Map<string, FactoryInfo>,\n    importRewriter: ImportRewriter): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n    return (file: ts.SourceFile): ts.SourceFile => {\n      return transformFactorySourceFile(factoryMap, context, importRewriter, file);\n    };\n  };\n}\n\nfunction transformFactorySourceFile(\n    factoryMap: Map<string, FactoryInfo>, context: ts.TransformationContext,\n    importRewriter: ImportRewriter, file: ts.SourceFile): ts.SourceFile {\n  // If this is not a generated file, it won't have factory info associated with it.\n  if (!factoryMap.has(file.fileName)) {\n    // Don't transform non-generated code.\n    return file;\n  }\n\n  const {moduleSymbols, sourceFilePath} = factoryMap.get(file.fileName)!;\n\n  // Not every exported factory statement is valid. They were generated before the program was\n  // analyzed, and before ngtsc knew which symbols were actually NgModules. factoryMap contains\n  // that knowledge now, so this transform filters the statement list and removes exported factories\n  // that aren't actually factories.\n  //\n  // This could leave the generated factory file empty. To prevent this (it causes issues with\n  // closure compiler) a 'ɵNonEmptyModule' export was added when the factory shim was created.\n  // Preserve that export if needed, and remove it otherwise.\n  //\n  // Additionally, an import to @angular/core is generated, but the current compilation unit could\n  // actually be @angular/core, in which case such an import is invalid and should be replaced with\n  // the proper path to access Ivy symbols in core.\n\n  // The filtered set of statements.\n  const transformedStatements: ts.Statement[] = [];\n\n  // The statement identified as the ɵNonEmptyModule export.\n  let nonEmptyExport: ts.Statement|null = null;\n\n  // Extracted identifiers which refer to import statements from @angular/core.\n  const coreImportIdentifiers = new Set<string>();\n\n  // Consider all the statements.\n  for (const stmt of file.statements) {\n    // Look for imports to @angular/core.\n    if (ts.isImportDeclaration(stmt) && ts.isStringLiteral(stmt.moduleSpecifier) &&\n        stmt.moduleSpecifier.text === '@angular/core') {\n      // Update the import path to point to the correct file using the ImportRewriter.\n      const rewrittenModuleSpecifier =\n          importRewriter.rewriteSpecifier('@angular/core', sourceFilePath);\n      if (rewrittenModuleSpecifier !== stmt.moduleSpecifier.text) {\n        transformedStatements.push(ts.updateImportDeclaration(\n            stmt, stmt.decorators, stmt.modifiers, stmt.importClause,\n            ts.createStringLiteral(rewrittenModuleSpecifier)));\n\n        // Record the identifier by which this imported module goes, so references to its symbols\n        // can be discovered later.\n        if (stmt.importClause !== undefined && stmt.importClause.namedBindings !== undefined &&\n            ts.isNamespaceImport(stmt.importClause.namedBindings)) {\n          coreImportIdentifiers.add(stmt.importClause.namedBindings.name.text);\n        }\n      } else {\n        transformedStatements.push(stmt);\n      }\n    } else if (ts.isVariableStatement(stmt) && stmt.declarationList.declarations.length === 1) {\n      const decl = stmt.declarationList.declarations[0];\n\n      // If this is the ɵNonEmptyModule export, then save it for later.\n      if (ts.isIdentifier(decl.name)) {\n        if (decl.name.text === 'ɵNonEmptyModule') {\n          nonEmptyExport = stmt;\n          continue;\n        }\n\n        // Otherwise, check if this export is a factory for a known NgModule, and retain it if so.\n        const match = STRIP_NG_FACTORY.exec(decl.name.text);\n        const module = match ? moduleSymbols.get(match[1]) : null;\n        if (module) {\n          // If the module can be tree shaken, then the factory should be wrapped in a\n          // `noSideEffects()` call which tells Closure to treat the expression as pure, allowing\n          // it to be removed if the result is not used.\n          //\n          // `NgModule`s with an `id` property will be lazy loaded. Google-internal lazy loading\n          // infra relies on a side effect from the `new NgModuleFactory()` call, which registers\n          // the module globally. Because of this, we **cannot** tree shake any module which has\n          // an `id` property. Doing so would cause lazy loaded modules to never be registered.\n          const moduleIsTreeShakable = !module.hasId;\n          const newStmt = !moduleIsTreeShakable ?\n              stmt :\n              updateInitializers(\n                  stmt,\n                  (init) => init ? wrapInNoSideEffects(init) : undefined,\n              );\n          transformedStatements.push(newStmt);\n        }\n      } else {\n        // Leave the statement alone, as it can't be understood.\n        transformedStatements.push(stmt);\n      }\n    } else {\n      // Include non-variable statements (imports, etc).\n      transformedStatements.push(stmt);\n    }\n  }\n\n  // Check whether the empty module export is still needed.\n  if (!transformedStatements.some(ts.isVariableStatement) && nonEmptyExport !== null) {\n    // If the resulting file has no factories, include an empty export to\n    // satisfy closure compiler.\n    transformedStatements.push(nonEmptyExport);\n  }\n\n  file = ts.updateSourceFileNode(file, transformedStatements);\n\n  // If any imports to @angular/core were detected and rewritten (which happens when compiling\n  // @angular/core), go through the SourceFile and rewrite references to symbols imported from core.\n  if (coreImportIdentifiers.size > 0) {\n    const visit = <T extends ts.Node>(node: T): T => {\n      node = ts.visitEachChild(node, child => visit(child), context);\n\n      // Look for expressions of the form \"i.s\" where 'i' is a detected name for an @angular/core\n      // import that was changed above. Rewrite 's' using the ImportResolver.\n      if (ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.expression) &&\n          coreImportIdentifiers.has(node.expression.text)) {\n        // This is an import of a symbol from @angular/core. Transform it with the importRewriter.\n        const rewrittenSymbol = importRewriter.rewriteSymbol(node.name.text, '@angular/core');\n        if (rewrittenSymbol !== node.name.text) {\n          const updated =\n              ts.updatePropertyAccess(node, node.expression, ts.createIdentifier(rewrittenSymbol));\n          node = updated as T & ts.PropertyAccessExpression;\n        }\n      }\n      return node;\n    };\n\n    file = visit(file);\n  }\n\n  return file;\n}\n\n\n/**\n * Parses and returns the comment text of a \\@fileoverview comment in the given source file.\n */\nfunction getFileoverviewComment(sourceFile: ts.SourceFile): string|null {\n  const text = sourceFile.getFullText();\n  const trivia = text.substring(0, sourceFile.getStart());\n\n  const leadingComments = ts.getLeadingCommentRanges(trivia, 0);\n  if (!leadingComments || leadingComments.length === 0) {\n    return null;\n  }\n\n  const comment = leadingComments[0];\n  if (comment.kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n    return null;\n  }\n\n  // Only comments separated with a \\n\\n from the file contents are considered file-level comments\n  // in TypeScript.\n  if (text.substring(comment.end, comment.end + 2) !== '\\n\\n') {\n    return null;\n  }\n\n  const commentText = text.substring(comment.pos, comment.end);\n  // Closure Compiler ignores @suppress and similar if the comment contains @license.\n  if (commentText.indexOf('@license') !== -1) {\n    return null;\n  }\n\n  return commentText;\n}\n\n/**\n * Wraps the given expression in a call to `ɵnoSideEffects()`, which tells\n * Closure we don't care about the side effects of this expression and it should\n * be treated as \"pure\". Closure is free to tree shake this expression if its\n * result is not used.\n *\n * Example: Takes `1 + 2` and returns `i0.ɵnoSideEffects(() => 1 + 2)`.\n */\nfunction wrapInNoSideEffects(expr: ts.Expression): ts.Expression {\n  const noSideEffects = ts.createPropertyAccess(\n      ts.createIdentifier('i0'),\n      'ɵnoSideEffects',\n  );\n\n  return ts.createCall(\n      noSideEffects,\n      /* typeArguments */[],\n      /* arguments */\n      [\n        ts.createFunctionExpression(\n            /* modifiers */[],\n            /* asteriskToken */ undefined,\n            /* name */ undefined,\n            /* typeParameters */[],\n            /* parameters */[],\n            /* type */ undefined,\n            /* body */ ts.createBlock([\n              ts.createReturn(expr),\n            ]),\n            ),\n      ],\n  );\n}\n\n/**\n * Clones and updates the initializers for a given statement to use the new\n * expression provided. Does not mutate the input statement.\n */\nfunction updateInitializers(\n    stmt: ts.VariableStatement,\n    update: (initializer?: ts.Expression) => ts.Expression | undefined,\n    ): ts.VariableStatement {\n  return ts.updateVariableStatement(\n      stmt,\n      stmt.modifiers,\n      ts.updateVariableDeclarationList(\n          stmt.declarationList,\n          stmt.declarationList.declarations.map(\n              (decl) => ts.updateVariableDeclaration(\n                  decl,\n                  decl.name,\n                  decl.type,\n                  update(decl.initializer),\n                  ),\n              ),\n          ),\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}