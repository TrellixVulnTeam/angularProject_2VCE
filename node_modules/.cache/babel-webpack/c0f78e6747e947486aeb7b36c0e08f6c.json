{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/tasks/completion\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/packages/build_marker\", \"@angular/compiler-cli/ngcc/src/packages/entry_point\", \"@angular/compiler-cli/ngcc/src/execution/tasks/api\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.createLogErrorHandler = exports.createThrowErrorHandler = exports.createMarkAsProcessedHandler = exports.composeTaskCompletedCallbacks = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var build_marker_1 = require(\"@angular/compiler-cli/ngcc/src/packages/build_marker\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point\");\n\n  var api_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/api\");\n  /**\n   * Compose a group of TaskCompletedHandlers into a single TaskCompletedCallback.\n   *\n   * The compose callback will receive an outcome and will delegate to the appropriate handler based\n   * on this outcome.\n   *\n   * @param callbacks a map of outcomes to handlers.\n   */\n\n\n  function composeTaskCompletedCallbacks(callbacks) {\n    return function (task, outcome, message) {\n      var callback = callbacks[outcome];\n\n      if (callback === undefined) {\n        throw new Error(\"Unknown task outcome: \\\"\" + outcome + \"\\\" - supported outcomes: \" + JSON.stringify(Object.keys(callbacks)));\n      }\n\n      callback(task, message);\n    };\n  }\n\n  exports.composeTaskCompletedCallbacks = composeTaskCompletedCallbacks;\n  /**\n   * Create a handler that will mark the entry-points in a package as being processed.\n   *\n   * @param pkgJsonUpdater The service used to update the package.json\n   */\n\n  function createMarkAsProcessedHandler(fs, pkgJsonUpdater) {\n    return function (task) {\n      var entryPoint = task.entryPoint,\n          formatPropertiesToMarkAsProcessed = task.formatPropertiesToMarkAsProcessed,\n          processDts = task.processDts;\n      var packageJsonPath = fs.resolve(entryPoint.path, 'package.json');\n\n      var propsToMarkAsProcessed = tslib_1.__spread(formatPropertiesToMarkAsProcessed);\n\n      if (processDts !== api_1.DtsProcessing.No) {\n        propsToMarkAsProcessed.push('typings');\n      }\n\n      build_marker_1.markAsProcessed(pkgJsonUpdater, entryPoint.packageJson, packageJsonPath, propsToMarkAsProcessed);\n    };\n  }\n\n  exports.createMarkAsProcessedHandler = createMarkAsProcessedHandler;\n  /**\n   * Create a handler that will throw an error.\n   */\n\n  function createThrowErrorHandler(fs) {\n    return function (task, message) {\n      throw new Error(createErrorMessage(fs, task, message));\n    };\n  }\n\n  exports.createThrowErrorHandler = createThrowErrorHandler;\n  /**\n   * Create a handler that logs an error and marks the task as failed.\n   */\n\n  function createLogErrorHandler(logger, fs, taskQueue) {\n    return function (task, message) {\n      taskQueue.markAsFailed(task);\n      logger.error(createErrorMessage(fs, task, message));\n    };\n  }\n\n  exports.createLogErrorHandler = createLogErrorHandler;\n\n  function createErrorMessage(fs, task, message) {\n    var _a;\n\n    var jsFormat = \"`\" + task.formatProperty + \"` as \" + ((_a = entry_point_1.getEntryPointFormat(fs, task.entryPoint, task.formatProperty)) !== null && _a !== void 0 ? _a : 'unknown format');\n    var format = task.typingsOnly ? \"typings only using \" + jsFormat : jsFormat;\n    message = message !== null ? \" due to \" + message : '';\n    return \"Failed to compile entry-point \" + task.entryPoint.name + \" (\" + format + \")\" + message;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/ngcc/src/execution/tasks/completion.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {PathManipulation, ReadonlyFileSystem} from '../../../../src/ngtsc/file_system';\nimport {Logger} from '../../../../src/ngtsc/logging';\nimport {markAsProcessed} from '../../packages/build_marker';\nimport {getEntryPointFormat, PackageJsonFormatProperties} from '../../packages/entry_point';\nimport {PackageJsonUpdater} from '../../writing/package_json_updater';\n\nimport {DtsProcessing, Task, TaskCompletedCallback, TaskProcessingOutcome, TaskQueue} from './api';\n\n/**\n * A function that can handle a specific outcome of a task completion.\n *\n * These functions can be composed using the `composeTaskCompletedCallbacks()`\n * to create a `TaskCompletedCallback` function that can be passed to an `Executor`.\n */\nexport type TaskCompletedHandler = (task: Task, message: string|null) => void;\n\n/**\n * Compose a group of TaskCompletedHandlers into a single TaskCompletedCallback.\n *\n * The compose callback will receive an outcome and will delegate to the appropriate handler based\n * on this outcome.\n *\n * @param callbacks a map of outcomes to handlers.\n */\nexport function composeTaskCompletedCallbacks(\n    callbacks: Record<TaskProcessingOutcome, TaskCompletedHandler>): TaskCompletedCallback {\n  return (task: Task, outcome: TaskProcessingOutcome, message: string|null): void => {\n    const callback = callbacks[outcome];\n    if (callback === undefined) {\n      throw new Error(`Unknown task outcome: \"${outcome}\" - supported outcomes: ${\n          JSON.stringify(Object.keys(callbacks))}`);\n    }\n    callback(task, message);\n  };\n}\n\n/**\n * Create a handler that will mark the entry-points in a package as being processed.\n *\n * @param pkgJsonUpdater The service used to update the package.json\n */\nexport function createMarkAsProcessedHandler(\n    fs: PathManipulation, pkgJsonUpdater: PackageJsonUpdater): TaskCompletedHandler {\n  return (task: Task): void => {\n    const {entryPoint, formatPropertiesToMarkAsProcessed, processDts} = task;\n    const packageJsonPath = fs.resolve(entryPoint.path, 'package.json');\n    const propsToMarkAsProcessed: PackageJsonFormatProperties[] =\n        [...formatPropertiesToMarkAsProcessed];\n    if (processDts !== DtsProcessing.No) {\n      propsToMarkAsProcessed.push('typings');\n    }\n    markAsProcessed(\n        pkgJsonUpdater, entryPoint.packageJson, packageJsonPath, propsToMarkAsProcessed);\n  };\n}\n\n/**\n * Create a handler that will throw an error.\n */\nexport function createThrowErrorHandler(fs: ReadonlyFileSystem): TaskCompletedHandler {\n  return (task: Task, message: string|null): void => {\n    throw new Error(createErrorMessage(fs, task, message));\n  };\n}\n\n/**\n * Create a handler that logs an error and marks the task as failed.\n */\nexport function createLogErrorHandler(\n    logger: Logger, fs: ReadonlyFileSystem, taskQueue: TaskQueue): TaskCompletedHandler {\n  return (task: Task, message: string|null): void => {\n    taskQueue.markAsFailed(task);\n    logger.error(createErrorMessage(fs, task, message));\n  };\n}\n\nfunction createErrorMessage(fs: ReadonlyFileSystem, task: Task, message: string|null): string {\n  const jsFormat = `\\`${task.formatProperty}\\` as ${\n      getEntryPointFormat(fs, task.entryPoint, task.formatProperty) ?? 'unknown format'}`;\n  const format = task.typingsOnly ? `typings only using ${jsFormat}` : jsFormat;\n  message = message !== null ? ` due to ${message}` : '';\n  return `Failed to compile entry-point ${task.entryPoint.name} (${format})` + message;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}