{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_check_block\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/diagnostics\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/expression\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/template_semantics\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_constructor\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Context = exports.TcbDirectiveOutputsOp = exports.generateTypeCheckBlock = exports.TcbGenericContextBehavior = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var comments_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/diagnostics\");\n\n  var expression_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/expression\");\n\n  var template_semantics_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/template_semantics\");\n\n  var ts_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\");\n\n  var type_constructor_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_constructor\");\n\n  var type_parameter_emitter_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter\");\n  /**\n   * Controls how generics for the component context class will be handled during TCB generation.\n   */\n\n\n  var TcbGenericContextBehavior;\n\n  (function (TcbGenericContextBehavior) {\n    /**\n     * References to generic parameter bounds will be emitted via the `TypeParameterEmitter`.\n     *\n     * The caller must verify that all parameter bounds are emittable in order to use this mode.\n     */\n    TcbGenericContextBehavior[TcbGenericContextBehavior[\"UseEmitter\"] = 0] = \"UseEmitter\";\n    /**\n     * Generic parameter declarations will be copied directly from the `ts.ClassDeclaration` of the\n     * component class.\n     *\n     * The caller must only use the generated TCB code in a context where such copies will still be\n     * valid, such as an inline type check block.\n     */\n\n    TcbGenericContextBehavior[TcbGenericContextBehavior[\"CopyClassNodes\"] = 1] = \"CopyClassNodes\";\n    /**\n     * Any generic parameters for the component context class will be set to `any`.\n     *\n     * Produces a less useful type, but is always safe to use.\n     */\n\n    TcbGenericContextBehavior[TcbGenericContextBehavior[\"FallbackToAny\"] = 2] = \"FallbackToAny\";\n  })(TcbGenericContextBehavior = exports.TcbGenericContextBehavior || (exports.TcbGenericContextBehavior = {}));\n  /**\n   * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a\n   * \"type check block\" function.\n   *\n   * When passed through TypeScript's TypeChecker, type errors that arise within the type check block\n   * function indicate issues in the template itself.\n   *\n   * As a side effect of generating a TCB for the component, `ts.Diagnostic`s may also be produced\n   * directly for issues within the template which are identified during generation. These issues are\n   * recorded in either the `domSchemaChecker` (which checks usage of DOM elements and bindings) as\n   * well as the `oobRecorder` (which records errors when the type-checking code generator is unable\n   * to sufficiently understand a template).\n   *\n   * @param env an `Environment` into which type-checking code will be generated.\n   * @param ref a `Reference` to the component class which should be type-checked.\n   * @param name a `ts.Identifier` to use for the generated `ts.FunctionDeclaration`.\n   * @param meta metadata about the component's template and the function being generated.\n   * @param domSchemaChecker used to check and record errors regarding improper usage of DOM elements\n   * and bindings.\n   * @param oobRecorder used to record errors regarding template elements which could not be correctly\n   * translated into types during TCB generation.\n   * @param genericContextBehavior controls how generic parameters (especially parameters with generic\n   * bounds) will be referenced from the generated TCB code.\n   */\n\n\n  function generateTypeCheckBlock(env, ref, name, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {\n    var tcb = new Context(env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas);\n    var scope = Scope.forNodes(tcb, null, tcb.boundTarget.target.template,\n    /* guard */\n    null);\n    var ctxRawType = env.referenceType(ref);\n\n    if (!ts.isTypeReferenceNode(ctxRawType)) {\n      throw new Error(\"Expected TypeReferenceNode when referencing the ctx param for \" + ref.debugName);\n    }\n\n    var typeParameters = undefined;\n    var typeArguments = undefined;\n\n    if (ref.node.typeParameters !== undefined) {\n      if (!env.config.useContextGenericType) {\n        genericContextBehavior = TcbGenericContextBehavior.FallbackToAny;\n      }\n\n      switch (genericContextBehavior) {\n        case TcbGenericContextBehavior.UseEmitter:\n          // Guaranteed to emit type parameters since we checked that the class has them above.\n          typeParameters = new type_parameter_emitter_1.TypeParameterEmitter(ref.node.typeParameters, env.reflector).emit(function (typeRef) {\n            return env.referenceType(typeRef);\n          });\n          typeArguments = typeParameters.map(function (param) {\n            return ts.factory.createTypeReferenceNode(param.name);\n          });\n          break;\n\n        case TcbGenericContextBehavior.CopyClassNodes:\n          typeParameters = tslib_1.__spread(ref.node.typeParameters);\n          typeArguments = typeParameters.map(function (param) {\n            return ts.factory.createTypeReferenceNode(param.name);\n          });\n          break;\n\n        case TcbGenericContextBehavior.FallbackToAny:\n          typeArguments = ref.node.typeParameters.map(function () {\n            return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n          });\n          break;\n      }\n    }\n\n    var paramList = [tcbCtxParam(ref.node, ctxRawType.typeName, typeArguments)];\n    var scopeStatements = scope.render();\n    var innerBody = ts.createBlock(tslib_1.__spread(env.getPreludeStatements(), scopeStatements)); // Wrap the body in an \"if (true)\" expression. This is unnecessary but has the effect of causing\n    // the `ts.Printer` to format the type-check block nicely.\n\n    var body = ts.createBlock([ts.createIf(ts.createTrue(), innerBody, undefined)]);\n    var fnDecl = ts.createFunctionDeclaration(\n    /* decorators */\n    undefined,\n    /* modifiers */\n    undefined,\n    /* asteriskToken */\n    undefined,\n    /* name */\n    name,\n    /* typeParameters */\n    env.config.useContextGenericType ? typeParameters : undefined,\n    /* parameters */\n    paramList,\n    /* type */\n    undefined,\n    /* body */\n    body);\n    diagnostics_1.addTemplateId(fnDecl, meta.id);\n    return fnDecl;\n  }\n\n  exports.generateTypeCheckBlock = generateTypeCheckBlock;\n  /**\n   * A code generation operation that's involved in the construction of a Type Check Block.\n   *\n   * The generation of a TCB is non-linear. Bindings within a template may result in the need to\n   * construct certain types earlier than they otherwise would be constructed. That is, if the\n   * generation of a TCB for a template is broken down into specific operations (constructing a\n   * directive, extracting a variable from a let- operation, etc), then it's possible for operations\n   * earlier in the sequence to depend on operations which occur later in the sequence.\n   *\n   * `TcbOp` abstracts the different types of operations which are required to convert a template into\n   * a TCB. This allows for two phases of processing for the template, where 1) a linear sequence of\n   * `TcbOp`s is generated, and then 2) these operations are executed, not necessarily in linear\n   * order.\n   *\n   * Each `TcbOp` may insert statements into the body of the TCB, and also optionally return a\n   * `ts.Expression` which can be used to reference the operation's result.\n   */\n\n  var TcbOp =\n  /** @class */\n  function () {\n    function TcbOp() {}\n    /**\n     * Replacement value or operation used while this `TcbOp` is executing (i.e. to resolve circular\n     * references during its execution).\n     *\n     * This is usually a `null!` expression (which asks TS to infer an appropriate type), but another\n     * `TcbOp` can be returned in cases where additional code generation is necessary to deal with\n     * circular references.\n     */\n\n\n    TcbOp.prototype.circularFallback = function () {\n      return INFER_TYPE_FOR_CIRCULAR_OP_EXPR;\n    };\n\n    return TcbOp;\n  }();\n  /**\n   * A `TcbOp` which creates an expression for a native DOM element (or web component) from a\n   * `TmplAstElement`.\n   *\n   * Executing this operation returns a reference to the element variable.\n   */\n\n\n  var TcbElementOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbElementOp, _super);\n\n    function TcbElementOp(tcb, scope, element) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.element = element;\n      return _this;\n    }\n\n    Object.defineProperty(TcbElementOp.prototype, \"optional\", {\n      get: function get() {\n        // The statement generated by this operation is only used for type-inference of the DOM\n        // element's type and won't report diagnostics by itself, so the operation is marked as optional\n        // to avoid generating statements for DOM elements that are never referenced.\n        return true;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbElementOp.prototype.execute = function () {\n      var id = this.tcb.allocateId(); // Add the declaration of the element using document.createElement.\n\n      var initializer = ts_util_1.tsCreateElement(this.element.name);\n      diagnostics_1.addParseSpanInfo(initializer, this.element.startSourceSpan || this.element.sourceSpan);\n      this.scope.addStatement(ts_util_1.tsCreateVariable(id, initializer));\n      return id;\n    };\n\n    return TcbElementOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which creates an expression for particular let- `TmplAstVariable` on a\n   * `TmplAstTemplate`'s context.\n   *\n   * Executing this operation returns a reference to the variable variable (lol).\n   */\n\n\n  var TcbVariableOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbVariableOp, _super);\n\n    function TcbVariableOp(tcb, scope, template, variable) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.template = template;\n      _this.variable = variable;\n      return _this;\n    }\n\n    Object.defineProperty(TcbVariableOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbVariableOp.prototype.execute = function () {\n      // Look for a context variable for the template.\n      var ctx = this.scope.resolve(this.template); // Allocate an identifier for the TmplAstVariable, and initialize it to a read of the variable\n      // on the template context.\n\n      var id = this.tcb.allocateId();\n      var initializer = ts.createPropertyAccess(\n      /* expression */\n      ctx,\n      /* name */\n      this.variable.value || '$implicit');\n      diagnostics_1.addParseSpanInfo(id, this.variable.keySpan); // Declare the variable, and return its identifier.\n\n      var variable;\n\n      if (this.variable.valueSpan !== undefined) {\n        diagnostics_1.addParseSpanInfo(initializer, this.variable.valueSpan);\n        variable = ts_util_1.tsCreateVariable(id, diagnostics_1.wrapForTypeChecker(initializer));\n      } else {\n        variable = ts_util_1.tsCreateVariable(id, initializer);\n      }\n\n      diagnostics_1.addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);\n      this.scope.addStatement(variable);\n      return id;\n    };\n\n    return TcbVariableOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which generates a variable for a `TmplAstTemplate`'s context.\n   *\n   * Executing this operation returns a reference to the template's context variable.\n   */\n\n\n  var TcbTemplateContextOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbTemplateContextOp, _super);\n\n    function TcbTemplateContextOp(tcb, scope) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope; // The declaration of the context variable is only needed when the context is actually referenced.\n\n      _this.optional = true;\n      return _this;\n    }\n\n    TcbTemplateContextOp.prototype.execute = function () {\n      // Allocate a template ctx variable and declare it with an 'any' type. The type of this variable\n      // may be narrowed as a result of template guard conditions.\n      var ctx = this.tcb.allocateId();\n      var type = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n      this.scope.addStatement(ts_util_1.tsDeclareVariable(ctx, type));\n      return ctx;\n    };\n\n    return TcbTemplateContextOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which descends into a `TmplAstTemplate`'s children and generates type-checking code for\n   * them.\n   *\n   * This operation wraps the children's type-checking code in an `if` block, which may include one\n   * or more type guard conditions that narrow types within the template body.\n   */\n\n\n  var TcbTemplateBodyOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbTemplateBodyOp, _super);\n\n    function TcbTemplateBodyOp(tcb, scope, template) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.template = template;\n      return _this;\n    }\n\n    Object.defineProperty(TcbTemplateBodyOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbTemplateBodyOp.prototype.execute = function () {\n      var e_1, _a;\n\n      var _this = this; // An `if` will be constructed, within which the template's children will be type checked. The\n      // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared\n      // in the template's TCB from the outer context, and it allows any directives on the templates\n      // to perform type narrowing of either expressions or the template's context.\n      //\n      // The guard is the `if` block's condition. It's usually set to `true` but directives that exist\n      // on the template can trigger extra guard expressions that serve to narrow types within the\n      // `if`. `guard` is calculated by starting with `true` and adding other conditions as needed.\n      // Collect these into `guards` by processing the directives.\n\n\n      var directiveGuards = [];\n      var directives = this.tcb.boundTarget.getDirectivesOfNode(this.template);\n\n      if (directives !== null) {\n        var _loop_1 = function _loop_1(dir) {\n          var dirInstId = this_1.scope.resolve(this_1.template, dir);\n          var dirId = this_1.tcb.env.reference(dir.ref); // There are two kinds of guards. Template guards (ngTemplateGuards) allow type narrowing of\n          // the expression passed to an @Input of the directive. Scan the directive to see if it has\n          // any template guards, and generate them if needed.\n\n          dir.ngTemplateGuards.forEach(function (guard) {\n            // For each template guard function on the directive, look for a binding to that input.\n            var boundInput = _this.template.inputs.find(function (i) {\n              return i.name === guard.inputName;\n            }) || _this.template.templateAttrs.find(function (i) {\n              return i instanceof compiler_1.TmplAstBoundAttribute && i.name === guard.inputName;\n            });\n\n            if (boundInput !== undefined) {\n              // If there is such a binding, generate an expression for it.\n              var expr = tcbExpression(boundInput.value, _this.tcb, _this.scope); // The expression has already been checked in the type constructor invocation, so\n              // it should be ignored when used within a template guard.\n\n              comments_1.markIgnoreDiagnostics(expr);\n\n              if (guard.type === 'binding') {\n                // Use the binding expression itself as guard.\n                directiveGuards.push(expr);\n              } else {\n                // Call the guard function on the directive with the directive instance and that\n                // expression.\n                var guardInvoke = ts_util_1.tsCallMethod(dirId, \"ngTemplateGuard_\" + guard.inputName, [dirInstId, expr]);\n                diagnostics_1.addParseSpanInfo(guardInvoke, boundInput.value.sourceSpan);\n                directiveGuards.push(guardInvoke);\n              }\n            }\n          }); // The second kind of guard is a template context guard. This guard narrows the template\n          // rendering context variable `ctx`.\n\n          if (dir.hasNgTemplateContextGuard) {\n            if (this_1.tcb.env.config.applyTemplateContextGuards) {\n              var ctx = this_1.scope.resolve(this_1.template);\n              var guardInvoke = ts_util_1.tsCallMethod(dirId, 'ngTemplateContextGuard', [dirInstId, ctx]);\n              diagnostics_1.addParseSpanInfo(guardInvoke, this_1.template.sourceSpan);\n              directiveGuards.push(guardInvoke);\n            } else if (this_1.template.variables.length > 0 && this_1.tcb.env.config.suggestionsForSuboptimalTypeInference) {\n              // The compiler could have inferred a better type for the variables in this template,\n              // but was prevented from doing so by the type-checking configuration. Issue a warning\n              // diagnostic.\n              this_1.tcb.oobRecorder.suboptimalTypeInference(this_1.tcb.id, this_1.template.variables);\n            }\n          }\n        };\n\n        var this_1 = this;\n\n        try {\n          for (var directives_1 = tslib_1.__values(directives), directives_1_1 = directives_1.next(); !directives_1_1.done; directives_1_1 = directives_1.next()) {\n            var dir = directives_1_1.value;\n\n            _loop_1(dir);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (directives_1_1 && !directives_1_1.done && (_a = directives_1.return)) _a.call(directives_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } // By default the guard is simply `true`.\n\n\n      var guard = null; // If there are any guards from directives, use them instead.\n\n      if (directiveGuards.length > 0) {\n        // Pop the first value and use it as the initializer to reduce(). This way, a single guard\n        // will be used on its own, but two or more will be combined into binary AND expressions.\n        guard = directiveGuards.reduce(function (expr, dirGuard) {\n          return ts.createBinary(expr, ts.SyntaxKind.AmpersandAmpersandToken, dirGuard);\n        }, directiveGuards.pop());\n      } // Create a new Scope for the template. This constructs the list of operations for the template\n      // children, as well as tracks bindings within the template.\n\n\n      var tmplScope = Scope.forNodes(this.tcb, this.scope, this.template, guard); // Render the template's `Scope` into its statements.\n\n      var statements = tmplScope.render();\n\n      if (statements.length === 0) {\n        // As an optimization, don't generate the scope's block if it has no statements. This is\n        // beneficial for templates that contain for example `<span *ngIf=\"first\"></span>`, in which\n        // case there's no need to render the `NgIf` guard expression. This seems like a minor\n        // improvement, however it reduces the number of flow-node antecedents that TypeScript needs\n        // to keep into account for such cases, resulting in an overall reduction of\n        // type-checking time.\n        return null;\n      }\n\n      var tmplBlock = ts.createBlock(statements);\n\n      if (guard !== null) {\n        // The scope has a guard that needs to be applied, so wrap the template block into an `if`\n        // statement containing the guard expression.\n        tmplBlock = ts.createIf(\n        /* expression */\n        guard,\n        /* thenStatement */\n        tmplBlock);\n      }\n\n      this.scope.addStatement(tmplBlock);\n      return null;\n    };\n\n    return TcbTemplateBodyOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which renders a text binding (interpolation) into the TCB.\n   *\n   * Executing this operation returns nothing.\n   */\n\n\n  var TcbTextInterpolationOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbTextInterpolationOp, _super);\n\n    function TcbTextInterpolationOp(tcb, scope, binding) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.binding = binding;\n      return _this;\n    }\n\n    Object.defineProperty(TcbTextInterpolationOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbTextInterpolationOp.prototype.execute = function () {\n      var expr = tcbExpression(this.binding.value, this.tcb, this.scope);\n      this.scope.addStatement(ts.createExpressionStatement(expr));\n      return null;\n    };\n\n    return TcbTextInterpolationOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which constructs an instance of a directive. For generic directives, generic\n   * parameters are set to `any` type.\n   */\n\n\n  var TcbDirectiveTypeOpBase =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbDirectiveTypeOpBase, _super);\n\n    function TcbDirectiveTypeOpBase(tcb, scope, node, dir) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.node = node;\n      _this.dir = dir;\n      return _this;\n    }\n\n    Object.defineProperty(TcbDirectiveTypeOpBase.prototype, \"optional\", {\n      get: function get() {\n        // The statement generated by this operation is only used to declare the directive's type and\n        // won't report diagnostics by itself, so the operation is marked as optional to avoid\n        // generating declarations for directives that don't have any inputs/outputs.\n        return true;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbDirectiveTypeOpBase.prototype.execute = function () {\n      var dirRef = this.dir.ref;\n      var rawType = this.tcb.env.referenceType(this.dir.ref);\n      var type;\n\n      if (this.dir.isGeneric === false || dirRef.node.typeParameters === undefined) {\n        type = rawType;\n      } else {\n        if (!ts.isTypeReferenceNode(rawType)) {\n          throw new Error(\"Expected TypeReferenceNode when referencing the type for \" + this.dir.ref.debugName);\n        }\n\n        var typeArguments = dirRef.node.typeParameters.map(function () {\n          return ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n        });\n        type = ts.factory.createTypeReferenceNode(rawType.typeName, typeArguments);\n      }\n\n      var id = this.tcb.allocateId();\n      comments_1.addExpressionIdentifier(type, comments_1.ExpressionIdentifier.DIRECTIVE);\n      diagnostics_1.addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n      this.scope.addStatement(ts_util_1.tsDeclareVariable(id, type));\n      return id;\n    };\n\n    return TcbDirectiveTypeOpBase;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which constructs an instance of a non-generic directive _without_ setting any of its\n   * inputs. Inputs  are later set in the `TcbDirectiveInputsOp`. Type checking was found to be\n   * faster when done in this way as opposed to `TcbDirectiveCtorOp` which is only necessary when the\n   * directive is generic.\n   *\n   * Executing this operation returns a reference to the directive instance variable with its inferred\n   * type.\n   */\n\n\n  var TcbNonGenericDirectiveTypeOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbNonGenericDirectiveTypeOp, _super);\n\n    function TcbNonGenericDirectiveTypeOp() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Creates a variable declaration for this op's directive of the argument type. Returns the id of\n     * the newly created variable.\n     */\n\n\n    TcbNonGenericDirectiveTypeOp.prototype.execute = function () {\n      var dirRef = this.dir.ref;\n\n      if (this.dir.isGeneric) {\n        throw new Error(\"Assertion Error: expected \" + dirRef.debugName + \" not to be generic.\");\n      }\n\n      return _super.prototype.execute.call(this);\n    };\n\n    return TcbNonGenericDirectiveTypeOp;\n  }(TcbDirectiveTypeOpBase);\n  /**\n   * A `TcbOp` which constructs an instance of a generic directive with its generic parameters set\n   * to `any` type. This op is like `TcbDirectiveTypeOp`, except that generic parameters are set to\n   * `any` type. This is used for situations where we want to avoid inlining.\n   *\n   * Executing this operation returns a reference to the directive instance variable with its generic\n   * type parameters set to `any`.\n   */\n\n\n  var TcbGenericDirectiveTypeWithAnyParamsOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbGenericDirectiveTypeWithAnyParamsOp, _super);\n\n    function TcbGenericDirectiveTypeWithAnyParamsOp() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    TcbGenericDirectiveTypeWithAnyParamsOp.prototype.execute = function () {\n      var dirRef = this.dir.ref;\n\n      if (dirRef.node.typeParameters === undefined) {\n        throw new Error(\"Assertion Error: expected typeParameters when creating a declaration for \" + dirRef.debugName);\n      }\n\n      return _super.prototype.execute.call(this);\n    };\n\n    return TcbGenericDirectiveTypeWithAnyParamsOp;\n  }(TcbDirectiveTypeOpBase);\n  /**\n   * A `TcbOp` which creates a variable for a local ref in a template.\n   * The initializer for the variable is the variable expression for the directive, template, or\n   * element the ref refers to. When the reference is used in the template, those TCB statements will\n   * access this variable as well. For example:\n   * ```\n   * var _t1 = document.createElement('div');\n   * var _t2 = _t1;\n   * _t2.value\n   * ```\n   * This operation supports more fluent lookups for the `TemplateTypeChecker` when getting a symbol\n   * for a reference. In most cases, this isn't essential; that is, the information for the symbol\n   * could be gathered without this operation using the `BoundTarget`. However, for the case of\n   * ng-template references, we will need this reference variable to not only provide a location in\n   * the shim file, but also to narrow the variable to the correct `TemplateRef<T>` type rather than\n   * `TemplateRef<any>` (this work is still TODO).\n   *\n   * Executing this operation returns a reference to the directive instance variable with its inferred\n   * type.\n   */\n\n\n  var TcbReferenceOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbReferenceOp, _super);\n\n    function TcbReferenceOp(tcb, scope, node, host, target) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.node = node;\n      _this.host = host;\n      _this.target = target; // The statement generated by this operation is only used to for the Type Checker\n      // so it can map a reference variable in the template directly to a node in the TCB.\n\n      _this.optional = true;\n      return _this;\n    }\n\n    TcbReferenceOp.prototype.execute = function () {\n      var id = this.tcb.allocateId();\n      var initializer = this.target instanceof compiler_1.TmplAstTemplate || this.target instanceof compiler_1.TmplAstElement ? this.scope.resolve(this.target) : this.scope.resolve(this.host, this.target); // The reference is either to an element, an <ng-template> node, or to a directive on an\n      // element or template.\n\n      if (this.target instanceof compiler_1.TmplAstElement && !this.tcb.env.config.checkTypeOfDomReferences || !this.tcb.env.config.checkTypeOfNonDomReferences) {\n        // References to DOM nodes are pinned to 'any' when `checkTypeOfDomReferences` is `false`.\n        // References to `TemplateRef`s and directives are pinned to 'any' when\n        // `checkTypeOfNonDomReferences` is `false`.\n        initializer = ts.createAsExpression(initializer, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n      } else if (this.target instanceof compiler_1.TmplAstTemplate) {\n        // Direct references to an <ng-template> node simply require a value of type\n        // `TemplateRef<any>`. To get this, an expression of the form\n        // `(_t1 as any as TemplateRef<any>)` is constructed.\n        initializer = ts.createAsExpression(initializer, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n        initializer = ts.createAsExpression(initializer, this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [compiler_1.DYNAMIC_TYPE]));\n        initializer = ts.createParen(initializer);\n      }\n\n      diagnostics_1.addParseSpanInfo(initializer, this.node.sourceSpan);\n      diagnostics_1.addParseSpanInfo(id, this.node.keySpan);\n      this.scope.addStatement(ts_util_1.tsCreateVariable(id, initializer));\n      return id;\n    };\n\n    return TcbReferenceOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which is used when the target of a reference is missing. This operation generates a\n   * variable of type any for usages of the invalid reference to resolve to. The invalid reference\n   * itself is recorded out-of-band.\n   */\n\n\n  var TcbInvalidReferenceOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbInvalidReferenceOp, _super);\n\n    function TcbInvalidReferenceOp(tcb, scope) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope; // The declaration of a missing reference is only needed when the reference is resolved.\n\n      _this.optional = true;\n      return _this;\n    }\n\n    TcbInvalidReferenceOp.prototype.execute = function () {\n      var id = this.tcb.allocateId();\n      this.scope.addStatement(ts_util_1.tsCreateVariable(id, expression_1.NULL_AS_ANY));\n      return id;\n    };\n\n    return TcbInvalidReferenceOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs. The\n   * inputs themselves are not checked here; checking of inputs is achieved in `TcbDirectiveInputsOp`.\n   * Any errors reported in this statement are ignored, as the type constructor call is only present\n   * for type-inference.\n   *\n   * When a Directive is generic, it is required that the TCB generates the instance using this method\n   * in order to infer the type information correctly.\n   *\n   * Executing this operation returns a reference to the directive instance variable with its inferred\n   * type.\n   */\n\n\n  var TcbDirectiveCtorOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbDirectiveCtorOp, _super);\n\n    function TcbDirectiveCtorOp(tcb, scope, node, dir) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.node = node;\n      _this.dir = dir;\n      return _this;\n    }\n\n    Object.defineProperty(TcbDirectiveCtorOp.prototype, \"optional\", {\n      get: function get() {\n        // The statement generated by this operation is only used to infer the directive's type and\n        // won't report diagnostics by itself, so the operation is marked as optional.\n        return true;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbDirectiveCtorOp.prototype.execute = function () {\n      var e_2, _a, e_3, _b, e_4, _c;\n\n      var id = this.tcb.allocateId();\n      comments_1.addExpressionIdentifier(id, comments_1.ExpressionIdentifier.DIRECTIVE);\n      diagnostics_1.addParseSpanInfo(id, this.node.startSourceSpan || this.node.sourceSpan);\n      var genericInputs = new Map();\n      var inputs = getBoundInputs(this.dir, this.node, this.tcb);\n\n      try {\n        for (var inputs_1 = tslib_1.__values(inputs), inputs_1_1 = inputs_1.next(); !inputs_1_1.done; inputs_1_1 = inputs_1.next()) {\n          var input = inputs_1_1.value; // Skip text attributes if configured to do so.\n\n          if (!this.tcb.env.config.checkTypeOfAttributes && input.attribute instanceof compiler_1.TmplAstTextAttribute) {\n            continue;\n          }\n\n          try {\n            for (var _d = (e_3 = void 0, tslib_1.__values(input.fieldNames)), _e = _d.next(); !_e.done; _e = _d.next()) {\n              var fieldName = _e.value; // Skip the field if an attribute has already been bound to it; we can't have a duplicate\n              // key in the type constructor call.\n\n              if (genericInputs.has(fieldName)) {\n                continue;\n              }\n\n              var expression = translateInput(input.attribute, this.tcb, this.scope);\n              genericInputs.set(fieldName, {\n                type: 'binding',\n                field: fieldName,\n                expression: expression,\n                sourceSpan: input.attribute.sourceSpan\n              });\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (inputs_1_1 && !inputs_1_1.done && (_a = inputs_1.return)) _a.call(inputs_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      try {\n        // Add unset directive inputs for each of the remaining unset fields.\n        for (var _f = tslib_1.__values(this.dir.inputs), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var _h = tslib_1.__read(_g.value, 1),\n              fieldName = _h[0];\n\n          if (!genericInputs.has(fieldName)) {\n            genericInputs.set(fieldName, {\n              type: 'unset',\n              field: fieldName\n            });\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      } // Call the type constructor of the directive to infer a type, and assign the directive\n      // instance.\n\n\n      var typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));\n      comments_1.markIgnoreDiagnostics(typeCtor);\n      this.scope.addStatement(ts_util_1.tsCreateVariable(id, typeCtor));\n      return id;\n    };\n\n    TcbDirectiveCtorOp.prototype.circularFallback = function () {\n      return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);\n    };\n\n    return TcbDirectiveCtorOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which generates code to check input bindings on an element that correspond with the\n   * members of a directive.\n   *\n   * Executing this operation returns nothing.\n   */\n\n\n  var TcbDirectiveInputsOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbDirectiveInputsOp, _super);\n\n    function TcbDirectiveInputsOp(tcb, scope, node, dir) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.node = node;\n      _this.dir = dir;\n      return _this;\n    }\n\n    Object.defineProperty(TcbDirectiveInputsOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbDirectiveInputsOp.prototype.execute = function () {\n      var e_5, _a, e_6, _b;\n\n      var dirId = null; // TODO(joost): report duplicate properties\n\n      var inputs = getBoundInputs(this.dir, this.node, this.tcb);\n\n      try {\n        for (var inputs_2 = tslib_1.__values(inputs), inputs_2_1 = inputs_2.next(); !inputs_2_1.done; inputs_2_1 = inputs_2.next()) {\n          var input = inputs_2_1.value; // For bound inputs, the property is assigned the binding expression.\n\n          var expr = translateInput(input.attribute, this.tcb, this.scope);\n\n          if (!this.tcb.env.config.checkTypeOfInputBindings) {\n            // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n            // before the assignment.\n            expr = ts_util_1.tsCastToAny(expr);\n          } else if (!this.tcb.env.config.strictNullInputBindings) {\n            // If strict null checks are disabled, erase `null` and `undefined` from the type by\n            // wrapping the expression in a non-null assertion.\n            expr = ts.createNonNullExpression(expr);\n          }\n\n          var assignment = diagnostics_1.wrapForDiagnostics(expr);\n\n          try {\n            for (var _c = (e_6 = void 0, tslib_1.__values(input.fieldNames)), _d = _c.next(); !_d.done; _d = _c.next()) {\n              var fieldName = _d.value;\n              var target = void 0;\n\n              if (this.dir.coercedInputFields.has(fieldName)) {\n                // The input has a coercion declaration which should be used instead of assigning the\n                // expression into the input field directly. To achieve this, a variable is declared\n                // with a type of `typeof Directive.ngAcceptInputType_fieldName` which is then used as\n                // target of the assignment.\n                var dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n\n                if (!ts.isTypeReferenceNode(dirTypeRef)) {\n                  throw new Error(\"Expected TypeReferenceNode from reference to \" + this.dir.ref.debugName);\n                }\n\n                var id = this.tcb.allocateId();\n                var type = ts_util_1.tsCreateTypeQueryForCoercedInput(dirTypeRef.typeName, fieldName);\n                this.scope.addStatement(ts_util_1.tsDeclareVariable(id, type));\n                target = id;\n              } else if (this.dir.undeclaredInputFields.has(fieldName)) {\n                // If no coercion declaration is present nor is the field declared (i.e. the input is\n                // declared in a `@Directive` or `@Component` decorator's `inputs` property) there is no\n                // assignment target available, so this field is skipped.\n                continue;\n              } else if (!this.tcb.env.config.honorAccessModifiersForInputBindings && this.dir.restrictedInputFields.has(fieldName)) {\n                // If strict checking of access modifiers is disabled and the field is restricted\n                // (i.e. private/protected/readonly), generate an assignment into a temporary variable\n                // that has the type of the field. This achieves type-checking but circumvents the access\n                // modifiers.\n                if (dirId === null) {\n                  dirId = this.scope.resolve(this.node, this.dir);\n                }\n\n                var id = this.tcb.allocateId();\n                var dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n\n                if (!ts.isTypeReferenceNode(dirTypeRef)) {\n                  throw new Error(\"Expected TypeReferenceNode from reference to \" + this.dir.ref.debugName);\n                }\n\n                var type = ts.createIndexedAccessTypeNode(ts.createTypeQueryNode(dirId), ts.createLiteralTypeNode(ts.createStringLiteral(fieldName)));\n                var temp = ts_util_1.tsDeclareVariable(id, type);\n                this.scope.addStatement(temp);\n                target = id;\n              } else {\n                if (dirId === null) {\n                  dirId = this.scope.resolve(this.node, this.dir);\n                } // To get errors assign directly to the fields on the instance, using property access\n                // when possible. String literal fields may not be valid JS identifiers so we use\n                // literal element access instead for those cases.\n\n\n                target = this.dir.stringLiteralInputFields.has(fieldName) ? ts.createElementAccess(dirId, ts.createStringLiteral(fieldName)) : ts.createPropertyAccess(dirId, ts.createIdentifier(fieldName));\n              }\n\n              if (input.attribute.keySpan !== undefined) {\n                diagnostics_1.addParseSpanInfo(target, input.attribute.keySpan);\n              } // Finally the assignment is extended by assigning it into the target expression.\n\n\n              assignment = ts.createBinary(target, ts.SyntaxKind.EqualsToken, assignment);\n            }\n          } catch (e_6_1) {\n            e_6 = {\n              error: e_6_1\n            };\n          } finally {\n            try {\n              if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n            } finally {\n              if (e_6) throw e_6.error;\n            }\n          }\n\n          diagnostics_1.addParseSpanInfo(assignment, input.attribute.sourceSpan); // Ignore diagnostics for text attributes if configured to do so.\n\n          if (!this.tcb.env.config.checkTypeOfAttributes && input.attribute instanceof compiler_1.TmplAstTextAttribute) {\n            comments_1.markIgnoreDiagnostics(assignment);\n          }\n\n          this.scope.addStatement(ts.createExpressionStatement(assignment));\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (inputs_2_1 && !inputs_2_1.done && (_a = inputs_2.return)) _a.call(inputs_2);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      return null;\n    };\n\n    return TcbDirectiveInputsOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which is used to generate a fallback expression if the inference of a directive type\n   * via `TcbDirectiveCtorOp` requires a reference to its own type. This can happen using a template\n   * reference:\n   *\n   * ```html\n   * <some-cmp #ref [prop]=\"ref.foo\"></some-cmp>\n   * ```\n   *\n   * In this case, `TcbDirectiveCtorCircularFallbackOp` will add a second inference of the directive\n   * type to the type-check block, this time calling the directive's type constructor without any\n   * input expressions. This infers the widest possible supertype for the directive, which is used to\n   * resolve any recursive references required to infer the real type.\n   */\n\n\n  var TcbDirectiveCtorCircularFallbackOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbDirectiveCtorCircularFallbackOp, _super);\n\n    function TcbDirectiveCtorCircularFallbackOp(tcb, scope, node, dir) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.node = node;\n      _this.dir = dir;\n      return _this;\n    }\n\n    Object.defineProperty(TcbDirectiveCtorCircularFallbackOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbDirectiveCtorCircularFallbackOp.prototype.execute = function () {\n      var id = this.tcb.allocateId();\n      var typeCtor = this.tcb.env.typeCtorFor(this.dir);\n      var circularPlaceholder = ts.createCall(typeCtor,\n      /* typeArguments */\n      undefined, [ts.createNonNullExpression(ts.createNull())]);\n      this.scope.addStatement(ts_util_1.tsCreateVariable(id, circularPlaceholder));\n      return id;\n    };\n\n    return TcbDirectiveCtorCircularFallbackOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which feeds elements and unclaimed properties to the `DomSchemaChecker`.\n   *\n   * The DOM schema is not checked via TCB code generation. Instead, the `DomSchemaChecker` ingests\n   * elements and property bindings and accumulates synthetic `ts.Diagnostic`s out-of-band. These are\n   * later merged with the diagnostics generated from the TCB.\n   *\n   * For convenience, the TCB iteration of the template is used to drive the `DomSchemaChecker` via\n   * the `TcbDomSchemaCheckerOp`.\n   */\n\n\n  var TcbDomSchemaCheckerOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbDomSchemaCheckerOp, _super);\n\n    function TcbDomSchemaCheckerOp(tcb, element, checkElement, claimedInputs) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.element = element;\n      _this.checkElement = checkElement;\n      _this.claimedInputs = claimedInputs;\n      return _this;\n    }\n\n    Object.defineProperty(TcbDomSchemaCheckerOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbDomSchemaCheckerOp.prototype.execute = function () {\n      var e_7, _a;\n\n      if (this.checkElement) {\n        this.tcb.domSchemaChecker.checkElement(this.tcb.id, this.element, this.tcb.schemas);\n      }\n\n      try {\n        // TODO(alxhub): this could be more efficient.\n        for (var _b = tslib_1.__values(this.element.inputs), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var binding = _c.value;\n\n          if (binding.type === 0\n          /* Property */\n          && this.claimedInputs.has(binding.name)) {\n            // Skip this binding as it was claimed by a directive.\n            continue;\n          }\n\n          if (binding.type === 0\n          /* Property */\n          ) {\n              if (binding.name !== 'style' && binding.name !== 'class') {\n                // A direct binding to a property.\n                var propertyName = ATTR_TO_PROP[binding.name] || binding.name;\n                this.tcb.domSchemaChecker.checkProperty(this.tcb.id, this.element, propertyName, binding.sourceSpan, this.tcb.schemas);\n              }\n            }\n        }\n      } catch (e_7_1) {\n        e_7 = {\n          error: e_7_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_7) throw e_7.error;\n        }\n      }\n\n      return null;\n    };\n\n    return TcbDomSchemaCheckerOp;\n  }(TcbOp);\n  /**\n   * Mapping between attributes names that don't correspond to their element property names.\n   * Note: this mapping has to be kept in sync with the equally named mapping in the runtime.\n   */\n\n\n  var ATTR_TO_PROP = {\n    'class': 'className',\n    'for': 'htmlFor',\n    'formaction': 'formAction',\n    'innerHtml': 'innerHTML',\n    'readonly': 'readOnly',\n    'tabindex': 'tabIndex'\n  };\n  /**\n   * A `TcbOp` which generates code to check \"unclaimed inputs\" - bindings on an element which were\n   * not attributed to any directive or component, and are instead processed against the HTML element\n   * itself.\n   *\n   * Currently, only the expressions of these bindings are checked. The targets of the bindings are\n   * checked against the DOM schema via a `TcbDomSchemaCheckerOp`.\n   *\n   * Executing this operation returns nothing.\n   */\n\n  var TcbUnclaimedInputsOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbUnclaimedInputsOp, _super);\n\n    function TcbUnclaimedInputsOp(tcb, scope, element, claimedInputs) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.element = element;\n      _this.claimedInputs = claimedInputs;\n      return _this;\n    }\n\n    Object.defineProperty(TcbUnclaimedInputsOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbUnclaimedInputsOp.prototype.execute = function () {\n      var e_8, _a; // `this.inputs` contains only those bindings not matched by any directive. These bindings go to\n      // the element itself.\n\n\n      var elId = null;\n\n      try {\n        // TODO(alxhub): this could be more efficient.\n        for (var _b = tslib_1.__values(this.element.inputs), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var binding = _c.value;\n\n          if (binding.type === 0\n          /* Property */\n          && this.claimedInputs.has(binding.name)) {\n            // Skip this binding as it was claimed by a directive.\n            continue;\n          }\n\n          var expr = tcbExpression(binding.value, this.tcb, this.scope);\n\n          if (!this.tcb.env.config.checkTypeOfInputBindings) {\n            // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n            // before the assignment.\n            expr = ts_util_1.tsCastToAny(expr);\n          } else if (!this.tcb.env.config.strictNullInputBindings) {\n            // If strict null checks are disabled, erase `null` and `undefined` from the type by\n            // wrapping the expression in a non-null assertion.\n            expr = ts.createNonNullExpression(expr);\n          }\n\n          if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === 0\n          /* Property */\n          ) {\n              if (binding.name !== 'style' && binding.name !== 'class') {\n                if (elId === null) {\n                  elId = this.scope.resolve(this.element);\n                } // A direct binding to a property.\n\n\n                var propertyName = ATTR_TO_PROP[binding.name] || binding.name;\n                var prop = ts.createElementAccess(elId, ts.createStringLiteral(propertyName));\n                var stmt = ts.createBinary(prop, ts.SyntaxKind.EqualsToken, diagnostics_1.wrapForDiagnostics(expr));\n                diagnostics_1.addParseSpanInfo(stmt, binding.sourceSpan);\n                this.scope.addStatement(ts.createExpressionStatement(stmt));\n              } else {\n                this.scope.addStatement(ts.createExpressionStatement(expr));\n              }\n            } else {\n            // A binding to an animation, attribute, class or style. For now, only validate the right-\n            // hand side of the expression.\n            // TODO: properly check class and style bindings.\n            this.scope.addStatement(ts.createExpressionStatement(expr));\n          }\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n\n      return null;\n    };\n\n    return TcbUnclaimedInputsOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which generates code to check event bindings on an element that correspond with the\n   * outputs of a directive.\n   *\n   * Executing this operation returns nothing.\n   */\n\n\n  var TcbDirectiveOutputsOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbDirectiveOutputsOp, _super);\n\n    function TcbDirectiveOutputsOp(tcb, scope, node, dir) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.node = node;\n      _this.dir = dir;\n      return _this;\n    }\n\n    Object.defineProperty(TcbDirectiveOutputsOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbDirectiveOutputsOp.prototype.execute = function () {\n      var e_9, _a;\n\n      var dirId = null;\n      var outputs = this.dir.outputs;\n\n      try {\n        for (var _b = tslib_1.__values(this.node.outputs), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var output = _c.value;\n\n          if (output.type !== 0\n          /* Regular */\n          || !outputs.hasBindingPropertyName(output.name)) {\n            continue;\n          } // TODO(alxhub): consider supporting multiple fields with the same property name for outputs.\n\n\n          var field = outputs.getByBindingPropertyName(output.name)[0].classPropertyName;\n\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n\n          var outputField = ts.createElementAccess(dirId, ts.createStringLiteral(field));\n          diagnostics_1.addParseSpanInfo(outputField, output.keySpan);\n\n          if (this.tcb.env.config.checkTypeOfOutputEvents) {\n            // For strict checking of directive events, generate a call to the `subscribe` method\n            // on the directive's output field to let type information flow into the handler function's\n            // `$event` parameter.\n            var handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0\n            /* Infer */\n            );\n            var subscribeFn = ts.createPropertyAccess(outputField, 'subscribe');\n            var call = ts.createCall(subscribeFn,\n            /* typeArguments */\n            undefined, [handler]);\n            diagnostics_1.addParseSpanInfo(call, output.sourceSpan);\n            this.scope.addStatement(ts.createExpressionStatement(call));\n          } else {\n            // If strict checking of directive events is disabled:\n            //\n            // * We still generate the access to the output field as a statement in the TCB so consumers\n            //   of the `TemplateTypeChecker` can still find the node for the class member for the\n            //   output.\n            // * Emit a handler function where the `$event` parameter has an explicit `any` type.\n            this.scope.addStatement(ts.createExpressionStatement(outputField));\n            var handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1\n            /* Any */\n            );\n            this.scope.addStatement(ts.createExpressionStatement(handler));\n          }\n\n          template_semantics_1.ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n        }\n      } catch (e_9_1) {\n        e_9 = {\n          error: e_9_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_9) throw e_9.error;\n        }\n      }\n\n      return null;\n    };\n\n    return TcbDirectiveOutputsOp;\n  }(TcbOp);\n\n  exports.TcbDirectiveOutputsOp = TcbDirectiveOutputsOp;\n  /**\n   * A `TcbOp` which generates code to check \"unclaimed outputs\" - event bindings on an element which\n   * were not attributed to any directive or component, and are instead processed against the HTML\n   * element itself.\n   *\n   * Executing this operation returns nothing.\n   */\n\n  var TcbUnclaimedOutputsOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbUnclaimedOutputsOp, _super);\n\n    function TcbUnclaimedOutputsOp(tcb, scope, element, claimedOutputs) {\n      var _this = _super.call(this) || this;\n\n      _this.tcb = tcb;\n      _this.scope = scope;\n      _this.element = element;\n      _this.claimedOutputs = claimedOutputs;\n      return _this;\n    }\n\n    Object.defineProperty(TcbUnclaimedOutputsOp.prototype, \"optional\", {\n      get: function get() {\n        return false;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TcbUnclaimedOutputsOp.prototype.execute = function () {\n      var e_10, _a;\n\n      var elId = null;\n\n      try {\n        // TODO(alxhub): this could be more efficient.\n        for (var _b = tslib_1.__values(this.element.outputs), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var output = _c.value;\n\n          if (this.claimedOutputs.has(output.name)) {\n            // Skip this event handler as it was claimed by a directive.\n            continue;\n          }\n\n          if (output.type === 1\n          /* Animation */\n          ) {\n              // Animation output bindings always have an `$event` parameter of type `AnimationEvent`.\n              var eventType = this.tcb.env.config.checkTypeOfAnimationEvents ? this.tcb.env.referenceExternalType('@angular/animations', 'AnimationEvent') : 1\n              /* Any */\n              ;\n              var handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);\n              this.scope.addStatement(ts.createExpressionStatement(handler));\n            } else if (this.tcb.env.config.checkTypeOfDomEvents) {\n            // If strict checking of DOM events is enabled, generate a call to `addEventListener` on\n            // the element instance so that TypeScript's type inference for\n            // `HTMLElement.addEventListener` using `HTMLElementEventMap` to infer an accurate type for\n            // `$event` depending on the event name. For unknown event names, TypeScript resorts to the\n            // base `Event` type.\n            var handler = tcbCreateEventHandler(output, this.tcb, this.scope, 0\n            /* Infer */\n            );\n\n            if (elId === null) {\n              elId = this.scope.resolve(this.element);\n            }\n\n            var propertyAccess = ts.createPropertyAccess(elId, 'addEventListener');\n            diagnostics_1.addParseSpanInfo(propertyAccess, output.keySpan);\n            var call = ts.createCall(\n            /* expression */\n            propertyAccess,\n            /* typeArguments */\n            undefined,\n            /* arguments */\n            [ts.createStringLiteral(output.name), handler]);\n            diagnostics_1.addParseSpanInfo(call, output.sourceSpan);\n            this.scope.addStatement(ts.createExpressionStatement(call));\n          } else {\n            // If strict checking of DOM inputs is disabled, emit a handler function where the `$event`\n            // parameter has an explicit `any` type.\n            var handler = tcbCreateEventHandler(output, this.tcb, this.scope, 1\n            /* Any */\n            );\n            this.scope.addStatement(ts.createExpressionStatement(handler));\n          }\n\n          template_semantics_1.ExpressionSemanticVisitor.visit(output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n        }\n      } catch (e_10_1) {\n        e_10 = {\n          error: e_10_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_10) throw e_10.error;\n        }\n      }\n\n      return null;\n    };\n\n    return TcbUnclaimedOutputsOp;\n  }(TcbOp);\n  /**\n   * A `TcbOp` which generates a completion point for the component context.\n   *\n   * This completion point looks like `ctx. ;` in the TCB output, and does not produce diagnostics.\n   * TypeScript autocompletion APIs can be used at this completion point (after the '.') to produce\n   * autocompletion results of properties and methods from the template's component context.\n   */\n\n\n  var TcbComponentContextCompletionOp =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbComponentContextCompletionOp, _super);\n\n    function TcbComponentContextCompletionOp(scope) {\n      var _this = _super.call(this) || this;\n\n      _this.scope = scope;\n      _this.optional = false;\n      return _this;\n    }\n\n    TcbComponentContextCompletionOp.prototype.execute = function () {\n      var ctx = ts.createIdentifier('ctx');\n      var ctxDot = ts.createPropertyAccess(ctx, '');\n      comments_1.markIgnoreDiagnostics(ctxDot);\n      comments_1.addExpressionIdentifier(ctxDot, comments_1.ExpressionIdentifier.COMPONENT_COMPLETION);\n      this.scope.addStatement(ts.createExpressionStatement(ctxDot));\n      return null;\n    };\n\n    return TcbComponentContextCompletionOp;\n  }(TcbOp);\n  /**\n   * Value used to break a circular reference between `TcbOp`s.\n   *\n   * This value is returned whenever `TcbOp`s have a circular dependency. The expression is a non-null\n   * assertion of the null value (in TypeScript, the expression `null!`). This construction will infer\n   * the least narrow type for whatever it's assigned to.\n   */\n\n\n  var INFER_TYPE_FOR_CIRCULAR_OP_EXPR = ts.createNonNullExpression(ts.createNull());\n  /**\n   * Overall generation context for the type check block.\n   *\n   * `Context` handles operations during code generation which are global with respect to the whole\n   * block. It's responsible for variable name allocation and management of any imports needed. It\n   * also contains the template metadata itself.\n   */\n\n  var Context =\n  /** @class */\n  function () {\n    function Context(env, domSchemaChecker, oobRecorder, id, boundTarget, pipes, schemas) {\n      this.env = env;\n      this.domSchemaChecker = domSchemaChecker;\n      this.oobRecorder = oobRecorder;\n      this.id = id;\n      this.boundTarget = boundTarget;\n      this.pipes = pipes;\n      this.schemas = schemas;\n      this.nextId = 1;\n    }\n    /**\n     * Allocate a new variable name for use within the `Context`.\n     *\n     * Currently this uses a monotonically increasing counter, but in the future the variable name\n     * might change depending on the type of data being stored.\n     */\n\n\n    Context.prototype.allocateId = function () {\n      return ts.createIdentifier(\"_t\" + this.nextId++);\n    };\n\n    Context.prototype.getPipeByName = function (name) {\n      if (!this.pipes.has(name)) {\n        return null;\n      }\n\n      return this.pipes.get(name);\n    };\n\n    return Context;\n  }();\n\n  exports.Context = Context;\n  /**\n   * Local scope within the type check block for a particular template.\n   *\n   * The top-level template and each nested `<ng-template>` have their own `Scope`, which exist in a\n   * hierarchy. The structure of this hierarchy mirrors the syntactic scopes in the generated type\n   * check block, where each nested template is encased in an `if` structure.\n   *\n   * As a template's `TcbOp`s are executed in a given `Scope`, statements are added via\n   * `addStatement()`. When this processing is complete, the `Scope` can be turned into a `ts.Block`\n   * via `renderToBlock()`.\n   *\n   * If a `TcbOp` requires the output of another, it can call `resolve()`.\n   */\n\n  var Scope =\n  /** @class */\n  function () {\n    function Scope(tcb, parent, guard) {\n      if (parent === void 0) {\n        parent = null;\n      }\n\n      if (guard === void 0) {\n        guard = null;\n      }\n\n      this.tcb = tcb;\n      this.parent = parent;\n      this.guard = guard;\n      /**\n       * A queue of operations which need to be performed to generate the TCB code for this scope.\n       *\n       * This array can contain either a `TcbOp` which has yet to be executed, or a `ts.Expression|null`\n       * representing the memoized result of executing the operation. As operations are executed, their\n       * results are written into the `opQueue`, overwriting the original operation.\n       *\n       * If an operation is in the process of being executed, it is temporarily overwritten here with\n       * `INFER_TYPE_FOR_CIRCULAR_OP_EXPR`. This way, if a cycle is encountered where an operation\n       * depends transitively on its own result, the inner operation will infer the least narrow type\n       * that fits instead. This has the same semantics as TypeScript itself when types are referenced\n       * circularly.\n       */\n\n      this.opQueue = [];\n      /**\n       * A map of `TmplAstElement`s to the index of their `TcbElementOp` in the `opQueue`\n       */\n\n      this.elementOpMap = new Map();\n      /**\n       * A map of maps which tracks the index of `TcbDirectiveCtorOp`s in the `opQueue` for each\n       * directive on a `TmplAstElement` or `TmplAstTemplate` node.\n       */\n\n      this.directiveOpMap = new Map();\n      /**\n       * A map of `TmplAstReference`s to the index of their `TcbReferenceOp` in the `opQueue`\n       */\n\n      this.referenceOpMap = new Map();\n      /**\n       * Map of immediately nested <ng-template>s (within this `Scope`) represented by `TmplAstTemplate`\n       * nodes to the index of their `TcbTemplateContextOp`s in the `opQueue`.\n       */\n\n      this.templateCtxOpMap = new Map();\n      /**\n       * Map of variables declared on the template that created this `Scope` (represented by\n       * `TmplAstVariable` nodes) to the index of their `TcbVariableOp`s in the `opQueue`.\n       */\n\n      this.varMap = new Map();\n      /**\n       * Statements for this template.\n       *\n       * Executing the `TcbOp`s in the `opQueue` populates this array.\n       */\n\n      this.statements = [];\n    }\n    /**\n     * Constructs a `Scope` given either a `TmplAstTemplate` or a list of `TmplAstNode`s.\n     *\n     * @param tcb the overall context of TCB generation.\n     * @param parent the `Scope` of the parent template (if any) or `null` if this is the root\n     * `Scope`.\n     * @param templateOrNodes either a `TmplAstTemplate` representing the template for which to\n     * calculate the `Scope`, or a list of nodes if no outer template object is available.\n     * @param guard an expression that is applied to this scope for type narrowing purposes.\n     */\n\n\n    Scope.forNodes = function (tcb, parent, templateOrNodes, guard) {\n      var e_11, _a, e_12, _b;\n\n      var scope = new Scope(tcb, parent, guard);\n\n      if (parent === null && tcb.env.config.enableTemplateTypeChecker) {\n        // Add an autocompletion point for the component context.\n        scope.opQueue.push(new TcbComponentContextCompletionOp(scope));\n      }\n\n      var children; // If given an actual `TmplAstTemplate` instance, then process any additional information it\n      // has.\n\n      if (templateOrNodes instanceof compiler_1.TmplAstTemplate) {\n        // The template's variable declarations need to be added as `TcbVariableOp`s.\n        var varMap = new Map();\n\n        try {\n          for (var _c = tslib_1.__values(templateOrNodes.variables), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var v = _d.value; // Validate that variables on the `TmplAstTemplate` are only declared once.\n\n            if (!varMap.has(v.name)) {\n              varMap.set(v.name, v);\n            } else {\n              var firstDecl = varMap.get(v.name);\n              tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);\n            }\n\n            var opIndex = scope.opQueue.push(new TcbVariableOp(tcb, scope, templateOrNodes, v)) - 1;\n            scope.varMap.set(v, opIndex);\n          }\n        } catch (e_11_1) {\n          e_11 = {\n            error: e_11_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_11) throw e_11.error;\n          }\n        }\n\n        children = templateOrNodes.children;\n      } else {\n        children = templateOrNodes;\n      }\n\n      try {\n        for (var children_1 = tslib_1.__values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {\n          var node = children_1_1.value;\n          scope.appendNode(node);\n        }\n      } catch (e_12_1) {\n        e_12 = {\n          error: e_12_1\n        };\n      } finally {\n        try {\n          if (children_1_1 && !children_1_1.done && (_b = children_1.return)) _b.call(children_1);\n        } finally {\n          if (e_12) throw e_12.error;\n        }\n      }\n\n      return scope;\n    };\n    /**\n     * Look up a `ts.Expression` representing the value of some operation in the current `Scope`,\n     * including any parent scope(s). This method always returns a mutable clone of the\n     * `ts.Expression` with the comments cleared.\n     *\n     * @param node a `TmplAstNode` of the operation in question. The lookup performed will depend on\n     * the type of this node:\n     *\n     * Assuming `directive` is not present, then `resolve` will return:\n     *\n     * * `TmplAstElement` - retrieve the expression for the element DOM node\n     * * `TmplAstTemplate` - retrieve the template context variable\n     * * `TmplAstVariable` - retrieve a template let- variable\n     * * `TmplAstReference` - retrieve variable created for the local ref\n     *\n     * @param directive if present, a directive type on a `TmplAstElement` or `TmplAstTemplate` to\n     * look up instead of the default for an element or template node.\n     */\n\n\n    Scope.prototype.resolve = function (node, directive) {\n      // Attempt to resolve the operation locally.\n      var res = this.resolveLocal(node, directive);\n\n      if (res !== null) {\n        // We want to get a clone of the resolved expression and clear the trailing comments\n        // so they don't continue to appear in every place the expression is used.\n        // As an example, this would otherwise produce:\n        // var _t1 /**T:DIR*/ /*1,2*/ = _ctor1();\n        // _t1 /**T:DIR*/ /*1,2*/.input = 'value';\n        //\n        // In addition, returning a clone prevents the consumer of `Scope#resolve` from\n        // attaching comments at the declaration site.\n        var clone = ts.getMutableClone(res);\n        ts.setSyntheticTrailingComments(clone, []);\n        return clone;\n      } else if (this.parent !== null) {\n        // Check with the parent.\n        return this.parent.resolve(node, directive);\n      } else {\n        throw new Error(\"Could not resolve \" + node + \" / \" + directive);\n      }\n    };\n    /**\n     * Add a statement to this scope.\n     */\n\n\n    Scope.prototype.addStatement = function (stmt) {\n      this.statements.push(stmt);\n    };\n    /**\n     * Get the statements.\n     */\n\n\n    Scope.prototype.render = function () {\n      for (var i = 0; i < this.opQueue.length; i++) {\n        // Optional statements cannot be skipped when we are generating the TCB for use\n        // by the TemplateTypeChecker.\n        var skipOptional = !this.tcb.env.config.enableTemplateTypeChecker;\n        this.executeOp(i, skipOptional);\n      }\n\n      return this.statements;\n    };\n    /**\n     * Returns an expression of all template guards that apply to this scope, including those of\n     * parent scopes. If no guards have been applied, null is returned.\n     */\n\n\n    Scope.prototype.guards = function () {\n      var parentGuards = null;\n\n      if (this.parent !== null) {\n        // Start with the guards from the parent scope, if present.\n        parentGuards = this.parent.guards();\n      }\n\n      if (this.guard === null) {\n        // This scope does not have a guard, so return the parent's guards as is.\n        return parentGuards;\n      } else if (parentGuards === null) {\n        // There's no guards from the parent scope, so this scope's guard represents all available\n        // guards.\n        return this.guard;\n      } else {\n        // Both the parent scope and this scope provide a guard, so create a combination of the two.\n        // It is important that the parent guard is used as left operand, given that it may provide\n        // narrowing that is required for this scope's guard to be valid.\n        return ts.createBinary(parentGuards, ts.SyntaxKind.AmpersandAmpersandToken, this.guard);\n      }\n    };\n\n    Scope.prototype.resolveLocal = function (ref, directive) {\n      if (ref instanceof compiler_1.TmplAstReference && this.referenceOpMap.has(ref)) {\n        return this.resolveOp(this.referenceOpMap.get(ref));\n      } else if (ref instanceof compiler_1.TmplAstVariable && this.varMap.has(ref)) {\n        // Resolving a context variable for this template.\n        // Execute the `TcbVariableOp` associated with the `TmplAstVariable`.\n        return this.resolveOp(this.varMap.get(ref));\n      } else if (ref instanceof compiler_1.TmplAstTemplate && directive === undefined && this.templateCtxOpMap.has(ref)) {\n        // Resolving the context of the given sub-template.\n        // Execute the `TcbTemplateContextOp` for the template.\n        return this.resolveOp(this.templateCtxOpMap.get(ref));\n      } else if ((ref instanceof compiler_1.TmplAstElement || ref instanceof compiler_1.TmplAstTemplate) && directive !== undefined && this.directiveOpMap.has(ref)) {\n        // Resolving a directive on an element or sub-template.\n        var dirMap = this.directiveOpMap.get(ref);\n\n        if (dirMap.has(directive)) {\n          return this.resolveOp(dirMap.get(directive));\n        } else {\n          return null;\n        }\n      } else if (ref instanceof compiler_1.TmplAstElement && this.elementOpMap.has(ref)) {\n        // Resolving the DOM node of an element in this template.\n        return this.resolveOp(this.elementOpMap.get(ref));\n      } else {\n        return null;\n      }\n    };\n    /**\n     * Like `executeOp`, but assert that the operation actually returned `ts.Expression`.\n     */\n\n\n    Scope.prototype.resolveOp = function (opIndex) {\n      var res = this.executeOp(opIndex,\n      /* skipOptional */\n      false);\n\n      if (res === null) {\n        throw new Error(\"Error resolving operation, got null\");\n      }\n\n      return res;\n    };\n    /**\n     * Execute a particular `TcbOp` in the `opQueue`.\n     *\n     * This method replaces the operation in the `opQueue` with the result of execution (once done)\n     * and also protects against a circular dependency from the operation to itself by temporarily\n     * setting the operation's result to a special expression.\n     */\n\n\n    Scope.prototype.executeOp = function (opIndex, skipOptional) {\n      var op = this.opQueue[opIndex];\n\n      if (!(op instanceof TcbOp)) {\n        return op;\n      }\n\n      if (skipOptional && op.optional) {\n        return null;\n      } // Set the result of the operation in the queue to its circular fallback. If executing this\n      // operation results in a circular dependency, this will prevent an infinite loop and allow for\n      // the resolution of such cycles.\n\n\n      this.opQueue[opIndex] = op.circularFallback();\n      var res = op.execute(); // Once the operation has finished executing, it's safe to cache the real result.\n\n      this.opQueue[opIndex] = res;\n      return res;\n    };\n\n    Scope.prototype.appendNode = function (node) {\n      var e_13, _a;\n\n      if (node instanceof compiler_1.TmplAstElement) {\n        var opIndex = this.opQueue.push(new TcbElementOp(this.tcb, this, node)) - 1;\n        this.elementOpMap.set(node, opIndex);\n        this.appendDirectivesAndInputsOfNode(node);\n        this.appendOutputsOfNode(node);\n\n        try {\n          for (var _b = tslib_1.__values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var child = _c.value;\n            this.appendNode(child);\n          }\n        } catch (e_13_1) {\n          e_13 = {\n            error: e_13_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_13) throw e_13.error;\n          }\n        }\n\n        this.checkAndAppendReferencesOfNode(node);\n      } else if (node instanceof compiler_1.TmplAstTemplate) {\n        // Template children are rendered in a child scope.\n        this.appendDirectivesAndInputsOfNode(node);\n        this.appendOutputsOfNode(node);\n        var ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;\n        this.templateCtxOpMap.set(node, ctxIndex);\n\n        if (this.tcb.env.config.checkTemplateBodies) {\n          this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));\n        } else if (this.tcb.env.config.alwaysCheckSchemaInTemplateBodies) {\n          this.appendDeepSchemaChecks(node.children);\n        }\n\n        this.checkAndAppendReferencesOfNode(node);\n      } else if (node instanceof compiler_1.TmplAstBoundText) {\n        this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, node));\n      } else if (node instanceof compiler_1.TmplAstIcu) {\n        this.appendIcuExpressions(node);\n      }\n    };\n\n    Scope.prototype.checkAndAppendReferencesOfNode = function (node) {\n      var e_14, _a;\n\n      try {\n        for (var _b = tslib_1.__values(node.references), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var ref = _c.value;\n          var target = this.tcb.boundTarget.getReferenceTarget(ref);\n          var ctxIndex = void 0;\n\n          if (target === null) {\n            // The reference is invalid if it doesn't have a target, so report it as an error.\n            this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref); // Any usages of the invalid reference will be resolved to a variable of type any.\n\n            ctxIndex = this.opQueue.push(new TcbInvalidReferenceOp(this.tcb, this)) - 1;\n          } else if (target instanceof compiler_1.TmplAstTemplate || target instanceof compiler_1.TmplAstElement) {\n            ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target)) - 1;\n          } else {\n            ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target.directive)) - 1;\n          }\n\n          this.referenceOpMap.set(ref, ctxIndex);\n        }\n      } catch (e_14_1) {\n        e_14 = {\n          error: e_14_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_14) throw e_14.error;\n        }\n      }\n    };\n\n    Scope.prototype.appendDirectivesAndInputsOfNode = function (node) {\n      var e_15, _a, e_16, _b, e_17, _c; // Collect all the inputs on the element.\n\n\n      var claimedInputs = new Set();\n      var directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n\n      if (directives === null || directives.length === 0) {\n        // If there are no directives, then all inputs are unclaimed inputs, so queue an operation\n        // to add them if needed.\n        if (node instanceof compiler_1.TmplAstElement) {\n          this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n          this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node,\n          /* checkElement */\n          true, claimedInputs));\n        }\n\n        return;\n      }\n\n      var dirMap = new Map();\n\n      try {\n        for (var directives_2 = tslib_1.__values(directives), directives_2_1 = directives_2.next(); !directives_2_1.done; directives_2_1 = directives_2.next()) {\n          var dir = directives_2_1.value;\n          var directiveOp = void 0;\n          var host = this.tcb.env.reflector;\n          var dirRef = dir.ref;\n\n          if (!dir.isGeneric) {\n            // The most common case is that when a directive is not generic, we use the normal\n            // `TcbNonDirectiveTypeOp`.\n            directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);\n          } else if (!type_constructor_1.requiresInlineTypeCtor(dirRef.node, host) || this.tcb.env.config.useInlineTypeConstructors) {\n            // For generic directives, we use a type constructor to infer types. If a directive requires\n            // an inline type constructor, then inlining must be available to use the\n            // `TcbDirectiveCtorOp`. If not we, we fallback to using `any` – see below.\n            directiveOp = new TcbDirectiveCtorOp(this.tcb, this, node, dir);\n          } else {\n            // If inlining is not available, then we give up on infering the generic params, and use\n            // `any` type for the directive's generic parameters.\n            directiveOp = new TcbGenericDirectiveTypeWithAnyParamsOp(this.tcb, this, node, dir);\n          }\n\n          var dirIndex = this.opQueue.push(directiveOp) - 1;\n          dirMap.set(dir, dirIndex);\n          this.opQueue.push(new TcbDirectiveInputsOp(this.tcb, this, node, dir));\n        }\n      } catch (e_15_1) {\n        e_15 = {\n          error: e_15_1\n        };\n      } finally {\n        try {\n          if (directives_2_1 && !directives_2_1.done && (_a = directives_2.return)) _a.call(directives_2);\n        } finally {\n          if (e_15) throw e_15.error;\n        }\n      }\n\n      this.directiveOpMap.set(node, dirMap); // After expanding the directives, we might need to queue an operation to check any unclaimed\n      // inputs.\n\n      if (node instanceof compiler_1.TmplAstElement) {\n        try {\n          // Go through the directives and remove any inputs that it claims from `elementInputs`.\n          for (var directives_3 = tslib_1.__values(directives), directives_3_1 = directives_3.next(); !directives_3_1.done; directives_3_1 = directives_3.next()) {\n            var dir = directives_3_1.value;\n\n            try {\n              for (var _d = (e_17 = void 0, tslib_1.__values(dir.inputs.propertyNames)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var propertyName = _e.value;\n                claimedInputs.add(propertyName);\n              }\n            } catch (e_17_1) {\n              e_17 = {\n                error: e_17_1\n              };\n            } finally {\n              try {\n                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n              } finally {\n                if (e_17) throw e_17.error;\n              }\n            }\n          }\n        } catch (e_16_1) {\n          e_16 = {\n            error: e_16_1\n          };\n        } finally {\n          try {\n            if (directives_3_1 && !directives_3_1.done && (_b = directives_3.return)) _b.call(directives_3);\n          } finally {\n            if (e_16) throw e_16.error;\n          }\n        }\n\n        this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs)); // If there are no directives which match this element, then it's a \"plain\" DOM element (or a\n        // web component), and should be checked against the DOM schema. If any directives match,\n        // we must assume that the element could be custom (either a component, or a directive like\n        // <router-outlet>) and shouldn't validate the element name itself.\n\n        var checkElement = directives.length === 0;\n        this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));\n      }\n    };\n\n    Scope.prototype.appendOutputsOfNode = function (node) {\n      var e_18, _a, e_19, _b, e_20, _c; // Collect all the outputs on the element.\n\n\n      var claimedOutputs = new Set();\n      var directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n\n      if (directives === null || directives.length === 0) {\n        // If there are no directives, then all outputs are unclaimed outputs, so queue an operation\n        // to add them if needed.\n        if (node instanceof compiler_1.TmplAstElement) {\n          this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n        }\n\n        return;\n      }\n\n      try {\n        // Queue operations for all directives to check the relevant outputs for a directive.\n        for (var directives_4 = tslib_1.__values(directives), directives_4_1 = directives_4.next(); !directives_4_1.done; directives_4_1 = directives_4.next()) {\n          var dir = directives_4_1.value;\n          this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, dir));\n        }\n      } catch (e_18_1) {\n        e_18 = {\n          error: e_18_1\n        };\n      } finally {\n        try {\n          if (directives_4_1 && !directives_4_1.done && (_a = directives_4.return)) _a.call(directives_4);\n        } finally {\n          if (e_18) throw e_18.error;\n        }\n      } // After expanding the directives, we might need to queue an operation to check any unclaimed\n      // outputs.\n\n\n      if (node instanceof compiler_1.TmplAstElement) {\n        try {\n          // Go through the directives and register any outputs that it claims in `claimedOutputs`.\n          for (var directives_5 = tslib_1.__values(directives), directives_5_1 = directives_5.next(); !directives_5_1.done; directives_5_1 = directives_5.next()) {\n            var dir = directives_5_1.value;\n\n            try {\n              for (var _d = (e_20 = void 0, tslib_1.__values(dir.outputs.propertyNames)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var outputProperty = _e.value;\n                claimedOutputs.add(outputProperty);\n              }\n            } catch (e_20_1) {\n              e_20 = {\n                error: e_20_1\n              };\n            } finally {\n              try {\n                if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n              } finally {\n                if (e_20) throw e_20.error;\n              }\n            }\n          }\n        } catch (e_19_1) {\n          e_19 = {\n            error: e_19_1\n          };\n        } finally {\n          try {\n            if (directives_5_1 && !directives_5_1.done && (_b = directives_5.return)) _b.call(directives_5);\n          } finally {\n            if (e_19) throw e_19.error;\n          }\n        }\n\n        this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n      }\n    };\n\n    Scope.prototype.appendDeepSchemaChecks = function (nodes) {\n      var e_21, _a, e_22, _b, e_23, _c;\n\n      try {\n        for (var nodes_1 = tslib_1.__values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n          var node = nodes_1_1.value;\n\n          if (!(node instanceof compiler_1.TmplAstElement || node instanceof compiler_1.TmplAstTemplate)) {\n            continue;\n          }\n\n          if (node instanceof compiler_1.TmplAstElement) {\n            var claimedInputs = new Set();\n            var directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n            var hasDirectives = void 0;\n\n            if (directives === null || directives.length === 0) {\n              hasDirectives = false;\n            } else {\n              hasDirectives = true;\n\n              try {\n                for (var directives_6 = (e_22 = void 0, tslib_1.__values(directives)), directives_6_1 = directives_6.next(); !directives_6_1.done; directives_6_1 = directives_6.next()) {\n                  var dir = directives_6_1.value;\n\n                  try {\n                    for (var _d = (e_23 = void 0, tslib_1.__values(dir.inputs.propertyNames)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                      var propertyName = _e.value;\n                      claimedInputs.add(propertyName);\n                    }\n                  } catch (e_23_1) {\n                    e_23 = {\n                      error: e_23_1\n                    };\n                  } finally {\n                    try {\n                      if (_e && !_e.done && (_c = _d.return)) _c.call(_d);\n                    } finally {\n                      if (e_23) throw e_23.error;\n                    }\n                  }\n                }\n              } catch (e_22_1) {\n                e_22 = {\n                  error: e_22_1\n                };\n              } finally {\n                try {\n                  if (directives_6_1 && !directives_6_1.done && (_b = directives_6.return)) _b.call(directives_6);\n                } finally {\n                  if (e_22) throw e_22.error;\n                }\n              }\n            }\n\n            this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, !hasDirectives, claimedInputs));\n          }\n\n          this.appendDeepSchemaChecks(node.children);\n        }\n      } catch (e_21_1) {\n        e_21 = {\n          error: e_21_1\n        };\n      } finally {\n        try {\n          if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n        } finally {\n          if (e_21) throw e_21.error;\n        }\n      }\n    };\n\n    Scope.prototype.appendIcuExpressions = function (node) {\n      var e_24, _a, e_25, _b;\n\n      try {\n        for (var _c = tslib_1.__values(Object.values(node.vars)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var variable = _d.value;\n          this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, variable));\n        }\n      } catch (e_24_1) {\n        e_24 = {\n          error: e_24_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_24) throw e_24.error;\n        }\n      }\n\n      try {\n        for (var _e = tslib_1.__values(Object.values(node.placeholders)), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var placeholder = _f.value;\n\n          if (placeholder instanceof compiler_1.TmplAstBoundText) {\n            this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, placeholder));\n          }\n        }\n      } catch (e_25_1) {\n        e_25 = {\n          error: e_25_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_25) throw e_25.error;\n        }\n      }\n    };\n\n    return Scope;\n  }();\n  /**\n   * Create the `ctx` parameter to the top-level TCB function, with the given generic type arguments.\n   */\n\n\n  function tcbCtxParam(node, name, typeArguments) {\n    var type = ts.factory.createTypeReferenceNode(name, typeArguments);\n    return ts.factory.createParameterDeclaration(\n    /* decorators */\n    undefined,\n    /* modifiers */\n    undefined,\n    /* dotDotDotToken */\n    undefined,\n    /* name */\n    'ctx',\n    /* questionToken */\n    undefined,\n    /* type */\n    type,\n    /* initializer */\n    undefined);\n  }\n  /**\n   * Process an `AST` expression and convert it into a `ts.Expression`, generating references to the\n   * correct identifiers in the current scope.\n   */\n\n\n  function tcbExpression(ast, tcb, scope) {\n    var translator = new TcbExpressionTranslator(tcb, scope);\n    return translator.translate(ast);\n  }\n\n  var TcbExpressionTranslator =\n  /** @class */\n  function () {\n    function TcbExpressionTranslator(tcb, scope) {\n      this.tcb = tcb;\n      this.scope = scope;\n    }\n\n    TcbExpressionTranslator.prototype.translate = function (ast) {\n      var _this = this; // `astToTypescript` actually does the conversion. A special resolver `tcbResolve` is passed\n      // which interprets specific expression nodes that interact with the `ImplicitReceiver`. These\n      // nodes actually refer to identifiers within the current scope.\n\n\n      return expression_1.astToTypescript(ast, function (ast) {\n        return _this.resolve(ast);\n      }, this.tcb.env.config);\n    };\n    /**\n     * Resolve an `AST` expression within the given scope.\n     *\n     * Some `AST` expressions refer to top-level concepts (references, variables, the component\n     * context). This method assists in resolving those.\n     */\n\n\n    TcbExpressionTranslator.prototype.resolve = function (ast) {\n      var _this = this;\n\n      if (ast instanceof compiler_1.PropertyRead && ast.receiver instanceof compiler_1.ImplicitReceiver) {\n        // Try to resolve a bound target for this expression. If no such target is available, then\n        // the expression is referencing the top-level component context. In that case, `null` is\n        // returned here to let it fall through resolution so it will be caught when the\n        // `ImplicitReceiver` is resolved in the branch below.\n        return this.resolveTarget(ast);\n      } else if (ast instanceof compiler_1.PropertyWrite && ast.receiver instanceof compiler_1.ImplicitReceiver) {\n        var target = this.resolveTarget(ast);\n\n        if (target === null) {\n          return null;\n        }\n\n        var expr = this.translate(ast.value);\n        var result = ts.createParen(ts.createBinary(target, ts.SyntaxKind.EqualsToken, expr));\n        diagnostics_1.addParseSpanInfo(result, ast.sourceSpan);\n        return result;\n      } else if (ast instanceof compiler_1.ImplicitReceiver) {\n        // AST instances representing variables and references look very similar to property reads\n        // or method calls from the component context: both have the shape\n        // PropertyRead(ImplicitReceiver, 'propName') or MethodCall(ImplicitReceiver, 'methodName').\n        //\n        // `translate` will first try to `resolve` the outer PropertyRead/MethodCall. If this works,\n        // it's because the `BoundTarget` found an expression target for the whole expression, and\n        // therefore `translate` will never attempt to `resolve` the ImplicitReceiver of that\n        // PropertyRead/MethodCall.\n        //\n        // Therefore if `resolve` is called on an `ImplicitReceiver`, it's because no outer\n        // PropertyRead/MethodCall resolved to a variable or reference, and therefore this is a\n        // property read or method call on the component context itself.\n        return ts.createIdentifier('ctx');\n      } else if (ast instanceof compiler_1.BindingPipe) {\n        var expr = this.translate(ast.exp);\n        var pipeRef = this.tcb.getPipeByName(ast.name);\n        var pipe = void 0;\n\n        if (pipeRef === null) {\n          // No pipe by that name exists in scope. Record this as an error.\n          this.tcb.oobRecorder.missingPipe(this.tcb.id, ast); // Use an 'any' value to at least allow the rest of the expression to be checked.\n\n          pipe = expression_1.NULL_AS_ANY;\n        } else if (this.tcb.env.config.checkTypeOfPipes) {\n          // Use a variable declared as the pipe's type.\n          pipe = this.tcb.env.pipeInst(pipeRef);\n        } else {\n          // Use an 'any' value when not checking the type of the pipe.\n          pipe = ts.createAsExpression(this.tcb.env.pipeInst(pipeRef), ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n        }\n\n        var args = ast.args.map(function (arg) {\n          return _this.translate(arg);\n        });\n        var methodAccess = ts.createPropertyAccess(pipe, 'transform');\n        diagnostics_1.addParseSpanInfo(methodAccess, ast.nameSpan);\n        var result = ts.createCall(\n        /* expression */\n        methodAccess,\n        /* typeArguments */\n        undefined, tslib_1.__spread([expr], args));\n        diagnostics_1.addParseSpanInfo(result, ast.sourceSpan);\n        return result;\n      } else if (ast instanceof compiler_1.MethodCall && ast.receiver instanceof compiler_1.ImplicitReceiver && !(ast.receiver instanceof compiler_1.ThisReceiver)) {\n        // Resolve the special `$any(expr)` syntax to insert a cast of the argument to type `any`.\n        // `$any(expr)` -> `expr as any`\n        if (ast.name === '$any' && ast.args.length === 1) {\n          var expr = this.translate(ast.args[0]);\n          var exprAsAny = ts.createAsExpression(expr, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n          var result = ts.createParen(exprAsAny);\n          diagnostics_1.addParseSpanInfo(result, ast.sourceSpan);\n          return result;\n        } // Attempt to resolve a bound target for the method, and generate the method call if a target\n        // could be resolved. If no target is available, then the method is referencing the top-level\n        // component context, in which case `null` is returned to let the `ImplicitReceiver` being\n        // resolved to the component context.\n\n\n        var receiver = this.resolveTarget(ast);\n\n        if (receiver === null) {\n          return null;\n        }\n\n        var method = diagnostics_1.wrapForDiagnostics(receiver);\n        diagnostics_1.addParseSpanInfo(method, ast.nameSpan);\n        var args = ast.args.map(function (arg) {\n          return _this.translate(arg);\n        });\n        var node = ts.createCall(method, undefined, args);\n        diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n        return node;\n      } else {\n        // This AST isn't special after all.\n        return null;\n      }\n    };\n    /**\n     * Attempts to resolve a bound target for a given expression, and translates it into the\n     * appropriate `ts.Expression` that represents the bound target. If no target is available,\n     * `null` is returned.\n     */\n\n\n    TcbExpressionTranslator.prototype.resolveTarget = function (ast) {\n      var binding = this.tcb.boundTarget.getExpressionTarget(ast);\n\n      if (binding === null) {\n        return null;\n      }\n\n      var expr = this.scope.resolve(binding);\n      diagnostics_1.addParseSpanInfo(expr, ast.sourceSpan);\n      return expr;\n    };\n\n    return TcbExpressionTranslator;\n  }();\n  /**\n   * Call the type constructor of a directive instance on a given template node, inferring a type for\n   * the directive instance from any bound inputs.\n   */\n\n\n  function tcbCallTypeCtor(dir, tcb, inputs) {\n    var typeCtor = tcb.env.typeCtorFor(dir); // Construct an array of `ts.PropertyAssignment`s for each of the directive's inputs.\n\n    var members = inputs.map(function (input) {\n      var propertyName = ts.createStringLiteral(input.field);\n\n      if (input.type === 'binding') {\n        // For bound inputs, the property is assigned the binding expression.\n        var expr = input.expression;\n\n        if (!tcb.env.config.checkTypeOfInputBindings) {\n          // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n          // before the assignment.\n          expr = ts_util_1.tsCastToAny(expr);\n        } else if (!tcb.env.config.strictNullInputBindings) {\n          // If strict null checks are disabled, erase `null` and `undefined` from the type by\n          // wrapping the expression in a non-null assertion.\n          expr = ts.createNonNullExpression(expr);\n        }\n\n        var assignment = ts.createPropertyAssignment(propertyName, diagnostics_1.wrapForDiagnostics(expr));\n        diagnostics_1.addParseSpanInfo(assignment, input.sourceSpan);\n        return assignment;\n      } else {\n        // A type constructor is required to be called with all input properties, so any unset\n        // inputs are simply assigned a value of type `any` to ignore them.\n        return ts.createPropertyAssignment(propertyName, expression_1.NULL_AS_ANY);\n      }\n    }); // Call the `ngTypeCtor` method on the directive class, with an object literal argument created\n    // from the matched inputs.\n\n    return ts.createCall(\n    /* expression */\n    typeCtor,\n    /* typeArguments */\n    undefined,\n    /* argumentsArray */\n    [ts.createObjectLiteral(members)]);\n  }\n\n  function getBoundInputs(directive, node, tcb) {\n    var boundInputs = [];\n\n    var processAttribute = function processAttribute(attr) {\n      // Skip non-property bindings.\n      if (attr instanceof compiler_1.TmplAstBoundAttribute && attr.type !== 0\n      /* Property */\n      ) {\n          return;\n        } // Skip the attribute if the directive does not have an input for it.\n\n\n      var inputs = directive.inputs.getByBindingPropertyName(attr.name);\n\n      if (inputs === null) {\n        return;\n      }\n\n      var fieldNames = inputs.map(function (input) {\n        return input.classPropertyName;\n      });\n      boundInputs.push({\n        attribute: attr,\n        fieldNames: fieldNames\n      });\n    };\n\n    node.inputs.forEach(processAttribute);\n    node.attributes.forEach(processAttribute);\n\n    if (node instanceof compiler_1.TmplAstTemplate) {\n      node.templateAttrs.forEach(processAttribute);\n    }\n\n    return boundInputs;\n  }\n  /**\n   * Translates the given attribute binding to a `ts.Expression`.\n   */\n\n\n  function translateInput(attr, tcb, scope) {\n    if (attr instanceof compiler_1.TmplAstBoundAttribute) {\n      // Produce an expression representing the value of the binding.\n      return tcbExpression(attr.value, tcb, scope);\n    } else {\n      // For regular attributes with a static string value, use the represented string literal.\n      return ts.createStringLiteral(attr.value);\n    }\n  }\n\n  var EVENT_PARAMETER = '$event';\n  /**\n   * Creates an arrow function to be used as handler function for event bindings. The handler\n   * function has a single parameter `$event` and the bound event's handler `AST` represented as a\n   * TypeScript expression as its body.\n   *\n   * When `eventType` is set to `Infer`, the `$event` parameter will not have an explicit type. This\n   * allows for the created handler function to have its `$event` parameter's type inferred based on\n   * how it's used, to enable strict type checking of event bindings. When set to `Any`, the `$event`\n   * parameter will have an explicit `any` type, effectively disabling strict type checking of event\n   * bindings. Alternatively, an explicit type can be passed for the `$event` parameter.\n   */\n\n  function tcbCreateEventHandler(event, tcb, scope, eventType) {\n    var handler = tcbEventHandlerExpression(event.handler, tcb, scope);\n    var eventParamType;\n\n    if (eventType === 0\n    /* Infer */\n    ) {\n        eventParamType = undefined;\n      } else if (eventType === 1\n    /* Any */\n    ) {\n        eventParamType = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n      } else {\n      eventParamType = eventType;\n    } // Obtain all guards that have been applied to the scope and its parents, as they have to be\n    // repeated within the handler function for their narrowing to be in effect within the handler.\n\n\n    var guards = scope.guards();\n    var body = ts.createExpressionStatement(handler);\n\n    if (guards !== null) {\n      // Wrap the body in an `if` statement containing all guards that have to be applied.\n      body = ts.createIf(guards, body);\n    }\n\n    var eventParam = ts.createParameter(\n    /* decorators */\n    undefined,\n    /* modifiers */\n    undefined,\n    /* dotDotDotToken */\n    undefined,\n    /* name */\n    EVENT_PARAMETER,\n    /* questionToken */\n    undefined,\n    /* type */\n    eventParamType);\n    comments_1.addExpressionIdentifier(eventParam, comments_1.ExpressionIdentifier.EVENT_PARAMETER);\n    return ts.createFunctionExpression(\n    /* modifier */\n    undefined,\n    /* asteriskToken */\n    undefined,\n    /* name */\n    undefined,\n    /* typeParameters */\n    undefined,\n    /* parameters */\n    [eventParam],\n    /* type */\n    ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n    /* body */\n    ts.createBlock([body]));\n  }\n  /**\n   * Similar to `tcbExpression`, this function converts the provided `AST` expression into a\n   * `ts.Expression`, with special handling of the `$event` variable that can be used within event\n   * bindings.\n   */\n\n\n  function tcbEventHandlerExpression(ast, tcb, scope) {\n    var translator = new TcbEventHandlerTranslator(tcb, scope);\n    return translator.translate(ast);\n  }\n\n  var TcbEventHandlerTranslator =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TcbEventHandlerTranslator, _super);\n\n    function TcbEventHandlerTranslator() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    TcbEventHandlerTranslator.prototype.resolve = function (ast) {\n      // Recognize a property read on the implicit receiver corresponding with the event parameter\n      // that is available in event bindings. Since this variable is a parameter of the handler\n      // function that the converted expression becomes a child of, just create a reference to the\n      // parameter by its name.\n      if (ast instanceof compiler_1.PropertyRead && ast.receiver instanceof compiler_1.ImplicitReceiver && !(ast.receiver instanceof compiler_1.ThisReceiver) && ast.name === EVENT_PARAMETER) {\n        var event_1 = ts.createIdentifier(EVENT_PARAMETER);\n        diagnostics_1.addParseSpanInfo(event_1, ast.nameSpan);\n        return event_1;\n      }\n\n      return _super.prototype.resolve.call(this, ast);\n    };\n\n    return TcbEventHandlerTranslator;\n  }(TcbExpressionTranslator);\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_check_block.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, BindingPipe, BindingType, BoundTarget, DYNAMIC_TYPE, ImplicitReceiver, MethodCall, ParsedEventType, ParseSourceSpan, PropertyRead, PropertyWrite, SchemaMetadata, ThisReceiver, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstIcu, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {ClassPropertyName} from '../../metadata';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {TemplateId, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata} from '../api';\n\nimport {addExpressionIdentifier, ExpressionIdentifier, markIgnoreDiagnostics} from './comments';\nimport {addParseSpanInfo, addTemplateId, wrapForDiagnostics, wrapForTypeChecker} from './diagnostics';\nimport {DomSchemaChecker} from './dom';\nimport {Environment} from './environment';\nimport {astToTypescript, NULL_AS_ANY} from './expression';\nimport {OutOfBandDiagnosticRecorder} from './oob';\nimport {ExpressionSemanticVisitor} from './template_semantics';\nimport {tsCallMethod, tsCastToAny, tsCreateElement, tsCreateTypeQueryForCoercedInput, tsCreateVariable, tsDeclareVariable} from './ts_util';\nimport {requiresInlineTypeCtor} from './type_constructor';\nimport {TypeParameterEmitter} from './type_parameter_emitter';\n\n/**\n * Controls how generics for the component context class will be handled during TCB generation.\n */\nexport enum TcbGenericContextBehavior {\n  /**\n   * References to generic parameter bounds will be emitted via the `TypeParameterEmitter`.\n   *\n   * The caller must verify that all parameter bounds are emittable in order to use this mode.\n   */\n  UseEmitter,\n\n  /**\n   * Generic parameter declarations will be copied directly from the `ts.ClassDeclaration` of the\n   * component class.\n   *\n   * The caller must only use the generated TCB code in a context where such copies will still be\n   * valid, such as an inline type check block.\n   */\n  CopyClassNodes,\n\n  /**\n   * Any generic parameters for the component context class will be set to `any`.\n   *\n   * Produces a less useful type, but is always safe to use.\n   */\n  FallbackToAny,\n}\n\n/**\n * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a\n * \"type check block\" function.\n *\n * When passed through TypeScript's TypeChecker, type errors that arise within the type check block\n * function indicate issues in the template itself.\n *\n * As a side effect of generating a TCB for the component, `ts.Diagnostic`s may also be produced\n * directly for issues within the template which are identified during generation. These issues are\n * recorded in either the `domSchemaChecker` (which checks usage of DOM elements and bindings) as\n * well as the `oobRecorder` (which records errors when the type-checking code generator is unable\n * to sufficiently understand a template).\n *\n * @param env an `Environment` into which type-checking code will be generated.\n * @param ref a `Reference` to the component class which should be type-checked.\n * @param name a `ts.Identifier` to use for the generated `ts.FunctionDeclaration`.\n * @param meta metadata about the component's template and the function being generated.\n * @param domSchemaChecker used to check and record errors regarding improper usage of DOM elements\n * and bindings.\n * @param oobRecorder used to record errors regarding template elements which could not be correctly\n * translated into types during TCB generation.\n * @param genericContextBehavior controls how generic parameters (especially parameters with generic\n * bounds) will be referenced from the generated TCB code.\n */\nexport function generateTypeCheckBlock(\n    env: Environment, ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, name: ts.Identifier,\n    meta: TypeCheckBlockMetadata, domSchemaChecker: DomSchemaChecker,\n    oobRecorder: OutOfBandDiagnosticRecorder,\n    genericContextBehavior: TcbGenericContextBehavior): ts.FunctionDeclaration {\n  const tcb = new Context(\n      env, domSchemaChecker, oobRecorder, meta.id, meta.boundTarget, meta.pipes, meta.schemas);\n  const scope = Scope.forNodes(tcb, null, tcb.boundTarget.target.template !, /* guard */ null);\n  const ctxRawType = env.referenceType(ref);\n  if (!ts.isTypeReferenceNode(ctxRawType)) {\n    throw new Error(\n        `Expected TypeReferenceNode when referencing the ctx param for ${ref.debugName}`);\n  }\n\n  let typeParameters: ts.TypeParameterDeclaration[]|undefined = undefined;\n  let typeArguments: ts.TypeNode[]|undefined = undefined;\n\n  if (ref.node.typeParameters !== undefined) {\n    if (!env.config.useContextGenericType) {\n      genericContextBehavior = TcbGenericContextBehavior.FallbackToAny;\n    }\n\n    switch (genericContextBehavior) {\n      case TcbGenericContextBehavior.UseEmitter:\n        // Guaranteed to emit type parameters since we checked that the class has them above.\n        typeParameters = new TypeParameterEmitter(ref.node.typeParameters, env.reflector)\n                             .emit(typeRef => env.referenceType(typeRef))!;\n        typeArguments = typeParameters.map(param => ts.factory.createTypeReferenceNode(param.name));\n        break;\n      case TcbGenericContextBehavior.CopyClassNodes:\n        typeParameters = [...ref.node.typeParameters];\n        typeArguments = typeParameters.map(param => ts.factory.createTypeReferenceNode(param.name));\n        break;\n      case TcbGenericContextBehavior.FallbackToAny:\n        typeArguments = ref.node.typeParameters.map(\n            () => ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n        break;\n    }\n  }\n\n  const paramList = [tcbCtxParam(ref.node, ctxRawType.typeName, typeArguments)];\n\n  const scopeStatements = scope.render();\n  const innerBody = ts.createBlock([\n    ...env.getPreludeStatements(),\n    ...scopeStatements,\n  ]);\n\n  // Wrap the body in an \"if (true)\" expression. This is unnecessary but has the effect of causing\n  // the `ts.Printer` to format the type-check block nicely.\n  const body = ts.createBlock([ts.createIf(ts.createTrue(), innerBody, undefined)]);\n  const fnDecl = ts.createFunctionDeclaration(\n      /* decorators */ undefined,\n      /* modifiers */ undefined,\n      /* asteriskToken */ undefined,\n      /* name */ name,\n      /* typeParameters */ env.config.useContextGenericType ? typeParameters : undefined,\n      /* parameters */ paramList,\n      /* type */ undefined,\n      /* body */ body);\n  addTemplateId(fnDecl, meta.id);\n  return fnDecl;\n}\n\n/**\n * A code generation operation that's involved in the construction of a Type Check Block.\n *\n * The generation of a TCB is non-linear. Bindings within a template may result in the need to\n * construct certain types earlier than they otherwise would be constructed. That is, if the\n * generation of a TCB for a template is broken down into specific operations (constructing a\n * directive, extracting a variable from a let- operation, etc), then it's possible for operations\n * earlier in the sequence to depend on operations which occur later in the sequence.\n *\n * `TcbOp` abstracts the different types of operations which are required to convert a template into\n * a TCB. This allows for two phases of processing for the template, where 1) a linear sequence of\n * `TcbOp`s is generated, and then 2) these operations are executed, not necessarily in linear\n * order.\n *\n * Each `TcbOp` may insert statements into the body of the TCB, and also optionally return a\n * `ts.Expression` which can be used to reference the operation's result.\n */\nabstract class TcbOp {\n  /**\n   * Set to true if this operation can be considered optional. Optional operations are only executed\n   * when depended upon by other operations, otherwise they are disregarded. This allows for less\n   * code to generate, parse and type-check, overall positively contributing to performance.\n   */\n  abstract readonly optional: boolean;\n\n  abstract execute(): ts.Expression|null;\n\n  /**\n   * Replacement value or operation used while this `TcbOp` is executing (i.e. to resolve circular\n   * references during its execution).\n   *\n   * This is usually a `null!` expression (which asks TS to infer an appropriate type), but another\n   * `TcbOp` can be returned in cases where additional code generation is necessary to deal with\n   * circular references.\n   */\n  circularFallback(): TcbOp|ts.Expression {\n    return INFER_TYPE_FOR_CIRCULAR_OP_EXPR;\n  }\n}\n\n/**\n * A `TcbOp` which creates an expression for a native DOM element (or web component) from a\n * `TmplAstElement`.\n *\n * Executing this operation returns a reference to the element variable.\n */\nclass TcbElementOp extends TcbOp {\n  constructor(private tcb: Context, private scope: Scope, private element: TmplAstElement) {\n    super();\n  }\n\n  get optional() {\n    // The statement generated by this operation is only used for type-inference of the DOM\n    // element's type and won't report diagnostics by itself, so the operation is marked as optional\n    // to avoid generating statements for DOM elements that are never referenced.\n    return true;\n  }\n\n  execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    // Add the declaration of the element using document.createElement.\n    const initializer = tsCreateElement(this.element.name);\n    addParseSpanInfo(initializer, this.element.startSourceSpan || this.element.sourceSpan);\n    this.scope.addStatement(tsCreateVariable(id, initializer));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which creates an expression for particular let- `TmplAstVariable` on a\n * `TmplAstTemplate`'s context.\n *\n * Executing this operation returns a reference to the variable variable (lol).\n */\nclass TcbVariableOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private template: TmplAstTemplate,\n      private variable: TmplAstVariable) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): ts.Identifier {\n    // Look for a context variable for the template.\n    const ctx = this.scope.resolve(this.template);\n\n    // Allocate an identifier for the TmplAstVariable, and initialize it to a read of the variable\n    // on the template context.\n    const id = this.tcb.allocateId();\n    const initializer = ts.createPropertyAccess(\n        /* expression */ ctx,\n        /* name */ this.variable.value || '$implicit');\n    addParseSpanInfo(id, this.variable.keySpan);\n\n    // Declare the variable, and return its identifier.\n    let variable: ts.VariableStatement;\n    if (this.variable.valueSpan !== undefined) {\n      addParseSpanInfo(initializer, this.variable.valueSpan);\n      variable = tsCreateVariable(id, wrapForTypeChecker(initializer));\n    } else {\n      variable = tsCreateVariable(id, initializer);\n    }\n    addParseSpanInfo(variable.declarationList.declarations[0], this.variable.sourceSpan);\n    this.scope.addStatement(variable);\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which generates a variable for a `TmplAstTemplate`'s context.\n *\n * Executing this operation returns a reference to the template's context variable.\n */\nclass TcbTemplateContextOp extends TcbOp {\n  constructor(private tcb: Context, private scope: Scope) {\n    super();\n  }\n\n  // The declaration of the context variable is only needed when the context is actually referenced.\n  readonly optional = true;\n\n  execute(): ts.Identifier {\n    // Allocate a template ctx variable and declare it with an 'any' type. The type of this variable\n    // may be narrowed as a result of template guard conditions.\n    const ctx = this.tcb.allocateId();\n    const type = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n    this.scope.addStatement(tsDeclareVariable(ctx, type));\n    return ctx;\n  }\n}\n\n/**\n * A `TcbOp` which descends into a `TmplAstTemplate`'s children and generates type-checking code for\n * them.\n *\n * This operation wraps the children's type-checking code in an `if` block, which may include one\n * or more type guard conditions that narrow types within the template body.\n */\nclass TcbTemplateBodyOp extends TcbOp {\n  constructor(private tcb: Context, private scope: Scope, private template: TmplAstTemplate) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): null {\n    // An `if` will be constructed, within which the template's children will be type checked. The\n    // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared\n    // in the template's TCB from the outer context, and it allows any directives on the templates\n    // to perform type narrowing of either expressions or the template's context.\n    //\n    // The guard is the `if` block's condition. It's usually set to `true` but directives that exist\n    // on the template can trigger extra guard expressions that serve to narrow types within the\n    // `if`. `guard` is calculated by starting with `true` and adding other conditions as needed.\n    // Collect these into `guards` by processing the directives.\n    const directiveGuards: ts.Expression[] = [];\n\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(this.template);\n    if (directives !== null) {\n      for (const dir of directives) {\n        const dirInstId = this.scope.resolve(this.template, dir);\n        const dirId =\n            this.tcb.env.reference(dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>);\n\n        // There are two kinds of guards. Template guards (ngTemplateGuards) allow type narrowing of\n        // the expression passed to an @Input of the directive. Scan the directive to see if it has\n        // any template guards, and generate them if needed.\n        dir.ngTemplateGuards.forEach(guard => {\n          // For each template guard function on the directive, look for a binding to that input.\n          const boundInput = this.template.inputs.find(i => i.name === guard.inputName) ||\n              this.template.templateAttrs.find(\n                  (i: TmplAstTextAttribute|TmplAstBoundAttribute): i is TmplAstBoundAttribute =>\n                      i instanceof TmplAstBoundAttribute && i.name === guard.inputName);\n          if (boundInput !== undefined) {\n            // If there is such a binding, generate an expression for it.\n            const expr = tcbExpression(boundInput.value, this.tcb, this.scope);\n\n            // The expression has already been checked in the type constructor invocation, so\n            // it should be ignored when used within a template guard.\n            markIgnoreDiagnostics(expr);\n\n            if (guard.type === 'binding') {\n              // Use the binding expression itself as guard.\n              directiveGuards.push(expr);\n            } else {\n              // Call the guard function on the directive with the directive instance and that\n              // expression.\n              const guardInvoke = tsCallMethod(dirId, `ngTemplateGuard_${guard.inputName}`, [\n                dirInstId,\n                expr,\n              ]);\n              addParseSpanInfo(guardInvoke, boundInput.value.sourceSpan);\n              directiveGuards.push(guardInvoke);\n            }\n          }\n        });\n\n        // The second kind of guard is a template context guard. This guard narrows the template\n        // rendering context variable `ctx`.\n        if (dir.hasNgTemplateContextGuard) {\n          if (this.tcb.env.config.applyTemplateContextGuards) {\n            const ctx = this.scope.resolve(this.template);\n            const guardInvoke = tsCallMethod(dirId, 'ngTemplateContextGuard', [dirInstId, ctx]);\n            addParseSpanInfo(guardInvoke, this.template.sourceSpan);\n            directiveGuards.push(guardInvoke);\n          } else if (\n              this.template.variables.length > 0 &&\n              this.tcb.env.config.suggestionsForSuboptimalTypeInference) {\n            // The compiler could have inferred a better type for the variables in this template,\n            // but was prevented from doing so by the type-checking configuration. Issue a warning\n            // diagnostic.\n            this.tcb.oobRecorder.suboptimalTypeInference(this.tcb.id, this.template.variables);\n          }\n        }\n      }\n    }\n\n    // By default the guard is simply `true`.\n    let guard: ts.Expression|null = null;\n\n    // If there are any guards from directives, use them instead.\n    if (directiveGuards.length > 0) {\n      // Pop the first value and use it as the initializer to reduce(). This way, a single guard\n      // will be used on its own, but two or more will be combined into binary AND expressions.\n      guard = directiveGuards.reduce(\n          (expr, dirGuard) =>\n              ts.createBinary(expr, ts.SyntaxKind.AmpersandAmpersandToken, dirGuard),\n          directiveGuards.pop()!);\n    }\n\n    // Create a new Scope for the template. This constructs the list of operations for the template\n    // children, as well as tracks bindings within the template.\n    const tmplScope = Scope.forNodes(this.tcb, this.scope, this.template, guard);\n\n    // Render the template's `Scope` into its statements.\n    const statements = tmplScope.render();\n    if (statements.length === 0) {\n      // As an optimization, don't generate the scope's block if it has no statements. This is\n      // beneficial for templates that contain for example `<span *ngIf=\"first\"></span>`, in which\n      // case there's no need to render the `NgIf` guard expression. This seems like a minor\n      // improvement, however it reduces the number of flow-node antecedents that TypeScript needs\n      // to keep into account for such cases, resulting in an overall reduction of\n      // type-checking time.\n      return null;\n    }\n\n    let tmplBlock: ts.Statement = ts.createBlock(statements);\n    if (guard !== null) {\n      // The scope has a guard that needs to be applied, so wrap the template block into an `if`\n      // statement containing the guard expression.\n      tmplBlock = ts.createIf(/* expression */ guard, /* thenStatement */ tmplBlock);\n    }\n    this.scope.addStatement(tmplBlock);\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which renders a text binding (interpolation) into the TCB.\n *\n * Executing this operation returns nothing.\n */\nclass TcbTextInterpolationOp extends TcbOp {\n  constructor(private tcb: Context, private scope: Scope, private binding: TmplAstBoundText) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): null {\n    const expr = tcbExpression(this.binding.value, this.tcb, this.scope);\n    this.scope.addStatement(ts.createExpressionStatement(expr));\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which constructs an instance of a directive. For generic directives, generic\n * parameters are set to `any` type.\n */\nabstract class TcbDirectiveTypeOpBase extends TcbOp {\n  constructor(\n      protected tcb: Context, protected scope: Scope,\n      protected node: TmplAstTemplate|TmplAstElement, protected dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  get optional() {\n    // The statement generated by this operation is only used to declare the directive's type and\n    // won't report diagnostics by itself, so the operation is marked as optional to avoid\n    // generating declarations for directives that don't have any inputs/outputs.\n    return true;\n  }\n\n  execute(): ts.Identifier {\n    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n\n    const rawType = this.tcb.env.referenceType(this.dir.ref);\n\n    let type: ts.TypeNode;\n    if (this.dir.isGeneric === false || dirRef.node.typeParameters === undefined) {\n      type = rawType;\n    } else {\n      if (!ts.isTypeReferenceNode(rawType)) {\n        throw new Error(\n            `Expected TypeReferenceNode when referencing the type for ${this.dir.ref.debugName}`);\n      }\n      const typeArguments = dirRef.node.typeParameters.map(\n          () => ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n      type = ts.factory.createTypeReferenceNode(rawType.typeName, typeArguments);\n    }\n\n    const id = this.tcb.allocateId();\n    addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);\n    addParseSpanInfo(type, this.node.startSourceSpan || this.node.sourceSpan);\n    this.scope.addStatement(tsDeclareVariable(id, type));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which constructs an instance of a non-generic directive _without_ setting any of its\n * inputs. Inputs  are later set in the `TcbDirectiveInputsOp`. Type checking was found to be\n * faster when done in this way as opposed to `TcbDirectiveCtorOp` which is only necessary when the\n * directive is generic.\n *\n * Executing this operation returns a reference to the directive instance variable with its inferred\n * type.\n */\nclass TcbNonGenericDirectiveTypeOp extends TcbDirectiveTypeOpBase {\n  /**\n   * Creates a variable declaration for this op's directive of the argument type. Returns the id of\n   * the newly created variable.\n   */\n  execute(): ts.Identifier {\n    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n    if (this.dir.isGeneric) {\n      throw new Error(`Assertion Error: expected ${dirRef.debugName} not to be generic.`);\n    }\n    return super.execute();\n  }\n}\n\n/**\n * A `TcbOp` which constructs an instance of a generic directive with its generic parameters set\n * to `any` type. This op is like `TcbDirectiveTypeOp`, except that generic parameters are set to\n * `any` type. This is used for situations where we want to avoid inlining.\n *\n * Executing this operation returns a reference to the directive instance variable with its generic\n * type parameters set to `any`.\n */\nclass TcbGenericDirectiveTypeWithAnyParamsOp extends TcbDirectiveTypeOpBase {\n  execute(): ts.Identifier {\n    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n    if (dirRef.node.typeParameters === undefined) {\n      throw new Error(`Assertion Error: expected typeParameters when creating a declaration for ${\n          dirRef.debugName}`);\n    }\n\n    return super.execute();\n  }\n}\n\n/**\n * A `TcbOp` which creates a variable for a local ref in a template.\n * The initializer for the variable is the variable expression for the directive, template, or\n * element the ref refers to. When the reference is used in the template, those TCB statements will\n * access this variable as well. For example:\n * ```\n * var _t1 = document.createElement('div');\n * var _t2 = _t1;\n * _t2.value\n * ```\n * This operation supports more fluent lookups for the `TemplateTypeChecker` when getting a symbol\n * for a reference. In most cases, this isn't essential; that is, the information for the symbol\n * could be gathered without this operation using the `BoundTarget`. However, for the case of\n * ng-template references, we will need this reference variable to not only provide a location in\n * the shim file, but also to narrow the variable to the correct `TemplateRef<T>` type rather than\n * `TemplateRef<any>` (this work is still TODO).\n *\n * Executing this operation returns a reference to the directive instance variable with its inferred\n * type.\n */\nclass TcbReferenceOp extends TcbOp {\n  constructor(\n      private readonly tcb: Context, private readonly scope: Scope,\n      private readonly node: TmplAstReference,\n      private readonly host: TmplAstElement|TmplAstTemplate,\n      private readonly target: TypeCheckableDirectiveMeta|TmplAstTemplate|TmplAstElement) {\n    super();\n  }\n\n  // The statement generated by this operation is only used to for the Type Checker\n  // so it can map a reference variable in the template directly to a node in the TCB.\n  readonly optional = true;\n\n  execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    let initializer =\n        this.target instanceof TmplAstTemplate || this.target instanceof TmplAstElement ?\n        this.scope.resolve(this.target) :\n        this.scope.resolve(this.host, this.target);\n\n    // The reference is either to an element, an <ng-template> node, or to a directive on an\n    // element or template.\n    if ((this.target instanceof TmplAstElement && !this.tcb.env.config.checkTypeOfDomReferences) ||\n        !this.tcb.env.config.checkTypeOfNonDomReferences) {\n      // References to DOM nodes are pinned to 'any' when `checkTypeOfDomReferences` is `false`.\n      // References to `TemplateRef`s and directives are pinned to 'any' when\n      // `checkTypeOfNonDomReferences` is `false`.\n      initializer =\n          ts.createAsExpression(initializer, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n    } else if (this.target instanceof TmplAstTemplate) {\n      // Direct references to an <ng-template> node simply require a value of type\n      // `TemplateRef<any>`. To get this, an expression of the form\n      // `(_t1 as any as TemplateRef<any>)` is constructed.\n      initializer =\n          ts.createAsExpression(initializer, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n      initializer = ts.createAsExpression(\n          initializer,\n          this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [DYNAMIC_TYPE]));\n      initializer = ts.createParen(initializer);\n    }\n    addParseSpanInfo(initializer, this.node.sourceSpan);\n    addParseSpanInfo(id, this.node.keySpan);\n\n    this.scope.addStatement(tsCreateVariable(id, initializer));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which is used when the target of a reference is missing. This operation generates a\n * variable of type any for usages of the invalid reference to resolve to. The invalid reference\n * itself is recorded out-of-band.\n */\nclass TcbInvalidReferenceOp extends TcbOp {\n  constructor(private readonly tcb: Context, private readonly scope: Scope) {\n    super();\n  }\n\n  // The declaration of a missing reference is only needed when the reference is resolved.\n  readonly optional = true;\n\n  execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    this.scope.addStatement(tsCreateVariable(id, NULL_AS_ANY));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs. The\n * inputs themselves are not checked here; checking of inputs is achieved in `TcbDirectiveInputsOp`.\n * Any errors reported in this statement are ignored, as the type constructor call is only present\n * for type-inference.\n *\n * When a Directive is generic, it is required that the TCB generates the instance using this method\n * in order to infer the type information correctly.\n *\n * Executing this operation returns a reference to the directive instance variable with its inferred\n * type.\n */\nclass TcbDirectiveCtorOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n      private dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  get optional() {\n    // The statement generated by this operation is only used to infer the directive's type and\n    // won't report diagnostics by itself, so the operation is marked as optional.\n    return true;\n  }\n\n  execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);\n    addParseSpanInfo(id, this.node.startSourceSpan || this.node.sourceSpan);\n\n    const genericInputs = new Map<string, TcbDirectiveInput>();\n\n    const inputs = getBoundInputs(this.dir, this.node, this.tcb);\n    for (const input of inputs) {\n      // Skip text attributes if configured to do so.\n      if (!this.tcb.env.config.checkTypeOfAttributes &&\n          input.attribute instanceof TmplAstTextAttribute) {\n        continue;\n      }\n      for (const fieldName of input.fieldNames) {\n        // Skip the field if an attribute has already been bound to it; we can't have a duplicate\n        // key in the type constructor call.\n        if (genericInputs.has(fieldName)) {\n          continue;\n        }\n\n        const expression = translateInput(input.attribute, this.tcb, this.scope);\n        genericInputs.set(fieldName, {\n          type: 'binding',\n          field: fieldName,\n          expression,\n          sourceSpan: input.attribute.sourceSpan\n        });\n      }\n    }\n\n    // Add unset directive inputs for each of the remaining unset fields.\n    for (const [fieldName] of this.dir.inputs) {\n      if (!genericInputs.has(fieldName)) {\n        genericInputs.set(fieldName, {type: 'unset', field: fieldName});\n      }\n    }\n\n    // Call the type constructor of the directive to infer a type, and assign the directive\n    // instance.\n    const typeCtor = tcbCallTypeCtor(this.dir, this.tcb, Array.from(genericInputs.values()));\n    markIgnoreDiagnostics(typeCtor);\n    this.scope.addStatement(tsCreateVariable(id, typeCtor));\n    return id;\n  }\n\n  circularFallback(): TcbOp {\n    return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);\n  }\n}\n\n/**\n * A `TcbOp` which generates code to check input bindings on an element that correspond with the\n * members of a directive.\n *\n * Executing this operation returns nothing.\n */\nclass TcbDirectiveInputsOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n      private dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): null {\n    let dirId: ts.Expression|null = null;\n\n    // TODO(joost): report duplicate properties\n\n    const inputs = getBoundInputs(this.dir, this.node, this.tcb);\n    for (const input of inputs) {\n      // For bound inputs, the property is assigned the binding expression.\n      let expr = translateInput(input.attribute, this.tcb, this.scope);\n      if (!this.tcb.env.config.checkTypeOfInputBindings) {\n        // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n        // before the assignment.\n        expr = tsCastToAny(expr);\n      } else if (!this.tcb.env.config.strictNullInputBindings) {\n        // If strict null checks are disabled, erase `null` and `undefined` from the type by\n        // wrapping the expression in a non-null assertion.\n        expr = ts.createNonNullExpression(expr);\n      }\n\n      let assignment: ts.Expression = wrapForDiagnostics(expr);\n\n      for (const fieldName of input.fieldNames) {\n        let target: ts.LeftHandSideExpression;\n        if (this.dir.coercedInputFields.has(fieldName)) {\n          // The input has a coercion declaration which should be used instead of assigning the\n          // expression into the input field directly. To achieve this, a variable is declared\n          // with a type of `typeof Directive.ngAcceptInputType_fieldName` which is then used as\n          // target of the assignment.\n          const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n          if (!ts.isTypeReferenceNode(dirTypeRef)) {\n            throw new Error(\n                `Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n          }\n\n          const id = this.tcb.allocateId();\n          const type = tsCreateTypeQueryForCoercedInput(dirTypeRef.typeName, fieldName);\n          this.scope.addStatement(tsDeclareVariable(id, type));\n\n          target = id;\n        } else if (this.dir.undeclaredInputFields.has(fieldName)) {\n          // If no coercion declaration is present nor is the field declared (i.e. the input is\n          // declared in a `@Directive` or `@Component` decorator's `inputs` property) there is no\n          // assignment target available, so this field is skipped.\n          continue;\n        } else if (\n            !this.tcb.env.config.honorAccessModifiersForInputBindings &&\n            this.dir.restrictedInputFields.has(fieldName)) {\n          // If strict checking of access modifiers is disabled and the field is restricted\n          // (i.e. private/protected/readonly), generate an assignment into a temporary variable\n          // that has the type of the field. This achieves type-checking but circumvents the access\n          // modifiers.\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n\n          const id = this.tcb.allocateId();\n          const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);\n          if (!ts.isTypeReferenceNode(dirTypeRef)) {\n            throw new Error(\n                `Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);\n          }\n          const type = ts.createIndexedAccessTypeNode(\n              ts.createTypeQueryNode(dirId as ts.Identifier),\n              ts.createLiteralTypeNode(ts.createStringLiteral(fieldName)));\n          const temp = tsDeclareVariable(id, type);\n          this.scope.addStatement(temp);\n          target = id;\n        } else {\n          if (dirId === null) {\n            dirId = this.scope.resolve(this.node, this.dir);\n          }\n\n          // To get errors assign directly to the fields on the instance, using property access\n          // when possible. String literal fields may not be valid JS identifiers so we use\n          // literal element access instead for those cases.\n          target = this.dir.stringLiteralInputFields.has(fieldName) ?\n              ts.createElementAccess(dirId, ts.createStringLiteral(fieldName)) :\n              ts.createPropertyAccess(dirId, ts.createIdentifier(fieldName));\n        }\n\n        if (input.attribute.keySpan !== undefined) {\n          addParseSpanInfo(target, input.attribute.keySpan);\n        }\n        // Finally the assignment is extended by assigning it into the target expression.\n        assignment = ts.createBinary(target, ts.SyntaxKind.EqualsToken, assignment);\n      }\n\n      addParseSpanInfo(assignment, input.attribute.sourceSpan);\n      // Ignore diagnostics for text attributes if configured to do so.\n      if (!this.tcb.env.config.checkTypeOfAttributes &&\n          input.attribute instanceof TmplAstTextAttribute) {\n        markIgnoreDiagnostics(assignment);\n      }\n\n      this.scope.addStatement(ts.createExpressionStatement(assignment));\n    }\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which is used to generate a fallback expression if the inference of a directive type\n * via `TcbDirectiveCtorOp` requires a reference to its own type. This can happen using a template\n * reference:\n *\n * ```html\n * <some-cmp #ref [prop]=\"ref.foo\"></some-cmp>\n * ```\n *\n * In this case, `TcbDirectiveCtorCircularFallbackOp` will add a second inference of the directive\n * type to the type-check block, this time calling the directive's type constructor without any\n * input expressions. This infers the widest possible supertype for the directive, which is used to\n * resolve any recursive references required to infer the real type.\n */\nclass TcbDirectiveCtorCircularFallbackOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n      private dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): ts.Identifier {\n    const id = this.tcb.allocateId();\n    const typeCtor = this.tcb.env.typeCtorFor(this.dir);\n    const circularPlaceholder = ts.createCall(\n        typeCtor, /* typeArguments */ undefined, [ts.createNonNullExpression(ts.createNull())]);\n    this.scope.addStatement(tsCreateVariable(id, circularPlaceholder));\n    return id;\n  }\n}\n\n/**\n * A `TcbOp` which feeds elements and unclaimed properties to the `DomSchemaChecker`.\n *\n * The DOM schema is not checked via TCB code generation. Instead, the `DomSchemaChecker` ingests\n * elements and property bindings and accumulates synthetic `ts.Diagnostic`s out-of-band. These are\n * later merged with the diagnostics generated from the TCB.\n *\n * For convenience, the TCB iteration of the template is used to drive the `DomSchemaChecker` via\n * the `TcbDomSchemaCheckerOp`.\n */\nclass TcbDomSchemaCheckerOp extends TcbOp {\n  constructor(\n      private tcb: Context, private element: TmplAstElement, private checkElement: boolean,\n      private claimedInputs: Set<string>) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): ts.Expression|null {\n    if (this.checkElement) {\n      this.tcb.domSchemaChecker.checkElement(this.tcb.id, this.element, this.tcb.schemas);\n    }\n\n    // TODO(alxhub): this could be more efficient.\n    for (const binding of this.element.inputs) {\n      if (binding.type === BindingType.Property && this.claimedInputs.has(binding.name)) {\n        // Skip this binding as it was claimed by a directive.\n        continue;\n      }\n\n      if (binding.type === BindingType.Property) {\n        if (binding.name !== 'style' && binding.name !== 'class') {\n          // A direct binding to a property.\n          const propertyName = ATTR_TO_PROP[binding.name] || binding.name;\n          this.tcb.domSchemaChecker.checkProperty(\n              this.tcb.id, this.element, propertyName, binding.sourceSpan, this.tcb.schemas);\n        }\n      }\n    }\n    return null;\n  }\n}\n\n\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n * Note: this mapping has to be kept in sync with the equally named mapping in the runtime.\n */\nconst ATTR_TO_PROP: {[name: string]: string} = {\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex',\n};\n\n/**\n * A `TcbOp` which generates code to check \"unclaimed inputs\" - bindings on an element which were\n * not attributed to any directive or component, and are instead processed against the HTML element\n * itself.\n *\n * Currently, only the expressions of these bindings are checked. The targets of the bindings are\n * checked against the DOM schema via a `TcbDomSchemaCheckerOp`.\n *\n * Executing this operation returns nothing.\n */\nclass TcbUnclaimedInputsOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private element: TmplAstElement,\n      private claimedInputs: Set<string>) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): null {\n    // `this.inputs` contains only those bindings not matched by any directive. These bindings go to\n    // the element itself.\n    let elId: ts.Expression|null = null;\n\n    // TODO(alxhub): this could be more efficient.\n    for (const binding of this.element.inputs) {\n      if (binding.type === BindingType.Property && this.claimedInputs.has(binding.name)) {\n        // Skip this binding as it was claimed by a directive.\n        continue;\n      }\n\n      let expr = tcbExpression(binding.value, this.tcb, this.scope);\n      if (!this.tcb.env.config.checkTypeOfInputBindings) {\n        // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n        // before the assignment.\n        expr = tsCastToAny(expr);\n      } else if (!this.tcb.env.config.strictNullInputBindings) {\n        // If strict null checks are disabled, erase `null` and `undefined` from the type by\n        // wrapping the expression in a non-null assertion.\n        expr = ts.createNonNullExpression(expr);\n      }\n\n      if (this.tcb.env.config.checkTypeOfDomBindings && binding.type === BindingType.Property) {\n        if (binding.name !== 'style' && binding.name !== 'class') {\n          if (elId === null) {\n            elId = this.scope.resolve(this.element);\n          }\n          // A direct binding to a property.\n          const propertyName = ATTR_TO_PROP[binding.name] || binding.name;\n          const prop = ts.createElementAccess(elId, ts.createStringLiteral(propertyName));\n          const stmt = ts.createBinary(prop, ts.SyntaxKind.EqualsToken, wrapForDiagnostics(expr));\n          addParseSpanInfo(stmt, binding.sourceSpan);\n          this.scope.addStatement(ts.createExpressionStatement(stmt));\n        } else {\n          this.scope.addStatement(ts.createExpressionStatement(expr));\n        }\n      } else {\n        // A binding to an animation, attribute, class or style. For now, only validate the right-\n        // hand side of the expression.\n        // TODO: properly check class and style bindings.\n        this.scope.addStatement(ts.createExpressionStatement(expr));\n      }\n    }\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which generates code to check event bindings on an element that correspond with the\n * outputs of a directive.\n *\n * Executing this operation returns nothing.\n */\nexport class TcbDirectiveOutputsOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private node: TmplAstTemplate|TmplAstElement,\n      private dir: TypeCheckableDirectiveMeta) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): null {\n    let dirId: ts.Expression|null = null;\n    const outputs = this.dir.outputs;\n\n    for (const output of this.node.outputs) {\n      if (output.type !== ParsedEventType.Regular || !outputs.hasBindingPropertyName(output.name)) {\n        continue;\n      }\n      // TODO(alxhub): consider supporting multiple fields with the same property name for outputs.\n      const field = outputs.getByBindingPropertyName(output.name)![0].classPropertyName;\n\n      if (dirId === null) {\n        dirId = this.scope.resolve(this.node, this.dir);\n      }\n      const outputField = ts.createElementAccess(dirId, ts.createStringLiteral(field));\n      addParseSpanInfo(outputField, output.keySpan);\n      if (this.tcb.env.config.checkTypeOfOutputEvents) {\n        // For strict checking of directive events, generate a call to the `subscribe` method\n        // on the directive's output field to let type information flow into the handler function's\n        // `$event` parameter.\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Infer);\n        const subscribeFn = ts.createPropertyAccess(outputField, 'subscribe');\n        const call = ts.createCall(subscribeFn, /* typeArguments */ undefined, [handler]);\n        addParseSpanInfo(call, output.sourceSpan);\n        this.scope.addStatement(ts.createExpressionStatement(call));\n      } else {\n        // If strict checking of directive events is disabled:\n        //\n        // * We still generate the access to the output field as a statement in the TCB so consumers\n        //   of the `TemplateTypeChecker` can still find the node for the class member for the\n        //   output.\n        // * Emit a handler function where the `$event` parameter has an explicit `any` type.\n        this.scope.addStatement(ts.createExpressionStatement(outputField));\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Any);\n        this.scope.addStatement(ts.createExpressionStatement(handler));\n      }\n\n      ExpressionSemanticVisitor.visit(\n          output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which generates code to check \"unclaimed outputs\" - event bindings on an element which\n * were not attributed to any directive or component, and are instead processed against the HTML\n * element itself.\n *\n * Executing this operation returns nothing.\n */\nclass TcbUnclaimedOutputsOp extends TcbOp {\n  constructor(\n      private tcb: Context, private scope: Scope, private element: TmplAstElement,\n      private claimedOutputs: Set<string>) {\n    super();\n  }\n\n  get optional() {\n    return false;\n  }\n\n  execute(): null {\n    let elId: ts.Expression|null = null;\n\n    // TODO(alxhub): this could be more efficient.\n    for (const output of this.element.outputs) {\n      if (this.claimedOutputs.has(output.name)) {\n        // Skip this event handler as it was claimed by a directive.\n        continue;\n      }\n\n      if (output.type === ParsedEventType.Animation) {\n        // Animation output bindings always have an `$event` parameter of type `AnimationEvent`.\n        const eventType = this.tcb.env.config.checkTypeOfAnimationEvents ?\n            this.tcb.env.referenceExternalType('@angular/animations', 'AnimationEvent') :\n            EventParamType.Any;\n\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, eventType);\n        this.scope.addStatement(ts.createExpressionStatement(handler));\n      } else if (this.tcb.env.config.checkTypeOfDomEvents) {\n        // If strict checking of DOM events is enabled, generate a call to `addEventListener` on\n        // the element instance so that TypeScript's type inference for\n        // `HTMLElement.addEventListener` using `HTMLElementEventMap` to infer an accurate type for\n        // `$event` depending on the event name. For unknown event names, TypeScript resorts to the\n        // base `Event` type.\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Infer);\n\n        if (elId === null) {\n          elId = this.scope.resolve(this.element);\n        }\n        const propertyAccess = ts.createPropertyAccess(elId, 'addEventListener');\n        addParseSpanInfo(propertyAccess, output.keySpan);\n        const call = ts.createCall(\n            /* expression */ propertyAccess,\n            /* typeArguments */ undefined,\n            /* arguments */[ts.createStringLiteral(output.name), handler]);\n        addParseSpanInfo(call, output.sourceSpan);\n        this.scope.addStatement(ts.createExpressionStatement(call));\n      } else {\n        // If strict checking of DOM inputs is disabled, emit a handler function where the `$event`\n        // parameter has an explicit `any` type.\n        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Any);\n        this.scope.addStatement(ts.createExpressionStatement(handler));\n      }\n\n      ExpressionSemanticVisitor.visit(\n          output.handler, this.tcb.id, this.tcb.boundTarget, this.tcb.oobRecorder);\n    }\n\n    return null;\n  }\n}\n\n/**\n * A `TcbOp` which generates a completion point for the component context.\n *\n * This completion point looks like `ctx. ;` in the TCB output, and does not produce diagnostics.\n * TypeScript autocompletion APIs can be used at this completion point (after the '.') to produce\n * autocompletion results of properties and methods from the template's component context.\n */\nclass TcbComponentContextCompletionOp extends TcbOp {\n  constructor(private scope: Scope) {\n    super();\n  }\n\n  readonly optional = false;\n\n  execute(): null {\n    const ctx = ts.createIdentifier('ctx');\n    const ctxDot = ts.createPropertyAccess(ctx, '');\n    markIgnoreDiagnostics(ctxDot);\n    addExpressionIdentifier(ctxDot, ExpressionIdentifier.COMPONENT_COMPLETION);\n    this.scope.addStatement(ts.createExpressionStatement(ctxDot));\n    return null;\n  }\n}\n\n/**\n * Value used to break a circular reference between `TcbOp`s.\n *\n * This value is returned whenever `TcbOp`s have a circular dependency. The expression is a non-null\n * assertion of the null value (in TypeScript, the expression `null!`). This construction will infer\n * the least narrow type for whatever it's assigned to.\n */\nconst INFER_TYPE_FOR_CIRCULAR_OP_EXPR = ts.createNonNullExpression(ts.createNull());\n\n/**\n * Overall generation context for the type check block.\n *\n * `Context` handles operations during code generation which are global with respect to the whole\n * block. It's responsible for variable name allocation and management of any imports needed. It\n * also contains the template metadata itself.\n */\nexport class Context {\n  private nextId = 1;\n\n  constructor(\n      readonly env: Environment, readonly domSchemaChecker: DomSchemaChecker,\n      readonly oobRecorder: OutOfBandDiagnosticRecorder, readonly id: TemplateId,\n      readonly boundTarget: BoundTarget<TypeCheckableDirectiveMeta>,\n      private pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,\n      readonly schemas: SchemaMetadata[]) {}\n\n  /**\n   * Allocate a new variable name for use within the `Context`.\n   *\n   * Currently this uses a monotonically increasing counter, but in the future the variable name\n   * might change depending on the type of data being stored.\n   */\n  allocateId(): ts.Identifier {\n    return ts.createIdentifier(`_t${this.nextId++}`);\n  }\n\n  getPipeByName(name: string): Reference<ClassDeclaration<ts.ClassDeclaration>>|null {\n    if (!this.pipes.has(name)) {\n      return null;\n    }\n    return this.pipes.get(name)!;\n  }\n}\n\n/**\n * Local scope within the type check block for a particular template.\n *\n * The top-level template and each nested `<ng-template>` have their own `Scope`, which exist in a\n * hierarchy. The structure of this hierarchy mirrors the syntactic scopes in the generated type\n * check block, where each nested template is encased in an `if` structure.\n *\n * As a template's `TcbOp`s are executed in a given `Scope`, statements are added via\n * `addStatement()`. When this processing is complete, the `Scope` can be turned into a `ts.Block`\n * via `renderToBlock()`.\n *\n * If a `TcbOp` requires the output of another, it can call `resolve()`.\n */\nclass Scope {\n  /**\n   * A queue of operations which need to be performed to generate the TCB code for this scope.\n   *\n   * This array can contain either a `TcbOp` which has yet to be executed, or a `ts.Expression|null`\n   * representing the memoized result of executing the operation. As operations are executed, their\n   * results are written into the `opQueue`, overwriting the original operation.\n   *\n   * If an operation is in the process of being executed, it is temporarily overwritten here with\n   * `INFER_TYPE_FOR_CIRCULAR_OP_EXPR`. This way, if a cycle is encountered where an operation\n   * depends transitively on its own result, the inner operation will infer the least narrow type\n   * that fits instead. This has the same semantics as TypeScript itself when types are referenced\n   * circularly.\n   */\n  private opQueue: (TcbOp|ts.Expression|null)[] = [];\n\n  /**\n   * A map of `TmplAstElement`s to the index of their `TcbElementOp` in the `opQueue`\n   */\n  private elementOpMap = new Map<TmplAstElement, number>();\n  /**\n   * A map of maps which tracks the index of `TcbDirectiveCtorOp`s in the `opQueue` for each\n   * directive on a `TmplAstElement` or `TmplAstTemplate` node.\n   */\n  private directiveOpMap =\n      new Map<TmplAstElement|TmplAstTemplate, Map<TypeCheckableDirectiveMeta, number>>();\n\n  /**\n   * A map of `TmplAstReference`s to the index of their `TcbReferenceOp` in the `opQueue`\n   */\n  private referenceOpMap = new Map<TmplAstReference, number>();\n\n  /**\n   * Map of immediately nested <ng-template>s (within this `Scope`) represented by `TmplAstTemplate`\n   * nodes to the index of their `TcbTemplateContextOp`s in the `opQueue`.\n   */\n  private templateCtxOpMap = new Map<TmplAstTemplate, number>();\n\n  /**\n   * Map of variables declared on the template that created this `Scope` (represented by\n   * `TmplAstVariable` nodes) to the index of their `TcbVariableOp`s in the `opQueue`.\n   */\n  private varMap = new Map<TmplAstVariable, number>();\n\n  /**\n   * Statements for this template.\n   *\n   * Executing the `TcbOp`s in the `opQueue` populates this array.\n   */\n  private statements: ts.Statement[] = [];\n\n  private constructor(\n      private tcb: Context, private parent: Scope|null = null,\n      private guard: ts.Expression|null = null) {}\n\n  /**\n   * Constructs a `Scope` given either a `TmplAstTemplate` or a list of `TmplAstNode`s.\n   *\n   * @param tcb the overall context of TCB generation.\n   * @param parent the `Scope` of the parent template (if any) or `null` if this is the root\n   * `Scope`.\n   * @param templateOrNodes either a `TmplAstTemplate` representing the template for which to\n   * calculate the `Scope`, or a list of nodes if no outer template object is available.\n   * @param guard an expression that is applied to this scope for type narrowing purposes.\n   */\n  static forNodes(\n      tcb: Context, parent: Scope|null, templateOrNodes: TmplAstTemplate|(TmplAstNode[]),\n      guard: ts.Expression|null): Scope {\n    const scope = new Scope(tcb, parent, guard);\n\n    if (parent === null && tcb.env.config.enableTemplateTypeChecker) {\n      // Add an autocompletion point for the component context.\n      scope.opQueue.push(new TcbComponentContextCompletionOp(scope));\n    }\n\n    let children: TmplAstNode[];\n\n    // If given an actual `TmplAstTemplate` instance, then process any additional information it\n    // has.\n    if (templateOrNodes instanceof TmplAstTemplate) {\n      // The template's variable declarations need to be added as `TcbVariableOp`s.\n      const varMap = new Map<string, TmplAstVariable>();\n\n      for (const v of templateOrNodes.variables) {\n        // Validate that variables on the `TmplAstTemplate` are only declared once.\n        if (!varMap.has(v.name)) {\n          varMap.set(v.name, v);\n        } else {\n          const firstDecl = varMap.get(v.name)!;\n          tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);\n        }\n\n        const opIndex = scope.opQueue.push(new TcbVariableOp(tcb, scope, templateOrNodes, v)) - 1;\n        scope.varMap.set(v, opIndex);\n      }\n      children = templateOrNodes.children;\n    } else {\n      children = templateOrNodes;\n    }\n    for (const node of children) {\n      scope.appendNode(node);\n    }\n    return scope;\n  }\n\n  /**\n   * Look up a `ts.Expression` representing the value of some operation in the current `Scope`,\n   * including any parent scope(s). This method always returns a mutable clone of the\n   * `ts.Expression` with the comments cleared.\n   *\n   * @param node a `TmplAstNode` of the operation in question. The lookup performed will depend on\n   * the type of this node:\n   *\n   * Assuming `directive` is not present, then `resolve` will return:\n   *\n   * * `TmplAstElement` - retrieve the expression for the element DOM node\n   * * `TmplAstTemplate` - retrieve the template context variable\n   * * `TmplAstVariable` - retrieve a template let- variable\n   * * `TmplAstReference` - retrieve variable created for the local ref\n   *\n   * @param directive if present, a directive type on a `TmplAstElement` or `TmplAstTemplate` to\n   * look up instead of the default for an element or template node.\n   */\n  resolve(\n      node: TmplAstElement|TmplAstTemplate|TmplAstVariable|TmplAstReference,\n      directive?: TypeCheckableDirectiveMeta): ts.Expression {\n    // Attempt to resolve the operation locally.\n    const res = this.resolveLocal(node, directive);\n    if (res !== null) {\n      // We want to get a clone of the resolved expression and clear the trailing comments\n      // so they don't continue to appear in every place the expression is used.\n      // As an example, this would otherwise produce:\n      // var _t1 /**T:DIR*/ /*1,2*/ = _ctor1();\n      // _t1 /**T:DIR*/ /*1,2*/.input = 'value';\n      //\n      // In addition, returning a clone prevents the consumer of `Scope#resolve` from\n      // attaching comments at the declaration site.\n\n      const clone = ts.getMutableClone(res);\n      ts.setSyntheticTrailingComments(clone, []);\n      return clone;\n    } else if (this.parent !== null) {\n      // Check with the parent.\n      return this.parent.resolve(node, directive);\n    } else {\n      throw new Error(`Could not resolve ${node} / ${directive}`);\n    }\n  }\n\n  /**\n   * Add a statement to this scope.\n   */\n  addStatement(stmt: ts.Statement): void {\n    this.statements.push(stmt);\n  }\n\n  /**\n   * Get the statements.\n   */\n  render(): ts.Statement[] {\n    for (let i = 0; i < this.opQueue.length; i++) {\n      // Optional statements cannot be skipped when we are generating the TCB for use\n      // by the TemplateTypeChecker.\n      const skipOptional = !this.tcb.env.config.enableTemplateTypeChecker;\n      this.executeOp(i, skipOptional);\n    }\n    return this.statements;\n  }\n\n  /**\n   * Returns an expression of all template guards that apply to this scope, including those of\n   * parent scopes. If no guards have been applied, null is returned.\n   */\n  guards(): ts.Expression|null {\n    let parentGuards: ts.Expression|null = null;\n    if (this.parent !== null) {\n      // Start with the guards from the parent scope, if present.\n      parentGuards = this.parent.guards();\n    }\n\n    if (this.guard === null) {\n      // This scope does not have a guard, so return the parent's guards as is.\n      return parentGuards;\n    } else if (parentGuards === null) {\n      // There's no guards from the parent scope, so this scope's guard represents all available\n      // guards.\n      return this.guard;\n    } else {\n      // Both the parent scope and this scope provide a guard, so create a combination of the two.\n      // It is important that the parent guard is used as left operand, given that it may provide\n      // narrowing that is required for this scope's guard to be valid.\n      return ts.createBinary(parentGuards, ts.SyntaxKind.AmpersandAmpersandToken, this.guard);\n    }\n  }\n\n  private resolveLocal(\n      ref: TmplAstElement|TmplAstTemplate|TmplAstVariable|TmplAstReference,\n      directive?: TypeCheckableDirectiveMeta): ts.Expression|null {\n    if (ref instanceof TmplAstReference && this.referenceOpMap.has(ref)) {\n      return this.resolveOp(this.referenceOpMap.get(ref)!);\n    } else if (ref instanceof TmplAstVariable && this.varMap.has(ref)) {\n      // Resolving a context variable for this template.\n      // Execute the `TcbVariableOp` associated with the `TmplAstVariable`.\n      return this.resolveOp(this.varMap.get(ref)!);\n    } else if (\n        ref instanceof TmplAstTemplate && directive === undefined &&\n        this.templateCtxOpMap.has(ref)) {\n      // Resolving the context of the given sub-template.\n      // Execute the `TcbTemplateContextOp` for the template.\n      return this.resolveOp(this.templateCtxOpMap.get(ref)!);\n    } else if (\n        (ref instanceof TmplAstElement || ref instanceof TmplAstTemplate) &&\n        directive !== undefined && this.directiveOpMap.has(ref)) {\n      // Resolving a directive on an element or sub-template.\n      const dirMap = this.directiveOpMap.get(ref)!;\n      if (dirMap.has(directive)) {\n        return this.resolveOp(dirMap.get(directive)!);\n      } else {\n        return null;\n      }\n    } else if (ref instanceof TmplAstElement && this.elementOpMap.has(ref)) {\n      // Resolving the DOM node of an element in this template.\n      return this.resolveOp(this.elementOpMap.get(ref)!);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Like `executeOp`, but assert that the operation actually returned `ts.Expression`.\n   */\n  private resolveOp(opIndex: number): ts.Expression {\n    const res = this.executeOp(opIndex, /* skipOptional */ false);\n    if (res === null) {\n      throw new Error(`Error resolving operation, got null`);\n    }\n    return res;\n  }\n\n  /**\n   * Execute a particular `TcbOp` in the `opQueue`.\n   *\n   * This method replaces the operation in the `opQueue` with the result of execution (once done)\n   * and also protects against a circular dependency from the operation to itself by temporarily\n   * setting the operation's result to a special expression.\n   */\n  private executeOp(opIndex: number, skipOptional: boolean): ts.Expression|null {\n    const op = this.opQueue[opIndex];\n    if (!(op instanceof TcbOp)) {\n      return op;\n    }\n\n    if (skipOptional && op.optional) {\n      return null;\n    }\n\n    // Set the result of the operation in the queue to its circular fallback. If executing this\n    // operation results in a circular dependency, this will prevent an infinite loop and allow for\n    // the resolution of such cycles.\n    this.opQueue[opIndex] = op.circularFallback();\n    const res = op.execute();\n    // Once the operation has finished executing, it's safe to cache the real result.\n    this.opQueue[opIndex] = res;\n    return res;\n  }\n\n  private appendNode(node: TmplAstNode): void {\n    if (node instanceof TmplAstElement) {\n      const opIndex = this.opQueue.push(new TcbElementOp(this.tcb, this, node)) - 1;\n      this.elementOpMap.set(node, opIndex);\n      this.appendDirectivesAndInputsOfNode(node);\n      this.appendOutputsOfNode(node);\n      for (const child of node.children) {\n        this.appendNode(child);\n      }\n      this.checkAndAppendReferencesOfNode(node);\n    } else if (node instanceof TmplAstTemplate) {\n      // Template children are rendered in a child scope.\n      this.appendDirectivesAndInputsOfNode(node);\n      this.appendOutputsOfNode(node);\n      const ctxIndex = this.opQueue.push(new TcbTemplateContextOp(this.tcb, this)) - 1;\n      this.templateCtxOpMap.set(node, ctxIndex);\n      if (this.tcb.env.config.checkTemplateBodies) {\n        this.opQueue.push(new TcbTemplateBodyOp(this.tcb, this, node));\n      } else if (this.tcb.env.config.alwaysCheckSchemaInTemplateBodies) {\n        this.appendDeepSchemaChecks(node.children);\n      }\n      this.checkAndAppendReferencesOfNode(node);\n    } else if (node instanceof TmplAstBoundText) {\n      this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, node));\n    } else if (node instanceof TmplAstIcu) {\n      this.appendIcuExpressions(node);\n    }\n  }\n\n  private checkAndAppendReferencesOfNode(node: TmplAstElement|TmplAstTemplate): void {\n    for (const ref of node.references) {\n      const target = this.tcb.boundTarget.getReferenceTarget(ref);\n\n      let ctxIndex: number;\n      if (target === null) {\n        // The reference is invalid if it doesn't have a target, so report it as an error.\n        this.tcb.oobRecorder.missingReferenceTarget(this.tcb.id, ref);\n\n        // Any usages of the invalid reference will be resolved to a variable of type any.\n        ctxIndex = this.opQueue.push(new TcbInvalidReferenceOp(this.tcb, this)) - 1;\n      } else if (target instanceof TmplAstTemplate || target instanceof TmplAstElement) {\n        ctxIndex = this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target)) - 1;\n      } else {\n        ctxIndex =\n            this.opQueue.push(new TcbReferenceOp(this.tcb, this, ref, node, target.directive)) - 1;\n      }\n      this.referenceOpMap.set(ref, ctxIndex);\n    }\n  }\n\n  private appendDirectivesAndInputsOfNode(node: TmplAstElement|TmplAstTemplate): void {\n    // Collect all the inputs on the element.\n    const claimedInputs = new Set<string>();\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n    if (directives === null || directives.length === 0) {\n      // If there are no directives, then all inputs are unclaimed inputs, so queue an operation\n      // to add them if needed.\n      if (node instanceof TmplAstElement) {\n        this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n        this.opQueue.push(\n            new TcbDomSchemaCheckerOp(this.tcb, node, /* checkElement */ true, claimedInputs));\n      }\n      return;\n    }\n\n    const dirMap = new Map<TypeCheckableDirectiveMeta, number>();\n    for (const dir of directives) {\n      let directiveOp: TcbOp;\n      const host = this.tcb.env.reflector;\n      const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n\n      if (!dir.isGeneric) {\n        // The most common case is that when a directive is not generic, we use the normal\n        // `TcbNonDirectiveTypeOp`.\n        directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);\n      } else if (\n          !requiresInlineTypeCtor(dirRef.node, host) ||\n          this.tcb.env.config.useInlineTypeConstructors) {\n        // For generic directives, we use a type constructor to infer types. If a directive requires\n        // an inline type constructor, then inlining must be available to use the\n        // `TcbDirectiveCtorOp`. If not we, we fallback to using `any` – see below.\n        directiveOp = new TcbDirectiveCtorOp(this.tcb, this, node, dir);\n      } else {\n        // If inlining is not available, then we give up on infering the generic params, and use\n        // `any` type for the directive's generic parameters.\n        directiveOp = new TcbGenericDirectiveTypeWithAnyParamsOp(this.tcb, this, node, dir);\n      }\n\n      const dirIndex = this.opQueue.push(directiveOp) - 1;\n      dirMap.set(dir, dirIndex);\n\n      this.opQueue.push(new TcbDirectiveInputsOp(this.tcb, this, node, dir));\n    }\n    this.directiveOpMap.set(node, dirMap);\n\n    // After expanding the directives, we might need to queue an operation to check any unclaimed\n    // inputs.\n    if (node instanceof TmplAstElement) {\n      // Go through the directives and remove any inputs that it claims from `elementInputs`.\n      for (const dir of directives) {\n        for (const propertyName of dir.inputs.propertyNames) {\n          claimedInputs.add(propertyName);\n        }\n      }\n\n      this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));\n      // If there are no directives which match this element, then it's a \"plain\" DOM element (or a\n      // web component), and should be checked against the DOM schema. If any directives match,\n      // we must assume that the element could be custom (either a component, or a directive like\n      // <router-outlet>) and shouldn't validate the element name itself.\n      const checkElement = directives.length === 0;\n      this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, checkElement, claimedInputs));\n    }\n  }\n\n  private appendOutputsOfNode(node: TmplAstElement|TmplAstTemplate): void {\n    // Collect all the outputs on the element.\n    const claimedOutputs = new Set<string>();\n    const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n    if (directives === null || directives.length === 0) {\n      // If there are no directives, then all outputs are unclaimed outputs, so queue an operation\n      // to add them if needed.\n      if (node instanceof TmplAstElement) {\n        this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n      }\n      return;\n    }\n\n    // Queue operations for all directives to check the relevant outputs for a directive.\n    for (const dir of directives) {\n      this.opQueue.push(new TcbDirectiveOutputsOp(this.tcb, this, node, dir));\n    }\n\n    // After expanding the directives, we might need to queue an operation to check any unclaimed\n    // outputs.\n    if (node instanceof TmplAstElement) {\n      // Go through the directives and register any outputs that it claims in `claimedOutputs`.\n      for (const dir of directives) {\n        for (const outputProperty of dir.outputs.propertyNames) {\n          claimedOutputs.add(outputProperty);\n        }\n      }\n\n      this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));\n    }\n  }\n\n  private appendDeepSchemaChecks(nodes: TmplAstNode[]): void {\n    for (const node of nodes) {\n      if (!(node instanceof TmplAstElement || node instanceof TmplAstTemplate)) {\n        continue;\n      }\n\n      if (node instanceof TmplAstElement) {\n        const claimedInputs = new Set<string>();\n        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);\n        let hasDirectives: boolean;\n        if (directives === null || directives.length === 0) {\n          hasDirectives = false;\n        } else {\n          hasDirectives = true;\n          for (const dir of directives) {\n            for (const propertyName of dir.inputs.propertyNames) {\n              claimedInputs.add(propertyName);\n            }\n          }\n        }\n        this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, !hasDirectives, claimedInputs));\n      }\n\n      this.appendDeepSchemaChecks(node.children);\n    }\n  }\n\n  private appendIcuExpressions(node: TmplAstIcu): void {\n    for (const variable of Object.values(node.vars)) {\n      this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, variable));\n    }\n    for (const placeholder of Object.values(node.placeholders)) {\n      if (placeholder instanceof TmplAstBoundText) {\n        this.opQueue.push(new TcbTextInterpolationOp(this.tcb, this, placeholder));\n      }\n    }\n  }\n}\n\ninterface TcbBoundInput {\n  attribute: TmplAstBoundAttribute|TmplAstTextAttribute;\n  fieldNames: ClassPropertyName[];\n}\n\n/**\n * Create the `ctx` parameter to the top-level TCB function, with the given generic type arguments.\n */\nfunction tcbCtxParam(\n    node: ClassDeclaration<ts.ClassDeclaration>, name: ts.EntityName,\n    typeArguments: ts.TypeNode[]|undefined): ts.ParameterDeclaration {\n  const type = ts.factory.createTypeReferenceNode(name, typeArguments);\n  return ts.factory.createParameterDeclaration(\n      /* decorators */ undefined,\n      /* modifiers */ undefined,\n      /* dotDotDotToken */ undefined,\n      /* name */ 'ctx',\n      /* questionToken */ undefined,\n      /* type */ type,\n      /* initializer */ undefined);\n}\n\n/**\n * Process an `AST` expression and convert it into a `ts.Expression`, generating references to the\n * correct identifiers in the current scope.\n */\nfunction tcbExpression(ast: AST, tcb: Context, scope: Scope): ts.Expression {\n  const translator = new TcbExpressionTranslator(tcb, scope);\n  return translator.translate(ast);\n}\n\nclass TcbExpressionTranslator {\n  constructor(protected tcb: Context, protected scope: Scope) {}\n\n  translate(ast: AST): ts.Expression {\n    // `astToTypescript` actually does the conversion. A special resolver `tcbResolve` is passed\n    // which interprets specific expression nodes that interact with the `ImplicitReceiver`. These\n    // nodes actually refer to identifiers within the current scope.\n    return astToTypescript(ast, ast => this.resolve(ast), this.tcb.env.config);\n  }\n\n  /**\n   * Resolve an `AST` expression within the given scope.\n   *\n   * Some `AST` expressions refer to top-level concepts (references, variables, the component\n   * context). This method assists in resolving those.\n   */\n  protected resolve(ast: AST): ts.Expression|null {\n    if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver) {\n      // Try to resolve a bound target for this expression. If no such target is available, then\n      // the expression is referencing the top-level component context. In that case, `null` is\n      // returned here to let it fall through resolution so it will be caught when the\n      // `ImplicitReceiver` is resolved in the branch below.\n      return this.resolveTarget(ast);\n    } else if (ast instanceof PropertyWrite && ast.receiver instanceof ImplicitReceiver) {\n      const target = this.resolveTarget(ast);\n      if (target === null) {\n        return null;\n      }\n\n      const expr = this.translate(ast.value);\n      const result = ts.createParen(ts.createBinary(target, ts.SyntaxKind.EqualsToken, expr));\n      addParseSpanInfo(result, ast.sourceSpan);\n      return result;\n    } else if (ast instanceof ImplicitReceiver) {\n      // AST instances representing variables and references look very similar to property reads\n      // or method calls from the component context: both have the shape\n      // PropertyRead(ImplicitReceiver, 'propName') or MethodCall(ImplicitReceiver, 'methodName').\n      //\n      // `translate` will first try to `resolve` the outer PropertyRead/MethodCall. If this works,\n      // it's because the `BoundTarget` found an expression target for the whole expression, and\n      // therefore `translate` will never attempt to `resolve` the ImplicitReceiver of that\n      // PropertyRead/MethodCall.\n      //\n      // Therefore if `resolve` is called on an `ImplicitReceiver`, it's because no outer\n      // PropertyRead/MethodCall resolved to a variable or reference, and therefore this is a\n      // property read or method call on the component context itself.\n      return ts.createIdentifier('ctx');\n    } else if (ast instanceof BindingPipe) {\n      const expr = this.translate(ast.exp);\n      const pipeRef = this.tcb.getPipeByName(ast.name);\n      let pipe: ts.Expression|null;\n      if (pipeRef === null) {\n        // No pipe by that name exists in scope. Record this as an error.\n        this.tcb.oobRecorder.missingPipe(this.tcb.id, ast);\n\n        // Use an 'any' value to at least allow the rest of the expression to be checked.\n        pipe = NULL_AS_ANY;\n      } else if (this.tcb.env.config.checkTypeOfPipes) {\n        // Use a variable declared as the pipe's type.\n        pipe = this.tcb.env.pipeInst(pipeRef);\n      } else {\n        // Use an 'any' value when not checking the type of the pipe.\n        pipe = ts.createAsExpression(\n            this.tcb.env.pipeInst(pipeRef), ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n      }\n      const args = ast.args.map(arg => this.translate(arg));\n      const methodAccess = ts.createPropertyAccess(pipe, 'transform');\n      addParseSpanInfo(methodAccess, ast.nameSpan);\n      const result = ts.createCall(\n          /* expression */ methodAccess,\n          /* typeArguments */ undefined,\n          /* argumentsArray */[expr, ...args]);\n      addParseSpanInfo(result, ast.sourceSpan);\n      return result;\n    } else if (\n        ast instanceof MethodCall && ast.receiver instanceof ImplicitReceiver &&\n        !(ast.receiver instanceof ThisReceiver)) {\n      // Resolve the special `$any(expr)` syntax to insert a cast of the argument to type `any`.\n      // `$any(expr)` -> `expr as any`\n      if (ast.name === '$any' && ast.args.length === 1) {\n        const expr = this.translate(ast.args[0]);\n        const exprAsAny =\n            ts.createAsExpression(expr, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n        const result = ts.createParen(exprAsAny);\n        addParseSpanInfo(result, ast.sourceSpan);\n        return result;\n      }\n\n      // Attempt to resolve a bound target for the method, and generate the method call if a target\n      // could be resolved. If no target is available, then the method is referencing the top-level\n      // component context, in which case `null` is returned to let the `ImplicitReceiver` being\n      // resolved to the component context.\n      const receiver = this.resolveTarget(ast);\n      if (receiver === null) {\n        return null;\n      }\n\n      const method = wrapForDiagnostics(receiver);\n      addParseSpanInfo(method, ast.nameSpan);\n      const args = ast.args.map(arg => this.translate(arg));\n      const node = ts.createCall(method, undefined, args);\n      addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    } else {\n      // This AST isn't special after all.\n      return null;\n    }\n  }\n\n  /**\n   * Attempts to resolve a bound target for a given expression, and translates it into the\n   * appropriate `ts.Expression` that represents the bound target. If no target is available,\n   * `null` is returned.\n   */\n  protected resolveTarget(ast: AST): ts.Expression|null {\n    const binding = this.tcb.boundTarget.getExpressionTarget(ast);\n    if (binding === null) {\n      return null;\n    }\n\n    const expr = this.scope.resolve(binding);\n    addParseSpanInfo(expr, ast.sourceSpan);\n    return expr;\n  }\n}\n\n/**\n * Call the type constructor of a directive instance on a given template node, inferring a type for\n * the directive instance from any bound inputs.\n */\nfunction tcbCallTypeCtor(\n    dir: TypeCheckableDirectiveMeta, tcb: Context, inputs: TcbDirectiveInput[]): ts.Expression {\n  const typeCtor = tcb.env.typeCtorFor(dir);\n\n  // Construct an array of `ts.PropertyAssignment`s for each of the directive's inputs.\n  const members = inputs.map(input => {\n    const propertyName = ts.createStringLiteral(input.field);\n\n    if (input.type === 'binding') {\n      // For bound inputs, the property is assigned the binding expression.\n      let expr = input.expression;\n      if (!tcb.env.config.checkTypeOfInputBindings) {\n        // If checking the type of bindings is disabled, cast the resulting expression to 'any'\n        // before the assignment.\n        expr = tsCastToAny(expr);\n      } else if (!tcb.env.config.strictNullInputBindings) {\n        // If strict null checks are disabled, erase `null` and `undefined` from the type by\n        // wrapping the expression in a non-null assertion.\n        expr = ts.createNonNullExpression(expr);\n      }\n\n      const assignment = ts.createPropertyAssignment(propertyName, wrapForDiagnostics(expr));\n      addParseSpanInfo(assignment, input.sourceSpan);\n      return assignment;\n    } else {\n      // A type constructor is required to be called with all input properties, so any unset\n      // inputs are simply assigned a value of type `any` to ignore them.\n      return ts.createPropertyAssignment(propertyName, NULL_AS_ANY);\n    }\n  });\n\n  // Call the `ngTypeCtor` method on the directive class, with an object literal argument created\n  // from the matched inputs.\n  return ts.createCall(\n      /* expression */ typeCtor,\n      /* typeArguments */ undefined,\n      /* argumentsArray */[ts.createObjectLiteral(members)]);\n}\n\nfunction getBoundInputs(\n    directive: TypeCheckableDirectiveMeta, node: TmplAstTemplate|TmplAstElement,\n    tcb: Context): TcbBoundInput[] {\n  const boundInputs: TcbBoundInput[] = [];\n\n  const processAttribute = (attr: TmplAstBoundAttribute|TmplAstTextAttribute) => {\n    // Skip non-property bindings.\n    if (attr instanceof TmplAstBoundAttribute && attr.type !== BindingType.Property) {\n      return;\n    }\n\n    // Skip the attribute if the directive does not have an input for it.\n    const inputs = directive.inputs.getByBindingPropertyName(attr.name);\n    if (inputs === null) {\n      return;\n    }\n    const fieldNames = inputs.map(input => input.classPropertyName);\n    boundInputs.push({attribute: attr, fieldNames});\n  };\n\n  node.inputs.forEach(processAttribute);\n  node.attributes.forEach(processAttribute);\n  if (node instanceof TmplAstTemplate) {\n    node.templateAttrs.forEach(processAttribute);\n  }\n\n  return boundInputs;\n}\n\n/**\n * Translates the given attribute binding to a `ts.Expression`.\n */\nfunction translateInput(\n    attr: TmplAstBoundAttribute|TmplAstTextAttribute, tcb: Context, scope: Scope): ts.Expression {\n  if (attr instanceof TmplAstBoundAttribute) {\n    // Produce an expression representing the value of the binding.\n    return tcbExpression(attr.value, tcb, scope);\n  } else {\n    // For regular attributes with a static string value, use the represented string literal.\n    return ts.createStringLiteral(attr.value);\n  }\n}\n\n/**\n * An input binding that corresponds with a field of a directive.\n */\ninterface TcbDirectiveBoundInput {\n  type: 'binding';\n\n  /**\n   * The name of a field on the directive that is set.\n   */\n  field: string;\n\n  /**\n   * The `ts.Expression` corresponding with the input binding expression.\n   */\n  expression: ts.Expression;\n\n  /**\n   * The source span of the full attribute binding.\n   */\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Indicates that a certain field of a directive does not have a corresponding input binding.\n */\ninterface TcbDirectiveUnsetInput {\n  type: 'unset';\n\n  /**\n   * The name of a field on the directive for which no input binding is present.\n   */\n  field: string;\n}\n\ntype TcbDirectiveInput = TcbDirectiveBoundInput|TcbDirectiveUnsetInput;\n\nconst EVENT_PARAMETER = '$event';\n\nconst enum EventParamType {\n  /* Generates code to infer the type of `$event` based on how the listener is registered. */\n  Infer,\n\n  /* Declares the type of the `$event` parameter as `any`. */\n  Any,\n}\n\n/**\n * Creates an arrow function to be used as handler function for event bindings. The handler\n * function has a single parameter `$event` and the bound event's handler `AST` represented as a\n * TypeScript expression as its body.\n *\n * When `eventType` is set to `Infer`, the `$event` parameter will not have an explicit type. This\n * allows for the created handler function to have its `$event` parameter's type inferred based on\n * how it's used, to enable strict type checking of event bindings. When set to `Any`, the `$event`\n * parameter will have an explicit `any` type, effectively disabling strict type checking of event\n * bindings. Alternatively, an explicit type can be passed for the `$event` parameter.\n */\nfunction tcbCreateEventHandler(\n    event: TmplAstBoundEvent, tcb: Context, scope: Scope,\n    eventType: EventParamType|ts.TypeNode): ts.Expression {\n  const handler = tcbEventHandlerExpression(event.handler, tcb, scope);\n\n  let eventParamType: ts.TypeNode|undefined;\n  if (eventType === EventParamType.Infer) {\n    eventParamType = undefined;\n  } else if (eventType === EventParamType.Any) {\n    eventParamType = ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n  } else {\n    eventParamType = eventType;\n  }\n\n  // Obtain all guards that have been applied to the scope and its parents, as they have to be\n  // repeated within the handler function for their narrowing to be in effect within the handler.\n  const guards = scope.guards();\n\n  let body: ts.Statement = ts.createExpressionStatement(handler);\n  if (guards !== null) {\n    // Wrap the body in an `if` statement containing all guards that have to be applied.\n    body = ts.createIf(guards, body);\n  }\n\n  const eventParam = ts.createParameter(\n      /* decorators */ undefined,\n      /* modifiers */ undefined,\n      /* dotDotDotToken */ undefined,\n      /* name */ EVENT_PARAMETER,\n      /* questionToken */ undefined,\n      /* type */ eventParamType);\n  addExpressionIdentifier(eventParam, ExpressionIdentifier.EVENT_PARAMETER);\n\n  return ts.createFunctionExpression(\n      /* modifier */ undefined,\n      /* asteriskToken */ undefined,\n      /* name */ undefined,\n      /* typeParameters */ undefined,\n      /* parameters */[eventParam],\n      /* type */ ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword),\n      /* body */ ts.createBlock([body]));\n}\n\n/**\n * Similar to `tcbExpression`, this function converts the provided `AST` expression into a\n * `ts.Expression`, with special handling of the `$event` variable that can be used within event\n * bindings.\n */\nfunction tcbEventHandlerExpression(ast: AST, tcb: Context, scope: Scope): ts.Expression {\n  const translator = new TcbEventHandlerTranslator(tcb, scope);\n  return translator.translate(ast);\n}\n\nclass TcbEventHandlerTranslator extends TcbExpressionTranslator {\n  protected resolve(ast: AST): ts.Expression|null {\n    // Recognize a property read on the implicit receiver corresponding with the event parameter\n    // that is available in event bindings. Since this variable is a parameter of the handler\n    // function that the converted expression becomes a child of, just create a reference to the\n    // parameter by its name.\n    if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver &&\n        !(ast.receiver instanceof ThisReceiver) && ast.name === EVENT_PARAMETER) {\n      const event = ts.createIdentifier(EVENT_PARAMETER);\n      addParseSpanInfo(event, ast.nameSpan);\n      return event;\n    }\n\n    return super.resolve(ast);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}