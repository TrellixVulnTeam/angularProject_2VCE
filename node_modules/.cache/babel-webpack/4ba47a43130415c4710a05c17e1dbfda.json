{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/imports/src/find_export\", [\"require\", \"exports\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.findExportedNameOfNode = void 0;\n\n  var ts = require(\"typescript\");\n  /**\n   * Find the name, if any, by which a node is exported from a given file.\n   */\n\n\n  function findExportedNameOfNode(target, file, reflector) {\n    var exports = reflector.getExportsOfModule(file);\n\n    if (exports === null) {\n      return null;\n    } // Look for the export which declares the node.\n\n\n    var keys = Array.from(exports.keys());\n    var name = keys.find(function (key) {\n      var decl = exports.get(key);\n      return decl !== undefined && decl.node === target;\n    });\n\n    if (name === undefined) {\n      throw new Error(\"Failed to find exported name of node (\" + target.getText() + \") in '\" + file.fileName + \"'.\");\n    }\n\n    return name;\n  }\n\n  exports.findExportedNameOfNode = findExportedNameOfNode;\n  /**\n   * Check whether a given `ts.Symbol` represents a declaration of a given node.\n   *\n   * This is not quite as trivial as just checking the declarations, as some nodes are\n   * `ts.ExportSpecifier`s and need to be unwrapped.\n   */\n\n  function symbolDeclaresNode(sym, node, checker) {\n    return sym.declarations.some(function (decl) {\n      if (ts.isExportSpecifier(decl)) {\n        var exportedSymbol = checker.getExportSpecifierLocalTargetSymbol(decl);\n\n        if (exportedSymbol !== undefined) {\n          return symbolDeclaresNode(exportedSymbol, node, checker);\n        }\n      }\n\n      return decl === node;\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/find_export.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAGA;;AAEG;;;AACH,WAAgB,sBAAhB,CACI,MADJ,EACqB,IADrB,EAC0C,SAD1C,EACmE;AACjE,QAAM,OAAO,GAAG,SAAS,CAAC,kBAAV,CAA6B,IAA7B,CAAhB;;AACA,QAAI,OAAO,KAAK,IAAhB,EAAsB;AACpB,aAAO,IAAP;AACD,KAJgE,CAKjE;;;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,IAAR,EAAX,CAAb;AACA,QAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,UAAA,GAAA,EAAG;AACxB,UAAM,IAAI,GAAG,OAAO,CAAC,GAAR,CAAY,GAAZ,CAAb;AACA,aAAO,IAAI,KAAK,SAAT,IAAsB,IAAI,CAAC,IAAL,KAAc,MAA3C;AACD,KAHY,CAAb;;AAKA,QAAI,IAAI,KAAK,SAAb,EAAwB;AACtB,YAAM,IAAI,KAAJ,CACF,2CAAyC,MAAM,CAAC,OAAP,EAAzC,GAAyD,QAAzD,GAAkE,IAAI,CAAC,QAAvE,GAA+E,IAD7E,CAAN;AAED;;AACD,WAAO,IAAP;AACD;;AAlBD,EAAA,OAAA,CAAA,sBAAA,GAAA,sBAAA;AAoBA;;;;;AAKG;;AACH,WAAS,kBAAT,CAA4B,GAA5B,EAA4C,IAA5C,EAA2D,OAA3D,EAAkF;AAChF,WAAO,GAAG,CAAC,YAAJ,CAAiB,IAAjB,CAAsB,UAAA,IAAA,EAAI;AAC/B,UAAI,EAAE,CAAC,iBAAH,CAAqB,IAArB,CAAJ,EAAgC;AAC9B,YAAM,cAAc,GAAG,OAAO,CAAC,mCAAR,CAA4C,IAA5C,CAAvB;;AACA,YAAI,cAAc,KAAK,SAAvB,EAAkC;AAChC,iBAAO,kBAAkB,CAAC,cAAD,EAAiB,IAAjB,EAAuB,OAAvB,CAAzB;AACD;AACF;;AACD,aAAO,IAAI,KAAK,IAAhB;AACD,KARM,CAAP;AASD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\nimport {ReflectionHost} from '../../reflection';\n\n/**\n * Find the name, if any, by which a node is exported from a given file.\n */\nexport function findExportedNameOfNode(\n    target: ts.Node, file: ts.SourceFile, reflector: ReflectionHost): string|null {\n  const exports = reflector.getExportsOfModule(file);\n  if (exports === null) {\n    return null;\n  }\n  // Look for the export which declares the node.\n  const keys = Array.from(exports.keys());\n  const name = keys.find(key => {\n    const decl = exports.get(key);\n    return decl !== undefined && decl.node === target;\n  });\n\n  if (name === undefined) {\n    throw new Error(\n        `Failed to find exported name of node (${target.getText()}) in '${file.fileName}'.`);\n  }\n  return name;\n}\n\n/**\n * Check whether a given `ts.Symbol` represents a declaration of a given node.\n *\n * This is not quite as trivial as just checking the declarations, as some nodes are\n * `ts.ExportSpecifier`s and need to be unwrapped.\n */\nfunction symbolDeclaresNode(sym: ts.Symbol, node: ts.Node, checker: ts.TypeChecker): boolean {\n  return sym.declarations.some(decl => {\n    if (ts.isExportSpecifier(decl)) {\n      const exportedSymbol = checker.getExportSpecifierLocalTargetSymbol(decl);\n      if (exportedSymbol !== undefined) {\n        return symbolDeclaresNode(exportedSymbol, node, checker);\n      }\n    }\n    return decl === node;\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}