{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar BrowserResult = require('./browser_result');\n\nvar helper = require('./helper');\n\nvar logger = require('./logger');\n\nvar CONNECTED = 'CONNECTED'; // The browser is connected but not yet been commanded to execute tests.\n\nvar CONFIGURING = 'CONFIGURING'; // The browser has been told to execute tests; it is configuring before tests execution.\n\nvar EXECUTING = 'EXECUTING'; // The browser is executing the tests.\n\nvar EXECUTING_DISCONNECTED = 'EXECUTING_DISCONNECTED'; // The browser is executing the tests, but temporarily disconnect (waiting for socket reconnecting).\n\nvar DISCONNECTED = 'DISCONNECTED'; // The browser got completely disconnected (e.g. browser crash) and can be only restored with a restart of execution.\n\nvar Browser = /*#__PURE__*/function () {\n  function Browser(id, fullName, collection, emitter, socket, timer, disconnectDelay, noActivityTimeout) {\n    _classCallCheck(this, Browser);\n\n    this.id = id;\n    this.fullName = fullName;\n    this.name = helper.browserFullNameToShort(fullName);\n    this.lastResult = new BrowserResult();\n    this.disconnectsCount = 0;\n    this.activeSockets = [socket];\n    this.noActivityTimeout = noActivityTimeout;\n    this.collection = collection;\n    this.emitter = emitter;\n    this.socket = socket;\n    this.timer = timer;\n    this.disconnectDelay = disconnectDelay;\n    this.log = logger.create(this.name);\n    this.noActivityTimeoutId = null;\n    this.pendingDisconnect = null;\n    this.setState(CONNECTED);\n  }\n\n  _createClass(Browser, [{\n    key: \"init\",\n    value: function init() {\n      this.log.info(\"Connected on socket \".concat(this.socket.id, \" with id \").concat(this.id));\n      this.bindSocketEvents(this.socket);\n      this.collection.add(this);\n      this.emitter.emit('browser_register', this);\n    }\n  }, {\n    key: \"setState\",\n    value: function setState(toState) {\n      this.log.debug(\"\".concat(this.state, \" -> \").concat(toState));\n      this.state = toState;\n    }\n  }, {\n    key: \"onKarmaError\",\n    value: function onKarmaError(error) {\n      if (this.isNotConnected()) {\n        this.lastResult.error = true;\n      }\n\n      this.emitter.emit('browser_error', this, error);\n      this.refreshNoActivityTimeout();\n    }\n  }, {\n    key: \"onInfo\",\n    value: function onInfo(info) {\n      if (helper.isDefined(info.dump)) {\n        this.emitter.emit('browser_log', this, info.dump, 'dump');\n      }\n\n      if (helper.isDefined(info.log)) {\n        this.emitter.emit('browser_log', this, info.log, info.type);\n      } else if (helper.isDefined(info.total)) {\n        if (this.state === EXECUTING) {\n          this.lastResult.total = info.total;\n        }\n      } else if (!helper.isDefined(info.dump)) {\n        this.emitter.emit('browser_info', this, info);\n      }\n\n      this.refreshNoActivityTimeout();\n    }\n  }, {\n    key: \"onStart\",\n    value: function onStart(info) {\n      if (info.total === null) {\n        this.log.warn('Adapter did not report total number of specs.');\n      }\n\n      this.lastResult = new BrowserResult(info.total);\n      this.setState(EXECUTING);\n      this.emitter.emit('browser_start', this, info);\n      this.refreshNoActivityTimeout();\n    }\n  }, {\n    key: \"onComplete\",\n    value: function onComplete(result) {\n      if (this.isNotConnected()) {\n        this.setState(CONNECTED);\n        this.lastResult.totalTimeEnd();\n        this.emitter.emit('browsers_change', this.collection);\n        this.emitter.emit('browser_complete', this, result);\n        this.clearNoActivityTimeout();\n      }\n    }\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(reason, disconnectedSocket) {\n      var _this = this;\n\n      helper.arrayRemove(this.activeSockets, disconnectedSocket);\n\n      if (this.activeSockets.length) {\n        this.log.debug(\"Disconnected \".concat(disconnectedSocket.id, \", still have \").concat(this.getActiveSocketsIds()));\n        return;\n      }\n\n      if (this.isConnected()) {\n        this.disconnect(\"Client disconnected from CONNECTED state (\".concat(reason, \")\"));\n      } else if ([CONFIGURING, EXECUTING].includes(this.state)) {\n        this.log.debug(\"Disconnected during run, waiting \".concat(this.disconnectDelay, \"ms for reconnecting.\"));\n        this.setState(EXECUTING_DISCONNECTED);\n        this.pendingDisconnect = this.timer.setTimeout(function () {\n          _this.lastResult.totalTimeEnd();\n\n          _this.lastResult.disconnected = true;\n\n          _this.disconnect(\"reconnect failed before timeout of \".concat(_this.disconnectDelay, \"ms (\").concat(reason, \")\"));\n\n          _this.emitter.emit('browser_complete', _this);\n        }, this.disconnectDelay);\n        this.clearNoActivityTimeout();\n      }\n    }\n  }, {\n    key: \"reconnect\",\n    value: function reconnect(newSocket) {\n      if (this.state === EXECUTING_DISCONNECTED) {\n        this.log.debug('Lost socket connection, but browser continued to execute. Reconnected ' + \"on socket \".concat(newSocket.id, \".\"));\n        this.setState(EXECUTING);\n      } else if ([CONNECTED, CONFIGURING, EXECUTING].includes(this.state)) {\n        this.log.debug(\"Rebinding to new socket \".concat(newSocket.id, \" (already have \") + \"\".concat(this.getActiveSocketsIds(), \")\"));\n      } else if (this.state === DISCONNECTED) {\n        this.log.info(\"Disconnected browser returned on socket \".concat(newSocket.id, \" with id \").concat(this.id, \".\"));\n        this.setState(CONNECTED); // Since the disconnected browser is already part of the collection and we want to\n        // make sure that the server can properly handle the browser like it's the first time\n        // connecting this browser (as we want a complete new execution), we need to emit the\n        // following events:\n\n        this.emitter.emit('browsers_change', this.collection);\n        this.emitter.emit('browser_register', this);\n      }\n\n      if (!this.activeSockets.some(function (s) {\n        return s.id === newSocket.id;\n      })) {\n        this.activeSockets.push(newSocket);\n        this.bindSocketEvents(newSocket);\n      }\n\n      if (this.pendingDisconnect) {\n        this.timer.clearTimeout(this.pendingDisconnect);\n      }\n\n      this.refreshNoActivityTimeout();\n    }\n  }, {\n    key: \"onResult\",\n    value: function onResult(result) {\n      if (Array.isArray(result)) {\n        result.forEach(this.onResult, this);\n      } else if (this.isNotConnected()) {\n        this.lastResult.add(result);\n        this.emitter.emit('spec_complete', this, result);\n      }\n\n      this.refreshNoActivityTimeout();\n    }\n  }, {\n    key: \"execute\",\n    value: function execute(config) {\n      this.activeSockets.forEach(function (socket) {\n        return socket.emit('execute', config);\n      });\n      this.setState(CONFIGURING);\n      this.refreshNoActivityTimeout();\n    }\n  }, {\n    key: \"getActiveSocketsIds\",\n    value: function getActiveSocketsIds() {\n      return this.activeSockets.map(function (s) {\n        return s.id;\n      }).join(', ');\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(reason) {\n      this.log.warn(\"Disconnected (\".concat(this.disconnectsCount, \" times)\").concat(reason || ''));\n      this.setState(DISCONNECTED);\n      this.disconnectsCount++;\n      this.emitter.emit('browser_error', this, \"Disconnected\".concat(reason || ''));\n      this.collection.remove(this);\n    }\n  }, {\n    key: \"refreshNoActivityTimeout\",\n    value: function refreshNoActivityTimeout() {\n      var _this2 = this;\n\n      if (this.noActivityTimeout) {\n        this.clearNoActivityTimeout();\n        this.noActivityTimeoutId = this.timer.setTimeout(function () {\n          _this2.lastResult.totalTimeEnd();\n\n          _this2.lastResult.disconnected = true;\n\n          _this2.disconnect(\", because no message in \".concat(_this2.noActivityTimeout, \" ms.\"));\n\n          _this2.emitter.emit('browser_complete', _this2);\n        }, this.noActivityTimeout);\n      }\n    }\n  }, {\n    key: \"clearNoActivityTimeout\",\n    value: function clearNoActivityTimeout() {\n      if (this.noActivityTimeout && this.noActivityTimeoutId) {\n        this.timer.clearTimeout(this.noActivityTimeoutId);\n        this.noActivityTimeoutId = null;\n      }\n    }\n  }, {\n    key: \"bindSocketEvents\",\n    value: function bindSocketEvents(socket) {\n      var _this3 = this;\n\n      // TODO: check which of these events are actually emitted by socket\n      socket.on('disconnect', function (reason) {\n        return _this3.onDisconnect(reason, socket);\n      });\n      socket.on('start', function (info) {\n        return _this3.onStart(info);\n      });\n      socket.on('karma_error', function (error) {\n        return _this3.onKarmaError(error);\n      });\n      socket.on('complete', function (result) {\n        return _this3.onComplete(result);\n      });\n      socket.on('info', function (info) {\n        return _this3.onInfo(info);\n      });\n      socket.on('result', function (result) {\n        return _this3.onResult(result);\n      });\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.state === CONNECTED;\n    }\n  }, {\n    key: \"isNotConnected\",\n    value: function isNotConnected() {\n      return !this.isConnected();\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        id: this.id,\n        name: this.name,\n        isConnected: this.state === CONNECTED\n      };\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.name;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.id,\n        fullName: this.fullName,\n        name: this.name,\n        state: this.state,\n        lastResult: this.lastResult,\n        disconnectsCount: this.disconnectsCount,\n        noActivityTimeout: this.noActivityTimeout,\n        disconnectDelay: this.disconnectDelay\n      };\n    }\n  }]);\n\n  return Browser;\n}();\n\nBrowser.factory = function (id, fullName,\n/* capturedBrowsers */\ncollection, emitter, socket, timer,\n/* config.browserDisconnectTimeout */\ndisconnectDelay,\n/* config.browserNoActivityTimeout */\nnoActivityTimeout) {\n  return new Browser(id, fullName, collection, emitter, socket, timer, disconnectDelay, noActivityTimeout);\n};\n\nBrowser.STATE_CONNECTED = CONNECTED;\nBrowser.STATE_CONFIGURING = CONFIGURING;\nBrowser.STATE_EXECUTING = EXECUTING;\nBrowser.STATE_EXECUTING_DISCONNECTED = EXECUTING_DISCONNECTED;\nBrowser.STATE_DISCONNECTED = DISCONNECTED;\nmodule.exports = Browser;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/karma/lib/browser.js"],"names":["BrowserResult","require","helper","logger","CONNECTED","CONFIGURING","EXECUTING","EXECUTING_DISCONNECTED","DISCONNECTED","Browser","id","fullName","collection","emitter","socket","timer","disconnectDelay","noActivityTimeout","name","browserFullNameToShort","lastResult","disconnectsCount","activeSockets","log","create","noActivityTimeoutId","pendingDisconnect","setState","info","bindSocketEvents","add","emit","toState","debug","state","error","isNotConnected","refreshNoActivityTimeout","isDefined","dump","type","total","warn","result","totalTimeEnd","clearNoActivityTimeout","reason","disconnectedSocket","arrayRemove","length","getActiveSocketsIds","isConnected","disconnect","includes","setTimeout","disconnected","newSocket","some","s","push","clearTimeout","Array","isArray","forEach","onResult","config","map","join","remove","on","onDisconnect","onStart","onKarmaError","onComplete","onInfo","factory","STATE_CONNECTED","STATE_CONFIGURING","STATE_EXECUTING","STATE_EXECUTING_DISCONNECTED","STATE_DISCONNECTED","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst BrowserResult = require('./browser_result')\nconst helper = require('./helper')\nconst logger = require('./logger')\n\nconst CONNECTED = 'CONNECTED' // The browser is connected but not yet been commanded to execute tests.\nconst CONFIGURING = 'CONFIGURING' // The browser has been told to execute tests; it is configuring before tests execution.\nconst EXECUTING = 'EXECUTING' // The browser is executing the tests.\nconst EXECUTING_DISCONNECTED = 'EXECUTING_DISCONNECTED' // The browser is executing the tests, but temporarily disconnect (waiting for socket reconnecting).\nconst DISCONNECTED = 'DISCONNECTED' // The browser got completely disconnected (e.g. browser crash) and can be only restored with a restart of execution.\n\nclass Browser {\n  constructor (id, fullName, collection, emitter, socket, timer, disconnectDelay, noActivityTimeout) {\n    this.id = id\n    this.fullName = fullName\n    this.name = helper.browserFullNameToShort(fullName)\n    this.lastResult = new BrowserResult()\n    this.disconnectsCount = 0\n    this.activeSockets = [socket]\n    this.noActivityTimeout = noActivityTimeout\n    this.collection = collection\n    this.emitter = emitter\n    this.socket = socket\n    this.timer = timer\n    this.disconnectDelay = disconnectDelay\n\n    this.log = logger.create(this.name)\n\n    this.noActivityTimeoutId = null\n    this.pendingDisconnect = null\n    this.setState(CONNECTED)\n  }\n\n  init () {\n    this.log.info(`Connected on socket ${this.socket.id} with id ${this.id}`)\n\n    this.bindSocketEvents(this.socket)\n    this.collection.add(this)\n    this.emitter.emit('browser_register', this)\n  }\n\n  setState (toState) {\n    this.log.debug(`${this.state} -> ${toState}`)\n    this.state = toState\n  }\n\n  onKarmaError (error) {\n    if (this.isNotConnected()) {\n      this.lastResult.error = true\n    }\n    this.emitter.emit('browser_error', this, error)\n    this.refreshNoActivityTimeout()\n  }\n\n  onInfo (info) {\n    if (helper.isDefined(info.dump)) {\n      this.emitter.emit('browser_log', this, info.dump, 'dump')\n    }\n\n    if (helper.isDefined(info.log)) {\n      this.emitter.emit('browser_log', this, info.log, info.type)\n    } else if (helper.isDefined(info.total)) {\n      if (this.state === EXECUTING) {\n        this.lastResult.total = info.total\n      }\n    } else if (!helper.isDefined(info.dump)) {\n      this.emitter.emit('browser_info', this, info)\n    }\n\n    this.refreshNoActivityTimeout()\n  }\n\n  onStart (info) {\n    if (info.total === null) {\n      this.log.warn('Adapter did not report total number of specs.')\n    }\n\n    this.lastResult = new BrowserResult(info.total)\n    this.setState(EXECUTING)\n    this.emitter.emit('browser_start', this, info)\n    this.refreshNoActivityTimeout()\n  }\n\n  onComplete (result) {\n    if (this.isNotConnected()) {\n      this.setState(CONNECTED)\n      this.lastResult.totalTimeEnd()\n\n      this.emitter.emit('browsers_change', this.collection)\n      this.emitter.emit('browser_complete', this, result)\n\n      this.clearNoActivityTimeout()\n    }\n  }\n\n  onDisconnect (reason, disconnectedSocket) {\n    helper.arrayRemove(this.activeSockets, disconnectedSocket)\n\n    if (this.activeSockets.length) {\n      this.log.debug(`Disconnected ${disconnectedSocket.id}, still have ${this.getActiveSocketsIds()}`)\n      return\n    }\n\n    if (this.isConnected()) {\n      this.disconnect(`Client disconnected from CONNECTED state (${reason})`)\n    } else if ([CONFIGURING, EXECUTING].includes(this.state)) {\n      this.log.debug(`Disconnected during run, waiting ${this.disconnectDelay}ms for reconnecting.`)\n      this.setState(EXECUTING_DISCONNECTED)\n\n      this.pendingDisconnect = this.timer.setTimeout(() => {\n        this.lastResult.totalTimeEnd()\n        this.lastResult.disconnected = true\n        this.disconnect(`reconnect failed before timeout of ${this.disconnectDelay}ms (${reason})`)\n        this.emitter.emit('browser_complete', this)\n      }, this.disconnectDelay)\n\n      this.clearNoActivityTimeout()\n    }\n  }\n\n  reconnect (newSocket) {\n    if (this.state === EXECUTING_DISCONNECTED) {\n      this.log.debug('Lost socket connection, but browser continued to execute. Reconnected ' +\n        `on socket ${newSocket.id}.`)\n      this.setState(EXECUTING)\n    } else if ([CONNECTED, CONFIGURING, EXECUTING].includes(this.state)) {\n      this.log.debug(`Rebinding to new socket ${newSocket.id} (already have ` +\n        `${this.getActiveSocketsIds()})`)\n    } else if (this.state === DISCONNECTED) {\n      this.log.info(`Disconnected browser returned on socket ${newSocket.id} with id ${this.id}.`)\n      this.setState(CONNECTED)\n\n      // Since the disconnected browser is already part of the collection and we want to\n      // make sure that the server can properly handle the browser like it's the first time\n      // connecting this browser (as we want a complete new execution), we need to emit the\n      // following events:\n      this.emitter.emit('browsers_change', this.collection)\n      this.emitter.emit('browser_register', this)\n    }\n\n    if (!this.activeSockets.some((s) => s.id === newSocket.id)) {\n      this.activeSockets.push(newSocket)\n      this.bindSocketEvents(newSocket)\n    }\n\n    if (this.pendingDisconnect) {\n      this.timer.clearTimeout(this.pendingDisconnect)\n    }\n\n    this.refreshNoActivityTimeout()\n  }\n\n  onResult (result) {\n    if (Array.isArray(result)) {\n      result.forEach(this.onResult, this)\n    } else if (this.isNotConnected()) {\n      this.lastResult.add(result)\n      this.emitter.emit('spec_complete', this, result)\n    }\n    this.refreshNoActivityTimeout()\n  }\n\n  execute (config) {\n    this.activeSockets.forEach((socket) => socket.emit('execute', config))\n    this.setState(CONFIGURING)\n    this.refreshNoActivityTimeout()\n  }\n\n  getActiveSocketsIds () {\n    return this.activeSockets.map((s) => s.id).join(', ')\n  }\n\n  disconnect (reason) {\n    this.log.warn(`Disconnected (${this.disconnectsCount} times)${reason || ''}`)\n    this.setState(DISCONNECTED)\n    this.disconnectsCount++\n    this.emitter.emit('browser_error', this, `Disconnected${reason || ''}`)\n    this.collection.remove(this)\n  }\n\n  refreshNoActivityTimeout () {\n    if (this.noActivityTimeout) {\n      this.clearNoActivityTimeout()\n\n      this.noActivityTimeoutId = this.timer.setTimeout(() => {\n        this.lastResult.totalTimeEnd()\n        this.lastResult.disconnected = true\n        this.disconnect(`, because no message in ${this.noActivityTimeout} ms.`)\n        this.emitter.emit('browser_complete', this)\n      }, this.noActivityTimeout)\n    }\n  }\n\n  clearNoActivityTimeout () {\n    if (this.noActivityTimeout && this.noActivityTimeoutId) {\n      this.timer.clearTimeout(this.noActivityTimeoutId)\n      this.noActivityTimeoutId = null\n    }\n  }\n\n  bindSocketEvents (socket) {\n    // TODO: check which of these events are actually emitted by socket\n    socket.on('disconnect', (reason) => this.onDisconnect(reason, socket))\n    socket.on('start', (info) => this.onStart(info))\n    socket.on('karma_error', (error) => this.onKarmaError(error))\n    socket.on('complete', (result) => this.onComplete(result))\n    socket.on('info', (info) => this.onInfo(info))\n    socket.on('result', (result) => this.onResult(result))\n  }\n\n  isConnected () {\n    return this.state === CONNECTED\n  }\n\n  isNotConnected () {\n    return !this.isConnected()\n  }\n\n  serialize () {\n    return {\n      id: this.id,\n      name: this.name,\n      isConnected: this.state === CONNECTED\n    }\n  }\n\n  toString () {\n    return this.name\n  }\n\n  toJSON () {\n    return {\n      id: this.id,\n      fullName: this.fullName,\n      name: this.name,\n      state: this.state,\n      lastResult: this.lastResult,\n      disconnectsCount: this.disconnectsCount,\n      noActivityTimeout: this.noActivityTimeout,\n      disconnectDelay: this.disconnectDelay\n    }\n  }\n}\n\nBrowser.factory = function (\n  id, fullName, /* capturedBrowsers */ collection, emitter, socket, timer,\n  /* config.browserDisconnectTimeout */ disconnectDelay,\n  /* config.browserNoActivityTimeout */ noActivityTimeout\n) {\n  return new Browser(id, fullName, collection, emitter, socket, timer, disconnectDelay, noActivityTimeout)\n}\n\nBrowser.STATE_CONNECTED = CONNECTED\nBrowser.STATE_CONFIGURING = CONFIGURING\nBrowser.STATE_EXECUTING = EXECUTING\nBrowser.STATE_EXECUTING_DISCONNECTED = EXECUTING_DISCONNECTED\nBrowser.STATE_DISCONNECTED = DISCONNECTED\n\nmodule.exports = Browser\n"]},"metadata":{},"sourceType":"script"}