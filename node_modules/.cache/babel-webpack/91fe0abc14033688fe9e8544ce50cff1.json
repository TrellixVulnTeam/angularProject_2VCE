{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.markAsyncChunksNonInitial = void 0;\n/**\n * Webpack stats may incorrectly mark extra entry points `initial` chunks, when\n * they are actually loaded asynchronously and thus not in the main bundle. This\n * function finds extra entry points in Webpack stats and corrects this value\n * whereever necessary. Does not modify {@param webpackStats}.\n */\n\nfunction markAsyncChunksNonInitial(webpackStats, extraEntryPoints) {\n  var _webpackStats$chunks = webpackStats.chunks,\n      chunks = _webpackStats$chunks === void 0 ? [] : _webpackStats$chunks,\n      _webpackStats$entrypo = webpackStats.entrypoints,\n      entryPoints = _webpackStats$entrypo === void 0 ? {} : _webpackStats$entrypo; // Find all Webpack chunk IDs not injected into the main bundle. We don't have\n  // to worry about transitive dependencies because extra entry points cannot be\n  // depended upon in Webpack, thus any extra entry point with `inject: false`,\n  // **cannot** be loaded in main bundle.\n\n  var asyncEntryPoints = extraEntryPoints.filter(function (entryPoint) {\n    return !entryPoint.inject;\n  });\n  var asyncChunkIds = flatMap(asyncEntryPoints, function (entryPoint) {\n    return entryPoints[entryPoint.bundleName].chunks;\n  }); // Find chunks for each ID.\n\n  var asyncChunks = asyncChunkIds.map(function (chunkId) {\n    var chunk = chunks.find(function (chunk) {\n      return chunk.id === chunkId;\n    });\n\n    if (!chunk) {\n      throw new Error(\"Failed to find chunk (\".concat(chunkId, \") in set:\\n\").concat(JSON.stringify(chunks)));\n    }\n\n    return chunk;\n  }) // All Webpack chunks are dependent on `runtime`, which is never an async\n  // entry point, simply ignore this one.\n  .filter(function (chunk) {\n    return chunk.names.indexOf('runtime') === -1;\n  }); // A chunk is considered `initial` only if Webpack already belives it to be initial\n  // and the application developer did not mark it async via an extra entry point.\n\n  return chunks.map(function (chunk) {\n    return _objectSpread(_objectSpread({}, chunk), {}, {\n      initial: chunk.initial && !asyncChunks.find(function (asyncChunk) {\n        return asyncChunk === chunk;\n      })\n    });\n  });\n}\n\nexports.markAsyncChunksNonInitial = markAsyncChunksNonInitial;\n\nfunction flatMap(list, mapper) {\n  var _ref;\n\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(list.map(mapper)));\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/src/webpack/utils/async-chunks.js"],"names":["Object","defineProperty","exports","value","markAsyncChunksNonInitial","webpackStats","extraEntryPoints","chunks","entrypoints","entryPoints","asyncEntryPoints","filter","entryPoint","inject","asyncChunkIds","flatMap","bundleName","asyncChunks","map","chunkId","chunk","find","id","Error","JSON","stringify","names","indexOf","initial","asyncChunk","list","mapper","concat"],"mappings":"AAAA;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,yBAAR,GAAoC,KAAK,CAAzC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,yBAAT,CAAmCC,YAAnC,EAAiDC,gBAAjD,EAAmE;AAC/D,6BAAuDD,YAAvD,CAAQE,MAAR;AAAA,MAAQA,MAAR,qCAAiB,EAAjB;AAAA,8BAAuDF,YAAvD,CAAqBG,WAArB;AAAA,MAAkCC,WAAlC,sCAAgD,EAAhD,yBAD+D,CAE/D;AACA;AACA;AACA;;AACA,MAAMC,gBAAgB,GAAGJ,gBAAgB,CAACK,MAAjB,CAAwB,UAACC,UAAD;AAAA,WAAgB,CAACA,UAAU,CAACC,MAA5B;AAAA,GAAxB,CAAzB;AACA,MAAMC,aAAa,GAAGC,OAAO,CAACL,gBAAD,EAAmB,UAACE,UAAD;AAAA,WAAgBH,WAAW,CAACG,UAAU,CAACI,UAAZ,CAAX,CAAmCT,MAAnD;AAAA,GAAnB,CAA7B,CAP+D,CAQ/D;;AACA,MAAMU,WAAW,GAAGH,aAAa,CAACI,GAAd,CAAkB,UAACC,OAAD,EAAa;AAC/C,QAAMC,KAAK,GAAGb,MAAM,CAACc,IAAP,CAAY,UAACD,KAAD;AAAA,aAAWA,KAAK,CAACE,EAAN,KAAaH,OAAxB;AAAA,KAAZ,CAAd;;AACA,QAAI,CAACC,KAAL,EAAY;AACR,YAAM,IAAIG,KAAJ,iCAAmCJ,OAAnC,wBAAwDK,IAAI,CAACC,SAAL,CAAelB,MAAf,CAAxD,EAAN;AACH;;AACD,WAAOa,KAAP;AACH,GANmB,EAOhB;AACA;AARgB,GASfT,MATe,CASR,UAACS,KAAD;AAAA,WAAWA,KAAK,CAACM,KAAN,CAAYC,OAAZ,CAAoB,SAApB,MAAmC,CAAC,CAA/C;AAAA,GATQ,CAApB,CAT+D,CAmB/D;AACA;;AACA,SAAOpB,MAAM,CAACW,GAAP,CAAW,UAACE,KAAD;AAAA,2CACXA,KADW;AAEdQ,MAAAA,OAAO,EAAER,KAAK,CAACQ,OAAN,IAAiB,CAACX,WAAW,CAACI,IAAZ,CAAiB,UAACQ,UAAD;AAAA,eAAgBA,UAAU,KAAKT,KAA/B;AAAA,OAAjB;AAFb;AAAA,GAAX,CAAP;AAIH;;AACDlB,OAAO,CAACE,yBAAR,GAAoCA,yBAApC;;AACA,SAASW,OAAT,CAAiBe,IAAjB,EAAuBC,MAAvB,EAA+B;AAAA;;AAC3B,SAAO,YAAGC,MAAH,gCAAaF,IAAI,CAACZ,GAAL,CAASa,MAAT,CAAb,EAAP;AACH","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.markAsyncChunksNonInitial = void 0;\n/**\n * Webpack stats may incorrectly mark extra entry points `initial` chunks, when\n * they are actually loaded asynchronously and thus not in the main bundle. This\n * function finds extra entry points in Webpack stats and corrects this value\n * whereever necessary. Does not modify {@param webpackStats}.\n */\nfunction markAsyncChunksNonInitial(webpackStats, extraEntryPoints) {\n    const { chunks = [], entrypoints: entryPoints = {} } = webpackStats;\n    // Find all Webpack chunk IDs not injected into the main bundle. We don't have\n    // to worry about transitive dependencies because extra entry points cannot be\n    // depended upon in Webpack, thus any extra entry point with `inject: false`,\n    // **cannot** be loaded in main bundle.\n    const asyncEntryPoints = extraEntryPoints.filter((entryPoint) => !entryPoint.inject);\n    const asyncChunkIds = flatMap(asyncEntryPoints, (entryPoint) => entryPoints[entryPoint.bundleName].chunks);\n    // Find chunks for each ID.\n    const asyncChunks = asyncChunkIds.map((chunkId) => {\n        const chunk = chunks.find((chunk) => chunk.id === chunkId);\n        if (!chunk) {\n            throw new Error(`Failed to find chunk (${chunkId}) in set:\\n${JSON.stringify(chunks)}`);\n        }\n        return chunk;\n    })\n        // All Webpack chunks are dependent on `runtime`, which is never an async\n        // entry point, simply ignore this one.\n        .filter((chunk) => chunk.names.indexOf('runtime') === -1);\n    // A chunk is considered `initial` only if Webpack already belives it to be initial\n    // and the application developer did not mark it async via an extra entry point.\n    return chunks.map((chunk) => ({\n        ...chunk,\n        initial: chunk.initial && !asyncChunks.find((asyncChunk) => asyncChunk === chunk),\n    }));\n}\nexports.markAsyncChunksNonInitial = markAsyncChunksNonInitial;\nfunction flatMap(list, mapper) {\n    return [].concat(...list.map(mapper));\n}\n"]},"metadata":{},"sourceType":"script"}