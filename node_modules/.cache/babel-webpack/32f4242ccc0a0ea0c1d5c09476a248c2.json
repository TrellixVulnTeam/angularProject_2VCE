{"ast":null,"code":"import _slicedToArray from \"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\nimport * as ast from \"./ast.js\";\nimport { make_node } from \"./utils/index.js\";\nimport { AST_Accessor, AST_Array, AST_Arrow, AST_Assign, AST_Atom, AST_Await, AST_BigInt, AST_Binary, AST_Block, AST_BlockStatement, AST_Boolean, AST_Break, AST_Call, AST_Case, AST_Catch, AST_Chain, AST_Class, AST_ClassExpression, AST_ClassProperty, AST_ClassPrivateProperty, AST_ConciseMethod, AST_Conditional, AST_Const, AST_Constant, AST_Continue, AST_Debugger, AST_Default, AST_DefaultAssign, AST_DefClass, AST_Definitions, AST_Defun, AST_Destructuring, AST_Directive, AST_Do, AST_Dot, AST_DotHash, AST_EmptyStatement, AST_Expansion, AST_Export, AST_False, AST_Finally, AST_For, AST_ForIn, AST_ForOf, AST_Function, AST_Hole, AST_If, AST_Import, AST_ImportMeta, AST_Label, AST_LabeledStatement, AST_LabelRef, AST_Lambda, AST_Let, AST_NameMapping, AST_New, AST_NewTarget, AST_Node, AST_Null, AST_Number, AST_Object, AST_ObjectGetter, AST_ObjectKeyVal, AST_ObjectProperty, AST_ObjectSetter, AST_PrefixedTemplateString, AST_PrivateGetter, AST_PrivateMethod, AST_PrivateSetter, AST_PropAccess, AST_RegExp, AST_Return, AST_Sequence, AST_SimpleStatement, AST_Statement, AST_String, AST_Sub, AST_Super, AST_Switch, AST_SwitchBranch, AST_Symbol, AST_SymbolCatch, AST_SymbolClass, AST_SymbolClassProperty, AST_SymbolConst, AST_SymbolDefClass, AST_SymbolDefun, AST_SymbolExport, AST_SymbolExportForeign, AST_SymbolFunarg, AST_SymbolImport, AST_SymbolImportForeign, AST_SymbolLambda, AST_SymbolLet, AST_SymbolMethod, AST_SymbolRef, AST_SymbolVar, AST_TemplateSegment, AST_TemplateString, AST_This, AST_Throw, AST_Token, AST_Toplevel, AST_True, AST_Try, AST_Unary, AST_UnaryPostfix, AST_UnaryPrefix, AST_Var, AST_VarDef, AST_While, AST_With, AST_Yield } from \"./ast.js\";\n\n(function () {\n  var normalize_directives = function normalize_directives(body) {\n    var in_directive = true;\n\n    for (var i = 0; i < body.length; i++) {\n      if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n        body[i] = new AST_Directive({\n          start: body[i].start,\n          end: body[i].end,\n          value: body[i].body.value\n        });\n      } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {\n        in_directive = false;\n      }\n    }\n\n    return body;\n  };\n\n  var MOZ_TO_ME = {\n    Program: function Program(M) {\n      return new AST_Toplevel({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: normalize_directives(M.body.map(from_moz))\n      });\n    },\n    ArrayPattern: function ArrayPattern(M) {\n      return new AST_Destructuring({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        names: M.elements.map(function (elm) {\n          if (elm === null) {\n            return new AST_Hole();\n          }\n\n          return from_moz(elm);\n        }),\n        is_array: true\n      });\n    },\n    ObjectPattern: function ObjectPattern(M) {\n      return new AST_Destructuring({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        names: M.properties.map(from_moz),\n        is_array: false\n      });\n    },\n    AssignmentPattern: function AssignmentPattern(M) {\n      return new AST_DefaultAssign({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        left: from_moz(M.left),\n        operator: \"=\",\n        right: from_moz(M.right)\n      });\n    },\n    SpreadElement: function SpreadElement(M) {\n      return new AST_Expansion({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    RestElement: function RestElement(M) {\n      return new AST_Expansion({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.argument)\n      });\n    },\n    TemplateElement: function TemplateElement(M) {\n      return new AST_TemplateSegment({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: M.value.cooked,\n        raw: M.value.raw\n      });\n    },\n    TemplateLiteral: function TemplateLiteral(M) {\n      var segments = [];\n\n      for (var i = 0; i < M.quasis.length; i++) {\n        segments.push(from_moz(M.quasis[i]));\n\n        if (M.expressions[i]) {\n          segments.push(from_moz(M.expressions[i]));\n        }\n      }\n\n      return new AST_TemplateString({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        segments: segments\n      });\n    },\n    TaggedTemplateExpression: function TaggedTemplateExpression(M) {\n      return new AST_PrefixedTemplateString({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        template_string: from_moz(M.quasi),\n        prefix: from_moz(M.tag)\n      });\n    },\n    FunctionDeclaration: function FunctionDeclaration(M) {\n      return new AST_Defun({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: M.params.map(from_moz),\n        is_generator: M.generator,\n        async: M.async,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    FunctionExpression: function FunctionExpression(M) {\n      return new AST_Function({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: from_moz(M.id),\n        argnames: M.params.map(from_moz),\n        is_generator: M.generator,\n        async: M.async,\n        body: normalize_directives(from_moz(M.body).body)\n      });\n    },\n    ArrowFunctionExpression: function ArrowFunctionExpression(M) {\n      var body = M.body.type === \"BlockStatement\" ? from_moz(M.body).body : [make_node(AST_Return, {}, {\n        value: from_moz(M.body)\n      })];\n      return new AST_Arrow({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        argnames: M.params.map(from_moz),\n        body: body,\n        async: M.async\n      });\n    },\n    ExpressionStatement: function ExpressionStatement(M) {\n      return new AST_SimpleStatement({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.expression)\n      });\n    },\n    TryStatement: function TryStatement(M) {\n      var handlers = M.handlers || [M.handler];\n\n      if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n        throw new Error(\"Multiple catch clauses are not supported.\");\n      }\n\n      return new AST_Try({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        body: from_moz(M.block).body,\n        bcatch: from_moz(handlers[0]),\n        bfinally: M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n      });\n    },\n    Property: function Property(M) {\n      var key = M.key;\n      var args = {\n        start: my_start_token(key || M.value),\n        end: my_end_token(M.value),\n        key: key.type == \"Identifier\" ? key.name : key.value,\n        value: from_moz(M.value)\n      };\n\n      if (M.computed) {\n        args.key = from_moz(M.key);\n      }\n\n      if (M.method) {\n        args.is_generator = M.value.generator;\n        args.async = M.value.async;\n\n        if (!M.computed) {\n          args.key = new AST_SymbolMethod({\n            name: args.key\n          });\n        } else {\n          args.key = from_moz(M.key);\n        }\n\n        return new AST_ConciseMethod(args);\n      }\n\n      if (M.kind == \"init\") {\n        if (key.type != \"Identifier\" && key.type != \"Literal\") {\n          args.key = from_moz(key);\n        }\n\n        return new AST_ObjectKeyVal(args);\n      }\n\n      if (typeof args.key === \"string\" || typeof args.key === \"number\") {\n        args.key = new AST_SymbolMethod({\n          name: args.key\n        });\n      }\n\n      args.value = new AST_Accessor(args.value);\n      if (M.kind == \"get\") return new AST_ObjectGetter(args);\n      if (M.kind == \"set\") return new AST_ObjectSetter(args);\n\n      if (M.kind == \"method\") {\n        args.async = M.value.async;\n        args.is_generator = M.value.generator;\n        args.quote = M.computed ? \"\\\"\" : null;\n        return new AST_ConciseMethod(args);\n      }\n    },\n    MethodDefinition: function MethodDefinition(M) {\n      var args = {\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: M.computed ? from_moz(M.key) : new AST_SymbolMethod({\n          name: M.key.name || M.key.value\n        }),\n        value: from_moz(M.value),\n        static: M.static\n      };\n\n      if (M.kind == \"get\") {\n        return new AST_ObjectGetter(args);\n      }\n\n      if (M.kind == \"set\") {\n        return new AST_ObjectSetter(args);\n      }\n\n      args.is_generator = M.value.generator;\n      args.async = M.value.async;\n      return new AST_ConciseMethod(args);\n    },\n    FieldDefinition: function FieldDefinition(M) {\n      var key;\n\n      if (M.computed) {\n        key = from_moz(M.key);\n      } else {\n        if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n        key = from_moz(M.key);\n      }\n\n      return new AST_ClassProperty({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        value: from_moz(M.value),\n        static: M.static\n      });\n    },\n    PropertyDefinition: function PropertyDefinition(M) {\n      var key;\n\n      if (M.computed) {\n        key = from_moz(M.key);\n      } else {\n        if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in PropertyDefinition\");\n        key = from_moz(M.key);\n      }\n\n      return new AST_ClassProperty({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        key: key,\n        value: from_moz(M.value),\n        static: M.static\n      });\n    },\n    ArrayExpression: function ArrayExpression(M) {\n      return new AST_Array({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        elements: M.elements.map(function (elem) {\n          return elem === null ? new AST_Hole() : from_moz(elem);\n        })\n      });\n    },\n    ObjectExpression: function ObjectExpression(M) {\n      return new AST_Object({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        properties: M.properties.map(function (prop) {\n          if (prop.type === \"SpreadElement\") {\n            return from_moz(prop);\n          }\n\n          prop.type = \"Property\";\n          return from_moz(prop);\n        })\n      });\n    },\n    SequenceExpression: function SequenceExpression(M) {\n      return new AST_Sequence({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expressions: M.expressions.map(from_moz)\n      });\n    },\n    MemberExpression: function MemberExpression(M) {\n      return new (M.computed ? AST_Sub : AST_Dot)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        property: M.computed ? from_moz(M.property) : M.property.name,\n        expression: from_moz(M.object),\n        optional: M.optional || false\n      });\n    },\n    ChainExpression: function ChainExpression(M) {\n      return new AST_Chain({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.expression)\n      });\n    },\n    SwitchCase: function SwitchCase(M) {\n      return new (M.test ? AST_Case : AST_Default)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        expression: from_moz(M.test),\n        body: M.consequent.map(from_moz)\n      });\n    },\n    VariableDeclaration: function VariableDeclaration(M) {\n      return new (M.kind === \"const\" ? AST_Const : M.kind === \"let\" ? AST_Let : AST_Var)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        definitions: M.declarations.map(from_moz)\n      });\n    },\n    ImportDeclaration: function ImportDeclaration(M) {\n      var imported_name = null;\n      var imported_names = null;\n      M.specifiers.forEach(function (specifier) {\n        if (specifier.type === \"ImportSpecifier\") {\n          if (!imported_names) {\n            imported_names = [];\n          }\n\n          imported_names.push(new AST_NameMapping({\n            start: my_start_token(specifier),\n            end: my_end_token(specifier),\n            foreign_name: from_moz(specifier.imported),\n            name: from_moz(specifier.local)\n          }));\n        } else if (specifier.type === \"ImportDefaultSpecifier\") {\n          imported_name = from_moz(specifier.local);\n        } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n          if (!imported_names) {\n            imported_names = [];\n          }\n\n          imported_names.push(new AST_NameMapping({\n            start: my_start_token(specifier),\n            end: my_end_token(specifier),\n            foreign_name: new AST_SymbolImportForeign({\n              name: \"*\"\n            }),\n            name: from_moz(specifier.local)\n          }));\n        }\n      });\n      return new AST_Import({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        imported_name: imported_name,\n        imported_names: imported_names,\n        module_name: from_moz(M.source)\n      });\n    },\n    ExportAllDeclaration: function ExportAllDeclaration(M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_names: [new AST_NameMapping({\n          name: new AST_SymbolExportForeign({\n            name: \"*\"\n          }),\n          foreign_name: new AST_SymbolExportForeign({\n            name: \"*\"\n          })\n        })],\n        module_name: from_moz(M.source)\n      });\n    },\n    ExportNamedDeclaration: function ExportNamedDeclaration(M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_definition: from_moz(M.declaration),\n        exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {\n          return new AST_NameMapping({\n            foreign_name: from_moz(specifier.exported),\n            name: from_moz(specifier.local)\n          });\n        }) : null,\n        module_name: from_moz(M.source)\n      });\n    },\n    ExportDefaultDeclaration: function ExportDefaultDeclaration(M) {\n      return new AST_Export({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        exported_value: from_moz(M.declaration),\n        is_default: true\n      });\n    },\n    Literal: function Literal(M) {\n      var val = M.value,\n          args = {\n        start: my_start_token(M),\n        end: my_end_token(M)\n      };\n      var rx = M.regex;\n\n      if (rx && rx.pattern) {\n        // RegExpLiteral as per ESTree AST spec\n        args.value = {\n          source: rx.pattern,\n          flags: rx.flags\n        };\n        return new AST_RegExp(args);\n      } else if (rx) {\n        // support legacy RegExp\n        var rx_source = M.raw || val;\n        var match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n        if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n\n        var _match = _slicedToArray(match, 3),\n            _ = _match[0],\n            source = _match[1],\n            flags = _match[2];\n\n        args.value = {\n          source: source,\n          flags: flags\n        };\n        return new AST_RegExp(args);\n      }\n\n      if (val === null) return new AST_Null(args);\n\n      switch (typeof val) {\n        case \"string\":\n          args.value = val;\n          return new AST_String(args);\n\n        case \"number\":\n          args.value = val;\n          args.raw = M.raw || val.toString();\n          return new AST_Number(args);\n\n        case \"boolean\":\n          return new (val ? AST_True : AST_False)(args);\n      }\n    },\n    MetaProperty: function MetaProperty(M) {\n      if (M.meta.name === \"new\" && M.property.name === \"target\") {\n        return new AST_NewTarget({\n          start: my_start_token(M),\n          end: my_end_token(M)\n        });\n      } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n        return new AST_ImportMeta({\n          start: my_start_token(M),\n          end: my_end_token(M)\n        });\n      }\n    },\n    Identifier: function Identifier(M) {\n      var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n      return new (p.type == \"LabeledStatement\" ? AST_Label : p.type == \"VariableDeclarator\" && p.id === M ? p.kind == \"const\" ? AST_SymbolConst : p.kind == \"let\" ? AST_SymbolLet : AST_SymbolVar : /Import.*Specifier/.test(p.type) ? p.local === M ? AST_SymbolImport : AST_SymbolImportForeign : p.type == \"ExportSpecifier\" ? p.local === M ? AST_SymbolExport : AST_SymbolExportForeign : p.type == \"FunctionExpression\" ? p.id === M ? AST_SymbolLambda : AST_SymbolFunarg : p.type == \"FunctionDeclaration\" ? p.id === M ? AST_SymbolDefun : AST_SymbolFunarg : p.type == \"ArrowFunctionExpression\" ? p.params.includes(M) ? AST_SymbolFunarg : AST_SymbolRef : p.type == \"ClassExpression\" ? p.id === M ? AST_SymbolClass : AST_SymbolRef : p.type == \"Property\" ? p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod : p.type == \"PropertyDefinition\" || p.type === \"FieldDefinition\" ? p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty : p.type == \"ClassDeclaration\" ? p.id === M ? AST_SymbolDefClass : AST_SymbolRef : p.type == \"MethodDefinition\" ? p.computed ? AST_SymbolRef : AST_SymbolMethod : p.type == \"CatchClause\" ? AST_SymbolCatch : p.type == \"BreakStatement\" || p.type == \"ContinueStatement\" ? AST_LabelRef : AST_SymbolRef)({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        name: M.name\n      });\n    },\n    BigIntLiteral: function BigIntLiteral(M) {\n      return new AST_BigInt({\n        start: my_start_token(M),\n        end: my_end_token(M),\n        value: M.value\n      });\n    }\n  };\n\n  MOZ_TO_ME.UpdateExpression = MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n    var prefix = \"prefix\" in M ? M.prefix : M.type == \"UnaryExpression\" ? true : false;\n    return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      operator: M.operator,\n      expression: from_moz(M.argument)\n    });\n  };\n\n  MOZ_TO_ME.ClassDeclaration = MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n    return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n      start: my_start_token(M),\n      end: my_end_token(M),\n      name: from_moz(M.id),\n      extends: from_moz(M.superClass),\n      properties: M.body.body.map(from_moz)\n    });\n  };\n\n  map(\"EmptyStatement\", AST_EmptyStatement);\n  map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n  map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n  map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n  map(\"BreakStatement\", AST_Break, \"label>label\");\n  map(\"ContinueStatement\", AST_Continue, \"label>label\");\n  map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n  map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n  map(\"ReturnStatement\", AST_Return, \"argument>value\");\n  map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n  map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n  map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n  map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n  map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n  map(\"ForOfStatement\", AST_ForOf, \"left>init, right>object, body>body, await=await\");\n  map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n  map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=is_star\");\n  map(\"DebuggerStatement\", AST_Debugger);\n  map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n  map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n  map(\"ThisExpression\", AST_This);\n  map(\"Super\", AST_Super);\n  map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n  map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n  map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n  map(\"NewExpression\", AST_New, \"callee>expression, arguments@args\");\n  map(\"CallExpression\", AST_Call, \"callee>expression, optional=optional, arguments@args\");\n  def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n    return to_moz_scope(\"Program\", M);\n  });\n  def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n    return {\n      type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n    return {\n      type: \"TaggedTemplateExpression\",\n      tag: to_moz(M.prefix),\n      quasi: to_moz(M.template_string)\n    };\n  });\n  def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n    var quasis = [];\n    var expressions = [];\n\n    for (var i = 0; i < M.segments.length; i++) {\n      if (i % 2 !== 0) {\n        expressions.push(to_moz(M.segments[i]));\n      } else {\n        quasis.push({\n          type: \"TemplateElement\",\n          value: {\n            raw: M.segments[i].raw,\n            cooked: M.segments[i].value\n          },\n          tail: i === M.segments.length - 1\n        });\n      }\n    }\n\n    return {\n      type: \"TemplateLiteral\",\n      quasis: quasis,\n      expressions: expressions\n    };\n  });\n  def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n    return {\n      type: \"FunctionDeclaration\",\n      id: to_moz(M.name),\n      params: M.argnames.map(to_moz),\n      generator: M.is_generator,\n      async: M.async,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {\n    var is_generator = parent.is_generator !== undefined ? parent.is_generator : M.is_generator;\n    return {\n      type: \"FunctionExpression\",\n      id: to_moz(M.name),\n      params: M.argnames.map(to_moz),\n      generator: is_generator,\n      async: M.async,\n      body: to_moz_scope(\"BlockStatement\", M)\n    };\n  });\n  def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n    var body = {\n      type: \"BlockStatement\",\n      body: M.body.map(to_moz)\n    };\n    return {\n      type: \"ArrowFunctionExpression\",\n      params: M.argnames.map(to_moz),\n      async: M.async,\n      body: body\n    };\n  });\n  def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n    if (M.is_array) {\n      return {\n        type: \"ArrayPattern\",\n        elements: M.names.map(to_moz)\n      };\n    }\n\n    return {\n      type: \"ObjectPattern\",\n      properties: M.names.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: M.value,\n        raw: M.print_to_string()\n      },\n      directive: M.value\n    };\n  });\n  def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n    return {\n      type: \"ExpressionStatement\",\n      expression: to_moz(M.body)\n    };\n  });\n  def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n    return {\n      type: \"SwitchCase\",\n      test: to_moz(M.expression),\n      consequent: M.body.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n    return {\n      type: \"TryStatement\",\n      block: to_moz_block(M),\n      handler: to_moz(M.bcatch),\n      guardedHandlers: [],\n      finalizer: to_moz(M.bfinally)\n    };\n  });\n  def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n    return {\n      type: \"CatchClause\",\n      param: to_moz(M.argname),\n      guard: null,\n      body: to_moz_block(M)\n    };\n  });\n  def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n    return {\n      type: \"VariableDeclaration\",\n      kind: M instanceof AST_Const ? \"const\" : M instanceof AST_Let ? \"let\" : \"var\",\n      declarations: M.definitions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n    if (M.exported_names) {\n      if (M.exported_names[0].name.name === \"*\") {\n        return {\n          type: \"ExportAllDeclaration\",\n          source: to_moz(M.module_name)\n        };\n      }\n\n      return {\n        type: \"ExportNamedDeclaration\",\n        specifiers: M.exported_names.map(function (name_mapping) {\n          return {\n            type: \"ExportSpecifier\",\n            exported: to_moz(name_mapping.foreign_name),\n            local: to_moz(name_mapping.name)\n          };\n        }),\n        declaration: to_moz(M.exported_definition),\n        source: to_moz(M.module_name)\n      };\n    }\n\n    return {\n      type: M.is_default ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\",\n      declaration: to_moz(M.exported_value || M.exported_definition)\n    };\n  });\n  def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n    var specifiers = [];\n\n    if (M.imported_name) {\n      specifiers.push({\n        type: \"ImportDefaultSpecifier\",\n        local: to_moz(M.imported_name)\n      });\n    }\n\n    if (M.imported_names && M.imported_names[0].foreign_name.name === \"*\") {\n      specifiers.push({\n        type: \"ImportNamespaceSpecifier\",\n        local: to_moz(M.imported_names[0].name)\n      });\n    } else if (M.imported_names) {\n      M.imported_names.forEach(function (name_mapping) {\n        specifiers.push({\n          type: \"ImportSpecifier\",\n          local: to_moz(name_mapping.name),\n          imported: to_moz(name_mapping.foreign_name)\n        });\n      });\n    }\n\n    return {\n      type: \"ImportDeclaration\",\n      specifiers: specifiers,\n      source: to_moz(M.module_name)\n    };\n  });\n  def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"import\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"meta\"\n      }\n    };\n  });\n  def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n    return {\n      type: \"SequenceExpression\",\n      expressions: M.expressions.map(to_moz)\n    };\n  });\n  def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {\n    return {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: false,\n      property: {\n        type: \"PrivateIdentifier\",\n        name: M.property\n      },\n      optional: M.optional\n    };\n  });\n  def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n    var isComputed = M instanceof AST_Sub;\n    return {\n      type: \"MemberExpression\",\n      object: to_moz(M.expression),\n      computed: isComputed,\n      property: isComputed ? to_moz(M.property) : {\n        type: \"Identifier\",\n        name: M.property\n      },\n      optional: M.optional\n    };\n  });\n  def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n    return {\n      type: \"ChainExpression\",\n      expression: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n    return {\n      type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n      operator: M.operator,\n      prefix: M instanceof AST_UnaryPrefix,\n      argument: to_moz(M.expression)\n    };\n  });\n  def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n    if (M.operator == \"=\" && to_moz_in_destructuring()) {\n      return {\n        type: \"AssignmentPattern\",\n        left: to_moz(M.left),\n        right: to_moz(M.right)\n      };\n    }\n\n    var type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\" ? \"LogicalExpression\" : \"BinaryExpression\";\n    return {\n      type: type,\n      left: to_moz(M.left),\n      operator: M.operator,\n      right: to_moz(M.right)\n    };\n  });\n  def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n    return {\n      type: \"ArrayExpression\",\n      elements: M.elements.map(to_moz)\n    };\n  });\n  def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n    return {\n      type: \"ObjectExpression\",\n      properties: M.properties.map(to_moz)\n    };\n  });\n  def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n    var key = M.key instanceof AST_Node ? to_moz(M.key) : {\n      type: \"Identifier\",\n      value: M.key\n    };\n\n    if (typeof M.key === \"number\") {\n      key = {\n        type: \"Literal\",\n        value: Number(M.key)\n      };\n    }\n\n    if (typeof M.key === \"string\") {\n      key = {\n        type: \"Identifier\",\n        name: M.key\n      };\n    }\n\n    var kind;\n    var string_or_num = typeof M.key === \"string\" || typeof M.key === \"number\";\n    var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;\n\n    if (M instanceof AST_ObjectKeyVal) {\n      kind = \"init\";\n      computed = !string_or_num;\n    } else if (M instanceof AST_ObjectGetter) {\n      kind = \"get\";\n    } else if (M instanceof AST_ObjectSetter) {\n      kind = \"set\";\n    }\n\n    if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {\n      var _kind = M instanceof AST_PrivateGetter ? \"get\" : \"set\";\n\n      return {\n        type: \"MethodDefinition\",\n        computed: false,\n        kind: _kind,\n        static: M.static,\n        key: {\n          type: \"PrivateIdentifier\",\n          name: M.key.name\n        },\n        value: to_moz(M.value)\n      };\n    }\n\n    if (M instanceof AST_ClassPrivateProperty) {\n      return {\n        type: \"PropertyDefinition\",\n        key: {\n          type: \"PrivateIdentifier\",\n          name: M.key.name\n        },\n        value: to_moz(M.value),\n        computed: false,\n        static: M.static\n      };\n    }\n\n    if (M instanceof AST_ClassProperty) {\n      return {\n        type: \"PropertyDefinition\",\n        key: key,\n        value: to_moz(M.value),\n        computed: computed,\n        static: M.static\n      };\n    }\n\n    if (parent instanceof AST_Class) {\n      return {\n        type: \"MethodDefinition\",\n        computed: computed,\n        kind: kind,\n        static: M.static,\n        key: to_moz(M.key),\n        value: to_moz(M.value)\n      };\n    }\n\n    return {\n      type: \"Property\",\n      computed: computed,\n      kind: kind,\n      key: key,\n      value: to_moz(M.value)\n    };\n  });\n  def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n    if (parent instanceof AST_Object) {\n      return {\n        type: \"Property\",\n        computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n        kind: \"init\",\n        method: true,\n        shorthand: false,\n        key: to_moz(M.key),\n        value: to_moz(M.value)\n      };\n    }\n\n    var key = M instanceof AST_PrivateMethod ? {\n      type: \"PrivateIdentifier\",\n      name: M.key.name\n    } : to_moz(M.key);\n    return {\n      type: \"MethodDefinition\",\n      kind: M.key === \"constructor\" ? \"constructor\" : \"method\",\n      key: key,\n      value: to_moz(M.value),\n      computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n      static: M.static\n    };\n  });\n  def_to_moz(AST_Class, function To_Moz_Class(M) {\n    var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n    return {\n      type: type,\n      superClass: to_moz(M.extends),\n      id: M.name ? to_moz(M.name) : null,\n      body: {\n        type: \"ClassBody\",\n        body: M.properties.map(to_moz)\n      }\n    };\n  });\n  def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n    return {\n      type: \"MetaProperty\",\n      meta: {\n        type: \"Identifier\",\n        name: \"new\"\n      },\n      property: {\n        type: \"Identifier\",\n        name: \"target\"\n      }\n    };\n  });\n  def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n    if (M instanceof AST_SymbolMethod && parent.quote) {\n      return {\n        type: \"Literal\",\n        value: M.name\n      };\n    }\n\n    var def = M.definition();\n    return {\n      type: \"Identifier\",\n      name: def ? def.mangled_name || def.name : M.name\n    };\n  });\n  def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n    var pattern = M.value.source;\n    var flags = M.value.flags;\n    return {\n      type: \"Literal\",\n      value: null,\n      raw: M.print_to_string(),\n      regex: {\n        pattern: pattern,\n        flags: flags\n      }\n    };\n  });\n  def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n    var value = M.value;\n    return {\n      type: \"Literal\",\n      value: value,\n      raw: M.raw || M.print_to_string()\n    };\n  });\n  def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n    return {\n      type: \"Identifier\",\n      name: String(M.value)\n    };\n  });\n  def_to_moz(AST_BigInt, function (M) {\n    return {\n      type: \"BigIntLiteral\",\n      value: M.value\n    };\n  });\n  AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n  AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n  AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() {\n    return null;\n  });\n  AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n  AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n  /* -----[ tools ]----- */\n\n  function my_start_token(moznode) {\n    var loc = moznode.loc,\n        start = loc && loc.start;\n    var range = moznode.range;\n    return new AST_Token(\"\", \"\", start && start.line || 0, start && start.column || 0, range ? range[0] : moznode.start, false, [], [], loc && loc.source);\n  }\n\n  function my_end_token(moznode) {\n    var loc = moznode.loc,\n        end = loc && loc.end;\n    var range = moznode.range;\n    return new AST_Token(\"\", \"\", end && end.line || 0, end && end.column || 0, range ? range[0] : moznode.end, false, [], [], loc && loc.source);\n  }\n\n  function map(moztype, mytype, propmap) {\n    var moz_to_me = \"function From_Moz_\" + moztype + \"(M){\\n\";\n    moz_to_me += \"return new U2.\" + mytype.name + \"({\\n\" + \"start: my_start_token(M),\\n\" + \"end: my_end_token(M)\";\n    var me_to_moz = \"function To_Moz_\" + moztype + \"(M){\\n\";\n    me_to_moz += \"return {\\n\" + \"type: \" + JSON.stringify(moztype);\n    if (propmap) propmap.split(/\\s*,\\s*/).forEach(function (prop) {\n      var m = /([a-z0-9$_]+)([=@>%])([a-z0-9$_]+)/i.exec(prop);\n      if (!m) throw new Error(\"Can't understand property map: \" + prop);\n      var moz = m[1],\n          how = m[2],\n          my = m[3];\n      moz_to_me += \",\\n\" + my + \": \";\n      me_to_moz += \",\\n\" + moz + \": \";\n\n      switch (how) {\n        case \"@\":\n          moz_to_me += \"M.\" + moz + \".map(from_moz)\";\n          me_to_moz += \"M.\" + my + \".map(to_moz)\";\n          break;\n\n        case \">\":\n          moz_to_me += \"from_moz(M.\" + moz + \")\";\n          me_to_moz += \"to_moz(M.\" + my + \")\";\n          break;\n\n        case \"=\":\n          moz_to_me += \"M.\" + moz;\n          me_to_moz += \"M.\" + my;\n          break;\n\n        case \"%\":\n          moz_to_me += \"from_moz(M.\" + moz + \").body\";\n          me_to_moz += \"to_moz_block(M)\";\n          break;\n\n        default:\n          throw new Error(\"Can't understand operator in propmap: \" + prop);\n      }\n    });\n    moz_to_me += \"\\n})\\n}\";\n    me_to_moz += \"\\n}\\n}\";\n    moz_to_me = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", \"return(\" + moz_to_me + \")\")(ast, my_start_token, my_end_token, from_moz);\n    me_to_moz = new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", \"return(\" + me_to_moz + \")\")(to_moz, to_moz_block, to_moz_scope);\n    MOZ_TO_ME[moztype] = moz_to_me;\n    def_to_moz(mytype, me_to_moz);\n  }\n\n  var FROM_MOZ_STACK = null;\n\n  function from_moz(node) {\n    FROM_MOZ_STACK.push(node);\n    var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n    FROM_MOZ_STACK.pop();\n    return ret;\n  }\n\n  AST_Node.from_mozilla_ast = function (node) {\n    var save_stack = FROM_MOZ_STACK;\n    FROM_MOZ_STACK = [];\n    var ast = from_moz(node);\n    FROM_MOZ_STACK = save_stack;\n    return ast;\n  };\n\n  function set_moz_loc(mynode, moznode) {\n    var start = mynode.start;\n    var end = mynode.end;\n\n    if (!(start && end)) {\n      return moznode;\n    }\n\n    if (start.pos != null && end.endpos != null) {\n      moznode.range = [start.pos, end.endpos];\n    }\n\n    if (start.line) {\n      moznode.loc = {\n        start: {\n          line: start.line,\n          column: start.col\n        },\n        end: end.endline ? {\n          line: end.endline,\n          column: end.endcol\n        } : null\n      };\n\n      if (start.file) {\n        moznode.loc.source = start.file;\n      }\n    }\n\n    return moznode;\n  }\n\n  function def_to_moz(mytype, handler) {\n    mytype.DEFMETHOD(\"to_mozilla_ast\", function (parent) {\n      return set_moz_loc(this, handler(this, parent));\n    });\n  }\n\n  var TO_MOZ_STACK = null;\n\n  function to_moz(node) {\n    if (TO_MOZ_STACK === null) {\n      TO_MOZ_STACK = [];\n    }\n\n    TO_MOZ_STACK.push(node);\n    var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n    TO_MOZ_STACK.pop();\n\n    if (TO_MOZ_STACK.length === 0) {\n      TO_MOZ_STACK = null;\n    }\n\n    return ast;\n  }\n\n  function to_moz_in_destructuring() {\n    var i = TO_MOZ_STACK.length;\n\n    while (i--) {\n      if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function to_moz_block(node) {\n    return {\n      type: \"BlockStatement\",\n      body: node.body.map(to_moz)\n    };\n  }\n\n  function to_moz_scope(type, node) {\n    var body = node.body.map(to_moz);\n\n    if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n      body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n    }\n\n    return {\n      type: type,\n      body: body\n    };\n  }\n})();","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/terser-webpack-plugin/node_modules/terser/lib/mozilla-ast.js"],"names":["ast","make_node","AST_Accessor","AST_Array","AST_Arrow","AST_Assign","AST_Atom","AST_Await","AST_BigInt","AST_Binary","AST_Block","AST_BlockStatement","AST_Boolean","AST_Break","AST_Call","AST_Case","AST_Catch","AST_Chain","AST_Class","AST_ClassExpression","AST_ClassProperty","AST_ClassPrivateProperty","AST_ConciseMethod","AST_Conditional","AST_Const","AST_Constant","AST_Continue","AST_Debugger","AST_Default","AST_DefaultAssign","AST_DefClass","AST_Definitions","AST_Defun","AST_Destructuring","AST_Directive","AST_Do","AST_Dot","AST_DotHash","AST_EmptyStatement","AST_Expansion","AST_Export","AST_False","AST_Finally","AST_For","AST_ForIn","AST_ForOf","AST_Function","AST_Hole","AST_If","AST_Import","AST_ImportMeta","AST_Label","AST_LabeledStatement","AST_LabelRef","AST_Lambda","AST_Let","AST_NameMapping","AST_New","AST_NewTarget","AST_Node","AST_Null","AST_Number","AST_Object","AST_ObjectGetter","AST_ObjectKeyVal","AST_ObjectProperty","AST_ObjectSetter","AST_PrefixedTemplateString","AST_PrivateGetter","AST_PrivateMethod","AST_PrivateSetter","AST_PropAccess","AST_RegExp","AST_Return","AST_Sequence","AST_SimpleStatement","AST_Statement","AST_String","AST_Sub","AST_Super","AST_Switch","AST_SwitchBranch","AST_Symbol","AST_SymbolCatch","AST_SymbolClass","AST_SymbolClassProperty","AST_SymbolConst","AST_SymbolDefClass","AST_SymbolDefun","AST_SymbolExport","AST_SymbolExportForeign","AST_SymbolFunarg","AST_SymbolImport","AST_SymbolImportForeign","AST_SymbolLambda","AST_SymbolLet","AST_SymbolMethod","AST_SymbolRef","AST_SymbolVar","AST_TemplateSegment","AST_TemplateString","AST_This","AST_Throw","AST_Token","AST_Toplevel","AST_True","AST_Try","AST_Unary","AST_UnaryPostfix","AST_UnaryPrefix","AST_Var","AST_VarDef","AST_While","AST_With","AST_Yield","normalize_directives","body","in_directive","i","length","start","end","value","MOZ_TO_ME","Program","M","my_start_token","my_end_token","map","from_moz","ArrayPattern","names","elements","elm","is_array","ObjectPattern","properties","AssignmentPattern","left","operator","right","SpreadElement","expression","argument","RestElement","TemplateElement","cooked","raw","TemplateLiteral","segments","quasis","push","expressions","TaggedTemplateExpression","template_string","quasi","prefix","tag","FunctionDeclaration","name","id","argnames","params","is_generator","generator","async","FunctionExpression","ArrowFunctionExpression","type","ExpressionStatement","TryStatement","handlers","handler","guardedHandlers","Error","block","bcatch","bfinally","finalizer","Property","key","args","computed","method","kind","quote","MethodDefinition","static","FieldDefinition","PropertyDefinition","ArrayExpression","elem","ObjectExpression","prop","SequenceExpression","MemberExpression","property","object","optional","ChainExpression","SwitchCase","test","consequent","VariableDeclaration","definitions","declarations","ImportDeclaration","imported_name","imported_names","specifiers","forEach","specifier","foreign_name","imported","local","module_name","source","ExportAllDeclaration","exported_names","ExportNamedDeclaration","exported_definition","declaration","exported","ExportDefaultDeclaration","exported_value","is_default","Literal","val","rx","regex","pattern","flags","rx_source","match","_","toString","MetaProperty","meta","Identifier","p","FROM_MOZ_STACK","includes","BigIntLiteral","UpdateExpression","UnaryExpression","To_Moz_Unary","ClassDeclaration","ClassExpression","From_Moz_Class","extends","superClass","def_to_moz","To_Moz_Program","to_moz_scope","To_Moz_Spread","to_moz_in_destructuring","to_moz","To_Moz_TaggedTemplateExpression","To_Moz_TemplateLiteral","tail","To_Moz_FunctionDeclaration","To_Moz_FunctionExpression","parent","undefined","To_Moz_ArrowFunctionExpression","To_Moz_ObjectPattern","To_Moz_Directive","print_to_string","directive","To_Moz_ExpressionStatement","To_Moz_SwitchCase","To_Moz_TryStatement","to_moz_block","To_Moz_CatchClause","param","argname","guard","To_Moz_VariableDeclaration","To_Moz_ExportDeclaration","name_mapping","To_Moz_ImportDeclaration","To_Moz_MetaProperty","To_Moz_SequenceExpression","To_Moz_PrivateMemberExpression","To_Moz_MemberExpression","isComputed","To_Moz_ChainExpression","To_Moz_BinaryExpression","To_Moz_ArrayExpression","To_Moz_ObjectExpression","To_Moz_Property","Number","string_or_num","To_Moz_MethodDefinition","shorthand","To_Moz_Class","To_Moz_Identifier","def","definition","mangled_name","To_Moz_RegExpLiteral","To_Moz_Literal","To_Moz_Atom","String","DEFMETHOD","prototype","to_mozilla_ast","To_Moz_ArrayHole","moznode","loc","range","line","column","moztype","mytype","propmap","moz_to_me","me_to_moz","JSON","stringify","split","m","exec","moz","how","my","Function","node","ret","pop","from_mozilla_ast","save_stack","set_moz_loc","mynode","pos","endpos","col","endline","endcol","file","TO_MOZ_STACK","unshift"],"mappings":"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","sourcesContent":["/***********************************************************************\n\n  A JavaScript tokenizer / parser / beautifier / compressor.\n  https://github.com/mishoo/UglifyJS2\n\n  -------------------------------- (C) ---------------------------------\n\n                           Author: Mihai Bazon\n                         <mihai.bazon@gmail.com>\n                       http://mihai.bazon.net/blog\n\n  Distributed under the BSD license:\n\n    Copyright 2012 (c) Mihai Bazon <mihai.bazon@gmail.com>\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n        * Redistributions of source code must retain the above\n          copyright notice, this list of conditions and the following\n          disclaimer.\n\n        * Redistributions in binary form must reproduce the above\n          copyright notice, this list of conditions and the following\n          disclaimer in the documentation and/or other materials\n          provided with the distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER “AS IS” AND ANY\n    EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n    TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n    THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    SUCH DAMAGE.\n\n ***********************************************************************/\n\nimport * as ast from \"./ast.js\";\nimport { make_node } from \"./utils/index.js\";\nimport {\n    AST_Accessor,\n    AST_Array,\n    AST_Arrow,\n    AST_Assign,\n    AST_Atom,\n    AST_Await,\n    AST_BigInt,\n    AST_Binary,\n    AST_Block,\n    AST_BlockStatement,\n    AST_Boolean,\n    AST_Break,\n    AST_Call,\n    AST_Case,\n    AST_Catch,\n    AST_Chain,\n    AST_Class,\n    AST_ClassExpression,\n    AST_ClassProperty,\n    AST_ClassPrivateProperty,\n    AST_ConciseMethod,\n    AST_Conditional,\n    AST_Const,\n    AST_Constant,\n    AST_Continue,\n    AST_Debugger,\n    AST_Default,\n    AST_DefaultAssign,\n    AST_DefClass,\n    AST_Definitions,\n    AST_Defun,\n    AST_Destructuring,\n    AST_Directive,\n    AST_Do,\n    AST_Dot,\n    AST_DotHash,\n    AST_EmptyStatement,\n    AST_Expansion,\n    AST_Export,\n    AST_False,\n    AST_Finally,\n    AST_For,\n    AST_ForIn,\n    AST_ForOf,\n    AST_Function,\n    AST_Hole,\n    AST_If,\n    AST_Import,\n    AST_ImportMeta,\n    AST_Label,\n    AST_LabeledStatement,\n    AST_LabelRef,\n    AST_Lambda,\n    AST_Let,\n    AST_NameMapping,\n    AST_New,\n    AST_NewTarget,\n    AST_Node,\n    AST_Null,\n    AST_Number,\n    AST_Object,\n    AST_ObjectGetter,\n    AST_ObjectKeyVal,\n    AST_ObjectProperty,\n    AST_ObjectSetter,\n    AST_PrefixedTemplateString,\n    AST_PrivateGetter,\n    AST_PrivateMethod,\n    AST_PrivateSetter,\n    AST_PropAccess,\n    AST_RegExp,\n    AST_Return,\n    AST_Sequence,\n    AST_SimpleStatement,\n    AST_Statement,\n    AST_String,\n    AST_Sub,\n    AST_Super,\n    AST_Switch,\n    AST_SwitchBranch,\n    AST_Symbol,\n    AST_SymbolCatch,\n    AST_SymbolClass,\n    AST_SymbolClassProperty,\n    AST_SymbolConst,\n    AST_SymbolDefClass,\n    AST_SymbolDefun,\n    AST_SymbolExport,\n    AST_SymbolExportForeign,\n    AST_SymbolFunarg,\n    AST_SymbolImport,\n    AST_SymbolImportForeign,\n    AST_SymbolLambda,\n    AST_SymbolLet,\n    AST_SymbolMethod,\n    AST_SymbolRef,\n    AST_SymbolVar,\n    AST_TemplateSegment,\n    AST_TemplateString,\n    AST_This,\n    AST_Throw,\n    AST_Token,\n    AST_Toplevel,\n    AST_True,\n    AST_Try,\n    AST_Unary,\n    AST_UnaryPostfix,\n    AST_UnaryPrefix,\n    AST_Var,\n    AST_VarDef,\n    AST_While,\n    AST_With,\n    AST_Yield,\n} from \"./ast.js\";\n\n(function() {\n\n    var normalize_directives = function(body) {\n        var in_directive = true;\n\n        for (var i = 0; i < body.length; i++) {\n            if (in_directive && body[i] instanceof AST_Statement && body[i].body instanceof AST_String) {\n                body[i] = new AST_Directive({\n                    start: body[i].start,\n                    end: body[i].end,\n                    value: body[i].body.value\n                });\n            } else if (in_directive && !(body[i] instanceof AST_Statement && body[i].body instanceof AST_String)) {\n                in_directive = false;\n            }\n        }\n\n        return body;\n    };\n\n    var MOZ_TO_ME = {\n        Program: function(M) {\n            return new AST_Toplevel({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: normalize_directives(M.body.map(from_moz))\n            });\n        },\n        ArrayPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.elements.map(function(elm) {\n                    if (elm === null) {\n                        return new AST_Hole();\n                    }\n                    return from_moz(elm);\n                }),\n                is_array: true\n            });\n        },\n        ObjectPattern: function(M) {\n            return new AST_Destructuring({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                names: M.properties.map(from_moz),\n                is_array: false\n            });\n        },\n        AssignmentPattern: function(M) {\n            return new AST_DefaultAssign({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                left: from_moz(M.left),\n                operator: \"=\",\n                right: from_moz(M.right)\n            });\n        },\n        SpreadElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n        RestElement: function(M) {\n            return new AST_Expansion({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                expression: from_moz(M.argument)\n            });\n        },\n        TemplateElement: function(M) {\n            return new AST_TemplateSegment({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                value: M.value.cooked,\n                raw: M.value.raw\n            });\n        },\n        TemplateLiteral: function(M) {\n            var segments = [];\n            for (var i = 0; i < M.quasis.length; i++) {\n                segments.push(from_moz(M.quasis[i]));\n                if (M.expressions[i]) {\n                    segments.push(from_moz(M.expressions[i]));\n                }\n            }\n            return new AST_TemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                segments: segments\n            });\n        },\n        TaggedTemplateExpression: function(M) {\n            return new AST_PrefixedTemplateString({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                template_string: from_moz(M.quasi),\n                prefix: from_moz(M.tag)\n            });\n        },\n        FunctionDeclaration: function(M) {\n            return new AST_Defun({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n        FunctionExpression: function(M) {\n            return new AST_Function({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                name: from_moz(M.id),\n                argnames: M.params.map(from_moz),\n                is_generator: M.generator,\n                async: M.async,\n                body: normalize_directives(from_moz(M.body).body)\n            });\n        },\n        ArrowFunctionExpression: function(M) {\n            const body = M.body.type === \"BlockStatement\"\n                ? from_moz(M.body).body\n                : [make_node(AST_Return, {}, { value: from_moz(M.body) })];\n            return new AST_Arrow({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                argnames: M.params.map(from_moz),\n                body,\n                async: M.async,\n            });\n        },\n        ExpressionStatement: function(M) {\n            return new AST_SimpleStatement({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                body: from_moz(M.expression)\n            });\n        },\n        TryStatement: function(M) {\n            var handlers = M.handlers || [M.handler];\n            if (handlers.length > 1 || M.guardedHandlers && M.guardedHandlers.length) {\n                throw new Error(\"Multiple catch clauses are not supported.\");\n            }\n            return new AST_Try({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                body     : from_moz(M.block).body,\n                bcatch   : from_moz(handlers[0]),\n                bfinally : M.finalizer ? new AST_Finally(from_moz(M.finalizer)) : null\n            });\n        },\n        Property: function(M) {\n            var key = M.key;\n            var args = {\n                start    : my_start_token(key || M.value),\n                end      : my_end_token(M.value),\n                key      : key.type == \"Identifier\" ? key.name : key.value,\n                value    : from_moz(M.value)\n            };\n            if (M.computed) {\n                args.key = from_moz(M.key);\n            }\n            if (M.method) {\n                args.is_generator = M.value.generator;\n                args.async = M.value.async;\n                if (!M.computed) {\n                    args.key = new AST_SymbolMethod({ name: args.key });\n                } else {\n                    args.key = from_moz(M.key);\n                }\n                return new AST_ConciseMethod(args);\n            }\n            if (M.kind == \"init\") {\n                if (key.type != \"Identifier\" && key.type != \"Literal\") {\n                    args.key = from_moz(key);\n                }\n                return new AST_ObjectKeyVal(args);\n            }\n            if (typeof args.key === \"string\" || typeof args.key === \"number\") {\n                args.key = new AST_SymbolMethod({\n                    name: args.key\n                });\n            }\n            args.value = new AST_Accessor(args.value);\n            if (M.kind == \"get\") return new AST_ObjectGetter(args);\n            if (M.kind == \"set\") return new AST_ObjectSetter(args);\n            if (M.kind == \"method\") {\n                args.async = M.value.async;\n                args.is_generator = M.value.generator;\n                args.quote = M.computed ? \"\\\"\" : null;\n                return new AST_ConciseMethod(args);\n            }\n        },\n        MethodDefinition: function(M) {\n            var args = {\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key      : M.computed ? from_moz(M.key) : new AST_SymbolMethod({ name: M.key.name || M.key.value }),\n                value    : from_moz(M.value),\n                static   : M.static,\n            };\n            if (M.kind == \"get\") {\n                return new AST_ObjectGetter(args);\n            }\n            if (M.kind == \"set\") {\n                return new AST_ObjectSetter(args);\n            }\n            args.is_generator = M.value.generator;\n            args.async = M.value.async;\n            return new AST_ConciseMethod(args);\n        },\n        FieldDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in FieldDefinition\");\n                key = from_moz(M.key);\n            }\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n        PropertyDefinition: function(M) {\n            let key;\n            if (M.computed) {\n                key = from_moz(M.key);\n            } else {\n                if (M.key.type !== \"Identifier\") throw new Error(\"Non-Identifier key in PropertyDefinition\");\n                key = from_moz(M.key);\n            }\n\n            return new AST_ClassProperty({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                key,\n                value    : from_moz(M.value),\n                static   : M.static,\n            });\n        },\n        ArrayExpression: function(M) {\n            return new AST_Array({\n                start    : my_start_token(M),\n                end      : my_end_token(M),\n                elements : M.elements.map(function(elem) {\n                    return elem === null ? new AST_Hole() : from_moz(elem);\n                })\n            });\n        },\n        ObjectExpression: function(M) {\n            return new AST_Object({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                properties : M.properties.map(function(prop) {\n                    if (prop.type === \"SpreadElement\") {\n                        return from_moz(prop);\n                    }\n                    prop.type = \"Property\";\n                    return from_moz(prop);\n                })\n            });\n        },\n        SequenceExpression: function(M) {\n            return new AST_Sequence({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expressions: M.expressions.map(from_moz)\n            });\n        },\n        MemberExpression: function(M) {\n            return new (M.computed ? AST_Sub : AST_Dot)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                property   : M.computed ? from_moz(M.property) : M.property.name,\n                expression : from_moz(M.object),\n                optional   : M.optional || false\n            });\n        },\n        ChainExpression: function(M) {\n            return new AST_Chain({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.expression)\n            });\n        },\n        SwitchCase: function(M) {\n            return new (M.test ? AST_Case : AST_Default)({\n                start      : my_start_token(M),\n                end        : my_end_token(M),\n                expression : from_moz(M.test),\n                body       : M.consequent.map(from_moz)\n            });\n        },\n        VariableDeclaration: function(M) {\n            return new (M.kind === \"const\" ? AST_Const :\n                        M.kind === \"let\" ? AST_Let : AST_Var)({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                definitions : M.declarations.map(from_moz)\n            });\n        },\n\n        ImportDeclaration: function(M) {\n            var imported_name = null;\n            var imported_names = null;\n            M.specifiers.forEach(function (specifier) {\n                if (specifier.type === \"ImportSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(new AST_NameMapping({\n                        start: my_start_token(specifier),\n                        end: my_end_token(specifier),\n                        foreign_name: from_moz(specifier.imported),\n                        name: from_moz(specifier.local)\n                    }));\n                } else if (specifier.type === \"ImportDefaultSpecifier\") {\n                    imported_name = from_moz(specifier.local);\n                } else if (specifier.type === \"ImportNamespaceSpecifier\") {\n                    if (!imported_names) { imported_names = []; }\n                    imported_names.push(new AST_NameMapping({\n                        start: my_start_token(specifier),\n                        end: my_end_token(specifier),\n                        foreign_name: new AST_SymbolImportForeign({ name: \"*\" }),\n                        name: from_moz(specifier.local)\n                    }));\n                }\n            });\n            return new AST_Import({\n                start       : my_start_token(M),\n                end         : my_end_token(M),\n                imported_name: imported_name,\n                imported_names : imported_names,\n                module_name : from_moz(M.source)\n            });\n        },\n        ExportAllDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_names: [\n                    new AST_NameMapping({\n                        name: new AST_SymbolExportForeign({ name: \"*\" }),\n                        foreign_name: new AST_SymbolExportForeign({ name: \"*\" })\n                    })\n                ],\n                module_name: from_moz(M.source)\n            });\n        },\n        ExportNamedDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_definition: from_moz(M.declaration),\n                exported_names: M.specifiers && M.specifiers.length ? M.specifiers.map(function (specifier) {\n                    return new AST_NameMapping({\n                        foreign_name: from_moz(specifier.exported),\n                        name: from_moz(specifier.local)\n                    });\n                }) : null,\n                module_name: from_moz(M.source)\n            });\n        },\n        ExportDefaultDeclaration: function(M) {\n            return new AST_Export({\n                start: my_start_token(M),\n                end: my_end_token(M),\n                exported_value: from_moz(M.declaration),\n                is_default: true\n            });\n        },\n        Literal: function(M) {\n            var val = M.value, args = {\n                start  : my_start_token(M),\n                end    : my_end_token(M)\n            };\n            var rx = M.regex;\n            if (rx && rx.pattern) {\n                // RegExpLiteral as per ESTree AST spec\n                args.value = {\n                    source: rx.pattern,\n                    flags: rx.flags\n                };\n                return new AST_RegExp(args);\n            } else if (rx) {\n                // support legacy RegExp\n                const rx_source = M.raw || val;\n                const match = rx_source.match(/^\\/(.*)\\/(\\w*)$/);\n                if (!match) throw new Error(\"Invalid regex source \" + rx_source);\n                const [_, source, flags] = match;\n                args.value = { source, flags };\n                return new AST_RegExp(args);\n            }\n            if (val === null) return new AST_Null(args);\n            switch (typeof val) {\n              case \"string\":\n                args.value = val;\n                return new AST_String(args);\n              case \"number\":\n                args.value = val;\n                args.raw = M.raw || val.toString();\n                return new AST_Number(args);\n              case \"boolean\":\n                return new (val ? AST_True : AST_False)(args);\n            }\n        },\n        MetaProperty: function(M) {\n            if (M.meta.name === \"new\" && M.property.name === \"target\") {\n                return new AST_NewTarget({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            } else if (M.meta.name === \"import\" && M.property.name === \"meta\") {\n                return new AST_ImportMeta({\n                    start: my_start_token(M),\n                    end: my_end_token(M)\n                });\n            }\n        },\n        Identifier: function(M) {\n            var p = FROM_MOZ_STACK[FROM_MOZ_STACK.length - 2];\n            return new (  p.type == \"LabeledStatement\" ? AST_Label\n                        : p.type == \"VariableDeclarator\" && p.id === M ? (p.kind == \"const\" ? AST_SymbolConst : p.kind == \"let\" ? AST_SymbolLet : AST_SymbolVar)\n                        : /Import.*Specifier/.test(p.type) ? (p.local === M ? AST_SymbolImport : AST_SymbolImportForeign)\n                        : p.type == \"ExportSpecifier\" ? (p.local === M ? AST_SymbolExport : AST_SymbolExportForeign)\n                        : p.type == \"FunctionExpression\" ? (p.id === M ? AST_SymbolLambda : AST_SymbolFunarg)\n                        : p.type == \"FunctionDeclaration\" ? (p.id === M ? AST_SymbolDefun : AST_SymbolFunarg)\n                        : p.type == \"ArrowFunctionExpression\" ? (p.params.includes(M)) ? AST_SymbolFunarg : AST_SymbolRef\n                        : p.type == \"ClassExpression\" ? (p.id === M ? AST_SymbolClass : AST_SymbolRef)\n                        : p.type == \"Property\" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolMethod)\n                        : p.type == \"PropertyDefinition\" || p.type === \"FieldDefinition\" ? (p.key === M && p.computed || p.value === M ? AST_SymbolRef : AST_SymbolClassProperty)\n                        : p.type == \"ClassDeclaration\" ? (p.id === M ? AST_SymbolDefClass : AST_SymbolRef)\n                        : p.type == \"MethodDefinition\" ? (p.computed ? AST_SymbolRef : AST_SymbolMethod)\n                        : p.type == \"CatchClause\" ? AST_SymbolCatch\n                        : p.type == \"BreakStatement\" || p.type == \"ContinueStatement\" ? AST_LabelRef\n                        : AST_SymbolRef)({\n                            start : my_start_token(M),\n                            end   : my_end_token(M),\n                            name  : M.name\n                        });\n        },\n        BigIntLiteral(M) {\n            return new AST_BigInt({\n                start : my_start_token(M),\n                end   : my_end_token(M),\n                value : M.value\n            });\n        }\n    };\n\n    MOZ_TO_ME.UpdateExpression =\n    MOZ_TO_ME.UnaryExpression = function To_Moz_Unary(M) {\n        var prefix = \"prefix\" in M ? M.prefix\n            : M.type == \"UnaryExpression\" ? true : false;\n        return new (prefix ? AST_UnaryPrefix : AST_UnaryPostfix)({\n            start      : my_start_token(M),\n            end        : my_end_token(M),\n            operator   : M.operator,\n            expression : from_moz(M.argument)\n        });\n    };\n\n    MOZ_TO_ME.ClassDeclaration =\n    MOZ_TO_ME.ClassExpression = function From_Moz_Class(M) {\n        return new (M.type === \"ClassDeclaration\" ? AST_DefClass : AST_ClassExpression)({\n            start    : my_start_token(M),\n            end      : my_end_token(M),\n            name     : from_moz(M.id),\n            extends  : from_moz(M.superClass),\n            properties: M.body.body.map(from_moz)\n        });\n    };\n\n    map(\"EmptyStatement\", AST_EmptyStatement);\n    map(\"BlockStatement\", AST_BlockStatement, \"body@body\");\n    map(\"IfStatement\", AST_If, \"test>condition, consequent>body, alternate>alternative\");\n    map(\"LabeledStatement\", AST_LabeledStatement, \"label>label, body>body\");\n    map(\"BreakStatement\", AST_Break, \"label>label\");\n    map(\"ContinueStatement\", AST_Continue, \"label>label\");\n    map(\"WithStatement\", AST_With, \"object>expression, body>body\");\n    map(\"SwitchStatement\", AST_Switch, \"discriminant>expression, cases@body\");\n    map(\"ReturnStatement\", AST_Return, \"argument>value\");\n    map(\"ThrowStatement\", AST_Throw, \"argument>value\");\n    map(\"WhileStatement\", AST_While, \"test>condition, body>body\");\n    map(\"DoWhileStatement\", AST_Do, \"test>condition, body>body\");\n    map(\"ForStatement\", AST_For, \"init>init, test>condition, update>step, body>body\");\n    map(\"ForInStatement\", AST_ForIn, \"left>init, right>object, body>body\");\n    map(\"ForOfStatement\", AST_ForOf, \"left>init, right>object, body>body, await=await\");\n    map(\"AwaitExpression\", AST_Await, \"argument>expression\");\n    map(\"YieldExpression\", AST_Yield, \"argument>expression, delegate=is_star\");\n    map(\"DebuggerStatement\", AST_Debugger);\n    map(\"VariableDeclarator\", AST_VarDef, \"id>name, init>value\");\n    map(\"CatchClause\", AST_Catch, \"param>argname, body%body\");\n\n    map(\"ThisExpression\", AST_This);\n    map(\"Super\", AST_Super);\n    map(\"BinaryExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"LogicalExpression\", AST_Binary, \"operator=operator, left>left, right>right\");\n    map(\"AssignmentExpression\", AST_Assign, \"operator=operator, left>left, right>right\");\n    map(\"ConditionalExpression\", AST_Conditional, \"test>condition, consequent>consequent, alternate>alternative\");\n    map(\"NewExpression\", AST_New, \"callee>expression, arguments@args\");\n    map(\"CallExpression\", AST_Call, \"callee>expression, optional=optional, arguments@args\");\n\n    def_to_moz(AST_Toplevel, function To_Moz_Program(M) {\n        return to_moz_scope(\"Program\", M);\n    });\n\n    def_to_moz(AST_Expansion, function To_Moz_Spread(M) {\n        return {\n            type: to_moz_in_destructuring() ? \"RestElement\" : \"SpreadElement\",\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_PrefixedTemplateString, function To_Moz_TaggedTemplateExpression(M) {\n        return {\n            type: \"TaggedTemplateExpression\",\n            tag: to_moz(M.prefix),\n            quasi: to_moz(M.template_string)\n        };\n    });\n\n    def_to_moz(AST_TemplateString, function To_Moz_TemplateLiteral(M) {\n        var quasis = [];\n        var expressions = [];\n        for (var i = 0; i < M.segments.length; i++) {\n            if (i % 2 !== 0) {\n                expressions.push(to_moz(M.segments[i]));\n            } else {\n                quasis.push({\n                    type: \"TemplateElement\",\n                    value: {\n                        raw: M.segments[i].raw,\n                        cooked: M.segments[i].value\n                    },\n                    tail: i === M.segments.length - 1\n                });\n            }\n        }\n        return {\n            type: \"TemplateLiteral\",\n            quasis: quasis,\n            expressions: expressions\n        };\n    });\n\n    def_to_moz(AST_Defun, function To_Moz_FunctionDeclaration(M) {\n        return {\n            type: \"FunctionDeclaration\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            generator: M.is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Function, function To_Moz_FunctionExpression(M, parent) {\n        var is_generator = parent.is_generator !== undefined ?\n            parent.is_generator : M.is_generator;\n        return {\n            type: \"FunctionExpression\",\n            id: to_moz(M.name),\n            params: M.argnames.map(to_moz),\n            generator: is_generator,\n            async: M.async,\n            body: to_moz_scope(\"BlockStatement\", M)\n        };\n    });\n\n    def_to_moz(AST_Arrow, function To_Moz_ArrowFunctionExpression(M) {\n        var body = {\n            type: \"BlockStatement\",\n            body: M.body.map(to_moz)\n        };\n        return {\n            type: \"ArrowFunctionExpression\",\n            params: M.argnames.map(to_moz),\n            async: M.async,\n            body: body\n        };\n    });\n\n    def_to_moz(AST_Destructuring, function To_Moz_ObjectPattern(M) {\n        if (M.is_array) {\n            return {\n                type: \"ArrayPattern\",\n                elements: M.names.map(to_moz)\n            };\n        }\n        return {\n            type: \"ObjectPattern\",\n            properties: M.names.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Directive, function To_Moz_Directive(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: {\n                type: \"Literal\",\n                value: M.value,\n                raw: M.print_to_string()\n            },\n            directive: M.value\n        };\n    });\n\n    def_to_moz(AST_SimpleStatement, function To_Moz_ExpressionStatement(M) {\n        return {\n            type: \"ExpressionStatement\",\n            expression: to_moz(M.body)\n        };\n    });\n\n    def_to_moz(AST_SwitchBranch, function To_Moz_SwitchCase(M) {\n        return {\n            type: \"SwitchCase\",\n            test: to_moz(M.expression),\n            consequent: M.body.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Try, function To_Moz_TryStatement(M) {\n        return {\n            type: \"TryStatement\",\n            block: to_moz_block(M),\n            handler: to_moz(M.bcatch),\n            guardedHandlers: [],\n            finalizer: to_moz(M.bfinally)\n        };\n    });\n\n    def_to_moz(AST_Catch, function To_Moz_CatchClause(M) {\n        return {\n            type: \"CatchClause\",\n            param: to_moz(M.argname),\n            guard: null,\n            body: to_moz_block(M)\n        };\n    });\n\n    def_to_moz(AST_Definitions, function To_Moz_VariableDeclaration(M) {\n        return {\n            type: \"VariableDeclaration\",\n            kind:\n                M instanceof AST_Const ? \"const\" :\n                M instanceof AST_Let ? \"let\" : \"var\",\n            declarations: M.definitions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Export, function To_Moz_ExportDeclaration(M) {\n        if (M.exported_names) {\n            if (M.exported_names[0].name.name === \"*\") {\n                return {\n                    type: \"ExportAllDeclaration\",\n                    source: to_moz(M.module_name)\n                };\n            }\n            return {\n                type: \"ExportNamedDeclaration\",\n                specifiers: M.exported_names.map(function (name_mapping) {\n                    return {\n                        type: \"ExportSpecifier\",\n                        exported: to_moz(name_mapping.foreign_name),\n                        local: to_moz(name_mapping.name)\n                    };\n                }),\n                declaration: to_moz(M.exported_definition),\n                source: to_moz(M.module_name)\n            };\n        }\n        return {\n            type: M.is_default ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\",\n            declaration: to_moz(M.exported_value || M.exported_definition)\n        };\n    });\n\n    def_to_moz(AST_Import, function To_Moz_ImportDeclaration(M) {\n        var specifiers = [];\n        if (M.imported_name) {\n            specifiers.push({\n                type: \"ImportDefaultSpecifier\",\n                local: to_moz(M.imported_name)\n            });\n        }\n        if (M.imported_names && M.imported_names[0].foreign_name.name === \"*\") {\n            specifiers.push({\n                type: \"ImportNamespaceSpecifier\",\n                local: to_moz(M.imported_names[0].name)\n            });\n        } else if (M.imported_names) {\n            M.imported_names.forEach(function(name_mapping) {\n                specifiers.push({\n                    type: \"ImportSpecifier\",\n                    local: to_moz(name_mapping.name),\n                    imported: to_moz(name_mapping.foreign_name)\n                });\n            });\n        }\n        return {\n            type: \"ImportDeclaration\",\n            specifiers: specifiers,\n            source: to_moz(M.module_name)\n        };\n    });\n\n    def_to_moz(AST_ImportMeta, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"import\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"meta\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Sequence, function To_Moz_SequenceExpression(M) {\n        return {\n            type: \"SequenceExpression\",\n            expressions: M.expressions.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_DotHash, function To_Moz_PrivateMemberExpression(M) {\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: false,\n            property: {\n                type: \"PrivateIdentifier\",\n                name: M.property\n            },\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_PropAccess, function To_Moz_MemberExpression(M) {\n        var isComputed = M instanceof AST_Sub;\n        return {\n            type: \"MemberExpression\",\n            object: to_moz(M.expression),\n            computed: isComputed,\n            property: isComputed ? to_moz(M.property) : {type: \"Identifier\", name: M.property},\n            optional: M.optional\n        };\n    });\n\n    def_to_moz(AST_Chain, function To_Moz_ChainExpression(M) {\n        return {\n            type: \"ChainExpression\",\n            expression: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Unary, function To_Moz_Unary(M) {\n        return {\n            type: M.operator == \"++\" || M.operator == \"--\" ? \"UpdateExpression\" : \"UnaryExpression\",\n            operator: M.operator,\n            prefix: M instanceof AST_UnaryPrefix,\n            argument: to_moz(M.expression)\n        };\n    });\n\n    def_to_moz(AST_Binary, function To_Moz_BinaryExpression(M) {\n        if (M.operator == \"=\" && to_moz_in_destructuring()) {\n            return {\n                type: \"AssignmentPattern\",\n                left: to_moz(M.left),\n                right: to_moz(M.right)\n            };\n        }\n\n        const type = M.operator == \"&&\" || M.operator == \"||\" || M.operator === \"??\"\n            ? \"LogicalExpression\"\n            : \"BinaryExpression\";\n\n        return {\n            type,\n            left: to_moz(M.left),\n            operator: M.operator,\n            right: to_moz(M.right)\n        };\n    });\n\n    def_to_moz(AST_Array, function To_Moz_ArrayExpression(M) {\n        return {\n            type: \"ArrayExpression\",\n            elements: M.elements.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_Object, function To_Moz_ObjectExpression(M) {\n        return {\n            type: \"ObjectExpression\",\n            properties: M.properties.map(to_moz)\n        };\n    });\n\n    def_to_moz(AST_ObjectProperty, function To_Moz_Property(M, parent) {\n        var key = M.key instanceof AST_Node ? to_moz(M.key) : {\n            type: \"Identifier\",\n            value: M.key\n        };\n        if (typeof M.key === \"number\") {\n            key = {\n                type: \"Literal\",\n                value: Number(M.key)\n            };\n        }\n        if (typeof M.key === \"string\") {\n            key = {\n                type: \"Identifier\",\n                name: M.key\n            };\n        }\n        var kind;\n        var string_or_num = typeof M.key === \"string\" || typeof M.key === \"number\";\n        var computed = string_or_num ? false : !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef;\n        if (M instanceof AST_ObjectKeyVal) {\n            kind = \"init\";\n            computed = !string_or_num;\n        } else\n        if (M instanceof AST_ObjectGetter) {\n            kind = \"get\";\n        } else\n        if (M instanceof AST_ObjectSetter) {\n            kind = \"set\";\n        }\n        if (M instanceof AST_PrivateGetter || M instanceof AST_PrivateSetter) {\n            const kind = M instanceof AST_PrivateGetter ? \"get\" : \"set\";\n            return {\n                type: \"MethodDefinition\",\n                computed: false,\n                kind: kind,\n                static: M.static,\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value)\n            };\n        }\n        if (M instanceof AST_ClassPrivateProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key: {\n                    type: \"PrivateIdentifier\",\n                    name: M.key.name\n                },\n                value: to_moz(M.value),\n                computed: false,\n                static: M.static\n            };\n        }\n        if (M instanceof AST_ClassProperty) {\n            return {\n                type: \"PropertyDefinition\",\n                key,\n                value: to_moz(M.value),\n                computed,\n                static: M.static\n            };\n        }\n        if (parent instanceof AST_Class) {\n            return {\n                type: \"MethodDefinition\",\n                computed: computed,\n                kind: kind,\n                static: M.static,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n        return {\n            type: \"Property\",\n            computed: computed,\n            kind: kind,\n            key: key,\n            value: to_moz(M.value)\n        };\n    });\n\n    def_to_moz(AST_ConciseMethod, function To_Moz_MethodDefinition(M, parent) {\n        if (parent instanceof AST_Object) {\n            return {\n                type: \"Property\",\n                computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n                kind: \"init\",\n                method: true,\n                shorthand: false,\n                key: to_moz(M.key),\n                value: to_moz(M.value)\n            };\n        }\n\n        const key = M instanceof AST_PrivateMethod\n            ? {\n                type: \"PrivateIdentifier\",\n                name: M.key.name\n            }\n            : to_moz(M.key);\n\n        return {\n            type: \"MethodDefinition\",\n            kind: M.key === \"constructor\" ? \"constructor\" : \"method\",\n            key,\n            value: to_moz(M.value),\n            computed: !(M.key instanceof AST_Symbol) || M.key instanceof AST_SymbolRef,\n            static: M.static,\n        };\n    });\n\n    def_to_moz(AST_Class, function To_Moz_Class(M) {\n        var type = M instanceof AST_ClassExpression ? \"ClassExpression\" : \"ClassDeclaration\";\n        return {\n            type: type,\n            superClass: to_moz(M.extends),\n            id: M.name ? to_moz(M.name) : null,\n            body: {\n                type: \"ClassBody\",\n                body: M.properties.map(to_moz)\n            }\n        };\n    });\n\n    def_to_moz(AST_NewTarget, function To_Moz_MetaProperty() {\n        return {\n            type: \"MetaProperty\",\n            meta: {\n                type: \"Identifier\",\n                name: \"new\"\n            },\n            property: {\n                type: \"Identifier\",\n                name: \"target\"\n            }\n        };\n    });\n\n    def_to_moz(AST_Symbol, function To_Moz_Identifier(M, parent) {\n        if (M instanceof AST_SymbolMethod && parent.quote) {\n            return {\n                type: \"Literal\",\n                value: M.name\n            };\n        }\n        var def = M.definition();\n        return {\n            type: \"Identifier\",\n            name: def ? def.mangled_name || def.name : M.name\n        };\n    });\n\n    def_to_moz(AST_RegExp, function To_Moz_RegExpLiteral(M) {\n        const pattern = M.value.source;\n        const flags = M.value.flags;\n        return {\n            type: \"Literal\",\n            value: null,\n            raw: M.print_to_string(),\n            regex: { pattern, flags }\n        };\n    });\n\n    def_to_moz(AST_Constant, function To_Moz_Literal(M) {\n        var value = M.value;\n        return {\n            type: \"Literal\",\n            value: value,\n            raw: M.raw || M.print_to_string()\n        };\n    });\n\n    def_to_moz(AST_Atom, function To_Moz_Atom(M) {\n        return {\n            type: \"Identifier\",\n            name: String(M.value)\n        };\n    });\n\n    def_to_moz(AST_BigInt, M => ({\n        type: \"BigIntLiteral\",\n        value: M.value\n    }));\n\n    AST_Boolean.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Null.DEFMETHOD(\"to_mozilla_ast\", AST_Constant.prototype.to_mozilla_ast);\n    AST_Hole.DEFMETHOD(\"to_mozilla_ast\", function To_Moz_ArrayHole() { return null; });\n\n    AST_Block.DEFMETHOD(\"to_mozilla_ast\", AST_BlockStatement.prototype.to_mozilla_ast);\n    AST_Lambda.DEFMETHOD(\"to_mozilla_ast\", AST_Function.prototype.to_mozilla_ast);\n\n    /* -----[ tools ]----- */\n\n    function my_start_token(moznode) {\n        var loc = moznode.loc, start = loc && loc.start;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            start && start.line || 0,\n            start && start.column || 0,\n            range ? range [0] : moznode.start,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function my_end_token(moznode) {\n        var loc = moznode.loc, end = loc && loc.end;\n        var range = moznode.range;\n        return new AST_Token(\n            \"\",\n            \"\",\n            end && end.line || 0,\n            end && end.column || 0,\n            range ? range [0] : moznode.end,\n            false,\n            [],\n            [],\n            loc && loc.source,\n        );\n    }\n\n    function map(moztype, mytype, propmap) {\n        var moz_to_me = \"function From_Moz_\" + moztype + \"(M){\\n\";\n        moz_to_me += \"return new U2.\" + mytype.name + \"({\\n\" +\n            \"start: my_start_token(M),\\n\" +\n            \"end: my_end_token(M)\";\n\n        var me_to_moz = \"function To_Moz_\" + moztype + \"(M){\\n\";\n        me_to_moz += \"return {\\n\" +\n            \"type: \" + JSON.stringify(moztype);\n\n        if (propmap) propmap.split(/\\s*,\\s*/).forEach(function(prop) {\n            var m = /([a-z0-9$_]+)([=@>%])([a-z0-9$_]+)/i.exec(prop);\n            if (!m) throw new Error(\"Can't understand property map: \" + prop);\n            var moz = m[1], how = m[2], my = m[3];\n            moz_to_me += \",\\n\" + my + \": \";\n            me_to_moz += \",\\n\" + moz + \": \";\n            switch (how) {\n                case \"@\":\n                    moz_to_me += \"M.\" + moz + \".map(from_moz)\";\n                    me_to_moz += \"M.\" +  my + \".map(to_moz)\";\n                    break;\n                case \">\":\n                    moz_to_me += \"from_moz(M.\" + moz + \")\";\n                    me_to_moz += \"to_moz(M.\" + my + \")\";\n                    break;\n                case \"=\":\n                    moz_to_me += \"M.\" + moz;\n                    me_to_moz += \"M.\" + my;\n                    break;\n                case \"%\":\n                    moz_to_me += \"from_moz(M.\" + moz + \").body\";\n                    me_to_moz += \"to_moz_block(M)\";\n                    break;\n                default:\n                    throw new Error(\"Can't understand operator in propmap: \" + prop);\n            }\n        });\n\n        moz_to_me += \"\\n})\\n}\";\n        me_to_moz += \"\\n}\\n}\";\n\n        moz_to_me = new Function(\"U2\", \"my_start_token\", \"my_end_token\", \"from_moz\", \"return(\" + moz_to_me + \")\")(\n            ast, my_start_token, my_end_token, from_moz\n        );\n        me_to_moz = new Function(\"to_moz\", \"to_moz_block\", \"to_moz_scope\", \"return(\" + me_to_moz + \")\")(\n            to_moz, to_moz_block, to_moz_scope\n        );\n        MOZ_TO_ME[moztype] = moz_to_me;\n        def_to_moz(mytype, me_to_moz);\n    }\n\n    var FROM_MOZ_STACK = null;\n\n    function from_moz(node) {\n        FROM_MOZ_STACK.push(node);\n        var ret = node != null ? MOZ_TO_ME[node.type](node) : null;\n        FROM_MOZ_STACK.pop();\n        return ret;\n    }\n\n    AST_Node.from_mozilla_ast = function(node) {\n        var save_stack = FROM_MOZ_STACK;\n        FROM_MOZ_STACK = [];\n        var ast = from_moz(node);\n        FROM_MOZ_STACK = save_stack;\n        return ast;\n    };\n\n    function set_moz_loc(mynode, moznode) {\n        var start = mynode.start;\n        var end = mynode.end;\n        if (!(start && end)) {\n            return moznode;\n        }\n        if (start.pos != null && end.endpos != null) {\n            moznode.range = [start.pos, end.endpos];\n        }\n        if (start.line) {\n            moznode.loc = {\n                start: {line: start.line, column: start.col},\n                end: end.endline ? {line: end.endline, column: end.endcol} : null\n            };\n            if (start.file) {\n                moznode.loc.source = start.file;\n            }\n        }\n        return moznode;\n    }\n\n    function def_to_moz(mytype, handler) {\n        mytype.DEFMETHOD(\"to_mozilla_ast\", function(parent) {\n            return set_moz_loc(this, handler(this, parent));\n        });\n    }\n\n    var TO_MOZ_STACK = null;\n\n    function to_moz(node) {\n        if (TO_MOZ_STACK === null) { TO_MOZ_STACK = []; }\n        TO_MOZ_STACK.push(node);\n        var ast = node != null ? node.to_mozilla_ast(TO_MOZ_STACK[TO_MOZ_STACK.length - 2]) : null;\n        TO_MOZ_STACK.pop();\n        if (TO_MOZ_STACK.length === 0) { TO_MOZ_STACK = null; }\n        return ast;\n    }\n\n    function to_moz_in_destructuring() {\n        var i = TO_MOZ_STACK.length;\n        while (i--) {\n            if (TO_MOZ_STACK[i] instanceof AST_Destructuring) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function to_moz_block(node) {\n        return {\n            type: \"BlockStatement\",\n            body: node.body.map(to_moz)\n        };\n    }\n\n    function to_moz_scope(type, node) {\n        var body = node.body.map(to_moz);\n        if (node.body[0] instanceof AST_SimpleStatement && node.body[0].body instanceof AST_String) {\n            body.unshift(to_moz(new AST_EmptyStatement(node.body[0])));\n        }\n        return {\n            type: type,\n            body: body\n        };\n    }\n})();\n"]},"metadata":{},"sourceType":"module"}