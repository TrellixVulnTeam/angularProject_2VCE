{"ast":null,"code":"\"use strict\";\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncDelegateHost = exports.SynchronousDelegateExpectedException = void 0;\n\nvar exception_1 = require(\"../../exception\");\n\nvar SynchronousDelegateExpectedException = /*#__PURE__*/function (_exception_1$BaseExce) {\n  _inherits(SynchronousDelegateExpectedException, _exception_1$BaseExce);\n\n  var _super = _createSuper(SynchronousDelegateExpectedException);\n\n  function SynchronousDelegateExpectedException() {\n    _classCallCheck(this, SynchronousDelegateExpectedException);\n\n    return _super.call(this, \"Expected a synchronous delegate but got an asynchronous one.\");\n  }\n\n  return SynchronousDelegateExpectedException;\n}(exception_1.BaseException);\n\nexports.SynchronousDelegateExpectedException = SynchronousDelegateExpectedException;\n/**\n * Implement a synchronous-only host interface (remove the Observable parts).\n */\n\nvar SyncDelegateHost = /*#__PURE__*/function () {\n  function SyncDelegateHost(_delegate) {\n    _classCallCheck(this, SyncDelegateHost);\n\n    this._delegate = _delegate;\n\n    if (!_delegate.capabilities.synchronous) {\n      throw new SynchronousDelegateExpectedException();\n    }\n  }\n\n  _createClass(SyncDelegateHost, [{\n    key: \"_doSyncCall\",\n    value: function _doSyncCall(observable) {\n      var completed = false;\n      var result = undefined;\n      var errorResult = undefined; // Perf note: this is not using an observer object to avoid a performance penalty in RxJS.\n      // See https://github.com/ReactiveX/rxjs/pull/5646 for details.\n\n      observable.subscribe(function (x) {\n        return result = x;\n      }, function (err) {\n        return errorResult = err;\n      }, function () {\n        return completed = true;\n      });\n\n      if (errorResult !== undefined) {\n        throw errorResult;\n      }\n\n      if (!completed) {\n        throw new SynchronousDelegateExpectedException();\n      } // The non-null operation is to work around `void` type. We don't allow to return undefined\n      // but ResultT could be void, which is undefined in JavaScript, so this doesn't change the\n      // behaviour.\n      // tslint:disable-next-line:no-non-null-assertion\n\n\n      return result;\n    }\n  }, {\n    key: \"capabilities\",\n    get: function get() {\n      return this._delegate.capabilities;\n    }\n  }, {\n    key: \"delegate\",\n    get: function get() {\n      return this._delegate;\n    }\n  }, {\n    key: \"write\",\n    value: function write(path, content) {\n      return this._doSyncCall(this._delegate.write(path, content));\n    }\n  }, {\n    key: \"read\",\n    value: function read(path) {\n      return this._doSyncCall(this._delegate.read(path));\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(path) {\n      return this._doSyncCall(this._delegate.delete(path));\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(from, to) {\n      return this._doSyncCall(this._delegate.rename(from, to));\n    }\n  }, {\n    key: \"list\",\n    value: function list(path) {\n      return this._doSyncCall(this._delegate.list(path));\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(path) {\n      return this._doSyncCall(this._delegate.exists(path));\n    }\n  }, {\n    key: \"isDirectory\",\n    value: function isDirectory(path) {\n      return this._doSyncCall(this._delegate.isDirectory(path));\n    }\n  }, {\n    key: \"isFile\",\n    value: function isFile(path) {\n      return this._doSyncCall(this._delegate.isFile(path));\n    } // Some hosts may not support stat.\n\n  }, {\n    key: \"stat\",\n    value: function stat(path) {\n      var result = this._delegate.stat(path);\n\n      if (result) {\n        return this._doSyncCall(result);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(path, options) {\n      return this._delegate.watch(path, options);\n    }\n  }]);\n\n  return SyncDelegateHost;\n}();\n\nexports.SyncDelegateHost = SyncDelegateHost;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/virtual-fs/host/sync.js"],"names":["Object","defineProperty","exports","value","SyncDelegateHost","SynchronousDelegateExpectedException","exception_1","require","BaseException","_delegate","capabilities","synchronous","observable","completed","result","undefined","errorResult","subscribe","x","err","path","content","_doSyncCall","write","read","delete","from","to","rename","list","exists","isDirectory","isFile","stat","options","watch"],"mappings":"AAAA;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,gBAAR,GAA2BF,OAAO,CAACG,oCAAR,GAA+C,KAAK,CAA/E;;AACA,IAAMC,WAAW,GAAGC,OAAO,CAAC,iBAAD,CAA3B;;IACMF,oC;;;;;AACF,kDAAc;AAAA;;AAAA;AAA0E;;;EADzCC,WAAW,CAACE,a;;AAG/DN,OAAO,CAACG,oCAAR,GAA+CA,oCAA/C;AACA;AACA;AACA;;IACMD,gB;AACF,4BAAYK,SAAZ,EAAuB;AAAA;;AACnB,SAAKA,SAAL,GAAiBA,SAAjB;;AACA,QAAI,CAACA,SAAS,CAACC,YAAV,CAAuBC,WAA5B,EAAyC;AACrC,YAAM,IAAIN,oCAAJ,EAAN;AACH;AACJ;;;;WACD,qBAAYO,UAAZ,EAAwB;AACpB,UAAIC,SAAS,GAAG,KAAhB;AACA,UAAIC,MAAM,GAAGC,SAAb;AACA,UAAIC,WAAW,GAAGD,SAAlB,CAHoB,CAIpB;AACA;;AACAH,MAAAA,UAAU,CAACK,SAAX,CAAqB,UAACC,CAAD;AAAA,eAAOJ,MAAM,GAAGI,CAAhB;AAAA,OAArB,EAAwC,UAACC,GAAD;AAAA,eAASH,WAAW,GAAGG,GAAvB;AAAA,OAAxC,EAAoE;AAAA,eAAMN,SAAS,GAAG,IAAlB;AAAA,OAApE;;AACA,UAAIG,WAAW,KAAKD,SAApB,EAA+B;AAC3B,cAAMC,WAAN;AACH;;AACD,UAAI,CAACH,SAAL,EAAgB;AACZ,cAAM,IAAIR,oCAAJ,EAAN;AACH,OAZmB,CAapB;AACA;AACA;AACA;;;AACA,aAAOS,MAAP;AACH;;;SACD,eAAmB;AACf,aAAO,KAAKL,SAAL,CAAeC,YAAtB;AACH;;;SACD,eAAe;AACX,aAAO,KAAKD,SAAZ;AACH;;;WACD,eAAMW,IAAN,EAAYC,OAAZ,EAAqB;AACjB,aAAO,KAAKC,WAAL,CAAiB,KAAKb,SAAL,CAAec,KAAf,CAAqBH,IAArB,EAA2BC,OAA3B,CAAjB,CAAP;AACH;;;WACD,cAAKD,IAAL,EAAW;AACP,aAAO,KAAKE,WAAL,CAAiB,KAAKb,SAAL,CAAee,IAAf,CAAoBJ,IAApB,CAAjB,CAAP;AACH;;;WACD,iBAAOA,IAAP,EAAa;AACT,aAAO,KAAKE,WAAL,CAAiB,KAAKb,SAAL,CAAegB,MAAf,CAAsBL,IAAtB,CAAjB,CAAP;AACH;;;WACD,gBAAOM,IAAP,EAAaC,EAAb,EAAiB;AACb,aAAO,KAAKL,WAAL,CAAiB,KAAKb,SAAL,CAAemB,MAAf,CAAsBF,IAAtB,EAA4BC,EAA5B,CAAjB,CAAP;AACH;;;WACD,cAAKP,IAAL,EAAW;AACP,aAAO,KAAKE,WAAL,CAAiB,KAAKb,SAAL,CAAeoB,IAAf,CAAoBT,IAApB,CAAjB,CAAP;AACH;;;WACD,gBAAOA,IAAP,EAAa;AACT,aAAO,KAAKE,WAAL,CAAiB,KAAKb,SAAL,CAAeqB,MAAf,CAAsBV,IAAtB,CAAjB,CAAP;AACH;;;WACD,qBAAYA,IAAZ,EAAkB;AACd,aAAO,KAAKE,WAAL,CAAiB,KAAKb,SAAL,CAAesB,WAAf,CAA2BX,IAA3B,CAAjB,CAAP;AACH;;;WACD,gBAAOA,IAAP,EAAa;AACT,aAAO,KAAKE,WAAL,CAAiB,KAAKb,SAAL,CAAeuB,MAAf,CAAsBZ,IAAtB,CAAjB,CAAP;AACH,K,CACD;;;;WACA,cAAKA,IAAL,EAAW;AACP,UAAMN,MAAM,GAAG,KAAKL,SAAL,CAAewB,IAAf,CAAoBb,IAApB,CAAf;;AACA,UAAIN,MAAJ,EAAY;AACR,eAAO,KAAKQ,WAAL,CAAiBR,MAAjB,CAAP;AACH,OAFD,MAGK;AACD,eAAO,IAAP;AACH;AACJ;;;WACD,eAAMM,IAAN,EAAYc,OAAZ,EAAqB;AACjB,aAAO,KAAKzB,SAAL,CAAe0B,KAAf,CAAqBf,IAArB,EAA2Bc,OAA3B,CAAP;AACH;;;;;;AAELhC,OAAO,CAACE,gBAAR,GAA2BA,gBAA3B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SyncDelegateHost = exports.SynchronousDelegateExpectedException = void 0;\nconst exception_1 = require(\"../../exception\");\nclass SynchronousDelegateExpectedException extends exception_1.BaseException {\n    constructor() { super(`Expected a synchronous delegate but got an asynchronous one.`); }\n}\nexports.SynchronousDelegateExpectedException = SynchronousDelegateExpectedException;\n/**\n * Implement a synchronous-only host interface (remove the Observable parts).\n */\nclass SyncDelegateHost {\n    constructor(_delegate) {\n        this._delegate = _delegate;\n        if (!_delegate.capabilities.synchronous) {\n            throw new SynchronousDelegateExpectedException();\n        }\n    }\n    _doSyncCall(observable) {\n        let completed = false;\n        let result = undefined;\n        let errorResult = undefined;\n        // Perf note: this is not using an observer object to avoid a performance penalty in RxJS.\n        // See https://github.com/ReactiveX/rxjs/pull/5646 for details.\n        observable.subscribe((x) => result = x, (err) => errorResult = err, () => completed = true);\n        if (errorResult !== undefined) {\n            throw errorResult;\n        }\n        if (!completed) {\n            throw new SynchronousDelegateExpectedException();\n        }\n        // The non-null operation is to work around `void` type. We don't allow to return undefined\n        // but ResultT could be void, which is undefined in JavaScript, so this doesn't change the\n        // behaviour.\n        // tslint:disable-next-line:no-non-null-assertion\n        return result;\n    }\n    get capabilities() {\n        return this._delegate.capabilities;\n    }\n    get delegate() {\n        return this._delegate;\n    }\n    write(path, content) {\n        return this._doSyncCall(this._delegate.write(path, content));\n    }\n    read(path) {\n        return this._doSyncCall(this._delegate.read(path));\n    }\n    delete(path) {\n        return this._doSyncCall(this._delegate.delete(path));\n    }\n    rename(from, to) {\n        return this._doSyncCall(this._delegate.rename(from, to));\n    }\n    list(path) {\n        return this._doSyncCall(this._delegate.list(path));\n    }\n    exists(path) {\n        return this._doSyncCall(this._delegate.exists(path));\n    }\n    isDirectory(path) {\n        return this._doSyncCall(this._delegate.isDirectory(path));\n    }\n    isFile(path) {\n        return this._doSyncCall(this._delegate.isFile(path));\n    }\n    // Some hosts may not support stat.\n    stat(path) {\n        const result = this._delegate.stat(path);\n        if (result) {\n            return this._doSyncCall(result);\n        }\n        else {\n            return null;\n        }\n    }\n    watch(path, options) {\n        return this._delegate.watch(path, options);\n    }\n}\nexports.SyncDelegateHost = SyncDelegateHost;\n"]},"metadata":{},"sourceType":"script"}