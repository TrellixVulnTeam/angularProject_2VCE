{"ast":null,"code":"function _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar path = _interopDefault(require('path'));\n\nvar WORKER_PLUGIN_SYMBOL = _interopDefault(require('./symbol.js'));\n/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\n\nvar ParserHelpers;\n\ntry {\n  ParserHelpers = require('webpack/lib/javascript/JavascriptParserHelpers'); // Webpack 5\n} catch (e) {}\n\nParserHelpers = ParserHelpers || require('webpack/lib/ParserHelpers'); // Webpack 4\n\nvar HarmonyImportSpecifierDependency;\n\ntry {\n  HarmonyImportSpecifierDependency = require('webpack/lib/dependencies/HarmonyImportSpecifierDependency');\n} catch (e) {}\n\nvar NAME = 'WorkerPlugin';\nvar workerLoader = path.resolve(__dirname, 'loader.js');\n\nvar WorkerPlugin = function WorkerPlugin(options) {\n  this.options = options || {};\n  this[WORKER_PLUGIN_SYMBOL] = true;\n};\n\nWorkerPlugin.prototype.apply = function apply(compiler) {\n  var this$1 = this;\n  compiler.hooks.normalModuleFactory.tap(NAME, function (factory) {\n    var workerId = 0;\n    factory.hooks.parser.for('javascript/auto').tap(NAME, function (parser) {\n      return parse(parser, false);\n    });\n    factory.hooks.parser.for('javascript/dynamic').tap(NAME, function (parser) {\n      return parse(parser, false);\n    });\n    factory.hooks.parser.for('javascript/esm').tap(NAME, function (parser) {\n      return parse(parser, true);\n    });\n\n    var parse = function parse(parser, esModule) {\n      var handleWorker = function handleWorker(workerTypeString) {\n        return function (expr) {\n          var dep = parser.evaluateExpression(expr.arguments[0]);\n          var optsExpr = expr.arguments[1];\n          var hasInitOptions = false;\n          var typeModuleExpr;\n          var opts;\n\n          if (optsExpr) {\n            opts = {};\n\n            for (var i = optsExpr.properties.length; i--;) {\n              var prop = optsExpr.properties[i];\n\n              if (prop.type === 'Property' && !prop.computed && !prop.shorthand && !prop.method) {\n                opts[prop.key.name] = parser.evaluateExpression(prop.value).string;\n\n                if (prop.key.name === 'type') {\n                  typeModuleExpr = prop;\n                } else {\n                  hasInitOptions = true;\n                }\n              }\n            }\n          }\n\n          if (!opts || opts.type !== 'module') {\n            // If an unknown type value is passed, it's probably an error and we can warn the developer:\n            if (opts && opts.type !== 'classic') {\n              parser.state.module.warnings.push({\n                message: \"new \" + workerTypeString + \"() will only be bundled if passed options that include { type: 'module' }.\" + (opts ? \"\\n  Received: new \" + workerTypeString + \"()(\" + JSON.stringify(dep.string) + \", \" + JSON.stringify(opts) + \")\" : '')\n              });\n            }\n\n            return false;\n          }\n\n          if (!dep.isString()) {\n            parser.state.module.warnings.push({\n              message: \"new \" + workerTypeString + \"(\\\"..\\\", { type: \\\"module\\\" }) will only be bundled if passed a String.\"\n            });\n            return false;\n          }\n\n          var isStrictModule = esModule || parser.state.buildMeta && parser.state.buildMeta.strictHarmonyModule; // Querystring-encoded loader prefix (faster/cleaner than JSON parameters):\n\n          var loaderRequest = workerLoader + \"?name=\" + encodeURIComponent(opts.name || workerId) + (isStrictModule ? '&esModule' : '') + \"!\" + dep.string; // Unique ID for the worker URL variable:\n\n          var id = \"__webpack__worker__\" + workerId++; // .mjs / strict harmony mode\n\n          if (isStrictModule) {\n            var module = parser.state.current;\n\n            if (!HarmonyImportSpecifierDependency) {\n              throw Error(NAME + \": Failed to import HarmonyImportSpecifierDependency. This plugin requires Webpack version 4.\");\n            } // This is essentially the internals of \"prepend an import to the module\":\n\n\n            var dependency = new HarmonyImportSpecifierDependency(loaderRequest, module, workerId, // no idea if this actually needs to be unique. 0 seemed to work. safety first?\n            parser.scope, 'default', id, // this never gets used\n            expr.arguments[0].range, // replace the usage/callsite with the generated reference: X_IMPORT_0[\"default\"]\n            true); // avoid serializing the full loader filepath: (this gets prepended to unique suffix)\n\n            dependency.userRequest = dep.string;\n            module.addDependency(dependency);\n          } else {\n            // For CommonJS/Auto\n            var req = \"require(\" + JSON.stringify(loaderRequest) + \")\";\n            ParserHelpers.toConstantDependency(parser, id)(expr.arguments[0]);\n            ParserHelpers.addParsedVariableToModule(parser, id, req);\n          } // update/remove the WorkerInitOptions argument\n\n\n          if (this$1.options.workerType) {\n            ParserHelpers.toConstantDependency(parser, JSON.stringify(this$1.options.workerType))(typeModuleExpr.value);\n          } else if (this$1.options.preserveTypeModule !== true) {\n            if (hasInitOptions) {\n              // there might be other options - to avoid trailing comma issues, replace the type value with undefined but *leave the key*:\n              ParserHelpers.toConstantDependency(parser, 'type:undefined')(typeModuleExpr);\n            } else {\n              // there was only a `{type}` option, we replace the opts argument with undefined to avoid trailing comma issues:\n              ParserHelpers.toConstantDependency(parser, 'undefined')(optsExpr);\n            }\n          }\n\n          return true;\n        };\n      };\n\n      if (this$1.options.worker !== false) {\n        parser.hooks.new.for('Worker').tap(NAME, handleWorker('Worker'));\n      }\n\n      if (this$1.options.sharedWorker) {\n        parser.hooks.new.for('SharedWorker').tap(NAME, handleWorker('SharedWorker'));\n      }\n    };\n  });\n};\n\nmodule.exports = WorkerPlugin;","map":{"version":3,"sources":["../src/index.js"],"names":["let","ParserHelpers","require","HarmonyImportSpecifierDependency","const","NAME","workerLoader","path","WorkerPlugin","constructor","options","apply","compiler","factory","workerId","parser","parse","handleWorker","workerTypeString","expr","dep","optsExpr","hasInitOptions","i","prop","opts","message","JSON","isStrictModule","esModule","loaderRequest","encodeURIComponent","id","module","Error","dependency","req","this","typeModuleExpr"],"mappings":"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","sourcesContent":["/**\n * Copyright 2018 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nimport path from 'path';\nimport WORKER_PLUGIN_SYMBOL from './symbol';\nlet ParserHelpers;\ntry {\n  ParserHelpers = require('webpack/lib/javascript/JavascriptParserHelpers'); // Webpack 5\n} catch (e) {}\nParserHelpers = ParserHelpers || require('webpack/lib/ParserHelpers'); // Webpack 4\nlet HarmonyImportSpecifierDependency;\ntry {\n  HarmonyImportSpecifierDependency = require('webpack/lib/dependencies/HarmonyImportSpecifierDependency');\n} catch (e) {}\n\nconst NAME = 'WorkerPlugin';\nconst workerLoader = path.resolve(__dirname, 'loader.js');\n\nexport default class WorkerPlugin {\n  constructor (options) {\n    this.options = options || {};\n    this[WORKER_PLUGIN_SYMBOL] = true;\n  }\n\n  apply (compiler) {\n    compiler.hooks.normalModuleFactory.tap(NAME, factory => {\n      let workerId = 0;\n      factory.hooks.parser.for('javascript/auto').tap(NAME, parser => parse(parser, false));\n      factory.hooks.parser.for('javascript/dynamic').tap(NAME, parser => parse(parser, false));\n      factory.hooks.parser.for('javascript/esm').tap(NAME, parser => parse(parser, true));\n\n      const parse = (parser, esModule) => {\n        const handleWorker = workerTypeString => expr => {\n          const dep = parser.evaluateExpression(expr.arguments[0]);\n\n          const optsExpr = expr.arguments[1];\n          let hasInitOptions = false;\n          let typeModuleExpr;\n          let opts;\n          if (optsExpr) {\n            opts = {};\n            for (let i = optsExpr.properties.length; i--;) {\n              const prop = optsExpr.properties[i];\n              if (prop.type === 'Property' && !prop.computed && !prop.shorthand && !prop.method) {\n                opts[prop.key.name] = parser.evaluateExpression(prop.value).string;\n\n                if (prop.key.name === 'type') {\n                  typeModuleExpr = prop;\n                } else {\n                  hasInitOptions = true;\n                }\n              }\n            }\n          }\n\n          if (!opts || opts.type !== 'module') {\n            // If an unknown type value is passed, it's probably an error and we can warn the developer:\n            if (opts && opts.type !== 'classic') {\n              parser.state.module.warnings.push({\n                message: `new ${workerTypeString}() will only be bundled if passed options that include { type: 'module' }.${opts ? `\\n  Received: new ${workerTypeString}()(${JSON.stringify(dep.string)}, ${JSON.stringify(opts)})` : ''}`\n              });\n            }\n            return false;\n          }\n\n          if (!dep.isString()) {\n            parser.state.module.warnings.push({\n              message: `new ${workerTypeString}(\"..\", { type: \"module\" }) will only be bundled if passed a String.`\n            });\n            return false;\n          }\n\n          const isStrictModule = esModule || (parser.state.buildMeta && parser.state.buildMeta.strictHarmonyModule);\n\n          // Querystring-encoded loader prefix (faster/cleaner than JSON parameters):\n          const loaderRequest = `${workerLoader}?name=${encodeURIComponent(opts.name || workerId)}${isStrictModule ? '&esModule' : ''}!${dep.string}`;\n\n          // Unique ID for the worker URL variable:\n          const id = `__webpack__worker__${workerId++}`;\n\n          // .mjs / strict harmony mode\n          if (isStrictModule) {\n            const module = parser.state.current;\n\n            if (!HarmonyImportSpecifierDependency) {\n              throw Error(`${NAME}: Failed to import HarmonyImportSpecifierDependency. This plugin requires Webpack version 4.`);\n            }\n\n            // This is essentially the internals of \"prepend an import to the module\":\n            const dependency = new HarmonyImportSpecifierDependency(\n              loaderRequest,\n              module,\n              workerId, // no idea if this actually needs to be unique. 0 seemed to work. safety first?\n              parser.scope,\n              'default',\n              id, // this never gets used\n              expr.arguments[0].range, // replace the usage/callsite with the generated reference: X_IMPORT_0[\"default\"]\n              true\n            );\n            // avoid serializing the full loader filepath: (this gets prepended to unique suffix)\n            dependency.userRequest = dep.string;\n\n            module.addDependency(dependency);\n          } else {\n            // For CommonJS/Auto\n            const req = `require(${JSON.stringify(loaderRequest)})`;\n            ParserHelpers.toConstantDependency(parser, id)(expr.arguments[0]);\n            ParserHelpers.addParsedVariableToModule(parser, id, req);\n          }\n\n          // update/remove the WorkerInitOptions argument\n          if (this.options.workerType) {\n            ParserHelpers.toConstantDependency(parser, JSON.stringify(this.options.workerType))(typeModuleExpr.value);\n          } else if (this.options.preserveTypeModule !== true) {\n            if (hasInitOptions) {\n              // there might be other options - to avoid trailing comma issues, replace the type value with undefined but *leave the key*:\n              ParserHelpers.toConstantDependency(parser, 'type:undefined')(typeModuleExpr);\n            } else {\n              // there was only a `{type}` option, we replace the opts argument with undefined to avoid trailing comma issues:\n              ParserHelpers.toConstantDependency(parser, 'undefined')(optsExpr);\n            }\n          }\n\n          return true;\n        };\n\n        if (this.options.worker !== false) {\n          parser.hooks.new.for('Worker').tap(NAME, handleWorker('Worker'));\n        }\n        if (this.options.sharedWorker) {\n          parser.hooks.new.for('SharedWorker').tap(NAME, handleWorker('SharedWorker'));\n        }\n      };\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}