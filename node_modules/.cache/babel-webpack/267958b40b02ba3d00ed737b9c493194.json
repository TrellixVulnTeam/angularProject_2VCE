{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ConstDependency = require(\"./dependencies/ConstDependency\");\n\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nvar ParserHelpers = require(\"./ParserHelpers\");\n\nvar NullFactory = require(\"./NullFactory\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Parser\")} Parser */\n\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\n\nvar RuntimeValue = /*#__PURE__*/function () {\n  function RuntimeValue(fn, fileDependencies) {\n    _classCallCheck(this, RuntimeValue);\n\n    this.fn = fn;\n    this.fileDependencies = fileDependencies || [];\n  }\n\n  _createClass(RuntimeValue, [{\n    key: \"exec\",\n    value: function exec(parser) {\n      if (this.fileDependencies === true) {\n        parser.state.module.buildInfo.cacheable = false;\n      } else {\n        var _iterator = _createForOfIteratorHelper(this.fileDependencies),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var fileDependency = _step.value;\n            parser.state.module.buildInfo.fileDependencies.add(fileDependency);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return this.fn({\n        module: parser.state.module\n      });\n    }\n  }]);\n\n  return RuntimeValue;\n}();\n\nvar stringifyObj = function stringifyObj(obj, parser) {\n  return \"Object({\" + Object.keys(obj).map(function (key) {\n    var code = obj[key];\n    return JSON.stringify(key) + \":\" + toCode(code, parser);\n  }).join(\",\") + \"})\";\n};\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\n\n\nvar toCode = function toCode(code, parser) {\n  if (code === null) {\n    return \"null\";\n  }\n\n  if (code === undefined) {\n    return \"undefined\";\n  }\n\n  if (code instanceof RuntimeValue) {\n    return toCode(code.exec(parser), parser);\n  }\n\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n\n  if (typeof code === \"function\" && code.toString) {\n    return \"(\" + code.toString() + \")\";\n  }\n\n  if (typeof code === \"object\") {\n    return stringifyObj(code, parser);\n  }\n\n  return code + \"\";\n};\n\nvar DefinePlugin = /*#__PURE__*/function () {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  function DefinePlugin(definitions) {\n    _classCallCheck(this, DefinePlugin);\n\n    this.definitions = definitions;\n  }\n\n  _createClass(DefinePlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * Apply the plugin\n     * @param {Compiler} compiler Webpack compiler\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var definitions = this.definitions;\n      compiler.hooks.compilation.tap(\"DefinePlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n        /**\n         * Handler\n         * @param {Parser} parser Parser\n         * @returns {void}\n         */\n\n        var handler = function handler(parser) {\n          /**\n           * Walk definitions\n           * @param {Object} definitions Definitions map\n           * @param {string} prefix Prefix string\n           * @returns {void}\n           */\n          var walkDefinitions = function walkDefinitions(definitions, prefix) {\n            Object.keys(definitions).forEach(function (key) {\n              var code = definitions[key];\n\n              if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n                walkDefinitions(code, prefix + key + \".\");\n                applyObjectDefine(prefix + key, code);\n                return;\n              }\n\n              applyDefineKey(prefix, key);\n              applyDefine(prefix + key, code);\n            });\n          };\n          /**\n           * Apply define key\n           * @param {string} prefix Prefix\n           * @param {string} key Key\n           * @returns {void}\n           */\n\n\n          var applyDefineKey = function applyDefineKey(prefix, key) {\n            var splittedKey = key.split(\".\");\n            splittedKey.slice(1).forEach(function (_, i) {\n              var fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n              parser.hooks.canRename.for(fullKey).tap(\"DefinePlugin\", ParserHelpers.approve);\n            });\n          };\n          /**\n           * Apply Code\n           * @param {string} key Key\n           * @param {CodeValue} code Code\n           * @returns {void}\n           */\n\n\n          var applyDefine = function applyDefine(key, code) {\n            var isTypeof = /^typeof\\s+/.test(key);\n            if (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n            var recurse = false;\n            var recurseTypeof = false;\n\n            if (!isTypeof) {\n              parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n              parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", function (expr) {\n                /**\n                 * this is needed in case there is a recursion in the DefinePlugin\n                 * to prevent an endless recursion\n                 * e.g.: new DefinePlugin({\n                 * \"a\": \"b\",\n                 * \"b\": \"a\"\n                 * });\n                 */\n                if (recurse) return;\n                recurse = true;\n                var res = parser.evaluate(toCode(code, parser));\n                recurse = false;\n                res.setRange(expr.range);\n                return res;\n              });\n              parser.hooks.expression.for(key).tap(\"DefinePlugin\", function (expr) {\n                var strCode = toCode(code, parser);\n\n                if (/__webpack_require__/.test(strCode)) {\n                  return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n                } else {\n                  return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n                }\n              });\n            }\n\n            parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"typeof a\": \"typeof b\",\n               * \"typeof b\": \"typeof a\"\n               * });\n               */\n              if (recurseTypeof) return;\n              recurseTypeof = true;\n              var typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n              var res = parser.evaluate(typeofCode);\n              recurseTypeof = false;\n              res.setRange(expr.range);\n              return res;\n            });\n            parser.hooks.typeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              var typeofCode = isTypeof ? toCode(code, parser) : \"typeof (\" + toCode(code, parser) + \")\";\n              var res = parser.evaluate(typeofCode);\n              if (!res.isString()) return;\n              return ParserHelpers.toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n            });\n          };\n          /**\n           * Apply Object\n           * @param {string} key Key\n           * @param {Object} obj Object\n           * @returns {void}\n           */\n\n\n          var applyObjectDefine = function applyObjectDefine(key, obj) {\n            parser.hooks.canRename.for(key).tap(\"DefinePlugin\", ParserHelpers.approve);\n            parser.hooks.evaluateIdentifier.for(key).tap(\"DefinePlugin\", function (expr) {\n              return new BasicEvaluatedExpression().setTruthy().setRange(expr.range);\n            });\n            parser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              return ParserHelpers.evaluateToString(\"object\")(expr);\n            });\n            parser.hooks.expression.for(key).tap(\"DefinePlugin\", function (expr) {\n              var strCode = stringifyObj(obj, parser);\n\n              if (/__webpack_require__/.test(strCode)) {\n                return ParserHelpers.toConstantDependencyWithWebpackRequire(parser, strCode)(expr);\n              } else {\n                return ParserHelpers.toConstantDependency(parser, strCode)(expr);\n              }\n            });\n            parser.hooks.typeof.for(key).tap(\"DefinePlugin\", function (expr) {\n              return ParserHelpers.toConstantDependency(parser, JSON.stringify(\"object\"))(expr);\n            });\n          };\n\n          walkDefinitions(definitions, \"\");\n        };\n\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"DefinePlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"DefinePlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"DefinePlugin\", handler);\n      });\n    }\n  }], [{\n    key: \"runtimeValue\",\n    value: function runtimeValue(fn, fileDependencies) {\n      return new RuntimeValue(fn, fileDependencies);\n    }\n  }]);\n\n  return DefinePlugin;\n}();\n\nmodule.exports = DefinePlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/DefinePlugin.js"],"names":["ConstDependency","require","BasicEvaluatedExpression","ParserHelpers","NullFactory","RuntimeValue","fn","fileDependencies","parser","state","module","buildInfo","cacheable","fileDependency","add","stringifyObj","obj","Object","keys","map","key","code","JSON","stringify","toCode","join","undefined","exec","RegExp","toString","DefinePlugin","definitions","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","handler","walkDefinitions","prefix","forEach","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","slice","_","i","fullKey","canRename","for","approve","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","strCode","toConstantDependencyWithWebpackRequire","toConstantDependency","evaluateTypeof","typeofCode","typeof","isString","string","bind","setTruthy","evaluateToString","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst ParserHelpers = require(\"./ParserHelpers\");\nconst NullFactory = require(\"./NullFactory\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Parser\")} Parser */\n/** @typedef {null|undefined|RegExp|Function|string|number} CodeValuePrimitive */\n/** @typedef {CodeValuePrimitive|Record<string, CodeValuePrimitive>|RuntimeValue} CodeValue */\n\nclass RuntimeValue {\n\tconstructor(fn, fileDependencies) {\n\t\tthis.fn = fn;\n\t\tthis.fileDependencies = fileDependencies || [];\n\t}\n\n\texec(parser) {\n\t\tif (this.fileDependencies === true) {\n\t\t\tparser.state.module.buildInfo.cacheable = false;\n\t\t} else {\n\t\t\tfor (const fileDependency of this.fileDependencies) {\n\t\t\t\tparser.state.module.buildInfo.fileDependencies.add(fileDependency);\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({ module: parser.state.module });\n\t}\n}\n\nconst stringifyObj = (obj, parser) => {\n\treturn (\n\t\t\"Object({\" +\n\t\tObject.keys(obj)\n\t\t\t.map(key => {\n\t\t\t\tconst code = obj[key];\n\t\t\t\treturn JSON.stringify(key) + \":\" + toCode(code, parser);\n\t\t\t})\n\t\t\t.join(\",\") +\n\t\t\"})\"\n\t);\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {Parser} parser Parser\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (code, parser) => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn toCode(code.exec(parser), parser);\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn \"(\" + code.toString() + \")\";\n\t}\n\tif (typeof code === \"object\") {\n\t\treturn stringifyObj(code, parser);\n\t}\n\treturn code + \"\";\n};\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\tstatic runtimeValue(fn, fileDependencies) {\n\t\treturn new RuntimeValue(fn, fileDependencies);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler Webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DefinePlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(ConstDependency, new NullFactory());\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {Parser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Object} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tObject.keys(definitions).forEach(key => {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(code, prefix + key + \".\");\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tsplittedKey.slice(1).forEach((_, i) => {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(fullKey)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst isTypeof = /^typeof\\s+/.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(/^typeof\\s+/, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(toCode(code, parser));\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t\tconst strCode = toCode(code, parser);\n\t\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(expr.range);\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst typeofCode = isTypeof\n\t\t\t\t\t\t\t\t? toCode(code, parser)\n\t\t\t\t\t\t\t\t: \"typeof (\" + toCode(code, parser) + \")\";\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {Object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", ParserHelpers.approve);\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\"DefinePlugin\", expr =>\n\t\t\t\t\t\t\t\tnew BasicEvaluatedExpression().setTruthy().setRange(expr.range)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.evaluateToString(\"object\")(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\tconst strCode = stringifyObj(obj, parser);\n\n\t\t\t\t\t\t\tif (/__webpack_require__/.test(strCode)) {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependencyWithWebpackRequire(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tstrCode\n\t\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(\"DefinePlugin\", expr => {\n\t\t\t\t\t\t\treturn ParserHelpers.toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(\"object\")\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"DefinePlugin\", handler);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"]},"metadata":{},"sourceType":"script"}