{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/patch_ts_expando_initializer\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/ngcc/src/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.restoreGetExpandoInitializer = exports.patchTsGetExpandoInitializer = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ts = require(\"typescript\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/utils\");\n  /**\n   * Consider the following ES5 code that may have been generated for a class:\n   *\n   * ```\n   * var A = (function(){\n   *   function A() {}\n   *   return A;\n   * }());\n   * A.staticProp = true;\n   * ```\n   *\n   * Here, TypeScript marks the symbol for \"A\" as a so-called \"expando symbol\", which causes\n   * \"staticProp\" to be added as an export of the \"A\" symbol.\n   *\n   * In the example above, symbol \"A\" has been assigned some flags to indicate that it represents a\n   * class. Due to this flag, the symbol is considered an expando symbol and as such, \"staticProp\" is\n   * stored in `ts.Symbol.exports`.\n   *\n   * A problem arises when \"A\" is not at the top-level, i.e. in UMD bundles. In that case, the symbol\n   * does not have the flag that marks the symbol as a class. Therefore, TypeScript inspects \"A\"'s\n   * initializer expression, which is an IIFE in the above example. Unfortunately however, only IIFEs\n   * of the form `(function(){})()` qualify as initializer for an \"expando symbol\"; the slightly\n   * different form seen in the example above, `(function(){}())`, does not. This prevents the \"A\"\n   * symbol from being considered an expando symbol, in turn preventing \"staticProp\" from being stored\n   * in `ts.Symbol.exports`.\n   *\n   * The logic for identifying symbols as \"expando symbols\" can be found here:\n   * https://github.com/microsoft/TypeScript/blob/v3.4.5/src/compiler/binder.ts#L2656-L2685\n   *\n   * Notice how the `getExpandoInitializer` function is available on the \"ts\" namespace in the\n   * compiled bundle, so we are able to override this function to accommodate for the alternative\n   * IIFE notation. The original implementation can be found at:\n   * https://github.com/Microsoft/TypeScript/blob/v3.4.5/src/compiler/utilities.ts#L1864-L1887\n   *\n   * Issue tracked in https://github.com/microsoft/TypeScript/issues/31778\n   *\n   * @returns the function to pass to `restoreGetExpandoInitializer` to undo the patch, or null if\n   * the issue is known to have been fixed.\n   */\n\n\n  function patchTsGetExpandoInitializer() {\n    if (isTs31778GetExpandoInitializerFixed()) {\n      return null;\n    }\n\n    var originalGetExpandoInitializer = ts.getExpandoInitializer;\n\n    if (originalGetExpandoInitializer === undefined) {\n      throw makeUnsupportedTypeScriptError();\n    } // Override the function to add support for recognizing the IIFE structure used in ES5 bundles.\n\n\n    ts.getExpandoInitializer = function (initializer, isPrototypeAssignment) {\n      // If the initializer is a call expression within parenthesis, unwrap the parenthesis\n      // upfront such that unsupported IIFE syntax `(function(){}())` becomes `function(){}()`,\n      // which is supported.\n      if (ts.isParenthesizedExpression(initializer) && ts.isCallExpression(initializer.expression)) {\n        initializer = initializer.expression;\n      }\n\n      return originalGetExpandoInitializer(initializer, isPrototypeAssignment);\n    };\n\n    return originalGetExpandoInitializer;\n  }\n\n  exports.patchTsGetExpandoInitializer = patchTsGetExpandoInitializer;\n\n  function restoreGetExpandoInitializer(originalGetExpandoInitializer) {\n    if (originalGetExpandoInitializer !== null) {\n      ts.getExpandoInitializer = originalGetExpandoInitializer;\n    }\n  }\n\n  exports.restoreGetExpandoInitializer = restoreGetExpandoInitializer;\n  var ts31778FixedResult = null;\n\n  function isTs31778GetExpandoInitializerFixed() {\n    // If the result has already been computed, return early.\n    if (ts31778FixedResult !== null) {\n      return ts31778FixedResult;\n    } // Determine if the issue has been fixed by checking if an expando property is present in a\n    // minimum reproduction using unpatched TypeScript.\n\n\n    ts31778FixedResult = checkIfExpandoPropertyIsPresent(); // If the issue does not appear to have been fixed, verify that applying the patch has the desired\n    // effect.\n\n    if (!ts31778FixedResult) {\n      var originalGetExpandoInitializer = patchTsGetExpandoInitializer();\n\n      try {\n        var patchIsSuccessful = checkIfExpandoPropertyIsPresent();\n\n        if (!patchIsSuccessful) {\n          throw makeUnsupportedTypeScriptError();\n        }\n      } finally {\n        restoreGetExpandoInitializer(originalGetExpandoInitializer);\n      }\n    }\n\n    return ts31778FixedResult;\n  }\n  /**\n   * Verifies whether TS issue 31778 has been fixed by inspecting a symbol from a minimum\n   * reproduction. If the symbol does in fact have the \"expando\" as export, the issue has been fixed.\n   *\n   * See https://github.com/microsoft/TypeScript/issues/31778 for details.\n   */\n\n\n  function checkIfExpandoPropertyIsPresent() {\n    var sourceText = \"\\n    (function() {\\n      var A = (function() {\\n        function A() {}\\n        return A;\\n      }());\\n      A.expando = true;\\n    }());\";\n    var sourceFile = ts.createSourceFile('test.js', sourceText, ts.ScriptTarget.ES5, true, ts.ScriptKind.JS);\n    var host = {\n      getSourceFile: function getSourceFile() {\n        return sourceFile;\n      },\n      fileExists: function fileExists() {\n        return true;\n      },\n      readFile: function readFile() {\n        return '';\n      },\n      writeFile: function writeFile() {},\n      getDefaultLibFileName: function getDefaultLibFileName() {\n        return '';\n      },\n      getCurrentDirectory: function getCurrentDirectory() {\n        return '';\n      },\n      getDirectories: function getDirectories() {\n        return [];\n      },\n      getCanonicalFileName: function getCanonicalFileName(fileName) {\n        return fileName;\n      },\n      useCaseSensitiveFileNames: function useCaseSensitiveFileNames() {\n        return true;\n      },\n      getNewLine: function getNewLine() {\n        return '\\n';\n      }\n    };\n    var options = {\n      noResolve: true,\n      noLib: true,\n      noEmit: true,\n      allowJs: true\n    };\n    var program = ts.createProgram(['test.js'], options, host);\n\n    function visitor(node) {\n      if (ts.isVariableDeclaration(node) && utils_1.hasNameIdentifier(node) && node.name.text === 'A') {\n        return node;\n      }\n\n      return ts.forEachChild(node, visitor);\n    }\n\n    var declaration = ts.forEachChild(sourceFile, visitor);\n\n    if (declaration === undefined) {\n      throw new Error('Unable to find declaration of outer A');\n    }\n\n    var symbol = program.getTypeChecker().getSymbolAtLocation(declaration.name);\n\n    if (symbol === undefined) {\n      throw new Error('Unable to resolve symbol of outer A');\n    }\n\n    return symbol.exports !== undefined && symbol.exports.has('expando');\n  }\n\n  function makeUnsupportedTypeScriptError() {\n    return new Error('The TypeScript version used is not supported by ngcc.');\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/patch_ts_expando_initializer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport {hasNameIdentifier} from '../utils';\n\n/**\n * Consider the following ES5 code that may have been generated for a class:\n *\n * ```\n * var A = (function(){\n *   function A() {}\n *   return A;\n * }());\n * A.staticProp = true;\n * ```\n *\n * Here, TypeScript marks the symbol for \"A\" as a so-called \"expando symbol\", which causes\n * \"staticProp\" to be added as an export of the \"A\" symbol.\n *\n * In the example above, symbol \"A\" has been assigned some flags to indicate that it represents a\n * class. Due to this flag, the symbol is considered an expando symbol and as such, \"staticProp\" is\n * stored in `ts.Symbol.exports`.\n *\n * A problem arises when \"A\" is not at the top-level, i.e. in UMD bundles. In that case, the symbol\n * does not have the flag that marks the symbol as a class. Therefore, TypeScript inspects \"A\"'s\n * initializer expression, which is an IIFE in the above example. Unfortunately however, only IIFEs\n * of the form `(function(){})()` qualify as initializer for an \"expando symbol\"; the slightly\n * different form seen in the example above, `(function(){}())`, does not. This prevents the \"A\"\n * symbol from being considered an expando symbol, in turn preventing \"staticProp\" from being stored\n * in `ts.Symbol.exports`.\n *\n * The logic for identifying symbols as \"expando symbols\" can be found here:\n * https://github.com/microsoft/TypeScript/blob/v3.4.5/src/compiler/binder.ts#L2656-L2685\n *\n * Notice how the `getExpandoInitializer` function is available on the \"ts\" namespace in the\n * compiled bundle, so we are able to override this function to accommodate for the alternative\n * IIFE notation. The original implementation can be found at:\n * https://github.com/Microsoft/TypeScript/blob/v3.4.5/src/compiler/utilities.ts#L1864-L1887\n *\n * Issue tracked in https://github.com/microsoft/TypeScript/issues/31778\n *\n * @returns the function to pass to `restoreGetExpandoInitializer` to undo the patch, or null if\n * the issue is known to have been fixed.\n */\nexport function patchTsGetExpandoInitializer(): unknown {\n  if (isTs31778GetExpandoInitializerFixed()) {\n    return null;\n  }\n\n  const originalGetExpandoInitializer = (ts as any).getExpandoInitializer;\n  if (originalGetExpandoInitializer === undefined) {\n    throw makeUnsupportedTypeScriptError();\n  }\n\n  // Override the function to add support for recognizing the IIFE structure used in ES5 bundles.\n  (ts as any).getExpandoInitializer = (initializer: ts.Node,\n                                       isPrototypeAssignment: boolean): ts.Expression|undefined => {\n    // If the initializer is a call expression within parenthesis, unwrap the parenthesis\n    // upfront such that unsupported IIFE syntax `(function(){}())` becomes `function(){}()`,\n    // which is supported.\n    if (ts.isParenthesizedExpression(initializer) && ts.isCallExpression(initializer.expression)) {\n      initializer = initializer.expression;\n    }\n    return originalGetExpandoInitializer(initializer, isPrototypeAssignment);\n  };\n  return originalGetExpandoInitializer;\n}\n\nexport function restoreGetExpandoInitializer(originalGetExpandoInitializer: unknown): void {\n  if (originalGetExpandoInitializer !== null) {\n    (ts as any).getExpandoInitializer = originalGetExpandoInitializer;\n  }\n}\n\nlet ts31778FixedResult: boolean|null = null;\n\nfunction isTs31778GetExpandoInitializerFixed(): boolean {\n  // If the result has already been computed, return early.\n  if (ts31778FixedResult !== null) {\n    return ts31778FixedResult;\n  }\n\n  // Determine if the issue has been fixed by checking if an expando property is present in a\n  // minimum reproduction using unpatched TypeScript.\n  ts31778FixedResult = checkIfExpandoPropertyIsPresent();\n\n  // If the issue does not appear to have been fixed, verify that applying the patch has the desired\n  // effect.\n  if (!ts31778FixedResult) {\n    const originalGetExpandoInitializer = patchTsGetExpandoInitializer();\n    try {\n      const patchIsSuccessful = checkIfExpandoPropertyIsPresent();\n      if (!patchIsSuccessful) {\n        throw makeUnsupportedTypeScriptError();\n      }\n    } finally {\n      restoreGetExpandoInitializer(originalGetExpandoInitializer);\n    }\n  }\n\n  return ts31778FixedResult;\n}\n\n/**\n * Verifies whether TS issue 31778 has been fixed by inspecting a symbol from a minimum\n * reproduction. If the symbol does in fact have the \"expando\" as export, the issue has been fixed.\n *\n * See https://github.com/microsoft/TypeScript/issues/31778 for details.\n */\nfunction checkIfExpandoPropertyIsPresent(): boolean {\n  const sourceText = `\n    (function() {\n      var A = (function() {\n        function A() {}\n        return A;\n      }());\n      A.expando = true;\n    }());`;\n  const sourceFile =\n      ts.createSourceFile('test.js', sourceText, ts.ScriptTarget.ES5, true, ts.ScriptKind.JS);\n  const host: ts.CompilerHost = {\n    getSourceFile(): ts.SourceFile |\n        undefined {\n          return sourceFile;\n        },\n    fileExists(): boolean {\n      return true;\n    },\n    readFile(): string |\n        undefined {\n          return '';\n        },\n    writeFile() {},\n    getDefaultLibFileName(): string {\n      return '';\n    },\n    getCurrentDirectory(): string {\n      return '';\n    },\n    getDirectories(): string[] {\n      return [];\n    },\n    getCanonicalFileName(fileName: string): string {\n      return fileName;\n    },\n    useCaseSensitiveFileNames(): boolean {\n      return true;\n    },\n    getNewLine(): string {\n      return '\\n';\n    },\n  };\n  const options = {noResolve: true, noLib: true, noEmit: true, allowJs: true};\n  const program = ts.createProgram(['test.js'], options, host);\n\n  function visitor(node: ts.Node): ts.VariableDeclaration|undefined {\n    if (ts.isVariableDeclaration(node) && hasNameIdentifier(node) && node.name.text === 'A') {\n      return node;\n    }\n    return ts.forEachChild(node, visitor);\n  }\n\n  const declaration = ts.forEachChild(sourceFile, visitor);\n  if (declaration === undefined) {\n    throw new Error('Unable to find declaration of outer A');\n  }\n\n  const symbol = program.getTypeChecker().getSymbolAtLocation(declaration.name);\n  if (symbol === undefined) {\n    throw new Error('Unable to resolve symbol of outer A');\n  }\n  return symbol.exports !== undefined && symbol.exports.has('expando' as ts.__String);\n}\n\nfunction makeUnsupportedTypeScriptError(): Error {\n  return new Error('The TypeScript version used is not supported by ngcc.');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}