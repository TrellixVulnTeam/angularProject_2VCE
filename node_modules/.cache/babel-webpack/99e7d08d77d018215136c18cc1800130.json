{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/output/output_jit\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/output/abstract_emitter\", \"@angular/compiler/src/output/abstract_js_emitter\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/output/output_jit_trusted_types\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.JitEmitterVisitor = exports.JitEvaluator = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var abstract_emitter_1 = require(\"@angular/compiler/src/output/abstract_emitter\");\n\n  var abstract_js_emitter_1 = require(\"@angular/compiler/src/output/abstract_js_emitter\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var output_jit_trusted_types_1 = require(\"@angular/compiler/src/output/output_jit_trusted_types\");\n  /**\n   * A helper class to manage the evaluation of JIT generated code.\n   */\n\n\n  var JitEvaluator =\n  /** @class */\n  function () {\n    function JitEvaluator() {}\n    /**\n     *\n     * @param sourceUrl The URL of the generated code.\n     * @param statements An array of Angular statement AST nodes to be evaluated.\n     * @param reflector A helper used when converting the statements to executable code.\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns A map of all the variables in the generated code.\n     */\n\n\n    JitEvaluator.prototype.evaluateStatements = function (sourceUrl, statements, reflector, createSourceMaps) {\n      var converter = new JitEmitterVisitor(reflector);\n      var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot(); // Ensure generated code is in strict mode\n\n      if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n        statements = tslib_1.__spread([o.literal('use strict').toStmt()], statements);\n      }\n\n      converter.visitAllStatements(statements, ctx);\n      converter.createReturnStmt(ctx);\n      return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n    };\n    /**\n     * Evaluate a piece of JIT generated code.\n     * @param sourceUrl The URL of this generated code.\n     * @param ctx A context object that contains an AST of the code to be evaluated.\n     * @param vars A map containing the names and values of variables that the evaluated code might\n     * reference.\n     * @param createSourceMap If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns The result of evaluating the code.\n     */\n\n\n    JitEvaluator.prototype.evaluateCode = function (sourceUrl, ctx, vars, createSourceMap) {\n      var fnBody = \"\\\"use strict\\\";\" + ctx.toSource() + \"\\n//# sourceURL=\" + sourceUrl;\n      var fnArgNames = [];\n      var fnArgValues = [];\n\n      for (var argName in vars) {\n        fnArgValues.push(vars[argName]);\n        fnArgNames.push(argName);\n      }\n\n      if (createSourceMap) {\n        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n        // E.g. ```\n        // function anonymous(a,b,c\n        // /**/) { ... }```\n        // We don't want to hard code this fact, so we auto detect it via an empty function first.\n        var emptyFn = output_jit_trusted_types_1.newTrustedFunctionForJIT.apply(void 0, tslib_1.__spread(fnArgNames.concat('return null;'))).toString();\n        var headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n        fnBody += \"\\n\" + ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment();\n      }\n\n      var fn = output_jit_trusted_types_1.newTrustedFunctionForJIT.apply(void 0, tslib_1.__spread(fnArgNames.concat(fnBody)));\n      return this.executeFunction(fn, fnArgValues);\n    };\n    /**\n     * Execute a JIT generated function by calling it.\n     *\n     * This method can be overridden in tests to capture the functions that are generated\n     * by this `JitEvaluator` class.\n     *\n     * @param fn A function to execute.\n     * @param args The arguments to pass to the function being executed.\n     * @returns The return value of the executed function.\n     */\n\n\n    JitEvaluator.prototype.executeFunction = function (fn, args) {\n      return fn.apply(void 0, tslib_1.__spread(args));\n    };\n\n    return JitEvaluator;\n  }();\n\n  exports.JitEvaluator = JitEvaluator;\n  /**\n   * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n   */\n\n  var JitEmitterVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(JitEmitterVisitor, _super);\n\n    function JitEmitterVisitor(reflector) {\n      var _this = _super.call(this) || this;\n\n      _this.reflector = reflector;\n      _this._evalArgNames = [];\n      _this._evalArgValues = [];\n      _this._evalExportedVars = [];\n      return _this;\n    }\n\n    JitEmitterVisitor.prototype.createReturnStmt = function (ctx) {\n      var stmt = new o.ReturnStatement(new o.LiteralMapExpr(this._evalExportedVars.map(function (resultVar) {\n        return new o.LiteralMapEntry(resultVar, o.variable(resultVar), false);\n      })));\n      stmt.visitStatement(this, ctx);\n    };\n\n    JitEmitterVisitor.prototype.getArgs = function () {\n      var result = {};\n\n      for (var i = 0; i < this._evalArgNames.length; i++) {\n        result[this._evalArgNames[i]] = this._evalArgValues[i];\n      }\n\n      return result;\n    };\n\n    JitEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n      this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\n\n      return null;\n    };\n\n    JitEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n      this._emitReferenceToExternal(ast, ast.node, ctx);\n\n      return null;\n    };\n\n    JitEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _super.prototype.visitDeclareVarStmt.call(this, stmt, ctx);\n    };\n\n    JitEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _super.prototype.visitDeclareFunctionStmt.call(this, stmt, ctx);\n    };\n\n    JitEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _super.prototype.visitDeclareClassStmt.call(this, stmt, ctx);\n    };\n\n    JitEmitterVisitor.prototype._emitReferenceToExternal = function (ast, value, ctx) {\n      var id = this._evalArgValues.indexOf(value);\n\n      if (id === -1) {\n        id = this._evalArgValues.length;\n\n        this._evalArgValues.push(value);\n\n        var name_1 = compile_metadata_1.identifierName({\n          reference: value\n        }) || 'val';\n\n        this._evalArgNames.push(\"jit_\" + name_1 + \"_\" + id);\n      }\n\n      ctx.print(ast, this._evalArgNames[id]);\n    };\n\n    return JitEmitterVisitor;\n  }(abstract_js_emitter_1.AbstractJsEmitterVisitor);\n\n  exports.JitEmitterVisitor = JitEmitterVisitor;\n\n  function isUseStrictStatement(statement) {\n    return statement.isEquivalent(o.literal('use strict').toStmt());\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/output/output_jit.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {identifierName} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\n\nimport {EmitterVisitorContext} from './abstract_emitter';\nimport {AbstractJsEmitterVisitor} from './abstract_js_emitter';\nimport * as o from './output_ast';\nimport {newTrustedFunctionForJIT} from './output_jit_trusted_types';\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nexport class JitEvaluator {\n  /**\n   *\n   * @param sourceUrl The URL of the generated code.\n   * @param statements An array of Angular statement AST nodes to be evaluated.\n   * @param reflector A helper used when converting the statements to executable code.\n   * @param createSourceMaps If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns A map of all the variables in the generated code.\n   */\n  evaluateStatements(\n      sourceUrl: string, statements: o.Statement[], reflector: CompileReflector,\n      createSourceMaps: boolean): {[key: string]: any} {\n    const converter = new JitEmitterVisitor(reflector);\n    const ctx = EmitterVisitorContext.createRoot();\n    // Ensure generated code is in strict mode\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [\n        o.literal('use strict').toStmt(),\n        ...statements,\n      ];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n\n  /**\n   * Evaluate a piece of JIT generated code.\n   * @param sourceUrl The URL of this generated code.\n   * @param ctx A context object that contains an AST of the code to be evaluated.\n   * @param vars A map containing the names and values of variables that the evaluated code might\n   * reference.\n   * @param createSourceMap If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns The result of evaluating the code.\n   */\n  evaluateCode(\n      sourceUrl: string, ctx: EmitterVisitorContext, vars: {[key: string]: any},\n      createSourceMap: boolean): any {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames: string[] = [];\n    const fnArgValues: any[] = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n      // E.g. ```\n      // function anonymous(a,b,c\n      // /**/) { ... }```\n      // We don't want to hard code this fact, so we auto detect it via an empty function first.\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n\n  /**\n   * Execute a JIT generated function by calling it.\n   *\n   * This method can be overridden in tests to capture the functions that are generated\n   * by this `JitEvaluator` class.\n   *\n   * @param fn A function to execute.\n   * @param args The arguments to pass to the function being executed.\n   * @returns The return value of the executed function.\n   */\n  executeFunction(fn: Function, args: any[]) {\n    return fn(...args);\n  }\n}\n\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nexport class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  private _evalArgNames: string[] = [];\n  private _evalArgValues: any[] = [];\n  private _evalExportedVars: string[] = [];\n\n  constructor(private reflector: CompileReflector) {\n    super();\n  }\n\n  createReturnStmt(ctx: EmitterVisitorContext) {\n    const stmt = new o.ReturnStatement(new o.LiteralMapExpr(this._evalExportedVars.map(\n        resultVar => new o.LiteralMapEntry(resultVar, o.variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n\n  getArgs(): {[key: string]: any} {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n\n  visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n\n  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n\n  visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareClassStmt(stmt, ctx);\n  }\n\n  private _emitReferenceToExternal(ast: o.Expression, value: any, ctx: EmitterVisitorContext):\n      void {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({reference: value}) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\n\n\nfunction isUseStrictStatement(statement: o.Statement): boolean {\n  return statement.isEquivalent(o.literal('use strict').toStmt());\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}