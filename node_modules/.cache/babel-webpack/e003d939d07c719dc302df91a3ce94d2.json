{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/entry_point_finder/utils\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/file_system\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.trackDuration = exports.getBasePaths = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n  /**\n   * Extract all the base-paths that we need to search for entry-points.\n   *\n   * This always contains the standard base-path (`sourceDirectory`).\n   * But it also parses the `paths` mappings object to guess additional base-paths.\n   *\n   * For example:\n   *\n   * ```\n   * getBasePaths('/node_modules', {baseUrl: '/dist', paths: {'*': ['lib/*', 'lib/generated/*']}})\n   * > ['/node_modules', '/dist/lib']\n   * ```\n   *\n   * Notice that `'/dist'` is not included as there is no `'*'` path,\n   * and `'/dist/lib/generated'` is not included as it is covered by `'/dist/lib'`.\n   *\n   * @param sourceDirectory The standard base-path (e.g. node_modules).\n   * @param pathMappings Path mapping configuration, from which to extract additional base-paths.\n   */\n\n\n  function getBasePaths(logger, sourceDirectory, pathMappings) {\n    var e_1, _a, e_2, _b, e_3, _c;\n\n    var fs = file_system_1.getFileSystem();\n    var basePaths = [sourceDirectory];\n\n    if (pathMappings) {\n      var baseUrl = fs.resolve(pathMappings.baseUrl);\n\n      if (fs.isRoot(baseUrl)) {\n        logger.warn(\"The provided pathMappings baseUrl is the root path \" + baseUrl + \".\\n\" + \"This is likely to mess up how ngcc finds entry-points and is probably not correct.\\n\" + \"Please check your path mappings configuration such as in the tsconfig.json file.\");\n      }\n\n      try {\n        for (var _d = tslib_1.__values(Object.values(pathMappings.paths)), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var paths = _e.value;\n\n          try {\n            for (var paths_1 = (e_2 = void 0, tslib_1.__values(paths)), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {\n              var path = paths_1_1.value;\n              var foundMatch = false; // We only want base paths that exist and are not files\n\n              var _f = extractPathPrefix(path),\n                  prefix = _f.prefix,\n                  hasWildcard = _f.hasWildcard;\n\n              var basePath = fs.resolve(baseUrl, prefix);\n\n              if (fs.exists(basePath) && fs.stat(basePath).isFile()) {\n                basePath = fs.dirname(basePath);\n              }\n\n              if (fs.exists(basePath)) {\n                // The `basePath` is itself a directory\n                basePaths.push(basePath);\n                foundMatch = true;\n              }\n\n              if (hasWildcard) {\n                // The path contains a wildcard (`*`) so also try searching for directories that start\n                // with the wildcard prefix path segment.\n                var wildcardContainer = fs.dirname(basePath);\n                var wildcardPrefix = fs.basename(basePath);\n\n                if (isExistingDirectory(fs, wildcardContainer)) {\n                  var candidates = fs.readdir(wildcardContainer);\n\n                  try {\n                    for (var candidates_1 = (e_3 = void 0, tslib_1.__values(candidates)), candidates_1_1 = candidates_1.next(); !candidates_1_1.done; candidates_1_1 = candidates_1.next()) {\n                      var candidate = candidates_1_1.value;\n\n                      if (candidate.startsWith(wildcardPrefix)) {\n                        var candidatePath = fs.resolve(wildcardContainer, candidate);\n\n                        if (isExistingDirectory(fs, candidatePath)) {\n                          foundMatch = true;\n                          basePaths.push(candidatePath);\n                        }\n                      }\n                    }\n                  } catch (e_3_1) {\n                    e_3 = {\n                      error: e_3_1\n                    };\n                  } finally {\n                    try {\n                      if (candidates_1_1 && !candidates_1_1.done && (_c = candidates_1.return)) _c.call(candidates_1);\n                    } finally {\n                      if (e_3) throw e_3.error;\n                    }\n                  }\n                }\n              }\n\n              if (!foundMatch) {\n                // We neither found a direct match (i.e. `basePath` is an existing directory) nor a\n                // directory that starts with a wildcard prefix.\n                logger.debug(\"The basePath \\\"\" + basePath + \"\\\" computed from baseUrl \\\"\" + baseUrl + \"\\\" and path mapping \\\"\" + path + \"\\\" does not exist in the file-system.\\n\" + \"It will not be scanned for entry-points.\");\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (paths_1_1 && !paths_1_1.done && (_b = paths_1.return)) _b.call(paths_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    var dedupedBasePaths = dedupePaths(fs, basePaths); // We want to ensure that the `sourceDirectory` is included when it is a node_modules folder.\n    // Otherwise our entry-point finding algorithm would fail to walk that folder.\n\n    if (fs.basename(sourceDirectory) === 'node_modules' && !dedupedBasePaths.includes(sourceDirectory)) {\n      dedupedBasePaths.unshift(sourceDirectory);\n    }\n\n    return dedupedBasePaths;\n  }\n\n  exports.getBasePaths = getBasePaths;\n\n  function isExistingDirectory(fs, path) {\n    return fs.exists(path) && fs.stat(path).isDirectory();\n  }\n  /**\n   * Extract everything in the `path` up to the first `*`.\n   * @param path The path to parse.\n   * @returns The extracted prefix and a flag to indicate whether there was a wildcard `*`.\n   */\n\n\n  function extractPathPrefix(path) {\n    var _a = tslib_1.__read(path.split('*', 2), 2),\n        prefix = _a[0],\n        rest = _a[1];\n\n    return {\n      prefix: prefix,\n      hasWildcard: rest !== undefined\n    };\n  }\n  /**\n   * Run a task and track how long it takes.\n   *\n   * @param task The task whose duration we are tracking.\n   * @param log The function to call with the duration of the task.\n   * @returns The result of calling `task`.\n   */\n\n\n  function trackDuration(task, log) {\n    var startTime = Date.now();\n    var result = task();\n    var duration = Math.round((Date.now() - startTime) / 100) / 10;\n    log(duration);\n    return result;\n  }\n\n  exports.trackDuration = trackDuration;\n  /**\n   * Remove paths that are contained by other paths.\n   *\n   * For example:\n   * Given `['a/b/c', 'a/b/x', 'a/b', 'd/e', 'd/f']` we will end up with `['a/b', 'd/e', 'd/f]`.\n   * (Note that we do not get `d` even though `d/e` and `d/f` share a base directory, since `d` is not\n   * one of the base paths.)\n   */\n\n  function dedupePaths(fs, paths) {\n    var e_4, _a;\n\n    var root = {\n      children: new Map()\n    };\n\n    try {\n      for (var paths_2 = tslib_1.__values(paths), paths_2_1 = paths_2.next(); !paths_2_1.done; paths_2_1 = paths_2.next()) {\n        var path = paths_2_1.value;\n        addPath(fs, root, path);\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (paths_2_1 && !paths_2_1.done && (_a = paths_2.return)) _a.call(paths_2);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return flattenTree(root);\n  }\n  /**\n   * Add a path (defined by the `segments`) to the current `node` in the tree.\n   */\n\n\n  function addPath(fs, root, path) {\n    var node = root;\n\n    if (!fs.isRoot(path)) {\n      var segments = path.split('/');\n\n      for (var index = 0; index < segments.length; index++) {\n        if (isLeaf(node)) {\n          // We hit a leaf so don't bother processing any more of the path\n          return;\n        } // This is not the end of the path continue to process the rest of this path.\n\n\n        var next = segments[index];\n\n        if (!node.children.has(next)) {\n          node.children.set(next, {\n            children: new Map()\n          });\n        }\n\n        node = node.children.get(next);\n      }\n    } // This path has finished so convert this node to a leaf\n\n\n    convertToLeaf(node, path);\n  }\n  /**\n   * Flatten the tree of nodes back into an array of absolute paths.\n   */\n\n\n  function flattenTree(root) {\n    var paths = [];\n    var nodes = [root];\n\n    for (var index = 0; index < nodes.length; index++) {\n      var node = nodes[index];\n\n      if (isLeaf(node)) {\n        // We found a leaf so store the currentPath\n        paths.push(node.path);\n      } else {\n        node.children.forEach(function (value) {\n          return nodes.push(value);\n        });\n      }\n    }\n\n    return paths;\n  }\n\n  function isLeaf(node) {\n    return node.path !== undefined;\n  }\n\n  function convertToLeaf(node, path) {\n    node.path = path;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/entry_point_finder/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, getFileSystem, PathManipulation, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {PathMappings} from '../path_mappings';\n\n/**\n * Extract all the base-paths that we need to search for entry-points.\n *\n * This always contains the standard base-path (`sourceDirectory`).\n * But it also parses the `paths` mappings object to guess additional base-paths.\n *\n * For example:\n *\n * ```\n * getBasePaths('/node_modules', {baseUrl: '/dist', paths: {'*': ['lib/*', 'lib/generated/*']}})\n * > ['/node_modules', '/dist/lib']\n * ```\n *\n * Notice that `'/dist'` is not included as there is no `'*'` path,\n * and `'/dist/lib/generated'` is not included as it is covered by `'/dist/lib'`.\n *\n * @param sourceDirectory The standard base-path (e.g. node_modules).\n * @param pathMappings Path mapping configuration, from which to extract additional base-paths.\n */\nexport function getBasePaths(\n    logger: Logger, sourceDirectory: AbsoluteFsPath,\n    pathMappings: PathMappings|undefined): AbsoluteFsPath[] {\n  const fs = getFileSystem();\n  const basePaths = [sourceDirectory];\n  if (pathMappings) {\n    const baseUrl = fs.resolve(pathMappings.baseUrl);\n    if (fs.isRoot(baseUrl)) {\n      logger.warn(\n          `The provided pathMappings baseUrl is the root path ${baseUrl}.\\n` +\n          `This is likely to mess up how ngcc finds entry-points and is probably not correct.\\n` +\n          `Please check your path mappings configuration such as in the tsconfig.json file.`);\n    }\n    for (const paths of Object.values(pathMappings.paths)) {\n      for (const path of paths) {\n        let foundMatch = false;\n\n        // We only want base paths that exist and are not files\n        const {prefix, hasWildcard} = extractPathPrefix(path);\n        let basePath = fs.resolve(baseUrl, prefix);\n        if (fs.exists(basePath) && fs.stat(basePath).isFile()) {\n          basePath = fs.dirname(basePath);\n        }\n\n        if (fs.exists(basePath)) {\n          // The `basePath` is itself a directory\n          basePaths.push(basePath);\n          foundMatch = true;\n        }\n\n        if (hasWildcard) {\n          // The path contains a wildcard (`*`) so also try searching for directories that start\n          // with the wildcard prefix path segment.\n          const wildcardContainer = fs.dirname(basePath);\n          const wildcardPrefix = fs.basename(basePath);\n          if (isExistingDirectory(fs, wildcardContainer)) {\n            const candidates = fs.readdir(wildcardContainer);\n            for (const candidate of candidates) {\n              if (candidate.startsWith(wildcardPrefix)) {\n                const candidatePath = fs.resolve(wildcardContainer, candidate);\n                if (isExistingDirectory(fs, candidatePath)) {\n                  foundMatch = true;\n                  basePaths.push(candidatePath);\n                }\n              }\n            }\n          }\n        }\n\n        if (!foundMatch) {\n          // We neither found a direct match (i.e. `basePath` is an existing directory) nor a\n          // directory that starts with a wildcard prefix.\n          logger.debug(\n              `The basePath \"${basePath}\" computed from baseUrl \"${baseUrl}\" and path mapping \"${\n                  path}\" does not exist in the file-system.\\n` +\n              `It will not be scanned for entry-points.`);\n        }\n      }\n    }\n  }\n\n  const dedupedBasePaths = dedupePaths(fs, basePaths);\n\n  // We want to ensure that the `sourceDirectory` is included when it is a node_modules folder.\n  // Otherwise our entry-point finding algorithm would fail to walk that folder.\n  if (fs.basename(sourceDirectory) === 'node_modules' &&\n      !dedupedBasePaths.includes(sourceDirectory)) {\n    dedupedBasePaths.unshift(sourceDirectory);\n  }\n\n  return dedupedBasePaths;\n}\n\nfunction isExistingDirectory(fs: ReadonlyFileSystem, path: AbsoluteFsPath): boolean {\n  return fs.exists(path) && fs.stat(path).isDirectory();\n}\n\n/**\n * Extract everything in the `path` up to the first `*`.\n * @param path The path to parse.\n * @returns The extracted prefix and a flag to indicate whether there was a wildcard `*`.\n */\nfunction extractPathPrefix(path: string): {prefix: string, hasWildcard: boolean} {\n  const [prefix, rest] = path.split('*', 2);\n  return {prefix, hasWildcard: rest !== undefined};\n}\n\n/**\n * Run a task and track how long it takes.\n *\n * @param task The task whose duration we are tracking.\n * @param log The function to call with the duration of the task.\n * @returns The result of calling `task`.\n */\nexport function trackDuration<T = void>(task: () => T extends Promise<unknown>? never : T,\n                                                              log: (duration: number) => void): T {\n  const startTime = Date.now();\n  const result = task();\n  const duration = Math.round((Date.now() - startTime) / 100) / 10;\n  log(duration);\n  return result;\n}\n\n/**\n * Remove paths that are contained by other paths.\n *\n * For example:\n * Given `['a/b/c', 'a/b/x', 'a/b', 'd/e', 'd/f']` we will end up with `['a/b', 'd/e', 'd/f]`.\n * (Note that we do not get `d` even though `d/e` and `d/f` share a base directory, since `d` is not\n * one of the base paths.)\n */\nfunction dedupePaths(fs: PathManipulation, paths: AbsoluteFsPath[]): AbsoluteFsPath[] {\n  const root: Node = {children: new Map()};\n  for (const path of paths) {\n    addPath(fs, root, path);\n  }\n  return flattenTree(root);\n}\n\n/**\n * Add a path (defined by the `segments`) to the current `node` in the tree.\n */\nfunction addPath(fs: PathManipulation, root: Node, path: AbsoluteFsPath): void {\n  let node = root;\n  if (!fs.isRoot(path)) {\n    const segments = path.split('/');\n    for (let index = 0; index < segments.length; index++) {\n      if (isLeaf(node)) {\n        // We hit a leaf so don't bother processing any more of the path\n        return;\n      }\n      // This is not the end of the path continue to process the rest of this path.\n      const next = segments[index];\n      if (!node.children.has(next)) {\n        node.children.set(next, {children: new Map()});\n      }\n      node = node.children.get(next)!;\n    }\n  }\n  // This path has finished so convert this node to a leaf\n  convertToLeaf(node, path);\n}\n\n/**\n * Flatten the tree of nodes back into an array of absolute paths.\n */\nfunction flattenTree(root: Node): AbsoluteFsPath[] {\n  const paths: AbsoluteFsPath[] = [];\n  const nodes: Node[] = [root];\n  for (let index = 0; index < nodes.length; index++) {\n    const node = nodes[index];\n    if (isLeaf(node)) {\n      // We found a leaf so store the currentPath\n      paths.push(node.path);\n    } else {\n      node.children.forEach(value => nodes.push(value));\n    }\n  }\n  return paths;\n}\n\nfunction isLeaf(node: Node): node is Leaf {\n  return node.path !== undefined;\n}\n\nfunction convertToLeaf(node: Node, path: AbsoluteFsPath) {\n  node.path = path;\n}\n\ninterface Node {\n  children: Map<string, Node>;\n  path?: AbsoluteFsPath;\n}\n\ntype Leaf = Required<Node>;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}