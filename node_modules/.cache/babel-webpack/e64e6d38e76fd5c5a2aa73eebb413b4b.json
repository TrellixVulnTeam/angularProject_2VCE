{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/jit/compiler\", [\"require\", \"exports\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/constant_pool\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/output/output_interpreter\", \"@angular/compiler/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.JitCompiler = void 0;\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var constant_pool_1 = require(\"@angular/compiler/src/constant_pool\");\n\n  var ir = require(\"@angular/compiler/src/output/output_ast\");\n\n  var output_interpreter_1 = require(\"@angular/compiler/src/output/output_interpreter\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n  /**\n   * An internal module of the Angular compiler that begins with component types,\n   * extracts templates, and eventually produces a compiled version of the component\n   * ready for linking into an application.\n   *\n   * @security  When compiling templates at runtime, you must ensure that the entire template comes\n   * from a trusted source. Attacker-controlled data introduced by a template could expose your\n   * application to XSS risks.  For more detail, see the [Security Guide](https://g.co/ng/security).\n   */\n\n\n  var JitCompiler =\n  /** @class */\n  function () {\n    function JitCompiler(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _reflector, _jitEvaluator, _compilerConfig, _console, getExtraNgModuleProviders) {\n      this._metadataResolver = _metadataResolver;\n      this._templateParser = _templateParser;\n      this._styleCompiler = _styleCompiler;\n      this._viewCompiler = _viewCompiler;\n      this._ngModuleCompiler = _ngModuleCompiler;\n      this._summaryResolver = _summaryResolver;\n      this._reflector = _reflector;\n      this._jitEvaluator = _jitEvaluator;\n      this._compilerConfig = _compilerConfig;\n      this._console = _console;\n      this.getExtraNgModuleProviders = getExtraNgModuleProviders;\n      this._compiledTemplateCache = new Map();\n      this._compiledHostTemplateCache = new Map();\n      this._compiledDirectiveWrapperCache = new Map();\n      this._compiledNgModuleCache = new Map();\n      this._sharedStylesheetCount = 0;\n      this._addedAotSummaries = new Set();\n    }\n\n    JitCompiler.prototype.compileModuleSync = function (moduleType) {\n      return util_1.SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\n    };\n\n    JitCompiler.prototype.compileModuleAsync = function (moduleType) {\n      return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\n    };\n\n    JitCompiler.prototype.compileModuleAndAllComponentsSync = function (moduleType) {\n      return util_1.SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\n    };\n\n    JitCompiler.prototype.compileModuleAndAllComponentsAsync = function (moduleType) {\n      return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\n    };\n\n    JitCompiler.prototype.getComponentFactory = function (component) {\n      var summary = this._metadataResolver.getDirectiveSummary(component);\n\n      return summary.componentFactory;\n    };\n\n    JitCompiler.prototype.loadAotSummaries = function (summaries) {\n      this.clearCache();\n\n      this._addAotSummaries(summaries);\n    };\n\n    JitCompiler.prototype._addAotSummaries = function (fn) {\n      if (this._addedAotSummaries.has(fn)) {\n        return;\n      }\n\n      this._addedAotSummaries.add(fn);\n\n      var summaries = fn();\n\n      for (var i = 0; i < summaries.length; i++) {\n        var entry = summaries[i];\n\n        if (typeof entry === 'function') {\n          this._addAotSummaries(entry);\n        } else {\n          var summary = entry;\n\n          this._summaryResolver.addSummary({\n            symbol: summary.type.reference,\n            metadata: null,\n            type: summary\n          });\n        }\n      }\n    };\n\n    JitCompiler.prototype.hasAotSummary = function (ref) {\n      return !!this._summaryResolver.resolveSummary(ref);\n    };\n\n    JitCompiler.prototype._filterJitIdentifiers = function (ids) {\n      var _this = this;\n\n      return ids.map(function (mod) {\n        return mod.reference;\n      }).filter(function (ref) {\n        return !_this.hasAotSummary(ref);\n      });\n    };\n\n    JitCompiler.prototype._compileModuleAndComponents = function (moduleType, isSync) {\n      var _this = this;\n\n      return util_1.SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n        _this._compileComponents(moduleType, null);\n\n        return _this._compileModule(moduleType);\n      });\n    };\n\n    JitCompiler.prototype._compileModuleAndAllComponents = function (moduleType, isSync) {\n      var _this = this;\n\n      return util_1.SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n        var componentFactories = [];\n\n        _this._compileComponents(moduleType, componentFactories);\n\n        return {\n          ngModuleFactory: _this._compileModule(moduleType),\n          componentFactories: componentFactories\n        };\n      });\n    };\n\n    JitCompiler.prototype._loadModules = function (mainModule, isSync) {\n      var _this = this;\n\n      var loading = [];\n\n      var mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule); // Note: for runtime compilation, we want to transitively compile all modules,\n      // so we also need to load the declared directives / pipes for all nested modules.\n\n\n      this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach(function (nestedNgModule) {\n        // getNgModuleMetadata only returns null if the value passed in is not an NgModule\n        var moduleMeta = _this._metadataResolver.getNgModuleMetadata(nestedNgModule);\n\n        _this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach(function (ref) {\n          var promise = _this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\n\n          if (promise) {\n            loading.push(promise);\n          }\n        });\n\n        _this._filterJitIdentifiers(moduleMeta.declaredPipes).forEach(function (ref) {\n          return _this._metadataResolver.getOrLoadPipeMetadata(ref);\n        });\n      });\n\n      return util_1.SyncAsync.all(loading);\n    };\n\n    JitCompiler.prototype._compileModule = function (moduleType) {\n      var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);\n\n      if (!ngModuleFactory) {\n        var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType); // Always provide a bound Compiler\n\n\n        var extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);\n        var outputCtx = createOutputContext();\n\n        var compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);\n\n        ngModuleFactory = this._interpretOrJit(compile_metadata_1.ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];\n\n        this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);\n      }\n\n      return ngModuleFactory;\n    };\n    /**\n     * @internal\n     */\n\n\n    JitCompiler.prototype._compileComponents = function (mainModule, allComponentFactories) {\n      var _this = this;\n\n      var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n\n      var moduleByJitDirective = new Map();\n      var templates = new Set();\n\n      var transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\n\n      transJitModules.forEach(function (localMod) {\n        var localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localMod);\n\n        _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n          moduleByJitDirective.set(dirRef, localModuleMeta);\n\n          var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);\n\n          if (dirMeta.isComponent) {\n            templates.add(_this._createCompiledTemplate(dirMeta, localModuleMeta));\n\n            if (allComponentFactories) {\n              var template = _this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n\n              templates.add(template);\n              allComponentFactories.push(dirMeta.componentFactory);\n            }\n          }\n        });\n      });\n      transJitModules.forEach(function (localMod) {\n        var localModuleMeta = _this._metadataResolver.getNgModuleMetadata(localMod);\n\n        _this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n          var dirMeta = _this._metadataResolver.getDirectiveMetadata(dirRef);\n\n          if (dirMeta.isComponent) {\n            dirMeta.entryComponents.forEach(function (entryComponentType) {\n              var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\n              templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n            });\n          }\n        });\n\n        localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n          if (!_this.hasAotSummary(entryComponentType.componentType)) {\n            var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\n            templates.add(_this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n          }\n        });\n      });\n      templates.forEach(function (template) {\n        return _this._compileTemplate(template);\n      });\n    };\n\n    JitCompiler.prototype.clearCacheFor = function (type) {\n      this._compiledNgModuleCache.delete(type);\n\n      this._metadataResolver.clearCacheFor(type);\n\n      this._compiledHostTemplateCache.delete(type);\n\n      var compiledTemplate = this._compiledTemplateCache.get(type);\n\n      if (compiledTemplate) {\n        this._compiledTemplateCache.delete(type);\n      }\n    };\n\n    JitCompiler.prototype.clearCache = function () {\n      // Note: don't clear the _addedAotSummaries, as they don't change!\n      this._metadataResolver.clearCache();\n\n      this._compiledTemplateCache.clear();\n\n      this._compiledHostTemplateCache.clear();\n\n      this._compiledNgModuleCache.clear();\n    };\n\n    JitCompiler.prototype._createCompiledHostTemplate = function (compType, ngModule) {\n      if (!ngModule) {\n        throw new Error(\"Component \" + util_1.stringify(compType) + \" is not part of any NgModule or the module has not been imported into your module.\");\n      }\n\n      var compiledTemplate = this._compiledHostTemplateCache.get(compType);\n\n      if (!compiledTemplate) {\n        var compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n\n        assertComponent(compMeta);\n\n        var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta, compMeta.componentFactory.viewDefFactory);\n\n        compiledTemplate = new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n\n        this._compiledHostTemplateCache.set(compType, compiledTemplate);\n      }\n\n      return compiledTemplate;\n    };\n\n    JitCompiler.prototype._createCompiledTemplate = function (compMeta, ngModule) {\n      var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n\n      if (!compiledTemplate) {\n        assertComponent(compMeta);\n        compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n\n        this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n      }\n\n      return compiledTemplate;\n    };\n\n    JitCompiler.prototype._compileTemplate = function (template) {\n      var _this = this;\n\n      if (template.isCompiled) {\n        return;\n      }\n\n      var compMeta = template.compMeta;\n      var externalStylesheetsByModuleUrl = new Map();\n      var outputContext = createOutputContext();\n\n      var componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);\n\n      compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {\n        var compiledStylesheet = _this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\n\n        externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl, compiledStylesheet);\n      });\n\n      this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\n\n      var pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) {\n        return _this._metadataResolver.getPipeSummary(pipe.reference);\n      });\n\n      var _a = this._parseTemplate(compMeta, template.ngModule, template.directives),\n          parsedTemplate = _a.template,\n          usedPipes = _a.pipes;\n\n      var compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, ir.variable(componentStylesheet.stylesVar), usedPipes);\n\n      var evalResult = this._interpretOrJit(compile_metadata_1.templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\n\n      var viewClass = evalResult[compileResult.viewClassVar];\n      var rendererType = evalResult[compileResult.rendererTypeVar];\n      template.compiled(viewClass, rendererType);\n    };\n\n    JitCompiler.prototype._parseTemplate = function (compMeta, ngModule, directiveIdentifiers) {\n      var _this = this; // Note: ! is ok here as components always have a template.\n\n\n      var preserveWhitespaces = compMeta.template.preserveWhitespaces;\n      var directives = directiveIdentifiers.map(function (dir) {\n        return _this._metadataResolver.getDirectiveSummary(dir.reference);\n      });\n      var pipes = ngModule.transitiveModule.pipes.map(function (pipe) {\n        return _this._metadataResolver.getPipeSummary(pipe.reference);\n      });\n      return this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, compile_metadata_1.templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\n    };\n\n    JitCompiler.prototype._resolveStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n      var _this = this;\n\n      result.dependencies.forEach(function (dep, i) {\n        var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);\n\n        var nestedStylesArr = _this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n\n        dep.setValue(nestedStylesArr);\n      });\n    };\n\n    JitCompiler.prototype._resolveAndEvalStylesCompileResult = function (result, externalStylesheetsByModuleUrl) {\n      this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n\n      return this._interpretOrJit(compile_metadata_1.sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];\n    };\n\n    JitCompiler.prototype._interpretOrJit = function (sourceUrl, statements) {\n      if (!this._compilerConfig.useJit) {\n        return output_interpreter_1.interpretStatements(statements, this._reflector);\n      } else {\n        return this._jitEvaluator.evaluateStatements(sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);\n      }\n    };\n\n    return JitCompiler;\n  }();\n\n  exports.JitCompiler = JitCompiler;\n\n  var CompiledTemplate =\n  /** @class */\n  function () {\n    function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {\n      this.isHost = isHost;\n      this.compType = compType;\n      this.compMeta = compMeta;\n      this.ngModule = ngModule;\n      this.directives = directives;\n      this._viewClass = null;\n      this.isCompiled = false;\n    }\n\n    CompiledTemplate.prototype.compiled = function (viewClass, rendererType) {\n      this._viewClass = viewClass;\n      this.compMeta.componentViewType.setDelegate(viewClass);\n\n      for (var prop in rendererType) {\n        this.compMeta.rendererType[prop] = rendererType[prop];\n      }\n\n      this.isCompiled = true;\n    };\n\n    return CompiledTemplate;\n  }();\n\n  function assertComponent(meta) {\n    if (!meta.isComponent) {\n      throw new Error(\"Could not compile '\" + compile_metadata_1.identifierName(meta.type) + \"' because it is not a component.\");\n    }\n  }\n\n  function createOutputContext() {\n    var importExpr = function importExpr(symbol) {\n      return ir.importExpr({\n        name: compile_metadata_1.identifierName(symbol),\n        moduleName: null,\n        runtime: symbol\n      });\n    };\n\n    return {\n      statements: [],\n      genFilePath: '',\n      importExpr: importExpr,\n      constantPool: new constant_pool_1.ConstantPool()\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/jit/compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, CompileIdentifierMetadata, CompileNgModuleMetadata, CompilePipeSummary, CompileProviderMetadata, CompileStylesheetMetadata, CompileTypeSummary, identifierName, ngModuleJitUrl, ProviderMeta, ProxyClass, sharedStylesheetJitUrl, templateJitUrl, templateSourceUrl} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {CompilerConfig} from '../config';\nimport {ConstantPool} from '../constant_pool';\nimport {Type} from '../core';\nimport {CompileMetadataResolver} from '../metadata_resolver';\nimport {NgModuleCompiler} from '../ng_module_compiler';\nimport * as ir from '../output/output_ast';\nimport {interpretStatements} from '../output/output_interpreter';\nimport {JitEvaluator} from '../output/output_jit';\nimport {CompiledStylesheet, StyleCompiler} from '../style_compiler';\nimport {SummaryResolver} from '../summary_resolver';\nimport {TemplateAst} from '../template_parser/template_ast';\nimport {TemplateParser} from '../template_parser/template_parser';\nimport {Console, OutputContext, stringify, SyncAsync} from '../util';\nimport {ViewCompiler} from '../view_compiler/view_compiler';\n\nexport interface ModuleWithComponentFactories {\n  ngModuleFactory: object;\n  componentFactories: object[];\n}\n\n/**\n * An internal module of the Angular compiler that begins with component types,\n * extracts templates, and eventually produces a compiled version of the component\n * ready for linking into an application.\n *\n * @security  When compiling templates at runtime, you must ensure that the entire template comes\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\n * application to XSS risks.  For more detail, see the [Security Guide](https://g.co/ng/security).\n */\nexport class JitCompiler {\n  private _compiledTemplateCache = new Map<Type, CompiledTemplate>();\n  private _compiledHostTemplateCache = new Map<Type, CompiledTemplate>();\n  private _compiledDirectiveWrapperCache = new Map<Type, Type>();\n  private _compiledNgModuleCache = new Map<Type, object>();\n  private _sharedStylesheetCount = 0;\n  private _addedAotSummaries = new Set<() => any[]>();\n\n  constructor(\n      private _metadataResolver: CompileMetadataResolver, private _templateParser: TemplateParser,\n      private _styleCompiler: StyleCompiler, private _viewCompiler: ViewCompiler,\n      private _ngModuleCompiler: NgModuleCompiler, private _summaryResolver: SummaryResolver<Type>,\n      private _reflector: CompileReflector, private _jitEvaluator: JitEvaluator,\n      private _compilerConfig: CompilerConfig, private _console: Console,\n      private getExtraNgModuleProviders: (ngModule: any) => CompileProviderMetadata[]) {}\n\n  compileModuleSync(moduleType: Type): object {\n    return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\n  }\n\n  compileModuleAsync(moduleType: Type): Promise<object> {\n    return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\n  }\n\n  compileModuleAndAllComponentsSync(moduleType: Type): ModuleWithComponentFactories {\n    return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\n  }\n\n  compileModuleAndAllComponentsAsync(moduleType: Type): Promise<ModuleWithComponentFactories> {\n    return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\n  }\n\n  getComponentFactory(component: Type): object {\n    const summary = this._metadataResolver.getDirectiveSummary(component);\n    return summary.componentFactory as object;\n  }\n\n  loadAotSummaries(summaries: () => any[]) {\n    this.clearCache();\n    this._addAotSummaries(summaries);\n  }\n\n  private _addAotSummaries(fn: () => any[]) {\n    if (this._addedAotSummaries.has(fn)) {\n      return;\n    }\n    this._addedAotSummaries.add(fn);\n    const summaries = fn();\n    for (let i = 0; i < summaries.length; i++) {\n      const entry = summaries[i];\n      if (typeof entry === 'function') {\n        this._addAotSummaries(entry);\n      } else {\n        const summary = entry as CompileTypeSummary;\n        this._summaryResolver.addSummary(\n            {symbol: summary.type.reference, metadata: null, type: summary});\n      }\n    }\n  }\n\n  hasAotSummary(ref: Type) {\n    return !!this._summaryResolver.resolveSummary(ref);\n  }\n\n  private _filterJitIdentifiers(ids: CompileIdentifierMetadata[]): any[] {\n    return ids.map(mod => mod.reference).filter((ref) => !this.hasAotSummary(ref));\n  }\n\n  private _compileModuleAndComponents(moduleType: Type, isSync: boolean): SyncAsync<object> {\n    return SyncAsync.then(this._loadModules(moduleType, isSync), () => {\n      this._compileComponents(moduleType, null);\n      return this._compileModule(moduleType);\n    });\n  }\n\n  private _compileModuleAndAllComponents(moduleType: Type, isSync: boolean):\n      SyncAsync<ModuleWithComponentFactories> {\n    return SyncAsync.then(this._loadModules(moduleType, isSync), () => {\n      const componentFactories: object[] = [];\n      this._compileComponents(moduleType, componentFactories);\n      return {\n        ngModuleFactory: this._compileModule(moduleType),\n        componentFactories: componentFactories\n      };\n    });\n  }\n\n  private _loadModules(mainModule: any, isSync: boolean): SyncAsync<any> {\n    const loading: Promise<any>[] = [];\n    const mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule)!;\n    // Note: for runtime compilation, we want to transitively compile all modules,\n    // so we also need to load the declared directives / pipes for all nested modules.\n    this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach((nestedNgModule) => {\n      // getNgModuleMetadata only returns null if the value passed in is not an NgModule\n      const moduleMeta = this._metadataResolver.getNgModuleMetadata(nestedNgModule)!;\n      this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach((ref) => {\n        const promise =\n            this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\n        if (promise) {\n          loading.push(promise);\n        }\n      });\n      this._filterJitIdentifiers(moduleMeta.declaredPipes)\n          .forEach((ref) => this._metadataResolver.getOrLoadPipeMetadata(ref));\n    });\n    return SyncAsync.all(loading);\n  }\n\n  private _compileModule(moduleType: Type): object {\n    let ngModuleFactory = this._compiledNgModuleCache.get(moduleType)!;\n    if (!ngModuleFactory) {\n      const moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType)!;\n      // Always provide a bound Compiler\n      const extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);\n      const outputCtx = createOutputContext();\n      const compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);\n      ngModuleFactory = this._interpretOrJit(\n          ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];\n      this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);\n    }\n    return ngModuleFactory;\n  }\n\n  /**\n   * @internal\n   */\n  _compileComponents(mainModule: Type, allComponentFactories: object[]|null) {\n    const ngModule = this._metadataResolver.getNgModuleMetadata(mainModule)!;\n    const moduleByJitDirective = new Map<any, CompileNgModuleMetadata>();\n    const templates = new Set<CompiledTemplate>();\n\n    const transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\n    transJitModules.forEach((localMod) => {\n      const localModuleMeta = this._metadataResolver.getNgModuleMetadata(localMod)!;\n      this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {\n        moduleByJitDirective.set(dirRef, localModuleMeta);\n        const dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);\n        if (dirMeta.isComponent) {\n          templates.add(this._createCompiledTemplate(dirMeta, localModuleMeta));\n          if (allComponentFactories) {\n            const template =\n                this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n            templates.add(template);\n            allComponentFactories.push(dirMeta.componentFactory as object);\n          }\n        }\n      });\n    });\n    transJitModules.forEach((localMod) => {\n      const localModuleMeta = this._metadataResolver.getNgModuleMetadata(localMod)!;\n      this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {\n        const dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);\n        if (dirMeta.isComponent) {\n          dirMeta.entryComponents.forEach((entryComponentType) => {\n            const moduleMeta = moduleByJitDirective.get(entryComponentType.componentType)!;\n            templates.add(\n                this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n          });\n        }\n      });\n      localModuleMeta.entryComponents.forEach((entryComponentType) => {\n        if (!this.hasAotSummary(entryComponentType.componentType)) {\n          const moduleMeta = moduleByJitDirective.get(entryComponentType.componentType)!;\n          templates.add(\n              this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n        }\n      });\n    });\n    templates.forEach((template) => this._compileTemplate(template));\n  }\n\n  clearCacheFor(type: Type) {\n    this._compiledNgModuleCache.delete(type);\n    this._metadataResolver.clearCacheFor(type);\n    this._compiledHostTemplateCache.delete(type);\n    const compiledTemplate = this._compiledTemplateCache.get(type);\n    if (compiledTemplate) {\n      this._compiledTemplateCache.delete(type);\n    }\n  }\n\n  clearCache(): void {\n    // Note: don't clear the _addedAotSummaries, as they don't change!\n    this._metadataResolver.clearCache();\n    this._compiledTemplateCache.clear();\n    this._compiledHostTemplateCache.clear();\n    this._compiledNgModuleCache.clear();\n  }\n\n  private _createCompiledHostTemplate(compType: Type, ngModule: CompileNgModuleMetadata):\n      CompiledTemplate {\n    if (!ngModule) {\n      throw new Error(`Component ${\n          stringify(\n              compType)} is not part of any NgModule or the module has not been imported into your module.`);\n    }\n    let compiledTemplate = this._compiledHostTemplateCache.get(compType);\n    if (!compiledTemplate) {\n      const compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n      assertComponent(compMeta);\n\n      const hostMeta = this._metadataResolver.getHostComponentMetadata(\n          compMeta, (compMeta.componentFactory as any).viewDefFactory);\n      compiledTemplate =\n          new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n      this._compiledHostTemplateCache.set(compType, compiledTemplate);\n    }\n    return compiledTemplate;\n  }\n\n  private _createCompiledTemplate(\n      compMeta: CompileDirectiveMetadata, ngModule: CompileNgModuleMetadata): CompiledTemplate {\n    let compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n    if (!compiledTemplate) {\n      assertComponent(compMeta);\n      compiledTemplate = new CompiledTemplate(\n          false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n      this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n    }\n    return compiledTemplate;\n  }\n\n  private _compileTemplate(template: CompiledTemplate) {\n    if (template.isCompiled) {\n      return;\n    }\n    const compMeta = template.compMeta;\n    const externalStylesheetsByModuleUrl = new Map<string, CompiledStylesheet>();\n    const outputContext = createOutputContext();\n    const componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);\n    compMeta.template !.externalStylesheets.forEach((stylesheetMeta) => {\n      const compiledStylesheet =\n          this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\n      externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl!, compiledStylesheet);\n    });\n    this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\n    const pipes = template.ngModule.transitiveModule.pipes.map(\n        pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n    const {template: parsedTemplate, pipes: usedPipes} =\n        this._parseTemplate(compMeta, template.ngModule, template.directives);\n    const compileResult = this._viewCompiler.compileComponent(\n        outputContext, compMeta, parsedTemplate, ir.variable(componentStylesheet.stylesVar),\n        usedPipes);\n    const evalResult = this._interpretOrJit(\n        templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\n    const viewClass = evalResult[compileResult.viewClassVar];\n    const rendererType = evalResult[compileResult.rendererTypeVar];\n    template.compiled(viewClass, rendererType);\n  }\n\n  private _parseTemplate(\n      compMeta: CompileDirectiveMetadata, ngModule: CompileNgModuleMetadata,\n      directiveIdentifiers: CompileIdentifierMetadata[]):\n      {template: TemplateAst[], pipes: CompilePipeSummary[]} {\n    // Note: ! is ok here as components always have a template.\n    const preserveWhitespaces = compMeta.template !.preserveWhitespaces;\n    const directives =\n        directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n    const pipes = ngModule.transitiveModule.pipes.map(\n        pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n    return this._templateParser.parse(\n        compMeta, compMeta.template !.htmlAst!, directives, pipes, ngModule.schemas,\n        templateSourceUrl(ngModule.type, compMeta, compMeta.template !), preserveWhitespaces);\n  }\n\n  private _resolveStylesCompileResult(\n      result: CompiledStylesheet, externalStylesheetsByModuleUrl: Map<string, CompiledStylesheet>) {\n    result.dependencies.forEach((dep, i) => {\n      const nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl)!;\n      const nestedStylesArr = this._resolveAndEvalStylesCompileResult(\n          nestedCompileResult, externalStylesheetsByModuleUrl);\n      dep.setValue(nestedStylesArr);\n    });\n  }\n\n  private _resolveAndEvalStylesCompileResult(\n      result: CompiledStylesheet,\n      externalStylesheetsByModuleUrl: Map<string, CompiledStylesheet>): string[] {\n    this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n    return this._interpretOrJit(\n        sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++),\n        result.outputCtx.statements)[result.stylesVar];\n  }\n\n  private _interpretOrJit(sourceUrl: string, statements: ir.Statement[]): any {\n    if (!this._compilerConfig.useJit) {\n      return interpretStatements(statements, this._reflector);\n    } else {\n      return this._jitEvaluator.evaluateStatements(\n          sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);\n    }\n  }\n}\n\nclass CompiledTemplate {\n  private _viewClass: Function = null!;\n  isCompiled = false;\n\n  constructor(\n      public isHost: boolean, public compType: CompileIdentifierMetadata,\n      public compMeta: CompileDirectiveMetadata, public ngModule: CompileNgModuleMetadata,\n      public directives: CompileIdentifierMetadata[]) {}\n\n  compiled(viewClass: Function, rendererType: any) {\n    this._viewClass = viewClass;\n    (<ProxyClass>this.compMeta.componentViewType).setDelegate(viewClass);\n    for (let prop in rendererType) {\n      (<any>this.compMeta.rendererType)[prop] = rendererType[prop];\n    }\n    this.isCompiled = true;\n  }\n}\n\nfunction assertComponent(meta: CompileDirectiveMetadata) {\n  if (!meta.isComponent) {\n    throw new Error(\n        `Could not compile '${identifierName(meta.type)}' because it is not a component.`);\n  }\n}\n\nfunction createOutputContext(): OutputContext {\n  const importExpr = (symbol: any) =>\n      ir.importExpr({name: identifierName(symbol), moduleName: null, runtime: symbol});\n  return {statements: [], genFilePath: '', importExpr, constantPool: new ConstantPool()};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}