{"ast":null,"code":"'use strict';\n\nvar path = require('path');\n\nvar niceTry = require('nice-try');\n\nvar resolveCommand = require('./util/resolveCommand');\n\nvar escape = require('./util/escape');\n\nvar readShebang = require('./util/readShebang');\n\nvar semver = require('semver');\n\nvar isWin = process.platform === 'win32';\nvar isExecutableRegExp = /\\.(?:com|exe)$/i;\nvar isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i; // `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0\n\nvar supportsShellOption = niceTry(function () {\n  return semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true);\n}) || false;\n\nfunction detectShebang(parsed) {\n  parsed.file = resolveCommand(parsed);\n  var shebang = parsed.file && readShebang(parsed.file);\n\n  if (shebang) {\n    parsed.args.unshift(parsed.file);\n    parsed.command = shebang;\n    return resolveCommand(parsed);\n  }\n\n  return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n  if (!isWin) {\n    return parsed;\n  } // Detect & add support for shebangs\n\n\n  var commandFile = detectShebang(parsed); // We don't need a shell if the command filename is an executable\n\n  var needsShell = !isExecutableRegExp.test(commandFile); // If a shell is required, use cmd.exe and take care of escaping everything correctly\n  // Note that `forceShell` is an hidden option used only in tests\n\n  if (parsed.options.forceShell || needsShell) {\n    // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n    // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n    // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n    // we need to double escape them\n    var needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile); // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n    // This is necessary otherwise it will always fail with ENOENT in those cases\n\n    parsed.command = path.normalize(parsed.command); // Escape command & arguments\n\n    parsed.command = escape.command(parsed.command);\n    parsed.args = parsed.args.map(function (arg) {\n      return escape.argument(arg, needsDoubleEscapeMetaChars);\n    });\n    var shellCommand = [parsed.command].concat(parsed.args).join(' ');\n    parsed.args = ['/d', '/s', '/c', \"\\\"\".concat(shellCommand, \"\\\"\")];\n    parsed.command = process.env.comspec || 'cmd.exe';\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  }\n\n  return parsed;\n}\n\nfunction parseShell(parsed) {\n  // If node supports the shell option, there's no need to mimic its behavior\n  if (supportsShellOption) {\n    return parsed;\n  } // Mimic node shell option\n  // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n\n\n  var shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n  if (isWin) {\n    parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n    parsed.args = ['/d', '/s', '/c', \"\\\"\".concat(shellCommand, \"\\\"\")];\n    parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n  } else {\n    if (typeof parsed.options.shell === 'string') {\n      parsed.command = parsed.options.shell;\n    } else if (process.platform === 'android') {\n      parsed.command = '/system/bin/sh';\n    } else {\n      parsed.command = '/bin/sh';\n    }\n\n    parsed.args = ['-c', shellCommand];\n  }\n\n  return parsed;\n}\n\nfunction parse(command, args, options) {\n  // Normalize arguments, similar to nodejs\n  if (args && !Array.isArray(args)) {\n    options = args;\n    args = null;\n  }\n\n  args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n\n  options = Object.assign({}, options); // Clone object to avoid changing the original\n  // Build our parsed object\n\n  var parsed = {\n    command: command,\n    args: args,\n    options: options,\n    file: undefined,\n    original: {\n      command: command,\n      args: args\n    }\n  }; // Delegate further parsing to shell or non-shell\n\n  return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/cross-spawn/lib/parse.js"],"names":["path","require","niceTry","resolveCommand","escape","readShebang","semver","isWin","process","platform","isExecutableRegExp","isCmdShimRegExp","supportsShellOption","satisfies","version","detectShebang","parsed","file","shebang","args","unshift","command","parseNonShell","commandFile","needsShell","test","options","forceShell","needsDoubleEscapeMetaChars","normalize","map","arg","argument","shellCommand","concat","join","env","comspec","windowsVerbatimArguments","parseShell","shell","parse","Array","isArray","slice","Object","assign","undefined","original","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst path = require('path');\nconst niceTry = require('nice-try');\nconst resolveCommand = require('./util/resolveCommand');\nconst escape = require('./util/escape');\nconst readShebang = require('./util/readShebang');\nconst semver = require('semver');\n\nconst isWin = process.platform === 'win32';\nconst isExecutableRegExp = /\\.(?:com|exe)$/i;\nconst isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;\n\n// `options.shell` is supported in Node ^4.8.0, ^5.7.0 and >= 6.0.0\nconst supportsShellOption = niceTry(() => semver.satisfies(process.version, '^4.8.0 || ^5.7.0 || >= 6.0.0', true)) || false;\n\nfunction detectShebang(parsed) {\n    parsed.file = resolveCommand(parsed);\n\n    const shebang = parsed.file && readShebang(parsed.file);\n\n    if (shebang) {\n        parsed.args.unshift(parsed.file);\n        parsed.command = shebang;\n\n        return resolveCommand(parsed);\n    }\n\n    return parsed.file;\n}\n\nfunction parseNonShell(parsed) {\n    if (!isWin) {\n        return parsed;\n    }\n\n    // Detect & add support for shebangs\n    const commandFile = detectShebang(parsed);\n\n    // We don't need a shell if the command filename is an executable\n    const needsShell = !isExecutableRegExp.test(commandFile);\n\n    // If a shell is required, use cmd.exe and take care of escaping everything correctly\n    // Note that `forceShell` is an hidden option used only in tests\n    if (parsed.options.forceShell || needsShell) {\n        // Need to double escape meta chars if the command is a cmd-shim located in `node_modules/.bin/`\n        // The cmd-shim simply calls execute the package bin file with NodeJS, proxying any argument\n        // Because the escape of metachars with ^ gets interpreted when the cmd.exe is first called,\n        // we need to double escape them\n        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);\n\n        // Normalize posix paths into OS compatible paths (e.g.: foo/bar -> foo\\bar)\n        // This is necessary otherwise it will always fail with ENOENT in those cases\n        parsed.command = path.normalize(parsed.command);\n\n        // Escape command & arguments\n        parsed.command = escape.command(parsed.command);\n        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));\n\n        const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.command = process.env.comspec || 'cmd.exe';\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    }\n\n    return parsed;\n}\n\nfunction parseShell(parsed) {\n    // If node supports the shell option, there's no need to mimic its behavior\n    if (supportsShellOption) {\n        return parsed;\n    }\n\n    // Mimic node shell option\n    // See https://github.com/nodejs/node/blob/b9f6a2dc059a1062776133f3d4fd848c4da7d150/lib/child_process.js#L335\n    const shellCommand = [parsed.command].concat(parsed.args).join(' ');\n\n    if (isWin) {\n        parsed.command = typeof parsed.options.shell === 'string' ? parsed.options.shell : process.env.comspec || 'cmd.exe';\n        parsed.args = ['/d', '/s', '/c', `\"${shellCommand}\"`];\n        parsed.options.windowsVerbatimArguments = true; // Tell node's spawn that the arguments are already escaped\n    } else {\n        if (typeof parsed.options.shell === 'string') {\n            parsed.command = parsed.options.shell;\n        } else if (process.platform === 'android') {\n            parsed.command = '/system/bin/sh';\n        } else {\n            parsed.command = '/bin/sh';\n        }\n\n        parsed.args = ['-c', shellCommand];\n    }\n\n    return parsed;\n}\n\nfunction parse(command, args, options) {\n    // Normalize arguments, similar to nodejs\n    if (args && !Array.isArray(args)) {\n        options = args;\n        args = null;\n    }\n\n    args = args ? args.slice(0) : []; // Clone array to avoid changing the original\n    options = Object.assign({}, options); // Clone object to avoid changing the original\n\n    // Build our parsed object\n    const parsed = {\n        command,\n        args,\n        options,\n        file: undefined,\n        original: {\n            command,\n            args,\n        },\n    };\n\n    // Delegate further parsing to shell or non-shell\n    return options.shell ? parseShell(parsed) : parseNonShell(parsed);\n}\n\nmodule.exports = parse;\n"]},"metadata":{},"sourceType":"script"}