{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar debug = require(\"debug\")(\"streamroller:RollingFileWriteStream\");\n\nvar fs = require(\"fs-extra\");\n\nvar path = require(\"path\");\n\nvar newNow = require(\"./now\");\n\nvar format = require(\"date-format\");\n\nvar _require = require(\"stream\"),\n    Writable = _require.Writable;\n\nvar fileNameFormatter = require(\"./fileNameFormatter\");\n\nvar fileNameParser = require(\"./fileNameParser\");\n\nvar moveAndMaybeCompressFile = require(\"./moveAndMaybeCompressFile\");\n/**\n * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.\n * RollingFileWriteStream inherits from stream.Writable\n */\n\n\nvar RollingFileWriteStream = /*#__PURE__*/function (_Writable) {\n  \"use strict\";\n\n  _inherits(RollingFileWriteStream, _Writable);\n\n  var _super = _createSuper(RollingFileWriteStream);\n\n  /**\n   * Create a RollingFileWriteStream\n   * @constructor\n   * @param {string} filePath - The file path to write.\n   * @param {object} options - The extra options\n   * @param {number} options.numToKeep - The max numbers of files to keep.\n   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.\n   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.\n   * @param {string} options.mode - The mode of the files. The default is '0644'. Refer to stream.writable for more.\n   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.\n   * @param {boolean} options.compress - Whether to compress backup files.\n   * @param {boolean} options.keepFileExt - Whether to keep the file extension.\n   * @param {string} options.pattern - The date string pattern in the file name.\n   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.\n   */\n  function RollingFileWriteStream(filePath, options) {\n    var _this;\n\n    _classCallCheck(this, RollingFileWriteStream);\n\n    debug(\"constructor: creating RollingFileWriteStream. path=\".concat(filePath));\n    _this = _super.call(this, options);\n    _this.options = _this._parseOption(options);\n    _this.fileObject = path.parse(filePath);\n\n    if (_this.fileObject.dir === \"\") {\n      _this.fileObject = path.parse(path.join(process.cwd(), filePath));\n    }\n\n    _this.fileFormatter = fileNameFormatter({\n      file: _this.fileObject,\n      alwaysIncludeDate: _this.options.alwaysIncludePattern,\n      needsIndex: _this.options.maxSize < Number.MAX_SAFE_INTEGER,\n      compress: _this.options.compress,\n      keepFileExt: _this.options.keepFileExt\n    });\n    _this.fileNameParser = fileNameParser({\n      file: _this.fileObject,\n      keepFileExt: _this.options.keepFileExt,\n      pattern: _this.options.pattern\n    });\n    _this.state = {\n      currentSize: 0\n    };\n\n    if (_this.options.pattern) {\n      _this.state.currentDate = format(_this.options.pattern, newNow());\n    }\n\n    _this.filename = _this.fileFormatter({\n      index: 0,\n      date: _this.state.currentDate\n    });\n\n    if ([\"a\", \"a+\", \"as\", \"as+\"].includes(_this.options.flags)) {\n      _this._setExistingSizeAndDate();\n    }\n\n    debug(\"constructor: create new file \".concat(_this.filename, \", state=\").concat(JSON.stringify(_this.state)));\n\n    _this._renewWriteStream();\n\n    return _this;\n  }\n\n  _createClass(RollingFileWriteStream, [{\n    key: \"_setExistingSizeAndDate\",\n    value: function _setExistingSizeAndDate() {\n      try {\n        var stats = fs.statSync(this.filename);\n        this.state.currentSize = stats.size;\n\n        if (this.options.pattern) {\n          this.state.currentDate = format(this.options.pattern, stats.mtime);\n        }\n      } catch (e) {\n        //file does not exist, that's fine - move along\n        return;\n      }\n    }\n  }, {\n    key: \"_parseOption\",\n    value: function _parseOption(rawOptions) {\n      var defaultOptions = {\n        maxSize: Number.MAX_SAFE_INTEGER,\n        numToKeep: Number.MAX_SAFE_INTEGER,\n        encoding: \"utf8\",\n        mode: parseInt(\"0644\", 8),\n        flags: \"a\",\n        compress: false,\n        keepFileExt: false,\n        alwaysIncludePattern: false\n      };\n      var options = Object.assign({}, defaultOptions, rawOptions);\n\n      if (options.maxSize <= 0) {\n        throw new Error(\"options.maxSize (\".concat(options.maxSize, \") should be > 0\"));\n      }\n\n      if (options.numToKeep <= 0) {\n        throw new Error(\"options.numToKeep (\".concat(options.numToKeep, \") should be > 0\"));\n      }\n\n      debug(\"_parseOption: creating stream with option=\".concat(JSON.stringify(options)));\n      return options;\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(callback) {\n      this.currentFileStream.end(\"\", this.options.encoding, callback);\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, callback) {\n      var _this2 = this;\n\n      this._shouldRoll().then(function () {\n        debug(\"_write: writing chunk. \" + \"file=\".concat(_this2.currentFileStream.path, \" \") + \"state=\".concat(JSON.stringify(_this2.state), \" \") + \"chunk=\".concat(chunk));\n\n        _this2.currentFileStream.write(chunk, encoding, function (e) {\n          _this2.state.currentSize += chunk.length;\n          callback(e);\n        });\n      });\n    }\n  }, {\n    key: \"_shouldRoll\",\n    value: function () {\n      var _shouldRoll2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this._dateChanged() || this._tooBig())) {\n                  _context.next = 4;\n                  break;\n                }\n\n                debug(\"_shouldRoll: rolling because dateChanged? \".concat(this._dateChanged(), \" or tooBig? \").concat(this._tooBig()));\n                _context.next = 4;\n                return this._roll();\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _shouldRoll() {\n        return _shouldRoll2.apply(this, arguments);\n      }\n\n      return _shouldRoll;\n    }()\n  }, {\n    key: \"_dateChanged\",\n    value: function _dateChanged() {\n      return this.state.currentDate && this.state.currentDate !== format(this.options.pattern, newNow());\n    }\n  }, {\n    key: \"_tooBig\",\n    value: function _tooBig() {\n      return this.state.currentSize >= this.options.maxSize;\n    }\n  }, {\n    key: \"_roll\",\n    value: function _roll() {\n      var _this3 = this;\n\n      debug(\"_roll: closing the current stream\");\n      return new Promise(function (resolve, reject) {\n        _this3.currentFileStream.end(\"\", _this3.options.encoding, function () {\n          _this3._moveOldFiles().then(resolve).catch(reject);\n        });\n      });\n    }\n  }, {\n    key: \"_moveOldFiles\",\n    value: function () {\n      var _moveOldFiles2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this4 = this;\n\n        var files, todaysFiles, i, sourceFilePath, targetFilePath;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._getExistingFiles();\n\n              case 2:\n                files = _context2.sent;\n                todaysFiles = this.state.currentDate ? files.filter(function (f) {\n                  return f.date === _this4.state.currentDate;\n                }) : files;\n                i = todaysFiles.length;\n\n              case 5:\n                if (!(i >= 0)) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                debug(\"_moveOldFiles: i = \".concat(i));\n                sourceFilePath = this.fileFormatter({\n                  date: this.state.currentDate,\n                  index: i\n                });\n                targetFilePath = this.fileFormatter({\n                  date: this.state.currentDate,\n                  index: i + 1\n                });\n                _context2.next = 11;\n                return moveAndMaybeCompressFile(sourceFilePath, targetFilePath, this.options.compress && i === 0);\n\n              case 11:\n                i--;\n                _context2.next = 5;\n                break;\n\n              case 14:\n                this.state.currentSize = 0;\n                this.state.currentDate = this.state.currentDate ? format(this.options.pattern, newNow()) : null;\n                debug(\"_moveOldFiles: finished rolling files. state=\".concat(JSON.stringify(this.state)));\n\n                this._renewWriteStream(); // wait for the file to be open before cleaning up old ones,\n                // otherwise the daysToKeep calculations can be off\n\n\n                _context2.next = 20;\n                return new Promise(function (resolve, reject) {\n                  _this4.currentFileStream.write(\"\", \"utf8\", function () {\n                    _this4._clean().then(resolve).catch(reject);\n                  });\n                });\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _moveOldFiles() {\n        return _moveOldFiles2.apply(this, arguments);\n      }\n\n      return _moveOldFiles;\n    }() // Sorted from the oldest to the latest\n\n  }, {\n    key: \"_getExistingFiles\",\n    value: function () {\n      var _getExistingFiles2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this5 = this;\n\n        var files, existingFileDetails, getKey;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return fs.readdir(this.fileObject.dir).catch(function () {\n                  return [];\n                });\n\n              case 2:\n                files = _context3.sent;\n                debug(\"_getExistingFiles: files=\".concat(files));\n                existingFileDetails = files.map(function (n) {\n                  return _this5.fileNameParser(n);\n                }).filter(function (n) {\n                  return n;\n                });\n\n                getKey = function getKey(n) {\n                  return (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;\n                };\n\n                existingFileDetails.sort(function (a, b) {\n                  return getKey(a) - getKey(b);\n                });\n                return _context3.abrupt(\"return\", existingFileDetails);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _getExistingFiles() {\n        return _getExistingFiles2.apply(this, arguments);\n      }\n\n      return _getExistingFiles;\n    }()\n  }, {\n    key: \"_renewWriteStream\",\n    value: function _renewWriteStream() {\n      var _this6 = this;\n\n      fs.ensureDirSync(this.fileObject.dir);\n      var filePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: 0\n      });\n      var ops = {\n        flags: this.options.flags,\n        encoding: this.options.encoding,\n        mode: this.options.mode\n      };\n      this.currentFileStream = fs.createWriteStream(filePath, ops);\n      this.currentFileStream.on(\"error\", function (e) {\n        _this6.emit(\"error\", e);\n      });\n    }\n  }, {\n    key: \"_clean\",\n    value: function () {\n      var _clean2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _this7 = this;\n\n        var existingFileDetails, fileNamesToRemove;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._getExistingFiles();\n\n              case 2:\n                existingFileDetails = _context4.sent;\n                debug(\"_clean: numToKeep = \".concat(this.options.numToKeep, \", existingFiles = \").concat(existingFileDetails.length));\n                debug(\"_clean: existing files are: \", existingFileDetails);\n\n                if (!this._tooManyFiles(existingFileDetails.length)) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep - 1).map(function (f) {\n                  return path.format({\n                    dir: _this7.fileObject.dir,\n                    base: f.filename\n                  });\n                });\n                _context4.next = 9;\n                return deleteFiles(fileNamesToRemove);\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _clean() {\n        return _clean2.apply(this, arguments);\n      }\n\n      return _clean;\n    }()\n  }, {\n    key: \"_tooManyFiles\",\n    value: function _tooManyFiles(numFiles) {\n      return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;\n    }\n  }]);\n\n  return RollingFileWriteStream;\n}(Writable);\n\nvar deleteFiles = function deleteFiles(fileNames) {\n  debug(\"deleteFiles: files to delete: \".concat(fileNames));\n  return Promise.all(fileNames.map(function (f) {\n    return fs.unlink(f).catch(function (e) {\n      debug(\"deleteFiles: error when unlinking \".concat(f, \", ignoring. Error was \").concat(e));\n    });\n  }));\n};\n\nmodule.exports = RollingFileWriteStream;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/streamroller/lib/RollingFileWriteStream.js"],"names":["debug","require","fs","path","newNow","format","Writable","fileNameFormatter","fileNameParser","moveAndMaybeCompressFile","RollingFileWriteStream","filePath","options","_parseOption","fileObject","parse","dir","join","process","cwd","fileFormatter","file","alwaysIncludeDate","alwaysIncludePattern","needsIndex","maxSize","Number","MAX_SAFE_INTEGER","compress","keepFileExt","pattern","state","currentSize","currentDate","filename","index","date","includes","flags","_setExistingSizeAndDate","JSON","stringify","_renewWriteStream","stats","statSync","size","mtime","e","rawOptions","defaultOptions","numToKeep","encoding","mode","parseInt","Object","assign","Error","callback","currentFileStream","end","chunk","_shouldRoll","then","write","length","_dateChanged","_tooBig","_roll","Promise","resolve","reject","_moveOldFiles","catch","_getExistingFiles","files","todaysFiles","filter","f","i","sourceFilePath","targetFilePath","_clean","readdir","existingFileDetails","map","n","getKey","timestamp","getTime","sort","a","b","ensureDirSync","ops","createWriteStream","on","emit","_tooManyFiles","fileNamesToRemove","slice","base","deleteFiles","numFiles","fileNames","all","unlink","module","exports"],"mappings":"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","sourcesContent":["const debug = require(\"debug\")(\"streamroller:RollingFileWriteStream\");\nconst fs = require(\"fs-extra\");\nconst path = require(\"path\");\nconst newNow = require(\"./now\");\nconst format = require(\"date-format\");\nconst { Writable } = require(\"stream\");\nconst fileNameFormatter = require(\"./fileNameFormatter\");\nconst fileNameParser = require(\"./fileNameParser\");\nconst moveAndMaybeCompressFile = require(\"./moveAndMaybeCompressFile\");\n\n/**\n * RollingFileWriteStream is mainly used when writing to a file rolling by date or size.\n * RollingFileWriteStream inherits from stream.Writable\n */\nclass RollingFileWriteStream extends Writable {\n  /**\n   * Create a RollingFileWriteStream\n   * @constructor\n   * @param {string} filePath - The file path to write.\n   * @param {object} options - The extra options\n   * @param {number} options.numToKeep - The max numbers of files to keep.\n   * @param {number} options.maxSize - The maxSize one file can reach. Unit is Byte.\n   *                                   This should be more than 1024. The default is Number.MAX_SAFE_INTEGER.\n   * @param {string} options.mode - The mode of the files. The default is '0644'. Refer to stream.writable for more.\n   * @param {string} options.flags - The default is 'a'. Refer to stream.flags for more.\n   * @param {boolean} options.compress - Whether to compress backup files.\n   * @param {boolean} options.keepFileExt - Whether to keep the file extension.\n   * @param {string} options.pattern - The date string pattern in the file name.\n   * @param {boolean} options.alwaysIncludePattern - Whether to add date to the name of the first file.\n   */\n  constructor(filePath, options) {\n    debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);\n    super(options);\n    this.options = this._parseOption(options);\n    this.fileObject = path.parse(filePath);\n    if (this.fileObject.dir === \"\") {\n      this.fileObject = path.parse(path.join(process.cwd(), filePath));\n    }\n    this.fileFormatter = fileNameFormatter({\n      file: this.fileObject,\n      alwaysIncludeDate: this.options.alwaysIncludePattern,\n      needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,\n      compress: this.options.compress,\n      keepFileExt: this.options.keepFileExt\n    });\n\n    this.fileNameParser = fileNameParser({\n      file: this.fileObject,\n      keepFileExt: this.options.keepFileExt,\n      pattern: this.options.pattern\n    });\n\n    this.state = {\n      currentSize: 0\n    };\n\n    if (this.options.pattern) {\n      this.state.currentDate = format(this.options.pattern, newNow());\n    }\n\n    this.filename = this.fileFormatter({\n      index: 0,\n      date: this.state.currentDate\n    });\n    if ([\"a\", \"a+\", \"as\", \"as+\"].includes(this.options.flags)) {\n      this._setExistingSizeAndDate();\n    }\n\n    debug(\n      `constructor: create new file ${this.filename}, state=${JSON.stringify(\n        this.state\n      )}`\n    );\n    this._renewWriteStream();\n  }\n\n  _setExistingSizeAndDate() {\n    try {\n      const stats = fs.statSync(this.filename);\n      this.state.currentSize = stats.size;\n      if (this.options.pattern) {\n        this.state.currentDate = format(this.options.pattern, stats.mtime);\n      }\n    } catch (e) {\n      //file does not exist, that's fine - move along\n      return;\n    }\n  }\n\n  _parseOption(rawOptions) {\n    const defaultOptions = {\n      maxSize: Number.MAX_SAFE_INTEGER,\n      numToKeep: Number.MAX_SAFE_INTEGER,\n      encoding: \"utf8\",\n      mode: parseInt(\"0644\", 8),\n      flags: \"a\",\n      compress: false,\n      keepFileExt: false,\n      alwaysIncludePattern: false\n    };\n    const options = Object.assign({}, defaultOptions, rawOptions);\n    if (options.maxSize <= 0) {\n      throw new Error(`options.maxSize (${options.maxSize}) should be > 0`);\n    }\n    if (options.numToKeep <= 0) {\n      throw new Error(`options.numToKeep (${options.numToKeep}) should be > 0`);\n    }\n    debug(\n      `_parseOption: creating stream with option=${JSON.stringify(options)}`\n    );\n    return options;\n  }\n\n  _final(callback) {\n    this.currentFileStream.end(\"\", this.options.encoding, callback);\n  }\n\n  _write(chunk, encoding, callback) {\n    this._shouldRoll().then(() => {\n      debug(\n        `_write: writing chunk. ` +\n          `file=${this.currentFileStream.path} ` +\n          `state=${JSON.stringify(this.state)} ` +\n          `chunk=${chunk}`\n      );\n      this.currentFileStream.write(chunk, encoding, e => {\n        this.state.currentSize += chunk.length;\n        callback(e);\n      });\n    });\n  }\n\n  async _shouldRoll() {\n    if (this._dateChanged() || this._tooBig()) {\n      debug(\n        `_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`\n      );\n      await this._roll();\n    }\n  }\n\n  _dateChanged() {\n    return (\n      this.state.currentDate &&\n      this.state.currentDate !== format(this.options.pattern, newNow())\n    );\n  }\n\n  _tooBig() {\n    return this.state.currentSize >= this.options.maxSize;\n  }\n\n  _roll() {\n    debug(`_roll: closing the current stream`);\n    return new Promise((resolve, reject) => {\n      this.currentFileStream.end(\"\", this.options.encoding, () => {\n        this._moveOldFiles()\n          .then(resolve)\n          .catch(reject);\n      });\n    });\n  }\n\n  async _moveOldFiles() {\n    const files = await this._getExistingFiles();\n    const todaysFiles = this.state.currentDate\n      ? files.filter(f => f.date === this.state.currentDate)\n      : files;\n    for (let i = todaysFiles.length; i >= 0; i--) {\n      debug(`_moveOldFiles: i = ${i}`);\n      const sourceFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i\n      });\n      const targetFilePath = this.fileFormatter({\n        date: this.state.currentDate,\n        index: i + 1\n      });\n\n      await moveAndMaybeCompressFile(\n        sourceFilePath,\n        targetFilePath,\n        this.options.compress && i === 0\n      );\n    }\n\n    this.state.currentSize = 0;\n    this.state.currentDate = this.state.currentDate\n      ? format(this.options.pattern, newNow())\n      : null;\n    debug(\n      `_moveOldFiles: finished rolling files. state=${JSON.stringify(\n        this.state\n      )}`\n    );\n    this._renewWriteStream();\n    // wait for the file to be open before cleaning up old ones,\n    // otherwise the daysToKeep calculations can be off\n    await new Promise((resolve, reject) => {\n      this.currentFileStream.write(\"\", \"utf8\", () => {\n        this._clean()\n          .then(resolve)\n          .catch(reject);\n      });\n    });\n  }\n\n  // Sorted from the oldest to the latest\n  async _getExistingFiles() {\n    const files = await fs.readdir(this.fileObject.dir).catch(() => []);\n\n    debug(`_getExistingFiles: files=${files}`);\n    const existingFileDetails = files\n      .map(n => this.fileNameParser(n))\n      .filter(n => n);\n\n    const getKey = n =>\n      (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;\n    existingFileDetails.sort((a, b) => getKey(a) - getKey(b));\n\n    return existingFileDetails;\n  }\n\n  _renewWriteStream() {\n    fs.ensureDirSync(this.fileObject.dir);\n    const filePath = this.fileFormatter({\n      date: this.state.currentDate,\n      index: 0\n    });\n    const ops = {\n      flags: this.options.flags,\n      encoding: this.options.encoding,\n      mode: this.options.mode\n    };\n    this.currentFileStream = fs.createWriteStream(filePath, ops);\n    this.currentFileStream.on(\"error\", e => {\n      this.emit(\"error\", e);\n    });\n  }\n\n  async _clean() {\n    const existingFileDetails = await this._getExistingFiles();\n    debug(\n      `_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`\n    );\n    debug(\"_clean: existing files are: \", existingFileDetails);\n    if (this._tooManyFiles(existingFileDetails.length)) {\n      const fileNamesToRemove = existingFileDetails\n        .slice(0, existingFileDetails.length - this.options.numToKeep - 1)\n        .map(f => path.format({ dir: this.fileObject.dir, base: f.filename }));\n      await deleteFiles(fileNamesToRemove);\n    }\n  }\n\n  _tooManyFiles(numFiles) {\n    return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;\n  }\n}\n\nconst deleteFiles = fileNames => {\n  debug(`deleteFiles: files to delete: ${fileNames}`);\n  return Promise.all(fileNames.map(f => fs.unlink(f).catch((e) => {\n    debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);\n  })));\n};\n\nmodule.exports = RollingFileWriteStream;\n"]},"metadata":{},"sourceType":"script"}