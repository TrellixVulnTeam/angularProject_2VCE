{"ast":null,"code":"var _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nfunction resolveModuleName(request, issuer, compilerOptions, moduleResolutionHost, parentResolver) {\n  var pnp = require(\"pnpapi\");\n\n  var _request$match = request.match(/^(!(?:.*!)+)?((?!\\.{0,2}\\/)(?:@[^\\/]+\\/)?[^\\/]+)?(.*)/),\n      _request$match2 = _slicedToArray(_request$match, 4),\n      _request$match2$ = _request$match2[1],\n      prefix = _request$match2$ === void 0 ? \"\" : _request$match2$,\n      _request$match2$2 = _request$match2[2],\n      packageName = _request$match2$2 === void 0 ? \"\" : _request$match2$2,\n      rest = _request$match2[3];\n\n  var failedLookupLocations = []; // First we try the resolution on \"@types/package-name\" starting from the project root\n\n  if (packageName) {\n    var typesPackagePath = \"@types/\".concat(packageName.replace(/\\//g, \"__\")).concat(rest);\n    var unqualified;\n\n    try {\n      unqualified = pnp.resolveToUnqualified(typesPackagePath, issuer, {\n        considerBuiltins: false\n      });\n    } catch (error) {}\n\n    if (unqualified) {\n      // TypeScript checks whether the directory of the candidate is a directory\n      // which may cause issues w/ zip loading (since the zip archive is still\n      // reported as a file). To workaround this we add a trailing slash, which\n      // causes TypeScript to assume the parent is a directory.\n      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(unqualified)) unqualified += \"/\";\n      var finalResolution = parentResolver(unqualified, issuer, compilerOptions, moduleResolutionHost);\n\n      if (finalResolution.resolvedModule || finalResolution.resolvedTypeReferenceDirective) {\n        return finalResolution;\n      } else {\n        failedLookupLocations = failedLookupLocations.concat(finalResolution.failedLookupLocations);\n      }\n    }\n  } // Then we try on \"package-name\", this time starting from the package that makes the request\n\n\n  if (true) {\n    var regularPackagePath = \"\".concat(packageName || \"\").concat(rest);\n\n    var _unqualified;\n\n    try {\n      _unqualified = pnp.resolveToUnqualified(regularPackagePath, issuer, {\n        considerBuiltins: false\n      });\n    } catch (error) {}\n\n    if (_unqualified) {\n      // TypeScript checks whether the directory of the candidate is a directory\n      // which may cause issues w/ zip loading (since the zip archive is still\n      // reported as a file). To workaround this we add a trailing slash, which\n      // causes TypeScript to assume the parent is a directory.\n      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(_unqualified)) _unqualified += \"/\";\n\n      var _finalResolution = parentResolver(_unqualified, issuer, compilerOptions, moduleResolutionHost);\n\n      if (_finalResolution.resolvedModule || _finalResolution.resolvedTypeReferenceDirective) {\n        return _finalResolution;\n      } else {\n        failedLookupLocations = failedLookupLocations.concat(_finalResolution.failedLookupLocations);\n      }\n    }\n  }\n\n  return {\n    resolvedModule: undefined,\n    resolvedTypeReferenceDirective: undefined,\n    failedLookupLocations: failedLookupLocations\n  };\n}\n\nmodule.exports.resolveModuleName = process.versions.pnp ? resolveModuleName : function (moduleName, containingFile, compilerOptions, compilerHost, resolveModuleName) {\n  return resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost);\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/ts-pnp/index.js"],"names":["resolveModuleName","request","issuer","compilerOptions","moduleResolutionHost","parentResolver","pnp","require","match","prefix","packageName","rest","failedLookupLocations","typesPackagePath","replace","unqualified","resolveToUnqualified","considerBuiltins","error","directoryExists","finalResolution","resolvedModule","resolvedTypeReferenceDirective","concat","regularPackagePath","undefined","module","exports","process","versions","moduleName","containingFile","compilerHost"],"mappings":";;AAAA,SAASA,iBAAT,CAA2BC,OAA3B,EAAoCC,MAApC,EAA4CC,eAA5C,EAA6DC,oBAA7D,EAAmFC,cAAnF,EAAmG;AACjG,MAAMC,GAAG,GAAGC,OAAO,UAAnB;;AAEA,uBAAgDN,OAAO,CAACO,KAAR,CAAc,uDAAd,CAAhD;AAAA;AAAA;AAAA,MAASC,MAAT;AAAA;AAAA,MAAsBC,WAAtB;AAAA,MAAwCC,IAAxC;;AAEA,MAAIC,qBAAqB,GAAG,EAA5B,CALiG,CAOjG;;AACA,MAAIF,WAAJ,EAAiB;AACf,QAAMG,gBAAgB,oBAAaH,WAAW,CAACI,OAAZ,CAAoB,KAApB,OAAb,SAAgDH,IAAhD,CAAtB;AAEA,QAAII,WAAJ;;AACA,QAAI;AACFA,MAAAA,WAAW,GAAGT,GAAG,CAACU,oBAAJ,CAAyBH,gBAAzB,EAA2CX,MAA3C,EAAmD;AAACe,QAAAA,gBAAgB,EAAE;AAAnB,OAAnD,CAAd;AACD,KAFD,CAEE,OAAOC,KAAP,EAAc,CAAE;;AAElB,QAAIH,WAAJ,EAAiB;AACf;AACA;AACA;AACA;AACA,UAAIX,oBAAoB,CAACe,eAArB,IAAwCf,oBAAoB,CAACe,eAArB,CAAqCJ,WAArC,CAA5C,EACEA,WAAW,OAAX;AAEF,UAAMK,eAAe,GAAGf,cAAc,CAACU,WAAD,EAAcb,MAAd,EAAsBC,eAAtB,EAAuCC,oBAAvC,CAAtC;;AAEA,UAAIgB,eAAe,CAACC,cAAhB,IAAkCD,eAAe,CAACE,8BAAtD,EAAsF;AACpF,eAAOF,eAAP;AACD,OAFD,MAEO;AACLR,QAAAA,qBAAqB,GAAGA,qBAAqB,CAACW,MAAtB,CAA6BH,eAAe,CAACR,qBAA7C,CAAxB;AACD;AACF;AACF,GAhCgG,CAkCjG;;;AACA,MAAI,IAAJ,EAAU;AACR,QAAMY,kBAAkB,aAAMd,WAAW,MAAjB,SAA0BC,IAA1B,CAAxB;;AAEA,QAAII,YAAJ;;AACA,QAAI;AACFA,MAAAA,YAAW,GAAGT,GAAG,CAACU,oBAAJ,CAAyBQ,kBAAzB,EAA6CtB,MAA7C,EAAqD;AAACe,QAAAA,gBAAgB,EAAE;AAAnB,OAArD,CAAd;AACD,KAFD,CAEE,OAAOC,KAAP,EAAc,CAAE;;AAElB,QAAIH,YAAJ,EAAiB;AACf;AACA;AACA;AACA;AACA,UAAIX,oBAAoB,CAACe,eAArB,IAAwCf,oBAAoB,CAACe,eAArB,CAAqCJ,YAArC,CAA5C,EACEA,YAAW,OAAX;;AAEF,UAAMK,gBAAe,GAAGf,cAAc,CAACU,YAAD,EAAcb,MAAd,EAAsBC,eAAtB,EAAuCC,oBAAvC,CAAtC;;AAEA,UAAIgB,gBAAe,CAACC,cAAhB,IAAkCD,gBAAe,CAACE,8BAAtD,EAAsF;AACpF,eAAOF,gBAAP;AACD,OAFD,MAEO;AACLR,QAAAA,qBAAqB,GAAGA,qBAAqB,CAACW,MAAtB,CAA6BH,gBAAe,CAACR,qBAA7C,CAAxB;AACD;AACF;AACF;;AAED,SAAO;AACLS,IAAAA,cAAc,EAAEI,SADX;AAELH,IAAAA,8BAA8B,EAAEG,SAF3B;AAGLb,IAAAA,qBAAqB,EAArBA;AAHK,GAAP;AAKD;;AAEDc,MAAM,CAACC,OAAP,CAAe3B,iBAAf,GAAmC4B,OAAO,CAACC,QAAR,CAAiBvB,GAAjB,GAC/BN,iBAD+B,GAE/B,UAAC8B,UAAD,EAAaC,cAAb,EAA6B5B,eAA7B,EAA8C6B,YAA9C,EAA4DhC,iBAA5D;AAAA,SACEA,iBAAiB,CAAC8B,UAAD,EAAaC,cAAb,EAA6B5B,eAA7B,EAA8C6B,YAA9C,CADnB;AAAA,CAFJ","sourcesContent":["function resolveModuleName(request, issuer, compilerOptions, moduleResolutionHost, parentResolver) {\n  const pnp = require(`pnpapi`);\n\n  const [, prefix = ``, packageName = ``, rest] = request.match(/^(!(?:.*!)+)?((?!\\.{0,2}\\/)(?:@[^\\/]+\\/)?[^\\/]+)?(.*)/);\n\n  let failedLookupLocations = [];\n\n  // First we try the resolution on \"@types/package-name\" starting from the project root\n  if (packageName) {\n    const typesPackagePath = `@types/${packageName.replace(/\\//g, `__`)}${rest}`;\n\n    let unqualified;\n    try {\n      unqualified = pnp.resolveToUnqualified(typesPackagePath, issuer, {considerBuiltins: false});\n    } catch (error) {}\n\n    if (unqualified) {\n      // TypeScript checks whether the directory of the candidate is a directory\n      // which may cause issues w/ zip loading (since the zip archive is still\n      // reported as a file). To workaround this we add a trailing slash, which\n      // causes TypeScript to assume the parent is a directory.\n      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(unqualified))\n        unqualified += `/`;\n\n      const finalResolution = parentResolver(unqualified, issuer, compilerOptions, moduleResolutionHost);\n\n      if (finalResolution.resolvedModule || finalResolution.resolvedTypeReferenceDirective) {\n        return finalResolution;\n      } else {\n        failedLookupLocations = failedLookupLocations.concat(finalResolution.failedLookupLocations);\n      }\n    }\n  }\n\n  // Then we try on \"package-name\", this time starting from the package that makes the request\n  if (true) {\n    const regularPackagePath = `${packageName || ``}${rest}`;\n\n    let unqualified;\n    try {\n      unqualified = pnp.resolveToUnqualified(regularPackagePath, issuer, {considerBuiltins: false});\n    } catch (error) {}\n\n    if (unqualified) {\n      // TypeScript checks whether the directory of the candidate is a directory\n      // which may cause issues w/ zip loading (since the zip archive is still\n      // reported as a file). To workaround this we add a trailing slash, which\n      // causes TypeScript to assume the parent is a directory.\n      if (moduleResolutionHost.directoryExists && moduleResolutionHost.directoryExists(unqualified))\n        unqualified += `/`;\n\n      const finalResolution = parentResolver(unqualified, issuer, compilerOptions, moduleResolutionHost);\n\n      if (finalResolution.resolvedModule || finalResolution.resolvedTypeReferenceDirective) {\n        return finalResolution;\n      } else {\n        failedLookupLocations = failedLookupLocations.concat(finalResolution.failedLookupLocations);\n      }\n    }\n  }\n\n  return {\n    resolvedModule: undefined,\n    resolvedTypeReferenceDirective: undefined,\n    failedLookupLocations,\n  };\n}\n\nmodule.exports.resolveModuleName = process.versions.pnp\n  ? resolveModuleName\n  : (moduleName, containingFile, compilerOptions, compilerHost, resolveModuleName) =>\n      resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost);\n"]},"metadata":{},"sourceType":"script"}