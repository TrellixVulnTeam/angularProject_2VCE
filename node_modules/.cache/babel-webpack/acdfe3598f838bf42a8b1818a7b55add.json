{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/ml_parser/ast\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/ast_path\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.findNode = exports.RecursiveVisitor = exports.visitAll = exports.Comment = exports.Element = exports.Attribute = exports.ExpansionCase = exports.Expansion = exports.Text = exports.NodeWithI18n = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ast_path_1 = require(\"@angular/compiler/src/ast_path\");\n\n  var NodeWithI18n =\n  /** @class */\n  function () {\n    function NodeWithI18n(sourceSpan, i18n) {\n      this.sourceSpan = sourceSpan;\n      this.i18n = i18n;\n    }\n\n    return NodeWithI18n;\n  }();\n\n  exports.NodeWithI18n = NodeWithI18n;\n\n  var Text =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Text, _super);\n\n    function Text(value, sourceSpan, i18n) {\n      var _this = _super.call(this, sourceSpan, i18n) || this;\n\n      _this.value = value;\n      return _this;\n    }\n\n    Text.prototype.visit = function (visitor, context) {\n      return visitor.visitText(this, context);\n    };\n\n    return Text;\n  }(NodeWithI18n);\n\n  exports.Text = Text;\n\n  var Expansion =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Expansion, _super);\n\n    function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n      var _this = _super.call(this, sourceSpan, i18n) || this;\n\n      _this.switchValue = switchValue;\n      _this.type = type;\n      _this.cases = cases;\n      _this.switchValueSourceSpan = switchValueSourceSpan;\n      return _this;\n    }\n\n    Expansion.prototype.visit = function (visitor, context) {\n      return visitor.visitExpansion(this, context);\n    };\n\n    return Expansion;\n  }(NodeWithI18n);\n\n  exports.Expansion = Expansion;\n\n  var ExpansionCase =\n  /** @class */\n  function () {\n    function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n      this.value = value;\n      this.expression = expression;\n      this.sourceSpan = sourceSpan;\n      this.valueSourceSpan = valueSourceSpan;\n      this.expSourceSpan = expSourceSpan;\n    }\n\n    ExpansionCase.prototype.visit = function (visitor, context) {\n      return visitor.visitExpansionCase(this, context);\n    };\n\n    return ExpansionCase;\n  }();\n\n  exports.ExpansionCase = ExpansionCase;\n\n  var Attribute =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Attribute, _super);\n\n    function Attribute(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n      var _this = _super.call(this, sourceSpan, i18n) || this;\n\n      _this.name = name;\n      _this.value = value;\n      _this.keySpan = keySpan;\n      _this.valueSpan = valueSpan;\n      return _this;\n    }\n\n    Attribute.prototype.visit = function (visitor, context) {\n      return visitor.visitAttribute(this, context);\n    };\n\n    return Attribute;\n  }(NodeWithI18n);\n\n  exports.Attribute = Attribute;\n\n  var Element =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Element, _super);\n\n    function Element(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n      if (endSourceSpan === void 0) {\n        endSourceSpan = null;\n      }\n\n      var _this = _super.call(this, sourceSpan, i18n) || this;\n\n      _this.name = name;\n      _this.attrs = attrs;\n      _this.children = children;\n      _this.startSourceSpan = startSourceSpan;\n      _this.endSourceSpan = endSourceSpan;\n      return _this;\n    }\n\n    Element.prototype.visit = function (visitor, context) {\n      return visitor.visitElement(this, context);\n    };\n\n    return Element;\n  }(NodeWithI18n);\n\n  exports.Element = Element;\n\n  var Comment =\n  /** @class */\n  function () {\n    function Comment(value, sourceSpan) {\n      this.value = value;\n      this.sourceSpan = sourceSpan;\n    }\n\n    Comment.prototype.visit = function (visitor, context) {\n      return visitor.visitComment(this, context);\n    };\n\n    return Comment;\n  }();\n\n  exports.Comment = Comment;\n\n  function visitAll(visitor, nodes, context) {\n    if (context === void 0) {\n      context = null;\n    }\n\n    var result = [];\n    var visit = visitor.visit ? function (ast) {\n      return visitor.visit(ast, context) || ast.visit(visitor, context);\n    } : function (ast) {\n      return ast.visit(visitor, context);\n    };\n    nodes.forEach(function (ast) {\n      var astResult = visit(ast);\n\n      if (astResult) {\n        result.push(astResult);\n      }\n    });\n    return result;\n  }\n\n  exports.visitAll = visitAll;\n\n  var RecursiveVisitor =\n  /** @class */\n  function () {\n    function RecursiveVisitor() {}\n\n    RecursiveVisitor.prototype.visitElement = function (ast, context) {\n      this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.children);\n      });\n    };\n\n    RecursiveVisitor.prototype.visitAttribute = function (ast, context) {};\n\n    RecursiveVisitor.prototype.visitText = function (ast, context) {};\n\n    RecursiveVisitor.prototype.visitComment = function (ast, context) {};\n\n    RecursiveVisitor.prototype.visitExpansion = function (ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.cases);\n      });\n    };\n\n    RecursiveVisitor.prototype.visitExpansionCase = function (ast, context) {};\n\n    RecursiveVisitor.prototype.visitChildren = function (context, cb) {\n      var results = [];\n      var t = this;\n\n      function visit(children) {\n        if (children) results.push(visitAll(t, children, context));\n      }\n\n      cb(visit);\n      return Array.prototype.concat.apply([], results);\n    };\n\n    return RecursiveVisitor;\n  }();\n\n  exports.RecursiveVisitor = RecursiveVisitor;\n\n  function spanOf(ast) {\n    var start = ast.sourceSpan.start.offset;\n    var end = ast.sourceSpan.end.offset;\n\n    if (ast instanceof Element) {\n      if (ast.endSourceSpan) {\n        end = ast.endSourceSpan.end.offset;\n      } else if (ast.children && ast.children.length) {\n        end = spanOf(ast.children[ast.children.length - 1]).end;\n      }\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  }\n\n  function findNode(nodes, position) {\n    var path = [];\n    var visitor = new (\n    /** @class */\n    function (_super) {\n      tslib_1.__extends(class_1, _super);\n\n      function class_1() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      class_1.prototype.visit = function (ast, context) {\n        var span = spanOf(ast);\n\n        if (span.start <= position && position < span.end) {\n          path.push(ast);\n        } else {\n          // Returning a value here will result in the children being skipped.\n          return true;\n        }\n      };\n\n      return class_1;\n    }(RecursiveVisitor))();\n    visitAll(visitor, nodes);\n    return new ast_path_1.AstPath(path, position);\n  }\n\n  exports.findNode = findNode;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/ml_parser/ast.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AstPath} from '../ast_path';\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\ninterface BaseNode {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport type Node = Attribute|Comment|Element|Expansion|ExpansionCase|Text;\n\nexport abstract class NodeWithI18n implements BaseNode {\n  constructor(public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  abstract visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text extends NodeWithI18n {\n  constructor(public value: string, sourceSpan: ParseSourceSpan, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\nexport class Expansion extends NodeWithI18n {\n  constructor(\n      public switchValue: string, public type: string, public cases: ExpansionCase[],\n      sourceSpan: ParseSourceSpan, public switchValueSourceSpan: ParseSourceSpan, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansion(this, context);\n  }\n}\n\nexport class ExpansionCase implements BaseNode {\n  constructor(\n      public value: string, public expression: Node[], public sourceSpan: ParseSourceSpan,\n      public valueSourceSpan: ParseSourceSpan, public expSourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitExpansionCase(this, context);\n  }\n}\n\nexport class Attribute extends NodeWithI18n {\n  constructor(\n      public name: string, public value: string, sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan?: ParseSourceSpan,\n      i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitAttribute(this, context);\n  }\n}\n\nexport class Element extends NodeWithI18n {\n  constructor(\n      public name: string, public attrs: Attribute[], public children: Node[],\n      sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null = null, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\nexport class Comment implements BaseNode {\n  constructor(public value: string|null, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any {\n    return visitor.visitComment(this, context);\n  }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit ?\n      (ast: Node) => visitor.visit!(ast, context) || ast.visit(visitor, context) :\n      (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nexport class RecursiveVisitor implements Visitor {\n  constructor() {}\n\n  visitElement(ast: Element, context: any): any {\n    this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.children);\n    });\n  }\n\n  visitAttribute(ast: Attribute, context: any): any {}\n  visitText(ast: Text, context: any): any {}\n  visitComment(ast: Comment, context: any): any {}\n\n  visitExpansion(ast: Expansion, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.cases);\n    });\n  }\n\n  visitExpansionCase(ast: ExpansionCase, context: any): any {}\n\n  private visitChildren<T extends Node>(\n      context: any, cb: (visit: (<V extends Node>(children: V[]|undefined) => void)) => void) {\n    let results: any[][] = [];\n    let t = this;\n    function visit<T extends Node>(children: T[]|undefined) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n\nexport type HtmlAstPath = AstPath<Node>;\n\nfunction spanOf(ast: Node) {\n  const start = ast.sourceSpan.start.offset;\n  let end = ast.sourceSpan.end.offset;\n  if (ast instanceof Element) {\n    if (ast.endSourceSpan) {\n      end = ast.endSourceSpan.end.offset;\n    } else if (ast.children && ast.children.length) {\n      end = spanOf(ast.children[ast.children.length - 1]).end;\n    }\n  }\n  return {start, end};\n}\n\nexport function findNode(nodes: Node[], position: number): HtmlAstPath {\n  const path: Node[] = [];\n\n  const visitor = new class extends RecursiveVisitor {\n    visit(ast: Node, context: any): any {\n      const span = spanOf(ast);\n      if (span.start <= position && position < span.end) {\n        path.push(ast);\n      } else {\n        // Returning a value here will result in the children being skipped.\n        return true;\n      }\n    }\n  };\n\n  visitAll(visitor, nodes);\n\n  return new AstPath<Node>(path, position);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}