{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics/src/diagnostic\", [\"require\", \"exports\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isTemplateDiagnostic = exports.makeTemplateDiagnostic = void 0;\n\n  var ts = require(\"typescript\");\n  /**\n   * Constructs a `ts.Diagnostic` for a given `ParseSourceSpan` within a template.\n   */\n\n\n  function makeTemplateDiagnostic(templateId, mapping, span, category, code, messageText, relatedMessage) {\n    if (mapping.type === 'direct') {\n      var relatedInformation = undefined;\n\n      if (relatedMessage !== undefined) {\n        relatedInformation = [{\n          category: ts.DiagnosticCategory.Message,\n          code: 0,\n          file: mapping.node.getSourceFile(),\n          start: relatedMessage.span.start.offset,\n          length: relatedMessage.span.end.offset - relatedMessage.span.start.offset,\n          messageText: relatedMessage.text\n        }];\n      } // For direct mappings, the error is shown inline as ngtsc was able to pinpoint a string\n      // constant within the `@Component` decorator for the template. This allows us to map the error\n      // directly into the bytes of the source file.\n\n\n      return {\n        source: 'ngtsc',\n        code: code,\n        category: category,\n        messageText: messageText,\n        file: mapping.node.getSourceFile(),\n        componentFile: mapping.node.getSourceFile(),\n        templateId: templateId,\n        start: span.start.offset,\n        length: span.end.offset - span.start.offset,\n        relatedInformation: relatedInformation\n      };\n    } else if (mapping.type === 'indirect' || mapping.type === 'external') {\n      // For indirect mappings (template was declared inline, but ngtsc couldn't map it directly\n      // to a string constant in the decorator), the component's file name is given with a suffix\n      // indicating it's not the TS file being displayed, but a template.\n      // For external temoplates, the HTML filename is used.\n      var componentSf = mapping.componentClass.getSourceFile();\n      var componentName = mapping.componentClass.name.text; // TODO(alxhub): remove cast when TS in g3 supports this narrowing.\n\n      var fileName = mapping.type === 'indirect' ? componentSf.fileName + \" (\" + componentName + \" template)\" : mapping.templateUrl; // TODO(alxhub): investigate creating a fake `ts.SourceFile` here instead of invoking the TS\n      // parser against the template (HTML is just really syntactically invalid TypeScript code ;).\n      // Also investigate caching the file to avoid running the parser multiple times.\n\n      var sf = ts.createSourceFile(fileName, mapping.template, ts.ScriptTarget.Latest, false, ts.ScriptKind.JSX);\n      var relatedInformation = [];\n\n      if (relatedMessage !== undefined) {\n        relatedInformation.push({\n          category: ts.DiagnosticCategory.Message,\n          code: 0,\n          file: sf,\n          start: relatedMessage.span.start.offset,\n          length: relatedMessage.span.end.offset - relatedMessage.span.start.offset,\n          messageText: relatedMessage.text\n        });\n      }\n\n      relatedInformation.push({\n        category: ts.DiagnosticCategory.Message,\n        code: 0,\n        file: componentSf,\n        // mapping.node represents either the 'template' or 'templateUrl' expression. getStart()\n        // and getEnd() are used because they don't include surrounding whitespace.\n        start: mapping.node.getStart(),\n        length: mapping.node.getEnd() - mapping.node.getStart(),\n        messageText: \"Error occurs in the template of component \" + componentName + \".\"\n      });\n      return {\n        source: 'ngtsc',\n        category: category,\n        code: code,\n        messageText: messageText,\n        file: sf,\n        componentFile: componentSf,\n        templateId: templateId,\n        start: span.start.offset,\n        length: span.end.offset - span.start.offset,\n        // Show a secondary message indicating the component whose template contains the error.\n        relatedInformation: relatedInformation\n      };\n    } else {\n      throw new Error(\"Unexpected source mapping type: \" + mapping.type);\n    }\n  }\n\n  exports.makeTemplateDiagnostic = makeTemplateDiagnostic;\n\n  function isTemplateDiagnostic(diagnostic) {\n    return diagnostic.hasOwnProperty('componentFile') && ts.isSourceFile(diagnostic.componentFile);\n  }\n\n  exports.isTemplateDiagnostic = isTemplateDiagnostic;\n});","map":{"version":3,"sources":["../../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/diagnostics/src/diagnostic.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ExternalTemplateSourceMapping, TemplateId, TemplateSourceMapping} from '../../api';\n\n/**\n * A `ts.Diagnostic` with additional information about the diagnostic related to template\n * type-checking.\n */\nexport interface TemplateDiagnostic extends ts.Diagnostic {\n  /**\n   * The component with the template that resulted in this diagnostic.\n   */\n  componentFile: ts.SourceFile;\n\n  /**\n   * The template id of the component that resulted in this diagnostic.\n   */\n  templateId: TemplateId;\n}\n\n/**\n * Constructs a `ts.Diagnostic` for a given `ParseSourceSpan` within a template.\n */\nexport function makeTemplateDiagnostic(\n    templateId: TemplateId, mapping: TemplateSourceMapping, span: ParseSourceSpan,\n    category: ts.DiagnosticCategory, code: number, messageText: string|ts.DiagnosticMessageChain,\n    relatedMessage?: {\n      text: string,\n      span: ParseSourceSpan,\n    }): TemplateDiagnostic {\n  if (mapping.type === 'direct') {\n    let relatedInformation: ts.DiagnosticRelatedInformation[]|undefined = undefined;\n    if (relatedMessage !== undefined) {\n      relatedInformation = [{\n        category: ts.DiagnosticCategory.Message,\n        code: 0,\n        file: mapping.node.getSourceFile(),\n        start: relatedMessage.span.start.offset,\n        length: relatedMessage.span.end.offset - relatedMessage.span.start.offset,\n        messageText: relatedMessage.text,\n      }];\n    }\n    // For direct mappings, the error is shown inline as ngtsc was able to pinpoint a string\n    // constant within the `@Component` decorator for the template. This allows us to map the error\n    // directly into the bytes of the source file.\n    return {\n      source: 'ngtsc',\n      code,\n      category,\n      messageText,\n      file: mapping.node.getSourceFile(),\n      componentFile: mapping.node.getSourceFile(),\n      templateId,\n      start: span.start.offset,\n      length: span.end.offset - span.start.offset,\n      relatedInformation,\n    };\n  } else if (mapping.type === 'indirect' || mapping.type === 'external') {\n    // For indirect mappings (template was declared inline, but ngtsc couldn't map it directly\n    // to a string constant in the decorator), the component's file name is given with a suffix\n    // indicating it's not the TS file being displayed, but a template.\n    // For external temoplates, the HTML filename is used.\n    const componentSf = mapping.componentClass.getSourceFile();\n    const componentName = mapping.componentClass.name.text;\n    // TODO(alxhub): remove cast when TS in g3 supports this narrowing.\n    const fileName = mapping.type === 'indirect' ?\n        `${componentSf.fileName} (${componentName} template)` :\n        (mapping as ExternalTemplateSourceMapping).templateUrl;\n    // TODO(alxhub): investigate creating a fake `ts.SourceFile` here instead of invoking the TS\n    // parser against the template (HTML is just really syntactically invalid TypeScript code ;).\n    // Also investigate caching the file to avoid running the parser multiple times.\n    const sf = ts.createSourceFile(\n        fileName, mapping.template, ts.ScriptTarget.Latest, false, ts.ScriptKind.JSX);\n\n    let relatedInformation: ts.DiagnosticRelatedInformation[] = [];\n    if (relatedMessage !== undefined) {\n      relatedInformation.push({\n        category: ts.DiagnosticCategory.Message,\n        code: 0,\n        file: sf,\n        start: relatedMessage.span.start.offset,\n        length: relatedMessage.span.end.offset - relatedMessage.span.start.offset,\n        messageText: relatedMessage.text,\n      });\n    }\n\n    relatedInformation.push({\n      category: ts.DiagnosticCategory.Message,\n      code: 0,\n      file: componentSf,\n      // mapping.node represents either the 'template' or 'templateUrl' expression. getStart()\n      // and getEnd() are used because they don't include surrounding whitespace.\n      start: mapping.node.getStart(),\n      length: mapping.node.getEnd() - mapping.node.getStart(),\n      messageText: `Error occurs in the template of component ${componentName}.`,\n    });\n\n    return {\n      source: 'ngtsc',\n      category,\n      code,\n      messageText,\n      file: sf,\n      componentFile: componentSf,\n      templateId,\n      start: span.start.offset,\n      length: span.end.offset - span.start.offset,\n      // Show a secondary message indicating the component whose template contains the error.\n      relatedInformation,\n    };\n  } else {\n    throw new Error(`Unexpected source mapping type: ${(mapping as {type: string}).type}`);\n  }\n}\n\nexport function isTemplateDiagnostic(diagnostic: ts.Diagnostic): diagnostic is TemplateDiagnostic {\n  return diagnostic.hasOwnProperty('componentFile') &&\n      ts.isSourceFile((diagnostic as any).componentFile);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}