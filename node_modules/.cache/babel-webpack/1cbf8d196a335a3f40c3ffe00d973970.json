{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n    REGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n    REGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n    REGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n    REGEXP_NAME = /\\[name\\]/gi,\n    REGEXP_ID = /\\[id\\]/gi,\n    REGEXP_MODULEID = /\\[moduleid\\]/gi,\n    REGEXP_FILE = /\\[file\\]/gi,\n    REGEXP_QUERY = /\\[query\\]/gi,\n    REGEXP_FILEBASE = /\\[filebase\\]/gi,\n    REGEXP_URL = /\\[url\\]/gi; // Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\n\nvar REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n    REGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n    REGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n    REGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nvar withHashLength = function withHashLength(replacer, handlerFn, assetInfo) {\n  var fn = function fn(match, hashLength) {\n    if (assetInfo) assetInfo.immutable = true;\n    var length = hashLength && parseInt(hashLength, 10);\n\n    if (length && handlerFn) {\n      return handlerFn(length);\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    var hash = replacer.apply(void 0, [match, hashLength].concat(args));\n    return length ? hash.slice(0, length) : hash;\n  };\n\n  return fn;\n};\n\nvar getReplacer = function getReplacer(value, allowEmpty) {\n  var fn = function fn(match) {\n    var _ref;\n\n    // last argument in replacer is the entire input string\n    var input = (_ref = (arguments.length <= 1 ? 0 : arguments.length - 1) - 1 + 1, _ref < 1 || arguments.length <= _ref ? undefined : arguments[_ref]);\n\n    if (value === null || value === undefined) {\n      if (!allowEmpty) {\n        throw new Error(\"Path variable \".concat(match, \" not implemented in this context: \").concat(input));\n      }\n\n      return \"\";\n    } else {\n      return \"\".concat(escapePathVariables(value));\n    }\n  };\n\n  return fn;\n};\n\nvar escapePathVariables = function escapePathVariables(value) {\n  return typeof value === \"string\" ? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\") : value;\n};\n\nvar replacePathVariables = function replacePathVariables(path, data, assetInfo) {\n  var chunk = data.chunk;\n  var chunkId = chunk && chunk.id;\n  var chunkName = chunk && (chunk.name || chunk.id);\n  var chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n  var chunkHashWithLength = chunk && chunk.hashWithLength;\n  var contentHashType = data.contentHashType;\n  var contentHash = chunk && chunk.contentHash && chunk.contentHash[contentHashType] || data.contentHash;\n  var contentHashWithLength = chunk && chunk.contentHashWithLength && chunk.contentHashWithLength[contentHashType] || data.contentHashWithLength;\n  var module = data.module;\n  var moduleId = module && module.id;\n  var moduleHash = module && (module.renderedHash || module.hash);\n  var moduleHashWithLength = module && module.hashWithLength;\n\n  if (typeof path === \"function\") {\n    path = path(data);\n  }\n\n  if (data.noChunkHash && (REGEXP_CHUNKHASH_FOR_TEST.test(path) || REGEXP_CONTENTHASH_FOR_TEST.test(path))) {\n    throw new Error(\"Cannot use [chunkhash] or [contenthash] for chunk in '\".concat(path, \"' (use [hash] instead)\"));\n  }\n\n  return path.replace(REGEXP_HASH, withHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)).replace(REGEXP_CHUNKHASH, withHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)).replace(REGEXP_CONTENTHASH, withHashLength(getReplacer(contentHash), contentHashWithLength, assetInfo)).replace(REGEXP_MODULEHASH, withHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)).replace(REGEXP_ID, getReplacer(chunkId)).replace(REGEXP_MODULEID, getReplacer(moduleId)).replace(REGEXP_NAME, getReplacer(chunkName)).replace(REGEXP_FILE, getReplacer(data.filename)).replace(REGEXP_FILEBASE, getReplacer(data.basename)) // query is optional, it's OK if it's in a path but there's nothing to replace it with\n  .replace(REGEXP_QUERY, getReplacer(data.query, true)) // only available in sourceMappingURLComment\n  .replace(REGEXP_URL, getReplacer(data.url)).replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\");\n};\n\nvar TemplatedPathPlugin = /*#__PURE__*/function () {\n  function TemplatedPathPlugin() {\n    _classCallCheck(this, TemplatedPathPlugin);\n  }\n\n  _createClass(TemplatedPathPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      compiler.hooks.compilation.tap(\"TemplatedPathPlugin\", function (compilation) {\n        var mainTemplate = compilation.mainTemplate;\n        mainTemplate.hooks.assetPath.tap(\"TemplatedPathPlugin\", replacePathVariables);\n        mainTemplate.hooks.globalHash.tap(\"TemplatedPathPlugin\", function (chunk, paths) {\n          var outputOptions = mainTemplate.outputOptions;\n          var publicPath = outputOptions.publicPath || \"\";\n          var filename = outputOptions.filename || \"\";\n          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n          if (REGEXP_HASH_FOR_TEST.test(publicPath) || REGEXP_CHUNKHASH_FOR_TEST.test(publicPath) || REGEXP_CONTENTHASH_FOR_TEST.test(publicPath) || REGEXP_NAME_FOR_TEST.test(publicPath)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n          if (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n        });\n        mainTemplate.hooks.hashForChunk.tap(\"TemplatedPathPlugin\", function (hash, chunk) {\n          var outputOptions = mainTemplate.outputOptions;\n          var chunkFilename = outputOptions.chunkFilename || outputOptions.filename;\n\n          if (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n          }\n\n          if (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).contentHash.javascript || {}));\n          }\n\n          if (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n            hash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n          }\n        });\n      });\n    }\n  }]);\n\n  return TemplatedPathPlugin;\n}();\n\nmodule.exports = TemplatedPathPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/TemplatedPathPlugin.js"],"names":["REGEXP_HASH","REGEXP_CHUNKHASH","REGEXP_MODULEHASH","REGEXP_CONTENTHASH","REGEXP_NAME","REGEXP_ID","REGEXP_MODULEID","REGEXP_FILE","REGEXP_QUERY","REGEXP_FILEBASE","REGEXP_URL","REGEXP_HASH_FOR_TEST","RegExp","source","REGEXP_CHUNKHASH_FOR_TEST","REGEXP_CONTENTHASH_FOR_TEST","REGEXP_NAME_FOR_TEST","withHashLength","replacer","handlerFn","assetInfo","fn","match","hashLength","immutable","length","parseInt","args","hash","slice","getReplacer","value","allowEmpty","input","undefined","Error","escapePathVariables","replace","replacePathVariables","path","data","chunk","chunkId","id","chunkName","name","chunkHash","renderedHash","chunkHashWithLength","hashWithLength","contentHashType","contentHash","contentHashWithLength","module","moduleId","moduleHash","moduleHashWithLength","noChunkHash","test","filename","basename","query","url","TemplatedPathPlugin","compiler","hooks","compilation","tap","mainTemplate","assetPath","globalHash","paths","outputOptions","publicPath","chunkFilename","join","hashForChunk","update","JSON","stringify","getChunkMaps","javascript","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Jason Anderson @diurnalist\n*/\n\"use strict\";\n\nconst REGEXP_HASH = /\\[hash(?::(\\d+))?\\]/gi,\n\tREGEXP_CHUNKHASH = /\\[chunkhash(?::(\\d+))?\\]/gi,\n\tREGEXP_MODULEHASH = /\\[modulehash(?::(\\d+))?\\]/gi,\n\tREGEXP_CONTENTHASH = /\\[contenthash(?::(\\d+))?\\]/gi,\n\tREGEXP_NAME = /\\[name\\]/gi,\n\tREGEXP_ID = /\\[id\\]/gi,\n\tREGEXP_MODULEID = /\\[moduleid\\]/gi,\n\tREGEXP_FILE = /\\[file\\]/gi,\n\tREGEXP_QUERY = /\\[query\\]/gi,\n\tREGEXP_FILEBASE = /\\[filebase\\]/gi,\n\tREGEXP_URL = /\\[url\\]/gi;\n\n// Using global RegExp for .test is dangerous\n// We use a normal RegExp instead of .test\nconst REGEXP_HASH_FOR_TEST = new RegExp(REGEXP_HASH.source, \"i\"),\n\tREGEXP_CHUNKHASH_FOR_TEST = new RegExp(REGEXP_CHUNKHASH.source, \"i\"),\n\tREGEXP_CONTENTHASH_FOR_TEST = new RegExp(REGEXP_CONTENTHASH.source, \"i\"),\n\tREGEXP_NAME_FOR_TEST = new RegExp(REGEXP_NAME.source, \"i\");\n\nconst withHashLength = (replacer, handlerFn, assetInfo) => {\n\tconst fn = (match, hashLength, ...args) => {\n\t\tif (assetInfo) assetInfo.immutable = true;\n\t\tconst length = hashLength && parseInt(hashLength, 10);\n\t\tif (length && handlerFn) {\n\t\t\treturn handlerFn(length);\n\t\t}\n\t\tconst hash = replacer(match, hashLength, ...args);\n\t\treturn length ? hash.slice(0, length) : hash;\n\t};\n\treturn fn;\n};\n\nconst getReplacer = (value, allowEmpty) => {\n\tconst fn = (match, ...args) => {\n\t\t// last argument in replacer is the entire input string\n\t\tconst input = args[args.length - 1];\n\t\tif (value === null || value === undefined) {\n\t\t\tif (!allowEmpty) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Path variable ${match} not implemented in this context: ${input}`\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn \"\";\n\t\t} else {\n\t\t\treturn `${escapePathVariables(value)}`;\n\t\t}\n\t};\n\treturn fn;\n};\n\nconst escapePathVariables = value => {\n\treturn typeof value === \"string\"\n\t\t? value.replace(/\\[(\\\\*[\\w:]+\\\\*)\\]/gi, \"[\\\\$1\\\\]\")\n\t\t: value;\n};\n\nconst replacePathVariables = (path, data, assetInfo) => {\n\tconst chunk = data.chunk;\n\tconst chunkId = chunk && chunk.id;\n\tconst chunkName = chunk && (chunk.name || chunk.id);\n\tconst chunkHash = chunk && (chunk.renderedHash || chunk.hash);\n\tconst chunkHashWithLength = chunk && chunk.hashWithLength;\n\tconst contentHashType = data.contentHashType;\n\tconst contentHash =\n\t\t(chunk && chunk.contentHash && chunk.contentHash[contentHashType]) ||\n\t\tdata.contentHash;\n\tconst contentHashWithLength =\n\t\t(chunk &&\n\t\t\tchunk.contentHashWithLength &&\n\t\t\tchunk.contentHashWithLength[contentHashType]) ||\n\t\tdata.contentHashWithLength;\n\tconst module = data.module;\n\tconst moduleId = module && module.id;\n\tconst moduleHash = module && (module.renderedHash || module.hash);\n\tconst moduleHashWithLength = module && module.hashWithLength;\n\n\tif (typeof path === \"function\") {\n\t\tpath = path(data);\n\t}\n\n\tif (\n\t\tdata.noChunkHash &&\n\t\t(REGEXP_CHUNKHASH_FOR_TEST.test(path) ||\n\t\t\tREGEXP_CONTENTHASH_FOR_TEST.test(path))\n\t) {\n\t\tthrow new Error(\n\t\t\t`Cannot use [chunkhash] or [contenthash] for chunk in '${path}' (use [hash] instead)`\n\t\t);\n\t}\n\n\treturn (\n\t\tpath\n\t\t\t.replace(\n\t\t\t\tREGEXP_HASH,\n\t\t\t\twithHashLength(getReplacer(data.hash), data.hashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_CHUNKHASH,\n\t\t\t\twithHashLength(getReplacer(chunkHash), chunkHashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_CONTENTHASH,\n\t\t\t\twithHashLength(\n\t\t\t\t\tgetReplacer(contentHash),\n\t\t\t\t\tcontentHashWithLength,\n\t\t\t\t\tassetInfo\n\t\t\t\t)\n\t\t\t)\n\t\t\t.replace(\n\t\t\t\tREGEXP_MODULEHASH,\n\t\t\t\twithHashLength(getReplacer(moduleHash), moduleHashWithLength, assetInfo)\n\t\t\t)\n\t\t\t.replace(REGEXP_ID, getReplacer(chunkId))\n\t\t\t.replace(REGEXP_MODULEID, getReplacer(moduleId))\n\t\t\t.replace(REGEXP_NAME, getReplacer(chunkName))\n\t\t\t.replace(REGEXP_FILE, getReplacer(data.filename))\n\t\t\t.replace(REGEXP_FILEBASE, getReplacer(data.basename))\n\t\t\t// query is optional, it's OK if it's in a path but there's nothing to replace it with\n\t\t\t.replace(REGEXP_QUERY, getReplacer(data.query, true))\n\t\t\t// only available in sourceMappingURLComment\n\t\t\t.replace(REGEXP_URL, getReplacer(data.url))\n\t\t\t.replace(/\\[\\\\(\\\\*[\\w:]+\\\\*)\\\\\\]/gi, \"[$1]\")\n\t);\n};\n\nclass TemplatedPathPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"TemplatedPathPlugin\", compilation => {\n\t\t\tconst mainTemplate = compilation.mainTemplate;\n\n\t\t\tmainTemplate.hooks.assetPath.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\treplacePathVariables\n\t\t\t);\n\n\t\t\tmainTemplate.hooks.globalHash.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\t(chunk, paths) => {\n\t\t\t\t\tconst outputOptions = mainTemplate.outputOptions;\n\t\t\t\t\tconst publicPath = outputOptions.publicPath || \"\";\n\t\t\t\t\tconst filename = outputOptions.filename || \"\";\n\t\t\t\t\tconst chunkFilename =\n\t\t\t\t\t\toutputOptions.chunkFilename || outputOptions.filename;\n\t\t\t\t\tif (\n\t\t\t\t\t\tREGEXP_HASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_CHUNKHASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_CONTENTHASH_FOR_TEST.test(publicPath) ||\n\t\t\t\t\t\tREGEXP_NAME_FOR_TEST.test(publicPath)\n\t\t\t\t\t)\n\t\t\t\t\t\treturn true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(filename)) return true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(chunkFilename)) return true;\n\t\t\t\t\tif (REGEXP_HASH_FOR_TEST.test(paths.join(\"|\"))) return true;\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tmainTemplate.hooks.hashForChunk.tap(\n\t\t\t\t\"TemplatedPathPlugin\",\n\t\t\t\t(hash, chunk) => {\n\t\t\t\t\tconst outputOptions = mainTemplate.outputOptions;\n\t\t\t\t\tconst chunkFilename =\n\t\t\t\t\t\toutputOptions.chunkFilename || outputOptions.filename;\n\t\t\t\t\tif (REGEXP_CHUNKHASH_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(JSON.stringify(chunk.getChunkMaps(true).hash));\n\t\t\t\t\t}\n\t\t\t\t\tif (REGEXP_CONTENTHASH_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(\n\t\t\t\t\t\t\tJSON.stringify(\n\t\t\t\t\t\t\t\tchunk.getChunkMaps(true).contentHash.javascript || {}\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tif (REGEXP_NAME_FOR_TEST.test(chunkFilename)) {\n\t\t\t\t\t\thash.update(JSON.stringify(chunk.getChunkMaps(true).name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = TemplatedPathPlugin;\n"]},"metadata":{},"sourceType":"script"}