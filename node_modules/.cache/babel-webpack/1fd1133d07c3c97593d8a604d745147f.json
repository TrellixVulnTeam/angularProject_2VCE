{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTranslationLoader = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar crypto_1 = require(\"crypto\");\n\nvar fs = require(\"fs\");\n\nfunction createTranslationLoader() {\n  return _createTranslationLoader.apply(this, arguments);\n}\n\nfunction _createTranslationLoader() {\n  _createTranslationLoader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var _yield$importParsers, parsers, diagnostics, analyze;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            analyze = function _analyze(parser, path, content) {\n              if (parser.analyze !== undefined) {\n                return parser.analyze(path, content);\n              } else {\n                var hint = parser.canParse(path, content);\n                return {\n                  canParse: hint !== false,\n                  hint: hint,\n                  diagnostics: diagnostics\n                };\n              }\n            };\n\n            _context.next = 3;\n            return importParsers();\n\n          case 3:\n            _yield$importParsers = _context.sent;\n            parsers = _yield$importParsers.parsers;\n            diagnostics = _yield$importParsers.diagnostics;\n            return _context.abrupt(\"return\", function (path) {\n              var content = fs.readFileSync(path, 'utf8');\n              var unusedParsers = new Map();\n\n              for (var _i = 0, _Object$entries = Object.entries(parsers); _i < _Object$entries.length; _i++) {\n                var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                    format = _Object$entries$_i[0],\n                    parser = _Object$entries$_i[1];\n\n                var analysis = analyze(parser, path, content);\n\n                if (analysis.canParse) {\n                  var _parser$parse = parser.parse(path, content, analysis.hint),\n                      locale = _parser$parse.locale,\n                      translations = _parser$parse.translations;\n\n                  var integrity = 'sha256-' + crypto_1.createHash('sha256').update(content).digest('base64');\n                  return {\n                    format: format,\n                    locale: locale,\n                    translations: translations,\n                    diagnostics: diagnostics,\n                    integrity: integrity\n                  };\n                } else {\n                  unusedParsers.set(parser, analysis);\n                }\n              }\n\n              var messages = [];\n\n              var _iterator = _createForOfIteratorHelper(unusedParsers.entries()),\n                  _step;\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var _step$value = _slicedToArray(_step.value, 2),\n                      _parser = _step$value[0],\n                      _analysis = _step$value[1];\n\n                  messages.push(_analysis.diagnostics.formatDiagnostics(\"*** \".concat(_parser.constructor.name, \" ***\")));\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              throw new Error(\"Unsupported translation file format in \".concat(path, \". The following parsers were tried:\\n\") + messages.join('\\n'));\n            });\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _createTranslationLoader.apply(this, arguments);\n}\n\nexports.createTranslationLoader = createTranslationLoader;\n\nfunction importParsers() {\n  return _importParsers.apply(this, arguments);\n}\n\nfunction _importParsers() {\n  _importParsers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    var localizeDiag, _diagnostics, parsers;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.prev = 0;\n            _context2.next = 3;\n            return Promise.resolve().then(function () {\n              return require('@angular/localize/src/tools/src/diagnostics');\n            });\n\n          case 3:\n            localizeDiag = _context2.sent;\n            _diagnostics = new localizeDiag.Diagnostics();\n            _context2.next = 7;\n            return Promise.resolve().then(function () {\n              return require( // tslint:disable-next-line:trailing-comma\n              '@angular/localize/src/tools/src/translate/translation_files/translation_parsers/simple_json_translation_parser');\n            });\n\n          case 7:\n            _context2.t0 = _context2.sent.SimpleJsonTranslationParser;\n            _context2.t1 = new _context2.t0();\n            _context2.next = 11;\n            return Promise.resolve().then(function () {\n              return require( // tslint:disable-next-line:trailing-comma\n              '@angular/localize/src/tools/src/translate/translation_files/translation_parsers/xliff1_translation_parser');\n            });\n\n          case 11:\n            _context2.t2 = _context2.sent.Xliff1TranslationParser;\n            _context2.t3 = new _context2.t2();\n            _context2.next = 15;\n            return Promise.resolve().then(function () {\n              return require( // tslint:disable-next-line:trailing-comma\n              '@angular/localize/src/tools/src/translate/translation_files/translation_parsers/xliff2_translation_parser');\n            });\n\n          case 15:\n            _context2.t4 = _context2.sent.Xliff2TranslationParser;\n            _context2.t5 = new _context2.t4();\n            _context2.next = 19;\n            return Promise.resolve().then(function () {\n              return require( // tslint:disable-next-line:trailing-comma\n              '@angular/localize/src/tools/src/translate/translation_files/translation_parsers/xtb_translation_parser');\n            });\n\n          case 19:\n            _context2.t6 = _context2.sent.XtbTranslationParser;\n            _context2.t7 = new _context2.t6();\n            parsers = {\n              json: _context2.t1,\n              xlf: _context2.t3,\n              xlf2: _context2.t5,\n              xmb: _context2.t7\n            };\n            return _context2.abrupt(\"return\", {\n              parsers: parsers,\n              diagnostics: _diagnostics\n            });\n\n          case 25:\n            _context2.prev = 25;\n            _context2.t8 = _context2[\"catch\"](0);\n            throw new Error(\"Unable to load translation file parsers. Please ensure '@angular/localize' is installed.\");\n\n          case 28:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[0, 25]]);\n  }));\n  return _importParsers.apply(this, arguments);\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/src/utils/load-translations.js"],"names":["Object","defineProperty","exports","value","createTranslationLoader","crypto_1","require","fs","analyze","parser","path","content","undefined","hint","canParse","diagnostics","importParsers","parsers","readFileSync","unusedParsers","Map","entries","format","analysis","parse","locale","translations","integrity","createHash","update","digest","set","messages","push","formatDiagnostics","constructor","name","Error","join","Promise","resolve","then","localizeDiag","Diagnostics","SimpleJsonTranslationParser","Xliff1TranslationParser","Xliff2TranslationParser","XtbTranslationParser","json","xlf","xlf2","xmb"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createTranslationLoader = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst crypto_1 = require(\"crypto\");\nconst fs = require(\"fs\");\nasync function createTranslationLoader() {\n    const { parsers, diagnostics } = await importParsers();\n    return (path) => {\n        const content = fs.readFileSync(path, 'utf8');\n        const unusedParsers = new Map();\n        for (const [format, parser] of Object.entries(parsers)) {\n            const analysis = analyze(parser, path, content);\n            if (analysis.canParse) {\n                const { locale, translations } = parser.parse(path, content, analysis.hint);\n                const integrity = 'sha256-' + crypto_1.createHash('sha256').update(content).digest('base64');\n                return { format, locale, translations, diagnostics, integrity };\n            }\n            else {\n                unusedParsers.set(parser, analysis);\n            }\n        }\n        const messages = [];\n        for (const [parser, analysis] of unusedParsers.entries()) {\n            messages.push(analysis.diagnostics.formatDiagnostics(`*** ${parser.constructor.name} ***`));\n        }\n        throw new Error(`Unsupported translation file format in ${path}. The following parsers were tried:\\n` +\n            messages.join('\\n'));\n    };\n    // TODO: `parser.canParse()` is deprecated; remove this polyfill once we are sure all parsers provide the `parser.analyze()` method.\n    // tslint:disable-next-line: no-any\n    function analyze(parser, path, content) {\n        if (parser.analyze !== undefined) {\n            return parser.analyze(path, content);\n        }\n        else {\n            const hint = parser.canParse(path, content);\n            return { canParse: hint !== false, hint, diagnostics };\n        }\n    }\n}\nexports.createTranslationLoader = createTranslationLoader;\nasync function importParsers() {\n    try {\n        const localizeDiag = await Promise.resolve().then(() => require('@angular/localize/src/tools/src/diagnostics'));\n        const diagnostics = new localizeDiag.Diagnostics();\n        const parsers = {\n            json: new (await Promise.resolve().then(() => require(\n            // tslint:disable-next-line:trailing-comma\n            '@angular/localize/src/tools/src/translate/translation_files/translation_parsers/simple_json_translation_parser'))).SimpleJsonTranslationParser(),\n            xlf: new (await Promise.resolve().then(() => require(\n            // tslint:disable-next-line:trailing-comma\n            '@angular/localize/src/tools/src/translate/translation_files/translation_parsers/xliff1_translation_parser'))).Xliff1TranslationParser(),\n            xlf2: new (await Promise.resolve().then(() => require(\n            // tslint:disable-next-line:trailing-comma\n            '@angular/localize/src/tools/src/translate/translation_files/translation_parsers/xliff2_translation_parser'))).Xliff2TranslationParser(),\n            // The name ('xmb') needs to match the AOT compiler option\n            xmb: new (await Promise.resolve().then(() => require(\n            // tslint:disable-next-line:trailing-comma\n            '@angular/localize/src/tools/src/translate/translation_files/translation_parsers/xtb_translation_parser'))).XtbTranslationParser(),\n        };\n        return { parsers, diagnostics };\n    }\n    catch (_a) {\n        throw new Error(`Unable to load translation file parsers. Please ensure '@angular/localize' is installed.`);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}