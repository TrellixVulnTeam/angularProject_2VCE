{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getExtensionDescription = getExtensionDescription;\nexports.ExplorerBase = void 0;\n\nvar _path = _interopRequireDefault(require(\"path\"));\n\nvar _loaders = require(\"./loaders\");\n\nvar _getPropertyByPath = require(\"./getPropertyByPath\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ExplorerBase = /*#__PURE__*/function () {\n  function ExplorerBase(options) {\n    _classCallCheck(this, ExplorerBase);\n\n    if (options.cache === true) {\n      this.loadCache = new Map();\n      this.searchCache = new Map();\n    }\n\n    this.config = options;\n    this.validateConfig();\n  }\n\n  _createClass(ExplorerBase, [{\n    key: \"clearLoadCache\",\n    value: function clearLoadCache() {\n      if (this.loadCache) {\n        this.loadCache.clear();\n      }\n    }\n  }, {\n    key: \"clearSearchCache\",\n    value: function clearSearchCache() {\n      if (this.searchCache) {\n        this.searchCache.clear();\n      }\n    }\n  }, {\n    key: \"clearCaches\",\n    value: function clearCaches() {\n      this.clearLoadCache();\n      this.clearSearchCache();\n    }\n  }, {\n    key: \"validateConfig\",\n    value: function validateConfig() {\n      var config = this.config;\n      config.searchPlaces.forEach(function (place) {\n        var loaderKey = _path.default.extname(place) || 'noExt';\n        var loader = config.loaders[loaderKey];\n\n        if (!loader) {\n          throw new Error(\"No loader specified for \".concat(getExtensionDescription(place), \", so searchPlaces item \\\"\").concat(place, \"\\\" is invalid\"));\n        }\n\n        if (typeof loader !== 'function') {\n          throw new Error(\"loader for \".concat(getExtensionDescription(place), \" is not a function (type provided: \\\"\").concat(typeof loader, \"\\\"), so searchPlaces item \\\"\").concat(place, \"\\\" is invalid\"));\n        }\n      });\n    }\n  }, {\n    key: \"shouldSearchStopWithResult\",\n    value: function shouldSearchStopWithResult(result) {\n      if (result === null) return false;\n      if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n      return true;\n    }\n  }, {\n    key: \"nextDirectoryToSearch\",\n    value: function nextDirectoryToSearch(currentDir, currentResult) {\n      if (this.shouldSearchStopWithResult(currentResult)) {\n        return null;\n      }\n\n      var nextDir = nextDirUp(currentDir);\n\n      if (nextDir === currentDir || currentDir === this.config.stopDir) {\n        return null;\n      }\n\n      return nextDir;\n    }\n  }, {\n    key: \"loadPackageProp\",\n    value: function loadPackageProp(filepath, content) {\n      var parsedContent = _loaders.loaders.loadJson(filepath, content);\n\n      var packagePropValue = (0, _getPropertyByPath.getPropertyByPath)(parsedContent, this.config.packageProp);\n      return packagePropValue || null;\n    }\n  }, {\n    key: \"getLoaderEntryForFile\",\n    value: function getLoaderEntryForFile(filepath) {\n      if (_path.default.basename(filepath) === 'package.json') {\n        var _loader = this.loadPackageProp.bind(this);\n\n        return _loader;\n      }\n\n      var loaderKey = _path.default.extname(filepath) || 'noExt';\n      var loader = this.config.loaders[loaderKey];\n\n      if (!loader) {\n        throw new Error(\"No loader specified for \".concat(getExtensionDescription(filepath)));\n      }\n\n      return loader;\n    }\n  }, {\n    key: \"loadedContentToCosmiconfigResult\",\n    value: function loadedContentToCosmiconfigResult(filepath, loadedContent) {\n      if (loadedContent === null) {\n        return null;\n      }\n\n      if (loadedContent === undefined) {\n        return {\n          filepath: filepath,\n          config: undefined,\n          isEmpty: true\n        };\n      }\n\n      return {\n        config: loadedContent,\n        filepath: filepath\n      };\n    }\n  }, {\n    key: \"validateFilePath\",\n    value: function validateFilePath(filepath) {\n      if (!filepath) {\n        throw new Error('load must pass a non-empty string');\n      }\n    }\n  }]);\n\n  return ExplorerBase;\n}();\n\nexports.ExplorerBase = ExplorerBase;\n\nfunction nextDirUp(dir) {\n  return _path.default.dirname(dir);\n}\n\nfunction getExtensionDescription(filepath) {\n  var ext = _path.default.extname(filepath);\n\n  return ext ? \"extension \\\"\".concat(ext, \"\\\"\") : 'files without extensions';\n}","map":{"version":3,"sources":["../src/ExplorerBase.ts"],"names":["options","config","place","loaderKey","path","loader","getExtensionDescription","result","nextDir","nextDirUp","currentDir","parsedContent","loaders","packagePropValue","loadedContent","filepath","isEmpty","ext"],"mappings":"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","sourcesContent":["import path from 'path';\nimport { loaders } from './loaders';\nimport { getPropertyByPath } from './getPropertyByPath';\nimport {\n  CosmiconfigResult,\n  ExplorerOptions,\n  ExplorerOptionsSync,\n  Cache,\n  LoadedFileContent,\n} from './types';\nimport { Loader } from './index';\n\nclass ExplorerBase<T extends ExplorerOptions | ExplorerOptionsSync> {\n  protected readonly loadCache?: Cache;\n  protected readonly searchCache?: Cache;\n  protected readonly config: T;\n\n  public constructor(options: T) {\n    if (options.cache === true) {\n      this.loadCache = new Map();\n      this.searchCache = new Map();\n    }\n\n    this.config = options;\n    this.validateConfig();\n  }\n\n  public clearLoadCache(): void {\n    if (this.loadCache) {\n      this.loadCache.clear();\n    }\n  }\n\n  public clearSearchCache(): void {\n    if (this.searchCache) {\n      this.searchCache.clear();\n    }\n  }\n\n  public clearCaches(): void {\n    this.clearLoadCache();\n    this.clearSearchCache();\n  }\n\n  private validateConfig(): void {\n    const config = this.config;\n\n    config.searchPlaces.forEach((place): void => {\n      const loaderKey = path.extname(place) || 'noExt';\n      const loader = config.loaders[loaderKey];\n      if (!loader) {\n        throw new Error(\n          `No loader specified for ${getExtensionDescription(\n            place,\n          )}, so searchPlaces item \"${place}\" is invalid`,\n        );\n      }\n\n      if (typeof loader !== 'function') {\n        throw new Error(\n          `loader for ${getExtensionDescription(\n            place,\n          )} is not a function (type provided: \"${typeof loader}\"), so searchPlaces item \"${place}\" is invalid`,\n        );\n      }\n    });\n  }\n\n  protected shouldSearchStopWithResult(result: CosmiconfigResult): boolean {\n    if (result === null) return false;\n    if (result.isEmpty && this.config.ignoreEmptySearchPlaces) return false;\n    return true;\n  }\n\n  protected nextDirectoryToSearch(\n    currentDir: string,\n    currentResult: CosmiconfigResult,\n  ): string | null {\n    if (this.shouldSearchStopWithResult(currentResult)) {\n      return null;\n    }\n    const nextDir = nextDirUp(currentDir);\n    if (nextDir === currentDir || currentDir === this.config.stopDir) {\n      return null;\n    }\n    return nextDir;\n  }\n\n  private loadPackageProp(filepath: string, content: string): unknown {\n    const parsedContent = loaders.loadJson(filepath, content);\n    const packagePropValue = getPropertyByPath(\n      parsedContent,\n      this.config.packageProp,\n    );\n    return packagePropValue || null;\n  }\n\n  protected getLoaderEntryForFile(filepath: string): Loader {\n    if (path.basename(filepath) === 'package.json') {\n      const loader = this.loadPackageProp.bind(this);\n      return loader;\n    }\n\n    const loaderKey = path.extname(filepath) || 'noExt';\n\n    const loader = this.config.loaders[loaderKey];\n\n    if (!loader) {\n      throw new Error(\n        `No loader specified for ${getExtensionDescription(filepath)}`,\n      );\n    }\n\n    return loader;\n  }\n\n  protected loadedContentToCosmiconfigResult(\n    filepath: string,\n    loadedContent: LoadedFileContent,\n  ): CosmiconfigResult {\n    if (loadedContent === null) {\n      return null;\n    }\n    if (loadedContent === undefined) {\n      return { filepath, config: undefined, isEmpty: true };\n    }\n    return { config: loadedContent, filepath };\n  }\n\n  protected validateFilePath(filepath: string): void {\n    if (!filepath) {\n      throw new Error('load must pass a non-empty string');\n    }\n  }\n}\n\nfunction nextDirUp(dir: string): string {\n  return path.dirname(dir);\n}\n\nfunction getExtensionDescription(filepath: string): string {\n  const ext = path.extname(filepath);\n  return ext ? `extension \"${ext}\"` : 'files without extensions';\n}\n\nexport { ExplorerBase, getExtensionDescription };\n"]},"metadata":{},"sourceType":"script"}