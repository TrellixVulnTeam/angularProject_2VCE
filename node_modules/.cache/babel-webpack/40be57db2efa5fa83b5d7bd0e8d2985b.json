{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar helper = require('./helper');\n\nfunction bufferEvents(emitter, eventsToBuffer) {\n  var listeners = [];\n  var eventsToReply = [];\n\n  function genericListener() {\n    eventsToReply.push(Array.from(arguments));\n  }\n\n  eventsToBuffer.forEach(function (eventName) {\n    var listener = genericListener.bind(null, eventName);\n    listeners.push(listener);\n    emitter.on(eventName, listener);\n  });\n  return function () {\n    listeners.forEach(function (listener, i) {\n      emitter.removeListener(eventsToBuffer[i], listener);\n    });\n    eventsToReply.forEach(function (args) {\n      EventEmitter.prototype.emit.apply(emitter, args);\n    });\n    listeners.length = 0;\n    eventsToReply.length = 0;\n  };\n}\n\nvar KarmaEventEmitter = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(KarmaEventEmitter, _EventEmitter);\n\n  var _super = _createSuper(KarmaEventEmitter);\n\n  function KarmaEventEmitter() {\n    _classCallCheck(this, KarmaEventEmitter);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(KarmaEventEmitter, [{\n    key: \"bind\",\n    value: function bind(object) {\n      var _this = this;\n\n      var _loop = function _loop(method) {\n        if (method.startsWith('on') && helper.isFunction(object[method])) {\n          _this.on(helper.camelToSnake(method.substr(2)), function () {\n            // We do not use an arrow function here, to supply the caller as this.\n            object[method].apply(object, Array.from(arguments).concat(this));\n          });\n        }\n      };\n\n      for (var method in object) {\n        _loop(method);\n      }\n    }\n  }, {\n    key: \"emitAsync\",\n    value: function emitAsync(name) {\n      // TODO(vojta): allow passing args\n      // TODO(vojta): ignore/throw if listener call done() multiple times\n      var pending = this.listeners(name).length;\n      var deferred = helper.defer();\n      this.emit(name, function () {\n        if (! --pending) {\n          deferred.resolve();\n        }\n      });\n\n      if (!pending) {\n        deferred.resolve();\n      }\n\n      return deferred.promise;\n    }\n  }]);\n\n  return KarmaEventEmitter;\n}(EventEmitter);\n\nexports.EventEmitter = KarmaEventEmitter;\nexports.bufferEvents = bufferEvents;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/karma/lib/events.js"],"names":["EventEmitter","require","helper","bufferEvents","emitter","eventsToBuffer","listeners","eventsToReply","genericListener","push","Array","from","arguments","forEach","eventName","listener","bind","on","i","removeListener","args","prototype","emit","apply","length","KarmaEventEmitter","object","method","startsWith","isFunction","camelToSnake","substr","concat","name","pending","deferred","defer","resolve","promise","exports"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAAvC;;AACA,IAAME,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AAEA,SAASE,YAAT,CAAuBC,OAAvB,EAAgCC,cAAhC,EAAgD;AAC9C,MAAMC,SAAS,GAAG,EAAlB;AACA,MAAMC,aAAa,GAAG,EAAtB;;AAEA,WAASC,eAAT,GAA4B;AAC1BD,IAAAA,aAAa,CAACE,IAAd,CAAmBC,KAAK,CAACC,IAAN,CAAWC,SAAX,CAAnB;AACD;;AAEDP,EAAAA,cAAc,CAACQ,OAAf,CAAuB,UAACC,SAAD,EAAe;AACpC,QAAMC,QAAQ,GAAGP,eAAe,CAACQ,IAAhB,CAAqB,IAArB,EAA2BF,SAA3B,CAAjB;AACAR,IAAAA,SAAS,CAACG,IAAV,CAAeM,QAAf;AACAX,IAAAA,OAAO,CAACa,EAAR,CAAWH,SAAX,EAAsBC,QAAtB;AACD,GAJD;AAMA,SAAO,YAAY;AACjBT,IAAAA,SAAS,CAACO,OAAV,CAAkB,UAACE,QAAD,EAAWG,CAAX,EAAiB;AACjCd,MAAAA,OAAO,CAACe,cAAR,CAAuBd,cAAc,CAACa,CAAD,CAArC,EAA0CH,QAA1C;AACD,KAFD;AAIAR,IAAAA,aAAa,CAACM,OAAd,CAAsB,UAACO,IAAD,EAAU;AAC9BpB,MAAAA,YAAY,CAACqB,SAAb,CAAuBC,IAAvB,CAA4BC,KAA5B,CAAkCnB,OAAlC,EAA2CgB,IAA3C;AACD,KAFD;AAIAd,IAAAA,SAAS,CAACkB,MAAV,GAAmB,CAAnB;AACAjB,IAAAA,aAAa,CAACiB,MAAd,GAAuB,CAAvB;AACD,GAXD;AAYD;;IAEKC,iB;;;;;;;;;;;;;WACJ,cAAMC,MAAN,EAAc;AAAA;;AAAA,iCACDC,MADC;AAEV,YAAIA,MAAM,CAACC,UAAP,CAAkB,IAAlB,KAA2B1B,MAAM,CAAC2B,UAAP,CAAkBH,MAAM,CAACC,MAAD,CAAxB,CAA/B,EAAkE;AAChE,UAAA,KAAI,CAACV,EAAL,CAAQf,MAAM,CAAC4B,YAAP,CAAoBH,MAAM,CAACI,MAAP,CAAc,CAAd,CAApB,CAAR,EAA+C,YAAY;AACzD;AACAL,YAAAA,MAAM,CAACC,MAAD,CAAN,CAAeJ,KAAf,CAAqBG,MAArB,EAA6BhB,KAAK,CAACC,IAAN,CAAWC,SAAX,EAAsBoB,MAAtB,CAA6B,IAA7B,CAA7B;AACD,WAHD;AAID;AAPS;;AACZ,WAAK,IAAML,MAAX,IAAqBD,MAArB,EAA6B;AAAA,cAAlBC,MAAkB;AAO5B;AACF;;;WAED,mBAAWM,IAAX,EAAiB;AACf;AACA;AACA,UAAIC,OAAO,GAAG,KAAK5B,SAAL,CAAe2B,IAAf,EAAqBT,MAAnC;AACA,UAAMW,QAAQ,GAAGjC,MAAM,CAACkC,KAAP,EAAjB;AAEA,WAAKd,IAAL,CAAUW,IAAV,EAAgB,YAAM;AACpB,YAAI,CAAC,GAAEC,OAAP,EAAgB;AACdC,UAAAA,QAAQ,CAACE,OAAT;AACD;AACF,OAJD;;AAMA,UAAI,CAACH,OAAL,EAAc;AACZC,QAAAA,QAAQ,CAACE,OAAT;AACD;;AAED,aAAOF,QAAQ,CAACG,OAAhB;AACD;;;;EA7B6BtC,Y;;AAgChCuC,OAAO,CAACvC,YAAR,GAAuByB,iBAAvB;AACAc,OAAO,CAACpC,YAAR,GAAuBA,YAAvB","sourcesContent":["'use strict'\n\nconst EventEmitter = require('events').EventEmitter\nconst helper = require('./helper')\n\nfunction bufferEvents (emitter, eventsToBuffer) {\n  const listeners = []\n  const eventsToReply = []\n\n  function genericListener () {\n    eventsToReply.push(Array.from(arguments))\n  }\n\n  eventsToBuffer.forEach((eventName) => {\n    const listener = genericListener.bind(null, eventName)\n    listeners.push(listener)\n    emitter.on(eventName, listener)\n  })\n\n  return function () {\n    listeners.forEach((listener, i) => {\n      emitter.removeListener(eventsToBuffer[i], listener)\n    })\n\n    eventsToReply.forEach((args) => {\n      EventEmitter.prototype.emit.apply(emitter, args)\n    })\n\n    listeners.length = 0\n    eventsToReply.length = 0\n  }\n}\n\nclass KarmaEventEmitter extends EventEmitter {\n  bind (object) {\n    for (const method in object) {\n      if (method.startsWith('on') && helper.isFunction(object[method])) {\n        this.on(helper.camelToSnake(method.substr(2)), function () {\n          // We do not use an arrow function here, to supply the caller as this.\n          object[method].apply(object, Array.from(arguments).concat(this))\n        })\n      }\n    }\n  }\n\n  emitAsync (name) {\n    // TODO(vojta): allow passing args\n    // TODO(vojta): ignore/throw if listener call done() multiple times\n    let pending = this.listeners(name).length\n    const deferred = helper.defer()\n\n    this.emit(name, () => {\n      if (!--pending) {\n        deferred.resolve()\n      }\n    })\n\n    if (!pending) {\n      deferred.resolve()\n    }\n\n    return deferred.promise\n  }\n}\n\nexports.EventEmitter = KarmaEventEmitter\nexports.bufferEvents = bufferEvents\n"]},"metadata":{},"sourceType":"script"}