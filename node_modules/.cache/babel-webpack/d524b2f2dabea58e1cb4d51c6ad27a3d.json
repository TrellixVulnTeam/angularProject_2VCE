{"ast":null,"code":"var cache = new Map();\n\nvar fs = require('fs');\n\nvar _require = require('path'),\n    dirname = _require.dirname,\n    resolve = _require.resolve;\n\nvar lstat = function lstat(path) {\n  return new Promise(function (res, rej) {\n    return fs.lstat(path, function (er, st) {\n      return er ? rej(er) : res(st);\n    });\n  });\n};\n\nvar inferOwner = function inferOwner(path) {\n  path = resolve(path);\n  if (cache.has(path)) return Promise.resolve(cache.get(path));\n\n  var statThen = function statThen(st) {\n    var uid = st.uid,\n        gid = st.gid;\n    cache.set(path, {\n      uid: uid,\n      gid: gid\n    });\n    return {\n      uid: uid,\n      gid: gid\n    };\n  };\n\n  var parent = dirname(path);\n  var parentTrap = parent === path ? null : function (er) {\n    return inferOwner(parent).then(function (owner) {\n      cache.set(path, owner);\n      return owner;\n    });\n  };\n  return lstat(path).then(statThen, parentTrap);\n};\n\nvar inferOwnerSync = function inferOwnerSync(path) {\n  path = resolve(path);\n  if (cache.has(path)) return cache.get(path);\n  var parent = dirname(path); // avoid obscuring call site by re-throwing\n  // \"catch\" the error by returning from a finally,\n  // only if we're not at the root, and the parent call works.\n\n  var threw = true;\n\n  try {\n    var st = fs.lstatSync(path);\n    threw = false;\n    var uid = st.uid,\n        gid = st.gid;\n    cache.set(path, {\n      uid: uid,\n      gid: gid\n    });\n    return {\n      uid: uid,\n      gid: gid\n    };\n  } finally {\n    if (threw && parent !== path) {\n      var owner = inferOwnerSync(parent);\n      cache.set(path, owner);\n      return owner; // eslint-disable-line no-unsafe-finally\n    }\n  }\n};\n\nvar inflight = new Map();\n\nmodule.exports = function (path) {\n  path = resolve(path);\n  if (inflight.has(path)) return Promise.resolve(inflight.get(path));\n  var p = inferOwner(path).then(function (owner) {\n    inflight.delete(path);\n    return owner;\n  });\n  inflight.set(path, p);\n  return p;\n};\n\nmodule.exports.sync = inferOwnerSync;\n\nmodule.exports.clearCache = function () {\n  cache.clear();\n  inflight.clear();\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/infer-owner/index.js"],"names":["cache","Map","fs","require","dirname","resolve","lstat","path","Promise","res","rej","er","st","inferOwner","has","get","statThen","uid","gid","set","parent","parentTrap","then","owner","inferOwnerSync","threw","lstatSync","inflight","module","exports","p","delete","sync","clearCache","clear"],"mappings":"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","sourcesContent":["const cache = new Map()\nconst fs = require('fs')\nconst { dirname, resolve } = require('path')\n\n\nconst lstat = path => new Promise((res, rej) =>\n  fs.lstat(path, (er, st) => er ? rej(er) : res(st)))\n\nconst inferOwner = path => {\n  path = resolve(path)\n  if (cache.has(path))\n    return Promise.resolve(cache.get(path))\n\n  const statThen = st => {\n    const { uid, gid } = st\n    cache.set(path, { uid, gid })\n    return { uid, gid }\n  }\n  const parent = dirname(path)\n  const parentTrap = parent === path ? null : er => {\n    return inferOwner(parent).then((owner) => {\n      cache.set(path, owner)\n      return owner\n    })\n  }\n  return lstat(path).then(statThen, parentTrap)\n}\n\nconst inferOwnerSync = path => {\n  path = resolve(path)\n  if (cache.has(path))\n    return cache.get(path)\n\n  const parent = dirname(path)\n\n  // avoid obscuring call site by re-throwing\n  // \"catch\" the error by returning from a finally,\n  // only if we're not at the root, and the parent call works.\n  let threw = true\n  try {\n    const st = fs.lstatSync(path)\n    threw = false\n    const { uid, gid } = st\n    cache.set(path, { uid, gid })\n    return { uid, gid }\n  } finally {\n    if (threw && parent !== path) {\n      const owner = inferOwnerSync(parent)\n      cache.set(path, owner)\n      return owner // eslint-disable-line no-unsafe-finally\n    }\n  }\n}\n\nconst inflight = new Map()\nmodule.exports = path => {\n  path = resolve(path)\n  if (inflight.has(path))\n    return Promise.resolve(inflight.get(path))\n  const p = inferOwner(path).then(owner => {\n    inflight.delete(path)\n    return owner\n  })\n  inflight.set(path, p)\n  return p\n}\nmodule.exports.sync = inferOwnerSync\nmodule.exports.clearCache = () => {\n  cache.clear()\n  inflight.clear()\n}\n"]},"metadata":{},"sourceType":"script"}