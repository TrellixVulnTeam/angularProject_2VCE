{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/output/output_jit_trusted_types\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.newTrustedFunctionForJIT = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @fileoverview\n   * A module to facilitate use of a Trusted Types policy within the JIT\n   * compiler. It lazily constructs the Trusted Types policy, providing helper\n   * utilities for promoting strings to Trusted Types. When Trusted Types are not\n   * available, strings are used as a fallback.\n   * @security All use of this module is security-sensitive and should go through\n   * security review.\n   */\n\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n  /**\n   * The Trusted Types policy, or null if Trusted Types are not\n   * enabled/supported, or undefined if the policy has not been created yet.\n   */\n\n\n  var policy;\n  /**\n   * Returns the Trusted Types policy, or null if Trusted Types are not\n   * enabled/supported. The first call to this function will create the policy.\n   */\n\n  function getPolicy() {\n    if (policy === undefined) {\n      policy = null;\n\n      if (util_1.global.trustedTypes) {\n        try {\n          policy = util_1.global.trustedTypes.createPolicy('angular#unsafe-jit', {\n            createScript: function createScript(s) {\n              return s;\n            }\n          });\n        } catch (_a) {// trustedTypes.createPolicy throws if called with a name that is\n          // already registered, even in report-only mode. Until the API changes,\n          // catch the error not to break the applications functionally. In such\n          // cases, the code will fall back to using strings.\n        }\n      }\n    }\n\n    return policy;\n  }\n  /**\n   * Unsafely promote a string to a TrustedScript, falling back to strings when\n   * Trusted Types are not available.\n   * @security In particular, it must be assured that the provided string will\n   * never cause an XSS vulnerability if used in a context that will be\n   * interpreted and executed as a script by a browser, e.g. when calling eval.\n   */\n\n\n  function trustedScriptFromString(script) {\n    var _a;\n\n    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\n  }\n  /**\n   * Unsafely call the Function constructor with the given string arguments.\n   * @security This is a security-sensitive function; any use of this function\n   * must go through security review. In particular, it must be assured that it\n   * is only called from the JIT compiler, as use in other code can lead to XSS\n   * vulnerabilities.\n   */\n\n\n  function newTrustedFunctionForJIT() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (!util_1.global.trustedTypes) {\n      // In environments that don't support Trusted Types, fall back to the most\n      // straightforward implementation:\n      return new (Function.bind.apply(Function, tslib_1.__spread([void 0], args)))();\n    } // Chrome currently does not support passing TrustedScript to the Function\n    // constructor. The following implements the workaround proposed on the page\n    // below, where the Chromium bug is also referenced:\n    // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n\n\n    var fnArgs = args.slice(0, -1).join(',');\n    var fnBody = args[args.length - 1];\n    var body = \"(function anonymous(\" + fnArgs + \"\\n) { \" + fnBody + \"\\n})\"; // Using eval directly confuses the compiler and prevents this module from\n    // being stripped out of JS binaries even if not used. The global['eval']\n    // indirection fixes that.\n\n    var fn = util_1.global['eval'](trustedScriptFromString(body));\n\n    if (fn.bind === undefined) {\n      // Workaround for a browser bug that only exists in Chrome 83, where passing\n      // a TrustedScript to eval just returns the TrustedScript back without\n      // evaluating it. In that case, fall back to the most straightforward\n      // implementation:\n      return new (Function.bind.apply(Function, tslib_1.__spread([void 0], args)))();\n    } // To completely mimic the behavior of calling \"new Function\", two more\n    // things need to happen:\n    // 1. Stringifying the resulting function should return its source code\n\n\n    fn.toString = function () {\n      return body;\n    }; // 2. When calling the resulting function, `this` should refer to `global`\n\n\n    return fn.bind(util_1.global); // When Trusted Types support in Function constructors is widely available,\n    // the implementation of this function can be simplified to:\n    // return new Function(...args.map(a => trustedScriptFromString(a)));\n  }\n\n  exports.newTrustedFunctionForJIT = newTrustedFunctionForJIT;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/output/output_jit_trusted_types.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;AAEH;;;;;;;;AAQG;;;AAEH,MAAA,MAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;AAmCA;;;AAGG;;;AACH,MAAI,MAAJ;AAEA;;;AAGG;;AACH,WAAS,SAAT,GAAkB;AAChB,QAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,MAAA,MAAM,GAAG,IAAT;;AACA,UAAI,MAAA,CAAA,MAAA,CAAO,YAAX,EAAyB;AACvB,YAAI;AACF,UAAA,MAAM,GACD,MAAA,CAAA,MAAA,CAAO,YAAP,CAAiD,YAAjD,CAA8D,oBAA9D,EAAoF;AACnF,YAAA,YAAY,EAAE,sBAAC,CAAD,EAAU;AAAK,qBAAA,CAAA;AAAC;AADqD,WAApF,CADL;AAID,SALD,CAKE,OAAA,EAAA,EAAM,CACN;AACA;AACA;AACA;AACD;AACF;AACF;;AACD,WAAO,MAAP;AACD;AAED;;;;;;AAMG;;;AACH,WAAS,uBAAT,CAAiC,MAAjC,EAA+C;;;AAC7C,WAAO,CAAA,CAAA,EAAA,GAAA,SAAS,EAAT,MAAW,IAAX,IAAW,EAAA,KAAA,KAAA,CAAX,GAAW,KAAA,CAAX,GAAW,EAAA,CAAE,YAAF,CAAe,MAAf,CAAX,KAAqC,MAA5C;AACD;AAED;;;;;;AAMG;;;AACH,WAAgB,wBAAhB,GAAwC;AAAC,QAAA,IAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAiB;AAAjB,MAAA,IAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACvC,QAAI,CAAC,MAAA,CAAA,MAAA,CAAO,YAAZ,EAA0B;AACxB;AACA;AACA,aAAA,KAAW,QAAQ,CAAA,IAAR,CAAQ,KAAR,CAAA,QAAA,EAAQ,OAAA,CAAA,QAAA,CAAA,CAAA,KAAA,CAAA,CAAA,EAAI,IAAJ,CAAR,CAAX,GAAA;AACD,KALqC,CAOtC;AACA;AACA;AACA;;;AACA,QAAM,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,CAAC,CAAf,EAAkB,IAAlB,CAAuB,GAAvB,CAAf;AACA,QAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAL,GAAc,CAAf,CAAnB;AACA,QAAM,IAAI,GAAG,yBAAuB,MAAvB,GAA6B,QAA7B,GACT,MADS,GACH,MADV,CAbsC,CAiBtC;AACA;AACA;;AACA,QAAM,EAAE,GAAG,MAAA,CAAA,MAAA,CAAO,MAAP,EAAe,uBAAuB,CAAC,IAAD,CAAtC,CAAX;;AACA,QAAI,EAAE,CAAC,IAAH,KAAY,SAAhB,EAA2B;AACzB;AACA;AACA;AACA;AACA,aAAA,KAAW,QAAQ,CAAA,IAAR,CAAQ,KAAR,CAAA,QAAA,EAAQ,OAAA,CAAA,QAAA,CAAA,CAAA,KAAA,CAAA,CAAA,EAAI,IAAJ,CAAR,CAAX,GAAA;AACD,KA3BqC,CA6BtC;AACA;AACA;;;AACA,IAAA,EAAE,CAAC,QAAH,GAAc,YAAA;AAAM,aAAA,IAAA;AAAI,KAAxB,CAhCsC,CAiCtC;;;AACA,WAAO,EAAE,CAAC,IAAH,CAAQ,MAAA,CAAA,MAAR,CAAP,CAlCsC,CAoCtC;AACA;AACA;AACD;;AAvCD,EAAA,OAAA,CAAA,wBAAA,GAAA,wBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy within the JIT\n * compiler. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../util';\n\n/**\n * While Angular only uses Trusted Types internally for the time being,\n * references to Trusted Types could leak into our core.d.ts, which would force\n * anyone compiling against @angular/core to provide the @types/trusted-types\n * package in their compilation unit.\n *\n * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n * will keep Angular's public API surface free of references to Trusted Types.\n * For internal and semi-private APIs that need to reference Trusted Types, the\n * minimal type definitions for the Trusted Types API provided by this module\n * should be used instead. They are marked as \"declare\" to prevent them from\n * being renamed by compiler optimization.\n *\n * Adapted from\n * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n * but restricted to the API surface used within Angular.\n */\n\nexport declare interface TrustedScript {\n  __brand__: 'TrustedScript';\n}\n\nexport declare interface TrustedTypePolicyFactory {\n  createPolicy(policyName: string, policyOptions: {\n    createScript?: (input: string) => string,\n  }): TrustedTypePolicy;\n}\n\nexport declare interface TrustedTypePolicy {\n  createScript(input: string): TrustedScript;\n}\n\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy|null|undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy|null {\n  if (policy === undefined) {\n    policy = null;\n    if (global.trustedTypes) {\n      try {\n        policy =\n            (global.trustedTypes as TrustedTypePolicyFactory).createPolicy('angular#unsafe-jit', {\n              createScript: (s: string) => s,\n            });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script: string): TrustedScript|string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nexport function newTrustedFunctionForJIT(...args: string[]): Function {\n  if (!global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(global);\n\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}