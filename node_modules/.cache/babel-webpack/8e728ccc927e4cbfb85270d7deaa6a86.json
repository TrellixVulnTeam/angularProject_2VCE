{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/incremental/src/strategy\", [\"require\", \"exports\", \"@angular/compiler-cli/src/ngtsc/incremental/src/state\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.PatchedProgramIncrementalBuildStrategy = exports.TrackedIncrementalBuildStrategy = exports.NoopIncrementalBuildStrategy = void 0;\n\n  var state_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/src/state\");\n  /**\n   * A noop implementation of `IncrementalBuildStrategy` which neither returns nor tracks any\n   * incremental data.\n   */\n\n\n  var NoopIncrementalBuildStrategy =\n  /** @class */\n  function () {\n    function NoopIncrementalBuildStrategy() {}\n\n    NoopIncrementalBuildStrategy.prototype.getIncrementalDriver = function () {\n      return null;\n    };\n\n    NoopIncrementalBuildStrategy.prototype.setIncrementalDriver = function () {};\n\n    NoopIncrementalBuildStrategy.prototype.toNextBuildStrategy = function () {\n      return this;\n    };\n\n    return NoopIncrementalBuildStrategy;\n  }();\n\n  exports.NoopIncrementalBuildStrategy = NoopIncrementalBuildStrategy;\n  /**\n   * Tracks an `IncrementalDriver` within the strategy itself.\n   */\n\n  var TrackedIncrementalBuildStrategy =\n  /** @class */\n  function () {\n    function TrackedIncrementalBuildStrategy() {\n      this.driver = null;\n      this.isSet = false;\n    }\n\n    TrackedIncrementalBuildStrategy.prototype.getIncrementalDriver = function () {\n      return this.driver;\n    };\n\n    TrackedIncrementalBuildStrategy.prototype.setIncrementalDriver = function (driver) {\n      this.driver = driver;\n      this.isSet = true;\n    };\n\n    TrackedIncrementalBuildStrategy.prototype.toNextBuildStrategy = function () {\n      var strategy = new TrackedIncrementalBuildStrategy(); // Only reuse a driver that was explicitly set via `setIncrementalDriver`.\n\n      strategy.driver = this.isSet ? this.driver : null;\n      return strategy;\n    };\n\n    return TrackedIncrementalBuildStrategy;\n  }();\n\n  exports.TrackedIncrementalBuildStrategy = TrackedIncrementalBuildStrategy;\n  /**\n   * Manages the `IncrementalDriver` associated with a `ts.Program` by monkey-patching it onto the\n   * program under `SYM_INCREMENTAL_DRIVER`.\n   */\n\n  var PatchedProgramIncrementalBuildStrategy =\n  /** @class */\n  function () {\n    function PatchedProgramIncrementalBuildStrategy() {}\n\n    PatchedProgramIncrementalBuildStrategy.prototype.getIncrementalDriver = function (program) {\n      var driver = program[SYM_INCREMENTAL_DRIVER];\n\n      if (driver === undefined || !(driver instanceof state_1.IncrementalDriver)) {\n        return null;\n      }\n\n      return driver;\n    };\n\n    PatchedProgramIncrementalBuildStrategy.prototype.setIncrementalDriver = function (driver, program) {\n      program[SYM_INCREMENTAL_DRIVER] = driver;\n    };\n\n    PatchedProgramIncrementalBuildStrategy.prototype.toNextBuildStrategy = function () {\n      return this;\n    };\n\n    return PatchedProgramIncrementalBuildStrategy;\n  }();\n\n  exports.PatchedProgramIncrementalBuildStrategy = PatchedProgramIncrementalBuildStrategy;\n  /**\n   * Symbol under which the `IncrementalDriver` is stored on a `ts.Program`.\n   *\n   * The TS model of incremental compilation is based around reuse of a previous `ts.Program` in the\n   * construction of a new one. The `NgCompiler` follows this abstraction - passing in a previous\n   * `ts.Program` is sufficient to trigger incremental compilation. This previous `ts.Program` need\n   * not be from an Angular compilation (that is, it need not have been created from `NgCompiler`).\n   *\n   * If it is, though, Angular can benefit from reusing previous analysis work. This reuse is managed\n   * by the `IncrementalDriver`, which is inherited from the old program to the new program. To\n   * support this behind the API of passing an old `ts.Program`, the `IncrementalDriver` is stored on\n   * the `ts.Program` under this symbol.\n   */\n\n  var SYM_INCREMENTAL_DRIVER = Symbol('NgIncrementalDriver');\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/src/strategy.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAGH,MAAA,OAAA,GAAA,OAAA,CAAA,uDAAA,CAAA;AAyBA;;;AAGG;;;AACH,MAAA,4BAAA;AAAA;AAAA,cAAA;AAAA,aAAA,4BAAA,GAAA,CAUC;;AATC,IAAA,4BAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;AACE,aAAO,IAAP;AACD,KAFD;;AAIA,IAAA,4BAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA,CAA+B,CAA/B;;AAEA,IAAA,4BAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,YAAA;AACE,aAAO,IAAP;AACD,KAFD;;AAGF,WAAA,4BAAA;AAAC,GAVD,EAAA;;AAAa,EAAA,OAAA,CAAA,4BAAA,GAAA,4BAAA;AAYb;;AAEG;;AACH,MAAA,+BAAA;AAAA;AAAA,cAAA;AAAA,aAAA,+BAAA,GAAA;AACU,WAAA,MAAA,GAAiC,IAAjC;AACA,WAAA,KAAA,GAAiB,KAAjB;AAiBT;;AAfC,IAAA,+BAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,YAAA;AACE,aAAO,KAAK,MAAZ;AACD,KAFD;;AAIA,IAAA,+BAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,MAArB,EAA8C;AAC5C,WAAK,MAAL,GAAc,MAAd;AACA,WAAK,KAAL,GAAa,IAAb;AACD,KAHD;;AAKA,IAAA,+BAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,YAAA;AACE,UAAM,QAAQ,GAAG,IAAI,+BAAJ,EAAjB,CADF,CAEE;;AACA,MAAA,QAAQ,CAAC,MAAT,GAAkB,KAAK,KAAL,GAAa,KAAK,MAAlB,GAA2B,IAA7C;AACA,aAAO,QAAP;AACD,KALD;;AAMF,WAAA,+BAAA;AAAC,GAnBD,EAAA;;AAAa,EAAA,OAAA,CAAA,+BAAA,GAAA,+BAAA;AAqBb;;;AAGG;;AACH,MAAA,sCAAA;AAAA;AAAA,cAAA;AAAA,aAAA,sCAAA,GAAA,CAgBC;;AAfC,IAAA,sCAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,OAArB,EAAwC;AACtC,UAAM,MAAM,GAAI,OAAe,CAAC,sBAAD,CAA/B;;AACA,UAAI,MAAM,KAAK,SAAX,IAAwB,EAAE,MAAM,YAAY,OAAA,CAAA,iBAApB,CAA5B,EAAoE;AAClE,eAAO,IAAP;AACD;;AACD,aAAO,MAAP;AACD,KAND;;AAQA,IAAA,sCAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,MAArB,EAAgD,OAAhD,EAAmE;AAChE,MAAA,OAAe,CAAC,sBAAD,CAAf,GAA0C,MAA1C;AACF,KAFD;;AAIA,IAAA,sCAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,YAAA;AACE,aAAO,IAAP;AACD,KAFD;;AAGF,WAAA,sCAAA;AAAC,GAhBD,EAAA;;AAAa,EAAA,OAAA,CAAA,sCAAA,GAAA,sCAAA;AAmBb;;;;;;;;;;;;AAYG;;AACH,MAAM,sBAAsB,GAAG,MAAM,CAAC,qBAAD,CAArC","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\nimport {IncrementalDriver} from './state';\n\n/**\n * Strategy used to manage the association between a `ts.Program` and the `IncrementalDriver` which\n * represents the reusable Angular part of its compilation.\n */\nexport interface IncrementalBuildStrategy {\n  /**\n   * Determine the Angular `IncrementalDriver` for the given `ts.Program`, if one is available.\n   */\n  getIncrementalDriver(program: ts.Program): IncrementalDriver|null;\n\n  /**\n   * Associate the given `IncrementalDriver` with the given `ts.Program` and make it available to\n   * future compilations.\n   */\n  setIncrementalDriver(driver: IncrementalDriver, program: ts.Program): void;\n\n  /**\n   * Convert this `IncrementalBuildStrategy` into a possibly new instance to be used in the next\n   * incremental compilation (may be a no-op if the strategy is not stateful).\n   */\n  toNextBuildStrategy(): IncrementalBuildStrategy;\n}\n\n/**\n * A noop implementation of `IncrementalBuildStrategy` which neither returns nor tracks any\n * incremental data.\n */\nexport class NoopIncrementalBuildStrategy implements IncrementalBuildStrategy {\n  getIncrementalDriver(): null {\n    return null;\n  }\n\n  setIncrementalDriver(): void {}\n\n  toNextBuildStrategy(): IncrementalBuildStrategy {\n    return this;\n  }\n}\n\n/**\n * Tracks an `IncrementalDriver` within the strategy itself.\n */\nexport class TrackedIncrementalBuildStrategy implements IncrementalBuildStrategy {\n  private driver: IncrementalDriver|null = null;\n  private isSet: boolean = false;\n\n  getIncrementalDriver(): IncrementalDriver|null {\n    return this.driver;\n  }\n\n  setIncrementalDriver(driver: IncrementalDriver): void {\n    this.driver = driver;\n    this.isSet = true;\n  }\n\n  toNextBuildStrategy(): TrackedIncrementalBuildStrategy {\n    const strategy = new TrackedIncrementalBuildStrategy();\n    // Only reuse a driver that was explicitly set via `setIncrementalDriver`.\n    strategy.driver = this.isSet ? this.driver : null;\n    return strategy;\n  }\n}\n\n/**\n * Manages the `IncrementalDriver` associated with a `ts.Program` by monkey-patching it onto the\n * program under `SYM_INCREMENTAL_DRIVER`.\n */\nexport class PatchedProgramIncrementalBuildStrategy implements IncrementalBuildStrategy {\n  getIncrementalDriver(program: ts.Program): IncrementalDriver|null {\n    const driver = (program as any)[SYM_INCREMENTAL_DRIVER];\n    if (driver === undefined || !(driver instanceof IncrementalDriver)) {\n      return null;\n    }\n    return driver;\n  }\n\n  setIncrementalDriver(driver: IncrementalDriver, program: ts.Program): void {\n    (program as any)[SYM_INCREMENTAL_DRIVER] = driver;\n  }\n\n  toNextBuildStrategy(): IncrementalBuildStrategy {\n    return this;\n  }\n}\n\n\n/**\n * Symbol under which the `IncrementalDriver` is stored on a `ts.Program`.\n *\n * The TS model of incremental compilation is based around reuse of a previous `ts.Program` in the\n * construction of a new one. The `NgCompiler` follows this abstraction - passing in a previous\n * `ts.Program` is sufficient to trigger incremental compilation. This previous `ts.Program` need\n * not be from an Angular compilation (that is, it need not have been created from `NgCompiler`).\n *\n * If it is, though, Angular can benefit from reusing previous analysis work. This reuse is managed\n * by the `IncrementalDriver`, which is inherited from the old program to the new program. To\n * support this behind the API of passing an old `ts.Program`, the `IncrementalDriver` is stored on\n * the `ts.Program` under this symbol.\n */\nconst SYM_INCREMENTAL_DRIVER = Symbol('NgIncrementalDriver');\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}