{"ast":null,"code":"var _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar postcss = require('postcss');\n\nvar topologicalSort = require('./topologicalSort');\n\nvar declWhitelist = ['composes'];\nvar declFilter = new RegExp(\"^(\".concat(declWhitelist.join('|'), \")$\"));\nvar matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/;\nvar icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/;\nvar VISITED_MARKER = 1;\n\nfunction createParentName(rule, root) {\n  return \"__\".concat(root.index(rule.parent), \"_\").concat(rule.selector);\n}\n\nfunction serializeImports(imports) {\n  return imports.map(function (importPath) {\n    return '`' + importPath + '`';\n  }).join(', ');\n}\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\n\n\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  var siblingsId = parentId + '_' + 'siblings';\n  var visitedId = parentId + '_' + importId;\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) visited[siblingsId] = [];\n    var siblings = visited[siblingsId];\n    if (Array.isArray(graph[importId])) graph[importId] = graph[importId].concat(siblings);else graph[importId] = siblings.slice();\n    visited[visitedId] = VISITED_MARKER;\n    siblings.push(importId);\n  }\n}\n\nmodule.exports = postcss.plugin('modules-extract-imports', function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var failOnWrongOrder = options.failOnWrongOrder;\n  return function (css) {\n    var graph = {};\n    var visited = {};\n    var existingImports = {};\n    var importDecls = {};\n    var imports = {};\n    var importIndex = 0;\n    var createImportedName = typeof options.createImportedName !== 'function' ? function (importName\n    /*, path*/\n    ) {\n      return \"i__imported_\".concat(importName.replace(/\\W/g, '_'), \"_\").concat(importIndex++);\n    } : options.createImportedName; // Check the existing imports order and save refs\n\n    css.walkRules(function (rule) {\n      var matches = icssImport.exec(rule.selector);\n\n      if (matches) {\n        var _matches = _slicedToArray(matches, 3),\n\n        /*match*/\n        doubleQuotePath = _matches[1],\n            singleQuotePath = _matches[2];\n\n        var importPath = doubleQuotePath || singleQuotePath;\n        addImportToGraph(importPath, 'root', graph, visited);\n        existingImports[importPath] = rule;\n      }\n    }); // Find any declaration that supports imports\n\n    css.walkDecls(declFilter, function (decl) {\n      var matches = decl.value.match(matchImports);\n      var tmpSymbols;\n\n      if (matches) {\n        var _matches2 = _slicedToArray(matches, 5),\n\n        /*match*/\n        symbols = _matches2[1],\n            doubleQuotePath = _matches2[2],\n            singleQuotePath = _matches2[3],\n            global = _matches2[4];\n\n        if (global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(function (s) {\n            return \"global(\".concat(s, \")\");\n          });\n        } else {\n          var importPath = doubleQuotePath || singleQuotePath;\n          var parentRule = createParentName(decl.parent, css);\n          addImportToGraph(importPath, parentRule, graph, visited);\n          importDecls[importPath] = decl;\n          imports[importPath] = imports[importPath] || {};\n          tmpSymbols = symbols.split(/\\s+/).map(function (s) {\n            if (!imports[importPath][s]) {\n              imports[importPath][s] = createImportedName(s, importPath);\n            }\n\n            return imports[importPath][s];\n          });\n        }\n\n        decl.value = tmpSymbols.join(' ');\n      }\n    });\n    var importsOrder = topologicalSort(graph, failOnWrongOrder);\n\n    if (importsOrder instanceof Error) {\n      var importPath = importsOrder.nodes.find(function (importPath) {\n        return importDecls.hasOwnProperty(importPath);\n      });\n      var decl = importDecls[importPath];\n      var errMsg = 'Failed to resolve order of composed modules ' + serializeImports(importsOrder.nodes) + '.';\n      throw decl.error(errMsg, {\n        plugin: 'modules-extract-imports',\n        word: 'composes'\n      });\n    }\n\n    var lastImportRule;\n    importsOrder.forEach(function (path) {\n      var importedSymbols = imports[path];\n      var rule = existingImports[path];\n\n      if (!rule && importedSymbols) {\n        rule = postcss.rule({\n          selector: \":import(\\\"\".concat(path, \"\\\")\"),\n          raws: {\n            after: '\\n'\n          }\n        });\n        if (lastImportRule) css.insertAfter(lastImportRule, rule);else css.prepend(rule);\n      }\n\n      lastImportRule = rule;\n      if (!importedSymbols) return;\n      Object.keys(importedSymbols).forEach(function (importedSymbol) {\n        rule.append(postcss.decl({\n          value: importedSymbol,\n          prop: importedSymbols[importedSymbol],\n          raws: {\n            before: '\\n  '\n          }\n        }));\n      });\n    });\n  };\n});","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/postcss-modules-extract-imports/src/index.js"],"names":["postcss","require","topologicalSort","declWhitelist","declFilter","RegExp","join","matchImports","icssImport","VISITED_MARKER","createParentName","rule","root","index","parent","selector","serializeImports","imports","map","importPath","addImportToGraph","importId","parentId","graph","visited","siblingsId","visitedId","Array","isArray","siblings","concat","slice","push","module","exports","plugin","options","failOnWrongOrder","css","existingImports","importDecls","importIndex","createImportedName","importName","replace","walkRules","matches","exec","doubleQuotePath","singleQuotePath","walkDecls","decl","value","match","tmpSymbols","symbols","global","split","s","parentRule","importsOrder","Error","nodes","find","hasOwnProperty","errMsg","error","word","lastImportRule","forEach","path","importedSymbols","raws","after","insertAfter","prepend","Object","keys","importedSymbol","append","prop","before"],"mappings":"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","sourcesContent":["const postcss = require('postcss')\nconst topologicalSort = require('./topologicalSort')\n\nconst declWhitelist = ['composes']\nconst declFilter = new RegExp(`^(${declWhitelist.join('|')})$`)\nconst matchImports = /^(.+?)\\s+from\\s+(?:\"([^\"]+)\"|'([^']+)'|(global))$/\nconst icssImport = /^:import\\((?:\"([^\"]+)\"|'([^']+)')\\)/\n\nconst VISITED_MARKER = 1\n\nfunction createParentName(rule, root) {\n  return `__${root.index(rule.parent)}_${rule.selector}`\n}\n\nfunction serializeImports(imports) {\n  return imports.map(importPath => '`' + importPath + '`').join(', ')\n}\n\n/**\n * :import('G') {}\n *\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'B'\n\n * Rule\n *   composes: ... from 'A'\n *   composes: ... from 'A'\n *   composes: ... from 'C'\n *\n * Results in:\n *\n * graph: {\n *   G: [],\n *   A: [],\n *   B: ['A'],\n *   C: ['A'],\n * }\n */\nfunction addImportToGraph(importId, parentId, graph, visited) {\n  const siblingsId = parentId + '_' + 'siblings'\n  const visitedId = parentId + '_' + importId\n\n  if (visited[visitedId] !== VISITED_MARKER) {\n    if (!Array.isArray(visited[siblingsId])) visited[siblingsId] = []\n\n    const siblings = visited[siblingsId]\n\n    if (Array.isArray(graph[importId]))\n      graph[importId] = graph[importId].concat(siblings)\n    else graph[importId] = siblings.slice()\n\n    visited[visitedId] = VISITED_MARKER\n    siblings.push(importId)\n  }\n}\n\nmodule.exports = postcss.plugin('modules-extract-imports', function(\n  options = {}\n) {\n  const failOnWrongOrder = options.failOnWrongOrder\n\n  return css => {\n    const graph = {}\n    const visited = {}\n\n    const existingImports = {}\n    const importDecls = {}\n    const imports = {}\n\n    let importIndex = 0\n\n    const createImportedName = typeof options.createImportedName !== 'function'\n      ? (importName /*, path*/) =>\n          `i__imported_${importName.replace(/\\W/g, '_')}_${importIndex++}`\n      : options.createImportedName\n\n    // Check the existing imports order and save refs\n    css.walkRules(rule => {\n      const matches = icssImport.exec(rule.selector)\n\n      if (matches) {\n        const [, /*match*/ doubleQuotePath, singleQuotePath] = matches\n        const importPath = doubleQuotePath || singleQuotePath\n\n        addImportToGraph(importPath, 'root', graph, visited)\n\n        existingImports[importPath] = rule\n      }\n    })\n\n    // Find any declaration that supports imports\n    css.walkDecls(declFilter, decl => {\n      let matches = decl.value.match(matchImports)\n      let tmpSymbols\n\n      if (matches) {\n        let [\n          ,\n          /*match*/ symbols,\n          doubleQuotePath,\n          singleQuotePath,\n          global\n        ] = matches\n\n        if (global) {\n          // Composing globals simply means changing these classes to wrap them in global(name)\n          tmpSymbols = symbols.split(/\\s+/).map(s => `global(${s})`)\n        } else {\n          const importPath = doubleQuotePath || singleQuotePath\n          const parentRule = createParentName(decl.parent, css)\n\n          addImportToGraph(importPath, parentRule, graph, visited)\n\n          importDecls[importPath] = decl\n          imports[importPath] = imports[importPath] || {}\n\n          tmpSymbols = symbols.split(/\\s+/).map(s => {\n            if (!imports[importPath][s]) {\n              imports[importPath][s] = createImportedName(s, importPath)\n            }\n\n            return imports[importPath][s]\n          })\n        }\n\n        decl.value = tmpSymbols.join(' ')\n      }\n    })\n\n    const importsOrder = topologicalSort(graph, failOnWrongOrder)\n\n    if (importsOrder instanceof Error) {\n      const importPath = importsOrder.nodes.find(importPath =>\n        importDecls.hasOwnProperty(importPath)\n      )\n      const decl = importDecls[importPath]\n\n      const errMsg =\n        'Failed to resolve order of composed modules ' +\n        serializeImports(importsOrder.nodes) +\n        '.'\n\n      throw decl.error(errMsg, {\n        plugin: 'modules-extract-imports',\n        word: 'composes'\n      })\n    }\n\n    let lastImportRule\n    importsOrder.forEach(path => {\n      const importedSymbols = imports[path]\n      let rule = existingImports[path]\n\n      if (!rule && importedSymbols) {\n        rule = postcss.rule({\n          selector: `:import(\"${path}\")`,\n          raws: { after: '\\n' }\n        })\n\n        if (lastImportRule) css.insertAfter(lastImportRule, rule)\n        else css.prepend(rule)\n      }\n\n      lastImportRule = rule\n\n      if (!importedSymbols) return\n\n      Object.keys(importedSymbols).forEach(importedSymbol => {\n        rule.append(\n          postcss.decl({\n            value: importedSymbol,\n            prop: importedSymbols[importedSymbol],\n            raws: { before: '\\n  ' }\n          })\n        )\n      })\n    })\n  }\n})\n"]},"metadata":{},"sourceType":"script"}