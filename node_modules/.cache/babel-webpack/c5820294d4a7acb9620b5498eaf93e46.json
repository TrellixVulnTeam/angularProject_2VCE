{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar util = require('util');\n\nvar contentPath = require('./path');\n\nvar fixOwner = require('../util/fix-owner');\n\nvar fs = require('fs');\n\nvar moveFile = require('../util/move-file');\n\nvar Minipass = require('minipass');\n\nvar Pipeline = require('minipass-pipeline');\n\nvar Flush = require('minipass-flush');\n\nvar path = require('path');\n\nvar rimraf = util.promisify(require('rimraf'));\n\nvar ssri = require('ssri');\n\nvar uniqueFilename = require('unique-filename');\n\nvar _require = require('./../util/disposer'),\n    disposer = _require.disposer;\n\nvar fsm = require('fs-minipass');\n\nvar writeFile = util.promisify(fs.writeFile);\nmodule.exports = write;\n\nfunction write(cache, data) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var algorithms = opts.algorithms,\n      size = opts.size,\n      integrity = opts.integrity;\n  if (algorithms && algorithms.length > 1) throw new Error('opts.algorithms only supports a single algorithm for now');\n  if (typeof size === 'number' && data.length !== size) return Promise.reject(sizeError(size, data.length));\n  var sri = ssri.fromData(data, algorithms ? {\n    algorithms: algorithms\n  } : {});\n  if (integrity && !ssri.checkData(data, integrity, opts)) return Promise.reject(checksumError(integrity, sri));\n  return disposer(makeTmp(cache, opts), makeTmpDisposer, function (tmp) {\n    return writeFile(tmp.target, data, {\n      flag: 'wx'\n    }).then(function () {\n      return moveToDestination(tmp, cache, sri, opts);\n    });\n  }).then(function () {\n    return {\n      integrity: sri,\n      size: data.length\n    };\n  });\n}\n\nmodule.exports.stream = writeStream; // writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\n\nvar CacacheWriteStream = /*#__PURE__*/function (_Flush) {\n  _inherits(CacacheWriteStream, _Flush);\n\n  var _super = _createSuper(CacacheWriteStream);\n\n  function CacacheWriteStream(cache, opts) {\n    var _this;\n\n    _classCallCheck(this, CacacheWriteStream);\n\n    _this = _super.call(this);\n    _this.opts = opts;\n    _this.cache = cache;\n    _this.inputStream = new Minipass();\n\n    _this.inputStream.on('error', function (er) {\n      return _this.emit('error', er);\n    });\n\n    _this.inputStream.on('drain', function () {\n      return _this.emit('drain');\n    });\n\n    _this.handleContentP = null;\n    return _this;\n  }\n\n  _createClass(CacacheWriteStream, [{\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      if (!this.handleContentP) {\n        this.handleContentP = handleContent(this.inputStream, this.cache, this.opts);\n      }\n\n      return this.inputStream.write(chunk, encoding, cb);\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(cb) {\n      var _this2 = this;\n\n      this.inputStream.end(function () {\n        if (!_this2.handleContentP) {\n          var e = new Error('Cache input stream was empty');\n          e.code = 'ENODATA'; // empty streams are probably emitting end right away.\n          // defer this one tick by rejecting a promise on it.\n\n          return Promise.reject(e).catch(cb);\n        }\n\n        _this2.handleContentP.then(function (res) {\n          res.integrity && _this2.emit('integrity', res.integrity);\n          res.size !== null && _this2.emit('size', res.size);\n          cb();\n        }, function (er) {\n          return cb(er);\n        });\n      });\n    }\n  }]);\n\n  return CacacheWriteStream;\n}(Flush);\n\nfunction writeStream(cache) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return new CacacheWriteStream(cache, opts);\n}\n\nfunction handleContent(inputStream, cache, opts) {\n  return disposer(makeTmp(cache, opts), makeTmpDisposer, function (tmp) {\n    return pipeToTmp(inputStream, cache, tmp.target, opts).then(function (res) {\n      return moveToDestination(tmp, cache, res.integrity, opts).then(function () {\n        return res;\n      });\n    });\n  });\n}\n\nfunction pipeToTmp(inputStream, cache, tmpTarget, opts) {\n  var integrity;\n  var size;\n  var hashStream = ssri.integrityStream({\n    integrity: opts.integrity,\n    algorithms: opts.algorithms,\n    size: opts.size\n  });\n  hashStream.on('integrity', function (i) {\n    integrity = i;\n  });\n  hashStream.on('size', function (s) {\n    size = s;\n  });\n  var outStream = new fsm.WriteStream(tmpTarget, {\n    flags: 'wx'\n  }); // NB: this can throw if the hashStream has a problem with\n  // it, and the data is fully written.  but pipeToTmp is only\n  // called in promisory contexts where that is handled.\n\n  var pipeline = new Pipeline(inputStream, hashStream, outStream);\n  return pipeline.promise().then(function () {\n    return {\n      integrity: integrity,\n      size: size\n    };\n  }).catch(function (er) {\n    return rimraf(tmpTarget).then(function () {\n      throw er;\n    });\n  });\n}\n\nfunction makeTmp(cache, opts) {\n  var tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n  return fixOwner.mkdirfix(cache, path.dirname(tmpTarget)).then(function () {\n    return {\n      target: tmpTarget,\n      moved: false\n    };\n  });\n}\n\nfunction makeTmpDisposer(tmp) {\n  if (tmp.moved) return Promise.resolve();\n  return rimraf(tmp.target);\n}\n\nfunction moveToDestination(tmp, cache, sri, opts) {\n  var destination = contentPath(cache, sri);\n  var destDir = path.dirname(destination);\n  return fixOwner.mkdirfix(cache, destDir).then(function () {\n    return moveFile(tmp.target, destination);\n  }).then(function () {\n    tmp.moved = true;\n    return fixOwner.chownr(cache, destination);\n  });\n}\n\nfunction sizeError(expected, found) {\n  var err = new Error(\"Bad data size: expected inserted data to be \".concat(expected, \" bytes, but got \").concat(found, \" instead\"));\n  err.expected = expected;\n  err.found = found;\n  err.code = 'EBADSIZE';\n  return err;\n}\n\nfunction checksumError(expected, found) {\n  var err = new Error(\"Integrity check failed:\\n  Wanted: \".concat(expected, \"\\n   Found: \").concat(found));\n  err.code = 'EINTEGRITY';\n  err.expected = expected;\n  err.found = found;\n  return err;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/cacache/lib/content/write.js"],"names":["util","require","contentPath","fixOwner","fs","moveFile","Minipass","Pipeline","Flush","path","rimraf","promisify","ssri","uniqueFilename","disposer","fsm","writeFile","module","exports","write","cache","data","opts","algorithms","size","integrity","length","Error","Promise","reject","sizeError","sri","fromData","checkData","checksumError","makeTmp","makeTmpDisposer","tmp","target","flag","then","moveToDestination","stream","writeStream","CacacheWriteStream","inputStream","on","er","emit","handleContentP","chunk","encoding","cb","handleContent","end","e","code","catch","res","pipeToTmp","tmpTarget","hashStream","integrityStream","i","s","outStream","WriteStream","flags","pipeline","promise","join","tmpPrefix","mkdirfix","dirname","moved","resolve","destination","destDir","chownr","expected","found","err"],"mappings":"AAAA;;;;;;;;;;AAEA,IAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AAEA,IAAMC,WAAW,GAAGD,OAAO,CAAC,QAAD,CAA3B;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,mBAAD,CAAxB;;AACA,IAAMG,EAAE,GAAGH,OAAO,CAAC,IAAD,CAAlB;;AACA,IAAMI,QAAQ,GAAGJ,OAAO,CAAC,mBAAD,CAAxB;;AACA,IAAMK,QAAQ,GAAGL,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMM,QAAQ,GAAGN,OAAO,CAAC,mBAAD,CAAxB;;AACA,IAAMO,KAAK,GAAGP,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAMQ,IAAI,GAAGR,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMS,MAAM,GAAGV,IAAI,CAACW,SAAL,CAAeV,OAAO,CAAC,QAAD,CAAtB,CAAf;;AACA,IAAMW,IAAI,GAAGX,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMY,cAAc,GAAGZ,OAAO,CAAC,iBAAD,CAA9B;;AACA,eAAqBA,OAAO,CAAC,oBAAD,CAA5B;AAAA,IAAQa,QAAR,YAAQA,QAAR;;AACA,IAAMC,GAAG,GAAGd,OAAO,CAAC,aAAD,CAAnB;;AAEA,IAAMe,SAAS,GAAGhB,IAAI,CAACW,SAAL,CAAeP,EAAE,CAACY,SAAlB,CAAlB;AAEAC,MAAM,CAACC,OAAP,GAAiBC,KAAjB;;AAEA,SAASA,KAAT,CAAgBC,KAAhB,EAAuBC,IAAvB,EAAwC;AAAA,MAAXC,IAAW,uEAAJ,EAAI;AACtC,MAAQC,UAAR,GAAwCD,IAAxC,CAAQC,UAAR;AAAA,MAAoBC,IAApB,GAAwCF,IAAxC,CAAoBE,IAApB;AAAA,MAA0BC,SAA1B,GAAwCH,IAAxC,CAA0BG,SAA1B;AACA,MAAIF,UAAU,IAAIA,UAAU,CAACG,MAAX,GAAoB,CAAtC,EACE,MAAM,IAAIC,KAAJ,CAAU,0DAAV,CAAN;AAEF,MAAI,OAAOH,IAAP,KAAgB,QAAhB,IAA4BH,IAAI,CAACK,MAAL,KAAgBF,IAAhD,EACE,OAAOI,OAAO,CAACC,MAAR,CAAeC,SAAS,CAACN,IAAD,EAAOH,IAAI,CAACK,MAAZ,CAAxB,CAAP;AAEF,MAAMK,GAAG,GAAGnB,IAAI,CAACoB,QAAL,CAAcX,IAAd,EAAoBE,UAAU,GAAG;AAAEA,IAAAA,UAAU,EAAVA;AAAF,GAAH,GAAoB,EAAlD,CAAZ;AACA,MAAIE,SAAS,IAAI,CAACb,IAAI,CAACqB,SAAL,CAAeZ,IAAf,EAAqBI,SAArB,EAAgCH,IAAhC,CAAlB,EACE,OAAOM,OAAO,CAACC,MAAR,CAAeK,aAAa,CAACT,SAAD,EAAYM,GAAZ,CAA5B,CAAP;AAEF,SAAOjB,QAAQ,CAACqB,OAAO,CAACf,KAAD,EAAQE,IAAR,CAAR,EAAuBc,eAAvB,EACb,UAACC,GAAD,EAAS;AACP,WAAOrB,SAAS,CAACqB,GAAG,CAACC,MAAL,EAAajB,IAAb,EAAmB;AAAEkB,MAAAA,IAAI,EAAE;AAAR,KAAnB,CAAT,CACJC,IADI,CACC;AAAA,aAAMC,iBAAiB,CAACJ,GAAD,EAAMjB,KAAN,EAAaW,GAAb,EAAkBT,IAAlB,CAAvB;AAAA,KADD,CAAP;AAED,GAJY,CAAR,CAKJkB,IALI,CAKC;AAAA,WAAO;AAAEf,MAAAA,SAAS,EAAEM,GAAb;AAAkBP,MAAAA,IAAI,EAAEH,IAAI,CAACK;AAA7B,KAAP;AAAA,GALD,CAAP;AAMD;;AAEDT,MAAM,CAACC,OAAP,CAAewB,MAAf,GAAwBC,WAAxB,C,CAEA;AACA;;IACMC,kB;;;;;AACJ,8BAAaxB,KAAb,EAAoBE,IAApB,EAA0B;AAAA;;AAAA;;AACxB;AACA,UAAKA,IAAL,GAAYA,IAAZ;AACA,UAAKF,KAAL,GAAaA,KAAb;AACA,UAAKyB,WAAL,GAAmB,IAAIvC,QAAJ,EAAnB;;AACA,UAAKuC,WAAL,CAAiBC,EAAjB,CAAoB,OAApB,EAA6B,UAAAC,EAAE;AAAA,aAAI,MAAKC,IAAL,CAAU,OAAV,EAAmBD,EAAnB,CAAJ;AAAA,KAA/B;;AACA,UAAKF,WAAL,CAAiBC,EAAjB,CAAoB,OAApB,EAA6B;AAAA,aAAM,MAAKE,IAAL,CAAU,OAAV,CAAN;AAAA,KAA7B;;AACA,UAAKC,cAAL,GAAsB,IAAtB;AAPwB;AAQzB;;;;WAED,eAAOC,KAAP,EAAcC,QAAd,EAAwBC,EAAxB,EAA4B;AAC1B,UAAI,CAAC,KAAKH,cAAV,EAA0B;AACxB,aAAKA,cAAL,GAAsBI,aAAa,CACjC,KAAKR,WAD4B,EAEjC,KAAKzB,KAF4B,EAGjC,KAAKE,IAH4B,CAAnC;AAKD;;AACD,aAAO,KAAKuB,WAAL,CAAiB1B,KAAjB,CAAuB+B,KAAvB,EAA8BC,QAA9B,EAAwCC,EAAxC,CAAP;AACD;;;WAED,eAAOA,EAAP,EAAW;AAAA;;AACT,WAAKP,WAAL,CAAiBS,GAAjB,CAAqB,YAAM;AACzB,YAAI,CAAC,MAAI,CAACL,cAAV,EAA0B;AACxB,cAAMM,CAAC,GAAG,IAAI5B,KAAJ,CAAU,8BAAV,CAAV;AACA4B,UAAAA,CAAC,CAACC,IAAF,GAAS,SAAT,CAFwB,CAGxB;AACA;;AACA,iBAAO5B,OAAO,CAACC,MAAR,CAAe0B,CAAf,EAAkBE,KAAlB,CAAwBL,EAAxB,CAAP;AACD;;AACD,QAAA,MAAI,CAACH,cAAL,CAAoBT,IAApB,CACE,UAACkB,GAAD,EAAS;AACPA,UAAAA,GAAG,CAACjC,SAAJ,IAAiB,MAAI,CAACuB,IAAL,CAAU,WAAV,EAAuBU,GAAG,CAACjC,SAA3B,CAAjB;AACAiC,UAAAA,GAAG,CAAClC,IAAJ,KAAa,IAAb,IAAqB,MAAI,CAACwB,IAAL,CAAU,MAAV,EAAkBU,GAAG,CAAClC,IAAtB,CAArB;AACA4B,UAAAA,EAAE;AACH,SALH,EAME,UAACL,EAAD;AAAA,iBAAQK,EAAE,CAACL,EAAD,CAAV;AAAA,SANF;AAQD,OAhBD;AAiBD;;;;EAxC8BvC,K;;AA2CjC,SAASmC,WAAT,CAAsBvB,KAAtB,EAAwC;AAAA,MAAXE,IAAW,uEAAJ,EAAI;AACtC,SAAO,IAAIsB,kBAAJ,CAAuBxB,KAAvB,EAA8BE,IAA9B,CAAP;AACD;;AAED,SAAS+B,aAAT,CAAwBR,WAAxB,EAAqCzB,KAArC,EAA4CE,IAA5C,EAAkD;AAChD,SAAOR,QAAQ,CAACqB,OAAO,CAACf,KAAD,EAAQE,IAAR,CAAR,EAAuBc,eAAvB,EAAwC,UAACC,GAAD,EAAS;AAC9D,WAAOsB,SAAS,CAACd,WAAD,EAAczB,KAAd,EAAqBiB,GAAG,CAACC,MAAzB,EAAiChB,IAAjC,CAAT,CACJkB,IADI,CACC,UAACkB,GAAD,EAAS;AACb,aAAOjB,iBAAiB,CACtBJ,GADsB,EAEtBjB,KAFsB,EAGtBsC,GAAG,CAACjC,SAHkB,EAItBH,IAJsB,CAAjB,CAKLkB,IALK,CAKA;AAAA,eAAMkB,GAAN;AAAA,OALA,CAAP;AAMD,KARI,CAAP;AASD,GAVc,CAAf;AAWD;;AAED,SAASC,SAAT,CAAoBd,WAApB,EAAiCzB,KAAjC,EAAwCwC,SAAxC,EAAmDtC,IAAnD,EAAyD;AACvD,MAAIG,SAAJ;AACA,MAAID,IAAJ;AACA,MAAMqC,UAAU,GAAGjD,IAAI,CAACkD,eAAL,CAAqB;AACtCrC,IAAAA,SAAS,EAAEH,IAAI,CAACG,SADsB;AAEtCF,IAAAA,UAAU,EAAED,IAAI,CAACC,UAFqB;AAGtCC,IAAAA,IAAI,EAAEF,IAAI,CAACE;AAH2B,GAArB,CAAnB;AAKAqC,EAAAA,UAAU,CAACf,EAAX,CAAc,WAAd,EAA2B,UAAAiB,CAAC,EAAI;AAC9BtC,IAAAA,SAAS,GAAGsC,CAAZ;AACD,GAFD;AAGAF,EAAAA,UAAU,CAACf,EAAX,CAAc,MAAd,EAAsB,UAAAkB,CAAC,EAAI;AACzBxC,IAAAA,IAAI,GAAGwC,CAAP;AACD,GAFD;AAIA,MAAMC,SAAS,GAAG,IAAIlD,GAAG,CAACmD,WAAR,CAAoBN,SAApB,EAA+B;AAC/CO,IAAAA,KAAK,EAAE;AADwC,GAA/B,CAAlB,CAfuD,CAmBvD;AACA;AACA;;AACA,MAAMC,QAAQ,GAAG,IAAI7D,QAAJ,CACfsC,WADe,EAEfgB,UAFe,EAGfI,SAHe,CAAjB;AAMA,SAAOG,QAAQ,CAACC,OAAT,GACJ7B,IADI,CACC;AAAA,WAAO;AAAEf,MAAAA,SAAS,EAATA,SAAF;AAAaD,MAAAA,IAAI,EAAJA;AAAb,KAAP;AAAA,GADD,EAEJiC,KAFI,CAEE,UAAAV,EAAE;AAAA,WAAIrC,MAAM,CAACkD,SAAD,CAAN,CAAkBpB,IAAlB,CAAuB,YAAM;AACxC,YAAMO,EAAN;AACD,KAFY,CAAJ;AAAA,GAFJ,CAAP;AAKD;;AAED,SAASZ,OAAT,CAAkBf,KAAlB,EAAyBE,IAAzB,EAA+B;AAC7B,MAAMsC,SAAS,GAAG/C,cAAc,CAACJ,IAAI,CAAC6D,IAAL,CAAUlD,KAAV,EAAiB,KAAjB,CAAD,EAA0BE,IAAI,CAACiD,SAA/B,CAAhC;AACA,SAAOpE,QAAQ,CAACqE,QAAT,CAAkBpD,KAAlB,EAAyBX,IAAI,CAACgE,OAAL,CAAab,SAAb,CAAzB,EAAkDpB,IAAlD,CAAuD;AAAA,WAAO;AACnEF,MAAAA,MAAM,EAAEsB,SAD2D;AAEnEc,MAAAA,KAAK,EAAE;AAF4D,KAAP;AAAA,GAAvD,CAAP;AAID;;AAED,SAAStC,eAAT,CAA0BC,GAA1B,EAA+B;AAC7B,MAAIA,GAAG,CAACqC,KAAR,EACE,OAAO9C,OAAO,CAAC+C,OAAR,EAAP;AAEF,SAAOjE,MAAM,CAAC2B,GAAG,CAACC,MAAL,CAAb;AACD;;AAED,SAASG,iBAAT,CAA4BJ,GAA5B,EAAiCjB,KAAjC,EAAwCW,GAAxC,EAA6CT,IAA7C,EAAmD;AACjD,MAAMsD,WAAW,GAAG1E,WAAW,CAACkB,KAAD,EAAQW,GAAR,CAA/B;AACA,MAAM8C,OAAO,GAAGpE,IAAI,CAACgE,OAAL,CAAaG,WAAb,CAAhB;AAEA,SAAOzE,QAAQ,CACZqE,QADI,CACKpD,KADL,EACYyD,OADZ,EAEJrC,IAFI,CAEC,YAAM;AACV,WAAOnC,QAAQ,CAACgC,GAAG,CAACC,MAAL,EAAasC,WAAb,CAAf;AACD,GAJI,EAKJpC,IALI,CAKC,YAAM;AACVH,IAAAA,GAAG,CAACqC,KAAJ,GAAY,IAAZ;AACA,WAAOvE,QAAQ,CAAC2E,MAAT,CAAgB1D,KAAhB,EAAuBwD,WAAvB,CAAP;AACD,GARI,CAAP;AASD;;AAED,SAAS9C,SAAT,CAAoBiD,QAApB,EAA8BC,KAA9B,EAAqC;AACnC,MAAMC,GAAG,GAAG,IAAItD,KAAJ,uDAAyDoD,QAAzD,6BAAoFC,KAApF,cAAZ;AACAC,EAAAA,GAAG,CAACF,QAAJ,GAAeA,QAAf;AACAE,EAAAA,GAAG,CAACD,KAAJ,GAAYA,KAAZ;AACAC,EAAAA,GAAG,CAACzB,IAAJ,GAAW,UAAX;AACA,SAAOyB,GAAP;AACD;;AAED,SAAS/C,aAAT,CAAwB6C,QAAxB,EAAkCC,KAAlC,EAAyC;AACvC,MAAMC,GAAG,GAAG,IAAItD,KAAJ,8CACFoD,QADE,yBAEFC,KAFE,EAAZ;AAGAC,EAAAA,GAAG,CAACzB,IAAJ,GAAW,YAAX;AACAyB,EAAAA,GAAG,CAACF,QAAJ,GAAeA,QAAf;AACAE,EAAAA,GAAG,CAACD,KAAJ,GAAYA,KAAZ;AACA,SAAOC,GAAP;AACD","sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst contentPath = require('./path')\nconst fixOwner = require('../util/fix-owner')\nconst fs = require('fs')\nconst moveFile = require('../util/move-file')\nconst Minipass = require('minipass')\nconst Pipeline = require('minipass-pipeline')\nconst Flush = require('minipass-flush')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\nconst uniqueFilename = require('unique-filename')\nconst { disposer } = require('./../util/disposer')\nconst fsm = require('fs-minipass')\n\nconst writeFile = util.promisify(fs.writeFile)\n\nmodule.exports = write\n\nfunction write (cache, data, opts = {}) {\n  const { algorithms, size, integrity } = opts\n  if (algorithms && algorithms.length > 1)\n    throw new Error('opts.algorithms only supports a single algorithm for now')\n\n  if (typeof size === 'number' && data.length !== size)\n    return Promise.reject(sizeError(size, data.length))\n\n  const sri = ssri.fromData(data, algorithms ? { algorithms } : {})\n  if (integrity && !ssri.checkData(data, integrity, opts))\n    return Promise.reject(checksumError(integrity, sri))\n\n  return disposer(makeTmp(cache, opts), makeTmpDisposer,\n    (tmp) => {\n      return writeFile(tmp.target, data, { flag: 'wx' })\n        .then(() => moveToDestination(tmp, cache, sri, opts))\n    })\n    .then(() => ({ integrity: sri, size: data.length }))\n}\n\nmodule.exports.stream = writeStream\n\n// writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\nclass CacacheWriteStream extends Flush {\n  constructor (cache, opts) {\n    super()\n    this.opts = opts\n    this.cache = cache\n    this.inputStream = new Minipass()\n    this.inputStream.on('error', er => this.emit('error', er))\n    this.inputStream.on('drain', () => this.emit('drain'))\n    this.handleContentP = null\n  }\n\n  write (chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(\n        this.inputStream,\n        this.cache,\n        this.opts\n      )\n    }\n    return this.inputStream.write(chunk, encoding, cb)\n  }\n\n  flush (cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty')\n        e.code = 'ENODATA'\n        // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n        return Promise.reject(e).catch(cb)\n      }\n      this.handleContentP.then(\n        (res) => {\n          res.integrity && this.emit('integrity', res.integrity)\n          res.size !== null && this.emit('size', res.size)\n          cb()\n        },\n        (er) => cb(er)\n      )\n    })\n  }\n}\n\nfunction writeStream (cache, opts = {}) {\n  return new CacacheWriteStream(cache, opts)\n}\n\nfunction handleContent (inputStream, cache, opts) {\n  return disposer(makeTmp(cache, opts), makeTmpDisposer, (tmp) => {\n    return pipeToTmp(inputStream, cache, tmp.target, opts)\n      .then((res) => {\n        return moveToDestination(\n          tmp,\n          cache,\n          res.integrity,\n          opts\n        ).then(() => res)\n      })\n  })\n}\n\nfunction pipeToTmp (inputStream, cache, tmpTarget, opts) {\n  let integrity\n  let size\n  const hashStream = ssri.integrityStream({\n    integrity: opts.integrity,\n    algorithms: opts.algorithms,\n    size: opts.size,\n  })\n  hashStream.on('integrity', i => {\n    integrity = i\n  })\n  hashStream.on('size', s => {\n    size = s\n  })\n\n  const outStream = new fsm.WriteStream(tmpTarget, {\n    flags: 'wx',\n  })\n\n  // NB: this can throw if the hashStream has a problem with\n  // it, and the data is fully written.  but pipeToTmp is only\n  // called in promisory contexts where that is handled.\n  const pipeline = new Pipeline(\n    inputStream,\n    hashStream,\n    outStream\n  )\n\n  return pipeline.promise()\n    .then(() => ({ integrity, size }))\n    .catch(er => rimraf(tmpTarget).then(() => {\n      throw er\n    }))\n}\n\nfunction makeTmp (cache, opts) {\n  const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix)\n  return fixOwner.mkdirfix(cache, path.dirname(tmpTarget)).then(() => ({\n    target: tmpTarget,\n    moved: false,\n  }))\n}\n\nfunction makeTmpDisposer (tmp) {\n  if (tmp.moved)\n    return Promise.resolve()\n\n  return rimraf(tmp.target)\n}\n\nfunction moveToDestination (tmp, cache, sri, opts) {\n  const destination = contentPath(cache, sri)\n  const destDir = path.dirname(destination)\n\n  return fixOwner\n    .mkdirfix(cache, destDir)\n    .then(() => {\n      return moveFile(tmp.target, destination)\n    })\n    .then(() => {\n      tmp.moved = true\n      return fixOwner.chownr(cache, destination)\n    })\n}\n\nfunction sizeError (expected, found) {\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`)\n  err.expected = expected\n  err.found = found\n  err.code = 'EBADSIZE'\n  return err\n}\n\nfunction checksumError (expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`)\n  err.code = 'EINTEGRITY'\n  err.expected = expected\n  err.found = found\n  return err\n}\n"]},"metadata":{},"sourceType":"script"}