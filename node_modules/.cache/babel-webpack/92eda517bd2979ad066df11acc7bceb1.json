{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/metadata/schema\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isMetadataError = exports.isMetadataSymbolicSpreadExpression = exports.isMetadataSymbolicSelectExpression = exports.isMetadataSymbolicReferenceExpression = exports.isMetadataImportDefaultReference = exports.isMetadataImportedSymbolReferenceExpression = exports.isMetadataModuleReferenceExpression = exports.isMetadataGlobalReferenceExpression = exports.isMetadataSymbolicIfExpression = exports.isMetadataSymbolicPrefixExpression = exports.isMetadataSymbolicCallExpression = exports.isMetadataSymbolicIndexExpression = exports.isMetadataSymbolicBinaryExpression = exports.isMetadataSymbolicExpression = exports.isFunctionMetadata = exports.isConstructorMetadata = exports.isMethodMetadata = exports.isMemberMetadata = exports.isInterfaceMetadata = exports.isClassMetadata = exports.isModuleMetadata = exports.METADATA_VERSION = void 0; // Metadata Schema\n  // If you make a backwards incompatible change to the schema, increment the METADTA_VERSION number.\n  // If you make a backwards compatible change to the metadata (such as adding an option field) then\n  // leave METADATA_VERSION the same. If possible, supply as many versions of the metadata that can\n  // represent the semantics of the file in an array. For example, when generating a version 2 file,\n  // if version 1 can accurately represent the metadata, generate both version 1 and version 2 in\n  // an array.\n\n  exports.METADATA_VERSION = 4;\n\n  function isModuleMetadata(value) {\n    return value && value.__symbolic === 'module';\n  }\n\n  exports.isModuleMetadata = isModuleMetadata;\n\n  function isClassMetadata(value) {\n    return value && value.__symbolic === 'class';\n  }\n\n  exports.isClassMetadata = isClassMetadata;\n\n  function isInterfaceMetadata(value) {\n    return value && value.__symbolic === 'interface';\n  }\n\n  exports.isInterfaceMetadata = isInterfaceMetadata;\n\n  function isMemberMetadata(value) {\n    if (value) {\n      switch (value.__symbolic) {\n        case 'constructor':\n        case 'method':\n        case 'property':\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  exports.isMemberMetadata = isMemberMetadata;\n\n  function isMethodMetadata(value) {\n    return value && (value.__symbolic === 'constructor' || value.__symbolic === 'method');\n  }\n\n  exports.isMethodMetadata = isMethodMetadata;\n\n  function isConstructorMetadata(value) {\n    return value && value.__symbolic === 'constructor';\n  }\n\n  exports.isConstructorMetadata = isConstructorMetadata;\n\n  function isFunctionMetadata(value) {\n    return value && value.__symbolic === 'function';\n  }\n\n  exports.isFunctionMetadata = isFunctionMetadata;\n\n  function isMetadataSymbolicExpression(value) {\n    if (value) {\n      switch (value.__symbolic) {\n        case 'binary':\n        case 'call':\n        case 'index':\n        case 'new':\n        case 'pre':\n        case 'reference':\n        case 'select':\n        case 'spread':\n        case 'if':\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  exports.isMetadataSymbolicExpression = isMetadataSymbolicExpression;\n\n  function isMetadataSymbolicBinaryExpression(value) {\n    return value && value.__symbolic === 'binary';\n  }\n\n  exports.isMetadataSymbolicBinaryExpression = isMetadataSymbolicBinaryExpression;\n\n  function isMetadataSymbolicIndexExpression(value) {\n    return value && value.__symbolic === 'index';\n  }\n\n  exports.isMetadataSymbolicIndexExpression = isMetadataSymbolicIndexExpression;\n\n  function isMetadataSymbolicCallExpression(value) {\n    return value && (value.__symbolic === 'call' || value.__symbolic === 'new');\n  }\n\n  exports.isMetadataSymbolicCallExpression = isMetadataSymbolicCallExpression;\n\n  function isMetadataSymbolicPrefixExpression(value) {\n    return value && value.__symbolic === 'pre';\n  }\n\n  exports.isMetadataSymbolicPrefixExpression = isMetadataSymbolicPrefixExpression;\n\n  function isMetadataSymbolicIfExpression(value) {\n    return value && value.__symbolic === 'if';\n  }\n\n  exports.isMetadataSymbolicIfExpression = isMetadataSymbolicIfExpression;\n\n  function isMetadataGlobalReferenceExpression(value) {\n    return value && value.name && !value.module && isMetadataSymbolicReferenceExpression(value);\n  }\n\n  exports.isMetadataGlobalReferenceExpression = isMetadataGlobalReferenceExpression;\n\n  function isMetadataModuleReferenceExpression(value) {\n    return value && value.module && !value.name && !value.default && isMetadataSymbolicReferenceExpression(value);\n  }\n\n  exports.isMetadataModuleReferenceExpression = isMetadataModuleReferenceExpression;\n\n  function isMetadataImportedSymbolReferenceExpression(value) {\n    return value && value.module && !!value.name && isMetadataSymbolicReferenceExpression(value);\n  }\n\n  exports.isMetadataImportedSymbolReferenceExpression = isMetadataImportedSymbolReferenceExpression;\n\n  function isMetadataImportDefaultReference(value) {\n    return value && value.module && value.default && isMetadataSymbolicReferenceExpression(value);\n  }\n\n  exports.isMetadataImportDefaultReference = isMetadataImportDefaultReference;\n\n  function isMetadataSymbolicReferenceExpression(value) {\n    return value && value.__symbolic === 'reference';\n  }\n\n  exports.isMetadataSymbolicReferenceExpression = isMetadataSymbolicReferenceExpression;\n\n  function isMetadataSymbolicSelectExpression(value) {\n    return value && value.__symbolic === 'select';\n  }\n\n  exports.isMetadataSymbolicSelectExpression = isMetadataSymbolicSelectExpression;\n\n  function isMetadataSymbolicSpreadExpression(value) {\n    return value && value.__symbolic === 'spread';\n  }\n\n  exports.isMetadataSymbolicSpreadExpression = isMetadataSymbolicSpreadExpression;\n\n  function isMetadataError(value) {\n    return value && value.__symbolic === 'error';\n  }\n\n  exports.isMetadataError = isMetadataError;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/metadata/schema.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Metadata Schema\n\n// If you make a backwards incompatible change to the schema, increment the METADTA_VERSION number.\n\n// If you make a backwards compatible change to the metadata (such as adding an option field) then\n// leave METADATA_VERSION the same. If possible, supply as many versions of the metadata that can\n// represent the semantics of the file in an array. For example, when generating a version 2 file,\n// if version 1 can accurately represent the metadata, generate both version 1 and version 2 in\n// an array.\n\nexport const METADATA_VERSION = 4;\n\nexport type MetadataEntry = ClassMetadata|InterfaceMetadata|FunctionMetadata|MetadataValue;\n\nexport interface ModuleMetadata {\n  __symbolic: 'module';\n  version: number;\n  exports?: ModuleExportMetadata[];\n  importAs?: string;\n  metadata: {[name: string]: MetadataEntry};\n  origins?: {[name: string]: string};\n}\nexport function isModuleMetadata(value: any): value is ModuleMetadata {\n  return value && value.__symbolic === 'module';\n}\n\nexport interface ModuleExportMetadata {\n  export?: (string|{name: string, as: string})[];\n  from: string;\n}\n\nexport interface ClassMetadata {\n  __symbolic: 'class';\n  extends?: MetadataSymbolicExpression|MetadataError;\n  arity?: number;\n  decorators?: (MetadataSymbolicExpression|MetadataError)[];\n  members?: MetadataMap;\n  statics?: {[name: string]: MetadataValue|FunctionMetadata};\n}\nexport function isClassMetadata(value: any): value is ClassMetadata {\n  return value && value.__symbolic === 'class';\n}\n\nexport interface InterfaceMetadata {\n  __symbolic: 'interface';\n}\nexport function isInterfaceMetadata(value: any): value is InterfaceMetadata {\n  return value && value.__symbolic === 'interface';\n}\n\nexport interface MetadataMap {\n  [name: string]: MemberMetadata[];\n}\n\nexport interface MemberMetadata {\n  __symbolic: 'constructor'|'method'|'property';\n  decorators?: (MetadataSymbolicExpression|MetadataError)[];\n  parameters?: (MetadataSymbolicExpression|MetadataError|null|undefined)[];\n}\nexport function isMemberMetadata(value: any): value is MemberMetadata {\n  if (value) {\n    switch (value.__symbolic) {\n      case 'constructor':\n      case 'method':\n      case 'property':\n        return true;\n    }\n  }\n  return false;\n}\n\nexport interface MethodMetadata extends MemberMetadata {\n  __symbolic: 'constructor'|'method';\n  parameterDecorators?: ((MetadataSymbolicExpression | MetadataError)[]|undefined)[];\n}\nexport function isMethodMetadata(value: any): value is MethodMetadata {\n  return value && (value.__symbolic === 'constructor' || value.__symbolic === 'method');\n}\n\nexport interface ConstructorMetadata extends MethodMetadata {\n  __symbolic: 'constructor';\n  parameters?: (MetadataSymbolicExpression|MetadataError|null|undefined)[];\n}\nexport function isConstructorMetadata(value: any): value is ConstructorMetadata {\n  return value && value.__symbolic === 'constructor';\n}\n\nexport interface FunctionMetadata {\n  __symbolic: 'function';\n  parameters: string[];\n  defaults?: MetadataValue[];\n  value: MetadataValue;\n}\nexport function isFunctionMetadata(value: any): value is FunctionMetadata {\n  return value && value.__symbolic === 'function';\n}\n\nexport type MetadataValue = string|number|boolean|undefined|null|MetadataObject|MetadataArray|\n    MetadataSymbolicExpression|MetadataSymbolicReferenceExpression|MetadataSymbolicBinaryExpression|\n    MetadataSymbolicIndexExpression|MetadataSymbolicCallExpression|MetadataSymbolicPrefixExpression|\n    MetadataSymbolicIfExpression|MetadataSymbolicSpreadExpression|MetadataSymbolicSelectExpression|\n    MetadataError;\n\nexport interface MetadataObject {\n  [name: string]: MetadataValue;\n}\n\nexport interface MetadataArray {\n  [name: number]: MetadataValue;\n}\n\nexport type MetadataSymbolicExpression = MetadataSymbolicBinaryExpression|\n    MetadataSymbolicIndexExpression|MetadataSymbolicIndexExpression|MetadataSymbolicCallExpression|\n    MetadataSymbolicCallExpression|MetadataSymbolicPrefixExpression|MetadataSymbolicIfExpression|\n    MetadataGlobalReferenceExpression|MetadataModuleReferenceExpression|\n    MetadataImportedSymbolReferenceExpression|MetadataImportedDefaultReferenceExpression|\n    MetadataSymbolicSelectExpression|MetadataSymbolicSpreadExpression;\n\nexport function isMetadataSymbolicExpression(value: any): value is MetadataSymbolicExpression {\n  if (value) {\n    switch (value.__symbolic) {\n      case 'binary':\n      case 'call':\n      case 'index':\n      case 'new':\n      case 'pre':\n      case 'reference':\n      case 'select':\n      case 'spread':\n      case 'if':\n        return true;\n    }\n  }\n  return false;\n}\n\nexport interface MetadataSymbolicBinaryExpression {\n  __symbolic: 'binary';\n  operator: '&&'|'||'|'|'|'^'|'&'|'=='|'!='|'==='|'!=='|'<'|'>'|'<='|'>='|'instanceof'|'in'|'as'|\n      '<<'|'>>'|'>>>'|'+'|'-'|'*'|'/'|'%'|'**';\n  left: MetadataValue;\n  right: MetadataValue;\n}\nexport function isMetadataSymbolicBinaryExpression(value: any):\n    value is MetadataSymbolicBinaryExpression {\n  return value && value.__symbolic === 'binary';\n}\n\nexport interface MetadataSymbolicIndexExpression {\n  __symbolic: 'index';\n  expression: MetadataValue;\n  index: MetadataValue;\n}\nexport function isMetadataSymbolicIndexExpression(value: any):\n    value is MetadataSymbolicIndexExpression {\n  return value && value.__symbolic === 'index';\n}\n\nexport interface MetadataSymbolicCallExpression {\n  __symbolic: 'call'|'new';\n  expression: MetadataValue;\n  arguments?: MetadataValue[];\n}\nexport function isMetadataSymbolicCallExpression(value: any):\n    value is MetadataSymbolicCallExpression {\n  return value && (value.__symbolic === 'call' || value.__symbolic === 'new');\n}\n\nexport interface MetadataSymbolicPrefixExpression {\n  __symbolic: 'pre';\n  operator: '+'|'-'|'~'|'!';\n  operand: MetadataValue;\n}\nexport function isMetadataSymbolicPrefixExpression(value: any):\n    value is MetadataSymbolicPrefixExpression {\n  return value && value.__symbolic === 'pre';\n}\n\nexport interface MetadataSymbolicIfExpression {\n  __symbolic: 'if';\n  condition: MetadataValue;\n  thenExpression: MetadataValue;\n  elseExpression: MetadataValue;\n}\nexport function isMetadataSymbolicIfExpression(value: any): value is MetadataSymbolicIfExpression {\n  return value && value.__symbolic === 'if';\n}\n\nexport interface MetadataSourceLocationInfo {\n  /**\n   * The line number of the error in the .ts file the metadata was created for.\n   */\n  line?: number;\n\n  /**\n   * The number of utf8 code-units from the beginning of the file of the error.\n   */\n  character?: number;\n}\n\nexport interface MetadataGlobalReferenceExpression extends MetadataSourceLocationInfo {\n  __symbolic: 'reference';\n  name: string;\n  arguments?: MetadataValue[];\n}\nexport function isMetadataGlobalReferenceExpression(value: any):\n    value is MetadataGlobalReferenceExpression {\n  return value && value.name && !value.module && isMetadataSymbolicReferenceExpression(value);\n}\n\nexport interface MetadataModuleReferenceExpression extends MetadataSourceLocationInfo {\n  __symbolic: 'reference';\n  module: string;\n}\nexport function isMetadataModuleReferenceExpression(value: any):\n    value is MetadataModuleReferenceExpression {\n  return value && value.module && !value.name && !value.default &&\n      isMetadataSymbolicReferenceExpression(value);\n}\n\nexport interface MetadataImportedSymbolReferenceExpression extends MetadataSourceLocationInfo {\n  __symbolic: 'reference';\n  module: string;\n  name: string;\n  arguments?: MetadataValue[];\n}\nexport function isMetadataImportedSymbolReferenceExpression(value: any):\n    value is MetadataImportedSymbolReferenceExpression {\n  return value && value.module && !!value.name && isMetadataSymbolicReferenceExpression(value);\n}\n\nexport interface MetadataImportedDefaultReferenceExpression extends MetadataSourceLocationInfo {\n  __symbolic: 'reference';\n  module: string;\n  default: boolean;\n  arguments?: MetadataValue[];\n}\nexport function isMetadataImportDefaultReference(value: any):\n    value is MetadataImportedDefaultReferenceExpression {\n  return value && value.module && value.default && isMetadataSymbolicReferenceExpression(value);\n}\n\nexport type MetadataSymbolicReferenceExpression =\n    MetadataGlobalReferenceExpression|MetadataModuleReferenceExpression|\n    MetadataImportedSymbolReferenceExpression|MetadataImportedDefaultReferenceExpression;\nexport function isMetadataSymbolicReferenceExpression(value: any):\n    value is MetadataSymbolicReferenceExpression {\n  return value && value.__symbolic === 'reference';\n}\n\nexport interface MetadataSymbolicSelectExpression {\n  __symbolic: 'select';\n  expression: MetadataValue;\n  member: string;\n}\nexport function isMetadataSymbolicSelectExpression(value: any):\n    value is MetadataSymbolicSelectExpression {\n  return value && value.__symbolic === 'select';\n}\n\nexport interface MetadataSymbolicSpreadExpression {\n  __symbolic: 'spread';\n  expression: MetadataValue;\n}\nexport function isMetadataSymbolicSpreadExpression(value: any):\n    value is MetadataSymbolicSpreadExpression {\n  return value && value.__symbolic === 'spread';\n}\n\nexport interface MetadataError extends MetadataSourceLocationInfo {\n  __symbolic: 'error';\n\n  /**\n   * This message should be short and relatively discriptive and should be fixed once it is created.\n   * If the reader doesn't recognize the message, it will display the message unmodified. If the\n   * reader recognizes the error message is it free to use substitute message the is more\n   * descriptive and/or localized.\n   */\n  message: string;\n\n  /**\n   * The module of the error (only used in bundled metadata)\n   */\n  module?: string;\n\n  /**\n   * Context information that can be used to generate a more descriptive error message. The content\n   * of the context is dependent on the error message.\n   */\n  context?: {[name: string]: string};\n}\n\nexport function isMetadataError(value: any): value is MetadataError {\n  return value && value.__symbolic === 'error';\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}