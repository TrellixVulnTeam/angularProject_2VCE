{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar virtual_fs_1 = require(\"../virtual-fs\");\n\nvar reader_1 = require(\"./json/reader\");\n\nvar writer_1 = require(\"./json/writer\");\n\nvar formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\n\nvar WorkspaceFormat;\n\n(function (WorkspaceFormat) {\n  WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat = exports.WorkspaceFormat || (exports.WorkspaceFormat = {}));\n/**\n * @private\n */\n\n\nfunction _test_addWorkspaceFile(name, format) {\n  workspaceFiles[name] = format;\n}\n\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\n\nfunction _test_removeWorkspaceFile(name) {\n  delete workspaceFiles[name];\n}\n\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile; // NOTE: future additions could also perform content analysis to determine format/version\n\nvar workspaceFiles = {\n  'angular.json': WorkspaceFormat.JSON,\n  '.angular.json': WorkspaceFormat.JSON\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\n\nfunction readWorkspace(_x, _x2, _x3) {\n  return _readWorkspace.apply(this, arguments);\n}\n\nfunction _readWorkspace() {\n  _readWorkspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, host, format) {\n    var directory, found, _i, _Object$entries, _Object$entries$_i, name, nameFormat, potential, filename, workspace;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return host.isDirectory(path);\n\n          case 2:\n            if (!_context.sent) {\n              _context.next = 25;\n              break;\n            }\n\n            // TODO: Warn if multiple found (requires diagnostics support)\n            directory = virtual_fs_1.normalize(path);\n            found = false;\n            _i = 0, _Object$entries = Object.entries(workspaceFiles);\n\n          case 6:\n            if (!(_i < _Object$entries.length)) {\n              _context.next = 21;\n              break;\n            }\n\n            _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), name = _Object$entries$_i[0], nameFormat = _Object$entries$_i[1];\n\n            if (!(format !== undefined && format !== nameFormat)) {\n              _context.next = 10;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 18);\n\n          case 10:\n            potential = virtual_fs_1.getSystemPath(virtual_fs_1.join(directory, name));\n            _context.next = 13;\n            return host.isFile(potential);\n\n          case 13:\n            if (!_context.sent) {\n              _context.next = 18;\n              break;\n            }\n\n            path = potential;\n            format = nameFormat;\n            found = true;\n            return _context.abrupt(\"break\", 21);\n\n          case 18:\n            _i++;\n            _context.next = 6;\n            break;\n\n          case 21:\n            if (found) {\n              _context.next = 23;\n              break;\n            }\n\n            throw new Error('Unable to locate a workspace file for workspace path.');\n\n          case 23:\n            _context.next = 26;\n            break;\n\n          case 25:\n            if (format === undefined) {\n              filename = virtual_fs_1.basename(virtual_fs_1.normalize(path));\n\n              if (filename in workspaceFiles) {\n                format = workspaceFiles[filename];\n              }\n            }\n\n          case 26:\n            if (!(format === undefined)) {\n              _context.next = 28;\n              break;\n            }\n\n            throw new Error('Unable to determine format for workspace path.');\n\n          case 28:\n            _context.t0 = format;\n            _context.next = _context.t0 === WorkspaceFormat.JSON ? 31 : 35;\n            break;\n\n          case 31:\n            _context.next = 33;\n            return reader_1.readJsonWorkspace(path, host);\n\n          case 33:\n            workspace = _context.sent;\n            return _context.abrupt(\"break\", 36);\n\n          case 35:\n            throw new Error('Unsupported workspace format.');\n\n          case 36:\n            formatLookup.set(workspace, WorkspaceFormat.JSON);\n            return _context.abrupt(\"return\", {\n              workspace: workspace\n            });\n\n          case 38:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _readWorkspace.apply(this, arguments);\n}\n\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\n\nfunction writeWorkspace(_x4, _x5, _x6, _x7) {\n  return _writeWorkspace.apply(this, arguments);\n}\n\nfunction _writeWorkspace() {\n  _writeWorkspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(workspace, host, path, format) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(format === undefined)) {\n              _context2.next = 4;\n              break;\n            }\n\n            format = formatLookup.get(workspace);\n\n            if (!(format === undefined)) {\n              _context2.next = 4;\n              break;\n            }\n\n            throw new Error('A format is required for custom workspace objects.');\n\n          case 4:\n            _context2.t0 = format;\n            _context2.next = _context2.t0 === WorkspaceFormat.JSON ? 7 : 8;\n            break;\n\n          case 7:\n            return _context2.abrupt(\"return\", writer_1.writeJsonWorkspace(workspace, host, path));\n\n          case 8:\n            throw new Error('Unsupported workspace format.');\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _writeWorkspace.apply(this, arguments);\n}\n\nexports.writeWorkspace = writeWorkspace;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/workspace/core.js"],"names":["Object","defineProperty","exports","value","writeWorkspace","readWorkspace","_test_removeWorkspaceFile","_test_addWorkspaceFile","WorkspaceFormat","virtual_fs_1","require","reader_1","writer_1","formatLookup","WeakMap","name","format","workspaceFiles","JSON","path","host","isDirectory","directory","normalize","found","entries","nameFormat","undefined","potential","getSystemPath","join","isFile","Error","filename","basename","readJsonWorkspace","workspace","set","get","writeJsonWorkspace"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst virtual_fs_1 = require(\"../virtual-fs\");\nconst reader_1 = require(\"./json/reader\");\nconst writer_1 = require(\"./json/writer\");\nconst formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\nvar WorkspaceFormat;\n(function (WorkspaceFormat) {\n    WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat = exports.WorkspaceFormat || (exports.WorkspaceFormat = {}));\n/**\n * @private\n */\nfunction _test_addWorkspaceFile(name, format) {\n    workspaceFiles[name] = format;\n}\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\nfunction _test_removeWorkspaceFile(name) {\n    delete workspaceFiles[name];\n}\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile;\n// NOTE: future additions could also perform content analysis to determine format/version\nconst workspaceFiles = {\n    'angular.json': WorkspaceFormat.JSON,\n    '.angular.json': WorkspaceFormat.JSON,\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\nasync function readWorkspace(path, host, format) {\n    if (await host.isDirectory(path)) {\n        // TODO: Warn if multiple found (requires diagnostics support)\n        const directory = virtual_fs_1.normalize(path);\n        let found = false;\n        for (const [name, nameFormat] of Object.entries(workspaceFiles)) {\n            if (format !== undefined && format !== nameFormat) {\n                continue;\n            }\n            const potential = virtual_fs_1.getSystemPath(virtual_fs_1.join(directory, name));\n            if (await host.isFile(potential)) {\n                path = potential;\n                format = nameFormat;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw new Error('Unable to locate a workspace file for workspace path.');\n        }\n    }\n    else if (format === undefined) {\n        const filename = virtual_fs_1.basename(virtual_fs_1.normalize(path));\n        if (filename in workspaceFiles) {\n            format = workspaceFiles[filename];\n        }\n    }\n    if (format === undefined) {\n        throw new Error('Unable to determine format for workspace path.');\n    }\n    let workspace;\n    switch (format) {\n        case WorkspaceFormat.JSON:\n            workspace = await reader_1.readJsonWorkspace(path, host);\n            break;\n        default:\n            throw new Error('Unsupported workspace format.');\n    }\n    formatLookup.set(workspace, WorkspaceFormat.JSON);\n    return { workspace };\n}\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\nasync function writeWorkspace(workspace, host, path, format) {\n    if (format === undefined) {\n        format = formatLookup.get(workspace);\n        if (format === undefined) {\n            throw new Error('A format is required for custom workspace objects.');\n        }\n    }\n    switch (format) {\n        case WorkspaceFormat.JSON:\n            return writer_1.writeJsonWorkspace(workspace, host, path);\n        default:\n            throw new Error('Unsupported workspace format.');\n    }\n}\nexports.writeWorkspace = writeWorkspace;\n"]},"metadata":{},"sourceType":"script"}