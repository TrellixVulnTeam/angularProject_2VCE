{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/cluster/master\", [\"require\", \"exports\", \"tslib\", \"cluster\", \"@angular/compiler-cli/ngcc/src/execution/tasks/utils\", \"@angular/compiler-cli/ngcc/src/execution/cluster/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ClusterMaster = void 0;\n\n  var tslib_1 = require(\"tslib\"); /// <reference types=\"node\" />\n\n\n  var cluster = require(\"cluster\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/utils\");\n\n  var utils_2 = require(\"@angular/compiler-cli/ngcc/src/execution/cluster/utils\");\n  /**\n   * The cluster master is responsible for analyzing all entry-points, planning the work that needs to\n   * be done, distributing it to worker-processes and collecting/post-processing the results.\n   */\n\n\n  var ClusterMaster =\n  /** @class */\n  function () {\n    function ClusterMaster(maxWorkerCount, fileSystem, logger, fileWriter, pkgJsonUpdater, analyzeEntryPoints, createTaskCompletedCallback) {\n      this.maxWorkerCount = maxWorkerCount;\n      this.fileSystem = fileSystem;\n      this.logger = logger;\n      this.fileWriter = fileWriter;\n      this.pkgJsonUpdater = pkgJsonUpdater;\n      this.finishedDeferred = new utils_2.Deferred();\n      this.processingStartTime = -1;\n      this.taskAssignments = new Map();\n      this.remainingRespawnAttempts = 3;\n\n      if (!cluster.isMaster) {\n        throw new Error('Tried to instantiate `ClusterMaster` on a worker process.');\n      } // Set the worker entry-point\n\n\n      cluster.setupMaster({\n        exec: this.fileSystem.resolve(__dirname, 'worker.js')\n      });\n      this.taskQueue = analyzeEntryPoints();\n      this.onTaskCompleted = createTaskCompletedCallback(this.taskQueue);\n    }\n\n    ClusterMaster.prototype.run = function () {\n      var _this = this;\n\n      if (this.taskQueue.allTasksCompleted) {\n        return Promise.resolve();\n      } // Set up listeners for worker events (emitted on `cluster`).\n\n\n      cluster.on('online', this.wrapEventHandler(function (worker) {\n        return _this.onWorkerOnline(worker.id);\n      }));\n      cluster.on('message', this.wrapEventHandler(function (worker, msg) {\n        return _this.onWorkerMessage(worker.id, msg);\n      }));\n      cluster.on('exit', this.wrapEventHandler(function (worker, code, signal) {\n        return _this.onWorkerExit(worker, code, signal);\n      })); // Since we have pending tasks at the very minimum we need a single worker.\n\n      cluster.fork();\n      return this.finishedDeferred.promise.then(function () {\n        return _this.stopWorkers();\n      }, function (err) {\n        _this.stopWorkers();\n\n        return Promise.reject(err);\n      });\n    };\n    /** Try to find available (idle) workers and assign them available (non-blocked) tasks. */\n\n\n    ClusterMaster.prototype.maybeDistributeWork = function () {\n      var e_1, _a;\n\n      var isWorkerAvailable = false; // First, check whether all tasks have been completed.\n\n      if (this.taskQueue.allTasksCompleted) {\n        var duration = Math.round((Date.now() - this.processingStartTime) / 100) / 10;\n        this.logger.debug(\"Processed tasks in \" + duration + \"s.\");\n        return this.finishedDeferred.resolve();\n      }\n\n      try {\n        // Look for available workers and available tasks to assign to them.\n        for (var _b = tslib_1.__values(Array.from(this.taskAssignments)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = tslib_1.__read(_c.value, 2),\n              workerId = _d[0],\n              assignedTask = _d[1];\n\n          if (assignedTask !== null) {\n            // This worker already has a job; check other workers.\n            continue;\n          } else {\n            // This worker is available.\n            isWorkerAvailable = true;\n          } // This worker needs a job. See if any are available.\n\n\n          var task = this.taskQueue.getNextTask();\n\n          if (task === null) {\n            // No suitable work available right now.\n            break;\n          } // Process the next task on the worker.\n\n\n          this.taskAssignments.set(workerId, {\n            task: task\n          });\n          utils_2.sendMessageToWorker(workerId, {\n            type: 'process-task',\n            task: task\n          });\n          isWorkerAvailable = false;\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      if (!isWorkerAvailable) {\n        var spawnedWorkerCount = Object.keys(cluster.workers).length;\n\n        if (spawnedWorkerCount < this.maxWorkerCount) {\n          this.logger.debug('Spawning another worker process as there is more work to be done.');\n          cluster.fork();\n        } else {\n          // If there are no available workers or no available tasks, log (for debugging purposes).\n          this.logger.debug(\"All \" + spawnedWorkerCount + \" workers are currently busy and cannot take on more work.\");\n        }\n      } else {\n        var busyWorkers = Array.from(this.taskAssignments).filter(function (_a) {\n          var _b = tslib_1.__read(_a, 2),\n              _workerId = _b[0],\n              task = _b[1];\n\n          return task !== null;\n        }).map(function (_a) {\n          var _b = tslib_1.__read(_a, 1),\n              workerId = _b[0];\n\n          return workerId;\n        });\n        var totalWorkerCount = this.taskAssignments.size;\n        var idleWorkerCount = totalWorkerCount - busyWorkers.length;\n        this.logger.debug(\"No assignments for \" + idleWorkerCount + \" idle (out of \" + totalWorkerCount + \" total) \" + (\"workers. Busy workers: \" + busyWorkers.join(', ')));\n\n        if (busyWorkers.length === 0) {\n          // This is a bug:\n          // All workers are idle (meaning no tasks are in progress) and `taskQueue.allTasksCompleted`\n          // is `false`, but there is still no assignable work.\n          throw new Error('There are still unprocessed tasks in the queue and no tasks are currently in ' + (\"progress, yet the queue did not return any available tasks: \" + this.taskQueue));\n        }\n      }\n    };\n    /** Handle a worker's exiting. (Might be intentional or not.) */\n\n\n    ClusterMaster.prototype.onWorkerExit = function (worker, code, signal) {\n      // If the worker's exiting was intentional, nothing to do.\n      if (worker.exitedAfterDisconnect) return; // The worker exited unexpectedly: Determine it's status and take an appropriate action.\n\n      var assignment = this.taskAssignments.get(worker.id);\n      this.taskAssignments.delete(worker.id);\n      this.logger.warn(\"Worker #\" + worker.id + \" exited unexpectedly (code: \" + code + \" | signal: \" + signal + \").\\n\" + (\"  Current task: \" + (assignment == null ? '-' : utils_1.stringifyTask(assignment.task)) + \"\\n\") + (\"  Current phase: \" + (assignment == null ? '-' : assignment.files == null ? 'compiling' : 'writing files')));\n\n      if (assignment == null) {\n        // The crashed worker process was not in the middle of a task:\n        // Just spawn another process.\n        this.logger.debug(\"Spawning another worker process to replace #\" + worker.id + \"...\");\n        cluster.fork();\n      } else {\n        var task = assignment.task,\n            files = assignment.files;\n\n        if (files != null) {\n          // The crashed worker process was in the middle of writing transformed files:\n          // Revert any changes before re-processing the task.\n          this.logger.debug(\"Reverting \" + files.length + \" transformed files...\");\n          this.fileWriter.revertBundle(task.entryPoint, files, task.formatPropertiesToMarkAsProcessed);\n        } // The crashed worker process was in the middle of a task:\n        // Re-add the task back to the queue.\n\n\n        this.taskQueue.markAsUnprocessed(task); // The crashing might be a result of increased memory consumption by ngcc.\n        // Do not spawn another process, unless this was the last worker process.\n\n        var spawnedWorkerCount = Object.keys(cluster.workers).length;\n\n        if (spawnedWorkerCount > 0) {\n          this.logger.debug(\"Not spawning another worker process to replace #\" + worker.id + \". Continuing with \" + spawnedWorkerCount + \" workers...\");\n          this.maybeDistributeWork();\n        } else if (this.remainingRespawnAttempts > 0) {\n          this.logger.debug(\"Spawning another worker process to replace #\" + worker.id + \"...\");\n          this.remainingRespawnAttempts--;\n          cluster.fork();\n        } else {\n          throw new Error('All worker processes crashed and attempts to re-spawn them failed. ' + 'Please check your system and ensure there is enough memory available.');\n        }\n      }\n    };\n    /** Handle a message from a worker. */\n\n\n    ClusterMaster.prototype.onWorkerMessage = function (workerId, msg) {\n      if (!this.taskAssignments.has(workerId)) {\n        var knownWorkers = Array.from(this.taskAssignments.keys());\n        throw new Error(\"Received message from unknown worker #\" + workerId + \" (known workers: \" + (knownWorkers.join(', ') + \"): \" + JSON.stringify(msg)));\n      }\n\n      switch (msg.type) {\n        case 'error':\n          throw new Error(\"Error on worker #\" + workerId + \": \" + msg.error);\n\n        case 'task-completed':\n          return this.onWorkerTaskCompleted(workerId, msg);\n\n        case 'transformed-files':\n          return this.onWorkerTransformedFiles(workerId, msg);\n\n        case 'update-package-json':\n          return this.onWorkerUpdatePackageJson(workerId, msg);\n\n        default:\n          throw new Error(\"Invalid message received from worker #\" + workerId + \": \" + JSON.stringify(msg));\n      }\n    };\n    /** Handle a worker's coming online. */\n\n\n    ClusterMaster.prototype.onWorkerOnline = function (workerId) {\n      if (this.taskAssignments.has(workerId)) {\n        throw new Error(\"Invariant violated: Worker #\" + workerId + \" came online more than once.\");\n      }\n\n      if (this.processingStartTime === -1) {\n        this.logger.debug('Processing tasks...');\n        this.processingStartTime = Date.now();\n      }\n\n      this.taskAssignments.set(workerId, null);\n      this.maybeDistributeWork();\n    };\n    /** Handle a worker's having completed their assigned task. */\n\n\n    ClusterMaster.prototype.onWorkerTaskCompleted = function (workerId, msg) {\n      var assignment = this.taskAssignments.get(workerId) || null;\n\n      if (assignment === null) {\n        throw new Error(\"Expected worker #\" + workerId + \" to have a task assigned, while handling message: \" + JSON.stringify(msg));\n      }\n\n      this.onTaskCompleted(assignment.task, msg.outcome, msg.message);\n      this.taskQueue.markAsCompleted(assignment.task);\n      this.taskAssignments.set(workerId, null);\n      this.maybeDistributeWork();\n    };\n    /** Handle a worker's message regarding the files transformed while processing its task. */\n\n\n    ClusterMaster.prototype.onWorkerTransformedFiles = function (workerId, msg) {\n      var assignment = this.taskAssignments.get(workerId) || null;\n\n      if (assignment === null) {\n        throw new Error(\"Expected worker #\" + workerId + \" to have a task assigned, while handling message: \" + JSON.stringify(msg));\n      }\n\n      var oldFiles = assignment.files;\n      var newFiles = msg.files;\n\n      if (oldFiles !== undefined) {\n        throw new Error(\"Worker #\" + workerId + \" reported transformed files more than once.\\n\" + (\"  Old files (\" + oldFiles.length + \"): [\" + oldFiles.join(', ') + \"]\\n\") + (\"  New files (\" + newFiles.length + \"): [\" + newFiles.join(', ') + \"]\\n\"));\n      }\n\n      assignment.files = newFiles;\n    };\n    /** Handle a worker's request to update a `package.json` file. */\n\n\n    ClusterMaster.prototype.onWorkerUpdatePackageJson = function (workerId, msg) {\n      var assignment = this.taskAssignments.get(workerId) || null;\n\n      if (assignment === null) {\n        throw new Error(\"Expected worker #\" + workerId + \" to have a task assigned, while handling message: \" + JSON.stringify(msg));\n      }\n\n      var entryPoint = assignment.task.entryPoint;\n      var expectedPackageJsonPath = this.fileSystem.resolve(entryPoint.path, 'package.json');\n\n      if (expectedPackageJsonPath !== msg.packageJsonPath) {\n        throw new Error(\"Received '\" + msg.type + \"' message from worker #\" + workerId + \" for '\" + msg.packageJsonPath + \"', \" + (\"but was expecting '\" + expectedPackageJsonPath + \"' (based on task assignment).\"));\n      } // NOTE: Although the change in the parsed `package.json` will be reflected in tasks objects\n      //       locally and thus also in future `process-task` messages sent to worker processes, any\n      //       processes already running and processing a task for the same entry-point will not get\n      //       the change.\n      //       Do not rely on having an up-to-date `package.json` representation in worker processes.\n      //       In other words, task processing should only rely on the info that was there when the\n      //       file was initially parsed (during entry-point analysis) and not on the info that might\n      //       be added later (during task processing).\n\n\n      this.pkgJsonUpdater.writeChanges(msg.changes, msg.packageJsonPath, entryPoint.packageJson);\n    };\n    /** Stop all workers and stop listening on cluster events. */\n\n\n    ClusterMaster.prototype.stopWorkers = function () {\n      var workers = Object.values(cluster.workers);\n      this.logger.debug(\"Stopping \" + workers.length + \" workers...\");\n      cluster.removeAllListeners();\n      workers.forEach(function (worker) {\n        return worker.kill();\n      });\n    };\n    /**\n     * Wrap an event handler to ensure that `finishedDeferred` will be rejected on error (regardless\n     * if the handler completes synchronously or asynchronously).\n     */\n\n\n    ClusterMaster.prototype.wrapEventHandler = function (fn) {\n      var _this = this;\n\n      return function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return tslib_1.__awaiter(_this, void 0, void 0, function () {\n          var err_1;\n          return tslib_1.__generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n\n                return [4\n                /*yield*/\n                , fn.apply(void 0, tslib_1.__spread(args))];\n\n              case 1:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 3];\n\n              case 2:\n                err_1 = _a.sent();\n                this.finishedDeferred.reject(err_1);\n                return [3\n                /*break*/\n                , 3];\n\n              case 3:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      };\n    };\n\n    return ClusterMaster;\n  }();\n\n  exports.ClusterMaster = ClusterMaster;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/ngcc/src/execution/cluster/master.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"node\" />\n\nimport * as cluster from 'cluster';\n\nimport {AbsoluteFsPath, PathManipulation} from '../../../../src/ngtsc/file_system';\nimport {Logger} from '../../../../src/ngtsc/logging';\nimport {FileWriter} from '../../writing/file_writer';\nimport {PackageJsonUpdater} from '../../writing/package_json_updater';\nimport {AnalyzeEntryPointsFn} from '../api';\nimport {CreateTaskCompletedCallback, Task, TaskCompletedCallback, TaskQueue} from '../tasks/api';\nimport {stringifyTask} from '../tasks/utils';\n\nimport {MessageFromWorker, TaskCompletedMessage, TransformedFilesMessage, UpdatePackageJsonMessage} from './api';\nimport {Deferred, sendMessageToWorker} from './utils';\n\n\n/**\n * The cluster master is responsible for analyzing all entry-points, planning the work that needs to\n * be done, distributing it to worker-processes and collecting/post-processing the results.\n */\nexport class ClusterMaster {\n  private finishedDeferred = new Deferred<void>();\n  private processingStartTime: number = -1;\n  private taskAssignments = new Map<number, {task: Task, files?: AbsoluteFsPath[]}|null>();\n  private taskQueue: TaskQueue;\n  private onTaskCompleted: TaskCompletedCallback;\n  private remainingRespawnAttempts = 3;\n\n  constructor(\n      private maxWorkerCount: number, private fileSystem: PathManipulation, private logger: Logger,\n      private fileWriter: FileWriter, private pkgJsonUpdater: PackageJsonUpdater,\n      analyzeEntryPoints: AnalyzeEntryPointsFn,\n      createTaskCompletedCallback: CreateTaskCompletedCallback) {\n    if (!cluster.isMaster) {\n      throw new Error('Tried to instantiate `ClusterMaster` on a worker process.');\n    }\n\n    // Set the worker entry-point\n    cluster.setupMaster({exec: this.fileSystem.resolve(__dirname, 'worker.js')});\n\n    this.taskQueue = analyzeEntryPoints();\n    this.onTaskCompleted = createTaskCompletedCallback(this.taskQueue);\n  }\n\n  run(): Promise<void> {\n    if (this.taskQueue.allTasksCompleted) {\n      return Promise.resolve();\n    }\n\n    // Set up listeners for worker events (emitted on `cluster`).\n    cluster.on('online', this.wrapEventHandler(worker => this.onWorkerOnline(worker.id)));\n\n    cluster.on(\n        'message', this.wrapEventHandler((worker, msg) => this.onWorkerMessage(worker.id, msg)));\n\n    cluster.on(\n        'exit',\n        this.wrapEventHandler((worker, code, signal) => this.onWorkerExit(worker, code, signal)));\n\n    // Since we have pending tasks at the very minimum we need a single worker.\n    cluster.fork();\n\n    return this.finishedDeferred.promise.then(() => this.stopWorkers(), err => {\n      this.stopWorkers();\n      return Promise.reject(err);\n    });\n  }\n\n  /** Try to find available (idle) workers and assign them available (non-blocked) tasks. */\n  private maybeDistributeWork(): void {\n    let isWorkerAvailable = false;\n\n    // First, check whether all tasks have been completed.\n    if (this.taskQueue.allTasksCompleted) {\n      const duration = Math.round((Date.now() - this.processingStartTime) / 100) / 10;\n      this.logger.debug(`Processed tasks in ${duration}s.`);\n\n      return this.finishedDeferred.resolve();\n    }\n\n    // Look for available workers and available tasks to assign to them.\n    for (const [workerId, assignedTask] of Array.from(this.taskAssignments)) {\n      if (assignedTask !== null) {\n        // This worker already has a job; check other workers.\n        continue;\n      } else {\n        // This worker is available.\n        isWorkerAvailable = true;\n      }\n\n      // This worker needs a job. See if any are available.\n      const task = this.taskQueue.getNextTask();\n      if (task === null) {\n        // No suitable work available right now.\n        break;\n      }\n\n      // Process the next task on the worker.\n      this.taskAssignments.set(workerId, {task});\n      sendMessageToWorker(workerId, {type: 'process-task', task});\n\n      isWorkerAvailable = false;\n    }\n\n    if (!isWorkerAvailable) {\n      const spawnedWorkerCount = Object.keys(cluster.workers).length;\n      if (spawnedWorkerCount < this.maxWorkerCount) {\n        this.logger.debug('Spawning another worker process as there is more work to be done.');\n        cluster.fork();\n      } else {\n        // If there are no available workers or no available tasks, log (for debugging purposes).\n        this.logger.debug(\n            `All ${spawnedWorkerCount} workers are currently busy and cannot take on more work.`);\n      }\n    } else {\n      const busyWorkers = Array.from(this.taskAssignments)\n                              .filter(([_workerId, task]) => task !== null)\n                              .map(([workerId]) => workerId);\n      const totalWorkerCount = this.taskAssignments.size;\n      const idleWorkerCount = totalWorkerCount - busyWorkers.length;\n\n      this.logger.debug(\n          `No assignments for ${idleWorkerCount} idle (out of ${totalWorkerCount} total) ` +\n          `workers. Busy workers: ${busyWorkers.join(', ')}`);\n\n      if (busyWorkers.length === 0) {\n        // This is a bug:\n        // All workers are idle (meaning no tasks are in progress) and `taskQueue.allTasksCompleted`\n        // is `false`, but there is still no assignable work.\n        throw new Error(\n            'There are still unprocessed tasks in the queue and no tasks are currently in ' +\n            `progress, yet the queue did not return any available tasks: ${this.taskQueue}`);\n      }\n    }\n  }\n\n  /** Handle a worker's exiting. (Might be intentional or not.) */\n  private onWorkerExit(worker: cluster.Worker, code: number|null, signal: string|null): void {\n    // If the worker's exiting was intentional, nothing to do.\n    if (worker.exitedAfterDisconnect) return;\n\n    // The worker exited unexpectedly: Determine it's status and take an appropriate action.\n    const assignment = this.taskAssignments.get(worker.id);\n    this.taskAssignments.delete(worker.id);\n\n    this.logger.warn(\n        `Worker #${worker.id} exited unexpectedly (code: ${code} | signal: ${signal}).\\n` +\n        `  Current task: ${(assignment == null) ? '-' : stringifyTask(assignment.task)}\\n` +\n        `  Current phase: ${\n            (assignment == null) ? '-' :\n                                   (assignment.files == null) ? 'compiling' : 'writing files'}`);\n\n    if (assignment == null) {\n      // The crashed worker process was not in the middle of a task:\n      // Just spawn another process.\n      this.logger.debug(`Spawning another worker process to replace #${worker.id}...`);\n      cluster.fork();\n    } else {\n      const {task, files} = assignment;\n\n      if (files != null) {\n        // The crashed worker process was in the middle of writing transformed files:\n        // Revert any changes before re-processing the task.\n        this.logger.debug(`Reverting ${files.length} transformed files...`);\n        this.fileWriter.revertBundle(\n            task.entryPoint, files, task.formatPropertiesToMarkAsProcessed);\n      }\n\n      // The crashed worker process was in the middle of a task:\n      // Re-add the task back to the queue.\n      this.taskQueue.markAsUnprocessed(task);\n\n      // The crashing might be a result of increased memory consumption by ngcc.\n      // Do not spawn another process, unless this was the last worker process.\n      const spawnedWorkerCount = Object.keys(cluster.workers).length;\n      if (spawnedWorkerCount > 0) {\n        this.logger.debug(`Not spawning another worker process to replace #${\n            worker.id}. Continuing with ${spawnedWorkerCount} workers...`);\n        this.maybeDistributeWork();\n      } else if (this.remainingRespawnAttempts > 0) {\n        this.logger.debug(`Spawning another worker process to replace #${worker.id}...`);\n        this.remainingRespawnAttempts--;\n        cluster.fork();\n      } else {\n        throw new Error(\n            'All worker processes crashed and attempts to re-spawn them failed. ' +\n            'Please check your system and ensure there is enough memory available.');\n      }\n    }\n  }\n\n  /** Handle a message from a worker. */\n  private onWorkerMessage(workerId: number, msg: MessageFromWorker): void {\n    if (!this.taskAssignments.has(workerId)) {\n      const knownWorkers = Array.from(this.taskAssignments.keys());\n      throw new Error(\n          `Received message from unknown worker #${workerId} (known workers: ` +\n          `${knownWorkers.join(', ')}): ${JSON.stringify(msg)}`);\n    }\n\n    switch (msg.type) {\n      case 'error':\n        throw new Error(`Error on worker #${workerId}: ${msg.error}`);\n      case 'task-completed':\n        return this.onWorkerTaskCompleted(workerId, msg);\n      case 'transformed-files':\n        return this.onWorkerTransformedFiles(workerId, msg);\n      case 'update-package-json':\n        return this.onWorkerUpdatePackageJson(workerId, msg);\n      default:\n        throw new Error(\n            `Invalid message received from worker #${workerId}: ${JSON.stringify(msg)}`);\n    }\n  }\n\n  /** Handle a worker's coming online. */\n  private onWorkerOnline(workerId: number): void {\n    if (this.taskAssignments.has(workerId)) {\n      throw new Error(`Invariant violated: Worker #${workerId} came online more than once.`);\n    }\n\n    if (this.processingStartTime === -1) {\n      this.logger.debug('Processing tasks...');\n      this.processingStartTime = Date.now();\n    }\n\n    this.taskAssignments.set(workerId, null);\n    this.maybeDistributeWork();\n  }\n\n  /** Handle a worker's having completed their assigned task. */\n  private onWorkerTaskCompleted(workerId: number, msg: TaskCompletedMessage): void {\n    const assignment = this.taskAssignments.get(workerId) || null;\n\n    if (assignment === null) {\n      throw new Error(\n          `Expected worker #${workerId} to have a task assigned, while handling message: ` +\n          JSON.stringify(msg));\n    }\n\n    this.onTaskCompleted(assignment.task, msg.outcome, msg.message);\n\n    this.taskQueue.markAsCompleted(assignment.task);\n    this.taskAssignments.set(workerId, null);\n    this.maybeDistributeWork();\n  }\n\n  /** Handle a worker's message regarding the files transformed while processing its task. */\n  private onWorkerTransformedFiles(workerId: number, msg: TransformedFilesMessage): void {\n    const assignment = this.taskAssignments.get(workerId) || null;\n\n    if (assignment === null) {\n      throw new Error(\n          `Expected worker #${workerId} to have a task assigned, while handling message: ` +\n          JSON.stringify(msg));\n    }\n\n    const oldFiles = assignment.files;\n    const newFiles = msg.files;\n\n    if (oldFiles !== undefined) {\n      throw new Error(\n          `Worker #${workerId} reported transformed files more than once.\\n` +\n          `  Old files (${oldFiles.length}): [${oldFiles.join(', ')}]\\n` +\n          `  New files (${newFiles.length}): [${newFiles.join(', ')}]\\n`);\n    }\n\n    assignment.files = newFiles;\n  }\n\n  /** Handle a worker's request to update a `package.json` file. */\n  private onWorkerUpdatePackageJson(workerId: number, msg: UpdatePackageJsonMessage): void {\n    const assignment = this.taskAssignments.get(workerId) || null;\n\n    if (assignment === null) {\n      throw new Error(\n          `Expected worker #${workerId} to have a task assigned, while handling message: ` +\n          JSON.stringify(msg));\n    }\n\n    const entryPoint = assignment.task.entryPoint;\n    const expectedPackageJsonPath = this.fileSystem.resolve(entryPoint.path, 'package.json');\n\n    if (expectedPackageJsonPath !== msg.packageJsonPath) {\n      throw new Error(\n          `Received '${msg.type}' message from worker #${workerId} for '${msg.packageJsonPath}', ` +\n          `but was expecting '${expectedPackageJsonPath}' (based on task assignment).`);\n    }\n\n    // NOTE: Although the change in the parsed `package.json` will be reflected in tasks objects\n    //       locally and thus also in future `process-task` messages sent to worker processes, any\n    //       processes already running and processing a task for the same entry-point will not get\n    //       the change.\n    //       Do not rely on having an up-to-date `package.json` representation in worker processes.\n    //       In other words, task processing should only rely on the info that was there when the\n    //       file was initially parsed (during entry-point analysis) and not on the info that might\n    //       be added later (during task processing).\n    this.pkgJsonUpdater.writeChanges(msg.changes, msg.packageJsonPath, entryPoint.packageJson);\n  }\n\n  /** Stop all workers and stop listening on cluster events. */\n  private stopWorkers(): void {\n    const workers = Object.values(cluster.workers) as cluster.Worker[];\n    this.logger.debug(`Stopping ${workers.length} workers...`);\n\n    cluster.removeAllListeners();\n    workers.forEach(worker => worker.kill());\n  }\n\n  /**\n   * Wrap an event handler to ensure that `finishedDeferred` will be rejected on error (regardless\n   * if the handler completes synchronously or asynchronously).\n   */\n  private wrapEventHandler<Args extends unknown[]>(fn: (...args: Args) => void|Promise<void>):\n      (...args: Args) => Promise<void> {\n    return async (...args: Args) => {\n      try {\n        await fn(...args);\n      } catch (err) {\n        this.finishedDeferred.reject(err);\n      }\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}