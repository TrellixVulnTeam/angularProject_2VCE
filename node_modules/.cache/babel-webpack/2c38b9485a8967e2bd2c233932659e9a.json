{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/metadata_cache\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/transformers/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.MetadataCache = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/transformers/util\");\n  /**\n   * Cache, and potentially transform, metadata as it is being collected.\n   */\n\n\n  var MetadataCache =\n  /** @class */\n  function () {\n    function MetadataCache(collector, strict, transformers) {\n      var e_1, _a;\n\n      this.collector = collector;\n      this.strict = strict;\n      this.transformers = transformers;\n      this.metadataCache = new Map();\n\n      try {\n        for (var transformers_1 = tslib_1.__values(transformers), transformers_1_1 = transformers_1.next(); !transformers_1_1.done; transformers_1_1 = transformers_1.next()) {\n          var transformer = transformers_1_1.value;\n\n          if (transformer.connect) {\n            transformer.connect(this);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (transformers_1_1 && !transformers_1_1.done && (_a = transformers_1.return)) _a.call(transformers_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    MetadataCache.prototype.getMetadata = function (sourceFile) {\n      var e_2, _a;\n\n      if (this.metadataCache.has(sourceFile.fileName)) {\n        return this.metadataCache.get(sourceFile.fileName);\n      }\n\n      var substitute = undefined; // Only process transformers on modules that are not declaration files.\n\n      var declarationFile = sourceFile.isDeclarationFile;\n      var moduleFile = ts.isExternalModule(sourceFile);\n\n      if (!declarationFile && moduleFile) {\n        var _loop_1 = function _loop_1(transform) {\n          var transformSubstitute = transform.start(sourceFile);\n\n          if (transformSubstitute) {\n            if (substitute) {\n              var previous_1 = substitute;\n\n              substitute = function substitute(value, node) {\n                return transformSubstitute(previous_1(value, node), node);\n              };\n            } else {\n              substitute = transformSubstitute;\n            }\n          }\n        };\n\n        try {\n          for (var _b = tslib_1.__values(this.transformers), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var transform = _c.value;\n\n            _loop_1(transform);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n\n      var isTsFile = util_1.TS.test(sourceFile.fileName);\n      var result = this.collector.getMetadata(sourceFile, this.strict && isTsFile, substitute);\n      this.metadataCache.set(sourceFile.fileName, result);\n      return result;\n    };\n\n    return MetadataCache;\n  }();\n\n  exports.MetadataCache = MetadataCache;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/metadata_cache.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAKA,MAAA,MAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;AASA;;AAEG;;;AACH,MAAA,aAAA;AAAA;AAAA,cAAA;AAGE,aAAA,aAAA,CACY,SADZ,EAC2D,MAD3D,EAEY,YAFZ,EAE+C;;;AADnC,WAAA,SAAA,GAAA,SAAA;AAA+C,WAAA,MAAA,GAAA,MAAA;AAC/C,WAAA,YAAA,GAAA,YAAA;AAJJ,WAAA,aAAA,GAAgB,IAAI,GAAJ,EAAhB;;;AAKN,aAAwB,IAAA,cAAA,GAAA,OAAA,CAAA,QAAA,CAAA,YAAA,CAAA,EAAY,gBAAA,GAAA,cAAA,CAAA,IAAA,EAApC,EAAoC,CAAA,gBAAA,CAAA,IAApC,EAAoC,gBAAA,GAAA,cAAA,CAAA,IAAA,EAApC,EAAsC;AAAjC,cAAI,WAAW,GAAA,gBAAA,CAAA,KAAf;;AACH,cAAI,WAAW,CAAC,OAAhB,EAAyB;AACvB,YAAA,WAAW,CAAC,OAAZ,CAAoB,IAApB;AACD;AACF;;;;;;;;;;;;AACF;;AAED,IAAA,aAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,UAAZ,EAAqC;;;AACnC,UAAI,KAAK,aAAL,CAAmB,GAAnB,CAAuB,UAAU,CAAC,QAAlC,CAAJ,EAAiD;AAC/C,eAAO,KAAK,aAAL,CAAmB,GAAnB,CAAuB,UAAU,CAAC,QAAlC,CAAP;AACD;;AACD,UAAI,UAAU,GAA6B,SAA3C,CAJmC,CAMnC;;AACA,UAAM,eAAe,GAAG,UAAU,CAAC,iBAAnC;AACA,UAAM,UAAU,GAAG,EAAE,CAAC,gBAAH,CAAoB,UAApB,CAAnB;;AACA,UAAI,CAAC,eAAD,IAAoB,UAAxB,EAAoC;uCACzB,S,EAAS;AAChB,cAAM,mBAAmB,GAAG,SAAS,CAAC,KAAV,CAAgB,UAAhB,CAA5B;;AACA,cAAI,mBAAJ,EAAyB;AACvB,gBAAI,UAAJ,EAAgB;AACd,kBAAM,UAAQ,GAAmB,UAAjC;;AACA,cAAA,UAAU,GAAG,oBAAC,KAAD,EAAuB,IAAvB,EAAoC;AAC7C,uBAAA,mBAAmB,CAAC,UAAQ,CAAC,KAAD,EAAQ,IAAR,CAAT,EAAwB,IAAxB,CAAnB;AAAgD,eADpD;AAED,aAJD,MAIO;AACL,cAAA,UAAU,GAAG,mBAAb;AACD;AACF;;;;AAVH,eAAsB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,YAAL,CAAA,EAAiB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAuC,CAAA,EAAA,CAAA,IAAvC,EAAuC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAuC;AAAlC,gBAAI,SAAS,GAAA,EAAA,CAAA,KAAb;;oBAAI,S;AAWR;;;;;;;;;;;;AACF;;AAED,UAAM,QAAQ,GAAG,MAAA,CAAA,EAAA,CAAG,IAAH,CAAQ,UAAU,CAAC,QAAnB,CAAjB;AACA,UAAM,MAAM,GAAG,KAAK,SAAL,CAAe,WAAf,CAA2B,UAA3B,EAAuC,KAAK,MAAL,IAAe,QAAtD,EAAgE,UAAhE,CAAf;AACA,WAAK,aAAL,CAAmB,GAAnB,CAAuB,UAAU,CAAC,QAAlC,EAA4C,MAA5C;AACA,aAAO,MAAP;AACD,KA5BD;;AA6BF,WAAA,aAAA;AAAC,GA1CD,EAAA;;AAAa,EAAA,OAAA,CAAA,aAAA,GAAA,aAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n\nimport {MetadataProvider} from './compiler_host';\nimport {TS} from './util';\n\nexport type ValueTransform = (value: MetadataValue, node: ts.Node) => MetadataValue;\n\nexport interface MetadataTransformer {\n  connect?(cache: MetadataCache): void;\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined;\n}\n\n/**\n * Cache, and potentially transform, metadata as it is being collected.\n */\nexport class MetadataCache implements MetadataProvider {\n  private metadataCache = new Map<string, ModuleMetadata|undefined>();\n\n  constructor(\n      private collector: MetadataCollector, private readonly strict: boolean,\n      private transformers: MetadataTransformer[]) {\n    for (let transformer of transformers) {\n      if (transformer.connect) {\n        transformer.connect(this);\n      }\n    }\n  }\n\n  getMetadata(sourceFile: ts.SourceFile): ModuleMetadata|undefined {\n    if (this.metadataCache.has(sourceFile.fileName)) {\n      return this.metadataCache.get(sourceFile.fileName);\n    }\n    let substitute: ValueTransform|undefined = undefined;\n\n    // Only process transformers on modules that are not declaration files.\n    const declarationFile = sourceFile.isDeclarationFile;\n    const moduleFile = ts.isExternalModule(sourceFile);\n    if (!declarationFile && moduleFile) {\n      for (let transform of this.transformers) {\n        const transformSubstitute = transform.start(sourceFile);\n        if (transformSubstitute) {\n          if (substitute) {\n            const previous: ValueTransform = substitute;\n            substitute = (value: MetadataValue, node: ts.Node) =>\n                transformSubstitute(previous(value, node), node);\n          } else {\n            substitute = transformSubstitute;\n          }\n        }\n      }\n    }\n\n    const isTsFile = TS.test(sourceFile.fileName);\n    const result = this.collector.getMetadata(sourceFile, this.strict && isTsFile, substitute);\n    this.metadataCache.set(sourceFile.fileName, result);\n    return result;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}