{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/configuration\", [\"require\", \"exports\", \"tslib\", \"crypto\", \"semver\", \"vm\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NgccConfiguration = exports.ProcessedNgccPackageConfig = exports.DEFAULT_NGCC_CONFIG = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var crypto_1 = require(\"crypto\");\n\n  var semver_1 = require(\"semver\");\n\n  var vm = require(\"vm\");\n  /**\n   * The default configuration for ngcc.\n   *\n   * This is the ultimate fallback configuration that ngcc will use if there is no configuration\n   * for a package at the package level or project level.\n   *\n   * This configuration is for packages that are \"dead\" - i.e. no longer maintained and so are\n   * unlikely to be fixed to work with ngcc, nor provide a package level config of their own.\n   *\n   * The fallback process for looking up configuration is:\n   *\n   * Project -> Package -> Default\n   *\n   * If a package provides its own configuration then that would override this default one.\n   *\n   * Also application developers can always provide configuration at their project level which\n   * will override everything else.\n   *\n   * Note that the fallback is package based not entry-point based.\n   * For example, if a there is configuration for a package at the project level this will replace all\n   * entry-point configurations that may have been provided in the package level or default level\n   * configurations, even if the project level configuration does not provide for a given entry-point.\n   */\n\n\n  exports.DEFAULT_NGCC_CONFIG = {\n    packages: {\n      // Add default package configuration here. For example:\n      // '@angular/fire@^5.2.0': {\n      //   entryPoints: {\n      //     './database-deprecated': {ignore: true},\n      //   },\n      // },\n      // The package does not contain any `.metadata.json` files in the root directory but only inside\n      // `dist/`. Without this config, ngcc does not realize this is a ViewEngine-built Angular\n      // package that needs to be compiled to Ivy.\n      'angular2-highcharts': {\n        entryPoints: {\n          '.': {\n            override: {\n              main: './index.js'\n            }\n          }\n        }\n      },\n      // The `dist/` directory has a duplicate `package.json` pointing to the same files, which (under\n      // certain configurations) can causes ngcc to try to process the files twice and fail.\n      // Ignore the `dist/` entry-point.\n      'ng2-dragula': {\n        entryPoints: {\n          './dist': {\n            ignore: true\n          }\n        }\n      }\n    },\n    locking: {\n      retryDelay: 500,\n      retryAttempts: 500\n    }\n  };\n  var NGCC_CONFIG_FILENAME = 'ngcc.config.js';\n  /**\n   * The processed package level configuration as a result of processing a raw package level config.\n   */\n\n  var ProcessedNgccPackageConfig =\n  /** @class */\n  function () {\n    function ProcessedNgccPackageConfig(fs, packagePath, _a) {\n      var _b = _a.entryPoints,\n          entryPoints = _b === void 0 ? {} : _b,\n          _c = _a.ignorableDeepImportMatchers,\n          ignorableDeepImportMatchers = _c === void 0 ? [] : _c;\n      var absolutePathEntries = Object.entries(entryPoints).map(function (_a) {\n        var _b = tslib_1.__read(_a, 2),\n            relativePath = _b[0],\n            config = _b[1];\n\n        return [fs.resolve(packagePath, relativePath), config];\n      });\n      this.packagePath = packagePath;\n      this.entryPoints = new Map(absolutePathEntries);\n      this.ignorableDeepImportMatchers = ignorableDeepImportMatchers;\n    }\n\n    return ProcessedNgccPackageConfig;\n  }();\n\n  exports.ProcessedNgccPackageConfig = ProcessedNgccPackageConfig;\n  /**\n   * Ngcc has a hierarchical configuration system that lets us \"fix up\" packages that do not\n   * work with ngcc out of the box.\n   *\n   * There are three levels at which configuration can be declared:\n   *\n   * * Default level - ngcc comes with built-in configuration for well known cases.\n   * * Package level - a library author publishes a configuration with their package to fix known\n   *   issues.\n   * * Project level - the application developer provides a configuration that fixes issues specific\n   *   to the libraries used in their application.\n   *\n   * Ngcc will match configuration based on the package name but also on its version. This allows\n   * configuration to provide different fixes to different version ranges of a package.\n   *\n   * * Package level configuration is specific to the package version where the configuration is\n   *   found.\n   * * Default and project level configuration should provide version ranges to ensure that the\n   *   configuration is only applied to the appropriate versions of a package.\n   *\n   * When getting a configuration for a package (via `getConfig()`) the caller should provide the\n   * version of the package in question, if available. If it is not provided then the first available\n   * configuration for a package is returned.\n   */\n\n  var NgccConfiguration =\n  /** @class */\n  function () {\n    function NgccConfiguration(fs, baseDir) {\n      this.fs = fs;\n      this.cache = new Map();\n      this.defaultConfig = this.processProjectConfig(exports.DEFAULT_NGCC_CONFIG);\n      this.projectConfig = this.processProjectConfig(this.loadProjectConfig(baseDir));\n      this.hash = this.computeHash();\n    }\n    /**\n     * Get the configuration options for locking the ngcc process.\n     */\n\n\n    NgccConfiguration.prototype.getLockingConfig = function () {\n      var _a = this.projectConfig.locking,\n          retryAttempts = _a.retryAttempts,\n          retryDelay = _a.retryDelay;\n\n      if (retryAttempts === undefined) {\n        retryAttempts = this.defaultConfig.locking.retryAttempts;\n      }\n\n      if (retryDelay === undefined) {\n        retryDelay = this.defaultConfig.locking.retryDelay;\n      }\n\n      return {\n        retryAttempts: retryAttempts,\n        retryDelay: retryDelay\n      };\n    };\n    /**\n     * Get a configuration for the given `version` of a package at `packagePath`.\n     *\n     * @param packageName The name of the package whose config we want.\n     * @param packagePath The path to the package whose config we want.\n     * @param version The version of the package whose config we want, or `null` if the package's\n     * package.json did not exist or was invalid.\n     */\n\n\n    NgccConfiguration.prototype.getPackageConfig = function (packageName, packagePath, version) {\n      var rawPackageConfig = this.getRawPackageConfig(packageName, packagePath, version);\n      return new ProcessedNgccPackageConfig(this.fs, packagePath, rawPackageConfig);\n    };\n\n    NgccConfiguration.prototype.getRawPackageConfig = function (packageName, packagePath, version) {\n      var cacheKey = packageName + (version !== null ? \"@\" + version : '');\n\n      if (this.cache.has(cacheKey)) {\n        return this.cache.get(cacheKey);\n      }\n\n      var projectLevelConfig = this.projectConfig.packages ? findSatisfactoryVersion(this.projectConfig.packages[packageName], version) : null;\n\n      if (projectLevelConfig !== null) {\n        this.cache.set(cacheKey, projectLevelConfig);\n        return projectLevelConfig;\n      }\n\n      var packageLevelConfig = this.loadPackageConfig(packagePath, version);\n\n      if (packageLevelConfig !== null) {\n        this.cache.set(cacheKey, packageLevelConfig);\n        return packageLevelConfig;\n      }\n\n      var defaultLevelConfig = this.defaultConfig.packages ? findSatisfactoryVersion(this.defaultConfig.packages[packageName], version) : null;\n\n      if (defaultLevelConfig !== null) {\n        this.cache.set(cacheKey, defaultLevelConfig);\n        return defaultLevelConfig;\n      }\n\n      return {\n        versionRange: '*'\n      };\n    };\n\n    NgccConfiguration.prototype.processProjectConfig = function (projectConfig) {\n      var processedConfig = {\n        packages: {},\n        locking: {}\n      }; // locking configuration\n\n      if (projectConfig.locking !== undefined) {\n        processedConfig.locking = projectConfig.locking;\n      } // packages configuration\n\n\n      for (var packageNameAndVersion in projectConfig.packages) {\n        var packageConfig = projectConfig.packages[packageNameAndVersion];\n\n        if (packageConfig) {\n          var _a = tslib_1.__read(this.splitNameAndVersion(packageNameAndVersion), 2),\n              packageName = _a[0],\n              _b = _a[1],\n              versionRange = _b === void 0 ? '*' : _b;\n\n          var packageConfigs = processedConfig.packages[packageName] || (processedConfig.packages[packageName] = []);\n          packageConfigs.push(tslib_1.__assign(tslib_1.__assign({}, packageConfig), {\n            versionRange: versionRange\n          }));\n        }\n      }\n\n      return processedConfig;\n    };\n\n    NgccConfiguration.prototype.loadProjectConfig = function (baseDir) {\n      var configFilePath = this.fs.join(baseDir, NGCC_CONFIG_FILENAME);\n\n      if (this.fs.exists(configFilePath)) {\n        try {\n          return this.evalSrcFile(configFilePath);\n        } catch (e) {\n          throw new Error(\"Invalid project configuration file at \\\"\" + configFilePath + \"\\\": \" + e.message);\n        }\n      } else {\n        return {\n          packages: {}\n        };\n      }\n    };\n\n    NgccConfiguration.prototype.loadPackageConfig = function (packagePath, version) {\n      var configFilePath = this.fs.join(packagePath, NGCC_CONFIG_FILENAME);\n\n      if (this.fs.exists(configFilePath)) {\n        try {\n          var packageConfig = this.evalSrcFile(configFilePath);\n          return tslib_1.__assign(tslib_1.__assign({}, packageConfig), {\n            versionRange: version || '*'\n          });\n        } catch (e) {\n          throw new Error(\"Invalid package configuration file at \\\"\" + configFilePath + \"\\\": \" + e.message);\n        }\n      } else {\n        return null;\n      }\n    };\n\n    NgccConfiguration.prototype.evalSrcFile = function (srcPath) {\n      var src = this.fs.readFile(srcPath);\n      var theExports = {};\n      var sandbox = {\n        module: {\n          exports: theExports\n        },\n        exports: theExports,\n        require: require,\n        __dirname: this.fs.dirname(srcPath),\n        __filename: srcPath\n      };\n      vm.runInNewContext(src, sandbox, {\n        filename: srcPath\n      });\n      return sandbox.module.exports;\n    };\n\n    NgccConfiguration.prototype.splitNameAndVersion = function (packageNameAndVersion) {\n      var versionIndex = packageNameAndVersion.lastIndexOf('@'); // Note that > 0 is because we don't want to match @ at the start of the line\n      // which is what you would have with a namespaced package, e.g. `@angular/common`.\n\n      return versionIndex > 0 ? [packageNameAndVersion.substring(0, versionIndex), packageNameAndVersion.substring(versionIndex + 1)] : [packageNameAndVersion, undefined];\n    };\n\n    NgccConfiguration.prototype.computeHash = function () {\n      return crypto_1.createHash('md5').update(JSON.stringify(this.projectConfig)).digest('hex');\n    };\n\n    return NgccConfiguration;\n  }();\n\n  exports.NgccConfiguration = NgccConfiguration;\n\n  function findSatisfactoryVersion(configs, version) {\n    if (configs === undefined) {\n      return null;\n    }\n\n    if (version === null) {\n      // The package has no version (!) - perhaps the entry-point was from a deep import, which made\n      // it impossible to find the package.json.\n      // So just return the first config that matches the package name.\n      return configs[0];\n    }\n\n    return configs.find(function (config) {\n      return semver_1.satisfies(version, config.versionRange, {\n        includePrerelease: true\n      });\n    }) || null;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/configuration.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {createHash} from 'crypto';\nimport {satisfies} from 'semver';\nimport * as vm from 'vm';\n\nimport {AbsoluteFsPath, PathManipulation, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\n\nimport {PackageJsonFormatPropertiesMap} from './entry_point';\n\n/**\n * The format of a project level configuration file.\n */\nexport interface NgccProjectConfig<T = RawNgccPackageConfig> {\n  /**\n   * The packages that are configured by this project config.\n   */\n  packages?: {[packagePath: string]: T|undefined};\n  /**\n   * Options that control how locking the process is handled.\n   */\n  locking?: ProcessLockingConfiguration;\n}\n\n/**\n * Options that control how locking the process is handled.\n */\nexport interface ProcessLockingConfiguration {\n  /**\n   * The number of times the AsyncLocker will attempt to lock the process before failing.\n   * Defaults to 500.\n   */\n  retryAttempts?: number;\n  /**\n   * The number of milliseconds between attempts to lock the process.\n   * Defaults to 500ms.\n   * */\n  retryDelay?: number;\n}\n\n/**\n * The raw format of a package level configuration (as it appears in configuration files).\n */\nexport interface RawNgccPackageConfig {\n  /**\n   * The entry-points to configure for this package.\n   *\n   * In the config file the keys are paths relative to the package path.\n   */\n  entryPoints?: {[entryPointPath: string]: NgccEntryPointConfig};\n\n  /**\n   * A collection of regexes that match deep imports to ignore, for this package, rather than\n   * displaying a warning.\n   */\n  ignorableDeepImportMatchers?: RegExp[];\n}\n\n/**\n * Configuration options for an entry-point.\n *\n * The existence of a configuration for a path tells ngcc that this should be considered for\n * processing as an entry-point.\n */\nexport interface NgccEntryPointConfig {\n  /** Do not process (or even acknowledge the existence of) this entry-point, if true. */\n  ignore?: boolean;\n\n  /**\n   * This property, if provided, holds values that will override equivalent properties in an\n   * entry-point's package.json file.\n   */\n  override?: PackageJsonFormatPropertiesMap;\n\n  /**\n   * Normally, ngcc will skip compilation of entrypoints that contain imports that can't be resolved\n   * or understood. If this option is specified, ngcc will proceed with compiling the entrypoint\n   * even in the face of such missing dependencies.\n   */\n  ignoreMissingDependencies?: boolean;\n\n  /**\n   * Enabling this option for an entrypoint tells ngcc that deep imports might be used for the files\n   * it contains, and that it should generate private re-exports alongside the NgModule of all the\n   * directives/pipes it makes available in support of those imports.\n   */\n  generateDeepReexports?: boolean;\n}\n\ninterface VersionedPackageConfig extends RawNgccPackageConfig {\n  versionRange: string;\n}\n\ntype PartiallyProcessedConfig = Required<NgccProjectConfig<VersionedPackageConfig[]>>;\n\n/**\n * The default configuration for ngcc.\n *\n * This is the ultimate fallback configuration that ngcc will use if there is no configuration\n * for a package at the package level or project level.\n *\n * This configuration is for packages that are \"dead\" - i.e. no longer maintained and so are\n * unlikely to be fixed to work with ngcc, nor provide a package level config of their own.\n *\n * The fallback process for looking up configuration is:\n *\n * Project -> Package -> Default\n *\n * If a package provides its own configuration then that would override this default one.\n *\n * Also application developers can always provide configuration at their project level which\n * will override everything else.\n *\n * Note that the fallback is package based not entry-point based.\n * For example, if a there is configuration for a package at the project level this will replace all\n * entry-point configurations that may have been provided in the package level or default level\n * configurations, even if the project level configuration does not provide for a given entry-point.\n */\nexport const DEFAULT_NGCC_CONFIG: NgccProjectConfig = {\n  packages: {\n    // Add default package configuration here. For example:\n    // '@angular/fire@^5.2.0': {\n    //   entryPoints: {\n    //     './database-deprecated': {ignore: true},\n    //   },\n    // },\n\n    // The package does not contain any `.metadata.json` files in the root directory but only inside\n    // `dist/`. Without this config, ngcc does not realize this is a ViewEngine-built Angular\n    // package that needs to be compiled to Ivy.\n    'angular2-highcharts': {\n      entryPoints: {\n        '.': {\n          override: {\n            main: './index.js',\n          },\n        },\n      },\n    },\n\n    // The `dist/` directory has a duplicate `package.json` pointing to the same files, which (under\n    // certain configurations) can causes ngcc to try to process the files twice and fail.\n    // Ignore the `dist/` entry-point.\n    'ng2-dragula': {\n      entryPoints: {\n        './dist': {ignore: true},\n      },\n    },\n  },\n  locking: {\n    retryDelay: 500,\n    retryAttempts: 500,\n  }\n};\n\nconst NGCC_CONFIG_FILENAME = 'ngcc.config.js';\n\n/**\n * The processed package level configuration as a result of processing a raw package level config.\n */\nexport class ProcessedNgccPackageConfig implements Omit<RawNgccPackageConfig, 'entryPoints'> {\n  /**\n   * The absolute path to this instance of the package.\n   * Note that there may be multiple instances of a package inside a project in nested\n   * `node_modules/`. For example, one at `<project-root>/node_modules/some-package/` and one at\n   * `<project-root>/node_modules/other-package/node_modules/some-package/`.\n   */\n  packagePath: AbsoluteFsPath;\n\n  /**\n   * The entry-points to configure for this package.\n   *\n   * In contrast to `RawNgccPackageConfig`, the paths are absolute and take the path of the specific\n   * instance of the package into account.\n   */\n  entryPoints: Map<AbsoluteFsPath, NgccEntryPointConfig>;\n\n  /**\n   * A collection of regexes that match deep imports to ignore, for this package, rather than\n   * displaying a warning.\n   */\n  ignorableDeepImportMatchers: RegExp[];\n\n  constructor(fs: PathManipulation, packagePath: AbsoluteFsPath, {\n    entryPoints = {},\n    ignorableDeepImportMatchers = [],\n  }: RawNgccPackageConfig) {\n    const absolutePathEntries: [AbsoluteFsPath, NgccEntryPointConfig][] =\n        Object.entries(entryPoints).map(([\n                                          relativePath, config\n                                        ]) => [fs.resolve(packagePath, relativePath), config]);\n\n    this.packagePath = packagePath;\n    this.entryPoints = new Map(absolutePathEntries);\n    this.ignorableDeepImportMatchers = ignorableDeepImportMatchers;\n  }\n}\n\n/**\n * Ngcc has a hierarchical configuration system that lets us \"fix up\" packages that do not\n * work with ngcc out of the box.\n *\n * There are three levels at which configuration can be declared:\n *\n * * Default level - ngcc comes with built-in configuration for well known cases.\n * * Package level - a library author publishes a configuration with their package to fix known\n *   issues.\n * * Project level - the application developer provides a configuration that fixes issues specific\n *   to the libraries used in their application.\n *\n * Ngcc will match configuration based on the package name but also on its version. This allows\n * configuration to provide different fixes to different version ranges of a package.\n *\n * * Package level configuration is specific to the package version where the configuration is\n *   found.\n * * Default and project level configuration should provide version ranges to ensure that the\n *   configuration is only applied to the appropriate versions of a package.\n *\n * When getting a configuration for a package (via `getConfig()`) the caller should provide the\n * version of the package in question, if available. If it is not provided then the first available\n * configuration for a package is returned.\n */\nexport class NgccConfiguration {\n  private defaultConfig: PartiallyProcessedConfig;\n  private projectConfig: PartiallyProcessedConfig;\n  private cache = new Map<string, VersionedPackageConfig>();\n  readonly hash: string;\n\n  constructor(private fs: ReadonlyFileSystem, baseDir: AbsoluteFsPath) {\n    this.defaultConfig = this.processProjectConfig(DEFAULT_NGCC_CONFIG);\n    this.projectConfig = this.processProjectConfig(this.loadProjectConfig(baseDir));\n    this.hash = this.computeHash();\n  }\n\n  /**\n   * Get the configuration options for locking the ngcc process.\n   */\n  getLockingConfig(): Required<ProcessLockingConfiguration> {\n    let {retryAttempts, retryDelay} = this.projectConfig.locking;\n    if (retryAttempts === undefined) {\n      retryAttempts = this.defaultConfig.locking.retryAttempts!;\n    }\n    if (retryDelay === undefined) {\n      retryDelay = this.defaultConfig.locking.retryDelay!;\n    }\n    return {retryAttempts, retryDelay};\n  }\n\n  /**\n   * Get a configuration for the given `version` of a package at `packagePath`.\n   *\n   * @param packageName The name of the package whose config we want.\n   * @param packagePath The path to the package whose config we want.\n   * @param version The version of the package whose config we want, or `null` if the package's\n   * package.json did not exist or was invalid.\n   */\n  getPackageConfig(packageName: string, packagePath: AbsoluteFsPath, version: string|null):\n      ProcessedNgccPackageConfig {\n    const rawPackageConfig = this.getRawPackageConfig(packageName, packagePath, version);\n    return new ProcessedNgccPackageConfig(this.fs, packagePath, rawPackageConfig);\n  }\n\n  private getRawPackageConfig(\n      packageName: string, packagePath: AbsoluteFsPath,\n      version: string|null): VersionedPackageConfig {\n    const cacheKey = packageName + (version !== null ? `@${version}` : '');\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey)!;\n    }\n\n    const projectLevelConfig = this.projectConfig.packages ?\n        findSatisfactoryVersion(this.projectConfig.packages[packageName], version) :\n        null;\n    if (projectLevelConfig !== null) {\n      this.cache.set(cacheKey, projectLevelConfig);\n      return projectLevelConfig;\n    }\n\n    const packageLevelConfig = this.loadPackageConfig(packagePath, version);\n    if (packageLevelConfig !== null) {\n      this.cache.set(cacheKey, packageLevelConfig);\n      return packageLevelConfig;\n    }\n\n    const defaultLevelConfig = this.defaultConfig.packages ?\n        findSatisfactoryVersion(this.defaultConfig.packages[packageName], version) :\n        null;\n    if (defaultLevelConfig !== null) {\n      this.cache.set(cacheKey, defaultLevelConfig);\n      return defaultLevelConfig;\n    }\n\n    return {versionRange: '*'};\n  }\n\n  private processProjectConfig(projectConfig: NgccProjectConfig): PartiallyProcessedConfig {\n    const processedConfig: PartiallyProcessedConfig = {packages: {}, locking: {}};\n\n    // locking configuration\n    if (projectConfig.locking !== undefined) {\n      processedConfig.locking = projectConfig.locking;\n    }\n\n    // packages configuration\n    for (const packageNameAndVersion in projectConfig.packages) {\n      const packageConfig = projectConfig.packages[packageNameAndVersion];\n      if (packageConfig) {\n        const [packageName, versionRange = '*'] = this.splitNameAndVersion(packageNameAndVersion);\n        const packageConfigs =\n            processedConfig.packages[packageName] || (processedConfig.packages[packageName] = []);\n        packageConfigs!.push({...packageConfig, versionRange});\n      }\n    }\n\n    return processedConfig;\n  }\n\n  private loadProjectConfig(baseDir: AbsoluteFsPath): NgccProjectConfig {\n    const configFilePath = this.fs.join(baseDir, NGCC_CONFIG_FILENAME);\n    if (this.fs.exists(configFilePath)) {\n      try {\n        return this.evalSrcFile(configFilePath);\n      } catch (e) {\n        throw new Error(`Invalid project configuration file at \"${configFilePath}\": ` + e.message);\n      }\n    } else {\n      return {packages: {}};\n    }\n  }\n\n  private loadPackageConfig(packagePath: AbsoluteFsPath, version: string|null):\n      VersionedPackageConfig|null {\n    const configFilePath = this.fs.join(packagePath, NGCC_CONFIG_FILENAME);\n    if (this.fs.exists(configFilePath)) {\n      try {\n        const packageConfig = this.evalSrcFile(configFilePath);\n        return {\n          ...packageConfig,\n          versionRange: version || '*',\n        };\n      } catch (e) {\n        throw new Error(`Invalid package configuration file at \"${configFilePath}\": ` + e.message);\n      }\n    } else {\n      return null;\n    }\n  }\n\n  private evalSrcFile(srcPath: AbsoluteFsPath): any {\n    const src = this.fs.readFile(srcPath);\n    const theExports = {};\n    const sandbox = {\n      module: {exports: theExports},\n      exports: theExports,\n      require,\n      __dirname: this.fs.dirname(srcPath),\n      __filename: srcPath\n    };\n    vm.runInNewContext(src, sandbox, {filename: srcPath});\n    return sandbox.module.exports;\n  }\n\n  private splitNameAndVersion(packageNameAndVersion: string): [string, string|undefined] {\n    const versionIndex = packageNameAndVersion.lastIndexOf('@');\n    // Note that > 0 is because we don't want to match @ at the start of the line\n    // which is what you would have with a namespaced package, e.g. `@angular/common`.\n    return versionIndex > 0 ?\n        [\n          packageNameAndVersion.substring(0, versionIndex),\n          packageNameAndVersion.substring(versionIndex + 1),\n        ] :\n        [packageNameAndVersion, undefined];\n  }\n\n  private computeHash(): string {\n    return createHash('md5').update(JSON.stringify(this.projectConfig)).digest('hex');\n  }\n}\n\nfunction findSatisfactoryVersion(configs: VersionedPackageConfig[]|undefined, version: string|null):\n    VersionedPackageConfig|null {\n  if (configs === undefined) {\n    return null;\n  }\n  if (version === null) {\n    // The package has no version (!) - perhaps the entry-point was from a deep import, which made\n    // it impossible to find the package.json.\n    // So just return the first config that matches the package name.\n    return configs[0];\n  }\n  return configs.find(\n             config => satisfies(version, config.versionRange, {includePrerelease: true})) ||\n      null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}