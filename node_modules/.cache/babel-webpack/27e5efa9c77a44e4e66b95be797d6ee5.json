{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/metadata_resolver\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/aot/static_symbol\", \"@angular/compiler/src/aot/util\", \"@angular/compiler/src/assertions\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/core\", \"@angular/compiler/src/directive_resolver\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/lifecycle_reflector\", \"@angular/compiler/src/selector\", \"@angular/compiler/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.CompileMetadataResolver = exports.getMissingNgModuleMetadataErrorData = exports.ERROR_COMPONENT_TYPE = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var static_symbol_1 = require(\"@angular/compiler/src/aot/static_symbol\");\n\n  var util_1 = require(\"@angular/compiler/src/aot/util\");\n\n  var assertions_1 = require(\"@angular/compiler/src/assertions\");\n\n  var cpl = require(\"@angular/compiler/src/compile_metadata\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var directive_resolver_1 = require(\"@angular/compiler/src/directive_resolver\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var lifecycle_reflector_1 = require(\"@angular/compiler/src/lifecycle_reflector\");\n\n  var selector_1 = require(\"@angular/compiler/src/selector\");\n\n  var util_2 = require(\"@angular/compiler/src/util\");\n\n  exports.ERROR_COMPONENT_TYPE = 'ngComponentType';\n  var MISSING_NG_MODULE_METADATA_ERROR_DATA = 'ngMissingNgModuleMetadataErrorData';\n\n  function getMissingNgModuleMetadataErrorData(error) {\n    var _a;\n\n    return (_a = error[MISSING_NG_MODULE_METADATA_ERROR_DATA]) !== null && _a !== void 0 ? _a : null;\n  }\n\n  exports.getMissingNgModuleMetadataErrorData = getMissingNgModuleMetadataErrorData; // Design notes:\n  // - don't lazily create metadata:\n  //   For some metadata, we need to do async work sometimes,\n  //   so the user has to kick off this loading.\n  //   But we want to report errors even when the async work is\n  //   not required to check that the user would have been able\n  //   to wait correctly.\n\n  var CompileMetadataResolver =\n  /** @class */\n  function () {\n    function CompileMetadataResolver(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n      this._config = _config;\n      this._htmlParser = _htmlParser;\n      this._ngModuleResolver = _ngModuleResolver;\n      this._directiveResolver = _directiveResolver;\n      this._pipeResolver = _pipeResolver;\n      this._summaryResolver = _summaryResolver;\n      this._schemaRegistry = _schemaRegistry;\n      this._directiveNormalizer = _directiveNormalizer;\n      this._console = _console;\n      this._staticSymbolCache = _staticSymbolCache;\n      this._reflector = _reflector;\n      this._errorCollector = _errorCollector;\n      this._nonNormalizedDirectiveCache = new Map();\n      this._directiveCache = new Map();\n      this._summaryCache = new Map();\n      this._pipeCache = new Map();\n      this._ngModuleCache = new Map();\n      this._ngModuleOfTypes = new Map();\n      this._shallowModuleCache = new Map();\n    }\n\n    CompileMetadataResolver.prototype.getReflector = function () {\n      return this._reflector;\n    };\n\n    CompileMetadataResolver.prototype.clearCacheFor = function (type) {\n      var dirMeta = this._directiveCache.get(type);\n\n      this._directiveCache.delete(type);\n\n      this._nonNormalizedDirectiveCache.delete(type);\n\n      this._summaryCache.delete(type);\n\n      this._pipeCache.delete(type);\n\n      this._ngModuleOfTypes.delete(type); // Clear all of the NgModule as they contain transitive information!\n\n\n      this._ngModuleCache.clear();\n\n      if (dirMeta) {\n        this._directiveNormalizer.clearCacheFor(dirMeta);\n      }\n    };\n\n    CompileMetadataResolver.prototype.clearCache = function () {\n      this._directiveCache.clear();\n\n      this._nonNormalizedDirectiveCache.clear();\n\n      this._summaryCache.clear();\n\n      this._pipeCache.clear();\n\n      this._ngModuleCache.clear();\n\n      this._ngModuleOfTypes.clear();\n\n      this._directiveNormalizer.clearCache();\n    };\n\n    CompileMetadataResolver.prototype._createProxyClass = function (baseType, name) {\n      var delegate = null;\n\n      var proxyClass = function proxyClass() {\n        if (!delegate) {\n          throw new Error(\"Illegal state: Class \" + name + \" for type \" + util_2.stringify(baseType) + \" is not compiled yet!\");\n        }\n\n        return delegate.apply(this, arguments);\n      };\n\n      proxyClass.setDelegate = function (d) {\n        delegate = d;\n        proxyClass.prototype = d.prototype;\n      }; // Make stringify work correctly\n\n\n      proxyClass.overriddenName = name;\n      return proxyClass;\n    };\n\n    CompileMetadataResolver.prototype.getGeneratedClass = function (dirType, name) {\n      if (dirType instanceof static_symbol_1.StaticSymbol) {\n        return this._staticSymbolCache.get(util_1.ngfactoryFilePath(dirType.filePath), name);\n      } else {\n        return this._createProxyClass(dirType, name);\n      }\n    };\n\n    CompileMetadataResolver.prototype.getComponentViewClass = function (dirType) {\n      return this.getGeneratedClass(dirType, cpl.viewClassName(dirType, 0));\n    };\n\n    CompileMetadataResolver.prototype.getHostComponentViewClass = function (dirType) {\n      return this.getGeneratedClass(dirType, cpl.hostViewClassName(dirType));\n    };\n\n    CompileMetadataResolver.prototype.getHostComponentType = function (dirType) {\n      var name = cpl.identifierName({\n        reference: dirType\n      }) + \"_Host\";\n\n      if (dirType instanceof static_symbol_1.StaticSymbol) {\n        return this._staticSymbolCache.get(dirType.filePath, name);\n      }\n\n      return this._createProxyClass(dirType, name);\n    };\n\n    CompileMetadataResolver.prototype.getRendererType = function (dirType) {\n      if (dirType instanceof static_symbol_1.StaticSymbol) {\n        return this._staticSymbolCache.get(util_1.ngfactoryFilePath(dirType.filePath), cpl.rendererTypeName(dirType));\n      } else {\n        // returning an object as proxy,\n        // that we fill later during runtime compilation.\n        return {};\n      }\n    };\n\n    CompileMetadataResolver.prototype.getComponentFactory = function (selector, dirType, inputs, outputs) {\n      if (dirType instanceof static_symbol_1.StaticSymbol) {\n        return this._staticSymbolCache.get(util_1.ngfactoryFilePath(dirType.filePath), cpl.componentFactoryName(dirType));\n      } else {\n        var hostView = this.getHostComponentViewClass(dirType); // Note: ngContentSelectors will be filled later once the template is\n        // loaded.\n\n        var createComponentFactory = this._reflector.resolveExternalReference(identifiers_1.Identifiers.createComponentFactory);\n\n        return createComponentFactory(selector, dirType, hostView, inputs, outputs, []);\n      }\n    };\n\n    CompileMetadataResolver.prototype.initComponentFactory = function (factory, ngContentSelectors) {\n      var _a;\n\n      if (!(factory instanceof static_symbol_1.StaticSymbol)) {\n        (_a = factory.ngContentSelectors).push.apply(_a, tslib_1.__spread(ngContentSelectors));\n      }\n    };\n\n    CompileMetadataResolver.prototype._loadSummary = function (type, kind) {\n      var typeSummary = this._summaryCache.get(type);\n\n      if (!typeSummary) {\n        var summary = this._summaryResolver.resolveSummary(type);\n\n        typeSummary = summary ? summary.type : null;\n\n        this._summaryCache.set(type, typeSummary || null);\n      }\n\n      return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    };\n\n    CompileMetadataResolver.prototype.getHostComponentMetadata = function (compMeta, hostViewType) {\n      var hostType = this.getHostComponentType(compMeta.type.reference);\n\n      if (!hostViewType) {\n        hostViewType = this.getHostComponentViewClass(hostType);\n      } // Note: ! is ok here as this method should only be called with normalized directive\n      // metadata, which always fills in the selector.\n\n\n      var template = selector_1.CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();\n      var templateUrl = '';\n\n      var htmlAst = this._htmlParser.parse(template, templateUrl);\n\n      return cpl.CompileDirectiveMetadata.create({\n        isHost: true,\n        type: {\n          reference: hostType,\n          diDeps: [],\n          lifecycleHooks: []\n        },\n        template: new cpl.CompileTemplateMetadata({\n          encapsulation: core_1.ViewEncapsulation.None,\n          template: template,\n          templateUrl: templateUrl,\n          htmlAst: htmlAst,\n          styles: [],\n          styleUrls: [],\n          ngContentSelectors: [],\n          animations: [],\n          isInline: true,\n          externalStylesheets: [],\n          interpolation: null,\n          preserveWhitespaces: false\n        }),\n        exportAs: null,\n        changeDetection: core_1.ChangeDetectionStrategy.Default,\n        inputs: [],\n        outputs: [],\n        host: {},\n        isComponent: true,\n        selector: '*',\n        providers: [],\n        viewProviders: [],\n        queries: [],\n        guards: {},\n        viewQueries: [],\n        componentViewType: hostViewType,\n        rendererType: {\n          id: '__Host__',\n          encapsulation: core_1.ViewEncapsulation.None,\n          styles: [],\n          data: {}\n        },\n        entryComponents: [],\n        componentFactory: null\n      });\n    };\n\n    CompileMetadataResolver.prototype.loadDirectiveMetadata = function (ngModuleType, directiveType, isSync) {\n      var _this = this;\n\n      if (this._directiveCache.has(directiveType)) {\n        return null;\n      }\n\n      directiveType = util_2.resolveForwardRef(directiveType);\n\n      var _a = this.getNonNormalizedDirectiveMetadata(directiveType),\n          annotation = _a.annotation,\n          metadata = _a.metadata;\n\n      var createDirectiveMetadata = function createDirectiveMetadata(templateMetadata) {\n        var normalizedDirMeta = new cpl.CompileDirectiveMetadata({\n          isHost: false,\n          type: metadata.type,\n          isComponent: metadata.isComponent,\n          selector: metadata.selector,\n          exportAs: metadata.exportAs,\n          changeDetection: metadata.changeDetection,\n          inputs: metadata.inputs,\n          outputs: metadata.outputs,\n          hostListeners: metadata.hostListeners,\n          hostProperties: metadata.hostProperties,\n          hostAttributes: metadata.hostAttributes,\n          providers: metadata.providers,\n          viewProviders: metadata.viewProviders,\n          queries: metadata.queries,\n          guards: metadata.guards,\n          viewQueries: metadata.viewQueries,\n          entryComponents: metadata.entryComponents,\n          componentViewType: metadata.componentViewType,\n          rendererType: metadata.rendererType,\n          componentFactory: metadata.componentFactory,\n          template: templateMetadata\n        });\n\n        if (templateMetadata) {\n          _this.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);\n        }\n\n        _this._directiveCache.set(directiveType, normalizedDirMeta);\n\n        _this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n\n        return null;\n      };\n\n      if (metadata.isComponent) {\n        var template = metadata.template;\n\n        var templateMeta = this._directiveNormalizer.normalizeTemplate({\n          ngModuleType: ngModuleType,\n          componentType: directiveType,\n          moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\n          encapsulation: template.encapsulation,\n          template: template.template,\n          templateUrl: template.templateUrl,\n          styles: template.styles,\n          styleUrls: template.styleUrls,\n          animations: template.animations,\n          interpolation: template.interpolation,\n          preserveWhitespaces: template.preserveWhitespaces\n        });\n\n        if (util_2.isPromise(templateMeta) && isSync) {\n          this._reportError(componentStillLoadingError(directiveType), directiveType);\n\n          return null;\n        }\n\n        return util_2.SyncAsync.then(templateMeta, createDirectiveMetadata);\n      } else {\n        // directive\n        createDirectiveMetadata(null);\n        return null;\n      }\n    };\n\n    CompileMetadataResolver.prototype.getNonNormalizedDirectiveMetadata = function (directiveType) {\n      var _this = this;\n\n      directiveType = util_2.resolveForwardRef(directiveType);\n\n      if (!directiveType) {\n        return null;\n      }\n\n      var cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n\n      if (cacheEntry) {\n        return cacheEntry;\n      }\n\n      var dirMeta = this._directiveResolver.resolve(directiveType, false);\n\n      if (!dirMeta) {\n        return null;\n      }\n\n      var nonNormalizedTemplateMetadata = undefined;\n\n      if (core_1.createComponent.isTypeOf(dirMeta)) {\n        // component\n        var compMeta = dirMeta;\n        assertions_1.assertArrayOfStrings('styles', compMeta.styles);\n        assertions_1.assertArrayOfStrings('styleUrls', compMeta.styleUrls);\n        assertions_1.assertInterpolationSymbols('interpolation', compMeta.interpolation);\n        var animations = compMeta.animations;\n        nonNormalizedTemplateMetadata = new cpl.CompileTemplateMetadata({\n          encapsulation: util_2.noUndefined(compMeta.encapsulation),\n          template: util_2.noUndefined(compMeta.template),\n          templateUrl: util_2.noUndefined(compMeta.templateUrl),\n          htmlAst: null,\n          styles: compMeta.styles || [],\n          styleUrls: compMeta.styleUrls || [],\n          animations: animations || [],\n          interpolation: util_2.noUndefined(compMeta.interpolation),\n          isInline: !!compMeta.template,\n          externalStylesheets: [],\n          ngContentSelectors: [],\n          preserveWhitespaces: util_2.noUndefined(dirMeta.preserveWhitespaces)\n        });\n      }\n\n      var changeDetectionStrategy = null;\n      var viewProviders = [];\n      var entryComponentMetadata = [];\n      var selector = dirMeta.selector;\n\n      if (core_1.createComponent.isTypeOf(dirMeta)) {\n        // Component\n        var compMeta = dirMeta;\n        changeDetectionStrategy = compMeta.changeDetection;\n\n        if (compMeta.viewProviders) {\n          viewProviders = this._getProvidersMetadata(compMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n        }\n\n        if (compMeta.entryComponents) {\n          entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents).map(function (type) {\n            return _this._getEntryComponentMetadata(type);\n          }).concat(entryComponentMetadata);\n        }\n\n        if (!selector) {\n          selector = this._schemaRegistry.getDefaultComponentElementName();\n        }\n      } else {\n        // Directive\n        if (!selector) {\n          selector = null;\n        }\n      }\n\n      var providers = [];\n\n      if (dirMeta.providers != null) {\n        providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\" + stringifyType(directiveType) + \"\\\"\", [], directiveType);\n      }\n\n      var queries = [];\n      var viewQueries = [];\n\n      if (dirMeta.queries != null) {\n        queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n        viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n      }\n\n      var metadata = cpl.CompileDirectiveMetadata.create({\n        isHost: false,\n        selector: selector,\n        exportAs: util_2.noUndefined(dirMeta.exportAs),\n        isComponent: !!nonNormalizedTemplateMetadata,\n        type: this._getTypeMetadata(directiveType),\n        template: nonNormalizedTemplateMetadata,\n        changeDetection: changeDetectionStrategy,\n        inputs: dirMeta.inputs || [],\n        outputs: dirMeta.outputs || [],\n        host: dirMeta.host || {},\n        providers: providers || [],\n        viewProviders: viewProviders || [],\n        queries: queries || [],\n        guards: dirMeta.guards || {},\n        viewQueries: viewQueries || [],\n        entryComponents: entryComponentMetadata,\n        componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) : null,\n        rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n        componentFactory: null\n      });\n\n      if (nonNormalizedTemplateMetadata) {\n        metadata.componentFactory = this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n      }\n\n      cacheEntry = {\n        metadata: metadata,\n        annotation: dirMeta\n      };\n\n      this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n\n      return cacheEntry;\n    };\n    /**\n     * Gets the metadata for the given directive.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     */\n\n\n    CompileMetadataResolver.prototype.getDirectiveMetadata = function (directiveType) {\n      var dirMeta = this._directiveCache.get(directiveType);\n\n      if (!dirMeta) {\n        this._reportError(util_2.syntaxError(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive \" + stringifyType(directiveType) + \".\"), directiveType);\n      }\n\n      return dirMeta;\n    };\n\n    CompileMetadataResolver.prototype.getDirectiveSummary = function (dirType) {\n      var dirSummary = this._loadSummary(dirType, cpl.CompileSummaryKind.Directive);\n\n      if (!dirSummary) {\n        this._reportError(util_2.syntaxError(\"Illegal state: Could not load the summary for directive \" + stringifyType(dirType) + \".\"), dirType);\n      }\n\n      return dirSummary;\n    };\n\n    CompileMetadataResolver.prototype.isDirective = function (type) {\n      return !!this._loadSummary(type, cpl.CompileSummaryKind.Directive) || this._directiveResolver.isDirective(type);\n    };\n\n    CompileMetadataResolver.prototype.isAbstractDirective = function (type) {\n      var summary = this._loadSummary(type, cpl.CompileSummaryKind.Directive);\n\n      if (summary && !summary.isComponent) {\n        return !summary.selector;\n      }\n\n      var meta = this._directiveResolver.resolve(type, false);\n\n      if (meta && !core_1.createComponent.isTypeOf(meta)) {\n        return !meta.selector;\n      }\n\n      return false;\n    };\n\n    CompileMetadataResolver.prototype.isPipe = function (type) {\n      return !!this._loadSummary(type, cpl.CompileSummaryKind.Pipe) || this._pipeResolver.isPipe(type);\n    };\n\n    CompileMetadataResolver.prototype.isNgModule = function (type) {\n      return !!this._loadSummary(type, cpl.CompileSummaryKind.NgModule) || this._ngModuleResolver.isNgModule(type);\n    };\n\n    CompileMetadataResolver.prototype.getNgModuleSummary = function (moduleType, alreadyCollecting) {\n      if (alreadyCollecting === void 0) {\n        alreadyCollecting = null;\n      }\n\n      var moduleSummary = this._loadSummary(moduleType, cpl.CompileSummaryKind.NgModule);\n\n      if (!moduleSummary) {\n        var moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);\n        moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n\n        if (moduleSummary) {\n          this._summaryCache.set(moduleType, moduleSummary);\n        }\n      }\n\n      return moduleSummary;\n    };\n    /**\n     * Loads the declared directives and pipes of an NgModule.\n     */\n\n\n    CompileMetadataResolver.prototype.loadNgModuleDirectiveAndPipeMetadata = function (moduleType, isSync, throwIfNotFound) {\n      var _this = this;\n\n      if (throwIfNotFound === void 0) {\n        throwIfNotFound = true;\n      }\n\n      var ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n      var loading = [];\n\n      if (ngModule) {\n        ngModule.declaredDirectives.forEach(function (id) {\n          var promise = _this.loadDirectiveMetadata(moduleType, id.reference, isSync);\n\n          if (promise) {\n            loading.push(promise);\n          }\n        });\n        ngModule.declaredPipes.forEach(function (id) {\n          return _this._loadPipeMetadata(id.reference);\n        });\n      }\n\n      return Promise.all(loading);\n    };\n\n    CompileMetadataResolver.prototype.getShallowModuleMetadata = function (moduleType) {\n      var compileMeta = this._shallowModuleCache.get(moduleType);\n\n      if (compileMeta) {\n        return compileMeta;\n      }\n\n      var ngModuleMeta = directive_resolver_1.findLast(this._reflector.shallowAnnotations(moduleType), core_1.createNgModule.isTypeOf);\n      compileMeta = {\n        type: this._getTypeMetadata(moduleType),\n        rawExports: ngModuleMeta.exports,\n        rawImports: ngModuleMeta.imports,\n        rawProviders: ngModuleMeta.providers\n      };\n\n      this._shallowModuleCache.set(moduleType, compileMeta);\n\n      return compileMeta;\n    };\n\n    CompileMetadataResolver.prototype.getNgModuleMetadata = function (moduleType, throwIfNotFound, alreadyCollecting) {\n      var _this = this;\n\n      if (throwIfNotFound === void 0) {\n        throwIfNotFound = true;\n      }\n\n      if (alreadyCollecting === void 0) {\n        alreadyCollecting = null;\n      }\n\n      moduleType = util_2.resolveForwardRef(moduleType);\n\n      var compileMeta = this._ngModuleCache.get(moduleType);\n\n      if (compileMeta) {\n        return compileMeta;\n      }\n\n      var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n\n      if (!meta) {\n        return null;\n      }\n\n      var declaredDirectives = [];\n      var exportedNonModuleIdentifiers = [];\n      var declaredPipes = [];\n      var importedModules = [];\n      var exportedModules = [];\n      var providers = [];\n      var entryComponents = [];\n      var bootstrapComponents = [];\n      var schemas = [];\n\n      if (meta.imports) {\n        flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n          var importedModuleType = undefined;\n\n          if (isValidType(importedType)) {\n            importedModuleType = importedType;\n          } else if (importedType && importedType.ngModule) {\n            var moduleWithProviders = importedType;\n            importedModuleType = moduleWithProviders.ngModule;\n\n            if (moduleWithProviders.providers) {\n              providers.push.apply(providers, tslib_1.__spread(_this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(importedModuleType) + \"'\", [], importedType)));\n            }\n          }\n\n          if (importedModuleType) {\n            if (_this._checkSelfImport(moduleType, importedModuleType)) return;\n            if (!alreadyCollecting) alreadyCollecting = new Set();\n\n            if (alreadyCollecting.has(importedModuleType)) {\n              _this._reportError(util_2.syntaxError(_this._getTypeDescriptor(importedModuleType) + \" '\" + stringifyType(importedType) + \"' is imported recursively by the module '\" + stringifyType(moduleType) + \"'.\"), moduleType);\n\n              return;\n            }\n\n            alreadyCollecting.add(importedModuleType);\n\n            var importedModuleSummary = _this.getNgModuleSummary(importedModuleType, alreadyCollecting);\n\n            alreadyCollecting.delete(importedModuleType);\n\n            if (!importedModuleSummary) {\n              var err = util_2.syntaxError(\"Unexpected \" + _this._getTypeDescriptor(importedType) + \" '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'. Please add a @NgModule annotation.\"); // If possible, record additional context for this error to enable more useful\n              // diagnostics on the compiler side.\n\n              if (importedType instanceof static_symbol_1.StaticSymbol) {\n                err[MISSING_NG_MODULE_METADATA_ERROR_DATA] = {\n                  fileName: importedType.filePath,\n                  className: importedType.name\n                };\n              }\n\n              _this._reportError(err, moduleType);\n\n              return;\n            }\n\n            importedModules.push(importedModuleSummary);\n          } else {\n            _this._reportError(util_2.syntaxError(\"Unexpected value '\" + stringifyType(importedType) + \"' imported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n\n            return;\n          }\n        });\n      }\n\n      if (meta.exports) {\n        flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n          if (!isValidType(exportedType)) {\n            _this._reportError(util_2.syntaxError(\"Unexpected value '\" + stringifyType(exportedType) + \"' exported by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n\n            return;\n          }\n\n          if (!alreadyCollecting) alreadyCollecting = new Set();\n\n          if (alreadyCollecting.has(exportedType)) {\n            _this._reportError(util_2.syntaxError(_this._getTypeDescriptor(exportedType) + \" '\" + util_2.stringify(exportedType) + \"' is exported recursively by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n\n            return;\n          }\n\n          alreadyCollecting.add(exportedType);\n\n          var exportedModuleSummary = _this.getNgModuleSummary(exportedType, alreadyCollecting);\n\n          alreadyCollecting.delete(exportedType);\n\n          if (exportedModuleSummary) {\n            exportedModules.push(exportedModuleSummary);\n          } else {\n            exportedNonModuleIdentifiers.push(_this._getIdentifierMetadata(exportedType));\n          }\n        });\n      } // Note: This will be modified later, so we rely on\n      // getting a new instance every time!\n\n\n      var transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n\n      if (meta.declarations) {\n        flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n          if (!isValidType(declaredType)) {\n            _this._reportError(util_2.syntaxError(\"Unexpected value '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n\n            return;\n          }\n\n          var declaredIdentifier = _this._getIdentifierMetadata(declaredType);\n\n          if (_this.isDirective(declaredType)) {\n            if (_this.isAbstractDirective(declaredType)) {\n              _this._reportError(util_2.syntaxError(\"Directive \" + stringifyType(declaredType) + \" has no selector, please add it!\"), declaredType);\n            }\n\n            transitiveModule.addDirective(declaredIdentifier);\n            declaredDirectives.push(declaredIdentifier);\n\n            _this._addTypeToModule(declaredType, moduleType);\n          } else if (_this.isPipe(declaredType)) {\n            transitiveModule.addPipe(declaredIdentifier);\n            transitiveModule.pipes.push(declaredIdentifier);\n            declaredPipes.push(declaredIdentifier);\n\n            _this._addTypeToModule(declaredType, moduleType);\n          } else {\n            _this._reportError(util_2.syntaxError(\"Unexpected \" + _this._getTypeDescriptor(declaredType) + \" '\" + stringifyType(declaredType) + \"' declared by the module '\" + stringifyType(moduleType) + \"'. Please add a @Pipe/@Directive/@Component annotation.\"), moduleType);\n\n            return;\n          }\n        });\n      }\n\n      var exportedDirectives = [];\n      var exportedPipes = [];\n      exportedNonModuleIdentifiers.forEach(function (exportedId) {\n        if (transitiveModule.directivesSet.has(exportedId.reference)) {\n          exportedDirectives.push(exportedId);\n          transitiveModule.addExportedDirective(exportedId);\n        } else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n          exportedPipes.push(exportedId);\n          transitiveModule.addExportedPipe(exportedId);\n        } else {\n          _this._reportError(util_2.syntaxError(\"Can't export \" + _this._getTypeDescriptor(exportedId.reference) + \" \" + stringifyType(exportedId.reference) + \" from \" + stringifyType(moduleType) + \" as it was neither declared nor imported!\"), moduleType);\n\n          return;\n        }\n      }); // The providers of the module have to go last\n      // so that they overwrite any other provider we already added.\n\n      if (meta.providers) {\n        providers.push.apply(providers, tslib_1.__spread(this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\" + stringifyType(moduleType) + \"'\", [], moduleType)));\n      }\n\n      if (meta.entryComponents) {\n        entryComponents.push.apply(entryComponents, tslib_1.__spread(flattenAndDedupeArray(meta.entryComponents).map(function (type) {\n          return _this._getEntryComponentMetadata(type);\n        })));\n      }\n\n      if (meta.bootstrap) {\n        flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {\n          if (!isValidType(type)) {\n            _this._reportError(util_2.syntaxError(\"Unexpected value '\" + stringifyType(type) + \"' used in the bootstrap property of module '\" + stringifyType(moduleType) + \"'\"), moduleType);\n\n            return;\n          }\n\n          bootstrapComponents.push(_this._getIdentifierMetadata(type));\n        });\n      }\n\n      entryComponents.push.apply(entryComponents, tslib_1.__spread(bootstrapComponents.map(function (type) {\n        return _this._getEntryComponentMetadata(type.reference);\n      })));\n\n      if (meta.schemas) {\n        schemas.push.apply(schemas, tslib_1.__spread(flattenAndDedupeArray(meta.schemas)));\n      }\n\n      compileMeta = new cpl.CompileNgModuleMetadata({\n        type: this._getTypeMetadata(moduleType),\n        providers: providers,\n        entryComponents: entryComponents,\n        bootstrapComponents: bootstrapComponents,\n        schemas: schemas,\n        declaredDirectives: declaredDirectives,\n        exportedDirectives: exportedDirectives,\n        declaredPipes: declaredPipes,\n        exportedPipes: exportedPipes,\n        importedModules: importedModules,\n        exportedModules: exportedModules,\n        transitiveModule: transitiveModule,\n        id: meta.id || null\n      });\n      entryComponents.forEach(function (id) {\n        return transitiveModule.addEntryComponent(id);\n      });\n      providers.forEach(function (provider) {\n        return transitiveModule.addProvider(provider, compileMeta.type);\n      });\n      transitiveModule.addModule(compileMeta.type);\n\n      this._ngModuleCache.set(moduleType, compileMeta);\n\n      return compileMeta;\n    };\n\n    CompileMetadataResolver.prototype._checkSelfImport = function (moduleType, importedModuleType) {\n      if (moduleType === importedModuleType) {\n        this._reportError(util_2.syntaxError(\"'\" + stringifyType(moduleType) + \"' module can't import itself\"), moduleType);\n\n        return true;\n      }\n\n      return false;\n    };\n\n    CompileMetadataResolver.prototype._getTypeDescriptor = function (type) {\n      if (isValidType(type)) {\n        if (this.isDirective(type)) {\n          return 'directive';\n        }\n\n        if (this.isPipe(type)) {\n          return 'pipe';\n        }\n\n        if (this.isNgModule(type)) {\n          return 'module';\n        }\n      }\n\n      if (type.provide) {\n        return 'provider';\n      }\n\n      return 'value';\n    };\n\n    CompileMetadataResolver.prototype._addTypeToModule = function (type, moduleType) {\n      var oldModule = this._ngModuleOfTypes.get(type);\n\n      if (oldModule && oldModule !== moduleType) {\n        this._reportError(util_2.syntaxError(\"Type \" + stringifyType(type) + \" is part of the declarations of 2 modules: \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \"! \" + (\"Please consider moving \" + stringifyType(type) + \" to a higher module that imports \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \". \") + (\"You can also create a new NgModule that exports and includes \" + stringifyType(type) + \" then import that NgModule in \" + stringifyType(oldModule) + \" and \" + stringifyType(moduleType) + \".\")), moduleType);\n\n        return;\n      }\n\n      this._ngModuleOfTypes.set(type, moduleType);\n    };\n\n    CompileMetadataResolver.prototype._getTransitiveNgModuleMetadata = function (importedModules, exportedModules) {\n      // collect `providers` / `entryComponents` from all imported and all exported modules\n      var result = new cpl.TransitiveCompileNgModuleMetadata();\n      var modulesByToken = new Map();\n      importedModules.concat(exportedModules).forEach(function (modSummary) {\n        modSummary.modules.forEach(function (mod) {\n          return result.addModule(mod);\n        });\n        modSummary.entryComponents.forEach(function (comp) {\n          return result.addEntryComponent(comp);\n        });\n        var addedTokens = new Set();\n        modSummary.providers.forEach(function (entry) {\n          var tokenRef = cpl.tokenReference(entry.provider.token);\n          var prevModules = modulesByToken.get(tokenRef);\n\n          if (!prevModules) {\n            prevModules = new Set();\n            modulesByToken.set(tokenRef, prevModules);\n          }\n\n          var moduleRef = entry.module.reference; // Note: the providers of one module may still contain multiple providers\n          // per token (e.g. for multi providers), and we need to preserve these.\n\n          if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n            prevModules.add(moduleRef);\n            addedTokens.add(tokenRef);\n            result.addProvider(entry.provider, entry.module);\n          }\n        });\n      });\n      exportedModules.forEach(function (modSummary) {\n        modSummary.exportedDirectives.forEach(function (id) {\n          return result.addExportedDirective(id);\n        });\n        modSummary.exportedPipes.forEach(function (id) {\n          return result.addExportedPipe(id);\n        });\n      });\n      importedModules.forEach(function (modSummary) {\n        modSummary.exportedDirectives.forEach(function (id) {\n          return result.addDirective(id);\n        });\n        modSummary.exportedPipes.forEach(function (id) {\n          return result.addPipe(id);\n        });\n      });\n      return result;\n    };\n\n    CompileMetadataResolver.prototype._getIdentifierMetadata = function (type) {\n      type = util_2.resolveForwardRef(type);\n      return {\n        reference: type\n      };\n    };\n\n    CompileMetadataResolver.prototype.isInjectable = function (type) {\n      var annotations = this._reflector.tryAnnotations(type);\n\n      return annotations.some(function (ann) {\n        return core_1.createInjectable.isTypeOf(ann);\n      });\n    };\n\n    CompileMetadataResolver.prototype.getInjectableSummary = function (type) {\n      return {\n        summaryKind: cpl.CompileSummaryKind.Injectable,\n        type: this._getTypeMetadata(type, null, false)\n      };\n    };\n\n    CompileMetadataResolver.prototype.getInjectableMetadata = function (type, dependencies, throwOnUnknownDeps) {\n      if (dependencies === void 0) {\n        dependencies = null;\n      }\n\n      if (throwOnUnknownDeps === void 0) {\n        throwOnUnknownDeps = true;\n      }\n\n      var typeSummary = this._loadSummary(type, cpl.CompileSummaryKind.Injectable);\n\n      var typeMetadata = typeSummary ? typeSummary.type : this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);\n\n      var annotations = this._reflector.annotations(type).filter(function (ann) {\n        return core_1.createInjectable.isTypeOf(ann);\n      });\n\n      if (annotations.length === 0) {\n        return null;\n      }\n\n      var meta = annotations[annotations.length - 1];\n      return {\n        symbol: type,\n        type: typeMetadata,\n        providedIn: meta.providedIn,\n        useValue: meta.useValue,\n        useClass: meta.useClass,\n        useExisting: meta.useExisting,\n        useFactory: meta.useFactory,\n        deps: meta.deps\n      };\n    };\n\n    CompileMetadataResolver.prototype._getTypeMetadata = function (type, dependencies, throwOnUnknownDeps) {\n      if (dependencies === void 0) {\n        dependencies = null;\n      }\n\n      if (throwOnUnknownDeps === void 0) {\n        throwOnUnknownDeps = true;\n      }\n\n      var identifier = this._getIdentifierMetadata(type);\n\n      return {\n        reference: identifier.reference,\n        diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n        lifecycleHooks: lifecycle_reflector_1.getAllLifecycleHooks(this._reflector, identifier.reference)\n      };\n    };\n\n    CompileMetadataResolver.prototype._getFactoryMetadata = function (factory, dependencies) {\n      if (dependencies === void 0) {\n        dependencies = null;\n      }\n\n      factory = util_2.resolveForwardRef(factory);\n      return {\n        reference: factory,\n        diDeps: this._getDependenciesMetadata(factory, dependencies)\n      };\n    };\n    /**\n     * Gets the metadata for the given pipe.\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n     */\n\n\n    CompileMetadataResolver.prototype.getPipeMetadata = function (pipeType) {\n      var pipeMeta = this._pipeCache.get(pipeType);\n\n      if (!pipeMeta) {\n        this._reportError(util_2.syntaxError(\"Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n      }\n\n      return pipeMeta || null;\n    };\n\n    CompileMetadataResolver.prototype.getPipeSummary = function (pipeType) {\n      var pipeSummary = this._loadSummary(pipeType, cpl.CompileSummaryKind.Pipe);\n\n      if (!pipeSummary) {\n        this._reportError(util_2.syntaxError(\"Illegal state: Could not load the summary for pipe \" + stringifyType(pipeType) + \".\"), pipeType);\n      }\n\n      return pipeSummary;\n    };\n\n    CompileMetadataResolver.prototype.getOrLoadPipeMetadata = function (pipeType) {\n      var pipeMeta = this._pipeCache.get(pipeType);\n\n      if (!pipeMeta) {\n        pipeMeta = this._loadPipeMetadata(pipeType);\n      }\n\n      return pipeMeta;\n    };\n\n    CompileMetadataResolver.prototype._loadPipeMetadata = function (pipeType) {\n      pipeType = util_2.resolveForwardRef(pipeType);\n\n      var pipeAnnotation = this._pipeResolver.resolve(pipeType);\n\n      var pipeMeta = new cpl.CompilePipeMetadata({\n        type: this._getTypeMetadata(pipeType),\n        name: pipeAnnotation.name,\n        pure: !!pipeAnnotation.pure\n      });\n\n      this._pipeCache.set(pipeType, pipeMeta);\n\n      this._summaryCache.set(pipeType, pipeMeta.toSummary());\n\n      return pipeMeta;\n    };\n\n    CompileMetadataResolver.prototype._getDependenciesMetadata = function (typeOrFunc, dependencies, throwOnUnknownDeps) {\n      var _this = this;\n\n      if (throwOnUnknownDeps === void 0) {\n        throwOnUnknownDeps = true;\n      }\n\n      var hasUnknownDeps = false;\n      var params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n      var dependenciesMetadata = params.map(function (param) {\n        var isAttribute = false;\n        var isHost = false;\n        var isSelf = false;\n        var isSkipSelf = false;\n        var isOptional = false;\n        var token = null;\n\n        if (Array.isArray(param)) {\n          param.forEach(function (paramEntry) {\n            if (core_1.createHost.isTypeOf(paramEntry)) {\n              isHost = true;\n            } else if (core_1.createSelf.isTypeOf(paramEntry)) {\n              isSelf = true;\n            } else if (core_1.createSkipSelf.isTypeOf(paramEntry)) {\n              isSkipSelf = true;\n            } else if (core_1.createOptional.isTypeOf(paramEntry)) {\n              isOptional = true;\n            } else if (core_1.createAttribute.isTypeOf(paramEntry)) {\n              isAttribute = true;\n              token = paramEntry.attributeName;\n            } else if (core_1.createInject.isTypeOf(paramEntry)) {\n              token = paramEntry.token;\n            } else if (core_1.createInjectionToken.isTypeOf(paramEntry) || paramEntry instanceof static_symbol_1.StaticSymbol) {\n              token = paramEntry;\n            } else if (isValidType(paramEntry) && token == null) {\n              token = paramEntry;\n            }\n          });\n        } else {\n          token = param;\n        }\n\n        if (token == null) {\n          hasUnknownDeps = true;\n          return {};\n        }\n\n        return {\n          isAttribute: isAttribute,\n          isHost: isHost,\n          isSelf: isSelf,\n          isSkipSelf: isSkipSelf,\n          isOptional: isOptional,\n          token: _this._getTokenMetadata(token)\n        };\n      });\n\n      if (hasUnknownDeps) {\n        var depsTokens = dependenciesMetadata.map(function (dep) {\n          return dep.token ? stringifyType(dep.token) : '?';\n        }).join(', ');\n        var message = \"Can't resolve all parameters for \" + stringifyType(typeOrFunc) + \": (\" + depsTokens + \").\";\n\n        if (throwOnUnknownDeps || this._config.strictInjectionParameters) {\n          this._reportError(util_2.syntaxError(message), typeOrFunc);\n        }\n      }\n\n      return dependenciesMetadata;\n    };\n\n    CompileMetadataResolver.prototype._getTokenMetadata = function (token) {\n      token = util_2.resolveForwardRef(token);\n      var compileToken;\n\n      if (typeof token === 'string') {\n        compileToken = {\n          value: token\n        };\n      } else {\n        compileToken = {\n          identifier: {\n            reference: token\n          }\n        };\n      }\n\n      return compileToken;\n    };\n\n    CompileMetadataResolver.prototype._getProvidersMetadata = function (providers, targetEntryComponents, debugInfo, compileProviders, type) {\n      var _this = this;\n\n      if (compileProviders === void 0) {\n        compileProviders = [];\n      }\n\n      providers.forEach(function (provider, providerIdx) {\n        if (Array.isArray(provider)) {\n          _this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n        } else {\n          provider = util_2.resolveForwardRef(provider);\n          var providerMeta = undefined;\n\n          if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n            _this._validateProvider(provider);\n\n            providerMeta = new cpl.ProviderMeta(provider.provide, provider);\n          } else if (isValidType(provider)) {\n            providerMeta = new cpl.ProviderMeta(provider, {\n              useClass: provider\n            });\n          } else if (provider === void 0) {\n            _this._reportError(util_2.syntaxError(\"Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.\"));\n\n            return;\n          } else {\n            var providersInfo = providers.reduce(function (soFar, seenProvider, seenProviderIdx) {\n              if (seenProviderIdx < providerIdx) {\n                soFar.push(\"\" + stringifyType(seenProvider));\n              } else if (seenProviderIdx == providerIdx) {\n                soFar.push(\"?\" + stringifyType(seenProvider) + \"?\");\n              } else if (seenProviderIdx == providerIdx + 1) {\n                soFar.push('...');\n              }\n\n              return soFar;\n            }, []).join(', ');\n\n            _this._reportError(util_2.syntaxError(\"Invalid \" + (debugInfo ? debugInfo : 'provider') + \" - only instances of Provider and Type are allowed, got: [\" + providersInfo + \"]\"), type);\n\n            return;\n          }\n\n          if (providerMeta.token === _this._reflector.resolveExternalReference(identifiers_1.Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n            targetEntryComponents.push.apply(targetEntryComponents, tslib_1.__spread(_this._getEntryComponentsFromProvider(providerMeta, type)));\n          } else {\n            compileProviders.push(_this.getProviderMetadata(providerMeta));\n          }\n        }\n      });\n      return compileProviders;\n    };\n\n    CompileMetadataResolver.prototype._validateProvider = function (provider) {\n      if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n        this._reportError(util_2.syntaxError(\"Invalid provider for \" + stringifyType(provider.provide) + \". useClass cannot be \" + provider.useClass + \".\\n           Usually it happens when:\\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\\n           2. Class was used before it was declared. Use forwardRef in this case.\"));\n      }\n    };\n\n    CompileMetadataResolver.prototype._getEntryComponentsFromProvider = function (provider, type) {\n      var _this = this;\n\n      var components = [];\n      var collectedIdentifiers = [];\n\n      if (provider.useFactory || provider.useExisting || provider.useClass) {\n        this._reportError(util_2.syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\"), type);\n\n        return [];\n      }\n\n      if (!provider.multi) {\n        this._reportError(util_2.syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\"), type);\n\n        return [];\n      }\n\n      extractIdentifiers(provider.useValue, collectedIdentifiers);\n      collectedIdentifiers.forEach(function (identifier) {\n        var entry = _this._getEntryComponentMetadata(identifier.reference, false);\n\n        if (entry) {\n          components.push(entry);\n        }\n      });\n      return components;\n    };\n\n    CompileMetadataResolver.prototype._getEntryComponentMetadata = function (dirType, throwIfNotFound) {\n      if (throwIfNotFound === void 0) {\n        throwIfNotFound = true;\n      }\n\n      var dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n\n      if (dirMeta && dirMeta.metadata.isComponent) {\n        return {\n          componentType: dirType,\n          componentFactory: dirMeta.metadata.componentFactory\n        };\n      }\n\n      var dirSummary = this._loadSummary(dirType, cpl.CompileSummaryKind.Directive);\n\n      if (dirSummary && dirSummary.isComponent) {\n        return {\n          componentType: dirType,\n          componentFactory: dirSummary.componentFactory\n        };\n      }\n\n      if (throwIfNotFound) {\n        throw util_2.syntaxError(dirType.name + \" cannot be used as an entry component.\");\n      }\n\n      return null;\n    };\n\n    CompileMetadataResolver.prototype._getInjectableTypeMetadata = function (type, dependencies) {\n      if (dependencies === void 0) {\n        dependencies = null;\n      }\n\n      var typeSummary = this._loadSummary(type, cpl.CompileSummaryKind.Injectable);\n\n      if (typeSummary) {\n        return typeSummary.type;\n      }\n\n      return this._getTypeMetadata(type, dependencies);\n    };\n\n    CompileMetadataResolver.prototype.getProviderMetadata = function (provider) {\n      var compileDeps = undefined;\n      var compileTypeMetadata = null;\n      var compileFactoryMetadata = null;\n\n      var token = this._getTokenMetadata(provider.token);\n\n      if (provider.useClass) {\n        compileTypeMetadata = this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);\n        compileDeps = compileTypeMetadata.diDeps;\n\n        if (provider.token === provider.useClass) {\n          // use the compileTypeMetadata as it contains information about lifecycleHooks...\n          token = {\n            identifier: compileTypeMetadata\n          };\n        }\n      } else if (provider.useFactory) {\n        compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n        compileDeps = compileFactoryMetadata.diDeps;\n      }\n\n      return {\n        token: token,\n        useClass: compileTypeMetadata,\n        useValue: provider.useValue,\n        useFactory: compileFactoryMetadata,\n        useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n        deps: compileDeps,\n        multi: provider.multi\n      };\n    };\n\n    CompileMetadataResolver.prototype._getQueriesMetadata = function (queries, isViewQuery, directiveType) {\n      var _this = this;\n\n      var res = [];\n      Object.keys(queries).forEach(function (propertyName) {\n        var query = queries[propertyName];\n\n        if (query.isViewQuery === isViewQuery) {\n          res.push(_this._getQueryMetadata(query, propertyName, directiveType));\n        }\n      });\n      return res;\n    };\n\n    CompileMetadataResolver.prototype._queryVarBindings = function (selector) {\n      return selector.split(/\\s*,\\s*/);\n    };\n\n    CompileMetadataResolver.prototype._getQueryMetadata = function (q, propertyName, typeOrFunc) {\n      var _this = this;\n\n      var selectors;\n\n      if (typeof q.selector === 'string') {\n        selectors = this._queryVarBindings(q.selector).map(function (varName) {\n          return _this._getTokenMetadata(varName);\n        });\n      } else {\n        if (!q.selector) {\n          this._reportError(util_2.syntaxError(\"Can't construct a query for the property \\\"\" + propertyName + \"\\\" of \\\"\" + stringifyType(typeOrFunc) + \"\\\" since the query selector wasn't defined.\"), typeOrFunc);\n\n          selectors = [];\n        } else {\n          selectors = [this._getTokenMetadata(q.selector)];\n        }\n      }\n\n      return {\n        selectors: selectors,\n        first: q.first,\n        descendants: q.descendants,\n        emitDistinctChangesOnly: q.emitDistinctChangesOnly,\n        propertyName: propertyName,\n        read: q.read ? this._getTokenMetadata(q.read) : null,\n        static: q.static\n      };\n    };\n\n    CompileMetadataResolver.prototype._reportError = function (error, type, otherType) {\n      if (this._errorCollector) {\n        this._errorCollector(error, type);\n\n        if (otherType) {\n          this._errorCollector(error, otherType);\n        }\n      } else {\n        throw error;\n      }\n    };\n\n    return CompileMetadataResolver;\n  }();\n\n  exports.CompileMetadataResolver = CompileMetadataResolver;\n\n  function flattenArray(tree, out) {\n    if (out === void 0) {\n      out = [];\n    }\n\n    if (tree) {\n      for (var i = 0; i < tree.length; i++) {\n        var item = util_2.resolveForwardRef(tree[i]);\n\n        if (Array.isArray(item)) {\n          flattenArray(item, out);\n        } else {\n          out.push(item);\n        }\n      }\n    }\n\n    return out;\n  }\n\n  function dedupeArray(array) {\n    if (array) {\n      return Array.from(new Set(array));\n    }\n\n    return [];\n  }\n\n  function flattenAndDedupeArray(tree) {\n    return dedupeArray(flattenArray(tree));\n  }\n\n  function isValidType(value) {\n    return value instanceof static_symbol_1.StaticSymbol || value instanceof core_1.Type;\n  }\n\n  function extractIdentifiers(value, targetIdentifiers) {\n    util_2.visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n  }\n\n  var _CompileValueConverter =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(_CompileValueConverter, _super);\n\n    function _CompileValueConverter() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    _CompileValueConverter.prototype.visitOther = function (value, targetIdentifiers) {\n      targetIdentifiers.push({\n        reference: value\n      });\n    };\n\n    return _CompileValueConverter;\n  }(util_2.ValueTransformer);\n\n  function stringifyType(type) {\n    if (type instanceof static_symbol_1.StaticSymbol) {\n      return type.name + \" in \" + type.filePath;\n    } else {\n      return util_2.stringify(type);\n    }\n  }\n  /**\n   * Indicates that a component is still being loaded in a synchronous compile.\n   */\n\n\n  function componentStillLoadingError(compType) {\n    var error = Error(\"Can't compile synchronously as \" + util_2.stringify(compType) + \" is still being loaded!\");\n    error[exports.ERROR_COMPONENT_TYPE] = compType;\n    return error;\n  }\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/metadata_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol, StaticSymbolCache} from './aot/static_symbol';\nimport {ngfactoryFilePath} from './aot/util';\nimport {assertArrayOfStrings, assertInterpolationSymbols} from './assertions';\nimport * as cpl from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport {CompilerConfig} from './config';\nimport {ChangeDetectionStrategy, Component, createAttribute, createComponent, createHost, createInject, createInjectable, createInjectionToken, createNgModule, createOptional, createSelf, createSkipSelf, Directive, Injectable, ModuleWithProviders, Provider, Query, SchemaMetadata, Type, ViewEncapsulation} from './core';\nimport {DirectiveNormalizer} from './directive_normalizer';\nimport {DirectiveResolver, findLast} from './directive_resolver';\nimport {Identifiers} from './identifiers';\nimport {getAllLifecycleHooks} from './lifecycle_reflector';\nimport {HtmlParser} from './ml_parser/html_parser';\nimport {NgModuleResolver} from './ng_module_resolver';\nimport {PipeResolver} from './pipe_resolver';\nimport {ElementSchemaRegistry} from './schema/element_schema_registry';\nimport {CssSelector} from './selector';\nimport {SummaryResolver} from './summary_resolver';\nimport {Console, isPromise, noUndefined, resolveForwardRef, stringify, SyncAsync, syntaxError, ValueTransformer, visitValue} from './util';\n\nexport type ErrorCollector = (error: any, type?: any) => void;\n\nexport const ERROR_COMPONENT_TYPE = 'ngComponentType';\n\nconst MISSING_NG_MODULE_METADATA_ERROR_DATA = 'ngMissingNgModuleMetadataErrorData';\nexport interface MissingNgModuleMetadataErrorData {\n  fileName: string;\n  className: string;\n}\n\n\nexport function getMissingNgModuleMetadataErrorData(error: any): MissingNgModuleMetadataErrorData|\n    null {\n  return error[MISSING_NG_MODULE_METADATA_ERROR_DATA] ?? null;\n}\n\n// Design notes:\n// - don't lazily create metadata:\n//   For some metadata, we need to do async work sometimes,\n//   so the user has to kick off this loading.\n//   But we want to report errors even when the async work is\n//   not required to check that the user would have been able\n//   to wait correctly.\nexport class CompileMetadataResolver {\n  private _nonNormalizedDirectiveCache =\n      new Map<Type, {annotation: Directive, metadata: cpl.CompileDirectiveMetadata}>();\n  private _directiveCache = new Map<Type, cpl.CompileDirectiveMetadata>();\n  private _summaryCache = new Map<Type, cpl.CompileTypeSummary|null>();\n  private _pipeCache = new Map<Type, cpl.CompilePipeMetadata>();\n  private _ngModuleCache = new Map<Type, cpl.CompileNgModuleMetadata>();\n  private _ngModuleOfTypes = new Map<Type, Type>();\n  private _shallowModuleCache = new Map<Type, cpl.CompileShallowModuleMetadata>();\n\n  constructor(\n      private _config: CompilerConfig, private _htmlParser: HtmlParser,\n      private _ngModuleResolver: NgModuleResolver, private _directiveResolver: DirectiveResolver,\n      private _pipeResolver: PipeResolver, private _summaryResolver: SummaryResolver<any>,\n      private _schemaRegistry: ElementSchemaRegistry,\n      private _directiveNormalizer: DirectiveNormalizer, private _console: Console,\n      private _staticSymbolCache: StaticSymbolCache, private _reflector: CompileReflector,\n      private _errorCollector?: ErrorCollector) {}\n\n  getReflector(): CompileReflector {\n    return this._reflector;\n  }\n\n  clearCacheFor(type: Type) {\n    const dirMeta = this._directiveCache.get(type);\n    this._directiveCache.delete(type);\n    this._nonNormalizedDirectiveCache.delete(type);\n    this._summaryCache.delete(type);\n    this._pipeCache.delete(type);\n    this._ngModuleOfTypes.delete(type);\n    // Clear all of the NgModule as they contain transitive information!\n    this._ngModuleCache.clear();\n    if (dirMeta) {\n      this._directiveNormalizer.clearCacheFor(dirMeta);\n    }\n  }\n\n  clearCache(): void {\n    this._directiveCache.clear();\n    this._nonNormalizedDirectiveCache.clear();\n    this._summaryCache.clear();\n    this._pipeCache.clear();\n    this._ngModuleCache.clear();\n    this._ngModuleOfTypes.clear();\n    this._directiveNormalizer.clearCache();\n  }\n\n  private _createProxyClass(baseType: any, name: string): cpl.ProxyClass {\n    let delegate: any = null;\n    const proxyClass: cpl.ProxyClass = <any>function(this: unknown) {\n      if (!delegate) {\n        throw new Error(\n            `Illegal state: Class ${name} for type ${stringify(baseType)} is not compiled yet!`);\n      }\n      return delegate.apply(this, arguments);\n    };\n    proxyClass.setDelegate = (d) => {\n      delegate = d;\n      (<any>proxyClass).prototype = d.prototype;\n    };\n    // Make stringify work correctly\n    (<any>proxyClass).overriddenName = name;\n    return proxyClass;\n  }\n\n  private getGeneratedClass(dirType: any, name: string): StaticSymbol|cpl.ProxyClass {\n    if (dirType instanceof StaticSymbol) {\n      return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n    } else {\n      return this._createProxyClass(dirType, name);\n    }\n  }\n\n  private getComponentViewClass(dirType: any): StaticSymbol|cpl.ProxyClass {\n    return this.getGeneratedClass(dirType, cpl.viewClassName(dirType, 0));\n  }\n\n  getHostComponentViewClass(dirType: any): StaticSymbol|cpl.ProxyClass {\n    return this.getGeneratedClass(dirType, cpl.hostViewClassName(dirType));\n  }\n\n  getHostComponentType(dirType: any): StaticSymbol|cpl.ProxyClass {\n    const name = `${cpl.identifierName({reference: dirType})}_Host`;\n    if (dirType instanceof StaticSymbol) {\n      return this._staticSymbolCache.get(dirType.filePath, name);\n    }\n\n    return this._createProxyClass(dirType, name);\n  }\n\n  private getRendererType(dirType: any): StaticSymbol|object {\n    if (dirType instanceof StaticSymbol) {\n      return this._staticSymbolCache.get(\n          ngfactoryFilePath(dirType.filePath), cpl.rendererTypeName(dirType));\n    } else {\n      // returning an object as proxy,\n      // that we fill later during runtime compilation.\n      return <any>{};\n    }\n  }\n\n  private getComponentFactory(\n      selector: string, dirType: any, inputs: {[key: string]: string}|null,\n      outputs: {[key: string]: string}): StaticSymbol|object {\n    if (dirType instanceof StaticSymbol) {\n      return this._staticSymbolCache.get(\n          ngfactoryFilePath(dirType.filePath), cpl.componentFactoryName(dirType));\n    } else {\n      const hostView = this.getHostComponentViewClass(dirType);\n      // Note: ngContentSelectors will be filled later once the template is\n      // loaded.\n      const createComponentFactory =\n          this._reflector.resolveExternalReference(Identifiers.createComponentFactory);\n      return createComponentFactory(selector, dirType, <any>hostView, inputs, outputs, []);\n    }\n  }\n\n  private initComponentFactory(factory: StaticSymbol|object, ngContentSelectors: string[]) {\n    if (!(factory instanceof StaticSymbol)) {\n      (factory as any).ngContentSelectors.push(...ngContentSelectors);\n    }\n  }\n\n  private _loadSummary(type: any, kind: cpl.CompileSummaryKind): cpl.CompileTypeSummary|null {\n    let typeSummary = this._summaryCache.get(type);\n    if (!typeSummary) {\n      const summary = this._summaryResolver.resolveSummary(type);\n      typeSummary = summary ? summary.type : null;\n      this._summaryCache.set(type, typeSummary || null);\n    }\n    return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n  }\n\n  getHostComponentMetadata(\n      compMeta: cpl.CompileDirectiveMetadata,\n      hostViewType?: StaticSymbol|cpl.ProxyClass): cpl.CompileDirectiveMetadata {\n    const hostType = this.getHostComponentType(compMeta.type.reference);\n    if (!hostViewType) {\n      hostViewType = this.getHostComponentViewClass(hostType);\n    }\n    // Note: ! is ok here as this method should only be called with normalized directive\n    // metadata, which always fills in the selector.\n    const template = CssSelector.parse(compMeta.selector!)[0].getMatchingElementTemplate();\n    const templateUrl = '';\n    const htmlAst = this._htmlParser.parse(template, templateUrl);\n    return cpl.CompileDirectiveMetadata.create({\n      isHost: true,\n      type: {reference: hostType, diDeps: [], lifecycleHooks: []},\n      template: new cpl.CompileTemplateMetadata({\n        encapsulation: ViewEncapsulation.None,\n        template,\n        templateUrl,\n        htmlAst,\n        styles: [],\n        styleUrls: [],\n        ngContentSelectors: [],\n        animations: [],\n        isInline: true,\n        externalStylesheets: [],\n        interpolation: null,\n        preserveWhitespaces: false,\n      }),\n      exportAs: null,\n      changeDetection: ChangeDetectionStrategy.Default,\n      inputs: [],\n      outputs: [],\n      host: {},\n      isComponent: true,\n      selector: '*',\n      providers: [],\n      viewProviders: [],\n      queries: [],\n      guards: {},\n      viewQueries: [],\n      componentViewType: hostViewType,\n      rendererType: {id: '__Host__', encapsulation: ViewEncapsulation.None, styles: [], data: {}} as\n          object,\n      entryComponents: [],\n      componentFactory: null\n    });\n  }\n\n  loadDirectiveMetadata(ngModuleType: any, directiveType: any, isSync: boolean): SyncAsync<null> {\n    if (this._directiveCache.has(directiveType)) {\n      return null;\n    }\n    directiveType = resolveForwardRef(directiveType);\n    const {annotation, metadata} = this.getNonNormalizedDirectiveMetadata(directiveType)!;\n\n    const createDirectiveMetadata = (templateMetadata: cpl.CompileTemplateMetadata|null) => {\n      const normalizedDirMeta = new cpl.CompileDirectiveMetadata({\n        isHost: false,\n        type: metadata.type,\n        isComponent: metadata.isComponent,\n        selector: metadata.selector,\n        exportAs: metadata.exportAs,\n        changeDetection: metadata.changeDetection,\n        inputs: metadata.inputs,\n        outputs: metadata.outputs,\n        hostListeners: metadata.hostListeners,\n        hostProperties: metadata.hostProperties,\n        hostAttributes: metadata.hostAttributes,\n        providers: metadata.providers,\n        viewProviders: metadata.viewProviders,\n        queries: metadata.queries,\n        guards: metadata.guards,\n        viewQueries: metadata.viewQueries,\n        entryComponents: metadata.entryComponents,\n        componentViewType: metadata.componentViewType,\n        rendererType: metadata.rendererType,\n        componentFactory: metadata.componentFactory,\n        template: templateMetadata\n      });\n      if (templateMetadata) {\n        this.initComponentFactory(metadata.componentFactory!, templateMetadata.ngContentSelectors);\n      }\n      this._directiveCache.set(directiveType, normalizedDirMeta);\n      this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n      return null;\n    };\n\n    if (metadata.isComponent) {\n      const template = metadata.template !;\n      const templateMeta = this._directiveNormalizer.normalizeTemplate({\n        ngModuleType,\n        componentType: directiveType,\n        moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\n        encapsulation: template.encapsulation,\n        template: template.template,\n        templateUrl: template.templateUrl,\n        styles: template.styles,\n        styleUrls: template.styleUrls,\n        animations: template.animations,\n        interpolation: template.interpolation,\n        preserveWhitespaces: template.preserveWhitespaces\n      });\n      if (isPromise(templateMeta) && isSync) {\n        this._reportError(componentStillLoadingError(directiveType), directiveType);\n        return null;\n      }\n      return SyncAsync.then(templateMeta, createDirectiveMetadata);\n    } else {\n      // directive\n      createDirectiveMetadata(null);\n      return null;\n    }\n  }\n\n  getNonNormalizedDirectiveMetadata(directiveType: any):\n      {annotation: Directive, metadata: cpl.CompileDirectiveMetadata}|null {\n    directiveType = resolveForwardRef(directiveType);\n    if (!directiveType) {\n      return null;\n    }\n    let cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n    if (cacheEntry) {\n      return cacheEntry;\n    }\n    const dirMeta = this._directiveResolver.resolve(directiveType, false);\n    if (!dirMeta) {\n      return null;\n    }\n    let nonNormalizedTemplateMetadata: cpl.CompileTemplateMetadata = undefined!;\n\n    if (createComponent.isTypeOf(dirMeta)) {\n      // component\n      const compMeta = dirMeta as Component;\n      assertArrayOfStrings('styles', compMeta.styles);\n      assertArrayOfStrings('styleUrls', compMeta.styleUrls);\n      assertInterpolationSymbols('interpolation', compMeta.interpolation);\n\n      const animations = compMeta.animations;\n\n      nonNormalizedTemplateMetadata = new cpl.CompileTemplateMetadata({\n        encapsulation: noUndefined(compMeta.encapsulation),\n        template: noUndefined(compMeta.template),\n        templateUrl: noUndefined(compMeta.templateUrl),\n        htmlAst: null,\n        styles: compMeta.styles || [],\n        styleUrls: compMeta.styleUrls || [],\n        animations: animations || [],\n        interpolation: noUndefined(compMeta.interpolation),\n        isInline: !!compMeta.template,\n        externalStylesheets: [],\n        ngContentSelectors: [],\n        preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces),\n      });\n    }\n\n    let changeDetectionStrategy: ChangeDetectionStrategy = null!;\n    let viewProviders: cpl.CompileProviderMetadata[] = [];\n    let entryComponentMetadata: cpl.CompileEntryComponentMetadata[] = [];\n    let selector = dirMeta.selector;\n\n    if (createComponent.isTypeOf(dirMeta)) {\n      // Component\n      const compMeta = dirMeta as Component;\n      changeDetectionStrategy = compMeta.changeDetection!;\n      if (compMeta.viewProviders) {\n        viewProviders = this._getProvidersMetadata(\n            compMeta.viewProviders, entryComponentMetadata,\n            `viewProviders for \"${stringifyType(directiveType)}\"`, [], directiveType);\n      }\n      if (compMeta.entryComponents) {\n        entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents)\n                                     .map((type) => this._getEntryComponentMetadata(type)!)\n                                     .concat(entryComponentMetadata);\n      }\n      if (!selector) {\n        selector = this._schemaRegistry.getDefaultComponentElementName();\n      }\n    } else {\n      // Directive\n      if (!selector) {\n        selector = null!;\n      }\n    }\n\n    let providers: cpl.CompileProviderMetadata[] = [];\n    if (dirMeta.providers != null) {\n      providers = this._getProvidersMetadata(\n          dirMeta.providers, entryComponentMetadata,\n          `providers for \"${stringifyType(directiveType)}\"`, [], directiveType);\n    }\n    let queries: cpl.CompileQueryMetadata[] = [];\n    let viewQueries: cpl.CompileQueryMetadata[] = [];\n    if (dirMeta.queries != null) {\n      queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n      viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n    }\n\n    const metadata = cpl.CompileDirectiveMetadata.create({\n      isHost: false,\n      selector: selector,\n      exportAs: noUndefined(dirMeta.exportAs),\n      isComponent: !!nonNormalizedTemplateMetadata,\n      type: this._getTypeMetadata(directiveType),\n      template: nonNormalizedTemplateMetadata,\n      changeDetection: changeDetectionStrategy,\n      inputs: dirMeta.inputs || [],\n      outputs: dirMeta.outputs || [],\n      host: dirMeta.host || {},\n      providers: providers || [],\n      viewProviders: viewProviders || [],\n      queries: queries || [],\n      guards: dirMeta.guards || {},\n      viewQueries: viewQueries || [],\n      entryComponents: entryComponentMetadata,\n      componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\n                                                         null,\n      rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n      componentFactory: null\n    });\n    if (nonNormalizedTemplateMetadata) {\n      metadata.componentFactory =\n          this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n    }\n    cacheEntry = {metadata, annotation: dirMeta};\n    this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n    return cacheEntry;\n  }\n\n  /**\n   * Gets the metadata for the given directive.\n   * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n   */\n  getDirectiveMetadata(directiveType: any): cpl.CompileDirectiveMetadata {\n    const dirMeta = this._directiveCache.get(directiveType)!;\n    if (!dirMeta) {\n      this._reportError(\n          syntaxError(\n              `Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive ${\n                  stringifyType(directiveType)}.`),\n          directiveType);\n    }\n    return dirMeta;\n  }\n\n  getDirectiveSummary(dirType: any): cpl.CompileDirectiveSummary {\n    const dirSummary =\n        <cpl.CompileDirectiveSummary>this._loadSummary(dirType, cpl.CompileSummaryKind.Directive);\n    if (!dirSummary) {\n      this._reportError(\n          syntaxError(\n              `Illegal state: Could not load the summary for directive ${stringifyType(dirType)}.`),\n          dirType);\n    }\n    return dirSummary;\n  }\n\n  isDirective(type: any) {\n    return !!this._loadSummary(type, cpl.CompileSummaryKind.Directive) ||\n        this._directiveResolver.isDirective(type);\n  }\n\n  isAbstractDirective(type: any): boolean {\n    const summary =\n        this._loadSummary(type, cpl.CompileSummaryKind.Directive) as cpl.CompileDirectiveSummary;\n    if (summary && !summary.isComponent) {\n      return !summary.selector;\n    }\n\n    const meta = this._directiveResolver.resolve(type, false);\n    if (meta && !createComponent.isTypeOf(meta)) {\n      return !meta.selector;\n    }\n\n    return false;\n  }\n\n  isPipe(type: any) {\n    return !!this._loadSummary(type, cpl.CompileSummaryKind.Pipe) ||\n        this._pipeResolver.isPipe(type);\n  }\n\n  isNgModule(type: any) {\n    return !!this._loadSummary(type, cpl.CompileSummaryKind.NgModule) ||\n        this._ngModuleResolver.isNgModule(type);\n  }\n\n  getNgModuleSummary(moduleType: any, alreadyCollecting: Set<any>|null = null):\n      cpl.CompileNgModuleSummary|null {\n    let moduleSummary: cpl.CompileNgModuleSummary|null =\n        <cpl.CompileNgModuleSummary>this._loadSummary(moduleType, cpl.CompileSummaryKind.NgModule);\n    if (!moduleSummary) {\n      const moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);\n      moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n      if (moduleSummary) {\n        this._summaryCache.set(moduleType, moduleSummary);\n      }\n    }\n    return moduleSummary;\n  }\n\n  /**\n   * Loads the declared directives and pipes of an NgModule.\n   */\n  loadNgModuleDirectiveAndPipeMetadata(moduleType: any, isSync: boolean, throwIfNotFound = true):\n      Promise<any> {\n    const ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n    const loading: Promise<any>[] = [];\n    if (ngModule) {\n      ngModule.declaredDirectives.forEach((id) => {\n        const promise = this.loadDirectiveMetadata(moduleType, id.reference, isSync);\n        if (promise) {\n          loading.push(promise);\n        }\n      });\n      ngModule.declaredPipes.forEach((id) => this._loadPipeMetadata(id.reference));\n    }\n    return Promise.all(loading);\n  }\n\n  getShallowModuleMetadata(moduleType: any): cpl.CompileShallowModuleMetadata|null {\n    let compileMeta = this._shallowModuleCache.get(moduleType);\n    if (compileMeta) {\n      return compileMeta;\n    }\n\n    const ngModuleMeta =\n        findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);\n\n    compileMeta = {\n      type: this._getTypeMetadata(moduleType),\n      rawExports: ngModuleMeta.exports,\n      rawImports: ngModuleMeta.imports,\n      rawProviders: ngModuleMeta.providers,\n    };\n\n    this._shallowModuleCache.set(moduleType, compileMeta);\n    return compileMeta;\n  }\n\n  getNgModuleMetadata(\n      moduleType: any, throwIfNotFound = true,\n      alreadyCollecting: Set<any>|null = null): cpl.CompileNgModuleMetadata|null {\n    moduleType = resolveForwardRef(moduleType);\n    let compileMeta = this._ngModuleCache.get(moduleType);\n    if (compileMeta) {\n      return compileMeta;\n    }\n    const meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n    if (!meta) {\n      return null;\n    }\n    const declaredDirectives: cpl.CompileIdentifierMetadata[] = [];\n    const exportedNonModuleIdentifiers: cpl.CompileIdentifierMetadata[] = [];\n    const declaredPipes: cpl.CompileIdentifierMetadata[] = [];\n    const importedModules: cpl.CompileNgModuleSummary[] = [];\n    const exportedModules: cpl.CompileNgModuleSummary[] = [];\n    const providers: cpl.CompileProviderMetadata[] = [];\n    const entryComponents: cpl.CompileEntryComponentMetadata[] = [];\n    const bootstrapComponents: cpl.CompileIdentifierMetadata[] = [];\n    const schemas: SchemaMetadata[] = [];\n\n    if (meta.imports) {\n      flattenAndDedupeArray(meta.imports).forEach((importedType) => {\n        let importedModuleType: Type = undefined!;\n        if (isValidType(importedType)) {\n          importedModuleType = importedType;\n        } else if (importedType && importedType.ngModule) {\n          const moduleWithProviders: ModuleWithProviders = importedType;\n          importedModuleType = moduleWithProviders.ngModule;\n          if (moduleWithProviders.providers) {\n            providers.push(...this._getProvidersMetadata(\n                moduleWithProviders.providers, entryComponents,\n                `provider for the NgModule '${stringifyType(importedModuleType)}'`, [],\n                importedType));\n          }\n        }\n\n        if (importedModuleType) {\n          if (this._checkSelfImport(moduleType, importedModuleType)) return;\n          if (!alreadyCollecting) alreadyCollecting = new Set();\n          if (alreadyCollecting.has(importedModuleType)) {\n            this._reportError(\n                syntaxError(`${this._getTypeDescriptor(importedModuleType)} '${\n                    stringifyType(importedType)}' is imported recursively by the module '${\n                    stringifyType(moduleType)}'.`),\n                moduleType);\n            return;\n          }\n          alreadyCollecting.add(importedModuleType);\n          const importedModuleSummary =\n              this.getNgModuleSummary(importedModuleType, alreadyCollecting);\n          alreadyCollecting.delete(importedModuleType);\n          if (!importedModuleSummary) {\n            const err = syntaxError(`Unexpected ${this._getTypeDescriptor(importedType)} '${\n                stringifyType(importedType)}' imported by the module '${\n                stringifyType(moduleType)}'. Please add a @NgModule annotation.`);\n            // If possible, record additional context for this error to enable more useful\n            // diagnostics on the compiler side.\n            if (importedType instanceof StaticSymbol) {\n              (err as any)[MISSING_NG_MODULE_METADATA_ERROR_DATA] = {\n                fileName: importedType.filePath,\n                className: importedType.name,\n              } as MissingNgModuleMetadataErrorData;\n            }\n            this._reportError(err, moduleType);\n            return;\n          }\n          importedModules.push(importedModuleSummary);\n        } else {\n          this._reportError(\n              syntaxError(\n                  `Unexpected value '${stringifyType(importedType)}' imported by the module '${\n                      stringifyType(moduleType)}'`),\n              moduleType);\n          return;\n        }\n      });\n    }\n\n    if (meta.exports) {\n      flattenAndDedupeArray(meta.exports).forEach((exportedType) => {\n        if (!isValidType(exportedType)) {\n          this._reportError(\n              syntaxError(\n                  `Unexpected value '${stringifyType(exportedType)}' exported by the module '${\n                      stringifyType(moduleType)}'`),\n              moduleType);\n          return;\n        }\n        if (!alreadyCollecting) alreadyCollecting = new Set();\n        if (alreadyCollecting.has(exportedType)) {\n          this._reportError(\n              syntaxError(`${this._getTypeDescriptor(exportedType)} '${\n                  stringify(exportedType)}' is exported recursively by the module '${\n                  stringifyType(moduleType)}'`),\n              moduleType);\n          return;\n        }\n        alreadyCollecting.add(exportedType);\n        const exportedModuleSummary = this.getNgModuleSummary(exportedType, alreadyCollecting);\n        alreadyCollecting.delete(exportedType);\n        if (exportedModuleSummary) {\n          exportedModules.push(exportedModuleSummary);\n        } else {\n          exportedNonModuleIdentifiers.push(this._getIdentifierMetadata(exportedType));\n        }\n      });\n    }\n\n    // Note: This will be modified later, so we rely on\n    // getting a new instance every time!\n    const transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n    if (meta.declarations) {\n      flattenAndDedupeArray(meta.declarations).forEach((declaredType) => {\n        if (!isValidType(declaredType)) {\n          this._reportError(\n              syntaxError(\n                  `Unexpected value '${stringifyType(declaredType)}' declared by the module '${\n                      stringifyType(moduleType)}'`),\n              moduleType);\n          return;\n        }\n        const declaredIdentifier = this._getIdentifierMetadata(declaredType);\n        if (this.isDirective(declaredType)) {\n          if (this.isAbstractDirective(declaredType)) {\n            this._reportError(\n                syntaxError(\n                    `Directive ${stringifyType(declaredType)} has no selector, please add it!`),\n                declaredType);\n          }\n          transitiveModule.addDirective(declaredIdentifier);\n          declaredDirectives.push(declaredIdentifier);\n          this._addTypeToModule(declaredType, moduleType);\n        } else if (this.isPipe(declaredType)) {\n          transitiveModule.addPipe(declaredIdentifier);\n          transitiveModule.pipes.push(declaredIdentifier);\n          declaredPipes.push(declaredIdentifier);\n          this._addTypeToModule(declaredType, moduleType);\n        } else {\n          this._reportError(\n              syntaxError(`Unexpected ${this._getTypeDescriptor(declaredType)} '${\n                  stringifyType(declaredType)}' declared by the module '${\n                  stringifyType(\n                      moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`),\n              moduleType);\n          return;\n        }\n      });\n    }\n\n    const exportedDirectives: cpl.CompileIdentifierMetadata[] = [];\n    const exportedPipes: cpl.CompileIdentifierMetadata[] = [];\n    exportedNonModuleIdentifiers.forEach((exportedId) => {\n      if (transitiveModule.directivesSet.has(exportedId.reference)) {\n        exportedDirectives.push(exportedId);\n        transitiveModule.addExportedDirective(exportedId);\n      } else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n        exportedPipes.push(exportedId);\n        transitiveModule.addExportedPipe(exportedId);\n      } else {\n        this._reportError(\n            syntaxError(`Can't export ${this._getTypeDescriptor(exportedId.reference)} ${\n                stringifyType(exportedId.reference)} from ${\n                stringifyType(moduleType)} as it was neither declared nor imported!`),\n            moduleType);\n        return;\n      }\n    });\n\n    // The providers of the module have to go last\n    // so that they overwrite any other provider we already added.\n    if (meta.providers) {\n      providers.push(...this._getProvidersMetadata(\n          meta.providers, entryComponents,\n          `provider for the NgModule '${stringifyType(moduleType)}'`, [], moduleType));\n    }\n\n    if (meta.entryComponents) {\n      entryComponents.push(...flattenAndDedupeArray(meta.entryComponents)\n                               .map(type => this._getEntryComponentMetadata(type)!));\n    }\n\n    if (meta.bootstrap) {\n      flattenAndDedupeArray(meta.bootstrap).forEach(type => {\n        if (!isValidType(type)) {\n          this._reportError(\n              syntaxError(`Unexpected value '${\n                  stringifyType(type)}' used in the bootstrap property of module '${\n                  stringifyType(moduleType)}'`),\n              moduleType);\n          return;\n        }\n        bootstrapComponents.push(this._getIdentifierMetadata(type));\n      });\n    }\n\n    entryComponents.push(\n        ...bootstrapComponents.map(type => this._getEntryComponentMetadata(type.reference)!));\n\n    if (meta.schemas) {\n      schemas.push(...flattenAndDedupeArray(meta.schemas));\n    }\n\n    compileMeta = new cpl.CompileNgModuleMetadata({\n      type: this._getTypeMetadata(moduleType),\n      providers,\n      entryComponents,\n      bootstrapComponents,\n      schemas,\n      declaredDirectives,\n      exportedDirectives,\n      declaredPipes,\n      exportedPipes,\n      importedModules,\n      exportedModules,\n      transitiveModule,\n      id: meta.id || null,\n    });\n\n    entryComponents.forEach((id) => transitiveModule.addEntryComponent(id));\n    providers.forEach((provider) => transitiveModule.addProvider(provider, compileMeta!.type));\n    transitiveModule.addModule(compileMeta.type);\n    this._ngModuleCache.set(moduleType, compileMeta);\n    return compileMeta;\n  }\n\n  private _checkSelfImport(moduleType: Type, importedModuleType: Type): boolean {\n    if (moduleType === importedModuleType) {\n      this._reportError(\n          syntaxError(`'${stringifyType(moduleType)}' module can't import itself`), moduleType);\n      return true;\n    }\n    return false;\n  }\n\n  private _getTypeDescriptor(type: Type): string {\n    if (isValidType(type)) {\n      if (this.isDirective(type)) {\n        return 'directive';\n      }\n\n      if (this.isPipe(type)) {\n        return 'pipe';\n      }\n\n      if (this.isNgModule(type)) {\n        return 'module';\n      }\n    }\n\n    if ((type as any).provide) {\n      return 'provider';\n    }\n\n    return 'value';\n  }\n\n\n  private _addTypeToModule(type: Type, moduleType: Type) {\n    const oldModule = this._ngModuleOfTypes.get(type);\n    if (oldModule && oldModule !== moduleType) {\n      this._reportError(\n          syntaxError(\n              `Type ${stringifyType(type)} is part of the declarations of 2 modules: ${\n                  stringifyType(oldModule)} and ${stringifyType(moduleType)}! ` +\n              `Please consider moving ${stringifyType(type)} to a higher module that imports ${\n                  stringifyType(oldModule)} and ${stringifyType(moduleType)}. ` +\n              `You can also create a new NgModule that exports and includes ${\n                  stringifyType(type)} then import that NgModule in ${\n                  stringifyType(oldModule)} and ${stringifyType(moduleType)}.`),\n          moduleType);\n      return;\n    }\n    this._ngModuleOfTypes.set(type, moduleType);\n  }\n\n  private _getTransitiveNgModuleMetadata(\n      importedModules: cpl.CompileNgModuleSummary[],\n      exportedModules: cpl.CompileNgModuleSummary[]): cpl.TransitiveCompileNgModuleMetadata {\n    // collect `providers` / `entryComponents` from all imported and all exported modules\n    const result = new cpl.TransitiveCompileNgModuleMetadata();\n    const modulesByToken = new Map<any, Set<any>>();\n    importedModules.concat(exportedModules).forEach((modSummary) => {\n      modSummary.modules.forEach((mod) => result.addModule(mod));\n      modSummary.entryComponents.forEach((comp) => result.addEntryComponent(comp));\n      const addedTokens = new Set<any>();\n      modSummary.providers.forEach((entry) => {\n        const tokenRef = cpl.tokenReference(entry.provider.token);\n        let prevModules = modulesByToken.get(tokenRef);\n        if (!prevModules) {\n          prevModules = new Set<any>();\n          modulesByToken.set(tokenRef, prevModules);\n        }\n        const moduleRef = entry.module.reference;\n        // Note: the providers of one module may still contain multiple providers\n        // per token (e.g. for multi providers), and we need to preserve these.\n        if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n          prevModules.add(moduleRef);\n          addedTokens.add(tokenRef);\n          result.addProvider(entry.provider, entry.module);\n        }\n      });\n    });\n    exportedModules.forEach((modSummary) => {\n      modSummary.exportedDirectives.forEach((id) => result.addExportedDirective(id));\n      modSummary.exportedPipes.forEach((id) => result.addExportedPipe(id));\n    });\n    importedModules.forEach((modSummary) => {\n      modSummary.exportedDirectives.forEach((id) => result.addDirective(id));\n      modSummary.exportedPipes.forEach((id) => result.addPipe(id));\n    });\n    return result;\n  }\n\n  private _getIdentifierMetadata(type: Type): cpl.CompileIdentifierMetadata {\n    type = resolveForwardRef(type);\n    return {reference: type};\n  }\n\n  isInjectable(type: any): boolean {\n    const annotations = this._reflector.tryAnnotations(type);\n    return annotations.some(ann => createInjectable.isTypeOf(ann));\n  }\n\n  getInjectableSummary(type: any): cpl.CompileTypeSummary {\n    return {\n      summaryKind: cpl.CompileSummaryKind.Injectable,\n      type: this._getTypeMetadata(type, null, false)\n    };\n  }\n\n  getInjectableMetadata(\n      type: any, dependencies: any[]|null = null,\n      throwOnUnknownDeps: boolean = true): cpl.CompileInjectableMetadata|null {\n    const typeSummary = this._loadSummary(type, cpl.CompileSummaryKind.Injectable);\n    const typeMetadata = typeSummary ?\n        typeSummary.type :\n        this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);\n\n    const annotations: Injectable[] =\n        this._reflector.annotations(type).filter(ann => createInjectable.isTypeOf(ann));\n\n    if (annotations.length === 0) {\n      return null;\n    }\n\n    const meta = annotations[annotations.length - 1];\n    return {\n      symbol: type,\n      type: typeMetadata,\n      providedIn: meta.providedIn,\n      useValue: meta.useValue,\n      useClass: meta.useClass,\n      useExisting: meta.useExisting,\n      useFactory: meta.useFactory,\n      deps: meta.deps,\n    };\n  }\n\n  private _getTypeMetadata(type: Type, dependencies: any[]|null = null, throwOnUnknownDeps = true):\n      cpl.CompileTypeMetadata {\n    const identifier = this._getIdentifierMetadata(type);\n    return {\n      reference: identifier.reference,\n      diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n      lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),\n    };\n  }\n\n  private _getFactoryMetadata(factory: Function, dependencies: any[]|null = null):\n      cpl.CompileFactoryMetadata {\n    factory = resolveForwardRef(factory);\n    return {reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies)};\n  }\n\n  /**\n   * Gets the metadata for the given pipe.\n   * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\n   */\n  getPipeMetadata(pipeType: any): cpl.CompilePipeMetadata|null {\n    const pipeMeta = this._pipeCache.get(pipeType);\n    if (!pipeMeta) {\n      this._reportError(\n          syntaxError(\n              `Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe ${\n                  stringifyType(pipeType)}.`),\n          pipeType);\n    }\n    return pipeMeta || null;\n  }\n\n  getPipeSummary(pipeType: any): cpl.CompilePipeSummary {\n    const pipeSummary =\n        <cpl.CompilePipeSummary>this._loadSummary(pipeType, cpl.CompileSummaryKind.Pipe);\n    if (!pipeSummary) {\n      this._reportError(\n          syntaxError(\n              `Illegal state: Could not load the summary for pipe ${stringifyType(pipeType)}.`),\n          pipeType);\n    }\n    return pipeSummary;\n  }\n\n  getOrLoadPipeMetadata(pipeType: any): cpl.CompilePipeMetadata {\n    let pipeMeta = this._pipeCache.get(pipeType);\n    if (!pipeMeta) {\n      pipeMeta = this._loadPipeMetadata(pipeType);\n    }\n    return pipeMeta;\n  }\n\n  private _loadPipeMetadata(pipeType: any): cpl.CompilePipeMetadata {\n    pipeType = resolveForwardRef(pipeType);\n    const pipeAnnotation = this._pipeResolver.resolve(pipeType)!;\n\n    const pipeMeta = new cpl.CompilePipeMetadata({\n      type: this._getTypeMetadata(pipeType),\n      name: pipeAnnotation.name,\n      pure: !!pipeAnnotation.pure\n    });\n    this._pipeCache.set(pipeType, pipeMeta);\n    this._summaryCache.set(pipeType, pipeMeta.toSummary());\n    return pipeMeta;\n  }\n\n  private _getDependenciesMetadata(\n      typeOrFunc: Type|Function, dependencies: any[]|null,\n      throwOnUnknownDeps = true): cpl.CompileDiDependencyMetadata[] {\n    let hasUnknownDeps = false;\n    const params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n\n    const dependenciesMetadata: cpl.CompileDiDependencyMetadata[] = params.map((param) => {\n      let isAttribute = false;\n      let isHost = false;\n      let isSelf = false;\n      let isSkipSelf = false;\n      let isOptional = false;\n      let token: any = null;\n      if (Array.isArray(param)) {\n        param.forEach((paramEntry: any) => {\n          if (createHost.isTypeOf(paramEntry)) {\n            isHost = true;\n          } else if (createSelf.isTypeOf(paramEntry)) {\n            isSelf = true;\n          } else if (createSkipSelf.isTypeOf(paramEntry)) {\n            isSkipSelf = true;\n          } else if (createOptional.isTypeOf(paramEntry)) {\n            isOptional = true;\n          } else if (createAttribute.isTypeOf(paramEntry)) {\n            isAttribute = true;\n            token = (paramEntry as any).attributeName;\n          } else if (createInject.isTypeOf(paramEntry)) {\n            token = (paramEntry as any).token;\n          } else if (\n              createInjectionToken.isTypeOf(paramEntry) ||\n              (paramEntry as any) instanceof StaticSymbol) {\n            token = paramEntry;\n          } else if (isValidType(paramEntry) && token == null) {\n            token = paramEntry;\n          }\n        });\n      } else {\n        token = param;\n      }\n      if (token == null) {\n        hasUnknownDeps = true;\n        return {};\n      }\n\n      return {\n        isAttribute,\n        isHost,\n        isSelf,\n        isSkipSelf,\n        isOptional,\n        token: this._getTokenMetadata(token)\n      };\n    });\n\n    if (hasUnknownDeps) {\n      const depsTokens =\n          dependenciesMetadata.map((dep) => dep.token ? stringifyType(dep.token) : '?').join(', ');\n      const message =\n          `Can't resolve all parameters for ${stringifyType(typeOrFunc)}: (${depsTokens}).`;\n      if (throwOnUnknownDeps || this._config.strictInjectionParameters) {\n        this._reportError(syntaxError(message), typeOrFunc);\n      }\n    }\n\n    return dependenciesMetadata;\n  }\n\n  private _getTokenMetadata(token: any): cpl.CompileTokenMetadata {\n    token = resolveForwardRef(token);\n    let compileToken: cpl.CompileTokenMetadata;\n    if (typeof token === 'string') {\n      compileToken = {value: token};\n    } else {\n      compileToken = {identifier: {reference: token}};\n    }\n    return compileToken;\n  }\n\n  private _getProvidersMetadata(\n      providers: Provider[], targetEntryComponents: cpl.CompileEntryComponentMetadata[],\n      debugInfo?: string, compileProviders: cpl.CompileProviderMetadata[] = [],\n      type?: any): cpl.CompileProviderMetadata[] {\n    providers.forEach((provider: any, providerIdx: number) => {\n      if (Array.isArray(provider)) {\n        this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n      } else {\n        provider = resolveForwardRef(provider);\n        let providerMeta: cpl.ProviderMeta = undefined!;\n        if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n          this._validateProvider(provider);\n          providerMeta = new cpl.ProviderMeta(provider.provide, provider);\n        } else if (isValidType(provider)) {\n          providerMeta = new cpl.ProviderMeta(provider, {useClass: provider});\n        } else if (provider === void 0) {\n          this._reportError(syntaxError(\n              `Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.`));\n          return;\n        } else {\n          const providersInfo =\n              providers\n                  .reduce(\n                      (soFar: string[], seenProvider: any, seenProviderIdx: number) => {\n                        if (seenProviderIdx < providerIdx) {\n                          soFar.push(`${stringifyType(seenProvider)}`);\n                        } else if (seenProviderIdx == providerIdx) {\n                          soFar.push(`?${stringifyType(seenProvider)}?`);\n                        } else if (seenProviderIdx == providerIdx + 1) {\n                          soFar.push('...');\n                        }\n                        return soFar;\n                      },\n                      [])\n                  .join(', ');\n          this._reportError(\n              syntaxError(`Invalid ${\n                  debugInfo ?\n                      debugInfo :\n                      'provider'} - only instances of Provider and Type are allowed, got: [${\n                  providersInfo}]`),\n              type);\n          return;\n        }\n        if (providerMeta.token ===\n            this._reflector.resolveExternalReference(Identifiers.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n          targetEntryComponents.push(...this._getEntryComponentsFromProvider(providerMeta, type));\n        } else {\n          compileProviders.push(this.getProviderMetadata(providerMeta));\n        }\n      }\n    });\n    return compileProviders;\n  }\n\n  private _validateProvider(provider: any): void {\n    if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n      this._reportError(syntaxError(`Invalid provider for ${\n          stringifyType(provider.provide)}. useClass cannot be ${provider.useClass}.\n           Usually it happens when:\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\n           2. Class was used before it was declared. Use forwardRef in this case.`));\n    }\n  }\n\n  private _getEntryComponentsFromProvider(provider: cpl.ProviderMeta, type?: any):\n      cpl.CompileEntryComponentMetadata[] {\n    const components: cpl.CompileEntryComponentMetadata[] = [];\n    const collectedIdentifiers: cpl.CompileIdentifierMetadata[] = [];\n\n    if (provider.useFactory || provider.useExisting || provider.useClass) {\n      this._reportError(\n          syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!`), type);\n      return [];\n    }\n\n    if (!provider.multi) {\n      this._reportError(\n          syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!`),\n          type);\n      return [];\n    }\n\n    extractIdentifiers(provider.useValue, collectedIdentifiers);\n    collectedIdentifiers.forEach((identifier) => {\n      const entry = this._getEntryComponentMetadata(identifier.reference, false);\n      if (entry) {\n        components.push(entry);\n      }\n    });\n    return components;\n  }\n\n  private _getEntryComponentMetadata(dirType: any, throwIfNotFound = true):\n      cpl.CompileEntryComponentMetadata|null {\n    const dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n    if (dirMeta && dirMeta.metadata.isComponent) {\n      return {componentType: dirType, componentFactory: dirMeta.metadata.componentFactory!};\n    }\n    const dirSummary =\n        <cpl.CompileDirectiveSummary>this._loadSummary(dirType, cpl.CompileSummaryKind.Directive);\n    if (dirSummary && dirSummary.isComponent) {\n      return {componentType: dirType, componentFactory: dirSummary.componentFactory!};\n    }\n    if (throwIfNotFound) {\n      throw syntaxError(`${dirType.name} cannot be used as an entry component.`);\n    }\n    return null;\n  }\n\n  private _getInjectableTypeMetadata(type: Type, dependencies: any[]|null = null):\n      cpl.CompileTypeMetadata {\n    const typeSummary = this._loadSummary(type, cpl.CompileSummaryKind.Injectable);\n    if (typeSummary) {\n      return typeSummary.type;\n    }\n    return this._getTypeMetadata(type, dependencies);\n  }\n\n  getProviderMetadata(provider: cpl.ProviderMeta): cpl.CompileProviderMetadata {\n    let compileDeps: cpl.CompileDiDependencyMetadata[] = undefined!;\n    let compileTypeMetadata: cpl.CompileTypeMetadata = null!;\n    let compileFactoryMetadata: cpl.CompileFactoryMetadata = null!;\n    let token: cpl.CompileTokenMetadata = this._getTokenMetadata(provider.token);\n\n    if (provider.useClass) {\n      compileTypeMetadata =\n          this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);\n      compileDeps = compileTypeMetadata.diDeps;\n      if (provider.token === provider.useClass) {\n        // use the compileTypeMetadata as it contains information about lifecycleHooks...\n        token = {identifier: compileTypeMetadata};\n      }\n    } else if (provider.useFactory) {\n      compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n      compileDeps = compileFactoryMetadata.diDeps;\n    }\n\n    return {\n      token: token,\n      useClass: compileTypeMetadata,\n      useValue: provider.useValue,\n      useFactory: compileFactoryMetadata,\n      useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n      deps: compileDeps,\n      multi: provider.multi\n    };\n  }\n\n  private _getQueriesMetadata(\n      queries: {[key: string]: Query}, isViewQuery: boolean,\n      directiveType: Type): cpl.CompileQueryMetadata[] {\n    const res: cpl.CompileQueryMetadata[] = [];\n\n    Object.keys(queries).forEach((propertyName: string) => {\n      const query = queries[propertyName];\n      if (query.isViewQuery === isViewQuery) {\n        res.push(this._getQueryMetadata(query, propertyName, directiveType));\n      }\n    });\n\n    return res;\n  }\n\n  private _queryVarBindings(selector: any): string[] {\n    return selector.split(/\\s*,\\s*/);\n  }\n\n  private _getQueryMetadata(q: Query, propertyName: string, typeOrFunc: Type|Function):\n      cpl.CompileQueryMetadata {\n    let selectors: cpl.CompileTokenMetadata[];\n    if (typeof q.selector === 'string') {\n      selectors =\n          this._queryVarBindings(q.selector).map(varName => this._getTokenMetadata(varName));\n    } else {\n      if (!q.selector) {\n        this._reportError(\n            syntaxError(`Can't construct a query for the property \"${propertyName}\" of \"${\n                stringifyType(typeOrFunc)}\" since the query selector wasn't defined.`),\n            typeOrFunc);\n        selectors = [];\n      } else {\n        selectors = [this._getTokenMetadata(q.selector)];\n      }\n    }\n\n    return {\n      selectors,\n      first: q.first,\n      descendants: q.descendants,\n      emitDistinctChangesOnly: q.emitDistinctChangesOnly,\n      propertyName,\n      read: q.read ? this._getTokenMetadata(q.read) : null!,\n      static: q.static\n    };\n  }\n\n  private _reportError(error: any, type?: any, otherType?: any) {\n    if (this._errorCollector) {\n      this._errorCollector(error, type);\n      if (otherType) {\n        this._errorCollector(error, otherType);\n      }\n    } else {\n      throw error;\n    }\n  }\n}\n\nfunction flattenArray(tree: any[], out: Array<any> = []): Array<any> {\n  if (tree) {\n    for (let i = 0; i < tree.length; i++) {\n      const item = resolveForwardRef(tree[i]);\n      if (Array.isArray(item)) {\n        flattenArray(item, out);\n      } else {\n        out.push(item);\n      }\n    }\n  }\n  return out;\n}\n\nfunction dedupeArray(array: any[]): Array<any> {\n  if (array) {\n    return Array.from(new Set(array));\n  }\n  return [];\n}\n\nfunction flattenAndDedupeArray(tree: any[]): Array<any> {\n  return dedupeArray(flattenArray(tree));\n}\n\nfunction isValidType(value: any): boolean {\n  return (value instanceof StaticSymbol) || (value instanceof Type);\n}\n\nfunction extractIdentifiers(value: any, targetIdentifiers: cpl.CompileIdentifierMetadata[]) {\n  visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\n\nclass _CompileValueConverter extends ValueTransformer {\n  visitOther(value: any, targetIdentifiers: cpl.CompileIdentifierMetadata[]): any {\n    targetIdentifiers.push({reference: value});\n  }\n}\n\nfunction stringifyType(type: any): string {\n  if (type instanceof StaticSymbol) {\n    return `${type.name} in ${type.filePath}`;\n  } else {\n    return stringify(type);\n  }\n}\n\n/**\n * Indicates that a component is still being loaded in a synchronous compile.\n */\nfunction componentStillLoadingError(compType: Type) {\n  const error =\n      Error(`Can't compile synchronously as ${stringify(compType)} is still being loaded!`);\n  (error as any)[ERROR_COMPONENT_TYPE] = compType;\n  return error;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}