{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJson = exports.parseJsonAst = exports.JsonParseMode = exports.PathSpecificJsonException = exports.UnexpectedEndOfInputException = exports.InvalidJsonCharacterException = exports.JsonException = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar exception_1 = require(\"../exception\");\n\nvar JsonException = /*#__PURE__*/function (_exception_1$BaseExce) {\n  _inherits(JsonException, _exception_1$BaseExce);\n\n  var _super = _createSuper(JsonException);\n\n  function JsonException() {\n    _classCallCheck(this, JsonException);\n\n    return _super.apply(this, arguments);\n  }\n\n  return JsonException;\n}(exception_1.BaseException);\n\nexports.JsonException = JsonException;\n/**\n * A character was invalid in this context.\n */\n\nvar InvalidJsonCharacterException = /*#__PURE__*/function (_JsonException) {\n  _inherits(InvalidJsonCharacterException, _JsonException);\n\n  var _super2 = _createSuper(InvalidJsonCharacterException);\n\n  function InvalidJsonCharacterException(context) {\n    var _this;\n\n    _classCallCheck(this, InvalidJsonCharacterException);\n\n    var pos = context.previous;\n    var invalidChar = JSON.stringify(_peek(context));\n    _this = _super2.call(this, \"Invalid JSON character: \".concat(invalidChar, \" at \").concat(pos.line, \":\").concat(pos.character, \".\"));\n    _this.invalidChar = invalidChar;\n    _this.line = pos.line;\n    _this.offset = pos.offset;\n    _this.character = pos.character;\n    return _this;\n  }\n\n  return InvalidJsonCharacterException;\n}(JsonException);\n\nexports.InvalidJsonCharacterException = InvalidJsonCharacterException;\n/**\n * More input was expected, but we reached the end of the stream.\n */\n\nvar UnexpectedEndOfInputException = /*#__PURE__*/function (_JsonException2) {\n  _inherits(UnexpectedEndOfInputException, _JsonException2);\n\n  var _super3 = _createSuper(UnexpectedEndOfInputException);\n\n  function UnexpectedEndOfInputException(_context) {\n    _classCallCheck(this, UnexpectedEndOfInputException);\n\n    return _super3.call(this, \"Unexpected end of file.\");\n  }\n\n  return UnexpectedEndOfInputException;\n}(JsonException);\n\nexports.UnexpectedEndOfInputException = UnexpectedEndOfInputException;\n/**\n * An error happened within a file.\n */\n\nvar PathSpecificJsonException = /*#__PURE__*/function (_JsonException3) {\n  _inherits(PathSpecificJsonException, _JsonException3);\n\n  var _super4 = _createSuper(PathSpecificJsonException);\n\n  function PathSpecificJsonException(path, exception) {\n    var _this2;\n\n    _classCallCheck(this, PathSpecificJsonException);\n\n    _this2 = _super4.call(this, \"An error happened at file path \".concat(JSON.stringify(path), \": \").concat(exception.message));\n    _this2.path = path;\n    _this2.exception = exception;\n    return _this2;\n  }\n\n  return PathSpecificJsonException;\n}(JsonException);\n\nexports.PathSpecificJsonException = PathSpecificJsonException;\n/**\n * Peek and return the next character from the context.\n * @private\n */\n\nfunction _peek(context) {\n  return context.original[context.position.offset];\n}\n/**\n * Move the context to the next character, including incrementing the line if necessary.\n * @private\n */\n\n\nfunction _next(context) {\n  context.previous = context.position;\n  var _context$position = context.position,\n      offset = _context$position.offset,\n      line = _context$position.line,\n      character = _context$position.character;\n  var char = context.original[offset];\n  offset++;\n\n  if (char == '\\n') {\n    line++;\n    character = 0;\n  } else {\n    character++;\n  }\n\n  context.position = {\n    offset: offset,\n    line: line,\n    character: character\n  };\n}\n\nfunction _token(context, valid) {\n  var char = _peek(context);\n\n  if (valid) {\n    if (!char) {\n      throw new UnexpectedEndOfInputException(context);\n    }\n\n    if (valid.indexOf(char) == -1) {\n      throw new InvalidJsonCharacterException(context);\n    }\n  } // Move the position of the context to the next character.\n\n\n  _next(context);\n\n  return char;\n}\n/**\n * Read the exponent part of a number. The exponent part is looser for JSON than the number\n * part. `str` is the string of the number itself found so far, and start the position\n * where the full number started. Returns the node found.\n * @private\n */\n\n\nfunction _readExpNumber(context, start, str, comments) {\n  var char;\n  var signed = false;\n\n  while (true) {\n    char = _token(context);\n\n    if (char == '+' || char == '-') {\n      if (signed) {\n        break;\n      }\n\n      signed = true;\n      str += char;\n    } else if (char == '0' || char == '1' || char == '2' || char == '3' || char == '4' || char == '5' || char == '6' || char == '7' || char == '8' || char == '9') {\n      signed = true;\n      str += char;\n    } else {\n      break;\n    }\n  } // We're done reading this number.\n\n\n  context.position = context.previous;\n  return {\n    kind: 'number',\n    start: start,\n    end: context.position,\n    text: context.original.substring(start.offset, context.position.offset),\n    value: Number.parseFloat(str),\n    comments: comments\n  };\n}\n/**\n * Read the hexa part of a 0xBADCAFE hexadecimal number.\n * @private\n */\n\n\nfunction _readHexaNumber(context, isNegative, start, comments) {\n  // Read an hexadecimal number, until it's not hexadecimal.\n  var hexa = '';\n  var valid = '0123456789abcdefABCDEF';\n\n  for (var ch = _peek(context); ch && valid.includes(ch); ch = _peek(context)) {\n    // Add it to the hexa string.\n    hexa += ch; // Move the position of the context to the next character.\n\n    _next(context);\n  }\n\n  var value = Number.parseInt(hexa, 16); // We're done reading this number.\n\n  return {\n    kind: 'number',\n    start: start,\n    end: context.position,\n    text: context.original.substring(start.offset, context.position.offset),\n    value: isNegative ? -value : value,\n    comments: comments\n  };\n}\n/**\n * Read a number from the context.\n * @private\n */\n\n\nfunction _readNumber(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var str = '';\n  var dotted = false;\n  var start = context.position; // read until `e` or end of line.\n\n  while (true) {\n    var char = _token(context); // Read tokens, one by one.\n\n\n    if (char == '-') {\n      if (str != '') {\n        throw new InvalidJsonCharacterException(context);\n      }\n    } else if (char == 'I' && (str == '-' || str == '' || str == '+') && (context.mode & JsonParseMode.NumberConstantsAllowed) != 0) {\n      // Infinity?\n      // _token(context, 'I'); Already read.\n      _token(context, 'n');\n\n      _token(context, 'f');\n\n      _token(context, 'i');\n\n      _token(context, 'n');\n\n      _token(context, 'i');\n\n      _token(context, 't');\n\n      _token(context, 'y');\n\n      str += 'Infinity';\n      break;\n    } else if (char == '0') {\n      if (str == '0' || str == '-0') {\n        throw new InvalidJsonCharacterException(context);\n      }\n    } else if (char == '1' || char == '2' || char == '3' || char == '4' || char == '5' || char == '6' || char == '7' || char == '8' || char == '9') {\n      if (str == '0' || str == '-0') {\n        throw new InvalidJsonCharacterException(context);\n      }\n    } else if (char == '+' && str == '') {// Pass over.\n    } else if (char == '.') {\n      if (dotted) {\n        throw new InvalidJsonCharacterException(context);\n      }\n\n      dotted = true;\n    } else if (char == 'e' || char == 'E') {\n      return _readExpNumber(context, start, str + char, comments);\n    } else if (char == 'x' && (str == '0' || str == '-0') && (context.mode & JsonParseMode.HexadecimalNumberAllowed) != 0) {\n      return _readHexaNumber(context, str == '-0', start, comments);\n    } else {\n      // We read one too many characters, so rollback the last character.\n      context.position = context.previous;\n      break;\n    }\n\n    str += char;\n  } // We're done reading this number.\n\n\n  if (str.endsWith('.') && (context.mode & JsonParseMode.HexadecimalNumberAllowed) == 0) {\n    throw new InvalidJsonCharacterException(context);\n  }\n\n  return {\n    kind: 'number',\n    start: start,\n    end: context.position,\n    text: context.original.substring(start.offset, context.position.offset),\n    value: Number.parseFloat(str),\n    comments: comments\n  };\n}\n/**\n * Read a string from the context. Takes the comments of the string or read the blanks before the\n * string.\n * @private\n */\n\n\nfunction _readString(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position; // Consume the first string delimiter.\n\n  var delim = _token(context);\n\n  if ((context.mode & JsonParseMode.SingleQuotesAllowed) == 0) {\n    if (delim == '\\'') {\n      throw new InvalidJsonCharacterException(context);\n    }\n  }\n\n  var str = '';\n\n  while (true) {\n    var char = _token(context);\n\n    if (char == delim) {\n      return {\n        kind: 'string',\n        start: start,\n        end: context.position,\n        text: context.original.substring(start.offset, context.position.offset),\n        value: str,\n        comments: comments\n      };\n    } else if (char == '\\\\') {\n      char = _token(context);\n\n      switch (char) {\n        case '\\\\':\n        case '\\/':\n        case '\"':\n        case delim:\n          str += char;\n          break;\n\n        case 'b':\n          str += '\\b';\n          break;\n\n        case 'f':\n          str += '\\f';\n          break;\n\n        case 'n':\n          str += '\\n';\n          break;\n\n        case 'r':\n          str += '\\r';\n          break;\n\n        case 't':\n          str += '\\t';\n          break;\n\n        case 'u':\n          var _token2 = _token(context, '0123456789abcdefABCDEF'),\n              _token3 = _slicedToArray(_token2, 1),\n              c0 = _token3[0];\n\n          var _token4 = _token(context, '0123456789abcdefABCDEF'),\n              _token5 = _slicedToArray(_token4, 1),\n              c1 = _token5[0];\n\n          var _token6 = _token(context, '0123456789abcdefABCDEF'),\n              _token7 = _slicedToArray(_token6, 1),\n              c2 = _token7[0];\n\n          var _token8 = _token(context, '0123456789abcdefABCDEF'),\n              _token9 = _slicedToArray(_token8, 1),\n              c3 = _token9[0];\n\n          str += String.fromCharCode(parseInt(c0 + c1 + c2 + c3, 16));\n          break;\n\n        case undefined:\n          throw new UnexpectedEndOfInputException(context);\n\n        case '\\n':\n          // Only valid when multiline strings are allowed.\n          if ((context.mode & JsonParseMode.MultiLineStringAllowed) == 0) {\n            throw new InvalidJsonCharacterException(context);\n          }\n\n          str += char;\n          break;\n\n        default:\n          throw new InvalidJsonCharacterException(context);\n      }\n    } else if (char === undefined) {\n      throw new UnexpectedEndOfInputException(context);\n    } else if (char == '\\b' || char == '\\f' || char == '\\n' || char == '\\r' || char == '\\t') {\n      throw new InvalidJsonCharacterException(context);\n    } else {\n      str += char;\n    }\n  }\n}\n/**\n * Read the constant `true` from the context.\n * @private\n */\n\n\nfunction _readTrue(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position;\n\n  _token(context, 't');\n\n  _token(context, 'r');\n\n  _token(context, 'u');\n\n  _token(context, 'e');\n\n  var end = context.position;\n  return {\n    kind: 'true',\n    start: start,\n    end: end,\n    text: context.original.substring(start.offset, end.offset),\n    value: true,\n    comments: comments\n  };\n}\n/**\n * Read the constant `false` from the context.\n * @private\n */\n\n\nfunction _readFalse(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position;\n\n  _token(context, 'f');\n\n  _token(context, 'a');\n\n  _token(context, 'l');\n\n  _token(context, 's');\n\n  _token(context, 'e');\n\n  var end = context.position;\n  return {\n    kind: 'false',\n    start: start,\n    end: end,\n    text: context.original.substring(start.offset, end.offset),\n    value: false,\n    comments: comments\n  };\n}\n/**\n * Read the constant `null` from the context.\n * @private\n */\n\n\nfunction _readNull(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position;\n\n  _token(context, 'n');\n\n  _token(context, 'u');\n\n  _token(context, 'l');\n\n  _token(context, 'l');\n\n  var end = context.position;\n  return {\n    kind: 'null',\n    start: start,\n    end: end,\n    text: context.original.substring(start.offset, end.offset),\n    value: null,\n    comments: comments\n  };\n}\n/**\n * Read the constant `NaN` from the context.\n * @private\n */\n\n\nfunction _readNaN(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position;\n\n  _token(context, 'N');\n\n  _token(context, 'a');\n\n  _token(context, 'N');\n\n  var end = context.position;\n  return {\n    kind: 'number',\n    start: start,\n    end: end,\n    text: context.original.substring(start.offset, end.offset),\n    value: NaN,\n    comments: comments\n  };\n}\n/**\n * Read an array of JSON values from the context.\n * @private\n */\n\n\nfunction _readArray(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position; // Consume the first delimiter.\n\n  _token(context, '[');\n\n  var value = [];\n  var elements = [];\n\n  _readBlanks(context);\n\n  if (_peek(context) != ']') {\n    var node = _readValue(context);\n\n    elements.push(node);\n    value.push(node.value);\n  }\n\n  while (_peek(context) != ']') {\n    _token(context, ',');\n\n    var valueComments = _readBlanks(context);\n\n    if ((context.mode & JsonParseMode.TrailingCommasAllowed) !== 0 && _peek(context) === ']') {\n      break;\n    }\n\n    var _node = _readValue(context, valueComments);\n\n    elements.push(_node);\n    value.push(_node.value);\n  }\n\n  _token(context, ']');\n\n  return {\n    kind: 'array',\n    start: start,\n    end: context.position,\n    text: context.original.substring(start.offset, context.position.offset),\n    value: value,\n    elements: elements,\n    comments: comments\n  };\n}\n/**\n * Read an identifier from the context. An identifier is a valid JavaScript identifier, and this\n * function is only used in Loose mode.\n * @private\n */\n\n\nfunction _readIdentifier(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position;\n\n  var char = _peek(context);\n\n  if (char && '0123456789'.indexOf(char) != -1) {\n    var identifierNode = _readNumber(context);\n\n    return {\n      kind: 'identifier',\n      start: start,\n      end: identifierNode.end,\n      text: identifierNode.text,\n      value: identifierNode.value.toString()\n    };\n  }\n\n  var identValidFirstChar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMOPQRSTUVWXYZ';\n  var identValidChar = '_$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMOPQRSTUVWXYZ0123456789';\n  var first = true;\n  var value = '';\n\n  while (true) {\n    char = _token(context);\n\n    if (char == undefined || (first ? identValidFirstChar.indexOf(char) : identValidChar.indexOf(char)) == -1) {\n      context.position = context.previous;\n      return {\n        kind: 'identifier',\n        start: start,\n        end: context.position,\n        text: context.original.substr(start.offset, context.position.offset),\n        value: value,\n        comments: comments\n      };\n    }\n\n    value += char;\n    first = false;\n  }\n}\n/**\n * Read a property from the context. A property is a string or (in Loose mode only) a number or\n * an identifier, followed by a colon `:`.\n * @private\n */\n\n\nfunction _readProperty(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position;\n  var key;\n\n  if ((context.mode & JsonParseMode.IdentifierKeyNamesAllowed) != 0) {\n    var top = _peek(context);\n\n    if (top == '\"' || top == '\\'') {\n      key = _readString(context);\n    } else {\n      key = _readIdentifier(context);\n    }\n  } else {\n    key = _readString(context);\n  }\n\n  _readBlanks(context);\n\n  _token(context, ':');\n\n  var value = _readValue(context);\n\n  var end = context.position;\n  return {\n    kind: 'keyvalue',\n    key: key,\n    value: value,\n    start: start,\n    end: end,\n    text: context.original.substring(start.offset, end.offset),\n    comments: comments\n  };\n}\n/**\n * Read an object of properties -> JSON values from the context.\n * @private\n */\n\n\nfunction _readObject(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var start = context.position; // Consume the first delimiter.\n\n  _token(context, '{');\n\n  var value = {};\n  var properties = [];\n\n  _readBlanks(context);\n\n  if (_peek(context) != '}') {\n    var property = _readProperty(context);\n\n    value[property.key.value] = property.value.value;\n    properties.push(property);\n\n    while (_peek(context) != '}') {\n      _token(context, ',');\n\n      var propertyComments = _readBlanks(context);\n\n      if ((context.mode & JsonParseMode.TrailingCommasAllowed) !== 0 && _peek(context) === '}') {\n        break;\n      }\n\n      var _property = _readProperty(context, propertyComments);\n\n      value[_property.key.value] = _property.value.value;\n      properties.push(_property);\n    }\n  }\n\n  _token(context, '}');\n\n  return {\n    kind: 'object',\n    properties: properties,\n    start: start,\n    end: context.position,\n    value: value,\n    text: context.original.substring(start.offset, context.position.offset),\n    comments: comments\n  };\n}\n/**\n * Remove any blank character or comments (in Loose mode) from the context, returning an array\n * of comments if any are found.\n * @private\n */\n\n\nfunction _readBlanks(context) {\n  if ((context.mode & JsonParseMode.CommentsAllowed) != 0) {\n    var comments = [];\n\n    while (true) {\n      var char = context.original[context.position.offset];\n\n      if (char == '/' && context.original[context.position.offset + 1] == '*') {\n        var start = context.position; // Multi line comment.\n\n        _next(context);\n\n        _next(context);\n\n        while (context.original[context.position.offset] != '*' || context.original[context.position.offset + 1] != '/') {\n          _next(context);\n\n          if (context.position.offset >= context.original.length) {\n            throw new UnexpectedEndOfInputException(context);\n          }\n        } // Remove \"*/\".\n\n\n        _next(context);\n\n        _next(context);\n\n        comments.push({\n          kind: 'multicomment',\n          start: start,\n          end: context.position,\n          text: context.original.substring(start.offset, context.position.offset),\n          content: context.original.substring(start.offset + 2, context.position.offset - 2)\n        });\n      } else if (char == '/' && context.original[context.position.offset + 1] == '/') {\n        var _start = context.position; // Multi line comment.\n\n        _next(context);\n\n        _next(context);\n\n        while (context.original[context.position.offset] != '\\n') {\n          _next(context);\n\n          if (context.position.offset >= context.original.length) {\n            break;\n          }\n        } // Remove \"\\n\".\n\n\n        if (context.position.offset < context.original.length) {\n          _next(context);\n        }\n\n        comments.push({\n          kind: 'comment',\n          start: _start,\n          end: context.position,\n          text: context.original.substring(_start.offset, context.position.offset),\n          content: context.original.substring(_start.offset + 2, context.position.offset - 1)\n        });\n      } else if (char == ' ' || char == '\\t' || char == '\\n' || char == '\\r' || char == '\\f') {\n        _next(context);\n      } else {\n        break;\n      }\n    }\n\n    return comments;\n  } else {\n    var _char = context.original[context.position.offset];\n\n    while (_char == ' ' || _char == '\\t' || _char == '\\n' || _char == '\\r' || _char == '\\f') {\n      _next(context);\n\n      _char = context.original[context.position.offset];\n    }\n\n    return [];\n  }\n}\n/**\n * Read a JSON value from the context, which can be any form of JSON value.\n * @private\n */\n\n\nfunction _readValue(context) {\n  var comments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _readBlanks(context);\n  var result; // Clean up before.\n\n  var char = _peek(context);\n\n  switch (char) {\n    case undefined:\n      throw new UnexpectedEndOfInputException(context);\n\n    case '-':\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9':\n      result = _readNumber(context, comments);\n      break;\n\n    case '.':\n    case '+':\n      if ((context.mode & JsonParseMode.LaxNumberParsingAllowed) == 0) {\n        throw new InvalidJsonCharacterException(context);\n      }\n\n      result = _readNumber(context, comments);\n      break;\n\n    case '\\'':\n    case '\"':\n      result = _readString(context, comments);\n      break;\n\n    case 'I':\n      if ((context.mode & JsonParseMode.NumberConstantsAllowed) == 0) {\n        throw new InvalidJsonCharacterException(context);\n      }\n\n      result = _readNumber(context, comments);\n      break;\n\n    case 'N':\n      if ((context.mode & JsonParseMode.NumberConstantsAllowed) == 0) {\n        throw new InvalidJsonCharacterException(context);\n      }\n\n      result = _readNaN(context, comments);\n      break;\n\n    case 't':\n      result = _readTrue(context, comments);\n      break;\n\n    case 'f':\n      result = _readFalse(context, comments);\n      break;\n\n    case 'n':\n      result = _readNull(context, comments);\n      break;\n\n    case '[':\n      result = _readArray(context, comments);\n      break;\n\n    case '{':\n      result = _readObject(context, comments);\n      break;\n\n    default:\n      throw new InvalidJsonCharacterException(context);\n  } // Clean up after.\n\n\n  _readBlanks(context);\n\n  return result;\n}\n/**\n * The Parse mode used for parsing the JSON string.\n */\n\n\nvar JsonParseMode;\n\n(function (JsonParseMode) {\n  JsonParseMode[JsonParseMode[\"Strict\"] = 0] = \"Strict\";\n  JsonParseMode[JsonParseMode[\"CommentsAllowed\"] = 1] = \"CommentsAllowed\";\n  JsonParseMode[JsonParseMode[\"SingleQuotesAllowed\"] = 2] = \"SingleQuotesAllowed\";\n  JsonParseMode[JsonParseMode[\"IdentifierKeyNamesAllowed\"] = 4] = \"IdentifierKeyNamesAllowed\";\n  JsonParseMode[JsonParseMode[\"TrailingCommasAllowed\"] = 8] = \"TrailingCommasAllowed\";\n  JsonParseMode[JsonParseMode[\"HexadecimalNumberAllowed\"] = 16] = \"HexadecimalNumberAllowed\";\n  JsonParseMode[JsonParseMode[\"MultiLineStringAllowed\"] = 32] = \"MultiLineStringAllowed\";\n  JsonParseMode[JsonParseMode[\"LaxNumberParsingAllowed\"] = 64] = \"LaxNumberParsingAllowed\";\n  JsonParseMode[JsonParseMode[\"NumberConstantsAllowed\"] = 128] = \"NumberConstantsAllowed\";\n  JsonParseMode[JsonParseMode[\"Default\"] = 0] = \"Default\";\n  JsonParseMode[JsonParseMode[\"Loose\"] = 255] = \"Loose\";\n  JsonParseMode[JsonParseMode[\"Json\"] = 0] = \"Json\";\n  JsonParseMode[JsonParseMode[\"Json5\"] = 255] = \"Json5\";\n})(JsonParseMode = exports.JsonParseMode || (exports.JsonParseMode = {}));\n/**\n * Parse the JSON string and return its AST. The AST may be losing data (end comments are\n * discarded for example, and space characters are not represented in the AST), but all values\n * will have a single node in the AST (a 1-to-1 mapping).\n * @param input The string to use.\n * @param mode The mode to parse the input with. {@see JsonParseMode}.\n * @returns {JsonAstNode} The root node of the value of the AST.\n */\n\n\nfunction parseJsonAst(input) {\n  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JsonParseMode.Default;\n\n  if (mode == JsonParseMode.Default) {\n    mode = JsonParseMode.Strict;\n  }\n\n  var context = {\n    position: {\n      offset: 0,\n      line: 0,\n      character: 0\n    },\n    previous: {\n      offset: 0,\n      line: 0,\n      character: 0\n    },\n    original: input,\n    comments: undefined,\n    mode: mode\n  };\n\n  var ast = _readValue(context);\n\n  if (context.position.offset < input.length) {\n    var rest = input.substr(context.position.offset);\n    var i = rest.length > 20 ? rest.substr(0, 20) + '...' : rest;\n    throw new Error(\"Expected end of file, got \\\"\".concat(i, \"\\\" at \") + \"\".concat(context.position.line, \":\").concat(context.position.character, \".\"));\n  }\n\n  return ast;\n}\n\nexports.parseJsonAst = parseJsonAst;\n/**\n * Parse a JSON string into its value.  This discards the AST and only returns the value itself.\n *\n * If a path option is pass, it also absorbs JSON parsing errors and return a new error with the\n * path in it. Useful for showing errors when parsing from a file.\n *\n * @param input The string to parse.\n * @param mode The mode to parse the input with. {@see JsonParseMode}.\n * @param options Additional optinos for parsing.\n * @returns {JsonValue} The value represented by the JSON string.\n */\n\nfunction parseJson(input) {\n  var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JsonParseMode.Default;\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n\n  try {\n    // Try parsing for the fastest path available, if error, uses our own parser for better errors.\n    if (mode == JsonParseMode.Strict) {\n      try {\n        return JSON.parse(input);\n      } catch (err) {\n        return parseJsonAst(input, mode).value;\n      }\n    }\n\n    return parseJsonAst(input, mode).value;\n  } catch (e) {\n    if (options && options.path && e instanceof JsonException) {\n      throw new PathSpecificJsonException(options.path, e);\n    }\n\n    throw e;\n  }\n}\n\nexports.parseJson = parseJson;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/json/parser.js"],"names":["Object","defineProperty","exports","value","parseJson","parseJsonAst","JsonParseMode","PathSpecificJsonException","UnexpectedEndOfInputException","InvalidJsonCharacterException","JsonException","exception_1","require","BaseException","context","pos","previous","invalidChar","JSON","stringify","_peek","line","character","offset","_context","path","exception","message","original","position","_next","char","_token","valid","indexOf","_readExpNumber","start","str","comments","signed","kind","end","text","substring","Number","parseFloat","_readHexaNumber","isNegative","hexa","ch","includes","parseInt","_readNumber","_readBlanks","dotted","mode","NumberConstantsAllowed","HexadecimalNumberAllowed","endsWith","_readString","delim","SingleQuotesAllowed","c0","c1","c2","c3","String","fromCharCode","undefined","MultiLineStringAllowed","_readTrue","_readFalse","_readNull","_readNaN","NaN","_readArray","elements","node","_readValue","push","valueComments","TrailingCommasAllowed","_readIdentifier","identifierNode","toString","identValidFirstChar","identValidChar","first","substr","_readProperty","key","IdentifierKeyNamesAllowed","top","_readObject","properties","property","propertyComments","CommentsAllowed","length","content","result","LaxNumberParsingAllowed","input","Default","Strict","ast","rest","i","Error","options","parse","err","e"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseJson = exports.parseJsonAst = exports.JsonParseMode = exports.PathSpecificJsonException = exports.UnexpectedEndOfInputException = exports.InvalidJsonCharacterException = exports.JsonException = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst exception_1 = require(\"../exception\");\nclass JsonException extends exception_1.BaseException {\n}\nexports.JsonException = JsonException;\n/**\n * A character was invalid in this context.\n */\nclass InvalidJsonCharacterException extends JsonException {\n    constructor(context) {\n        const pos = context.previous;\n        const invalidChar = JSON.stringify(_peek(context));\n        super(`Invalid JSON character: ${invalidChar} at ${pos.line}:${pos.character}.`);\n        this.invalidChar = invalidChar;\n        this.line = pos.line;\n        this.offset = pos.offset;\n        this.character = pos.character;\n    }\n}\nexports.InvalidJsonCharacterException = InvalidJsonCharacterException;\n/**\n * More input was expected, but we reached the end of the stream.\n */\nclass UnexpectedEndOfInputException extends JsonException {\n    constructor(_context) {\n        super(`Unexpected end of file.`);\n    }\n}\nexports.UnexpectedEndOfInputException = UnexpectedEndOfInputException;\n/**\n * An error happened within a file.\n */\nclass PathSpecificJsonException extends JsonException {\n    constructor(path, exception) {\n        super(`An error happened at file path ${JSON.stringify(path)}: ${exception.message}`);\n        this.path = path;\n        this.exception = exception;\n    }\n}\nexports.PathSpecificJsonException = PathSpecificJsonException;\n/**\n * Peek and return the next character from the context.\n * @private\n */\nfunction _peek(context) {\n    return context.original[context.position.offset];\n}\n/**\n * Move the context to the next character, including incrementing the line if necessary.\n * @private\n */\nfunction _next(context) {\n    context.previous = context.position;\n    let { offset, line, character } = context.position;\n    const char = context.original[offset];\n    offset++;\n    if (char == '\\n') {\n        line++;\n        character = 0;\n    }\n    else {\n        character++;\n    }\n    context.position = { offset, line, character };\n}\nfunction _token(context, valid) {\n    const char = _peek(context);\n    if (valid) {\n        if (!char) {\n            throw new UnexpectedEndOfInputException(context);\n        }\n        if (valid.indexOf(char) == -1) {\n            throw new InvalidJsonCharacterException(context);\n        }\n    }\n    // Move the position of the context to the next character.\n    _next(context);\n    return char;\n}\n/**\n * Read the exponent part of a number. The exponent part is looser for JSON than the number\n * part. `str` is the string of the number itself found so far, and start the position\n * where the full number started. Returns the node found.\n * @private\n */\nfunction _readExpNumber(context, start, str, comments) {\n    let char;\n    let signed = false;\n    while (true) {\n        char = _token(context);\n        if (char == '+' || char == '-') {\n            if (signed) {\n                break;\n            }\n            signed = true;\n            str += char;\n        }\n        else if (char == '0' || char == '1' || char == '2' || char == '3' || char == '4'\n            || char == '5' || char == '6' || char == '7' || char == '8' || char == '9') {\n            signed = true;\n            str += char;\n        }\n        else {\n            break;\n        }\n    }\n    // We're done reading this number.\n    context.position = context.previous;\n    return {\n        kind: 'number',\n        start,\n        end: context.position,\n        text: context.original.substring(start.offset, context.position.offset),\n        value: Number.parseFloat(str),\n        comments: comments,\n    };\n}\n/**\n * Read the hexa part of a 0xBADCAFE hexadecimal number.\n * @private\n */\nfunction _readHexaNumber(context, isNegative, start, comments) {\n    // Read an hexadecimal number, until it's not hexadecimal.\n    let hexa = '';\n    const valid = '0123456789abcdefABCDEF';\n    for (let ch = _peek(context); ch && valid.includes(ch); ch = _peek(context)) {\n        // Add it to the hexa string.\n        hexa += ch;\n        // Move the position of the context to the next character.\n        _next(context);\n    }\n    const value = Number.parseInt(hexa, 16);\n    // We're done reading this number.\n    return {\n        kind: 'number',\n        start,\n        end: context.position,\n        text: context.original.substring(start.offset, context.position.offset),\n        value: isNegative ? -value : value,\n        comments,\n    };\n}\n/**\n * Read a number from the context.\n * @private\n */\nfunction _readNumber(context, comments = _readBlanks(context)) {\n    let str = '';\n    let dotted = false;\n    const start = context.position;\n    // read until `e` or end of line.\n    while (true) {\n        const char = _token(context);\n        // Read tokens, one by one.\n        if (char == '-') {\n            if (str != '') {\n                throw new InvalidJsonCharacterException(context);\n            }\n        }\n        else if (char == 'I'\n            && (str == '-' || str == '' || str == '+')\n            && (context.mode & JsonParseMode.NumberConstantsAllowed) != 0) {\n            // Infinity?\n            // _token(context, 'I'); Already read.\n            _token(context, 'n');\n            _token(context, 'f');\n            _token(context, 'i');\n            _token(context, 'n');\n            _token(context, 'i');\n            _token(context, 't');\n            _token(context, 'y');\n            str += 'Infinity';\n            break;\n        }\n        else if (char == '0') {\n            if (str == '0' || str == '-0') {\n                throw new InvalidJsonCharacterException(context);\n            }\n        }\n        else if (char == '1' || char == '2' || char == '3' || char == '4' || char == '5'\n            || char == '6' || char == '7' || char == '8' || char == '9') {\n            if (str == '0' || str == '-0') {\n                throw new InvalidJsonCharacterException(context);\n            }\n        }\n        else if (char == '+' && str == '') {\n            // Pass over.\n        }\n        else if (char == '.') {\n            if (dotted) {\n                throw new InvalidJsonCharacterException(context);\n            }\n            dotted = true;\n        }\n        else if (char == 'e' || char == 'E') {\n            return _readExpNumber(context, start, str + char, comments);\n        }\n        else if (char == 'x' && (str == '0' || str == '-0')\n            && (context.mode & JsonParseMode.HexadecimalNumberAllowed) != 0) {\n            return _readHexaNumber(context, str == '-0', start, comments);\n        }\n        else {\n            // We read one too many characters, so rollback the last character.\n            context.position = context.previous;\n            break;\n        }\n        str += char;\n    }\n    // We're done reading this number.\n    if (str.endsWith('.') && (context.mode & JsonParseMode.HexadecimalNumberAllowed) == 0) {\n        throw new InvalidJsonCharacterException(context);\n    }\n    return {\n        kind: 'number',\n        start,\n        end: context.position,\n        text: context.original.substring(start.offset, context.position.offset),\n        value: Number.parseFloat(str),\n        comments,\n    };\n}\n/**\n * Read a string from the context. Takes the comments of the string or read the blanks before the\n * string.\n * @private\n */\nfunction _readString(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    // Consume the first string delimiter.\n    const delim = _token(context);\n    if ((context.mode & JsonParseMode.SingleQuotesAllowed) == 0) {\n        if (delim == '\\'') {\n            throw new InvalidJsonCharacterException(context);\n        }\n    }\n    let str = '';\n    while (true) {\n        let char = _token(context);\n        if (char == delim) {\n            return {\n                kind: 'string',\n                start,\n                end: context.position,\n                text: context.original.substring(start.offset, context.position.offset),\n                value: str,\n                comments: comments,\n            };\n        }\n        else if (char == '\\\\') {\n            char = _token(context);\n            switch (char) {\n                case '\\\\':\n                case '\\/':\n                case '\"':\n                case delim:\n                    str += char;\n                    break;\n                case 'b':\n                    str += '\\b';\n                    break;\n                case 'f':\n                    str += '\\f';\n                    break;\n                case 'n':\n                    str += '\\n';\n                    break;\n                case 'r':\n                    str += '\\r';\n                    break;\n                case 't':\n                    str += '\\t';\n                    break;\n                case 'u':\n                    const [c0] = _token(context, '0123456789abcdefABCDEF');\n                    const [c1] = _token(context, '0123456789abcdefABCDEF');\n                    const [c2] = _token(context, '0123456789abcdefABCDEF');\n                    const [c3] = _token(context, '0123456789abcdefABCDEF');\n                    str += String.fromCharCode(parseInt(c0 + c1 + c2 + c3, 16));\n                    break;\n                case undefined:\n                    throw new UnexpectedEndOfInputException(context);\n                case '\\n':\n                    // Only valid when multiline strings are allowed.\n                    if ((context.mode & JsonParseMode.MultiLineStringAllowed) == 0) {\n                        throw new InvalidJsonCharacterException(context);\n                    }\n                    str += char;\n                    break;\n                default:\n                    throw new InvalidJsonCharacterException(context);\n            }\n        }\n        else if (char === undefined) {\n            throw new UnexpectedEndOfInputException(context);\n        }\n        else if (char == '\\b' || char == '\\f' || char == '\\n' || char == '\\r' || char == '\\t') {\n            throw new InvalidJsonCharacterException(context);\n        }\n        else {\n            str += char;\n        }\n    }\n}\n/**\n * Read the constant `true` from the context.\n * @private\n */\nfunction _readTrue(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    _token(context, 't');\n    _token(context, 'r');\n    _token(context, 'u');\n    _token(context, 'e');\n    const end = context.position;\n    return {\n        kind: 'true',\n        start,\n        end,\n        text: context.original.substring(start.offset, end.offset),\n        value: true,\n        comments,\n    };\n}\n/**\n * Read the constant `false` from the context.\n * @private\n */\nfunction _readFalse(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    _token(context, 'f');\n    _token(context, 'a');\n    _token(context, 'l');\n    _token(context, 's');\n    _token(context, 'e');\n    const end = context.position;\n    return {\n        kind: 'false',\n        start,\n        end,\n        text: context.original.substring(start.offset, end.offset),\n        value: false,\n        comments,\n    };\n}\n/**\n * Read the constant `null` from the context.\n * @private\n */\nfunction _readNull(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    _token(context, 'n');\n    _token(context, 'u');\n    _token(context, 'l');\n    _token(context, 'l');\n    const end = context.position;\n    return {\n        kind: 'null',\n        start,\n        end,\n        text: context.original.substring(start.offset, end.offset),\n        value: null,\n        comments: comments,\n    };\n}\n/**\n * Read the constant `NaN` from the context.\n * @private\n */\nfunction _readNaN(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    _token(context, 'N');\n    _token(context, 'a');\n    _token(context, 'N');\n    const end = context.position;\n    return {\n        kind: 'number',\n        start,\n        end,\n        text: context.original.substring(start.offset, end.offset),\n        value: NaN,\n        comments: comments,\n    };\n}\n/**\n * Read an array of JSON values from the context.\n * @private\n */\nfunction _readArray(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    // Consume the first delimiter.\n    _token(context, '[');\n    const value = [];\n    const elements = [];\n    _readBlanks(context);\n    if (_peek(context) != ']') {\n        const node = _readValue(context);\n        elements.push(node);\n        value.push(node.value);\n    }\n    while (_peek(context) != ']') {\n        _token(context, ',');\n        const valueComments = _readBlanks(context);\n        if ((context.mode & JsonParseMode.TrailingCommasAllowed) !== 0 && _peek(context) === ']') {\n            break;\n        }\n        const node = _readValue(context, valueComments);\n        elements.push(node);\n        value.push(node.value);\n    }\n    _token(context, ']');\n    return {\n        kind: 'array',\n        start,\n        end: context.position,\n        text: context.original.substring(start.offset, context.position.offset),\n        value,\n        elements,\n        comments,\n    };\n}\n/**\n * Read an identifier from the context. An identifier is a valid JavaScript identifier, and this\n * function is only used in Loose mode.\n * @private\n */\nfunction _readIdentifier(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    let char = _peek(context);\n    if (char && '0123456789'.indexOf(char) != -1) {\n        const identifierNode = _readNumber(context);\n        return {\n            kind: 'identifier',\n            start,\n            end: identifierNode.end,\n            text: identifierNode.text,\n            value: identifierNode.value.toString(),\n        };\n    }\n    const identValidFirstChar = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMOPQRSTUVWXYZ';\n    const identValidChar = '_$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMOPQRSTUVWXYZ0123456789';\n    let first = true;\n    let value = '';\n    while (true) {\n        char = _token(context);\n        if (char == undefined\n            || (first ? identValidFirstChar.indexOf(char) : identValidChar.indexOf(char)) == -1) {\n            context.position = context.previous;\n            return {\n                kind: 'identifier',\n                start,\n                end: context.position,\n                text: context.original.substr(start.offset, context.position.offset),\n                value,\n                comments,\n            };\n        }\n        value += char;\n        first = false;\n    }\n}\n/**\n * Read a property from the context. A property is a string or (in Loose mode only) a number or\n * an identifier, followed by a colon `:`.\n * @private\n */\nfunction _readProperty(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    let key;\n    if ((context.mode & JsonParseMode.IdentifierKeyNamesAllowed) != 0) {\n        const top = _peek(context);\n        if (top == '\"' || top == '\\'') {\n            key = _readString(context);\n        }\n        else {\n            key = _readIdentifier(context);\n        }\n    }\n    else {\n        key = _readString(context);\n    }\n    _readBlanks(context);\n    _token(context, ':');\n    const value = _readValue(context);\n    const end = context.position;\n    return {\n        kind: 'keyvalue',\n        key,\n        value,\n        start,\n        end,\n        text: context.original.substring(start.offset, end.offset),\n        comments,\n    };\n}\n/**\n * Read an object of properties -> JSON values from the context.\n * @private\n */\nfunction _readObject(context, comments = _readBlanks(context)) {\n    const start = context.position;\n    // Consume the first delimiter.\n    _token(context, '{');\n    const value = {};\n    const properties = [];\n    _readBlanks(context);\n    if (_peek(context) != '}') {\n        const property = _readProperty(context);\n        value[property.key.value] = property.value.value;\n        properties.push(property);\n        while (_peek(context) != '}') {\n            _token(context, ',');\n            const propertyComments = _readBlanks(context);\n            if ((context.mode & JsonParseMode.TrailingCommasAllowed) !== 0 && _peek(context) === '}') {\n                break;\n            }\n            const property = _readProperty(context, propertyComments);\n            value[property.key.value] = property.value.value;\n            properties.push(property);\n        }\n    }\n    _token(context, '}');\n    return {\n        kind: 'object',\n        properties,\n        start,\n        end: context.position,\n        value,\n        text: context.original.substring(start.offset, context.position.offset),\n        comments,\n    };\n}\n/**\n * Remove any blank character or comments (in Loose mode) from the context, returning an array\n * of comments if any are found.\n * @private\n */\nfunction _readBlanks(context) {\n    if ((context.mode & JsonParseMode.CommentsAllowed) != 0) {\n        const comments = [];\n        while (true) {\n            const char = context.original[context.position.offset];\n            if (char == '/' && context.original[context.position.offset + 1] == '*') {\n                const start = context.position;\n                // Multi line comment.\n                _next(context);\n                _next(context);\n                while (context.original[context.position.offset] != '*'\n                    || context.original[context.position.offset + 1] != '/') {\n                    _next(context);\n                    if (context.position.offset >= context.original.length) {\n                        throw new UnexpectedEndOfInputException(context);\n                    }\n                }\n                // Remove \"*/\".\n                _next(context);\n                _next(context);\n                comments.push({\n                    kind: 'multicomment',\n                    start,\n                    end: context.position,\n                    text: context.original.substring(start.offset, context.position.offset),\n                    content: context.original.substring(start.offset + 2, context.position.offset - 2),\n                });\n            }\n            else if (char == '/' && context.original[context.position.offset + 1] == '/') {\n                const start = context.position;\n                // Multi line comment.\n                _next(context);\n                _next(context);\n                while (context.original[context.position.offset] != '\\n') {\n                    _next(context);\n                    if (context.position.offset >= context.original.length) {\n                        break;\n                    }\n                }\n                // Remove \"\\n\".\n                if (context.position.offset < context.original.length) {\n                    _next(context);\n                }\n                comments.push({\n                    kind: 'comment',\n                    start,\n                    end: context.position,\n                    text: context.original.substring(start.offset, context.position.offset),\n                    content: context.original.substring(start.offset + 2, context.position.offset - 1),\n                });\n            }\n            else if (char == ' ' || char == '\\t' || char == '\\n' || char == '\\r' || char == '\\f') {\n                _next(context);\n            }\n            else {\n                break;\n            }\n        }\n        return comments;\n    }\n    else {\n        let char = context.original[context.position.offset];\n        while (char == ' ' || char == '\\t' || char == '\\n' || char == '\\r' || char == '\\f') {\n            _next(context);\n            char = context.original[context.position.offset];\n        }\n        return [];\n    }\n}\n/**\n * Read a JSON value from the context, which can be any form of JSON value.\n * @private\n */\nfunction _readValue(context, comments = _readBlanks(context)) {\n    let result;\n    // Clean up before.\n    const char = _peek(context);\n    switch (char) {\n        case undefined:\n            throw new UnexpectedEndOfInputException(context);\n        case '-':\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n            result = _readNumber(context, comments);\n            break;\n        case '.':\n        case '+':\n            if ((context.mode & JsonParseMode.LaxNumberParsingAllowed) == 0) {\n                throw new InvalidJsonCharacterException(context);\n            }\n            result = _readNumber(context, comments);\n            break;\n        case '\\'':\n        case '\"':\n            result = _readString(context, comments);\n            break;\n        case 'I':\n            if ((context.mode & JsonParseMode.NumberConstantsAllowed) == 0) {\n                throw new InvalidJsonCharacterException(context);\n            }\n            result = _readNumber(context, comments);\n            break;\n        case 'N':\n            if ((context.mode & JsonParseMode.NumberConstantsAllowed) == 0) {\n                throw new InvalidJsonCharacterException(context);\n            }\n            result = _readNaN(context, comments);\n            break;\n        case 't':\n            result = _readTrue(context, comments);\n            break;\n        case 'f':\n            result = _readFalse(context, comments);\n            break;\n        case 'n':\n            result = _readNull(context, comments);\n            break;\n        case '[':\n            result = _readArray(context, comments);\n            break;\n        case '{':\n            result = _readObject(context, comments);\n            break;\n        default:\n            throw new InvalidJsonCharacterException(context);\n    }\n    // Clean up after.\n    _readBlanks(context);\n    return result;\n}\n/**\n * The Parse mode used for parsing the JSON string.\n */\nvar JsonParseMode;\n(function (JsonParseMode) {\n    JsonParseMode[JsonParseMode[\"Strict\"] = 0] = \"Strict\";\n    JsonParseMode[JsonParseMode[\"CommentsAllowed\"] = 1] = \"CommentsAllowed\";\n    JsonParseMode[JsonParseMode[\"SingleQuotesAllowed\"] = 2] = \"SingleQuotesAllowed\";\n    JsonParseMode[JsonParseMode[\"IdentifierKeyNamesAllowed\"] = 4] = \"IdentifierKeyNamesAllowed\";\n    JsonParseMode[JsonParseMode[\"TrailingCommasAllowed\"] = 8] = \"TrailingCommasAllowed\";\n    JsonParseMode[JsonParseMode[\"HexadecimalNumberAllowed\"] = 16] = \"HexadecimalNumberAllowed\";\n    JsonParseMode[JsonParseMode[\"MultiLineStringAllowed\"] = 32] = \"MultiLineStringAllowed\";\n    JsonParseMode[JsonParseMode[\"LaxNumberParsingAllowed\"] = 64] = \"LaxNumberParsingAllowed\";\n    JsonParseMode[JsonParseMode[\"NumberConstantsAllowed\"] = 128] = \"NumberConstantsAllowed\";\n    JsonParseMode[JsonParseMode[\"Default\"] = 0] = \"Default\";\n    JsonParseMode[JsonParseMode[\"Loose\"] = 255] = \"Loose\";\n    JsonParseMode[JsonParseMode[\"Json\"] = 0] = \"Json\";\n    JsonParseMode[JsonParseMode[\"Json5\"] = 255] = \"Json5\";\n})(JsonParseMode = exports.JsonParseMode || (exports.JsonParseMode = {}));\n/**\n * Parse the JSON string and return its AST. The AST may be losing data (end comments are\n * discarded for example, and space characters are not represented in the AST), but all values\n * will have a single node in the AST (a 1-to-1 mapping).\n * @param input The string to use.\n * @param mode The mode to parse the input with. {@see JsonParseMode}.\n * @returns {JsonAstNode} The root node of the value of the AST.\n */\nfunction parseJsonAst(input, mode = JsonParseMode.Default) {\n    if (mode == JsonParseMode.Default) {\n        mode = JsonParseMode.Strict;\n    }\n    const context = {\n        position: { offset: 0, line: 0, character: 0 },\n        previous: { offset: 0, line: 0, character: 0 },\n        original: input,\n        comments: undefined,\n        mode,\n    };\n    const ast = _readValue(context);\n    if (context.position.offset < input.length) {\n        const rest = input.substr(context.position.offset);\n        const i = rest.length > 20 ? rest.substr(0, 20) + '...' : rest;\n        throw new Error(`Expected end of file, got \"${i}\" at `\n            + `${context.position.line}:${context.position.character}.`);\n    }\n    return ast;\n}\nexports.parseJsonAst = parseJsonAst;\n/**\n * Parse a JSON string into its value.  This discards the AST and only returns the value itself.\n *\n * If a path option is pass, it also absorbs JSON parsing errors and return a new error with the\n * path in it. Useful for showing errors when parsing from a file.\n *\n * @param input The string to parse.\n * @param mode The mode to parse the input with. {@see JsonParseMode}.\n * @param options Additional optinos for parsing.\n * @returns {JsonValue} The value represented by the JSON string.\n */\nfunction parseJson(input, mode = JsonParseMode.Default, options) {\n    try {\n        // Try parsing for the fastest path available, if error, uses our own parser for better errors.\n        if (mode == JsonParseMode.Strict) {\n            try {\n                return JSON.parse(input);\n            }\n            catch (err) {\n                return parseJsonAst(input, mode).value;\n            }\n        }\n        return parseJsonAst(input, mode).value;\n    }\n    catch (e) {\n        if (options && options.path && e instanceof JsonException) {\n            throw new PathSpecificJsonException(options.path, e);\n        }\n        throw e;\n    }\n}\nexports.parseJson = parseJson;\n"]},"metadata":{},"sourceType":"script"}