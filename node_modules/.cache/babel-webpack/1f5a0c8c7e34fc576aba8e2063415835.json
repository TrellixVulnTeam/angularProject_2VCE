{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/incremental/src/dependency_tracking\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.FileDependencyGraph = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * An implementation of the `DependencyTracker` dependency graph API.\n   *\n   * The `FileDependencyGraph`'s primary job is to determine whether a given file has \"logically\"\n   * changed, given the set of physical changes (direct changes to files on disk).\n   *\n   * A file is logically changed if at least one of three conditions is met:\n   *\n   * 1. The file itself has physically changed.\n   * 2. One of its dependencies has physically changed.\n   * 3. One of its resource dependencies has physically changed.\n   */\n\n\n  var FileDependencyGraph =\n  /** @class */\n  function () {\n    function FileDependencyGraph() {\n      this.nodes = new Map();\n    }\n\n    FileDependencyGraph.prototype.addDependency = function (from, on) {\n      this.nodeFor(from).dependsOn.add(on.fileName);\n    };\n\n    FileDependencyGraph.prototype.addResourceDependency = function (from, resource) {\n      this.nodeFor(from).usesResources.add(resource);\n    };\n\n    FileDependencyGraph.prototype.recordDependencyAnalysisFailure = function (file) {\n      this.nodeFor(file).failedAnalysis = true;\n    };\n\n    FileDependencyGraph.prototype.getResourceDependencies = function (from) {\n      var node = this.nodes.get(from);\n      return node ? tslib_1.__spread(node.usesResources) : [];\n    };\n    /**\n     * Update the current dependency graph from a previous one, incorporating a set of physical\n     * changes.\n     *\n     * This method performs two tasks:\n     *\n     * 1. For files which have not logically changed, their dependencies from `previous` are added to\n     *    `this` graph.\n     * 2. For files which have logically changed, they're added to a set of logically changed files\n     *    which is eventually returned.\n     *\n     * In essence, for build `n`, this method performs:\n     *\n     * G(n) + L(n) = G(n - 1) + P(n)\n     *\n     * where:\n     *\n     * G(n) = the dependency graph of build `n`\n     * L(n) = the logically changed files from build n - 1 to build n.\n     * P(n) = the physically changed files from build n - 1 to build n.\n     */\n\n\n    FileDependencyGraph.prototype.updateWithPhysicalChanges = function (previous, changedTsPaths, deletedTsPaths, changedResources) {\n      var e_1, _a;\n\n      var logicallyChanged = new Set();\n\n      try {\n        for (var _b = tslib_1.__values(previous.nodes.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var sf = _c.value;\n          var node = previous.nodeFor(sf);\n\n          if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {\n            logicallyChanged.add(sf.fileName);\n          } else if (!deletedTsPaths.has(sf.fileName)) {\n            this.nodes.set(sf, {\n              dependsOn: new Set(node.dependsOn),\n              usesResources: new Set(node.usesResources),\n              failedAnalysis: false\n            });\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return logicallyChanged;\n    };\n\n    FileDependencyGraph.prototype.nodeFor = function (sf) {\n      if (!this.nodes.has(sf)) {\n        this.nodes.set(sf, {\n          dependsOn: new Set(),\n          usesResources: new Set(),\n          failedAnalysis: false\n        });\n      }\n\n      return this.nodes.get(sf);\n    };\n\n    return FileDependencyGraph;\n  }();\n\n  exports.FileDependencyGraph = FileDependencyGraph;\n  /**\n   * Determine whether `sf` has logically changed, given its dependencies and the set of physically\n   * changed files and resources.\n   */\n\n  function isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources) {\n    var e_2, _a, e_3, _b; // A file is assumed to have logically changed if its dependencies could not be determined\n    // accurately.\n\n\n    if (node.failedAnalysis) {\n      return true;\n    } // A file is logically changed if it has physically changed itself (including being deleted).\n\n\n    if (changedTsPaths.has(sf.fileName) || deletedTsPaths.has(sf.fileName)) {\n      return true;\n    }\n\n    try {\n      // A file is logically changed if one of its dependencies has physically changed.\n      for (var _c = tslib_1.__values(node.dependsOn), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var dep = _d.value;\n\n        if (changedTsPaths.has(dep) || deletedTsPaths.has(dep)) {\n          return true;\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    try {\n      // A file is logically changed if one of its resources has physically changed.\n      for (var _e = tslib_1.__values(node.usesResources), _f = _e.next(); !_f.done; _f = _e.next()) {\n        var dep = _f.value;\n\n        if (changedResources.has(dep)) {\n          return true;\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    return false;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/src/dependency_tracking.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {DependencyTracker} from '../api';\n\n/**\n * An implementation of the `DependencyTracker` dependency graph API.\n *\n * The `FileDependencyGraph`'s primary job is to determine whether a given file has \"logically\"\n * changed, given the set of physical changes (direct changes to files on disk).\n *\n * A file is logically changed if at least one of three conditions is met:\n *\n * 1. The file itself has physically changed.\n * 2. One of its dependencies has physically changed.\n * 3. One of its resource dependencies has physically changed.\n */\nexport class FileDependencyGraph<T extends {fileName: string} = ts.SourceFile> implements\n    DependencyTracker<T> {\n  private nodes = new Map<T, FileNode>();\n\n  addDependency(from: T, on: T): void {\n    this.nodeFor(from).dependsOn.add(on.fileName);\n  }\n\n  addResourceDependency(from: T, resource: AbsoluteFsPath): void {\n    this.nodeFor(from).usesResources.add(resource);\n  }\n\n  recordDependencyAnalysisFailure(file: T): void {\n    this.nodeFor(file).failedAnalysis = true;\n  }\n\n  getResourceDependencies(from: T): AbsoluteFsPath[] {\n    const node = this.nodes.get(from);\n\n    return node ? [...node.usesResources] : [];\n  }\n\n  /**\n   * Update the current dependency graph from a previous one, incorporating a set of physical\n   * changes.\n   *\n   * This method performs two tasks:\n   *\n   * 1. For files which have not logically changed, their dependencies from `previous` are added to\n   *    `this` graph.\n   * 2. For files which have logically changed, they're added to a set of logically changed files\n   *    which is eventually returned.\n   *\n   * In essence, for build `n`, this method performs:\n   *\n   * G(n) + L(n) = G(n - 1) + P(n)\n   *\n   * where:\n   *\n   * G(n) = the dependency graph of build `n`\n   * L(n) = the logically changed files from build n - 1 to build n.\n   * P(n) = the physically changed files from build n - 1 to build n.\n   */\n  updateWithPhysicalChanges(\n      previous: FileDependencyGraph<T>, changedTsPaths: Set<string>, deletedTsPaths: Set<string>,\n      changedResources: Set<AbsoluteFsPath>): Set<string> {\n    const logicallyChanged = new Set<string>();\n\n    for (const sf of previous.nodes.keys()) {\n      const node = previous.nodeFor(sf);\n      if (isLogicallyChanged(sf, node, changedTsPaths, deletedTsPaths, changedResources)) {\n        logicallyChanged.add(sf.fileName);\n      } else if (!deletedTsPaths.has(sf.fileName)) {\n        this.nodes.set(sf, {\n          dependsOn: new Set(node.dependsOn),\n          usesResources: new Set(node.usesResources),\n          failedAnalysis: false,\n        });\n      }\n    }\n\n    return logicallyChanged;\n  }\n\n  private nodeFor(sf: T): FileNode {\n    if (!this.nodes.has(sf)) {\n      this.nodes.set(sf, {\n        dependsOn: new Set<string>(),\n        usesResources: new Set<AbsoluteFsPath>(),\n        failedAnalysis: false,\n      });\n    }\n    return this.nodes.get(sf)!;\n  }\n}\n\n/**\n * Determine whether `sf` has logically changed, given its dependencies and the set of physically\n * changed files and resources.\n */\nfunction isLogicallyChanged<T extends {fileName: string}>(\n    sf: T, node: FileNode, changedTsPaths: ReadonlySet<string>, deletedTsPaths: ReadonlySet<string>,\n    changedResources: ReadonlySet<AbsoluteFsPath>): boolean {\n  // A file is assumed to have logically changed if its dependencies could not be determined\n  // accurately.\n  if (node.failedAnalysis) {\n    return true;\n  }\n\n  // A file is logically changed if it has physically changed itself (including being deleted).\n  if (changedTsPaths.has(sf.fileName) || deletedTsPaths.has(sf.fileName)) {\n    return true;\n  }\n\n  // A file is logically changed if one of its dependencies has physically changed.\n  for (const dep of node.dependsOn) {\n    if (changedTsPaths.has(dep) || deletedTsPaths.has(dep)) {\n      return true;\n    }\n  }\n\n  // A file is logically changed if one of its resources has physically changed.\n  for (const dep of node.usesResources) {\n    if (changedResources.has(dep)) {\n      return true;\n    }\n  }\n  return false;\n}\n\ninterface FileNode {\n  dependsOn: Set<string>;\n  usesResources: Set<AbsoluteFsPath>;\n  failedAnalysis: boolean;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}