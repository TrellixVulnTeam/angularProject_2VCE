{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/util\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/util\", \"@angular/compiler/src/render3/r3_ast\", \"@angular/compiler/src/render3/view/i18n/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getInterpolationArgsLength = exports.chainedInstruction = exports.getAttrsForDirectiveMatching = exports.DefinitionMap = exports.getQueryPredicate = exports.trimTrailingNulls = exports.conditionallyCreateMapObjectLiteral = exports.asLiteral = exports.invalid = exports.unsupported = exports.temporaryAllocator = exports.NON_BINDABLE_ATTR = exports.IMPLICIT_REFERENCE = exports.REFERENCE_PREFIX = exports.RENDER_FLAGS = exports.CONTEXT_NAME = exports.TEMPORARY_NAME = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var t = require(\"@angular/compiler/src/render3/r3_ast\");\n\n  var util_2 = require(\"@angular/compiler/src/render3/view/i18n/util\");\n  /**\n   * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n   * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n   * bot work in some cases when object keys are mangled by minifier.\n   *\n   * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n   * inputs that contain potentially unsafe chars.\n   */\n\n\n  var UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n  /** Name of the temporary to use during data binding */\n\n  exports.TEMPORARY_NAME = '_t';\n  /** Name of the context parameter passed into a template function */\n\n  exports.CONTEXT_NAME = 'ctx';\n  /** Name of the RenderFlag passed into a template function */\n\n  exports.RENDER_FLAGS = 'rf';\n  /** The prefix reference variables */\n\n  exports.REFERENCE_PREFIX = '_r';\n  /** The name of the implicit context reference */\n\n  exports.IMPLICIT_REFERENCE = '$implicit';\n  /** Non bindable attribute name **/\n\n  exports.NON_BINDABLE_ATTR = 'ngNonBindable';\n  /**\n   * Creates an allocator for a temporary variable.\n   *\n   * A variable declaration is added to the statements the first time the allocator is invoked.\n   */\n\n  function temporaryAllocator(statements, name) {\n    var temp = null;\n    return function () {\n      if (!temp) {\n        statements.push(new o.DeclareVarStmt(exports.TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n        temp = o.variable(name);\n      }\n\n      return temp;\n    };\n  }\n\n  exports.temporaryAllocator = temporaryAllocator;\n\n  function unsupported(feature) {\n    if (this) {\n      throw new Error(\"Builder \" + this.constructor.name + \" doesn't support \" + feature + \" yet\");\n    }\n\n    throw new Error(\"Feature \" + feature + \" is not supported yet\");\n  }\n\n  exports.unsupported = unsupported;\n\n  function invalid(arg) {\n    throw new Error(\"Invalid state: Visitor \" + this.constructor.name + \" doesn't handle \" + arg.constructor.name);\n  }\n\n  exports.invalid = invalid;\n\n  function asLiteral(value) {\n    if (Array.isArray(value)) {\n      return o.literalArr(value.map(asLiteral));\n    }\n\n    return o.literal(value, o.INFERRED_TYPE);\n  }\n\n  exports.asLiteral = asLiteral;\n\n  function conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\n    if (Object.getOwnPropertyNames(keys).length > 0) {\n      return mapToExpression(keys, keepDeclared);\n    }\n\n    return null;\n  }\n\n  exports.conditionallyCreateMapObjectLiteral = conditionallyCreateMapObjectLiteral;\n\n  function mapToExpression(map, keepDeclared) {\n    return o.literalMap(Object.getOwnPropertyNames(map).map(function (key) {\n      var _a, _b; // canonical syntax: `dirProp: publicProp`\n      // if there is no `:`, use dirProp = elProp\n\n\n      var value = map[key];\n      var declaredName;\n      var publicName;\n      var minifiedName;\n      var needsDeclaredName;\n\n      if (Array.isArray(value)) {\n        _a = tslib_1.__read(value, 2), publicName = _a[0], declaredName = _a[1];\n        minifiedName = key;\n        needsDeclaredName = publicName !== declaredName;\n      } else {\n        _b = tslib_1.__read(util_1.splitAtColon(key, [key, value]), 2), declaredName = _b[0], publicName = _b[1];\n        minifiedName = declaredName; // Only include the declared name if extracted from the key, i.e. the key contains a colon.\n        // Otherwise the declared name should be omitted even if it is different from the public name,\n        // as it may have already been minified.\n\n        needsDeclaredName = publicName !== declaredName && key.includes(':');\n      }\n\n      return {\n        key: minifiedName,\n        // put quotes around keys that contain potentially unsafe characters\n        quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n        value: keepDeclared && needsDeclaredName ? o.literalArr([asLiteral(publicName), asLiteral(declaredName)]) : asLiteral(publicName)\n      };\n    }));\n  }\n  /**\n   *  Remove trailing null nodes as they are implied.\n   */\n\n\n  function trimTrailingNulls(parameters) {\n    while (o.isNull(parameters[parameters.length - 1])) {\n      parameters.pop();\n    }\n\n    return parameters;\n  }\n\n  exports.trimTrailingNulls = trimTrailingNulls;\n\n  function getQueryPredicate(query, constantPool) {\n    if (Array.isArray(query.predicate)) {\n      var predicate_1 = [];\n      query.predicate.forEach(function (selector) {\n        // Each item in predicates array may contain strings with comma-separated refs\n        // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n        // as separate array entities\n        var selectors = selector.split(',').map(function (token) {\n          return o.literal(token.trim());\n        });\n        predicate_1.push.apply(predicate_1, tslib_1.__spread(selectors));\n      });\n      return constantPool.getConstLiteral(o.literalArr(predicate_1), true);\n    } else {\n      return query.predicate;\n    }\n  }\n\n  exports.getQueryPredicate = getQueryPredicate;\n  /**\n   * A representation for an object literal used during codegen of definition objects. The generic\n   * type `T` allows to reference a documented type of the generated structure, such that the\n   * property names that are set can be resolved to their documented declaration.\n   */\n\n  var DefinitionMap =\n  /** @class */\n  function () {\n    function DefinitionMap() {\n      this.values = [];\n    }\n\n    DefinitionMap.prototype.set = function (key, value) {\n      if (value) {\n        this.values.push({\n          key: key,\n          value: value,\n          quoted: false\n        });\n      }\n    };\n\n    DefinitionMap.prototype.toLiteralMap = function () {\n      return o.literalMap(this.values);\n    };\n\n    return DefinitionMap;\n  }();\n\n  exports.DefinitionMap = DefinitionMap;\n  /**\n   * Extract a map of properties to values for a given element or template node, which can be used\n   * by the directive matching machinery.\n   *\n   * @param elOrTpl the element or template in question\n   * @return an object set up for directive matching. For attributes on the element/template, this\n   * object maps a property name to its (static) value. For any bindings, this map simply maps the\n   * property name to an empty string.\n   */\n\n  function getAttrsForDirectiveMatching(elOrTpl) {\n    var attributesMap = {};\n\n    if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n      elOrTpl.templateAttrs.forEach(function (a) {\n        return attributesMap[a.name] = '';\n      });\n    } else {\n      elOrTpl.attributes.forEach(function (a) {\n        if (!util_2.isI18nAttribute(a.name)) {\n          attributesMap[a.name] = a.value;\n        }\n      });\n      elOrTpl.inputs.forEach(function (i) {\n        attributesMap[i.name] = '';\n      });\n      elOrTpl.outputs.forEach(function (o) {\n        attributesMap[o.name] = '';\n      });\n    }\n\n    return attributesMap;\n  }\n\n  exports.getAttrsForDirectiveMatching = getAttrsForDirectiveMatching;\n  /** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\n\n  function chainedInstruction(reference, calls, span) {\n    var expression = o.importExpr(reference, null, span);\n\n    if (calls.length > 0) {\n      for (var i = 0; i < calls.length; i++) {\n        expression = expression.callFn(calls[i], span);\n      }\n    } else {\n      // Add a blank invocation, in case the `calls` array is empty.\n      expression = expression.callFn([], span);\n    }\n\n    return expression;\n  }\n\n  exports.chainedInstruction = chainedInstruction;\n  /**\n   * Gets the number of arguments expected to be passed to a generated instruction in the case of\n   * interpolation instructions.\n   * @param interpolation An interpolation ast\n   */\n\n  function getInterpolationArgsLength(interpolation) {\n    var expressions = interpolation.expressions,\n        strings = interpolation.strings;\n\n    if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n      // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n      // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n      // `textInterpolate`.\n      return 1;\n    } else {\n      return expressions.length + strings.length;\n    }\n  }\n\n  exports.getInterpolationArgsLength = getInterpolationArgsLength;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/view/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport {Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport {splitAtColon} from '../../util';\nimport * as t from '../r3_ast';\n\nimport {R3QueryMetadata} from './api';\nimport {isI18nAttribute} from './i18n/util';\n\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/** The prefix reference variables */\nexport const REFERENCE_PREFIX = '_r';\n\n/** The name of the implicit context reference */\nexport const IMPLICIT_REFERENCE = '$implicit';\n\n/** Non bindable attribute name **/\nexport const NON_BINDABLE_ATTR = 'ngNonBindable';\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr|null = null;\n  return () => {\n    if (!temp) {\n      statements.push(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\n\nexport function unsupported(this: void|Function, feature: string): never {\n  if (this) {\n    throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);\n  }\n  throw new Error(`Feature ${feature} is not supported yet`);\n}\n\nexport function invalid<T>(this: t.Visitor, arg: o.Expression|o.Statement|t.Node): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\nexport function conditionallyCreateMapObjectLiteral(\n    keys: {[key: string]: string|string[]}, keepDeclared?: boolean): o.Expression|null {\n  if (Object.getOwnPropertyNames(keys).length > 0) {\n    return mapToExpression(keys, keepDeclared);\n  }\n  return null;\n}\n\nfunction mapToExpression(\n    map: {[key: string]: string|string[]}, keepDeclared?: boolean): o.Expression {\n  return o.literalMap(Object.getOwnPropertyNames(map).map(key => {\n    // canonical syntax: `dirProp: publicProp`\n    // if there is no `:`, use dirProp = elProp\n    const value = map[key];\n    let declaredName: string;\n    let publicName: string;\n    let minifiedName: string;\n    let needsDeclaredName: boolean;\n    if (Array.isArray(value)) {\n      [publicName, declaredName] = value;\n      minifiedName = key;\n      needsDeclaredName = publicName !== declaredName;\n    } else {\n      [declaredName, publicName] = splitAtColon(key, [key, value]);\n      minifiedName = declaredName;\n      // Only include the declared name if extracted from the key, i.e. the key contains a colon.\n      // Otherwise the declared name should be omitted even if it is different from the public name,\n      // as it may have already been minified.\n      needsDeclaredName = publicName !== declaredName && key.includes(':');\n    }\n    return {\n      key: minifiedName,\n      // put quotes around keys that contain potentially unsafe characters\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: (keepDeclared && needsDeclaredName) ?\n          o.literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n          asLiteral(publicName)\n    };\n  }));\n}\n\n/**\n *  Remove trailing null nodes as they are implied.\n */\nexport function trimTrailingNulls(parameters: o.Expression[]): o.Expression[] {\n  while (o.isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n  return parameters;\n}\n\nexport function getQueryPredicate(\n    query: R3QueryMetadata, constantPool: ConstantPool): o.Expression {\n  if (Array.isArray(query.predicate)) {\n    let predicate: o.Expression[] = [];\n    query.predicate.forEach((selector: string): void => {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      const selectors = selector.split(',').map(token => o.literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(o.literalArr(predicate), true);\n  } else {\n    return query.predicate;\n  }\n}\n\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nexport class DefinitionMap<T = any> {\n  values: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  set(key: keyof T, value: o.Expression|null): void {\n    if (value) {\n      this.values.push({key: key as string, value, quoted: false});\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr {\n    return o.literalMap(this.values);\n  }\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nexport function getAttrsForDirectiveMatching(elOrTpl: t.Element|\n                                             t.Template): {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n\n  if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n\n    elOrTpl.inputs.forEach(i => {\n      attributesMap[i.name] = '';\n    });\n    elOrTpl.outputs.forEach(o => {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\nexport function chainedInstruction(\n    reference: o.ExternalReference, calls: o.Expression[][], span?: ParseSourceSpan|null) {\n  let expression = o.importExpr(reference, null, span) as o.Expression;\n\n  if (calls.length > 0) {\n    for (let i = 0; i < calls.length; i++) {\n      expression = expression.callFn(calls[i], span);\n    }\n  } else {\n    // Add a blank invocation, in case the `calls` array is empty.\n    expression = expression.callFn([], span);\n  }\n\n  return expression;\n}\n\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nexport function getInterpolationArgsLength(interpolation: Interpolation) {\n  const {expressions, strings} = interpolation;\n  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n    // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n    // `textInterpolate`.\n    return 1;\n  } else {\n    return expressions.length + strings.length;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}