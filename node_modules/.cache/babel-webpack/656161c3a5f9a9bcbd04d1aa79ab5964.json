{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/locking/sync_locker\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SyncLocker = void 0;\n  /**\n   * SyncLocker is used to prevent more than one instance of ngcc executing at the same time,\n   * when being called in a synchronous context.\n   *\n   * * When ngcc starts executing, it creates a file in the `compiler-cli/ngcc` folder.\n   * * If it finds one is already there then it fails with a suitable error message.\n   * * When ngcc completes executing, it removes the file so that future ngcc executions can start.\n   */\n\n  var SyncLocker =\n  /** @class */\n  function () {\n    function SyncLocker(lockFile) {\n      this.lockFile = lockFile;\n    }\n    /**\n     * Run the given function guarded by the lock file.\n     *\n     * @param fn the function to run.\n     * @returns the value returned from the `fn` call.\n     */\n\n\n    SyncLocker.prototype.lock = function (fn) {\n      this.create();\n\n      try {\n        return fn();\n      } finally {\n        this.lockFile.remove();\n      }\n    };\n    /**\n     * Write a lock file to disk, or error if there is already one there.\n     */\n\n\n    SyncLocker.prototype.create = function () {\n      try {\n        this.lockFile.write();\n      } catch (e) {\n        if (e.code !== 'EEXIST') {\n          throw e;\n        }\n\n        this.handleExistingLockFile();\n      }\n    };\n    /**\n     * The lock-file already exists so raise a helpful error.\n     */\n\n\n    SyncLocker.prototype.handleExistingLockFile = function () {\n      var pid = this.lockFile.read();\n      throw new Error(\"ngcc is already running at process with id \" + pid + \".\\n\" + \"If you are running multiple builds in parallel then you might try pre-processing your node_modules via the command line ngcc tool before starting the builds.\\n\" + (\"(If you are sure no ngcc process is running then you should delete the lock-file at \" + this.lockFile.path + \".)\"));\n    };\n\n    return SyncLocker;\n  }();\n\n  exports.SyncLocker = SyncLocker;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/locking/sync_locker.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AASA;;;;;;;AAOG;;AACH,MAAA,UAAA;AAAA;AAAA,cAAA;AACE,aAAA,UAAA,CAAoB,QAApB,EAAsC;AAAlB,WAAA,QAAA,GAAA,QAAA;AAAsB;AAE1C;;;;;AAKG;;;AACH,IAAA,UAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAQ,EAAR,EAAmB;AACjB,WAAK,MAAL;;AACA,UAAI;AACF,eAAO,EAAE,EAAT;AACD,OAFD,SAEU;AACR,aAAK,QAAL,CAAc,MAAd;AACD;AACF,KAPD;AASA;;AAEG;;;AACO,IAAA,UAAA,CAAA,SAAA,CAAA,MAAA,GAAV,YAAA;AACE,UAAI;AACF,aAAK,QAAL,CAAc,KAAd;AACD,OAFD,CAEE,OAAO,CAAP,EAAU;AACV,YAAI,CAAC,CAAC,IAAF,KAAW,QAAf,EAAyB;AACvB,gBAAM,CAAN;AACD;;AACD,aAAK,sBAAL;AACD;AACF,KATS;AAWV;;AAEG;;;AACO,IAAA,UAAA,CAAA,SAAA,CAAA,sBAAA,GAAV,YAAA;AACE,UAAM,GAAG,GAAG,KAAK,QAAL,CAAc,IAAd,EAAZ;AACA,YAAM,IAAI,KAAJ,CACF,gDAA8C,GAA9C,GAAiD,KAAjD,GACA,iKADA,IAEA,yFACI,KAAK,QAAL,CAAc,IADlB,GACsB,IAHtB,CADE,CAAN;AAKD,KAPS;;AAQZ,WAAA,UAAA;AAAC,GA3CD,EAAA;;AAAa,EAAA,OAAA,CAAA,UAAA,GAAA,UAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {LockFile} from './lock_file';\n\n/**\n * SyncLocker is used to prevent more than one instance of ngcc executing at the same time,\n * when being called in a synchronous context.\n *\n * * When ngcc starts executing, it creates a file in the `compiler-cli/ngcc` folder.\n * * If it finds one is already there then it fails with a suitable error message.\n * * When ngcc completes executing, it removes the file so that future ngcc executions can start.\n */\nexport class SyncLocker {\n  constructor(private lockFile: LockFile) {}\n\n  /**\n   * Run the given function guarded by the lock file.\n   *\n   * @param fn the function to run.\n   * @returns the value returned from the `fn` call.\n   */\n  lock<T>(fn: () => T): T {\n    this.create();\n    try {\n      return fn();\n    } finally {\n      this.lockFile.remove();\n    }\n  }\n\n  /**\n   * Write a lock file to disk, or error if there is already one there.\n   */\n  protected create(): void {\n    try {\n      this.lockFile.write();\n    } catch (e) {\n      if (e.code !== 'EEXIST') {\n        throw e;\n      }\n      this.handleExistingLockFile();\n    }\n  }\n\n  /**\n   * The lock-file already exists so raise a helpful error.\n   */\n  protected handleExistingLockFile(): void {\n    const pid = this.lockFile.read();\n    throw new Error(\n        `ngcc is already running at process with id ${pid}.\\n` +\n        `If you are running multiple builds in parallel then you might try pre-processing your node_modules via the command line ngcc tool before starting the builds.\\n` +\n        `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n            this.lockFile.path}.)`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}