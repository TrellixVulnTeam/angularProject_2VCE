{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/metadata/src/property_mapping\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ClassPropertyMapping = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * A mapping of component property and template binding property names, for example containing the\n   * inputs of a particular directive or component.\n   *\n   * A single component property has exactly one input/output annotation (and therefore one binding\n   * property name) associated with it, but the same binding property name may be shared across many\n   * component property names.\n   *\n   * Allows bidirectional querying of the mapping - looking up all inputs/outputs with a given\n   * property name, or mapping from a specific class property to its binding property name.\n   */\n\n\n  var ClassPropertyMapping =\n  /** @class */\n  function () {\n    function ClassPropertyMapping(forwardMap) {\n      this.forwardMap = forwardMap;\n      this.reverseMap = reverseMapFromForwardMap(forwardMap);\n    }\n    /**\n     * Construct a `ClassPropertyMapping` with no entries.\n     */\n\n\n    ClassPropertyMapping.empty = function () {\n      return new ClassPropertyMapping(new Map());\n    };\n    /**\n     * Construct a `ClassPropertyMapping` from a primitive JS object which maps class property names\n     * to either binding property names or an array that contains both names, which is used in on-disk\n     * metadata formats (e.g. in .d.ts files).\n     */\n\n\n    ClassPropertyMapping.fromMappedObject = function (obj) {\n      var e_1, _a;\n\n      var forwardMap = new Map();\n\n      try {\n        for (var _b = tslib_1.__values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var classPropertyName = _c.value;\n          var value = obj[classPropertyName];\n          var bindingPropertyName = Array.isArray(value) ? value[0] : value;\n          var inputOrOutput = {\n            classPropertyName: classPropertyName,\n            bindingPropertyName: bindingPropertyName\n          };\n          forwardMap.set(classPropertyName, inputOrOutput);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return new ClassPropertyMapping(forwardMap);\n    };\n    /**\n     * Merge two mappings into one, with class properties from `b` taking precedence over class\n     * properties from `a`.\n     */\n\n\n    ClassPropertyMapping.merge = function (a, b) {\n      var e_2, _a;\n\n      var forwardMap = new Map(a.forwardMap.entries());\n\n      try {\n        for (var _b = tslib_1.__values(b.forwardMap), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = tslib_1.__read(_c.value, 2),\n              classPropertyName = _d[0],\n              inputOrOutput = _d[1];\n\n          forwardMap.set(classPropertyName, inputOrOutput);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return new ClassPropertyMapping(forwardMap);\n    };\n\n    Object.defineProperty(ClassPropertyMapping.prototype, \"classPropertyNames\", {\n      /**\n       * All class property names mapped in this mapping.\n       */\n      get: function get() {\n        return Array.from(this.forwardMap.keys());\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(ClassPropertyMapping.prototype, \"propertyNames\", {\n      /**\n       * All binding property names mapped in this mapping.\n       */\n      get: function get() {\n        return Array.from(this.reverseMap.keys());\n      },\n      enumerable: false,\n      configurable: true\n    });\n    /**\n     * Check whether a mapping for the given property name exists.\n     */\n\n    ClassPropertyMapping.prototype.hasBindingPropertyName = function (propertyName) {\n      return this.reverseMap.has(propertyName);\n    };\n    /**\n     * Lookup all `InputOrOutput`s that use this `propertyName`.\n     */\n\n\n    ClassPropertyMapping.prototype.getByBindingPropertyName = function (propertyName) {\n      return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName) : null;\n    };\n    /**\n     * Lookup the `InputOrOutput` associated with a `classPropertyName`.\n     */\n\n\n    ClassPropertyMapping.prototype.getByClassPropertyName = function (classPropertyName) {\n      return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName) : null;\n    };\n    /**\n     * Convert this mapping to a primitive JS object which maps each class property directly to the\n     * binding property name associated with it.\n     */\n\n\n    ClassPropertyMapping.prototype.toDirectMappedObject = function () {\n      var e_3, _a;\n\n      var obj = {};\n\n      try {\n        for (var _b = tslib_1.__values(this.forwardMap), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = tslib_1.__read(_c.value, 2),\n              classPropertyName = _d[0],\n              inputOrOutput = _d[1];\n\n          obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return obj;\n    };\n    /**\n     * Convert this mapping to a primitive JS object which maps each class property either to itself\n     * (for cases where the binding property name is the same) or to an array which contains both\n     * names if they differ.\n     *\n     * This object format is used when mappings are serialized (for example into .d.ts files).\n     */\n\n\n    ClassPropertyMapping.prototype.toJointMappedObject = function () {\n      var e_4, _a;\n\n      var obj = {};\n\n      try {\n        for (var _b = tslib_1.__values(this.forwardMap), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = tslib_1.__read(_c.value, 2),\n              classPropertyName = _d[0],\n              inputOrOutput = _d[1];\n\n          if (inputOrOutput.bindingPropertyName === classPropertyName) {\n            obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n          } else {\n            obj[classPropertyName] = [inputOrOutput.bindingPropertyName, classPropertyName];\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      return obj;\n    };\n    /**\n     * Implement the iterator protocol and return entry objects which contain the class and binding\n     * property names (and are useful for destructuring).\n     */\n\n\n    ClassPropertyMapping.prototype[Symbol.iterator] = function () {\n      var _a, _b, _c, classPropertyName, inputOrOutput, e_5_1;\n\n      var e_5, _d;\n\n      return tslib_1.__generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _e.trys.push([0, 5, 6, 7]);\n\n            _a = tslib_1.__values(this.forwardMap.entries()), _b = _a.next();\n            _e.label = 1;\n\n          case 1:\n            if (!!_b.done) return [3\n            /*break*/\n            , 4];\n            _c = tslib_1.__read(_b.value, 2), classPropertyName = _c[0], inputOrOutput = _c[1];\n            return [4\n            /*yield*/\n            , [classPropertyName, inputOrOutput.bindingPropertyName]];\n\n          case 2:\n            _e.sent();\n\n            _e.label = 3;\n\n          case 3:\n            _b = _a.next();\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            e_5_1 = _e.sent();\n            e_5 = {\n              error: e_5_1\n            };\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            try {\n              if (_b && !_b.done && (_d = _a.return)) _d.call(_a);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n\n            return [7\n            /*endfinally*/\n            ];\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    };\n\n    return ClassPropertyMapping;\n  }();\n\n  exports.ClassPropertyMapping = ClassPropertyMapping;\n\n  function reverseMapFromForwardMap(forwardMap) {\n    var e_6, _a;\n\n    var reverseMap = new Map();\n\n    try {\n      for (var forwardMap_1 = tslib_1.__values(forwardMap), forwardMap_1_1 = forwardMap_1.next(); !forwardMap_1_1.done; forwardMap_1_1 = forwardMap_1.next()) {\n        var _b = tslib_1.__read(forwardMap_1_1.value, 2),\n            _ = _b[0],\n            inputOrOutput = _b[1];\n\n        if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {\n          reverseMap.set(inputOrOutput.bindingPropertyName, []);\n        }\n\n        reverseMap.get(inputOrOutput.bindingPropertyName).push(inputOrOutput);\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (forwardMap_1_1 && !forwardMap_1_1.done && (_a = forwardMap_1.return)) _a.call(forwardMap_1);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    return reverseMap;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/property_mapping.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InputOutputPropertySet} from '@angular/compiler';\n\n/**\n * The name of a class property that backs an input or output declared by a directive or component.\n *\n * This type exists for documentation only.\n */\nexport type ClassPropertyName = string;\n\n/**\n * The name by which an input or output of a directive or component is bound in an Angular template.\n *\n * This type exists for documentation only.\n */\nexport type BindingPropertyName = string;\n\n/**\n * An input or output of a directive that has both a named JavaScript class property on a component\n * or directive class, as well as an Angular template property name used for binding.\n */\nexport interface InputOrOutput {\n  /**\n   * The name of the JavaScript property on the component or directive instance for this input or\n   * output.\n   */\n  readonly classPropertyName: ClassPropertyName;\n\n  /**\n   * The property name used to bind this input or output in an Angular template.\n   */\n  readonly bindingPropertyName: BindingPropertyName;\n}\n\n/**\n * A mapping of component property and template binding property names, for example containing the\n * inputs of a particular directive or component.\n *\n * A single component property has exactly one input/output annotation (and therefore one binding\n * property name) associated with it, but the same binding property name may be shared across many\n * component property names.\n *\n * Allows bidirectional querying of the mapping - looking up all inputs/outputs with a given\n * property name, or mapping from a specific class property to its binding property name.\n */\nexport class ClassPropertyMapping implements InputOutputPropertySet {\n  /**\n   * Mapping from class property names to the single `InputOrOutput` for that class property.\n   */\n  private forwardMap: Map<ClassPropertyName, InputOrOutput>;\n\n  /**\n   * Mapping from property names to one or more `InputOrOutput`s which share that name.\n   */\n  private reverseMap: Map<BindingPropertyName, InputOrOutput[]>;\n\n  private constructor(forwardMap: Map<ClassPropertyName, InputOrOutput>) {\n    this.forwardMap = forwardMap;\n    this.reverseMap = reverseMapFromForwardMap(forwardMap);\n  }\n\n  /**\n   * Construct a `ClassPropertyMapping` with no entries.\n   */\n  static empty(): ClassPropertyMapping {\n    return new ClassPropertyMapping(new Map());\n  }\n\n  /**\n   * Construct a `ClassPropertyMapping` from a primitive JS object which maps class property names\n   * to either binding property names or an array that contains both names, which is used in on-disk\n   * metadata formats (e.g. in .d.ts files).\n   */\n  static fromMappedObject(obj: {\n    [classPropertyName: string]: BindingPropertyName|[ClassPropertyName, BindingPropertyName]\n  }): ClassPropertyMapping {\n    const forwardMap = new Map<ClassPropertyName, InputOrOutput>();\n\n    for (const classPropertyName of Object.keys(obj)) {\n      const value = obj[classPropertyName];\n      const bindingPropertyName = Array.isArray(value) ? value[0] : value;\n      const inputOrOutput: InputOrOutput = {classPropertyName, bindingPropertyName};\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n\n    return new ClassPropertyMapping(forwardMap);\n  }\n\n  /**\n   * Merge two mappings into one, with class properties from `b` taking precedence over class\n   * properties from `a`.\n   */\n  static merge(a: ClassPropertyMapping, b: ClassPropertyMapping): ClassPropertyMapping {\n    const forwardMap = new Map<ClassPropertyName, InputOrOutput>(a.forwardMap.entries());\n    for (const [classPropertyName, inputOrOutput] of b.forwardMap) {\n      forwardMap.set(classPropertyName, inputOrOutput);\n    }\n\n    return new ClassPropertyMapping(forwardMap);\n  }\n\n  /**\n   * All class property names mapped in this mapping.\n   */\n  get classPropertyNames(): ClassPropertyName[] {\n    return Array.from(this.forwardMap.keys());\n  }\n\n  /**\n   * All binding property names mapped in this mapping.\n   */\n  get propertyNames(): BindingPropertyName[] {\n    return Array.from(this.reverseMap.keys());\n  }\n\n  /**\n   * Check whether a mapping for the given property name exists.\n   */\n  hasBindingPropertyName(propertyName: BindingPropertyName): boolean {\n    return this.reverseMap.has(propertyName);\n  }\n\n  /**\n   * Lookup all `InputOrOutput`s that use this `propertyName`.\n   */\n  getByBindingPropertyName(propertyName: string): ReadonlyArray<InputOrOutput>|null {\n    return this.reverseMap.has(propertyName) ? this.reverseMap.get(propertyName)! : null;\n  }\n\n  /**\n   * Lookup the `InputOrOutput` associated with a `classPropertyName`.\n   */\n  getByClassPropertyName(classPropertyName: string): InputOrOutput|null {\n    return this.forwardMap.has(classPropertyName) ? this.forwardMap.get(classPropertyName)! : null;\n  }\n\n  /**\n   * Convert this mapping to a primitive JS object which maps each class property directly to the\n   * binding property name associated with it.\n   */\n  toDirectMappedObject(): {[classPropertyName: string]: BindingPropertyName} {\n    const obj: {[classPropertyName: string]: BindingPropertyName} = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n    }\n    return obj;\n  }\n\n  /**\n   * Convert this mapping to a primitive JS object which maps each class property either to itself\n   * (for cases where the binding property name is the same) or to an array which contains both\n   * names if they differ.\n   *\n   * This object format is used when mappings are serialized (for example into .d.ts files).\n   */\n  toJointMappedObject():\n      {[classPropertyName: string]: BindingPropertyName|[BindingPropertyName, ClassPropertyName]} {\n    const obj: {\n      [classPropertyName: string]: BindingPropertyName|[BindingPropertyName, ClassPropertyName]\n    } = {};\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap) {\n      if (inputOrOutput.bindingPropertyName as string === classPropertyName as string) {\n        obj[classPropertyName] = inputOrOutput.bindingPropertyName;\n      } else {\n        obj[classPropertyName] = [inputOrOutput.bindingPropertyName, classPropertyName];\n      }\n    }\n    return obj;\n  }\n\n  /**\n   * Implement the iterator protocol and return entry objects which contain the class and binding\n   * property names (and are useful for destructuring).\n   */\n  * [Symbol.iterator](): IterableIterator<[ClassPropertyName, BindingPropertyName]> {\n    for (const [classPropertyName, inputOrOutput] of this.forwardMap.entries()) {\n      yield [classPropertyName, inputOrOutput.bindingPropertyName];\n    }\n  }\n}\n\nfunction reverseMapFromForwardMap(forwardMap: Map<ClassPropertyName, InputOrOutput>):\n    Map<BindingPropertyName, InputOrOutput[]> {\n  const reverseMap = new Map<BindingPropertyName, InputOrOutput[]>();\n  for (const [_, inputOrOutput] of forwardMap) {\n    if (!reverseMap.has(inputOrOutput.bindingPropertyName)) {\n      reverseMap.set(inputOrOutput.bindingPropertyName, []);\n    }\n\n    reverseMap.get(inputOrOutput.bindingPropertyName)!.push(inputOrOutput);\n  }\n  return reverseMap;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}