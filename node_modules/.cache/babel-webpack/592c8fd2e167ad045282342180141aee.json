{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scheduleByTarget = exports.scheduleByName = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar core_1 = require(\"@angular-devkit/core\");\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar api_1 = require(\"./api\");\n\nvar progressSchema = require('./progress-schema.json');\n\nvar _uniqueId = 0;\n\nfunction scheduleByName(_x, _x2, _x3) {\n  return _scheduleByName.apply(this, arguments);\n}\n\nfunction _scheduleByName() {\n  _scheduleByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name, buildOptions, options) {\n    var childLoggerName, logger, job, stateSubscription, workspaceRoot, currentDirectory, description, info, id, message, logChannelSub, s, output, reporter;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            childLoggerName = options.target ? \"{\".concat(api_1.targetStringFromTarget(options.target), \"}\") : name;\n            logger = options.logger.createChild(childLoggerName);\n            job = options.scheduler.schedule(name, {});\n            _context.next = 5;\n            return options.workspaceRoot;\n\n          case 5:\n            workspaceRoot = _context.sent;\n            _context.next = 8;\n            return options.currentDirectory;\n\n          case 8:\n            currentDirectory = _context.sent;\n            _context.next = 11;\n            return job.description.toPromise();\n\n          case 11:\n            description = _context.sent;\n            info = description.info;\n            id = ++_uniqueId;\n            message = _objectSpread({\n              id: id,\n              currentDirectory: currentDirectory,\n              workspaceRoot: workspaceRoot,\n              info: info,\n              options: buildOptions\n            }, options.target ? {\n              target: options.target\n            } : {}); // Wait for the job to be ready.\n\n            if (job.state !== core_1.experimental.jobs.JobState.Started) {\n              stateSubscription = job.outboundBus.subscribe(function (event) {\n                if (event.kind === core_1.experimental.jobs.JobOutboundMessageKind.Start) {\n                  job.input.next(message);\n                }\n              }, function () {});\n            } else {\n              job.input.next(message);\n            }\n\n            logChannelSub = job.getChannel('log').subscribe(function (entry) {\n              logger.next(entry);\n            }, function () {});\n            s = job.outboundBus.subscribe({\n              error: function error() {},\n              complete: function complete() {\n                s.unsubscribe();\n                logChannelSub.unsubscribe();\n\n                if (stateSubscription) {\n                  stateSubscription.unsubscribe();\n                }\n              }\n            });\n            output = job.output.pipe(operators_1.map(function (output) {\n              return _objectSpread(_objectSpread(_objectSpread({}, output), options.target ? {\n                target: options.target\n              } : 0), {}, {\n                info: info\n              });\n            }), operators_1.shareReplay()); // If there's an analytics object, take the job channel and report it to the analytics.\n\n            if (options.analytics) {\n              reporter = new core_1.analytics.AnalyticsReporter(options.analytics);\n              job.getChannel('analytics').subscribe(function (report) {\n                return reporter.report(report);\n              });\n            } // Start the builder.\n\n\n            output.pipe(operators_1.first()).subscribe({\n              error: function error() {}\n            });\n            _context.t0 = id;\n            _context.t1 = info;\n            _context.t2 = output;\n            _context.t3 = job.getChannel('progress', progressSchema).pipe(operators_1.shareReplay(1));\n\n            _context.t4 = function stop() {\n              job.stop();\n              return job.outboundBus.pipe(operators_1.ignoreElements(), operators_1.catchError(function () {\n                return rxjs_1.EMPTY;\n              })).toPromise();\n            };\n\n            return _context.abrupt(\"return\", {\n              id: _context.t0,\n              info: _context.t1,\n\n              // This is a getter so that it always returns the next output, and not the same one.\n              get result() {\n                return output.pipe(operators_1.first()).toPromise();\n              },\n\n              output: _context.t2,\n              progress: _context.t3,\n              stop: _context.t4\n            });\n\n          case 27:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _scheduleByName.apply(this, arguments);\n}\n\nexports.scheduleByName = scheduleByName;\n\nfunction scheduleByTarget(_x4, _x5, _x6) {\n  return _scheduleByTarget.apply(this, arguments);\n}\n\nfunction _scheduleByTarget() {\n  _scheduleByTarget = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(target, overrides, options) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", scheduleByName(\"{\".concat(api_1.targetStringFromTarget(target), \"}\"), overrides, _objectSpread(_objectSpread({}, options), {}, {\n              target: target,\n              logger: options.logger\n            })));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _scheduleByTarget.apply(this, arguments);\n}\n\nexports.scheduleByTarget = scheduleByTarget;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/architect/src/schedule-by-name.js"],"names":["Object","defineProperty","exports","value","scheduleByTarget","scheduleByName","core_1","require","rxjs_1","operators_1","api_1","progressSchema","_uniqueId","name","buildOptions","options","childLoggerName","target","targetStringFromTarget","logger","createChild","job","scheduler","schedule","workspaceRoot","currentDirectory","description","toPromise","info","id","message","state","experimental","jobs","JobState","Started","stateSubscription","outboundBus","subscribe","event","kind","JobOutboundMessageKind","Start","input","next","logChannelSub","getChannel","entry","s","error","complete","unsubscribe","output","pipe","map","shareReplay","analytics","reporter","AnalyticsReporter","report","first","stop","ignoreElements","catchError","EMPTY","result","progress","overrides"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.scheduleByTarget = exports.scheduleByName = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst core_1 = require(\"@angular-devkit/core\");\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst api_1 = require(\"./api\");\nconst progressSchema = require('./progress-schema.json');\nlet _uniqueId = 0;\nasync function scheduleByName(name, buildOptions, options) {\n    const childLoggerName = options.target ? `{${api_1.targetStringFromTarget(options.target)}}` : name;\n    const logger = options.logger.createChild(childLoggerName);\n    const job = options.scheduler.schedule(name, {});\n    let stateSubscription;\n    const workspaceRoot = await options.workspaceRoot;\n    const currentDirectory = await options.currentDirectory;\n    const description = await job.description.toPromise();\n    const info = description.info;\n    const id = ++_uniqueId;\n    const message = {\n        id,\n        currentDirectory,\n        workspaceRoot,\n        info: info,\n        options: buildOptions,\n        ...(options.target ? { target: options.target } : {}),\n    };\n    // Wait for the job to be ready.\n    if (job.state !== core_1.experimental.jobs.JobState.Started) {\n        stateSubscription = job.outboundBus.subscribe(event => {\n            if (event.kind === core_1.experimental.jobs.JobOutboundMessageKind.Start) {\n                job.input.next(message);\n            }\n        }, () => { });\n    }\n    else {\n        job.input.next(message);\n    }\n    const logChannelSub = job.getChannel('log').subscribe(entry => {\n        logger.next(entry);\n    }, () => { });\n    const s = job.outboundBus.subscribe({\n        error() { },\n        complete() {\n            s.unsubscribe();\n            logChannelSub.unsubscribe();\n            if (stateSubscription) {\n                stateSubscription.unsubscribe();\n            }\n        },\n    });\n    const output = job.output.pipe(operators_1.map(output => ({\n        ...output,\n        ...options.target ? { target: options.target } : 0,\n        info,\n    })), operators_1.shareReplay());\n    // If there's an analytics object, take the job channel and report it to the analytics.\n    if (options.analytics) {\n        const reporter = new core_1.analytics.AnalyticsReporter(options.analytics);\n        job.getChannel('analytics')\n            .subscribe(report => reporter.report(report));\n    }\n    // Start the builder.\n    output.pipe(operators_1.first()).subscribe({\n        error() { },\n    });\n    return {\n        id,\n        info,\n        // This is a getter so that it always returns the next output, and not the same one.\n        get result() { return output.pipe(operators_1.first()).toPromise(); },\n        output,\n        progress: job.getChannel('progress', progressSchema).pipe(operators_1.shareReplay(1)),\n        stop() {\n            job.stop();\n            return job.outboundBus.pipe(operators_1.ignoreElements(), operators_1.catchError(() => rxjs_1.EMPTY)).toPromise();\n        },\n    };\n}\nexports.scheduleByName = scheduleByName;\nasync function scheduleByTarget(target, overrides, options) {\n    return scheduleByName(`{${api_1.targetStringFromTarget(target)}}`, overrides, {\n        ...options,\n        target,\n        logger: options.logger,\n    });\n}\nexports.scheduleByTarget = scheduleByTarget;\n"]},"metadata":{},"sourceType":"script"}