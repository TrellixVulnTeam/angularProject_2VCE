{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/scope/src/typecheck\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/metadata\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeCheckScopeRegistry = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata\");\n  /**\n   * Computes scope information to be used in template type checking.\n   */\n\n\n  var TypeCheckScopeRegistry =\n  /** @class */\n  function () {\n    function TypeCheckScopeRegistry(scopeReader, metaReader) {\n      this.scopeReader = scopeReader;\n      this.metaReader = metaReader;\n      /**\n       * Cache of flattened directive metadata. Because flattened metadata is scope-invariant it's\n       * cached individually, such that all scopes refer to the same flattened metadata.\n       */\n\n      this.flattenedDirectiveMetaCache = new Map();\n      /**\n       * Cache of the computed type check scope per NgModule declaration.\n       */\n\n      this.scopeCache = new Map();\n    }\n    /**\n     * Computes the type-check scope information for the component declaration. If the NgModule\n     * contains an error, then 'error' is returned. If the component is not declared in any NgModule,\n     * an empty type-check scope is returned.\n     */\n\n\n    TypeCheckScopeRegistry.prototype.getTypeCheckScope = function (node) {\n      var e_1, _a, e_2, _b;\n\n      var matcher = new compiler_1.SelectorMatcher();\n      var directives = [];\n      var pipes = new Map();\n      var scope = this.scopeReader.getScopeForComponent(node);\n\n      if (scope === null) {\n        return {\n          matcher: matcher,\n          directives: directives,\n          pipes: pipes,\n          schemas: [],\n          isPoisoned: false\n        };\n      }\n\n      if (this.scopeCache.has(scope.ngModule)) {\n        return this.scopeCache.get(scope.ngModule);\n      }\n\n      try {\n        for (var _c = tslib_1.__values(scope.compilation.directives), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var meta = _d.value;\n\n          if (meta.selector !== null) {\n            var extMeta = this.getTypeCheckDirectiveMetadata(meta.ref);\n            matcher.addSelectables(compiler_1.CssSelector.parse(meta.selector), extMeta);\n            directives.push(extMeta);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        for (var _e = tslib_1.__values(scope.compilation.pipes), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var _g = _f.value,\n              name_1 = _g.name,\n              ref = _g.ref;\n\n          if (!ts.isClassDeclaration(ref.node)) {\n            throw new Error(\"Unexpected non-class declaration \" + ts.SyntaxKind[ref.node.kind] + \" for pipe \" + ref.debugName);\n          }\n\n          pipes.set(name_1, ref);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      var typeCheckScope = {\n        matcher: matcher,\n        directives: directives,\n        pipes: pipes,\n        schemas: scope.schemas,\n        isPoisoned: scope.compilation.isPoisoned || scope.exported.isPoisoned\n      };\n      this.scopeCache.set(scope.ngModule, typeCheckScope);\n      return typeCheckScope;\n    };\n\n    TypeCheckScopeRegistry.prototype.getTypeCheckDirectiveMetadata = function (ref) {\n      var clazz = ref.node;\n\n      if (this.flattenedDirectiveMetaCache.has(clazz)) {\n        return this.flattenedDirectiveMetaCache.get(clazz);\n      }\n\n      var meta = metadata_1.flattenInheritedDirectiveMetadata(this.metaReader, ref);\n      this.flattenedDirectiveMetaCache.set(clazz, meta);\n      return meta;\n    };\n\n    return TypeCheckScopeRegistry;\n  }();\n\n  exports.TypeCheckScopeRegistry = TypeCheckScopeRegistry;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/typecheck.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CssSelector, SchemaMetadata, SelectorMatcher} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {DirectiveMeta, flattenInheritedDirectiveMetadata, MetadataReader} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ComponentScopeReader} from './component_scope';\n\n/**\n * The scope that is used for type-check code generation of a component template.\n */\nexport interface TypeCheckScope {\n  /**\n   * A `SelectorMatcher` instance that contains the flattened directive metadata of all directives\n   * that are in the compilation scope of the declaring NgModule.\n   */\n  matcher: SelectorMatcher<DirectiveMeta>;\n\n  /**\n   * All of the directives available in the compilation scope of the declaring NgModule.\n   */\n  directives: DirectiveMeta[];\n\n  /**\n   * The pipes that are available in the compilation scope.\n   */\n  pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>;\n\n  /**\n   * The schemas that are used in this scope.\n   */\n  schemas: SchemaMetadata[];\n\n  /**\n   * Whether the original compilation scope which produced this `TypeCheckScope` was itself poisoned\n   * (contained semantic errors during its production).\n   */\n  isPoisoned: boolean;\n}\n\n/**\n * Computes scope information to be used in template type checking.\n */\nexport class TypeCheckScopeRegistry {\n  /**\n   * Cache of flattened directive metadata. Because flattened metadata is scope-invariant it's\n   * cached individually, such that all scopes refer to the same flattened metadata.\n   */\n  private flattenedDirectiveMetaCache = new Map<ClassDeclaration, DirectiveMeta>();\n\n  /**\n   * Cache of the computed type check scope per NgModule declaration.\n   */\n  private scopeCache = new Map<ClassDeclaration, TypeCheckScope>();\n\n  constructor(private scopeReader: ComponentScopeReader, private metaReader: MetadataReader) {}\n\n  /**\n   * Computes the type-check scope information for the component declaration. If the NgModule\n   * contains an error, then 'error' is returned. If the component is not declared in any NgModule,\n   * an empty type-check scope is returned.\n   */\n  getTypeCheckScope(node: ClassDeclaration): TypeCheckScope {\n    const matcher = new SelectorMatcher<DirectiveMeta>();\n    const directives: DirectiveMeta[] = [];\n    const pipes = new Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>();\n\n    const scope = this.scopeReader.getScopeForComponent(node);\n    if (scope === null) {\n      return {\n        matcher,\n        directives,\n        pipes,\n        schemas: [],\n        isPoisoned: false,\n      };\n    }\n\n    if (this.scopeCache.has(scope.ngModule)) {\n      return this.scopeCache.get(scope.ngModule)!;\n    }\n\n    for (const meta of scope.compilation.directives) {\n      if (meta.selector !== null) {\n        const extMeta = this.getTypeCheckDirectiveMetadata(meta.ref);\n        matcher.addSelectables(CssSelector.parse(meta.selector), extMeta);\n        directives.push(extMeta);\n      }\n    }\n\n    for (const {name, ref} of scope.compilation.pipes) {\n      if (!ts.isClassDeclaration(ref.node)) {\n        throw new Error(`Unexpected non-class declaration ${\n            ts.SyntaxKind[ref.node.kind]} for pipe ${ref.debugName}`);\n      }\n      pipes.set(name, ref as Reference<ClassDeclaration<ts.ClassDeclaration>>);\n    }\n\n    const typeCheckScope: TypeCheckScope = {\n      matcher,\n      directives,\n      pipes,\n      schemas: scope.schemas,\n      isPoisoned: scope.compilation.isPoisoned || scope.exported.isPoisoned,\n    };\n    this.scopeCache.set(scope.ngModule, typeCheckScope);\n    return typeCheckScope;\n  }\n\n  getTypeCheckDirectiveMetadata(ref: Reference<ClassDeclaration>): DirectiveMeta {\n    const clazz = ref.node;\n    if (this.flattenedDirectiveMetaCache.has(clazz)) {\n      return this.flattenedDirectiveMetaCache.get(clazz)!;\n    }\n\n    const meta = flattenInheritedDirectiveMetadata(this.metaReader, ref);\n    this.flattenedDirectiveMetaCache.set(clazz, meta);\n    return meta;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}