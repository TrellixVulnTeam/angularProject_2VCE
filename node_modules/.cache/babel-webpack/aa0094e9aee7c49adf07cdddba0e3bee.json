{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_check_file\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/translator\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/environment\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_check_block\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.typeCheckFilePath = exports.TypeCheckFile = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var translator_1 = require(\"@angular/compiler-cli/src/ngtsc/translator\");\n\n  var environment_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/environment\");\n\n  var type_check_block_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_check_block\");\n  /**\n   * An `Environment` representing the single type-checking file into which most (if not all) Type\n   * Check Blocks (TCBs) will be generated.\n   *\n   * The `TypeCheckFile` hosts multiple TCBs and allows the sharing of declarations (e.g. type\n   * constructors) between them. Rather than return such declarations via `getPreludeStatements()`, it\n   * hoists them to the top of the generated `ts.SourceFile`.\n   */\n\n\n  var TypeCheckFile =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TypeCheckFile, _super);\n\n    function TypeCheckFile(fileName, config, refEmitter, reflector, compilerHost) {\n      var _this = _super.call(this, config, new translator_1.ImportManager(new imports_1.NoopImportRewriter(), 'i'), refEmitter, reflector, ts.createSourceFile(compilerHost.getCanonicalFileName(fileName), '', ts.ScriptTarget.Latest, true)) || this;\n\n      _this.fileName = fileName;\n      _this.nextTcbId = 1;\n      _this.tcbStatements = [];\n      return _this;\n    }\n\n    TypeCheckFile.prototype.addTypeCheckBlock = function (ref, meta, domSchemaChecker, oobRecorder, genericContextBehavior) {\n      var fnId = ts.createIdentifier(\"_tcb\" + this.nextTcbId++);\n      var fn = type_check_block_1.generateTypeCheckBlock(this, ref, fnId, meta, domSchemaChecker, oobRecorder, genericContextBehavior);\n      this.tcbStatements.push(fn);\n    };\n\n    TypeCheckFile.prototype.render = function (removeComments) {\n      var e_1, _a, e_2, _b, e_3, _c;\n\n      var source = this.importManager.getAllImports(this.contextFile.fileName).map(function (i) {\n        return \"import * as \" + i.qualifier.text + \" from '\" + i.specifier + \"';\";\n      }).join('\\n') + '\\n\\n';\n      var printer = ts.createPrinter({\n        removeComments: removeComments\n      });\n      source += '\\n';\n\n      try {\n        for (var _d = tslib_1.__values(this.pipeInstStatements), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var stmt = _e.value;\n          source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        for (var _f = tslib_1.__values(this.typeCtorStatements), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var stmt = _g.value;\n          source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      source += '\\n';\n\n      try {\n        for (var _h = tslib_1.__values(this.tcbStatements), _j = _h.next(); !_j.done; _j = _h.next()) {\n          var stmt = _j.value;\n          source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      } // Ensure the template type-checking file is an ES module. Otherwise, it's interpreted as some\n      // kind of global namespace in TS, which forces a full re-typecheck of the user's program that\n      // is somehow more expensive than the initial parse.\n\n\n      source += '\\nexport const IS_A_MODULE = true;\\n';\n      return source;\n    };\n\n    TypeCheckFile.prototype.getPreludeStatements = function () {\n      return [];\n    };\n\n    return TypeCheckFile;\n  }(environment_1.Environment);\n\n  exports.TypeCheckFile = TypeCheckFile;\n\n  function typeCheckFilePath(rootDirs) {\n    var shortest = rootDirs.concat([]).sort(function (a, b) {\n      return a.length - b.length;\n    })[0];\n    return file_system_1.join(shortest, '__ng_typecheck__.ts');\n  }\n\n  exports.typeCheckFilePath = typeCheckFilePath;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_check_file.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath, join} from '../../file_system';\nimport {NoopImportRewriter, Reference, ReferenceEmitter} from '../../imports';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ImportManager} from '../../translator';\nimport {TypeCheckBlockMetadata, TypeCheckingConfig} from '../api';\n\nimport {DomSchemaChecker} from './dom';\nimport {Environment} from './environment';\nimport {OutOfBandDiagnosticRecorder} from './oob';\nimport {generateTypeCheckBlock, TcbGenericContextBehavior} from './type_check_block';\n\n\n\n/**\n * An `Environment` representing the single type-checking file into which most (if not all) Type\n * Check Blocks (TCBs) will be generated.\n *\n * The `TypeCheckFile` hosts multiple TCBs and allows the sharing of declarations (e.g. type\n * constructors) between them. Rather than return such declarations via `getPreludeStatements()`, it\n * hoists them to the top of the generated `ts.SourceFile`.\n */\nexport class TypeCheckFile extends Environment {\n  private nextTcbId = 1;\n  private tcbStatements: ts.Statement[] = [];\n\n  constructor(\n      readonly fileName: AbsoluteFsPath, config: TypeCheckingConfig, refEmitter: ReferenceEmitter,\n      reflector: ReflectionHost, compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>) {\n    super(\n        config, new ImportManager(new NoopImportRewriter(), 'i'), refEmitter, reflector,\n        ts.createSourceFile(\n            compilerHost.getCanonicalFileName(fileName), '', ts.ScriptTarget.Latest, true));\n  }\n\n  addTypeCheckBlock(\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, meta: TypeCheckBlockMetadata,\n      domSchemaChecker: DomSchemaChecker, oobRecorder: OutOfBandDiagnosticRecorder,\n      genericContextBehavior: TcbGenericContextBehavior): void {\n    const fnId = ts.createIdentifier(`_tcb${this.nextTcbId++}`);\n    const fn = generateTypeCheckBlock(\n        this, ref, fnId, meta, domSchemaChecker, oobRecorder, genericContextBehavior);\n    this.tcbStatements.push(fn);\n  }\n\n  render(removeComments: boolean): string {\n    let source: string = this.importManager.getAllImports(this.contextFile.fileName)\n                             .map(i => `import * as ${i.qualifier.text} from '${i.specifier}';`)\n                             .join('\\n') +\n        '\\n\\n';\n    const printer = ts.createPrinter({removeComments});\n    source += '\\n';\n    for (const stmt of this.pipeInstStatements) {\n      source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n    }\n    for (const stmt of this.typeCtorStatements) {\n      source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n    }\n    source += '\\n';\n    for (const stmt of this.tcbStatements) {\n      source += printer.printNode(ts.EmitHint.Unspecified, stmt, this.contextFile) + '\\n';\n    }\n\n    // Ensure the template type-checking file is an ES module. Otherwise, it's interpreted as some\n    // kind of global namespace in TS, which forces a full re-typecheck of the user's program that\n    // is somehow more expensive than the initial parse.\n    source += '\\nexport const IS_A_MODULE = true;\\n';\n\n    return source;\n  }\n\n  getPreludeStatements(): ts.Statement[] {\n    return [];\n  }\n}\n\nexport function typeCheckFilePath(rootDirs: AbsoluteFsPath[]): AbsoluteFsPath {\n  const shortest = rootDirs.concat([]).sort((a, b) => a.length - b.length)[0];\n  return join(shortest, '__ng_typecheck__.ts');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}