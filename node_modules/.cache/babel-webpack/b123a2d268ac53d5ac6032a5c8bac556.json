{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseDataUrl;\n\nvar _whatwgMimetype = _interopRequireDefault(require(\"whatwg-mimetype\"));\n\nvar _abab = require(\"abab\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction isASCIIHex(c) {\n  return c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;\n}\n\nfunction percentDecodeBytes(input) {\n  var output = new Uint8Array(input.byteLength);\n  var outputIndex = 0;\n\n  for (var i = 0; i < input.byteLength; ++i) {\n    var byte = input[i];\n\n    if (byte !== 0x25) {\n      output[outputIndex] = byte;\n    } else if (byte === 0x25 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {\n      output[outputIndex] = byte;\n    } else {\n      output[outputIndex] = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);\n      i += 2;\n    }\n\n    outputIndex += 1;\n  }\n\n  return output.slice(0, outputIndex);\n}\n\nfunction parseDataUrl(stringInput) {\n  var parsedUrl;\n\n  try {\n    parsedUrl = new URL(stringInput);\n  } catch (error) {\n    return null;\n  }\n\n  if (parsedUrl.protocol !== 'data:') {\n    return null;\n  }\n\n  parsedUrl.hash = ''; // `5` is value of `'data:'.length`\n\n  var input = parsedUrl.toString().substring(5);\n  var position = 0;\n  var mimeType = '';\n\n  while (position < input.length && input[position] !== ',') {\n    mimeType += input[position];\n    position += 1;\n  }\n\n  mimeType = mimeType.replace(/^[ \\t\\n\\f\\r]+/, '').replace(/[ \\t\\n\\f\\r]+$/, '');\n\n  if (position === input.length) {\n    return null;\n  }\n\n  position += 1;\n  var encodedBody = input.substring(position);\n  var body = Buffer.from(percentDecodeBytes(Buffer.from(encodedBody, 'utf-8'))); // Can't use /i regexp flag because it isn't restricted to ASCII.\n\n  var mimeTypeBase64MatchResult = /(.*); *[Bb][Aa][Ss][Ee]64$/.exec(mimeType);\n\n  if (mimeTypeBase64MatchResult) {\n    var stringBody = body.toString('binary');\n    var asString = (0, _abab.atob)(stringBody);\n\n    if (asString === null) {\n      return null;\n    }\n\n    body = Buffer.from(asString, 'binary');\n\n    var _mimeTypeBase64MatchR = _slicedToArray(mimeTypeBase64MatchResult, 2);\n\n    mimeType = _mimeTypeBase64MatchR[1];\n  }\n\n  if (mimeType.startsWith(';')) {\n    mimeType = \"text/plain \".concat(mimeType);\n  }\n\n  var mimeTypeRecord;\n\n  try {\n    mimeTypeRecord = new _whatwgMimetype.default(mimeType);\n  } catch (e) {\n    mimeTypeRecord = new _whatwgMimetype.default('text/plain;charset=US-ASCII');\n  }\n\n  return {\n    mimeType: mimeTypeRecord,\n    body: body\n  };\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/source-map-loader/dist/parse-data-url.js"],"names":["Object","defineProperty","exports","value","default","parseDataUrl","_whatwgMimetype","_interopRequireDefault","require","_abab","obj","__esModule","isASCIIHex","c","percentDecodeBytes","input","output","Uint8Array","byteLength","outputIndex","i","byte","parseInt","String","fromCodePoint","slice","stringInput","parsedUrl","URL","error","protocol","hash","toString","substring","position","mimeType","length","replace","encodedBody","body","Buffer","from","mimeTypeBase64MatchResult","exec","stringBody","asString","atob","startsWith","mimeTypeRecord","e"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = parseDataUrl;\n\nvar _whatwgMimetype = _interopRequireDefault(require(\"whatwg-mimetype\"));\n\nvar _abab = require(\"abab\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isASCIIHex(c) {\n  return c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x46 || c >= 0x61 && c <= 0x66;\n}\n\nfunction percentDecodeBytes(input) {\n  const output = new Uint8Array(input.byteLength);\n  let outputIndex = 0;\n\n  for (let i = 0; i < input.byteLength; ++i) {\n    const byte = input[i];\n\n    if (byte !== 0x25) {\n      output[outputIndex] = byte;\n    } else if (byte === 0x25 && (!isASCIIHex(input[i + 1]) || !isASCIIHex(input[i + 2]))) {\n      output[outputIndex] = byte;\n    } else {\n      output[outputIndex] = parseInt(String.fromCodePoint(input[i + 1], input[i + 2]), 16);\n      i += 2;\n    }\n\n    outputIndex += 1;\n  }\n\n  return output.slice(0, outputIndex);\n}\n\nfunction parseDataUrl(stringInput) {\n  let parsedUrl;\n\n  try {\n    parsedUrl = new URL(stringInput);\n  } catch (error) {\n    return null;\n  }\n\n  if (parsedUrl.protocol !== 'data:') {\n    return null;\n  }\n\n  parsedUrl.hash = ''; // `5` is value of `'data:'.length`\n\n  const input = parsedUrl.toString().substring(5);\n  let position = 0;\n  let mimeType = '';\n\n  while (position < input.length && input[position] !== ',') {\n    mimeType += input[position];\n    position += 1;\n  }\n\n  mimeType = mimeType.replace(/^[ \\t\\n\\f\\r]+/, '').replace(/[ \\t\\n\\f\\r]+$/, '');\n\n  if (position === input.length) {\n    return null;\n  }\n\n  position += 1;\n  const encodedBody = input.substring(position);\n  let body = Buffer.from(percentDecodeBytes(Buffer.from(encodedBody, 'utf-8'))); // Can't use /i regexp flag because it isn't restricted to ASCII.\n\n  const mimeTypeBase64MatchResult = /(.*); *[Bb][Aa][Ss][Ee]64$/.exec(mimeType);\n\n  if (mimeTypeBase64MatchResult) {\n    const stringBody = body.toString('binary');\n    const asString = (0, _abab.atob)(stringBody);\n\n    if (asString === null) {\n      return null;\n    }\n\n    body = Buffer.from(asString, 'binary');\n    [, mimeType] = mimeTypeBase64MatchResult;\n  }\n\n  if (mimeType.startsWith(';')) {\n    mimeType = `text/plain ${mimeType}`;\n  }\n\n  let mimeTypeRecord;\n\n  try {\n    mimeTypeRecord = new _whatwgMimetype.default(mimeType);\n  } catch (e) {\n    mimeTypeRecord = new _whatwgMimetype.default('text/plain;charset=US-ASCII');\n  }\n\n  return {\n    mimeType: mimeTypeRecord,\n    body\n  };\n}"]},"metadata":{},"sourceType":"script"}