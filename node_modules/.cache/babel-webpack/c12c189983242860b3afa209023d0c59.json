{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('util'),\n    promisify = _require.promisify;\n\nvar mm = require('minimatch');\n\nvar Glob = require('glob').Glob;\n\nvar fs = require('graceful-fs');\n\nvar statAsync = promisify(fs.stat.bind(fs));\n\nvar pathLib = require('path');\n\nvar _ = require('lodash');\n\nvar File = require('./file');\n\nvar Url = require('./url');\n\nvar helper = require('./helper');\n\nvar log = require('./logger').create('filelist');\n\nvar createPatternObject = require('./config').createPatternObject;\n\nvar FileList = /*#__PURE__*/function () {\n  function FileList(patterns, excludes, emitter, preprocess, autoWatchBatchDelay) {\n    var _this = this;\n\n    _classCallCheck(this, FileList);\n\n    this._patterns = patterns || [];\n    this._excludes = excludes || [];\n    this._emitter = emitter;\n    this._preprocess = preprocess;\n    this.buckets = new Map(); // A promise that is pending if and only if we are active in this.refresh_()\n\n    this._refreshing = null;\n\n    var emit = function emit() {\n      _this._emitter.emit('file_list_modified', _this.files);\n    };\n\n    var debouncedEmit = _.debounce(emit, autoWatchBatchDelay);\n\n    this._emitModified = function (immediate) {\n      immediate ? emit() : debouncedEmit();\n    };\n  }\n\n  _createClass(FileList, [{\n    key: \"_findExcluded\",\n    value: function _findExcluded(path) {\n      return this._excludes.find(function (pattern) {\n        return mm(path, pattern);\n      });\n    }\n  }, {\n    key: \"_findIncluded\",\n    value: function _findIncluded(path) {\n      return this._patterns.find(function (pattern) {\n        return mm(path, pattern.pattern);\n      });\n    }\n  }, {\n    key: \"_findFile\",\n    value: function _findFile(path, pattern) {\n      if (!path || !pattern) return;\n      return this._getFilesByPattern(pattern.pattern).find(function (file) {\n        return file.originalPath === path;\n      });\n    }\n  }, {\n    key: \"_exists\",\n    value: function _exists(path) {\n      var _this2 = this;\n\n      return !!this._patterns.find(function (pattern) {\n        return mm(path, pattern.pattern) && _this2._findFile(path, pattern);\n      });\n    }\n  }, {\n    key: \"_getFilesByPattern\",\n    value: function _getFilesByPattern(pattern) {\n      return this.buckets.get(pattern) || [];\n    }\n  }, {\n    key: \"_refresh\",\n    value: function _refresh() {\n      var _this3 = this;\n\n      var matchedFiles = new Set();\n      var lastCompletedRefresh = this._refreshing;\n      lastCompletedRefresh = Promise.all(this._patterns.map( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n          var pattern, type, nocache, isBinary, mg, files;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  pattern = _ref.pattern, type = _ref.type, nocache = _ref.nocache, isBinary = _ref.isBinary;\n\n                  if (!helper.isUrlAbsolute(pattern)) {\n                    _context.next = 4;\n                    break;\n                  }\n\n                  _this3.buckets.set(pattern, [new Url(pattern, type)]);\n\n                  return _context.abrupt(\"return\");\n\n                case 4:\n                  mg = new Glob(pathLib.normalize(pattern), {\n                    cwd: '/',\n                    follow: true,\n                    nodir: true,\n                    sync: true\n                  });\n                  files = mg.found.filter(function (path) {\n                    if (_this3._findExcluded(path)) {\n                      log.debug(\"Excluded file \\\"\".concat(path, \"\\\"\"));\n                      return false;\n                    } else if (matchedFiles.has(path)) {\n                      return false;\n                    } else {\n                      matchedFiles.add(path);\n                      return true;\n                    }\n                  }).map(function (path) {\n                    return new File(path, mg.statCache[path].mtime, nocache, type, isBinary);\n                  });\n\n                  if (!nocache) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  log.debug(\"Not preprocessing \\\"\".concat(pattern, \"\\\" due to nocache\"));\n                  _context.next = 12;\n                  break;\n\n                case 10:\n                  _context.next = 12;\n                  return Promise.all(files.map(function (file) {\n                    return _this3._preprocess(file);\n                  }));\n\n                case 12:\n                  _this3.buckets.set(pattern, files);\n\n                  if (_.isEmpty(mg.found)) {\n                    log.warn(\"Pattern \\\"\".concat(pattern, \"\\\" does not match any file.\"));\n                  } else if (_.isEmpty(files)) {\n                    log.warn(\"All files matched by \\\"\".concat(pattern, \"\\\" were excluded or matched by prior matchers.\"));\n                  }\n\n                case 14:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function (_x) {\n          return _ref2.apply(this, arguments);\n        };\n      }())).then(function () {\n        // When we return from this function the file processing chain will be\n        // complete. In the case of two fast refresh() calls, the second call\n        // will overwrite this._refreshing, and we want the status to reflect\n        // the second call and skip the modification event from the first call.\n        if (_this3._refreshing !== lastCompletedRefresh) {\n          return _this3._refreshing;\n        }\n\n        _this3._emitModified(true);\n\n        return _this3.files;\n      });\n      return lastCompletedRefresh;\n    }\n  }, {\n    key: \"files\",\n    get: function get() {\n      var _this4 = this;\n\n      var served = [];\n      var included = {};\n      var lookup = {};\n\n      this._patterns.forEach(function (p) {\n        // This needs to be here sadly, as plugins are modifiying\n        // the _patterns directly resulting in elements not being\n        // instantiated properly\n        if (p.constructor.name !== 'Pattern') {\n          p = createPatternObject(p);\n        }\n\n        var files = _this4._getFilesByPattern(p.pattern);\n\n        files.sort(function (a, b) {\n          if (a.path > b.path) return 1;\n          if (a.path < b.path) return -1;\n          return 0;\n        });\n\n        if (p.served) {\n          served.push.apply(served, _toConsumableArray(files));\n        }\n\n        files.forEach(function (file) {\n          if (lookup[file.path] && lookup[file.path].compare(p) < 0) return;\n          lookup[file.path] = p;\n\n          if (p.included) {\n            included[file.path] = file;\n          } else {\n            delete included[file.path];\n          }\n        });\n      });\n\n      return {\n        served: _.uniq(served, 'path'),\n        included: _.values(included)\n      };\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this._refreshing = this._refresh();\n      return this._refreshing;\n    }\n  }, {\n    key: \"reload\",\n    value: function reload(patterns, excludes) {\n      this._patterns = patterns || [];\n      this._excludes = excludes || [];\n      return this.refresh();\n    }\n  }, {\n    key: \"addFile\",\n    value: function () {\n      var _addFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path) {\n        var excluded, pattern, file, _yield$Promise$all, _yield$Promise$all2, stat;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                excluded = this._findExcluded(path);\n\n                if (!excluded) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                log.debug(\"Add file \\\"\".concat(path, \"\\\" ignored. Excluded by \\\"\").concat(excluded, \"\\\".\"));\n                return _context2.abrupt(\"return\", this.files);\n\n              case 4:\n                pattern = this._findIncluded(path);\n\n                if (pattern) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                log.debug(\"Add file \\\"\".concat(path, \"\\\" ignored. Does not match any pattern.\"));\n                return _context2.abrupt(\"return\", this.files);\n\n              case 8:\n                if (!this._exists(path)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                log.debug(\"Add file \\\"\".concat(path, \"\\\" ignored. Already in the list.\"));\n                return _context2.abrupt(\"return\", this.files);\n\n              case 11:\n                file = new File(path);\n\n                this._getFilesByPattern(pattern.pattern).push(file);\n\n                _context2.next = 15;\n                return Promise.all([statAsync(path), this._refreshing]);\n\n              case 15:\n                _yield$Promise$all = _context2.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 1);\n                stat = _yield$Promise$all2[0];\n                file.mtime = stat.mtime;\n                _context2.next = 21;\n                return this._preprocess(file);\n\n              case 21:\n                log.info(\"Added file \\\"\".concat(path, \"\\\".\"));\n\n                this._emitModified();\n\n                return _context2.abrupt(\"return\", this.files);\n\n              case 24:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function addFile(_x2) {\n        return _addFile.apply(this, arguments);\n      }\n\n      return addFile;\n    }()\n  }, {\n    key: \"changeFile\",\n    value: function () {\n      var _changeFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path, force) {\n        var pattern, file, _yield$Promise$all3, _yield$Promise$all4, stat;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                pattern = this._findIncluded(path);\n                file = this._findFile(path, pattern);\n\n                if (file) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                log.debug(\"Changed file \\\"\".concat(path, \"\\\" ignored. Does not match any file in the list.\"));\n                return _context3.abrupt(\"return\", this.files);\n\n              case 5:\n                _context3.next = 7;\n                return Promise.all([statAsync(path), this._refreshing]);\n\n              case 7:\n                _yield$Promise$all3 = _context3.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 1);\n                stat = _yield$Promise$all4[0];\n\n                if (!(force || stat.mtime > file.mtime)) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                file.mtime = stat.mtime;\n                _context3.next = 14;\n                return this._preprocess(file);\n\n              case 14:\n                log.info(\"Changed file \\\"\".concat(path, \"\\\".\"));\n\n                this._emitModified(force);\n\n              case 16:\n                return _context3.abrupt(\"return\", this.files);\n\n              case 17:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function changeFile(_x3, _x4) {\n        return _changeFile.apply(this, arguments);\n      }\n\n      return changeFile;\n    }()\n  }, {\n    key: \"removeFile\",\n    value: function () {\n      var _removeFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path) {\n        var pattern, file;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                pattern = this._findIncluded(path);\n                file = this._findFile(path, pattern);\n\n                if (file) {\n                  helper.arrayRemove(this._getFilesByPattern(pattern.pattern), file);\n                  log.info(\"Removed file \\\"\".concat(path, \"\\\".\"));\n\n                  this._emitModified();\n                } else {\n                  log.debug(\"Removed file \\\"\".concat(path, \"\\\" ignored. Does not match any file in the list.\"));\n                }\n\n                return _context4.abrupt(\"return\", this.files);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function removeFile(_x5) {\n        return _removeFile.apply(this, arguments);\n      }\n\n      return removeFile;\n    }()\n  }]);\n\n  return FileList;\n}();\n\nFileList.factory = function (config, emitter, preprocess) {\n  return new FileList(config.files, config.exclude, emitter, preprocess, config.autoWatchBatchDelay);\n};\n\nFileList.factory.$inject = ['config', 'emitter', 'preprocess'];\nmodule.exports = FileList;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/karma/lib/file-list.js"],"names":["require","promisify","mm","Glob","fs","statAsync","stat","bind","pathLib","_","File","Url","helper","log","create","createPatternObject","FileList","patterns","excludes","emitter","preprocess","autoWatchBatchDelay","_patterns","_excludes","_emitter","_preprocess","buckets","Map","_refreshing","emit","files","debouncedEmit","debounce","_emitModified","immediate","path","find","pattern","_getFilesByPattern","file","originalPath","_findFile","get","matchedFiles","Set","lastCompletedRefresh","Promise","all","map","type","nocache","isBinary","isUrlAbsolute","set","mg","normalize","cwd","follow","nodir","sync","found","filter","_findExcluded","debug","has","add","statCache","mtime","isEmpty","warn","then","served","included","lookup","forEach","p","constructor","name","sort","a","b","push","compare","uniq","values","_refresh","refresh","excluded","_findIncluded","_exists","info","force","arrayRemove","factory","config","exclude","$inject","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst { promisify } = require('util')\nconst mm = require('minimatch')\nconst Glob = require('glob').Glob\nconst fs = require('graceful-fs')\nconst statAsync = promisify(fs.stat.bind(fs))\nconst pathLib = require('path')\nconst _ = require('lodash')\n\nconst File = require('./file')\nconst Url = require('./url')\nconst helper = require('./helper')\nconst log = require('./logger').create('filelist')\nconst createPatternObject = require('./config').createPatternObject\n\nclass FileList {\n  constructor (patterns, excludes, emitter, preprocess, autoWatchBatchDelay) {\n    this._patterns = patterns || []\n    this._excludes = excludes || []\n    this._emitter = emitter\n    this._preprocess = preprocess\n\n    this.buckets = new Map()\n\n    // A promise that is pending if and only if we are active in this.refresh_()\n    this._refreshing = null\n\n    const emit = () => {\n      this._emitter.emit('file_list_modified', this.files)\n    }\n\n    const debouncedEmit = _.debounce(emit, autoWatchBatchDelay)\n    this._emitModified = (immediate) => {\n      immediate ? emit() : debouncedEmit()\n    }\n  }\n\n  _findExcluded (path) {\n    return this._excludes.find((pattern) => mm(path, pattern))\n  }\n\n  _findIncluded (path) {\n    return this._patterns.find((pattern) => mm(path, pattern.pattern))\n  }\n\n  _findFile (path, pattern) {\n    if (!path || !pattern) return\n    return this._getFilesByPattern(pattern.pattern).find((file) => file.originalPath === path)\n  }\n\n  _exists (path) {\n    return !!this._patterns.find((pattern) => mm(path, pattern.pattern) && this._findFile(path, pattern))\n  }\n\n  _getFilesByPattern (pattern) {\n    return this.buckets.get(pattern) || []\n  }\n\n  _refresh () {\n    const matchedFiles = new Set()\n\n    let lastCompletedRefresh = this._refreshing\n    lastCompletedRefresh = Promise.all(\n      this._patterns.map(async ({ pattern, type, nocache, isBinary }) => {\n        if (helper.isUrlAbsolute(pattern)) {\n          this.buckets.set(pattern, [new Url(pattern, type)])\n          return\n        }\n\n        const mg = new Glob(pathLib.normalize(pattern), { cwd: '/', follow: true, nodir: true, sync: true })\n\n        const files = mg.found\n          .filter((path) => {\n            if (this._findExcluded(path)) {\n              log.debug(`Excluded file \"${path}\"`)\n              return false\n            } else if (matchedFiles.has(path)) {\n              return false\n            } else {\n              matchedFiles.add(path)\n              return true\n            }\n          })\n          .map((path) => new File(path, mg.statCache[path].mtime, nocache, type, isBinary))\n\n        if (nocache) {\n          log.debug(`Not preprocessing \"${pattern}\" due to nocache`)\n        } else {\n          await Promise.all(files.map((file) => this._preprocess(file)))\n        }\n\n        this.buckets.set(pattern, files)\n\n        if (_.isEmpty(mg.found)) {\n          log.warn(`Pattern \"${pattern}\" does not match any file.`)\n        } else if (_.isEmpty(files)) {\n          log.warn(`All files matched by \"${pattern}\" were excluded or matched by prior matchers.`)\n        }\n      })\n    )\n      .then(() => {\n        // When we return from this function the file processing chain will be\n        // complete. In the case of two fast refresh() calls, the second call\n        // will overwrite this._refreshing, and we want the status to reflect\n        // the second call and skip the modification event from the first call.\n        if (this._refreshing !== lastCompletedRefresh) {\n          return this._refreshing\n        }\n        this._emitModified(true)\n        return this.files\n      })\n\n    return lastCompletedRefresh\n  }\n\n  get files () {\n    const served = []\n    const included = {}\n    const lookup = {}\n    this._patterns.forEach((p) => {\n      // This needs to be here sadly, as plugins are modifiying\n      // the _patterns directly resulting in elements not being\n      // instantiated properly\n      if (p.constructor.name !== 'Pattern') {\n        p = createPatternObject(p)\n      }\n\n      const files = this._getFilesByPattern(p.pattern)\n      files.sort((a, b) => {\n        if (a.path > b.path) return 1\n        if (a.path < b.path) return -1\n\n        return 0\n      })\n\n      if (p.served) {\n        served.push(...files)\n      }\n\n      files.forEach((file) => {\n        if (lookup[file.path] && lookup[file.path].compare(p) < 0) return\n\n        lookup[file.path] = p\n        if (p.included) {\n          included[file.path] = file\n        } else {\n          delete included[file.path]\n        }\n      })\n    })\n\n    return {\n      served: _.uniq(served, 'path'),\n      included: _.values(included)\n    }\n  }\n\n  refresh () {\n    this._refreshing = this._refresh()\n    return this._refreshing\n  }\n\n  reload (patterns, excludes) {\n    this._patterns = patterns || []\n    this._excludes = excludes || []\n\n    return this.refresh()\n  }\n\n  async addFile (path) {\n    const excluded = this._findExcluded(path)\n    if (excluded) {\n      log.debug(`Add file \"${path}\" ignored. Excluded by \"${excluded}\".`)\n      return this.files\n    }\n\n    const pattern = this._findIncluded(path)\n    if (!pattern) {\n      log.debug(`Add file \"${path}\" ignored. Does not match any pattern.`)\n      return this.files\n    }\n\n    if (this._exists(path)) {\n      log.debug(`Add file \"${path}\" ignored. Already in the list.`)\n      return this.files\n    }\n\n    const file = new File(path)\n    this._getFilesByPattern(pattern.pattern).push(file)\n\n    const [stat] = await Promise.all([statAsync(path), this._refreshing])\n    file.mtime = stat.mtime\n    await this._preprocess(file)\n\n    log.info(`Added file \"${path}\".`)\n    this._emitModified()\n    return this.files\n  }\n\n  async changeFile (path, force) {\n    const pattern = this._findIncluded(path)\n    const file = this._findFile(path, pattern)\n\n    if (!file) {\n      log.debug(`Changed file \"${path}\" ignored. Does not match any file in the list.`)\n      return this.files\n    }\n\n    const [stat] = await Promise.all([statAsync(path), this._refreshing])\n    if (force || stat.mtime > file.mtime) {\n      file.mtime = stat.mtime\n      await this._preprocess(file)\n      log.info(`Changed file \"${path}\".`)\n      this._emitModified(force)\n    }\n    return this.files\n  }\n\n  async removeFile (path) {\n    const pattern = this._findIncluded(path)\n    const file = this._findFile(path, pattern)\n\n    if (file) {\n      helper.arrayRemove(this._getFilesByPattern(pattern.pattern), file)\n      log.info(`Removed file \"${path}\".`)\n\n      this._emitModified()\n    } else {\n      log.debug(`Removed file \"${path}\" ignored. Does not match any file in the list.`)\n    }\n    return this.files\n  }\n}\n\nFileList.factory = function (config, emitter, preprocess) {\n  return new FileList(config.files, config.exclude, emitter, preprocess, config.autoWatchBatchDelay)\n}\n\nFileList.factory.$inject = ['config', 'emitter', 'preprocess']\n\nmodule.exports = FileList\n"]},"metadata":{},"sourceType":"script"}