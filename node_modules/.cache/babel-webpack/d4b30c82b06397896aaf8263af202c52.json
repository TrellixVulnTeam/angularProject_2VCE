{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/shim\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeCheckShimGenerator = void 0;\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n  /**\n   * A `ShimGenerator` which adds type-checking files to the `ts.Program`.\n   *\n   * This is a requirement for performant template type-checking, as TypeScript will only reuse\n   * information in the main program when creating the type-checking program if the set of files in\n   * each are exactly the same. Thus, the main program also needs the synthetic type-checking files.\n   */\n\n\n  var TypeCheckShimGenerator =\n  /** @class */\n  function () {\n    function TypeCheckShimGenerator() {\n      this.extensionPrefix = 'ngtypecheck';\n      this.shouldEmit = false;\n    }\n\n    TypeCheckShimGenerator.prototype.generateShimForFile = function (sf, genFilePath, priorShimSf) {\n      if (priorShimSf !== null) {\n        // If this shim existed in the previous program, reuse it now. It might not be correct, but\n        // reusing it in the main program allows the shape of its imports to potentially remain the\n        // same and TS can then use the fastest path for incremental program creation. Later during\n        // the type-checking phase it's going to either be reused, or replaced anyways. Thus there's\n        // no harm in reuse here even if it's out of date.\n        return priorShimSf;\n      }\n\n      return ts.createSourceFile(genFilePath, 'export const USED_FOR_NG_TYPE_CHECKING = true;', ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);\n    };\n\n    TypeCheckShimGenerator.shimFor = function (fileName) {\n      return file_system_1.absoluteFrom(fileName.replace(/\\.tsx?$/, '.ngtypecheck.ts'));\n    };\n\n    return TypeCheckShimGenerator;\n  }();\n\n  exports.TypeCheckShimGenerator = TypeCheckShimGenerator;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/shim.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;AAGA;;;;;;AAMG;;;AACH,MAAA,sBAAA;AAAA;AAAA,cAAA;AAAA,aAAA,sBAAA,GAAA;AACW,WAAA,eAAA,GAAkB,aAAlB;AACA,WAAA,UAAA,GAAa,KAAb;AAqBV;;AAnBC,IAAA,sBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UACI,EADJ,EACuB,WADvB,EAEI,WAFJ,EAEmC;AACjC,UAAI,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA;AACA;AACA;AACA;AACA,eAAO,WAAP;AACD;;AACD,aAAO,EAAE,CAAC,gBAAH,CACH,WADG,EACU,gDADV,EAC4D,EAAE,CAAC,YAAH,CAAgB,MAD5E,EACoF,IADpF,EAEH,EAAE,CAAC,UAAH,CAAc,EAFX,CAAP;AAGD,KAdD;;AAgBO,IAAA,sBAAA,CAAA,OAAA,GAAP,UAAe,QAAf,EAAuC;AACrC,aAAO,aAAA,CAAA,YAAA,CAAa,QAAQ,CAAC,OAAT,CAAiB,SAAjB,EAA4B,iBAA5B,CAAb,CAAP;AACD,KAFM;;AAGT,WAAA,sBAAA;AAAC,GAvBD,EAAA;;AAAa,EAAA,OAAA,CAAA,sBAAA,GAAA,sBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {absoluteFrom, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\nimport {PerFileShimGenerator, TopLevelShimGenerator} from '../../shims/api';\n\n/**\n * A `ShimGenerator` which adds type-checking files to the `ts.Program`.\n *\n * This is a requirement for performant template type-checking, as TypeScript will only reuse\n * information in the main program when creating the type-checking program if the set of files in\n * each are exactly the same. Thus, the main program also needs the synthetic type-checking files.\n */\nexport class TypeCheckShimGenerator implements PerFileShimGenerator {\n  readonly extensionPrefix = 'ngtypecheck';\n  readonly shouldEmit = false;\n\n  generateShimForFile(\n      sf: ts.SourceFile, genFilePath: AbsoluteFsPath,\n      priorShimSf: ts.SourceFile|null): ts.SourceFile {\n    if (priorShimSf !== null) {\n      // If this shim existed in the previous program, reuse it now. It might not be correct, but\n      // reusing it in the main program allows the shape of its imports to potentially remain the\n      // same and TS can then use the fastest path for incremental program creation. Later during\n      // the type-checking phase it's going to either be reused, or replaced anyways. Thus there's\n      // no harm in reuse here even if it's out of date.\n      return priorShimSf;\n    }\n    return ts.createSourceFile(\n        genFilePath, 'export const USED_FOR_NG_TYPE_CHECKING = true;', ts.ScriptTarget.Latest, true,\n        ts.ScriptKind.TS);\n  }\n\n  static shimFor(fileName: AbsoluteFsPath): AbsoluteFsPath {\n    return absoluteFrom(fileName.replace(/\\.tsx?$/, '.ngtypecheck.ts'));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}