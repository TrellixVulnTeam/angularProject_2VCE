{"ast":null,"code":"/**\n * This module contains some common helpers shared between middlewares\n */\n'use strict';\n\nvar mime = require('mime');\n\nvar parseRange = require('range-parser');\n\nvar log = require('../logger').create('web-server');\n\nfunction createServeFile(fs, directory, config) {\n  var cache = Object.create(null);\n  return function (filepath, rangeHeader, response, transform, content, doNotCache) {\n    var responseData;\n\n    function convertForRangeRequest() {\n      var range = parseRange(responseData.length, rangeHeader);\n\n      if (range === -2) {\n        return 200; // malformed header string\n      } else if (range === -1) {\n        responseData = Buffer.alloc(0); // unsatisfiable range\n\n        return 416;\n      } else if (range.type === 'bytes') {\n        responseData = Buffer.from(responseData);\n\n        if (range.length === 1) {\n          var _range$ = range[0],\n              start = _range$.start,\n              end = _range$.end;\n          response.setHeader('Content-Range', \"bytes \".concat(start, \"-\").concat(end, \"/\").concat(responseData.length));\n          response.setHeader('Accept-Ranges', 'bytes');\n          response.setHeader('Content-Length', end - start + 1);\n          responseData = responseData.slice(start, end + 1);\n          return 206;\n        } else {\n          responseData = Buffer.alloc(0); // Multiple ranges are not supported. Maybe future?\n\n          return 416;\n        }\n      }\n\n      return 200; // All other states, ignore\n    }\n\n    if (directory) {\n      filepath = directory + filepath;\n    }\n\n    if (!content && cache[filepath]) {\n      content = cache[filepath];\n    }\n\n    if (config && config.customHeaders && config.customHeaders.length > 0) {\n      config.customHeaders.forEach(function (header) {\n        var regex = new RegExp(header.match);\n\n        if (regex.test(filepath)) {\n          log.debug(\"setting header: \".concat(header.name, \" for: \").concat(filepath));\n          response.setHeader(header.name, header.value);\n        }\n      });\n    }\n\n    if (content && !doNotCache) {\n      log.debug(\"serving (cached): \".concat(filepath));\n      response.setHeader('Content-Type', mime.getType(filepath, 'text/plain'));\n      responseData = transform && transform(content) || content;\n      response.writeHead(rangeHeader ? convertForRangeRequest() : 200);\n      return response.end(responseData);\n    }\n\n    return fs.readFile(filepath, function (error, data) {\n      if (error) {\n        return serve404(response, filepath);\n      }\n\n      if (!doNotCache) {\n        cache[filepath] = data.toString();\n      }\n\n      log.debug('serving: ' + filepath);\n      response.setHeader('Content-Type', mime.getType(filepath, 'text/plain'));\n      responseData = transform && transform(data.toString()) || data;\n      response.writeHead(rangeHeader ? convertForRangeRequest() : 200);\n      return response.end(responseData);\n    });\n  };\n}\n\nfunction serve404(response, path) {\n  log.warn(\"404: \".concat(path));\n  response.writeHead(404);\n  return response.end('NOT FOUND');\n}\n\nfunction setNoCacheHeaders(response) {\n  response.setHeader('Cache-Control', 'no-cache');\n  response.setHeader('Pragma', 'no-cache');\n  response.setHeader('Expires', new Date(0).toUTCString());\n}\n\nfunction setHeavyCacheHeaders(response) {\n  response.setHeader('Cache-Control', 'public, max-age=31536000');\n} // PUBLIC API\n\n\nexports.createServeFile = createServeFile;\nexports.setNoCacheHeaders = setNoCacheHeaders;\nexports.setHeavyCacheHeaders = setHeavyCacheHeaders;\nexports.serve404 = serve404;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/karma/lib/middleware/common.js"],"names":["mime","require","parseRange","log","create","createServeFile","fs","directory","config","cache","Object","filepath","rangeHeader","response","transform","content","doNotCache","responseData","convertForRangeRequest","range","length","Buffer","alloc","type","from","start","end","setHeader","slice","customHeaders","forEach","header","regex","RegExp","match","test","debug","name","value","getType","writeHead","readFile","error","data","serve404","toString","path","warn","setNoCacheHeaders","Date","toUTCString","setHeavyCacheHeaders","exports"],"mappings":"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","sourcesContent":["/**\n * This module contains some common helpers shared between middlewares\n */\n'use strict'\n\nconst mime = require('mime')\nconst parseRange = require('range-parser')\nconst log = require('../logger').create('web-server')\n\nfunction createServeFile (fs, directory, config) {\n  const cache = Object.create(null)\n\n  return function (filepath, rangeHeader, response, transform, content, doNotCache) {\n    let responseData\n\n    function convertForRangeRequest () {\n      const range = parseRange(responseData.length, rangeHeader)\n      if (range === -2) {\n        return 200 // malformed header string\n      } else if (range === -1) {\n        responseData = Buffer.alloc(0) // unsatisfiable range\n        return 416\n      } else if (range.type === 'bytes') {\n        responseData = Buffer.from(responseData)\n        if (range.length === 1) {\n          const { start, end } = range[0]\n          response.setHeader('Content-Range', `bytes ${start}-${end}/${responseData.length}`)\n          response.setHeader('Accept-Ranges', 'bytes')\n          response.setHeader('Content-Length', end - start + 1)\n          responseData = responseData.slice(start, end + 1)\n          return 206\n        } else {\n          responseData = Buffer.alloc(0) // Multiple ranges are not supported. Maybe future?\n          return 416\n        }\n      }\n      return 200 // All other states, ignore\n    }\n\n    if (directory) {\n      filepath = directory + filepath\n    }\n\n    if (!content && cache[filepath]) {\n      content = cache[filepath]\n    }\n\n    if (config && config.customHeaders && config.customHeaders.length > 0) {\n      config.customHeaders.forEach((header) => {\n        const regex = new RegExp(header.match)\n        if (regex.test(filepath)) {\n          log.debug(`setting header: ${header.name} for: ${filepath}`)\n          response.setHeader(header.name, header.value)\n        }\n      })\n    }\n\n    if (content && !doNotCache) {\n      log.debug(`serving (cached): ${filepath}`)\n      response.setHeader('Content-Type', mime.getType(filepath, 'text/plain'))\n      responseData = (transform && transform(content)) || content\n      response.writeHead(rangeHeader ? convertForRangeRequest() : 200)\n      return response.end(responseData)\n    }\n\n    return fs.readFile(filepath, function (error, data) {\n      if (error) {\n        return serve404(response, filepath)\n      }\n\n      if (!doNotCache) {\n        cache[filepath] = data.toString()\n      }\n\n      log.debug('serving: ' + filepath)\n      response.setHeader('Content-Type', mime.getType(filepath, 'text/plain'))\n      responseData = (transform && transform(data.toString())) || data\n      response.writeHead(rangeHeader ? convertForRangeRequest() : 200)\n\n      return response.end(responseData)\n    })\n  }\n}\n\nfunction serve404 (response, path) {\n  log.warn(`404: ${path}`)\n  response.writeHead(404)\n  return response.end('NOT FOUND')\n}\n\nfunction setNoCacheHeaders (response) {\n  response.setHeader('Cache-Control', 'no-cache')\n  response.setHeader('Pragma', 'no-cache')\n  response.setHeader('Expires', (new Date(0)).toUTCString())\n}\n\nfunction setHeavyCacheHeaders (response) {\n  response.setHeader('Cache-Control', 'public, max-age=31536000')\n}\n\n// PUBLIC API\nexports.createServeFile = createServeFile\nexports.setNoCacheHeaders = setNoCacheHeaders\nexports.setHeavyCacheHeaders = setHeavyCacheHeaders\nexports.serve404 = serve404\n"]},"metadata":{},"sourceType":"script"}