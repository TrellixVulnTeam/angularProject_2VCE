{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/aot/static_reflector\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/core\", \"@angular/compiler/src/util\", \"@angular/compiler/src/aot/formatted_error\", \"@angular/compiler/src/aot/static_symbol\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.StaticReflector = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var formatted_error_1 = require(\"@angular/compiler/src/aot/formatted_error\");\n\n  var static_symbol_1 = require(\"@angular/compiler/src/aot/static_symbol\");\n\n  var ANGULAR_CORE = '@angular/core';\n  var ANGULAR_ROUTER = '@angular/router';\n  var HIDDEN_KEY = /^\\$.*\\$$/;\n  var IGNORE = {\n    __symbolic: 'ignore'\n  };\n  var USE_VALUE = 'useValue';\n  var PROVIDE = 'provide';\n  var REFERENCE_SET = new Set([USE_VALUE, 'useFactory', 'data', 'id', 'loadChildren']);\n  var TYPEGUARD_POSTFIX = 'TypeGuard';\n  var USE_IF = 'UseIf';\n\n  function shouldIgnore(value) {\n    return value && value.__symbolic == 'ignore';\n  }\n  /**\n   * A static reflector implements enough of the Reflector API that is necessary to compile\n   * templates statically.\n   */\n\n\n  var StaticReflector =\n  /** @class */\n  function () {\n    function StaticReflector(summaryResolver, symbolResolver, knownMetadataClasses, knownMetadataFunctions, errorRecorder) {\n      var _this = this;\n\n      if (knownMetadataClasses === void 0) {\n        knownMetadataClasses = [];\n      }\n\n      if (knownMetadataFunctions === void 0) {\n        knownMetadataFunctions = [];\n      }\n\n      this.summaryResolver = summaryResolver;\n      this.symbolResolver = symbolResolver;\n      this.errorRecorder = errorRecorder;\n      this.annotationCache = new Map();\n      this.shallowAnnotationCache = new Map();\n      this.propertyCache = new Map();\n      this.parameterCache = new Map();\n      this.methodCache = new Map();\n      this.staticCache = new Map();\n      this.conversionMap = new Map();\n      this.resolvedExternalReferences = new Map();\n      this.annotationForParentClassWithSummaryKind = new Map();\n      this.initializeConversionMap();\n      knownMetadataClasses.forEach(function (kc) {\n        return _this._registerDecoratorOrConstructor(_this.getStaticSymbol(kc.filePath, kc.name), kc.ctor);\n      });\n      knownMetadataFunctions.forEach(function (kf) {\n        return _this._registerFunction(_this.getStaticSymbol(kf.filePath, kf.name), kf.fn);\n      });\n      this.annotationForParentClassWithSummaryKind.set(compile_metadata_1.CompileSummaryKind.Directive, [core_1.createDirective, core_1.createComponent]);\n      this.annotationForParentClassWithSummaryKind.set(compile_metadata_1.CompileSummaryKind.Pipe, [core_1.createPipe]);\n      this.annotationForParentClassWithSummaryKind.set(compile_metadata_1.CompileSummaryKind.NgModule, [core_1.createNgModule]);\n      this.annotationForParentClassWithSummaryKind.set(compile_metadata_1.CompileSummaryKind.Injectable, [core_1.createInjectable, core_1.createPipe, core_1.createDirective, core_1.createComponent, core_1.createNgModule]);\n    }\n\n    StaticReflector.prototype.componentModuleUrl = function (typeOrFunc) {\n      var staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n      return this.symbolResolver.getResourcePath(staticSymbol);\n    };\n    /**\n     * Invalidate the specified `symbols` on program change.\n     * @param symbols\n     */\n\n\n    StaticReflector.prototype.invalidateSymbols = function (symbols) {\n      var e_1, _a;\n\n      try {\n        for (var symbols_1 = tslib_1.__values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n          var symbol = symbols_1_1.value;\n          this.annotationCache.delete(symbol);\n          this.shallowAnnotationCache.delete(symbol);\n          this.propertyCache.delete(symbol);\n          this.parameterCache.delete(symbol);\n          this.methodCache.delete(symbol);\n          this.staticCache.delete(symbol);\n          this.conversionMap.delete(symbol);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    StaticReflector.prototype.resolveExternalReference = function (ref, containingFile) {\n      var key = undefined;\n\n      if (!containingFile) {\n        key = ref.moduleName + \":\" + ref.name;\n        var declarationSymbol_1 = this.resolvedExternalReferences.get(key);\n        if (declarationSymbol_1) return declarationSymbol_1;\n      }\n\n      var refSymbol = this.symbolResolver.getSymbolByModule(ref.moduleName, ref.name, containingFile);\n      var declarationSymbol = this.findSymbolDeclaration(refSymbol);\n\n      if (!containingFile) {\n        this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName);\n        this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);\n      }\n\n      if (key) {\n        this.resolvedExternalReferences.set(key, declarationSymbol);\n      }\n\n      return declarationSymbol;\n    };\n\n    StaticReflector.prototype.findDeclaration = function (moduleUrl, name, containingFile) {\n      return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    };\n\n    StaticReflector.prototype.tryFindDeclaration = function (moduleUrl, name, containingFile) {\n      var _this = this;\n\n      return this.symbolResolver.ignoreErrorsFor(function () {\n        return _this.findDeclaration(moduleUrl, name, containingFile);\n      });\n    };\n\n    StaticReflector.prototype.findSymbolDeclaration = function (symbol) {\n      var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n\n      if (resolvedSymbol) {\n        var resolvedMetadata = resolvedSymbol.metadata;\n\n        if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {\n          resolvedMetadata = resolvedMetadata.symbol;\n        }\n\n        if (resolvedMetadata instanceof static_symbol_1.StaticSymbol) {\n          return this.findSymbolDeclaration(resolvedSymbol.metadata);\n        }\n      }\n\n      return symbol;\n    };\n\n    StaticReflector.prototype.tryAnnotations = function (type) {\n      var originalRecorder = this.errorRecorder;\n\n      this.errorRecorder = function (error, fileName) {};\n\n      try {\n        return this.annotations(type);\n      } finally {\n        this.errorRecorder = originalRecorder;\n      }\n    };\n\n    StaticReflector.prototype.annotations = function (type) {\n      var _this = this;\n\n      return this._annotations(type, function (type, decorators) {\n        return _this.simplify(type, decorators);\n      }, this.annotationCache);\n    };\n\n    StaticReflector.prototype.shallowAnnotations = function (type) {\n      var _this = this;\n\n      return this._annotations(type, function (type, decorators) {\n        return _this.simplify(type, decorators, true);\n      }, this.shallowAnnotationCache);\n    };\n\n    StaticReflector.prototype._annotations = function (type, simplify, annotationCache) {\n      var annotations = annotationCache.get(type);\n\n      if (!annotations) {\n        annotations = [];\n        var classMetadata = this.getTypeMetadata(type);\n        var parentType = this.findParentType(type, classMetadata);\n\n        if (parentType) {\n          var parentAnnotations = this.annotations(parentType);\n          annotations.push.apply(annotations, tslib_1.__spread(parentAnnotations));\n        }\n\n        var ownAnnotations_1 = [];\n\n        if (classMetadata['decorators']) {\n          ownAnnotations_1 = simplify(type, classMetadata['decorators']);\n\n          if (ownAnnotations_1) {\n            annotations.push.apply(annotations, tslib_1.__spread(ownAnnotations_1));\n          }\n        }\n\n        if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) && this.summaryResolver.isLibraryFile(parentType.filePath)) {\n          var summary = this.summaryResolver.resolveSummary(parentType);\n\n          if (summary && summary.type) {\n            var requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);\n            var typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) {\n              return ownAnnotations_1.some(function (ann) {\n                return requiredType.isTypeOf(ann);\n              });\n            });\n\n            if (!typeHasRequiredAnnotation) {\n              this.reportError(formatMetadataError(metadataError(\"Class \" + type.name + \" in \" + type.filePath + \" extends from a \" + compile_metadata_1.CompileSummaryKind[summary.type.summaryKind] + \" in another compilation unit without duplicating the decorator\",\n              /* summary */\n              undefined, \"Please add a \" + requiredAnnotationTypes.map(function (type) {\n                return type.ngMetadataName;\n              }).join(' or ') + \" decorator to the class\"), type), type);\n            }\n          }\n        }\n\n        annotationCache.set(type, annotations.filter(function (ann) {\n          return !!ann;\n        }));\n      }\n\n      return annotations;\n    };\n\n    StaticReflector.prototype.propMetadata = function (type) {\n      var _this = this;\n\n      var propMetadata = this.propertyCache.get(type);\n\n      if (!propMetadata) {\n        var classMetadata = this.getTypeMetadata(type);\n        propMetadata = {};\n        var parentType = this.findParentType(type, classMetadata);\n\n        if (parentType) {\n          var parentPropMetadata_1 = this.propMetadata(parentType);\n          Object.keys(parentPropMetadata_1).forEach(function (parentProp) {\n            propMetadata[parentProp] = parentPropMetadata_1[parentProp];\n          });\n        }\n\n        var members_1 = classMetadata['members'] || {};\n        Object.keys(members_1).forEach(function (propName) {\n          var propData = members_1[propName];\n          var prop = propData.find(function (a) {\n            return a['__symbolic'] == 'property' || a['__symbolic'] == 'method';\n          });\n          var decorators = []; // hasOwnProperty() is used here to make sure we do not look up methods\n          // on `Object.prototype`.\n\n          if (propMetadata === null || propMetadata === void 0 ? void 0 : propMetadata.hasOwnProperty(propName)) {\n            decorators.push.apply(decorators, tslib_1.__spread(propMetadata[propName]));\n          }\n\n          propMetadata[propName] = decorators;\n\n          if (prop && prop['decorators']) {\n            decorators.push.apply(decorators, tslib_1.__spread(_this.simplify(type, prop['decorators'])));\n          }\n        });\n        this.propertyCache.set(type, propMetadata);\n      }\n\n      return propMetadata;\n    };\n\n    StaticReflector.prototype.parameters = function (type) {\n      var _this = this;\n\n      if (!(type instanceof static_symbol_1.StaticSymbol)) {\n        this.reportError(new Error(\"parameters received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n        return [];\n      }\n\n      try {\n        var parameters_1 = this.parameterCache.get(type);\n\n        if (!parameters_1) {\n          var classMetadata = this.getTypeMetadata(type);\n          var parentType = this.findParentType(type, classMetadata);\n          var members = classMetadata ? classMetadata['members'] : null;\n          var ctorData = members ? members['__ctor__'] : null;\n\n          if (ctorData) {\n            var ctor = ctorData.find(function (a) {\n              return a['__symbolic'] == 'constructor';\n            });\n            var rawParameterTypes = ctor['parameters'] || [];\n            var parameterDecorators_1 = this.simplify(type, ctor['parameterDecorators'] || []);\n            parameters_1 = [];\n            rawParameterTypes.forEach(function (rawParamType, index) {\n              var nestedResult = [];\n\n              var paramType = _this.trySimplify(type, rawParamType);\n\n              if (paramType) nestedResult.push(paramType);\n              var decorators = parameterDecorators_1 ? parameterDecorators_1[index] : null;\n\n              if (decorators) {\n                nestedResult.push.apply(nestedResult, tslib_1.__spread(decorators));\n              }\n\n              parameters_1.push(nestedResult);\n            });\n          } else if (parentType) {\n            parameters_1 = this.parameters(parentType);\n          }\n\n          if (!parameters_1) {\n            parameters_1 = [];\n          }\n\n          this.parameterCache.set(type, parameters_1);\n        }\n\n        return parameters_1;\n      } catch (e) {\n        console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n        throw e;\n      }\n    };\n\n    StaticReflector.prototype._methodNames = function (type) {\n      var methodNames = this.methodCache.get(type);\n\n      if (!methodNames) {\n        var classMetadata = this.getTypeMetadata(type);\n        methodNames = {};\n        var parentType = this.findParentType(type, classMetadata);\n\n        if (parentType) {\n          var parentMethodNames_1 = this._methodNames(parentType);\n\n          Object.keys(parentMethodNames_1).forEach(function (parentProp) {\n            methodNames[parentProp] = parentMethodNames_1[parentProp];\n          });\n        }\n\n        var members_2 = classMetadata['members'] || {};\n        Object.keys(members_2).forEach(function (propName) {\n          var propData = members_2[propName];\n          var isMethod = propData.some(function (a) {\n            return a['__symbolic'] == 'method';\n          });\n          methodNames[propName] = methodNames[propName] || isMethod;\n        });\n        this.methodCache.set(type, methodNames);\n      }\n\n      return methodNames;\n    };\n\n    StaticReflector.prototype._staticMembers = function (type) {\n      var staticMembers = this.staticCache.get(type);\n\n      if (!staticMembers) {\n        var classMetadata = this.getTypeMetadata(type);\n        var staticMemberData = classMetadata['statics'] || {};\n        staticMembers = Object.keys(staticMemberData);\n        this.staticCache.set(type, staticMembers);\n      }\n\n      return staticMembers;\n    };\n\n    StaticReflector.prototype.findParentType = function (type, classMetadata) {\n      var parentType = this.trySimplify(type, classMetadata['extends']);\n\n      if (parentType instanceof static_symbol_1.StaticSymbol) {\n        return parentType;\n      }\n    };\n\n    StaticReflector.prototype.hasLifecycleHook = function (type, lcProperty) {\n      if (!(type instanceof static_symbol_1.StaticSymbol)) {\n        this.reportError(new Error(\"hasLifecycleHook received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n      }\n\n      try {\n        return !!this._methodNames(type)[lcProperty];\n      } catch (e) {\n        console.error(\"Failed on type \" + JSON.stringify(type) + \" with error \" + e);\n        throw e;\n      }\n    };\n\n    StaticReflector.prototype.guards = function (type) {\n      var e_2, _a;\n\n      if (!(type instanceof static_symbol_1.StaticSymbol)) {\n        this.reportError(new Error(\"guards received \" + JSON.stringify(type) + \" which is not a StaticSymbol\"), type);\n        return {};\n      }\n\n      var staticMembers = this._staticMembers(type);\n\n      var result = {};\n\n      try {\n        for (var staticMembers_1 = tslib_1.__values(staticMembers), staticMembers_1_1 = staticMembers_1.next(); !staticMembers_1_1.done; staticMembers_1_1 = staticMembers_1.next()) {\n          var name_1 = staticMembers_1_1.value;\n\n          if (name_1.endsWith(TYPEGUARD_POSTFIX)) {\n            var property = name_1.substr(0, name_1.length - TYPEGUARD_POSTFIX.length);\n            var value = void 0;\n\n            if (property.endsWith(USE_IF)) {\n              property = name_1.substr(0, property.length - USE_IF.length);\n              value = USE_IF;\n            } else {\n              value = this.getStaticSymbol(type.filePath, type.name, [name_1]);\n            }\n\n            result[property] = value;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (staticMembers_1_1 && !staticMembers_1_1.done && (_a = staticMembers_1.return)) _a.call(staticMembers_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return result;\n    };\n\n    StaticReflector.prototype._registerDecoratorOrConstructor = function (type, ctor) {\n      this.conversionMap.set(type, function (context, args) {\n        return new (ctor.bind.apply(ctor, tslib_1.__spread([void 0], args)))();\n      });\n    };\n\n    StaticReflector.prototype._registerFunction = function (type, fn) {\n      this.conversionMap.set(type, function (context, args) {\n        return fn.apply(undefined, args);\n      });\n    };\n\n    StaticReflector.prototype.initializeConversionMap = function () {\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), core_1.createInjectable);\n\n      this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n      this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n      this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\n      this.ANALYZE_FOR_ENTRY_COMPONENTS = this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), core_1.createHost);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), core_1.createSelf);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), core_1.createSkipSelf);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), core_1.createInject);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), core_1.createOptional);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), core_1.createAttribute);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), core_1.createContentChild);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), core_1.createContentChildren);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), core_1.createViewChild);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), core_1.createViewChildren);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), core_1.createInput);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), core_1.createOutput);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), core_1.createPipe);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), core_1.createHostBinding);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), core_1.createHostListener);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), core_1.createDirective);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), core_1.createComponent);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), core_1.createNgModule); // Note: Some metadata classes can be used directly with Provider.deps.\n\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), core_1.createHost);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), core_1.createSelf);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), core_1.createSkipSelf);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), core_1.createOptional);\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param declarationFile the absolute path of the file where the symbol is declared\n     * @param name the name of the type.\n     */\n\n\n    StaticReflector.prototype.getStaticSymbol = function (declarationFile, name, members) {\n      return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    };\n    /**\n     * Simplify but discard any errors\n     */\n\n\n    StaticReflector.prototype.trySimplify = function (context, value) {\n      var originalRecorder = this.errorRecorder;\n\n      this.errorRecorder = function (error, fileName) {};\n\n      var result = this.simplify(context, value);\n      this.errorRecorder = originalRecorder;\n      return result;\n    };\n    /** @internal */\n\n\n    StaticReflector.prototype.simplify = function (context, value, lazy) {\n      if (lazy === void 0) {\n        lazy = false;\n      }\n\n      var self = this;\n      var scope = BindingScope.empty;\n      var calling = new Map();\n      var rootContext = context;\n\n      function simplifyInContext(context, value, depth, references) {\n        function resolveReferenceValue(staticSymbol) {\n          var resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n          return resolvedSymbol ? resolvedSymbol.metadata : null;\n        }\n\n        function simplifyEagerly(value) {\n          return simplifyInContext(context, value, depth, 0);\n        }\n\n        function simplifyLazily(value) {\n          return simplifyInContext(context, value, depth, references + 1);\n        }\n\n        function simplifyNested(nestedContext, value) {\n          if (nestedContext === context) {\n            // If the context hasn't changed let the exception propagate unmodified.\n            return simplifyInContext(nestedContext, value, depth + 1, references);\n          }\n\n          try {\n            return simplifyInContext(nestedContext, value, depth + 1, references);\n          } catch (e) {\n            if (isMetadataError(e)) {\n              // Propagate the message text up but add a message to the chain that explains how we got\n              // here.\n              // e.chain implies e.symbol\n              var summaryMsg = e.chain ? 'references \\'' + e.symbol.name + '\\'' : errorSummary(e);\n              var summary = \"'\" + nestedContext.name + \"' \" + summaryMsg;\n              var chain = {\n                message: summary,\n                position: e.position,\n                next: e.chain\n              }; // TODO(chuckj): retrieve the position information indirectly from the collectors node\n              // map if the metadata is from a .ts file.\n\n              self.error({\n                message: e.message,\n                advise: e.advise,\n                context: e.context,\n                chain: chain,\n                symbol: nestedContext\n              }, context);\n            } else {\n              // It is probably an internal error.\n              throw e;\n            }\n          }\n        }\n\n        function simplifyCall(functionSymbol, targetFunction, args, targetExpression) {\n          if (targetFunction && targetFunction['__symbolic'] == 'function') {\n            if (calling.get(functionSymbol)) {\n              self.error({\n                message: 'Recursion is not supported',\n                summary: \"called '\" + functionSymbol.name + \"' recursively\",\n                value: targetFunction\n              }, functionSymbol);\n            }\n\n            try {\n              var value_1 = targetFunction['value'];\n\n              if (value_1 && (depth != 0 || value_1.__symbolic != 'error')) {\n                var parameters = targetFunction['parameters'];\n                var defaults = targetFunction.defaults;\n                args = args.map(function (arg) {\n                  return simplifyNested(context, arg);\n                }).map(function (arg) {\n                  return shouldIgnore(arg) ? undefined : arg;\n                });\n\n                if (defaults && defaults.length > args.length) {\n                  args.push.apply(args, tslib_1.__spread(defaults.slice(args.length).map(function (value) {\n                    return simplify(value);\n                  })));\n                }\n\n                calling.set(functionSymbol, true);\n                var functionScope = BindingScope.build();\n\n                for (var i = 0; i < parameters.length; i++) {\n                  functionScope.define(parameters[i], args[i]);\n                }\n\n                var oldScope = scope;\n                var result_1;\n\n                try {\n                  scope = functionScope.done();\n                  result_1 = simplifyNested(functionSymbol, value_1);\n                } finally {\n                  scope = oldScope;\n                }\n\n                return result_1;\n              }\n            } finally {\n              calling.delete(functionSymbol);\n            }\n          }\n\n          if (depth === 0) {\n            // If depth is 0 we are evaluating the top level expression that is describing element\n            // decorator. In this case, it is a decorator we don't understand, such as a custom\n            // non-angular decorator, and we should just ignore it.\n            return IGNORE;\n          }\n\n          var position = undefined;\n\n          if (targetExpression && targetExpression.__symbolic == 'resolved') {\n            var line = targetExpression.line;\n            var character = targetExpression.character;\n            var fileName = targetExpression.fileName;\n\n            if (fileName != null && line != null && character != null) {\n              position = {\n                fileName: fileName,\n                line: line,\n                column: character\n              };\n            }\n          }\n\n          self.error({\n            message: FUNCTION_CALL_NOT_SUPPORTED,\n            context: functionSymbol,\n            value: targetFunction,\n            position: position\n          }, context);\n        }\n\n        function simplify(expression) {\n          var e_3, _a, e_4, _b;\n\n          if (isPrimitive(expression)) {\n            return expression;\n          }\n\n          if (Array.isArray(expression)) {\n            var result_2 = [];\n\n            try {\n              for (var _c = tslib_1.__values(expression), _d = _c.next(); !_d.done; _d = _c.next()) {\n                var item = _d.value; // Check for a spread expression\n\n                if (item && item.__symbolic === 'spread') {\n                  // We call with references as 0 because we require the actual value and cannot\n                  // tolerate a reference here.\n                  var spreadArray = simplifyEagerly(item.expression);\n\n                  if (Array.isArray(spreadArray)) {\n                    try {\n                      for (var spreadArray_1 = (e_4 = void 0, tslib_1.__values(spreadArray)), spreadArray_1_1 = spreadArray_1.next(); !spreadArray_1_1.done; spreadArray_1_1 = spreadArray_1.next()) {\n                        var spreadItem = spreadArray_1_1.value;\n                        result_2.push(spreadItem);\n                      }\n                    } catch (e_4_1) {\n                      e_4 = {\n                        error: e_4_1\n                      };\n                    } finally {\n                      try {\n                        if (spreadArray_1_1 && !spreadArray_1_1.done && (_b = spreadArray_1.return)) _b.call(spreadArray_1);\n                      } finally {\n                        if (e_4) throw e_4.error;\n                      }\n                    }\n\n                    continue;\n                  }\n                }\n\n                var value_2 = simplify(item);\n\n                if (shouldIgnore(value_2)) {\n                  continue;\n                }\n\n                result_2.push(value_2);\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n\n            return result_2;\n          }\n\n          if (expression instanceof static_symbol_1.StaticSymbol) {\n            // Stop simplification at builtin symbols or if we are in a reference context and\n            // the symbol doesn't have members.\n            if (expression === self.injectionToken || self.conversionMap.has(expression) || references > 0 && !expression.members.length) {\n              return expression;\n            } else {\n              var staticSymbol = expression;\n              var declarationValue = resolveReferenceValue(staticSymbol);\n\n              if (declarationValue != null) {\n                return simplifyNested(staticSymbol, declarationValue);\n              } else {\n                return staticSymbol;\n              }\n            }\n          }\n\n          if (expression) {\n            if (expression['__symbolic']) {\n              var staticSymbol = void 0;\n\n              switch (expression['__symbolic']) {\n                case 'binop':\n                  var left = simplify(expression['left']);\n                  if (shouldIgnore(left)) return left;\n                  var right = simplify(expression['right']);\n                  if (shouldIgnore(right)) return right;\n\n                  switch (expression['operator']) {\n                    case '&&':\n                      return left && right;\n\n                    case '||':\n                      return left || right;\n\n                    case '|':\n                      return left | right;\n\n                    case '^':\n                      return left ^ right;\n\n                    case '&':\n                      return left & right;\n\n                    case '==':\n                      return left == right;\n\n                    case '!=':\n                      return left != right;\n\n                    case '===':\n                      return left === right;\n\n                    case '!==':\n                      return left !== right;\n\n                    case '<':\n                      return left < right;\n\n                    case '>':\n                      return left > right;\n\n                    case '<=':\n                      return left <= right;\n\n                    case '>=':\n                      return left >= right;\n\n                    case '<<':\n                      return left << right;\n\n                    case '>>':\n                      return left >> right;\n\n                    case '+':\n                      return left + right;\n\n                    case '-':\n                      return left - right;\n\n                    case '*':\n                      return left * right;\n\n                    case '/':\n                      return left / right;\n\n                    case '%':\n                      return left % right;\n                  }\n\n                  return null;\n\n                case 'if':\n                  var condition = simplify(expression['condition']);\n                  return condition ? simplify(expression['thenExpression']) : simplify(expression['elseExpression']);\n\n                case 'pre':\n                  var operand = simplify(expression['operand']);\n                  if (shouldIgnore(operand)) return operand;\n\n                  switch (expression['operator']) {\n                    case '+':\n                      return operand;\n\n                    case '-':\n                      return -operand;\n\n                    case '!':\n                      return !operand;\n\n                    case '~':\n                      return ~operand;\n                  }\n\n                  return null;\n\n                case 'index':\n                  var indexTarget = simplifyEagerly(expression['expression']);\n                  var index = simplifyEagerly(expression['index']);\n                  if (indexTarget && isPrimitive(index)) return indexTarget[index];\n                  return null;\n\n                case 'select':\n                  var member = expression['member'];\n                  var selectContext = context;\n                  var selectTarget = simplify(expression['expression']);\n\n                  if (selectTarget instanceof static_symbol_1.StaticSymbol) {\n                    var members = selectTarget.members.concat(member);\n                    selectContext = self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                    var declarationValue = resolveReferenceValue(selectContext);\n\n                    if (declarationValue != null) {\n                      return simplifyNested(selectContext, declarationValue);\n                    } else {\n                      return selectContext;\n                    }\n                  }\n\n                  if (selectTarget && isPrimitive(member)) return simplifyNested(selectContext, selectTarget[member]);\n                  return null;\n\n                case 'reference':\n                  // Note: This only has to deal with variable references, as symbol references have\n                  // been converted into 'resolved'\n                  // in the StaticSymbolResolver.\n                  var name_2 = expression['name'];\n                  var localValue = scope.resolve(name_2);\n\n                  if (localValue != BindingScope.missing) {\n                    return localValue;\n                  }\n\n                  break;\n\n                case 'resolved':\n                  try {\n                    return simplify(expression.symbol);\n                  } catch (e) {\n                    // If an error is reported evaluating the symbol record the position of the\n                    // reference in the error so it can\n                    // be reported in the error message generated from the exception.\n                    if (isMetadataError(e) && expression.fileName != null && expression.line != null && expression.character != null) {\n                      e.position = {\n                        fileName: expression.fileName,\n                        line: expression.line,\n                        column: expression.character\n                      };\n                    }\n\n                    throw e;\n                  }\n\n                case 'class':\n                  return context;\n\n                case 'function':\n                  return context;\n\n                case 'new':\n                case 'call':\n                  // Determine if the function is a built-in conversion\n                  staticSymbol = simplifyInContext(context, expression['expression'], depth + 1,\n                  /* references */\n                  0);\n\n                  if (staticSymbol instanceof static_symbol_1.StaticSymbol) {\n                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                      // if somebody calls new InjectionToken, don't create an InjectionToken,\n                      // but rather return the symbol to which the InjectionToken is assigned to.\n                      // OpaqueToken is supported too as it is required by the language service to\n                      // support v4 and prior versions of Angular.\n                      return context;\n                    }\n\n                    var argExpressions = expression['arguments'] || [];\n                    var converter = self.conversionMap.get(staticSymbol);\n\n                    if (converter) {\n                      var args = argExpressions.map(function (arg) {\n                        return simplifyNested(context, arg);\n                      }).map(function (arg) {\n                        return shouldIgnore(arg) ? undefined : arg;\n                      });\n                      return converter(context, args);\n                    } else {\n                      // Determine if the function is one we can simplify.\n                      var targetFunction = resolveReferenceValue(staticSymbol);\n                      return simplifyCall(staticSymbol, targetFunction, argExpressions, expression['expression']);\n                    }\n                  }\n\n                  return IGNORE;\n\n                case 'error':\n                  var message = expression.message;\n\n                  if (expression['line'] != null) {\n                    self.error({\n                      message: message,\n                      context: expression.context,\n                      value: expression,\n                      position: {\n                        fileName: expression['fileName'],\n                        line: expression['line'],\n                        column: expression['character']\n                      }\n                    }, context);\n                  } else {\n                    self.error({\n                      message: message,\n                      context: expression.context\n                    }, context);\n                  }\n\n                  return IGNORE;\n\n                case 'ignore':\n                  return expression;\n              }\n\n              return null;\n            }\n\n            return mapStringMap(expression, function (value, name) {\n              if (REFERENCE_SET.has(name)) {\n                if (name === USE_VALUE && PROVIDE in expression) {\n                  // If this is a provider expression, check for special tokens that need the value\n                  // during analysis.\n                  var provide = simplify(expression.provide);\n\n                  if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\n                    return simplify(value);\n                  }\n                }\n\n                return simplifyLazily(value);\n              }\n\n              return simplify(value);\n            });\n          }\n\n          return IGNORE;\n        }\n\n        return simplify(value);\n      }\n\n      var result;\n\n      try {\n        result = simplifyInContext(context, value, 0, lazy ? 1 : 0);\n      } catch (e) {\n        if (this.errorRecorder) {\n          this.reportError(e, context);\n        } else {\n          throw formatMetadataError(e, context);\n        }\n      }\n\n      if (shouldIgnore(result)) {\n        return undefined;\n      }\n\n      return result;\n    };\n\n    StaticReflector.prototype.getTypeMetadata = function (type) {\n      var resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n      return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata : {\n        __symbolic: 'class'\n      };\n    };\n\n    StaticReflector.prototype.reportError = function (error, context, path) {\n      if (this.errorRecorder) {\n        this.errorRecorder(formatMetadataError(error, context), context && context.filePath || path);\n      } else {\n        throw error;\n      }\n    };\n\n    StaticReflector.prototype.error = function (_a, reportingContext) {\n      var message = _a.message,\n          summary = _a.summary,\n          advise = _a.advise,\n          position = _a.position,\n          context = _a.context,\n          value = _a.value,\n          symbol = _a.symbol,\n          chain = _a.chain;\n      this.reportError(metadataError(message, summary, advise, position, symbol, context, chain), reportingContext);\n    };\n\n    return StaticReflector;\n  }();\n\n  exports.StaticReflector = StaticReflector;\n  var METADATA_ERROR = 'ngMetadataError';\n\n  function metadataError(message, summary, advise, position, symbol, context, chain) {\n    var error = util_1.syntaxError(message);\n    error[METADATA_ERROR] = true;\n    if (advise) error.advise = advise;\n    if (position) error.position = position;\n    if (summary) error.summary = summary;\n    if (context) error.context = context;\n    if (chain) error.chain = chain;\n    if (symbol) error.symbol = symbol;\n    return error;\n  }\n\n  function isMetadataError(error) {\n    return !!error[METADATA_ERROR];\n  }\n\n  var REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';\n  var VARIABLE_NOT_INITIALIZED = 'Variable not initialized';\n  var DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';\n  var COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';\n  var FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';\n  var REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';\n  var LAMBDA_NOT_SUPPORTED = 'Lambda not supported';\n\n  function expandedMessage(message, context) {\n    switch (message) {\n      case REFERENCE_TO_NONEXPORTED_CLASS:\n        if (context && context.className) {\n          return \"References to a non-exported class are not supported in decorators but \" + context.className + \" was referenced.\";\n        }\n\n        break;\n\n      case VARIABLE_NOT_INITIALIZED:\n        return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';\n\n      case DESTRUCTURE_NOT_SUPPORTED:\n        return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';\n\n      case COULD_NOT_RESOLVE_TYPE:\n        if (context && context.typeName) {\n          return \"Could not resolve type \" + context.typeName;\n        }\n\n        break;\n\n      case FUNCTION_CALL_NOT_SUPPORTED:\n        if (context && context.name) {\n          return \"Function calls are not supported in decorators but '\" + context.name + \"' was called\";\n        }\n\n        return 'Function calls are not supported in decorators';\n\n      case REFERENCE_TO_LOCAL_SYMBOL:\n        if (context && context.name) {\n          return \"Reference to a local (non-exported) symbols are not supported in decorators but '\" + context.name + \"' was referenced\";\n        }\n\n        break;\n\n      case LAMBDA_NOT_SUPPORTED:\n        return \"Function expressions are not supported in decorators\";\n    }\n\n    return message;\n  }\n\n  function messageAdvise(message, context) {\n    switch (message) {\n      case REFERENCE_TO_NONEXPORTED_CLASS:\n        if (context && context.className) {\n          return \"Consider exporting '\" + context.className + \"'\";\n        }\n\n        break;\n\n      case DESTRUCTURE_NOT_SUPPORTED:\n        return 'Consider simplifying to avoid destructuring';\n\n      case REFERENCE_TO_LOCAL_SYMBOL:\n        if (context && context.name) {\n          return \"Consider exporting '\" + context.name + \"'\";\n        }\n\n        break;\n\n      case LAMBDA_NOT_SUPPORTED:\n        return \"Consider changing the function expression into an exported function\";\n    }\n\n    return undefined;\n  }\n\n  function errorSummary(error) {\n    if (error.summary) {\n      return error.summary;\n    }\n\n    switch (error.message) {\n      case REFERENCE_TO_NONEXPORTED_CLASS:\n        if (error.context && error.context.className) {\n          return \"references non-exported class \" + error.context.className;\n        }\n\n        break;\n\n      case VARIABLE_NOT_INITIALIZED:\n        return 'is not initialized';\n\n      case DESTRUCTURE_NOT_SUPPORTED:\n        return 'is a destructured variable';\n\n      case COULD_NOT_RESOLVE_TYPE:\n        return 'could not be resolved';\n\n      case FUNCTION_CALL_NOT_SUPPORTED:\n        if (error.context && error.context.name) {\n          return \"calls '\" + error.context.name + \"'\";\n        }\n\n        return \"calls a function\";\n\n      case REFERENCE_TO_LOCAL_SYMBOL:\n        if (error.context && error.context.name) {\n          return \"references local variable \" + error.context.name;\n        }\n\n        return \"references a local variable\";\n    }\n\n    return 'contains the error';\n  }\n\n  function mapStringMap(input, transform) {\n    if (!input) return {};\n    var result = {};\n    Object.keys(input).forEach(function (key) {\n      var value = transform(input[key], key);\n\n      if (!shouldIgnore(value)) {\n        if (HIDDEN_KEY.test(key)) {\n          Object.defineProperty(result, key, {\n            enumerable: false,\n            configurable: true,\n            value: value\n          });\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n    return result;\n  }\n\n  function isPrimitive(o) {\n    return o === null || typeof o !== 'function' && typeof o !== 'object';\n  }\n\n  var BindingScope =\n  /** @class */\n  function () {\n    function BindingScope() {}\n\n    BindingScope.build = function () {\n      var current = new Map();\n      return {\n        define: function define(name, value) {\n          current.set(name, value);\n          return this;\n        },\n        done: function done() {\n          return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n        }\n      };\n    };\n\n    BindingScope.missing = {};\n    BindingScope.empty = {\n      resolve: function resolve(name) {\n        return BindingScope.missing;\n      }\n    };\n    return BindingScope;\n  }();\n\n  var PopulatedScope =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(PopulatedScope, _super);\n\n    function PopulatedScope(bindings) {\n      var _this = _super.call(this) || this;\n\n      _this.bindings = bindings;\n      return _this;\n    }\n\n    PopulatedScope.prototype.resolve = function (name) {\n      return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;\n    };\n\n    return PopulatedScope;\n  }(BindingScope);\n\n  function formatMetadataMessageChain(chain, advise) {\n    var expanded = expandedMessage(chain.message, chain.context);\n    var nesting = chain.symbol ? \" in '\" + chain.symbol.name + \"'\" : '';\n    var message = \"\" + expanded + nesting;\n    var position = chain.position;\n    var next = chain.next ? formatMetadataMessageChain(chain.next, advise) : advise ? {\n      message: advise\n    } : undefined;\n    return {\n      message: message,\n      position: position,\n      next: next ? [next] : undefined\n    };\n  }\n\n  function formatMetadataError(e, context) {\n    if (isMetadataError(e)) {\n      // Produce a formatted version of the and leaving enough information in the original error\n      // to recover the formatting information to eventually produce a diagnostic error message.\n      var position = e.position;\n      var chain = {\n        message: \"Error during template compile of '\" + context.name + \"'\",\n        position: position,\n        next: {\n          message: e.message,\n          next: e.chain,\n          context: e.context,\n          symbol: e.symbol\n        }\n      };\n      var advise = e.advise || messageAdvise(e.message, e.context);\n      return formatted_error_1.formattedError(formatMetadataMessageChain(chain, advise));\n    }\n\n    return e;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/static_reflector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileSummaryKind} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {createAttribute, createComponent, createContentChild, createContentChildren, createDirective, createHost, createHostBinding, createHostListener, createInject, createInjectable, createInput, createNgModule, createOptional, createOutput, createPipe, createSelf, createSkipSelf, createViewChild, createViewChildren, MetadataFactory} from '../core';\nimport * as o from '../output/output_ast';\nimport {SummaryResolver} from '../summary_resolver';\nimport {syntaxError} from '../util';\n\nimport {formattedError, FormattedMessageChain} from './formatted_error';\nimport {StaticSymbol} from './static_symbol';\nimport {StaticSymbolResolver} from './static_symbol_resolver';\n\nconst ANGULAR_CORE = '@angular/core';\nconst ANGULAR_ROUTER = '@angular/router';\n\nconst HIDDEN_KEY = /^\\$.*\\$$/;\n\nconst IGNORE = {\n  __symbolic: 'ignore'\n};\n\nconst USE_VALUE = 'useValue';\nconst PROVIDE = 'provide';\nconst REFERENCE_SET = new Set([USE_VALUE, 'useFactory', 'data', 'id', 'loadChildren']);\nconst TYPEGUARD_POSTFIX = 'TypeGuard';\nconst USE_IF = 'UseIf';\n\nfunction shouldIgnore(value: any): boolean {\n  return value && value.__symbolic == 'ignore';\n}\n\n/**\n * A static reflector implements enough of the Reflector API that is necessary to compile\n * templates statically.\n */\nexport class StaticReflector implements CompileReflector {\n  private annotationCache = new Map<StaticSymbol, any[]>();\n  private shallowAnnotationCache = new Map<StaticSymbol, any[]>();\n  private propertyCache = new Map<StaticSymbol, {[key: string]: any[]}>();\n  private parameterCache = new Map<StaticSymbol, any[]>();\n  private methodCache = new Map<StaticSymbol, {[key: string]: boolean}>();\n  private staticCache = new Map<StaticSymbol, string[]>();\n  private conversionMap = new Map<StaticSymbol, (context: StaticSymbol, args: any[]) => any>();\n  private resolvedExternalReferences = new Map<string, StaticSymbol>();\n  // TODO(issue/24571): remove '!'.\n  private injectionToken!: StaticSymbol;\n  // TODO(issue/24571): remove '!'.\n  private opaqueToken!: StaticSymbol;\n  // TODO(issue/24571): remove '!'.\n  ROUTES!: StaticSymbol;\n  // TODO(issue/24571): remove '!'.\n  private ANALYZE_FOR_ENTRY_COMPONENTS!: StaticSymbol;\n  private annotationForParentClassWithSummaryKind =\n      new Map<CompileSummaryKind, MetadataFactory<any>[]>();\n\n  constructor(\n      private summaryResolver: SummaryResolver<StaticSymbol>,\n      private symbolResolver: StaticSymbolResolver,\n      knownMetadataClasses: {name: string, filePath: string, ctor: any}[] = [],\n      knownMetadataFunctions: {name: string, filePath: string, fn: any}[] = [],\n      private errorRecorder?: (error: any, fileName?: string) => void) {\n    this.initializeConversionMap();\n    knownMetadataClasses.forEach(\n        (kc) => this._registerDecoratorOrConstructor(\n            this.getStaticSymbol(kc.filePath, kc.name), kc.ctor));\n    knownMetadataFunctions.forEach(\n        (kf) => this._registerFunction(this.getStaticSymbol(kf.filePath, kf.name), kf.fn));\n    this.annotationForParentClassWithSummaryKind.set(\n        CompileSummaryKind.Directive, [createDirective, createComponent]);\n    this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);\n    this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);\n    this.annotationForParentClassWithSummaryKind.set(\n        CompileSummaryKind.Injectable,\n        [createInjectable, createPipe, createDirective, createComponent, createNgModule]);\n  }\n\n  componentModuleUrl(typeOrFunc: StaticSymbol): string {\n    const staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n    return this.symbolResolver.getResourcePath(staticSymbol);\n  }\n\n  /**\n   * Invalidate the specified `symbols` on program change.\n   * @param symbols\n   */\n  invalidateSymbols(symbols: StaticSymbol[]) {\n    for (const symbol of symbols) {\n      this.annotationCache.delete(symbol);\n      this.shallowAnnotationCache.delete(symbol);\n      this.propertyCache.delete(symbol);\n      this.parameterCache.delete(symbol);\n      this.methodCache.delete(symbol);\n      this.staticCache.delete(symbol);\n      this.conversionMap.delete(symbol);\n    }\n  }\n\n  resolveExternalReference(ref: o.ExternalReference, containingFile?: string): StaticSymbol {\n    let key: string|undefined = undefined;\n    if (!containingFile) {\n      key = `${ref.moduleName}:${ref.name}`;\n      const declarationSymbol = this.resolvedExternalReferences.get(key);\n      if (declarationSymbol) return declarationSymbol;\n    }\n    const refSymbol =\n        this.symbolResolver.getSymbolByModule(ref.moduleName!, ref.name!, containingFile);\n    const declarationSymbol = this.findSymbolDeclaration(refSymbol);\n    if (!containingFile) {\n      this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName!);\n      this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);\n    }\n    if (key) {\n      this.resolvedExternalReferences.set(key, declarationSymbol);\n    }\n    return declarationSymbol;\n  }\n\n  findDeclaration(moduleUrl: string, name: string, containingFile?: string): StaticSymbol {\n    return this.findSymbolDeclaration(\n        this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n  }\n\n  tryFindDeclaration(moduleUrl: string, name: string, containingFile?: string): StaticSymbol {\n    return this.symbolResolver.ignoreErrorsFor(\n        () => this.findDeclaration(moduleUrl, name, containingFile));\n  }\n\n  findSymbolDeclaration(symbol: StaticSymbol): StaticSymbol {\n    const resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n    if (resolvedSymbol) {\n      let resolvedMetadata = resolvedSymbol.metadata;\n      if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {\n        resolvedMetadata = resolvedMetadata.symbol;\n      }\n      if (resolvedMetadata instanceof StaticSymbol) {\n        return this.findSymbolDeclaration(resolvedSymbol.metadata);\n      }\n    }\n    return symbol;\n  }\n\n  public tryAnnotations(type: StaticSymbol): any[] {\n    const originalRecorder = this.errorRecorder;\n    this.errorRecorder = (error: any, fileName?: string) => {};\n    try {\n      return this.annotations(type);\n    } finally {\n      this.errorRecorder = originalRecorder;\n    }\n  }\n\n  public annotations(type: StaticSymbol): any[] {\n    return this._annotations(\n        type, (type: StaticSymbol, decorators: any) => this.simplify(type, decorators),\n        this.annotationCache);\n  }\n\n  public shallowAnnotations(type: StaticSymbol): any[] {\n    return this._annotations(\n        type, (type: StaticSymbol, decorators: any) => this.simplify(type, decorators, true),\n        this.shallowAnnotationCache);\n  }\n\n  private _annotations(\n      type: StaticSymbol, simplify: (type: StaticSymbol, decorators: any) => any,\n      annotationCache: Map<StaticSymbol, any[]>): any[] {\n    let annotations = annotationCache.get(type);\n    if (!annotations) {\n      annotations = [];\n      const classMetadata = this.getTypeMetadata(type);\n      const parentType = this.findParentType(type, classMetadata);\n      if (parentType) {\n        const parentAnnotations = this.annotations(parentType);\n        annotations.push(...parentAnnotations);\n      }\n      let ownAnnotations: any[] = [];\n      if (classMetadata['decorators']) {\n        ownAnnotations = simplify(type, classMetadata['decorators']);\n        if (ownAnnotations) {\n          annotations.push(...ownAnnotations);\n        }\n      }\n      if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\n          this.summaryResolver.isLibraryFile(parentType.filePath)) {\n        const summary = this.summaryResolver.resolveSummary(parentType);\n        if (summary && summary.type) {\n          const requiredAnnotationTypes =\n              this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind!)!;\n          const typeHasRequiredAnnotation = requiredAnnotationTypes.some(\n              (requiredType) => ownAnnotations.some(ann => requiredType.isTypeOf(ann)));\n          if (!typeHasRequiredAnnotation) {\n            this.reportError(\n                formatMetadataError(\n                    metadataError(\n                        `Class ${type.name} in ${type.filePath} extends from a ${\n                            CompileSummaryKind[summary.type.summaryKind!\n            ]} in another compilation unit without duplicating the decorator`,\n                        /* summary */ undefined,\n                        `Please add a ${\n                            requiredAnnotationTypes.map((type) => type.ngMetadataName)\n                                .join(' or ')} decorator to the class`),\n                    type),\n                type);\n          }\n        }\n      }\n      annotationCache.set(type, annotations.filter(ann => !!ann));\n    }\n    return annotations;\n  }\n\n  public propMetadata(type: StaticSymbol): {[key: string]: any[]} {\n    let propMetadata = this.propertyCache.get(type);\n    if (!propMetadata) {\n      const classMetadata = this.getTypeMetadata(type);\n      propMetadata = {};\n      const parentType = this.findParentType(type, classMetadata);\n      if (parentType) {\n        const parentPropMetadata = this.propMetadata(parentType);\n        Object.keys(parentPropMetadata).forEach((parentProp) => {\n          propMetadata![parentProp] = parentPropMetadata[parentProp];\n        });\n      }\n\n      const members = classMetadata['members'] || {};\n      Object.keys(members).forEach((propName) => {\n        const propData = members[propName];\n        const prop = (<any[]>propData)\n                         .find(a => a['__symbolic'] == 'property' || a['__symbolic'] == 'method');\n        const decorators: any[] = [];\n        // hasOwnProperty() is used here to make sure we do not look up methods\n        // on `Object.prototype`.\n        if (propMetadata?.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata![propName]);\n        }\n        propMetadata![propName] = decorators;\n        if (prop && prop['decorators']) {\n          decorators.push(...this.simplify(type, prop['decorators']));\n        }\n      });\n      this.propertyCache.set(type, propMetadata);\n    }\n    return propMetadata;\n  }\n\n  public parameters(type: StaticSymbol): any[] {\n    if (!(type instanceof StaticSymbol)) {\n      this.reportError(\n          new Error(`parameters received ${JSON.stringify(type)} which is not a StaticSymbol`),\n          type);\n      return [];\n    }\n    try {\n      let parameters = this.parameterCache.get(type);\n      if (!parameters) {\n        const classMetadata = this.getTypeMetadata(type);\n        const parentType = this.findParentType(type, classMetadata);\n        const members = classMetadata ? classMetadata['members'] : null;\n        const ctorData = members ? members['__ctor__'] : null;\n        if (ctorData) {\n          const ctor = (<any[]>ctorData).find(a => a['__symbolic'] == 'constructor');\n          const rawParameterTypes = <any[]>ctor['parameters'] || [];\n          const parameterDecorators = <any[]>this.simplify(type, ctor['parameterDecorators'] || []);\n          parameters = [];\n          rawParameterTypes.forEach((rawParamType, index) => {\n            const nestedResult: any[] = [];\n            const paramType = this.trySimplify(type, rawParamType);\n            if (paramType) nestedResult.push(paramType);\n            const decorators = parameterDecorators ? parameterDecorators[index] : null;\n            if (decorators) {\n              nestedResult.push(...decorators);\n            }\n            parameters!.push(nestedResult);\n          });\n        } else if (parentType) {\n          parameters = this.parameters(parentType);\n        }\n        if (!parameters) {\n          parameters = [];\n        }\n        this.parameterCache.set(type, parameters);\n      }\n      return parameters;\n    } catch (e) {\n      console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);\n      throw e;\n    }\n  }\n\n  private _methodNames(type: any): {[key: string]: boolean} {\n    let methodNames = this.methodCache.get(type);\n    if (!methodNames) {\n      const classMetadata = this.getTypeMetadata(type);\n      methodNames = {};\n      const parentType = this.findParentType(type, classMetadata);\n      if (parentType) {\n        const parentMethodNames = this._methodNames(parentType);\n        Object.keys(parentMethodNames).forEach((parentProp) => {\n          methodNames![parentProp] = parentMethodNames[parentProp];\n        });\n      }\n\n      const members = classMetadata['members'] || {};\n      Object.keys(members).forEach((propName) => {\n        const propData = members[propName];\n        const isMethod = (<any[]>propData).some(a => a['__symbolic'] == 'method');\n        methodNames![propName] = methodNames![propName] || isMethod;\n      });\n      this.methodCache.set(type, methodNames);\n    }\n    return methodNames;\n  }\n\n  private _staticMembers(type: StaticSymbol): string[] {\n    let staticMembers = this.staticCache.get(type);\n    if (!staticMembers) {\n      const classMetadata = this.getTypeMetadata(type);\n      const staticMemberData = classMetadata['statics'] || {};\n      staticMembers = Object.keys(staticMemberData);\n      this.staticCache.set(type, staticMembers);\n    }\n    return staticMembers;\n  }\n\n\n  private findParentType(type: StaticSymbol, classMetadata: any): StaticSymbol|undefined {\n    const parentType = this.trySimplify(type, classMetadata['extends']);\n    if (parentType instanceof StaticSymbol) {\n      return parentType;\n    }\n  }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean {\n    if (!(type instanceof StaticSymbol)) {\n      this.reportError(\n          new Error(\n              `hasLifecycleHook received ${JSON.stringify(type)} which is not a StaticSymbol`),\n          type);\n    }\n    try {\n      return !!this._methodNames(type)[lcProperty];\n    } catch (e) {\n      console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);\n      throw e;\n    }\n  }\n\n  guards(type: any): {[key: string]: StaticSymbol} {\n    if (!(type instanceof StaticSymbol)) {\n      this.reportError(\n          new Error(`guards received ${JSON.stringify(type)} which is not a StaticSymbol`), type);\n      return {};\n    }\n    const staticMembers = this._staticMembers(type);\n    const result: {[key: string]: StaticSymbol} = {};\n    for (let name of staticMembers) {\n      if (name.endsWith(TYPEGUARD_POSTFIX)) {\n        let property = name.substr(0, name.length - TYPEGUARD_POSTFIX.length);\n        let value: any;\n        if (property.endsWith(USE_IF)) {\n          property = name.substr(0, property.length - USE_IF.length);\n          value = USE_IF;\n        } else {\n          value = this.getStaticSymbol(type.filePath, type.name, [name]);\n        }\n        result[property] = value;\n      }\n    }\n    return result;\n  }\n\n  private _registerDecoratorOrConstructor(type: StaticSymbol, ctor: any): void {\n    this.conversionMap.set(type, (context: StaticSymbol, args: any[]) => new ctor(...args));\n  }\n\n  private _registerFunction(type: StaticSymbol, fn: any): void {\n    this.conversionMap.set(type, (context: StaticSymbol, args: any[]) => fn.apply(undefined, args));\n  }\n\n  private initializeConversionMap(): void {\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);\n    this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n    this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n    this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\n    this.ANALYZE_FOR_ENTRY_COMPONENTS =\n        this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\n\n    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);\n    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);\n    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule);\n\n    // Note: Some metadata classes can be used directly with Provider.deps.\n    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n    this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n    this._registerDecoratorOrConstructor(\n        this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n  }\n\n  /**\n   * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n   * All types passed to the StaticResolver should be pseudo-types returned by this method.\n   *\n   * @param declarationFile the absolute path of the file where the symbol is declared\n   * @param name the name of the type.\n   */\n  getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n  }\n\n  /**\n   * Simplify but discard any errors\n   */\n  private trySimplify(context: StaticSymbol, value: any): any {\n    const originalRecorder = this.errorRecorder;\n    this.errorRecorder = (error: any, fileName?: string) => {};\n    const result = this.simplify(context, value);\n    this.errorRecorder = originalRecorder;\n    return result;\n  }\n\n  /** @internal */\n  public simplify(context: StaticSymbol, value: any, lazy: boolean = false): any {\n    const self = this;\n    let scope = BindingScope.empty;\n    const calling = new Map<StaticSymbol, boolean>();\n    const rootContext = context;\n\n    function simplifyInContext(\n        context: StaticSymbol, value: any, depth: number, references: number): any {\n      function resolveReferenceValue(staticSymbol: StaticSymbol): any {\n        const resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n        return resolvedSymbol ? resolvedSymbol.metadata : null;\n      }\n\n      function simplifyEagerly(value: any): any {\n        return simplifyInContext(context, value, depth, 0);\n      }\n\n      function simplifyLazily(value: any): any {\n        return simplifyInContext(context, value, depth, references + 1);\n      }\n\n      function simplifyNested(nestedContext: StaticSymbol, value: any): any {\n        if (nestedContext === context) {\n          // If the context hasn't changed let the exception propagate unmodified.\n          return simplifyInContext(nestedContext, value, depth + 1, references);\n        }\n        try {\n          return simplifyInContext(nestedContext, value, depth + 1, references);\n        } catch (e) {\n          if (isMetadataError(e)) {\n            // Propagate the message text up but add a message to the chain that explains how we got\n            // here.\n            // e.chain implies e.symbol\n            const summaryMsg = e.chain ? 'references \\'' + e.symbol!.name + '\\'' : errorSummary(e);\n            const summary = `'${nestedContext.name}' ${summaryMsg}`;\n            const chain = {message: summary, position: e.position, next: e.chain};\n            // TODO(chuckj): retrieve the position information indirectly from the collectors node\n            // map if the metadata is from a .ts file.\n            self.error(\n                {\n                  message: e.message,\n                  advise: e.advise,\n                  context: e.context,\n                  chain,\n                  symbol: nestedContext\n                },\n                context);\n          } else {\n            // It is probably an internal error.\n            throw e;\n          }\n        }\n      }\n\n      function simplifyCall(\n          functionSymbol: StaticSymbol, targetFunction: any, args: any[], targetExpression: any) {\n        if (targetFunction && targetFunction['__symbolic'] == 'function') {\n          if (calling.get(functionSymbol)) {\n            self.error(\n                {\n                  message: 'Recursion is not supported',\n                  summary: `called '${functionSymbol.name}' recursively`,\n                  value: targetFunction\n                },\n                functionSymbol);\n          }\n          try {\n            const value = targetFunction['value'];\n            if (value && (depth != 0 || value.__symbolic != 'error')) {\n              const parameters: string[] = targetFunction['parameters'];\n              const defaults: any[] = targetFunction.defaults;\n              args = args.map(arg => simplifyNested(context, arg))\n                         .map(arg => shouldIgnore(arg) ? undefined : arg);\n              if (defaults && defaults.length > args.length) {\n                args.push(...defaults.slice(args.length).map((value: any) => simplify(value)));\n              }\n              calling.set(functionSymbol, true);\n              const functionScope = BindingScope.build();\n              for (let i = 0; i < parameters.length; i++) {\n                functionScope.define(parameters[i], args[i]);\n              }\n              const oldScope = scope;\n              let result: any;\n              try {\n                scope = functionScope.done();\n                result = simplifyNested(functionSymbol, value);\n              } finally {\n                scope = oldScope;\n              }\n              return result;\n            }\n          } finally {\n            calling.delete(functionSymbol);\n          }\n        }\n\n        if (depth === 0) {\n          // If depth is 0 we are evaluating the top level expression that is describing element\n          // decorator. In this case, it is a decorator we don't understand, such as a custom\n          // non-angular decorator, and we should just ignore it.\n          return IGNORE;\n        }\n        let position: Position|undefined = undefined;\n        if (targetExpression && targetExpression.__symbolic == 'resolved') {\n          const line = targetExpression.line;\n          const character = targetExpression.character;\n          const fileName = targetExpression.fileName;\n          if (fileName != null && line != null && character != null) {\n            position = {fileName, line, column: character};\n          }\n        }\n        self.error(\n            {\n              message: FUNCTION_CALL_NOT_SUPPORTED,\n              context: functionSymbol,\n              value: targetFunction,\n              position\n            },\n            context);\n      }\n\n      function simplify(expression: any): any {\n        if (isPrimitive(expression)) {\n          return expression;\n        }\n        if (Array.isArray(expression)) {\n          const result: any[] = [];\n          for (const item of (<any>expression)) {\n            // Check for a spread expression\n            if (item && item.__symbolic === 'spread') {\n              // We call with references as 0 because we require the actual value and cannot\n              // tolerate a reference here.\n              const spreadArray = simplifyEagerly(item.expression);\n              if (Array.isArray(spreadArray)) {\n                for (const spreadItem of spreadArray) {\n                  result.push(spreadItem);\n                }\n                continue;\n              }\n            }\n            const value = simplify(item);\n            if (shouldIgnore(value)) {\n              continue;\n            }\n            result.push(value);\n          }\n          return result;\n        }\n        if (expression instanceof StaticSymbol) {\n          // Stop simplification at builtin symbols or if we are in a reference context and\n          // the symbol doesn't have members.\n          if (expression === self.injectionToken || self.conversionMap.has(expression) ||\n              (references > 0 && !expression.members.length)) {\n            return expression;\n          } else {\n            const staticSymbol = expression;\n            const declarationValue = resolveReferenceValue(staticSymbol);\n            if (declarationValue != null) {\n              return simplifyNested(staticSymbol, declarationValue);\n            } else {\n              return staticSymbol;\n            }\n          }\n        }\n        if (expression) {\n          if (expression['__symbolic']) {\n            let staticSymbol: StaticSymbol;\n            switch (expression['__symbolic']) {\n              case 'binop':\n                let left = simplify(expression['left']);\n                if (shouldIgnore(left)) return left;\n                let right = simplify(expression['right']);\n                if (shouldIgnore(right)) return right;\n                switch (expression['operator']) {\n                  case '&&':\n                    return left && right;\n                  case '||':\n                    return left || right;\n                  case '|':\n                    return left | right;\n                  case '^':\n                    return left ^ right;\n                  case '&':\n                    return left & right;\n                  case '==':\n                    return left == right;\n                  case '!=':\n                    return left != right;\n                  case '===':\n                    return left === right;\n                  case '!==':\n                    return left !== right;\n                  case '<':\n                    return left < right;\n                  case '>':\n                    return left > right;\n                  case '<=':\n                    return left <= right;\n                  case '>=':\n                    return left >= right;\n                  case '<<':\n                    return left << right;\n                  case '>>':\n                    return left >> right;\n                  case '+':\n                    return left + right;\n                  case '-':\n                    return left - right;\n                  case '*':\n                    return left * right;\n                  case '/':\n                    return left / right;\n                  case '%':\n                    return left % right;\n                }\n                return null;\n              case 'if':\n                let condition = simplify(expression['condition']);\n                return condition ? simplify(expression['thenExpression']) :\n                                   simplify(expression['elseExpression']);\n              case 'pre':\n                let operand = simplify(expression['operand']);\n                if (shouldIgnore(operand)) return operand;\n                switch (expression['operator']) {\n                  case '+':\n                    return operand;\n                  case '-':\n                    return -operand;\n                  case '!':\n                    return !operand;\n                  case '~':\n                    return ~operand;\n                }\n                return null;\n              case 'index':\n                let indexTarget = simplifyEagerly(expression['expression']);\n                let index = simplifyEagerly(expression['index']);\n                if (indexTarget && isPrimitive(index)) return indexTarget[index];\n                return null;\n              case 'select':\n                const member = expression['member'];\n                let selectContext = context;\n                let selectTarget = simplify(expression['expression']);\n                if (selectTarget instanceof StaticSymbol) {\n                  const members = selectTarget.members.concat(member);\n                  selectContext =\n                      self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n                  const declarationValue = resolveReferenceValue(selectContext);\n                  if (declarationValue != null) {\n                    return simplifyNested(selectContext, declarationValue);\n                  } else {\n                    return selectContext;\n                  }\n                }\n                if (selectTarget && isPrimitive(member))\n                  return simplifyNested(selectContext, selectTarget[member]);\n                return null;\n              case 'reference':\n                // Note: This only has to deal with variable references, as symbol references have\n                // been converted into 'resolved'\n                // in the StaticSymbolResolver.\n                const name: string = expression['name'];\n                const localValue = scope.resolve(name);\n                if (localValue != BindingScope.missing) {\n                  return localValue;\n                }\n                break;\n              case 'resolved':\n                try {\n                  return simplify(expression.symbol);\n                } catch (e) {\n                  // If an error is reported evaluating the symbol record the position of the\n                  // reference in the error so it can\n                  // be reported in the error message generated from the exception.\n                  if (isMetadataError(e) && expression.fileName != null &&\n                      expression.line != null && expression.character != null) {\n                    e.position = {\n                      fileName: expression.fileName,\n                      line: expression.line,\n                      column: expression.character\n                    };\n                  }\n                  throw e;\n                }\n              case 'class':\n                return context;\n              case 'function':\n                return context;\n              case 'new':\n              case 'call':\n                // Determine if the function is a built-in conversion\n                staticSymbol = simplifyInContext(\n                    context, expression['expression'], depth + 1, /* references */ 0);\n                if (staticSymbol instanceof StaticSymbol) {\n                  if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\n                    // if somebody calls new InjectionToken, don't create an InjectionToken,\n                    // but rather return the symbol to which the InjectionToken is assigned to.\n\n                    // OpaqueToken is supported too as it is required by the language service to\n                    // support v4 and prior versions of Angular.\n                    return context;\n                  }\n                  const argExpressions: any[] = expression['arguments'] || [];\n                  let converter = self.conversionMap.get(staticSymbol);\n                  if (converter) {\n                    const args = argExpressions.map(arg => simplifyNested(context, arg))\n                                     .map(arg => shouldIgnore(arg) ? undefined : arg);\n                    return converter(context, args);\n                  } else {\n                    // Determine if the function is one we can simplify.\n                    const targetFunction = resolveReferenceValue(staticSymbol);\n                    return simplifyCall(\n                        staticSymbol, targetFunction, argExpressions, expression['expression']);\n                  }\n                }\n                return IGNORE;\n              case 'error':\n                let message = expression.message;\n                if (expression['line'] != null) {\n                  self.error(\n                      {\n                        message,\n                        context: expression.context,\n                        value: expression,\n                        position: {\n                          fileName: expression['fileName'],\n                          line: expression['line'],\n                          column: expression['character']\n                        }\n                      },\n                      context);\n                } else {\n                  self.error({message, context: expression.context}, context);\n                }\n                return IGNORE;\n              case 'ignore':\n                return expression;\n            }\n            return null;\n          }\n          return mapStringMap(expression, (value, name) => {\n            if (REFERENCE_SET.has(name)) {\n              if (name === USE_VALUE && PROVIDE in expression) {\n                // If this is a provider expression, check for special tokens that need the value\n                // during analysis.\n                const provide = simplify(expression.provide);\n                if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\n                  return simplify(value);\n                }\n              }\n              return simplifyLazily(value);\n            }\n            return simplify(value);\n          });\n        }\n        return IGNORE;\n      }\n\n      return simplify(value);\n    }\n\n    let result: any;\n    try {\n      result = simplifyInContext(context, value, 0, lazy ? 1 : 0);\n    } catch (e) {\n      if (this.errorRecorder) {\n        this.reportError(e, context);\n      } else {\n        throw formatMetadataError(e, context);\n      }\n    }\n    if (shouldIgnore(result)) {\n      return undefined;\n    }\n    return result;\n  }\n\n  private getTypeMetadata(type: StaticSymbol): {[key: string]: any} {\n    const resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n    return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\n                                                       {__symbolic: 'class'};\n  }\n\n  private reportError(error: Error, context: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(\n          formatMetadataError(error, context), (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n\n  private error(\n      {message, summary, advise, position, context, value, symbol, chain}: {\n        message: string,\n        summary?: string,\n        advise?: string,\n        position?: Position,\n        context?: any,\n        value?: any,\n        symbol?: StaticSymbol,\n        chain?: MetadataMessageChain\n      },\n      reportingContext: StaticSymbol) {\n    this.reportError(\n        metadataError(message, summary, advise, position, symbol, context, chain),\n        reportingContext);\n  }\n}\n\ninterface Position {\n  fileName: string;\n  line: number;\n  column: number;\n}\n\ninterface MetadataMessageChain {\n  message: string;\n  summary?: string;\n  position?: Position;\n  context?: any;\n  symbol?: StaticSymbol;\n  next?: MetadataMessageChain;\n}\n\ntype MetadataError = Error&{\n  position?: Position;\n  advise?: string;\n  summary?: string;\n  context?: any;\n  symbol?: StaticSymbol;\n  chain?: MetadataMessageChain;\n};\n\nconst METADATA_ERROR = 'ngMetadataError';\n\nfunction metadataError(\n    message: string, summary?: string, advise?: string, position?: Position, symbol?: StaticSymbol,\n    context?: any, chain?: MetadataMessageChain): MetadataError {\n  const error = syntaxError(message) as MetadataError;\n  (error as any)[METADATA_ERROR] = true;\n  if (advise) error.advise = advise;\n  if (position) error.position = position;\n  if (summary) error.summary = summary;\n  if (context) error.context = context;\n  if (chain) error.chain = chain;\n  if (symbol) error.symbol = symbol;\n  return error;\n}\n\nfunction isMetadataError(error: Error): error is MetadataError {\n  return !!(error as any)[METADATA_ERROR];\n}\n\nconst REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';\nconst VARIABLE_NOT_INITIALIZED = 'Variable not initialized';\nconst DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';\nconst COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';\nconst FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';\nconst REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';\nconst LAMBDA_NOT_SUPPORTED = 'Lambda not supported';\n\nfunction expandedMessage(message: string, context: any): string {\n  switch (message) {\n    case REFERENCE_TO_NONEXPORTED_CLASS:\n      if (context && context.className) {\n        return `References to a non-exported class are not supported in decorators but ${\n            context.className} was referenced.`;\n      }\n      break;\n    case VARIABLE_NOT_INITIALIZED:\n      return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';\n    case DESTRUCTURE_NOT_SUPPORTED:\n      return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';\n    case COULD_NOT_RESOLVE_TYPE:\n      if (context && context.typeName) {\n        return `Could not resolve type ${context.typeName}`;\n      }\n      break;\n    case FUNCTION_CALL_NOT_SUPPORTED:\n      if (context && context.name) {\n        return `Function calls are not supported in decorators but '${context.name}' was called`;\n      }\n      return 'Function calls are not supported in decorators';\n    case REFERENCE_TO_LOCAL_SYMBOL:\n      if (context && context.name) {\n        return `Reference to a local (non-exported) symbols are not supported in decorators but '${\n            context.name}' was referenced`;\n      }\n      break;\n    case LAMBDA_NOT_SUPPORTED:\n      return `Function expressions are not supported in decorators`;\n  }\n  return message;\n}\n\nfunction messageAdvise(message: string, context: any): string|undefined {\n  switch (message) {\n    case REFERENCE_TO_NONEXPORTED_CLASS:\n      if (context && context.className) {\n        return `Consider exporting '${context.className}'`;\n      }\n      break;\n    case DESTRUCTURE_NOT_SUPPORTED:\n      return 'Consider simplifying to avoid destructuring';\n    case REFERENCE_TO_LOCAL_SYMBOL:\n      if (context && context.name) {\n        return `Consider exporting '${context.name}'`;\n      }\n      break;\n    case LAMBDA_NOT_SUPPORTED:\n      return `Consider changing the function expression into an exported function`;\n  }\n  return undefined;\n}\n\nfunction errorSummary(error: MetadataError): string {\n  if (error.summary) {\n    return error.summary;\n  }\n  switch (error.message) {\n    case REFERENCE_TO_NONEXPORTED_CLASS:\n      if (error.context && error.context.className) {\n        return `references non-exported class ${error.context.className}`;\n      }\n      break;\n    case VARIABLE_NOT_INITIALIZED:\n      return 'is not initialized';\n    case DESTRUCTURE_NOT_SUPPORTED:\n      return 'is a destructured variable';\n    case COULD_NOT_RESOLVE_TYPE:\n      return 'could not be resolved';\n    case FUNCTION_CALL_NOT_SUPPORTED:\n      if (error.context && error.context.name) {\n        return `calls '${error.context.name}'`;\n      }\n      return `calls a function`;\n    case REFERENCE_TO_LOCAL_SYMBOL:\n      if (error.context && error.context.name) {\n        return `references local variable ${error.context.name}`;\n      }\n      return `references a local variable`;\n  }\n  return 'contains the error';\n}\n\nfunction mapStringMap(input: {[key: string]: any}, transform: (value: any, key: string) => any):\n    {[key: string]: any} {\n  if (!input) return {};\n  const result: {[key: string]: any} = {};\n  Object.keys(input).forEach((key) => {\n    const value = transform(input[key], key);\n    if (!shouldIgnore(value)) {\n      if (HIDDEN_KEY.test(key)) {\n        Object.defineProperty(result, key, {enumerable: false, configurable: true, value: value});\n      } else {\n        result[key] = value;\n      }\n    }\n  });\n  return result;\n}\n\nfunction isPrimitive(o: any): boolean {\n  return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\n\ninterface BindingScopeBuilder {\n  define(name: string, value: any): BindingScopeBuilder;\n  done(): BindingScope;\n}\n\nabstract class BindingScope {\n  abstract resolve(name: string): any;\n  public static missing = {};\n  public static empty: BindingScope = {resolve: name => BindingScope.missing};\n\n  public static build(): BindingScopeBuilder {\n    const current = new Map<string, any>();\n    return {\n      define: function(name, value) {\n        current.set(name, value);\n        return this;\n      },\n      done: function() {\n        return current.size > 0 ? new PopulatedScope(current) : BindingScope.empty;\n      }\n    };\n  }\n}\n\nclass PopulatedScope extends BindingScope {\n  constructor(private bindings: Map<string, any>) {\n    super();\n  }\n\n  resolve(name: string): any {\n    return this.bindings.has(name) ? this.bindings.get(name) : BindingScope.missing;\n  }\n}\n\nfunction formatMetadataMessageChain(\n    chain: MetadataMessageChain, advise: string|undefined): FormattedMessageChain {\n  const expanded = expandedMessage(chain.message, chain.context);\n  const nesting = chain.symbol ? ` in '${chain.symbol.name}'` : '';\n  const message = `${expanded}${nesting}`;\n  const position = chain.position;\n  const next: FormattedMessageChain|undefined = chain.next ?\n      formatMetadataMessageChain(chain.next, advise) :\n      advise ? {message: advise} : undefined;\n  return {message, position, next: next ? [next] : undefined};\n}\n\nfunction formatMetadataError(e: Error, context: StaticSymbol): Error {\n  if (isMetadataError(e)) {\n    // Produce a formatted version of the and leaving enough information in the original error\n    // to recover the formatting information to eventually produce a diagnostic error message.\n    const position = e.position;\n    const chain: MetadataMessageChain = {\n      message: `Error during template compile of '${context.name}'`,\n      position: position,\n      next: {message: e.message, next: e.chain, context: e.context, symbol: e.symbol}\n    };\n    const advise = e.advise || messageAdvise(e.message, e.context);\n    return formattedError(formatMetadataMessageChain(chain, advise));\n  }\n  return e;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}