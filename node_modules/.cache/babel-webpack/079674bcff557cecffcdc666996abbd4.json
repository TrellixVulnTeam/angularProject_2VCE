{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/utils\", \"@angular/compiler-cli/ngcc/src/dependencies/module_resolver\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.DependencyHostBase = exports.createDependencyInfo = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/utils\");\n\n  var module_resolver_1 = require(\"@angular/compiler-cli/ngcc/src/dependencies/module_resolver\");\n\n  function createDependencyInfo() {\n    return {\n      dependencies: new Set(),\n      missing: new Set(),\n      deepImports: new Set()\n    };\n  }\n\n  exports.createDependencyInfo = createDependencyInfo;\n\n  var DependencyHostBase =\n  /** @class */\n  function () {\n    function DependencyHostBase(fs, moduleResolver) {\n      this.fs = fs;\n      this.moduleResolver = moduleResolver;\n    }\n    /**\n     * Find all the dependencies for the entry-point at the given path.\n     *\n     * @param entryPointPath The absolute path to the JavaScript file that represents an entry-point.\n     * @param dependencyInfo An object containing information about the dependencies of the\n     * entry-point, including those that were missing or deep imports into other entry-points. The\n     * sets in this object will be updated with new information about the entry-point's dependencies.\n     */\n\n\n    DependencyHostBase.prototype.collectDependencies = function (entryPointPath, _a) {\n      var dependencies = _a.dependencies,\n          missing = _a.missing,\n          deepImports = _a.deepImports;\n      var resolvedFile = utils_1.resolveFileWithPostfixes(this.fs, entryPointPath, this.moduleResolver.relativeExtensions);\n\n      if (resolvedFile !== null) {\n        var alreadySeen = new Set();\n        this.recursivelyCollectDependencies(resolvedFile, dependencies, missing, deepImports, alreadySeen);\n      }\n    };\n    /**\n     * Find all the dependencies for the provided paths.\n     *\n     * @param files The list of absolute paths of JavaScript files to scan for dependencies.\n     * @param dependencyInfo An object containing information about the dependencies of the\n     * entry-point, including those that were missing or deep imports into other entry-points. The\n     * sets in this object will be updated with new information about the entry-point's dependencies.\n     */\n\n\n    DependencyHostBase.prototype.collectDependenciesInFiles = function (files, _a) {\n      var e_1, _b;\n\n      var dependencies = _a.dependencies,\n          missing = _a.missing,\n          deepImports = _a.deepImports;\n      var alreadySeen = new Set();\n\n      try {\n        for (var files_1 = tslib_1.__values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {\n          var file = files_1_1.value;\n          this.processFile(file, dependencies, missing, deepImports, alreadySeen);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (files_1_1 && !files_1_1.done && (_b = files_1.return)) _b.call(files_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n    /**\n     * Compute the dependencies of the given file.\n     *\n     * @param file An absolute path to the file whose dependencies we want to get.\n     * @param dependencies A set that will have the absolute paths of resolved entry points added to\n     * it.\n     * @param missing A set that will have the dependencies that could not be found added to it.\n     * @param deepImports A set that will have the import paths that exist but cannot be mapped to\n     * entry-points, i.e. deep-imports.\n     * @param alreadySeen A set that is used to track internal dependencies to prevent getting stuck\n     * in a circular dependency loop.\n     */\n\n\n    DependencyHostBase.prototype.recursivelyCollectDependencies = function (file, dependencies, missing, deepImports, alreadySeen) {\n      var e_2, _a;\n\n      var fromContents = this.fs.readFile(file);\n\n      if (this.canSkipFile(fromContents)) {\n        return;\n      }\n\n      var imports = this.extractImports(file, fromContents);\n\n      try {\n        for (var imports_1 = tslib_1.__values(imports), imports_1_1 = imports_1.next(); !imports_1_1.done; imports_1_1 = imports_1.next()) {\n          var importPath = imports_1_1.value;\n          var resolved = this.processImport(importPath, file, dependencies, missing, deepImports, alreadySeen);\n\n          if (!resolved) {\n            missing.add(importPath);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (imports_1_1 && !imports_1_1.done && (_a = imports_1.return)) _a.call(imports_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    };\n    /**\n     * Resolve the given `importPath` from `file` and add it to the appropriate set.\n     *\n     * If the import is local to this package then follow it by calling\n     * `recursivelyCollectDependencies()`.\n     *\n     * @returns `true` if the import was resolved (to an entry-point, a local import, or a\n     * deep-import), `false` otherwise.\n     */\n\n\n    DependencyHostBase.prototype.processImport = function (importPath, file, dependencies, missing, deepImports, alreadySeen) {\n      var resolvedModule = this.moduleResolver.resolveModuleImport(importPath, file);\n\n      if (resolvedModule === null) {\n        return false;\n      }\n\n      if (resolvedModule instanceof module_resolver_1.ResolvedRelativeModule) {\n        this.processFile(resolvedModule.modulePath, dependencies, missing, deepImports, alreadySeen);\n      } else if (resolvedModule instanceof module_resolver_1.ResolvedDeepImport) {\n        deepImports.add(resolvedModule.importPath);\n      } else {\n        dependencies.add(resolvedModule.entryPointPath);\n      }\n\n      return true;\n    };\n    /**\n     * Processes the file if it has not already been seen. This will also recursively process\n     * all files that are imported from the file, while taking the set of already seen files\n     * into account.\n     */\n\n\n    DependencyHostBase.prototype.processFile = function (file, dependencies, missing, deepImports, alreadySeen) {\n      if (!alreadySeen.has(file)) {\n        alreadySeen.add(file);\n        this.recursivelyCollectDependencies(file, dependencies, missing, deepImports, alreadySeen);\n      }\n    };\n\n    return DependencyHostBase;\n  }();\n\n  exports.DependencyHostBase = DependencyHostBase;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/dependencies/dependency_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, PathSegment, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {EntryPoint} from '../packages/entry_point';\nimport {resolveFileWithPostfixes} from '../utils';\n\nimport {ModuleResolver, ResolvedDeepImport, ResolvedRelativeModule} from './module_resolver';\n\nexport interface DependencyHost {\n  collectDependencies(\n      entryPointPath: AbsoluteFsPath, {dependencies, missing, deepImports}: DependencyInfo): void;\n}\n\nexport interface DependencyInfo {\n  dependencies: Set<AbsoluteFsPath>;\n  missing: Set<AbsoluteFsPath|PathSegment>;\n  deepImports: Set<AbsoluteFsPath>;\n}\n\nexport interface EntryPointWithDependencies {\n  entryPoint: EntryPoint;\n  depInfo: DependencyInfo;\n}\n\nexport function createDependencyInfo(): DependencyInfo {\n  return {dependencies: new Set(), missing: new Set(), deepImports: new Set()};\n}\n\nexport abstract class DependencyHostBase implements DependencyHost {\n  constructor(protected fs: ReadonlyFileSystem, protected moduleResolver: ModuleResolver) {}\n\n  /**\n   * Find all the dependencies for the entry-point at the given path.\n   *\n   * @param entryPointPath The absolute path to the JavaScript file that represents an entry-point.\n   * @param dependencyInfo An object containing information about the dependencies of the\n   * entry-point, including those that were missing or deep imports into other entry-points. The\n   * sets in this object will be updated with new information about the entry-point's dependencies.\n   */\n  collectDependencies(\n      entryPointPath: AbsoluteFsPath, {dependencies, missing, deepImports}: DependencyInfo): void {\n    const resolvedFile =\n        resolveFileWithPostfixes(this.fs, entryPointPath, this.moduleResolver.relativeExtensions);\n    if (resolvedFile !== null) {\n      const alreadySeen = new Set<AbsoluteFsPath>();\n      this.recursivelyCollectDependencies(\n          resolvedFile, dependencies, missing, deepImports, alreadySeen);\n    }\n  }\n\n  /**\n   * Find all the dependencies for the provided paths.\n   *\n   * @param files The list of absolute paths of JavaScript files to scan for dependencies.\n   * @param dependencyInfo An object containing information about the dependencies of the\n   * entry-point, including those that were missing or deep imports into other entry-points. The\n   * sets in this object will be updated with new information about the entry-point's dependencies.\n   */\n  collectDependenciesInFiles(\n      files: AbsoluteFsPath[], {dependencies, missing, deepImports}: DependencyInfo): void {\n    const alreadySeen = new Set<AbsoluteFsPath>();\n    for (const file of files) {\n      this.processFile(file, dependencies, missing, deepImports, alreadySeen);\n    }\n  }\n\n  /**\n   * Compute the dependencies of the given file.\n   *\n   * @param file An absolute path to the file whose dependencies we want to get.\n   * @param dependencies A set that will have the absolute paths of resolved entry points added to\n   * it.\n   * @param missing A set that will have the dependencies that could not be found added to it.\n   * @param deepImports A set that will have the import paths that exist but cannot be mapped to\n   * entry-points, i.e. deep-imports.\n   * @param alreadySeen A set that is used to track internal dependencies to prevent getting stuck\n   * in a circular dependency loop.\n   */\n  protected recursivelyCollectDependencies(\n      file: AbsoluteFsPath, dependencies: Set<AbsoluteFsPath>, missing: Set<string>,\n      deepImports: Set<string>, alreadySeen: Set<AbsoluteFsPath>): void {\n    const fromContents = this.fs.readFile(file);\n    if (this.canSkipFile(fromContents)) {\n      return;\n    }\n    const imports = this.extractImports(file, fromContents);\n    for (const importPath of imports) {\n      const resolved =\n          this.processImport(importPath, file, dependencies, missing, deepImports, alreadySeen);\n      if (!resolved) {\n        missing.add(importPath);\n      }\n    }\n  }\n\n  protected abstract canSkipFile(fileContents: string): boolean;\n  protected abstract extractImports(file: AbsoluteFsPath, fileContents: string): Set<string>;\n\n  /**\n   * Resolve the given `importPath` from `file` and add it to the appropriate set.\n   *\n   * If the import is local to this package then follow it by calling\n   * `recursivelyCollectDependencies()`.\n   *\n   * @returns `true` if the import was resolved (to an entry-point, a local import, or a\n   * deep-import), `false` otherwise.\n   */\n  protected processImport(\n      importPath: string, file: AbsoluteFsPath, dependencies: Set<AbsoluteFsPath>,\n      missing: Set<string>, deepImports: Set<string>, alreadySeen: Set<AbsoluteFsPath>): boolean {\n    const resolvedModule = this.moduleResolver.resolveModuleImport(importPath, file);\n    if (resolvedModule === null) {\n      return false;\n    }\n    if (resolvedModule instanceof ResolvedRelativeModule) {\n      this.processFile(resolvedModule.modulePath, dependencies, missing, deepImports, alreadySeen);\n    } else if (resolvedModule instanceof ResolvedDeepImport) {\n      deepImports.add(resolvedModule.importPath);\n    } else {\n      dependencies.add(resolvedModule.entryPointPath);\n    }\n    return true;\n  }\n\n  /**\n   * Processes the file if it has not already been seen. This will also recursively process\n   * all files that are imported from the file, while taking the set of already seen files\n   * into account.\n   */\n  protected processFile(\n      file: AbsoluteFsPath, dependencies: Set<AbsoluteFsPath>, missing: Set<string>,\n      deepImports: Set<string>, alreadySeen: Set<AbsoluteFsPath>): void {\n    if (!alreadySeen.has(file)) {\n      alreadySeen.add(file);\n      this.recursivelyCollectDependencies(file, dependencies, missing, deepImports, alreadySeen);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}