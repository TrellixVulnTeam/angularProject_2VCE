{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/entry_point_finder/targeted_entry_point_finder\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/packages/build_marker\", \"@angular/compiler-cli/ngcc/src/packages/entry_point\", \"@angular/compiler-cli/ngcc/src/entry_point_finder/tracing_entry_point_finder\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TargetedEntryPointFinder = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var build_marker_1 = require(\"@angular/compiler-cli/ngcc/src/packages/build_marker\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point\");\n\n  var tracing_entry_point_finder_1 = require(\"@angular/compiler-cli/ngcc/src/entry_point_finder/tracing_entry_point_finder\");\n  /**\n   * An EntryPointFinder that starts from a target entry-point and only finds\n   * entry-points that are dependencies of the target.\n   *\n   * This is faster than searching the entire file-system for all the entry-points,\n   * and is used primarily by the CLI integration.\n   */\n\n\n  var TargetedEntryPointFinder =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TargetedEntryPointFinder, _super);\n\n    function TargetedEntryPointFinder(fs, config, logger, resolver, basePath, pathMappings, targetPath) {\n      var _this = _super.call(this, fs, config, logger, resolver, basePath, pathMappings) || this;\n\n      _this.targetPath = targetPath;\n      return _this;\n    }\n    /**\n     * Search for Angular entry-points that can be reached from the entry-point specified by the given\n     * `targetPath`.\n     */\n\n\n    TargetedEntryPointFinder.prototype.findEntryPoints = function () {\n      var _this = this;\n\n      var entryPoints = _super.prototype.findEntryPoints.call(this);\n\n      var invalidTarget = entryPoints.invalidEntryPoints.find(function (i) {\n        return i.entryPoint.path === _this.targetPath;\n      });\n\n      if (invalidTarget !== undefined) {\n        throw new Error(\"The target entry-point \\\"\" + invalidTarget.entryPoint.name + \"\\\" has missing dependencies:\\n\" + invalidTarget.missingDependencies.map(function (dep) {\n          return \" - \" + dep + \"\\n\";\n        }).join(''));\n      }\n\n      return entryPoints;\n    };\n    /**\n     * Determine whether the entry-point at the given `targetPath` needs to be processed.\n     *\n     * @param propertiesToConsider the package.json properties that should be considered for\n     *     processing.\n     * @param compileAllFormats true if all formats need to be processed, or false if it is enough for\n     *     one of the formats covered by the `propertiesToConsider` is processed.\n     */\n\n\n    TargetedEntryPointFinder.prototype.targetNeedsProcessingOrCleaning = function (propertiesToConsider, compileAllFormats) {\n      var e_1, _a;\n\n      var entryPointWithDeps = this.getEntryPointWithDeps(this.targetPath);\n\n      if (entryPointWithDeps === null) {\n        return false;\n      }\n\n      try {\n        for (var propertiesToConsider_1 = tslib_1.__values(propertiesToConsider), propertiesToConsider_1_1 = propertiesToConsider_1.next(); !propertiesToConsider_1_1.done; propertiesToConsider_1_1 = propertiesToConsider_1.next()) {\n          var property = propertiesToConsider_1_1.value;\n\n          if (entryPointWithDeps.entryPoint.packageJson[property]) {\n            // Here is a property that should be processed.\n            if (!build_marker_1.hasBeenProcessed(entryPointWithDeps.entryPoint.packageJson, property)) {\n              return true;\n            }\n\n            if (!compileAllFormats) {\n              // This property has been processed, and we only need one.\n              return false;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (propertiesToConsider_1_1 && !propertiesToConsider_1_1.done && (_a = propertiesToConsider_1.return)) _a.call(propertiesToConsider_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // All `propertiesToConsider` that appear in this entry-point have been processed.\n      // In other words, there were no properties that need processing.\n\n\n      return false;\n    };\n    /**\n     * Return an array containing the `targetPath` from which to start the trace.\n     */\n\n\n    TargetedEntryPointFinder.prototype.getInitialEntryPointPaths = function () {\n      return [this.targetPath];\n    };\n    /**\n     * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including\n     * paths to other entry-points that this entry-point depends upon.\n     *\n     * @param entryPointPath the path to the entry-point whose information and dependencies are to be\n     *     retrieved or computed.\n     *\n     * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by\n     *     Angular or cannot be determined.\n     */\n\n\n    TargetedEntryPointFinder.prototype.getEntryPointWithDeps = function (entryPointPath) {\n      var packagePath = this.computePackagePath(entryPointPath);\n      var entryPoint = entry_point_1.getEntryPointInfo(this.fs, this.config, this.logger, packagePath, entryPointPath);\n\n      if (!entry_point_1.isEntryPoint(entryPoint) || !entryPoint.compiledByAngular) {\n        return null;\n      }\n\n      return this.resolver.getEntryPointWithDependencies(entryPoint);\n    };\n    /**\n     * Compute the path to the package that contains the given entry-point.\n     *\n     * In this entry-point finder it is not trivial to find the containing package, since it is\n     * possible that this entry-point is not directly below the directory containing the package.\n     * Moreover, the import path could be affected by path-mapping.\n     *\n     * @param entryPointPath the path to the entry-point, whose package path we want to compute.\n     */\n\n\n    TargetedEntryPointFinder.prototype.computePackagePath = function (entryPointPath) {\n      var e_2, _a; // First try the main basePath, to avoid having to compute the other basePaths from the paths\n      // mappings, which can be computationally intensive.\n\n\n      if (this.isPathContainedBy(this.basePath, entryPointPath)) {\n        var packagePath = this.computePackagePathFromContainingPath(entryPointPath, this.basePath);\n\n        if (packagePath !== null) {\n          return packagePath;\n        }\n      }\n\n      try {\n        // The main `basePath` didn't work out so now we try the `basePaths` computed from the paths\n        // mappings in `tsconfig.json`.\n        for (var _b = tslib_1.__values(this.getBasePaths()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var basePath = _c.value;\n\n          if (this.isPathContainedBy(basePath, entryPointPath)) {\n            var packagePath = this.computePackagePathFromContainingPath(entryPointPath, basePath);\n\n            if (packagePath !== null) {\n              return packagePath;\n            } // If we got here then we couldn't find a `packagePath` for the current `basePath`.\n            // Since `basePath`s are guaranteed not to be a sub-directory of each other then no other\n            // `basePath` will match either.\n\n\n            break;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      } // Finally, if we couldn't find a `packagePath` using `basePaths` then try to find the nearest\n      // `node_modules` that contains the `entryPointPath`, if there is one, and use it as a\n      // `basePath`.\n\n\n      return this.computePackagePathFromNearestNodeModules(entryPointPath);\n    };\n    /**\n     * Compute whether the `test` path is contained within the `base` path.\n     *\n     * Note that this doesn't use a simple `startsWith()` since that would result in a false positive\n     * for `test` paths such as `a/b/c-x` when the `base` path is `a/b/c`.\n     *\n     * Since `fs.relative()` can be quite expensive we check the fast possibilities first.\n     */\n\n\n    TargetedEntryPointFinder.prototype.isPathContainedBy = function (base, test) {\n      return test === base || test.startsWith(base) && !this.fs.relative(base, test).startsWith('..');\n    };\n    /**\n     * Search down to the `entryPointPath` from the `containingPath` for the first `package.json` that\n     * we come to. This is the path to the entry-point's containing package. For example if\n     * `containingPath` is `/a/b/c` and `entryPointPath` is `/a/b/c/d/e` and there exists\n     * `/a/b/c/d/package.json` and `/a/b/c/d/e/package.json`, then we will return `/a/b/c/d`.\n     *\n     * To account for nested `node_modules` we actually start the search at the last `node_modules` in\n     * the `entryPointPath` that is below the `containingPath`. E.g. if `containingPath` is `/a/b/c`\n     * and `entryPointPath` is `/a/b/c/d/node_modules/x/y/z`, we start the search at\n     * `/a/b/c/d/node_modules`.\n     */\n\n\n    TargetedEntryPointFinder.prototype.computePackagePathFromContainingPath = function (entryPointPath, containingPath) {\n      var e_3, _a;\n\n      var packagePath = containingPath;\n      var segments = this.splitPath(this.fs.relative(containingPath, entryPointPath));\n      var nodeModulesIndex = segments.lastIndexOf('node_modules'); // If there are no `node_modules` in the relative path between the `basePath` and the\n      // `entryPointPath` then just try the `basePath` as the `packagePath`.\n      // (This can be the case with path-mapped entry-points.)\n\n      if (nodeModulesIndex === -1) {\n        if (this.fs.exists(this.fs.join(packagePath, 'package.json'))) {\n          return packagePath;\n        }\n      } // Start the search at the deepest nested `node_modules` folder that is below the `basePath`\n      // but above the `entryPointPath`, if there are any.\n\n\n      while (nodeModulesIndex >= 0) {\n        packagePath = this.fs.join(packagePath, segments.shift());\n        nodeModulesIndex--;\n      }\n\n      try {\n        // Note that we start at the folder below the current candidate `packagePath` because the\n        // initial candidate `packagePath` is either a `node_modules` folder or the `basePath` with\n        // no `package.json`.\n        for (var segments_1 = tslib_1.__values(segments), segments_1_1 = segments_1.next(); !segments_1_1.done; segments_1_1 = segments_1.next()) {\n          var segment = segments_1_1.value;\n          packagePath = this.fs.join(packagePath, segment);\n\n          if (this.fs.exists(this.fs.join(packagePath, 'package.json'))) {\n            return packagePath;\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (segments_1_1 && !segments_1_1.done && (_a = segments_1.return)) _a.call(segments_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Search up the directory tree from the `entryPointPath` looking for a `node_modules` directory\n     * that we can use as a potential starting point for computing the package path.\n     */\n\n\n    TargetedEntryPointFinder.prototype.computePackagePathFromNearestNodeModules = function (entryPointPath) {\n      var packagePath = entryPointPath;\n      var scopedPackagePath = packagePath;\n      var containerPath = this.fs.dirname(packagePath);\n\n      while (!this.fs.isRoot(containerPath) && !containerPath.endsWith('node_modules')) {\n        scopedPackagePath = packagePath;\n        packagePath = containerPath;\n        containerPath = this.fs.dirname(containerPath);\n      }\n\n      if (this.fs.exists(this.fs.join(packagePath, 'package.json'))) {\n        // The directory directly below `node_modules` is a package - use it\n        return packagePath;\n      } else if (this.fs.basename(packagePath).startsWith('@') && this.fs.exists(this.fs.join(scopedPackagePath, 'package.json'))) {\n        // The directory directly below the `node_modules` is a scope and the directory directly\n        // below that is a scoped package - use it\n        return scopedPackagePath;\n      } else {\n        // If we get here then none of the `basePaths` contained the `entryPointPath` and the\n        // `entryPointPath` contains no `node_modules` that contains a package or a scoped\n        // package. All we can do is assume that this entry-point is a primary entry-point to a\n        // package.\n        return entryPointPath;\n      }\n    };\n    /**\n     * Split the given `path` into path segments using an FS independent algorithm.\n     */\n\n\n    TargetedEntryPointFinder.prototype.splitPath = function (path) {\n      var segments = [];\n      var container = this.fs.dirname(path);\n\n      while (path !== container) {\n        segments.unshift(this.fs.basename(path));\n        path = container;\n        container = this.fs.dirname(container);\n      }\n\n      return segments;\n    };\n\n    return TargetedEntryPointFinder;\n  }(tracing_entry_point_finder_1.TracingEntryPointFinder);\n\n  exports.TargetedEntryPointFinder = TargetedEntryPointFinder;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/entry_point_finder/targeted_entry_point_finder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, PathSegment, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {EntryPointWithDependencies} from '../dependencies/dependency_host';\nimport {DependencyResolver, SortedEntryPointsInfo} from '../dependencies/dependency_resolver';\nimport {hasBeenProcessed} from '../packages/build_marker';\nimport {NgccConfiguration} from '../packages/configuration';\nimport {EntryPointJsonProperty, getEntryPointInfo, isEntryPoint} from '../packages/entry_point';\nimport {PathMappings} from '../path_mappings';\n\nimport {TracingEntryPointFinder} from './tracing_entry_point_finder';\n\n/**\n * An EntryPointFinder that starts from a target entry-point and only finds\n * entry-points that are dependencies of the target.\n *\n * This is faster than searching the entire file-system for all the entry-points,\n * and is used primarily by the CLI integration.\n */\nexport class TargetedEntryPointFinder extends TracingEntryPointFinder {\n  constructor(\n      fs: ReadonlyFileSystem, config: NgccConfiguration, logger: Logger,\n      resolver: DependencyResolver, basePath: AbsoluteFsPath, pathMappings: PathMappings|undefined,\n      private targetPath: AbsoluteFsPath) {\n    super(fs, config, logger, resolver, basePath, pathMappings);\n  }\n\n  /**\n   * Search for Angular entry-points that can be reached from the entry-point specified by the given\n   * `targetPath`.\n   */\n  findEntryPoints(): SortedEntryPointsInfo {\n    const entryPoints = super.findEntryPoints();\n\n    const invalidTarget =\n        entryPoints.invalidEntryPoints.find(i => i.entryPoint.path === this.targetPath);\n    if (invalidTarget !== undefined) {\n      throw new Error(\n          `The target entry-point \"${invalidTarget.entryPoint.name}\" has missing dependencies:\\n` +\n          invalidTarget.missingDependencies.map(dep => ` - ${dep}\\n`).join(''));\n    }\n    return entryPoints;\n  }\n\n  /**\n   * Determine whether the entry-point at the given `targetPath` needs to be processed.\n   *\n   * @param propertiesToConsider the package.json properties that should be considered for\n   *     processing.\n   * @param compileAllFormats true if all formats need to be processed, or false if it is enough for\n   *     one of the formats covered by the `propertiesToConsider` is processed.\n   */\n  targetNeedsProcessingOrCleaning(\n      propertiesToConsider: EntryPointJsonProperty[], compileAllFormats: boolean): boolean {\n    const entryPointWithDeps = this.getEntryPointWithDeps(this.targetPath);\n    if (entryPointWithDeps === null) {\n      return false;\n    }\n\n    for (const property of propertiesToConsider) {\n      if (entryPointWithDeps.entryPoint.packageJson[property]) {\n        // Here is a property that should be processed.\n        if (!hasBeenProcessed(entryPointWithDeps.entryPoint.packageJson, property)) {\n          return true;\n        }\n        if (!compileAllFormats) {\n          // This property has been processed, and we only need one.\n          return false;\n        }\n      }\n    }\n    // All `propertiesToConsider` that appear in this entry-point have been processed.\n    // In other words, there were no properties that need processing.\n    return false;\n  }\n\n  /**\n   * Return an array containing the `targetPath` from which to start the trace.\n   */\n  protected getInitialEntryPointPaths(): AbsoluteFsPath[] {\n    return [this.targetPath];\n  }\n\n  /**\n   * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including\n   * paths to other entry-points that this entry-point depends upon.\n   *\n   * @param entryPointPath the path to the entry-point whose information and dependencies are to be\n   *     retrieved or computed.\n   *\n   * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by\n   *     Angular or cannot be determined.\n   */\n  protected getEntryPointWithDeps(entryPointPath: AbsoluteFsPath): EntryPointWithDependencies|null {\n    const packagePath = this.computePackagePath(entryPointPath);\n    const entryPoint =\n        getEntryPointInfo(this.fs, this.config, this.logger, packagePath, entryPointPath);\n    if (!isEntryPoint(entryPoint) || !entryPoint.compiledByAngular) {\n      return null;\n    }\n    return this.resolver.getEntryPointWithDependencies(entryPoint);\n  }\n\n  /**\n   * Compute the path to the package that contains the given entry-point.\n   *\n   * In this entry-point finder it is not trivial to find the containing package, since it is\n   * possible that this entry-point is not directly below the directory containing the package.\n   * Moreover, the import path could be affected by path-mapping.\n   *\n   * @param entryPointPath the path to the entry-point, whose package path we want to compute.\n   */\n  private computePackagePath(entryPointPath: AbsoluteFsPath): AbsoluteFsPath {\n    // First try the main basePath, to avoid having to compute the other basePaths from the paths\n    // mappings, which can be computationally intensive.\n    if (this.isPathContainedBy(this.basePath, entryPointPath)) {\n      const packagePath = this.computePackagePathFromContainingPath(entryPointPath, this.basePath);\n      if (packagePath !== null) {\n        return packagePath;\n      }\n    }\n\n    // The main `basePath` didn't work out so now we try the `basePaths` computed from the paths\n    // mappings in `tsconfig.json`.\n    for (const basePath of this.getBasePaths()) {\n      if (this.isPathContainedBy(basePath, entryPointPath)) {\n        const packagePath = this.computePackagePathFromContainingPath(entryPointPath, basePath);\n        if (packagePath !== null) {\n          return packagePath;\n        }\n        // If we got here then we couldn't find a `packagePath` for the current `basePath`.\n        // Since `basePath`s are guaranteed not to be a sub-directory of each other then no other\n        // `basePath` will match either.\n        break;\n      }\n    }\n\n    // Finally, if we couldn't find a `packagePath` using `basePaths` then try to find the nearest\n    // `node_modules` that contains the `entryPointPath`, if there is one, and use it as a\n    // `basePath`.\n    return this.computePackagePathFromNearestNodeModules(entryPointPath);\n  }\n\n  /**\n   * Compute whether the `test` path is contained within the `base` path.\n   *\n   * Note that this doesn't use a simple `startsWith()` since that would result in a false positive\n   * for `test` paths such as `a/b/c-x` when the `base` path is `a/b/c`.\n   *\n   * Since `fs.relative()` can be quite expensive we check the fast possibilities first.\n   */\n  private isPathContainedBy(base: AbsoluteFsPath, test: AbsoluteFsPath): boolean {\n    return test === base ||\n        (test.startsWith(base) && !this.fs.relative(base, test).startsWith('..'));\n  }\n\n  /**\n   * Search down to the `entryPointPath` from the `containingPath` for the first `package.json` that\n   * we come to. This is the path to the entry-point's containing package. For example if\n   * `containingPath` is `/a/b/c` and `entryPointPath` is `/a/b/c/d/e` and there exists\n   * `/a/b/c/d/package.json` and `/a/b/c/d/e/package.json`, then we will return `/a/b/c/d`.\n   *\n   * To account for nested `node_modules` we actually start the search at the last `node_modules` in\n   * the `entryPointPath` that is below the `containingPath`. E.g. if `containingPath` is `/a/b/c`\n   * and `entryPointPath` is `/a/b/c/d/node_modules/x/y/z`, we start the search at\n   * `/a/b/c/d/node_modules`.\n   */\n  private computePackagePathFromContainingPath(\n      entryPointPath: AbsoluteFsPath, containingPath: AbsoluteFsPath): AbsoluteFsPath|null {\n    let packagePath = containingPath;\n    const segments = this.splitPath(this.fs.relative(containingPath, entryPointPath));\n    let nodeModulesIndex = segments.lastIndexOf('node_modules' as PathSegment);\n\n    // If there are no `node_modules` in the relative path between the `basePath` and the\n    // `entryPointPath` then just try the `basePath` as the `packagePath`.\n    // (This can be the case with path-mapped entry-points.)\n    if (nodeModulesIndex === -1) {\n      if (this.fs.exists(this.fs.join(packagePath, 'package.json'))) {\n        return packagePath;\n      }\n    }\n\n    // Start the search at the deepest nested `node_modules` folder that is below the `basePath`\n    // but above the `entryPointPath`, if there are any.\n    while (nodeModulesIndex >= 0) {\n      packagePath = this.fs.join(packagePath, segments.shift()!);\n      nodeModulesIndex--;\n    }\n\n    // Note that we start at the folder below the current candidate `packagePath` because the\n    // initial candidate `packagePath` is either a `node_modules` folder or the `basePath` with\n    // no `package.json`.\n    for (const segment of segments) {\n      packagePath = this.fs.join(packagePath, segment);\n      if (this.fs.exists(this.fs.join(packagePath, 'package.json'))) {\n        return packagePath;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Search up the directory tree from the `entryPointPath` looking for a `node_modules` directory\n   * that we can use as a potential starting point for computing the package path.\n   */\n  private computePackagePathFromNearestNodeModules(entryPointPath: AbsoluteFsPath): AbsoluteFsPath {\n    let packagePath = entryPointPath;\n    let scopedPackagePath = packagePath;\n    let containerPath = this.fs.dirname(packagePath);\n    while (!this.fs.isRoot(containerPath) && !containerPath.endsWith('node_modules')) {\n      scopedPackagePath = packagePath;\n      packagePath = containerPath;\n      containerPath = this.fs.dirname(containerPath);\n    }\n\n    if (this.fs.exists(this.fs.join(packagePath, 'package.json'))) {\n      // The directory directly below `node_modules` is a package - use it\n      return packagePath;\n    } else if (\n        this.fs.basename(packagePath).startsWith('@') &&\n        this.fs.exists(this.fs.join(scopedPackagePath, 'package.json'))) {\n      // The directory directly below the `node_modules` is a scope and the directory directly\n      // below that is a scoped package - use it\n      return scopedPackagePath;\n    } else {\n      // If we get here then none of the `basePaths` contained the `entryPointPath` and the\n      // `entryPointPath` contains no `node_modules` that contains a package or a scoped\n      // package. All we can do is assume that this entry-point is a primary entry-point to a\n      // package.\n      return entryPointPath;\n    }\n  }\n\n  /**\n   * Split the given `path` into path segments using an FS independent algorithm.\n   */\n  private splitPath(path: PathSegment|AbsoluteFsPath) {\n    const segments = [];\n    let container = this.fs.dirname(path);\n    while (path !== container) {\n      segments.unshift(this.fs.basename(path));\n      path = container;\n      container = this.fs.dirname(container);\n    }\n    return segments;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}