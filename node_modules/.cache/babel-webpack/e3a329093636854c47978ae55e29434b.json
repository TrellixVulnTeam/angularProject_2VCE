{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _ = {\n  sum: require('lodash/sum'),\n  flatten: require('lodash/flatten')\n};\n\nvar chalk = require('chalk');\n/**\n * The paginator returns a subset of the choices if the list is too long.\n */\n\n\nvar Paginator = /*#__PURE__*/function () {\n  function Paginator(screen) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Paginator);\n\n    var _options$isInfinite = options.isInfinite,\n        isInfinite = _options$isInfinite === void 0 ? true : _options$isInfinite;\n    this.lastIndex = 0;\n    this.screen = screen;\n    this.isInfinite = isInfinite;\n  }\n\n  _createClass(Paginator, [{\n    key: \"paginate\",\n    value: function paginate(output, active, pageSize) {\n      pageSize = pageSize || 7;\n      var lines = output.split('\\n');\n\n      if (this.screen) {\n        lines = this.screen.breakLines(lines);\n        active = _.sum(lines.map(function (lineParts) {\n          return lineParts.length;\n        }).splice(0, active));\n        lines = _.flatten(lines);\n      } // Make sure there's enough lines to paginate\n\n\n      if (lines.length <= pageSize) {\n        return output;\n      }\n\n      var visibleLines = this.isInfinite ? this.getInfiniteLines(lines, active, pageSize) : this.getFiniteLines(lines, active, pageSize);\n      this.lastIndex = active;\n      return visibleLines.join('\\n') + '\\n' + chalk.dim('(Move up and down to reveal more choices)');\n    }\n  }, {\n    key: \"getInfiniteLines\",\n    value: function getInfiniteLines(lines, active, pageSize) {\n      if (this.pointer === undefined) {\n        this.pointer = 0;\n      }\n\n      var middleOfList = Math.floor(pageSize / 2); // Move the pointer only when the user go down and limit it to the middle of the list\n\n      if (this.pointer < middleOfList && this.lastIndex < active && active - this.lastIndex < pageSize) {\n        this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n      } // Duplicate the lines so it give an infinite list look\n\n\n      var infinite = _.flatten([lines, lines, lines]);\n\n      var topIndex = Math.max(0, active + lines.length - this.pointer);\n      return infinite.splice(topIndex, pageSize);\n    }\n  }, {\n    key: \"getFiniteLines\",\n    value: function getFiniteLines(lines, active, pageSize) {\n      var topIndex = active - pageSize / 2;\n\n      if (topIndex < 0) {\n        topIndex = 0;\n      } else if (topIndex + pageSize > lines.length) {\n        topIndex = lines.length - pageSize;\n      }\n\n      return lines.splice(topIndex, pageSize);\n    }\n  }]);\n\n  return Paginator;\n}();\n\nmodule.exports = Paginator;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/inquirer/lib/utils/paginator.js"],"names":["_","sum","require","flatten","chalk","Paginator","screen","options","isInfinite","lastIndex","output","active","pageSize","lines","split","breakLines","map","lineParts","length","splice","visibleLines","getInfiniteLines","getFiniteLines","join","dim","pointer","undefined","middleOfList","Math","floor","min","infinite","topIndex","max","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar _ = {\n  sum: require('lodash/sum'),\n  flatten: require('lodash/flatten'),\n};\nvar chalk = require('chalk');\n\n/**\n * The paginator returns a subset of the choices if the list is too long.\n */\n\nclass Paginator {\n  constructor(screen, options = {}) {\n    const { isInfinite = true } = options;\n    this.lastIndex = 0;\n    this.screen = screen;\n    this.isInfinite = isInfinite;\n  }\n\n  paginate(output, active, pageSize) {\n    pageSize = pageSize || 7;\n    var lines = output.split('\\n');\n\n    if (this.screen) {\n      lines = this.screen.breakLines(lines);\n      active = _.sum(lines.map((lineParts) => lineParts.length).splice(0, active));\n      lines = _.flatten(lines);\n    }\n\n    // Make sure there's enough lines to paginate\n    if (lines.length <= pageSize) {\n      return output;\n    }\n    const visibleLines = this.isInfinite\n      ? this.getInfiniteLines(lines, active, pageSize)\n      : this.getFiniteLines(lines, active, pageSize);\n    this.lastIndex = active;\n    return (\n      visibleLines.join('\\n') +\n      '\\n' +\n      chalk.dim('(Move up and down to reveal more choices)')\n    );\n  }\n\n  getInfiniteLines(lines, active, pageSize) {\n    if (this.pointer === undefined) {\n      this.pointer = 0;\n    }\n    var middleOfList = Math.floor(pageSize / 2);\n    // Move the pointer only when the user go down and limit it to the middle of the list\n    if (\n      this.pointer < middleOfList &&\n      this.lastIndex < active &&\n      active - this.lastIndex < pageSize\n    ) {\n      this.pointer = Math.min(middleOfList, this.pointer + active - this.lastIndex);\n    }\n\n    // Duplicate the lines so it give an infinite list look\n    var infinite = _.flatten([lines, lines, lines]);\n    var topIndex = Math.max(0, active + lines.length - this.pointer);\n\n    return infinite.splice(topIndex, pageSize);\n  }\n\n  getFiniteLines(lines, active, pageSize) {\n    var topIndex = active - pageSize / 2;\n    if (topIndex < 0) {\n      topIndex = 0;\n    } else if (topIndex + pageSize > lines.length) {\n      topIndex = lines.length - pageSize;\n    }\n    return lines.splice(topIndex, pageSize);\n  }\n}\n\nmodule.exports = Paginator;\n"]},"metadata":{},"sourceType":"script"}