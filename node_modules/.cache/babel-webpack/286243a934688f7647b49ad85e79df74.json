{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require(\"webpack-sources\"),\n    ConcatSource = _require.ConcatSource;\n/** @typedef {import(\"../ChunkTemplate\")} ChunkTemplate */\n\n\nvar getEntryInfo = function getEntryInfo(chunk) {\n  return [chunk.entryModule].filter(Boolean).map(function (m) {\n    return [m.id].concat(Array.from(chunk.groupsIterable)[0].chunks.filter(function (c) {\n      return c !== chunk;\n    }).map(function (c) {\n      return c.id;\n    }));\n  });\n};\n\nvar JsonpChunkTemplatePlugin = /*#__PURE__*/function () {\n  function JsonpChunkTemplatePlugin() {\n    _classCallCheck(this, JsonpChunkTemplatePlugin);\n  }\n\n  _createClass(JsonpChunkTemplatePlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * @param {ChunkTemplate} chunkTemplate the chunk template\n     * @returns {void}\n     */\n    function apply(chunkTemplate) {\n      chunkTemplate.hooks.render.tap(\"JsonpChunkTemplatePlugin\", function (modules, chunk) {\n        var jsonpFunction = chunkTemplate.outputOptions.jsonpFunction;\n        var globalObject = chunkTemplate.outputOptions.globalObject;\n        var source = new ConcatSource();\n        var prefetchChunks = chunk.getChildIdsByOrders().prefetch;\n        source.add(\"(\".concat(globalObject, \"[\").concat(JSON.stringify(jsonpFunction), \"] = \").concat(globalObject, \"[\").concat(JSON.stringify(jsonpFunction), \"] || []).push([\").concat(JSON.stringify(chunk.ids), \",\"));\n        source.add(modules);\n        var entries = getEntryInfo(chunk);\n\n        if (entries.length > 0) {\n          source.add(\",\".concat(JSON.stringify(entries)));\n        } else if (prefetchChunks && prefetchChunks.length) {\n          source.add(\",0\");\n        }\n\n        if (prefetchChunks && prefetchChunks.length) {\n          source.add(\",\".concat(JSON.stringify(prefetchChunks)));\n        }\n\n        source.add(\"])\");\n        return source;\n      });\n      chunkTemplate.hooks.hash.tap(\"JsonpChunkTemplatePlugin\", function (hash) {\n        hash.update(\"JsonpChunkTemplatePlugin\");\n        hash.update(\"4\");\n        hash.update(\"\".concat(chunkTemplate.outputOptions.jsonpFunction));\n        hash.update(\"\".concat(chunkTemplate.outputOptions.globalObject));\n      });\n      chunkTemplate.hooks.hashForChunk.tap(\"JsonpChunkTemplatePlugin\", function (hash, chunk) {\n        hash.update(JSON.stringify(getEntryInfo(chunk)));\n        hash.update(JSON.stringify(chunk.getChildIdsByOrders().prefetch) || \"\");\n      });\n    }\n  }]);\n\n  return JsonpChunkTemplatePlugin;\n}();\n\nmodule.exports = JsonpChunkTemplatePlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/web/JsonpChunkTemplatePlugin.js"],"names":["require","ConcatSource","getEntryInfo","chunk","entryModule","filter","Boolean","map","m","id","concat","Array","from","groupsIterable","chunks","c","JsonpChunkTemplatePlugin","chunkTemplate","hooks","render","tap","modules","jsonpFunction","outputOptions","globalObject","source","prefetchChunks","getChildIdsByOrders","prefetch","add","JSON","stringify","ids","entries","length","hash","update","hashForChunk","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst { ConcatSource } = require(\"webpack-sources\");\n\n/** @typedef {import(\"../ChunkTemplate\")} ChunkTemplate */\n\nconst getEntryInfo = chunk => {\n\treturn [chunk.entryModule].filter(Boolean).map(m =>\n\t\t[m.id].concat(\n\t\t\tArray.from(chunk.groupsIterable)[0]\n\t\t\t\t.chunks.filter(c => c !== chunk)\n\t\t\t\t.map(c => c.id)\n\t\t)\n\t);\n};\n\nclass JsonpChunkTemplatePlugin {\n\t/**\n\t * @param {ChunkTemplate} chunkTemplate the chunk template\n\t * @returns {void}\n\t */\n\tapply(chunkTemplate) {\n\t\tchunkTemplate.hooks.render.tap(\n\t\t\t\"JsonpChunkTemplatePlugin\",\n\t\t\t(modules, chunk) => {\n\t\t\t\tconst jsonpFunction = chunkTemplate.outputOptions.jsonpFunction;\n\t\t\t\tconst globalObject = chunkTemplate.outputOptions.globalObject;\n\t\t\t\tconst source = new ConcatSource();\n\t\t\t\tconst prefetchChunks = chunk.getChildIdsByOrders().prefetch;\n\t\t\t\tsource.add(\n\t\t\t\t\t`(${globalObject}[${JSON.stringify(\n\t\t\t\t\t\tjsonpFunction\n\t\t\t\t\t)}] = ${globalObject}[${JSON.stringify(\n\t\t\t\t\t\tjsonpFunction\n\t\t\t\t\t)}] || []).push([${JSON.stringify(chunk.ids)},`\n\t\t\t\t);\n\t\t\t\tsource.add(modules);\n\t\t\t\tconst entries = getEntryInfo(chunk);\n\t\t\t\tif (entries.length > 0) {\n\t\t\t\t\tsource.add(`,${JSON.stringify(entries)}`);\n\t\t\t\t} else if (prefetchChunks && prefetchChunks.length) {\n\t\t\t\t\tsource.add(`,0`);\n\t\t\t\t}\n\n\t\t\t\tif (prefetchChunks && prefetchChunks.length) {\n\t\t\t\t\tsource.add(`,${JSON.stringify(prefetchChunks)}`);\n\t\t\t\t}\n\t\t\t\tsource.add(\"])\");\n\t\t\t\treturn source;\n\t\t\t}\n\t\t);\n\t\tchunkTemplate.hooks.hash.tap(\"JsonpChunkTemplatePlugin\", hash => {\n\t\t\thash.update(\"JsonpChunkTemplatePlugin\");\n\t\t\thash.update(\"4\");\n\t\t\thash.update(`${chunkTemplate.outputOptions.jsonpFunction}`);\n\t\t\thash.update(`${chunkTemplate.outputOptions.globalObject}`);\n\t\t});\n\t\tchunkTemplate.hooks.hashForChunk.tap(\n\t\t\t\"JsonpChunkTemplatePlugin\",\n\t\t\t(hash, chunk) => {\n\t\t\t\thash.update(JSON.stringify(getEntryInfo(chunk)));\n\t\t\t\thash.update(JSON.stringify(chunk.getChildIdsByOrders().prefetch) || \"\");\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = JsonpChunkTemplatePlugin;\n"]},"metadata":{},"sourceType":"script"}