{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/view_compiler/view_compiler\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/compiler_util/expression_converter\", \"@angular/compiler/src/core\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/lifecycle_reflector\", \"@angular/compiler/src/ml_parser/tags\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/output/value_util\", \"@angular/compiler/src/template_parser/template_ast\", \"@angular/compiler/src/view_compiler/provider_compiler\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.elementEventFullName = exports.ViewCompiler = exports.ViewCompileResult = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var expression_converter_1 = require(\"@angular/compiler/src/compiler_util/expression_converter\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var lifecycle_reflector_1 = require(\"@angular/compiler/src/lifecycle_reflector\");\n\n  var tags_1 = require(\"@angular/compiler/src/ml_parser/tags\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var value_util_1 = require(\"@angular/compiler/src/output/value_util\");\n\n  var template_ast_1 = require(\"@angular/compiler/src/template_parser/template_ast\");\n\n  var provider_compiler_1 = require(\"@angular/compiler/src/view_compiler/provider_compiler\");\n\n  var CLASS_ATTR = 'class';\n  var STYLE_ATTR = 'style';\n  var IMPLICIT_TEMPLATE_VAR = '\\$implicit';\n\n  var ViewCompileResult =\n  /** @class */\n  function () {\n    function ViewCompileResult(viewClassVar, rendererTypeVar) {\n      this.viewClassVar = viewClassVar;\n      this.rendererTypeVar = rendererTypeVar;\n    }\n\n    return ViewCompileResult;\n  }();\n\n  exports.ViewCompileResult = ViewCompileResult;\n\n  var ViewCompiler =\n  /** @class */\n  function () {\n    function ViewCompiler(_reflector) {\n      this._reflector = _reflector;\n    }\n\n    ViewCompiler.prototype.compileComponent = function (outputCtx, component, template, styles, usedPipes) {\n      var _a;\n\n      var _this = this;\n\n      var embeddedViewCount = 0;\n      var renderComponentVarName = undefined;\n\n      if (!component.isHost) {\n        var template_1 = component.template;\n        var customRenderData = [];\n\n        if (template_1.animations && template_1.animations.length) {\n          customRenderData.push(new o.LiteralMapEntry('animation', value_util_1.convertValueToOutputAst(outputCtx, template_1.animations), true));\n        }\n\n        var renderComponentVar = o.variable(compile_metadata_1.rendererTypeName(component.type.reference));\n        renderComponentVarName = renderComponentVar.name;\n        outputCtx.statements.push(renderComponentVar.set(o.importExpr(identifiers_1.Identifiers.createRendererType2).callFn([new o.LiteralMapExpr([new o.LiteralMapEntry('encapsulation', o.literal(template_1.encapsulation), false), new o.LiteralMapEntry('styles', styles, false), new o.LiteralMapEntry('data', new o.LiteralMapExpr(customRenderData), false)])])).toDeclStmt(o.importType(identifiers_1.Identifiers.RendererType2), [o.StmtModifier.Final, o.StmtModifier.Exported]));\n      }\n\n      var viewBuilderFactory = function viewBuilderFactory(parent) {\n        var embeddedViewIndex = embeddedViewCount++;\n        return new ViewBuilder(_this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory);\n      };\n\n      var visitor = viewBuilderFactory(null);\n      visitor.visitAll([], template);\n\n      (_a = outputCtx.statements).push.apply(_a, tslib_1.__spread(visitor.build()));\n\n      return new ViewCompileResult(visitor.viewName, renderComponentVarName);\n    };\n\n    return ViewCompiler;\n  }();\n\n  exports.ViewCompiler = ViewCompiler;\n  var LOG_VAR = o.variable('_l');\n  var VIEW_VAR = o.variable('_v');\n  var CHECK_VAR = o.variable('_ck');\n  var COMP_VAR = o.variable('_co');\n  var EVENT_NAME_VAR = o.variable('en');\n  var ALLOW_DEFAULT_VAR = o.variable(\"ad\");\n\n  var ViewBuilder =\n  /** @class */\n  function () {\n    function ViewBuilder(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory) {\n      this.reflector = reflector;\n      this.outputCtx = outputCtx;\n      this.parent = parent;\n      this.component = component;\n      this.embeddedViewIndex = embeddedViewIndex;\n      this.usedPipes = usedPipes;\n      this.viewBuilderFactory = viewBuilderFactory;\n      this.nodes = [];\n      this.purePipeNodeIndices = Object.create(null); // Need Object.create so that we don't have builtin values...\n\n      this.refNodeIndices = Object.create(null);\n      this.variables = [];\n      this.children = []; // TODO(tbosch): The old view compiler used to use an `any` type\n      // for the context in any embedded view. We keep this behaivor for now\n      // to be able to introduce the new view compiler without too many errors.\n\n      this.compType = this.embeddedViewIndex > 0 ? o.DYNAMIC_TYPE : o.expressionType(outputCtx.importExpr(this.component.type.reference));\n      this.viewName = compile_metadata_1.viewClassName(this.component.type.reference, this.embeddedViewIndex);\n    }\n\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n      var _this = this;\n\n      this.variables = variables; // create the pipes for the pure pipes immediately, so that we know their indices.\n\n      if (!this.parent) {\n        this.usedPipes.forEach(function (pipe) {\n          if (pipe.pure) {\n            _this.purePipeNodeIndices[pipe.name] = _this._createPipe(null, pipe);\n          }\n        });\n      }\n\n      if (!this.parent) {\n        this.component.viewQueries.forEach(function (query, queryIndex) {\n          // Note: queries start with id 1 so we can use the number in a Bloom filter!\n          var queryId = queryIndex + 1;\n          var bindingType = query.first ? 0\n          /* First */\n          : 1\n          /* All */\n          ;\n          var flags = 134217728\n          /* TypeViewQuery */\n          | calcQueryFlags(query);\n\n          _this.nodes.push(function () {\n            return {\n              sourceSpan: null,\n              nodeFlags: flags,\n              nodeDef: o.importExpr(identifiers_1.Identifiers.queryDef).callFn([o.literal(flags), o.literal(queryId), new o.LiteralMapExpr([new o.LiteralMapEntry(query.propertyName, o.literal(bindingType), false)])])\n            };\n          });\n        });\n      }\n\n      template_ast_1.templateVisitAll(this, astNodes);\n\n      if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n        // if the view is an embedded view, then we need to add an additional root node in some cases\n        this.nodes.push(function () {\n          return {\n            sourceSpan: null,\n            nodeFlags: 1\n            /* TypeElement */\n            ,\n            nodeDef: o.importExpr(identifiers_1.Identifiers.anchorDef).callFn([o.literal(0\n            /* None */\n            ), o.NULL_EXPR, o.NULL_EXPR, o.literal(0)])\n          };\n        });\n      }\n    };\n\n    ViewBuilder.prototype.build = function (targetStatements) {\n      if (targetStatements === void 0) {\n        targetStatements = [];\n      }\n\n      this.children.forEach(function (child) {\n        return child.build(targetStatements);\n      });\n\n      var _a = this._createNodeExpressions(),\n          updateRendererStmts = _a.updateRendererStmts,\n          updateDirectivesStmts = _a.updateDirectivesStmts,\n          nodeDefExprs = _a.nodeDefExprs;\n\n      var updateRendererFn = this._createUpdateFn(updateRendererStmts);\n\n      var updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n\n      var viewFlags = 0\n      /* None */\n      ;\n\n      if (!this.parent && this.component.changeDetection === core_1.ChangeDetectionStrategy.OnPush) {\n        viewFlags |= 2\n        /* OnPush */\n        ;\n      }\n\n      var viewFactory = new o.DeclareFunctionStmt(this.viewName, [new o.FnParam(LOG_VAR.name)], [new o.ReturnStatement(o.importExpr(identifiers_1.Identifiers.viewDef).callFn([o.literal(viewFlags), o.literalArr(nodeDefExprs), updateDirectivesFn, updateRendererFn]))], o.importType(identifiers_1.Identifiers.ViewDefinition), this.embeddedViewIndex === 0 ? [o.StmtModifier.Exported] : []);\n      targetStatements.push(viewFactory);\n      return targetStatements;\n    };\n\n    ViewBuilder.prototype._createUpdateFn = function (updateStmts) {\n      var updateFn;\n\n      if (updateStmts.length > 0) {\n        var preStmts = [];\n\n        if (!this.component.isHost && o.findReadVarNames(updateStmts).has(COMP_VAR.name)) {\n          preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n        }\n\n        updateFn = o.fn([new o.FnParam(CHECK_VAR.name, o.INFERRED_TYPE), new o.FnParam(VIEW_VAR.name, o.INFERRED_TYPE)], tslib_1.__spread(preStmts, updateStmts), o.INFERRED_TYPE);\n      } else {\n        updateFn = o.NULL_EXPR;\n      }\n\n      return updateFn;\n    };\n\n    ViewBuilder.prototype.visitNgContent = function (ast, context) {\n      // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 8\n          /* TypeNgContent */\n          ,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.ngContentDef).callFn([o.literal(ast.ngContentIndex), o.literal(ast.index)])\n        };\n      });\n    };\n\n    ViewBuilder.prototype.visitText = function (ast, context) {\n      // Static text nodes have no check function\n      var checkIndex = -1;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 2\n          /* TypeText */\n          ,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.textDef).callFn([o.literal(checkIndex), o.literal(ast.ngContentIndex), o.literalArr([o.literal(ast.value)])])\n        };\n      });\n    };\n\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n      var _this = this;\n\n      var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array\n\n      this.nodes.push(null);\n      var astWithSource = ast.value;\n      var inter = astWithSource.ast;\n      var updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) {\n        return _this._preprocessUpdateExpression({\n          nodeIndex: nodeIndex,\n          bindingIndex: bindingIndex,\n          sourceSpan: ast.sourceSpan,\n          context: COMP_VAR,\n          value: expr\n        });\n      }); // Check index is the same as the node index during compilation\n      // They might only differ at runtime\n\n      var checkIndex = nodeIndex;\n\n      this.nodes[nodeIndex] = function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 2\n          /* TypeText */\n          ,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.textDef).callFn([o.literal(checkIndex), o.literal(ast.ngContentIndex), o.literalArr(inter.strings.map(function (s) {\n            return o.literal(s);\n          }))]),\n          updateRenderer: updateRendererExpressions\n        };\n      };\n    };\n\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n      var _this = this;\n\n      var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array\n\n      this.nodes.push(null);\n\n      var _a = this._visitElementOrTemplate(nodeIndex, ast),\n          flags = _a.flags,\n          queryMatchesExpr = _a.queryMatchesExpr,\n          hostEvents = _a.hostEvents;\n\n      var childVisitor = this.viewBuilderFactory(this);\n      this.children.push(childVisitor);\n      childVisitor.visitAll(ast.variables, ast.children);\n      var childCount = this.nodes.length - nodeIndex - 1; // anchorDef(\n      //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n      //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n      //   ViewDefinitionFactory): NodeDef;\n\n      this.nodes[nodeIndex] = function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 1\n          /* TypeElement */\n          | flags,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.anchorDef).callFn([o.literal(flags), queryMatchesExpr, o.literal(ast.ngContentIndex), o.literal(childCount), _this._createElementHandleEventFn(nodeIndex, hostEvents), o.variable(childVisitor.viewName)])\n        };\n      };\n    };\n\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n      var _this = this;\n\n      var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array so we can add children\n\n      this.nodes.push(null); // Using a null element name creates an anchor.\n\n      var elName = tags_1.isNgContainer(ast.name) ? null : ast.name;\n\n      var _a = this._visitElementOrTemplate(nodeIndex, ast),\n          flags = _a.flags,\n          usedEvents = _a.usedEvents,\n          queryMatchesExpr = _a.queryMatchesExpr,\n          dirHostBindings = _a.hostBindings,\n          hostEvents = _a.hostEvents;\n\n      var inputDefs = [];\n      var updateRendererExpressions = [];\n      var outputDefs = [];\n\n      if (elName) {\n        var hostBindings = ast.inputs.map(function (inputAst) {\n          return {\n            context: COMP_VAR,\n            inputAst: inputAst,\n            dirAst: null\n          };\n        }).concat(dirHostBindings);\n\n        if (hostBindings.length) {\n          updateRendererExpressions = hostBindings.map(function (hostBinding, bindingIndex) {\n            return _this._preprocessUpdateExpression({\n              context: hostBinding.context,\n              nodeIndex: nodeIndex,\n              bindingIndex: bindingIndex,\n              sourceSpan: hostBinding.inputAst.sourceSpan,\n              value: hostBinding.inputAst.value\n            });\n          });\n          inputDefs = hostBindings.map(function (hostBinding) {\n            return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst);\n          });\n        }\n\n        outputDefs = usedEvents.map(function (_a) {\n          var _b = tslib_1.__read(_a, 2),\n              target = _b[0],\n              eventName = _b[1];\n\n          return o.literalArr([o.literal(target), o.literal(eventName)]);\n        });\n      }\n\n      template_ast_1.templateVisitAll(this, ast.children);\n      var childCount = this.nodes.length - nodeIndex - 1;\n      var compAst = ast.directives.find(function (dirAst) {\n        return dirAst.directive.isComponent;\n      });\n      var compRendererType = o.NULL_EXPR;\n      var compView = o.NULL_EXPR;\n\n      if (compAst) {\n        compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\n        compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\n      } // Check index is the same as the node index during compilation\n      // They might only differ at runtime\n\n\n      var checkIndex = nodeIndex;\n\n      this.nodes[nodeIndex] = function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 1\n          /* TypeElement */\n          | flags,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.elementDef).callFn([o.literal(checkIndex), o.literal(flags), queryMatchesExpr, o.literal(ast.ngContentIndex), o.literal(childCount), o.literal(elName), elName ? fixedAttrsDef(ast) : o.NULL_EXPR, inputDefs.length ? o.literalArr(inputDefs) : o.NULL_EXPR, outputDefs.length ? o.literalArr(outputDefs) : o.NULL_EXPR, _this._createElementHandleEventFn(nodeIndex, hostEvents), compView, compRendererType]),\n          updateRenderer: updateRendererExpressions\n        };\n      };\n    };\n\n    ViewBuilder.prototype._visitElementOrTemplate = function (nodeIndex, ast) {\n      var _this = this;\n\n      var flags = 0\n      /* None */\n      ;\n\n      if (ast.hasViewContainer) {\n        flags |= 16777216\n        /* EmbeddedViews */\n        ;\n      }\n\n      var usedEvents = new Map();\n      ast.outputs.forEach(function (event) {\n        var _a = elementEventNameAndTarget(event, null),\n            name = _a.name,\n            target = _a.target;\n\n        usedEvents.set(elementEventFullName(target, name), [target, name]);\n      });\n      ast.directives.forEach(function (dirAst) {\n        dirAst.hostEvents.forEach(function (event) {\n          var _a = elementEventNameAndTarget(event, dirAst),\n              name = _a.name,\n              target = _a.target;\n\n          usedEvents.set(elementEventFullName(target, name), [target, name]);\n        });\n      });\n      var hostBindings = [];\n      var hostEvents = [];\n\n      this._visitComponentFactoryResolverProvider(ast.directives);\n\n      ast.providers.forEach(function (providerAst) {\n        var dirAst = undefined;\n        ast.directives.forEach(function (localDirAst) {\n          if (localDirAst.directive.type.reference === compile_metadata_1.tokenReference(providerAst.token)) {\n            dirAst = localDirAst;\n          }\n        });\n\n        if (dirAst) {\n          var _a = _this._visitDirective(providerAst, dirAst, ast.references, ast.queryMatches, usedEvents),\n              dirHostBindings = _a.hostBindings,\n              dirHostEvents = _a.hostEvents;\n\n          hostBindings.push.apply(hostBindings, tslib_1.__spread(dirHostBindings));\n          hostEvents.push.apply(hostEvents, tslib_1.__spread(dirHostEvents));\n        } else {\n          _this._visitProvider(providerAst, ast.queryMatches);\n        }\n      });\n      var queryMatchExprs = [];\n      ast.queryMatches.forEach(function (match) {\n        var valueType = undefined;\n\n        if (compile_metadata_1.tokenReference(match.value) === _this.reflector.resolveExternalReference(identifiers_1.Identifiers.ElementRef)) {\n          valueType = 0\n          /* ElementRef */\n          ;\n        } else if (compile_metadata_1.tokenReference(match.value) === _this.reflector.resolveExternalReference(identifiers_1.Identifiers.ViewContainerRef)) {\n          valueType = 3\n          /* ViewContainerRef */\n          ;\n        } else if (compile_metadata_1.tokenReference(match.value) === _this.reflector.resolveExternalReference(identifiers_1.Identifiers.TemplateRef)) {\n          valueType = 2\n          /* TemplateRef */\n          ;\n        }\n\n        if (valueType != null) {\n          queryMatchExprs.push(o.literalArr([o.literal(match.queryId), o.literal(valueType)]));\n        }\n      });\n      ast.references.forEach(function (ref) {\n        var valueType = undefined;\n\n        if (!ref.value) {\n          valueType = 1\n          /* RenderElement */\n          ;\n        } else if (compile_metadata_1.tokenReference(ref.value) === _this.reflector.resolveExternalReference(identifiers_1.Identifiers.TemplateRef)) {\n          valueType = 2\n          /* TemplateRef */\n          ;\n        }\n\n        if (valueType != null) {\n          _this.refNodeIndices[ref.name] = nodeIndex;\n          queryMatchExprs.push(o.literalArr([o.literal(ref.name), o.literal(valueType)]));\n        }\n      });\n      ast.outputs.forEach(function (outputAst) {\n        hostEvents.push({\n          context: COMP_VAR,\n          eventAst: outputAst,\n          dirAst: null\n        });\n      });\n      return {\n        flags: flags,\n        usedEvents: Array.from(usedEvents.values()),\n        queryMatchesExpr: queryMatchExprs.length ? o.literalArr(queryMatchExprs) : o.NULL_EXPR,\n        hostBindings: hostBindings,\n        hostEvents: hostEvents\n      };\n    };\n\n    ViewBuilder.prototype._visitDirective = function (providerAst, dirAst, refs, queryMatches, usedEvents) {\n      var _this = this;\n\n      var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array so we can add children\n\n      this.nodes.push(null);\n      dirAst.directive.queries.forEach(function (query, queryIndex) {\n        var queryId = dirAst.contentQueryStartId + queryIndex;\n        var flags = 67108864\n        /* TypeContentQuery */\n        | calcQueryFlags(query);\n        var bindingType = query.first ? 0\n        /* First */\n        : 1\n        /* All */\n        ;\n\n        _this.nodes.push(function () {\n          return {\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: flags,\n            nodeDef: o.importExpr(identifiers_1.Identifiers.queryDef).callFn([o.literal(flags), o.literal(queryId), new o.LiteralMapExpr([new o.LiteralMapEntry(query.propertyName, o.literal(bindingType), false)])])\n          };\n        });\n      }); // Note: the operation below might also create new nodeDefs,\n      // but we don't want them to be a child of a directive,\n      // as they might be a provider/pipe on their own.\n      // I.e. we only allow queries as children of directives nodes.\n\n      var childCount = this.nodes.length - nodeIndex - 1;\n\n      var _a = this._visitProviderOrDirective(providerAst, queryMatches),\n          flags = _a.flags,\n          queryMatchExprs = _a.queryMatchExprs,\n          providerExpr = _a.providerExpr,\n          depsExpr = _a.depsExpr;\n\n      refs.forEach(function (ref) {\n        if (ref.value && compile_metadata_1.tokenReference(ref.value) === compile_metadata_1.tokenReference(providerAst.token)) {\n          _this.refNodeIndices[ref.name] = nodeIndex;\n          queryMatchExprs.push(o.literalArr([o.literal(ref.name), o.literal(4\n          /* Provider */\n          )]));\n        }\n      });\n\n      if (dirAst.directive.isComponent) {\n        flags |= 32768\n        /* Component */\n        ;\n      }\n\n      var inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {\n        var mapValue = o.literalArr([o.literal(inputIndex), o.literal(inputAst.directiveName)]); // Note: it's important to not quote the key so that we can capture renames by minifiers!\n\n        return new o.LiteralMapEntry(inputAst.directiveName, mapValue, false);\n      });\n      var outputDefs = [];\n      var dirMeta = dirAst.directive;\n      Object.keys(dirMeta.outputs).forEach(function (propName) {\n        var eventName = dirMeta.outputs[propName];\n\n        if (usedEvents.has(eventName)) {\n          // Note: it's important to not quote the key so that we can capture renames by minifiers!\n          outputDefs.push(new o.LiteralMapEntry(propName, o.literal(eventName), false));\n        }\n      });\n      var updateDirectiveExpressions = [];\n\n      if (dirAst.inputs.length || (flags & (262144\n      /* DoCheck */\n      | 65536\n      /* OnInit */\n      )) > 0) {\n        updateDirectiveExpressions = dirAst.inputs.map(function (input, bindingIndex) {\n          return _this._preprocessUpdateExpression({\n            nodeIndex: nodeIndex,\n            bindingIndex: bindingIndex,\n            sourceSpan: input.sourceSpan,\n            context: COMP_VAR,\n            value: input.value\n          });\n        });\n      }\n\n      var dirContextExpr = o.importExpr(identifiers_1.Identifiers.nodeValue).callFn([VIEW_VAR, o.literal(nodeIndex)]);\n      var hostBindings = dirAst.hostProperties.map(function (inputAst) {\n        return {\n          context: dirContextExpr,\n          dirAst: dirAst,\n          inputAst: inputAst\n        };\n      });\n      var hostEvents = dirAst.hostEvents.map(function (hostEventAst) {\n        return {\n          context: dirContextExpr,\n          eventAst: hostEventAst,\n          dirAst: dirAst\n        };\n      }); // Check index is the same as the node index during compilation\n      // They might only differ at runtime\n\n      var checkIndex = nodeIndex;\n\n      this.nodes[nodeIndex] = function () {\n        return {\n          sourceSpan: dirAst.sourceSpan,\n          nodeFlags: 16384\n          /* TypeDirective */\n          | flags,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.directiveDef).callFn([o.literal(checkIndex), o.literal(flags), queryMatchExprs.length ? o.literalArr(queryMatchExprs) : o.NULL_EXPR, o.literal(childCount), providerExpr, depsExpr, inputDefs.length ? new o.LiteralMapExpr(inputDefs) : o.NULL_EXPR, outputDefs.length ? new o.LiteralMapExpr(outputDefs) : o.NULL_EXPR]),\n          updateDirectives: updateDirectiveExpressions,\n          directive: dirAst.directive.type\n        };\n      };\n\n      return {\n        hostBindings: hostBindings,\n        hostEvents: hostEvents\n      };\n    };\n\n    ViewBuilder.prototype._visitProvider = function (providerAst, queryMatches) {\n      this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\n    };\n\n    ViewBuilder.prototype._visitComponentFactoryResolverProvider = function (directives) {\n      var componentDirMeta = directives.find(function (dirAst) {\n        return dirAst.directive.isComponent;\n      });\n\n      if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n        var _a = provider_compiler_1.componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192\n        /* PrivateProvider */\n        , componentDirMeta.directive.entryComponents),\n            providerExpr = _a.providerExpr,\n            depsExpr = _a.depsExpr,\n            flags = _a.flags,\n            tokenExpr = _a.tokenExpr;\n\n        this._addProviderNode({\n          providerExpr: providerExpr,\n          depsExpr: depsExpr,\n          flags: flags,\n          tokenExpr: tokenExpr,\n          queryMatchExprs: [],\n          sourceSpan: componentDirMeta.sourceSpan\n        });\n      }\n    };\n\n    ViewBuilder.prototype._addProviderNode = function (data) {\n      // providerDef(\n      //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n      //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: data.sourceSpan,\n          nodeFlags: data.flags,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.providerDef).callFn([o.literal(data.flags), data.queryMatchExprs.length ? o.literalArr(data.queryMatchExprs) : o.NULL_EXPR, data.tokenExpr, data.providerExpr, data.depsExpr])\n        };\n      });\n    };\n\n    ViewBuilder.prototype._visitProviderOrDirective = function (providerAst, queryMatches) {\n      var flags = 0\n      /* None */\n      ;\n      var queryMatchExprs = [];\n      queryMatches.forEach(function (match) {\n        if (compile_metadata_1.tokenReference(match.value) === compile_metadata_1.tokenReference(providerAst.token)) {\n          queryMatchExprs.push(o.literalArr([o.literal(match.queryId), o.literal(4\n          /* Provider */\n          )]));\n        }\n      });\n\n      var _a = provider_compiler_1.providerDef(this.outputCtx, providerAst),\n          providerExpr = _a.providerExpr,\n          depsExpr = _a.depsExpr,\n          providerFlags = _a.flags,\n          tokenExpr = _a.tokenExpr;\n\n      return {\n        flags: flags | providerFlags,\n        queryMatchExprs: queryMatchExprs,\n        providerExpr: providerExpr,\n        depsExpr: depsExpr,\n        tokenExpr: tokenExpr,\n        sourceSpan: providerAst.sourceSpan\n      };\n    };\n\n    ViewBuilder.prototype.getLocal = function (name) {\n      if (name == expression_converter_1.EventHandlerVars.event.name) {\n        return expression_converter_1.EventHandlerVars.event;\n      }\n\n      var currViewExpr = VIEW_VAR;\n\n      for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent, currViewExpr = currViewExpr.prop('parent').cast(o.DYNAMIC_TYPE)) {\n        // check references\n        var refNodeIndex = currBuilder.refNodeIndices[name];\n\n        if (refNodeIndex != null) {\n          return o.importExpr(identifiers_1.Identifiers.nodeValue).callFn([currViewExpr, o.literal(refNodeIndex)]);\n        } // check variables\n\n\n        var varAst = currBuilder.variables.find(function (varAst) {\n          return varAst.name === name;\n        });\n\n        if (varAst) {\n          var varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n          return currViewExpr.prop('context').prop(varValue);\n        }\n      }\n\n      return null;\n    };\n\n    ViewBuilder.prototype.notifyImplicitReceiverUse = function () {// Not needed in View Engine as View Engine walks through the generated\n      // expressions to figure out if the implicit receiver is used and needs\n      // to be generated as part of the pre-update statements.\n    };\n\n    ViewBuilder.prototype._createLiteralArrayConverter = function (sourceSpan, argCount) {\n      if (argCount === 0) {\n        var valueExpr_1 = o.importExpr(identifiers_1.Identifiers.EMPTY_ARRAY);\n        return function () {\n          return valueExpr_1;\n        };\n      }\n\n      var checkIndex = this.nodes.length;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: sourceSpan,\n          nodeFlags: 32\n          /* TypePureArray */\n          ,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.pureArrayDef).callFn([o.literal(checkIndex), o.literal(argCount)])\n        };\n      });\n      return function (args) {\n        return callCheckStmt(checkIndex, args);\n      };\n    };\n\n    ViewBuilder.prototype._createLiteralMapConverter = function (sourceSpan, keys) {\n      if (keys.length === 0) {\n        var valueExpr_2 = o.importExpr(identifiers_1.Identifiers.EMPTY_MAP);\n        return function () {\n          return valueExpr_2;\n        };\n      }\n\n      var map = o.literalMap(keys.map(function (e, i) {\n        return tslib_1.__assign(tslib_1.__assign({}, e), {\n          value: o.literal(i)\n        });\n      }));\n      var checkIndex = this.nodes.length;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: sourceSpan,\n          nodeFlags: 64\n          /* TypePureObject */\n          ,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.pureObjectDef).callFn([o.literal(checkIndex), map])\n        };\n      });\n      return function (args) {\n        return callCheckStmt(checkIndex, args);\n      };\n    };\n\n    ViewBuilder.prototype._createPipeConverter = function (expression, name, argCount) {\n      var pipe = this.usedPipes.find(function (pipeSummary) {\n        return pipeSummary.name === name;\n      });\n\n      if (pipe.pure) {\n        var checkIndex_1 = this.nodes.length;\n        this.nodes.push(function () {\n          return {\n            sourceSpan: expression.sourceSpan,\n            nodeFlags: 128\n            /* TypePurePipe */\n            ,\n            nodeDef: o.importExpr(identifiers_1.Identifiers.purePipeDef).callFn([o.literal(checkIndex_1), o.literal(argCount)])\n          };\n        }); // find underlying pipe in the component view\n\n        var compViewExpr = VIEW_VAR;\n        var compBuilder = this;\n\n        while (compBuilder.parent) {\n          compBuilder = compBuilder.parent;\n          compViewExpr = compViewExpr.prop('parent').cast(o.DYNAMIC_TYPE);\n        }\n\n        var pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n        var pipeValueExpr_1 = o.importExpr(identifiers_1.Identifiers.nodeValue).callFn([compViewExpr, o.literal(pipeNodeIndex)]);\n        return function (args) {\n          return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(checkIndex_1, [pipeValueExpr_1].concat(args)));\n        };\n      } else {\n        var nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n\n        var nodeValueExpr_1 = o.importExpr(identifiers_1.Identifiers.nodeValue).callFn([VIEW_VAR, o.literal(nodeIndex)]);\n        return function (args) {\n          return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr_1.callMethod('transform', args));\n        };\n      }\n    };\n\n    ViewBuilder.prototype._createPipe = function (sourceSpan, pipe) {\n      var _this = this;\n\n      var nodeIndex = this.nodes.length;\n      var flags = 0\n      /* None */\n      ;\n      pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {\n        // for pipes, we only support ngOnDestroy\n        if (lifecycleHook === lifecycle_reflector_1.LifecycleHooks.OnDestroy) {\n          flags |= provider_compiler_1.lifecycleHookToNodeFlag(lifecycleHook);\n        }\n      });\n      var depExprs = pipe.type.diDeps.map(function (diDep) {\n        return provider_compiler_1.depDef(_this.outputCtx, diDep);\n      }); // function pipeDef(\n      //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n\n      this.nodes.push(function () {\n        return {\n          sourceSpan: sourceSpan,\n          nodeFlags: 16\n          /* TypePipe */\n          ,\n          nodeDef: o.importExpr(identifiers_1.Identifiers.pipeDef).callFn([o.literal(flags), _this.outputCtx.importExpr(pipe.type.reference), o.literalArr(depExprs)])\n        };\n      });\n      return nodeIndex;\n    };\n    /**\n     * For the AST in `UpdateExpression.value`:\n     * - create nodes for pipes, literal arrays and, literal maps,\n     * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.\n     *\n     * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!\n     */\n\n\n    ViewBuilder.prototype._preprocessUpdateExpression = function (expression) {\n      var _this = this;\n\n      return {\n        nodeIndex: expression.nodeIndex,\n        bindingIndex: expression.bindingIndex,\n        sourceSpan: expression.sourceSpan,\n        context: expression.context,\n        value: expression_converter_1.convertPropertyBindingBuiltins({\n          createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {\n            return _this._createLiteralArrayConverter(expression.sourceSpan, argCount);\n          },\n          createLiteralMapConverter: function createLiteralMapConverter(keys) {\n            return _this._createLiteralMapConverter(expression.sourceSpan, keys);\n          },\n          createPipeConverter: function createPipeConverter(name, argCount) {\n            return _this._createPipeConverter(expression, name, argCount);\n          }\n        }, expression.value)\n      };\n    };\n\n    ViewBuilder.prototype._createNodeExpressions = function () {\n      var self = this;\n      var updateBindingCount = 0;\n      var updateRendererStmts = [];\n      var updateDirectivesStmts = [];\n      var nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {\n        var _a = factory(),\n            nodeDef = _a.nodeDef,\n            nodeFlags = _a.nodeFlags,\n            updateDirectives = _a.updateDirectives,\n            updateRenderer = _a.updateRenderer,\n            sourceSpan = _a.sourceSpan;\n\n        if (updateRenderer) {\n          updateRendererStmts.push.apply(updateRendererStmts, tslib_1.__spread(createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false)));\n        }\n\n        if (updateDirectives) {\n          updateDirectivesStmts.push.apply(updateDirectivesStmts, tslib_1.__spread(createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144\n          /* DoCheck */\n          | 65536\n          /* OnInit */\n          )) > 0)));\n        } // We use a comma expression to call the log function before\n        // the nodeDef function, but still use the result of the nodeDef function\n        // as the value.\n        // Note: We only add the logger to elements / text nodes,\n        // so we don't generate too much code.\n\n\n        var logWithNodeDef = nodeFlags & 3\n        /* CatRenderNode */\n        ? new o.CommaExpr([LOG_VAR.callFn([]).callFn([]), nodeDef]) : nodeDef;\n        return o.applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n      });\n      return {\n        updateRendererStmts: updateRendererStmts,\n        updateDirectivesStmts: updateDirectivesStmts,\n        nodeDefExprs: nodeDefExprs\n      };\n\n      function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n        var updateStmts = [];\n        var exprs = expressions.map(function (_a) {\n          var sourceSpan = _a.sourceSpan,\n              context = _a.context,\n              value = _a.value;\n          var bindingId = \"\" + updateBindingCount++;\n          var nameResolver = context === COMP_VAR ? self : null;\n\n          var _b = expression_converter_1.convertPropertyBinding(nameResolver, context, value, bindingId, expression_converter_1.BindingForm.General),\n              stmts = _b.stmts,\n              currValExpr = _b.currValExpr;\n\n          updateStmts.push.apply(updateStmts, tslib_1.__spread(stmts.map(function (stmt) {\n            return o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan);\n          })));\n          return o.applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n        });\n\n        if (expressions.length || allowEmptyExprs) {\n          updateStmts.push(o.applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n        }\n\n        return updateStmts;\n      }\n    };\n\n    ViewBuilder.prototype._createElementHandleEventFn = function (nodeIndex, handlers) {\n      var _this = this;\n\n      var handleEventStmts = [];\n      var handleEventBindingCount = 0;\n      handlers.forEach(function (_a) {\n        var context = _a.context,\n            eventAst = _a.eventAst,\n            dirAst = _a.dirAst;\n        var bindingId = \"\" + handleEventBindingCount++;\n        var nameResolver = context === COMP_VAR ? _this : null;\n\n        var _b = expression_converter_1.convertActionBinding(nameResolver, context, eventAst.handler, bindingId),\n            stmts = _b.stmts,\n            allowDefault = _b.allowDefault;\n\n        var trueStmts = stmts;\n\n        if (allowDefault) {\n          trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n        }\n\n        var _c = elementEventNameAndTarget(eventAst, dirAst),\n            eventTarget = _c.target,\n            eventName = _c.name;\n\n        var fullEventName = elementEventFullName(eventTarget, eventName);\n        handleEventStmts.push(o.applySourceSpanToStatementIfNeeded(new o.IfStmt(o.literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n      });\n      var handleEventFn;\n\n      if (handleEventStmts.length > 0) {\n        var preStmts = [ALLOW_DEFAULT_VAR.set(o.literal(true)).toDeclStmt(o.BOOL_TYPE)];\n\n        if (!this.component.isHost && o.findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {\n          preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n        }\n\n        handleEventFn = o.fn([new o.FnParam(VIEW_VAR.name, o.INFERRED_TYPE), new o.FnParam(EVENT_NAME_VAR.name, o.INFERRED_TYPE), new o.FnParam(expression_converter_1.EventHandlerVars.event.name, o.INFERRED_TYPE)], tslib_1.__spread(preStmts, handleEventStmts, [new o.ReturnStatement(ALLOW_DEFAULT_VAR)]), o.INFERRED_TYPE);\n      } else {\n        handleEventFn = o.NULL_EXPR;\n      }\n\n      return handleEventFn;\n    };\n\n    ViewBuilder.prototype.visitDirective = function (ast, context) {};\n\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) {};\n\n    ViewBuilder.prototype.visitReference = function (ast, context) {};\n\n    ViewBuilder.prototype.visitVariable = function (ast, context) {};\n\n    ViewBuilder.prototype.visitEvent = function (ast, context) {};\n\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) {};\n\n    ViewBuilder.prototype.visitAttr = function (ast, context) {};\n\n    return ViewBuilder;\n  }();\n\n  function needsAdditionalRootNode(astNodes) {\n    var lastAstNode = astNodes[astNodes.length - 1];\n\n    if (lastAstNode instanceof template_ast_1.EmbeddedTemplateAst) {\n      return lastAstNode.hasViewContainer;\n    }\n\n    if (lastAstNode instanceof template_ast_1.ElementAst) {\n      if (tags_1.isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n        return needsAdditionalRootNode(lastAstNode.children);\n      }\n\n      return lastAstNode.hasViewContainer;\n    }\n\n    return lastAstNode instanceof template_ast_1.NgContentAst;\n  }\n\n  function elementBindingDef(inputAst, dirAst) {\n    var inputType = inputAst.type;\n\n    switch (inputType) {\n      case 1\n      /* Attribute */\n      :\n        return o.literalArr([o.literal(1\n        /* TypeElementAttribute */\n        ), o.literal(inputAst.name), o.literal(inputAst.securityContext)]);\n\n      case 0\n      /* Property */\n      :\n        return o.literalArr([o.literal(8\n        /* TypeProperty */\n        ), o.literal(inputAst.name), o.literal(inputAst.securityContext)]);\n\n      case 4\n      /* Animation */\n      :\n        var bindingType = 8\n        /* TypeProperty */\n        | (dirAst && dirAst.directive.isComponent ? 32\n        /* SyntheticHostProperty */\n        : 16\n        /* SyntheticProperty */\n        );\n        return o.literalArr([o.literal(bindingType), o.literal('@' + inputAst.name), o.literal(inputAst.securityContext)]);\n\n      case 2\n      /* Class */\n      :\n        return o.literalArr([o.literal(2\n        /* TypeElementClass */\n        ), o.literal(inputAst.name), o.NULL_EXPR]);\n\n      case 3\n      /* Style */\n      :\n        return o.literalArr([o.literal(4\n        /* TypeElementStyle */\n        ), o.literal(inputAst.name), o.literal(inputAst.unit)]);\n\n      default:\n        // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n        // However Closure Compiler does not understand that and reports an error in typed mode.\n        // The `throw new Error` below works around the problem, and the unexpected: never variable\n        // makes sure tsc still checks this code is unreachable.\n        var unexpected = inputType;\n        throw new Error(\"unexpected \" + unexpected);\n    }\n  }\n\n  function fixedAttrsDef(elementAst) {\n    var mapResult = Object.create(null);\n    elementAst.attrs.forEach(function (attrAst) {\n      mapResult[attrAst.name] = attrAst.value;\n    });\n    elementAst.directives.forEach(function (dirAst) {\n      Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {\n        var value = dirAst.directive.hostAttributes[name];\n        var prevValue = mapResult[name];\n        mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n      });\n    }); // Note: We need to sort to get a defined output order\n    // for tests and for caching generated artifacts...\n\n    return o.literalArr(Object.keys(mapResult).sort().map(function (attrName) {\n      return o.literalArr([o.literal(attrName), o.literal(mapResult[attrName])]);\n    }));\n  }\n\n  function mergeAttributeValue(attrName, attrValue1, attrValue2) {\n    if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {\n      return attrValue1 + \" \" + attrValue2;\n    } else {\n      return attrValue2;\n    }\n  }\n\n  function callCheckStmt(nodeIndex, exprs) {\n    if (exprs.length > 10) {\n      return CHECK_VAR.callFn([VIEW_VAR, o.literal(nodeIndex), o.literal(1\n      /* Dynamic */\n      ), o.literalArr(exprs)]);\n    } else {\n      return CHECK_VAR.callFn(tslib_1.__spread([VIEW_VAR, o.literal(nodeIndex), o.literal(0\n      /* Inline */\n      )], exprs));\n    }\n  }\n\n  function callUnwrapValue(nodeIndex, bindingIdx, expr) {\n    return o.importExpr(identifiers_1.Identifiers.unwrapValue).callFn([VIEW_VAR, o.literal(nodeIndex), o.literal(bindingIdx), expr]);\n  }\n\n  function elementEventNameAndTarget(eventAst, dirAst) {\n    if (eventAst.isAnimation) {\n      return {\n        name: \"@\" + eventAst.name + \".\" + eventAst.phase,\n        target: dirAst && dirAst.directive.isComponent ? 'component' : null\n      };\n    } else {\n      return eventAst;\n    }\n  }\n\n  function calcQueryFlags(query) {\n    var flags = 0\n    /* None */\n    ; // Note: We only make queries static that query for a single item and the user specifically\n    // set the to be static. This is because of backwards compatibility with the old view compiler...\n\n    if (query.first && query.static) {\n      flags |= 268435456\n      /* StaticQuery */\n      ;\n    } else {\n      flags |= 536870912\n      /* DynamicQuery */\n      ;\n    }\n\n    if (query.emitDistinctChangesOnly) {\n      flags |= -2147483648\n      /* EmitDistinctChangesOnly */\n      ;\n    }\n\n    return flags;\n  }\n\n  function elementEventFullName(target, name) {\n    return target ? target + \":\" + name : name;\n  }\n\n  exports.elementEventFullName = elementEventFullName;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/view_compiler/view_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, CompilePipeSummary, CompileQueryMetadata, rendererTypeName, tokenReference, viewClassName} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {BindingForm, BuiltinConverter, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins, EventHandlerVars, LocalResolver} from '../compiler_util/expression_converter';\nimport {ArgumentType, BindingFlags, ChangeDetectionStrategy, NodeFlags, QueryBindingType, QueryValueType, ViewFlags} from '../core';\nimport {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport {LifecycleHooks} from '../lifecycle_reflector';\nimport {isNgContainer} from '../ml_parser/tags';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ParseSourceSpan} from '../parse_util';\nimport {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, PropertyBindingType, ProviderAst, QueryMatch, ReferenceAst, TemplateAst, TemplateAstVisitor, templateVisitAll, TextAst, VariableAst} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\nimport {componentFactoryResolverProviderDef, depDef, lifecycleHookToNodeFlag, providerDef} from './provider_compiler';\n\nconst CLASS_ATTR = 'class';\nconst STYLE_ATTR = 'style';\nconst IMPLICIT_TEMPLATE_VAR = '\\$implicit';\n\nexport class ViewCompileResult {\n  constructor(public viewClassVar: string, public rendererTypeVar: string) {}\n}\n\nexport class ViewCompiler {\n  constructor(private _reflector: CompileReflector) {}\n\n  compileComponent(\n      outputCtx: OutputContext, component: CompileDirectiveMetadata, template: TemplateAst[],\n      styles: o.Expression, usedPipes: CompilePipeSummary[]): ViewCompileResult {\n    let embeddedViewCount = 0;\n\n    let renderComponentVarName: string = undefined!;\n    if (!component.isHost) {\n      const template = component.template !;\n      const customRenderData: o.LiteralMapEntry[] = [];\n      if (template.animations && template.animations.length) {\n        customRenderData.push(new o.LiteralMapEntry(\n            'animation', convertValueToOutputAst(outputCtx, template.animations), true));\n      }\n\n      const renderComponentVar = o.variable(rendererTypeName(component.type.reference));\n      renderComponentVarName = renderComponentVar.name!;\n      outputCtx.statements.push(\n          renderComponentVar\n              .set(o.importExpr(Identifiers.createRendererType2).callFn([new o.LiteralMapExpr([\n                new o.LiteralMapEntry('encapsulation', o.literal(template.encapsulation), false),\n                new o.LiteralMapEntry('styles', styles, false),\n                new o.LiteralMapEntry('data', new o.LiteralMapExpr(customRenderData), false)\n              ])]))\n              .toDeclStmt(\n                  o.importType(Identifiers.RendererType2),\n                  [o.StmtModifier.Final, o.StmtModifier.Exported]));\n    }\n\n    const viewBuilderFactory = (parent: ViewBuilder|null): ViewBuilder => {\n      const embeddedViewIndex = embeddedViewCount++;\n      return new ViewBuilder(\n          this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes,\n          viewBuilderFactory);\n    };\n\n    const visitor = viewBuilderFactory(null);\n    visitor.visitAll([], template);\n\n    outputCtx.statements.push(...visitor.build());\n\n    return new ViewCompileResult(visitor.viewName, renderComponentVarName);\n  }\n}\n\ninterface ViewBuilderFactory {\n  (parent: ViewBuilder): ViewBuilder;\n}\n\ninterface UpdateExpression {\n  context: o.Expression;\n  nodeIndex: number;\n  bindingIndex: number;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\nconst LOG_VAR = o.variable('_l');\nconst VIEW_VAR = o.variable('_v');\nconst CHECK_VAR = o.variable('_ck');\nconst COMP_VAR = o.variable('_co');\nconst EVENT_NAME_VAR = o.variable('en');\nconst ALLOW_DEFAULT_VAR = o.variable(`ad`);\n\nclass ViewBuilder implements TemplateAstVisitor, LocalResolver {\n  private compType: o.Type;\n  private nodes: (() => {\n    sourceSpan: ParseSourceSpan | null,\n    nodeDef: o.Expression,\n    nodeFlags: NodeFlags,\n    updateDirectives?: UpdateExpression[],\n    updateRenderer?: UpdateExpression[]\n  })[] = [];\n  private purePipeNodeIndices: {[pipeName: string]: number} = Object.create(null);\n  // Need Object.create so that we don't have builtin values...\n  private refNodeIndices: {[refName: string]: number} = Object.create(null);\n  private variables: VariableAst[] = [];\n  private children: ViewBuilder[] = [];\n\n  public readonly viewName: string;\n\n  constructor(\n      private reflector: CompileReflector, private outputCtx: OutputContext,\n      private parent: ViewBuilder|null, private component: CompileDirectiveMetadata,\n      private embeddedViewIndex: number, private usedPipes: CompilePipeSummary[],\n      private viewBuilderFactory: ViewBuilderFactory) {\n    // TODO(tbosch): The old view compiler used to use an `any` type\n    // for the context in any embedded view. We keep this behaivor for now\n    // to be able to introduce the new view compiler without too many errors.\n    this.compType = this.embeddedViewIndex > 0 ?\n        o.DYNAMIC_TYPE :\n        o.expressionType(outputCtx.importExpr(this.component.type.reference))!;\n    this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);\n  }\n\n  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n    this.variables = variables;\n    // create the pipes for the pure pipes immediately, so that we know their indices.\n    if (!this.parent) {\n      this.usedPipes.forEach((pipe) => {\n        if (pipe.pure) {\n          this.purePipeNodeIndices[pipe.name] = this._createPipe(null, pipe);\n        }\n      });\n    }\n\n    if (!this.parent) {\n      this.component.viewQueries.forEach((query, queryIndex) => {\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\n        const queryId = queryIndex + 1;\n        const bindingType = query.first ? QueryBindingType.First : QueryBindingType.All;\n        const flags = NodeFlags.TypeViewQuery | calcQueryFlags(query);\n        this.nodes.push(() => ({\n                          sourceSpan: null,\n                          nodeFlags: flags,\n                          nodeDef: o.importExpr(Identifiers.queryDef).callFn([\n                            o.literal(flags), o.literal(queryId),\n                            new o.LiteralMapExpr([new o.LiteralMapEntry(\n                                query.propertyName, o.literal(bindingType), false)])\n                          ])\n                        }));\n      });\n    }\n    templateVisitAll(this, astNodes);\n    if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n      // if the view is an embedded view, then we need to add an additional root node in some cases\n      this.nodes.push(() => ({\n                        sourceSpan: null,\n                        nodeFlags: NodeFlags.TypeElement,\n                        nodeDef: o.importExpr(Identifiers.anchorDef).callFn([\n                          o.literal(NodeFlags.None), o.NULL_EXPR, o.NULL_EXPR, o.literal(0)\n                        ])\n                      }));\n    }\n  }\n\n  build(targetStatements: o.Statement[] = []): o.Statement[] {\n    this.children.forEach((child) => child.build(targetStatements));\n\n    const {updateRendererStmts, updateDirectivesStmts, nodeDefExprs} =\n        this._createNodeExpressions();\n\n    const updateRendererFn = this._createUpdateFn(updateRendererStmts);\n    const updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n\n\n    let viewFlags = ViewFlags.None;\n    if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {\n      viewFlags |= ViewFlags.OnPush;\n    }\n    const viewFactory = new o.DeclareFunctionStmt(\n        this.viewName, [new o.FnParam(LOG_VAR.name!)],\n        [new o.ReturnStatement(o.importExpr(Identifiers.viewDef).callFn([\n          o.literal(viewFlags),\n          o.literalArr(nodeDefExprs),\n          updateDirectivesFn,\n          updateRendererFn,\n        ]))],\n        o.importType(Identifiers.ViewDefinition),\n        this.embeddedViewIndex === 0 ? [o.StmtModifier.Exported] : []);\n\n    targetStatements.push(viewFactory);\n    return targetStatements;\n  }\n\n  private _createUpdateFn(updateStmts: o.Statement[]): o.Expression {\n    let updateFn: o.Expression;\n    if (updateStmts.length > 0) {\n      const preStmts: o.Statement[] = [];\n      if (!this.component.isHost && o.findReadVarNames(updateStmts).has(COMP_VAR.name!)) {\n        preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n      }\n      updateFn = o.fn(\n          [\n            new o.FnParam(CHECK_VAR.name!, o.INFERRED_TYPE),\n            new o.FnParam(VIEW_VAR.name!, o.INFERRED_TYPE)\n          ],\n          [...preStmts, ...updateStmts], o.INFERRED_TYPE);\n    } else {\n      updateFn = o.NULL_EXPR;\n    }\n    return updateFn;\n  }\n\n  visitNgContent(ast: NgContentAst, context: any): any {\n    // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n    this.nodes.push(() => ({\n                      sourceSpan: ast.sourceSpan,\n                      nodeFlags: NodeFlags.TypeNgContent,\n                      nodeDef: o.importExpr(Identifiers.ngContentDef)\n                                   .callFn([o.literal(ast.ngContentIndex), o.literal(ast.index)])\n                    }));\n  }\n\n  visitText(ast: TextAst, context: any): any {\n    // Static text nodes have no check function\n    const checkIndex = -1;\n    this.nodes.push(() => ({\n                      sourceSpan: ast.sourceSpan,\n                      nodeFlags: NodeFlags.TypeText,\n                      nodeDef: o.importExpr(Identifiers.textDef).callFn([\n                        o.literal(checkIndex),\n                        o.literal(ast.ngContentIndex),\n                        o.literalArr([o.literal(ast.value)]),\n                      ])\n                    }));\n  }\n\n  visitBoundText(ast: BoundTextAst, context: any): any {\n    const nodeIndex = this.nodes.length;\n    // reserve the space in the nodeDefs array\n    this.nodes.push(null!);\n\n    const astWithSource = <ASTWithSource>ast.value;\n    const inter = <Interpolation>astWithSource.ast;\n\n    const updateRendererExpressions = inter.expressions.map(\n        (expr, bindingIndex) => this._preprocessUpdateExpression(\n            {nodeIndex, bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr}));\n\n    // Check index is the same as the node index during compilation\n    // They might only differ at runtime\n    const checkIndex = nodeIndex;\n\n    this.nodes[nodeIndex] = () => ({\n      sourceSpan: ast.sourceSpan,\n      nodeFlags: NodeFlags.TypeText,\n      nodeDef: o.importExpr(Identifiers.textDef).callFn([\n        o.literal(checkIndex),\n        o.literal(ast.ngContentIndex),\n        o.literalArr(inter.strings.map(s => o.literal(s))),\n      ]),\n      updateRenderer: updateRendererExpressions\n    });\n  }\n\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    const nodeIndex = this.nodes.length;\n    // reserve the space in the nodeDefs array\n    this.nodes.push(null!);\n\n    const {flags, queryMatchesExpr, hostEvents} = this._visitElementOrTemplate(nodeIndex, ast);\n\n    const childVisitor = this.viewBuilderFactory(this);\n    this.children.push(childVisitor);\n    childVisitor.visitAll(ast.variables, ast.children);\n\n    const childCount = this.nodes.length - nodeIndex - 1;\n\n    // anchorDef(\n    //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n    //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n    //   ViewDefinitionFactory): NodeDef;\n    this.nodes[nodeIndex] = () => ({\n      sourceSpan: ast.sourceSpan,\n      nodeFlags: NodeFlags.TypeElement | flags,\n      nodeDef: o.importExpr(Identifiers.anchorDef).callFn([\n        o.literal(flags),\n        queryMatchesExpr,\n        o.literal(ast.ngContentIndex),\n        o.literal(childCount),\n        this._createElementHandleEventFn(nodeIndex, hostEvents),\n        o.variable(childVisitor.viewName),\n      ])\n    });\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    const nodeIndex = this.nodes.length;\n    // reserve the space in the nodeDefs array so we can add children\n    this.nodes.push(null!);\n\n    // Using a null element name creates an anchor.\n    const elName: string|null = isNgContainer(ast.name) ? null : ast.name;\n\n    const {flags, usedEvents, queryMatchesExpr, hostBindings: dirHostBindings, hostEvents} =\n        this._visitElementOrTemplate(nodeIndex, ast);\n\n    let inputDefs: o.Expression[] = [];\n    let updateRendererExpressions: UpdateExpression[] = [];\n    let outputDefs: o.Expression[] = [];\n    if (elName) {\n      const hostBindings: any[] = ast.inputs\n                                      .map((inputAst) => ({\n                                             context: COMP_VAR as o.Expression,\n                                             inputAst,\n                                             dirAst: null as any,\n                                           }))\n                                      .concat(dirHostBindings);\n      if (hostBindings.length) {\n        updateRendererExpressions =\n            hostBindings.map((hostBinding, bindingIndex) => this._preprocessUpdateExpression({\n              context: hostBinding.context,\n              nodeIndex,\n              bindingIndex,\n              sourceSpan: hostBinding.inputAst.sourceSpan,\n              value: hostBinding.inputAst.value\n            }));\n        inputDefs = hostBindings.map(\n            hostBinding => elementBindingDef(hostBinding.inputAst, hostBinding.dirAst));\n      }\n      outputDefs = usedEvents.map(\n          ([target, eventName]) => o.literalArr([o.literal(target), o.literal(eventName)]));\n    }\n\n    templateVisitAll(this, ast.children);\n\n    const childCount = this.nodes.length - nodeIndex - 1;\n\n    const compAst = ast.directives.find(dirAst => dirAst.directive.isComponent);\n    let compRendererType = o.NULL_EXPR as o.Expression;\n    let compView = o.NULL_EXPR as o.Expression;\n    if (compAst) {\n      compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\n      compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\n    }\n\n    // Check index is the same as the node index during compilation\n    // They might only differ at runtime\n    const checkIndex = nodeIndex;\n\n    this.nodes[nodeIndex] = () => ({\n      sourceSpan: ast.sourceSpan,\n      nodeFlags: NodeFlags.TypeElement | flags,\n      nodeDef: o.importExpr(Identifiers.elementDef).callFn([\n        o.literal(checkIndex),\n        o.literal(flags),\n        queryMatchesExpr,\n        o.literal(ast.ngContentIndex),\n        o.literal(childCount),\n        o.literal(elName),\n        elName ? fixedAttrsDef(ast) : o.NULL_EXPR,\n        inputDefs.length ? o.literalArr(inputDefs) : o.NULL_EXPR,\n        outputDefs.length ? o.literalArr(outputDefs) : o.NULL_EXPR,\n        this._createElementHandleEventFn(nodeIndex, hostEvents),\n        compView,\n        compRendererType,\n      ]),\n      updateRenderer: updateRendererExpressions\n    });\n  }\n\n  private _visitElementOrTemplate(nodeIndex: number, ast: {\n    hasViewContainer: boolean,\n    outputs: BoundEventAst[],\n    directives: DirectiveAst[],\n    providers: ProviderAst[],\n    references: ReferenceAst[],\n    queryMatches: QueryMatch[]\n  }): {\n    flags: NodeFlags,\n    usedEvents: [string|null, string][],\n    queryMatchesExpr: o.Expression,\n    hostBindings:\n        {context: o.Expression, inputAst: BoundElementPropertyAst, dirAst: DirectiveAst}[],\n    hostEvents: {context: o.Expression, eventAst: BoundEventAst, dirAst: DirectiveAst}[],\n  } {\n    let flags = NodeFlags.None;\n    if (ast.hasViewContainer) {\n      flags |= NodeFlags.EmbeddedViews;\n    }\n    const usedEvents = new Map<string, [string | null, string]>();\n    ast.outputs.forEach((event) => {\n      const {name, target} = elementEventNameAndTarget(event, null);\n      usedEvents.set(elementEventFullName(target, name), [target, name]);\n    });\n    ast.directives.forEach((dirAst) => {\n      dirAst.hostEvents.forEach((event) => {\n        const {name, target} = elementEventNameAndTarget(event, dirAst);\n        usedEvents.set(elementEventFullName(target, name), [target, name]);\n      });\n    });\n    const hostBindings:\n        {context: o.Expression, inputAst: BoundElementPropertyAst, dirAst: DirectiveAst}[] = [];\n    const hostEvents: {context: o.Expression, eventAst: BoundEventAst, dirAst: DirectiveAst}[] = [];\n    this._visitComponentFactoryResolverProvider(ast.directives);\n\n    ast.providers.forEach(providerAst => {\n      let dirAst: DirectiveAst = undefined!;\n      ast.directives.forEach(localDirAst => {\n        if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n          dirAst = localDirAst;\n        }\n      });\n      if (dirAst) {\n        const {hostBindings: dirHostBindings, hostEvents: dirHostEvents} =\n            this._visitDirective(providerAst, dirAst, ast.references, ast.queryMatches, usedEvents);\n        hostBindings.push(...dirHostBindings);\n        hostEvents.push(...dirHostEvents);\n      } else {\n        this._visitProvider(providerAst, ast.queryMatches);\n      }\n    });\n\n    let queryMatchExprs: o.Expression[] = [];\n    ast.queryMatches.forEach((match) => {\n      let valueType: QueryValueType = undefined!;\n      if (tokenReference(match.value) ===\n          this.reflector.resolveExternalReference(Identifiers.ElementRef)) {\n        valueType = QueryValueType.ElementRef;\n      } else if (\n          tokenReference(match.value) ===\n          this.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n        valueType = QueryValueType.ViewContainerRef;\n      } else if (\n          tokenReference(match.value) ===\n          this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n        valueType = QueryValueType.TemplateRef;\n      }\n      if (valueType != null) {\n        queryMatchExprs.push(o.literalArr([o.literal(match.queryId), o.literal(valueType)]));\n      }\n    });\n    ast.references.forEach((ref) => {\n      let valueType: QueryValueType = undefined!;\n      if (!ref.value) {\n        valueType = QueryValueType.RenderElement;\n      } else if (\n          tokenReference(ref.value) ===\n          this.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n        valueType = QueryValueType.TemplateRef;\n      }\n      if (valueType != null) {\n        this.refNodeIndices[ref.name] = nodeIndex;\n        queryMatchExprs.push(o.literalArr([o.literal(ref.name), o.literal(valueType)]));\n      }\n    });\n    ast.outputs.forEach((outputAst) => {\n      hostEvents.push({context: COMP_VAR, eventAst: outputAst, dirAst: null!});\n    });\n\n    return {\n      flags,\n      usedEvents: Array.from(usedEvents.values()),\n      queryMatchesExpr: queryMatchExprs.length ? o.literalArr(queryMatchExprs) : o.NULL_EXPR,\n      hostBindings,\n      hostEvents: hostEvents\n    };\n  }\n\n  private _visitDirective(\n      providerAst: ProviderAst, dirAst: DirectiveAst, refs: ReferenceAst[],\n      queryMatches: QueryMatch[], usedEvents: Map<string, any>): {\n    hostBindings:\n        {context: o.Expression, inputAst: BoundElementPropertyAst, dirAst: DirectiveAst}[],\n    hostEvents: {context: o.Expression, eventAst: BoundEventAst, dirAst: DirectiveAst}[]\n  } {\n    const nodeIndex = this.nodes.length;\n    // reserve the space in the nodeDefs array so we can add children\n    this.nodes.push(null!);\n\n    dirAst.directive.queries.forEach((query, queryIndex) => {\n      const queryId = dirAst.contentQueryStartId + queryIndex;\n      const flags = NodeFlags.TypeContentQuery | calcQueryFlags(query);\n      const bindingType = query.first ? QueryBindingType.First : QueryBindingType.All;\n      this.nodes.push(() => ({\n                        sourceSpan: dirAst.sourceSpan,\n                        nodeFlags: flags,\n                        nodeDef: o.importExpr(Identifiers.queryDef).callFn([\n                          o.literal(flags), o.literal(queryId),\n                          new o.LiteralMapExpr([new o.LiteralMapEntry(\n                              query.propertyName, o.literal(bindingType), false)])\n                        ]),\n                      }));\n    });\n\n    // Note: the operation below might also create new nodeDefs,\n    // but we don't want them to be a child of a directive,\n    // as they might be a provider/pipe on their own.\n    // I.e. we only allow queries as children of directives nodes.\n    const childCount = this.nodes.length - nodeIndex - 1;\n\n    let {flags, queryMatchExprs, providerExpr, depsExpr} =\n        this._visitProviderOrDirective(providerAst, queryMatches);\n\n    refs.forEach((ref) => {\n      if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n        this.refNodeIndices[ref.name] = nodeIndex;\n        queryMatchExprs.push(\n            o.literalArr([o.literal(ref.name), o.literal(QueryValueType.Provider)]));\n      }\n    });\n\n    if (dirAst.directive.isComponent) {\n      flags |= NodeFlags.Component;\n    }\n\n    const inputDefs = dirAst.inputs.map((inputAst, inputIndex) => {\n      const mapValue = o.literalArr([o.literal(inputIndex), o.literal(inputAst.directiveName)]);\n      // Note: it's important to not quote the key so that we can capture renames by minifiers!\n      return new o.LiteralMapEntry(inputAst.directiveName, mapValue, false);\n    });\n\n    const outputDefs: o.LiteralMapEntry[] = [];\n    const dirMeta = dirAst.directive;\n    Object.keys(dirMeta.outputs).forEach((propName) => {\n      const eventName = dirMeta.outputs[propName];\n      if (usedEvents.has(eventName)) {\n        // Note: it's important to not quote the key so that we can capture renames by minifiers!\n        outputDefs.push(new o.LiteralMapEntry(propName, o.literal(eventName), false));\n      }\n    });\n    let updateDirectiveExpressions: UpdateExpression[] = [];\n    if (dirAst.inputs.length || (flags & (NodeFlags.DoCheck | NodeFlags.OnInit)) > 0) {\n      updateDirectiveExpressions =\n          dirAst.inputs.map((input, bindingIndex) => this._preprocessUpdateExpression({\n            nodeIndex,\n            bindingIndex,\n            sourceSpan: input.sourceSpan,\n            context: COMP_VAR,\n            value: input.value\n          }));\n    }\n\n    const dirContextExpr =\n        o.importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, o.literal(nodeIndex)]);\n    const hostBindings = dirAst.hostProperties.map((inputAst) => ({\n                                                     context: dirContextExpr,\n                                                     dirAst,\n                                                     inputAst,\n                                                   }));\n    const hostEvents = dirAst.hostEvents.map((hostEventAst) => ({\n                                               context: dirContextExpr,\n                                               eventAst: hostEventAst,\n                                               dirAst,\n                                             }));\n\n    // Check index is the same as the node index during compilation\n    // They might only differ at runtime\n    const checkIndex = nodeIndex;\n\n    this.nodes[nodeIndex] = () => ({\n      sourceSpan: dirAst.sourceSpan,\n      nodeFlags: NodeFlags.TypeDirective | flags,\n      nodeDef: o.importExpr(Identifiers.directiveDef).callFn([\n        o.literal(checkIndex),\n        o.literal(flags),\n        queryMatchExprs.length ? o.literalArr(queryMatchExprs) : o.NULL_EXPR,\n        o.literal(childCount),\n        providerExpr,\n        depsExpr,\n        inputDefs.length ? new o.LiteralMapExpr(inputDefs) : o.NULL_EXPR,\n        outputDefs.length ? new o.LiteralMapExpr(outputDefs) : o.NULL_EXPR,\n      ]),\n      updateDirectives: updateDirectiveExpressions,\n      directive: dirAst.directive.type,\n    });\n\n    return {hostBindings, hostEvents};\n  }\n\n  private _visitProvider(providerAst: ProviderAst, queryMatches: QueryMatch[]): void {\n    this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\n  }\n\n  private _visitComponentFactoryResolverProvider(directives: DirectiveAst[]) {\n    const componentDirMeta = directives.find(dirAst => dirAst.directive.isComponent);\n    if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n      const {providerExpr, depsExpr, flags, tokenExpr} = componentFactoryResolverProviderDef(\n          this.reflector, this.outputCtx, NodeFlags.PrivateProvider,\n          componentDirMeta.directive.entryComponents);\n      this._addProviderNode({\n        providerExpr,\n        depsExpr,\n        flags,\n        tokenExpr,\n        queryMatchExprs: [],\n        sourceSpan: componentDirMeta.sourceSpan\n      });\n    }\n  }\n\n  private _addProviderNode(data: {\n    flags: NodeFlags,\n    queryMatchExprs: o.Expression[],\n    providerExpr: o.Expression,\n    depsExpr: o.Expression,\n    tokenExpr: o.Expression,\n    sourceSpan: ParseSourceSpan\n  }) {\n    // providerDef(\n    //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n    //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n    this.nodes.push(\n        () => ({\n          sourceSpan: data.sourceSpan,\n          nodeFlags: data.flags,\n          nodeDef: o.importExpr(Identifiers.providerDef).callFn([\n            o.literal(data.flags),\n            data.queryMatchExprs.length ? o.literalArr(data.queryMatchExprs) : o.NULL_EXPR,\n            data.tokenExpr, data.providerExpr, data.depsExpr\n          ])\n        }));\n  }\n\n  private _visitProviderOrDirective(providerAst: ProviderAst, queryMatches: QueryMatch[]): {\n    flags: NodeFlags,\n    tokenExpr: o.Expression,\n    sourceSpan: ParseSourceSpan,\n    queryMatchExprs: o.Expression[],\n    providerExpr: o.Expression,\n    depsExpr: o.Expression\n  } {\n    let flags = NodeFlags.None;\n    let queryMatchExprs: o.Expression[] = [];\n\n    queryMatches.forEach((match) => {\n      if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n        queryMatchExprs.push(\n            o.literalArr([o.literal(match.queryId), o.literal(QueryValueType.Provider)]));\n      }\n    });\n    const {providerExpr, depsExpr, flags: providerFlags, tokenExpr} =\n        providerDef(this.outputCtx, providerAst);\n    return {\n      flags: flags | providerFlags,\n      queryMatchExprs,\n      providerExpr,\n      depsExpr,\n      tokenExpr,\n      sourceSpan: providerAst.sourceSpan\n    };\n  }\n\n  getLocal(name: string): o.Expression|null {\n    if (name == EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    let currViewExpr: o.Expression = VIEW_VAR;\n    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent,\n                          currViewExpr = currViewExpr.prop('parent').cast(o.DYNAMIC_TYPE)) {\n      // check references\n      const refNodeIndex = currBuilder.refNodeIndices[name];\n      if (refNodeIndex != null) {\n        return o.importExpr(Identifiers.nodeValue).callFn([currViewExpr, o.literal(refNodeIndex)]);\n      }\n\n      // check variables\n      const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n      if (varAst) {\n        const varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n        return currViewExpr.prop('context').prop(varValue);\n      }\n    }\n    return null;\n  }\n\n  notifyImplicitReceiverUse(): void {\n    // Not needed in View Engine as View Engine walks through the generated\n    // expressions to figure out if the implicit receiver is used and needs\n    // to be generated as part of the pre-update statements.\n  }\n\n  private _createLiteralArrayConverter(sourceSpan: ParseSourceSpan, argCount: number):\n      BuiltinConverter {\n    if (argCount === 0) {\n      const valueExpr = o.importExpr(Identifiers.EMPTY_ARRAY);\n      return () => valueExpr;\n    }\n\n    const checkIndex = this.nodes.length;\n\n    this.nodes.push(() => ({\n                      sourceSpan,\n                      nodeFlags: NodeFlags.TypePureArray,\n                      nodeDef: o.importExpr(Identifiers.pureArrayDef).callFn([\n                        o.literal(checkIndex),\n                        o.literal(argCount),\n                      ])\n                    }));\n\n    return (args: o.Expression[]) => callCheckStmt(checkIndex, args);\n  }\n\n  private _createLiteralMapConverter(\n      sourceSpan: ParseSourceSpan, keys: {key: string, quoted: boolean}[]): BuiltinConverter {\n    if (keys.length === 0) {\n      const valueExpr = o.importExpr(Identifiers.EMPTY_MAP);\n      return () => valueExpr;\n    }\n\n    const map = o.literalMap(keys.map((e, i) => ({...e, value: o.literal(i)})));\n    const checkIndex = this.nodes.length;\n    this.nodes.push(() => ({\n                      sourceSpan,\n                      nodeFlags: NodeFlags.TypePureObject,\n                      nodeDef: o.importExpr(Identifiers.pureObjectDef).callFn([\n                        o.literal(checkIndex),\n                        map,\n                      ])\n                    }));\n\n    return (args: o.Expression[]) => callCheckStmt(checkIndex, args);\n  }\n\n  private _createPipeConverter(expression: UpdateExpression, name: string, argCount: number):\n      BuiltinConverter {\n    const pipe = this.usedPipes.find((pipeSummary) => pipeSummary.name === name)!;\n    if (pipe.pure) {\n      const checkIndex = this.nodes.length;\n      this.nodes.push(() => ({\n                        sourceSpan: expression.sourceSpan,\n                        nodeFlags: NodeFlags.TypePurePipe,\n                        nodeDef: o.importExpr(Identifiers.purePipeDef).callFn([\n                          o.literal(checkIndex),\n                          o.literal(argCount),\n                        ])\n                      }));\n\n      // find underlying pipe in the component view\n      let compViewExpr: o.Expression = VIEW_VAR;\n      let compBuilder: ViewBuilder = this;\n      while (compBuilder.parent) {\n        compBuilder = compBuilder.parent;\n        compViewExpr = compViewExpr.prop('parent').cast(o.DYNAMIC_TYPE);\n      }\n      const pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n      const pipeValueExpr: o.Expression =\n          o.importExpr(Identifiers.nodeValue).callFn([compViewExpr, o.literal(pipeNodeIndex)]);\n\n      return (args: o.Expression[]) => callUnwrapValue(\n                 expression.nodeIndex, expression.bindingIndex,\n                 callCheckStmt(checkIndex, [pipeValueExpr].concat(args)));\n    } else {\n      const nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n      const nodeValueExpr =\n          o.importExpr(Identifiers.nodeValue).callFn([VIEW_VAR, o.literal(nodeIndex)]);\n\n      return (args: o.Expression[]) => callUnwrapValue(\n                 expression.nodeIndex, expression.bindingIndex,\n                 nodeValueExpr.callMethod('transform', args));\n    }\n  }\n\n  private _createPipe(sourceSpan: ParseSourceSpan|null, pipe: CompilePipeSummary): number {\n    const nodeIndex = this.nodes.length;\n    let flags = NodeFlags.None;\n    pipe.type.lifecycleHooks.forEach((lifecycleHook) => {\n      // for pipes, we only support ngOnDestroy\n      if (lifecycleHook === LifecycleHooks.OnDestroy) {\n        flags |= lifecycleHookToNodeFlag(lifecycleHook);\n      }\n    });\n\n    const depExprs = pipe.type.diDeps.map((diDep) => depDef(this.outputCtx, diDep));\n    // function pipeDef(\n    //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n    this.nodes.push(\n        () => ({\n          sourceSpan,\n          nodeFlags: NodeFlags.TypePipe,\n          nodeDef: o.importExpr(Identifiers.pipeDef).callFn([\n            o.literal(flags), this.outputCtx.importExpr(pipe.type.reference), o.literalArr(depExprs)\n          ])\n        }));\n    return nodeIndex;\n  }\n\n  /**\n   * For the AST in `UpdateExpression.value`:\n   * - create nodes for pipes, literal arrays and, literal maps,\n   * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.\n   *\n   * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!\n   */\n  private _preprocessUpdateExpression(expression: UpdateExpression): UpdateExpression {\n    return {\n      nodeIndex: expression.nodeIndex,\n      bindingIndex: expression.bindingIndex,\n      sourceSpan: expression.sourceSpan,\n      context: expression.context,\n      value: convertPropertyBindingBuiltins(\n          {\n            createLiteralArrayConverter: (argCount: number) =>\n                this._createLiteralArrayConverter(expression.sourceSpan, argCount),\n            createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) =>\n                this._createLiteralMapConverter(expression.sourceSpan, keys),\n            createPipeConverter: (name: string, argCount: number) =>\n                this._createPipeConverter(expression, name, argCount)\n          },\n          expression.value)\n    };\n  }\n\n  private _createNodeExpressions(): {\n    updateRendererStmts: o.Statement[],\n    updateDirectivesStmts: o.Statement[],\n    nodeDefExprs: o.Expression[]\n  } {\n    const self = this;\n    let updateBindingCount = 0;\n    const updateRendererStmts: o.Statement[] = [];\n    const updateDirectivesStmts: o.Statement[] = [];\n    const nodeDefExprs = this.nodes.map((factory, nodeIndex) => {\n      const {nodeDef, nodeFlags, updateDirectives, updateRenderer, sourceSpan} = factory();\n      if (updateRenderer) {\n        updateRendererStmts.push(\n            ...createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));\n      }\n      if (updateDirectives) {\n        updateDirectivesStmts.push(...createUpdateStatements(\n            nodeIndex, sourceSpan, updateDirectives,\n            (nodeFlags & (NodeFlags.DoCheck | NodeFlags.OnInit)) > 0));\n      }\n      // We use a comma expression to call the log function before\n      // the nodeDef function, but still use the result of the nodeDef function\n      // as the value.\n      // Note: We only add the logger to elements / text nodes,\n      // so we don't generate too much code.\n      const logWithNodeDef = nodeFlags & NodeFlags.CatRenderNode ?\n          new o.CommaExpr([LOG_VAR.callFn([]).callFn([]), nodeDef]) :\n          nodeDef;\n      return o.applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n    });\n    return {updateRendererStmts, updateDirectivesStmts, nodeDefExprs};\n\n    function createUpdateStatements(\n        nodeIndex: number, sourceSpan: ParseSourceSpan|null, expressions: UpdateExpression[],\n        allowEmptyExprs: boolean): o.Statement[] {\n      const updateStmts: o.Statement[] = [];\n      const exprs = expressions.map(({sourceSpan, context, value}) => {\n        const bindingId = `${updateBindingCount++}`;\n        const nameResolver = context === COMP_VAR ? self : null;\n        const {stmts, currValExpr} =\n            convertPropertyBinding(nameResolver, context, value, bindingId, BindingForm.General);\n        updateStmts.push(...stmts.map(\n            (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n        return o.applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n      });\n      if (expressions.length || allowEmptyExprs) {\n        updateStmts.push(o.applySourceSpanToStatementIfNeeded(\n            callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n      }\n      return updateStmts;\n    }\n  }\n\n  private _createElementHandleEventFn(\n      nodeIndex: number,\n      handlers: {context: o.Expression, eventAst: BoundEventAst, dirAst: DirectiveAst}[]) {\n    const handleEventStmts: o.Statement[] = [];\n    let handleEventBindingCount = 0;\n    handlers.forEach(({context, eventAst, dirAst}) => {\n      const bindingId = `${handleEventBindingCount++}`;\n      const nameResolver = context === COMP_VAR ? this : null;\n      const {stmts, allowDefault} =\n          convertActionBinding(nameResolver, context, eventAst.handler, bindingId);\n      const trueStmts = stmts;\n      if (allowDefault) {\n        trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n      }\n      const {target: eventTarget, name: eventName} = elementEventNameAndTarget(eventAst, dirAst);\n      const fullEventName = elementEventFullName(eventTarget, eventName);\n      handleEventStmts.push(o.applySourceSpanToStatementIfNeeded(\n          new o.IfStmt(o.literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts),\n          eventAst.sourceSpan));\n    });\n    let handleEventFn: o.Expression;\n    if (handleEventStmts.length > 0) {\n      const preStmts: o.Statement[] =\n          [ALLOW_DEFAULT_VAR.set(o.literal(true)).toDeclStmt(o.BOOL_TYPE)];\n      if (!this.component.isHost && o.findReadVarNames(handleEventStmts).has(COMP_VAR.name!)) {\n        preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n      }\n      handleEventFn = o.fn(\n          [\n            new o.FnParam(VIEW_VAR.name!, o.INFERRED_TYPE),\n            new o.FnParam(EVENT_NAME_VAR.name!, o.INFERRED_TYPE),\n            new o.FnParam(EventHandlerVars.event.name!, o.INFERRED_TYPE)\n          ],\n          [...preStmts, ...handleEventStmts, new o.ReturnStatement(ALLOW_DEFAULT_VAR)],\n          o.INFERRED_TYPE);\n    } else {\n      handleEventFn = o.NULL_EXPR;\n    }\n    return handleEventFn;\n  }\n\n  visitDirective(ast: DirectiveAst, context: {usedEvents: Set<string>}): any {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n  visitReference(ast: ReferenceAst, context: any): any {}\n  visitVariable(ast: VariableAst, context: any): any {}\n  visitEvent(ast: BoundEventAst, context: any): any {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n  visitAttr(ast: AttrAst, context: any): any {}\n}\n\nfunction needsAdditionalRootNode(astNodes: TemplateAst[]): boolean {\n  const lastAstNode = astNodes[astNodes.length - 1];\n  if (lastAstNode instanceof EmbeddedTemplateAst) {\n    return lastAstNode.hasViewContainer;\n  }\n\n  if (lastAstNode instanceof ElementAst) {\n    if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n      return needsAdditionalRootNode(lastAstNode.children);\n    }\n    return lastAstNode.hasViewContainer;\n  }\n\n  return lastAstNode instanceof NgContentAst;\n}\n\n\nfunction elementBindingDef(inputAst: BoundElementPropertyAst, dirAst: DirectiveAst): o.Expression {\n  const inputType = inputAst.type;\n  switch (inputType) {\n    case PropertyBindingType.Attribute:\n      return o.literalArr([\n        o.literal(BindingFlags.TypeElementAttribute), o.literal(inputAst.name),\n        o.literal(inputAst.securityContext)\n      ]);\n    case PropertyBindingType.Property:\n      return o.literalArr([\n        o.literal(BindingFlags.TypeProperty), o.literal(inputAst.name),\n        o.literal(inputAst.securityContext)\n      ]);\n    case PropertyBindingType.Animation:\n      const bindingType = BindingFlags.TypeProperty |\n          (dirAst && dirAst.directive.isComponent ? BindingFlags.SyntheticHostProperty :\n                                                    BindingFlags.SyntheticProperty);\n      return o.literalArr([\n        o.literal(bindingType), o.literal('@' + inputAst.name), o.literal(inputAst.securityContext)\n      ]);\n    case PropertyBindingType.Class:\n      return o.literalArr(\n          [o.literal(BindingFlags.TypeElementClass), o.literal(inputAst.name), o.NULL_EXPR]);\n    case PropertyBindingType.Style:\n      return o.literalArr([\n        o.literal(BindingFlags.TypeElementStyle), o.literal(inputAst.name), o.literal(inputAst.unit)\n      ]);\n    default:\n      // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n      // However Closure Compiler does not understand that and reports an error in typed mode.\n      // The `throw new Error` below works around the problem, and the unexpected: never variable\n      // makes sure tsc still checks this code is unreachable.\n      const unexpected: never = inputType;\n      throw new Error(`unexpected ${unexpected}`);\n  }\n}\n\n\nfunction fixedAttrsDef(elementAst: ElementAst): o.Expression {\n  const mapResult: {[key: string]: string} = Object.create(null);\n  elementAst.attrs.forEach(attrAst => {\n    mapResult[attrAst.name] = attrAst.value;\n  });\n  elementAst.directives.forEach(dirAst => {\n    Object.keys(dirAst.directive.hostAttributes).forEach(name => {\n      const value = dirAst.directive.hostAttributes[name];\n      const prevValue = mapResult[name];\n      mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n    });\n  });\n  // Note: We need to sort to get a defined output order\n  // for tests and for caching generated artifacts...\n  return o.literalArr(Object.keys(mapResult).sort().map(\n      (attrName) => o.literalArr([o.literal(attrName), o.literal(mapResult[attrName])])));\n}\n\nfunction mergeAttributeValue(attrName: string, attrValue1: string, attrValue2: string): string {\n  if (attrName == CLASS_ATTR || attrName == STYLE_ATTR) {\n    return `${attrValue1} ${attrValue2}`;\n  } else {\n    return attrValue2;\n  }\n}\n\nfunction callCheckStmt(nodeIndex: number, exprs: o.Expression[]): o.Expression {\n  if (exprs.length > 10) {\n    return CHECK_VAR.callFn(\n        [VIEW_VAR, o.literal(nodeIndex), o.literal(ArgumentType.Dynamic), o.literalArr(exprs)]);\n  } else {\n    return CHECK_VAR.callFn(\n        [VIEW_VAR, o.literal(nodeIndex), o.literal(ArgumentType.Inline), ...exprs]);\n  }\n}\n\nfunction callUnwrapValue(nodeIndex: number, bindingIdx: number, expr: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.unwrapValue).callFn([\n    VIEW_VAR, o.literal(nodeIndex), o.literal(bindingIdx), expr\n  ]);\n}\n\nfunction elementEventNameAndTarget(\n    eventAst: BoundEventAst, dirAst: DirectiveAst|null): {name: string, target: string|null} {\n  if (eventAst.isAnimation) {\n    return {\n      name: `@${eventAst.name}.${eventAst.phase}`,\n      target: dirAst && dirAst.directive.isComponent ? 'component' : null\n    };\n  } else {\n    return eventAst;\n  }\n}\n\nfunction calcQueryFlags(query: CompileQueryMetadata) {\n  let flags = NodeFlags.None;\n  // Note: We only make queries static that query for a single item and the user specifically\n  // set the to be static. This is because of backwards compatibility with the old view compiler...\n  if (query.first && query.static) {\n    flags |= NodeFlags.StaticQuery;\n  } else {\n    flags |= NodeFlags.DynamicQuery;\n  }\n  if (query.emitDistinctChangesOnly) {\n    flags |= NodeFlags.EmitDistinctChangesOnly;\n  }\n  return flags;\n}\n\nexport function elementEventFullName(target: string|null, name: string): string {\n  return target ? `${target}:${name}` : name;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}