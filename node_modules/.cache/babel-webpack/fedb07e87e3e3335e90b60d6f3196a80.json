{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleActionCache = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar cacache = require(\"cacache\");\n\nvar crypto_1 = require(\"crypto\");\n\nvar fs = require(\"fs\");\n\nvar copy_file_1 = require(\"./copy-file\");\n\nvar environment_options_1 = require(\"./environment-options\");\n\nvar packageVersion = require('../../package.json').version;\n\nvar BundleActionCache = /*#__PURE__*/function () {\n  function BundleActionCache(cachePath, integrityAlgorithm) {\n    _classCallCheck(this, BundleActionCache);\n\n    this.cachePath = cachePath;\n    this.integrityAlgorithm = integrityAlgorithm;\n  }\n\n  _createClass(BundleActionCache, [{\n    key: \"generateIntegrityValue\",\n    value: function generateIntegrityValue(content) {\n      var algorithm = this.integrityAlgorithm || 'sha1';\n      var codeHash = crypto_1.createHash(algorithm).update(content).digest('base64');\n      return \"\".concat(algorithm, \"-\").concat(codeHash);\n    }\n  }, {\n    key: \"generateBaseCacheKey\",\n    value: function generateBaseCacheKey(content) {\n      // Create base cache key with elements:\n      // * package version - different build-angular versions cause different final outputs\n      // * code length/hash - ensure cached version matches the same input code\n      var integrity = this.generateIntegrityValue(content);\n      var baseCacheKey = \"\".concat(packageVersion, \"|\").concat(content.length, \"|\").concat(integrity);\n\n      if (!environment_options_1.allowMangle) {\n        baseCacheKey += '|MD';\n      }\n\n      return baseCacheKey;\n    }\n  }, {\n    key: \"generateCacheKeys\",\n    value: function generateCacheKeys(action) {\n      // Postfix added to sourcemap cache keys when vendor, hidden sourcemaps are present\n      // Allows non-destructive caching of both variants\n      var sourceMapVendorPostfix = action.sourceMaps && action.vendorSourceMaps ? '|vendor' : ''; // sourceMappingURL is added at the very end which causes the code to be the same when sourcemaps are enabled/disabled\n      // When using hiddenSourceMaps we can omit the postfix since sourceMappingURL will not be added.\n      // When having sourcemaps a hashed file and non hashed file can have the same content. But the sourceMappingURL will differ.\n\n      var sourceMapPostFix = action.sourceMaps && !action.hiddenSourceMaps ? \"|sourcemap|\".concat(action.filename) : '';\n      var baseCacheKey = this.generateBaseCacheKey(action.code); // Determine cache entries required based on build settings\n\n      var cacheKeys = []; // If optimizing and the original is not ignored, add original as required\n\n      if (!action.ignoreOriginal) {\n        cacheKeys[0\n        /* OriginalCode */\n        ] = baseCacheKey + sourceMapPostFix + '|orig'; // If sourcemaps are enabled, add original sourcemap as required\n\n        if (action.sourceMaps) {\n          cacheKeys[1\n          /* OriginalMap */\n          ] = baseCacheKey + sourceMapVendorPostfix + '|orig-map';\n        }\n      } // If not only optimizing, add downlevel as required\n\n\n      if (!action.optimizeOnly) {\n        cacheKeys[2\n        /* DownlevelCode */\n        ] = baseCacheKey + sourceMapPostFix + '|dl'; // If sourcemaps are enabled, add downlevel sourcemap as required\n\n        if (action.sourceMaps) {\n          cacheKeys[3\n          /* DownlevelMap */\n          ] = baseCacheKey + sourceMapVendorPostfix + '|dl-map';\n        }\n      }\n\n      return cacheKeys;\n    }\n  }, {\n    key: \"getCacheEntries\",\n    value: function () {\n      var _getCacheEntries = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cacheKeys) {\n        var cacheEntries, _iterator, _step, key, entry;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Attempt to get required cache entries\n                cacheEntries = [];\n                _iterator = _createForOfIteratorHelper(cacheKeys);\n                _context.prev = 2;\n\n                _iterator.s();\n\n              case 4:\n                if ((_step = _iterator.n()).done) {\n                  _context.next = 18;\n                  break;\n                }\n\n                key = _step.value;\n\n                if (!key) {\n                  _context.next = 15;\n                  break;\n                }\n\n                _context.next = 9;\n                return cacache.get.info(this.cachePath, key);\n\n              case 9:\n                entry = _context.sent;\n\n                if (entry) {\n                  _context.next = 12;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", false);\n\n              case 12:\n                cacheEntries.push({\n                  path: entry.path,\n                  // tslint:disable-next-line: no-any\n                  size: entry.size,\n                  integrity: entry.metadata && entry.metadata.integrity\n                });\n                _context.next = 16;\n                break;\n\n              case 15:\n                cacheEntries.push(null);\n\n              case 16:\n                _context.next = 4;\n                break;\n\n              case 18:\n                _context.next = 23;\n                break;\n\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context[\"catch\"](2);\n\n                _iterator.e(_context.t0);\n\n              case 23:\n                _context.prev = 23;\n\n                _iterator.f();\n\n                return _context.finish(23);\n\n              case 26:\n                return _context.abrupt(\"return\", cacheEntries);\n\n              case 27:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[2, 20, 23, 26]]);\n      }));\n\n      function getCacheEntries(_x) {\n        return _getCacheEntries.apply(this, arguments);\n      }\n\n      return getCacheEntries;\n    }()\n  }, {\n    key: \"getCachedBundleResult\",\n    value: function () {\n      var _getCachedBundleResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(action) {\n        var entries, result, cacheEntry;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = action.cacheKeys;\n\n                if (!_context2.t0) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return this.getCacheEntries(action.cacheKeys);\n\n              case 4:\n                _context2.t0 = _context2.sent;\n\n              case 5:\n                entries = _context2.t0;\n\n                if (entries) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", null);\n\n              case 8:\n                result = {\n                  name: action.name,\n                  integrity: this.generateIntegrityValue(action.code)\n                };\n                cacheEntry = entries[0\n                /* OriginalCode */\n                ];\n\n                if (cacheEntry) {\n                  result.original = {\n                    filename: action.filename,\n                    size: cacheEntry.size,\n                    integrity: cacheEntry.integrity\n                  };\n                  BundleActionCache.copyEntryContent(cacheEntry, result.original.filename);\n                  cacheEntry = entries[1\n                  /* OriginalMap */\n                  ];\n\n                  if (cacheEntry) {\n                    result.original.map = {\n                      filename: action.filename + '.map',\n                      size: cacheEntry.size\n                    };\n                    BundleActionCache.copyEntryContent(cacheEntry, result.original.filename + '.map');\n                  }\n                } else if (!action.ignoreOriginal) {\n                  // If the original wasn't processed (and therefore not cached), add info\n                  result.original = {\n                    filename: action.filename,\n                    size: Buffer.byteLength(action.code, 'utf8'),\n                    map: action.map === undefined ? undefined : {\n                      filename: action.filename + '.map',\n                      size: Buffer.byteLength(action.map, 'utf8')\n                    }\n                  };\n                }\n\n                cacheEntry = entries[2\n                /* DownlevelCode */\n                ];\n\n                if (cacheEntry) {\n                  result.downlevel = {\n                    filename: action.filename.replace(/\\-(es20\\d{2}|esnext)/, '-es5'),\n                    size: cacheEntry.size,\n                    integrity: cacheEntry.integrity\n                  };\n                  BundleActionCache.copyEntryContent(cacheEntry, result.downlevel.filename);\n                  cacheEntry = entries[3\n                  /* DownlevelMap */\n                  ];\n\n                  if (cacheEntry) {\n                    result.downlevel.map = {\n                      filename: action.filename.replace(/\\-(es20\\d{2}|esnext)/, '-es5') + '.map',\n                      size: cacheEntry.size\n                    };\n                    BundleActionCache.copyEntryContent(cacheEntry, result.downlevel.filename + '.map');\n                  }\n                }\n\n                return _context2.abrupt(\"return\", result);\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getCachedBundleResult(_x2) {\n        return _getCachedBundleResult.apply(this, arguments);\n      }\n\n      return getCachedBundleResult;\n    }()\n  }], [{\n    key: \"copyEntryContent\",\n    value: function copyEntryContent(entry, dest) {\n      copy_file_1.copyFile(typeof entry === 'string' ? entry : entry.path, dest);\n\n      if (process.platform !== 'win32') {\n        // The cache writes entries as readonly and when using copyFile the permissions will also be copied.\n        // See: https://github.com/npm/cacache/blob/073fbe1a9f789ba42d9a41de7b8429c93cf61579/lib/util/move-file.js#L36\n        fs.chmodSync(dest, 420);\n      }\n    }\n  }]);\n\n  return BundleActionCache;\n}();\n\nexports.BundleActionCache = BundleActionCache;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/src/utils/action-cache.js"],"names":["Object","defineProperty","exports","value","BundleActionCache","cacache","require","crypto_1","fs","copy_file_1","environment_options_1","packageVersion","version","cachePath","integrityAlgorithm","content","algorithm","codeHash","createHash","update","digest","integrity","generateIntegrityValue","baseCacheKey","length","allowMangle","action","sourceMapVendorPostfix","sourceMaps","vendorSourceMaps","sourceMapPostFix","hiddenSourceMaps","filename","generateBaseCacheKey","code","cacheKeys","ignoreOriginal","optimizeOnly","cacheEntries","key","get","info","entry","push","path","size","metadata","getCacheEntries","entries","result","name","cacheEntry","original","copyEntryContent","map","Buffer","byteLength","undefined","downlevel","replace","dest","copyFile","process","platform","chmodSync"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BundleActionCache = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst cacache = require(\"cacache\");\nconst crypto_1 = require(\"crypto\");\nconst fs = require(\"fs\");\nconst copy_file_1 = require(\"./copy-file\");\nconst environment_options_1 = require(\"./environment-options\");\nconst packageVersion = require('../../package.json').version;\nclass BundleActionCache {\n    constructor(cachePath, integrityAlgorithm) {\n        this.cachePath = cachePath;\n        this.integrityAlgorithm = integrityAlgorithm;\n    }\n    static copyEntryContent(entry, dest) {\n        copy_file_1.copyFile(typeof entry === 'string' ? entry : entry.path, dest);\n        if (process.platform !== 'win32') {\n            // The cache writes entries as readonly and when using copyFile the permissions will also be copied.\n            // See: https://github.com/npm/cacache/blob/073fbe1a9f789ba42d9a41de7b8429c93cf61579/lib/util/move-file.js#L36\n            fs.chmodSync(dest, 0o644);\n        }\n    }\n    generateIntegrityValue(content) {\n        const algorithm = this.integrityAlgorithm || 'sha1';\n        const codeHash = crypto_1.createHash(algorithm)\n            .update(content)\n            .digest('base64');\n        return `${algorithm}-${codeHash}`;\n    }\n    generateBaseCacheKey(content) {\n        // Create base cache key with elements:\n        // * package version - different build-angular versions cause different final outputs\n        // * code length/hash - ensure cached version matches the same input code\n        const integrity = this.generateIntegrityValue(content);\n        let baseCacheKey = `${packageVersion}|${content.length}|${integrity}`;\n        if (!environment_options_1.allowMangle) {\n            baseCacheKey += '|MD';\n        }\n        return baseCacheKey;\n    }\n    generateCacheKeys(action) {\n        // Postfix added to sourcemap cache keys when vendor, hidden sourcemaps are present\n        // Allows non-destructive caching of both variants\n        const sourceMapVendorPostfix = action.sourceMaps && action.vendorSourceMaps ? '|vendor' : '';\n        // sourceMappingURL is added at the very end which causes the code to be the same when sourcemaps are enabled/disabled\n        // When using hiddenSourceMaps we can omit the postfix since sourceMappingURL will not be added.\n        // When having sourcemaps a hashed file and non hashed file can have the same content. But the sourceMappingURL will differ.\n        const sourceMapPostFix = action.sourceMaps && !action.hiddenSourceMaps ? `|sourcemap|${action.filename}` : '';\n        const baseCacheKey = this.generateBaseCacheKey(action.code);\n        // Determine cache entries required based on build settings\n        const cacheKeys = [];\n        // If optimizing and the original is not ignored, add original as required\n        if (!action.ignoreOriginal) {\n            cacheKeys[0 /* OriginalCode */] = baseCacheKey + sourceMapPostFix + '|orig';\n            // If sourcemaps are enabled, add original sourcemap as required\n            if (action.sourceMaps) {\n                cacheKeys[1 /* OriginalMap */] = baseCacheKey + sourceMapVendorPostfix + '|orig-map';\n            }\n        }\n        // If not only optimizing, add downlevel as required\n        if (!action.optimizeOnly) {\n            cacheKeys[2 /* DownlevelCode */] = baseCacheKey + sourceMapPostFix + '|dl';\n            // If sourcemaps are enabled, add downlevel sourcemap as required\n            if (action.sourceMaps) {\n                cacheKeys[3 /* DownlevelMap */] = baseCacheKey + sourceMapVendorPostfix + '|dl-map';\n            }\n        }\n        return cacheKeys;\n    }\n    async getCacheEntries(cacheKeys) {\n        // Attempt to get required cache entries\n        const cacheEntries = [];\n        for (const key of cacheKeys) {\n            if (key) {\n                const entry = await cacache.get.info(this.cachePath, key);\n                if (!entry) {\n                    return false;\n                }\n                cacheEntries.push({\n                    path: entry.path,\n                    // tslint:disable-next-line: no-any\n                    size: entry.size,\n                    integrity: entry.metadata && entry.metadata.integrity,\n                });\n            }\n            else {\n                cacheEntries.push(null);\n            }\n        }\n        return cacheEntries;\n    }\n    async getCachedBundleResult(action) {\n        const entries = action.cacheKeys && await this.getCacheEntries(action.cacheKeys);\n        if (!entries) {\n            return null;\n        }\n        const result = {\n            name: action.name,\n            integrity: this.generateIntegrityValue(action.code),\n        };\n        let cacheEntry = entries[0 /* OriginalCode */];\n        if (cacheEntry) {\n            result.original = {\n                filename: action.filename,\n                size: cacheEntry.size,\n                integrity: cacheEntry.integrity,\n            };\n            BundleActionCache.copyEntryContent(cacheEntry, result.original.filename);\n            cacheEntry = entries[1 /* OriginalMap */];\n            if (cacheEntry) {\n                result.original.map = {\n                    filename: action.filename + '.map',\n                    size: cacheEntry.size,\n                };\n                BundleActionCache.copyEntryContent(cacheEntry, result.original.filename + '.map');\n            }\n        }\n        else if (!action.ignoreOriginal) {\n            // If the original wasn't processed (and therefore not cached), add info\n            result.original = {\n                filename: action.filename,\n                size: Buffer.byteLength(action.code, 'utf8'),\n                map: action.map === undefined\n                    ? undefined\n                    : {\n                        filename: action.filename + '.map',\n                        size: Buffer.byteLength(action.map, 'utf8'),\n                    },\n            };\n        }\n        cacheEntry = entries[2 /* DownlevelCode */];\n        if (cacheEntry) {\n            result.downlevel = {\n                filename: action.filename.replace(/\\-(es20\\d{2}|esnext)/, '-es5'),\n                size: cacheEntry.size,\n                integrity: cacheEntry.integrity,\n            };\n            BundleActionCache.copyEntryContent(cacheEntry, result.downlevel.filename);\n            cacheEntry = entries[3 /* DownlevelMap */];\n            if (cacheEntry) {\n                result.downlevel.map = {\n                    filename: action.filename.replace(/\\-(es20\\d{2}|esnext)/, '-es5') + '.map',\n                    size: cacheEntry.size,\n                };\n                BundleActionCache.copyEntryContent(cacheEntry, result.downlevel.filename + '.map');\n            }\n        }\n        return result;\n    }\n}\nexports.BundleActionCache = BundleActionCache;\n"]},"metadata":{},"sourceType":"script"}