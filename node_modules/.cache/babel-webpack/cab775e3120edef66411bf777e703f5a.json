{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_emitter\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeParameterEmitter = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var type_emitter_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_emitter\");\n  /**\n   * See `TypeEmitter` for more information on the emitting process.\n   */\n\n\n  var TypeParameterEmitter =\n  /** @class */\n  function () {\n    function TypeParameterEmitter(typeParameters, reflector) {\n      this.typeParameters = typeParameters;\n      this.reflector = reflector;\n    }\n    /**\n     * Determines whether the type parameters can be emitted. If this returns true, then a call to\n     * `emit` is known to succeed. Vice versa, if false is returned then `emit` should not be\n     * called, as it would fail.\n     */\n\n\n    TypeParameterEmitter.prototype.canEmit = function () {\n      var _this = this;\n\n      if (this.typeParameters === undefined) {\n        return true;\n      }\n\n      return this.typeParameters.every(function (typeParam) {\n        if (typeParam.constraint === undefined) {\n          return true;\n        }\n\n        return type_emitter_1.canEmitType(typeParam.constraint, function (type) {\n          return _this.resolveTypeReference(type);\n        });\n      });\n    };\n    /**\n     * Emits the type parameters using the provided emitter function for `Reference`s.\n     */\n\n\n    TypeParameterEmitter.prototype.emit = function (emitReference) {\n      var _this = this;\n\n      if (this.typeParameters === undefined) {\n        return undefined;\n      }\n\n      var emitter = new type_emitter_1.TypeEmitter(function (type) {\n        return _this.resolveTypeReference(type);\n      }, emitReference);\n      return this.typeParameters.map(function (typeParam) {\n        var constraint = typeParam.constraint !== undefined ? emitter.emitType(typeParam.constraint) : undefined;\n        return ts.updateTypeParameterDeclaration(\n        /* node */\n        typeParam,\n        /* name */\n        typeParam.name,\n        /* constraint */\n        constraint,\n        /* defaultType */\n        typeParam.default);\n      });\n    };\n\n    TypeParameterEmitter.prototype.resolveTypeReference = function (type) {\n      var target = ts.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;\n      var declaration = this.reflector.getDeclarationOfIdentifier(target); // If no declaration could be resolved or does not have a `ts.Declaration`, the type cannot be\n      // resolved.\n\n      if (declaration === null || declaration.node === null) {\n        return null;\n      } // If the declaration corresponds with a local type parameter, the type reference can be used\n      // as is.\n\n\n      if (this.isLocalTypeParameter(declaration.node)) {\n        return type;\n      }\n\n      var owningModule = null;\n\n      if (declaration.viaModule !== null) {\n        owningModule = {\n          specifier: declaration.viaModule,\n          resolutionContext: type.getSourceFile().fileName\n        };\n      }\n\n      return new imports_1.Reference(declaration.node, owningModule);\n    };\n\n    TypeParameterEmitter.prototype.isLocalTypeParameter = function (decl) {\n      // Checking for local type parameters only occurs during resolution of type parameters, so it is\n      // guaranteed that type parameters are present.\n      return this.typeParameters.some(function (param) {\n        return param === decl;\n      });\n    };\n\n    return TypeParameterEmitter;\n  }();\n\n  exports.TypeParameterEmitter = TypeParameterEmitter;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {OwningModule, Reference} from '../../imports';\nimport {DeclarationNode, ReflectionHost} from '../../reflection';\n\nimport {canEmitType, ResolvedTypeReference, TypeEmitter} from './type_emitter';\n\n\n/**\n * See `TypeEmitter` for more information on the emitting process.\n */\nexport class TypeParameterEmitter {\n  constructor(\n      private typeParameters: ts.NodeArray<ts.TypeParameterDeclaration>|undefined,\n      private reflector: ReflectionHost) {}\n\n  /**\n   * Determines whether the type parameters can be emitted. If this returns true, then a call to\n   * `emit` is known to succeed. Vice versa, if false is returned then `emit` should not be\n   * called, as it would fail.\n   */\n  canEmit(): boolean {\n    if (this.typeParameters === undefined) {\n      return true;\n    }\n\n    return this.typeParameters.every(typeParam => {\n      if (typeParam.constraint === undefined) {\n        return true;\n      }\n\n      return canEmitType(typeParam.constraint, type => this.resolveTypeReference(type));\n    });\n  }\n\n  /**\n   * Emits the type parameters using the provided emitter function for `Reference`s.\n   */\n  emit(emitReference: (ref: Reference) => ts.TypeNode): ts.TypeParameterDeclaration[]|undefined {\n    if (this.typeParameters === undefined) {\n      return undefined;\n    }\n\n    const emitter = new TypeEmitter(type => this.resolveTypeReference(type), emitReference);\n\n    return this.typeParameters.map(typeParam => {\n      const constraint =\n          typeParam.constraint !== undefined ? emitter.emitType(typeParam.constraint) : undefined;\n\n      return ts.updateTypeParameterDeclaration(\n          /* node */ typeParam,\n          /* name */ typeParam.name,\n          /* constraint */ constraint,\n          /* defaultType */ typeParam.default);\n    });\n  }\n\n  private resolveTypeReference(type: ts.TypeReferenceNode): ResolvedTypeReference {\n    const target = ts.isIdentifier(type.typeName) ? type.typeName : type.typeName.right;\n    const declaration = this.reflector.getDeclarationOfIdentifier(target);\n\n    // If no declaration could be resolved or does not have a `ts.Declaration`, the type cannot be\n    // resolved.\n    if (declaration === null || declaration.node === null) {\n      return null;\n    }\n\n    // If the declaration corresponds with a local type parameter, the type reference can be used\n    // as is.\n    if (this.isLocalTypeParameter(declaration.node)) {\n      return type;\n    }\n\n    let owningModule: OwningModule|null = null;\n    if (declaration.viaModule !== null) {\n      owningModule = {\n        specifier: declaration.viaModule,\n        resolutionContext: type.getSourceFile().fileName,\n      };\n    }\n\n    return new Reference(declaration.node, owningModule);\n  }\n\n  private isLocalTypeParameter(decl: DeclarationNode): boolean {\n    // Checking for local type parameters only occurs during resolution of type parameters, so it is\n    // guaranteed that type parameters are present.\n    return this.typeParameters!.some(param => param === decl);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}