{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/aot/summary_resolver\", [\"require\", \"exports\", \"@angular/compiler/src/aot/summary_serializer\", \"@angular/compiler/src/aot/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.AotSummaryResolver = void 0;\n\n  var summary_serializer_1 = require(\"@angular/compiler/src/aot/summary_serializer\");\n\n  var util_1 = require(\"@angular/compiler/src/aot/util\");\n\n  var AotSummaryResolver =\n  /** @class */\n  function () {\n    function AotSummaryResolver(host, staticSymbolCache) {\n      this.host = host;\n      this.staticSymbolCache = staticSymbolCache; // Note: this will only contain StaticSymbols without members!\n\n      this.summaryCache = new Map();\n      this.loadedFilePaths = new Map(); // Note: this will only contain StaticSymbols without members!\n\n      this.importAs = new Map();\n      this.knownFileNameToModuleNames = new Map();\n    }\n\n    AotSummaryResolver.prototype.isLibraryFile = function (filePath) {\n      // Note: We need to strip the .ngfactory. file path,\n      // so this method also works for generated files\n      // (for which host.isSourceFile will always return false).\n      return !this.host.isSourceFile(util_1.stripGeneratedFileSuffix(filePath));\n    };\n\n    AotSummaryResolver.prototype.toSummaryFileName = function (filePath, referringSrcFileName) {\n      return this.host.toSummaryFileName(filePath, referringSrcFileName);\n    };\n\n    AotSummaryResolver.prototype.fromSummaryFileName = function (fileName, referringLibFileName) {\n      return this.host.fromSummaryFileName(fileName, referringLibFileName);\n    };\n\n    AotSummaryResolver.prototype.resolveSummary = function (staticSymbol) {\n      var rootSymbol = staticSymbol.members.length ? this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) : staticSymbol;\n      var summary = this.summaryCache.get(rootSymbol);\n\n      if (!summary) {\n        this._loadSummaryFile(staticSymbol.filePath);\n\n        summary = this.summaryCache.get(staticSymbol);\n      }\n\n      return rootSymbol === staticSymbol && summary || null;\n    };\n\n    AotSummaryResolver.prototype.getSymbolsOf = function (filePath) {\n      if (this._loadSummaryFile(filePath)) {\n        return Array.from(this.summaryCache.keys()).filter(function (symbol) {\n          return symbol.filePath === filePath;\n        });\n      }\n\n      return null;\n    };\n\n    AotSummaryResolver.prototype.getImportAs = function (staticSymbol) {\n      staticSymbol.assertNoMembers();\n      return this.importAs.get(staticSymbol);\n    };\n    /**\n     * Converts a file path to a module name that can be used as an `import`.\n     */\n\n\n    AotSummaryResolver.prototype.getKnownModuleName = function (importedFilePath) {\n      return this.knownFileNameToModuleNames.get(importedFilePath) || null;\n    };\n\n    AotSummaryResolver.prototype.addSummary = function (summary) {\n      this.summaryCache.set(summary.symbol, summary);\n    };\n\n    AotSummaryResolver.prototype._loadSummaryFile = function (filePath) {\n      var _this = this;\n\n      var hasSummary = this.loadedFilePaths.get(filePath);\n\n      if (hasSummary != null) {\n        return hasSummary;\n      }\n\n      var json = null;\n\n      if (this.isLibraryFile(filePath)) {\n        var summaryFilePath = util_1.summaryFileName(filePath);\n\n        try {\n          json = this.host.loadSummary(summaryFilePath);\n        } catch (e) {\n          console.error(\"Error loading summary file \" + summaryFilePath);\n          throw e;\n        }\n      }\n\n      hasSummary = json != null;\n      this.loadedFilePaths.set(filePath, hasSummary);\n\n      if (json) {\n        var _a = summary_serializer_1.deserializeSummaries(this.staticSymbolCache, this, filePath, json),\n            moduleName = _a.moduleName,\n            summaries = _a.summaries,\n            importAs = _a.importAs;\n\n        summaries.forEach(function (summary) {\n          return _this.summaryCache.set(summary.symbol, summary);\n        });\n\n        if (moduleName) {\n          this.knownFileNameToModuleNames.set(filePath, moduleName);\n        }\n\n        importAs.forEach(function (importAs) {\n          _this.importAs.set(importAs.symbol, importAs.importAs);\n        });\n      }\n\n      return hasSummary;\n    };\n\n    return AotSummaryResolver;\n  }();\n\n  exports.AotSummaryResolver = AotSummaryResolver;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/summary_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Summary, SummaryResolver} from '../summary_resolver';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {deserializeSummaries} from './summary_serializer';\nimport {stripGeneratedFileSuffix, summaryFileName} from './util';\n\nexport interface AotSummaryResolverHost {\n  /**\n   * Loads an NgModule/Directive/Pipe summary file\n   */\n  loadSummary(filePath: string): string|null;\n\n  /**\n   * Returns whether a file is a source file or not.\n   */\n  isSourceFile(sourceFilePath: string): boolean;\n  /**\n   * Converts a file name into a representation that should be stored in a summary file.\n   * This has to include changing the suffix as well.\n   * E.g.\n   * `some_file.ts` -> `some_file.d.ts`\n   *\n   * @param referringSrcFileName the soure file that refers to fileName\n   */\n  toSummaryFileName(fileName: string, referringSrcFileName: string): string;\n\n  /**\n   * Converts a fileName that was processed by `toSummaryFileName` back into a real fileName\n   * given the fileName of the library that is referrig to it.\n   */\n  fromSummaryFileName(fileName: string, referringLibFileName: string): string;\n}\n\nexport class AotSummaryResolver implements SummaryResolver<StaticSymbol> {\n  // Note: this will only contain StaticSymbols without members!\n  private summaryCache = new Map<StaticSymbol, Summary<StaticSymbol>>();\n  private loadedFilePaths = new Map<string, boolean>();\n  // Note: this will only contain StaticSymbols without members!\n  private importAs = new Map<StaticSymbol, StaticSymbol>();\n  private knownFileNameToModuleNames = new Map<string, string>();\n\n  constructor(private host: AotSummaryResolverHost, private staticSymbolCache: StaticSymbolCache) {}\n\n  isLibraryFile(filePath: string): boolean {\n    // Note: We need to strip the .ngfactory. file path,\n    // so this method also works for generated files\n    // (for which host.isSourceFile will always return false).\n    return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));\n  }\n\n  toSummaryFileName(filePath: string, referringSrcFileName: string) {\n    return this.host.toSummaryFileName(filePath, referringSrcFileName);\n  }\n\n  fromSummaryFileName(fileName: string, referringLibFileName: string) {\n    return this.host.fromSummaryFileName(fileName, referringLibFileName);\n  }\n\n  resolveSummary(staticSymbol: StaticSymbol): Summary<StaticSymbol>|null {\n    const rootSymbol = staticSymbol.members.length ?\n        this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) :\n        staticSymbol;\n    let summary = this.summaryCache.get(rootSymbol);\n    if (!summary) {\n      this._loadSummaryFile(staticSymbol.filePath);\n      summary = this.summaryCache.get(staticSymbol)!;\n    }\n    return (rootSymbol === staticSymbol && summary) || null;\n  }\n\n  getSymbolsOf(filePath: string): StaticSymbol[]|null {\n    if (this._loadSummaryFile(filePath)) {\n      return Array.from(this.summaryCache.keys()).filter((symbol) => symbol.filePath === filePath);\n    }\n    return null;\n  }\n\n  getImportAs(staticSymbol: StaticSymbol): StaticSymbol {\n    staticSymbol.assertNoMembers();\n    return this.importAs.get(staticSymbol)!;\n  }\n\n  /**\n   * Converts a file path to a module name that can be used as an `import`.\n   */\n  getKnownModuleName(importedFilePath: string): string|null {\n    return this.knownFileNameToModuleNames.get(importedFilePath) || null;\n  }\n\n  addSummary(summary: Summary<StaticSymbol>) {\n    this.summaryCache.set(summary.symbol, summary);\n  }\n\n  private _loadSummaryFile(filePath: string): boolean {\n    let hasSummary = this.loadedFilePaths.get(filePath);\n    if (hasSummary != null) {\n      return hasSummary;\n    }\n    let json: string|null = null;\n    if (this.isLibraryFile(filePath)) {\n      const summaryFilePath = summaryFileName(filePath);\n      try {\n        json = this.host.loadSummary(summaryFilePath);\n      } catch (e) {\n        console.error(`Error loading summary file ${summaryFilePath}`);\n        throw e;\n      }\n    }\n    hasSummary = json != null;\n    this.loadedFilePaths.set(filePath, hasSummary);\n    if (json) {\n      const {moduleName, summaries, importAs} =\n          deserializeSummaries(this.staticSymbolCache, this, filePath, json);\n      summaries.forEach((summary) => this.summaryCache.set(summary.symbol, summary));\n      if (moduleName) {\n        this.knownFileNameToModuleNames.set(filePath, moduleName);\n      }\n      importAs.forEach((importAs) => {\n        this.importAs.set(importAs.symbol, importAs.importAs);\n      });\n    }\n    return hasSummary;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}