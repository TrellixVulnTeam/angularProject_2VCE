{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/typecheck/api\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SymbolBuilder = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/api\");\n\n  var comments_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\");\n\n  var ts_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\");\n  /**\n   * Generates and caches `Symbol`s for various template structures for a given component.\n   *\n   * The `SymbolBuilder` internally caches the `Symbol`s it creates, and must be destroyed and\n   * replaced if the component's template changes.\n   */\n\n\n  var SymbolBuilder =\n  /** @class */\n  function () {\n    function SymbolBuilder(shimPath, typeCheckBlock, templateData, componentScopeReader, // The `ts.TypeChecker` depends on the current type-checking program, and so must be requested\n    // on-demand instead of cached.\n    getTypeChecker) {\n      this.shimPath = shimPath;\n      this.typeCheckBlock = typeCheckBlock;\n      this.templateData = templateData;\n      this.componentScopeReader = componentScopeReader;\n      this.getTypeChecker = getTypeChecker;\n      this.symbolCache = new Map();\n    }\n\n    SymbolBuilder.prototype.getSymbol = function (node) {\n      if (this.symbolCache.has(node)) {\n        return this.symbolCache.get(node);\n      }\n\n      var symbol = null;\n\n      if (node instanceof compiler_1.TmplAstBoundAttribute || node instanceof compiler_1.TmplAstTextAttribute) {\n        // TODO(atscott): input and output bindings only return the first directive match but should\n        // return a list of bindings for all of them.\n        symbol = this.getSymbolOfInputBinding(node);\n      } else if (node instanceof compiler_1.TmplAstBoundEvent) {\n        symbol = this.getSymbolOfBoundEvent(node);\n      } else if (node instanceof compiler_1.TmplAstElement) {\n        symbol = this.getSymbolOfElement(node);\n      } else if (node instanceof compiler_1.TmplAstTemplate) {\n        symbol = this.getSymbolOfAstTemplate(node);\n      } else if (node instanceof compiler_1.TmplAstVariable) {\n        symbol = this.getSymbolOfVariable(node);\n      } else if (node instanceof compiler_1.TmplAstReference) {\n        symbol = this.getSymbolOfReference(node);\n      } else if (node instanceof compiler_1.BindingPipe) {\n        symbol = this.getSymbolOfPipe(node);\n      } else if (node instanceof compiler_1.AST) {\n        symbol = this.getSymbolOfTemplateExpression(node);\n      } else {// TODO(atscott): TmplAstContent, TmplAstIcu\n      }\n\n      this.symbolCache.set(node, symbol);\n      return symbol;\n    };\n\n    SymbolBuilder.prototype.getSymbolOfAstTemplate = function (template) {\n      var directives = this.getDirectivesOfNode(template);\n      return {\n        kind: api_1.SymbolKind.Template,\n        directives: directives,\n        templateNode: template\n      };\n    };\n\n    SymbolBuilder.prototype.getSymbolOfElement = function (element) {\n      var _a;\n\n      var elementSourceSpan = (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan;\n      var node = comments_1.findFirstMatchingNode(this.typeCheckBlock, {\n        withSpan: elementSourceSpan,\n        filter: ts.isVariableDeclaration\n      });\n\n      if (node === null) {\n        return null;\n      }\n\n      var symbolFromDeclaration = this.getSymbolOfTsNode(node);\n\n      if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {\n        return null;\n      }\n\n      var directives = this.getDirectivesOfNode(element); // All statements in the TCB are `Expression`s that optionally include more information.\n      // An `ElementSymbol` uses the information returned for the variable declaration expression,\n      // adds the directives for the element, and updates the `kind` to be `SymbolKind.Element`.\n\n      return tslib_1.__assign(tslib_1.__assign({}, symbolFromDeclaration), {\n        kind: api_1.SymbolKind.Element,\n        directives: directives,\n        templateNode: element\n      });\n    };\n\n    SymbolBuilder.prototype.getDirectivesOfNode = function (element) {\n      var _this = this;\n\n      var _a;\n\n      var elementSourceSpan = (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan;\n      var tcbSourceFile = this.typeCheckBlock.getSourceFile(); // directives could be either:\n      // - var _t1: TestDir /*T:D*/ = (null!);\n      // - var _t1 /*T:D*/ = _ctor1({});\n\n      var isDirectiveDeclaration = function isDirectiveDeclaration(node) {\n        return (ts.isTypeNode(node) || ts.isIdentifier(node)) && ts.isVariableDeclaration(node.parent) && comments_1.hasExpressionIdentifier(tcbSourceFile, node, comments_1.ExpressionIdentifier.DIRECTIVE);\n      };\n\n      var nodes = comments_1.findAllMatchingNodes(this.typeCheckBlock, {\n        withSpan: elementSourceSpan,\n        filter: isDirectiveDeclaration\n      });\n      return nodes.map(function (node) {\n        var _a;\n\n        var symbol = _this.getSymbolOfTsNode(node.parent);\n\n        if (symbol === null || symbol.tsSymbol === null || symbol.tsSymbol.valueDeclaration === undefined || !ts.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n          return null;\n        }\n\n        var meta = _this.getDirectiveMeta(element, symbol.tsSymbol.valueDeclaration);\n\n        if (meta === null) {\n          return null;\n        }\n\n        var ngModule = _this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);\n\n        if (meta.selector === null) {\n          return null;\n        }\n\n        var isComponent = (_a = meta.isComponent) !== null && _a !== void 0 ? _a : null;\n\n        var directiveSymbol = tslib_1.__assign(tslib_1.__assign({}, symbol), {\n          tsSymbol: symbol.tsSymbol,\n          selector: meta.selector,\n          isComponent: isComponent,\n          ngModule: ngModule,\n          kind: api_1.SymbolKind.Directive,\n          isStructural: meta.isStructural\n        });\n\n        return directiveSymbol;\n      }).filter(function (d) {\n        return d !== null;\n      });\n    };\n\n    SymbolBuilder.prototype.getDirectiveMeta = function (host, directiveDeclaration) {\n      var _a;\n\n      var directives = this.templateData.boundTarget.getDirectivesOfNode(host);\n\n      if (directives === null) {\n        return null;\n      }\n\n      return (_a = directives.find(function (m) {\n        return m.ref.node === directiveDeclaration;\n      })) !== null && _a !== void 0 ? _a : null;\n    };\n\n    SymbolBuilder.prototype.getDirectiveModule = function (declaration) {\n      var scope = this.componentScopeReader.getScopeForComponent(declaration);\n\n      if (scope === null) {\n        return null;\n      }\n\n      return scope.ngModule;\n    };\n\n    SymbolBuilder.prototype.getSymbolOfBoundEvent = function (eventBinding) {\n      var e_1, _a;\n\n      var consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n\n      if (consumer === null) {\n        return null;\n      } // Outputs in the TCB look like one of the two:\n      // * _t1[\"outputField\"].subscribe(handler);\n      // * _t1.addEventListener(handler);\n      // Even with strict null checks disabled, we still produce the access as a separate statement\n      // so that it can be found here.\n\n\n      var expectedAccess;\n\n      if (consumer instanceof compiler_1.TmplAstTemplate || consumer instanceof compiler_1.TmplAstElement) {\n        expectedAccess = 'addEventListener';\n      } else {\n        var bindingPropertyNames = consumer.outputs.getByBindingPropertyName(eventBinding.name);\n\n        if (bindingPropertyNames === null || bindingPropertyNames.length === 0) {\n          return null;\n        } // Note that we only get the expectedAccess text from a single consumer of the binding. If\n        // there are multiple consumers (not supported in the `boundTarget` API) and one of them has\n        // an alias, it will not get matched here.\n\n\n        expectedAccess = bindingPropertyNames[0].classPropertyName;\n      }\n\n      function filter(n) {\n        if (!ts_util_1.isAccessExpression(n)) {\n          return false;\n        }\n\n        if (ts.isPropertyAccessExpression(n)) {\n          return n.name.getText() === expectedAccess;\n        } else {\n          return ts.isStringLiteral(n.argumentExpression) && n.argumentExpression.text === expectedAccess;\n        }\n      }\n\n      var outputFieldAccesses = comments_1.findAllMatchingNodes(this.typeCheckBlock, {\n        withSpan: eventBinding.keySpan,\n        filter: filter\n      });\n      var bindings = [];\n\n      try {\n        for (var outputFieldAccesses_1 = tslib_1.__values(outputFieldAccesses), outputFieldAccesses_1_1 = outputFieldAccesses_1.next(); !outputFieldAccesses_1_1.done; outputFieldAccesses_1_1 = outputFieldAccesses_1.next()) {\n          var outputFieldAccess = outputFieldAccesses_1_1.value;\n\n          if (consumer instanceof compiler_1.TmplAstTemplate || consumer instanceof compiler_1.TmplAstElement) {\n            if (!ts.isPropertyAccessExpression(outputFieldAccess)) {\n              continue;\n            }\n\n            var addEventListener_1 = outputFieldAccess.name;\n            var tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener_1);\n            var tsType = this.getTypeChecker().getTypeAtLocation(addEventListener_1);\n            var positionInShimFile = this.getShimPositionForNode(addEventListener_1);\n            var target = this.getSymbol(consumer);\n\n            if (target === null || tsSymbol === undefined) {\n              continue;\n            }\n\n            bindings.push({\n              kind: api_1.SymbolKind.Binding,\n              tsSymbol: tsSymbol,\n              tsType: tsType,\n              target: target,\n              shimLocation: {\n                shimPath: this.shimPath,\n                positionInShimFile: positionInShimFile\n              }\n            });\n          } else {\n            if (!ts.isElementAccessExpression(outputFieldAccess)) {\n              continue;\n            }\n\n            var tsSymbol = this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n\n            if (tsSymbol === undefined) {\n              continue;\n            }\n\n            var target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n\n            if (target === null) {\n              continue;\n            }\n\n            var positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n            var tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);\n            bindings.push({\n              kind: api_1.SymbolKind.Binding,\n              tsSymbol: tsSymbol,\n              tsType: tsType,\n              target: target,\n              shimLocation: {\n                shimPath: this.shimPath,\n                positionInShimFile: positionInShimFile\n              }\n            });\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (outputFieldAccesses_1_1 && !outputFieldAccesses_1_1.done && (_a = outputFieldAccesses_1.return)) _a.call(outputFieldAccesses_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      if (bindings.length === 0) {\n        return null;\n      }\n\n      return {\n        kind: api_1.SymbolKind.Output,\n        bindings: bindings\n      };\n    };\n\n    SymbolBuilder.prototype.getSymbolOfInputBinding = function (binding) {\n      var e_2, _a;\n\n      var consumer = this.templateData.boundTarget.getConsumerOfBinding(binding);\n\n      if (consumer === null) {\n        return null;\n      }\n\n      if (consumer instanceof compiler_1.TmplAstElement || consumer instanceof compiler_1.TmplAstTemplate) {\n        var host = this.getSymbol(consumer);\n        return host !== null ? {\n          kind: api_1.SymbolKind.DomBinding,\n          host: host\n        } : null;\n      }\n\n      var nodes = comments_1.findAllMatchingNodes(this.typeCheckBlock, {\n        withSpan: binding.sourceSpan,\n        filter: typescript_1.isAssignment\n      });\n      var bindings = [];\n\n      try {\n        for (var nodes_1 = tslib_1.__values(nodes), nodes_1_1 = nodes_1.next(); !nodes_1_1.done; nodes_1_1 = nodes_1.next()) {\n          var node = nodes_1_1.value;\n\n          if (!ts_util_1.isAccessExpression(node.left)) {\n            continue;\n          }\n\n          var symbolInfo = this.getSymbolOfTsNode(node.left);\n\n          if (symbolInfo === null || symbolInfo.tsSymbol === null) {\n            continue;\n          }\n\n          var target = this.getDirectiveSymbolForAccessExpression(node.left, consumer);\n\n          if (target === null) {\n            continue;\n          }\n\n          bindings.push(tslib_1.__assign(tslib_1.__assign({}, symbolInfo), {\n            tsSymbol: symbolInfo.tsSymbol,\n            kind: api_1.SymbolKind.Binding,\n            target: target\n          }));\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (nodes_1_1 && !nodes_1_1.done && (_a = nodes_1.return)) _a.call(nodes_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      if (bindings.length === 0) {\n        return null;\n      }\n\n      return {\n        kind: api_1.SymbolKind.Input,\n        bindings: bindings\n      };\n    };\n\n    SymbolBuilder.prototype.getDirectiveSymbolForAccessExpression = function (node, _a) {\n      var _b;\n\n      var isComponent = _a.isComponent,\n          selector = _a.selector,\n          isStructural = _a.isStructural; // In either case, `_t1[\"index\"]` or `_t1.index`, `node.expression` is _t1.\n      // The retrieved symbol for _t1 will be the variable declaration.\n\n      var tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);\n\n      if (tsSymbol === undefined || tsSymbol.declarations.length === 0 || selector === null) {\n        return null;\n      }\n\n      var _c = tslib_1.__read(tsSymbol.declarations, 1),\n          declaration = _c[0];\n\n      if (!ts.isVariableDeclaration(declaration) || !comments_1.hasExpressionIdentifier( // The expression identifier could be on the type (for regular directives) or the name\n      // (for generic directives and the ctor op).\n      declaration.getSourceFile(), (_b = declaration.type) !== null && _b !== void 0 ? _b : declaration.name, comments_1.ExpressionIdentifier.DIRECTIVE)) {\n        return null;\n      }\n\n      var symbol = this.getSymbolOfTsNode(declaration);\n\n      if (symbol === null || symbol.tsSymbol === null || symbol.tsSymbol.valueDeclaration === undefined || !ts.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n        return null;\n      }\n\n      var ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);\n      return {\n        kind: api_1.SymbolKind.Directive,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        shimLocation: symbol.shimLocation,\n        isComponent: isComponent,\n        isStructural: isStructural,\n        selector: selector,\n        ngModule: ngModule\n      };\n    };\n\n    SymbolBuilder.prototype.getSymbolOfVariable = function (variable) {\n      var node = comments_1.findFirstMatchingNode(this.typeCheckBlock, {\n        withSpan: variable.sourceSpan,\n        filter: ts.isVariableDeclaration\n      });\n\n      if (node === null || node.initializer === undefined) {\n        return null;\n      }\n\n      var expressionSymbol = this.getSymbolOfTsNode(node.initializer);\n\n      if (expressionSymbol === null) {\n        return null;\n      }\n\n      return {\n        tsType: expressionSymbol.tsType,\n        tsSymbol: expressionSymbol.tsSymbol,\n        initializerLocation: expressionSymbol.shimLocation,\n        kind: api_1.SymbolKind.Variable,\n        declaration: variable,\n        localVarLocation: {\n          shimPath: this.shimPath,\n          positionInShimFile: this.getShimPositionForNode(node.name)\n        }\n      };\n    };\n\n    SymbolBuilder.prototype.getSymbolOfReference = function (ref) {\n      var target = this.templateData.boundTarget.getReferenceTarget(ref); // Find the node for the reference declaration, i.e. `var _t2 = _t1;`\n\n      var node = comments_1.findFirstMatchingNode(this.typeCheckBlock, {\n        withSpan: ref.sourceSpan,\n        filter: ts.isVariableDeclaration\n      });\n\n      if (node === null || target === null || node.initializer === undefined) {\n        return null;\n      } // Get the original declaration for the references variable, with the exception of template refs\n      // which are of the form var _t3 = (_t2 as any as i2.TemplateRef<any>)\n      // TODO(atscott): Consider adding an `ExpressionIdentifier` to tag variable declaration\n      // initializers as invalid for symbol retrieval.\n\n\n      var originalDeclaration = ts.isParenthesizedExpression(node.initializer) && ts.isAsExpression(node.initializer.expression) ? this.getTypeChecker().getSymbolAtLocation(node.name) : this.getTypeChecker().getSymbolAtLocation(node.initializer);\n\n      if (originalDeclaration === undefined || originalDeclaration.valueDeclaration === undefined) {\n        return null;\n      }\n\n      var symbol = this.getSymbolOfTsNode(originalDeclaration.valueDeclaration);\n\n      if (symbol === null || symbol.tsSymbol === null) {\n        return null;\n      }\n\n      var referenceVarShimLocation = {\n        shimPath: this.shimPath,\n        positionInShimFile: this.getShimPositionForNode(node)\n      };\n\n      if (target instanceof compiler_1.TmplAstTemplate || target instanceof compiler_1.TmplAstElement) {\n        return {\n          kind: api_1.SymbolKind.Reference,\n          tsSymbol: symbol.tsSymbol,\n          tsType: symbol.tsType,\n          target: target,\n          declaration: ref,\n          targetLocation: symbol.shimLocation,\n          referenceVarLocation: referenceVarShimLocation\n        };\n      } else {\n        if (!ts.isClassDeclaration(target.directive.ref.node)) {\n          return null;\n        }\n\n        return {\n          kind: api_1.SymbolKind.Reference,\n          tsSymbol: symbol.tsSymbol,\n          tsType: symbol.tsType,\n          declaration: ref,\n          target: target.directive.ref.node,\n          targetLocation: symbol.shimLocation,\n          referenceVarLocation: referenceVarShimLocation\n        };\n      }\n    };\n\n    SymbolBuilder.prototype.getSymbolOfPipe = function (expression) {\n      var node = comments_1.findFirstMatchingNode(this.typeCheckBlock, {\n        withSpan: expression.sourceSpan,\n        filter: ts.isCallExpression\n      });\n\n      if (node === null || !ts.isPropertyAccessExpression(node.expression)) {\n        return null;\n      }\n\n      var methodAccess = node.expression; // Find the node for the pipe variable from the transform property access. This will be one of\n      // two forms: `_pipe1.transform` or `(_pipe1 as any).transform`.\n\n      var pipeVariableNode = ts.isParenthesizedExpression(methodAccess.expression) && ts.isAsExpression(methodAccess.expression.expression) ? methodAccess.expression.expression.expression : methodAccess.expression;\n      var pipeDeclaration = this.getTypeChecker().getSymbolAtLocation(pipeVariableNode);\n\n      if (pipeDeclaration === undefined || pipeDeclaration.valueDeclaration === undefined) {\n        return null;\n      }\n\n      var pipeInstance = this.getSymbolOfTsNode(pipeDeclaration.valueDeclaration);\n\n      if (pipeInstance === null || pipeInstance.tsSymbol === null) {\n        return null;\n      }\n\n      var symbolInfo = this.getSymbolOfTsNode(methodAccess);\n\n      if (symbolInfo === null) {\n        return null;\n      }\n\n      return tslib_1.__assign(tslib_1.__assign({\n        kind: api_1.SymbolKind.Pipe\n      }, symbolInfo), {\n        classSymbol: tslib_1.__assign(tslib_1.__assign({}, pipeInstance), {\n          tsSymbol: pipeInstance.tsSymbol\n        })\n      });\n    };\n\n    SymbolBuilder.prototype.getSymbolOfTemplateExpression = function (expression) {\n      if (expression instanceof compiler_1.ASTWithSource) {\n        expression = expression.ast;\n      }\n\n      var expressionTarget = this.templateData.boundTarget.getExpressionTarget(expression);\n\n      if (expressionTarget !== null) {\n        return this.getSymbol(expressionTarget);\n      } // The `name` part of a `PropertyWrite` and `MethodCall` does not have its own\n      // AST so there is no way to retrieve a `Symbol` for just the `name` via a specific node.\n\n\n      var withSpan = expression instanceof compiler_1.PropertyWrite || expression instanceof compiler_1.MethodCall ? expression.nameSpan : expression.sourceSpan;\n      var node = comments_1.findFirstMatchingNode(this.typeCheckBlock, {\n        withSpan: withSpan,\n        filter: function filter(n) {\n          return true;\n        }\n      });\n\n      if (node === null) {\n        return null;\n      }\n\n      while (ts.isParenthesizedExpression(node)) {\n        node = node.expression;\n      } // - If we have safe property read (\"a?.b\") we want to get the Symbol for b, the `whenTrue`\n      // expression.\n      // - If our expression is a pipe binding (\"a | test:b:c\"), we want the Symbol for the\n      // `transform` on the pipe.\n      // - Otherwise, we retrieve the symbol for the node itself with no special considerations\n\n\n      if ((expression instanceof compiler_1.SafePropertyRead || expression instanceof compiler_1.SafeMethodCall) && ts.isConditionalExpression(node)) {\n        var whenTrueSymbol = expression instanceof compiler_1.SafeMethodCall && ts.isCallExpression(node.whenTrue) ? this.getSymbolOfTsNode(node.whenTrue.expression) : this.getSymbolOfTsNode(node.whenTrue);\n\n        if (whenTrueSymbol === null) {\n          return null;\n        }\n\n        return tslib_1.__assign(tslib_1.__assign({}, whenTrueSymbol), {\n          kind: api_1.SymbolKind.Expression,\n          // Rather than using the type of only the `whenTrue` part of the expression, we should\n          // still get the type of the whole conditional expression to include `|undefined`.\n          tsType: this.getTypeChecker().getTypeAtLocation(node)\n        });\n      } else {\n        var symbolInfo = this.getSymbolOfTsNode(node);\n        return symbolInfo === null ? null : tslib_1.__assign(tslib_1.__assign({}, symbolInfo), {\n          kind: api_1.SymbolKind.Expression\n        });\n      }\n    };\n\n    SymbolBuilder.prototype.getSymbolOfTsNode = function (node) {\n      var _a;\n\n      while (ts.isParenthesizedExpression(node)) {\n        node = node.expression;\n      }\n\n      var tsSymbol;\n\n      if (ts.isPropertyAccessExpression(node)) {\n        tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.name);\n      } else if (ts.isElementAccessExpression(node)) {\n        tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.argumentExpression);\n      } else {\n        tsSymbol = this.getTypeChecker().getSymbolAtLocation(node);\n      }\n\n      var positionInShimFile = this.getShimPositionForNode(node);\n      var type = this.getTypeChecker().getTypeAtLocation(node);\n      return {\n        // If we could not find a symbol, fall back to the symbol on the type for the node.\n        // Some nodes won't have a \"symbol at location\" but will have a symbol for the type.\n        // Examples of this would be literals and `document.createElement('div')`.\n        tsSymbol: (_a = tsSymbol !== null && tsSymbol !== void 0 ? tsSymbol : type.symbol) !== null && _a !== void 0 ? _a : null,\n        tsType: type,\n        shimLocation: {\n          shimPath: this.shimPath,\n          positionInShimFile: positionInShimFile\n        }\n      };\n    };\n\n    SymbolBuilder.prototype.getShimPositionForNode = function (node) {\n      if (ts.isTypeReferenceNode(node)) {\n        return this.getShimPositionForNode(node.typeName);\n      } else if (ts.isQualifiedName(node)) {\n        return node.right.getStart();\n      } else if (ts.isPropertyAccessExpression(node)) {\n        return node.name.getStart();\n      } else if (ts.isElementAccessExpression(node)) {\n        return node.argumentExpression.getStart();\n      } else {\n        return node.getStart();\n      }\n    };\n\n    return SymbolBuilder;\n  }();\n\n  exports.SymbolBuilder = SymbolBuilder;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAKA,MAAA,YAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,+CAAA,CAAA;;AAEA,MAAA,UAAA,GAAA,OAAA,CAAA,wDAAA,CAAA;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,uDAAA,CAAA;AAEA;;;;;AAKG;;;AACH,MAAA,aAAA;AAAA;AAAA,cAAA;AAGE,aAAA,aAAA,CACqB,QADrB,EAEqB,cAFrB,EAGqB,YAHrB,EAIqB,oBAJrB,EAKI;AACA;AACiB,IAAA,cAPrB,EAOyD;AANpC,WAAA,QAAA,GAAA,QAAA;AACA,WAAA,cAAA,GAAA,cAAA;AACA,WAAA,YAAA,GAAA,YAAA;AACA,WAAA,oBAAA,GAAA,oBAAA;AAGA,WAAA,cAAA,GAAA,cAAA;AATb,WAAA,WAAA,GAAc,IAAI,GAAJ,EAAd;AAUJ;;AAKJ,IAAA,aAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,IAAV,EAA+B;AAC7B,UAAI,KAAK,WAAL,CAAiB,GAAjB,CAAqB,IAArB,CAAJ,EAAgC;AAC9B,eAAO,KAAK,WAAL,CAAiB,GAAjB,CAAqB,IAArB,CAAP;AACD;;AAED,UAAI,MAAM,GAAgB,IAA1B;;AACA,UAAI,IAAI,YAAY,UAAA,CAAA,qBAAhB,IAAyC,IAAI,YAAY,UAAA,CAAA,oBAA7D,EAAmF;AACjF;AACA;AACA,QAAA,MAAM,GAAG,KAAK,uBAAL,CAA6B,IAA7B,CAAT;AACD,OAJD,MAIO,IAAI,IAAI,YAAY,UAAA,CAAA,iBAApB,EAAuC;AAC5C,QAAA,MAAM,GAAG,KAAK,qBAAL,CAA2B,IAA3B,CAAT;AACD,OAFM,MAEA,IAAI,IAAI,YAAY,UAAA,CAAA,cAApB,EAAoC;AACzC,QAAA,MAAM,GAAG,KAAK,kBAAL,CAAwB,IAAxB,CAAT;AACD,OAFM,MAEA,IAAI,IAAI,YAAY,UAAA,CAAA,eAApB,EAAqC;AAC1C,QAAA,MAAM,GAAG,KAAK,sBAAL,CAA4B,IAA5B,CAAT;AACD,OAFM,MAEA,IAAI,IAAI,YAAY,UAAA,CAAA,eAApB,EAAqC;AAC1C,QAAA,MAAM,GAAG,KAAK,mBAAL,CAAyB,IAAzB,CAAT;AACD,OAFM,MAEA,IAAI,IAAI,YAAY,UAAA,CAAA,gBAApB,EAAsC;AAC3C,QAAA,MAAM,GAAG,KAAK,oBAAL,CAA0B,IAA1B,CAAT;AACD,OAFM,MAEA,IAAI,IAAI,YAAY,UAAA,CAAA,WAApB,EAAiC;AACtC,QAAA,MAAM,GAAG,KAAK,eAAL,CAAqB,IAArB,CAAT;AACD,OAFM,MAEA,IAAI,IAAI,YAAY,UAAA,CAAA,GAApB,EAAyB;AAC9B,QAAA,MAAM,GAAG,KAAK,6BAAL,CAAmC,IAAnC,CAAT;AACD,OAFM,MAEA,CACL;AACD;;AAED,WAAK,WAAL,CAAiB,GAAjB,CAAqB,IAArB,EAA2B,MAA3B;AACA,aAAO,MAAP;AACD,KA9BD;;AAgCQ,IAAA,aAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B,QAA/B,EAAwD;AACtD,UAAM,UAAU,GAAG,KAAK,mBAAL,CAAyB,QAAzB,CAAnB;AACA,aAAO;AAAC,QAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,QAAlB;AAA4B,QAAA,UAAU,EAAA,UAAtC;AAAwC,QAAA,YAAY,EAAE;AAAtD,OAAP;AACD,KAHO;;AAKA,IAAA,aAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,OAA3B,EAAkD;;;AAChD,UAAM,iBAAiB,GAAA,CAAA,EAAA,GAAG,OAAO,CAAC,eAAX,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,EAA1B,GAA8B,OAAO,CAAC,UAA7D;AAEA,UAAM,IAAI,GAAG,UAAA,CAAA,qBAAA,CACT,KAAK,cADI,EACY;AAAC,QAAA,QAAQ,EAAE,iBAAX;AAA8B,QAAA,MAAM,EAAE,EAAE,CAAC;AAAzC,OADZ,CAAb;;AAEA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,eAAO,IAAP;AACD;;AAED,UAAM,qBAAqB,GAAG,KAAK,iBAAL,CAAuB,IAAvB,CAA9B;;AACA,UAAI,qBAAqB,KAAK,IAA1B,IAAkC,qBAAqB,CAAC,QAAtB,KAAmC,IAAzE,EAA+E;AAC7E,eAAO,IAAP;AACD;;AAED,UAAM,UAAU,GAAG,KAAK,mBAAL,CAAyB,OAAzB,CAAnB,CAdgD,CAehD;AACA;AACA;;AACA,aAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACK,qBADL,CAAA,EAC0B;AACxB,QAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,OADO;AAExB,QAAA,UAAU,EAAA,UAFc;AAGxB,QAAA,YAAY,EAAE;AAHU,OAD1B,CAAA;AAMD,KAxBO;;AA0BA,IAAA,aAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,OAA5B,EAAmE;AAAnE,UAAA,KAAA,GAAA,IAAA;;;;AACE,UAAM,iBAAiB,GAAA,CAAA,EAAA,GAAG,OAAO,CAAC,eAAX,MAA0B,IAA1B,IAA0B,EAAA,KAAA,KAAA,CAA1B,GAA0B,EAA1B,GAA8B,OAAO,CAAC,UAA7D;AACA,UAAM,aAAa,GAAG,KAAK,cAAL,CAAoB,aAApB,EAAtB,CAFiE,CAGjE;AACA;AACA;;AACA,UAAM,sBAAsB,GAAG,SAAzB,sBAAyB,CAAC,IAAD,EAAc;AACzC,eAAA,CAAC,EAAE,CAAC,UAAH,CAAc,IAAd,KAAuB,EAAE,CAAC,YAAH,CAAgB,IAAhB,CAAxB,KAAkD,EAAE,CAAC,qBAAH,CAAyB,IAAI,CAAC,MAA9B,CAAlD,IACA,UAAA,CAAA,uBAAA,CAAwB,aAAxB,EAAuC,IAAvC,EAA6C,UAAA,CAAA,oBAAA,CAAqB,SAAlE,CADA;AAC4E,OAFhF;;AAIA,UAAM,KAAK,GAAG,UAAA,CAAA,oBAAA,CACV,KAAK,cADK,EACW;AAAC,QAAA,QAAQ,EAAE,iBAAX;AAA8B,QAAA,MAAM,EAAE;AAAtC,OADX,CAAd;AAEA,aAAO,KAAK,CACP,GADE,CACE,UAAA,IAAA,EAAI;;;AACP,YAAM,MAAM,GAAG,KAAI,CAAC,iBAAL,CAAuB,IAAI,CAAC,MAA5B,CAAf;;AACA,YAAI,MAAM,KAAK,IAAX,IAAmB,MAAM,CAAC,QAAP,KAAoB,IAAvC,IACA,MAAM,CAAC,QAAP,CAAgB,gBAAhB,KAAqC,SADrC,IAEA,CAAC,EAAE,CAAC,kBAAH,CAAsB,MAAM,CAAC,QAAP,CAAgB,gBAAtC,CAFL,EAE8D;AAC5D,iBAAO,IAAP;AACD;;AACD,YAAM,IAAI,GAAG,KAAI,CAAC,gBAAL,CAAsB,OAAtB,EAA+B,MAAM,CAAC,QAAP,CAAgB,gBAA/C,CAAb;;AACA,YAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,iBAAO,IAAP;AACD;;AAED,YAAM,QAAQ,GAAG,KAAI,CAAC,kBAAL,CAAwB,MAAM,CAAC,QAAP,CAAgB,gBAAxC,CAAjB;;AACA,YAAI,IAAI,CAAC,QAAL,KAAkB,IAAtB,EAA4B;AAC1B,iBAAO,IAAP;AACD;;AACD,YAAM,WAAW,GAAA,CAAA,EAAA,GAAG,IAAI,CAAC,WAAR,MAAmB,IAAnB,IAAmB,EAAA,KAAA,KAAA,CAAnB,GAAmB,EAAnB,GAAuB,IAAxC;;AACA,YAAM,eAAe,GAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAChB,MADgB,CAAA,EACV;AACT,UAAA,QAAQ,EAAE,MAAM,CAAC,QADR;AAET,UAAA,QAAQ,EAAE,IAAI,CAAC,QAFN;AAGT,UAAA,WAAW,EAAA,WAHF;AAIT,UAAA,QAAQ,EAAA,QAJC;AAKT,UAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,SALR;AAMT,UAAA,YAAY,EAAE,IAAI,CAAC;AANV,SADU,CAArB;;AASA,eAAO,eAAP;AACD,OA5BE,EA6BF,MA7BE,CA6BK,UAAC,CAAD,EAAE;AAA2B,eAAA,CAAC,KAAD,IAAA;AAAU,OA7B5C,CAAP;AA8BD,KA1CO;;AA4CA,IAAA,aAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UACI,IADJ,EAEI,oBAFJ,EAEwC;;;AACtC,UAAM,UAAU,GAAG,KAAK,YAAL,CAAkB,WAAlB,CAA8B,mBAA9B,CAAkD,IAAlD,CAAnB;;AACA,UAAI,UAAU,KAAK,IAAnB,EAAyB;AACvB,eAAO,IAAP;AACD;;AAED,aAAA,CAAA,EAAA,GAAO,UAAU,CAAC,IAAX,CAAgB,UAAA,CAAA,EAAC;AAAI,eAAA,CAAC,CAAC,GAAF,CAAM,IAAN,KAAA,oBAAA;AAAmC,OAAxD,CAAP,MAAgE,IAAhE,IAAgE,EAAA,KAAA,KAAA,CAAhE,GAAgE,EAAhE,GAAoE,IAApE;AACD,KATO;;AAWA,IAAA,aAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,WAA3B,EAA2D;AACzD,UAAM,KAAK,GAAG,KAAK,oBAAL,CAA0B,oBAA1B,CAA+C,WAA/C,CAAd;;AACA,UAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,eAAO,IAAP;AACD;;AACD,aAAO,KAAK,CAAC,QAAb;AACD,KANO;;AAQA,IAAA,aAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,UAA8B,YAA9B,EAA6D;;;AAC3D,UAAM,QAAQ,GAAG,KAAK,YAAL,CAAkB,WAAlB,CAA8B,oBAA9B,CAAmD,YAAnD,CAAjB;;AACA,UAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,eAAO,IAAP;AACD,OAJ0D,CAM3D;AACA;AACA;AACA;AACA;;;AACA,UAAI,cAAJ;;AACA,UAAI,QAAQ,YAAY,UAAA,CAAA,eAApB,IAAuC,QAAQ,YAAY,UAAA,CAAA,cAA/D,EAA+E;AAC7E,QAAA,cAAc,GAAG,kBAAjB;AACD,OAFD,MAEO;AACL,YAAM,oBAAoB,GAAG,QAAQ,CAAC,OAAT,CAAiB,wBAAjB,CAA0C,YAAY,CAAC,IAAvD,CAA7B;;AACA,YAAI,oBAAoB,KAAK,IAAzB,IAAiC,oBAAoB,CAAC,MAArB,KAAgC,CAArE,EAAwE;AACtE,iBAAO,IAAP;AACD,SAJI,CAKL;AACA;AACA;;;AACA,QAAA,cAAc,GAAG,oBAAoB,CAAC,CAAD,CAApB,CAAwB,iBAAzC;AACD;;AAED,eAAS,MAAT,CAAgB,CAAhB,EAA0B;AACxB,YAAI,CAAC,SAAA,CAAA,kBAAA,CAAmB,CAAnB,CAAL,EAA4B;AAC1B,iBAAO,KAAP;AACD;;AAED,YAAI,EAAE,CAAC,0BAAH,CAA8B,CAA9B,CAAJ,EAAsC;AACpC,iBAAO,CAAC,CAAC,IAAF,CAAO,OAAP,OAAqB,cAA5B;AACD,SAFD,MAEO;AACL,iBAAO,EAAE,CAAC,eAAH,CAAmB,CAAC,CAAC,kBAArB,KACH,CAAC,CAAC,kBAAF,CAAqB,IAArB,KAA8B,cADlC;AAED;AACF;;AACD,UAAM,mBAAmB,GACrB,UAAA,CAAA,oBAAA,CAAqB,KAAK,cAA1B,EAA0C;AAAC,QAAA,QAAQ,EAAE,YAAY,CAAC,OAAxB;AAAiC,QAAA,MAAM,EAAA;AAAvC,OAA1C,CADJ;AAGA,UAAM,QAAQ,GAAoB,EAAlC;;;AACA,aAAgC,IAAA,qBAAA,GAAA,OAAA,CAAA,QAAA,CAAA,mBAAA,CAAA,EAAmB,uBAAA,GAAA,qBAAA,CAAA,IAAA,EAAnD,EAAmD,CAAA,uBAAA,CAAA,IAAnD,EAAmD,uBAAA,GAAA,qBAAA,CAAA,IAAA,EAAnD,EAAqD;AAAhD,cAAM,iBAAiB,GAAA,uBAAA,CAAA,KAAvB;;AACH,cAAI,QAAQ,YAAY,UAAA,CAAA,eAApB,IAAuC,QAAQ,YAAY,UAAA,CAAA,cAA/D,EAA+E;AAC7E,gBAAI,CAAC,EAAE,CAAC,0BAAH,CAA8B,iBAA9B,CAAL,EAAuD;AACrD;AACD;;AAED,gBAAM,kBAAgB,GAAG,iBAAiB,CAAC,IAA3C;AACA,gBAAM,QAAQ,GAAG,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,kBAA1C,CAAjB;AACA,gBAAM,MAAM,GAAG,KAAK,cAAL,GAAsB,iBAAtB,CAAwC,kBAAxC,CAAf;AACA,gBAAM,kBAAkB,GAAG,KAAK,sBAAL,CAA4B,kBAA5B,CAA3B;AACA,gBAAM,MAAM,GAAG,KAAK,SAAL,CAAe,QAAf,CAAf;;AAEA,gBAAI,MAAM,KAAK,IAAX,IAAmB,QAAQ,KAAK,SAApC,EAA+C;AAC7C;AACD;;AAED,YAAA,QAAQ,CAAC,IAAT,CAAc;AACZ,cAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,OADL;AAEZ,cAAA,QAAQ,EAAA,QAFI;AAGZ,cAAA,MAAM,EAAA,MAHM;AAIZ,cAAA,MAAM,EAAA,MAJM;AAKZ,cAAA,YAAY,EAAE;AAAC,gBAAA,QAAQ,EAAE,KAAK,QAAhB;AAA0B,gBAAA,kBAAkB,EAAA;AAA5C;AALF,aAAd;AAOD,WAtBD,MAsBO;AACL,gBAAI,CAAC,EAAE,CAAC,yBAAH,CAA6B,iBAA7B,CAAL,EAAsD;AACpD;AACD;;AACD,gBAAM,QAAQ,GACV,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,iBAAiB,CAAC,kBAA5D,CADJ;;AAEA,gBAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B;AACD;;AAGD,gBAAM,MAAM,GAAG,KAAK,qCAAL,CAA2C,iBAA3C,EAA8D,QAA9D,CAAf;;AACA,gBAAI,MAAM,KAAK,IAAf,EAAqB;AACnB;AACD;;AAED,gBAAM,kBAAkB,GAAG,KAAK,sBAAL,CAA4B,iBAA5B,CAA3B;AACA,gBAAM,MAAM,GAAG,KAAK,cAAL,GAAsB,iBAAtB,CAAwC,iBAAxC,CAAf;AACA,YAAA,QAAQ,CAAC,IAAT,CAAc;AACZ,cAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,OADL;AAEZ,cAAA,QAAQ,EAAA,QAFI;AAGZ,cAAA,MAAM,EAAA,MAHM;AAIZ,cAAA,MAAM,EAAA,MAJM;AAKZ,cAAA,YAAY,EAAE;AAAC,gBAAA,QAAQ,EAAE,KAAK,QAAhB;AAA0B,gBAAA,kBAAkB,EAAA;AAA5C;AALF,aAAd;AAOD;AACF;;;;;;;;;;;;;AAED,UAAI,QAAQ,CAAC,MAAT,KAAoB,CAAxB,EAA2B;AACzB,eAAO,IAAP;AACD;;AACD,aAAO;AAAC,QAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,MAAlB;AAA0B,QAAA,QAAQ,EAAA;AAAlC,OAAP;AACD,KAhGO;;AAkGA,IAAA,aAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,UAAgC,OAAhC,EACoD;;;AAClD,UAAM,QAAQ,GAAG,KAAK,YAAL,CAAkB,WAAlB,CAA8B,oBAA9B,CAAmD,OAAnD,CAAjB;;AACA,UAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,eAAO,IAAP;AACD;;AAED,UAAI,QAAQ,YAAY,UAAA,CAAA,cAApB,IAAsC,QAAQ,YAAY,UAAA,CAAA,eAA9D,EAA+E;AAC7E,YAAM,IAAI,GAAG,KAAK,SAAL,CAAe,QAAf,CAAb;AACA,eAAO,IAAI,KAAK,IAAT,GAAgB;AAAC,UAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,UAAlB;AAA8B,UAAA,IAAI,EAAA;AAAlC,SAAhB,GAAsD,IAA7D;AACD;;AAED,UAAM,KAAK,GAAG,UAAA,CAAA,oBAAA,CACV,KAAK,cADK,EACW;AAAC,QAAA,QAAQ,EAAE,OAAO,CAAC,UAAnB;AAA+B,QAAA,MAAM,EAAE,YAAA,CAAA;AAAvC,OADX,CAAd;AAEA,UAAM,QAAQ,GAAoB,EAAlC;;;AACA,aAAmB,IAAA,OAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAA,CAAA,EAAK,SAAA,GAAA,OAAA,CAAA,IAAA,EAAxB,EAAwB,CAAA,SAAA,CAAA,IAAxB,EAAwB,SAAA,GAAA,OAAA,CAAA,IAAA,EAAxB,EAA0B;AAArB,cAAM,IAAI,GAAA,SAAA,CAAA,KAAV;;AACH,cAAI,CAAC,SAAA,CAAA,kBAAA,CAAmB,IAAI,CAAC,IAAxB,CAAL,EAAoC;AAClC;AACD;;AAED,cAAM,UAAU,GAAG,KAAK,iBAAL,CAAuB,IAAI,CAAC,IAA5B,CAAnB;;AACA,cAAI,UAAU,KAAK,IAAf,IAAuB,UAAU,CAAC,QAAX,KAAwB,IAAnD,EAAyD;AACvD;AACD;;AAED,cAAM,MAAM,GAAG,KAAK,qCAAL,CAA2C,IAAI,CAAC,IAAhD,EAAsD,QAAtD,CAAf;;AACA,cAAI,MAAM,KAAK,IAAf,EAAqB;AACnB;AACD;;AACD,UAAA,QAAQ,CAAC,IAAT,CAAa,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACR,UADQ,CAAA,EACE;AACb,YAAA,QAAQ,EAAE,UAAU,CAAC,QADR;AAEb,YAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,OAFJ;AAGb,YAAA,MAAM,EAAA;AAHO,WADF,CAAb;AAMD;;;;;;;;;;;;;AACD,UAAI,QAAQ,CAAC,MAAT,KAAoB,CAAxB,EAA2B;AACzB,eAAO,IAAP;AACD;;AAED,aAAO;AAAC,QAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,KAAlB;AAAyB,QAAA,QAAQ,EAAA;AAAjC,OAAP;AACD,KAzCO;;AA2CA,IAAA,aAAA,CAAA,SAAA,CAAA,qCAAA,GAAR,UACI,IADJ,EAEI,EAFJ,EAEqE;;;UAAhE,WAAW,GAAA,EAAA,CAAA,W;UAAE,QAAQ,GAAA,EAAA,CAAA,Q;UAAE,YAAY,GAAA,EAAA,CAAA,Y,CAA6B,CACnE;AACA;;AACA,UAAM,QAAQ,GAAG,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,IAAI,CAAC,UAA/C,CAAjB;;AACA,UAAI,QAAQ,KAAK,SAAb,IAA0B,QAAQ,CAAC,YAAT,CAAsB,MAAtB,KAAiC,CAA3D,IAAgE,QAAQ,KAAK,IAAjF,EAAuF;AACrF,eAAO,IAAP;AACD;;AAEK,UAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAAgB,QAAQ,CAAC,YAAzB,EAAqC,CAArC,CAAA;AAAA,UAAC,WAAW,GAAA,EAAA,CAAA,CAAA,CAAZ;;AACN,UAAI,CAAC,EAAE,CAAC,qBAAH,CAAyB,WAAzB,CAAD,IACA,CAAC,UAAA,CAAA,uBAAA,EACG;AACA;AACA,MAAA,WAAW,CAAC,aAAZ,EAHH,EAG8B,CAAA,EAAA,GAAE,WAAW,CAAC,IAAd,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,EAAlB,GAAsB,WAAW,CAAC,IAHhE,EAIG,UAAA,CAAA,oBAAA,CAAqB,SAJxB,CADL,EAKyC;AACvC,eAAO,IAAP;AACD;;AAED,UAAM,MAAM,GAAG,KAAK,iBAAL,CAAuB,WAAvB,CAAf;;AACA,UAAI,MAAM,KAAK,IAAX,IAAmB,MAAM,CAAC,QAAP,KAAoB,IAAvC,IACA,MAAM,CAAC,QAAP,CAAgB,gBAAhB,KAAqC,SADrC,IAEA,CAAC,EAAE,CAAC,kBAAH,CAAsB,MAAM,CAAC,QAAP,CAAgB,gBAAtC,CAFL,EAE8D;AAC5D,eAAO,IAAP;AACD;;AAED,UAAM,QAAQ,GAAG,KAAK,kBAAL,CAAwB,MAAM,CAAC,QAAP,CAAgB,gBAAxC,CAAjB;AACA,aAAO;AACL,QAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,SADZ;AAEL,QAAA,QAAQ,EAAE,MAAM,CAAC,QAFZ;AAGL,QAAA,MAAM,EAAE,MAAM,CAAC,MAHV;AAIL,QAAA,YAAY,EAAE,MAAM,CAAC,YAJhB;AAKL,QAAA,WAAW,EAAA,WALN;AAML,QAAA,YAAY,EAAA,YANP;AAOL,QAAA,QAAQ,EAAA,QAPH;AAQL,QAAA,QAAQ,EAAA;AARH,OAAP;AAUD,KAtCO;;AAwCA,IAAA,aAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,QAA5B,EAAqD;AACnD,UAAM,IAAI,GAAG,UAAA,CAAA,qBAAA,CACT,KAAK,cADI,EACY;AAAC,QAAA,QAAQ,EAAE,QAAQ,CAAC,UAApB;AAAgC,QAAA,MAAM,EAAE,EAAE,CAAC;AAA3C,OADZ,CAAb;;AAEA,UAAI,IAAI,KAAK,IAAT,IAAiB,IAAI,CAAC,WAAL,KAAqB,SAA1C,EAAqD;AACnD,eAAO,IAAP;AACD;;AAED,UAAM,gBAAgB,GAAG,KAAK,iBAAL,CAAuB,IAAI,CAAC,WAA5B,CAAzB;;AACA,UAAI,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,eAAO,IAAP;AACD;;AAED,aAAO;AACL,QAAA,MAAM,EAAE,gBAAgB,CAAC,MADpB;AAEL,QAAA,QAAQ,EAAE,gBAAgB,CAAC,QAFtB;AAGL,QAAA,mBAAmB,EAAE,gBAAgB,CAAC,YAHjC;AAIL,QAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,QAJZ;AAKL,QAAA,WAAW,EAAE,QALR;AAML,QAAA,gBAAgB,EAAE;AAChB,UAAA,QAAQ,EAAE,KAAK,QADC;AAEhB,UAAA,kBAAkB,EAAE,KAAK,sBAAL,CAA4B,IAAI,CAAC,IAAjC;AAFJ;AANb,OAAP;AAWD,KAvBO;;AAyBA,IAAA,aAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UAA6B,GAA7B,EAAkD;AAChD,UAAM,MAAM,GAAG,KAAK,YAAL,CAAkB,WAAlB,CAA8B,kBAA9B,CAAiD,GAAjD,CAAf,CADgD,CAEhD;;AACA,UAAI,IAAI,GAAG,UAAA,CAAA,qBAAA,CACP,KAAK,cADE,EACc;AAAC,QAAA,QAAQ,EAAE,GAAG,CAAC,UAAf;AAA2B,QAAA,MAAM,EAAE,EAAE,CAAC;AAAtC,OADd,CAAX;;AAEA,UAAI,IAAI,KAAK,IAAT,IAAiB,MAAM,KAAK,IAA5B,IAAoC,IAAI,CAAC,WAAL,KAAqB,SAA7D,EAAwE;AACtE,eAAO,IAAP;AACD,OAP+C,CAShD;AACA;AACA;AACA;;;AACA,UAAM,mBAAmB,GAAG,EAAE,CAAC,yBAAH,CAA6B,IAAI,CAAC,WAAlC,KACpB,EAAE,CAAC,cAAH,CAAkB,IAAI,CAAC,WAAL,CAAiB,UAAnC,CADoB,GAExB,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,IAAI,CAAC,IAA/C,CAFwB,GAGxB,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,IAAI,CAAC,WAA/C,CAHJ;;AAIA,UAAI,mBAAmB,KAAK,SAAxB,IAAqC,mBAAmB,CAAC,gBAApB,KAAyC,SAAlF,EAA6F;AAC3F,eAAO,IAAP;AACD;;AACD,UAAM,MAAM,GAAG,KAAK,iBAAL,CAAuB,mBAAmB,CAAC,gBAA3C,CAAf;;AACA,UAAI,MAAM,KAAK,IAAX,IAAmB,MAAM,CAAC,QAAP,KAAoB,IAA3C,EAAiD;AAC/C,eAAO,IAAP;AACD;;AAED,UAAM,wBAAwB,GAAiB;AAC7C,QAAA,QAAQ,EAAE,KAAK,QAD8B;AAE7C,QAAA,kBAAkB,EAAE,KAAK,sBAAL,CAA4B,IAA5B;AAFyB,OAA/C;;AAIA,UAAI,MAAM,YAAY,UAAA,CAAA,eAAlB,IAAqC,MAAM,YAAY,UAAA,CAAA,cAA3D,EAA2E;AACzE,eAAO;AACL,UAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,SADZ;AAEL,UAAA,QAAQ,EAAE,MAAM,CAAC,QAFZ;AAGL,UAAA,MAAM,EAAE,MAAM,CAAC,MAHV;AAIL,UAAA,MAAM,EAAA,MAJD;AAKL,UAAA,WAAW,EAAE,GALR;AAML,UAAA,cAAc,EAAE,MAAM,CAAC,YANlB;AAOL,UAAA,oBAAoB,EAAE;AAPjB,SAAP;AASD,OAVD,MAUO;AACL,YAAI,CAAC,EAAE,CAAC,kBAAH,CAAsB,MAAM,CAAC,SAAP,CAAiB,GAAjB,CAAqB,IAA3C,CAAL,EAAuD;AACrD,iBAAO,IAAP;AACD;;AAED,eAAO;AACL,UAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,SADZ;AAEL,UAAA,QAAQ,EAAE,MAAM,CAAC,QAFZ;AAGL,UAAA,MAAM,EAAE,MAAM,CAAC,MAHV;AAIL,UAAA,WAAW,EAAE,GAJR;AAKL,UAAA,MAAM,EAAE,MAAM,CAAC,SAAP,CAAiB,GAAjB,CAAqB,IALxB;AAML,UAAA,cAAc,EAAE,MAAM,CAAC,YANlB;AAOL,UAAA,oBAAoB,EAAE;AAPjB,SAAP;AASD;AACF,KAtDO;;AAwDA,IAAA,aAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,UAAxB,EAA+C;AAC7C,UAAM,IAAI,GAAG,UAAA,CAAA,qBAAA,CACT,KAAK,cADI,EACY;AAAC,QAAA,QAAQ,EAAE,UAAU,CAAC,UAAtB;AAAkC,QAAA,MAAM,EAAE,EAAE,CAAC;AAA7C,OADZ,CAAb;;AAEA,UAAI,IAAI,KAAK,IAAT,IAAiB,CAAC,EAAE,CAAC,0BAAH,CAA8B,IAAI,CAAC,UAAnC,CAAtB,EAAsE;AACpE,eAAO,IAAP;AACD;;AAED,UAAM,YAAY,GAAG,IAAI,CAAC,UAA1B,CAP6C,CAQ7C;AACA;;AACA,UAAM,gBAAgB,GAAG,EAAE,CAAC,yBAAH,CAA6B,YAAY,CAAC,UAA1C,KACjB,EAAE,CAAC,cAAH,CAAkB,YAAY,CAAC,UAAb,CAAwB,UAA1C,CADiB,GAErB,YAAY,CAAC,UAAb,CAAwB,UAAxB,CAAmC,UAFd,GAGrB,YAAY,CAAC,UAHjB;AAIA,UAAM,eAAe,GAAG,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,gBAA1C,CAAxB;;AACA,UAAI,eAAe,KAAK,SAApB,IAAiC,eAAe,CAAC,gBAAhB,KAAqC,SAA1E,EAAqF;AACnF,eAAO,IAAP;AACD;;AAED,UAAM,YAAY,GAAG,KAAK,iBAAL,CAAuB,eAAe,CAAC,gBAAvC,CAArB;;AACA,UAAI,YAAY,KAAK,IAAjB,IAAyB,YAAY,CAAC,QAAb,KAA0B,IAAvD,EAA6D;AAC3D,eAAO,IAAP;AACD;;AAED,UAAM,UAAU,GAAG,KAAK,iBAAL,CAAuB,YAAvB,CAAnB;;AACA,UAAI,UAAU,KAAK,IAAnB,EAAyB;AACvB,eAAO,IAAP;AACD;;AAED,aAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA;AACE,QAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW;AADnB,OAAA,EAEK,UAFL,CAAA,EAEe;AACb,QAAA,WAAW,EAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACN,YADM,CAAA,EACM;AACf,UAAA,QAAQ,EAAE,YAAY,CAAC;AADR,SADN;AADE,OAFf,CAAA;AAQD,KArCO;;AAuCA,IAAA,aAAA,CAAA,SAAA,CAAA,6BAAA,GAAR,UAAsC,UAAtC,EAAqD;AAEnD,UAAI,UAAU,YAAY,UAAA,CAAA,aAA1B,EAAyC;AACvC,QAAA,UAAU,GAAG,UAAU,CAAC,GAAxB;AACD;;AAED,UAAM,gBAAgB,GAAG,KAAK,YAAL,CAAkB,WAAlB,CAA8B,mBAA9B,CAAkD,UAAlD,CAAzB;;AACA,UAAI,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,eAAO,KAAK,SAAL,CAAe,gBAAf,CAAP;AACD,OATkD,CAWnD;AACA;;;AACA,UAAM,QAAQ,GAAI,UAAU,YAAY,UAAA,CAAA,aAAtB,IAAuC,UAAU,YAAY,UAAA,CAAA,UAA9D,GACb,UAAU,CAAC,QADE,GAEb,UAAU,CAAC,UAFf;AAIA,UAAI,IAAI,GAAG,UAAA,CAAA,qBAAA,CACP,KAAK,cADE,EACc;AAAC,QAAA,QAAQ,EAAA,QAAT;AAAW,QAAA,MAAM,EAAE,gBAAC,CAAD,EAAW;AAAmB,iBAAA,IAAA;AAAI;AAArD,OADd,CAAX;;AAEA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,eAAO,IAAP;AACD;;AAED,aAAO,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAP,EAA2C;AACzC,QAAA,IAAI,GAAG,IAAI,CAAC,UAAZ;AACD,OAzBkD,CA2BnD;AACA;AACA;AACA;AACA;;;AACA,UAAI,CAAC,UAAU,YAAY,UAAA,CAAA,gBAAtB,IAA0C,UAAU,YAAY,UAAA,CAAA,cAAjE,KACA,EAAE,CAAC,uBAAH,CAA2B,IAA3B,CADJ,EACsC;AACpC,YAAM,cAAc,GACf,UAAU,YAAY,UAAA,CAAA,cAAtB,IAAwC,EAAE,CAAC,gBAAH,CAAoB,IAAI,CAAC,QAAzB,CAAzC,GACA,KAAK,iBAAL,CAAuB,IAAI,CAAC,QAAL,CAAc,UAArC,CADA,GAEA,KAAK,iBAAL,CAAuB,IAAI,CAAC,QAA5B,CAHJ;;AAIA,YAAI,cAAc,KAAK,IAAvB,EAA6B;AAC3B,iBAAO,IAAP;AACD;;AAED,eAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACK,cADL,CAAA,EACmB;AACjB,UAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW,UADA;AAEjB;AACA;AACA,UAAA,MAAM,EAAE,KAAK,cAAL,GAAsB,iBAAtB,CAAwC,IAAxC;AAJS,SADnB,CAAA;AAOD,OAjBD,MAiBO;AACL,YAAM,UAAU,GAAG,KAAK,iBAAL,CAAuB,IAAvB,CAAnB;AACA,eAAO,UAAU,KAAK,IAAf,GAAsB,IAAtB,GAA4B,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAAK,UAAL,CAAA,EAAe;AAAE,UAAA,IAAI,EAAE,KAAA,CAAA,UAAA,CAAW;AAAnB,SAAf,CAAnC;AACD;AACF,KArDO;;AAuDA,IAAA,aAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,IAA1B,EAAuC;;;AACrC,aAAO,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAP,EAA2C;AACzC,QAAA,IAAI,GAAG,IAAI,CAAC,UAAZ;AACD;;AAED,UAAI,QAAJ;;AACA,UAAI,EAAE,CAAC,0BAAH,CAA8B,IAA9B,CAAJ,EAAyC;AACvC,QAAA,QAAQ,GAAG,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,IAAI,CAAC,IAA/C,CAAX;AACD,OAFD,MAEO,IAAI,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAJ,EAAwC;AAC7C,QAAA,QAAQ,GAAG,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,IAAI,CAAC,kBAA/C,CAAX;AACD,OAFM,MAEA;AACL,QAAA,QAAQ,GAAG,KAAK,cAAL,GAAsB,mBAAtB,CAA0C,IAA1C,CAAX;AACD;;AAED,UAAM,kBAAkB,GAAG,KAAK,sBAAL,CAA4B,IAA5B,CAA3B;AACA,UAAM,IAAI,GAAG,KAAK,cAAL,GAAsB,iBAAtB,CAAwC,IAAxC,CAAb;AACA,aAAO;AACL;AACA;AACA;AACA,QAAA,QAAQ,EAAA,CAAA,EAAA,GAAE,QAAQ,KAAA,IAAR,IAAA,QAAQ,KAAA,KAAA,CAAR,GAAA,QAAA,GAAY,IAAI,CAAC,MAAnB,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,EAAzB,GAA6B,IAJhC;AAKL,QAAA,MAAM,EAAE,IALH;AAML,QAAA,YAAY,EAAE;AAAC,UAAA,QAAQ,EAAE,KAAK,QAAhB;AAA0B,UAAA,kBAAkB,EAAA;AAA5C;AANT,OAAP;AAQD,KAxBO;;AA0BA,IAAA,aAAA,CAAA,SAAA,CAAA,sBAAA,GAAR,UAA+B,IAA/B,EAA4C;AAC1C,UAAI,EAAE,CAAC,mBAAH,CAAuB,IAAvB,CAAJ,EAAkC;AAChC,eAAO,KAAK,sBAAL,CAA4B,IAAI,CAAC,QAAjC,CAAP;AACD,OAFD,MAEO,IAAI,EAAE,CAAC,eAAH,CAAmB,IAAnB,CAAJ,EAA8B;AACnC,eAAO,IAAI,CAAC,KAAL,CAAW,QAAX,EAAP;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,0BAAH,CAA8B,IAA9B,CAAJ,EAAyC;AAC9C,eAAO,IAAI,CAAC,IAAL,CAAU,QAAV,EAAP;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAJ,EAAwC;AAC7C,eAAO,IAAI,CAAC,kBAAL,CAAwB,QAAxB,EAAP;AACD,OAFM,MAEA;AACL,eAAO,IAAI,CAAC,QAAL,EAAP;AACD;AACF,KAZO;;AAaV,WAAA,aAAA;AAAC,GAzhBD,EAAA;;AAAa,EAAA,OAAA,CAAA,aAAA,GAAA,aAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, ASTWithSource, BindingPipe, MethodCall, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstTextAttribute, TmplAstVariable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {ClassDeclaration} from '../../reflection';\nimport {ComponentScopeReader} from '../../scope';\nimport {isAssignment} from '../../util/src/typescript';\nimport {BindingSymbol, DirectiveSymbol, DomBindingSymbol, ElementSymbol, ExpressionSymbol, InputBindingSymbol, OutputBindingSymbol, PipeSymbol, ReferenceSymbol, ShimLocation, Symbol, SymbolKind, TemplateSymbol, TsNodeSymbolInfo, TypeCheckableDirectiveMeta, VariableSymbol} from '../api';\n\nimport {ExpressionIdentifier, findAllMatchingNodes, findFirstMatchingNode, hasExpressionIdentifier} from './comments';\nimport {TemplateData} from './context';\nimport {isAccessExpression} from './ts_util';\n\n/**\n * Generates and caches `Symbol`s for various template structures for a given component.\n *\n * The `SymbolBuilder` internally caches the `Symbol`s it creates, and must be destroyed and\n * replaced if the component's template changes.\n */\nexport class SymbolBuilder {\n  private symbolCache = new Map<AST|TmplAstNode, Symbol|null>();\n\n  constructor(\n      private readonly shimPath: AbsoluteFsPath,\n      private readonly typeCheckBlock: ts.Node,\n      private readonly templateData: TemplateData,\n      private readonly componentScopeReader: ComponentScopeReader,\n      // The `ts.TypeChecker` depends on the current type-checking program, and so must be requested\n      // on-demand instead of cached.\n      private readonly getTypeChecker: () => ts.TypeChecker,\n  ) {}\n\n  getSymbol(node: TmplAstTemplate|TmplAstElement): TemplateSymbol|ElementSymbol|null;\n  getSymbol(node: TmplAstReference|TmplAstVariable): ReferenceSymbol|VariableSymbol|null;\n  getSymbol(node: AST|TmplAstNode): Symbol|null;\n  getSymbol(node: AST|TmplAstNode): Symbol|null {\n    if (this.symbolCache.has(node)) {\n      return this.symbolCache.get(node)!;\n    }\n\n    let symbol: Symbol|null = null;\n    if (node instanceof TmplAstBoundAttribute || node instanceof TmplAstTextAttribute) {\n      // TODO(atscott): input and output bindings only return the first directive match but should\n      // return a list of bindings for all of them.\n      symbol = this.getSymbolOfInputBinding(node);\n    } else if (node instanceof TmplAstBoundEvent) {\n      symbol = this.getSymbolOfBoundEvent(node);\n    } else if (node instanceof TmplAstElement) {\n      symbol = this.getSymbolOfElement(node);\n    } else if (node instanceof TmplAstTemplate) {\n      symbol = this.getSymbolOfAstTemplate(node);\n    } else if (node instanceof TmplAstVariable) {\n      symbol = this.getSymbolOfVariable(node);\n    } else if (node instanceof TmplAstReference) {\n      symbol = this.getSymbolOfReference(node);\n    } else if (node instanceof BindingPipe) {\n      symbol = this.getSymbolOfPipe(node);\n    } else if (node instanceof AST) {\n      symbol = this.getSymbolOfTemplateExpression(node);\n    } else {\n      // TODO(atscott): TmplAstContent, TmplAstIcu\n    }\n\n    this.symbolCache.set(node, symbol);\n    return symbol;\n  }\n\n  private getSymbolOfAstTemplate(template: TmplAstTemplate): TemplateSymbol|null {\n    const directives = this.getDirectivesOfNode(template);\n    return {kind: SymbolKind.Template, directives, templateNode: template};\n  }\n\n  private getSymbolOfElement(element: TmplAstElement): ElementSymbol|null {\n    const elementSourceSpan = element.startSourceSpan ?? element.sourceSpan;\n\n    const node = findFirstMatchingNode(\n        this.typeCheckBlock, {withSpan: elementSourceSpan, filter: ts.isVariableDeclaration});\n    if (node === null) {\n      return null;\n    }\n\n    const symbolFromDeclaration = this.getSymbolOfTsNode(node);\n    if (symbolFromDeclaration === null || symbolFromDeclaration.tsSymbol === null) {\n      return null;\n    }\n\n    const directives = this.getDirectivesOfNode(element);\n    // All statements in the TCB are `Expression`s that optionally include more information.\n    // An `ElementSymbol` uses the information returned for the variable declaration expression,\n    // adds the directives for the element, and updates the `kind` to be `SymbolKind.Element`.\n    return {\n      ...symbolFromDeclaration,\n      kind: SymbolKind.Element,\n      directives,\n      templateNode: element,\n    };\n  }\n\n  private getDirectivesOfNode(element: TmplAstElement|TmplAstTemplate): DirectiveSymbol[] {\n    const elementSourceSpan = element.startSourceSpan ?? element.sourceSpan;\n    const tcbSourceFile = this.typeCheckBlock.getSourceFile();\n    // directives could be either:\n    // - var _t1: TestDir /*T:D*/ = (null!);\n    // - var _t1 /*T:D*/ = _ctor1({});\n    const isDirectiveDeclaration = (node: ts.Node): node is ts.TypeNode|ts.Identifier =>\n        (ts.isTypeNode(node) || ts.isIdentifier(node)) && ts.isVariableDeclaration(node.parent) &&\n        hasExpressionIdentifier(tcbSourceFile, node, ExpressionIdentifier.DIRECTIVE);\n\n    const nodes = findAllMatchingNodes(\n        this.typeCheckBlock, {withSpan: elementSourceSpan, filter: isDirectiveDeclaration});\n    return nodes\n        .map(node => {\n          const symbol = this.getSymbolOfTsNode(node.parent);\n          if (symbol === null || symbol.tsSymbol === null ||\n              symbol.tsSymbol.valueDeclaration === undefined ||\n              !ts.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n            return null;\n          }\n          const meta = this.getDirectiveMeta(element, symbol.tsSymbol.valueDeclaration);\n          if (meta === null) {\n            return null;\n          }\n\n          const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);\n          if (meta.selector === null) {\n            return null;\n          }\n          const isComponent = meta.isComponent ?? null;\n          const directiveSymbol: DirectiveSymbol = {\n            ...symbol,\n            tsSymbol: symbol.tsSymbol,\n            selector: meta.selector,\n            isComponent,\n            ngModule,\n            kind: SymbolKind.Directive,\n            isStructural: meta.isStructural,\n          };\n          return directiveSymbol;\n        })\n        .filter((d): d is DirectiveSymbol => d !== null);\n  }\n\n  private getDirectiveMeta(\n      host: TmplAstTemplate|TmplAstElement,\n      directiveDeclaration: ts.Declaration): TypeCheckableDirectiveMeta|null {\n    const directives = this.templateData.boundTarget.getDirectivesOfNode(host);\n    if (directives === null) {\n      return null;\n    }\n\n    return directives.find(m => m.ref.node === directiveDeclaration) ?? null;\n  }\n\n  private getDirectiveModule(declaration: ts.ClassDeclaration): ClassDeclaration|null {\n    const scope = this.componentScopeReader.getScopeForComponent(declaration as ClassDeclaration);\n    if (scope === null) {\n      return null;\n    }\n    return scope.ngModule;\n  }\n\n  private getSymbolOfBoundEvent(eventBinding: TmplAstBoundEvent): OutputBindingSymbol|null {\n    const consumer = this.templateData.boundTarget.getConsumerOfBinding(eventBinding);\n    if (consumer === null) {\n      return null;\n    }\n\n    // Outputs in the TCB look like one of the two:\n    // * _t1[\"outputField\"].subscribe(handler);\n    // * _t1.addEventListener(handler);\n    // Even with strict null checks disabled, we still produce the access as a separate statement\n    // so that it can be found here.\n    let expectedAccess: string;\n    if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n      expectedAccess = 'addEventListener';\n    } else {\n      const bindingPropertyNames = consumer.outputs.getByBindingPropertyName(eventBinding.name);\n      if (bindingPropertyNames === null || bindingPropertyNames.length === 0) {\n        return null;\n      }\n      // Note that we only get the expectedAccess text from a single consumer of the binding. If\n      // there are multiple consumers (not supported in the `boundTarget` API) and one of them has\n      // an alias, it will not get matched here.\n      expectedAccess = bindingPropertyNames[0].classPropertyName;\n    }\n\n    function filter(n: ts.Node): n is ts.PropertyAccessExpression|ts.ElementAccessExpression {\n      if (!isAccessExpression(n)) {\n        return false;\n      }\n\n      if (ts.isPropertyAccessExpression(n)) {\n        return n.name.getText() === expectedAccess;\n      } else {\n        return ts.isStringLiteral(n.argumentExpression) &&\n            n.argumentExpression.text === expectedAccess;\n      }\n    }\n    const outputFieldAccesses =\n        findAllMatchingNodes(this.typeCheckBlock, {withSpan: eventBinding.keySpan, filter});\n\n    const bindings: BindingSymbol[] = [];\n    for (const outputFieldAccess of outputFieldAccesses) {\n      if (consumer instanceof TmplAstTemplate || consumer instanceof TmplAstElement) {\n        if (!ts.isPropertyAccessExpression(outputFieldAccess)) {\n          continue;\n        }\n\n        const addEventListener = outputFieldAccess.name;\n        const tsSymbol = this.getTypeChecker().getSymbolAtLocation(addEventListener);\n        const tsType = this.getTypeChecker().getTypeAtLocation(addEventListener);\n        const positionInShimFile = this.getShimPositionForNode(addEventListener);\n        const target = this.getSymbol(consumer);\n\n        if (target === null || tsSymbol === undefined) {\n          continue;\n        }\n\n        bindings.push({\n          kind: SymbolKind.Binding,\n          tsSymbol,\n          tsType,\n          target,\n          shimLocation: {shimPath: this.shimPath, positionInShimFile},\n        });\n      } else {\n        if (!ts.isElementAccessExpression(outputFieldAccess)) {\n          continue;\n        }\n        const tsSymbol =\n            this.getTypeChecker().getSymbolAtLocation(outputFieldAccess.argumentExpression);\n        if (tsSymbol === undefined) {\n          continue;\n        }\n\n\n        const target = this.getDirectiveSymbolForAccessExpression(outputFieldAccess, consumer);\n        if (target === null) {\n          continue;\n        }\n\n        const positionInShimFile = this.getShimPositionForNode(outputFieldAccess);\n        const tsType = this.getTypeChecker().getTypeAtLocation(outputFieldAccess);\n        bindings.push({\n          kind: SymbolKind.Binding,\n          tsSymbol,\n          tsType,\n          target,\n          shimLocation: {shimPath: this.shimPath, positionInShimFile},\n        });\n      }\n    }\n\n    if (bindings.length === 0) {\n      return null;\n    }\n    return {kind: SymbolKind.Output, bindings};\n  }\n\n  private getSymbolOfInputBinding(binding: TmplAstBoundAttribute|\n                                  TmplAstTextAttribute): InputBindingSymbol|DomBindingSymbol|null {\n    const consumer = this.templateData.boundTarget.getConsumerOfBinding(binding);\n    if (consumer === null) {\n      return null;\n    }\n\n    if (consumer instanceof TmplAstElement || consumer instanceof TmplAstTemplate) {\n      const host = this.getSymbol(consumer);\n      return host !== null ? {kind: SymbolKind.DomBinding, host} : null;\n    }\n\n    const nodes = findAllMatchingNodes(\n        this.typeCheckBlock, {withSpan: binding.sourceSpan, filter: isAssignment});\n    const bindings: BindingSymbol[] = [];\n    for (const node of nodes) {\n      if (!isAccessExpression(node.left)) {\n        continue;\n      }\n\n      const symbolInfo = this.getSymbolOfTsNode(node.left);\n      if (symbolInfo === null || symbolInfo.tsSymbol === null) {\n        continue;\n      }\n\n      const target = this.getDirectiveSymbolForAccessExpression(node.left, consumer);\n      if (target === null) {\n        continue;\n      }\n      bindings.push({\n        ...symbolInfo,\n        tsSymbol: symbolInfo.tsSymbol,\n        kind: SymbolKind.Binding,\n        target,\n      });\n    }\n    if (bindings.length === 0) {\n      return null;\n    }\n\n    return {kind: SymbolKind.Input, bindings};\n  }\n\n  private getDirectiveSymbolForAccessExpression(\n      node: ts.ElementAccessExpression|ts.PropertyAccessExpression,\n      {isComponent, selector, isStructural}: TypeCheckableDirectiveMeta): DirectiveSymbol|null {\n    // In either case, `_t1[\"index\"]` or `_t1.index`, `node.expression` is _t1.\n    // The retrieved symbol for _t1 will be the variable declaration.\n    const tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.expression);\n    if (tsSymbol === undefined || tsSymbol.declarations.length === 0 || selector === null) {\n      return null;\n    }\n\n    const [declaration] = tsSymbol.declarations;\n    if (!ts.isVariableDeclaration(declaration) ||\n        !hasExpressionIdentifier(\n            // The expression identifier could be on the type (for regular directives) or the name\n            // (for generic directives and the ctor op).\n            declaration.getSourceFile(), declaration.type ?? declaration.name,\n            ExpressionIdentifier.DIRECTIVE)) {\n      return null;\n    }\n\n    const symbol = this.getSymbolOfTsNode(declaration);\n    if (symbol === null || symbol.tsSymbol === null ||\n        symbol.tsSymbol.valueDeclaration === undefined ||\n        !ts.isClassDeclaration(symbol.tsSymbol.valueDeclaration)) {\n      return null;\n    }\n\n    const ngModule = this.getDirectiveModule(symbol.tsSymbol.valueDeclaration);\n    return {\n      kind: SymbolKind.Directive,\n      tsSymbol: symbol.tsSymbol,\n      tsType: symbol.tsType,\n      shimLocation: symbol.shimLocation,\n      isComponent,\n      isStructural,\n      selector,\n      ngModule,\n    };\n  }\n\n  private getSymbolOfVariable(variable: TmplAstVariable): VariableSymbol|null {\n    const node = findFirstMatchingNode(\n        this.typeCheckBlock, {withSpan: variable.sourceSpan, filter: ts.isVariableDeclaration});\n    if (node === null || node.initializer === undefined) {\n      return null;\n    }\n\n    const expressionSymbol = this.getSymbolOfTsNode(node.initializer);\n    if (expressionSymbol === null) {\n      return null;\n    }\n\n    return {\n      tsType: expressionSymbol.tsType,\n      tsSymbol: expressionSymbol.tsSymbol,\n      initializerLocation: expressionSymbol.shimLocation,\n      kind: SymbolKind.Variable,\n      declaration: variable,\n      localVarLocation: {\n        shimPath: this.shimPath,\n        positionInShimFile: this.getShimPositionForNode(node.name),\n      }\n    };\n  }\n\n  private getSymbolOfReference(ref: TmplAstReference): ReferenceSymbol|null {\n    const target = this.templateData.boundTarget.getReferenceTarget(ref);\n    // Find the node for the reference declaration, i.e. `var _t2 = _t1;`\n    let node = findFirstMatchingNode(\n        this.typeCheckBlock, {withSpan: ref.sourceSpan, filter: ts.isVariableDeclaration});\n    if (node === null || target === null || node.initializer === undefined) {\n      return null;\n    }\n\n    // Get the original declaration for the references variable, with the exception of template refs\n    // which are of the form var _t3 = (_t2 as any as i2.TemplateRef<any>)\n    // TODO(atscott): Consider adding an `ExpressionIdentifier` to tag variable declaration\n    // initializers as invalid for symbol retrieval.\n    const originalDeclaration = ts.isParenthesizedExpression(node.initializer) &&\n            ts.isAsExpression(node.initializer.expression) ?\n        this.getTypeChecker().getSymbolAtLocation(node.name) :\n        this.getTypeChecker().getSymbolAtLocation(node.initializer);\n    if (originalDeclaration === undefined || originalDeclaration.valueDeclaration === undefined) {\n      return null;\n    }\n    const symbol = this.getSymbolOfTsNode(originalDeclaration.valueDeclaration);\n    if (symbol === null || symbol.tsSymbol === null) {\n      return null;\n    }\n\n    const referenceVarShimLocation: ShimLocation = {\n      shimPath: this.shimPath,\n      positionInShimFile: this.getShimPositionForNode(node),\n    };\n    if (target instanceof TmplAstTemplate || target instanceof TmplAstElement) {\n      return {\n        kind: SymbolKind.Reference,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        target,\n        declaration: ref,\n        targetLocation: symbol.shimLocation,\n        referenceVarLocation: referenceVarShimLocation,\n      };\n    } else {\n      if (!ts.isClassDeclaration(target.directive.ref.node)) {\n        return null;\n      }\n\n      return {\n        kind: SymbolKind.Reference,\n        tsSymbol: symbol.tsSymbol,\n        tsType: symbol.tsType,\n        declaration: ref,\n        target: target.directive.ref.node,\n        targetLocation: symbol.shimLocation,\n        referenceVarLocation: referenceVarShimLocation,\n      };\n    }\n  }\n\n  private getSymbolOfPipe(expression: BindingPipe): PipeSymbol|null {\n    const node = findFirstMatchingNode(\n        this.typeCheckBlock, {withSpan: expression.sourceSpan, filter: ts.isCallExpression});\n    if (node === null || !ts.isPropertyAccessExpression(node.expression)) {\n      return null;\n    }\n\n    const methodAccess = node.expression;\n    // Find the node for the pipe variable from the transform property access. This will be one of\n    // two forms: `_pipe1.transform` or `(_pipe1 as any).transform`.\n    const pipeVariableNode = ts.isParenthesizedExpression(methodAccess.expression) &&\n            ts.isAsExpression(methodAccess.expression.expression) ?\n        methodAccess.expression.expression.expression :\n        methodAccess.expression;\n    const pipeDeclaration = this.getTypeChecker().getSymbolAtLocation(pipeVariableNode);\n    if (pipeDeclaration === undefined || pipeDeclaration.valueDeclaration === undefined) {\n      return null;\n    }\n\n    const pipeInstance = this.getSymbolOfTsNode(pipeDeclaration.valueDeclaration);\n    if (pipeInstance === null || pipeInstance.tsSymbol === null) {\n      return null;\n    }\n\n    const symbolInfo = this.getSymbolOfTsNode(methodAccess);\n    if (symbolInfo === null) {\n      return null;\n    }\n\n    return {\n      kind: SymbolKind.Pipe,\n      ...symbolInfo,\n      classSymbol: {\n        ...pipeInstance,\n        tsSymbol: pipeInstance.tsSymbol,\n      },\n    };\n  }\n\n  private getSymbolOfTemplateExpression(expression: AST): VariableSymbol|ReferenceSymbol\n      |ExpressionSymbol|null {\n    if (expression instanceof ASTWithSource) {\n      expression = expression.ast;\n    }\n\n    const expressionTarget = this.templateData.boundTarget.getExpressionTarget(expression);\n    if (expressionTarget !== null) {\n      return this.getSymbol(expressionTarget);\n    }\n\n    // The `name` part of a `PropertyWrite` and `MethodCall` does not have its own\n    // AST so there is no way to retrieve a `Symbol` for just the `name` via a specific node.\n    const withSpan = (expression instanceof PropertyWrite || expression instanceof MethodCall) ?\n        expression.nameSpan :\n        expression.sourceSpan;\n\n    let node = findFirstMatchingNode(\n        this.typeCheckBlock, {withSpan, filter: (n: ts.Node): n is ts.Node => true});\n    if (node === null) {\n      return null;\n    }\n\n    while (ts.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n\n    // - If we have safe property read (\"a?.b\") we want to get the Symbol for b, the `whenTrue`\n    // expression.\n    // - If our expression is a pipe binding (\"a | test:b:c\"), we want the Symbol for the\n    // `transform` on the pipe.\n    // - Otherwise, we retrieve the symbol for the node itself with no special considerations\n    if ((expression instanceof SafePropertyRead || expression instanceof SafeMethodCall) &&\n        ts.isConditionalExpression(node)) {\n      const whenTrueSymbol =\n          (expression instanceof SafeMethodCall && ts.isCallExpression(node.whenTrue)) ?\n          this.getSymbolOfTsNode(node.whenTrue.expression) :\n          this.getSymbolOfTsNode(node.whenTrue);\n      if (whenTrueSymbol === null) {\n        return null;\n      }\n\n      return {\n        ...whenTrueSymbol,\n        kind: SymbolKind.Expression,\n        // Rather than using the type of only the `whenTrue` part of the expression, we should\n        // still get the type of the whole conditional expression to include `|undefined`.\n        tsType: this.getTypeChecker().getTypeAtLocation(node)\n      };\n    } else {\n      const symbolInfo = this.getSymbolOfTsNode(node);\n      return symbolInfo === null ? null : {...symbolInfo, kind: SymbolKind.Expression};\n    }\n  }\n\n  private getSymbolOfTsNode(node: ts.Node): TsNodeSymbolInfo|null {\n    while (ts.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n\n    let tsSymbol: ts.Symbol|undefined;\n    if (ts.isPropertyAccessExpression(node)) {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.name);\n    } else if (ts.isElementAccessExpression(node)) {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node.argumentExpression);\n    } else {\n      tsSymbol = this.getTypeChecker().getSymbolAtLocation(node);\n    }\n\n    const positionInShimFile = this.getShimPositionForNode(node);\n    const type = this.getTypeChecker().getTypeAtLocation(node);\n    return {\n      // If we could not find a symbol, fall back to the symbol on the type for the node.\n      // Some nodes won't have a \"symbol at location\" but will have a symbol for the type.\n      // Examples of this would be literals and `document.createElement('div')`.\n      tsSymbol: tsSymbol ?? type.symbol ?? null,\n      tsType: type,\n      shimLocation: {shimPath: this.shimPath, positionInShimFile},\n    };\n  }\n\n  private getShimPositionForNode(node: ts.Node): number {\n    if (ts.isTypeReferenceNode(node)) {\n      return this.getShimPositionForNode(node.typeName);\n    } else if (ts.isQualifiedName(node)) {\n      return node.right.getStart();\n    } else if (ts.isPropertyAccessExpression(node)) {\n      return node.name.getStart();\n    } else if (ts.isElementAccessExpression(node)) {\n      return node.argumentExpression.getStart();\n    } else {\n      return node.getStart();\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}