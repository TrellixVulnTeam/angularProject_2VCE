{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/dependencies/commonjs_dependency_host\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/ngcc/src/host/commonjs_umd_utils\", \"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.hasRequireCalls = exports.CommonJsDependencyHost = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var commonjs_umd_utils_1 = require(\"@angular/compiler-cli/ngcc/src/host/commonjs_umd_utils\");\n\n  var dependency_host_1 = require(\"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\");\n  /**\n   * Helper functions for computing dependencies.\n   */\n\n\n  var CommonJsDependencyHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(CommonJsDependencyHost, _super);\n\n    function CommonJsDependencyHost() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    CommonJsDependencyHost.prototype.canSkipFile = function (fileContents) {\n      return !hasRequireCalls(fileContents);\n    };\n\n    CommonJsDependencyHost.prototype.extractImports = function (file, fileContents) {\n      var e_1, _a, e_2, _b; // Parse the source into a TypeScript AST and then walk it looking for imports and re-exports.\n\n\n      var sf = ts.createSourceFile(file, fileContents, ts.ScriptTarget.ES2015, false, ts.ScriptKind.JS);\n      var requireCalls = [];\n\n      try {\n        for (var _c = tslib_1.__values(sf.statements), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var stmt = _d.value;\n\n          if (ts.isVariableStatement(stmt)) {\n            // Regular import(s):\n            // `var foo = require('...')` or `var foo = require('...'), bar = require('...')`\n            var declarations = stmt.declarationList.declarations;\n\n            try {\n              for (var declarations_1 = (e_2 = void 0, tslib_1.__values(declarations)), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {\n                var declaration = declarations_1_1.value;\n\n                if (declaration.initializer !== undefined && commonjs_umd_utils_1.isRequireCall(declaration.initializer)) {\n                  requireCalls.push(declaration.initializer);\n                }\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n          } else if (ts.isExpressionStatement(stmt)) {\n            if (commonjs_umd_utils_1.isRequireCall(stmt.expression)) {\n              // Import for the side-effects only:\n              // `require('...')`\n              requireCalls.push(stmt.expression);\n            } else if (commonjs_umd_utils_1.isWildcardReexportStatement(stmt)) {\n              // Re-export in one of the following formats:\n              // - `__export(require('...'))`\n              // - `__export(<identifier>)`\n              // - `tslib_1.__exportStar(require('...'), exports)`\n              // - `tslib_1.__exportStar(<identifier>, exports)`\n              var firstExportArg = stmt.expression.arguments[0];\n\n              if (commonjs_umd_utils_1.isRequireCall(firstExportArg)) {\n                // Re-export with `require()` call:\n                // `__export(require('...'))` or `tslib_1.__exportStar(require('...'), exports)`\n                requireCalls.push(firstExportArg);\n              }\n            } else if (ts.isBinaryExpression(stmt.expression) && stmt.expression.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n              if (commonjs_umd_utils_1.isRequireCall(stmt.expression.right)) {\n                // Import with assignment. E.g.:\n                // `exports.foo = require('...')`\n                requireCalls.push(stmt.expression.right);\n              } else if (ts.isObjectLiteralExpression(stmt.expression.right)) {\n                // Import in object literal. E.g.:\n                // `module.exports = {foo: require('...')}`\n                stmt.expression.right.properties.forEach(function (prop) {\n                  if (ts.isPropertyAssignment(prop) && commonjs_umd_utils_1.isRequireCall(prop.initializer)) {\n                    requireCalls.push(prop.initializer);\n                  }\n                });\n              }\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return new Set(requireCalls.map(function (call) {\n        return call.arguments[0].text;\n      }));\n    };\n\n    return CommonJsDependencyHost;\n  }(dependency_host_1.DependencyHostBase);\n\n  exports.CommonJsDependencyHost = CommonJsDependencyHost;\n  /**\n   * Check whether a source file needs to be parsed for imports.\n   * This is a performance short-circuit, which saves us from creating\n   * a TypeScript AST unnecessarily.\n   *\n   * @param source The content of the source file to check.\n   *\n   * @returns false if there are definitely no require calls\n   * in this file, true otherwise.\n   */\n\n  function hasRequireCalls(source) {\n    return /require\\(['\"]/.test(source);\n  }\n\n  exports.hasRequireCalls = hasRequireCalls;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/dependencies/commonjs_dependency_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../../src/ngtsc/file_system';\nimport {isRequireCall, isWildcardReexportStatement, RequireCall} from '../host/commonjs_umd_utils';\n\nimport {DependencyHostBase} from './dependency_host';\n\n/**\n * Helper functions for computing dependencies.\n */\nexport class CommonJsDependencyHost extends DependencyHostBase {\n  protected canSkipFile(fileContents: string): boolean {\n    return !hasRequireCalls(fileContents);\n  }\n\n  protected extractImports(file: AbsoluteFsPath, fileContents: string): Set<string> {\n    // Parse the source into a TypeScript AST and then walk it looking for imports and re-exports.\n    const sf =\n        ts.createSourceFile(file, fileContents, ts.ScriptTarget.ES2015, false, ts.ScriptKind.JS);\n    const requireCalls: RequireCall[] = [];\n\n    for (const stmt of sf.statements) {\n      if (ts.isVariableStatement(stmt)) {\n        // Regular import(s):\n        // `var foo = require('...')` or `var foo = require('...'), bar = require('...')`\n        const declarations = stmt.declarationList.declarations;\n        for (const declaration of declarations) {\n          if ((declaration.initializer !== undefined) && isRequireCall(declaration.initializer)) {\n            requireCalls.push(declaration.initializer);\n          }\n        }\n      } else if (ts.isExpressionStatement(stmt)) {\n        if (isRequireCall(stmt.expression)) {\n          // Import for the side-effects only:\n          // `require('...')`\n          requireCalls.push(stmt.expression);\n        } else if (isWildcardReexportStatement(stmt)) {\n          // Re-export in one of the following formats:\n          // - `__export(require('...'))`\n          // - `__export(<identifier>)`\n          // - `tslib_1.__exportStar(require('...'), exports)`\n          // - `tslib_1.__exportStar(<identifier>, exports)`\n          const firstExportArg = stmt.expression.arguments[0];\n\n          if (isRequireCall(firstExportArg)) {\n            // Re-export with `require()` call:\n            // `__export(require('...'))` or `tslib_1.__exportStar(require('...'), exports)`\n            requireCalls.push(firstExportArg);\n          }\n        } else if (\n            ts.isBinaryExpression(stmt.expression) &&\n            (stmt.expression.operatorToken.kind === ts.SyntaxKind.EqualsToken)) {\n          if (isRequireCall(stmt.expression.right)) {\n            // Import with assignment. E.g.:\n            // `exports.foo = require('...')`\n            requireCalls.push(stmt.expression.right);\n          } else if (ts.isObjectLiteralExpression(stmt.expression.right)) {\n            // Import in object literal. E.g.:\n            // `module.exports = {foo: require('...')}`\n            stmt.expression.right.properties.forEach(prop => {\n              if (ts.isPropertyAssignment(prop) && isRequireCall(prop.initializer)) {\n                requireCalls.push(prop.initializer);\n              }\n            });\n          }\n        }\n      }\n    }\n\n    return new Set(requireCalls.map(call => call.arguments[0].text));\n  }\n}\n\n/**\n * Check whether a source file needs to be parsed for imports.\n * This is a performance short-circuit, which saves us from creating\n * a TypeScript AST unnecessarily.\n *\n * @param source The content of the source file to check.\n *\n * @returns false if there are definitely no require calls\n * in this file, true otherwise.\n */\nexport function hasRequireCalls(source: string): boolean {\n  return /require\\(['\"]/.test(source);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}