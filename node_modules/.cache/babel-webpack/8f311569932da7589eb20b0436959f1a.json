{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/writing/cleaning/package_cleaner\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/packages/build_marker\", \"@angular/compiler-cli/ngcc/src/writing/cleaning/cleaning_strategies\", \"@angular/compiler-cli/ngcc/src/writing/cleaning/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.cleanOutdatedPackages = exports.PackageCleaner = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var build_marker_1 = require(\"@angular/compiler-cli/ngcc/src/packages/build_marker\");\n\n  var cleaning_strategies_1 = require(\"@angular/compiler-cli/ngcc/src/writing/cleaning/cleaning_strategies\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/writing/cleaning/utils\");\n  /**\n   * A class that can clean ngcc artifacts from a directory.\n   */\n\n\n  var PackageCleaner =\n  /** @class */\n  function () {\n    function PackageCleaner(fs, cleaners) {\n      this.fs = fs;\n      this.cleaners = cleaners;\n    }\n    /**\n     * Recurse through the file-system cleaning files and directories as determined by the configured\n     * cleaning-strategies.\n     *\n     * @param directory the current directory to clean\n     */\n\n\n    PackageCleaner.prototype.clean = function (directory) {\n      var e_1, _a, e_2, _b;\n\n      var basenames = this.fs.readdir(directory);\n\n      try {\n        for (var basenames_1 = tslib_1.__values(basenames), basenames_1_1 = basenames_1.next(); !basenames_1_1.done; basenames_1_1 = basenames_1.next()) {\n          var basename = basenames_1_1.value;\n\n          if (basename === 'node_modules') {\n            continue;\n          }\n\n          var path = this.fs.resolve(directory, basename);\n\n          try {\n            for (var _c = (e_2 = void 0, tslib_1.__values(this.cleaners)), _d = _c.next(); !_d.done; _d = _c.next()) {\n              var cleaner = _d.value;\n\n              if (cleaner.canClean(path, basename)) {\n                cleaner.clean(path, basename);\n                break;\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          } // Recurse into subdirectories (note that a cleaner may have removed this path)\n\n\n          if (utils_1.isLocalDirectory(this.fs, path)) {\n            this.clean(path);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (basenames_1_1 && !basenames_1_1.done && (_a = basenames_1.return)) _a.call(basenames_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    return PackageCleaner;\n  }();\n\n  exports.PackageCleaner = PackageCleaner;\n  /**\n   * Iterate through the given `entryPoints` identifying the package for each that has at least one\n   * outdated processed format, then cleaning those packages.\n   *\n   * Note that we have to clean entire packages because there is no clear file-system boundary\n   * between entry-points within a package. So if one entry-point is outdated we have to clean\n   * everything within that package.\n   *\n   * @param fileSystem the current file-system\n   * @param entryPoints the entry-points that have been collected for this run of ngcc\n   * @returns true if packages needed to be cleaned.\n   */\n\n  function cleanOutdatedPackages(fileSystem, entryPoints) {\n    var e_3, _a, e_4, _b;\n\n    var packagesToClean = new Set();\n\n    try {\n      for (var entryPoints_1 = tslib_1.__values(entryPoints), entryPoints_1_1 = entryPoints_1.next(); !entryPoints_1_1.done; entryPoints_1_1 = entryPoints_1.next()) {\n        var entryPoint = entryPoints_1_1.value;\n\n        if (build_marker_1.needsCleaning(entryPoint.packageJson)) {\n          packagesToClean.add(entryPoint.packagePath);\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (entryPoints_1_1 && !entryPoints_1_1.done && (_a = entryPoints_1.return)) _a.call(entryPoints_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    var cleaner = new PackageCleaner(fileSystem, [new cleaning_strategies_1.PackageJsonCleaner(fileSystem), new cleaning_strategies_1.NgccDirectoryCleaner(fileSystem), new cleaning_strategies_1.BackupFileCleaner(fileSystem)]);\n\n    try {\n      for (var packagesToClean_1 = tslib_1.__values(packagesToClean), packagesToClean_1_1 = packagesToClean_1.next(); !packagesToClean_1_1.done; packagesToClean_1_1 = packagesToClean_1.next()) {\n        var packagePath = packagesToClean_1_1.value;\n        cleaner.clean(packagePath);\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (packagesToClean_1_1 && !packagesToClean_1_1.done && (_b = packagesToClean_1.return)) _b.call(packagesToClean_1);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return packagesToClean.size > 0;\n  }\n\n  exports.cleanOutdatedPackages = cleanOutdatedPackages;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/ngcc/src/writing/cleaning/package_cleaner.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, FileSystem, ReadonlyFileSystem} from '../../../../src/ngtsc/file_system';\nimport {needsCleaning} from '../../packages/build_marker';\nimport {EntryPoint} from '../../packages/entry_point';\n\nimport {BackupFileCleaner, CleaningStrategy, NgccDirectoryCleaner, PackageJsonCleaner} from './cleaning_strategies';\nimport {isLocalDirectory} from './utils';\n\n/**\n * A class that can clean ngcc artifacts from a directory.\n */\nexport class PackageCleaner {\n  constructor(private fs: ReadonlyFileSystem, private cleaners: CleaningStrategy[]) {}\n\n  /**\n   * Recurse through the file-system cleaning files and directories as determined by the configured\n   * cleaning-strategies.\n   *\n   * @param directory the current directory to clean\n   */\n  clean(directory: AbsoluteFsPath) {\n    const basenames = this.fs.readdir(directory);\n    for (const basename of basenames) {\n      if (basename === 'node_modules') {\n        continue;\n      }\n\n      const path = this.fs.resolve(directory, basename);\n      for (const cleaner of this.cleaners) {\n        if (cleaner.canClean(path, basename)) {\n          cleaner.clean(path, basename);\n          break;\n        }\n      }\n      // Recurse into subdirectories (note that a cleaner may have removed this path)\n      if (isLocalDirectory(this.fs, path)) {\n        this.clean(path);\n      }\n    }\n  }\n}\n\n\n/**\n * Iterate through the given `entryPoints` identifying the package for each that has at least one\n * outdated processed format, then cleaning those packages.\n *\n * Note that we have to clean entire packages because there is no clear file-system boundary\n * between entry-points within a package. So if one entry-point is outdated we have to clean\n * everything within that package.\n *\n * @param fileSystem the current file-system\n * @param entryPoints the entry-points that have been collected for this run of ngcc\n * @returns true if packages needed to be cleaned.\n */\nexport function cleanOutdatedPackages(fileSystem: FileSystem, entryPoints: EntryPoint[]): boolean {\n  const packagesToClean = new Set<AbsoluteFsPath>();\n  for (const entryPoint of entryPoints) {\n    if (needsCleaning(entryPoint.packageJson)) {\n      packagesToClean.add(entryPoint.packagePath);\n    }\n  }\n\n  const cleaner = new PackageCleaner(fileSystem, [\n    new PackageJsonCleaner(fileSystem),\n    new NgccDirectoryCleaner(fileSystem),\n    new BackupFileCleaner(fileSystem),\n  ]);\n  for (const packagePath of packagesToClean) {\n    cleaner.clean(packagePath);\n  }\n\n  return packagesToClean.size > 0;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}