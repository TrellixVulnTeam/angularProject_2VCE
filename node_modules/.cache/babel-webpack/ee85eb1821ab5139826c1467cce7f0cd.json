{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _assertThisInitialized = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar _require2 = require('util'),\n    promisify = _require2.promisify;\n\nvar readdirp = require('readdirp');\n\nvar anymatch = require('anymatch').default;\n\nvar globParent = require('glob-parent');\n\nvar isGlob = require('is-glob');\n\nvar braces = require('braces');\n\nvar normalizePath = require('normalize-path');\n\nvar NodeFsHandler = require('./lib/nodefs-handler');\n\nvar FsEventsHandler = require('./lib/fsevents-handler');\n\nvar _require3 = require('./lib/constants'),\n    EV_ALL = _require3.EV_ALL,\n    EV_READY = _require3.EV_READY,\n    EV_ADD = _require3.EV_ADD,\n    EV_CHANGE = _require3.EV_CHANGE,\n    EV_UNLINK = _require3.EV_UNLINK,\n    EV_ADD_DIR = _require3.EV_ADD_DIR,\n    EV_UNLINK_DIR = _require3.EV_UNLINK_DIR,\n    EV_RAW = _require3.EV_RAW,\n    EV_ERROR = _require3.EV_ERROR,\n    STR_CLOSE = _require3.STR_CLOSE,\n    STR_END = _require3.STR_END,\n    BACK_SLASH_RE = _require3.BACK_SLASH_RE,\n    DOUBLE_SLASH_RE = _require3.DOUBLE_SLASH_RE,\n    SLASH_OR_BACK_SLASH_RE = _require3.SLASH_OR_BACK_SLASH_RE,\n    DOT_RE = _require3.DOT_RE,\n    REPLACER_RE = _require3.REPLACER_RE,\n    SLASH = _require3.SLASH,\n    SLASH_SLASH = _require3.SLASH_SLASH,\n    BRACE_START = _require3.BRACE_START,\n    BANG = _require3.BANG,\n    ONE_DOT = _require3.ONE_DOT,\n    TWO_DOTS = _require3.TWO_DOTS,\n    GLOBSTAR = _require3.GLOBSTAR,\n    SLASH_GLOBSTAR = _require3.SLASH_GLOBSTAR,\n    ANYMATCH_OPTS = _require3.ANYMATCH_OPTS,\n    STRING_TYPE = _require3.STRING_TYPE,\n    FUNCTION_TYPE = _require3.FUNCTION_TYPE,\n    EMPTY_STR = _require3.EMPTY_STR,\n    EMPTY_FN = _require3.EMPTY_FN,\n    isWindows = _require3.isWindows,\n    isMacos = _require3.isMacos,\n    isIBMi = _require3.isIBMi;\n\nvar stat = promisify(fs.stat);\nvar readdir = promisify(fs.readdir);\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nvar arrify = function arrify() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return Array.isArray(value) ? value : [value];\n};\n\nvar flatten = function flatten(list) {\n  var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  list.forEach(function (item) {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nvar unifyPaths = function unifyPaths(paths_) {\n  /**\n   * @type {Array<String>}\n   */\n  var paths = flatten(arrify(paths_));\n\n  if (!paths.every(function (p) {\n    return typeof p === STRING_TYPE;\n  })) {\n    throw new TypeError(\"Non-string provided as watch path: \".concat(paths));\n  }\n\n  return paths.map(normalizePathToUnix);\n}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n\n\nvar toUnix = function toUnix(string) {\n  var str = string.replace(BACK_SLASH_RE, SLASH);\n  var prepend = false;\n\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n\n  if (prepend) {\n    str = SLASH + str;\n  }\n\n  return str;\n}; // Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\n\n\nvar normalizePathToUnix = function normalizePathToUnix(path) {\n  return toUnix(sysPath.normalize(toUnix(path)));\n};\n\nvar normalizeIgnored = function normalizeIgnored() {\n  var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_STR;\n  return function (path) {\n    if (typeof path !== STRING_TYPE) return path;\n    return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n  };\n};\n\nvar getAbsolutePath = function getAbsolutePath(path, cwd) {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n\n  return sysPath.join(cwd, path);\n};\n\nvar undef = function undef(opts, key) {\n  return opts[key] === undefined;\n};\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\n\n\nvar DirEntry = /*#__PURE__*/function () {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  function DirEntry(dir, removeWatcher) {\n    _classCallCheck(this, DirEntry);\n\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n\n    this.items = new Set();\n  }\n\n  _createClass(DirEntry, [{\n    key: \"add\",\n    value: function add(item) {\n      var items = this.items;\n      if (!items) return;\n      if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n    }\n  }, {\n    key: \"remove\",\n    value: function () {\n      var _remove = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(item) {\n        var items, dir;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                items = this.items;\n\n                if (items) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 3:\n                items.delete(item);\n\n                if (!(items.size > 0)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 6:\n                dir = this.path;\n                _context.prev = 7;\n                _context.next = 10;\n                return readdir(dir);\n\n              case 10:\n                _context.next = 15;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](7);\n\n                if (this._removeWatcher) {\n                  this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n                }\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 12]]);\n      }));\n\n      function remove(_x) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }()\n  }, {\n    key: \"has\",\n    value: function has(item) {\n      var items = this.items;\n      if (!items) return;\n      return items.has(item);\n    }\n    /**\n     * @returns {Array<String>}\n     */\n\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var items = this.items;\n      if (!items) return;\n      return _toConsumableArray(items.values());\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.items.clear();\n      delete this.path;\n      delete this._removeWatcher;\n      delete this.items;\n      Object.freeze(this);\n    }\n  }]);\n\n  return DirEntry;\n}();\n\nvar STAT_METHOD_F = 'stat';\nvar STAT_METHOD_L = 'lstat';\n\nvar WatchHelper = /*#__PURE__*/function () {\n  function WatchHelper(path, watchPath, follow, fsw) {\n    _classCallCheck(this, WatchHelper);\n\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(function (parts) {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  _createClass(WatchHelper, [{\n    key: \"checkGlobSymlink\",\n    value: function checkGlobSymlink(entry) {\n      // only need to resolve once\n      // first entry should always have entry.parentDir === EMPTY_STR\n      if (this.globSymlink === undefined) {\n        this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n          realPath: entry.fullParentDir,\n          linkPath: this.fullWatchPath\n        };\n      }\n\n      if (this.globSymlink) {\n        return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n      }\n\n      return entry.fullPath;\n    }\n  }, {\n    key: \"entryPath\",\n    value: function entryPath(entry) {\n      return sysPath.join(this.watchPath, sysPath.relative(this.watchPath, this.checkGlobSymlink(entry)));\n    }\n  }, {\n    key: \"filterPath\",\n    value: function filterPath(entry) {\n      var stats = entry.stats;\n      if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n      var resolvedPath = this.entryPath(entry);\n      var matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;\n      return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n    }\n  }, {\n    key: \"getDirParts\",\n    value: function getDirParts(path) {\n      var _this = this;\n\n      if (!this.hasGlob) return [];\n      var parts = [];\n      var expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n      expandedPath.forEach(function (path) {\n        parts.push(sysPath.relative(_this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n      });\n      return parts;\n    }\n  }, {\n    key: \"filterDir\",\n    value: function filterDir(entry) {\n      if (this.hasGlob) {\n        var entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n        var globstar = false;\n        this.unmatchedGlob = !this.dirParts.some(function (parts) {\n          return parts.every(function (part, i) {\n            if (part === GLOBSTAR) globstar = true;\n            return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n          });\n        });\n      }\n\n      return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n    }\n  }]);\n\n  return WatchHelper;\n}();\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\n\n\nvar FSWatcher = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(FSWatcher, _EventEmitter);\n\n  var _super = _createSuper(FSWatcher);\n\n  // Not indenting methods for history sake; for now.\n  function FSWatcher(_opts) {\n    var _this2;\n\n    _classCallCheck(this, FSWatcher);\n\n    _this2 = _super.call(this);\n    var opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n\n    _this2._watched = new Map();\n    /** @type {Map<String, Array>} */\n\n    _this2._closers = new Map();\n    /** @type {Set<String>} */\n\n    _this2._ignoredPaths = new Set();\n    /** @type {Map<ThrottleType, Map>} */\n\n    _this2._throttled = new Map();\n    /** @type {Map<Path, String|Boolean>} */\n\n    _this2._symlinkPaths = new Map();\n    _this2._streams = new Set();\n    _this2.closed = false; // Set up default options.\n\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n    var canUseFsEvents = FsEventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    } // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n\n\n    if (isIBMi) {\n      opts.usePolling = true;\n    } // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n\n\n    var envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n    if (envPoll !== undefined) {\n      var envLower = envPoll.toLowerCase();\n\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n\n    var envInterval = process.env.CHOKIDAR_INTERVAL;\n\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    } // Editor atomic write normalization enabled by default with fs.watch\n\n\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) _this2._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    var awf = opts.awaitWriteFinish;\n\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      _this2._pendingWrites = new Map();\n    }\n\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    var readyCalls = 0;\n\n    _this2._emitReady = function () {\n      readyCalls++;\n\n      if (readyCalls >= _this2._readyCount) {\n        _this2._emitReady = EMPTY_FN;\n        _this2._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n        process.nextTick(function () {\n          return _this2.emit(EV_READY);\n        });\n      }\n    };\n\n    _this2._emitRaw = function () {\n      var _this3;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return (_this3 = _this2).emit.apply(_this3, [EV_RAW].concat(args));\n    };\n\n    _this2._readyEmitted = false;\n    _this2.options = opts; // Initialize with proper watcher.\n\n    if (opts.useFsEvents) {\n      _this2._fsEventsHandler = new FsEventsHandler(_assertThisInitialized(_this2));\n    } else {\n      _this2._nodeFsHandler = new NodeFsHandler(_assertThisInitialized(_this2));\n    } // You’re frozen when your heart’s not open.\n\n\n    Object.freeze(opts);\n    return _this2;\n  } // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n\n\n  _createClass(FSWatcher, [{\n    key: \"add\",\n    value: function add(paths_, _origAdd, _internal) {\n      var _this4 = this;\n\n      var _this$options = this.options,\n          cwd = _this$options.cwd,\n          disableGlobbing = _this$options.disableGlobbing;\n      this.closed = false;\n      var paths = unifyPaths(paths_);\n\n      if (cwd) {\n        paths = paths.map(function (path) {\n          var absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n          if (disableGlobbing || !isGlob(path)) {\n            return absPath;\n          }\n\n          return normalizePath(absPath);\n        });\n      } // set aside negated glob strings\n\n\n      paths = paths.filter(function (path) {\n        if (path.startsWith(BANG)) {\n          _this4._ignoredPaths.add(path.slice(1));\n\n          return false;\n        } // if a path is being added that was previously ignored, stop ignoring it\n\n\n        _this4._ignoredPaths.delete(path);\n\n        _this4._ignoredPaths.delete(path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn\n        // to make ignoredPaths changes effective\n\n\n        _this4._userIgnored = undefined;\n        return true;\n      });\n\n      if (this.options.useFsEvents && this._fsEventsHandler) {\n        if (!this._readyCount) this._readyCount = paths.length;\n        if (this.options.persistent) this._readyCount *= 2;\n        paths.forEach(function (path) {\n          return _this4._fsEventsHandler._addToFsEvents(path);\n        });\n      } else {\n        if (!this._readyCount) this._readyCount = 0;\n        this._readyCount += paths.length;\n        Promise.all(paths.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path) {\n            var res;\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return _this4._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n\n                  case 2:\n                    res = _context2.sent;\n                    if (res) _this4._emitReady();\n                    return _context2.abrupt(\"return\", res);\n\n                  case 5:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function (_x2) {\n            return _ref.apply(this, arguments);\n          };\n        }())).then(function (results) {\n          if (_this4.closed) return;\n          results.filter(function (item) {\n            return item;\n          }).forEach(function (item) {\n            _this4.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n          });\n        });\n      }\n\n      return this;\n    }\n    /**\n     * Close watchers or start ignoring events from specified paths.\n     * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n     * @returns {FSWatcher} for chaining\n    */\n\n  }, {\n    key: \"unwatch\",\n    value: function unwatch(paths_) {\n      var _this5 = this;\n\n      if (this.closed) return this;\n      var paths = unifyPaths(paths_);\n      var cwd = this.options.cwd;\n      paths.forEach(function (path) {\n        // convert to absolute path unless relative path already matches\n        if (!sysPath.isAbsolute(path) && !_this5._closers.has(path)) {\n          if (cwd) path = sysPath.join(cwd, path);\n          path = sysPath.resolve(path);\n        }\n\n        _this5._closePath(path);\n\n        _this5._ignoredPaths.add(path);\n\n        if (_this5._watched.has(path)) {\n          _this5._ignoredPaths.add(path + SLASH_GLOBSTAR);\n        } // reset the cached userIgnored anymatch fn\n        // to make ignoredPaths changes effective\n\n\n        _this5._userIgnored = undefined;\n      });\n      return this;\n    }\n    /**\n     * Close watchers and remove all listeners from watched paths.\n     * @returns {Promise<void>}.\n    */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this6 = this;\n\n      if (this.closed) return this._closePromise;\n      this.closed = true; // Memory management.\n\n      this.removeAllListeners();\n      var closers = [];\n\n      this._closers.forEach(function (closerList) {\n        return closerList.forEach(function (closer) {\n          var promise = closer();\n          if (promise instanceof Promise) closers.push(promise);\n        });\n      });\n\n      this._streams.forEach(function (stream) {\n        return stream.destroy();\n      });\n\n      this._userIgnored = undefined;\n      this._readyCount = 0;\n      this._readyEmitted = false;\n\n      this._watched.forEach(function (dirent) {\n        return dirent.dispose();\n      });\n\n      ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(function (key) {\n        _this6[\"_\".concat(key)].clear();\n      });\n      this._closePromise = closers.length ? Promise.all(closers).then(function () {\n        return undefined;\n      }) : Promise.resolve();\n      return this._closePromise;\n    }\n    /**\n     * Expose list of watched paths\n     * @returns {Object} for chaining\n    */\n\n  }, {\n    key: \"getWatched\",\n    value: function getWatched() {\n      var _this7 = this;\n\n      var watchList = {};\n\n      this._watched.forEach(function (entry, dir) {\n        var key = _this7.options.cwd ? sysPath.relative(_this7.options.cwd, dir) : dir;\n        watchList[key || ONE_DOT] = entry.getChildren().sort();\n      });\n\n      return watchList;\n    }\n  }, {\n    key: \"emitWithAll\",\n    value: function emitWithAll(event, args) {\n      this.emit.apply(this, _toConsumableArray(args));\n      if (event !== EV_ERROR) this.emit.apply(this, [EV_ALL].concat(_toConsumableArray(args)));\n    } // Common helpers\n    // --------------\n\n    /**\n     * Normalize and emit events.\n     * Calling _emit DOES NOT MEAN emit() would be called!\n     * @param {EventName} event Type of event\n     * @param {Path} path File or directory path\n     * @param {*=} val1 arguments to be passed with event\n     * @param {*=} val2\n     * @param {*=} val3\n     * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n\n  }, {\n    key: \"_emit\",\n    value: function () {\n      var _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(event, path, val1, val2, val3) {\n        var _this8 = this;\n\n        var opts, args, awf, pw, awfEmit, isThrottled, fullPath, stats;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.closed) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                opts = this.options;\n                if (isWindows) path = sysPath.normalize(path);\n                if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n                /** @type Array<any> */\n\n                args = [event, path];\n                if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n                awf = opts.awaitWriteFinish;\n\n                if (!(awf && (pw = this._pendingWrites.get(path)))) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                pw.lastChange = new Date();\n                return _context3.abrupt(\"return\", this);\n\n              case 11:\n                if (!opts.atomic) {\n                  _context3.next = 17;\n                  break;\n                }\n\n                if (!(event === EV_UNLINK)) {\n                  _context3.next = 16;\n                  break;\n                }\n\n                this._pendingUnlinks.set(path, args);\n\n                setTimeout(function () {\n                  _this8._pendingUnlinks.forEach(function (entry, path) {\n                    _this8.emit.apply(_this8, _toConsumableArray(entry));\n\n                    _this8.emit.apply(_this8, [EV_ALL].concat(_toConsumableArray(entry)));\n\n                    _this8._pendingUnlinks.delete(path);\n                  });\n                }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n                return _context3.abrupt(\"return\", this);\n\n              case 16:\n                if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n                  event = args[0] = EV_CHANGE;\n\n                  this._pendingUnlinks.delete(path);\n                }\n\n              case 17:\n                if (!(awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted)) {\n                  _context3.next = 21;\n                  break;\n                }\n\n                awfEmit = function awfEmit(err, stats) {\n                  if (err) {\n                    event = args[0] = EV_ERROR;\n                    args[1] = err;\n\n                    _this8.emitWithAll(event, args);\n                  } else if (stats) {\n                    // if stats doesn't exist the file must have been deleted\n                    if (args.length > 2) {\n                      args[2] = stats;\n                    } else {\n                      args.push(stats);\n                    }\n\n                    _this8.emitWithAll(event, args);\n                  }\n                };\n\n                this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n                return _context3.abrupt(\"return\", this);\n\n              case 21:\n                if (!(event === EV_CHANGE)) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                isThrottled = !this._throttle(EV_CHANGE, path, 50);\n\n                if (!isThrottled) {\n                  _context3.next = 25;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this);\n\n              case 25:\n                if (!(opts.alwaysStat && val1 === undefined && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE))) {\n                  _context3.next = 38;\n                  break;\n                }\n\n                fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n                _context3.prev = 27;\n                _context3.next = 30;\n                return stat(fullPath);\n\n              case 30:\n                stats = _context3.sent;\n                _context3.next = 35;\n                break;\n\n              case 33:\n                _context3.prev = 33;\n                _context3.t0 = _context3[\"catch\"](27);\n\n              case 35:\n                if (!(!stats || this.closed)) {\n                  _context3.next = 37;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 37:\n                args.push(stats);\n\n              case 38:\n                this.emitWithAll(event, args);\n                return _context3.abrupt(\"return\", this);\n\n              case 40:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[27, 33]]);\n      }));\n\n      function _emit(_x3, _x4, _x5, _x6, _x7) {\n        return _emit2.apply(this, arguments);\n      }\n\n      return _emit;\n    }()\n    /**\n     * Common handler for errors\n     * @param {Error} error\n     * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n     */\n\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(error) {\n      var code = error && error.code;\n\n      if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n        this.emit(EV_ERROR, error);\n      }\n\n      return error || this.closed;\n    }\n    /**\n     * Helper utility for throttling\n     * @param {ThrottleType} actionType type being throttled\n     * @param {Path} path being acted upon\n     * @param {Number} timeout duration of time to suppress duplicate actions\n     * @returns {Object|false} tracking object or false if action should be suppressed\n     */\n\n  }, {\n    key: \"_throttle\",\n    value: function _throttle(actionType, path, timeout) {\n      if (!this._throttled.has(actionType)) {\n        this._throttled.set(actionType, new Map());\n      }\n      /** @type {Map<Path, Object>} */\n\n\n      var action = this._throttled.get(actionType);\n      /** @type {Object} */\n\n\n      var actionPath = action.get(path);\n\n      if (actionPath) {\n        actionPath.count++;\n        return false;\n      }\n\n      var timeoutObject;\n\n      var clear = function clear() {\n        var item = action.get(path);\n        var count = item ? item.count : 0;\n        action.delete(path);\n        clearTimeout(timeoutObject);\n        if (item) clearTimeout(item.timeoutObject);\n        return count;\n      };\n\n      timeoutObject = setTimeout(clear, timeout);\n      var thr = {\n        timeoutObject: timeoutObject,\n        clear: clear,\n        count: 0\n      };\n      action.set(path, thr);\n      return thr;\n    }\n  }, {\n    key: \"_incrReadyCount\",\n    value: function _incrReadyCount() {\n      return this._readyCount++;\n    }\n    /**\n     * Awaits write operation to finish.\n     * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n     * @param {Path} path being acted upon\n     * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n     * @param {EventName} event\n     * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n     */\n\n  }, {\n    key: \"_awaitWriteFinish\",\n    value: function _awaitWriteFinish(path, threshold, event, awfEmit) {\n      var _this9 = this;\n\n      var timeoutHandler;\n      var fullPath = path;\n\n      if (this.options.cwd && !sysPath.isAbsolute(path)) {\n        fullPath = sysPath.join(this.options.cwd, path);\n      }\n\n      var now = new Date();\n\n      var awaitWriteFinish = function awaitWriteFinish(prevStat) {\n        fs.stat(fullPath, function (err, curStat) {\n          if (err || !_this9._pendingWrites.has(path)) {\n            if (err && err.code !== 'ENOENT') awfEmit(err);\n            return;\n          }\n\n          var now = Number(new Date());\n\n          if (prevStat && curStat.size !== prevStat.size) {\n            _this9._pendingWrites.get(path).lastChange = now;\n          }\n\n          var pw = _this9._pendingWrites.get(path);\n\n          var df = now - pw.lastChange;\n\n          if (df >= threshold) {\n            _this9._pendingWrites.delete(path);\n\n            awfEmit(undefined, curStat);\n          } else {\n            timeoutHandler = setTimeout(awaitWriteFinish, _this9.options.awaitWriteFinish.pollInterval, curStat);\n          }\n        });\n      };\n\n      if (!this._pendingWrites.has(path)) {\n        this._pendingWrites.set(path, {\n          lastChange: now,\n          cancelWait: function cancelWait() {\n            _this9._pendingWrites.delete(path);\n\n            clearTimeout(timeoutHandler);\n            return event;\n          }\n        });\n\n        timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n      }\n    }\n  }, {\n    key: \"_getGlobIgnored\",\n    value: function _getGlobIgnored() {\n      return _toConsumableArray(this._ignoredPaths.values());\n    }\n    /**\n     * Determines whether user has asked to ignore this path.\n     * @param {Path} path filepath or dir\n     * @param {fs.Stats=} stats result of fs.stat\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"_isIgnored\",\n    value: function _isIgnored(path, stats) {\n      if (this.options.atomic && DOT_RE.test(path)) return true;\n\n      if (!this._userIgnored) {\n        var cwd = this.options.cwd;\n        var ign = this.options.ignored;\n        var ignored = ign && ign.map(normalizeIgnored(cwd));\n        var paths = arrify(ignored).filter(function (path) {\n          return typeof path === STRING_TYPE && !isGlob(path);\n        }).map(function (path) {\n          return path + SLASH_GLOBSTAR;\n        });\n\n        var list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\n        this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n      }\n\n      return this._userIgnored([path, stats]);\n    }\n  }, {\n    key: \"_isntIgnored\",\n    value: function _isntIgnored(path, stat) {\n      return !this._isIgnored(path, stat);\n    }\n    /**\n     * Provides a set of common helpers and properties relating to symlink and glob handling.\n     * @param {Path} path file, directory, or glob pattern being watched\n     * @param {Number=} depth at any depth > 0, this isn't a glob\n     * @returns {WatchHelper} object containing helpers for this path\n     */\n\n  }, {\n    key: \"_getWatchHelpers\",\n    value: function _getWatchHelpers(path, depth) {\n      var watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n      var follow = this.options.followSymlinks;\n      return new WatchHelper(path, watchPath, follow, this);\n    } // Directory helpers\n    // -----------------\n\n    /**\n     * Provides directory tracking objects\n     * @param {String} directory path of the directory\n     * @returns {DirEntry} the directory's tracking object\n     */\n\n  }, {\n    key: \"_getWatchedDir\",\n    value: function _getWatchedDir(directory) {\n      if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n      var dir = sysPath.resolve(directory);\n      if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n      return this._watched.get(dir);\n    } // File helpers\n    // ------------\n\n    /**\n     * Check for read permissions.\n     * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n     * @param {fs.Stats} stats - object, result of fs_stat\n     * @returns {Boolean} indicates whether the file can be read\n    */\n\n  }, {\n    key: \"_hasReadPermissions\",\n    value: function _hasReadPermissions(stats) {\n      if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint\n\n      var md = stats && Number.parseInt(stats.mode, 10);\n      var st = md & 511;\n      var it = Number.parseInt(st.toString(8)[0], 10);\n      return Boolean(4 & it);\n    }\n    /**\n     * Handles emitting unlink events for\n     * files and directories, and via recursion, for\n     * files and directories within directories that are unlinked\n     * @param {String} directory within which the following item is located\n     * @param {String} item      base path of item/directory\n     * @returns {void}\n    */\n\n  }, {\n    key: \"_remove\",\n    value: function _remove(directory, item, isDirectory) {\n      var _this10 = this;\n\n      // if what is being deleted is a directory, get that directory's paths\n      // for recursive deleting and cleaning of watched object\n      // if it is not a directory, nestedDirectoryChildren will be empty array\n      var path = sysPath.join(directory, item);\n      var fullPath = sysPath.resolve(path);\n      isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously\n      // via multiple paths (such as _handleFile and _handleDir)\n\n      if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n      if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n        this.add(directory, item, true);\n      } // This will create a new entry in the watched object in either case\n      // so we got to do the directory check beforehand\n\n\n      var wp = this._getWatchedDir(path);\n\n      var nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.\n\n      nestedDirectoryChildren.forEach(function (nested) {\n        return _this10._remove(path, nested);\n      }); // Check if item was on the watched list and remove it\n\n      var parent = this._getWatchedDir(directory);\n\n      var wasTracked = parent.has(item);\n      parent.remove(item); // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n      // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n      // but never removed from the map in case the path was deleted.\n      // This leads to an incorrect state if the path was recreated:\n      // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n\n      if (this._symlinkPaths.has(fullPath)) {\n        this._symlinkPaths.delete(fullPath);\n      } // If we wait for this file to be fully written, cancel the wait.\n\n\n      var relPath = path;\n      if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n\n      if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n        var event = this._pendingWrites.get(relPath).cancelWait();\n\n        if (event === EV_ADD) return;\n      } // The Entry will either be a directory that just got removed\n      // or a bogus entry to a file, in either case we have to remove it\n\n\n      this._watched.delete(path);\n\n      this._watched.delete(fullPath);\n\n      var eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n      if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n      if (!this.options.useFsEvents) {\n        this._closePath(path);\n      }\n    }\n    /**\n     * Closes all watchers for a path\n     * @param {Path} path\n     */\n\n  }, {\n    key: \"_closePath\",\n    value: function _closePath(path) {\n      this._closeFile(path);\n\n      var dir = sysPath.dirname(path);\n\n      this._getWatchedDir(dir).remove(sysPath.basename(path));\n    }\n    /**\n     * Closes only file-specific watchers\n     * @param {Path} path\n     */\n\n  }, {\n    key: \"_closeFile\",\n    value: function _closeFile(path) {\n      var closers = this._closers.get(path);\n\n      if (!closers) return;\n      closers.forEach(function (closer) {\n        return closer();\n      });\n\n      this._closers.delete(path);\n    }\n    /**\n     *\n     * @param {Path} path\n     * @param {Function} closer\n     */\n\n  }, {\n    key: \"_addPathCloser\",\n    value: function _addPathCloser(path, closer) {\n      if (!closer) return;\n\n      var list = this._closers.get(path);\n\n      if (!list) {\n        list = [];\n\n        this._closers.set(path, list);\n      }\n\n      list.push(closer);\n    }\n  }, {\n    key: \"_readdirp\",\n    value: function _readdirp(root, opts) {\n      var _this11 = this;\n\n      if (this.closed) return;\n\n      var options = _objectSpread({\n        type: EV_ALL,\n        alwaysStat: true,\n        lstat: true\n      }, opts);\n\n      var stream = readdirp(root, options);\n\n      this._streams.add(stream);\n\n      stream.once(STR_CLOSE, function () {\n        stream = undefined;\n      });\n      stream.once(STR_END, function () {\n        if (stream) {\n          _this11._streams.delete(stream);\n\n          stream = undefined;\n        }\n      });\n      return stream;\n    }\n  }]);\n\n  return FSWatcher;\n}(EventEmitter); // Export FSWatcher class\n\n\nexports.FSWatcher = FSWatcher;\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\n\nvar watch = function watch(paths, options) {\n  var watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/chokidar/index.js"],"names":["require","EventEmitter","fs","sysPath","promisify","readdirp","anymatch","default","globParent","isGlob","braces","normalizePath","NodeFsHandler","FsEventsHandler","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_UNLINK","EV_ADD_DIR","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_CLOSE","STR_END","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","SLASH_SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","GLOBSTAR","SLASH_GLOBSTAR","ANYMATCH_OPTS","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","isWindows","isMacos","isIBMi","stat","readdir","arrify","value","Array","isArray","flatten","list","result","forEach","item","push","unifyPaths","paths_","paths","every","p","TypeError","map","normalizePathToUnix","toUnix","string","str","replace","prepend","startsWith","match","path","normalize","normalizeIgnored","cwd","isAbsolute","join","getAbsolutePath","slice","undef","opts","key","undefined","DirEntry","dir","removeWatcher","_removeWatcher","items","Set","add","delete","size","dirname","basename","has","values","clear","Object","freeze","STAT_METHOD_F","STAT_METHOD_L","WatchHelper","watchPath","follow","fsw","fullWatchPath","resolve","hasGlob","globSymlink","globFilter","dirParts","getDirParts","parts","length","pop","followSymlinks","statMethod","entry","fullParentDir","realPath","linkPath","fullPath","relative","checkGlobSymlink","stats","isSymbolicLink","filterDir","resolvedPath","entryPath","matchesGlob","_isntIgnored","_hasReadPermissions","expandedPath","includes","expand","split","entryParts","globstar","unmatchedGlob","some","part","i","FSWatcher","_opts","assign","_watched","Map","_closers","_ignoredPaths","_throttled","_symlinkPaths","_streams","closed","persistent","ignoreInitial","ignorePermissionErrors","interval","binaryInterval","disableGlobbing","enableBinaryInterval","useFsEvents","usePolling","canUseFsEvents","canUse","envPoll","process","env","CHOKIDAR_USEPOLLING","envLower","toLowerCase","envInterval","CHOKIDAR_INTERVAL","Number","parseInt","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","ignored","readyCalls","_emitReady","_readyCount","_readyEmitted","nextTick","emit","_emitRaw","args","options","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","absPath","filter","_userIgnored","_addToFsEvents","Promise","all","_addToNodeFs","res","then","results","_closePath","_closePromise","removeAllListeners","closers","closerList","closer","promise","stream","destroy","dirent","dispose","watchList","getChildren","sort","event","val1","val2","val3","pw","get","lastChange","Date","set","setTimeout","awfEmit","err","emitWithAll","_awaitWriteFinish","isThrottled","_throttle","alwaysStat","error","code","actionType","timeout","action","actionPath","count","timeoutObject","clearTimeout","thr","threshold","timeoutHandler","now","prevStat","curStat","df","cancelWait","test","ign","_getGlobIgnored","concat","_isIgnored","depth","directory","_boundRemove","_remove","bind","md","mode","st","it","toString","Boolean","isDirectory","wp","_getWatchedDir","nestedDirectoryChildren","nested","parent","wasTracked","remove","relPath","eventName","_emit","_closeFile","root","type","lstat","once","exports","watch","watcher"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { EventEmitter } = require('events');\nconst fs = require('fs');\nconst sysPath = require('path');\nconst { promisify } = require('util');\nconst readdirp = require('readdirp');\nconst anymatch = require('anymatch').default;\nconst globParent = require('glob-parent');\nconst isGlob = require('is-glob');\nconst braces = require('braces');\nconst normalizePath = require('normalize-path');\n\nconst NodeFsHandler = require('./lib/nodefs-handler');\nconst FsEventsHandler = require('./lib/fsevents-handler');\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD,\n  EV_CHANGE,\n  EV_UNLINK,\n  EV_ADD_DIR,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR,\n\n  STR_CLOSE,\n  STR_END,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START,\n  BANG,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE,\n  EMPTY_STR,\n  EMPTY_FN,\n\n  isWindows,\n  isMacos,\n  isIBMi\n} = require('./lib/constants');\n\nconst stat = promisify(fs.stat);\nconst readdir = promisify(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\n// If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  if (prepend) {\n    str = SLASH + str;\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path) => toUnix(sysPath.normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR) => (path) => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath.isAbsolute(path) ? path : sysPath.join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath.isAbsolute(path)) {\n    return path;\n  }\n  if (path.startsWith(BANG)) {\n    return BANG + sysPath.join(cwd, path.slice(1));\n  }\n  return sysPath.join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath.resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n    if (path === EMPTY_STR) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath.join(this.watchPath,\n      sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START) ? braces.expand(path) : [path];\n    expandedPath.forEach((path) => {\n      parts.push(sysPath.relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = FsEventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Always default to polling on IBM i because fs.watch() is not available on IBM i.\n  if(isIBMi) {\n    opts.usePolling = true;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new FsEventsHandler(this);\n  } else {\n    this._nodeFsHandler = new NodeFsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path) => {\n    // convert to absolute path unless relative path already matches\n    if (!sysPath.isAbsolute(path) && !this._closers.has(path)) {\n      if (cwd) path = sysPath.join(cwd, path);\n      path = sysPath.resolve(path);\n    }\n\n    this._closePath(path);\n\n    this._ignoredPaths.add(path);\n    if (this._watched.has(path)) {\n      this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows) path = sysPath.normalize(path);\n  if (opts.cwd) path = sysPath.relative(opts.cwd, path);\n  /** @type Array<any> */\n  const args = [event, path];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK) {\n      this._pendingUnlinks.set(path, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD && this._pendingUnlinks.has(path)) {\n      event = args[0] = EV_CHANGE;\n      this._pendingUnlinks.delete(path);\n    }\n  }\n\n  if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE) {\n    const isThrottled = !this._throttle(EV_CHANGE, path, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)\n  ) {\n    const fullPath = opts.cwd ? sysPath.join(opts.cwd, path) : path;\n    let stats;\n    try {\n      stats = await stat(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path;\n  if (this.options.cwd && !sysPath.isAbsolute(path)) {\n    fullPath = sysPath.join(this.options.cwd, path);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path)) {\n    this._pendingWrites.set(path, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = sysPath.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path = sysPath.join(directory, item);\n  const fullPath = sysPath.resolve(path);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // Fixes issue #1042 -> Relative paths were detected and added as symlinks\n  // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),\n  // but never removed from the map in case the path was deleted.\n  // This leads to an incorrect state if the path was recreated:\n  // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553\n  if (this._symlinkPaths.has(fullPath)) {\n    this._symlinkPaths.delete(fullPath);\n  }\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path;\n  if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;\n  if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path);\n  }\n}\n\n/**\n * Closes all watchers for a path\n * @param {Path} path\n */\n_closePath(path) {\n  this._closeFile(path)\n  const dir = sysPath.dirname(path);\n  this._getWatchedDir(dir).remove(sysPath.basename(path));\n}\n\n/**\n * Closes only file-specific watchers\n * @param {Path} path\n */\n_closeFile(path) {\n  const closers = this._closers.get(path);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path);\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nexports.FSWatcher = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nexports.watch = watch;\n"]},"metadata":{},"sourceType":"script"}