{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n *\n */\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar index_1 = require(\"../../exception/index\");\n\nvar index_2 = require(\"../../utils/index\");\n\nvar api_1 = require(\"./api\");\n\nvar ChannelAlreadyExistException = /*#__PURE__*/function (_index_1$BaseExceptio) {\n  _inherits(ChannelAlreadyExistException, _index_1$BaseExceptio);\n\n  var _super = _createSuper(ChannelAlreadyExistException);\n\n  function ChannelAlreadyExistException(name) {\n    _classCallCheck(this, ChannelAlreadyExistException);\n\n    return _super.call(this, \"Channel \".concat(JSON.stringify(name), \" already exist.\"));\n  }\n\n  return ChannelAlreadyExistException;\n}(index_1.BaseException);\n\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\n\nfunction createJobHandler(fn) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var handler = function handler(argument, context) {\n    var description = context.description;\n    var inboundBus = context.inboundBus;\n    var inputChannel = new rxjs_1.Subject();\n    var subscription;\n    return new rxjs_1.Observable(function (subject) {\n      function complete() {\n        if (subscription) {\n          subscription.unsubscribe();\n        }\n\n        subject.next({\n          kind: api_1.JobOutboundMessageKind.End,\n          description: description\n        });\n        subject.complete();\n        inputChannel.complete();\n      } // Handle input.\n\n\n      var inboundSub = inboundBus.subscribe(function (message) {\n        switch (message.kind) {\n          case api_1.JobInboundMessageKind.Ping:\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.Pong,\n              description: description,\n              id: message.id\n            });\n            break;\n\n          case api_1.JobInboundMessageKind.Stop:\n            // There's no way to cancel a promise or a synchronous function, but we do cancel\n            // observables where possible.\n            complete();\n            break;\n\n          case api_1.JobInboundMessageKind.Input:\n            inputChannel.next(message.value);\n            break;\n        }\n      }); // Execute the function with the additional context.\n\n      var channels = new Map();\n\n      var newContext = _objectSpread(_objectSpread({}, context), {}, {\n        input: inputChannel.asObservable(),\n        createChannel: function createChannel(name) {\n          if (channels.has(name)) {\n            throw new ChannelAlreadyExistException(name);\n          }\n\n          var channelSubject = new rxjs_1.Subject();\n          var channelSub = channelSubject.subscribe(function (message) {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelMessage,\n              description: description,\n              name: name,\n              message: message\n            });\n          }, function (error) {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelError,\n              description: description,\n              name: name,\n              error: error\n            }); // This can be reopened.\n\n            channels.delete(name);\n          }, function () {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelComplete,\n              description: description,\n              name: name\n            }); // This can be reopened.\n\n            channels.delete(name);\n          });\n          channels.set(name, channelSubject);\n\n          if (subscription) {\n            subscription.add(channelSub);\n          }\n\n          return channelSubject;\n        }\n      });\n\n      subject.next({\n        kind: api_1.JobOutboundMessageKind.Start,\n        description: description\n      });\n      var result = fn(argument, newContext); // If the result is a promise, simply wait for it to complete before reporting the result.\n\n      if (index_2.isPromise(result)) {\n        result = rxjs_1.from(result);\n      } else if (!rxjs_1.isObservable(result)) {\n        result = rxjs_1.of(result);\n      }\n\n      subscription = result.subscribe(function (value) {\n        return subject.next({\n          kind: api_1.JobOutboundMessageKind.Output,\n          description: description,\n          value: value\n        });\n      }, function (error) {\n        return subject.error(error);\n      }, function () {\n        return complete();\n      });\n      subscription.add(inboundSub);\n      return subscription;\n    });\n  };\n\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\n\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\n\nfunction createJobFactory(loader) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var handler = function handler(argument, context) {\n    return rxjs_1.from(loader()).pipe(operators_1.switchMap(function (fn) {\n      return fn(argument, context);\n    }));\n  };\n\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\n\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\n\nfunction createLoggerJob(job, logger) {\n  var handler = function handler(argument, context) {\n    context.inboundBus.pipe(operators_1.tap(function (message) {\n      return logger.info(\"Input: \".concat(JSON.stringify(message)));\n    })).subscribe();\n    return job(argument, context).pipe(operators_1.tap(function (message) {\n      return logger.info(\"Message: \".concat(JSON.stringify(message)));\n    }, function (error) {\n      return logger.warn(\"Error: \".concat(JSON.stringify(error)));\n    }, function () {\n      return logger.info(\"Completed\");\n    }));\n  };\n\n  return Object.assign(handler, job);\n}\n\nexports.createLoggerJob = createLoggerJob;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/experimental/jobs/create-job-handler.js"],"names":["Object","defineProperty","exports","value","createLoggerJob","createJobFactory","createJobHandler","ChannelAlreadyExistException","rxjs_1","require","operators_1","index_1","index_2","api_1","name","JSON","stringify","BaseException","fn","options","handler","argument","context","description","inboundBus","inputChannel","Subject","subscription","Observable","subject","complete","unsubscribe","next","kind","JobOutboundMessageKind","End","inboundSub","subscribe","message","JobInboundMessageKind","Ping","Pong","id","Stop","Input","channels","Map","newContext","input","asObservable","createChannel","has","channelSubject","channelSub","ChannelMessage","error","ChannelError","delete","ChannelComplete","set","add","Start","result","isPromise","from","isObservable","of","Output","assign","jobDescription","loader","pipe","switchMap","job","logger","tap","info","warn"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n *\n */\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst index_1 = require(\"../../exception/index\");\nconst index_2 = require(\"../../utils/index\");\nconst api_1 = require(\"./api\");\nclass ChannelAlreadyExistException extends index_1.BaseException {\n    constructor(name) {\n        super(`Channel ${JSON.stringify(name)} already exist.`);\n    }\n}\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\nfunction createJobHandler(fn, options = {}) {\n    const handler = (argument, context) => {\n        const description = context.description;\n        const inboundBus = context.inboundBus;\n        const inputChannel = new rxjs_1.Subject();\n        let subscription;\n        return new rxjs_1.Observable(subject => {\n            function complete() {\n                if (subscription) {\n                    subscription.unsubscribe();\n                }\n                subject.next({ kind: api_1.JobOutboundMessageKind.End, description });\n                subject.complete();\n                inputChannel.complete();\n            }\n            // Handle input.\n            const inboundSub = inboundBus.subscribe(message => {\n                switch (message.kind) {\n                    case api_1.JobInboundMessageKind.Ping:\n                        subject.next({ kind: api_1.JobOutboundMessageKind.Pong, description, id: message.id });\n                        break;\n                    case api_1.JobInboundMessageKind.Stop:\n                        // There's no way to cancel a promise or a synchronous function, but we do cancel\n                        // observables where possible.\n                        complete();\n                        break;\n                    case api_1.JobInboundMessageKind.Input:\n                        inputChannel.next(message.value);\n                        break;\n                }\n            });\n            // Execute the function with the additional context.\n            const channels = new Map();\n            const newContext = {\n                ...context,\n                input: inputChannel.asObservable(),\n                createChannel(name) {\n                    if (channels.has(name)) {\n                        throw new ChannelAlreadyExistException(name);\n                    }\n                    const channelSubject = new rxjs_1.Subject();\n                    const channelSub = channelSubject.subscribe(message => {\n                        subject.next({\n                            kind: api_1.JobOutboundMessageKind.ChannelMessage, description, name, message,\n                        });\n                    }, error => {\n                        subject.next({ kind: api_1.JobOutboundMessageKind.ChannelError, description, name, error });\n                        // This can be reopened.\n                        channels.delete(name);\n                    }, () => {\n                        subject.next({ kind: api_1.JobOutboundMessageKind.ChannelComplete, description, name });\n                        // This can be reopened.\n                        channels.delete(name);\n                    });\n                    channels.set(name, channelSubject);\n                    if (subscription) {\n                        subscription.add(channelSub);\n                    }\n                    return channelSubject;\n                },\n            };\n            subject.next({ kind: api_1.JobOutboundMessageKind.Start, description });\n            let result = fn(argument, newContext);\n            // If the result is a promise, simply wait for it to complete before reporting the result.\n            if (index_2.isPromise(result)) {\n                result = rxjs_1.from(result);\n            }\n            else if (!rxjs_1.isObservable(result)) {\n                result = rxjs_1.of(result);\n            }\n            subscription = result.subscribe((value) => subject.next({ kind: api_1.JobOutboundMessageKind.Output, description, value }), error => subject.error(error), () => complete());\n            subscription.add(inboundSub);\n            return subscription;\n        });\n    };\n    return Object.assign(handler, { jobDescription: options });\n}\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\nfunction createJobFactory(loader, options = {}) {\n    const handler = (argument, context) => {\n        return rxjs_1.from(loader())\n            .pipe(operators_1.switchMap(fn => fn(argument, context)));\n    };\n    return Object.assign(handler, { jobDescription: options });\n}\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\nfunction createLoggerJob(job, logger) {\n    const handler = (argument, context) => {\n        context.inboundBus.pipe(operators_1.tap(message => logger.info(`Input: ${JSON.stringify(message)}`))).subscribe();\n        return job(argument, context).pipe(operators_1.tap(message => logger.info(`Message: ${JSON.stringify(message)}`), error => logger.warn(`Error: ${JSON.stringify(error)}`), () => logger.info(`Completed`)));\n    };\n    return Object.assign(handler, job);\n}\nexports.createLoggerJob = createLoggerJob;\n"]},"metadata":{},"sourceType":"script"}