{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _toArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _require = require('./util/hints'),\n    stringHints = _require.stringHints,\n    numberHints = _require.numberHints;\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n\n/** @enum {number} */\n\n\nvar SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\nfunction filterMax(array, fn) {\n  var evaluatedMax = array.reduce(function (max, item) {\n    return Math.max(max, fn(item));\n  }, 0);\n  return array.filter(function (item) {\n    return fn(item) === evaluatedMax;\n  });\n}\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction filterChildren(children) {\n  var newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  function (error) {\n    return error.dataPath ? error.dataPath.length : 0;\n  });\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  function (error) {\n    return SPECIFICITY[\n    /** @type {keyof typeof SPECIFICITY} */\n    error.keyword] || 2;\n  });\n  return newChildren;\n}\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\n\n\nfunction findAllChildren(children, schemaPaths) {\n  var i = children.length - 1;\n\n  var predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  function predicate(schemaPath) {\n    return children[i].schemaPath.indexOf(schemaPath) !== 0;\n  };\n\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === 'anyOf' || children[i].keyword === 'oneOf') {\n      var refs = extractRefs(children[i]);\n      var childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n\n  return i + 1;\n}\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\n\n\nfunction extractRefs(error) {\n  var schema = error.schema;\n\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n\n  return schema.map(function (_ref) {\n    var $ref = _ref.$ref;\n    return $ref;\n  }).filter(function (s) {\n    return s;\n  });\n}\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction groupChildrenByFirstChild(children) {\n  var result = [];\n  var i = children.length - 1;\n\n  while (i > 0) {\n    var child = children[i];\n\n    if (child.keyword === 'anyOf' || child.keyword === 'oneOf') {\n      var refs = extractRefs(child);\n      var childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n\n    i -= 1;\n  }\n\n  if (i === 0) {\n    result.push(children[i]);\n  }\n\n  return result.reverse();\n}\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, \"\\n\".concat(prefix));\n}\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\n\n\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\n\n\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n\n  return schema;\n}\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\n\n\nfunction canApplyNot(schema) {\n  var typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\n\n\nfunction isObject(maybeObj) {\n  return typeof maybeObj === 'object' && maybeObj !== null;\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNumber(schema) {\n  return schema.type === 'number' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeInteger(schema) {\n  return schema.type === 'integer' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeString(schema) {\n  return schema.type === 'string' || typeof schema.minLength !== 'undefined' || typeof schema.maxLength !== 'undefined' || typeof schema.pattern !== 'undefined' || typeof schema.format !== 'undefined' || typeof schema.formatMinimum !== 'undefined' || typeof schema.formatMaximum !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeBoolean(schema) {\n  return schema.type === 'boolean';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeArray(schema) {\n  return schema.type === 'array' || typeof schema.minItems === 'number' || typeof schema.maxItems === 'number' || typeof schema.uniqueItems !== 'undefined' || typeof schema.items !== 'undefined' || typeof schema.additionalItems !== 'undefined' || typeof schema.contains !== 'undefined';\n}\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\n\n\nfunction likeObject(schema) {\n  return schema.type === 'object' || typeof schema.minProperties !== 'undefined' || typeof schema.maxProperties !== 'undefined' || typeof schema.required !== 'undefined' || typeof schema.properties !== 'undefined' || typeof schema.patternProperties !== 'undefined' || typeof schema.additionalProperties !== 'undefined' || typeof schema.dependencies !== 'undefined' || typeof schema.propertyNames !== 'undefined' || typeof schema.patternRequired !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNull(schema) {\n  return schema.type === 'null';\n}\n/**\n * @param {string} type\n * @returns {string}\n */\n\n\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return 'an';\n  }\n\n  return 'a';\n}\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\n\n\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return '';\n  }\n\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return ' | should be any non-number';\n    }\n\n    if (likeString(schema)) {\n      return ' | should be any non-string';\n    }\n\n    if (likeArray(schema)) {\n      return ' | should be any non-array';\n    }\n\n    if (likeObject(schema)) {\n      return ' | should be any non-object';\n    }\n  }\n\n  return '';\n}\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\n\n\nfunction formatHints(hints) {\n  return hints.length > 0 ? \"(\".concat(hints.join(', '), \")\") : '';\n}\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\n\n\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    return numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    return stringHints(schema, logic);\n  }\n\n  return [];\n}\n\nvar ValidationError = /*#__PURE__*/function (_Error) {\n  _inherits(ValidationError, _Error);\n\n  var _super = _createSuper(ValidationError);\n\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  function ValidationError(errors, schema) {\n    var _this;\n\n    var configuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, ValidationError);\n\n    _this = _super.call(this);\n    /** @type {string} */\n\n    _this.name = 'ValidationError';\n    /** @type {Array<SchemaUtilErrorObject>} */\n\n    _this.errors = errors;\n    /** @type {Schema} */\n\n    _this.schema = schema;\n    var headerNameFromSchema;\n    var baseDataPathFromSchema;\n\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      var splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          var _splittedTitleFromSch = _slicedToArray(splittedTitleFromSchema, 2);\n\n          headerNameFromSchema = _splittedTitleFromSch[1];\n        }\n\n        if (!configuration.baseDataPath) {\n          var _splittedTitleFromSch2 = _slicedToArray(splittedTitleFromSchema, 3);\n\n          baseDataPathFromSchema = _splittedTitleFromSch2[2];\n        }\n      }\n    }\n    /** @type {string} */\n\n\n    _this.headerName = configuration.name || headerNameFromSchema || 'Object';\n    /** @type {string} */\n\n    _this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || 'configuration';\n    /** @type {PostFormatter | null} */\n\n    _this.postFormatter = configuration.postFormatter || null;\n    var header = \"Invalid \".concat(_this.baseDataPath, \" object. \").concat(_this.headerName, \" has been initialized using \").concat(getArticle(_this.baseDataPath), \" \").concat(_this.baseDataPath, \" object that does not match the API schema.\\n\");\n    /** @type {string} */\n\n    _this.message = \"\".concat(header).concat(_this.formatValidationErrors(errors));\n    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);\n    return _this;\n  }\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n\n\n  _createClass(ValidationError, [{\n    key: \"getSchemaPart\",\n    value: function getSchemaPart(path) {\n      var newPath = path.split('/');\n      var schemaPart = this.schema;\n\n      for (var i = 1; i < newPath.length; i++) {\n        var inner = schemaPart[\n        /** @type {keyof Schema} */\n        newPath[i]];\n\n        if (!inner) {\n          break;\n        }\n\n        schemaPart = inner;\n      }\n\n      return schemaPart;\n    }\n    /**\n     * @param {Schema} schema\n     * @param {boolean} logic\n     * @param {Array<Object>} prevSchemas\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatSchema\",\n    value: function formatSchema(schema) {\n      var _this2 = this;\n\n      var logic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var prevSchemas = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var newLogic = logic;\n\n      var formatInnerSchema =\n      /**\n       *\n       * @param {Object} innerSchema\n       * @param {boolean=} addSelf\n       * @returns {string}\n       */\n      function formatInnerSchema(innerSchema, addSelf) {\n        if (!addSelf) {\n          return _this2.formatSchema(innerSchema, newLogic, prevSchemas);\n        }\n\n        if (prevSchemas.includes(innerSchema)) {\n          return '(recursive)';\n        }\n\n        return _this2.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n      };\n\n      if (hasNotInSchema(schema) && !likeObject(schema)) {\n        if (canApplyNot(schema.not)) {\n          newLogic = !logic;\n          return formatInnerSchema(schema.not);\n        }\n\n        var needApplyLogicHere = !schema.not.not;\n        var prefix = logic ? '' : 'non ';\n        newLogic = !logic;\n        return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n      }\n\n      if (\n      /** @type {Schema & {instanceof: string | Array<string>}} */\n      schema.instanceof) {\n        var value =\n        /** @type {Schema & {instanceof: string | Array<string>}} */\n        schema.instanceof;\n        var values = !Array.isArray(value) ? [value] : value;\n        return values.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        function (item) {\n          return item === 'Function' ? 'function' : item;\n        }).join(' | ');\n      }\n\n      if (schema.enum) {\n        return (\n          /** @type {Array<any>} */\n          schema.enum.map(function (item) {\n            return JSON.stringify(item);\n          }).join(' | ')\n        );\n      }\n\n      if (typeof schema.const !== 'undefined') {\n        return JSON.stringify(schema.const);\n      }\n\n      if (schema.oneOf) {\n        return (\n          /** @type {Array<Schema>} */\n          schema.oneOf.map(function (item) {\n            return formatInnerSchema(item, true);\n          }).join(' | ')\n        );\n      }\n\n      if (schema.anyOf) {\n        return (\n          /** @type {Array<Schema>} */\n          schema.anyOf.map(function (item) {\n            return formatInnerSchema(item, true);\n          }).join(' | ')\n        );\n      }\n\n      if (schema.allOf) {\n        return (\n          /** @type {Array<Schema>} */\n          schema.allOf.map(function (item) {\n            return formatInnerSchema(item, true);\n          }).join(' & ')\n        );\n      }\n\n      if (\n      /** @type {JSONSchema7} */\n      schema.if) {\n        var ifValue =\n        /** @type {JSONSchema7} */\n        schema.if,\n            thenValue =\n        /** @type {JSONSchema7} */\n        schema.then,\n            elseValue =\n        /** @type {JSONSchema7} */\n        schema.else;\n        return \"\".concat(ifValue ? \"if \".concat(formatInnerSchema(ifValue)) : '').concat(thenValue ? \" then \".concat(formatInnerSchema(thenValue)) : '').concat(elseValue ? \" else \".concat(formatInnerSchema(elseValue)) : '');\n      }\n\n      if (schema.$ref) {\n        return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n      }\n\n      if (likeNumber(schema) || likeInteger(schema)) {\n        var _getHints = getHints(schema, logic),\n            _getHints2 = _toArray(_getHints),\n            type = _getHints2[0],\n            hints = _getHints2.slice(1);\n\n        var str = \"\".concat(type).concat(hints.length > 0 ? \" \".concat(formatHints(hints)) : '');\n        return logic ? str : hints.length > 0 ? \"non-\".concat(type, \" | \").concat(str) : \"non-\".concat(type);\n      }\n\n      if (likeString(schema)) {\n        var _getHints3 = getHints(schema, logic),\n            _getHints4 = _toArray(_getHints3),\n            _type = _getHints4[0],\n            _hints = _getHints4.slice(1);\n\n        var _str = \"\".concat(_type).concat(_hints.length > 0 ? \" \".concat(formatHints(_hints)) : '');\n\n        return logic ? _str : _str === 'string' ? 'non-string' : \"non-string | \".concat(_str);\n      }\n\n      if (likeBoolean(schema)) {\n        return \"\".concat(logic ? '' : 'non-', \"boolean\");\n      }\n\n      if (likeArray(schema)) {\n        // not logic already applied in formatValidationError\n        newLogic = true;\n        var _hints2 = [];\n\n        if (typeof schema.minItems === 'number') {\n          _hints2.push(\"should not have fewer than \".concat(schema.minItems, \" item\").concat(schema.minItems > 1 ? 's' : ''));\n        }\n\n        if (typeof schema.maxItems === 'number') {\n          _hints2.push(\"should not have more than \".concat(schema.maxItems, \" item\").concat(schema.maxItems > 1 ? 's' : ''));\n        }\n\n        if (schema.uniqueItems) {\n          _hints2.push('should not have duplicate items');\n        }\n\n        var hasAdditionalItems = typeof schema.additionalItems === 'undefined' || Boolean(schema.additionalItems);\n        var items = '';\n\n        if (schema.items) {\n          if (Array.isArray(schema.items) && schema.items.length > 0) {\n            items = \"\".concat(\n            /** @type {Array<Schema>} */\n            schema.items.map(function (item) {\n              return formatInnerSchema(item);\n            }).join(', '));\n\n            if (hasAdditionalItems) {\n              if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n                _hints2.push(\"additional items should be \".concat(formatInnerSchema(schema.additionalItems)));\n              }\n            }\n          } else if (schema.items && Object.keys(schema.items).length > 0) {\n            // \"additionalItems\" is ignored\n            items = \"\".concat(formatInnerSchema(schema.items));\n          } else {\n            // Fallback for empty `items` value\n            items = 'any';\n          }\n        } else {\n          // \"additionalItems\" is ignored\n          items = 'any';\n        }\n\n        if (schema.contains && Object.keys(schema.contains).length > 0) {\n          _hints2.push(\"should contains at least one \".concat(this.formatSchema(schema.contains), \" item\"));\n        }\n\n        return \"[\".concat(items).concat(hasAdditionalItems ? ', ...' : '', \"]\").concat(_hints2.length > 0 ? \" (\".concat(_hints2.join(', '), \")\") : '');\n      }\n\n      if (likeObject(schema)) {\n        // not logic already applied in formatValidationError\n        newLogic = true;\n        var _hints3 = [];\n\n        if (typeof schema.minProperties === 'number') {\n          _hints3.push(\"should not have fewer than \".concat(schema.minProperties, \" \").concat(schema.minProperties > 1 ? 'properties' : 'property'));\n        }\n\n        if (typeof schema.maxProperties === 'number') {\n          _hints3.push(\"should not have more than \".concat(schema.maxProperties, \" \").concat(schema.minProperties && schema.minProperties > 1 ? 'properties' : 'property'));\n        }\n\n        if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n          var patternProperties = Object.keys(schema.patternProperties);\n\n          _hints3.push(\"additional property names should match pattern\".concat(patternProperties.length > 1 ? 's' : '', \" \").concat(patternProperties.map(function (pattern) {\n            return JSON.stringify(pattern);\n          }).join(' | ')));\n        }\n\n        var properties = schema.properties ? Object.keys(schema.properties) : [];\n        var required = schema.required ? schema.required : [];\n\n        var allProperties = _toConsumableArray(new Set(\n        /** @type {Array<string>} */\n        [].concat(required).concat(properties)));\n\n        var objectStructure = allProperties.map(function (property) {\n          var isRequired = required.includes(property); // Some properties need quotes, maybe we should add check\n          // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n\n          return \"\".concat(property).concat(isRequired ? '' : '?');\n        }).concat(typeof schema.additionalProperties === 'undefined' || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [\"<key>: \".concat(formatInnerSchema(schema.additionalProperties))] : ['…'] : []).join(', ');\n        var dependencies =\n        /** @type {Schema & {patternRequired?: Array<string>;}} */\n        schema.dependencies,\n            propertyNames =\n        /** @type {Schema & {patternRequired?: Array<string>;}} */\n        schema.propertyNames,\n            patternRequired =\n        /** @type {Schema & {patternRequired?: Array<string>;}} */\n        schema.patternRequired;\n\n        if (dependencies) {\n          Object.keys(dependencies).forEach(function (dependencyName) {\n            var dependency = dependencies[dependencyName];\n\n            if (Array.isArray(dependency)) {\n              _hints3.push(\"should have \".concat(dependency.length > 1 ? 'properties' : 'property', \" \").concat(dependency.map(function (dep) {\n                return \"'\".concat(dep, \"'\");\n              }).join(', '), \" when property '\").concat(dependencyName, \"' is present\"));\n            } else {\n              _hints3.push(\"should be valid according to the schema \".concat(formatInnerSchema(dependency), \" when property '\").concat(dependencyName, \"' is present\"));\n            }\n          });\n        }\n\n        if (propertyNames && Object.keys(propertyNames).length > 0) {\n          _hints3.push(\"each property name should match format \".concat(JSON.stringify(schema.propertyNames.format)));\n        }\n\n        if (patternRequired && patternRequired.length > 0) {\n          _hints3.push(\"should have property matching pattern \".concat(patternRequired.map(\n          /**\n           * @param {string} item\n           * @returns {string}\n           */\n          function (item) {\n            return JSON.stringify(item);\n          })));\n        }\n\n        return \"object {\".concat(objectStructure ? \" \".concat(objectStructure, \" \") : '', \"}\").concat(_hints3.length > 0 ? \" (\".concat(_hints3.join(', '), \")\") : '');\n      }\n\n      if (likeNull(schema)) {\n        return \"\".concat(logic ? '' : 'non-', \"null\");\n      }\n\n      if (Array.isArray(schema.type)) {\n        // not logic already applied in formatValidationError\n        return \"\".concat(schema.type.join(' | '));\n      } // Fallback for unknown keywords\n      // not logic already applied in formatValidationError\n\n      /* istanbul ignore next */\n\n\n      return JSON.stringify(schema, null, 2);\n    }\n    /**\n     * @param {Schema=} schemaPart\n     * @param {(boolean | Array<string>)=} additionalPath\n     * @param {boolean=} needDot\n     * @param {boolean=} logic\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getSchemaPartText\",\n    value: function getSchemaPartText(schemaPart, additionalPath) {\n      var needDot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var logic = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      if (!schemaPart) {\n        return '';\n      }\n\n      if (Array.isArray(additionalPath)) {\n        for (var i = 0; i < additionalPath.length; i++) {\n          /** @type {Schema | undefined} */\n          var inner = schemaPart[\n          /** @type {keyof Schema} */\n          additionalPath[i]];\n\n          if (inner) {\n            // eslint-disable-next-line no-param-reassign\n            schemaPart = inner;\n          } else {\n            break;\n          }\n        }\n      }\n\n      while (schemaPart.$ref) {\n        // eslint-disable-next-line no-param-reassign\n        schemaPart = this.getSchemaPart(schemaPart.$ref);\n      }\n\n      var schemaText = \"\".concat(this.formatSchema(schemaPart, logic)).concat(needDot ? '.' : '');\n\n      if (schemaPart.description) {\n        schemaText += \"\\n-> \".concat(schemaPart.description);\n      }\n\n      return schemaText;\n    }\n    /**\n     * @param {Schema=} schemaPart\n     * @returns {string}\n     */\n\n  }, {\n    key: \"getSchemaPartDescription\",\n    value: function getSchemaPartDescription(schemaPart) {\n      if (!schemaPart) {\n        return '';\n      }\n\n      while (schemaPart.$ref) {\n        // eslint-disable-next-line no-param-reassign\n        schemaPart = this.getSchemaPart(schemaPart.$ref);\n      }\n\n      if (schemaPart.description) {\n        return \"\\n-> \".concat(schemaPart.description);\n      }\n\n      return '';\n    }\n    /**\n     * @param {SchemaUtilErrorObject} error\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatValidationError\",\n    value: function formatValidationError(error) {\n      var _this3 = this;\n\n      var keyword = error.keyword,\n          errorDataPath = error.dataPath;\n      var dataPath = \"\".concat(this.baseDataPath).concat(errorDataPath);\n\n      switch (keyword) {\n        case 'type':\n          {\n            var parentSchema = error.parentSchema,\n                params = error.params; // eslint-disable-next-line default-case\n\n            switch (\n            /** @type {import(\"ajv\").TypeParams} */\n            params.type) {\n              case 'number':\n                return \"\".concat(dataPath, \" should be a \").concat(this.getSchemaPartText(parentSchema, false, true));\n\n              case 'integer':\n                return \"\".concat(dataPath, \" should be a \").concat(this.getSchemaPartText(parentSchema, false, true));\n\n              case 'string':\n                return \"\".concat(dataPath, \" should be a \").concat(this.getSchemaPartText(parentSchema, false, true));\n\n              case 'boolean':\n                return \"\".concat(dataPath, \" should be a \").concat(this.getSchemaPartText(parentSchema, false, true));\n\n              case 'array':\n                return \"\".concat(dataPath, \" should be an array:\\n\").concat(this.getSchemaPartText(parentSchema));\n\n              case 'object':\n                return \"\".concat(dataPath, \" should be an object:\\n\").concat(this.getSchemaPartText(parentSchema));\n\n              case 'null':\n                return \"\".concat(dataPath, \" should be a \").concat(this.getSchemaPartText(parentSchema, false, true));\n\n              default:\n                return \"\".concat(dataPath, \" should be:\\n\").concat(this.getSchemaPartText(parentSchema));\n            }\n          }\n\n        case 'instanceof':\n          {\n            var _parentSchema = error.parentSchema;\n            return \"\".concat(dataPath, \" should be an instance of \").concat(this.getSchemaPartText(_parentSchema, false, true));\n          }\n\n        case 'pattern':\n          {\n            var _params = error.params,\n                _parentSchema2 = error.parentSchema;\n            var pattern =\n            /** @type {import(\"ajv\").PatternParams} */\n            _params.pattern;\n            return \"\".concat(dataPath, \" should match pattern \").concat(JSON.stringify(pattern)).concat(getSchemaNonTypes(_parentSchema2), \".\").concat(this.getSchemaPartDescription(_parentSchema2));\n          }\n\n        case 'format':\n          {\n            var _params2 = error.params,\n                _parentSchema3 = error.parentSchema;\n            var format =\n            /** @type {import(\"ajv\").FormatParams} */\n            _params2.format;\n            return \"\".concat(dataPath, \" should match format \").concat(JSON.stringify(format)).concat(getSchemaNonTypes(_parentSchema3), \".\").concat(this.getSchemaPartDescription(_parentSchema3));\n          }\n\n        case 'formatMinimum':\n        case 'formatMaximum':\n          {\n            var _params3 = error.params,\n                _parentSchema4 = error.parentSchema;\n            var comparison =\n            /** @type {import(\"ajv\").ComparisonParams} */\n            _params3.comparison,\n                limit =\n            /** @type {import(\"ajv\").ComparisonParams} */\n            _params3.limit;\n            return \"\".concat(dataPath, \" should be \").concat(comparison, \" \").concat(JSON.stringify(limit)).concat(getSchemaNonTypes(_parentSchema4), \".\").concat(this.getSchemaPartDescription(_parentSchema4));\n          }\n\n        case 'minimum':\n        case 'maximum':\n        case 'exclusiveMinimum':\n        case 'exclusiveMaximum':\n          {\n            var _parentSchema5 = error.parentSchema,\n                _params4 = error.params;\n            var _comparison =\n            /** @type {import(\"ajv\").ComparisonParams} */\n            _params4.comparison,\n                _limit =\n            /** @type {import(\"ajv\").ComparisonParams} */\n            _params4.limit;\n\n            var _getHints5 = getHints(\n            /** @type {Schema} */\n            _parentSchema5, true),\n                _getHints6 = _toArray(_getHints5),\n                hints = _getHints6.slice(1);\n\n            if (hints.length === 0) {\n              hints.push(\"should be \".concat(_comparison, \" \").concat(_limit));\n            }\n\n            return \"\".concat(dataPath, \" \").concat(hints.join(' ')).concat(getSchemaNonTypes(_parentSchema5), \".\").concat(this.getSchemaPartDescription(_parentSchema5));\n          }\n\n        case 'multipleOf':\n          {\n            var _params5 = error.params,\n                _parentSchema6 = error.parentSchema;\n            var multipleOf =\n            /** @type {import(\"ajv\").MultipleOfParams} */\n            _params5.multipleOf;\n            return \"\".concat(dataPath, \" should be multiple of \").concat(multipleOf).concat(getSchemaNonTypes(_parentSchema6), \".\").concat(this.getSchemaPartDescription(_parentSchema6));\n          }\n\n        case 'patternRequired':\n          {\n            var _params6 = error.params,\n                _parentSchema7 = error.parentSchema;\n            var missingPattern =\n            /** @type {import(\"ajv\").PatternRequiredParams} */\n            _params6.missingPattern;\n            return \"\".concat(dataPath, \" should have property matching pattern \").concat(JSON.stringify(missingPattern)).concat(getSchemaNonTypes(_parentSchema7), \".\").concat(this.getSchemaPartDescription(_parentSchema7));\n          }\n\n        case 'minLength':\n          {\n            var _params7 = error.params,\n                _parentSchema8 = error.parentSchema;\n            var _limit2 =\n            /** @type {import(\"ajv\").LimitParams} */\n            _params7.limit;\n\n            if (_limit2 === 1) {\n              return \"\".concat(dataPath, \" should be an non-empty string\").concat(getSchemaNonTypes(_parentSchema8), \".\").concat(this.getSchemaPartDescription(_parentSchema8));\n            }\n\n            var length = _limit2 - 1;\n            return \"\".concat(dataPath, \" should be longer than \").concat(length, \" character\").concat(length > 1 ? 's' : '').concat(getSchemaNonTypes(_parentSchema8), \".\").concat(this.getSchemaPartDescription(_parentSchema8));\n          }\n\n        case 'minItems':\n          {\n            var _params8 = error.params,\n                _parentSchema9 = error.parentSchema;\n            var _limit3 =\n            /** @type {import(\"ajv\").LimitParams} */\n            _params8.limit;\n\n            if (_limit3 === 1) {\n              return \"\".concat(dataPath, \" should be an non-empty array\").concat(getSchemaNonTypes(_parentSchema9), \".\").concat(this.getSchemaPartDescription(_parentSchema9));\n            }\n\n            return \"\".concat(dataPath, \" should not have fewer than \").concat(_limit3, \" items\").concat(getSchemaNonTypes(_parentSchema9), \".\").concat(this.getSchemaPartDescription(_parentSchema9));\n          }\n\n        case 'minProperties':\n          {\n            var _params9 = error.params,\n                _parentSchema10 = error.parentSchema;\n            var _limit4 =\n            /** @type {import(\"ajv\").LimitParams} */\n            _params9.limit;\n\n            if (_limit4 === 1) {\n              return \"\".concat(dataPath, \" should be an non-empty object\").concat(getSchemaNonTypes(_parentSchema10), \".\").concat(this.getSchemaPartDescription(_parentSchema10));\n            }\n\n            return \"\".concat(dataPath, \" should not have fewer than \").concat(_limit4, \" properties\").concat(getSchemaNonTypes(_parentSchema10), \".\").concat(this.getSchemaPartDescription(_parentSchema10));\n          }\n\n        case 'maxLength':\n          {\n            var _params10 = error.params,\n                _parentSchema11 = error.parentSchema;\n            var _limit5 =\n            /** @type {import(\"ajv\").LimitParams} */\n            _params10.limit;\n            var max = _limit5 + 1;\n            return \"\".concat(dataPath, \" should be shorter than \").concat(max, \" character\").concat(max > 1 ? 's' : '').concat(getSchemaNonTypes(_parentSchema11), \".\").concat(this.getSchemaPartDescription(_parentSchema11));\n          }\n\n        case 'maxItems':\n          {\n            var _params11 = error.params,\n                _parentSchema12 = error.parentSchema;\n            var _limit6 =\n            /** @type {import(\"ajv\").LimitParams} */\n            _params11.limit;\n            return \"\".concat(dataPath, \" should not have more than \").concat(_limit6, \" items\").concat(getSchemaNonTypes(_parentSchema12), \".\").concat(this.getSchemaPartDescription(_parentSchema12));\n          }\n\n        case 'maxProperties':\n          {\n            var _params12 = error.params,\n                _parentSchema13 = error.parentSchema;\n            var _limit7 =\n            /** @type {import(\"ajv\").LimitParams} */\n            _params12.limit;\n            return \"\".concat(dataPath, \" should not have more than \").concat(_limit7, \" properties\").concat(getSchemaNonTypes(_parentSchema13), \".\").concat(this.getSchemaPartDescription(_parentSchema13));\n          }\n\n        case 'uniqueItems':\n          {\n            var _params13 = error.params,\n                _parentSchema14 = error.parentSchema;\n            var i =\n            /** @type {import(\"ajv\").UniqueItemsParams} */\n            _params13.i;\n            return \"\".concat(dataPath, \" should not contain the item '\").concat(error.data[i], \"' twice\").concat(getSchemaNonTypes(_parentSchema14), \".\").concat(this.getSchemaPartDescription(_parentSchema14));\n          }\n\n        case 'additionalItems':\n          {\n            var _params14 = error.params,\n                _parentSchema15 = error.parentSchema;\n            var _limit8 =\n            /** @type {import(\"ajv\").LimitParams} */\n            _params14.limit;\n            return \"\".concat(dataPath, \" should not have more than \").concat(_limit8, \" items\").concat(getSchemaNonTypes(_parentSchema15), \". These items are valid:\\n\").concat(this.getSchemaPartText(_parentSchema15));\n          }\n\n        case 'contains':\n          {\n            var _parentSchema16 = error.parentSchema;\n            return \"\".concat(dataPath, \" should contains at least one \").concat(this.getSchemaPartText(_parentSchema16, ['contains']), \" item\").concat(getSchemaNonTypes(_parentSchema16), \".\");\n          }\n\n        case 'required':\n          {\n            var _parentSchema17 = error.parentSchema,\n                _params15 = error.params;\n\n            var missingProperty =\n            /** @type {import(\"ajv\").DependenciesParams} */\n            _params15.missingProperty.replace(/^\\./, '');\n\n            var hasProperty = _parentSchema17 && Boolean(\n            /** @type {Schema} */\n            _parentSchema17.properties &&\n            /** @type {Schema} */\n            _parentSchema17.properties[missingProperty]);\n\n            return \"\".concat(dataPath, \" misses the property '\").concat(missingProperty, \"'\").concat(getSchemaNonTypes(_parentSchema17), \".\").concat(hasProperty ? \" Should be:\\n\".concat(this.getSchemaPartText(_parentSchema17, ['properties', missingProperty])) : this.getSchemaPartDescription(_parentSchema17));\n          }\n\n        case 'additionalProperties':\n          {\n            var _params16 = error.params,\n                _parentSchema18 = error.parentSchema;\n            var additionalProperty =\n            /** @type {import(\"ajv\").AdditionalPropertiesParams} */\n            _params16.additionalProperty;\n            return \"\".concat(dataPath, \" has an unknown property '\").concat(additionalProperty, \"'\").concat(getSchemaNonTypes(_parentSchema18), \". These properties are valid:\\n\").concat(this.getSchemaPartText(_parentSchema18));\n          }\n\n        case 'dependencies':\n          {\n            var _params17 = error.params,\n                _parentSchema19 = error.parentSchema;\n            var property =\n            /** @type {import(\"ajv\").DependenciesParams} */\n            _params17.property,\n                deps =\n            /** @type {import(\"ajv\").DependenciesParams} */\n            _params17.deps;\n            var dependencies = deps.split(',').map(\n            /**\n             * @param {string} dep\n             * @returns {string}\n             */\n            function (dep) {\n              return \"'\".concat(dep.trim(), \"'\");\n            }).join(', ');\n            return \"\".concat(dataPath, \" should have properties \").concat(dependencies, \" when property '\").concat(property, \"' is present\").concat(getSchemaNonTypes(_parentSchema19), \".\").concat(this.getSchemaPartDescription(_parentSchema19));\n          }\n\n        case 'propertyNames':\n          {\n            var _params18 = error.params,\n                _parentSchema20 = error.parentSchema,\n                schema = error.schema;\n            var propertyName =\n            /** @type {import(\"ajv\").PropertyNamesParams} */\n            _params18.propertyName;\n            return \"\".concat(dataPath, \" property name '\").concat(propertyName, \"' is invalid\").concat(getSchemaNonTypes(_parentSchema20), \". Property names should be match format \").concat(JSON.stringify(schema.format), \".\").concat(this.getSchemaPartDescription(_parentSchema20));\n          }\n\n        case 'enum':\n          {\n            var _parentSchema21 = error.parentSchema;\n\n            if (_parentSchema21 &&\n            /** @type {Schema} */\n            _parentSchema21.enum &&\n            /** @type {Schema} */\n            _parentSchema21.enum.length === 1) {\n              return \"\".concat(dataPath, \" should be \").concat(this.getSchemaPartText(_parentSchema21, false, true));\n            }\n\n            return \"\".concat(dataPath, \" should be one of these:\\n\").concat(this.getSchemaPartText(_parentSchema21));\n          }\n\n        case 'const':\n          {\n            var _parentSchema22 = error.parentSchema;\n            return \"\".concat(dataPath, \" should be equal to constant \").concat(this.getSchemaPartText(_parentSchema22, false, true));\n          }\n\n        case 'not':\n          {\n            var postfix = likeObject(\n            /** @type {Schema} */\n            error.parentSchema) ? \"\\n\".concat(this.getSchemaPartText(error.parentSchema)) : '';\n            var schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n\n            if (canApplyNot(error.schema)) {\n              return \"\".concat(dataPath, \" should be any \").concat(schemaOutput).concat(postfix, \".\");\n            }\n\n            var _schema = error.schema,\n                _parentSchema23 = error.parentSchema;\n            return \"\".concat(dataPath, \" should not be \").concat(this.getSchemaPartText(_schema, false, true)).concat(_parentSchema23 && likeObject(_parentSchema23) ? \"\\n\".concat(this.getSchemaPartText(_parentSchema23)) : '');\n          }\n\n        case 'oneOf':\n        case 'anyOf':\n          {\n            var _parentSchema24 = error.parentSchema,\n                children = error.children;\n\n            if (children && children.length > 0) {\n              if (error.schema.length === 1) {\n                var lastChild = children[children.length - 1];\n                var remainingChildren = children.slice(0, children.length - 1);\n                return this.formatValidationError(Object.assign({}, lastChild, {\n                  children: remainingChildren,\n                  parentSchema: Object.assign({}, _parentSchema24, lastChild.parentSchema)\n                }));\n              }\n\n              var filteredChildren = filterChildren(children);\n\n              if (filteredChildren.length === 1) {\n                return this.formatValidationError(filteredChildren[0]);\n              }\n\n              filteredChildren = groupChildrenByFirstChild(filteredChildren);\n              return \"\".concat(dataPath, \" should be one of these:\\n\").concat(this.getSchemaPartText(_parentSchema24), \"\\nDetails:\\n\").concat(filteredChildren.map(\n              /**\n               * @param {SchemaUtilErrorObject} nestedError\n               * @returns {string}\n               */\n              function (nestedError) {\n                return \" * \".concat(indent(_this3.formatValidationError(nestedError), '   '));\n              }).join('\\n'));\n            }\n\n            return \"\".concat(dataPath, \" should be one of these:\\n\").concat(this.getSchemaPartText(_parentSchema24));\n          }\n\n        case 'if':\n          {\n            var _params19 = error.params,\n                _parentSchema25 = error.parentSchema;\n            var failingKeyword =\n            /** @type {import(\"ajv\").IfParams} */\n            _params19.failingKeyword;\n            return \"\".concat(dataPath, \" should match \\\"\").concat(failingKeyword, \"\\\" schema:\\n\").concat(this.getSchemaPartText(_parentSchema25, [failingKeyword]));\n          }\n\n        case 'absolutePath':\n          {\n            var message = error.message,\n                _parentSchema26 = error.parentSchema;\n            return \"\".concat(dataPath, \": \").concat(message).concat(this.getSchemaPartDescription(_parentSchema26));\n          }\n\n        /* istanbul ignore next */\n\n        default:\n          {\n            var _message = error.message,\n                _parentSchema27 = error.parentSchema;\n            var ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords\n            // Fallback for unknown keywords\n\n            return \"\".concat(dataPath, \" \").concat(_message, \" (\").concat(ErrorInJSON, \").\\n\").concat(this.getSchemaPartText(_parentSchema27, false));\n          }\n      }\n    }\n    /**\n     * @param {Array<SchemaUtilErrorObject>} errors\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatValidationErrors\",\n    value: function formatValidationErrors(errors) {\n      var _this4 = this;\n\n      return errors.map(function (error) {\n        var formattedError = _this4.formatValidationError(error);\n\n        if (_this4.postFormatter) {\n          formattedError = _this4.postFormatter(formattedError, error);\n        }\n\n        return \" - \".concat(indent(formattedError, '   '));\n      }).join('\\n');\n    }\n  }]);\n\n  return ValidationError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar _default = ValidationError;\nexports.default = _default;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/babel-loader/node_modules/schema-utils/dist/ValidationError.js"],"names":["Object","defineProperty","exports","value","default","require","stringHints","numberHints","SPECIFICITY","type","not","oneOf","anyOf","if","enum","const","instanceof","required","pattern","patternRequired","format","formatMinimum","formatMaximum","minimum","exclusiveMinimum","maximum","exclusiveMaximum","multipleOf","uniqueItems","contains","minLength","maxLength","minItems","maxItems","minProperties","maxProperties","dependencies","propertyNames","additionalItems","additionalProperties","absolutePath","filterMax","array","fn","evaluatedMax","reduce","max","item","Math","filter","filterChildren","children","newChildren","error","dataPath","length","keyword","findAllChildren","schemaPaths","i","predicate","schemaPath","indexOf","every","refs","extractRefs","childrenStart","slice","concat","schema","Array","isArray","map","$ref","s","groupChildrenByFirstChild","result","child","push","assign","reverse","indent","str","prefix","replace","hasNotInSchema","findFirstTypedSchema","canApplyNot","typedSchema","likeNumber","likeInteger","likeString","likeNull","likeBoolean","isObject","maybeObj","likeArray","items","likeObject","properties","patternProperties","getArticle","test","getSchemaNonTypes","formatHints","hints","join","getHints","logic","ValidationError","errors","configuration","name","headerNameFromSchema","baseDataPathFromSchema","title","baseDataPath","splittedTitleFromSchema","match","headerName","postFormatter","header","message","formatValidationErrors","Error","captureStackTrace","constructor","path","newPath","split","schemaPart","inner","prevSchemas","newLogic","formatInnerSchema","innerSchema","addSelf","formatSchema","includes","needApplyLogicHere","values","JSON","stringify","allOf","ifValue","thenValue","then","elseValue","else","getSchemaPart","hasAdditionalItems","Boolean","keys","allProperties","Set","objectStructure","property","isRequired","forEach","dependencyName","dependency","dep","additionalPath","needDot","schemaText","description","errorDataPath","parentSchema","params","getSchemaPartText","getSchemaPartDescription","comparison","limit","missingPattern","data","missingProperty","hasProperty","additionalProperty","deps","trim","propertyName","postfix","schemaOutput","lastChild","remainingChildren","formatValidationError","filteredChildren","nestedError","failingKeyword","ErrorInJSON","formattedError","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nconst {\n  stringHints,\n  numberHints\n} = require('./util/hints');\n/** @typedef {import(\"json-schema\").JSONSchema6} JSONSchema6 */\n\n/** @typedef {import(\"json-schema\").JSONSchema7} JSONSchema7 */\n\n/** @typedef {import(\"./validate\").Schema} Schema */\n\n/** @typedef {import(\"./validate\").ValidationErrorConfiguration} ValidationErrorConfiguration */\n\n/** @typedef {import(\"./validate\").PostFormatter} PostFormatter */\n\n/** @typedef {import(\"./validate\").SchemaUtilErrorObject} SchemaUtilErrorObject */\n\n/** @enum {number} */\n\n\nconst SPECIFICITY = {\n  type: 1,\n  not: 1,\n  oneOf: 1,\n  anyOf: 1,\n  if: 1,\n  enum: 1,\n  const: 1,\n  instanceof: 1,\n  required: 2,\n  pattern: 2,\n  patternRequired: 2,\n  format: 2,\n  formatMinimum: 2,\n  formatMaximum: 2,\n  minimum: 2,\n  exclusiveMinimum: 2,\n  maximum: 2,\n  exclusiveMaximum: 2,\n  multipleOf: 2,\n  uniqueItems: 2,\n  contains: 2,\n  minLength: 2,\n  maxLength: 2,\n  minItems: 2,\n  maxItems: 2,\n  minProperties: 2,\n  maxProperties: 2,\n  dependencies: 2,\n  propertyNames: 2,\n  additionalItems: 2,\n  additionalProperties: 2,\n  absolutePath: 2\n};\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} array\n * @param {(item: SchemaUtilErrorObject) => number} fn\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\nfunction filterMax(array, fn) {\n  const evaluatedMax = array.reduce((max, item) => Math.max(max, fn(item)), 0);\n  return array.filter(item => fn(item) === evaluatedMax);\n}\n/**\n *\n * @param {Array<SchemaUtilErrorObject>} children\n * @returns {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction filterChildren(children) {\n  let newChildren = children;\n  newChildren = filterMax(newChildren,\n  /**\n   *\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => error.dataPath ? error.dataPath.length : 0);\n  newChildren = filterMax(newChildren,\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {number}\n   */\n  error => SPECIFICITY[\n  /** @type {keyof typeof SPECIFICITY} */\n  error.keyword] || 2);\n  return newChildren;\n}\n/**\n * Find all children errors\n * @param {Array<SchemaUtilErrorObject>} children\n * @param {Array<string>} schemaPaths\n * @return {number} returns index of first child\n */\n\n\nfunction findAllChildren(children, schemaPaths) {\n  let i = children.length - 1;\n\n  const predicate =\n  /**\n   * @param {string} schemaPath\n   * @returns {boolean}\n   */\n  schemaPath => children[i].schemaPath.indexOf(schemaPath) !== 0;\n\n  while (i > -1 && !schemaPaths.every(predicate)) {\n    if (children[i].keyword === 'anyOf' || children[i].keyword === 'oneOf') {\n      const refs = extractRefs(children[i]);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(children[i].schemaPath));\n      i = childrenStart - 1;\n    } else {\n      i -= 1;\n    }\n  }\n\n  return i + 1;\n}\n/**\n * Extracts all refs from schema\n * @param {SchemaUtilErrorObject} error\n * @return {Array<string>}\n */\n\n\nfunction extractRefs(error) {\n  const {\n    schema\n  } = error;\n\n  if (!Array.isArray(schema)) {\n    return [];\n  }\n\n  return schema.map(({\n    $ref\n  }) => $ref).filter(s => s);\n}\n/**\n * Groups children by their first level parent (assuming that error is root)\n * @param {Array<SchemaUtilErrorObject>} children\n * @return {Array<SchemaUtilErrorObject>}\n */\n\n\nfunction groupChildrenByFirstChild(children) {\n  const result = [];\n  let i = children.length - 1;\n\n  while (i > 0) {\n    const child = children[i];\n\n    if (child.keyword === 'anyOf' || child.keyword === 'oneOf') {\n      const refs = extractRefs(child);\n      const childrenStart = findAllChildren(children.slice(0, i), refs.concat(child.schemaPath));\n\n      if (childrenStart !== i) {\n        result.push(Object.assign({}, child, {\n          children: children.slice(childrenStart, i)\n        }));\n        i = childrenStart;\n      } else {\n        result.push(child);\n      }\n    } else {\n      result.push(child);\n    }\n\n    i -= 1;\n  }\n\n  if (i === 0) {\n    result.push(children[i]);\n  }\n\n  return result.reverse();\n}\n/**\n * @param {string} str\n * @param {string} prefix\n * @returns {string}\n */\n\n\nfunction indent(str, prefix) {\n  return str.replace(/\\n(?!$)/g, `\\n${prefix}`);\n}\n/**\n * @param {Schema} schema\n * @returns {schema is (Schema & {not: Schema})}\n */\n\n\nfunction hasNotInSchema(schema) {\n  return !!schema.not;\n}\n/**\n * @param {Schema} schema\n * @return {Schema}\n */\n\n\nfunction findFirstTypedSchema(schema) {\n  if (hasNotInSchema(schema)) {\n    return findFirstTypedSchema(schema.not);\n  }\n\n  return schema;\n}\n/**\n * @param {Schema} schema\n * @return {boolean}\n */\n\n\nfunction canApplyNot(schema) {\n  const typedSchema = findFirstTypedSchema(schema);\n  return likeNumber(typedSchema) || likeInteger(typedSchema) || likeString(typedSchema) || likeNull(typedSchema) || likeBoolean(typedSchema);\n}\n/**\n * @param {any} maybeObj\n * @returns {boolean}\n */\n\n\nfunction isObject(maybeObj) {\n  return typeof maybeObj === 'object' && maybeObj !== null;\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNumber(schema) {\n  return schema.type === 'number' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeInteger(schema) {\n  return schema.type === 'integer' || typeof schema.minimum !== 'undefined' || typeof schema.exclusiveMinimum !== 'undefined' || typeof schema.maximum !== 'undefined' || typeof schema.exclusiveMaximum !== 'undefined' || typeof schema.multipleOf !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeString(schema) {\n  return schema.type === 'string' || typeof schema.minLength !== 'undefined' || typeof schema.maxLength !== 'undefined' || typeof schema.pattern !== 'undefined' || typeof schema.format !== 'undefined' || typeof schema.formatMinimum !== 'undefined' || typeof schema.formatMaximum !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeBoolean(schema) {\n  return schema.type === 'boolean';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeArray(schema) {\n  return schema.type === 'array' || typeof schema.minItems === 'number' || typeof schema.maxItems === 'number' || typeof schema.uniqueItems !== 'undefined' || typeof schema.items !== 'undefined' || typeof schema.additionalItems !== 'undefined' || typeof schema.contains !== 'undefined';\n}\n/**\n * @param {Schema & {patternRequired?: Array<string>}} schema\n * @returns {boolean}\n */\n\n\nfunction likeObject(schema) {\n  return schema.type === 'object' || typeof schema.minProperties !== 'undefined' || typeof schema.maxProperties !== 'undefined' || typeof schema.required !== 'undefined' || typeof schema.properties !== 'undefined' || typeof schema.patternProperties !== 'undefined' || typeof schema.additionalProperties !== 'undefined' || typeof schema.dependencies !== 'undefined' || typeof schema.propertyNames !== 'undefined' || typeof schema.patternRequired !== 'undefined';\n}\n/**\n * @param {Schema} schema\n * @returns {boolean}\n */\n\n\nfunction likeNull(schema) {\n  return schema.type === 'null';\n}\n/**\n * @param {string} type\n * @returns {string}\n */\n\n\nfunction getArticle(type) {\n  if (/^[aeiou]/i.test(type)) {\n    return 'an';\n  }\n\n  return 'a';\n}\n/**\n * @param {Schema=} schema\n * @returns {string}\n */\n\n\nfunction getSchemaNonTypes(schema) {\n  if (!schema) {\n    return '';\n  }\n\n  if (!schema.type) {\n    if (likeNumber(schema) || likeInteger(schema)) {\n      return ' | should be any non-number';\n    }\n\n    if (likeString(schema)) {\n      return ' | should be any non-string';\n    }\n\n    if (likeArray(schema)) {\n      return ' | should be any non-array';\n    }\n\n    if (likeObject(schema)) {\n      return ' | should be any non-object';\n    }\n  }\n\n  return '';\n}\n/**\n * @param {Array<string>} hints\n * @returns {string}\n */\n\n\nfunction formatHints(hints) {\n  return hints.length > 0 ? `(${hints.join(', ')})` : '';\n}\n/**\n * @param {Schema} schema\n * @param {boolean} logic\n * @returns {string[]}\n */\n\n\nfunction getHints(schema, logic) {\n  if (likeNumber(schema) || likeInteger(schema)) {\n    return numberHints(schema, logic);\n  } else if (likeString(schema)) {\n    return stringHints(schema, logic);\n  }\n\n  return [];\n}\n\nclass ValidationError extends Error {\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @param {Schema} schema\n   * @param {ValidationErrorConfiguration} configuration\n   */\n  constructor(errors, schema, configuration = {}) {\n    super();\n    /** @type {string} */\n\n    this.name = 'ValidationError';\n    /** @type {Array<SchemaUtilErrorObject>} */\n\n    this.errors = errors;\n    /** @type {Schema} */\n\n    this.schema = schema;\n    let headerNameFromSchema;\n    let baseDataPathFromSchema;\n\n    if (schema.title && (!configuration.name || !configuration.baseDataPath)) {\n      const splittedTitleFromSchema = schema.title.match(/^(.+) (.+)$/);\n\n      if (splittedTitleFromSchema) {\n        if (!configuration.name) {\n          [, headerNameFromSchema] = splittedTitleFromSchema;\n        }\n\n        if (!configuration.baseDataPath) {\n          [,, baseDataPathFromSchema] = splittedTitleFromSchema;\n        }\n      }\n    }\n    /** @type {string} */\n\n\n    this.headerName = configuration.name || headerNameFromSchema || 'Object';\n    /** @type {string} */\n\n    this.baseDataPath = configuration.baseDataPath || baseDataPathFromSchema || 'configuration';\n    /** @type {PostFormatter | null} */\n\n    this.postFormatter = configuration.postFormatter || null;\n    const header = `Invalid ${this.baseDataPath} object. ${this.headerName} has been initialized using ${getArticle(this.baseDataPath)} ${this.baseDataPath} object that does not match the API schema.\\n`;\n    /** @type {string} */\n\n    this.message = `${header}${this.formatValidationErrors(errors)}`;\n    Error.captureStackTrace(this, this.constructor);\n  }\n  /**\n   * @param {string} path\n   * @returns {Schema}\n   */\n\n\n  getSchemaPart(path) {\n    const newPath = path.split('/');\n    let schemaPart = this.schema;\n\n    for (let i = 1; i < newPath.length; i++) {\n      const inner = schemaPart[\n      /** @type {keyof Schema} */\n      newPath[i]];\n\n      if (!inner) {\n        break;\n      }\n\n      schemaPart = inner;\n    }\n\n    return schemaPart;\n  }\n  /**\n   * @param {Schema} schema\n   * @param {boolean} logic\n   * @param {Array<Object>} prevSchemas\n   * @returns {string}\n   */\n\n\n  formatSchema(schema, logic = true, prevSchemas = []) {\n    let newLogic = logic;\n\n    const formatInnerSchema =\n    /**\n     *\n     * @param {Object} innerSchema\n     * @param {boolean=} addSelf\n     * @returns {string}\n     */\n    (innerSchema, addSelf) => {\n      if (!addSelf) {\n        return this.formatSchema(innerSchema, newLogic, prevSchemas);\n      }\n\n      if (prevSchemas.includes(innerSchema)) {\n        return '(recursive)';\n      }\n\n      return this.formatSchema(innerSchema, newLogic, prevSchemas.concat(schema));\n    };\n\n    if (hasNotInSchema(schema) && !likeObject(schema)) {\n      if (canApplyNot(schema.not)) {\n        newLogic = !logic;\n        return formatInnerSchema(schema.not);\n      }\n\n      const needApplyLogicHere = !schema.not.not;\n      const prefix = logic ? '' : 'non ';\n      newLogic = !logic;\n      return needApplyLogicHere ? prefix + formatInnerSchema(schema.not) : formatInnerSchema(schema.not);\n    }\n\n    if (\n    /** @type {Schema & {instanceof: string | Array<string>}} */\n    schema.instanceof) {\n      const {\n        instanceof: value\n      } =\n      /** @type {Schema & {instanceof: string | Array<string>}} */\n      schema;\n      const values = !Array.isArray(value) ? [value] : value;\n      return values.map(\n      /**\n       * @param {string} item\n       * @returns {string}\n       */\n      item => item === 'Function' ? 'function' : item).join(' | ');\n    }\n\n    if (schema.enum) {\n      return (\n        /** @type {Array<any>} */\n        schema.enum.map(item => JSON.stringify(item)).join(' | ')\n      );\n    }\n\n    if (typeof schema.const !== 'undefined') {\n      return JSON.stringify(schema.const);\n    }\n\n    if (schema.oneOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.oneOf.map(item => formatInnerSchema(item, true)).join(' | ')\n      );\n    }\n\n    if (schema.anyOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.anyOf.map(item => formatInnerSchema(item, true)).join(' | ')\n      );\n    }\n\n    if (schema.allOf) {\n      return (\n        /** @type {Array<Schema>} */\n        schema.allOf.map(item => formatInnerSchema(item, true)).join(' & ')\n      );\n    }\n\n    if (\n    /** @type {JSONSchema7} */\n    schema.if) {\n      const {\n        if: ifValue,\n        then: thenValue,\n        else: elseValue\n      } =\n      /** @type {JSONSchema7} */\n      schema;\n      return `${ifValue ? `if ${formatInnerSchema(ifValue)}` : ''}${thenValue ? ` then ${formatInnerSchema(thenValue)}` : ''}${elseValue ? ` else ${formatInnerSchema(elseValue)}` : ''}`;\n    }\n\n    if (schema.$ref) {\n      return formatInnerSchema(this.getSchemaPart(schema.$ref), true);\n    }\n\n    if (likeNumber(schema) || likeInteger(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ''}`;\n      return logic ? str : hints.length > 0 ? `non-${type} | ${str}` : `non-${type}`;\n    }\n\n    if (likeString(schema)) {\n      const [type, ...hints] = getHints(schema, logic);\n      const str = `${type}${hints.length > 0 ? ` ${formatHints(hints)}` : ''}`;\n      return logic ? str : str === 'string' ? 'non-string' : `non-string | ${str}`;\n    }\n\n    if (likeBoolean(schema)) {\n      return `${logic ? '' : 'non-'}boolean`;\n    }\n\n    if (likeArray(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minItems === 'number') {\n        hints.push(`should not have fewer than ${schema.minItems} item${schema.minItems > 1 ? 's' : ''}`);\n      }\n\n      if (typeof schema.maxItems === 'number') {\n        hints.push(`should not have more than ${schema.maxItems} item${schema.maxItems > 1 ? 's' : ''}`);\n      }\n\n      if (schema.uniqueItems) {\n        hints.push('should not have duplicate items');\n      }\n\n      const hasAdditionalItems = typeof schema.additionalItems === 'undefined' || Boolean(schema.additionalItems);\n      let items = '';\n\n      if (schema.items) {\n        if (Array.isArray(schema.items) && schema.items.length > 0) {\n          items = `${\n          /** @type {Array<Schema>} */\n          schema.items.map(item => formatInnerSchema(item)).join(', ')}`;\n\n          if (hasAdditionalItems) {\n            if (schema.additionalItems && isObject(schema.additionalItems) && Object.keys(schema.additionalItems).length > 0) {\n              hints.push(`additional items should be ${formatInnerSchema(schema.additionalItems)}`);\n            }\n          }\n        } else if (schema.items && Object.keys(schema.items).length > 0) {\n          // \"additionalItems\" is ignored\n          items = `${formatInnerSchema(schema.items)}`;\n        } else {\n          // Fallback for empty `items` value\n          items = 'any';\n        }\n      } else {\n        // \"additionalItems\" is ignored\n        items = 'any';\n      }\n\n      if (schema.contains && Object.keys(schema.contains).length > 0) {\n        hints.push(`should contains at least one ${this.formatSchema(schema.contains)} item`);\n      }\n\n      return `[${items}${hasAdditionalItems ? ', ...' : ''}]${hints.length > 0 ? ` (${hints.join(', ')})` : ''}`;\n    }\n\n    if (likeObject(schema)) {\n      // not logic already applied in formatValidationError\n      newLogic = true;\n      const hints = [];\n\n      if (typeof schema.minProperties === 'number') {\n        hints.push(`should not have fewer than ${schema.minProperties} ${schema.minProperties > 1 ? 'properties' : 'property'}`);\n      }\n\n      if (typeof schema.maxProperties === 'number') {\n        hints.push(`should not have more than ${schema.maxProperties} ${schema.minProperties && schema.minProperties > 1 ? 'properties' : 'property'}`);\n      }\n\n      if (schema.patternProperties && Object.keys(schema.patternProperties).length > 0) {\n        const patternProperties = Object.keys(schema.patternProperties);\n        hints.push(`additional property names should match pattern${patternProperties.length > 1 ? 's' : ''} ${patternProperties.map(pattern => JSON.stringify(pattern)).join(' | ')}`);\n      }\n\n      const properties = schema.properties ? Object.keys(schema.properties) : [];\n      const required = schema.required ? schema.required : [];\n      const allProperties = [...new Set(\n      /** @type {Array<string>} */\n      [].concat(required).concat(properties))];\n      const objectStructure = allProperties.map(property => {\n        const isRequired = required.includes(property); // Some properties need quotes, maybe we should add check\n        // Maybe we should output type of property (`foo: string`), but it is looks very unreadable\n\n        return `${property}${isRequired ? '' : '?'}`;\n      }).concat(typeof schema.additionalProperties === 'undefined' || Boolean(schema.additionalProperties) ? schema.additionalProperties && isObject(schema.additionalProperties) ? [`<key>: ${formatInnerSchema(schema.additionalProperties)}`] : ['…'] : []).join(', ');\n      const {\n        dependencies,\n        propertyNames,\n        patternRequired\n      } =\n      /** @type {Schema & {patternRequired?: Array<string>;}} */\n      schema;\n\n      if (dependencies) {\n        Object.keys(dependencies).forEach(dependencyName => {\n          const dependency = dependencies[dependencyName];\n\n          if (Array.isArray(dependency)) {\n            hints.push(`should have ${dependency.length > 1 ? 'properties' : 'property'} ${dependency.map(dep => `'${dep}'`).join(', ')} when property '${dependencyName}' is present`);\n          } else {\n            hints.push(`should be valid according to the schema ${formatInnerSchema(dependency)} when property '${dependencyName}' is present`);\n          }\n        });\n      }\n\n      if (propertyNames && Object.keys(propertyNames).length > 0) {\n        hints.push(`each property name should match format ${JSON.stringify(schema.propertyNames.format)}`);\n      }\n\n      if (patternRequired && patternRequired.length > 0) {\n        hints.push(`should have property matching pattern ${patternRequired.map(\n        /**\n         * @param {string} item\n         * @returns {string}\n         */\n        item => JSON.stringify(item))}`);\n      }\n\n      return `object {${objectStructure ? ` ${objectStructure} ` : ''}}${hints.length > 0 ? ` (${hints.join(', ')})` : ''}`;\n    }\n\n    if (likeNull(schema)) {\n      return `${logic ? '' : 'non-'}null`;\n    }\n\n    if (Array.isArray(schema.type)) {\n      // not logic already applied in formatValidationError\n      return `${schema.type.join(' | ')}`;\n    } // Fallback for unknown keywords\n    // not logic already applied in formatValidationError\n\n    /* istanbul ignore next */\n\n\n    return JSON.stringify(schema, null, 2);\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @param {(boolean | Array<string>)=} additionalPath\n   * @param {boolean=} needDot\n   * @param {boolean=} logic\n   * @returns {string}\n   */\n\n\n  getSchemaPartText(schemaPart, additionalPath, needDot = false, logic = true) {\n    if (!schemaPart) {\n      return '';\n    }\n\n    if (Array.isArray(additionalPath)) {\n      for (let i = 0; i < additionalPath.length; i++) {\n        /** @type {Schema | undefined} */\n        const inner = schemaPart[\n        /** @type {keyof Schema} */\n        additionalPath[i]];\n\n        if (inner) {\n          // eslint-disable-next-line no-param-reassign\n          schemaPart = inner;\n        } else {\n          break;\n        }\n      }\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    let schemaText = `${this.formatSchema(schemaPart, logic)}${needDot ? '.' : ''}`;\n\n    if (schemaPart.description) {\n      schemaText += `\\n-> ${schemaPart.description}`;\n    }\n\n    return schemaText;\n  }\n  /**\n   * @param {Schema=} schemaPart\n   * @returns {string}\n   */\n\n\n  getSchemaPartDescription(schemaPart) {\n    if (!schemaPart) {\n      return '';\n    }\n\n    while (schemaPart.$ref) {\n      // eslint-disable-next-line no-param-reassign\n      schemaPart = this.getSchemaPart(schemaPart.$ref);\n    }\n\n    if (schemaPart.description) {\n      return `\\n-> ${schemaPart.description}`;\n    }\n\n    return '';\n  }\n  /**\n   * @param {SchemaUtilErrorObject} error\n   * @returns {string}\n   */\n\n\n  formatValidationError(error) {\n    const {\n      keyword,\n      dataPath: errorDataPath\n    } = error;\n    const dataPath = `${this.baseDataPath}${errorDataPath}`;\n\n    switch (keyword) {\n      case 'type':\n        {\n          const {\n            parentSchema,\n            params\n          } = error; // eslint-disable-next-line default-case\n\n          switch (\n          /** @type {import(\"ajv\").TypeParams} */\n          params.type) {\n            case 'number':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'integer':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'string':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'boolean':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            case 'array':\n              return `${dataPath} should be an array:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case 'object':\n              return `${dataPath} should be an object:\\n${this.getSchemaPartText(parentSchema)}`;\n\n            case 'null':\n              return `${dataPath} should be a ${this.getSchemaPartText(parentSchema, false, true)}`;\n\n            default:\n              return `${dataPath} should be:\\n${this.getSchemaPartText(parentSchema)}`;\n          }\n        }\n\n      case 'instanceof':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be an instance of ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case 'pattern':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            pattern\n          } =\n          /** @type {import(\"ajv\").PatternParams} */\n          params;\n          return `${dataPath} should match pattern ${JSON.stringify(pattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'format':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            format\n          } =\n          /** @type {import(\"ajv\").FormatParams} */\n          params;\n          return `${dataPath} should match format ${JSON.stringify(format)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'formatMinimum':\n      case 'formatMaximum':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          return `${dataPath} should be ${comparison} ${JSON.stringify(limit)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minimum':\n      case 'maximum':\n      case 'exclusiveMinimum':\n      case 'exclusiveMaximum':\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const {\n            comparison,\n            limit\n          } =\n          /** @type {import(\"ajv\").ComparisonParams} */\n          params;\n          const [, ...hints] = getHints(\n          /** @type {Schema} */\n          parentSchema, true);\n\n          if (hints.length === 0) {\n            hints.push(`should be ${comparison} ${limit}`);\n          }\n\n          return `${dataPath} ${hints.join(' ')}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'multipleOf':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            multipleOf\n          } =\n          /** @type {import(\"ajv\").MultipleOfParams} */\n          params;\n          return `${dataPath} should be multiple of ${multipleOf}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'patternRequired':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            missingPattern\n          } =\n          /** @type {import(\"ajv\").PatternRequiredParams} */\n          params;\n          return `${dataPath} should have property matching pattern ${JSON.stringify(missingPattern)}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minLength':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty string${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          const length = limit - 1;\n          return `${dataPath} should be longer than ${length} character${length > 1 ? 's' : ''}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty array${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'minProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n\n          if (limit === 1) {\n            return `${dataPath} should be an non-empty object${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n          }\n\n          return `${dataPath} should not have fewer than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxLength':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          const max = limit + 1;\n          return `${dataPath} should be shorter than ${max} character${max > 1 ? 's' : ''}${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'maxProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} properties${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'uniqueItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            i\n          } =\n          /** @type {import(\"ajv\").UniqueItemsParams} */\n          params;\n          return `${dataPath} should not contain the item '${error.data[i]}' twice${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'additionalItems':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            limit\n          } =\n          /** @type {import(\"ajv\").LimitParams} */\n          params;\n          return `${dataPath} should not have more than ${limit} items${getSchemaNonTypes(parentSchema)}. These items are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'contains':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should contains at least one ${this.getSchemaPartText(parentSchema, ['contains'])} item${getSchemaNonTypes(parentSchema)}.`;\n        }\n\n      case 'required':\n        {\n          const {\n            parentSchema,\n            params\n          } = error;\n          const missingProperty =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params.missingProperty.replace(/^\\./, '');\n          const hasProperty = parentSchema && Boolean(\n          /** @type {Schema} */\n          parentSchema.properties &&\n          /** @type {Schema} */\n          parentSchema.properties[missingProperty]);\n          return `${dataPath} misses the property '${missingProperty}'${getSchemaNonTypes(parentSchema)}.${hasProperty ? ` Should be:\\n${this.getSchemaPartText(parentSchema, ['properties', missingProperty])}` : this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'additionalProperties':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            additionalProperty\n          } =\n          /** @type {import(\"ajv\").AdditionalPropertiesParams} */\n          params;\n          return `${dataPath} has an unknown property '${additionalProperty}'${getSchemaNonTypes(parentSchema)}. These properties are valid:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'dependencies':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            property,\n            deps\n          } =\n          /** @type {import(\"ajv\").DependenciesParams} */\n          params;\n          const dependencies = deps.split(',').map(\n          /**\n           * @param {string} dep\n           * @returns {string}\n           */\n          dep => `'${dep.trim()}'`).join(', ');\n          return `${dataPath} should have properties ${dependencies} when property '${property}' is present${getSchemaNonTypes(parentSchema)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'propertyNames':\n        {\n          const {\n            params,\n            parentSchema,\n            schema\n          } = error;\n          const {\n            propertyName\n          } =\n          /** @type {import(\"ajv\").PropertyNamesParams} */\n          params;\n          return `${dataPath} property name '${propertyName}' is invalid${getSchemaNonTypes(parentSchema)}. Property names should be match format ${JSON.stringify(schema.format)}.${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      case 'enum':\n        {\n          const {\n            parentSchema\n          } = error;\n\n          if (parentSchema &&\n          /** @type {Schema} */\n          parentSchema.enum &&\n          /** @type {Schema} */\n          parentSchema.enum.length === 1) {\n            return `${dataPath} should be ${this.getSchemaPartText(parentSchema, false, true)}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'const':\n        {\n          const {\n            parentSchema\n          } = error;\n          return `${dataPath} should be equal to constant ${this.getSchemaPartText(parentSchema, false, true)}`;\n        }\n\n      case 'not':\n        {\n          const postfix = likeObject(\n          /** @type {Schema} */\n          error.parentSchema) ? `\\n${this.getSchemaPartText(error.parentSchema)}` : '';\n          const schemaOutput = this.getSchemaPartText(error.schema, false, false, false);\n\n          if (canApplyNot(error.schema)) {\n            return `${dataPath} should be any ${schemaOutput}${postfix}.`;\n          }\n\n          const {\n            schema,\n            parentSchema\n          } = error;\n          return `${dataPath} should not be ${this.getSchemaPartText(schema, false, true)}${parentSchema && likeObject(parentSchema) ? `\\n${this.getSchemaPartText(parentSchema)}` : ''}`;\n        }\n\n      case 'oneOf':\n      case 'anyOf':\n        {\n          const {\n            parentSchema,\n            children\n          } = error;\n\n          if (children && children.length > 0) {\n            if (error.schema.length === 1) {\n              const lastChild = children[children.length - 1];\n              const remainingChildren = children.slice(0, children.length - 1);\n              return this.formatValidationError(Object.assign({}, lastChild, {\n                children: remainingChildren,\n                parentSchema: Object.assign({}, parentSchema, lastChild.parentSchema)\n              }));\n            }\n\n            let filteredChildren = filterChildren(children);\n\n            if (filteredChildren.length === 1) {\n              return this.formatValidationError(filteredChildren[0]);\n            }\n\n            filteredChildren = groupChildrenByFirstChild(filteredChildren);\n            return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}\\nDetails:\\n${filteredChildren.map(\n            /**\n             * @param {SchemaUtilErrorObject} nestedError\n             * @returns {string}\n             */\n            nestedError => ` * ${indent(this.formatValidationError(nestedError), '   ')}`).join('\\n')}`;\n          }\n\n          return `${dataPath} should be one of these:\\n${this.getSchemaPartText(parentSchema)}`;\n        }\n\n      case 'if':\n        {\n          const {\n            params,\n            parentSchema\n          } = error;\n          const {\n            failingKeyword\n          } =\n          /** @type {import(\"ajv\").IfParams} */\n          params;\n          return `${dataPath} should match \"${failingKeyword}\" schema:\\n${this.getSchemaPartText(parentSchema, [failingKeyword])}`;\n        }\n\n      case 'absolutePath':\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          return `${dataPath}: ${message}${this.getSchemaPartDescription(parentSchema)}`;\n        }\n\n      /* istanbul ignore next */\n\n      default:\n        {\n          const {\n            message,\n            parentSchema\n          } = error;\n          const ErrorInJSON = JSON.stringify(error, null, 2); // For `custom`, `false schema`, `$ref` keywords\n          // Fallback for unknown keywords\n\n          return `${dataPath} ${message} (${ErrorInJSON}).\\n${this.getSchemaPartText(parentSchema, false)}`;\n        }\n    }\n  }\n  /**\n   * @param {Array<SchemaUtilErrorObject>} errors\n   * @returns {string}\n   */\n\n\n  formatValidationErrors(errors) {\n    return errors.map(error => {\n      let formattedError = this.formatValidationError(error);\n\n      if (this.postFormatter) {\n        formattedError = this.postFormatter(formattedError, error);\n      }\n\n      return ` - ${indent(formattedError, '   ')}`;\n    }).join('\\n');\n  }\n\n}\n\nvar _default = ValidationError;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}