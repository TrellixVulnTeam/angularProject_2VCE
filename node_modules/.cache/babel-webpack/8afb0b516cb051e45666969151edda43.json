{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/url_resolver\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getUrlScheme = exports.UrlResolver = exports.createOfflineCompileUrlResolver = exports.createUrlResolverWithoutPackagePrefix = void 0;\n  /**\n   * Create a {@link UrlResolver} with no package prefix.\n   */\n\n  function createUrlResolverWithoutPackagePrefix() {\n    return new exports.UrlResolver();\n  }\n\n  exports.createUrlResolverWithoutPackagePrefix = createUrlResolverWithoutPackagePrefix;\n\n  function createOfflineCompileUrlResolver() {\n    return new exports.UrlResolver('.');\n  }\n\n  exports.createOfflineCompileUrlResolver = createOfflineCompileUrlResolver;\n\n  exports.UrlResolver =\n  /** @class */\n  function () {\n    function UrlResolverImpl(_packagePrefix) {\n      if (_packagePrefix === void 0) {\n        _packagePrefix = null;\n      }\n\n      this._packagePrefix = _packagePrefix;\n    }\n    /**\n     * Resolves the `url` given the `baseUrl`:\n     * - when the `url` is null, the `baseUrl` is returned,\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n     * `baseUrl` and `url`,\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n     * returned as is (ignoring the `baseUrl`)\n     */\n\n\n    UrlResolverImpl.prototype.resolve = function (baseUrl, url) {\n      var resolvedUrl = url;\n\n      if (baseUrl != null && baseUrl.length > 0) {\n        resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n      }\n\n      var resolvedParts = _split(resolvedUrl);\n\n      var prefix = this._packagePrefix;\n\n      if (prefix != null && resolvedParts != null && resolvedParts[_ComponentIndex.Scheme] == 'package') {\n        var path = resolvedParts[_ComponentIndex.Path];\n        prefix = prefix.replace(/\\/+$/, '');\n        path = path.replace(/^\\/+/, '');\n        return prefix + \"/\" + path;\n      }\n\n      return resolvedUrl;\n    };\n\n    return UrlResolverImpl;\n  }();\n  /**\n   * Extract the scheme of a URL.\n   */\n\n\n  function getUrlScheme(url) {\n    var match = _split(url);\n\n    return match && match[_ComponentIndex.Scheme] || '';\n  }\n\n  exports.getUrlScheme = getUrlScheme; // The code below is adapted from Traceur:\n  // https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\n\n  /**\n   * Builds a URI string from already-encoded parts.\n   *\n   * No encoding is performed.  Any component may be omitted as either null or\n   * undefined.\n   *\n   * @param opt_scheme The scheme such as 'http'.\n   * @param opt_userInfo The user name before the '@'.\n   * @param opt_domain The domain such as 'www.google.com', already\n   *     URI-encoded.\n   * @param opt_port The port number.\n   * @param opt_path The path, already URI-encoded.  If it is not\n   *     empty, it must begin with a slash.\n   * @param opt_queryData The URI-encoded query data.\n   * @param opt_fragment The URI-encoded fragment identifier.\n   * @return The fully combined URI.\n   */\n\n  function _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var out = [];\n\n    if (opt_scheme != null) {\n      out.push(opt_scheme + ':');\n    }\n\n    if (opt_domain != null) {\n      out.push('//');\n\n      if (opt_userInfo != null) {\n        out.push(opt_userInfo + '@');\n      }\n\n      out.push(opt_domain);\n\n      if (opt_port != null) {\n        out.push(':' + opt_port);\n      }\n    }\n\n    if (opt_path != null) {\n      out.push(opt_path);\n    }\n\n    if (opt_queryData != null) {\n      out.push('?' + opt_queryData);\n    }\n\n    if (opt_fragment != null) {\n      out.push('#' + opt_fragment);\n    }\n\n    return out.join('');\n  }\n  /**\n   * A regular expression for breaking a URI into its component parts.\n   *\n   * {@link https://tools.ietf.org/html/rfc3986#appendix-B} says\n   * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n   * disambiguation method used by POSIX regular expressions, it is natural and\n   * commonplace to use a regular expression for parsing the potential five\n   * components of a URI reference.\n   *\n   * The following line is the regular expression for breaking-down a\n   * well-formed URI reference into its components.\n   *\n   * <pre>\n   * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n   *  12            3  4          5       6  7        8 9\n   * </pre>\n   *\n   * The numbers in the second line above are only to assist readability; they\n   * indicate the reference points for each subexpression (i.e., each paired\n   * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n   * For example, matching the above expression to\n   * <pre>\n   *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n   * </pre>\n   * results in the following subexpression matches:\n   * <pre>\n   *    $1 = http:\n   *    $2 = http\n   *    $3 = //www.ics.uci.edu\n   *    $4 = www.ics.uci.edu\n   *    $5 = /pub/ietf/uri/\n   *    $6 = <undefined>\n   *    $7 = <undefined>\n   *    $8 = #Related\n   *    $9 = Related\n   * </pre>\n   * where <undefined> indicates that the component is not present, as is the\n   * case for the query component in the above example. Therefore, we can\n   * determine the value of the five components as\n   * <pre>\n   *    scheme    = $2\n   *    authority = $4\n   *    path      = $5\n   *    query     = $7\n   *    fragment  = $9\n   * </pre>\n   *\n   * The regular expression has been modified slightly to expose the\n   * userInfo, domain, and port separately from the authority.\n   * The modified version yields\n   * <pre>\n   *    $1 = http              scheme\n   *    $2 = <undefined>       userInfo -\\\n   *    $3 = www.ics.uci.edu   domain     | authority\n   *    $4 = <undefined>       port     -/\n   *    $5 = /pub/ietf/uri/    path\n   *    $6 = <undefined>       query without ?\n   *    $7 = Related           fragment without #\n   * </pre>\n   * @internal\n   */\n\n\n  var _splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + // scheme - ignore special characters\n  // used by other URL parts such as :,\n  // ?, /, #, and .\n  ':)?' + '(?://' + '(?:([^/?#]*)@)?' + // userInfo\n  \"([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)\" + // domain - restrict to letters,\n  // digits, dashes, dots, percent\n  // escapes, and unicode characters.\n  '(?::([0-9]+))?' + // port\n  ')?' + '([^?#]+)?' + // path\n  '(?:\\\\?([^#]*))?' + // query\n  '(?:#(.*))?' + // fragment\n  '$');\n  /**\n   * The index of each URI component in the return value of goog.uri.utils.split.\n   * @enum {number}\n   */\n\n\n  var _ComponentIndex;\n\n  (function (_ComponentIndex) {\n    _ComponentIndex[_ComponentIndex[\"Scheme\"] = 1] = \"Scheme\";\n    _ComponentIndex[_ComponentIndex[\"UserInfo\"] = 2] = \"UserInfo\";\n    _ComponentIndex[_ComponentIndex[\"Domain\"] = 3] = \"Domain\";\n    _ComponentIndex[_ComponentIndex[\"Port\"] = 4] = \"Port\";\n    _ComponentIndex[_ComponentIndex[\"Path\"] = 5] = \"Path\";\n    _ComponentIndex[_ComponentIndex[\"QueryData\"] = 6] = \"QueryData\";\n    _ComponentIndex[_ComponentIndex[\"Fragment\"] = 7] = \"Fragment\";\n  })(_ComponentIndex || (_ComponentIndex = {}));\n  /**\n   * Splits a URI into its component parts.\n   *\n   * Each component can be accessed via the component indices; for example:\n   * <pre>\n   * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n   * </pre>\n   *\n   * @param uri The URI string to examine.\n   * @return Each component still URI-encoded.\n   *     Each component that is present will contain the encoded value, whereas\n   *     components that are not present will be undefined or empty, depending\n   *     on the browser's regular expression implementation.  Never null, since\n   *     arbitrary strings may still look like path names.\n   */\n\n\n  function _split(uri) {\n    return uri.match(_splitRe);\n  }\n  /**\n   * Removes dot segments in given path component, as described in\n   * RFC 3986, section 5.2.4.\n   *\n   * @param path A non-empty path component.\n   * @return Path component with removed dot segments.\n   */\n\n\n  function _removeDotSegments(path) {\n    if (path == '/') return '/';\n    var leadingSlash = path[0] == '/' ? '/' : '';\n    var trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n    var segments = path.split('/');\n    var out = [];\n    var up = 0;\n\n    for (var pos = 0; pos < segments.length; pos++) {\n      var segment = segments[pos];\n\n      switch (segment) {\n        case '':\n        case '.':\n          break;\n\n        case '..':\n          if (out.length > 0) {\n            out.pop();\n          } else {\n            up++;\n          }\n\n          break;\n\n        default:\n          out.push(segment);\n      }\n    }\n\n    if (leadingSlash == '') {\n      while (up-- > 0) {\n        out.unshift('..');\n      }\n\n      if (out.length === 0) out.push('.');\n    }\n\n    return leadingSlash + out.join('/') + trailingSlash;\n  }\n  /**\n   * Takes an array of the parts from split and canonicalizes the path part\n   * and then joins all the parts.\n   */\n\n\n  function _joinAndCanonicalizePath(parts) {\n    var path = parts[_ComponentIndex.Path];\n    path = path == null ? '' : _removeDotSegments(path);\n    parts[_ComponentIndex.Path] = path;\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n  }\n  /**\n   * Resolves a URL.\n   * @param base The URL acting as the base URL.\n   * @param to The URL to resolve.\n   */\n\n\n  function _resolveUrl(base, url) {\n    var parts = _split(encodeURI(url));\n\n    var baseParts = _split(base);\n\n    if (parts[_ComponentIndex.Scheme] != null) {\n      return _joinAndCanonicalizePath(parts);\n    } else {\n      parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n    }\n\n    for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n      if (parts[i] == null) {\n        parts[i] = baseParts[i];\n      }\n    }\n\n    if (parts[_ComponentIndex.Path][0] == '/') {\n      return _joinAndCanonicalizePath(parts);\n    }\n\n    var path = baseParts[_ComponentIndex.Path];\n    if (path == null) path = '/';\n    var index = path.lastIndexOf('/');\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n    parts[_ComponentIndex.Path] = path;\n    return _joinAndCanonicalizePath(parts);\n  }\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/url_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Create a {@link UrlResolver} with no package prefix.\n */\nexport function createUrlResolverWithoutPackagePrefix(): UrlResolver {\n  return new UrlResolver();\n}\n\nexport function createOfflineCompileUrlResolver(): UrlResolver {\n  return new UrlResolver('.');\n}\n\n/**\n * Used by the {@link Compiler} when resolving HTML and CSS template URLs.\n *\n * This class can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n *\n * ## Example\n *\n * <code-example path=\"compiler/ts/url_resolver/url_resolver.ts\"></code-example>\n *\n * @security  When compiling templates at runtime, you must\n * ensure that the entire template comes from a trusted source.\n * Attacker-controlled data introduced by a template could expose your\n * application to XSS risks. For more detail, see the [Security Guide](https://g.co/ng/security).\n */\nexport interface UrlResolver {\n  resolve(baseUrl: string, url: string): string;\n}\n\nexport interface UrlResolverCtor {\n  new(packagePrefix?: string|null): UrlResolver;\n}\n\nexport const UrlResolver: UrlResolverCtor = class UrlResolverImpl {\n  constructor(private _packagePrefix: string|null = null) {}\n\n  /**\n   * Resolves the `url` given the `baseUrl`:\n   * - when the `url` is null, the `baseUrl` is returned,\n   * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\n   * `baseUrl` and `url`,\n   * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\n   * returned as is (ignoring the `baseUrl`)\n   */\n  resolve(baseUrl: string, url: string): string {\n    let resolvedUrl = url;\n    if (baseUrl != null && baseUrl.length > 0) {\n      resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n    }\n    const resolvedParts = _split(resolvedUrl);\n    let prefix = this._packagePrefix;\n    if (prefix != null && resolvedParts != null &&\n        resolvedParts[_ComponentIndex.Scheme] == 'package') {\n      let path = resolvedParts[_ComponentIndex.Path];\n      prefix = prefix.replace(/\\/+$/, '');\n      path = path.replace(/^\\/+/, '');\n      return `${prefix}/${path}`;\n    }\n    return resolvedUrl;\n  }\n};\n\n/**\n * Extract the scheme of a URL.\n */\nexport function getUrlScheme(url: string): string {\n  const match = _split(url);\n  return (match && match[_ComponentIndex.Scheme]) || '';\n}\n\n// The code below is adapted from Traceur:\n// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\n\n/**\n * Builds a URI string from already-encoded parts.\n *\n * No encoding is performed.  Any component may be omitted as either null or\n * undefined.\n *\n * @param opt_scheme The scheme such as 'http'.\n * @param opt_userInfo The user name before the '@'.\n * @param opt_domain The domain such as 'www.google.com', already\n *     URI-encoded.\n * @param opt_port The port number.\n * @param opt_path The path, already URI-encoded.  If it is not\n *     empty, it must begin with a slash.\n * @param opt_queryData The URI-encoded query data.\n * @param opt_fragment The URI-encoded fragment identifier.\n * @return The fully combined URI.\n */\nfunction _buildFromEncodedParts(\n    opt_scheme?: string, opt_userInfo?: string, opt_domain?: string, opt_port?: string,\n    opt_path?: string, opt_queryData?: string, opt_fragment?: string): string {\n  const out: string[] = [];\n\n  if (opt_scheme != null) {\n    out.push(opt_scheme + ':');\n  }\n\n  if (opt_domain != null) {\n    out.push('//');\n\n    if (opt_userInfo != null) {\n      out.push(opt_userInfo + '@');\n    }\n\n    out.push(opt_domain);\n\n    if (opt_port != null) {\n      out.push(':' + opt_port);\n    }\n  }\n\n  if (opt_path != null) {\n    out.push(opt_path);\n  }\n\n  if (opt_queryData != null) {\n    out.push('?' + opt_queryData);\n  }\n\n  if (opt_fragment != null) {\n    out.push('#' + opt_fragment);\n  }\n\n  return out.join('');\n}\n\n/**\n * A regular expression for breaking a URI into its component parts.\n *\n * {@link https://tools.ietf.org/html/rfc3986#appendix-B} says\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\n * disambiguation method used by POSIX regular expressions, it is natural and\n * commonplace to use a regular expression for parsing the potential five\n * components of a URI reference.\n *\n * The following line is the regular expression for breaking-down a\n * well-formed URI reference into its components.\n *\n * <pre>\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n *  12            3  4          5       6  7        8 9\n * </pre>\n *\n * The numbers in the second line above are only to assist readability; they\n * indicate the reference points for each subexpression (i.e., each paired\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\n * For example, matching the above expression to\n * <pre>\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\n * </pre>\n * results in the following subexpression matches:\n * <pre>\n *    $1 = http:\n *    $2 = http\n *    $3 = //www.ics.uci.edu\n *    $4 = www.ics.uci.edu\n *    $5 = /pub/ietf/uri/\n *    $6 = <undefined>\n *    $7 = <undefined>\n *    $8 = #Related\n *    $9 = Related\n * </pre>\n * where <undefined> indicates that the component is not present, as is the\n * case for the query component in the above example. Therefore, we can\n * determine the value of the five components as\n * <pre>\n *    scheme    = $2\n *    authority = $4\n *    path      = $5\n *    query     = $7\n *    fragment  = $9\n * </pre>\n *\n * The regular expression has been modified slightly to expose the\n * userInfo, domain, and port separately from the authority.\n * The modified version yields\n * <pre>\n *    $1 = http              scheme\n *    $2 = <undefined>       userInfo -\\\n *    $3 = www.ics.uci.edu   domain     | authority\n *    $4 = <undefined>       port     -/\n *    $5 = /pub/ietf/uri/    path\n *    $6 = <undefined>       query without ?\n *    $7 = Related           fragment without #\n * </pre>\n * @internal\n */\nconst _splitRe = new RegExp(\n    '^' +\n    '(?:' +\n    '([^:/?#.]+)' +  // scheme - ignore special characters\n                     // used by other URL parts such as :,\n                     // ?, /, #, and .\n    ':)?' +\n    '(?://' +\n    '(?:([^/?#]*)@)?' +                  // userInfo\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' +  // domain - restrict to letters,\n                                         // digits, dashes, dots, percent\n                                         // escapes, and unicode characters.\n    '(?::([0-9]+))?' +                   // port\n    ')?' +\n    '([^?#]+)?' +        // path\n    '(?:\\\\?([^#]*))?' +  // query\n    '(?:#(.*))?' +       // fragment\n    '$');\n\n/**\n * The index of each URI component in the return value of goog.uri.utils.split.\n * @enum {number}\n */\nenum _ComponentIndex {\n  Scheme = 1,\n  UserInfo,\n  Domain,\n  Port,\n  Path,\n  QueryData,\n  Fragment\n}\n\n/**\n * Splits a URI into its component parts.\n *\n * Each component can be accessed via the component indices; for example:\n * <pre>\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\n * </pre>\n *\n * @param uri The URI string to examine.\n * @return Each component still URI-encoded.\n *     Each component that is present will contain the encoded value, whereas\n *     components that are not present will be undefined or empty, depending\n *     on the browser's regular expression implementation.  Never null, since\n *     arbitrary strings may still look like path names.\n */\nfunction _split(uri: string): Array<string|any> {\n  return uri.match(_splitRe)!;\n}\n\n/**\n * Removes dot segments in given path component, as described in\n * RFC 3986, section 5.2.4.\n *\n * @param path A non-empty path component.\n * @return Path component with removed dot segments.\n */\nfunction _removeDotSegments(path: string): string {\n  if (path == '/') return '/';\n\n  const leadingSlash = path[0] == '/' ? '/' : '';\n  const trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n  const segments = path.split('/');\n\n  const out: string[] = [];\n  let up = 0;\n  for (let pos = 0; pos < segments.length; pos++) {\n    const segment = segments[pos];\n    switch (segment) {\n      case '':\n      case '.':\n        break;\n      case '..':\n        if (out.length > 0) {\n          out.pop();\n        } else {\n          up++;\n        }\n        break;\n      default:\n        out.push(segment);\n    }\n  }\n\n  if (leadingSlash == '') {\n    while (up-- > 0) {\n      out.unshift('..');\n    }\n\n    if (out.length === 0) out.push('.');\n  }\n\n  return leadingSlash + out.join('/') + trailingSlash;\n}\n\n/**\n * Takes an array of the parts from split and canonicalizes the path part\n * and then joins all the parts.\n */\nfunction _joinAndCanonicalizePath(parts: any[]): string {\n  let path = parts[_ComponentIndex.Path];\n  path = path == null ? '' : _removeDotSegments(path);\n  parts[_ComponentIndex.Path] = path;\n\n  return _buildFromEncodedParts(\n      parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain],\n      parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData],\n      parts[_ComponentIndex.Fragment]);\n}\n\n/**\n * Resolves a URL.\n * @param base The URL acting as the base URL.\n * @param to The URL to resolve.\n */\nfunction _resolveUrl(base: string, url: string): string {\n  const parts = _split(encodeURI(url));\n  const baseParts = _split(base);\n\n  if (parts[_ComponentIndex.Scheme] != null) {\n    return _joinAndCanonicalizePath(parts);\n  } else {\n    parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n  }\n\n  for (let i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n    if (parts[i] == null) {\n      parts[i] = baseParts[i];\n    }\n  }\n\n  if (parts[_ComponentIndex.Path][0] == '/') {\n    return _joinAndCanonicalizePath(parts);\n  }\n\n  let path = baseParts[_ComponentIndex.Path];\n  if (path == null) path = '/';\n  const index = path.lastIndexOf('/');\n  path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n  parts[_ComponentIndex.Path] = path;\n  return _joinAndCanonicalizePath(parts);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}