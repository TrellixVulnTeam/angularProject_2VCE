{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SemanticSymbol = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n  /**\n   * Represents a symbol that is recognizable across incremental rebuilds, which enables the captured\n   * metadata to be compared to the prior compilation. This allows for semantic understanding of\n   * the changes that have been made in a rebuild, which potentially enables more reuse of work\n   * from the prior compilation.\n   */\n\n\n  var SemanticSymbol =\n  /** @class */\n  function () {\n    function SemanticSymbol(\n    /**\n     * The declaration for this symbol.\n     */\n    decl) {\n      this.decl = decl;\n      this.path = file_system_1.absoluteFromSourceFile(decl.getSourceFile());\n      this.identifier = getSymbolIdentifier(decl);\n    }\n\n    return SemanticSymbol;\n  }();\n\n  exports.SemanticSymbol = SemanticSymbol;\n\n  function getSymbolIdentifier(decl) {\n    if (!ts.isSourceFile(decl.parent)) {\n      return null;\n    } // If this is a top-level class declaration, the class name is used as unique identifier.\n    // Other scenarios are currently not supported and causes the symbol not to be identified\n    // across rebuilds, unless the declaration node has not changed.\n\n\n    return decl.name.text;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;;;;;AAMG;;AACH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;AAGA;;;;;AAKG;;;AACH,MAAA,cAAA;AAAA;AAAA,cAAA;AAiBE,aAAA,cAAA;AACI;;AAEG;AACa,IAAA,IAJpB,EAI0C;AAAtB,WAAA,IAAA,GAAA,IAAA;AAElB,WAAK,IAAL,GAAY,aAAA,CAAA,sBAAA,CAAuB,IAAI,CAAC,aAAL,EAAvB,CAAZ;AACA,WAAK,UAAL,GAAkB,mBAAmB,CAAC,IAAD,CAArC;AACD;;AAuDH,WAAA,cAAA;AAAC,GAhFD,EAAA;;AAAsB,EAAA,OAAA,CAAA,cAAA,GAAA,cAAA;;AAmGtB,WAAS,mBAAT,CAA6B,IAA7B,EAAmD;AACjD,QAAI,CAAC,EAAE,CAAC,YAAH,CAAgB,IAAI,CAAC,MAArB,CAAL,EAAmC;AACjC,aAAO,IAAP;AACD,KAHgD,CAKjD;AACA;AACA;;;AACA,WAAO,IAAI,CAAC,IAAL,CAAU,IAAjB;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {absoluteFromSourceFile, AbsoluteFsPath} from '../../../file_system';\nimport {ClassDeclaration} from '../../../reflection';\n\n/**\n * Represents a symbol that is recognizable across incremental rebuilds, which enables the captured\n * metadata to be compared to the prior compilation. This allows for semantic understanding of\n * the changes that have been made in a rebuild, which potentially enables more reuse of work\n * from the prior compilation.\n */\nexport abstract class SemanticSymbol {\n  /**\n   * The path of the file that declares this symbol.\n   */\n  public readonly path: AbsoluteFsPath;\n\n  /**\n   * The identifier of this symbol, or null if no identifier could be determined. It should\n   * uniquely identify the symbol relative to `file`. This is typically just the name of a\n   * top-level class declaration, as that uniquely identifies the class within the file.\n   *\n   * If the identifier is null, then this symbol cannot be recognized across rebuilds. In that\n   * case, the symbol is always assumed to have semantically changed to guarantee a proper\n   * rebuild.\n   */\n  public readonly identifier: string|null;\n\n  constructor(\n      /**\n       * The declaration for this symbol.\n       */\n      public readonly decl: ClassDeclaration,\n  ) {\n    this.path = absoluteFromSourceFile(decl.getSourceFile());\n    this.identifier = getSymbolIdentifier(decl);\n  }\n\n  /**\n   * Allows the symbol to be compared to the equivalent symbol in the previous compilation. The\n   * return value indicates whether the symbol has been changed in a way such that its public API\n   * is affected.\n   *\n   * This method determines whether a change to _this_ symbol require the symbols that\n   * use to this symbol to be re-emitted.\n   *\n   * Note: `previousSymbol` is obtained from the most recently succeeded compilation. Symbols of\n   * failed compilations are never provided.\n   *\n   * @param previousSymbol The symbol from a prior compilation.\n   */\n  abstract isPublicApiAffected(previousSymbol: SemanticSymbol): boolean;\n\n  /**\n   * Allows the symbol to determine whether its emit is affected. The equivalent symbol from a prior\n   * build is given, in addition to the set of symbols of which the public API has changed.\n   *\n   * This method determines whether a change to _other_ symbols, i.e. those present in\n   * `publicApiAffected`, should cause _this_ symbol to be re-emitted.\n   *\n   * @param previousSymbol The equivalent symbol from a prior compilation. Note that it may be a\n   * different type of symbol, if e.g. a Component was changed into a Directive with the same name.\n   * @param publicApiAffected The set of symbols of which the public API has changed.\n   */\n  isEmitAffected?(previousSymbol: SemanticSymbol, publicApiAffected: Set<SemanticSymbol>): boolean;\n\n  /**\n   * Similar to `isPublicApiAffected`, but here equivalent symbol from a prior compilation needs\n   * to be compared to see if the type-check block of components that use this symbol is affected.\n   *\n   * This method determines whether a change to _this_ symbol require the symbols that\n   * use to this symbol to have their type-check block regenerated.\n   *\n   * Note: `previousSymbol` is obtained from the most recently succeeded compilation. Symbols of\n   * failed compilations are never provided.\n   *\n   * @param previousSymbol The symbol from a prior compilation.\n   */\n  abstract isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean;\n\n  /**\n   * Similar to `isEmitAffected`, but focused on the type-check block of this symbol. This method\n   * determines whether a change to _other_ symbols, i.e. those present in `typeCheckApiAffected`,\n   * should cause _this_ symbol's type-check block to be regenerated.\n   *\n   * @param previousSymbol The equivalent symbol from a prior compilation. Note that it may be a\n   * different type of symbol, if e.g. a Component was changed into a Directive with the same name.\n   * @param typeCheckApiAffected The set of symbols of which the type-check API has changed.\n   */\n  isTypeCheckBlockAffected?\n      (previousSymbol: SemanticSymbol, typeCheckApiAffected: Set<SemanticSymbol>): boolean;\n}\n\n/**\n * Represents a reference to a semantic symbol that has been emitted into a source file. The\n * reference may refer to the symbol using a different name than the semantic symbol's declared\n * name, e.g. in case a re-export under a different name was chosen by a reference emitter.\n * Consequently, to know that an emitted reference is still valid not only requires that the\n * semantic symbol is still valid, but also that the path by which the symbol is imported has not\n * changed.\n */\nexport interface SemanticReference {\n  symbol: SemanticSymbol;\n\n  /**\n   * The path by which the symbol has been referenced.\n   */\n  importPath: string|null;\n}\n\nfunction getSymbolIdentifier(decl: ClassDeclaration): string|null {\n  if (!ts.isSourceFile(decl.parent)) {\n    return null;\n  }\n\n  // If this is a top-level class declaration, the class name is used as unique identifier.\n  // Other scenarios are currently not supported and causes the symbol not to be identified\n  // across rebuilds, unless the declaration node has not changed.\n  return decl.name.text;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}