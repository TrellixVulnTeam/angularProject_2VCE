{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/injectable_compiler_2\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/render3/r3_factory\", \"@angular/compiler/src/render3/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.compileInjectable = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var r3_factory_1 = require(\"@angular/compiler/src/render3/r3_factory\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/util\");\n\n  function compileInjectable(meta) {\n    var result = null;\n    var factoryMeta = {\n      name: meta.name,\n      type: meta.type,\n      internalType: meta.internalType,\n      typeArgumentCount: meta.typeArgumentCount,\n      deps: [],\n      injectFn: identifiers_1.Identifiers.inject,\n      target: r3_factory_1.R3FactoryTarget.Injectable\n    };\n\n    if (meta.useClass !== undefined) {\n      // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n      // used to instantiate the class with dependencies injected, or deps are not specified and\n      // the factory of the class is used to instantiate it.\n      //\n      // A special case exists for useClass: Type where Type is the injectable type itself and no\n      // deps are specified, in which case 'useClass' is effectively ignored.\n      var useClassOnSelf = meta.useClass.isEquivalent(meta.internalType);\n      var deps = undefined;\n\n      if (meta.userDeps !== undefined) {\n        deps = meta.userDeps;\n      }\n\n      if (deps !== undefined) {\n        // factory: () => new meta.useClass(...deps)\n        result = r3_factory_1.compileFactoryFunction(tslib_1.__assign(tslib_1.__assign({}, factoryMeta), {\n          delegate: meta.useClass,\n          delegateDeps: deps,\n          delegateType: r3_factory_1.R3FactoryDelegateType.Class\n        }));\n      } else if (useClassOnSelf) {\n        result = r3_factory_1.compileFactoryFunction(factoryMeta);\n      } else {\n        result = delegateToFactory(meta.type.value, meta.useClass);\n      }\n    } else if (meta.useFactory !== undefined) {\n      if (meta.userDeps !== undefined) {\n        result = r3_factory_1.compileFactoryFunction(tslib_1.__assign(tslib_1.__assign({}, factoryMeta), {\n          delegate: meta.useFactory,\n          delegateDeps: meta.userDeps || [],\n          delegateType: r3_factory_1.R3FactoryDelegateType.Function\n        }));\n      } else {\n        result = {\n          statements: [],\n          factory: o.fn([], [new o.ReturnStatement(meta.useFactory.callFn([]))])\n        };\n      }\n    } else if (meta.useValue !== undefined) {\n      // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n      // client code because meta.useValue is an Expression which will be defined even if the actual\n      // value is undefined.\n      result = r3_factory_1.compileFactoryFunction(tslib_1.__assign(tslib_1.__assign({}, factoryMeta), {\n        expression: meta.useValue\n      }));\n    } else if (meta.useExisting !== undefined) {\n      // useExisting is an `inject` call on the existing token.\n      result = r3_factory_1.compileFactoryFunction(tslib_1.__assign(tslib_1.__assign({}, factoryMeta), {\n        expression: o.importExpr(identifiers_1.Identifiers.inject).callFn([meta.useExisting])\n      }));\n    } else {\n      result = delegateToFactory(meta.type.value, meta.internalType);\n    }\n\n    var token = meta.internalType;\n    var injectableProps = {\n      token: token,\n      factory: result.factory\n    }; // Only generate providedIn property if it has a non-null value\n\n    if (meta.providedIn.value !== null) {\n      injectableProps.providedIn = meta.providedIn;\n    }\n\n    var expression = o.importExpr(identifiers_1.Identifiers.ɵɵdefineInjectable).callFn([util_1.mapToMapExpression(injectableProps)]);\n    var type = new o.ExpressionType(o.importExpr(identifiers_1.Identifiers.InjectableDef, [util_1.typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n    return {\n      expression: expression,\n      type: type,\n      statements: result.statements\n    };\n  }\n\n  exports.compileInjectable = compileInjectable;\n\n  function delegateToFactory(type, internalType) {\n    return {\n      statements: [],\n      // If types are the same, we can generate `factory: type.ɵfac`\n      // If types are different, we have to generate a wrapper function to ensure\n      // the internal type has been resolved (`factory: function(t) { return type.ɵfac(t); }`)\n      factory: type.node === internalType.node ? internalType.prop('ɵfac') : o.fn([new o.FnParam('t', o.DYNAMIC_TYPE)], [new o.ReturnStatement(internalType.callMethod('ɵfac', [o.variable('t')]))])\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/injectable_compiler_2.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,aAAA,GAAA,OAAA,CAAA,mCAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,0CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,oCAAA,CAAA;;AAqBA,WAAgB,iBAAhB,CAAkC,IAAlC,EAA4D;AAC1D,QAAI,MAAM,GAA4D,IAAtE;AAEA,QAAM,WAAW,GAAsB;AACrC,MAAA,IAAI,EAAE,IAAI,CAAC,IAD0B;AAErC,MAAA,IAAI,EAAE,IAAI,CAAC,IAF0B;AAGrC,MAAA,YAAY,EAAE,IAAI,CAAC,YAHkB;AAIrC,MAAA,iBAAiB,EAAE,IAAI,CAAC,iBAJa;AAKrC,MAAA,IAAI,EAAE,EAL+B;AAMrC,MAAA,QAAQ,EAAE,aAAA,CAAA,WAAA,CAAY,MANe;AAOrC,MAAA,MAAM,EAAE,YAAA,CAAA,eAAA,CAAgB;AAPa,KAAvC;;AAUA,QAAI,IAAI,CAAC,QAAL,KAAkB,SAAtB,EAAiC;AAC/B;AACA;AACA;AACA;AACA;AACA;AAEA,UAAM,cAAc,GAAG,IAAI,CAAC,QAAL,CAAc,YAAd,CAA2B,IAAI,CAAC,YAAhC,CAAvB;AACA,UAAI,IAAI,GAAqC,SAA7C;;AACA,UAAI,IAAI,CAAC,QAAL,KAAkB,SAAtB,EAAiC;AAC/B,QAAA,IAAI,GAAG,IAAI,CAAC,QAAZ;AACD;;AAED,UAAI,IAAI,KAAK,SAAb,EAAwB;AACtB;AACA,QAAA,MAAM,GAAG,YAAA,CAAA,sBAAA,CAAsB,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAC1B,WAD0B,CAAA,EACf;AACd,UAAA,QAAQ,EAAE,IAAI,CAAC,QADD;AAEd,UAAA,YAAY,EAAE,IAFA;AAGd,UAAA,YAAY,EAAE,YAAA,CAAA,qBAAA,CAAsB;AAHtB,SADe,CAAtB,CAAT;AAMD,OARD,MAQO,IAAI,cAAJ,EAAoB;AACzB,QAAA,MAAM,GAAG,YAAA,CAAA,sBAAA,CAAuB,WAAvB,CAAT;AACD,OAFM,MAEA;AACL,QAAA,MAAM,GAAG,iBAAiB,CACtB,IAAI,CAAC,IAAL,CAAU,KADY,EACqB,IAAI,CAAC,QAD1B,CAA1B;AAED;AACF,KA5BD,MA4BO,IAAI,IAAI,CAAC,UAAL,KAAoB,SAAxB,EAAmC;AACxC,UAAI,IAAI,CAAC,QAAL,KAAkB,SAAtB,EAAiC;AAC/B,QAAA,MAAM,GAAG,YAAA,CAAA,sBAAA,CAAsB,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAC1B,WAD0B,CAAA,EACf;AACd,UAAA,QAAQ,EAAE,IAAI,CAAC,UADD;AAEd,UAAA,YAAY,EAAE,IAAI,CAAC,QAAL,IAAiB,EAFjB;AAGd,UAAA,YAAY,EAAE,YAAA,CAAA,qBAAA,CAAsB;AAHtB,SADe,CAAtB,CAAT;AAMD,OAPD,MAOO;AACL,QAAA,MAAM,GAAG;AACP,UAAA,UAAU,EAAE,EADL;AAEP,UAAA,OAAO,EAAE,CAAC,CAAC,EAAF,CAAK,EAAL,EAAS,CAAC,IAAI,CAAC,CAAC,eAAN,CAAsB,IAAI,CAAC,UAAL,CAAgB,MAAhB,CAAuB,EAAvB,CAAtB,CAAD,CAAT;AAFF,SAAT;AAID;AACF,KAdM,MAcA,IAAI,IAAI,CAAC,QAAL,KAAkB,SAAtB,EAAiC;AACtC;AACA;AACA;AACA,MAAA,MAAM,GAAG,YAAA,CAAA,sBAAA,CAAsB,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAC1B,WAD0B,CAAA,EACf;AACd,QAAA,UAAU,EAAE,IAAI,CAAC;AADH,OADe,CAAtB,CAAT;AAID,KARM,MAQA,IAAI,IAAI,CAAC,WAAL,KAAqB,SAAzB,EAAoC;AACzC;AACA,MAAA,MAAM,GAAG,YAAA,CAAA,sBAAA,CAAsB,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAC1B,WAD0B,CAAA,EACf;AACd,QAAA,UAAU,EAAE,CAAC,CAAC,UAAF,CAAa,aAAA,CAAA,WAAA,CAAY,MAAzB,EAAiC,MAAjC,CAAwC,CAAC,IAAI,CAAC,WAAN,CAAxC;AADE,OADe,CAAtB,CAAT;AAID,KANM,MAMA;AACL,MAAA,MAAM,GAAG,iBAAiB,CACtB,IAAI,CAAC,IAAL,CAAU,KADY,EACqB,IAAI,CAAC,YAD1B,CAA1B;AAED;;AAED,QAAM,KAAK,GAAG,IAAI,CAAC,YAAnB;AAEA,QAAM,eAAe,GAAkC;AAAC,MAAA,KAAK,EAAA,KAAN;AAAQ,MAAA,OAAO,EAAE,MAAM,CAAC;AAAxB,KAAvD,CA5E0D,CA8E1D;;AACA,QAAK,IAAI,CAAC,UAAL,CAAkC,KAAlC,KAA4C,IAAjD,EAAuD;AACrD,MAAA,eAAe,CAAC,UAAhB,GAA6B,IAAI,CAAC,UAAlC;AACD;;AAED,QAAM,UAAU,GACZ,CAAC,CAAC,UAAF,CAAa,aAAA,CAAA,WAAA,CAAY,kBAAzB,EAA6C,MAA7C,CAAoD,CAAC,MAAA,CAAA,kBAAA,CAAmB,eAAnB,CAAD,CAApD,CADJ;AAEA,QAAM,IAAI,GAAG,IAAI,CAAC,CAAC,cAAN,CAAqB,CAAC,CAAC,UAAF,CAC9B,aAAA,CAAA,WAAA,CAAY,aADkB,EACH,CAAC,MAAA,CAAA,kBAAA,CAAmB,IAAI,CAAC,IAAL,CAAU,IAA7B,EAAmC,IAAI,CAAC,iBAAxC,CAAD,CADG,CAArB,CAAb;AAGA,WAAO;AACL,MAAA,UAAU,EAAA,UADL;AAEL,MAAA,IAAI,EAAA,IAFC;AAGL,MAAA,UAAU,EAAE,MAAM,CAAC;AAHd,KAAP;AAKD;;AA7FD,EAAA,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AA+FA,WAAS,iBAAT,CAA2B,IAA3B,EAAyD,YAAzD,EAA6F;AAC3F,WAAO;AACL,MAAA,UAAU,EAAE,EADP;AAEL;AACA;AACA;AACA,MAAA,OAAO,EAAE,IAAI,CAAC,IAAL,KAAc,YAAY,CAAC,IAA3B,GACL,YAAY,CAAC,IAAb,CAAkB,MAAlB,CADK,GAEL,CAAC,CAAC,EAAF,CAAK,CAAC,IAAI,CAAC,CAAC,OAAN,CAAc,GAAd,EAAmB,CAAC,CAAC,YAArB,CAAD,CAAL,EAA2C,CAAC,IAAI,CAAC,CAAC,eAAN,CAAsB,YAAY,CAAC,UAAb,CACnB,MADmB,EACX,CAAC,CAAC,CAAC,QAAF,CAAW,GAAX,CAAD,CADW,CAAtB,CAAD,CAA3C;AAPC,KAAP;AAUD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {compileFactoryFunction, R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata, R3FactoryTarget} from './render3/r3_factory';\nimport {mapToMapExpression, R3Reference, typeWithParameters} from './render3/util';\n\nexport interface InjectableDef {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: R3Reference;\n  internalType: o.Expression;\n  typeArgumentCount: number;\n  providedIn: o.Expression;\n  useClass?: o.Expression;\n  useFactory?: o.Expression;\n  useExisting?: o.Expression;\n  useValue?: o.Expression;\n  userDeps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(meta: R3InjectableMetadata): InjectableDef {\n  let result: {factory: o.Expression, statements: o.Statement[]}|null = null;\n\n  const factoryMeta: R3FactoryMetadata = {\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    injectFn: Identifiers.inject,\n    target: R3FactoryTarget.Injectable,\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n\n    const useClassOnSelf = meta.useClass.isEquivalent(meta.internalType);\n    let deps: R3DependencyMetadata[]|undefined = undefined;\n    if (meta.userDeps !== undefined) {\n      deps = meta.userDeps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class,\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = delegateToFactory(\n          meta.type.value as o.WrappedNodeExpr<any>, meta.useClass as o.WrappedNodeExpr<any>);\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.userDeps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.userDeps || [],\n        delegateType: R3FactoryDelegateType.Function,\n      });\n    } else {\n      result = {\n        statements: [],\n        factory: o.fn([], [new o.ReturnStatement(meta.useFactory.callFn([]))])\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue,\n    });\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: o.importExpr(Identifiers.inject).callFn([meta.useExisting]),\n    });\n  } else {\n    result = delegateToFactory(\n        meta.type.value as o.WrappedNodeExpr<any>, meta.internalType as o.WrappedNodeExpr<any>);\n  }\n\n  const token = meta.internalType;\n\n  const injectableProps: {[key: string]: o.Expression} = {token, factory: result.factory};\n\n  // Only generate providedIn property if it has a non-null value\n  if ((meta.providedIn as o.LiteralExpr).value !== null) {\n    injectableProps.providedIn = meta.providedIn;\n  }\n\n  const expression =\n      o.importExpr(Identifiers.ɵɵdefineInjectable).callFn([mapToMapExpression(injectableProps)]);\n  const type = new o.ExpressionType(o.importExpr(\n      Identifiers.InjectableDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n\n  return {\n    expression,\n    type,\n    statements: result.statements,\n  };\n}\n\nfunction delegateToFactory(type: o.WrappedNodeExpr<any>, internalType: o.WrappedNodeExpr<any>) {\n  return {\n    statements: [],\n    // If types are the same, we can generate `factory: type.ɵfac`\n    // If types are different, we have to generate a wrapper function to ensure\n    // the internal type has been resolved (`factory: function(t) { return type.ɵfac(t); }`)\n    factory: type.node === internalType.node ?\n        internalType.prop('ɵfac') :\n        o.fn([new o.FnParam('t', o.DYNAMIC_TYPE)], [new o.ReturnStatement(internalType.callMethod(\n                                                       'ɵfac', [o.variable('t')]))])\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}