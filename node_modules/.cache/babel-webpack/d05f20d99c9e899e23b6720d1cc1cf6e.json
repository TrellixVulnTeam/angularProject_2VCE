{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/util\", [\"require\", \"exports\", \"@angular/compiler/src/aot/static_symbol\", \"@angular/compiler/src/output/abstract_emitter\", \"@angular/compiler/src/output/output_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.wrapReference = exports.guardedExpression = exports.devOnlyGuardedExpression = exports.jitOnlyGuardedExpression = exports.prepareSyntheticListenerFunctionName = exports.getSafePropertyAccessString = exports.getSyntheticPropertyName = exports.isSyntheticPropertyOrListener = exports.prepareSyntheticListenerName = exports.prepareSyntheticPropertyName = exports.typeWithParameters = exports.convertMetaToOutput = exports.mapToMapExpression = void 0;\n\n  var static_symbol_1 = require(\"@angular/compiler/src/aot/static_symbol\");\n\n  var abstract_emitter_1 = require(\"@angular/compiler/src/output/abstract_emitter\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n  /**\n   * Convert an object map with `Expression` values into a `LiteralMapExpr`.\n   */\n\n\n  function mapToMapExpression(map) {\n    var result = Object.keys(map).map(function (key) {\n      return {\n        key: key,\n        // The assertion here is because really TypeScript doesn't allow us to express that if the\n        // key is present, it will have a value, but this is true in reality.\n        value: map[key],\n        quoted: false\n      };\n    });\n    return o.literalMap(result);\n  }\n\n  exports.mapToMapExpression = mapToMapExpression;\n  /**\n   * Convert metadata into an `Expression` in the given `OutputContext`.\n   *\n   * This operation will handle arrays, references to symbols, or literal `null` or `undefined`.\n   */\n\n  function convertMetaToOutput(meta, ctx) {\n    if (Array.isArray(meta)) {\n      return o.literalArr(meta.map(function (entry) {\n        return convertMetaToOutput(entry, ctx);\n      }));\n    }\n\n    if (meta instanceof static_symbol_1.StaticSymbol) {\n      return ctx.importExpr(meta);\n    }\n\n    if (meta == null) {\n      return o.literal(meta);\n    }\n\n    throw new Error(\"Internal error: Unsupported or unknown metadata: \" + meta);\n  }\n\n  exports.convertMetaToOutput = convertMetaToOutput;\n\n  function typeWithParameters(type, numParams) {\n    if (numParams === 0) {\n      return o.expressionType(type);\n    }\n\n    var params = [];\n\n    for (var i = 0; i < numParams; i++) {\n      params.push(o.DYNAMIC_TYPE);\n    }\n\n    return o.expressionType(type, undefined, params);\n  }\n\n  exports.typeWithParameters = typeWithParameters;\n  var ANIMATE_SYMBOL_PREFIX = '@';\n\n  function prepareSyntheticPropertyName(name) {\n    return \"\" + ANIMATE_SYMBOL_PREFIX + name;\n  }\n\n  exports.prepareSyntheticPropertyName = prepareSyntheticPropertyName;\n\n  function prepareSyntheticListenerName(name, phase) {\n    return \"\" + ANIMATE_SYMBOL_PREFIX + name + \".\" + phase;\n  }\n\n  exports.prepareSyntheticListenerName = prepareSyntheticListenerName;\n\n  function isSyntheticPropertyOrListener(name) {\n    return name.charAt(0) == ANIMATE_SYMBOL_PREFIX;\n  }\n\n  exports.isSyntheticPropertyOrListener = isSyntheticPropertyOrListener;\n\n  function getSyntheticPropertyName(name) {\n    // this will strip out listener phase values...\n    // @foo.start => @foo\n    var i = name.indexOf('.');\n    name = i > 0 ? name.substring(0, i) : name;\n\n    if (name.charAt(0) !== ANIMATE_SYMBOL_PREFIX) {\n      name = ANIMATE_SYMBOL_PREFIX + name;\n    }\n\n    return name;\n  }\n\n  exports.getSyntheticPropertyName = getSyntheticPropertyName;\n\n  function getSafePropertyAccessString(accessor, name) {\n    var escapedName = abstract_emitter_1.escapeIdentifier(name, false, false);\n    return escapedName !== name ? accessor + \"[\" + escapedName + \"]\" : accessor + \".\" + name;\n  }\n\n  exports.getSafePropertyAccessString = getSafePropertyAccessString;\n\n  function prepareSyntheticListenerFunctionName(name, phase) {\n    return \"animation_\" + name + \"_\" + phase;\n  }\n\n  exports.prepareSyntheticListenerFunctionName = prepareSyntheticListenerFunctionName;\n\n  function jitOnlyGuardedExpression(expr) {\n    return guardedExpression('ngJitMode', expr);\n  }\n\n  exports.jitOnlyGuardedExpression = jitOnlyGuardedExpression;\n\n  function devOnlyGuardedExpression(expr) {\n    return guardedExpression('ngDevMode', expr);\n  }\n\n  exports.devOnlyGuardedExpression = devOnlyGuardedExpression;\n\n  function guardedExpression(guard, expr) {\n    var guardExpr = new o.ExternalExpr({\n      name: guard,\n      moduleName: null\n    });\n    var guardNotDefined = new o.BinaryOperatorExpr(o.BinaryOperator.Identical, new o.TypeofExpr(guardExpr), o.literal('undefined'));\n    var guardUndefinedOrTrue = new o.BinaryOperatorExpr(o.BinaryOperator.Or, guardNotDefined, guardExpr,\n    /* type */\n    undefined,\n    /* sourceSpan */\n    undefined, true);\n    return new o.BinaryOperatorExpr(o.BinaryOperator.And, guardUndefinedOrTrue, expr);\n  }\n\n  exports.guardedExpression = guardedExpression;\n\n  function wrapReference(value) {\n    var wrapped = new o.WrappedNodeExpr(value);\n    return {\n      value: wrapped,\n      type: wrapped\n    };\n  }\n\n  exports.wrapReference = wrapReference;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/render3/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {escapeIdentifier} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\nimport {OutputContext} from '../util';\n\n/**\n * Convert an object map with `Expression` values into a `LiteralMapExpr`.\n */\nexport function mapToMapExpression(map: {[key: string]: o.Expression|undefined}): o.LiteralMapExpr {\n  const result = Object.keys(map).map(\n      key => ({\n        key,\n        // The assertion here is because really TypeScript doesn't allow us to express that if the\n        // key is present, it will have a value, but this is true in reality.\n        value: map[key]!,\n        quoted: false,\n      }));\n  return o.literalMap(result);\n}\n\n/**\n * Convert metadata into an `Expression` in the given `OutputContext`.\n *\n * This operation will handle arrays, references to symbols, or literal `null` or `undefined`.\n */\nexport function convertMetaToOutput(meta: any, ctx: OutputContext): o.Expression {\n  if (Array.isArray(meta)) {\n    return o.literalArr(meta.map(entry => convertMetaToOutput(entry, ctx)));\n  }\n  if (meta instanceof StaticSymbol) {\n    return ctx.importExpr(meta);\n  }\n  if (meta == null) {\n    return o.literal(meta);\n  }\n\n  throw new Error(`Internal error: Unsupported or unknown metadata: ${meta}`);\n}\n\nexport function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n  if (numParams === 0) {\n    return o.expressionType(type);\n  }\n  const params: o.Type[] = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(o.DYNAMIC_TYPE);\n  }\n  return o.expressionType(type, undefined, params);\n}\n\nexport interface R3Reference {\n  value: o.Expression;\n  type: o.Expression;\n}\n\nconst ANIMATE_SYMBOL_PREFIX = '@';\nexport function prepareSyntheticPropertyName(name: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\n\nexport function prepareSyntheticListenerName(name: string, phase: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\n\nexport function isSyntheticPropertyOrListener(name: string) {\n  return name.charAt(0) == ANIMATE_SYMBOL_PREFIX;\n}\n\nexport function getSyntheticPropertyName(name: string) {\n  // this will strip out listener phase values...\n  // @foo.start => @foo\n  const i = name.indexOf('.');\n  name = i > 0 ? name.substring(0, i) : name;\n  if (name.charAt(0) !== ANIMATE_SYMBOL_PREFIX) {\n    name = ANIMATE_SYMBOL_PREFIX + name;\n  }\n  return name;\n}\n\nexport function getSafePropertyAccessString(accessor: string, name: string): string {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\n\nexport function prepareSyntheticListenerFunctionName(name: string, phase: string) {\n  return `animation_${name}_${phase}`;\n}\n\nexport function jitOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngJitMode', expr);\n}\n\nexport function devOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngDevMode', expr);\n}\n\nexport function guardedExpression(guard: string, expr: o.Expression): o.Expression {\n  const guardExpr = new o.ExternalExpr({name: guard, moduleName: null});\n  const guardNotDefined = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Identical, new o.TypeofExpr(guardExpr), o.literal('undefined'));\n  const guardUndefinedOrTrue = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined,\n      /* sourceSpan */ undefined, true);\n  return new o.BinaryOperatorExpr(o.BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\n\nexport function wrapReference(value: any): R3Reference {\n  const wrapped = new o.WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}