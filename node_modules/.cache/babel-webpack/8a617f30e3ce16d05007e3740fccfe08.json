{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NgccProcessor = void 0;\n\nvar ngcc_1 = require(\"@angular/compiler-cli/ngcc\");\n\nvar child_process_1 = require(\"child_process\");\n\nvar crypto_1 = require(\"crypto\");\n\nvar enhanced_resolve_1 = require(\"enhanced-resolve\");\n\nvar fs_1 = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar benchmark_1 = require(\"./benchmark\"); // We cannot create a plugin for this, because NGTSC requires addition type\n// information which ngcc creates when processing a package which was compiled with NGC.\n// Example of such errors:\n// ERROR in node_modules/@angular/platform-browser/platform-browser.d.ts(42,22):\n// error TS-996002: Appears in the NgModule.imports of AppModule,\n// but could not be resolved to an NgModule class\n// We now transform a package and it's typings when NGTSC is resolving a module.\n\n\nvar NgccProcessor = /*#__PURE__*/function () {\n  function NgccProcessor(propertiesToConsider, compilationWarnings, compilationErrors, basePath, tsConfigPath, inputFileSystem, symlinks) {\n    _classCallCheck(this, NgccProcessor);\n\n    this.propertiesToConsider = propertiesToConsider;\n    this.compilationWarnings = compilationWarnings;\n    this.compilationErrors = compilationErrors;\n    this.basePath = basePath;\n    this.tsConfigPath = tsConfigPath;\n    this.inputFileSystem = inputFileSystem;\n    this.symlinks = symlinks;\n    this._processedModules = new Set();\n    this._logger = new NgccLogger(this.compilationWarnings, this.compilationErrors);\n    this._nodeModulesDirectory = this.findNodeModulesDirectory(this.basePath);\n    this._resolver = enhanced_resolve_1.ResolverFactory.createResolver({\n      // NOTE: @types/webpack InputFileSystem is missing some methods\n      // tslint:disable-next-line: no-any\n      fileSystem: this.inputFileSystem,\n      extensions: ['.json'],\n      useSyncFileSystemCalls: true,\n      symlinks: symlinks\n    });\n  }\n  /** Process the entire node modules tree. */\n\n\n  _createClass(NgccProcessor, [{\n    key: \"process\",\n    value: function (_process) {\n      function process() {\n        return _process.apply(this, arguments);\n      }\n\n      process.toString = function () {\n        return _process.toString();\n      };\n\n      return process;\n    }(function () {\n      // Under Bazel when running in sandbox mode parts of the filesystem is read-only.\n      if (process.env.BAZEL_TARGET) {\n        return;\n      } // Skip if node_modules are read-only\n\n\n      var corePackage = this.tryResolvePackage('@angular/core', this._nodeModulesDirectory);\n\n      if (corePackage && isReadOnlyFile(corePackage)) {\n        return;\n      } // Perform a ngcc run check to determine if an initial execution is required.\n      // If a run hash file exists that matches the current package manager lock file and the\n      // project's tsconfig, then an initial ngcc run has already been performed.\n\n\n      var skipProcessing = false;\n      var runHashFilePath;\n      var runHashBasePath = path.join(this._nodeModulesDirectory, '.cli-ngcc');\n      var projectBasePath = path.join(this._nodeModulesDirectory, '..');\n\n      try {\n        var lockData;\n        var lockFile = 'yarn.lock';\n\n        try {\n          lockData = fs_1.readFileSync(path.join(projectBasePath, lockFile));\n        } catch (_a) {\n          lockFile = 'package-lock.json';\n          lockData = fs_1.readFileSync(path.join(projectBasePath, lockFile));\n        }\n\n        var ngccConfigData;\n\n        try {\n          ngccConfigData = fs_1.readFileSync(path.join(projectBasePath, 'ngcc.config.js'));\n        } catch (_b) {\n          ngccConfigData = '';\n        }\n\n        var relativeTsconfigPath = path.relative(projectBasePath, this.tsConfigPath);\n        var tsconfigData = fs_1.readFileSync(this.tsConfigPath); // Generate a hash that represents the state of the package lock file and used tsconfig\n\n        var runHash = crypto_1.createHash('sha256').update(lockData).update(lockFile).update(ngccConfigData).update(tsconfigData).update(relativeTsconfigPath).digest('hex'); // The hash is used directly in the file name to mitigate potential read/write race\n        // conditions as well as to only require a file existence check\n\n        runHashFilePath = path.join(runHashBasePath, runHash + '.lock'); // If the run hash lock file exists, then ngcc was already run against this project state\n\n        if (fs_1.existsSync(runHashFilePath)) {\n          skipProcessing = true;\n        }\n      } catch (_c) {// Any error means an ngcc execution is needed\n      }\n\n      if (skipProcessing) {\n        return;\n      }\n\n      var timeLabel = 'NgccProcessor.process';\n      benchmark_1.time(timeLabel); // We spawn instead of using the API because:\n      // - NGCC Async uses clustering which is problematic when used via the API which means\n      // that we cannot setup multiple cluster masters with different options.\n      // - We will not be able to have concurrent builds otherwise Ex: App-Shell,\n      // as NGCC will create a lock file for both builds and it will cause builds to fails.\n\n      var _child_process_1$spaw = child_process_1.spawnSync(process.execPath, [require.resolve('@angular/compiler-cli/ngcc/main-ngcc.js'), '--source', this._nodeModulesDirectory, '--properties'].concat(_toConsumableArray(this.propertiesToConsider), ['--first-only', '--create-ivy-entry-points', '--async', '--tsconfig', this.tsConfigPath, '--use-program-dependencies']), {\n        stdio: ['inherit', process.stderr, process.stderr]\n      }),\n          status = _child_process_1$spaw.status,\n          error = _child_process_1$spaw.error;\n\n      if (status !== 0) {\n        var errorMessage = (error === null || error === void 0 ? void 0 : error.message) || '';\n        throw new Error(errorMessage + \"NGCC failed\".concat(errorMessage ? ', see above' : '', \".\"));\n      }\n\n      benchmark_1.timeEnd(timeLabel); // ngcc was successful so if a run hash was generated, write it for next time\n\n      if (runHashFilePath) {\n        try {\n          if (!fs_1.existsSync(runHashBasePath)) {\n            fs_1.mkdirSync(runHashBasePath, {\n              recursive: true\n            });\n          }\n\n          fs_1.writeFileSync(runHashFilePath, '');\n        } catch (_d) {// Errors are non-fatal\n        }\n      }\n    }\n    /** Process a module and it's depedencies. */\n    )\n  }, {\n    key: \"processModule\",\n    value: function processModule(moduleName, resolvedModule) {\n      var resolvedFileName = resolvedModule.resolvedFileName;\n\n      if (!resolvedFileName || moduleName.startsWith('.') || this._processedModules.has(resolvedFileName)) {\n        // Skip when module is unknown, relative or NGCC compiler is not found or already processed.\n        return;\n      }\n\n      var packageJsonPath = this.tryResolvePackage(moduleName, resolvedFileName); // If the package.json is read only we should skip calling NGCC.\n      // With Bazel when running under sandbox the filesystem is read-only.\n\n      if (!packageJsonPath || isReadOnlyFile(packageJsonPath)) {\n        // add it to processed so the second time round we skip this.\n        this._processedModules.add(resolvedFileName);\n\n        return;\n      }\n\n      var timeLabel = \"NgccProcessor.processModule.ngcc.process+\".concat(moduleName);\n      benchmark_1.time(timeLabel);\n      ngcc_1.process({\n        basePath: this._nodeModulesDirectory,\n        targetEntryPointPath: path.dirname(packageJsonPath),\n        propertiesToConsider: this.propertiesToConsider,\n        compileAllFormats: false,\n        createNewEntryPointFormats: true,\n        logger: this._logger,\n        tsConfigPath: this.tsConfigPath\n      });\n      benchmark_1.timeEnd(timeLabel); // Purge this file from cache, since NGCC add new mainFields. Ex: module_ivy_ngcc\n      // which are unknown in the cached file.\n\n      if (this.inputFileSystem.purge) {\n        // tslint:disable-next-line: no-any\n        this.inputFileSystem.purge(packageJsonPath);\n      }\n\n      this._processedModules.add(resolvedFileName);\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(fileName) {\n      this._processedModules.delete(fileName);\n    }\n    /**\n     * Try resolve a package.json file from the resolved .d.ts file.\n     */\n\n  }, {\n    key: \"tryResolvePackage\",\n    value: function tryResolvePackage(moduleName, resolvedFileName) {\n      try {\n        var resolvedPath = this._resolver.resolveSync({}, resolvedFileName, \"\".concat(moduleName, \"/package.json\"));\n\n        return resolvedPath || undefined;\n      } catch (_a) {\n        // Ex: @angular/compiler/src/i18n/i18n_ast/package.json\n        // or local libraries which don't reside in node_modules\n        var packageJsonPath = path.resolve(resolvedFileName, '../package.json');\n        return fs_1.existsSync(packageJsonPath) ? packageJsonPath : undefined;\n      }\n    }\n  }, {\n    key: \"findNodeModulesDirectory\",\n    value: function findNodeModulesDirectory(startPoint) {\n      var current = startPoint;\n\n      while (path.dirname(current) !== current) {\n        var nodePath = path.join(current, 'node_modules');\n\n        if (fs_1.existsSync(nodePath)) {\n          return nodePath;\n        }\n\n        current = path.dirname(current);\n      }\n\n      throw new Error(\"Cannot locate the 'node_modules' directory.\");\n    }\n  }]);\n\n  return NgccProcessor;\n}();\n\nexports.NgccProcessor = NgccProcessor;\n\nvar NgccLogger = /*#__PURE__*/function () {\n  function NgccLogger(compilationWarnings, compilationErrors) {\n    _classCallCheck(this, NgccLogger);\n\n    this.compilationWarnings = compilationWarnings;\n    this.compilationErrors = compilationErrors;\n    this.level = ngcc_1.LogLevel.info;\n  }\n\n  _createClass(NgccLogger, [{\n    key: \"debug\",\n    value: function debug() {}\n  }, {\n    key: \"info\",\n    value: function info() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // Log to stderr because it's a progress-like info message.\n      process.stderr.write(\"\\n\".concat(args.join(' '), \"\\n\"));\n    }\n  }, {\n    key: \"warn\",\n    value: function warn() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      this.compilationWarnings.push(args.join(' '));\n    }\n  }, {\n    key: \"error\",\n    value: function error() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      this.compilationErrors.push(new Error(args.join(' ')));\n    }\n  }]);\n\n  return NgccLogger;\n}();\n\nfunction isReadOnlyFile(fileName) {\n  try {\n    fs_1.accessSync(fileName, fs_1.constants.W_OK);\n    return false;\n  } catch (_a) {\n    return true;\n  }\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/ngcc_processor.js"],"names":["Object","defineProperty","exports","value","NgccProcessor","ngcc_1","require","child_process_1","crypto_1","enhanced_resolve_1","fs_1","path","benchmark_1","propertiesToConsider","compilationWarnings","compilationErrors","basePath","tsConfigPath","inputFileSystem","symlinks","_processedModules","Set","_logger","NgccLogger","_nodeModulesDirectory","findNodeModulesDirectory","_resolver","ResolverFactory","createResolver","fileSystem","extensions","useSyncFileSystemCalls","process","env","BAZEL_TARGET","corePackage","tryResolvePackage","isReadOnlyFile","skipProcessing","runHashFilePath","runHashBasePath","join","projectBasePath","lockData","lockFile","readFileSync","_a","ngccConfigData","_b","relativeTsconfigPath","relative","tsconfigData","runHash","createHash","update","digest","existsSync","_c","timeLabel","time","spawnSync","execPath","resolve","stdio","stderr","status","error","errorMessage","message","Error","timeEnd","mkdirSync","recursive","writeFileSync","_d","moduleName","resolvedModule","resolvedFileName","startsWith","has","packageJsonPath","add","targetEntryPointPath","dirname","compileAllFormats","createNewEntryPointFormats","logger","purge","fileName","delete","resolvedPath","resolveSync","undefined","startPoint","current","nodePath","level","LogLevel","info","args","write","push","accessSync","constants","W_OK"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,aAAR,GAAwB,KAAK,CAA7B;;AACA,IAAMC,MAAM,GAAGC,OAAO,CAAC,4BAAD,CAAtB;;AACA,IAAMC,eAAe,GAAGD,OAAO,CAAC,eAAD,CAA/B;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,QAAD,CAAxB;;AACA,IAAMG,kBAAkB,GAAGH,OAAO,CAAC,kBAAD,CAAlC;;AACA,IAAMI,IAAI,GAAGJ,OAAO,CAAC,IAAD,CAApB;;AACA,IAAMK,IAAI,GAAGL,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMM,WAAW,GAAGN,OAAO,CAAC,aAAD,CAA3B,C,CACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACMF,a;AACF,yBAAYS,oBAAZ,EAAkCC,mBAAlC,EAAuDC,iBAAvD,EAA0EC,QAA1E,EAAoFC,YAApF,EAAkGC,eAAlG,EAAmHC,QAAnH,EAA6H;AAAA;;AACzH,SAAKN,oBAAL,GAA4BA,oBAA5B;AACA,SAAKC,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,iBAAL,GAAyB,IAAIC,GAAJ,EAAzB;AACA,SAAKC,OAAL,GAAe,IAAIC,UAAJ,CAAe,KAAKT,mBAApB,EAAyC,KAAKC,iBAA9C,CAAf;AACA,SAAKS,qBAAL,GAA6B,KAAKC,wBAAL,CAA8B,KAAKT,QAAnC,CAA7B;AACA,SAAKU,SAAL,GAAiBjB,kBAAkB,CAACkB,eAAnB,CAAmCC,cAAnC,CAAkD;AAC/D;AACA;AACAC,MAAAA,UAAU,EAAE,KAAKX,eAH8C;AAI/DY,MAAAA,UAAU,EAAE,CAAC,OAAD,CAJmD;AAK/DC,MAAAA,sBAAsB,EAAE,IALuC;AAM/DZ,MAAAA,QAAQ,EAARA;AAN+D,KAAlD,CAAjB;AAQH;AACD;;;;;;;;;;;;;;;MACA,YAAU;AACN;AACA,UAAIa,OAAO,CAACC,GAAR,CAAYC,YAAhB,EAA8B;AAC1B;AACH,OAJK,CAKN;;;AACA,UAAMC,WAAW,GAAG,KAAKC,iBAAL,CAAuB,eAAvB,EAAwC,KAAKZ,qBAA7C,CAApB;;AACA,UAAIW,WAAW,IAAIE,cAAc,CAACF,WAAD,CAAjC,EAAgD;AAC5C;AACH,OATK,CAUN;AACA;AACA;;;AACA,UAAIG,cAAc,GAAG,KAArB;AACA,UAAIC,eAAJ;AACA,UAAMC,eAAe,GAAG7B,IAAI,CAAC8B,IAAL,CAAU,KAAKjB,qBAAf,EAAsC,WAAtC,CAAxB;AACA,UAAMkB,eAAe,GAAG/B,IAAI,CAAC8B,IAAL,CAAU,KAAKjB,qBAAf,EAAsC,IAAtC,CAAxB;;AACA,UAAI;AACA,YAAImB,QAAJ;AACA,YAAIC,QAAQ,GAAG,WAAf;;AACA,YAAI;AACAD,UAAAA,QAAQ,GAAGjC,IAAI,CAACmC,YAAL,CAAkBlC,IAAI,CAAC8B,IAAL,CAAUC,eAAV,EAA2BE,QAA3B,CAAlB,CAAX;AACH,SAFD,CAGA,OAAOE,EAAP,EAAW;AACPF,UAAAA,QAAQ,GAAG,mBAAX;AACAD,UAAAA,QAAQ,GAAGjC,IAAI,CAACmC,YAAL,CAAkBlC,IAAI,CAAC8B,IAAL,CAAUC,eAAV,EAA2BE,QAA3B,CAAlB,CAAX;AACH;;AACD,YAAIG,cAAJ;;AACA,YAAI;AACAA,UAAAA,cAAc,GAAGrC,IAAI,CAACmC,YAAL,CAAkBlC,IAAI,CAAC8B,IAAL,CAAUC,eAAV,EAA2B,gBAA3B,CAAlB,CAAjB;AACH,SAFD,CAGA,OAAOM,EAAP,EAAW;AACPD,UAAAA,cAAc,GAAG,EAAjB;AACH;;AACD,YAAME,oBAAoB,GAAGtC,IAAI,CAACuC,QAAL,CAAcR,eAAd,EAA+B,KAAKzB,YAApC,CAA7B;AACA,YAAMkC,YAAY,GAAGzC,IAAI,CAACmC,YAAL,CAAkB,KAAK5B,YAAvB,CAArB,CAlBA,CAmBA;;AACA,YAAMmC,OAAO,GAAG5C,QAAQ,CAAC6C,UAAT,CAAoB,QAApB,EACXC,MADW,CACJX,QADI,EAEXW,MAFW,CAEJV,QAFI,EAGXU,MAHW,CAGJP,cAHI,EAIXO,MAJW,CAIJH,YAJI,EAKXG,MALW,CAKJL,oBALI,EAMXM,MANW,CAMJ,KANI,CAAhB,CApBA,CA2BA;AACA;;AACAhB,QAAAA,eAAe,GAAG5B,IAAI,CAAC8B,IAAL,CAAUD,eAAV,EAA2BY,OAAO,GAAG,OAArC,CAAlB,CA7BA,CA8BA;;AACA,YAAI1C,IAAI,CAAC8C,UAAL,CAAgBjB,eAAhB,CAAJ,EAAsC;AAClCD,UAAAA,cAAc,GAAG,IAAjB;AACH;AACJ,OAlCD,CAmCA,OAAOmB,EAAP,EAAW,CACP;AACH;;AACD,UAAInB,cAAJ,EAAoB;AAChB;AACH;;AACD,UAAMoB,SAAS,GAAG,uBAAlB;AACA9C,MAAAA,WAAW,CAAC+C,IAAZ,CAAiBD,SAAjB,EA3DM,CA4DN;AACA;AACA;AACA;AACA;;AACA,kCAA0BnD,eAAe,CAACqD,SAAhB,CAA0B5B,OAAO,CAAC6B,QAAlC,GACtBvD,OAAO,CAACwD,OAAR,CAAgB,yCAAhB,CADsB,EAEtB,UAFsB,EAGtB,KAAKtC,qBAHiB,EAItB,cAJsB,4BAKnB,KAAKX,oBALc,IAMtB,cANsB,EAOtB,2BAPsB,EAQtB,SARsB,EAStB,YATsB,EAUtB,KAAKI,YAViB,EAWtB,4BAXsB,IAYvB;AACC8C,QAAAA,KAAK,EAAE,CAAC,SAAD,EAAY/B,OAAO,CAACgC,MAApB,EAA4BhC,OAAO,CAACgC,MAApC;AADR,OAZuB,CAA1B;AAAA,UAAQC,MAAR,yBAAQA,MAAR;AAAA,UAAgBC,KAAhB,yBAAgBA,KAAhB;;AAeA,UAAID,MAAM,KAAK,CAAf,EAAkB;AACd,YAAME,YAAY,GAAG,CAACD,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAK,KAAK,CAAjC,GAAqC,KAAK,CAA1C,GAA8CA,KAAK,CAACE,OAArD,KAAiE,EAAtF;AACA,cAAM,IAAIC,KAAJ,CAAUF,YAAY,wBAAiBA,YAAY,GAAG,aAAH,GAAmB,EAAhD,MAAtB,CAAN;AACH;;AACDvD,MAAAA,WAAW,CAAC0D,OAAZ,CAAoBZ,SAApB,EApFM,CAqFN;;AACA,UAAInB,eAAJ,EAAqB;AACjB,YAAI;AACA,cAAI,CAAC7B,IAAI,CAAC8C,UAAL,CAAgBhB,eAAhB,CAAL,EAAuC;AACnC9B,YAAAA,IAAI,CAAC6D,SAAL,CAAe/B,eAAf,EAAgC;AAAEgC,cAAAA,SAAS,EAAE;AAAb,aAAhC;AACH;;AACD9D,UAAAA,IAAI,CAAC+D,aAAL,CAAmBlC,eAAnB,EAAoC,EAApC;AACH,SALD,CAMA,OAAOmC,EAAP,EAAW,CACP;AACH;AACJ;AACJ;AACD;;;;WACA,uBAAcC,UAAd,EAA0BC,cAA1B,EAA0C;AACtC,UAAMC,gBAAgB,GAAGD,cAAc,CAACC,gBAAxC;;AACA,UAAI,CAACA,gBAAD,IAAqBF,UAAU,CAACG,UAAX,CAAsB,GAAtB,CAArB,IACG,KAAK1D,iBAAL,CAAuB2D,GAAvB,CAA2BF,gBAA3B,CADP,EACqD;AACjD;AACA;AACH;;AACD,UAAMG,eAAe,GAAG,KAAK5C,iBAAL,CAAuBuC,UAAvB,EAAmCE,gBAAnC,CAAxB,CAPsC,CAQtC;AACA;;AACA,UAAI,CAACG,eAAD,IAAoB3C,cAAc,CAAC2C,eAAD,CAAtC,EAAyD;AACrD;AACA,aAAK5D,iBAAL,CAAuB6D,GAAvB,CAA2BJ,gBAA3B;;AACA;AACH;;AACD,UAAMnB,SAAS,sDAA+CiB,UAA/C,CAAf;AACA/D,MAAAA,WAAW,CAAC+C,IAAZ,CAAiBD,SAAjB;AACArD,MAAAA,MAAM,CAAC2B,OAAP,CAAe;AACXhB,QAAAA,QAAQ,EAAE,KAAKQ,qBADJ;AAEX0D,QAAAA,oBAAoB,EAAEvE,IAAI,CAACwE,OAAL,CAAaH,eAAb,CAFX;AAGXnE,QAAAA,oBAAoB,EAAE,KAAKA,oBAHhB;AAIXuE,QAAAA,iBAAiB,EAAE,KAJR;AAKXC,QAAAA,0BAA0B,EAAE,IALjB;AAMXC,QAAAA,MAAM,EAAE,KAAKhE,OANF;AAOXL,QAAAA,YAAY,EAAE,KAAKA;AAPR,OAAf;AASAL,MAAAA,WAAW,CAAC0D,OAAZ,CAAoBZ,SAApB,EA1BsC,CA2BtC;AACA;;AACA,UAAI,KAAKxC,eAAL,CAAqBqE,KAAzB,EAAgC;AAC5B;AACA,aAAKrE,eAAL,CAAqBqE,KAArB,CAA2BP,eAA3B;AACH;;AACD,WAAK5D,iBAAL,CAAuB6D,GAAvB,CAA2BJ,gBAA3B;AACH;;;WACD,oBAAWW,QAAX,EAAqB;AACjB,WAAKpE,iBAAL,CAAuBqE,MAAvB,CAA8BD,QAA9B;AACH;AACD;AACJ;AACA;;;;WACI,2BAAkBb,UAAlB,EAA8BE,gBAA9B,EAAgD;AAC5C,UAAI;AACA,YAAMa,YAAY,GAAG,KAAKhE,SAAL,CAAeiE,WAAf,CAA2B,EAA3B,EAA+Bd,gBAA/B,YAAoDF,UAApD,mBAArB;;AACA,eAAOe,YAAY,IAAIE,SAAvB;AACH,OAHD,CAIA,OAAO9C,EAAP,EAAW;AACP;AACA;AACA,YAAMkC,eAAe,GAAGrE,IAAI,CAACmD,OAAL,CAAae,gBAAb,EAA+B,iBAA/B,CAAxB;AACA,eAAOnE,IAAI,CAAC8C,UAAL,CAAgBwB,eAAhB,IAAmCA,eAAnC,GAAqDY,SAA5D;AACH;AACJ;;;WACD,kCAAyBC,UAAzB,EAAqC;AACjC,UAAIC,OAAO,GAAGD,UAAd;;AACA,aAAOlF,IAAI,CAACwE,OAAL,CAAaW,OAAb,MAA0BA,OAAjC,EAA0C;AACtC,YAAMC,QAAQ,GAAGpF,IAAI,CAAC8B,IAAL,CAAUqD,OAAV,EAAmB,cAAnB,CAAjB;;AACA,YAAIpF,IAAI,CAAC8C,UAAL,CAAgBuC,QAAhB,CAAJ,EAA+B;AAC3B,iBAAOA,QAAP;AACH;;AACDD,QAAAA,OAAO,GAAGnF,IAAI,CAACwE,OAAL,CAAaW,OAAb,CAAV;AACH;;AACD,YAAM,IAAIzB,KAAJ,+CAAN;AACH;;;;;;AAELnE,OAAO,CAACE,aAAR,GAAwBA,aAAxB;;IACMmB,U;AACF,sBAAYT,mBAAZ,EAAiCC,iBAAjC,EAAoD;AAAA;;AAChD,SAAKD,mBAAL,GAA2BA,mBAA3B;AACA,SAAKC,iBAAL,GAAyBA,iBAAzB;AACA,SAAKiF,KAAL,GAAa3F,MAAM,CAAC4F,QAAP,CAAgBC,IAA7B;AACH;;;;WACD,iBAAgB,CAAG;;;WACnB,gBAAc;AAAA,wCAANC,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACV;AACAnE,MAAAA,OAAO,CAACgC,MAAR,CAAeoC,KAAf,aAA0BD,IAAI,CAAC1D,IAAL,CAAU,GAAV,CAA1B;AACH;;;WACD,gBAAc;AAAA,yCAAN0D,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACV,WAAKrF,mBAAL,CAAyBuF,IAAzB,CAA8BF,IAAI,CAAC1D,IAAL,CAAU,GAAV,CAA9B;AACH;;;WACD,iBAAe;AAAA,yCAAN0D,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACX,WAAKpF,iBAAL,CAAuBsF,IAAvB,CAA4B,IAAIhC,KAAJ,CAAU8B,IAAI,CAAC1D,IAAL,CAAU,GAAV,CAAV,CAA5B;AACH;;;;;;AAEL,SAASJ,cAAT,CAAwBmD,QAAxB,EAAkC;AAC9B,MAAI;AACA9E,IAAAA,IAAI,CAAC4F,UAAL,CAAgBd,QAAhB,EAA0B9E,IAAI,CAAC6F,SAAL,CAAeC,IAAzC;AACA,WAAO,KAAP;AACH,GAHD,CAIA,OAAO1D,EAAP,EAAW;AACP,WAAO,IAAP;AACH;AACJ","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NgccProcessor = void 0;\nconst ngcc_1 = require(\"@angular/compiler-cli/ngcc\");\nconst child_process_1 = require(\"child_process\");\nconst crypto_1 = require(\"crypto\");\nconst enhanced_resolve_1 = require(\"enhanced-resolve\");\nconst fs_1 = require(\"fs\");\nconst path = require(\"path\");\nconst benchmark_1 = require(\"./benchmark\");\n// We cannot create a plugin for this, because NGTSC requires addition type\n// information which ngcc creates when processing a package which was compiled with NGC.\n// Example of such errors:\n// ERROR in node_modules/@angular/platform-browser/platform-browser.d.ts(42,22):\n// error TS-996002: Appears in the NgModule.imports of AppModule,\n// but could not be resolved to an NgModule class\n// We now transform a package and it's typings when NGTSC is resolving a module.\nclass NgccProcessor {\n    constructor(propertiesToConsider, compilationWarnings, compilationErrors, basePath, tsConfigPath, inputFileSystem, symlinks) {\n        this.propertiesToConsider = propertiesToConsider;\n        this.compilationWarnings = compilationWarnings;\n        this.compilationErrors = compilationErrors;\n        this.basePath = basePath;\n        this.tsConfigPath = tsConfigPath;\n        this.inputFileSystem = inputFileSystem;\n        this.symlinks = symlinks;\n        this._processedModules = new Set();\n        this._logger = new NgccLogger(this.compilationWarnings, this.compilationErrors);\n        this._nodeModulesDirectory = this.findNodeModulesDirectory(this.basePath);\n        this._resolver = enhanced_resolve_1.ResolverFactory.createResolver({\n            // NOTE: @types/webpack InputFileSystem is missing some methods\n            // tslint:disable-next-line: no-any\n            fileSystem: this.inputFileSystem,\n            extensions: ['.json'],\n            useSyncFileSystemCalls: true,\n            symlinks,\n        });\n    }\n    /** Process the entire node modules tree. */\n    process() {\n        // Under Bazel when running in sandbox mode parts of the filesystem is read-only.\n        if (process.env.BAZEL_TARGET) {\n            return;\n        }\n        // Skip if node_modules are read-only\n        const corePackage = this.tryResolvePackage('@angular/core', this._nodeModulesDirectory);\n        if (corePackage && isReadOnlyFile(corePackage)) {\n            return;\n        }\n        // Perform a ngcc run check to determine if an initial execution is required.\n        // If a run hash file exists that matches the current package manager lock file and the\n        // project's tsconfig, then an initial ngcc run has already been performed.\n        let skipProcessing = false;\n        let runHashFilePath;\n        const runHashBasePath = path.join(this._nodeModulesDirectory, '.cli-ngcc');\n        const projectBasePath = path.join(this._nodeModulesDirectory, '..');\n        try {\n            let lockData;\n            let lockFile = 'yarn.lock';\n            try {\n                lockData = fs_1.readFileSync(path.join(projectBasePath, lockFile));\n            }\n            catch (_a) {\n                lockFile = 'package-lock.json';\n                lockData = fs_1.readFileSync(path.join(projectBasePath, lockFile));\n            }\n            let ngccConfigData;\n            try {\n                ngccConfigData = fs_1.readFileSync(path.join(projectBasePath, 'ngcc.config.js'));\n            }\n            catch (_b) {\n                ngccConfigData = '';\n            }\n            const relativeTsconfigPath = path.relative(projectBasePath, this.tsConfigPath);\n            const tsconfigData = fs_1.readFileSync(this.tsConfigPath);\n            // Generate a hash that represents the state of the package lock file and used tsconfig\n            const runHash = crypto_1.createHash('sha256')\n                .update(lockData)\n                .update(lockFile)\n                .update(ngccConfigData)\n                .update(tsconfigData)\n                .update(relativeTsconfigPath)\n                .digest('hex');\n            // The hash is used directly in the file name to mitigate potential read/write race\n            // conditions as well as to only require a file existence check\n            runHashFilePath = path.join(runHashBasePath, runHash + '.lock');\n            // If the run hash lock file exists, then ngcc was already run against this project state\n            if (fs_1.existsSync(runHashFilePath)) {\n                skipProcessing = true;\n            }\n        }\n        catch (_c) {\n            // Any error means an ngcc execution is needed\n        }\n        if (skipProcessing) {\n            return;\n        }\n        const timeLabel = 'NgccProcessor.process';\n        benchmark_1.time(timeLabel);\n        // We spawn instead of using the API because:\n        // - NGCC Async uses clustering which is problematic when used via the API which means\n        // that we cannot setup multiple cluster masters with different options.\n        // - We will not be able to have concurrent builds otherwise Ex: App-Shell,\n        // as NGCC will create a lock file for both builds and it will cause builds to fails.\n        const { status, error } = child_process_1.spawnSync(process.execPath, [\n            require.resolve('@angular/compiler-cli/ngcc/main-ngcc.js'),\n            '--source',\n            this._nodeModulesDirectory,\n            '--properties',\n            ...this.propertiesToConsider,\n            '--first-only',\n            '--create-ivy-entry-points',\n            '--async',\n            '--tsconfig',\n            this.tsConfigPath,\n            '--use-program-dependencies',\n        ], {\n            stdio: ['inherit', process.stderr, process.stderr],\n        });\n        if (status !== 0) {\n            const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || '';\n            throw new Error(errorMessage + `NGCC failed${errorMessage ? ', see above' : ''}.`);\n        }\n        benchmark_1.timeEnd(timeLabel);\n        // ngcc was successful so if a run hash was generated, write it for next time\n        if (runHashFilePath) {\n            try {\n                if (!fs_1.existsSync(runHashBasePath)) {\n                    fs_1.mkdirSync(runHashBasePath, { recursive: true });\n                }\n                fs_1.writeFileSync(runHashFilePath, '');\n            }\n            catch (_d) {\n                // Errors are non-fatal\n            }\n        }\n    }\n    /** Process a module and it's depedencies. */\n    processModule(moduleName, resolvedModule) {\n        const resolvedFileName = resolvedModule.resolvedFileName;\n        if (!resolvedFileName || moduleName.startsWith('.')\n            || this._processedModules.has(resolvedFileName)) {\n            // Skip when module is unknown, relative or NGCC compiler is not found or already processed.\n            return;\n        }\n        const packageJsonPath = this.tryResolvePackage(moduleName, resolvedFileName);\n        // If the package.json is read only we should skip calling NGCC.\n        // With Bazel when running under sandbox the filesystem is read-only.\n        if (!packageJsonPath || isReadOnlyFile(packageJsonPath)) {\n            // add it to processed so the second time round we skip this.\n            this._processedModules.add(resolvedFileName);\n            return;\n        }\n        const timeLabel = `NgccProcessor.processModule.ngcc.process+${moduleName}`;\n        benchmark_1.time(timeLabel);\n        ngcc_1.process({\n            basePath: this._nodeModulesDirectory,\n            targetEntryPointPath: path.dirname(packageJsonPath),\n            propertiesToConsider: this.propertiesToConsider,\n            compileAllFormats: false,\n            createNewEntryPointFormats: true,\n            logger: this._logger,\n            tsConfigPath: this.tsConfigPath,\n        });\n        benchmark_1.timeEnd(timeLabel);\n        // Purge this file from cache, since NGCC add new mainFields. Ex: module_ivy_ngcc\n        // which are unknown in the cached file.\n        if (this.inputFileSystem.purge) {\n            // tslint:disable-next-line: no-any\n            this.inputFileSystem.purge(packageJsonPath);\n        }\n        this._processedModules.add(resolvedFileName);\n    }\n    invalidate(fileName) {\n        this._processedModules.delete(fileName);\n    }\n    /**\n     * Try resolve a package.json file from the resolved .d.ts file.\n     */\n    tryResolvePackage(moduleName, resolvedFileName) {\n        try {\n            const resolvedPath = this._resolver.resolveSync({}, resolvedFileName, `${moduleName}/package.json`);\n            return resolvedPath || undefined;\n        }\n        catch (_a) {\n            // Ex: @angular/compiler/src/i18n/i18n_ast/package.json\n            // or local libraries which don't reside in node_modules\n            const packageJsonPath = path.resolve(resolvedFileName, '../package.json');\n            return fs_1.existsSync(packageJsonPath) ? packageJsonPath : undefined;\n        }\n    }\n    findNodeModulesDirectory(startPoint) {\n        let current = startPoint;\n        while (path.dirname(current) !== current) {\n            const nodePath = path.join(current, 'node_modules');\n            if (fs_1.existsSync(nodePath)) {\n                return nodePath;\n            }\n            current = path.dirname(current);\n        }\n        throw new Error(`Cannot locate the 'node_modules' directory.`);\n    }\n}\nexports.NgccProcessor = NgccProcessor;\nclass NgccLogger {\n    constructor(compilationWarnings, compilationErrors) {\n        this.compilationWarnings = compilationWarnings;\n        this.compilationErrors = compilationErrors;\n        this.level = ngcc_1.LogLevel.info;\n    }\n    debug(..._args) { }\n    info(...args) {\n        // Log to stderr because it's a progress-like info message.\n        process.stderr.write(`\\n${args.join(' ')}\\n`);\n    }\n    warn(...args) {\n        this.compilationWarnings.push(args.join(' '));\n    }\n    error(...args) {\n        this.compilationErrors.push(new Error(args.join(' ')));\n    }\n}\nfunction isReadOnlyFile(fileName) {\n    try {\n        fs_1.accessSync(fileName, fs_1.constants.W_OK);\n        return false;\n    }\n    catch (_a) {\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}