{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/api/context\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/api/context.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseError, ParseSourceFile, R3TargetBinder, SchemaMetadata, TmplAstNode} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {TemplateSourceMapping, TypeCheckableDirectiveMeta} from './api';\n\n/**\n * A currently pending type checking operation, into which templates for type-checking can be\n * registered.\n */\nexport interface TypeCheckContext {\n  /**\n   * Register a template to potentially be type-checked.\n   *\n   * Templates registered via `addTemplate` are available for checking, but might be skipped if\n   * checking of that component is not required. This can happen for a few reasons, including if\n   * the component was previously checked and the prior results are still valid.\n   *\n   * @param ref a `Reference` to the component class which yielded this template.\n   * @param binder an `R3TargetBinder` which encapsulates the scope of this template, including all\n   * available directives.\n   * @param template the original template AST of this component.\n   * @param pipes a `Map` of pipes available within the scope of this template.\n   * @param schemas any schemas which apply to this template.\n   * @param sourceMapping a `TemplateSourceMapping` instance which describes the origin of the\n   * template text described by the AST.\n   * @param file the `ParseSourceFile` associated with the template.\n   * @param parseErrors the `ParseError`'s associated with the template.\n   */\n  addTemplate(\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      binder: R3TargetBinder<TypeCheckableDirectiveMeta>, template: TmplAstNode[],\n      pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,\n      schemas: SchemaMetadata[], sourceMapping: TemplateSourceMapping, file: ParseSourceFile,\n      parseErrors: ParseError[]|null): void;\n}\n\n/**\n * Interface to trigger generation of type-checking code for a program given a new\n * `TypeCheckContext`.\n */\nexport interface ProgramTypeCheckAdapter {\n  typeCheck(sf: ts.SourceFile, ctx: TypeCheckContext): void;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}