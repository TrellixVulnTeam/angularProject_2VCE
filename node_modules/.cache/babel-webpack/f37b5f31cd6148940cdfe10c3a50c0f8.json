{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/expression_parser/parser\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/chars\", \"@angular/compiler/src/ml_parser/interpolation_config\", \"@angular/compiler/src/expression_parser/ast\", \"@angular/compiler/src/expression_parser/lexer\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports._ParseAST = exports.IvyParser = exports.Parser = exports.TemplateBindingParseResult = exports.SplitInterpolation = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var chars = require(\"@angular/compiler/src/chars\");\n\n  var interpolation_config_1 = require(\"@angular/compiler/src/ml_parser/interpolation_config\");\n\n  var ast_1 = require(\"@angular/compiler/src/expression_parser/ast\");\n\n  var lexer_1 = require(\"@angular/compiler/src/expression_parser/lexer\");\n\n  var SplitInterpolation =\n  /** @class */\n  function () {\n    function SplitInterpolation(strings, expressions, offsets) {\n      this.strings = strings;\n      this.expressions = expressions;\n      this.offsets = offsets;\n    }\n\n    return SplitInterpolation;\n  }();\n\n  exports.SplitInterpolation = SplitInterpolation;\n\n  var TemplateBindingParseResult =\n  /** @class */\n  function () {\n    function TemplateBindingParseResult(templateBindings, warnings, errors) {\n      this.templateBindings = templateBindings;\n      this.warnings = warnings;\n      this.errors = errors;\n    }\n\n    return TemplateBindingParseResult;\n  }();\n\n  exports.TemplateBindingParseResult = TemplateBindingParseResult;\n\n  var Parser =\n  /** @class */\n  function () {\n    function Parser(_lexer) {\n      this._lexer = _lexer;\n      this.errors = [];\n      this.simpleExpressionChecker = SimpleExpressionChecker;\n    }\n\n    Parser.prototype.parseAction = function (input, location, absoluteOffset, interpolationConfig) {\n      if (interpolationConfig === void 0) {\n        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;\n      }\n\n      this._checkNoInterpolation(input, location, interpolationConfig);\n\n      var sourceToLex = this._stripComments(input);\n\n      var tokens = this._lexer.tokenize(this._stripComments(input));\n\n      var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length).parseChain();\n      return new ast_1.ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n\n    Parser.prototype.parseBinding = function (input, location, absoluteOffset, interpolationConfig) {\n      if (interpolationConfig === void 0) {\n        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;\n      }\n\n      var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n\n      return new ast_1.ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n\n    Parser.prototype.checkSimpleExpression = function (ast) {\n      var checker = new this.simpleExpressionChecker();\n      ast.visit(checker);\n      return checker.errors;\n    };\n\n    Parser.prototype.parseSimpleBinding = function (input, location, absoluteOffset, interpolationConfig) {\n      if (interpolationConfig === void 0) {\n        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;\n      }\n\n      var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n\n      var errors = this.checkSimpleExpression(ast);\n\n      if (errors.length > 0) {\n        this._reportError(\"Host binding expression cannot contain \" + errors.join(' '), input, location);\n      }\n\n      return new ast_1.ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    };\n\n    Parser.prototype._reportError = function (message, input, errLocation, ctxLocation) {\n      this.errors.push(new ast_1.ParserError(message, input, errLocation, ctxLocation));\n    };\n\n    Parser.prototype._parseBindingAst = function (input, location, absoluteOffset, interpolationConfig) {\n      // Quotes expressions use 3rd-party expression language. We don't want to use\n      // our lexer or parser for that, so we check for that ahead of time.\n      var quote = this._parseQuote(input, location, absoluteOffset);\n\n      if (quote != null) {\n        return quote;\n      }\n\n      this._checkNoInterpolation(input, location, interpolationConfig);\n\n      var sourceToLex = this._stripComments(input);\n\n      var tokens = this._lexer.tokenize(sourceToLex);\n\n      return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length).parseChain();\n    };\n\n    Parser.prototype._parseQuote = function (input, location, absoluteOffset) {\n      if (input == null) return null;\n      var prefixSeparatorIndex = input.indexOf(':');\n      if (prefixSeparatorIndex == -1) return null;\n      var prefix = input.substring(0, prefixSeparatorIndex).trim();\n      if (!lexer_1.isIdentifier(prefix)) return null;\n      var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n      var span = new ast_1.ParseSpan(0, input.length);\n      return new ast_1.Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);\n    };\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items\">\n     *         ^      ^ absoluteValueOffset for `templateValue`\n     *         absoluteKeyOffset for `templateKey`\n     * ```\n     * contains three bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     *\n     * This is apparent from the de-sugared template:\n     * ```\n     *   <ng-template ngFor let-item [ngForOf]=\"items\">\n     * ```\n     *\n     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n     * @param templateValue RHS of the microsyntax attribute\n     * @param templateUrl template filename if it's external, component filename if it's inline\n     * @param absoluteKeyOffset start of the `templateKey`\n     * @param absoluteValueOffset start of the `templateValue`\n     */\n\n\n    Parser.prototype.parseTemplateBindings = function (templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {\n      var tokens = this._lexer.tokenize(templateValue);\n\n      var parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false\n      /* parseAction */\n      , this.errors, 0\n      /* relative offset */\n      );\n      return parser.parseTemplateBindings({\n        source: templateKey,\n        span: new ast_1.AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)\n      });\n    };\n\n    Parser.prototype.parseInterpolation = function (input, location, absoluteOffset, interpolationConfig) {\n      if (interpolationConfig === void 0) {\n        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;\n      }\n\n      var _a = this.splitInterpolation(input, location, interpolationConfig),\n          strings = _a.strings,\n          expressions = _a.expressions,\n          offsets = _a.offsets;\n\n      if (expressions.length === 0) return null;\n      var expressionNodes = [];\n\n      for (var i = 0; i < expressions.length; ++i) {\n        var expressionText = expressions[i].text;\n\n        var sourceToLex = this._stripComments(expressionText);\n\n        var tokens = this._lexer.tokenize(sourceToLex);\n\n        var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, offsets[i] + (expressionText.length - sourceToLex.length)).parseChain();\n        expressionNodes.push(ast);\n      }\n\n      return this.createInterpolationAst(strings.map(function (s) {\n        return s.text;\n      }), expressionNodes, input, location, absoluteOffset);\n    };\n    /**\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n     * This is used for parsing the switch expression in ICUs.\n     */\n\n\n    Parser.prototype.parseInterpolationExpression = function (expression, location, absoluteOffset) {\n      var sourceToLex = this._stripComments(expression);\n\n      var tokens = this._lexer.tokenize(sourceToLex);\n\n      var ast = new _ParseAST(expression, location, absoluteOffset, tokens, sourceToLex.length,\n      /* parseAction */\n      false, this.errors, 0).parseChain();\n      var strings = ['', '']; // The prefix and suffix strings are both empty\n\n      return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n    };\n\n    Parser.prototype.createInterpolationAst = function (strings, expressions, input, location, absoluteOffset) {\n      var span = new ast_1.ParseSpan(0, input.length);\n      var interpolation = new ast_1.Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n      return new ast_1.ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n    };\n    /**\n     * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n     * the string.\n     * Returns `null` if there are no interpolations, otherwise a\n     * `SplitInterpolation` with splits that look like\n     *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n     */\n\n\n    Parser.prototype.splitInterpolation = function (input, location, interpolationConfig) {\n      if (interpolationConfig === void 0) {\n        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;\n      }\n\n      var strings = [];\n      var expressions = [];\n      var offsets = [];\n      var i = 0;\n      var atInterpolation = false;\n      var extendLastString = false;\n      var interpStart = interpolationConfig.start,\n          interpEnd = interpolationConfig.end;\n\n      while (i < input.length) {\n        if (!atInterpolation) {\n          // parse until starting {{\n          var start = i;\n          i = input.indexOf(interpStart, i);\n\n          if (i === -1) {\n            i = input.length;\n          }\n\n          var text = input.substring(start, i);\n          strings.push({\n            text: text,\n            start: start,\n            end: i\n          });\n          atInterpolation = true;\n        } else {\n          // parse from starting {{ to ending }} while ignoring content inside quotes.\n          var fullStart = i;\n          var exprStart = fullStart + interpStart.length;\n\n          var exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n\n          if (exprEnd === -1) {\n            // Could not find the end of the interpolation; do not parse an expression.\n            // Instead we should extend the content on the last raw string.\n            atInterpolation = false;\n            extendLastString = true;\n            break;\n          }\n\n          var fullEnd = exprEnd + interpEnd.length;\n          var text = input.substring(exprStart, exprEnd);\n\n          if (text.trim().length === 0) {\n            this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \" + i + \" in\", location);\n          }\n\n          expressions.push({\n            text: text,\n            start: fullStart,\n            end: fullEnd\n          });\n          offsets.push(exprStart);\n          i = fullEnd;\n          atInterpolation = false;\n        }\n      }\n\n      if (!atInterpolation) {\n        // If we are now at a text section, add the remaining content as a raw string.\n        if (extendLastString) {\n          var piece = strings[strings.length - 1];\n          piece.text += input.substring(i);\n          piece.end = input.length;\n        } else {\n          strings.push({\n            text: input.substring(i),\n            start: i,\n            end: input.length\n          });\n        }\n      }\n\n      return new SplitInterpolation(strings, expressions, offsets);\n    };\n\n    Parser.prototype.wrapLiteralPrimitive = function (input, location, absoluteOffset) {\n      var span = new ast_1.ParseSpan(0, input == null ? 0 : input.length);\n      return new ast_1.ASTWithSource(new ast_1.LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);\n    };\n\n    Parser.prototype._stripComments = function (input) {\n      var i = this._commentStart(input);\n\n      return i != null ? input.substring(0, i).trim() : input;\n    };\n\n    Parser.prototype._commentStart = function (input) {\n      var outerQuote = null;\n\n      for (var i = 0; i < input.length - 1; i++) {\n        var char = input.charCodeAt(i);\n        var nextChar = input.charCodeAt(i + 1);\n        if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n        if (outerQuote === char) {\n          outerQuote = null;\n        } else if (outerQuote == null && lexer_1.isQuote(char)) {\n          outerQuote = char;\n        }\n      }\n\n      return null;\n    };\n\n    Parser.prototype._checkNoInterpolation = function (input, location, _a) {\n      var e_1, _b;\n\n      var start = _a.start,\n          end = _a.end;\n      var startIndex = -1;\n      var endIndex = -1;\n\n      try {\n        for (var _c = tslib_1.__values(this._forEachUnquotedChar(input, 0)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var charIndex = _d.value;\n\n          if (startIndex === -1) {\n            if (input.startsWith(start)) {\n              startIndex = charIndex;\n            }\n          } else {\n            endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n\n            if (endIndex > -1) {\n              break;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      if (startIndex > -1 && endIndex > -1) {\n        this._reportError(\"Got interpolation (\" + start + end + \") where expression was expected\", input, \"at column \" + startIndex + \" in\", location);\n      }\n    };\n    /**\n     * Finds the index of the end of an interpolation expression\n     * while ignoring comments and quoted content.\n     */\n\n\n    Parser.prototype._getInterpolationEndIndex = function (input, expressionEnd, start) {\n      var e_2, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this._forEachUnquotedChar(input, start)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var charIndex = _c.value;\n\n          if (input.startsWith(expressionEnd, charIndex)) {\n            return charIndex;\n          } // Nothing else in the expression matters after we've\n          // hit a comment so look directly for the end token.\n\n\n          if (input.startsWith('//', charIndex)) {\n            return input.indexOf(expressionEnd, charIndex);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return -1;\n    };\n    /**\n     * Generator used to iterate over the character indexes of a string that are outside of quotes.\n     * @param input String to loop through.\n     * @param start Index within the string at which to start.\n     */\n\n\n    Parser.prototype._forEachUnquotedChar = function (input, start) {\n      var currentQuote, escapeCount, i, char;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            currentQuote = null;\n            escapeCount = 0;\n            i = start;\n            _a.label = 1;\n\n          case 1:\n            if (!(i < input.length)) return [3\n            /*break*/\n            , 6];\n            char = input[i];\n            if (!(lexer_1.isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0)) return [3\n            /*break*/\n            , 2];\n            currentQuote = currentQuote === null ? char : null;\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            if (!(currentQuote === null)) return [3\n            /*break*/\n            , 4];\n            return [4\n            /*yield*/\n            , i];\n\n          case 3:\n            _a.sent();\n\n            _a.label = 4;\n\n          case 4:\n            escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n            _a.label = 5;\n\n          case 5:\n            i++;\n            return [3\n            /*break*/\n            , 1];\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    };\n\n    return Parser;\n  }();\n\n  exports.Parser = Parser;\n\n  var IvyParser =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(IvyParser, _super);\n\n    function IvyParser() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.simpleExpressionChecker = IvySimpleExpressionChecker;\n      return _this;\n    }\n\n    return IvyParser;\n  }(Parser);\n\n  exports.IvyParser = IvyParser;\n  /** Describes a stateful context an expression parser is in. */\n\n  var ParseContextFlags;\n\n  (function (ParseContextFlags) {\n    ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\n    /**\n     * A Writable context is one in which a value may be written to an lvalue.\n     * For example, after we see a property access, we may expect a write to the\n     * property via the \"=\" operator.\n     *   prop\n     *        ^ possible \"=\" after\n     */\n\n    ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\n  })(ParseContextFlags || (ParseContextFlags = {}));\n\n  var _ParseAST =\n  /** @class */\n  function () {\n    function _ParseAST(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {\n      this.input = input;\n      this.location = location;\n      this.absoluteOffset = absoluteOffset;\n      this.tokens = tokens;\n      this.inputLength = inputLength;\n      this.parseAction = parseAction;\n      this.errors = errors;\n      this.offset = offset;\n      this.rparensExpected = 0;\n      this.rbracketsExpected = 0;\n      this.rbracesExpected = 0;\n      this.context = ParseContextFlags.None; // Cache of expression start and input indeces to the absolute source span they map to, used to\n      // prevent creating superfluous source spans in `sourceSpan`.\n      // A serial of the expression start and input index is used for mapping because both are stateful\n      // and may change for subsequent expressions visited by the parser.\n\n      this.sourceSpanCache = new Map();\n      this.index = 0;\n    }\n\n    _ParseAST.prototype.peek = function (offset) {\n      var i = this.index + offset;\n      return i < this.tokens.length ? this.tokens[i] : lexer_1.EOF;\n    };\n\n    Object.defineProperty(_ParseAST.prototype, \"next\", {\n      get: function get() {\n        return this.peek(0);\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"atEOF\", {\n      /** Whether all the parser input has been processed. */\n      get: function get() {\n        return this.index >= this.tokens.length;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"inputIndex\", {\n      /**\n       * Index of the next token to be processed, or the end of the last token if all have been\n       * processed.\n       */\n      get: function get() {\n        return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"currentEndIndex\", {\n      /**\n       * End index of the last processed token, or the start of the first token if none have been\n       * processed.\n       */\n      get: function get() {\n        if (this.index > 0) {\n          var curToken = this.peek(-1);\n          return curToken.end + this.offset;\n        } // No tokens have been processed yet; return the next token's start or the length of the input\n        // if there is no token.\n\n\n        if (this.tokens.length === 0) {\n          return this.inputLength + this.offset;\n        }\n\n        return this.next.index + this.offset;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(_ParseAST.prototype, \"currentAbsoluteOffset\", {\n      /**\n       * Returns the absolute offset of the start of the current token.\n       */\n      get: function get() {\n        return this.absoluteOffset + this.inputIndex;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    /**\n     * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n     * provided).\n     *\n     * @param start Position from which the `ParseSpan` will start.\n     * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n     *     natural ending index)\n     */\n\n    _ParseAST.prototype.span = function (start, artificialEndIndex) {\n      var endIndex = this.currentEndIndex;\n\n      if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n        endIndex = artificialEndIndex;\n      }\n\n      return new ast_1.ParseSpan(start, endIndex);\n    };\n\n    _ParseAST.prototype.sourceSpan = function (start, artificialEndIndex) {\n      var serial = start + \"@\" + this.inputIndex + \":\" + artificialEndIndex;\n\n      if (!this.sourceSpanCache.has(serial)) {\n        this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n      }\n\n      return this.sourceSpanCache.get(serial);\n    };\n\n    _ParseAST.prototype.advance = function () {\n      this.index++;\n    };\n    /**\n     * Executes a callback in the provided context.\n     */\n\n\n    _ParseAST.prototype.withContext = function (context, cb) {\n      this.context |= context;\n      var ret = cb();\n      this.context ^= context;\n      return ret;\n    };\n\n    _ParseAST.prototype.consumeOptionalCharacter = function (code) {\n      if (this.next.isCharacter(code)) {\n        this.advance();\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    _ParseAST.prototype.peekKeywordLet = function () {\n      return this.next.isKeywordLet();\n    };\n\n    _ParseAST.prototype.peekKeywordAs = function () {\n      return this.next.isKeywordAs();\n    };\n    /**\n     * Consumes an expected character, otherwise emits an error about the missing expected character\n     * and skips over the token stream until reaching a recoverable point.\n     *\n     * See `this.error` and `this.skip` for more details.\n     */\n\n\n    _ParseAST.prototype.expectCharacter = function (code) {\n      if (this.consumeOptionalCharacter(code)) return;\n      this.error(\"Missing expected \" + String.fromCharCode(code));\n    };\n\n    _ParseAST.prototype.consumeOptionalOperator = function (op) {\n      if (this.next.isOperator(op)) {\n        this.advance();\n        return true;\n      } else {\n        return false;\n      }\n    };\n\n    _ParseAST.prototype.expectOperator = function (operator) {\n      if (this.consumeOptionalOperator(operator)) return;\n      this.error(\"Missing expected operator \" + operator);\n    };\n\n    _ParseAST.prototype.prettyPrintToken = function (tok) {\n      return tok === lexer_1.EOF ? 'end of input' : \"token \" + tok;\n    };\n\n    _ParseAST.prototype.expectIdentifierOrKeyword = function () {\n      var n = this.next;\n\n      if (!n.isIdentifier() && !n.isKeyword()) {\n        this.error(\"Unexpected \" + this.prettyPrintToken(n) + \", expected identifier or keyword\");\n        return null;\n      }\n\n      this.advance();\n      return n.toString();\n    };\n\n    _ParseAST.prototype.expectIdentifierOrKeywordOrString = function () {\n      var n = this.next;\n\n      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n        this.error(\"Unexpected \" + this.prettyPrintToken(n) + \", expected identifier, keyword, or string\");\n        return '';\n      }\n\n      this.advance();\n      return n.toString();\n    };\n\n    _ParseAST.prototype.parseChain = function () {\n      var exprs = [];\n      var start = this.inputIndex;\n\n      while (this.index < this.tokens.length) {\n        var expr = this.parsePipe();\n        exprs.push(expr);\n\n        if (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n          if (!this.parseAction) {\n            this.error('Binding expression cannot contain chained expression');\n          }\n\n          while (this.consumeOptionalCharacter(chars.$SEMICOLON)) {} // read all semicolons\n\n        } else if (this.index < this.tokens.length) {\n          this.error(\"Unexpected token '\" + this.next + \"'\");\n        }\n      }\n\n      if (exprs.length == 0) {\n        // We have no expressions so create an empty expression that spans the entire input length\n        var artificialStart = this.offset;\n        var artificialEnd = this.offset + this.inputLength;\n        return new ast_1.EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\n      }\n\n      if (exprs.length == 1) return exprs[0];\n      return new ast_1.Chain(this.span(start), this.sourceSpan(start), exprs);\n    };\n\n    _ParseAST.prototype.parsePipe = function () {\n      var start = this.inputIndex;\n      var result = this.parseExpression();\n\n      if (this.consumeOptionalOperator('|')) {\n        if (this.parseAction) {\n          this.error('Cannot have a pipe in an action expression');\n        }\n\n        do {\n          var nameStart = this.inputIndex;\n          var nameId = this.expectIdentifierOrKeyword();\n          var nameSpan = void 0;\n          var fullSpanEnd = undefined;\n\n          if (nameId !== null) {\n            nameSpan = this.sourceSpan(nameStart);\n          } else {\n            // No valid identifier was found, so we'll assume an empty pipe name ('').\n            nameId = ''; // However, there may have been whitespace present between the pipe character and the next\n            // token in the sequence (or the end of input). We want to track this whitespace so that\n            // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n            // whitespace beyond it. Another way of thinking about this is that the zero-length name\n            // is assumed to be at the end of any whitespace beyond the pipe character.\n            //\n            // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n            // beginning of the next token, or until the end of input if the next token is EOF.\n\n            fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset; // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n            // beyond the pipe character.\n\n            nameSpan = new ast_1.ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n          }\n\n          var args = [];\n\n          while (this.consumeOptionalCharacter(chars.$COLON)) {\n            args.push(this.parseExpression()); // If there are additional expressions beyond the name, then the artificial end for the\n            // name is no longer relevant.\n          }\n\n          result = new ast_1.BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n        } while (this.consumeOptionalOperator('|'));\n      }\n\n      return result;\n    };\n\n    _ParseAST.prototype.parseExpression = function () {\n      return this.parseConditional();\n    };\n\n    _ParseAST.prototype.parseConditional = function () {\n      var start = this.inputIndex;\n      var result = this.parseLogicalOr();\n\n      if (this.consumeOptionalOperator('?')) {\n        var yes = this.parsePipe();\n        var no = void 0;\n\n        if (!this.consumeOptionalCharacter(chars.$COLON)) {\n          var end = this.inputIndex;\n          var expression = this.input.substring(start, end);\n          this.error(\"Conditional expression \" + expression + \" requires all 3 expressions\");\n          no = new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));\n        } else {\n          no = this.parsePipe();\n        }\n\n        return new ast_1.Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n      } else {\n        return result;\n      }\n    };\n\n    _ParseAST.prototype.parseLogicalOr = function () {\n      // '||'\n      var start = this.inputIndex;\n      var result = this.parseLogicalAnd();\n\n      while (this.consumeOptionalOperator('||')) {\n        var right = this.parseLogicalAnd();\n        result = new ast_1.Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n      }\n\n      return result;\n    };\n\n    _ParseAST.prototype.parseLogicalAnd = function () {\n      // '&&'\n      var start = this.inputIndex;\n      var result = this.parseEquality();\n\n      while (this.consumeOptionalOperator('&&')) {\n        var right = this.parseEquality();\n        result = new ast_1.Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n      }\n\n      return result;\n    };\n\n    _ParseAST.prototype.parseEquality = function () {\n      // '==','!=','===','!=='\n      var start = this.inputIndex;\n      var result = this.parseRelational();\n\n      while (this.next.type == lexer_1.TokenType.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '==':\n          case '===':\n          case '!=':\n          case '!==':\n            this.advance();\n            var right = this.parseRelational();\n            result = new ast_1.Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    };\n\n    _ParseAST.prototype.parseRelational = function () {\n      // '<', '>', '<=', '>='\n      var start = this.inputIndex;\n      var result = this.parseAdditive();\n\n      while (this.next.type == lexer_1.TokenType.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '<':\n          case '>':\n          case '<=':\n          case '>=':\n            this.advance();\n            var right = this.parseAdditive();\n            result = new ast_1.Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    };\n\n    _ParseAST.prototype.parseAdditive = function () {\n      // '+', '-'\n      var start = this.inputIndex;\n      var result = this.parseMultiplicative();\n\n      while (this.next.type == lexer_1.TokenType.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '+':\n          case '-':\n            this.advance();\n            var right = this.parseMultiplicative();\n            result = new ast_1.Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    };\n\n    _ParseAST.prototype.parseMultiplicative = function () {\n      // '*', '%', '/'\n      var start = this.inputIndex;\n      var result = this.parsePrefix();\n\n      while (this.next.type == lexer_1.TokenType.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '*':\n          case '%':\n          case '/':\n            this.advance();\n            var right = this.parsePrefix();\n            result = new ast_1.Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    };\n\n    _ParseAST.prototype.parsePrefix = function () {\n      if (this.next.type == lexer_1.TokenType.Operator) {\n        var start = this.inputIndex;\n        var operator = this.next.strValue;\n        var result = void 0;\n\n        switch (operator) {\n          case '+':\n            this.advance();\n            result = this.parsePrefix();\n            return ast_1.Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n\n          case '-':\n            this.advance();\n            result = this.parsePrefix();\n            return ast_1.Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n\n          case '!':\n            this.advance();\n            result = this.parsePrefix();\n            return new ast_1.PrefixNot(this.span(start), this.sourceSpan(start), result);\n        }\n      }\n\n      return this.parseCallChain();\n    };\n\n    _ParseAST.prototype.parseCallChain = function () {\n      var _this = this;\n\n      var start = this.inputIndex;\n      var result = this.parsePrimary();\n\n      while (true) {\n        if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n          result = this.parseAccessMemberOrMethodCall(result, start, false);\n        } else if (this.consumeOptionalOperator('?.')) {\n          result = this.parseAccessMemberOrMethodCall(result, start, true);\n        } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n          this.withContext(ParseContextFlags.Writable, function () {\n            _this.rbracketsExpected++;\n\n            var key = _this.parsePipe();\n\n            if (key instanceof ast_1.EmptyExpr) {\n              _this.error(\"Key access cannot be empty\");\n            }\n\n            _this.rbracketsExpected--;\n\n            _this.expectCharacter(chars.$RBRACKET);\n\n            if (_this.consumeOptionalOperator('=')) {\n              var value = _this.parseConditional();\n\n              result = new ast_1.KeyedWrite(_this.span(start), _this.sourceSpan(start), result, key, value);\n            } else {\n              result = new ast_1.KeyedRead(_this.span(start), _this.sourceSpan(start), result, key);\n            }\n          });\n        } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n          this.rparensExpected++;\n          var args = this.parseCallArguments();\n          this.rparensExpected--;\n          this.expectCharacter(chars.$RPAREN);\n          result = new ast_1.FunctionCall(this.span(start), this.sourceSpan(start), result, args);\n        } else if (this.consumeOptionalOperator('!')) {\n          result = new ast_1.NonNullAssert(this.span(start), this.sourceSpan(start), result);\n        } else {\n          return result;\n        }\n      }\n    };\n\n    _ParseAST.prototype.parsePrimary = function () {\n      var start = this.inputIndex;\n\n      if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        var result = this.parsePipe();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        return result;\n      } else if (this.next.isKeywordNull()) {\n        this.advance();\n        return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n      } else if (this.next.isKeywordUndefined()) {\n        this.advance();\n        return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n      } else if (this.next.isKeywordTrue()) {\n        this.advance();\n        return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n      } else if (this.next.isKeywordFalse()) {\n        this.advance();\n        return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n      } else if (this.next.isKeywordThis()) {\n        this.advance();\n        return new ast_1.ThisReceiver(this.span(start), this.sourceSpan(start));\n      } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        var elements = this.parseExpressionList(chars.$RBRACKET);\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        return new ast_1.LiteralArray(this.span(start), this.sourceSpan(start), elements);\n      } else if (this.next.isCharacter(chars.$LBRACE)) {\n        return this.parseLiteralMap();\n      } else if (this.next.isIdentifier()) {\n        return this.parseAccessMemberOrMethodCall(new ast_1.ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n      } else if (this.next.isNumber()) {\n        var value = this.next.toNumber();\n        this.advance();\n        return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n      } else if (this.next.isString()) {\n        var literalValue = this.next.toString();\n        this.advance();\n        return new ast_1.LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n      } else if (this.index >= this.tokens.length) {\n        this.error(\"Unexpected end of expression: \" + this.input);\n        return new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        this.error(\"Unexpected token \" + this.next);\n        return new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));\n      }\n    };\n\n    _ParseAST.prototype.parseExpressionList = function (terminator) {\n      var result = [];\n\n      do {\n        if (!this.next.isCharacter(terminator)) {\n          result.push(this.parsePipe());\n        } else {\n          break;\n        }\n      } while (this.consumeOptionalCharacter(chars.$COMMA));\n\n      return result;\n    };\n\n    _ParseAST.prototype.parseLiteralMap = function () {\n      var keys = [];\n      var values = [];\n      var start = this.inputIndex;\n      this.expectCharacter(chars.$LBRACE);\n\n      if (!this.consumeOptionalCharacter(chars.$RBRACE)) {\n        this.rbracesExpected++;\n\n        do {\n          var quoted = this.next.isString();\n          var key = this.expectIdentifierOrKeywordOrString();\n          keys.push({\n            key: key,\n            quoted: quoted\n          });\n          this.expectCharacter(chars.$COLON);\n          values.push(this.parsePipe());\n        } while (this.consumeOptionalCharacter(chars.$COMMA));\n\n        this.rbracesExpected--;\n        this.expectCharacter(chars.$RBRACE);\n      }\n\n      return new ast_1.LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n    };\n\n    _ParseAST.prototype.parseAccessMemberOrMethodCall = function (receiver, start, isSafe) {\n      var _this = this;\n\n      if (isSafe === void 0) {\n        isSafe = false;\n      }\n\n      var nameStart = this.inputIndex;\n      var id = this.withContext(ParseContextFlags.Writable, function () {\n        var _a;\n\n        var id = (_a = _this.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';\n\n        if (id.length === 0) {\n          _this.error(\"Expected identifier for property access\", receiver.span.end);\n        }\n\n        return id;\n      });\n      var nameSpan = this.sourceSpan(nameStart);\n\n      if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        var args = this.parseCallArguments();\n        this.expectCharacter(chars.$RPAREN);\n        this.rparensExpected--;\n        var span = this.span(start);\n        var sourceSpan = this.sourceSpan(start);\n        return isSafe ? new ast_1.SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args) : new ast_1.MethodCall(span, sourceSpan, nameSpan, receiver, id, args);\n      } else {\n        if (isSafe) {\n          if (this.consumeOptionalOperator('=')) {\n            this.error('The \\'?.\\' operator cannot be used in the assignment');\n            return new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));\n          } else {\n            return new ast_1.SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n          }\n        } else {\n          if (this.consumeOptionalOperator('=')) {\n            if (!this.parseAction) {\n              this.error('Bindings cannot contain assignments');\n              return new ast_1.EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n\n            var value = this.parseConditional();\n            return new ast_1.PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);\n          } else {\n            return new ast_1.PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n          }\n        }\n      }\n    };\n\n    _ParseAST.prototype.parseCallArguments = function () {\n      if (this.next.isCharacter(chars.$RPAREN)) return [];\n      var positionals = [];\n\n      do {\n        positionals.push(this.parsePipe());\n      } while (this.consumeOptionalCharacter(chars.$COMMA));\n\n      return positionals;\n    };\n    /**\n     * Parses an identifier, a keyword, a string with an optional `-` in between,\n     * and returns the string along with its absolute source span.\n     */\n\n\n    _ParseAST.prototype.expectTemplateBindingKey = function () {\n      var result = '';\n      var operatorFound = false;\n      var start = this.currentAbsoluteOffset;\n\n      do {\n        result += this.expectIdentifierOrKeywordOrString();\n        operatorFound = this.consumeOptionalOperator('-');\n\n        if (operatorFound) {\n          result += '-';\n        }\n      } while (operatorFound);\n\n      return {\n        source: result,\n        span: new ast_1.AbsoluteSourceSpan(start, start + result.length)\n      };\n    };\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n     * ```\n     * contains five bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     * 4. i -> NgForOfContext.index\n     * 5. ngForTrackBy -> func\n     *\n     * For a full description of the microsyntax grammar, see\n     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n     *\n     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n     * without the *, along with its absolute span.\n     */\n\n\n    _ParseAST.prototype.parseTemplateBindings = function (templateKey) {\n      var bindings = []; // The first binding is for the template key itself\n      // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n      // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n\n      bindings.push.apply(bindings, tslib_1.__spread(this.parseDirectiveKeywordBindings(templateKey)));\n\n      while (this.index < this.tokens.length) {\n        // If it starts with 'let', then this must be variable declaration\n        var letBinding = this.parseLetBinding();\n\n        if (letBinding) {\n          bindings.push(letBinding);\n        } else {\n          // Two possible cases here, either `value \"as\" key` or\n          // \"directive-keyword expression\". We don't know which case, but both\n          // \"value\" and \"directive-keyword\" are template binding key, so consume\n          // the key first.\n          var key = this.expectTemplateBindingKey(); // Peek at the next token, if it is \"as\" then this must be variable\n          // declaration.\n\n          var binding = this.parseAsBinding(key);\n\n          if (binding) {\n            bindings.push(binding);\n          } else {\n            // Otherwise the key must be a directive keyword, like \"of\". Transform\n            // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n            key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n            bindings.push.apply(bindings, tslib_1.__spread(this.parseDirectiveKeywordBindings(key)));\n          }\n        }\n\n        this.consumeStatementTerminator();\n      }\n\n      return new TemplateBindingParseResult(bindings, []\n      /* warnings */\n      , this.errors);\n    };\n    /**\n     * Parse a directive keyword, followed by a mandatory expression.\n     * For example, \"of items\", \"trackBy: func\".\n     * The bindings are: ngForOf -> items, ngForTrackBy -> func\n     * There could be an optional \"as\" binding that follows the expression.\n     * For example,\n     * ```\n     *   *ngFor=\"let item of items | slice:0:1 as collection\".\n     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n     *               keyword    bound target   optional 'as' binding\n     * ```\n     *\n     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n     * absolute span.\n     */\n\n\n    _ParseAST.prototype.parseDirectiveKeywordBindings = function (key) {\n      var bindings = [];\n      this.consumeOptionalCharacter(chars.$COLON); // trackBy: trackByFunction\n\n      var value = this.getDirectiveBoundTarget();\n      var spanEnd = this.currentAbsoluteOffset; // The binding could optionally be followed by \"as\". For example,\n      // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n      // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n      // 'key' in the current context now becomes the \"value\" in the next binding.\n\n      var asBinding = this.parseAsBinding(key);\n\n      if (!asBinding) {\n        this.consumeStatementTerminator();\n        spanEnd = this.currentAbsoluteOffset;\n      }\n\n      var sourceSpan = new ast_1.AbsoluteSourceSpan(key.span.start, spanEnd);\n      bindings.push(new ast_1.ExpressionBinding(sourceSpan, key, value));\n\n      if (asBinding) {\n        bindings.push(asBinding);\n      }\n\n      return bindings;\n    };\n    /**\n     * Return the expression AST for the bound target of a directive keyword\n     * binding. For example,\n     * ```\n     *   *ngIf=\"condition | pipe\"\n     *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n     *   *ngFor=\"let item of items\"\n     *                       ^^^^^ bound target for \"ngForOf\"\n     * ```\n     */\n\n\n    _ParseAST.prototype.getDirectiveBoundTarget = function () {\n      if (this.next === lexer_1.EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n        return null;\n      }\n\n      var ast = this.parsePipe(); // example: \"condition | async\"\n\n      var _a = ast.span,\n          start = _a.start,\n          end = _a.end;\n      var value = this.input.substring(start, end);\n      return new ast_1.ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n    };\n    /**\n     * Return the binding for a variable declared using `as`. Note that the order\n     * of the key-value pair in this declaration is reversed. For example,\n     * ```\n     *   *ngFor=\"let item of items; index as i\"\n     *                              ^^^^^    ^\n     *                              value    key\n     * ```\n     *\n     * @param value name of the value in the declaration, \"ngIf\" in the example\n     * above, along with its absolute span.\n     */\n\n\n    _ParseAST.prototype.parseAsBinding = function (value) {\n      if (!this.peekKeywordAs()) {\n        return null;\n      }\n\n      this.advance(); // consume the 'as' keyword\n\n      var key = this.expectTemplateBindingKey();\n      this.consumeStatementTerminator();\n      var sourceSpan = new ast_1.AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n      return new ast_1.VariableBinding(sourceSpan, key, value);\n    };\n    /**\n     * Return the binding for a variable declared using `let`. For example,\n     * ```\n     *   *ngFor=\"let item of items; let i=index;\"\n     *           ^^^^^^^^           ^^^^^^^^^^^\n     * ```\n     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n     * In the second binding, `i` is bound to `NgForOfContext.index`.\n     */\n\n\n    _ParseAST.prototype.parseLetBinding = function () {\n      if (!this.peekKeywordLet()) {\n        return null;\n      }\n\n      var spanStart = this.currentAbsoluteOffset;\n      this.advance(); // consume the 'let' keyword\n\n      var key = this.expectTemplateBindingKey();\n      var value = null;\n\n      if (this.consumeOptionalOperator('=')) {\n        value = this.expectTemplateBindingKey();\n      }\n\n      this.consumeStatementTerminator();\n      var sourceSpan = new ast_1.AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n      return new ast_1.VariableBinding(sourceSpan, key, value);\n    };\n    /**\n     * Consume the optional statement terminator: semicolon or comma.\n     */\n\n\n    _ParseAST.prototype.consumeStatementTerminator = function () {\n      this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);\n    };\n    /**\n     * Records an error and skips over the token stream until reaching a recoverable point. See\n     * `this.skip` for more details on token skipping.\n     */\n\n\n    _ParseAST.prototype.error = function (message, index) {\n      if (index === void 0) {\n        index = null;\n      }\n\n      this.errors.push(new ast_1.ParserError(message, this.input, this.locationText(index), this.location));\n      this.skip();\n    };\n\n    _ParseAST.prototype.locationText = function (index) {\n      if (index === void 0) {\n        index = null;\n      }\n\n      if (index == null) index = this.index;\n      return index < this.tokens.length ? \"at column \" + (this.tokens[index].index + 1) + \" in\" : \"at the end of the expression\";\n    };\n    /**\n     * Error recovery should skip tokens until it encounters a recovery point.\n     *\n     * The following are treated as unconditional recovery points:\n     *   - end of input\n     *   - ';' (parseChain() is always the root production, and it expects a ';')\n     *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n     *\n     * The following are conditional recovery points:\n     *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n     *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n     *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n     *       an '(' <expr> ')' production).\n     *       The recovery points of grouping symbols must be conditional as they must be skipped if\n     *       none of the calling productions are not expecting the closing token else we will never\n     *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n     *       That is, we skip a closing symbol if we are not in a grouping production.\n     *   - '=' in a `Writable` context\n     *     - In this context, we are able to recover after seeing the `=` operator, which\n     *       signals the presence of an independent rvalue expression following the `=` operator.\n     *\n     * If a production expects one of these token it increments the corresponding nesting count,\n     * and then decrements it just prior to checking if the token is in the input.\n     */\n\n\n    _ParseAST.prototype.skip = function () {\n      var n = this.next;\n\n      while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) && !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n        if (this.next.isError()) {\n          this.errors.push(new ast_1.ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n        }\n\n        this.advance();\n        n = this.next;\n      }\n    };\n\n    return _ParseAST;\n  }();\n\n  exports._ParseAST = _ParseAST;\n\n  var SimpleExpressionChecker =\n  /** @class */\n  function () {\n    function SimpleExpressionChecker() {\n      this.errors = [];\n    }\n\n    SimpleExpressionChecker.prototype.visitImplicitReceiver = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitThisReceiver = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitInterpolation = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitLiteralPrimitive = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitPropertyRead = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitPropertyWrite = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitSafePropertyRead = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitMethodCall = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitSafeMethodCall = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitFunctionCall = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitLiteralArray = function (ast, context) {\n      this.visitAll(ast.expressions, context);\n    };\n\n    SimpleExpressionChecker.prototype.visitLiteralMap = function (ast, context) {\n      this.visitAll(ast.values, context);\n    };\n\n    SimpleExpressionChecker.prototype.visitUnary = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitBinary = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitPrefixNot = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitNonNullAssert = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitConditional = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitPipe = function (ast, context) {\n      this.errors.push('pipes');\n    };\n\n    SimpleExpressionChecker.prototype.visitKeyedRead = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitKeyedWrite = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitAll = function (asts, context) {\n      var _this = this;\n\n      return asts.map(function (node) {\n        return node.visit(_this, context);\n      });\n    };\n\n    SimpleExpressionChecker.prototype.visitChain = function (ast, context) {};\n\n    SimpleExpressionChecker.prototype.visitQuote = function (ast, context) {};\n\n    return SimpleExpressionChecker;\n  }();\n  /**\n   * This class implements SimpleExpressionChecker used in View Engine and performs more strict checks\n   * to make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is\n   * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at\n   * compile time. In order to preserve View Engine behavior, more strict checks are introduced for\n   * Ivy mode only.\n   */\n\n\n  var IvySimpleExpressionChecker =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(IvySimpleExpressionChecker, _super);\n\n    function IvySimpleExpressionChecker() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.errors = [];\n      return _this;\n    }\n\n    IvySimpleExpressionChecker.prototype.visitPipe = function () {\n      this.errors.push('pipes');\n    };\n\n    return IvySimpleExpressionChecker;\n  }(ast_1.RecursiveAstVisitor);\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/expression_parser/parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\n\nimport {AbsoluteSourceSpan, AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Chain, Conditional, EmptyExpr, ExpressionBinding, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, MethodCall, NonNullAssert, ParserError, ParseSpan, PrefixNot, PropertyRead, PropertyWrite, Quote, RecursiveAstVisitor, SafeMethodCall, SafePropertyRead, TemplateBinding, TemplateBindingIdentifier, ThisReceiver, Unary, VariableBinding} from './ast';\nimport {EOF, isIdentifier, isQuote, Lexer, Token, TokenType} from './lexer';\n\nexport interface InterpolationPiece {\n  text: string;\n  start: number;\n  end: number;\n}\nexport class SplitInterpolation {\n  constructor(\n      public strings: InterpolationPiece[], public expressions: InterpolationPiece[],\n      public offsets: number[]) {}\n}\n\nexport class TemplateBindingParseResult {\n  constructor(\n      public templateBindings: TemplateBinding[], public warnings: string[],\n      public errors: ParserError[]) {}\n}\n\nexport class Parser {\n  private errors: ParserError[] = [];\n\n  constructor(private _lexer: Lexer) {}\n\n  simpleExpressionChecker = SimpleExpressionChecker;\n\n  parseAction(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(this._stripComments(input));\n    const ast = new _ParseAST(\n                    input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors,\n                    input.length - sourceToLex.length)\n                    .parseChain();\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  parseBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private checkSimpleExpression(ast: AST): string[] {\n    const checker = new this.simpleExpressionChecker();\n    ast.visit(checker);\n    return checker.errors;\n  }\n\n  parseSimpleBinding(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n    const errors = this.checkSimpleExpression(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n  }\n\n  private _reportError(message: string, input: string, errLocation: string, ctxLocation?: string) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n\n  private _parseBindingAst(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const quote = this._parseQuote(input, location, absoluteOffset);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const sourceToLex = this._stripComments(input);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(\n               input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors,\n               input.length - sourceToLex.length)\n        .parseChain();\n  }\n\n  private _parseQuote(input: string|null, location: string, absoluteOffset: number): AST|null {\n    if (input == null) return null;\n    const prefixSeparatorIndex = input.indexOf(':');\n    if (prefixSeparatorIndex == -1) return null;\n    const prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) return null;\n    const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    const span = new ParseSpan(0, input.length);\n    return new Quote(\n        span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```\n   *   <div *ngFor=\"let item of items\">\n   *         ^      ^ absoluteValueOffset for `templateValue`\n   *         absoluteKeyOffset for `templateKey`\n   * ```\n   * contains three bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   *\n   * This is apparent from the de-sugared template:\n   * ```\n   *   <ng-template ngFor let-item [ngForOf]=\"items\">\n   * ```\n   *\n   * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n   * @param templateValue RHS of the microsyntax attribute\n   * @param templateUrl template filename if it's external, component filename if it's inline\n   * @param absoluteKeyOffset start of the `templateKey`\n   * @param absoluteValueOffset start of the `templateValue`\n   */\n  parseTemplateBindings(\n      templateKey: string, templateValue: string, templateUrl: string, absoluteKeyOffset: number,\n      absoluteValueOffset: number): TemplateBindingParseResult {\n    const tokens = this._lexer.tokenize(templateValue);\n    const parser = new _ParseAST(\n        templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length,\n        false /* parseAction */, this.errors, 0 /* relative offset */);\n    return parser.parseTemplateBindings({\n      source: templateKey,\n      span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\n    });\n  }\n\n  parseInterpolation(\n      input: string, location: string, absoluteOffset: number,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource|null {\n    const {strings, expressions, offsets} =\n        this.splitInterpolation(input, location, interpolationConfig);\n    if (expressions.length === 0) return null;\n\n    const expressionNodes: AST[] = [];\n\n    for (let i = 0; i < expressions.length; ++i) {\n      const expressionText = expressions[i].text;\n      const sourceToLex = this._stripComments(expressionText);\n      const tokens = this._lexer.tokenize(sourceToLex);\n      const ast = new _ParseAST(\n                      input, location, absoluteOffset, tokens, sourceToLex.length, false,\n                      this.errors, offsets[i] + (expressionText.length - sourceToLex.length))\n                      .parseChain();\n      expressionNodes.push(ast);\n    }\n\n    return this.createInterpolationAst(\n        strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, location: string, absoluteOffset: number):\n      ASTWithSource {\n    const sourceToLex = this._stripComments(expression);\n    const tokens = this._lexer.tokenize(sourceToLex);\n    const ast = new _ParseAST(\n                    expression, location, absoluteOffset, tokens, sourceToLex.length,\n                    /* parseAction */ false, this.errors, 0)\n                    .parseChain();\n    const strings = ['', ''];  // The prefix and suffix strings are both empty\n    return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n  }\n\n  private createInterpolationAst(\n      strings: string[], expressions: AST[], input: string, location: string,\n      absoluteOffset: number): ASTWithSource {\n    const span = new ParseSpan(0, input.length);\n    const interpolation =\n        new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n    return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n  }\n\n  /**\n   * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\n   * the string.\n   * Returns `null` if there are no interpolations, otherwise a\n   * `SplitInterpolation` with splits that look like\n   *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\n   */\n  splitInterpolation(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation {\n    const strings: InterpolationPiece[] = [];\n    const expressions: InterpolationPiece[] = [];\n    const offsets: number[] = [];\n    let i = 0;\n    let atInterpolation = false;\n    let extendLastString = false;\n    let {start: interpStart, end: interpEnd} = interpolationConfig;\n    while (i < input.length) {\n      if (!atInterpolation) {\n        // parse until starting {{\n        const start = i;\n        i = input.indexOf(interpStart, i);\n        if (i === -1) {\n          i = input.length;\n        }\n        const text = input.substring(start, i);\n        strings.push({text, start, end: i});\n\n        atInterpolation = true;\n      } else {\n        // parse from starting {{ to ending }} while ignoring content inside quotes.\n        const fullStart = i;\n        const exprStart = fullStart + interpStart.length;\n        const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n        if (exprEnd === -1) {\n          // Could not find the end of the interpolation; do not parse an expression.\n          // Instead we should extend the content on the last raw string.\n          atInterpolation = false;\n          extendLastString = true;\n          break;\n        }\n        const fullEnd = exprEnd + interpEnd.length;\n\n        const text = input.substring(exprStart, exprEnd);\n        if (text.trim().length === 0) {\n          this._reportError(\n              'Blank expressions are not allowed in interpolated strings', input,\n              `at column ${i} in`, location);\n        }\n        expressions.push({text, start: fullStart, end: fullEnd});\n        offsets.push(exprStart);\n\n        i = fullEnd;\n        atInterpolation = false;\n      }\n    }\n    if (!atInterpolation) {\n      // If we are now at a text section, add the remaining content as a raw string.\n      if (extendLastString) {\n        const piece = strings[strings.length - 1];\n        piece.text += input.substring(i);\n        piece.end = input.length;\n      } else {\n        strings.push({text: input.substring(i), start: i, end: input.length});\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n\n  wrapLiteralPrimitive(input: string|null, location: string, absoluteOffset: number):\n      ASTWithSource {\n    const span = new ParseSpan(0, input == null ? 0 : input.length);\n    return new ASTWithSource(\n        new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location,\n        absoluteOffset, this.errors);\n  }\n\n  private _stripComments(input: string): string {\n    const i = this._commentStart(input);\n    return i != null ? input.substring(0, i).trim() : input;\n  }\n\n  private _commentStart(input: string): number|null {\n    let outerQuote: number|null = null;\n    for (let i = 0; i < input.length - 1; i++) {\n      const char = input.charCodeAt(i);\n      const nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n\n  private _checkNoInterpolation(input: string, location: string, {start, end}: InterpolationConfig):\n      void {\n    let startIndex = -1;\n    let endIndex = -1;\n\n    for (const charIndex of this._forEachUnquotedChar(input, 0)) {\n      if (startIndex === -1) {\n        if (input.startsWith(start)) {\n          startIndex = charIndex;\n        }\n      } else {\n        endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n        if (endIndex > -1) {\n          break;\n        }\n      }\n    }\n\n    if (startIndex > -1 && endIndex > -1) {\n      this._reportError(\n          `Got interpolation (${start}${end}) where expression was expected`, input,\n          `at column ${startIndex} in`, location);\n    }\n  }\n\n  /**\n   * Finds the index of the end of an interpolation expression\n   * while ignoring comments and quoted content.\n   */\n  private _getInterpolationEndIndex(input: string, expressionEnd: string, start: number): number {\n    for (const charIndex of this._forEachUnquotedChar(input, start)) {\n      if (input.startsWith(expressionEnd, charIndex)) {\n        return charIndex;\n      }\n\n      // Nothing else in the expression matters after we've\n      // hit a comment so look directly for the end token.\n      if (input.startsWith('//', charIndex)) {\n        return input.indexOf(expressionEnd, charIndex);\n      }\n    }\n\n    return -1;\n  }\n\n  /**\n   * Generator used to iterate over the character indexes of a string that are outside of quotes.\n   * @param input String to loop through.\n   * @param start Index within the string at which to start.\n   */\n  private * _forEachUnquotedChar(input: string, start: number) {\n    let currentQuote: string|null = null;\n    let escapeCount = 0;\n    for (let i = start; i < input.length; i++) {\n      const char = input[i];\n      // Skip the characters inside quotes. Note that we only care about the outer-most\n      // quotes matching up and we need to account for escape characters.\n      if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\n          escapeCount % 2 === 0) {\n        currentQuote = currentQuote === null ? char : null;\n      } else if (currentQuote === null) {\n        yield i;\n      }\n      escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n    }\n  }\n}\n\nexport class IvyParser extends Parser {\n  simpleExpressionChecker = IvySimpleExpressionChecker;\n}\n\n/** Describes a stateful context an expression parser is in. */\nenum ParseContextFlags {\n  None = 0,\n  /**\n   * A Writable context is one in which a value may be written to an lvalue.\n   * For example, after we see a property access, we may expect a write to the\n   * property via the \"=\" operator.\n   *   prop\n   *        ^ possible \"=\" after\n   */\n  Writable = 1,\n}\n\nexport class _ParseAST {\n  private rparensExpected = 0;\n  private rbracketsExpected = 0;\n  private rbracesExpected = 0;\n  private context = ParseContextFlags.None;\n\n  // Cache of expression start and input indeces to the absolute source span they map to, used to\n  // prevent creating superfluous source spans in `sourceSpan`.\n  // A serial of the expression start and input index is used for mapping because both are stateful\n  // and may change for subsequent expressions visited by the parser.\n  private sourceSpanCache = new Map<string, AbsoluteSourceSpan>();\n\n  index: number = 0;\n\n  constructor(\n      public input: string, public location: string, public absoluteOffset: number,\n      public tokens: Token[], public inputLength: number, public parseAction: boolean,\n      private errors: ParserError[], private offset: number) {}\n\n  peek(offset: number): Token {\n    const i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n\n  get next(): Token {\n    return this.peek(0);\n  }\n\n  /** Whether all the parser input has been processed. */\n  get atEOF(): boolean {\n    return this.index >= this.tokens.length;\n  }\n\n  /**\n   * Index of the next token to be processed, or the end of the last token if all have been\n   * processed.\n   */\n  get inputIndex(): number {\n    return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n  }\n\n  /**\n   * End index of the last processed token, or the start of the first token if none have been\n   * processed.\n   */\n  get currentEndIndex(): number {\n    if (this.index > 0) {\n      const curToken = this.peek(-1);\n      return curToken.end + this.offset;\n    }\n    // No tokens have been processed yet; return the next token's start or the length of the input\n    // if there is no token.\n    if (this.tokens.length === 0) {\n      return this.inputLength + this.offset;\n    }\n    return this.next.index + this.offset;\n  }\n\n  /**\n   * Returns the absolute offset of the start of the current token.\n   */\n  get currentAbsoluteOffset(): number {\n    return this.absoluteOffset + this.inputIndex;\n  }\n\n  /**\n   * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\n   * provided).\n   *\n   * @param start Position from which the `ParseSpan` will start.\n   * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\n   *     natural ending index)\n   */\n  span(start: number, artificialEndIndex?: number): ParseSpan {\n    let endIndex = this.currentEndIndex;\n    if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n      endIndex = artificialEndIndex;\n    }\n    return new ParseSpan(start, endIndex);\n  }\n\n  sourceSpan(start: number, artificialEndIndex?: number): AbsoluteSourceSpan {\n    const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\n    if (!this.sourceSpanCache.has(serial)) {\n      this.sourceSpanCache.set(\n          serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n    }\n    return this.sourceSpanCache.get(serial)!;\n  }\n\n  advance() {\n    this.index++;\n  }\n\n  /**\n   * Executes a callback in the provided context.\n   */\n  private withContext<T>(context: ParseContextFlags, cb: () => T): T {\n    this.context |= context;\n    const ret = cb();\n    this.context ^= context;\n    return ret;\n  }\n\n  consumeOptionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  peekKeywordLet(): boolean {\n    return this.next.isKeywordLet();\n  }\n  peekKeywordAs(): boolean {\n    return this.next.isKeywordAs();\n  }\n\n  /**\n   * Consumes an expected character, otherwise emits an error about the missing expected character\n   * and skips over the token stream until reaching a recoverable point.\n   *\n   * See `this.error` and `this.skip` for more details.\n   */\n  expectCharacter(code: number) {\n    if (this.consumeOptionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n\n  consumeOptionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  expectOperator(operator: string) {\n    if (this.consumeOptionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n\n  prettyPrintToken(tok: Token): string {\n    return tok === EOF ? 'end of input' : `token ${tok}`;\n  }\n\n  expectIdentifierOrKeyword(): string|null {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\n      return null;\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  expectIdentifierOrKeywordOrString(): string {\n    const n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\n      return '';\n    }\n    this.advance();\n    return n.toString() as string;\n  }\n\n  parseChain(): AST {\n    const exprs: AST[] = [];\n    const start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.consumeOptionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length == 0) {\n      // We have no expressions so create an empty expression that spans the entire input length\n      const artificialStart = this.offset;\n      const artificialEnd = this.offset + this.inputLength;\n      return new EmptyExpr(\n          this.span(artificialStart, artificialEnd),\n          this.sourceSpan(artificialStart, artificialEnd));\n    }\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), this.sourceSpan(start), exprs);\n  }\n\n  parsePipe(): AST {\n    const start = this.inputIndex;\n    let result = this.parseExpression();\n    if (this.consumeOptionalOperator('|')) {\n      if (this.parseAction) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        const nameStart = this.inputIndex;\n        let nameId = this.expectIdentifierOrKeyword();\n        let nameSpan: AbsoluteSourceSpan;\n        let fullSpanEnd: number|undefined = undefined;\n        if (nameId !== null) {\n          nameSpan = this.sourceSpan(nameStart);\n        } else {\n          // No valid identifier was found, so we'll assume an empty pipe name ('').\n          nameId = '';\n\n          // However, there may have been whitespace present between the pipe character and the next\n          // token in the sequence (or the end of input). We want to track this whitespace so that\n          // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n          // whitespace beyond it. Another way of thinking about this is that the zero-length name\n          // is assumed to be at the end of any whitespace beyond the pipe character.\n          //\n          // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n          // beginning of the next token, or until the end of input if the next token is EOF.\n          fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset;\n\n          // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n          // beyond the pipe character.\n          nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n        }\n\n        const args: AST[] = [];\n        while (this.consumeOptionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n\n          // If there are additional expressions beyond the name, then the artificial end for the\n          // name is no longer relevant.\n        }\n        result = new BindingPipe(\n            this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n      } while (this.consumeOptionalOperator('|'));\n    }\n\n    return result;\n  }\n\n  parseExpression(): AST {\n    return this.parseConditional();\n  }\n\n  parseConditional(): AST {\n    const start = this.inputIndex;\n    const result = this.parseLogicalOr();\n\n    if (this.consumeOptionalOperator('?')) {\n      const yes = this.parsePipe();\n      let no: AST;\n      if (!this.consumeOptionalCharacter(chars.$COLON)) {\n        const end = this.inputIndex;\n        const expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n\n  parseLogicalOr(): AST {\n    // '||'\n    const start = this.inputIndex;\n    let result = this.parseLogicalAnd();\n    while (this.consumeOptionalOperator('||')) {\n      const right = this.parseLogicalAnd();\n      result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n    }\n    return result;\n  }\n\n  parseLogicalAnd(): AST {\n    // '&&'\n    const start = this.inputIndex;\n    let result = this.parseEquality();\n    while (this.consumeOptionalOperator('&&')) {\n      const right = this.parseEquality();\n      result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n    }\n    return result;\n  }\n\n  parseEquality(): AST {\n    // '==','!=','===','!=='\n    const start = this.inputIndex;\n    let result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const right = this.parseRelational();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseRelational(): AST {\n    // '<', '>', '<=', '>='\n    const start = this.inputIndex;\n    let result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const right = this.parseAdditive();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseAdditive(): AST {\n    // '+', '-'\n    const start = this.inputIndex;\n    let result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let right = this.parseMultiplicative();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parseMultiplicative(): AST {\n    // '*', '%', '/'\n    const start = this.inputIndex;\n    let result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let right = this.parsePrefix();\n          result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n\n  parsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const start = this.inputIndex;\n      const operator = this.next.strValue;\n      let result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n\n  parseCallChain(): AST {\n    const start = this.inputIndex;\n    let result = this.parsePrimary();\n    while (true) {\n      if (this.consumeOptionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, start, false);\n\n      } else if (this.consumeOptionalOperator('?.')) {\n        result = this.parseAccessMemberOrMethodCall(result, start, true);\n\n      } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n        this.withContext(ParseContextFlags.Writable, () => {\n          this.rbracketsExpected++;\n          const key = this.parsePipe();\n          if (key instanceof EmptyExpr) {\n            this.error(`Key access cannot be empty`);\n          }\n          this.rbracketsExpected--;\n          this.expectCharacter(chars.$RBRACKET);\n          if (this.consumeOptionalOperator('=')) {\n            const value = this.parseConditional();\n            result = new KeyedWrite(this.span(start), this.sourceSpan(start), result, key, value);\n          } else {\n            result = new KeyedRead(this.span(start), this.sourceSpan(start), result, key);\n          }\n        });\n      } else if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(start), this.sourceSpan(start), result, args);\n\n      } else if (this.consumeOptionalOperator('!')) {\n        result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n\n      } else {\n        return result;\n      }\n    }\n  }\n\n  parsePrimary(): AST {\n    const start = this.inputIndex;\n    if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ThisReceiver(this.span(start), this.sourceSpan(start));\n    } else if (this.consumeOptionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(\n          new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n\n    } else if (this.next.isNumber()) {\n      const value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n\n    } else if (this.next.isString()) {\n      const literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start), this.sourceSpan(start));\n    }\n  }\n\n  parseExpressionList(terminator: number): AST[] {\n    const result: AST[] = [];\n\n    do {\n      if (!this.next.isCharacter(terminator)) {\n        result.push(this.parsePipe());\n      } else {\n        break;\n      }\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return result;\n  }\n\n  parseLiteralMap(): LiteralMap {\n    const keys: LiteralMapKey[] = [];\n    const values: AST[] = [];\n    const start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.consumeOptionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const quoted = this.next.isString();\n        const key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.consumeOptionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n  }\n\n  parseAccessMemberOrMethodCall(receiver: AST, start: number, isSafe: boolean = false): AST {\n    const nameStart = this.inputIndex;\n    const id = this.withContext(ParseContextFlags.Writable, () => {\n      const id = this.expectIdentifierOrKeyword() ?? '';\n      if (id.length === 0) {\n        this.error(`Expected identifier for property access`, receiver.span.end);\n      }\n      return id;\n    });\n    const nameSpan = this.sourceSpan(nameStart);\n\n    if (this.consumeOptionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const span = this.span(start);\n      const sourceSpan = this.sourceSpan(start);\n      return isSafe ? new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args) :\n                      new MethodCall(span, sourceSpan, nameSpan, receiver, id, args);\n\n    } else {\n      if (isSafe) {\n        if (this.consumeOptionalOperator('=')) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n          return new EmptyExpr(this.span(start), this.sourceSpan(start));\n        } else {\n          return new SafePropertyRead(\n              this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n        }\n      } else {\n        if (this.consumeOptionalOperator('=')) {\n          if (!this.parseAction) {\n            this.error('Bindings cannot contain assignments');\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n          }\n\n          const value = this.parseConditional();\n          return new PropertyWrite(\n              this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n        }\n      }\n    }\n  }\n\n  parseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.consumeOptionalCharacter(chars.$COMMA));\n    return positionals as BindingPipe[];\n  }\n\n  /**\n   * Parses an identifier, a keyword, a string with an optional `-` in between,\n   * and returns the string along with its absolute source span.\n   */\n  expectTemplateBindingKey(): TemplateBindingIdentifier {\n    let result = '';\n    let operatorFound = false;\n    const start = this.currentAbsoluteOffset;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.consumeOptionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n    return {\n      source: result,\n      span: new AbsoluteSourceSpan(start, start + result.length),\n    };\n  }\n\n  /**\n   * Parse microsyntax template expression and return a list of bindings or\n   * parsing errors in case the given expression is invalid.\n   *\n   * For example,\n   * ```\n   *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n   * ```\n   * contains five bindings:\n   * 1. ngFor -> null\n   * 2. item -> NgForOfContext.$implicit\n   * 3. ngForOf -> items\n   * 4. i -> NgForOfContext.index\n   * 5. ngForTrackBy -> func\n   *\n   * For a full description of the microsyntax grammar, see\n   * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n   *\n   * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n   * without the *, along with its absolute span.\n   */\n  parseTemplateBindings(templateKey: TemplateBindingIdentifier): TemplateBindingParseResult {\n    const bindings: TemplateBinding[] = [];\n\n    // The first binding is for the template key itself\n    // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n    // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n    bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\n\n    while (this.index < this.tokens.length) {\n      // If it starts with 'let', then this must be variable declaration\n      const letBinding = this.parseLetBinding();\n      if (letBinding) {\n        bindings.push(letBinding);\n      } else {\n        // Two possible cases here, either `value \"as\" key` or\n        // \"directive-keyword expression\". We don't know which case, but both\n        // \"value\" and \"directive-keyword\" are template binding key, so consume\n        // the key first.\n        const key = this.expectTemplateBindingKey();\n        // Peek at the next token, if it is \"as\" then this must be variable\n        // declaration.\n        const binding = this.parseAsBinding(key);\n        if (binding) {\n          bindings.push(binding);\n        } else {\n          // Otherwise the key must be a directive keyword, like \"of\". Transform\n          // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n          key.source =\n              templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n          bindings.push(...this.parseDirectiveKeywordBindings(key));\n        }\n      }\n      this.consumeStatementTerminator();\n    }\n\n    return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\n  }\n\n  /**\n   * Parse a directive keyword, followed by a mandatory expression.\n   * For example, \"of items\", \"trackBy: func\".\n   * The bindings are: ngForOf -> items, ngForTrackBy -> func\n   * There could be an optional \"as\" binding that follows the expression.\n   * For example,\n   * ```\n   *   *ngFor=\"let item of items | slice:0:1 as collection\".\n   *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n   *               keyword    bound target   optional 'as' binding\n   * ```\n   *\n   * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n   * absolute span.\n   */\n  private parseDirectiveKeywordBindings(key: TemplateBindingIdentifier): TemplateBinding[] {\n    const bindings: TemplateBinding[] = [];\n    this.consumeOptionalCharacter(chars.$COLON);  // trackBy: trackByFunction\n    const value = this.getDirectiveBoundTarget();\n    let spanEnd = this.currentAbsoluteOffset;\n    // The binding could optionally be followed by \"as\". For example,\n    // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n    // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n    // 'key' in the current context now becomes the \"value\" in the next binding.\n    const asBinding = this.parseAsBinding(key);\n    if (!asBinding) {\n      this.consumeStatementTerminator();\n      spanEnd = this.currentAbsoluteOffset;\n    }\n    const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n    bindings.push(new ExpressionBinding(sourceSpan, key, value));\n    if (asBinding) {\n      bindings.push(asBinding);\n    }\n    return bindings;\n  }\n\n  /**\n   * Return the expression AST for the bound target of a directive keyword\n   * binding. For example,\n   * ```\n   *   *ngIf=\"condition | pipe\"\n   *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n   *   *ngFor=\"let item of items\"\n   *                       ^^^^^ bound target for \"ngForOf\"\n   * ```\n   */\n  private getDirectiveBoundTarget(): ASTWithSource|null {\n    if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n      return null;\n    }\n    const ast = this.parsePipe();  // example: \"condition | async\"\n    const {start, end} = ast.span;\n    const value = this.input.substring(start, end);\n    return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n  }\n\n  /**\n   * Return the binding for a variable declared using `as`. Note that the order\n   * of the key-value pair in this declaration is reversed. For example,\n   * ```\n   *   *ngFor=\"let item of items; index as i\"\n   *                              ^^^^^    ^\n   *                              value    key\n   * ```\n   *\n   * @param value name of the value in the declaration, \"ngIf\" in the example\n   * above, along with its absolute span.\n   */\n  private parseAsBinding(value: TemplateBindingIdentifier): TemplateBinding|null {\n    if (!this.peekKeywordAs()) {\n      return null;\n    }\n    this.advance();  // consume the 'as' keyword\n    const key = this.expectTemplateBindingKey();\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Return the binding for a variable declared using `let`. For example,\n   * ```\n   *   *ngFor=\"let item of items; let i=index;\"\n   *           ^^^^^^^^           ^^^^^^^^^^^\n   * ```\n   * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n   * In the second binding, `i` is bound to `NgForOfContext.index`.\n   */\n  private parseLetBinding(): TemplateBinding|null {\n    if (!this.peekKeywordLet()) {\n      return null;\n    }\n    const spanStart = this.currentAbsoluteOffset;\n    this.advance();  // consume the 'let' keyword\n    const key = this.expectTemplateBindingKey();\n    let value: TemplateBindingIdentifier|null = null;\n    if (this.consumeOptionalOperator('=')) {\n      value = this.expectTemplateBindingKey();\n    }\n    this.consumeStatementTerminator();\n    const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n    return new VariableBinding(sourceSpan, key, value);\n  }\n\n  /**\n   * Consume the optional statement terminator: semicolon or comma.\n   */\n  private consumeStatementTerminator() {\n    this.consumeOptionalCharacter(chars.$SEMICOLON) || this.consumeOptionalCharacter(chars.$COMMA);\n  }\n\n  /**\n   * Records an error and skips over the token stream until reaching a recoverable point. See\n   * `this.skip` for more details on token skipping.\n   */\n  error(message: string, index: number|null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n\n  private locationText(index: number|null = null) {\n    if (index == null) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n\n  /**\n   * Error recovery should skip tokens until it encounters a recovery point.\n   *\n   * The following are treated as unconditional recovery points:\n   *   - end of input\n   *   - ';' (parseChain() is always the root production, and it expects a ';')\n   *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\n   *\n   * The following are conditional recovery points:\n   *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\n   *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\n   *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\n   *       an '(' <expr> ')' production).\n   *       The recovery points of grouping symbols must be conditional as they must be skipped if\n   *       none of the calling productions are not expecting the closing token else we will never\n   *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\n   *       That is, we skip a closing symbol if we are not in a grouping production.\n   *   - '=' in a `Writable` context\n   *     - In this context, we are able to recover after seeing the `=` operator, which\n   *       signals the presence of an independent rvalue expression following the `=` operator.\n   *\n   * If a production expects one of these token it increments the corresponding nesting count,\n   * and then decrements it just prior to checking if the token is in the input.\n   */\n  private skip() {\n    let n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET)) &&\n           (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n      if (this.next.isError()) {\n        this.errors.push(\n            new ParserError(this.next.toString()!, this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n  errors: string[] = [];\n\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n\n  visitThisReceiver(ast: ThisReceiver, context: any) {}\n\n  visitInterpolation(ast: Interpolation, context: any) {}\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n\n  visitPropertyRead(ast: PropertyRead, context: any) {}\n\n  visitPropertyWrite(ast: PropertyWrite, context: any) {}\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n\n  visitMethodCall(ast: MethodCall, context: any) {}\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n\n  visitFunctionCall(ast: FunctionCall, context: any) {}\n\n  visitLiteralArray(ast: LiteralArray, context: any) {\n    this.visitAll(ast.expressions, context);\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any) {\n    this.visitAll(ast.values, context);\n  }\n\n  visitUnary(ast: Unary, context: any) {}\n\n  visitBinary(ast: Binary, context: any) {}\n\n  visitPrefixNot(ast: PrefixNot, context: any) {}\n\n  visitNonNullAssert(ast: NonNullAssert, context: any) {}\n\n  visitConditional(ast: Conditional, context: any) {}\n\n  visitPipe(ast: BindingPipe, context: any) {\n    this.errors.push('pipes');\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any) {}\n\n  visitKeyedWrite(ast: KeyedWrite, context: any) {}\n\n  visitAll(asts: any[], context: any): any[] {\n    return asts.map(node => node.visit(this, context));\n  }\n\n  visitChain(ast: Chain, context: any) {}\n\n  visitQuote(ast: Quote, context: any) {}\n}\n\n/**\n * This class implements SimpleExpressionChecker used in View Engine and performs more strict checks\n * to make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is\n * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at\n * compile time. In order to preserve View Engine behavior, more strict checks are introduced for\n * Ivy mode only.\n */\nclass IvySimpleExpressionChecker extends RecursiveAstVisitor implements SimpleExpressionChecker {\n  errors: string[] = [];\n\n  visitPipe() {\n    this.errors.push('pipes');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}