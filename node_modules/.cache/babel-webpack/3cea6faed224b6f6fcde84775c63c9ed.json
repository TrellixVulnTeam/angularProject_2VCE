{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/i18n/meta\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/i18n/digest\", \"@angular/compiler/src/i18n/i18n_ast\", \"@angular/compiler/src/i18n/i18n_parser\", \"@angular/compiler/src/i18n/parse_util\", \"@angular/compiler/src/ml_parser/ast\", \"@angular/compiler/src/ml_parser/interpolation_config\", \"@angular/compiler/src/ml_parser/parser\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/schema/trusted_types_sinks\", \"@angular/compiler/src/render3/view/i18n/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.i18nMetaToJSDoc = exports.parseI18nMeta = exports.I18nMetaVisitor = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var digest_1 = require(\"@angular/compiler/src/i18n/digest\");\n\n  var i18n = require(\"@angular/compiler/src/i18n/i18n_ast\");\n\n  var i18n_parser_1 = require(\"@angular/compiler/src/i18n/i18n_parser\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/i18n/parse_util\");\n\n  var html = require(\"@angular/compiler/src/ml_parser/ast\");\n\n  var interpolation_config_1 = require(\"@angular/compiler/src/ml_parser/interpolation_config\");\n\n  var parser_1 = require(\"@angular/compiler/src/ml_parser/parser\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var trusted_types_sinks_1 = require(\"@angular/compiler/src/schema/trusted_types_sinks\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/view/i18n/util\");\n\n  var setI18nRefs = function setI18nRefs(htmlNode, i18nNode) {\n    if (htmlNode instanceof html.NodeWithI18n) {\n      if (i18nNode instanceof i18n.IcuPlaceholder && htmlNode.i18n instanceof i18n.Message) {\n        // This html node represents an ICU but this is a second processing pass, and the legacy id\n        // was computed in the previous pass and stored in the `i18n` property as a message.\n        // We are about to wipe out that property so capture the previous message to be reused when\n        // generating the message for this ICU later. See `_generateI18nMessage()`.\n        i18nNode.previousMessage = htmlNode.i18n;\n      }\n\n      htmlNode.i18n = i18nNode;\n    }\n\n    return i18nNode;\n  };\n  /**\n   * This visitor walks over HTML parse tree and converts information stored in\n   * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n   * stored with other element's and attribute's information.\n   */\n\n\n  var I18nMetaVisitor =\n  /** @class */\n  function () {\n    function I18nMetaVisitor(interpolationConfig, keepI18nAttrs, enableI18nLegacyMessageIdFormat) {\n      if (interpolationConfig === void 0) {\n        interpolationConfig = interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;\n      }\n\n      if (keepI18nAttrs === void 0) {\n        keepI18nAttrs = false;\n      }\n\n      if (enableI18nLegacyMessageIdFormat === void 0) {\n        enableI18nLegacyMessageIdFormat = false;\n      }\n\n      this.interpolationConfig = interpolationConfig;\n      this.keepI18nAttrs = keepI18nAttrs;\n      this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat; // whether visited nodes contain i18n information\n\n      this.hasI18nMeta = false;\n      this._errors = []; // i18n message generation factory\n\n      this._createI18nMessage = i18n_parser_1.createI18nMessageFactory(this.interpolationConfig);\n    }\n\n    I18nMetaVisitor.prototype._generateI18nMessage = function (nodes, meta, visitNodeFn) {\n      if (meta === void 0) {\n        meta = '';\n      }\n\n      var _a = this._parseMetadata(meta),\n          meaning = _a.meaning,\n          description = _a.description,\n          customId = _a.customId;\n\n      var message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n\n      this._setMessageId(message, meta);\n\n      this._setLegacyIds(message, meta);\n\n      return message;\n    };\n\n    I18nMetaVisitor.prototype.visitAllWithErrors = function (nodes) {\n      var _this = this;\n\n      var result = nodes.map(function (node) {\n        return node.visit(_this, null);\n      });\n      return new parser_1.ParseTreeResult(result, this._errors);\n    };\n\n    I18nMetaVisitor.prototype.visitElement = function (element) {\n      var e_1, _a, e_2, _b;\n\n      if (util_1.hasI18nAttrs(element)) {\n        this.hasI18nMeta = true;\n        var attrs = [];\n        var attrsMeta = {};\n\n        try {\n          for (var _c = tslib_1.__values(element.attrs), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var attr = _d.value;\n\n            if (attr.name === util_1.I18N_ATTR) {\n              // root 'i18n' node attribute\n              var i18n_1 = element.i18n || attr.value;\n\n              var message = this._generateI18nMessage(element.children, i18n_1, setI18nRefs); // do not assign empty i18n meta\n\n\n              if (message.nodes.length) {\n                element.i18n = message;\n              }\n            } else if (attr.name.startsWith(util_1.I18N_ATTR_PREFIX)) {\n              // 'i18n-*' attributes\n              var name_1 = attr.name.slice(util_1.I18N_ATTR_PREFIX.length);\n\n              if (trusted_types_sinks_1.isTrustedTypesSink(element.name, name_1)) {\n                this._reportError(attr, \"Translating attribute '\" + name_1 + \"' is disallowed for security reasons.\");\n              } else {\n                attrsMeta[name_1] = attr.value;\n              }\n            } else {\n              // non-i18n attributes\n              attrs.push(attr);\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        } // set i18n meta for attributes\n\n\n        if (Object.keys(attrsMeta).length) {\n          try {\n            for (var attrs_1 = tslib_1.__values(attrs), attrs_1_1 = attrs_1.next(); !attrs_1_1.done; attrs_1_1 = attrs_1.next()) {\n              var attr = attrs_1_1.value;\n              var meta = attrsMeta[attr.name]; // do not create translation for empty attributes\n\n              if (meta !== undefined && attr.value) {\n                attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (attrs_1_1 && !attrs_1_1.done && (_b = attrs_1.return)) _b.call(attrs_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n\n        if (!this.keepI18nAttrs) {\n          // update element's attributes,\n          // keeping only non-i18n related ones\n          element.attrs = attrs;\n        }\n      }\n\n      html.visitAll(this, element.children, element.i18n);\n      return element;\n    };\n\n    I18nMetaVisitor.prototype.visitExpansion = function (expansion, currentMessage) {\n      var message;\n      var meta = expansion.i18n;\n      this.hasI18nMeta = true;\n\n      if (meta instanceof i18n.IcuPlaceholder) {\n        // set ICU placeholder name (e.g. \"ICU_1\"),\n        // generated while processing root element contents,\n        // so we can reference it when we output translation\n        var name_2 = meta.name;\n        message = this._generateI18nMessage([expansion], meta);\n        var icu = util_1.icuFromI18nMessage(message);\n        icu.name = name_2;\n      } else {\n        // ICU is a top level message, try to use metadata from container element if provided via\n        // `context` argument. Note: context may not be available for standalone ICUs (without\n        // wrapping element), so fallback to ICU metadata in this case.\n        message = this._generateI18nMessage([expansion], currentMessage || meta);\n      }\n\n      expansion.i18n = message;\n      return expansion;\n    };\n\n    I18nMetaVisitor.prototype.visitText = function (text) {\n      return text;\n    };\n\n    I18nMetaVisitor.prototype.visitAttribute = function (attribute) {\n      return attribute;\n    };\n\n    I18nMetaVisitor.prototype.visitComment = function (comment) {\n      return comment;\n    };\n\n    I18nMetaVisitor.prototype.visitExpansionCase = function (expansionCase) {\n      return expansionCase;\n    };\n    /**\n     * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n     * `Message`.\n     *\n     * There are three possibilities for the `meta` variable\n     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n     * 4) other: ignore this and just process the message metadata as normal\n     *\n     * @param meta the bucket that holds information about the message\n     * @returns the parsed metadata.\n     */\n\n\n    I18nMetaVisitor.prototype._parseMetadata = function (meta) {\n      return typeof meta === 'string' ? parseI18nMeta(meta) : meta instanceof i18n.Message ? meta : {};\n    };\n    /**\n     * Generate (or restore) message id if not specified already.\n     */\n\n\n    I18nMetaVisitor.prototype._setMessageId = function (message, meta) {\n      if (!message.id) {\n        message.id = meta instanceof i18n.Message && meta.id || digest_1.decimalDigest(message);\n      }\n    };\n    /**\n     * Update the `message` with a `legacyId` if necessary.\n     *\n     * @param message the message whose legacy id should be set\n     * @param meta information about the message being processed\n     */\n\n\n    I18nMetaVisitor.prototype._setLegacyIds = function (message, meta) {\n      if (this.enableI18nLegacyMessageIdFormat) {\n        message.legacyIds = [digest_1.computeDigest(message), digest_1.computeDecimalDigest(message)];\n      } else if (typeof meta !== 'string') {\n        // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n        // `packages/compiler/src/render3/view/template.ts`).\n        // In that case we want to reuse the legacy message generated in the 1st pass (see\n        // `setI18nRefs()`).\n        var previousMessage = meta instanceof i18n.Message ? meta : meta instanceof i18n.IcuPlaceholder ? meta.previousMessage : undefined;\n        message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n      }\n    };\n\n    I18nMetaVisitor.prototype._reportError = function (node, msg) {\n      this._errors.push(new parse_util_1.I18nError(node.sourceSpan, msg));\n    };\n\n    return I18nMetaVisitor;\n  }();\n\n  exports.I18nMetaVisitor = I18nMetaVisitor;\n  /** I18n separators for metadata **/\n\n  var I18N_MEANING_SEPARATOR = '|';\n  var I18N_ID_SEPARATOR = '@@';\n  /**\n   * Parses i18n metas like:\n   *  - \"@@id\",\n   *  - \"description[@@id]\",\n   *  - \"meaning|description[@@id]\"\n   * and returns an object with parsed output.\n   *\n   * @param meta String that represents i18n meta\n   * @returns Object with id, meaning and description fields\n   */\n\n  function parseI18nMeta(meta) {\n    var _a, _b;\n\n    if (meta === void 0) {\n      meta = '';\n    }\n\n    var customId;\n    var meaning;\n    var description;\n    meta = meta.trim();\n\n    if (meta) {\n      var idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n      var descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n      var meaningAndDesc = void 0;\n      _a = tslib_1.__read(idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''], 2), meaningAndDesc = _a[0], customId = _a[1];\n      _b = tslib_1.__read(descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc], 2), meaning = _b[0], description = _b[1];\n    }\n\n    return {\n      customId: customId,\n      meaning: meaning,\n      description: description\n    };\n  }\n\n  exports.parseI18nMeta = parseI18nMeta; // Converts i18n meta information for a message (id, description, meaning)\n  // to a JsDoc statement formatted as expected by the Closure compiler.\n\n  function i18nMetaToJSDoc(meta) {\n    var tags = [];\n\n    if (meta.description) {\n      tags.push({\n        tagName: \"desc\"\n        /* Desc */\n        ,\n        text: meta.description\n      });\n    }\n\n    if (meta.meaning) {\n      tags.push({\n        tagName: \"meaning\"\n        /* Meaning */\n        ,\n        text: meta.meaning\n      });\n    }\n\n    return tags.length == 0 ? null : o.jsDocComment(tags);\n  }\n\n  exports.i18nMetaToJSDoc = i18nMetaToJSDoc;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler/src/render3/view/i18n/meta.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {computeDecimalDigest, computeDigest, decimalDigest} from '../../../i18n/digest';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {createI18nMessageFactory, VisitNodeFn} from '../../../i18n/i18n_parser';\nimport {I18nError} from '../../../i18n/parse_util';\nimport * as html from '../../../ml_parser/ast';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../../../ml_parser/interpolation_config';\nimport {ParseTreeResult} from '../../../ml_parser/parser';\nimport * as o from '../../../output/output_ast';\nimport {isTrustedTypesSink} from '../../../schema/trusted_types_sinks';\n\nimport {hasI18nAttrs, I18N_ATTR, I18N_ATTR_PREFIX, icuFromI18nMessage} from './util';\n\nexport type I18nMeta = {\n  id?: string,\n  customId?: string,\n  legacyIds?: string[],\n  description?: string,\n  meaning?: string\n};\n\n\nconst setI18nRefs: VisitNodeFn = (htmlNode, i18nNode) => {\n  if (htmlNode instanceof html.NodeWithI18n) {\n    if (i18nNode instanceof i18n.IcuPlaceholder && htmlNode.i18n instanceof i18n.Message) {\n      // This html node represents an ICU but this is a second processing pass, and the legacy id\n      // was computed in the previous pass and stored in the `i18n` property as a message.\n      // We are about to wipe out that property so capture the previous message to be reused when\n      // generating the message for this ICU later. See `_generateI18nMessage()`.\n      i18nNode.previousMessage = htmlNode.i18n;\n    }\n    htmlNode.i18n = i18nNode;\n  }\n  return i18nNode;\n};\n\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\nexport class I18nMetaVisitor implements html.Visitor {\n  // whether visited nodes contain i18n information\n  public hasI18nMeta: boolean = false;\n  private _errors: I18nError[] = [];\n\n  // i18n message generation factory\n  private _createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n\n  constructor(\n      private interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG,\n      private keepI18nAttrs = false, private enableI18nLegacyMessageIdFormat = false) {}\n\n  private _generateI18nMessage(\n      nodes: html.Node[], meta: string|i18n.I18nMeta = '',\n      visitNodeFn?: VisitNodeFn): i18n.Message {\n    const {meaning, description, customId} = this._parseMetadata(meta);\n    const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    this._setMessageId(message, meta);\n    this._setLegacyIds(message, meta);\n    return message;\n  }\n\n  visitAllWithErrors(nodes: html.Node[]): ParseTreeResult {\n    const result = nodes.map(node => node.visit(this, null));\n    return new ParseTreeResult(result, this._errors);\n  }\n\n  visitElement(element: html.Element): any {\n    if (hasI18nAttrs(element)) {\n      this.hasI18nMeta = true;\n      const attrs: html.Attribute[] = [];\n      const attrsMeta: {[key: string]: string} = {};\n\n      for (const attr of element.attrs) {\n        if (attr.name === I18N_ATTR) {\n          // root 'i18n' node attribute\n          const i18n = element.i18n || attr.value;\n          const message = this._generateI18nMessage(element.children, i18n, setI18nRefs);\n          // do not assign empty i18n meta\n          if (message.nodes.length) {\n            element.i18n = message;\n          }\n\n        } else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\n          // 'i18n-*' attributes\n          const name = attr.name.slice(I18N_ATTR_PREFIX.length);\n          if (isTrustedTypesSink(element.name, name)) {\n            this._reportError(\n                attr, `Translating attribute '${name}' is disallowed for security reasons.`);\n          } else {\n            attrsMeta[name] = attr.value;\n          }\n        } else {\n          // non-i18n attributes\n          attrs.push(attr);\n        }\n      }\n\n      // set i18n meta for attributes\n      if (Object.keys(attrsMeta).length) {\n        for (const attr of attrs) {\n          const meta = attrsMeta[attr.name];\n          // do not create translation for empty attributes\n          if (meta !== undefined && attr.value) {\n            attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n          }\n        }\n      }\n\n      if (!this.keepI18nAttrs) {\n        // update element's attributes,\n        // keeping only non-i18n related ones\n        element.attrs = attrs;\n      }\n    }\n    html.visitAll(this, element.children, element.i18n);\n    return element;\n  }\n\n  visitExpansion(expansion: html.Expansion, currentMessage: i18n.Message|undefined): any {\n    let message;\n    const meta = expansion.i18n;\n    this.hasI18nMeta = true;\n    if (meta instanceof i18n.IcuPlaceholder) {\n      // set ICU placeholder name (e.g. \"ICU_1\"),\n      // generated while processing root element contents,\n      // so we can reference it when we output translation\n      const name = meta.name;\n      message = this._generateI18nMessage([expansion], meta);\n      const icu = icuFromI18nMessage(message);\n      icu.name = name;\n    } else {\n      // ICU is a top level message, try to use metadata from container element if provided via\n      // `context` argument. Note: context may not be available for standalone ICUs (without\n      // wrapping element), so fallback to ICU metadata in this case.\n      message = this._generateI18nMessage([expansion], currentMessage || meta);\n    }\n    expansion.i18n = message;\n    return expansion;\n  }\n\n  visitText(text: html.Text): any {\n    return text;\n  }\n  visitAttribute(attribute: html.Attribute): any {\n    return attribute;\n  }\n  visitComment(comment: html.Comment): any {\n    return comment;\n  }\n  visitExpansionCase(expansionCase: html.ExpansionCase): any {\n    return expansionCase;\n  }\n\n  /**\n   * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n   * `Message`.\n   *\n   * There are three possibilities for the `meta` variable\n   * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n   * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n   * 4) other: ignore this and just process the message metadata as normal\n   *\n   * @param meta the bucket that holds information about the message\n   * @returns the parsed metadata.\n   */\n  private _parseMetadata(meta: string|i18n.I18nMeta): I18nMeta {\n    return typeof meta === 'string' ? parseI18nMeta(meta) :\n                                      meta instanceof i18n.Message ? meta : {};\n  }\n\n  /**\n   * Generate (or restore) message id if not specified already.\n   */\n  private _setMessageId(message: i18n.Message, meta: string|i18n.I18nMeta): void {\n    if (!message.id) {\n      message.id = meta instanceof i18n.Message && meta.id || decimalDigest(message);\n    }\n  }\n\n  /**\n   * Update the `message` with a `legacyId` if necessary.\n   *\n   * @param message the message whose legacy id should be set\n   * @param meta information about the message being processed\n   */\n  private _setLegacyIds(message: i18n.Message, meta: string|i18n.I18nMeta): void {\n    if (this.enableI18nLegacyMessageIdFormat) {\n      message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n    } else if (typeof meta !== 'string') {\n      // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n      // `packages/compiler/src/render3/view/template.ts`).\n      // In that case we want to reuse the legacy message generated in the 1st pass (see\n      // `setI18nRefs()`).\n      const previousMessage = meta instanceof i18n.Message ?\n          meta :\n          meta instanceof i18n.IcuPlaceholder ? meta.previousMessage : undefined;\n      message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n    }\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, msg));\n  }\n}\n\n/** I18n separators for metadata **/\nconst I18N_MEANING_SEPARATOR = '|';\nconst I18N_ID_SEPARATOR = '@@';\n\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\nexport function parseI18nMeta(meta: string = ''): I18nMeta {\n  let customId: string|undefined;\n  let meaning: string|undefined;\n  let description: string|undefined;\n\n  meta = meta.trim();\n  if (meta) {\n    const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    let meaningAndDesc: string;\n    [meaningAndDesc, customId] =\n        (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n    [meaning, description] = (descIndex > -1) ?\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n        ['', meaningAndDesc];\n  }\n\n  return {customId, meaning, description};\n}\n\n// Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\nexport function i18nMetaToJSDoc(meta: I18nMeta): o.JSDocComment|null {\n  const tags: o.JSDocTag[] = [];\n  if (meta.description) {\n    tags.push({tagName: o.JSDocTagName.Desc, text: meta.description});\n  }\n  if (meta.meaning) {\n    tags.push({tagName: o.JSDocTagName.Meaning, text: meta.meaning});\n  }\n  return tags.length == 0 ? null : o.jsDocComment(tags);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}