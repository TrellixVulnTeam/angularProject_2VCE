{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar hexify = function hexify(char) {\n  var h = char.charCodeAt(0).toString(16).toUpperCase();\n  return '0x' + (h.length % 2 ? '0' : '') + h;\n};\n\nvar parseError = function parseError(e, txt, context) {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0\n    };\n  }\n\n  var badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i);\n  var errIdx = badToken ? +badToken[2] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;\n  var msg = badToken ? e.message.replace(/^Unexpected token ./, \"Unexpected token \".concat(JSON.stringify(badToken[1]), \" (\").concat(hexify(badToken[1]), \")\")) : e.message;\n\n  if (errIdx !== null && errIdx !== undefined) {\n    var start = errIdx <= context ? 0 : errIdx - context;\n    var end = errIdx + context >= txt.length ? txt.length : errIdx + context;\n    var slice = (start === 0 ? '' : '...') + txt.slice(start, end) + (end === txt.length ? '' : '...');\n    var near = txt === slice ? '' : 'near ';\n    return {\n      message: msg + \" while parsing \".concat(near).concat(JSON.stringify(slice)),\n      position: errIdx\n    };\n  } else {\n    return {\n      message: msg + \" while parsing '\".concat(txt.slice(0, context * 2), \"'\"),\n      position: 0\n    };\n  }\n};\n\nvar JSONParseError = /*#__PURE__*/function (_SyntaxError) {\n  _inherits(JSONParseError, _SyntaxError);\n\n  var _super = _createSuper(JSONParseError);\n\n  function JSONParseError(er, txt, context, caller) {\n    var _this;\n\n    _classCallCheck(this, JSONParseError);\n\n    context = context || 20;\n    var metadata = parseError(er, txt, context);\n    _this = _super.call(this, metadata.message);\n    Object.assign(_assertThisInitialized(_this), metadata);\n    _this.code = 'EJSONPARSE';\n    _this.systemError = er;\n    Error.captureStackTrace(_assertThisInitialized(_this), caller || _this.constructor);\n    return _this;\n  }\n\n  _createClass(JSONParseError, [{\n    key: \"name\",\n    get: function get() {\n      return this.constructor.name;\n    },\n    set: function set(n) {}\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return this.constructor.name;\n    }\n  }]);\n\n  return JSONParseError;\n}( /*#__PURE__*/_wrapNativeSuper(SyntaxError));\n\nvar kIndent = Symbol.for('indent');\nvar kNewline = Symbol.for('newline'); // only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\n\nvar formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/;\nvar emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/;\n\nvar parseJson = function parseJson(txt, reviver, context) {\n  var parseText = stripBOM(txt);\n  context = context || 20;\n\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    var _ref = parseText.match(emptyRE) || parseText.match(formatRE) || [, '', ''],\n        _ref2 = _slicedToArray(_ref, 3),\n        _ref2$ = _ref2[1],\n        newline = _ref2$ === void 0 ? '\\n' : _ref2$,\n        _ref2$2 = _ref2[2],\n        indent = _ref2$2 === void 0 ? '  ' : _ref2$2;\n\n    var result = JSON.parse(parseText, reviver);\n\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline;\n      result[kIndent] = indent;\n    }\n\n    return result;\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      var isEmptyArray = Array.isArray(txt) && txt.length === 0;\n      throw Object.assign(new TypeError(\"Cannot parse \".concat(isEmptyArray ? 'an empty array' : String(txt))), {\n        code: 'EJSONPARSE',\n        systemError: e\n      });\n    }\n\n    throw new JSONParseError(e, parseText, context, parseJson);\n  }\n}; // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\n\n\nvar stripBOM = function stripBOM(txt) {\n  return String(txt).replace(/^\\uFEFF/, '');\n};\n\nmodule.exports = parseJson;\nparseJson.JSONParseError = JSONParseError;\n\nparseJson.noExceptions = function (txt, reviver) {\n  try {\n    return JSON.parse(stripBOM(txt), reviver);\n  } catch (e) {}\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/json-parse-even-better-errors/index.js"],"names":["hexify","char","h","charCodeAt","toString","toUpperCase","length","parseError","e","txt","context","message","position","badToken","match","errIdx","msg","replace","JSON","stringify","undefined","start","end","slice","near","JSONParseError","er","caller","metadata","Object","assign","code","systemError","Error","captureStackTrace","constructor","name","n","Symbol","toStringTag","SyntaxError","kIndent","for","kNewline","formatRE","emptyRE","parseJson","reviver","parseText","stripBOM","newline","indent","result","parse","Buffer","isBuffer","isEmptyArray","Array","isArray","TypeError","String","module","exports","noExceptions"],"mappings":"AAAA;;;;;;;;;;;;;;;;AAEA,IAAMA,MAAM,GAAG,SAATA,MAAS,CAAAC,IAAI,EAAI;AACrB,MAAMC,CAAC,GAAGD,IAAI,CAACE,UAAL,CAAgB,CAAhB,EAAmBC,QAAnB,CAA4B,EAA5B,EAAgCC,WAAhC,EAAV;AACA,SAAO,QAAQH,CAAC,CAACI,MAAF,GAAW,CAAX,GAAe,GAAf,GAAqB,EAA7B,IAAmCJ,CAA1C;AACD,CAHD;;AAKA,IAAMK,UAAU,GAAG,SAAbA,UAAa,CAACC,CAAD,EAAIC,GAAJ,EAASC,OAAT,EAAqB;AACtC,MAAI,CAACD,GAAL,EAAU;AACR,WAAO;AACLE,MAAAA,OAAO,EAAEH,CAAC,CAACG,OAAF,GAAY,6BADhB;AAELC,MAAAA,QAAQ,EAAE;AAFL,KAAP;AAID;;AACD,MAAMC,QAAQ,GAAGL,CAAC,CAACG,OAAF,CAAUG,KAAV,CAAgB,2CAAhB,CAAjB;AACA,MAAMC,MAAM,GAAGF,QAAQ,GAAG,CAACA,QAAQ,CAAC,CAAD,CAAZ,GACnBL,CAAC,CAACG,OAAF,CAAUG,KAAV,CAAgB,4BAAhB,IAAgDL,GAAG,CAACH,MAAJ,GAAa,CAA7D,GACA,IAFJ;AAIA,MAAMU,GAAG,GAAGH,QAAQ,GAAGL,CAAC,CAACG,OAAF,CAAUM,OAAV,CAAkB,qBAAlB,6BACnBC,IAAI,CAACC,SAAL,CAAeN,QAAQ,CAAC,CAAD,CAAvB,CADmB,eAEhBb,MAAM,CAACa,QAAQ,CAAC,CAAD,CAAT,CAFU,OAAH,GAGhBL,CAAC,CAACG,OAHN;;AAKA,MAAII,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAKK,SAAlC,EAA6C;AAC3C,QAAMC,KAAK,GAAGN,MAAM,IAAIL,OAAV,GAAoB,CAApB,GACVK,MAAM,GAAGL,OADb;AAGA,QAAMY,GAAG,GAAGP,MAAM,GAAGL,OAAT,IAAoBD,GAAG,CAACH,MAAxB,GAAiCG,GAAG,CAACH,MAArC,GACRS,MAAM,GAAGL,OADb;AAGA,QAAMa,KAAK,GAAG,CAACF,KAAK,KAAK,CAAV,GAAc,EAAd,GAAmB,KAApB,IACZZ,GAAG,CAACc,KAAJ,CAAUF,KAAV,EAAiBC,GAAjB,CADY,IAEXA,GAAG,KAAKb,GAAG,CAACH,MAAZ,GAAqB,EAArB,GAA0B,KAFf,CAAd;AAIA,QAAMkB,IAAI,GAAGf,GAAG,KAAKc,KAAR,GAAgB,EAAhB,GAAqB,OAAlC;AAEA,WAAO;AACLZ,MAAAA,OAAO,EAAEK,GAAG,4BAAqBQ,IAArB,SAA4BN,IAAI,CAACC,SAAL,CAAeI,KAAf,CAA5B,CADP;AAELX,MAAAA,QAAQ,EAAEG;AAFL,KAAP;AAID,GAjBD,MAiBO;AACL,WAAO;AACLJ,MAAAA,OAAO,EAAEK,GAAG,6BAAsBP,GAAG,CAACc,KAAJ,CAAU,CAAV,EAAab,OAAO,GAAG,CAAvB,CAAtB,MADP;AAELE,MAAAA,QAAQ,EAAE;AAFL,KAAP;AAID;AACF,CAxCD;;IA0CMa,c;;;;;AACJ,0BAAaC,EAAb,EAAiBjB,GAAjB,EAAsBC,OAAtB,EAA+BiB,MAA/B,EAAuC;AAAA;;AAAA;;AACrCjB,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAMkB,QAAQ,GAAGrB,UAAU,CAACmB,EAAD,EAAKjB,GAAL,EAAUC,OAAV,CAA3B;AACA,8BAAMkB,QAAQ,CAACjB,OAAf;AACAkB,IAAAA,MAAM,CAACC,MAAP,gCAAoBF,QAApB;AACA,UAAKG,IAAL,GAAY,YAAZ;AACA,UAAKC,WAAL,GAAmBN,EAAnB;AACAO,IAAAA,KAAK,CAACC,iBAAN,gCAA8BP,MAAM,IAAI,MAAKQ,WAA7C;AAPqC;AAQtC;;;;SACD,eAAY;AAAE,aAAO,KAAKA,WAAL,CAAiBC,IAAxB;AAA8B,K;SAC5C,aAAUC,CAAV,EAAa,CAAE;;SACVC,MAAM,CAACC,W;SAAZ,eAA4B;AAAE,aAAO,KAAKJ,WAAL,CAAiBC,IAAxB;AAA8B;;;;iCAZjCI,W;;AAe7B,IAAMC,OAAO,GAAGH,MAAM,CAACI,GAAP,CAAW,QAAX,CAAhB;AACA,IAAMC,QAAQ,GAAGL,MAAM,CAACI,GAAP,CAAW,SAAX,CAAjB,C,CACA;AACA;AACA;AACA;;AACA,IAAME,QAAQ,GAAG,gCAAjB;AACA,IAAMC,OAAO,GAAG,8BAAhB;;AAEA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAACrC,GAAD,EAAMsC,OAAN,EAAerC,OAAf,EAA2B;AAC3C,MAAMsC,SAAS,GAAGC,QAAQ,CAACxC,GAAD,CAA1B;AACAC,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,MAAI;AACF;AACA;AACA;AACA;AACA;AACA;AACA,eAA0CsC,SAAS,CAAClC,KAAV,CAAgB+B,OAAhB,KACxCG,SAAS,CAAClC,KAAV,CAAgB8B,QAAhB,CADwC,IAExC,GAAG,EAAH,EAAO,EAAP,CAFF;AAAA;AAAA;AAAA,QAASM,OAAT,uBAAmB,IAAnB;AAAA;AAAA,QAAyBC,MAAzB,wBAAkC,IAAlC;;AAIA,QAAMC,MAAM,GAAGlC,IAAI,CAACmC,KAAL,CAAWL,SAAX,EAAsBD,OAAtB,CAAf;;AACA,QAAIK,MAAM,IAAI,OAAOA,MAAP,KAAkB,QAAhC,EAA0C;AACxCA,MAAAA,MAAM,CAACT,QAAD,CAAN,GAAmBO,OAAnB;AACAE,MAAAA,MAAM,CAACX,OAAD,CAAN,GAAkBU,MAAlB;AACD;;AACD,WAAOC,MAAP;AACD,GAjBD,CAiBE,OAAO5C,CAAP,EAAU;AACV,QAAI,OAAOC,GAAP,KAAe,QAAf,IAA2B,CAAC6C,MAAM,CAACC,QAAP,CAAgB9C,GAAhB,CAAhC,EAAsD;AACpD,UAAM+C,YAAY,GAAGC,KAAK,CAACC,OAAN,CAAcjD,GAAd,KAAsBA,GAAG,CAACH,MAAJ,KAAe,CAA1D;AACA,YAAMuB,MAAM,CAACC,MAAP,CAAc,IAAI6B,SAAJ,wBACFH,YAAY,GAAG,gBAAH,GAAsBI,MAAM,CAACnD,GAAD,CADtC,EAAd,EAEH;AACDsB,QAAAA,IAAI,EAAE,YADL;AAEDC,QAAAA,WAAW,EAAExB;AAFZ,OAFG,CAAN;AAMD;;AAED,UAAM,IAAIiB,cAAJ,CAAmBjB,CAAnB,EAAsBwC,SAAtB,EAAiCtC,OAAjC,EAA0CoC,SAA1C,CAAN;AACD;AACF,CAjCD,C,CAmCA;AACA;AACA;;;AACA,IAAMG,QAAQ,GAAG,SAAXA,QAAW,CAAAxC,GAAG;AAAA,SAAImD,MAAM,CAACnD,GAAD,CAAN,CAAYQ,OAAZ,CAAoB,SAApB,EAA+B,EAA/B,CAAJ;AAAA,CAApB;;AAEA4C,MAAM,CAACC,OAAP,GAAiBhB,SAAjB;AACAA,SAAS,CAACrB,cAAV,GAA2BA,cAA3B;;AAEAqB,SAAS,CAACiB,YAAV,GAAyB,UAACtD,GAAD,EAAMsC,OAAN,EAAkB;AACzC,MAAI;AACF,WAAO7B,IAAI,CAACmC,KAAL,CAAWJ,QAAQ,CAACxC,GAAD,CAAnB,EAA0BsC,OAA1B,CAAP;AACD,GAFD,CAEE,OAAOvC,CAAP,EAAU,CAAE;AACf,CAJD","sourcesContent":["'use strict'\n\nconst hexify = char => {\n  const h = char.charCodeAt(0).toString(16).toUpperCase()\n  return '0x' + (h.length % 2 ? '0' : '') + h\n}\n\nconst parseError = (e, txt, context) => {\n  if (!txt) {\n    return {\n      message: e.message + ' while parsing empty string',\n      position: 0,\n    }\n  }\n  const badToken = e.message.match(/^Unexpected token (.) .*position\\s+(\\d+)/i)\n  const errIdx = badToken ? +badToken[2]\n    : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1\n    : null\n\n  const msg = badToken ? e.message.replace(/^Unexpected token ./, `Unexpected token ${\n      JSON.stringify(badToken[1])\n    } (${hexify(badToken[1])})`)\n    : e.message\n\n  if (errIdx !== null && errIdx !== undefined) {\n    const start = errIdx <= context ? 0\n      : errIdx - context\n\n    const end = errIdx + context >= txt.length ? txt.length\n      : errIdx + context\n\n    const slice = (start === 0 ? '' : '...') +\n      txt.slice(start, end) +\n      (end === txt.length ? '' : '...')\n\n    const near = txt === slice ? '' : 'near '\n\n    return {\n      message: msg + ` while parsing ${near}${JSON.stringify(slice)}`,\n      position: errIdx,\n    }\n  } else {\n    return {\n      message: msg + ` while parsing '${txt.slice(0, context * 2)}'`,\n      position: 0,\n    }\n  }\n}\n\nclass JSONParseError extends SyntaxError {\n  constructor (er, txt, context, caller) {\n    context = context || 20\n    const metadata = parseError(er, txt, context)\n    super(metadata.message)\n    Object.assign(this, metadata)\n    this.code = 'EJSONPARSE'\n    this.systemError = er\n    Error.captureStackTrace(this, caller || this.constructor)\n  }\n  get name () { return this.constructor.name }\n  set name (n) {}\n  get [Symbol.toStringTag] () { return this.constructor.name }\n}\n\nconst kIndent = Symbol.for('indent')\nconst kNewline = Symbol.for('newline')\n// only respect indentation if we got a line break, otherwise squash it\n// things other than objects and arrays aren't indented, so ignore those\n// Important: in both of these regexps, the $1 capture group is the newline\n// or undefined, and the $2 capture group is the indent, or undefined.\nconst formatRE = /^\\s*[{\\[]((?:\\r?\\n)+)([\\s\\t]*)/\nconst emptyRE = /^(?:\\{\\}|\\[\\])((?:\\r?\\n)+)?$/\n\nconst parseJson = (txt, reviver, context) => {\n  const parseText = stripBOM(txt)\n  context = context || 20\n  try {\n    // get the indentation so that we can save it back nicely\n    // if the file starts with {\" then we have an indent of '', ie, none\n    // otherwise, pick the indentation of the next line after the first \\n\n    // If the pattern doesn't match, then it means no indentation.\n    // JSON.stringify ignores symbols, so this is reasonably safe.\n    // if the string is '{}' or '[]', then use the default 2-space indent.\n    const [, newline = '\\n', indent = '  '] = parseText.match(emptyRE) ||\n      parseText.match(formatRE) ||\n      [, '', '']\n\n    const result = JSON.parse(parseText, reviver)\n    if (result && typeof result === 'object') {\n      result[kNewline] = newline\n      result[kIndent] = indent\n    }\n    return result\n  } catch (e) {\n    if (typeof txt !== 'string' && !Buffer.isBuffer(txt)) {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\n      throw Object.assign(new TypeError(\n        `Cannot parse ${isEmptyArray ? 'an empty array' : String(txt)}`\n      ), {\n        code: 'EJSONPARSE',\n        systemError: e,\n      })\n    }\n\n    throw new JSONParseError(e, parseText, context, parseJson)\n  }\n}\n\n// Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n// because the buffer-to-string conversion in `fs.readFileSync()`\n// translates it to FEFF, the UTF-16 BOM.\nconst stripBOM = txt => String(txt).replace(/^\\uFEFF/, '')\n\nmodule.exports = parseJson\nparseJson.JSONParseError = JSONParseError\n\nparseJson.noExceptions = (txt, reviver) => {\n  try {\n    return JSON.parse(stripBOM(txt), reviver)\n  } catch (e) {}\n}\n"]},"metadata":{},"sourceType":"script"}