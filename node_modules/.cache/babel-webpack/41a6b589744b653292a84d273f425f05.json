{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/aot/summary_serializer\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/util\", \"@angular/compiler/src/aot/static_symbol\", \"@angular/compiler/src/aot/static_symbol_resolver\", \"@angular/compiler/src/aot/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.createForJitStub = exports.deserializeSummaries = exports.serializeSummaries = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var static_symbol_1 = require(\"@angular/compiler/src/aot/static_symbol\");\n\n  var static_symbol_resolver_1 = require(\"@angular/compiler/src/aot/static_symbol_resolver\");\n\n  var util_2 = require(\"@angular/compiler/src/aot/util\");\n\n  function serializeSummaries(srcFileName, forJitCtx, summaryResolver, symbolResolver, symbols, types, createExternalSymbolReexports) {\n    if (createExternalSymbolReexports === void 0) {\n      createExternalSymbolReexports = false;\n    }\n\n    var toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName); // for symbols, we use everything except for the class metadata itself\n    // (we keep the statics though), as the class metadata is contained in the\n    // CompileTypeSummary.\n\n    symbols.forEach(function (resolvedSymbol) {\n      return toJsonSerializer.addSummary({\n        symbol: resolvedSymbol.symbol,\n        metadata: resolvedSymbol.metadata\n      });\n    }); // Add type summaries.\n\n    types.forEach(function (_a) {\n      var summary = _a.summary,\n          metadata = _a.metadata;\n      toJsonSerializer.addSummary({\n        symbol: summary.type.reference,\n        metadata: undefined,\n        type: summary\n      });\n    });\n\n    var _a = toJsonSerializer.serialize(createExternalSymbolReexports),\n        json = _a.json,\n        exportAs = _a.exportAs;\n\n    if (forJitCtx) {\n      var forJitSerializer_1 = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);\n      types.forEach(function (_a) {\n        var summary = _a.summary,\n            metadata = _a.metadata;\n        forJitSerializer_1.addSourceType(summary, metadata);\n      });\n      toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach(function (summary) {\n        if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {\n          forJitSerializer_1.addLibType(summary.type);\n        }\n      });\n      forJitSerializer_1.serialize(exportAs);\n    }\n\n    return {\n      json: json,\n      exportAs: exportAs\n    };\n  }\n\n  exports.serializeSummaries = serializeSummaries;\n\n  function deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {\n    var deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);\n    return deserializer.deserialize(libraryFileName, json);\n  }\n\n  exports.deserializeSummaries = deserializeSummaries;\n\n  function createForJitStub(outputCtx, reference) {\n    return createSummaryForJitFunction(outputCtx, reference, o.NULL_EXPR);\n  }\n\n  exports.createForJitStub = createForJitStub;\n\n  function createSummaryForJitFunction(outputCtx, reference, value) {\n    var fnName = util_2.summaryForJitName(reference.name);\n    outputCtx.statements.push(o.fn([], [new o.ReturnStatement(value)], new o.ArrayType(o.DYNAMIC_TYPE)).toDeclStmt(fnName, [o.StmtModifier.Final, o.StmtModifier.Exported]));\n  }\n\n  var ToJsonSerializer =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ToJsonSerializer, _super);\n\n    function ToJsonSerializer(symbolResolver, summaryResolver, srcFileName) {\n      var _this = _super.call(this) || this;\n\n      _this.symbolResolver = symbolResolver;\n      _this.summaryResolver = summaryResolver;\n      _this.srcFileName = srcFileName; // Note: This only contains symbols without members.\n\n      _this.symbols = [];\n      _this.indexBySymbol = new Map();\n      _this.reexportedBy = new Map(); // This now contains a `__symbol: number` in the place of\n      // StaticSymbols, but otherwise has the same shape as the original objects.\n\n      _this.processedSummaryBySymbol = new Map();\n      _this.processedSummaries = [];\n      _this.unprocessedSymbolSummariesBySymbol = new Map();\n      _this.moduleName = symbolResolver.getKnownModuleName(srcFileName);\n      return _this;\n    }\n\n    ToJsonSerializer.prototype.addSummary = function (summary) {\n      var _this = this;\n\n      var unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);\n      var processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n\n      if (!unprocessedSummary) {\n        unprocessedSummary = {\n          symbol: summary.symbol,\n          metadata: undefined\n        };\n        this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);\n        processedSummary = {\n          symbol: this.processValue(summary.symbol, 0\n          /* None */\n          )\n        };\n        this.processedSummaries.push(processedSummary);\n        this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n      }\n\n      if (!unprocessedSummary.metadata && summary.metadata) {\n        var metadata_1 = summary.metadata || {};\n\n        if (metadata_1.__symbolic === 'class') {\n          // For classes, we keep everything except their class decorators.\n          // We need to keep e.g. the ctor args, method names, method decorators\n          // so that the class can be extended in another compilation unit.\n          // We don't keep the class decorators as\n          // 1) they refer to data\n          //   that should not cause a rebuild of downstream compilation units\n          //   (e.g. inline templates of @Component, or @NgModule.declarations)\n          // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n          var clone_1 = {};\n          Object.keys(metadata_1).forEach(function (propName) {\n            if (propName !== 'decorators') {\n              clone_1[propName] = metadata_1[propName];\n            }\n          });\n          metadata_1 = clone_1;\n        } else if (isCall(metadata_1)) {\n          if (!isFunctionCall(metadata_1) && !isMethodCallOnVariable(metadata_1)) {\n            // Don't store complex calls as we won't be able to simplify them anyways later on.\n            metadata_1 = {\n              __symbolic: 'error',\n              message: 'Complex function calls are not supported.'\n            };\n          }\n        } // Note: We need to keep storing ctor calls for e.g.\n        // `export const x = new InjectionToken(...)`\n\n\n        unprocessedSummary.metadata = metadata_1;\n        processedSummary.metadata = this.processValue(metadata_1, 1\n        /* ResolveValue */\n        );\n\n        if (metadata_1 instanceof static_symbol_1.StaticSymbol && this.summaryResolver.isLibraryFile(metadata_1.filePath)) {\n          var declarationSymbol = this.symbols[this.indexBySymbol.get(metadata_1)];\n\n          if (!util_2.isLoweredSymbol(declarationSymbol.name)) {\n            // Note: symbols that were introduced during codegen in the user file can have a reexport\n            // if a user used `export *`. However, we can't rely on this as tsickle will change\n            // `export *` into named exports, using only the information from the typechecker.\n            // As we introduce the new symbols after typecheck, Tsickle does not know about them,\n            // and omits them when expanding `export *`.\n            // So we have to keep reexporting these symbols manually via .ngfactory files.\n            this.reexportedBy.set(declarationSymbol, summary.symbol);\n          }\n        }\n      }\n\n      if (!unprocessedSummary.type && summary.type) {\n        unprocessedSummary.type = summary.type; // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n        // as the type summaries already contain the transitive data that they require\n        // (in a minimal way).\n\n        processedSummary.type = this.processValue(summary.type, 0\n        /* None */\n        ); // except for reexported directives / pipes, so we need to store\n        // their summaries explicitly.\n\n        if (summary.type.summaryKind === compile_metadata_1.CompileSummaryKind.NgModule) {\n          var ngModuleSummary = summary.type;\n          ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {\n            var symbol = id.reference;\n\n            if (_this.summaryResolver.isLibraryFile(symbol.filePath) && !_this.unprocessedSymbolSummariesBySymbol.has(symbol)) {\n              var summary_1 = _this.summaryResolver.resolveSummary(symbol);\n\n              if (summary_1) {\n                _this.addSummary(summary_1);\n              }\n            }\n          });\n        }\n      }\n    };\n    /**\n     * @param createExternalSymbolReexports Whether external static symbols should be re-exported.\n     * This can be enabled if external symbols should be re-exported by the current module in\n     * order to avoid dynamically generated module dependencies which can break strict dependency\n     * enforcements (as in Google3). Read more here: https://github.com/angular/angular/issues/25644\n     */\n\n\n    ToJsonSerializer.prototype.serialize = function (createExternalSymbolReexports) {\n      var _this = this;\n\n      var exportAs = [];\n      var json = JSON.stringify({\n        moduleName: this.moduleName,\n        summaries: this.processedSummaries,\n        symbols: this.symbols.map(function (symbol, index) {\n          symbol.assertNoMembers();\n          var importAs = undefined;\n\n          if (_this.summaryResolver.isLibraryFile(symbol.filePath)) {\n            var reexportSymbol = _this.reexportedBy.get(symbol);\n\n            if (reexportSymbol) {\n              // In case the given external static symbol is already manually exported by the\n              // user, we just proxy the external static symbol reference to the manual export.\n              // This ensures that the AOT compiler imports the external symbol through the\n              // user export and does not introduce another dependency which is not needed.\n              importAs = _this.indexBySymbol.get(reexportSymbol);\n            } else if (createExternalSymbolReexports) {\n              // In this case, the given external static symbol is *not* manually exported by\n              // the user, and we manually create a re-export in the factory file so that we\n              // don't introduce another module dependency. This is useful when running within\n              // Bazel so that the AOT compiler does not introduce any module dependencies\n              // which can break the strict dependency enforcement. (e.g. as in Google3)\n              // Read more about this here: https://github.com/angular/angular/issues/25644\n              var summary = _this.unprocessedSymbolSummariesBySymbol.get(symbol);\n\n              if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {\n                importAs = symbol.name + \"_\" + index;\n                exportAs.push({\n                  symbol: symbol,\n                  exportAs: importAs\n                });\n              }\n            }\n          }\n\n          return {\n            __symbol: index,\n            name: symbol.name,\n            filePath: _this.summaryResolver.toSummaryFileName(symbol.filePath, _this.srcFileName),\n            importAs: importAs\n          };\n        })\n      });\n      return {\n        json: json,\n        exportAs: exportAs\n      };\n    };\n\n    ToJsonSerializer.prototype.processValue = function (value, flags) {\n      return util_1.visitValue(value, this, flags);\n    };\n\n    ToJsonSerializer.prototype.visitOther = function (value, context) {\n      if (value instanceof static_symbol_1.StaticSymbol) {\n        var baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n        var index = this.visitStaticSymbol(baseSymbol, context);\n        return {\n          __symbol: index,\n          members: value.members\n        };\n      }\n    };\n    /**\n     * Strip line and character numbers from ngsummaries.\n     * Emitting them causes white spaces changes to retrigger upstream\n     * recompilations in bazel.\n     * TODO: find out a way to have line and character numbers in errors without\n     * excessive recompilation in bazel.\n     */\n\n\n    ToJsonSerializer.prototype.visitStringMap = function (map, context) {\n      if (map['__symbolic'] === 'resolved') {\n        return util_1.visitValue(map['symbol'], this, context);\n      }\n\n      if (map['__symbolic'] === 'error') {\n        delete map['line'];\n        delete map['character'];\n      }\n\n      return _super.prototype.visitStringMap.call(this, map, context);\n    };\n    /**\n     * Returns null if the options.resolveValue is true, and the summary for the symbol\n     * resolved to a type or could not be resolved.\n     */\n\n\n    ToJsonSerializer.prototype.visitStaticSymbol = function (baseSymbol, flags) {\n      var index = this.indexBySymbol.get(baseSymbol);\n      var summary = null;\n\n      if (flags & 1\n      /* ResolveValue */\n      && this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {\n        if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {\n          // the summary for this symbol was already added\n          // -> nothing to do.\n          return index;\n        }\n\n        summary = this.loadSummary(baseSymbol);\n\n        if (summary && summary.metadata instanceof static_symbol_1.StaticSymbol) {\n          // The summary is a reexport\n          index = this.visitStaticSymbol(summary.metadata, flags); // reset the summary as it is just a reexport, so we don't want to store it.\n\n          summary = null;\n        }\n      } else if (index != null) {\n        // Note: == on purpose to compare with undefined!\n        // No summary and the symbol is already added -> nothing to do.\n        return index;\n      } // Note: == on purpose to compare with undefined!\n\n\n      if (index == null) {\n        index = this.symbols.length;\n        this.symbols.push(baseSymbol);\n      }\n\n      this.indexBySymbol.set(baseSymbol, index);\n\n      if (summary) {\n        this.addSummary(summary);\n      }\n\n      return index;\n    };\n\n    ToJsonSerializer.prototype.loadSummary = function (symbol) {\n      var summary = this.summaryResolver.resolveSummary(symbol);\n\n      if (!summary) {\n        // some symbols might originate from a plain typescript library\n        // that just exported .d.ts and .metadata.json files, i.e. where no summary\n        // files were created.\n        var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n\n        if (resolvedSymbol) {\n          summary = {\n            symbol: resolvedSymbol.symbol,\n            metadata: resolvedSymbol.metadata\n          };\n        }\n      }\n\n      return summary;\n    };\n\n    return ToJsonSerializer;\n  }(util_1.ValueTransformer);\n\n  var ForJitSerializer =\n  /** @class */\n  function () {\n    function ForJitSerializer(outputCtx, symbolResolver, summaryResolver) {\n      this.outputCtx = outputCtx;\n      this.symbolResolver = symbolResolver;\n      this.summaryResolver = summaryResolver;\n      this.data = [];\n    }\n\n    ForJitSerializer.prototype.addSourceType = function (summary, metadata) {\n      this.data.push({\n        summary: summary,\n        metadata: metadata,\n        isLibrary: false\n      });\n    };\n\n    ForJitSerializer.prototype.addLibType = function (summary) {\n      this.data.push({\n        summary: summary,\n        metadata: null,\n        isLibrary: true\n      });\n    };\n\n    ForJitSerializer.prototype.serialize = function (exportAsArr) {\n      var e_1, _a, e_2, _b, e_3, _c;\n\n      var _this = this;\n\n      var exportAsBySymbol = new Map();\n\n      try {\n        for (var exportAsArr_1 = tslib_1.__values(exportAsArr), exportAsArr_1_1 = exportAsArr_1.next(); !exportAsArr_1_1.done; exportAsArr_1_1 = exportAsArr_1.next()) {\n          var _d = exportAsArr_1_1.value,\n              symbol = _d.symbol,\n              exportAs = _d.exportAs;\n          exportAsBySymbol.set(symbol, exportAs);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (exportAsArr_1_1 && !exportAsArr_1_1.done && (_a = exportAsArr_1.return)) _a.call(exportAsArr_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var ngModuleSymbols = new Set();\n\n      try {\n        for (var _e = tslib_1.__values(this.data), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var _g = _f.value,\n              summary = _g.summary,\n              metadata = _g.metadata,\n              isLibrary = _g.isLibrary;\n\n          if (summary.summaryKind === compile_metadata_1.CompileSummaryKind.NgModule) {\n            // collect the symbols that refer to NgModule classes.\n            // Note: we can't just rely on `summary.type.summaryKind` to determine this as\n            // we don't add the summaries of all referenced symbols when we serialize type summaries.\n            // See serializeSummaries for details.\n            ngModuleSymbols.add(summary.type.reference);\n            var modSummary = summary;\n\n            try {\n              for (var _h = (e_3 = void 0, tslib_1.__values(modSummary.modules)), _j = _h.next(); !_j.done; _j = _h.next()) {\n                var mod = _j.value;\n                ngModuleSymbols.add(mod.reference);\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n          }\n\n          if (!isLibrary) {\n            var fnName = util_2.summaryForJitName(summary.type.reference.name);\n            createSummaryForJitFunction(this.outputCtx, summary.type.reference, this.serializeSummaryWithDeps(summary, metadata));\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      ngModuleSymbols.forEach(function (ngModuleSymbol) {\n        if (_this.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {\n          var exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;\n          var jitExportAsName = util_2.summaryForJitName(exportAs);\n\n          _this.outputCtx.statements.push(o.variable(jitExportAsName).set(_this.serializeSummaryRef(ngModuleSymbol)).toDeclStmt(null, [o.StmtModifier.Exported]));\n        }\n      });\n    };\n\n    ForJitSerializer.prototype.serializeSummaryWithDeps = function (summary, metadata) {\n      var _this = this;\n\n      var expressions = [this.serializeSummary(summary)];\n      var providers = [];\n\n      if (metadata instanceof compile_metadata_1.CompileNgModuleMetadata) {\n        expressions.push.apply(expressions, tslib_1.__spread( // For directives / pipes, we only add the declared ones,\n        // and rely on transitively importing NgModules to get the transitive\n        // summaries.\n        metadata.declaredDirectives.concat(metadata.declaredPipes).map(function (type) {\n          return type.reference;\n        }) // For modules,\n        // we also add the summaries for modules\n        // from libraries.\n        // This is ok as we produce reexports for all transitive modules.\n        .concat(metadata.transitiveModule.modules.map(function (type) {\n          return type.reference;\n        }).filter(function (ref) {\n          return ref !== metadata.type.reference;\n        })).map(function (ref) {\n          return _this.serializeSummaryRef(ref);\n        }))); // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\n        // and we already have transitive modules.\n\n        providers = metadata.providers;\n      } else if (summary.summaryKind === compile_metadata_1.CompileSummaryKind.Directive) {\n        var dirSummary = summary;\n        providers = dirSummary.providers.concat(dirSummary.viewProviders);\n      } // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\n      // declaredDirectives / declaredPipes), as we allow\n      // providers without ctor arguments to skip the `@Injectable` decorator,\n      // i.e. we didn't generate .ngsummary.ts files for these.\n\n\n      expressions.push.apply(expressions, tslib_1.__spread(providers.filter(function (provider) {\n        return !!provider.useClass;\n      }).map(function (provider) {\n        return _this.serializeSummary({\n          summaryKind: compile_metadata_1.CompileSummaryKind.Injectable,\n          type: provider.useClass\n        });\n      })));\n      return o.literalArr(expressions);\n    };\n\n    ForJitSerializer.prototype.serializeSummaryRef = function (typeSymbol) {\n      var jitImportedSymbol = this.symbolResolver.getStaticSymbol(util_2.summaryForJitFileName(typeSymbol.filePath), util_2.summaryForJitName(typeSymbol.name));\n      return this.outputCtx.importExpr(jitImportedSymbol);\n    };\n\n    ForJitSerializer.prototype.serializeSummary = function (data) {\n      var outputCtx = this.outputCtx;\n\n      var Transformer =\n      /** @class */\n      function () {\n        function Transformer() {}\n\n        Transformer.prototype.visitArray = function (arr, context) {\n          var _this = this;\n\n          return o.literalArr(arr.map(function (entry) {\n            return util_1.visitValue(entry, _this, context);\n          }));\n        };\n\n        Transformer.prototype.visitStringMap = function (map, context) {\n          var _this = this;\n\n          return new o.LiteralMapExpr(Object.keys(map).map(function (key) {\n            return new o.LiteralMapEntry(key, util_1.visitValue(map[key], _this, context), false);\n          }));\n        };\n\n        Transformer.prototype.visitPrimitive = function (value, context) {\n          return o.literal(value);\n        };\n\n        Transformer.prototype.visitOther = function (value, context) {\n          if (value instanceof static_symbol_1.StaticSymbol) {\n            return outputCtx.importExpr(value);\n          } else {\n            throw new Error(\"Illegal State: Encountered value \" + value);\n          }\n        };\n\n        return Transformer;\n      }();\n\n      return util_1.visitValue(data, new Transformer(), null);\n    };\n\n    return ForJitSerializer;\n  }();\n\n  var FromJsonDeserializer =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(FromJsonDeserializer, _super);\n\n    function FromJsonDeserializer(symbolCache, summaryResolver) {\n      var _this = _super.call(this) || this;\n\n      _this.symbolCache = symbolCache;\n      _this.summaryResolver = summaryResolver;\n      return _this;\n    }\n\n    FromJsonDeserializer.prototype.deserialize = function (libraryFileName, json) {\n      var _this = this;\n\n      var data = JSON.parse(json);\n      var allImportAs = [];\n      this.symbols = data.symbols.map(function (serializedSymbol) {\n        return _this.symbolCache.get(_this.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName), serializedSymbol.name);\n      });\n      data.symbols.forEach(function (serializedSymbol, index) {\n        var symbol = _this.symbols[index];\n        var importAs = serializedSymbol.importAs;\n\n        if (typeof importAs === 'number') {\n          allImportAs.push({\n            symbol: symbol,\n            importAs: _this.symbols[importAs]\n          });\n        } else if (typeof importAs === 'string') {\n          allImportAs.push({\n            symbol: symbol,\n            importAs: _this.symbolCache.get(util_2.ngfactoryFilePath(libraryFileName), importAs)\n          });\n        }\n      });\n      var summaries = util_1.visitValue(data.summaries, this, null);\n      return {\n        moduleName: data.moduleName,\n        summaries: summaries,\n        importAs: allImportAs\n      };\n    };\n\n    FromJsonDeserializer.prototype.visitStringMap = function (map, context) {\n      if ('__symbol' in map) {\n        var baseSymbol = this.symbols[map['__symbol']];\n        var members = map['members'];\n        return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) : baseSymbol;\n      } else {\n        return _super.prototype.visitStringMap.call(this, map, context);\n      }\n    };\n\n    return FromJsonDeserializer;\n  }(util_1.ValueTransformer);\n\n  function isCall(metadata) {\n    return metadata && metadata.__symbolic === 'call';\n  }\n\n  function isFunctionCall(metadata) {\n    return isCall(metadata) && static_symbol_resolver_1.unwrapResolvedMetadata(metadata.expression) instanceof static_symbol_1.StaticSymbol;\n  }\n\n  function isMethodCallOnVariable(metadata) {\n    return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' && static_symbol_resolver_1.unwrapResolvedMetadata(metadata.expression.expression) instanceof static_symbol_1.StaticSymbol;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/summary_serializer.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAMG;;;AACH,MAAA,kBAAA,GAAA,OAAA,CAAA,wCAAA,CAAA;;AACA,MAAA,CAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAEA,MAAA,eAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AACA,MAAA,wBAAA,GAAA,OAAA,CAAA,kDAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,gCAAA,CAAA;;AAEA,WAAgB,kBAAhB,CACI,WADJ,EACyB,SADzB,EAEI,eAFJ,EAEoD,cAFpD,EAGI,OAHJ,EAGqC,KAHrC,EAQI,6BARJ,EASa;AADT,QAAA,6BAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,6BAAA,GAAA,KAAA;AACS;;AACX,QAAM,gBAAgB,GAAG,IAAI,gBAAJ,CAAqB,cAArB,EAAqC,eAArC,EAAsD,WAAtD,CAAzB,CADW,CAGX;AACA;AACA;;AACA,IAAA,OAAO,CAAC,OAAR,CACI,UAAC,cAAD,EAAe;AAAK,aAAA,gBAAgB,CAAC,UAAjB,CAChB;AAAC,QAAA,MAAM,EAAE,cAAc,CAAC,MAAxB;AAAgC,QAAA,QAAQ,EAAE,cAAc,CADxC;AAChB,OADgB,CAAA;AACmD,KAF3E,EANW,CAUX;;AACA,IAAA,KAAK,CAAC,OAAN,CAAc,UAAC,EAAD,EAAoB;UAAlB,OAAO,GAAA,EAAA,CAAA,O;UAAE,QAAQ,GAAA,EAAA,CAAA,Q;AAC/B,MAAA,gBAAgB,CAAC,UAAjB,CACI;AAAC,QAAA,MAAM,EAAE,OAAO,CAAC,IAAR,CAAa,SAAtB;AAAiC,QAAA,QAAQ,EAAE,SAA3C;AAAsD,QAAA,IAAI,EAAE;AAA5D,OADJ;AAED,KAHD;;AAIM,QAAA,EAAA,GAAmB,gBAAgB,CAAC,SAAjB,CAA2B,6BAA3B,CAAnB;AAAA,QAAC,IAAI,GAAA,EAAA,CAAA,IAAL;AAAA,QAAO,QAAQ,GAAA,EAAA,CAAA,QAAf;;AACN,QAAI,SAAJ,EAAe;AACb,UAAM,kBAAgB,GAAG,IAAI,gBAAJ,CAAqB,SAArB,EAAgC,cAAhC,EAAgD,eAAhD,CAAzB;AACA,MAAA,KAAK,CAAC,OAAN,CAAc,UAAC,EAAD,EAAoB;YAAlB,OAAO,GAAA,EAAA,CAAA,O;YAAE,QAAQ,GAAA,EAAA,CAAA,Q;AAC/B,QAAA,kBAAgB,CAAC,aAAjB,CAA+B,OAA/B,EAAwC,QAAxC;AACD,OAFD;AAGA,MAAA,gBAAgB,CAAC,kCAAjB,CAAoD,OAApD,CAA4D,UAAC,OAAD,EAAQ;AAClE,YAAI,eAAe,CAAC,aAAhB,CAA8B,OAAO,CAAC,MAAR,CAAe,QAA7C,KAA0D,OAAO,CAAC,IAAtE,EAA4E;AAC1E,UAAA,kBAAgB,CAAC,UAAjB,CAA4B,OAAO,CAAC,IAApC;AACD;AACF,OAJD;AAKA,MAAA,kBAAgB,CAAC,SAAjB,CAA2B,QAA3B;AACD;;AACD,WAAO;AAAC,MAAA,IAAI,EAAA,IAAL;AAAO,MAAA,QAAQ,EAAA;AAAf,KAAP;AACD;;AAtCD,EAAA,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAwCA,WAAgB,oBAAhB,CACI,WADJ,EACoC,eADpC,EAEI,eAFJ,EAE6B,IAF7B,EAEyC;AAKvC,QAAM,YAAY,GAAG,IAAI,oBAAJ,CAAyB,WAAzB,EAAsC,eAAtC,CAArB;AACA,WAAO,YAAY,CAAC,WAAb,CAAyB,eAAzB,EAA0C,IAA1C,CAAP;AACD;;AATD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAWA,WAAgB,gBAAhB,CAAiC,SAAjC,EAA2D,SAA3D,EAAkF;AAChF,WAAO,2BAA2B,CAAC,SAAD,EAAY,SAAZ,EAAuB,CAAC,CAAC,SAAzB,CAAlC;AACD;;AAFD,EAAA,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAIA,WAAS,2BAAT,CACI,SADJ,EAC8B,SAD9B,EACuD,KADvD,EAC0E;AACxE,QAAM,MAAM,GAAG,MAAA,CAAA,iBAAA,CAAkB,SAAS,CAAC,IAA5B,CAAf;AACA,IAAA,SAAS,CAAC,UAAV,CAAqB,IAArB,CACI,CAAC,CAAC,EAAF,CAAK,EAAL,EAAS,CAAC,IAAI,CAAC,CAAC,eAAN,CAAsB,KAAtB,CAAD,CAAT,EAAyC,IAAI,CAAC,CAAC,SAAN,CAAgB,CAAC,CAAC,YAAlB,CAAzC,EAA0E,UAA1E,CAAqF,MAArF,EAA6F,CAC3F,CAAC,CAAC,YAAF,CAAe,KAD4E,EACrE,CAAC,CAAC,YAAF,CAAe,QADsD,CAA7F,CADJ;AAID;;AAOD,MAAA,gBAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAA+B,IAAA,OAAA,CAAA,SAAA,CAAA,gBAAA,EAAA,MAAA;;AAa7B,aAAA,gBAAA,CACY,cADZ,EAEY,eAFZ,EAEoE,WAFpE,EAEuF;AAFvF,UAAA,KAAA,GAGE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IAHT;;AACY,MAAA,KAAA,CAAA,cAAA,GAAA,cAAA;AACA,MAAA,KAAA,CAAA,eAAA,GAAA,eAAA;AAAwD,MAAA,KAAA,CAAA,WAAA,GAAA,WAAA,CAAmB,CAdvF;;AACQ,MAAA,KAAA,CAAA,OAAA,GAA0B,EAA1B;AACA,MAAA,KAAA,CAAA,aAAA,GAAgB,IAAI,GAAJ,EAAhB;AACA,MAAA,KAAA,CAAA,YAAA,GAAe,IAAI,GAAJ,EAAf,CAW+E,CAVvF;AACA;;AACQ,MAAA,KAAA,CAAA,wBAAA,GAA2B,IAAI,GAAJ,EAA3B;AACA,MAAA,KAAA,CAAA,kBAAA,GAA4B,EAA5B;AAGR,MAAA,KAAA,CAAA,kCAAA,GAAqC,IAAI,GAAJ,EAArC;AAME,MAAA,KAAI,CAAC,UAAL,GAAkB,cAAc,CAAC,kBAAf,CAAkC,WAAlC,CAAlB;;AACD;;AAED,IAAA,gBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,OAAX,EAAyC;AAAzC,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,kBAAkB,GAAG,KAAK,kCAAL,CAAwC,GAAxC,CAA4C,OAAO,CAAC,MAApD,CAAzB;AACA,UAAI,gBAAgB,GAAG,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,OAAO,CAAC,MAA1C,CAAvB;;AACA,UAAI,CAAC,kBAAL,EAAyB;AACvB,QAAA,kBAAkB,GAAG;AAAC,UAAA,MAAM,EAAE,OAAO,CAAC,MAAjB;AAAyB,UAAA,QAAQ,EAAE;AAAnC,SAArB;AACA,aAAK,kCAAL,CAAwC,GAAxC,CAA4C,OAAO,CAAC,MAApD,EAA4D,kBAA5D;AACA,QAAA,gBAAgB,GAAG;AAAC,UAAA,MAAM,EAAE,KAAK,YAAL,CAAkB,OAAO,CAAC,MAA1B,EAAgC;AAAA;AAAhC;AAAT,SAAnB;AACA,aAAK,kBAAL,CAAwB,IAAxB,CAA6B,gBAA7B;AACA,aAAK,wBAAL,CAA8B,GAA9B,CAAkC,OAAO,CAAC,MAA1C,EAAkD,gBAAlD;AACD;;AACD,UAAI,CAAC,kBAAkB,CAAC,QAApB,IAAgC,OAAO,CAAC,QAA5C,EAAsD;AACpD,YAAI,UAAQ,GAAG,OAAO,CAAC,QAAR,IAAoB,EAAnC;;AACA,YAAI,UAAQ,CAAC,UAAT,KAAwB,OAA5B,EAAqC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAM,OAAK,GAAyB,EAApC;AACA,UAAA,MAAM,CAAC,IAAP,CAAY,UAAZ,EAAsB,OAAtB,CAA8B,UAAC,QAAD,EAAS;AACrC,gBAAI,QAAQ,KAAK,YAAjB,EAA+B;AAC7B,cAAA,OAAK,CAAC,QAAD,CAAL,GAAkB,UAAQ,CAAC,QAAD,CAA1B;AACD;AACF,WAJD;AAKA,UAAA,UAAQ,GAAG,OAAX;AACD,SAhBD,MAgBO,IAAI,MAAM,CAAC,UAAD,CAAV,EAAsB;AAC3B,cAAI,CAAC,cAAc,CAAC,UAAD,CAAf,IAA6B,CAAC,sBAAsB,CAAC,UAAD,CAAxD,EAAoE;AAClE;AACA,YAAA,UAAQ,GAAG;AACT,cAAA,UAAU,EAAE,OADH;AAET,cAAA,OAAO,EAAE;AAFA,aAAX;AAID;AACF,SA1BmD,CA2BpD;AACA;;;AACA,QAAA,kBAAkB,CAAC,QAAnB,GAA8B,UAA9B;AACA,QAAA,gBAAgB,CAAC,QAAjB,GAA4B,KAAK,YAAL,CAAkB,UAAlB,EAA0B;AAAA;AAA1B,SAA5B;;AACA,YAAI,UAAQ,YAAY,eAAA,CAAA,YAApB,IACA,KAAK,eAAL,CAAqB,aAArB,CAAmC,UAAQ,CAAC,QAA5C,CADJ,EAC2D;AACzD,cAAM,iBAAiB,GAAG,KAAK,OAAL,CAAa,KAAK,aAAL,CAAmB,GAAnB,CAAuB,UAAvB,CAAb,CAA1B;;AACA,cAAI,CAAC,MAAA,CAAA,eAAA,CAAgB,iBAAiB,CAAC,IAAlC,CAAL,EAA8C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAK,YAAL,CAAkB,GAAlB,CAAsB,iBAAtB,EAAyC,OAAO,CAAC,MAAjD;AACD;AACF;AACF;;AACD,UAAI,CAAC,kBAAkB,CAAC,IAApB,IAA4B,OAAO,CAAC,IAAxC,EAA8C;AAC5C,QAAA,kBAAkB,CAAC,IAAnB,GAA0B,OAAO,CAAC,IAAlC,CAD4C,CAE5C;AACA;AACA;;AACA,QAAA,gBAAgB,CAAC,IAAjB,GAAwB,KAAK,YAAL,CAAkB,OAAO,CAAC,IAA1B,EAA8B;AAAA;AAA9B,SAAxB,CAL4C,CAM5C;AACA;;AACA,YAAI,OAAO,CAAC,IAAR,CAAa,WAAb,KAA6B,kBAAA,CAAA,kBAAA,CAAmB,QAApD,EAA8D;AAC5D,cAAM,eAAe,GAA2B,OAAO,CAAC,IAAxD;AACA,UAAA,eAAe,CAAC,kBAAhB,CAAmC,MAAnC,CAA0C,eAAe,CAAC,aAA1D,EAAyE,OAAzE,CAAiF,UAAC,EAAD,EAAG;AAClF,gBAAM,MAAM,GAAiB,EAAE,CAAC,SAAhC;;AACA,gBAAI,KAAI,CAAC,eAAL,CAAqB,aAArB,CAAmC,MAAM,CAAC,QAA1C,KACA,CAAC,KAAI,CAAC,kCAAL,CAAwC,GAAxC,CAA4C,MAA5C,CADL,EAC0D;AACxD,kBAAM,SAAO,GAAG,KAAI,CAAC,eAAL,CAAqB,cAArB,CAAoC,MAApC,CAAhB;;AACA,kBAAI,SAAJ,EAAa;AACX,gBAAA,KAAI,CAAC,UAAL,CAAgB,SAAhB;AACD;AACF;AACF,WATD;AAUD;AACF;AACF,KA7ED;AA+EA;;;;;AAKG;;;AACH,IAAA,gBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,6BAAV,EAAgD;AAAhD,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAM,QAAQ,GAA+C,EAA7D;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,SAAL,CAAe;AAC1B,QAAA,UAAU,EAAE,KAAK,UADS;AAE1B,QAAA,SAAS,EAAE,KAAK,kBAFU;AAG1B,QAAA,OAAO,EAAE,KAAK,OAAL,CAAa,GAAb,CAAiB,UAAC,MAAD,EAAS,KAAT,EAAc;AACtC,UAAA,MAAM,CAAC,eAAP;AACA,cAAI,QAAQ,GAAkB,SAA9B;;AACA,cAAI,KAAI,CAAC,eAAL,CAAqB,aAArB,CAAmC,MAAM,CAAC,QAA1C,CAAJ,EAAyD;AACvD,gBAAM,cAAc,GAAG,KAAI,CAAC,YAAL,CAAkB,GAAlB,CAAsB,MAAtB,CAAvB;;AACA,gBAAI,cAAJ,EAAoB;AAClB;AACA;AACA;AACA;AACA,cAAA,QAAQ,GAAG,KAAI,CAAC,aAAL,CAAmB,GAAnB,CAAuB,cAAvB,CAAX;AACD,aAND,MAMO,IAAI,6BAAJ,EAAmC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAM,OAAO,GAAG,KAAI,CAAC,kCAAL,CAAwC,GAAxC,CAA4C,MAA5C,CAAhB;;AACA,kBAAI,CAAC,OAAD,IAAY,CAAC,OAAO,CAAC,QAArB,IAAiC,OAAO,CAAC,QAAR,CAAiB,UAAjB,KAAgC,WAArE,EAAkF;AAChF,gBAAA,QAAQ,GAAM,MAAM,CAAC,IAAP,GAAW,GAAX,GAAe,KAA7B;AACA,gBAAA,QAAQ,CAAC,IAAT,CAAc;AAAC,kBAAA,MAAM,EAAA,MAAP;AAAS,kBAAA,QAAQ,EAAE;AAAnB,iBAAd;AACD;AACF;AACF;;AACD,iBAAO;AACL,YAAA,QAAQ,EAAE,KADL;AAEL,YAAA,IAAI,EAAE,MAAM,CAAC,IAFR;AAGL,YAAA,QAAQ,EAAE,KAAI,CAAC,eAAL,CAAqB,iBAArB,CAAuC,MAAM,CAAC,QAA9C,EAAwD,KAAI,CAAC,WAA7D,CAHL;AAIL,YAAA,QAAQ,EAAE;AAJL,WAAP;AAMD,SA/BQ;AAHiB,OAAf,CAAb;AAoCA,aAAO;AAAC,QAAA,IAAI,EAAA,IAAL;AAAO,QAAA,QAAQ,EAAA;AAAf,OAAP;AACD,KAxCD;;AA0CQ,IAAA,gBAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAqB,KAArB,EAAiC,KAAjC,EAA0D;AACxD,aAAO,MAAA,CAAA,UAAA,CAAW,KAAX,EAAkB,IAAlB,EAAwB,KAAxB,CAAP;AACD,KAFO;;AAIR,IAAA,gBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,KAAX,EAAuB,OAAvB,EAAmC;AACjC,UAAI,KAAK,YAAY,eAAA,CAAA,YAArB,EAAmC;AACjC,YAAI,UAAU,GAAG,KAAK,cAAL,CAAoB,eAApB,CAAoC,KAAK,CAAC,QAA1C,EAAoD,KAAK,CAAC,IAA1D,CAAjB;AACA,YAAM,KAAK,GAAG,KAAK,iBAAL,CAAuB,UAAvB,EAAmC,OAAnC,CAAd;AACA,eAAO;AAAC,UAAA,QAAQ,EAAE,KAAX;AAAkB,UAAA,OAAO,EAAE,KAAK,CAAC;AAAjC,SAAP;AACD;AACF,KAND;AAQA;;;;;;AAMG;;;AACH,IAAA,gBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAA0C,OAA1C,EAAsD;AACpD,UAAI,GAAG,CAAC,YAAD,CAAH,KAAsB,UAA1B,EAAsC;AACpC,eAAO,MAAA,CAAA,UAAA,CAAW,GAAG,CAAC,QAAD,CAAd,EAA0B,IAA1B,EAAgC,OAAhC,CAAP;AACD;;AACD,UAAI,GAAG,CAAC,YAAD,CAAH,KAAsB,OAA1B,EAAmC;AACjC,eAAO,GAAG,CAAC,MAAD,CAAV;AACA,eAAO,GAAG,CAAC,WAAD,CAAV;AACD;;AACD,aAAO,MAAA,CAAA,SAAA,CAAM,cAAN,CAAoB,IAApB,CAAoB,IAApB,EAAqB,GAArB,EAA0B,OAA1B,CAAP;AACD,KATD;AAWA;;;AAGG;;;AACK,IAAA,gBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,UAA1B,EAAoD,KAApD,EAA6E;AAC3E,UAAI,KAAK,GAA0B,KAAK,aAAL,CAAmB,GAAnB,CAAuB,UAAvB,CAAnC;AACA,UAAI,OAAO,GAA+B,IAA1C;;AACA,UAAI,KAAK,GAAA;AAAA;AAAL,SACA,KAAK,eAAL,CAAqB,aAArB,CAAmC,UAAU,CAAC,QAA9C,CADJ,EAC6D;AAC3D,YAAI,KAAK,kCAAL,CAAwC,GAAxC,CAA4C,UAA5C,CAAJ,EAA6D;AAC3D;AACA;AACA,iBAAO,KAAP;AACD;;AACD,QAAA,OAAO,GAAG,KAAK,WAAL,CAAiB,UAAjB,CAAV;;AACA,YAAI,OAAO,IAAI,OAAO,CAAC,QAAR,YAA4B,eAAA,CAAA,YAA3C,EAAyD;AACvD;AACA,UAAA,KAAK,GAAG,KAAK,iBAAL,CAAuB,OAAO,CAAC,QAA/B,EAAyC,KAAzC,CAAR,CAFuD,CAGvD;;AACA,UAAA,OAAO,GAAG,IAAV;AACD;AACF,OAdD,MAcO,IAAI,KAAK,IAAI,IAAb,EAAmB;AACxB;AACA;AACA,eAAO,KAAP;AACD,OArB0E,CAsB3E;;;AACA,UAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,QAAA,KAAK,GAAG,KAAK,OAAL,CAAa,MAArB;AACA,aAAK,OAAL,CAAa,IAAb,CAAkB,UAAlB;AACD;;AACD,WAAK,aAAL,CAAmB,GAAnB,CAAuB,UAAvB,EAAmC,KAAnC;;AACA,UAAI,OAAJ,EAAa;AACX,aAAK,UAAL,CAAgB,OAAhB;AACD;;AACD,aAAO,KAAP;AACD,KAhCO;;AAkCA,IAAA,gBAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,MAApB,EAAwC;AACtC,UAAI,OAAO,GAAG,KAAK,eAAL,CAAqB,cAArB,CAAoC,MAApC,CAAd;;AACA,UAAI,CAAC,OAAL,EAAc;AACZ;AACA;AACA;AACA,YAAM,cAAc,GAAG,KAAK,cAAL,CAAoB,aAApB,CAAkC,MAAlC,CAAvB;;AACA,YAAI,cAAJ,EAAoB;AAClB,UAAA,OAAO,GAAG;AAAC,YAAA,MAAM,EAAE,cAAc,CAAC,MAAxB;AAAgC,YAAA,QAAQ,EAAE,cAAc,CAAC;AAAzD,WAAV;AACD;AACF;;AACD,aAAO,OAAP;AACD,KAZO;;AAaV,WAAA,gBAAA;AAAC,GApOD,CAA+B,MAAA,CAAA,gBAA/B,CAAA;;AAsOA,MAAA,gBAAA;AAAA;AAAA,cAAA;AAQE,aAAA,gBAAA,CACY,SADZ,EAC8C,cAD9C,EAEY,eAFZ,EAE0D;AAD9C,WAAA,SAAA,GAAA,SAAA;AAAkC,WAAA,cAAA,GAAA,cAAA;AAClC,WAAA,eAAA,GAAA,eAAA;AATJ,WAAA,IAAA,GAKH,EALG;AASsD;;AAE9D,IAAA,gBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UACI,OADJ,EAEI,QAFJ,EAGuB;AACrB,WAAK,IAAL,CAAU,IAAV,CAAe;AAAC,QAAA,OAAO,EAAA,OAAR;AAAU,QAAA,QAAQ,EAAA,QAAlB;AAAoB,QAAA,SAAS,EAAE;AAA/B,OAAf;AACD,KALD;;AAOA,IAAA,gBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,OAAX,EAAsC;AACpC,WAAK,IAAL,CAAU,IAAV,CAAe;AAAC,QAAA,OAAO,EAAA,OAAR;AAAU,QAAA,QAAQ,EAAE,IAApB;AAA0B,QAAA,SAAS,EAAE;AAArC,OAAf;AACD,KAFD;;AAIA,IAAA,gBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,WAAV,EAAiE;;;AAAjE,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,gBAAgB,GAAG,IAAI,GAAJ,EAAzB;;;AACA,aAAiC,IAAA,aAAA,GAAA,OAAA,CAAA,QAAA,CAAA,WAAA,CAAA,EAAW,eAAA,GAAA,aAAA,CAAA,IAAA,EAA5C,EAA4C,CAAA,eAAA,CAAA,IAA5C,EAA4C,eAAA,GAAA,aAAA,CAAA,IAAA,EAA5C,EAA8C;AAAnC,cAAA,EAAA,GAAA,eAAA,CAAA,KAAA;AAAA,cAAC,MAAM,GAAA,EAAA,CAAA,MAAP;AAAA,cAAS,QAAQ,GAAA,EAAA,CAAA,QAAjB;AACT,UAAA,gBAAgB,CAAC,GAAjB,CAAqB,MAArB,EAA6B,QAA7B;AACD;;;;;;;;;;;;;AACD,UAAM,eAAe,GAAG,IAAI,GAAJ,EAAxB;;;AAEA,aAA6C,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,IAAL,CAAA,EAAS,EAAA,GAAA,EAAA,CAAA,IAAA,EAAtD,EAAsD,CAAA,EAAA,CAAA,IAAtD,EAAsD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAtD,EAAwD;AAA7C,cAAA,EAAA,GAAA,EAAA,CAAA,KAAA;AAAA,cAAC,OAAO,GAAA,EAAA,CAAA,OAAR;AAAA,cAAU,QAAQ,GAAA,EAAA,CAAA,QAAlB;AAAA,cAAoB,SAAS,GAAA,EAAA,CAAA,SAA7B;;AACT,cAAI,OAAO,CAAC,WAAR,KAAwB,kBAAA,CAAA,kBAAA,CAAmB,QAA/C,EAAyD;AACvD;AACA;AACA;AACA;AACA,YAAA,eAAe,CAAC,GAAhB,CAAoB,OAAO,CAAC,IAAR,CAAa,SAAjC;AACA,gBAAM,UAAU,GAA2B,OAA3C;;;AACA,mBAAkB,IAAA,EAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,UAAU,CAAC,OAAX,CAAA,CAAA,EAAkB,EAAA,GAAA,EAAA,CAAA,IAAA,EAApC,EAAoC,CAAA,EAAA,CAAA,IAApC,EAAoC,EAAA,GAAA,EAAA,CAAA,IAAA,EAApC,EAAsC;AAAjC,oBAAM,GAAG,GAAA,EAAA,CAAA,KAAT;AACH,gBAAA,eAAe,CAAC,GAAhB,CAAoB,GAAG,CAAC,SAAxB;AACD;;;;;;;;;;;;AACF;;AACD,cAAI,CAAC,SAAL,EAAgB;AACd,gBAAM,MAAM,GAAG,MAAA,CAAA,iBAAA,CAAkB,OAAO,CAAC,IAAR,CAAa,SAAb,CAAuB,IAAzC,CAAf;AACA,YAAA,2BAA2B,CACvB,KAAK,SADkB,EACP,OAAO,CAAC,IAAR,CAAa,SADN,EAEvB,KAAK,wBAAL,CAA8B,OAA9B,EAAuC,QAAvC,CAFuB,CAA3B;AAGD;AACF;;;;;;;;;;;;;AAED,MAAA,eAAe,CAAC,OAAhB,CAAwB,UAAC,cAAD,EAAe;AACrC,YAAI,KAAI,CAAC,eAAL,CAAqB,aAArB,CAAmC,cAAc,CAAC,QAAlD,CAAJ,EAAiE;AAC/D,cAAI,QAAQ,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,cAArB,KAAwC,cAAc,CAAC,IAAtE;AACA,cAAM,eAAe,GAAG,MAAA,CAAA,iBAAA,CAAkB,QAAlB,CAAxB;;AACA,UAAA,KAAI,CAAC,SAAL,CAAe,UAAf,CAA0B,IAA1B,CAA+B,CAAC,CAAC,QAAF,CAAW,eAAX,EACK,GADL,CACS,KAAI,CAAC,mBAAL,CAAyB,cAAzB,CADT,EAEK,UAFL,CAEgB,IAFhB,EAEsB,CAAC,CAAC,CAAC,YAAF,CAAe,QAAhB,CAFtB,CAA/B;AAGD;AACF,OARD;AASD,KApCD;;AAsCQ,IAAA,gBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UACI,OADJ,EAEI,QAFJ,EAGuB;AAHvB,UAAA,KAAA,GAAA,IAAA;;AAIE,UAAM,WAAW,GAAmB,CAAC,KAAK,gBAAL,CAAsB,OAAtB,CAAD,CAApC;AACA,UAAI,SAAS,GAA8B,EAA3C;;AACA,UAAI,QAAQ,YAAY,kBAAA,CAAA,uBAAxB,EAAiD;AAC/C,QAAA,WAAW,CAAC,IAAZ,CAAgB,KAAhB,CAAA,WAAA,EAAW,OAAA,CAAA,QAAA,EACM;AACA;AACA;AACA,QAAA,QAAQ,CAAC,kBAAT,CAA4B,MAA5B,CAAmC,QAAQ,CAAC,aAA5C,EACK,GADL,CACS,UAAA,IAAA,EAAI;AAAI,iBAAA,IAAI,CAAJ,SAAA;AAAc,SAD/B,EAEI;AACA;AACA;AACA;AALJ,SAMK,MANL,CAMY,QAAQ,CAAC,gBAAT,CAA0B,OAA1B,CAAkC,GAAlC,CAAsC,UAAA,IAAA,EAAI;AAAI,iBAAA,IAAI,CAAJ,SAAA;AAAc,SAA5D,EACK,MADL,CACY,UAAA,GAAA,EAAG;AAAI,iBAAA,GAAG,KAAK,QAAQ,CAAC,IAAT,CAAR,SAAA;AAA+B,SADlD,CANZ,EAQK,GARL,CAQS,UAAC,GAAD,EAAI;AAAK,iBAAA,KAAI,CAAC,mBAAL,CAAA,GAAA,CAAA;AAA6B,SAR/C,CAJN,CAAX,EAD+C,CAc/C;AACA;;AACA,QAAA,SAAS,GAAG,QAAQ,CAAC,SAArB;AACD,OAjBD,MAiBO,IAAI,OAAO,CAAC,WAAR,KAAwB,kBAAA,CAAA,kBAAA,CAAmB,SAA/C,EAA0D;AAC/D,YAAM,UAAU,GAA4B,OAA5C;AACA,QAAA,SAAS,GAAG,UAAU,CAAC,SAAX,CAAqB,MAArB,CAA4B,UAAU,CAAC,aAAvC,CAAZ;AACD,OAvBoB,CAwBrB;AACA;AACA;AACA;;;AACA,MAAA,WAAW,CAAC,IAAZ,CAAgB,KAAhB,CAAA,WAAA,EAAW,OAAA,CAAA,QAAA,CACJ,SAAS,CAAC,MAAV,CAAiB,UAAA,QAAA,EAAQ;AAAI,eAAA,CAAC,CAAC,QAAQ,CAAV,QAAA;AAAmB,OAAhD,EAAkD,GAAlD,CAAsD,UAAA,QAAA,EAAQ;AAAI,eAAA,KAAI,CAAC,gBAAL,CAAsB;AACzF,UAAA,WAAW,EAAE,kBAAA,CAAA,kBAAA,CAAmB,UADyD;AAEzF,UAAA,IAAI,EAAE,QAAQ,CAAC;AAF0E,SAAtB,CAAA;AAG7C,OAHrB,CADI,CAAX;AAKA,aAAO,CAAC,CAAC,UAAF,CAAa,WAAb,CAAP;AACD,KArCO;;AAuCA,IAAA,gBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,UAA5B,EAAoD;AAClD,UAAM,iBAAiB,GAAG,KAAK,cAAL,CAAoB,eAApB,CACtB,MAAA,CAAA,qBAAA,CAAsB,UAAU,CAAC,QAAjC,CADsB,EACsB,MAAA,CAAA,iBAAA,CAAkB,UAAU,CAAC,IAA7B,CADtB,CAA1B;AAEA,aAAO,KAAK,SAAL,CAAe,UAAf,CAA0B,iBAA1B,CAAP;AACD,KAJO;;AAMA,IAAA,gBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,IAAzB,EAAmD;AACjD,UAAM,SAAS,GAAG,KAAK,SAAvB;;AAEA,UAAA,WAAA;AAAA;AAAA,kBAAA;AAAA,iBAAA,WAAA,GAAA,CAkBC;;AAjBC,QAAA,WAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,GAAX,EAAuB,OAAvB,EAAmC;AAAnC,cAAA,KAAA,GAAA,IAAA;;AACE,iBAAO,CAAC,CAAC,UAAF,CAAa,GAAG,CAAC,GAAJ,CAAQ,UAAA,KAAA,EAAK;AAAI,mBAAA,MAAA,CAAA,UAAA,CAAW,KAAX,EAAkB,KAAlB,EAAA,OAAA,CAAA;AAAgC,WAAjD,CAAb,CAAP;AACD,SAFD;;AAGA,QAAA,WAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAA0C,OAA1C,EAAsD;AAAtD,cAAA,KAAA,GAAA,IAAA;;AACE,iBAAO,IAAI,CAAC,CAAC,cAAN,CAAqB,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,GAAjB,CACxB,UAAC,GAAD,EAAI;AAAK,mBAAA,IAAI,CAAC,CAAC,eAAN,CAAsB,GAAtB,EAA2B,MAAA,CAAA,UAAA,CAAW,GAAG,CAAC,GAAD,CAAd,EAAqB,KAArB,EAA2B,OAA3B,CAA3B,EAAA,KAAA,CAAA;AAAsE,WADvD,CAArB,CAAP;AAED,SAHD;;AAIA,QAAA,WAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,KAAf,EAA2B,OAA3B,EAAuC;AACrC,iBAAO,CAAC,CAAC,OAAF,CAAU,KAAV,CAAP;AACD,SAFD;;AAGA,QAAA,WAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,KAAX,EAAuB,OAAvB,EAAmC;AACjC,cAAI,KAAK,YAAY,eAAA,CAAA,YAArB,EAAmC;AACjC,mBAAO,SAAS,CAAC,UAAV,CAAqB,KAArB,CAAP;AACD,WAFD,MAEO;AACL,kBAAM,IAAI,KAAJ,CAAU,sCAAoC,KAA9C,CAAN;AACD;AACF,SAND;;AAOF,eAAA,WAAA;AAAC,OAlBD,EAAA;;AAoBA,aAAO,MAAA,CAAA,UAAA,CAAW,IAAX,EAAiB,IAAI,WAAJ,EAAjB,EAAoC,IAApC,CAAP;AACD,KAxBO;;AAyBV,WAAA,gBAAA;AAAC,GAnID,EAAA;;AAqIA,MAAA,oBAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAmC,IAAA,OAAA,CAAA,SAAA,CAAA,oBAAA,EAAA,MAAA;;AAIjC,aAAA,oBAAA,CACY,WADZ,EAEY,eAFZ,EAE0D;AAF1D,UAAA,KAAA,GAGE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IAHT;;AACY,MAAA,KAAA,CAAA,WAAA,GAAA,WAAA;AACA,MAAA,KAAA,CAAA,eAAA,GAAA,eAAA;;AAEX;;AAED,IAAA,oBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,eAAZ,EAAqC,IAArC,EAAiD;AAAjD,UAAA,KAAA,GAAA,IAAA;;AAKE,UAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAb;AACA,UAAM,WAAW,GAAqD,EAAtE;AACA,WAAK,OAAL,GAAe,IAAI,CAAC,OAAL,CAAa,GAAb,CACX,UAAC,gBAAD,EAAiB;AAAK,eAAA,KAAI,CAAC,WAAL,CAAiB,GAAjB,CAClB,KAAI,CAAC,eAAL,CAAqB,mBAArB,CAAyC,gBAAgB,CAAC,QAA1D,EAAoE,eAApE,CADkB,EAElB,gBAAgB,CAFE,IAAA,CAAA;AAEI,OAHf,CAAf;AAIA,MAAA,IAAI,CAAC,OAAL,CAAa,OAAb,CAAqB,UAAC,gBAAD,EAAmB,KAAnB,EAAwB;AAC3C,YAAM,MAAM,GAAG,KAAI,CAAC,OAAL,CAAa,KAAb,CAAf;AACA,YAAM,QAAQ,GAAG,gBAAgB,CAAC,QAAlC;;AACA,YAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,UAAA,WAAW,CAAC,IAAZ,CAAiB;AAAC,YAAA,MAAM,EAAA,MAAP;AAAS,YAAA,QAAQ,EAAE,KAAI,CAAC,OAAL,CAAa,QAAb;AAAnB,WAAjB;AACD,SAFD,MAEO,IAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AACvC,UAAA,WAAW,CAAC,IAAZ,CACI;AAAC,YAAA,MAAM,EAAA,MAAP;AAAS,YAAA,QAAQ,EAAE,KAAI,CAAC,WAAL,CAAiB,GAAjB,CAAqB,MAAA,CAAA,iBAAA,CAAkB,eAAlB,CAArB,EAAyD,QAAzD;AAAnB,WADJ;AAED;AACF,OATD;AAUA,UAAM,SAAS,GAAG,MAAA,CAAA,UAAA,CAAW,IAAI,CAAC,SAAhB,EAA2B,IAA3B,EAAiC,IAAjC,CAAlB;AACA,aAAO;AAAC,QAAA,UAAU,EAAE,IAAI,CAAC,UAAlB;AAA8B,QAAA,SAAS,EAAA,SAAvC;AAAyC,QAAA,QAAQ,EAAE;AAAnD,OAAP;AACD,KAvBD;;AAyBA,IAAA,oBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAA0C,OAA1C,EAAsD;AACpD,UAAI,cAAc,GAAlB,EAAuB;AACrB,YAAM,UAAU,GAAG,KAAK,OAAL,CAAa,GAAG,CAAC,UAAD,CAAhB,CAAnB;AACA,YAAM,OAAO,GAAG,GAAG,CAAC,SAAD,CAAnB;AACA,eAAO,OAAO,CAAC,MAAR,GAAiB,KAAK,WAAL,CAAiB,GAAjB,CAAqB,UAAU,CAAC,QAAhC,EAA0C,UAAU,CAAC,IAArD,EAA2D,OAA3D,CAAjB,GACiB,UADxB;AAED,OALD,MAKO;AACL,eAAO,MAAA,CAAA,SAAA,CAAM,cAAN,CAAoB,IAApB,CAAoB,IAApB,EAAqB,GAArB,EAA0B,OAA1B,CAAP;AACD;AACF,KATD;;AAUF,WAAA,oBAAA;AAAC,GA7CD,CAAmC,MAAA,CAAA,gBAAnC,CAAA;;AA+CA,WAAS,MAAT,CAAgB,QAAhB,EAA6B;AAC3B,WAAO,QAAQ,IAAI,QAAQ,CAAC,UAAT,KAAwB,MAA3C;AACD;;AAED,WAAS,cAAT,CAAwB,QAAxB,EAAqC;AACnC,WAAO,MAAM,CAAC,QAAD,CAAN,IAAoB,wBAAA,CAAA,sBAAA,CAAuB,QAAQ,CAAC,UAAhC,aAAuD,eAAA,CAAA,YAAlF;AACD;;AAED,WAAS,sBAAT,CAAgC,QAAhC,EAA6C;AAC3C,WAAO,MAAM,CAAC,QAAD,CAAN,IAAoB,QAAQ,CAAC,UAA7B,IAA2C,QAAQ,CAAC,UAAT,CAAoB,UAApB,KAAmC,QAA9E,IACH,wBAAA,CAAA,sBAAA,CAAuB,QAAQ,CAAC,UAAT,CAAoB,UAA3C,aAAkE,eAAA,CAAA,YADtE;AAED","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {CompileDirectiveMetadata, CompileDirectiveSummary, CompileNgModuleMetadata, CompileNgModuleSummary, CompilePipeMetadata, CompileProviderMetadata, CompileSummaryKind, CompileTypeMetadata, CompileTypeSummary} from '../compile_metadata';\nimport * as o from '../output/output_ast';\nimport {Summary, SummaryResolver} from '../summary_resolver';\nimport {OutputContext, ValueTransformer, ValueVisitor, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {ResolvedStaticSymbol, StaticSymbolResolver, unwrapResolvedMetadata} from './static_symbol_resolver';\nimport {isLoweredSymbol, ngfactoryFilePath, summaryForJitFileName, summaryForJitName} from './util';\n\nexport function serializeSummaries(\n    srcFileName: string, forJitCtx: OutputContext|null,\n    summaryResolver: SummaryResolver<StaticSymbol>, symbolResolver: StaticSymbolResolver,\n    symbols: ResolvedStaticSymbol[], types: {\n      summary: CompileTypeSummary,\n      metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n      CompileTypeMetadata\n    }[],\n    createExternalSymbolReexports =\n        false): {json: string, exportAs: {symbol: StaticSymbol, exportAs: string}[]} {\n  const toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName);\n\n  // for symbols, we use everything except for the class metadata itself\n  // (we keep the statics though), as the class metadata is contained in the\n  // CompileTypeSummary.\n  symbols.forEach(\n      (resolvedSymbol) => toJsonSerializer.addSummary(\n          {symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata}));\n\n  // Add type summaries.\n  types.forEach(({summary, metadata}) => {\n    toJsonSerializer.addSummary(\n        {symbol: summary.type.reference, metadata: undefined, type: summary});\n  });\n  const {json, exportAs} = toJsonSerializer.serialize(createExternalSymbolReexports);\n  if (forJitCtx) {\n    const forJitSerializer = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);\n    types.forEach(({summary, metadata}) => {\n      forJitSerializer.addSourceType(summary, metadata);\n    });\n    toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach((summary) => {\n      if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {\n        forJitSerializer.addLibType(summary.type);\n      }\n    });\n    forJitSerializer.serialize(exportAs);\n  }\n  return {json, exportAs};\n}\n\nexport function deserializeSummaries(\n    symbolCache: StaticSymbolCache, summaryResolver: SummaryResolver<StaticSymbol>,\n    libraryFileName: string, json: string): {\n  moduleName: string|null,\n  summaries: Summary<StaticSymbol>[],\n  importAs: {symbol: StaticSymbol, importAs: StaticSymbol}[]\n} {\n  const deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);\n  return deserializer.deserialize(libraryFileName, json);\n}\n\nexport function createForJitStub(outputCtx: OutputContext, reference: StaticSymbol) {\n  return createSummaryForJitFunction(outputCtx, reference, o.NULL_EXPR);\n}\n\nfunction createSummaryForJitFunction(\n    outputCtx: OutputContext, reference: StaticSymbol, value: o.Expression) {\n  const fnName = summaryForJitName(reference.name);\n  outputCtx.statements.push(\n      o.fn([], [new o.ReturnStatement(value)], new o.ArrayType(o.DYNAMIC_TYPE)).toDeclStmt(fnName, [\n        o.StmtModifier.Final, o.StmtModifier.Exported\n      ]));\n}\n\nconst enum SerializationFlags {\n  None = 0,\n  ResolveValue = 1,\n}\n\nclass ToJsonSerializer extends ValueTransformer {\n  // Note: This only contains symbols without members.\n  private symbols: StaticSymbol[] = [];\n  private indexBySymbol = new Map<StaticSymbol, number>();\n  private reexportedBy = new Map<StaticSymbol, StaticSymbol>();\n  // This now contains a `__symbol: number` in the place of\n  // StaticSymbols, but otherwise has the same shape as the original objects.\n  private processedSummaryBySymbol = new Map<StaticSymbol, any>();\n  private processedSummaries: any[] = [];\n  private moduleName: string|null;\n\n  unprocessedSymbolSummariesBySymbol = new Map<StaticSymbol, Summary<StaticSymbol>>();\n\n  constructor(\n      private symbolResolver: StaticSymbolResolver,\n      private summaryResolver: SummaryResolver<StaticSymbol>, private srcFileName: string) {\n    super();\n    this.moduleName = symbolResolver.getKnownModuleName(srcFileName);\n  }\n\n  addSummary(summary: Summary<StaticSymbol>) {\n    let unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);\n    let processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n    if (!unprocessedSummary) {\n      unprocessedSummary = {symbol: summary.symbol, metadata: undefined};\n      this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);\n      processedSummary = {symbol: this.processValue(summary.symbol, SerializationFlags.None)};\n      this.processedSummaries.push(processedSummary);\n      this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n    }\n    if (!unprocessedSummary.metadata && summary.metadata) {\n      let metadata = summary.metadata || {};\n      if (metadata.__symbolic === 'class') {\n        // For classes, we keep everything except their class decorators.\n        // We need to keep e.g. the ctor args, method names, method decorators\n        // so that the class can be extended in another compilation unit.\n        // We don't keep the class decorators as\n        // 1) they refer to data\n        //   that should not cause a rebuild of downstream compilation units\n        //   (e.g. inline templates of @Component, or @NgModule.declarations)\n        // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n        const clone: {[key: string]: any} = {};\n        Object.keys(metadata).forEach((propName) => {\n          if (propName !== 'decorators') {\n            clone[propName] = metadata[propName];\n          }\n        });\n        metadata = clone;\n      } else if (isCall(metadata)) {\n        if (!isFunctionCall(metadata) && !isMethodCallOnVariable(metadata)) {\n          // Don't store complex calls as we won't be able to simplify them anyways later on.\n          metadata = {\n            __symbolic: 'error',\n            message: 'Complex function calls are not supported.',\n          };\n        }\n      }\n      // Note: We need to keep storing ctor calls for e.g.\n      // `export const x = new InjectionToken(...)`\n      unprocessedSummary.metadata = metadata;\n      processedSummary.metadata = this.processValue(metadata, SerializationFlags.ResolveValue);\n      if (metadata instanceof StaticSymbol &&\n          this.summaryResolver.isLibraryFile(metadata.filePath)) {\n        const declarationSymbol = this.symbols[this.indexBySymbol.get(metadata)!];\n        if (!isLoweredSymbol(declarationSymbol.name)) {\n          // Note: symbols that were introduced during codegen in the user file can have a reexport\n          // if a user used `export *`. However, we can't rely on this as tsickle will change\n          // `export *` into named exports, using only the information from the typechecker.\n          // As we introduce the new symbols after typecheck, Tsickle does not know about them,\n          // and omits them when expanding `export *`.\n          // So we have to keep reexporting these symbols manually via .ngfactory files.\n          this.reexportedBy.set(declarationSymbol, summary.symbol);\n        }\n      }\n    }\n    if (!unprocessedSummary.type && summary.type) {\n      unprocessedSummary.type = summary.type;\n      // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n      // as the type summaries already contain the transitive data that they require\n      // (in a minimal way).\n      processedSummary.type = this.processValue(summary.type, SerializationFlags.None);\n      // except for reexported directives / pipes, so we need to store\n      // their summaries explicitly.\n      if (summary.type.summaryKind === CompileSummaryKind.NgModule) {\n        const ngModuleSummary = <CompileNgModuleSummary>summary.type;\n        ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach((id) => {\n          const symbol: StaticSymbol = id.reference;\n          if (this.summaryResolver.isLibraryFile(symbol.filePath) &&\n              !this.unprocessedSymbolSummariesBySymbol.has(symbol)) {\n            const summary = this.summaryResolver.resolveSummary(symbol);\n            if (summary) {\n              this.addSummary(summary);\n            }\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * @param createExternalSymbolReexports Whether external static symbols should be re-exported.\n   * This can be enabled if external symbols should be re-exported by the current module in\n   * order to avoid dynamically generated module dependencies which can break strict dependency\n   * enforcements (as in Google3). Read more here: https://github.com/angular/angular/issues/25644\n   */\n  serialize(createExternalSymbolReexports: boolean):\n      {json: string, exportAs: {symbol: StaticSymbol, exportAs: string}[]} {\n    const exportAs: {symbol: StaticSymbol, exportAs: string}[] = [];\n    const json = JSON.stringify({\n      moduleName: this.moduleName,\n      summaries: this.processedSummaries,\n      symbols: this.symbols.map((symbol, index) => {\n        symbol.assertNoMembers();\n        let importAs: string|number = undefined!;\n        if (this.summaryResolver.isLibraryFile(symbol.filePath)) {\n          const reexportSymbol = this.reexportedBy.get(symbol);\n          if (reexportSymbol) {\n            // In case the given external static symbol is already manually exported by the\n            // user, we just proxy the external static symbol reference to the manual export.\n            // This ensures that the AOT compiler imports the external symbol through the\n            // user export and does not introduce another dependency which is not needed.\n            importAs = this.indexBySymbol.get(reexportSymbol)!;\n          } else if (createExternalSymbolReexports) {\n            // In this case, the given external static symbol is *not* manually exported by\n            // the user, and we manually create a re-export in the factory file so that we\n            // don't introduce another module dependency. This is useful when running within\n            // Bazel so that the AOT compiler does not introduce any module dependencies\n            // which can break the strict dependency enforcement. (e.g. as in Google3)\n            // Read more about this here: https://github.com/angular/angular/issues/25644\n            const summary = this.unprocessedSymbolSummariesBySymbol.get(symbol);\n            if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {\n              importAs = `${symbol.name}_${index}`;\n              exportAs.push({symbol, exportAs: importAs});\n            }\n          }\n        }\n        return {\n          __symbol: index,\n          name: symbol.name,\n          filePath: this.summaryResolver.toSummaryFileName(symbol.filePath, this.srcFileName),\n          importAs: importAs\n        };\n      })\n    });\n    return {json, exportAs};\n  }\n\n  private processValue(value: any, flags: SerializationFlags): any {\n    return visitValue(value, this, flags);\n  }\n\n  visitOther(value: any, context: any): any {\n    if (value instanceof StaticSymbol) {\n      let baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n      const index = this.visitStaticSymbol(baseSymbol, context);\n      return {__symbol: index, members: value.members};\n    }\n  }\n\n  /**\n   * Strip line and character numbers from ngsummaries.\n   * Emitting them causes white spaces changes to retrigger upstream\n   * recompilations in bazel.\n   * TODO: find out a way to have line and character numbers in errors without\n   * excessive recompilation in bazel.\n   */\n  visitStringMap(map: {[key: string]: any}, context: any): any {\n    if (map['__symbolic'] === 'resolved') {\n      return visitValue(map['symbol'], this, context);\n    }\n    if (map['__symbolic'] === 'error') {\n      delete map['line'];\n      delete map['character'];\n    }\n    return super.visitStringMap(map, context);\n  }\n\n  /**\n   * Returns null if the options.resolveValue is true, and the summary for the symbol\n   * resolved to a type or could not be resolved.\n   */\n  private visitStaticSymbol(baseSymbol: StaticSymbol, flags: SerializationFlags): number {\n    let index: number|undefined|null = this.indexBySymbol.get(baseSymbol);\n    let summary: Summary<StaticSymbol>|null = null;\n    if (flags & SerializationFlags.ResolveValue &&\n        this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {\n      if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {\n        // the summary for this symbol was already added\n        // -> nothing to do.\n        return index!;\n      }\n      summary = this.loadSummary(baseSymbol);\n      if (summary && summary.metadata instanceof StaticSymbol) {\n        // The summary is a reexport\n        index = this.visitStaticSymbol(summary.metadata, flags);\n        // reset the summary as it is just a reexport, so we don't want to store it.\n        summary = null;\n      }\n    } else if (index != null) {\n      // Note: == on purpose to compare with undefined!\n      // No summary and the symbol is already added -> nothing to do.\n      return index;\n    }\n    // Note: == on purpose to compare with undefined!\n    if (index == null) {\n      index = this.symbols.length;\n      this.symbols.push(baseSymbol);\n    }\n    this.indexBySymbol.set(baseSymbol, index);\n    if (summary) {\n      this.addSummary(summary);\n    }\n    return index;\n  }\n\n  private loadSummary(symbol: StaticSymbol): Summary<StaticSymbol>|null {\n    let summary = this.summaryResolver.resolveSummary(symbol);\n    if (!summary) {\n      // some symbols might originate from a plain typescript library\n      // that just exported .d.ts and .metadata.json files, i.e. where no summary\n      // files were created.\n      const resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n      if (resolvedSymbol) {\n        summary = {symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata};\n      }\n    }\n    return summary;\n  }\n}\n\nclass ForJitSerializer {\n  private data: Array<{\n    summary: CompileTypeSummary,\n    metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n    CompileTypeMetadata|null,\n    isLibrary: boolean\n  }> = [];\n\n  constructor(\n      private outputCtx: OutputContext, private symbolResolver: StaticSymbolResolver,\n      private summaryResolver: SummaryResolver<StaticSymbol>) {}\n\n  addSourceType(\n      summary: CompileTypeSummary,\n      metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n      CompileTypeMetadata) {\n    this.data.push({summary, metadata, isLibrary: false});\n  }\n\n  addLibType(summary: CompileTypeSummary) {\n    this.data.push({summary, metadata: null, isLibrary: true});\n  }\n\n  serialize(exportAsArr: {symbol: StaticSymbol, exportAs: string}[]): void {\n    const exportAsBySymbol = new Map<StaticSymbol, string>();\n    for (const {symbol, exportAs} of exportAsArr) {\n      exportAsBySymbol.set(symbol, exportAs);\n    }\n    const ngModuleSymbols = new Set<StaticSymbol>();\n\n    for (const {summary, metadata, isLibrary} of this.data) {\n      if (summary.summaryKind === CompileSummaryKind.NgModule) {\n        // collect the symbols that refer to NgModule classes.\n        // Note: we can't just rely on `summary.type.summaryKind` to determine this as\n        // we don't add the summaries of all referenced symbols when we serialize type summaries.\n        // See serializeSummaries for details.\n        ngModuleSymbols.add(summary.type.reference);\n        const modSummary = <CompileNgModuleSummary>summary;\n        for (const mod of modSummary.modules) {\n          ngModuleSymbols.add(mod.reference);\n        }\n      }\n      if (!isLibrary) {\n        const fnName = summaryForJitName(summary.type.reference.name);\n        createSummaryForJitFunction(\n            this.outputCtx, summary.type.reference,\n            this.serializeSummaryWithDeps(summary, metadata!));\n      }\n    }\n\n    ngModuleSymbols.forEach((ngModuleSymbol) => {\n      if (this.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {\n        let exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;\n        const jitExportAsName = summaryForJitName(exportAs);\n        this.outputCtx.statements.push(o.variable(jitExportAsName)\n                                           .set(this.serializeSummaryRef(ngModuleSymbol))\n                                           .toDeclStmt(null, [o.StmtModifier.Exported]));\n      }\n    });\n  }\n\n  private serializeSummaryWithDeps(\n      summary: CompileTypeSummary,\n      metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n      CompileTypeMetadata): o.Expression {\n    const expressions: o.Expression[] = [this.serializeSummary(summary)];\n    let providers: CompileProviderMetadata[] = [];\n    if (metadata instanceof CompileNgModuleMetadata) {\n      expressions.push(...\n                       // For directives / pipes, we only add the declared ones,\n                       // and rely on transitively importing NgModules to get the transitive\n                       // summaries.\n                       metadata.declaredDirectives.concat(metadata.declaredPipes)\n                           .map(type => type.reference)\n                           // For modules,\n                           // we also add the summaries for modules\n                           // from libraries.\n                           // This is ok as we produce reexports for all transitive modules.\n                           .concat(metadata.transitiveModule.modules.map(type => type.reference)\n                                       .filter(ref => ref !== metadata.type.reference))\n                           .map((ref) => this.serializeSummaryRef(ref)));\n      // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\n      // and we already have transitive modules.\n      providers = metadata.providers;\n    } else if (summary.summaryKind === CompileSummaryKind.Directive) {\n      const dirSummary = <CompileDirectiveSummary>summary;\n      providers = dirSummary.providers.concat(dirSummary.viewProviders);\n    }\n    // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\n    // declaredDirectives / declaredPipes), as we allow\n    // providers without ctor arguments to skip the `@Injectable` decorator,\n    // i.e. we didn't generate .ngsummary.ts files for these.\n    expressions.push(\n        ...providers.filter(provider => !!provider.useClass).map(provider => this.serializeSummary({\n          summaryKind: CompileSummaryKind.Injectable,\n          type: provider.useClass\n        } as CompileTypeSummary)));\n    return o.literalArr(expressions);\n  }\n\n  private serializeSummaryRef(typeSymbol: StaticSymbol): o.Expression {\n    const jitImportedSymbol = this.symbolResolver.getStaticSymbol(\n        summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));\n    return this.outputCtx.importExpr(jitImportedSymbol);\n  }\n\n  private serializeSummary(data: {[key: string]: any}): o.Expression {\n    const outputCtx = this.outputCtx;\n\n    class Transformer implements ValueVisitor {\n      visitArray(arr: any[], context: any): any {\n        return o.literalArr(arr.map(entry => visitValue(entry, this, context)));\n      }\n      visitStringMap(map: {[key: string]: any}, context: any): any {\n        return new o.LiteralMapExpr(Object.keys(map).map(\n            (key) => new o.LiteralMapEntry(key, visitValue(map[key], this, context), false)));\n      }\n      visitPrimitive(value: any, context: any): any {\n        return o.literal(value);\n      }\n      visitOther(value: any, context: any): any {\n        if (value instanceof StaticSymbol) {\n          return outputCtx.importExpr(value);\n        } else {\n          throw new Error(`Illegal State: Encountered value ${value}`);\n        }\n      }\n    }\n\n    return visitValue(data, new Transformer(), null);\n  }\n}\n\nclass FromJsonDeserializer extends ValueTransformer {\n  // TODO(issue/24571): remove '!'.\n  private symbols!: StaticSymbol[];\n\n  constructor(\n      private symbolCache: StaticSymbolCache,\n      private summaryResolver: SummaryResolver<StaticSymbol>) {\n    super();\n  }\n\n  deserialize(libraryFileName: string, json: string): {\n    moduleName: string|null,\n    summaries: Summary<StaticSymbol>[],\n    importAs: {symbol: StaticSymbol, importAs: StaticSymbol}[]\n  } {\n    const data = JSON.parse(json) as {moduleName: string | null, summaries: any[], symbols: any[]};\n    const allImportAs: {symbol: StaticSymbol, importAs: StaticSymbol}[] = [];\n    this.symbols = data.symbols.map(\n        (serializedSymbol) => this.symbolCache.get(\n            this.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName),\n            serializedSymbol.name));\n    data.symbols.forEach((serializedSymbol, index) => {\n      const symbol = this.symbols[index];\n      const importAs = serializedSymbol.importAs;\n      if (typeof importAs === 'number') {\n        allImportAs.push({symbol, importAs: this.symbols[importAs]});\n      } else if (typeof importAs === 'string') {\n        allImportAs.push(\n            {symbol, importAs: this.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs)});\n      }\n    });\n    const summaries = visitValue(data.summaries, this, null) as Summary<StaticSymbol>[];\n    return {moduleName: data.moduleName, summaries, importAs: allImportAs};\n  }\n\n  visitStringMap(map: {[key: string]: any}, context: any): any {\n    if ('__symbol' in map) {\n      const baseSymbol = this.symbols[map['__symbol']];\n      const members = map['members'];\n      return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\n                              baseSymbol;\n    } else {\n      return super.visitStringMap(map, context);\n    }\n  }\n}\n\nfunction isCall(metadata: any): boolean {\n  return metadata && metadata.__symbolic === 'call';\n}\n\nfunction isFunctionCall(metadata: any): boolean {\n  return isCall(metadata) && unwrapResolvedMetadata(metadata.expression) instanceof StaticSymbol;\n}\n\nfunction isMethodCallOnVariable(metadata: any): boolean {\n  return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' &&\n      unwrapResolvedMetadata(metadata.expression.expression) instanceof StaticSymbol;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}