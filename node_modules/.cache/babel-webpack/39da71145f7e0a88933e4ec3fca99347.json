{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\", [\"require\", \"exports\", \"tslib\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isAccessExpression = exports.checkIfGenericTypesAreUnbound = exports.checkIfClassIsExported = exports.tsCallMethod = exports.tsCreateVariable = exports.tsCreateTypeQueryForCoercedInput = exports.tsDeclareVariable = exports.tsCreateElement = exports.tsCastToAny = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n  /**\n   * A `Set` of `ts.SyntaxKind`s of `ts.Expression` which are safe to wrap in a `ts.AsExpression`\n   * without needing to be wrapped in parentheses.\n   *\n   * For example, `foo.bar()` is a `ts.CallExpression`, and can be safely cast to `any` with\n   * `foo.bar() as any`. however, `foo !== bar` is a `ts.BinaryExpression`, and attempting to cast\n   * without the parentheses yields the expression `foo !== bar as any`. This is semantically\n   * equivalent to `foo !== (bar as any)`, which is not what was intended. Thus,\n   * `ts.BinaryExpression`s need to be wrapped in parentheses before casting.\n   */\n  //\n\n\n  var SAFE_TO_CAST_WITHOUT_PARENS = new Set([// Expressions which are already parenthesized can be cast without further wrapping.\n  ts.SyntaxKind.ParenthesizedExpression, // Expressions which form a single lexical unit leave no room for precedence issues with the cast.\n  ts.SyntaxKind.Identifier, ts.SyntaxKind.CallExpression, ts.SyntaxKind.NonNullExpression, ts.SyntaxKind.ElementAccessExpression, ts.SyntaxKind.PropertyAccessExpression, ts.SyntaxKind.ArrayLiteralExpression, ts.SyntaxKind.ObjectLiteralExpression, // The same goes for various literals.\n  ts.SyntaxKind.StringLiteral, ts.SyntaxKind.NumericLiteral, ts.SyntaxKind.TrueKeyword, ts.SyntaxKind.FalseKeyword, ts.SyntaxKind.NullKeyword, ts.SyntaxKind.UndefinedKeyword]);\n\n  function tsCastToAny(expr) {\n    // Wrap `expr` in parentheses if needed (see `SAFE_TO_CAST_WITHOUT_PARENS` above).\n    if (!SAFE_TO_CAST_WITHOUT_PARENS.has(expr.kind)) {\n      expr = ts.createParen(expr);\n    } // The outer expression is always wrapped in parentheses.\n\n\n    return ts.createParen(ts.createAsExpression(expr, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)));\n  }\n\n  exports.tsCastToAny = tsCastToAny;\n  /**\n   * Create an expression which instantiates an element by its HTML tagName.\n   *\n   * Thanks to narrowing of `document.createElement()`, this expression will have its type inferred\n   * based on the tag name, including for custom elements that have appropriate .d.ts definitions.\n   */\n\n  function tsCreateElement(tagName) {\n    var createElement = ts.createPropertyAccess(\n    /* expression */\n    ts.createIdentifier('document'), 'createElement');\n    return ts.createCall(\n    /* expression */\n    createElement,\n    /* typeArguments */\n    undefined,\n    /* argumentsArray */\n    [ts.createLiteral(tagName)]);\n  }\n\n  exports.tsCreateElement = tsCreateElement;\n  /**\n   * Create a `ts.VariableStatement` which declares a variable without explicit initialization.\n   *\n   * The initializer `null!` is used to bypass strict variable initialization checks.\n   *\n   * Unlike with `tsCreateVariable`, the type of the variable is explicitly specified.\n   */\n\n  function tsDeclareVariable(id, type) {\n    var decl = ts.createVariableDeclaration(\n    /* name */\n    id,\n    /* type */\n    type,\n    /* initializer */\n    ts.createNonNullExpression(ts.createNull()));\n    return ts.createVariableStatement(\n    /* modifiers */\n    undefined,\n    /* declarationList */\n    [decl]);\n  }\n\n  exports.tsDeclareVariable = tsDeclareVariable;\n  /**\n   * Creates a `ts.TypeQueryNode` for a coerced input.\n   *\n   * For example: `typeof MatInput.ngAcceptInputType_value`, where MatInput is `typeName` and `value`\n   * is the `coercedInputName`.\n   *\n   * @param typeName The `EntityName` of the Directive where the static coerced input is defined.\n   * @param coercedInputName The field name of the coerced input.\n   */\n\n  function tsCreateTypeQueryForCoercedInput(typeName, coercedInputName) {\n    return ts.createTypeQueryNode(ts.createQualifiedName(typeName, \"ngAcceptInputType_\" + coercedInputName));\n  }\n\n  exports.tsCreateTypeQueryForCoercedInput = tsCreateTypeQueryForCoercedInput;\n  /**\n   * Create a `ts.VariableStatement` that initializes a variable with a given expression.\n   *\n   * Unlike with `tsDeclareVariable`, the type of the variable is inferred from the initializer\n   * expression.\n   */\n\n  function tsCreateVariable(id, initializer) {\n    var decl = ts.createVariableDeclaration(\n    /* name */\n    id,\n    /* type */\n    undefined,\n    /* initializer */\n    initializer);\n    return ts.createVariableStatement(\n    /* modifiers */\n    undefined,\n    /* declarationList */\n    [decl]);\n  }\n\n  exports.tsCreateVariable = tsCreateVariable;\n  /**\n   * Construct a `ts.CallExpression` that calls a method on a receiver.\n   */\n\n  function tsCallMethod(receiver, methodName, args) {\n    if (args === void 0) {\n      args = [];\n    }\n\n    var methodAccess = ts.createPropertyAccess(receiver, methodName);\n    return ts.createCall(\n    /* expression */\n    methodAccess,\n    /* typeArguments */\n    undefined,\n    /* argumentsArray */\n    args);\n  }\n\n  exports.tsCallMethod = tsCallMethod;\n\n  function checkIfClassIsExported(node) {\n    // A class is exported if one of two conditions is met:\n    // 1) it has the 'export' modifier.\n    // 2) it's declared at the top level, and there is an export statement for the class.\n    if (node.modifiers !== undefined && node.modifiers.some(function (mod) {\n      return mod.kind === ts.SyntaxKind.ExportKeyword;\n    })) {\n      // Condition 1 is true, the class has an 'export' keyword attached.\n      return true;\n    } else if (node.parent !== undefined && ts.isSourceFile(node.parent) && checkIfFileHasExport(node.parent, node.name.text)) {\n      // Condition 2 is true, the class is exported via an 'export {}' statement.\n      return true;\n    }\n\n    return false;\n  }\n\n  exports.checkIfClassIsExported = checkIfClassIsExported;\n\n  function checkIfFileHasExport(sf, name) {\n    var e_1, _a, e_2, _b;\n\n    try {\n      for (var _c = tslib_1.__values(sf.statements), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var stmt = _d.value;\n\n        if (ts.isExportDeclaration(stmt) && stmt.exportClause !== undefined && ts.isNamedExports(stmt.exportClause)) {\n          try {\n            for (var _e = (e_2 = void 0, tslib_1.__values(stmt.exportClause.elements)), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var element = _f.value;\n\n              if (element.propertyName === undefined && element.name.text === name) {\n                // The named declaration is directly exported.\n                return true;\n              } else if (element.propertyName !== undefined && element.propertyName.text == name) {\n                // The named declaration is exported via an alias.\n                return true;\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return false;\n  }\n\n  function checkIfGenericTypesAreUnbound(node) {\n    if (node.typeParameters === undefined) {\n      return true;\n    }\n\n    return node.typeParameters.every(function (param) {\n      return param.constraint === undefined;\n    });\n  }\n\n  exports.checkIfGenericTypesAreUnbound = checkIfGenericTypesAreUnbound;\n\n  function isAccessExpression(node) {\n    return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node);\n  }\n\n  exports.isAccessExpression = isAccessExpression;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/ts_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\nimport {ClassDeclaration} from '../../reflection';\n\n/**\n * A `Set` of `ts.SyntaxKind`s of `ts.Expression` which are safe to wrap in a `ts.AsExpression`\n * without needing to be wrapped in parentheses.\n *\n * For example, `foo.bar()` is a `ts.CallExpression`, and can be safely cast to `any` with\n * `foo.bar() as any`. however, `foo !== bar` is a `ts.BinaryExpression`, and attempting to cast\n * without the parentheses yields the expression `foo !== bar as any`. This is semantically\n * equivalent to `foo !== (bar as any)`, which is not what was intended. Thus,\n * `ts.BinaryExpression`s need to be wrapped in parentheses before casting.\n */\n//\nconst SAFE_TO_CAST_WITHOUT_PARENS: Set<ts.SyntaxKind> = new Set([\n  // Expressions which are already parenthesized can be cast without further wrapping.\n  ts.SyntaxKind.ParenthesizedExpression,\n\n  // Expressions which form a single lexical unit leave no room for precedence issues with the cast.\n  ts.SyntaxKind.Identifier,\n  ts.SyntaxKind.CallExpression,\n  ts.SyntaxKind.NonNullExpression,\n  ts.SyntaxKind.ElementAccessExpression,\n  ts.SyntaxKind.PropertyAccessExpression,\n  ts.SyntaxKind.ArrayLiteralExpression,\n  ts.SyntaxKind.ObjectLiteralExpression,\n\n  // The same goes for various literals.\n  ts.SyntaxKind.StringLiteral,\n  ts.SyntaxKind.NumericLiteral,\n  ts.SyntaxKind.TrueKeyword,\n  ts.SyntaxKind.FalseKeyword,\n  ts.SyntaxKind.NullKeyword,\n  ts.SyntaxKind.UndefinedKeyword,\n]);\n\nexport function tsCastToAny(expr: ts.Expression): ts.Expression {\n  // Wrap `expr` in parentheses if needed (see `SAFE_TO_CAST_WITHOUT_PARENS` above).\n  if (!SAFE_TO_CAST_WITHOUT_PARENS.has(expr.kind)) {\n    expr = ts.createParen(expr);\n  }\n\n  // The outer expression is always wrapped in parentheses.\n  return ts.createParen(\n      ts.createAsExpression(expr, ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)));\n}\n\n\n/**\n * Create an expression which instantiates an element by its HTML tagName.\n *\n * Thanks to narrowing of `document.createElement()`, this expression will have its type inferred\n * based on the tag name, including for custom elements that have appropriate .d.ts definitions.\n */\nexport function tsCreateElement(tagName: string): ts.Expression {\n  const createElement = ts.createPropertyAccess(\n      /* expression */ ts.createIdentifier('document'), 'createElement');\n  return ts.createCall(\n      /* expression */ createElement,\n      /* typeArguments */ undefined,\n      /* argumentsArray */[ts.createLiteral(tagName)]);\n}\n\n/**\n * Create a `ts.VariableStatement` which declares a variable without explicit initialization.\n *\n * The initializer `null!` is used to bypass strict variable initialization checks.\n *\n * Unlike with `tsCreateVariable`, the type of the variable is explicitly specified.\n */\nexport function tsDeclareVariable(id: ts.Identifier, type: ts.TypeNode): ts.VariableStatement {\n  const decl = ts.createVariableDeclaration(\n      /* name */ id,\n      /* type */ type,\n      /* initializer */ ts.createNonNullExpression(ts.createNull()));\n  return ts.createVariableStatement(\n      /* modifiers */ undefined,\n      /* declarationList */[decl]);\n}\n\n/**\n * Creates a `ts.TypeQueryNode` for a coerced input.\n *\n * For example: `typeof MatInput.ngAcceptInputType_value`, where MatInput is `typeName` and `value`\n * is the `coercedInputName`.\n *\n * @param typeName The `EntityName` of the Directive where the static coerced input is defined.\n * @param coercedInputName The field name of the coerced input.\n */\nexport function tsCreateTypeQueryForCoercedInput(\n    typeName: ts.EntityName, coercedInputName: string): ts.TypeQueryNode {\n  return ts.createTypeQueryNode(\n      ts.createQualifiedName(typeName, `ngAcceptInputType_${coercedInputName}`));\n}\n\n/**\n * Create a `ts.VariableStatement` that initializes a variable with a given expression.\n *\n * Unlike with `tsDeclareVariable`, the type of the variable is inferred from the initializer\n * expression.\n */\nexport function tsCreateVariable(\n    id: ts.Identifier, initializer: ts.Expression): ts.VariableStatement {\n  const decl = ts.createVariableDeclaration(\n      /* name */ id,\n      /* type */ undefined,\n      /* initializer */ initializer);\n  return ts.createVariableStatement(\n      /* modifiers */ undefined,\n      /* declarationList */[decl]);\n}\n\n/**\n * Construct a `ts.CallExpression` that calls a method on a receiver.\n */\nexport function tsCallMethod(\n    receiver: ts.Expression, methodName: string, args: ts.Expression[] = []): ts.CallExpression {\n  const methodAccess = ts.createPropertyAccess(receiver, methodName);\n  return ts.createCall(\n      /* expression */ methodAccess,\n      /* typeArguments */ undefined,\n      /* argumentsArray */ args);\n}\n\nexport function checkIfClassIsExported(node: ClassDeclaration): boolean {\n  // A class is exported if one of two conditions is met:\n  // 1) it has the 'export' modifier.\n  // 2) it's declared at the top level, and there is an export statement for the class.\n  if (node.modifiers !== undefined &&\n      node.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword)) {\n    // Condition 1 is true, the class has an 'export' keyword attached.\n    return true;\n  } else if (\n      node.parent !== undefined && ts.isSourceFile(node.parent) &&\n      checkIfFileHasExport(node.parent, node.name.text)) {\n    // Condition 2 is true, the class is exported via an 'export {}' statement.\n    return true;\n  }\n  return false;\n}\n\nfunction checkIfFileHasExport(sf: ts.SourceFile, name: string): boolean {\n  for (const stmt of sf.statements) {\n    if (ts.isExportDeclaration(stmt) && stmt.exportClause !== undefined &&\n        ts.isNamedExports(stmt.exportClause)) {\n      for (const element of stmt.exportClause.elements) {\n        if (element.propertyName === undefined && element.name.text === name) {\n          // The named declaration is directly exported.\n          return true;\n        } else if (element.propertyName !== undefined && element.propertyName.text == name) {\n          // The named declaration is exported via an alias.\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nexport function checkIfGenericTypesAreUnbound(node: ClassDeclaration<ts.ClassDeclaration>):\n    boolean {\n  if (node.typeParameters === undefined) {\n    return true;\n  }\n  return node.typeParameters.every(param => param.constraint === undefined);\n}\n\nexport function isAccessExpression(node: ts.Node): node is ts.ElementAccessExpression|\n    ts.PropertyAccessExpression {\n  return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}