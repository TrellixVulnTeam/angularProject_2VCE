{"ast":null,"code":"var _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar mkdirp = require(\"mkdirp\");\n\nvar _require = require(\"chrome-trace-event\"),\n    Tracer = _require.Tracer;\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../../schemas/plugins/debug/ProfilingPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n\n\nvar inspector = undefined;\n\ntry {\n  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n  inspector = require(\"inspector\");\n} catch (e) {\n  console.log(\"Unable to CPU profile in < node 8.0\");\n}\n\nvar Profiler = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Profiler(inspector) {\n    _classCallCheck(this, Profiler);\n\n    this.session = undefined;\n    this.inspector = inspector;\n  }\n\n  _createClass(Profiler, [{\n    key: \"hasSession\",\n    value: function hasSession() {\n      return this.session !== undefined;\n    }\n  }, {\n    key: \"startProfiling\",\n    value: function startProfiling() {\n      if (this.inspector === undefined) {\n        return Promise.resolve();\n      }\n\n      try {\n        this.session = new inspector.Session();\n        this.session.connect();\n      } catch (_) {\n        this.session = undefined;\n        return Promise.resolve();\n      }\n\n      return Promise.all([this.sendCommand(\"Profiler.setSamplingInterval\", {\n        interval: 100\n      }), this.sendCommand(\"Profiler.enable\"), this.sendCommand(\"Profiler.start\")]);\n    }\n  }, {\n    key: \"sendCommand\",\n    value: function sendCommand(method, params) {\n      var _this = this;\n\n      if (this.hasSession()) {\n        return new Promise(function (res, rej) {\n          return _this.session.post(method, params, function (err, params) {\n            if (err !== null) {\n              rej(err);\n            } else {\n              res(params);\n            }\n          });\n        });\n      } else {\n        return Promise.resolve();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this.hasSession()) {\n        this.session.disconnect();\n      }\n\n      return Promise.resolve();\n    }\n  }, {\n    key: \"stopProfiling\",\n    value: function stopProfiling() {\n      return this.sendCommand(\"Profiler.stop\");\n    }\n  }]);\n\n  return Profiler;\n}();\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\n\n\nvar createTrace = function createTrace(outputPath) {\n  var trace = new Tracer({\n    noStream: true\n  });\n  var profiler = new Profiler(inspector);\n\n  if (/\\/|\\\\/.test(outputPath)) {\n    var dirPath = path.dirname(outputPath);\n    mkdirp.sync(dirPath);\n  }\n\n  var fsStream = fs.createWriteStream(outputPath);\n  var counter = 0;\n  trace.pipe(fsStream); // These are critical events that need to be inserted so that tools like\n  // chrome dev tools can load the profile.\n\n  trace.instantEvent({\n    name: \"TracingStartedInPage\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\",\n        page: \"0xfff\",\n        frames: [{\n          frame: \"0xfff\",\n          url: \"webpack\",\n          name: \"\"\n        }]\n      }\n    }\n  });\n  trace.instantEvent({\n    name: \"TracingStartedInBrowser\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\"\n      }\n    }\n  });\n  return {\n    trace: trace,\n    counter: counter,\n    profiler: profiler,\n    end: function end(callback) {\n      // Wait until the write stream finishes.\n      fsStream.on(\"finish\", function () {\n        callback();\n      }); // Tear down the readable trace stream.\n\n      trace.push(null);\n    }\n  };\n};\n\nvar pluginName = \"ProfilingPlugin\";\n\nvar ProfilingPlugin = /*#__PURE__*/function () {\n  \"use strict\";\n\n  /**\n   * @param {ProfilingPluginOptions=} opts options object\n   */\n  function ProfilingPlugin(opts) {\n    _classCallCheck(this, ProfilingPlugin);\n\n    validateOptions(schema, opts || {}, \"Profiling plugin\");\n    opts = opts || {};\n    this.outputPath = opts.outputPath || \"events.json\";\n  }\n\n  _createClass(ProfilingPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var tracer = createTrace(this.outputPath);\n      tracer.profiler.startProfiling(); // Compiler Hooks\n\n      Object.keys(compiler.hooks).forEach(function (hookName) {\n        compiler.hooks[hookName].intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n      });\n      Object.keys(compiler.resolverFactory.hooks).forEach(function (hookName) {\n        compiler.resolverFactory.hooks[hookName].intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n      });\n      compiler.hooks.compilation.tap(pluginName, function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory,\n            contextModuleFactory = _ref.contextModuleFactory;\n        interceptAllHooksFor(compilation, tracer, \"Compilation\");\n        interceptAllHooksFor(normalModuleFactory, tracer, \"Normal Module Factory\");\n        interceptAllHooksFor(contextModuleFactory, tracer, \"Context Module Factory\");\n        interceptAllParserHooks(normalModuleFactory, tracer);\n        interceptTemplateInstancesFrom(compilation, tracer);\n      }); // We need to write out the CPU profile when we are all done.\n\n      compiler.hooks.done.tapAsync({\n        name: pluginName,\n        stage: Infinity\n      }, function (stats, callback) {\n        tracer.profiler.stopProfiling().then(function (parsedResults) {\n          if (parsedResults === undefined) {\n            tracer.profiler.destroy();\n            tracer.trace.flush();\n            tracer.end(callback);\n            return;\n          }\n\n          var cpuStartTime = parsedResults.profile.startTime;\n          var cpuEndTime = parsedResults.profile.endTime;\n          tracer.trace.completeEvent({\n            name: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n            id: ++tracer.counter,\n            cat: [\"toplevel\"],\n            ts: cpuStartTime,\n            args: {\n              src_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n              src_func: \"Accept\"\n            }\n          });\n          tracer.trace.completeEvent({\n            name: \"EvaluateScript\",\n            id: ++tracer.counter,\n            cat: [\"devtools.timeline\"],\n            ts: cpuStartTime,\n            dur: cpuEndTime - cpuStartTime,\n            args: {\n              data: {\n                url: \"webpack\",\n                lineNumber: 1,\n                columnNumber: 1,\n                frame: \"0xFFF\"\n              }\n            }\n          });\n          tracer.trace.instantEvent({\n            name: \"CpuProfile\",\n            id: ++tracer.counter,\n            cat: [\"disabled-by-default-devtools.timeline\"],\n            ts: cpuEndTime,\n            args: {\n              data: {\n                cpuProfile: parsedResults.profile\n              }\n            }\n          });\n          tracer.profiler.destroy();\n          tracer.trace.flush();\n          tracer.end(callback);\n        });\n      });\n    }\n  }]);\n\n  return ProfilingPlugin;\n}();\n\nvar interceptTemplateInstancesFrom = function interceptTemplateInstancesFrom(compilation, tracer) {\n  var mainTemplate = compilation.mainTemplate,\n      chunkTemplate = compilation.chunkTemplate,\n      hotUpdateChunkTemplate = compilation.hotUpdateChunkTemplate,\n      moduleTemplates = compilation.moduleTemplates;\n  var javascript = moduleTemplates.javascript,\n      webassembly = moduleTemplates.webassembly;\n  [{\n    instance: mainTemplate,\n    name: \"MainTemplate\"\n  }, {\n    instance: chunkTemplate,\n    name: \"ChunkTemplate\"\n  }, {\n    instance: hotUpdateChunkTemplate,\n    name: \"HotUpdateChunkTemplate\"\n  }, {\n    instance: javascript,\n    name: \"JavaScriptModuleTemplate\"\n  }, {\n    instance: webassembly,\n    name: \"WebAssemblyModuleTemplate\"\n  }].forEach(function (templateObject) {\n    Object.keys(templateObject.instance.hooks).forEach(function (hookName) {\n      templateObject.instance.hooks[hookName].intercept(makeInterceptorFor(templateObject.name, tracer)(hookName));\n    });\n  });\n};\n\nvar interceptAllHooksFor = function interceptAllHooksFor(instance, tracer, logLabel) {\n  if (Reflect.has(instance, \"hooks\")) {\n    Object.keys(instance.hooks).forEach(function (hookName) {\n      instance.hooks[hookName].intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n    });\n  }\n};\n\nvar interceptAllParserHooks = function interceptAllParserHooks(moduleFactory, tracer) {\n  var moduleTypes = [\"javascript/auto\", \"javascript/dynamic\", \"javascript/esm\", \"json\", \"webassembly/experimental\"];\n  moduleTypes.forEach(function (moduleType) {\n    moduleFactory.hooks.parser.for(moduleType).tap(\"ProfilingPlugin\", function (parser, parserOpts) {\n      interceptAllHooksFor(parser, tracer, \"Parser\");\n    });\n  });\n};\n\nvar makeInterceptorFor = function makeInterceptorFor(instance, tracer) {\n  return function (hookName) {\n    return {\n      register: function register(_ref2) {\n        var name = _ref2.name,\n            type = _ref2.type,\n            context = _ref2.context,\n            fn = _ref2.fn;\n        var newFn = makeNewProfiledTapFn(hookName, tracer, {\n          name: name,\n          type: type,\n          fn: fn\n        });\n        return {\n          name: name,\n          type: type,\n          context: context,\n          fn: newFn\n        };\n      }\n    };\n  };\n}; // TODO improve typing\n\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\n\n\nvar makeNewProfiledTapFn = function makeNewProfiledTapFn(hookName, tracer, _ref3) {\n  var name = _ref3.name,\n      type = _ref3.type,\n      fn = _ref3.fn;\n  var defaultCategory = [\"blink.user_timing\"];\n\n  switch (type) {\n    case \"promise\":\n      return function () {\n        var id = ++tracer.counter;\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        var promise =\n        /** @type {Promise<*>} */\n        fn.apply(void 0, arguments);\n        return promise.then(function (r) {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          return r;\n        });\n      };\n\n    case \"async\":\n      return function () {\n        var id = ++tracer.counter;\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        var callback = args.pop();\n        fn.apply(void 0, args.concat([function () {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          callback.apply(void 0, arguments);\n        }]));\n      };\n\n    case \"sync\":\n      return function () {\n        var id = ++tracer.counter; // Do not instrument ourself due to the CPU\n        // profile needing to be the last event in the trace.\n\n        if (name === pluginName) {\n          return fn.apply(void 0, arguments);\n        }\n\n        tracer.trace.begin({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        var r;\n\n        try {\n          r = fn.apply(void 0, arguments);\n        } catch (error) {\n          tracer.trace.end({\n            name: name,\n            id: id,\n            cat: defaultCategory\n          });\n          throw error;\n        }\n\n        tracer.trace.end({\n          name: name,\n          id: id,\n          cat: defaultCategory\n        });\n        return r;\n      };\n\n    default:\n      break;\n  }\n};\n\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/debug/ProfilingPlugin.js"],"names":["fs","require","path","mkdirp","Tracer","validateOptions","schema","inspector","undefined","e","console","log","Profiler","session","Promise","resolve","Session","connect","_","all","sendCommand","interval","method","params","hasSession","res","rej","post","err","disconnect","createTrace","outputPath","trace","noStream","profiler","test","dirPath","dirname","sync","fsStream","createWriteStream","counter","pipe","instantEvent","name","id","cat","args","data","sessionId","page","frames","frame","url","end","callback","on","push","pluginName","ProfilingPlugin","opts","compiler","tracer","startProfiling","Object","keys","hooks","forEach","hookName","intercept","makeInterceptorFor","resolverFactory","compilation","tap","normalModuleFactory","contextModuleFactory","interceptAllHooksFor","interceptAllParserHooks","interceptTemplateInstancesFrom","done","tapAsync","stage","Infinity","stats","stopProfiling","then","parsedResults","destroy","flush","cpuStartTime","profile","startTime","cpuEndTime","endTime","completeEvent","ts","src_file","src_func","dur","lineNumber","columnNumber","cpuProfile","mainTemplate","chunkTemplate","hotUpdateChunkTemplate","moduleTemplates","javascript","webassembly","instance","templateObject","logLabel","Reflect","has","moduleFactory","moduleTypes","moduleType","parser","for","parserOpts","register","type","context","fn","newFn","makeNewProfiledTapFn","defaultCategory","begin","promise","r","pop","error","module","exports"],"mappings":"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","sourcesContent":["const fs = require(\"fs\");\nconst path = require(\"path\");\nconst mkdirp = require(\"mkdirp\");\nconst { Tracer } = require(\"chrome-trace-event\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/debug/ProfilingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n\nlet inspector = undefined;\n\ntry {\n\t// eslint-disable-next-line node/no-unsupported-features/node-builtins\n\tinspector = require(\"inspector\");\n} catch (e) {\n\tconsole.log(\"Unable to CPU profile in < node 8.0\");\n}\n\nclass Profiler {\n\tconstructor(inspector) {\n\t\tthis.session = undefined;\n\t\tthis.inspector = inspector;\n\t}\n\n\thasSession() {\n\t\treturn this.session !== undefined;\n\t}\n\n\tstartProfiling() {\n\t\tif (this.inspector === undefined) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\ttry {\n\t\t\tthis.session = new inspector.Session();\n\t\t\tthis.session.connect();\n\t\t} catch (_) {\n\t\t\tthis.session = undefined;\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.all([\n\t\t\tthis.sendCommand(\"Profiler.setSamplingInterval\", {\n\t\t\t\tinterval: 100\n\t\t\t}),\n\t\t\tthis.sendCommand(\"Profiler.enable\"),\n\t\t\tthis.sendCommand(\"Profiler.start\")\n\t\t]);\n\t}\n\n\tsendCommand(method, params) {\n\t\tif (this.hasSession()) {\n\t\t\treturn new Promise((res, rej) => {\n\t\t\t\treturn this.session.post(method, params, (err, params) => {\n\t\t\t\t\tif (err !== null) {\n\t\t\t\t\t\trej(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tres(params);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\tdestroy() {\n\t\tif (this.hasSession()) {\n\t\t\tthis.session.disconnect();\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\tstopProfiling() {\n\t\treturn this.sendCommand(\"Profiler.stop\");\n\t}\n}\n\n/**\n * an object that wraps Tracer and Profiler with a counter\n * @typedef {Object} Trace\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\nconst createTrace = outputPath => {\n\tconst trace = new Tracer({\n\t\tnoStream: true\n\t});\n\tconst profiler = new Profiler(inspector);\n\tif (/\\/|\\\\/.test(outputPath)) {\n\t\tconst dirPath = path.dirname(outputPath);\n\t\tmkdirp.sync(dirPath);\n\t}\n\tconst fsStream = fs.createWriteStream(outputPath);\n\n\tlet counter = 0;\n\n\ttrace.pipe(fsStream);\n\t// These are critical events that need to be inserted so that tools like\n\t// chrome dev tools can load the profile.\n\ttrace.instantEvent({\n\t\tname: \"TracingStartedInPage\",\n\t\tid: ++counter,\n\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\targs: {\n\t\t\tdata: {\n\t\t\t\tsessionId: \"-1\",\n\t\t\t\tpage: \"0xfff\",\n\t\t\t\tframes: [\n\t\t\t\t\t{\n\t\t\t\t\t\tframe: \"0xfff\",\n\t\t\t\t\t\turl: \"webpack\",\n\t\t\t\t\t\tname: \"\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}\n\t\t}\n\t});\n\n\ttrace.instantEvent({\n\t\tname: \"TracingStartedInBrowser\",\n\t\tid: ++counter,\n\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\targs: {\n\t\t\tdata: {\n\t\t\t\tsessionId: \"-1\"\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\ttrace,\n\t\tcounter,\n\t\tprofiler,\n\t\tend: callback => {\n\t\t\t// Wait until the write stream finishes.\n\t\t\tfsStream.on(\"finish\", () => {\n\t\t\t\tcallback();\n\t\t\t});\n\t\t\t// Tear down the readable trace stream.\n\t\t\ttrace.push(null);\n\t\t}\n\t};\n};\n\nconst pluginName = \"ProfilingPlugin\";\n\nclass ProfilingPlugin {\n\t/**\n\t * @param {ProfilingPluginOptions=} opts options object\n\t */\n\tconstructor(opts) {\n\t\tvalidateOptions(schema, opts || {}, \"Profiling plugin\");\n\t\topts = opts || {};\n\t\tthis.outputPath = opts.outputPath || \"events.json\";\n\t}\n\n\tapply(compiler) {\n\t\tconst tracer = createTrace(this.outputPath);\n\t\ttracer.profiler.startProfiling();\n\n\t\t// Compiler Hooks\n\t\tObject.keys(compiler.hooks).forEach(hookName => {\n\t\t\tcompiler.hooks[hookName].intercept(\n\t\t\t\tmakeInterceptorFor(\"Compiler\", tracer)(hookName)\n\t\t\t);\n\t\t});\n\n\t\tObject.keys(compiler.resolverFactory.hooks).forEach(hookName => {\n\t\t\tcompiler.resolverFactory.hooks[hookName].intercept(\n\t\t\t\tmakeInterceptorFor(\"Resolver\", tracer)(hookName)\n\t\t\t);\n\t\t});\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tpluginName,\n\t\t\t(compilation, { normalModuleFactory, contextModuleFactory }) => {\n\t\t\t\tinterceptAllHooksFor(compilation, tracer, \"Compilation\");\n\t\t\t\tinterceptAllHooksFor(\n\t\t\t\t\tnormalModuleFactory,\n\t\t\t\t\ttracer,\n\t\t\t\t\t\"Normal Module Factory\"\n\t\t\t\t);\n\t\t\t\tinterceptAllHooksFor(\n\t\t\t\t\tcontextModuleFactory,\n\t\t\t\t\ttracer,\n\t\t\t\t\t\"Context Module Factory\"\n\t\t\t\t);\n\t\t\t\tinterceptAllParserHooks(normalModuleFactory, tracer);\n\t\t\t\tinterceptTemplateInstancesFrom(compilation, tracer);\n\t\t\t}\n\t\t);\n\n\t\t// We need to write out the CPU profile when we are all done.\n\t\tcompiler.hooks.done.tapAsync(\n\t\t\t{\n\t\t\t\tname: pluginName,\n\t\t\t\tstage: Infinity\n\t\t\t},\n\t\t\t(stats, callback) => {\n\t\t\t\ttracer.profiler.stopProfiling().then(parsedResults => {\n\t\t\t\t\tif (parsedResults === undefined) {\n\t\t\t\t\t\ttracer.profiler.destroy();\n\t\t\t\t\t\ttracer.trace.flush();\n\t\t\t\t\t\ttracer.end(callback);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst cpuStartTime = parsedResults.profile.startTime;\n\t\t\t\t\tconst cpuEndTime = parsedResults.profile.endTime;\n\n\t\t\t\t\ttracer.trace.completeEvent({\n\t\t\t\t\t\tname: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"toplevel\"],\n\t\t\t\t\t\tts: cpuStartTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tsrc_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n\t\t\t\t\t\t\tsrc_func: \"Accept\"\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.trace.completeEvent({\n\t\t\t\t\t\tname: \"EvaluateScript\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"devtools.timeline\"],\n\t\t\t\t\t\tts: cpuStartTime,\n\t\t\t\t\t\tdur: cpuEndTime - cpuStartTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\turl: \"webpack\",\n\t\t\t\t\t\t\t\tlineNumber: 1,\n\t\t\t\t\t\t\t\tcolumnNumber: 1,\n\t\t\t\t\t\t\t\tframe: \"0xFFF\"\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.trace.instantEvent({\n\t\t\t\t\t\tname: \"CpuProfile\",\n\t\t\t\t\t\tid: ++tracer.counter,\n\t\t\t\t\t\tcat: [\"disabled-by-default-devtools.timeline\"],\n\t\t\t\t\t\tts: cpuEndTime,\n\t\t\t\t\t\targs: {\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\tcpuProfile: parsedResults.profile\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\ttracer.profiler.destroy();\n\t\t\t\t\ttracer.trace.flush();\n\t\t\t\t\ttracer.end(callback);\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nconst interceptTemplateInstancesFrom = (compilation, tracer) => {\n\tconst {\n\t\tmainTemplate,\n\t\tchunkTemplate,\n\t\thotUpdateChunkTemplate,\n\t\tmoduleTemplates\n\t} = compilation;\n\n\tconst { javascript, webassembly } = moduleTemplates;\n\n\t[\n\t\t{\n\t\t\tinstance: mainTemplate,\n\t\t\tname: \"MainTemplate\"\n\t\t},\n\t\t{\n\t\t\tinstance: chunkTemplate,\n\t\t\tname: \"ChunkTemplate\"\n\t\t},\n\t\t{\n\t\t\tinstance: hotUpdateChunkTemplate,\n\t\t\tname: \"HotUpdateChunkTemplate\"\n\t\t},\n\t\t{\n\t\t\tinstance: javascript,\n\t\t\tname: \"JavaScriptModuleTemplate\"\n\t\t},\n\t\t{\n\t\t\tinstance: webassembly,\n\t\t\tname: \"WebAssemblyModuleTemplate\"\n\t\t}\n\t].forEach(templateObject => {\n\t\tObject.keys(templateObject.instance.hooks).forEach(hookName => {\n\t\t\ttemplateObject.instance.hooks[hookName].intercept(\n\t\t\t\tmakeInterceptorFor(templateObject.name, tracer)(hookName)\n\t\t\t);\n\t\t});\n\t});\n};\n\nconst interceptAllHooksFor = (instance, tracer, logLabel) => {\n\tif (Reflect.has(instance, \"hooks\")) {\n\t\tObject.keys(instance.hooks).forEach(hookName => {\n\t\t\tinstance.hooks[hookName].intercept(\n\t\t\t\tmakeInterceptorFor(logLabel, tracer)(hookName)\n\t\t\t);\n\t\t});\n\t}\n};\n\nconst interceptAllParserHooks = (moduleFactory, tracer) => {\n\tconst moduleTypes = [\n\t\t\"javascript/auto\",\n\t\t\"javascript/dynamic\",\n\t\t\"javascript/esm\",\n\t\t\"json\",\n\t\t\"webassembly/experimental\"\n\t];\n\n\tmoduleTypes.forEach(moduleType => {\n\t\tmoduleFactory.hooks.parser\n\t\t\t.for(moduleType)\n\t\t\t.tap(\"ProfilingPlugin\", (parser, parserOpts) => {\n\t\t\t\tinterceptAllHooksFor(parser, tracer, \"Parser\");\n\t\t\t});\n\t});\n};\n\nconst makeInterceptorFor = (instance, tracer) => hookName => ({\n\tregister: ({ name, type, context, fn }) => {\n\t\tconst newFn = makeNewProfiledTapFn(hookName, tracer, {\n\t\t\tname,\n\t\t\ttype,\n\t\t\tfn\n\t\t});\n\t\treturn {\n\t\t\tname,\n\t\t\ttype,\n\t\t\tcontext,\n\t\t\tfn: newFn\n\t\t};\n\t}\n});\n\n// TODO improve typing\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\nconst makeNewProfiledTapFn = (hookName, tracer, { name, type, fn }) => {\n\tconst defaultCategory = [\"blink.user_timing\"];\n\n\tswitch (type) {\n\t\tcase \"promise\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tconst promise = /** @type {Promise<*>} */ (fn(...args));\n\t\t\t\treturn promise.then(r => {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\treturn r;\n\t\t\t\t});\n\t\t\t};\n\t\tcase \"async\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tconst callback = args.pop();\n\t\t\t\tfn(...args, (...r) => {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\tcallback(...r);\n\t\t\t\t});\n\t\t\t};\n\t\tcase \"sync\":\n\t\t\treturn (...args) => {\n\t\t\t\tconst id = ++tracer.counter;\n\t\t\t\t// Do not instrument ourself due to the CPU\n\t\t\t\t// profile needing to be the last event in the trace.\n\t\t\t\tif (name === pluginName) {\n\t\t\t\t\treturn fn(...args);\n\t\t\t\t}\n\n\t\t\t\ttracer.trace.begin({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\tlet r;\n\t\t\t\ttry {\n\t\t\t\t\tr = fn(...args);\n\t\t\t\t} catch (error) {\n\t\t\t\t\ttracer.trace.end({\n\t\t\t\t\t\tname,\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tcat: defaultCategory\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t\ttracer.trace.end({\n\t\t\t\t\tname,\n\t\t\t\t\tid,\n\t\t\t\t\tcat: defaultCategory\n\t\t\t\t});\n\t\t\t\treturn r;\n\t\t\t};\n\t\tdefault:\n\t\t\tbreak;\n\t}\n};\n\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;\n"]},"metadata":{},"sourceType":"script"}