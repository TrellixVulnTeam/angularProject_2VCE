{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/switch/src/switch\", [\"require\", \"exports\", \"tslib\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ivySwitchTransform = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var IVY_SWITCH_PRE_SUFFIX = '__PRE_R3__';\n  var IVY_SWITCH_POST_SUFFIX = '__POST_R3__';\n\n  function ivySwitchTransform(_) {\n    return flipIvySwitchInFile;\n  }\n\n  exports.ivySwitchTransform = ivySwitchTransform;\n\n  function flipIvySwitchInFile(sf) {\n    // To replace the statements array, it must be copied. This only needs to happen if a statement\n    // must actually be replaced within the array, so the newStatements array is lazily initialized.\n    var newStatements = undefined; // Iterate over the statements in the file.\n\n    for (var i = 0; i < sf.statements.length; i++) {\n      var statement = sf.statements[i]; // Skip over everything that isn't a variable statement.\n\n      if (!ts.isVariableStatement(statement) || !hasIvySwitches(statement)) {\n        continue;\n      } // This statement needs to be replaced. Check if the newStatements array needs to be lazily\n      // initialized to a copy of the original statements.\n\n\n      if (newStatements === undefined) {\n        newStatements = tslib_1.__spread(sf.statements);\n      } // Flip any switches in the VariableStatement. If there were any, a new statement will be\n      // returned; otherwise the old statement will be.\n\n\n      newStatements[i] = flipIvySwitchesInVariableStatement(statement, sf.statements);\n    } // Only update the statements in the SourceFile if any have changed.\n\n\n    if (newStatements !== undefined) {\n      return ts.updateSourceFileNode(sf, newStatements);\n    }\n\n    return sf;\n  }\n  /**\n   * Look for the ts.Identifier of a ts.Declaration with this name.\n   *\n   * The real identifier is needed (rather than fabricating one) as TypeScript decides how to\n   * reference this identifier based on information stored against its node in the AST, which a\n   * synthetic node would not have. In particular, since the post-switch variable is often exported,\n   * TypeScript needs to know this so it can write `exports.VAR` instead of just `VAR` when emitting\n   * code.\n   *\n   * Only variable, function, and class declarations are currently searched.\n   */\n\n\n  function findPostSwitchIdentifier(statements, name) {\n    var e_1, _a;\n\n    try {\n      for (var statements_1 = tslib_1.__values(statements), statements_1_1 = statements_1.next(); !statements_1_1.done; statements_1_1 = statements_1.next()) {\n        var stmt = statements_1_1.value;\n\n        if (ts.isVariableStatement(stmt)) {\n          var decl = stmt.declarationList.declarations.find(function (decl) {\n            return ts.isIdentifier(decl.name) && decl.name.text === name;\n          });\n\n          if (decl !== undefined) {\n            return decl.name;\n          }\n        } else if (ts.isFunctionDeclaration(stmt) || ts.isClassDeclaration(stmt)) {\n          if (stmt.name !== undefined && ts.isIdentifier(stmt.name) && stmt.name.text === name) {\n            return stmt.name;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (statements_1_1 && !statements_1_1.done && (_a = statements_1.return)) _a.call(statements_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Flip any Ivy switches which are discovered in the given ts.VariableStatement.\n   */\n\n\n  function flipIvySwitchesInVariableStatement(stmt, statements) {\n    // Build a new list of variable declarations. Specific declarations that are initialized to a\n    // pre-switch identifier will be replaced with a declaration initialized to the post-switch\n    // identifier.\n    var newDeclarations = tslib_1.__spread(stmt.declarationList.declarations);\n\n    for (var i = 0; i < newDeclarations.length; i++) {\n      var decl = newDeclarations[i]; // Skip declarations that aren't initialized to an identifier.\n\n      if (decl.initializer === undefined || !ts.isIdentifier(decl.initializer)) {\n        continue;\n      } // Skip declarations that aren't Ivy switches.\n\n\n      if (!decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX)) {\n        continue;\n      } // Determine the name of the post-switch variable.\n\n\n      var postSwitchName = decl.initializer.text.replace(IVY_SWITCH_PRE_SUFFIX, IVY_SWITCH_POST_SUFFIX); // Find the post-switch variable identifier. If one can't be found, it's an error. This is\n      // reported as a thrown error and not a diagnostic as transformers cannot output diagnostics.\n\n      var newIdentifier = findPostSwitchIdentifier(statements, postSwitchName);\n\n      if (newIdentifier === null) {\n        throw new Error(\"Unable to find identifier \" + postSwitchName + \" in \" + stmt.getSourceFile().fileName + \" for the Ivy switch.\");\n      }\n\n      newDeclarations[i] = ts.updateVariableDeclaration(\n      /* node */\n      decl,\n      /* name */\n      decl.name,\n      /* type */\n      decl.type,\n      /* initializer */\n      newIdentifier);\n    }\n\n    var newDeclList = ts.updateVariableDeclarationList(\n    /* declarationList */\n    stmt.declarationList,\n    /* declarations */\n    newDeclarations);\n    var newStmt = ts.updateVariableStatement(\n    /* statement */\n    stmt,\n    /* modifiers */\n    stmt.modifiers,\n    /* declarationList */\n    newDeclList);\n    return newStmt;\n  }\n  /**\n   * Check whether the given VariableStatement has any Ivy switch variables.\n   */\n\n\n  function hasIvySwitches(stmt) {\n    return stmt.declarationList.declarations.some(function (decl) {\n      return decl.initializer !== undefined && ts.isIdentifier(decl.initializer) && decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX);\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/switch/src/switch.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nconst IVY_SWITCH_PRE_SUFFIX = '__PRE_R3__';\nconst IVY_SWITCH_POST_SUFFIX = '__POST_R3__';\n\nexport function ivySwitchTransform(_: ts.TransformationContext): ts.Transformer<ts.SourceFile> {\n  return flipIvySwitchInFile;\n}\n\nfunction flipIvySwitchInFile(sf: ts.SourceFile): ts.SourceFile {\n  // To replace the statements array, it must be copied. This only needs to happen if a statement\n  // must actually be replaced within the array, so the newStatements array is lazily initialized.\n  let newStatements: ts.Statement[]|undefined = undefined;\n\n  // Iterate over the statements in the file.\n  for (let i = 0; i < sf.statements.length; i++) {\n    const statement = sf.statements[i];\n\n    // Skip over everything that isn't a variable statement.\n    if (!ts.isVariableStatement(statement) || !hasIvySwitches(statement)) {\n      continue;\n    }\n\n    // This statement needs to be replaced. Check if the newStatements array needs to be lazily\n    // initialized to a copy of the original statements.\n    if (newStatements === undefined) {\n      newStatements = [...sf.statements];\n    }\n\n    // Flip any switches in the VariableStatement. If there were any, a new statement will be\n    // returned; otherwise the old statement will be.\n    newStatements[i] = flipIvySwitchesInVariableStatement(statement, sf.statements);\n  }\n\n  // Only update the statements in the SourceFile if any have changed.\n  if (newStatements !== undefined) {\n    return ts.updateSourceFileNode(sf, newStatements);\n  }\n  return sf;\n}\n\n/**\n * Look for the ts.Identifier of a ts.Declaration with this name.\n *\n * The real identifier is needed (rather than fabricating one) as TypeScript decides how to\n * reference this identifier based on information stored against its node in the AST, which a\n * synthetic node would not have. In particular, since the post-switch variable is often exported,\n * TypeScript needs to know this so it can write `exports.VAR` instead of just `VAR` when emitting\n * code.\n *\n * Only variable, function, and class declarations are currently searched.\n */\nfunction findPostSwitchIdentifier(\n    statements: ReadonlyArray<ts.Statement>, name: string): ts.Identifier|null {\n  for (const stmt of statements) {\n    if (ts.isVariableStatement(stmt)) {\n      const decl = stmt.declarationList.declarations.find(\n          decl => ts.isIdentifier(decl.name) && decl.name.text === name);\n      if (decl !== undefined) {\n        return decl.name as ts.Identifier;\n      }\n    } else if (ts.isFunctionDeclaration(stmt) || ts.isClassDeclaration(stmt)) {\n      if (stmt.name !== undefined && ts.isIdentifier(stmt.name) && stmt.name.text === name) {\n        return stmt.name;\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * Flip any Ivy switches which are discovered in the given ts.VariableStatement.\n */\nfunction flipIvySwitchesInVariableStatement(\n    stmt: ts.VariableStatement, statements: ReadonlyArray<ts.Statement>): ts.VariableStatement {\n  // Build a new list of variable declarations. Specific declarations that are initialized to a\n  // pre-switch identifier will be replaced with a declaration initialized to the post-switch\n  // identifier.\n  const newDeclarations = [...stmt.declarationList.declarations];\n  for (let i = 0; i < newDeclarations.length; i++) {\n    const decl = newDeclarations[i];\n\n    // Skip declarations that aren't initialized to an identifier.\n    if (decl.initializer === undefined || !ts.isIdentifier(decl.initializer)) {\n      continue;\n    }\n\n    // Skip declarations that aren't Ivy switches.\n    if (!decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX)) {\n      continue;\n    }\n\n    // Determine the name of the post-switch variable.\n    const postSwitchName =\n        decl.initializer.text.replace(IVY_SWITCH_PRE_SUFFIX, IVY_SWITCH_POST_SUFFIX);\n\n    // Find the post-switch variable identifier. If one can't be found, it's an error. This is\n    // reported as a thrown error and not a diagnostic as transformers cannot output diagnostics.\n    const newIdentifier = findPostSwitchIdentifier(statements, postSwitchName);\n    if (newIdentifier === null) {\n      throw new Error(`Unable to find identifier ${postSwitchName} in ${\n          stmt.getSourceFile().fileName} for the Ivy switch.`);\n    }\n\n    newDeclarations[i] = ts.updateVariableDeclaration(\n        /* node */ decl,\n        /* name */ decl.name,\n        /* type */ decl.type,\n        /* initializer */ newIdentifier);\n  }\n\n  const newDeclList = ts.updateVariableDeclarationList(\n      /* declarationList */ stmt.declarationList,\n      /* declarations */ newDeclarations);\n\n  const newStmt = ts.updateVariableStatement(\n      /* statement */ stmt,\n      /* modifiers */ stmt.modifiers,\n      /* declarationList */ newDeclList);\n\n  return newStmt;\n}\n\n/**\n * Check whether the given VariableStatement has any Ivy switch variables.\n */\nfunction hasIvySwitches(stmt: ts.VariableStatement) {\n  return stmt.declarationList.declarations.some(\n      decl => decl.initializer !== undefined && ts.isIdentifier(decl.initializer) &&\n          decl.initializer.text.endsWith(IVY_SWITCH_PRE_SUFFIX));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}