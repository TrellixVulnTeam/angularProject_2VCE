{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/output/source_map\", [\"require\", \"exports\", \"@angular/compiler/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.toBase64String = exports.SourceMapGenerator = void 0;\n\n  var util_1 = require(\"@angular/compiler/src/util\"); // https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\n\n\n  var VERSION = 3;\n  var JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\n  var SourceMapGenerator =\n  /** @class */\n  function () {\n    function SourceMapGenerator(file) {\n      if (file === void 0) {\n        file = null;\n      }\n\n      this.file = file;\n      this.sourcesContent = new Map();\n      this.lines = [];\n      this.lastCol0 = 0;\n      this.hasMappings = false;\n    } // The content is `null` when the content is expected to be loaded using the URL\n\n\n    SourceMapGenerator.prototype.addSource = function (url, content) {\n      if (content === void 0) {\n        content = null;\n      }\n\n      if (!this.sourcesContent.has(url)) {\n        this.sourcesContent.set(url, content);\n      }\n\n      return this;\n    };\n\n    SourceMapGenerator.prototype.addLine = function () {\n      this.lines.push([]);\n      this.lastCol0 = 0;\n      return this;\n    };\n\n    SourceMapGenerator.prototype.addMapping = function (col0, sourceUrl, sourceLine0, sourceCol0) {\n      if (!this.currentLine) {\n        throw new Error(\"A line must be added before mappings can be added\");\n      }\n\n      if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n        throw new Error(\"Unknown source file \\\"\" + sourceUrl + \"\\\"\");\n      }\n\n      if (col0 == null) {\n        throw new Error(\"The column in the generated code must be provided\");\n      }\n\n      if (col0 < this.lastCol0) {\n        throw new Error(\"Mapping should be added in output order\");\n      }\n\n      if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n        throw new Error(\"The source location must be provided when a source url is provided\");\n      }\n\n      this.hasMappings = true;\n      this.lastCol0 = col0;\n      this.currentLine.push({\n        col0: col0,\n        sourceUrl: sourceUrl,\n        sourceLine0: sourceLine0,\n        sourceCol0: sourceCol0\n      });\n      return this;\n    };\n\n    Object.defineProperty(SourceMapGenerator.prototype, \"currentLine\", {\n      /**\n       * @internal strip this from published d.ts files due to\n       * https://github.com/microsoft/TypeScript/issues/36216\n       */\n      get: function get() {\n        return this.lines.slice(-1)[0];\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    SourceMapGenerator.prototype.toJSON = function () {\n      var _this = this;\n\n      if (!this.hasMappings) {\n        return null;\n      }\n\n      var sourcesIndex = new Map();\n      var sources = [];\n      var sourcesContent = [];\n      Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n        sourcesIndex.set(url, i);\n        sources.push(url);\n        sourcesContent.push(_this.sourcesContent.get(url) || null);\n      });\n      var mappings = '';\n      var lastCol0 = 0;\n      var lastSourceIndex = 0;\n      var lastSourceLine0 = 0;\n      var lastSourceCol0 = 0;\n      this.lines.forEach(function (segments) {\n        lastCol0 = 0;\n        mappings += segments.map(function (segment) {\n          // zero-based starting column of the line in the generated code\n          var segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n          lastCol0 = segment.col0;\n\n          if (segment.sourceUrl != null) {\n            // zero-based index into the “sources” list\n            segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n            lastSourceIndex = sourcesIndex.get(segment.sourceUrl); // the zero-based starting line in the original source\n\n            segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n            lastSourceLine0 = segment.sourceLine0; // the zero-based starting column in the original source\n\n            segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n            lastSourceCol0 = segment.sourceCol0;\n          }\n\n          return segAsStr;\n        }).join(',');\n        mappings += ';';\n      });\n      mappings = mappings.slice(0, -1);\n      return {\n        'file': this.file || '',\n        'version': VERSION,\n        'sourceRoot': '',\n        'sources': sources,\n        'sourcesContent': sourcesContent,\n        'mappings': mappings\n      };\n    };\n\n    SourceMapGenerator.prototype.toJsComment = function () {\n      return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';\n    };\n\n    return SourceMapGenerator;\n  }();\n\n  exports.SourceMapGenerator = SourceMapGenerator;\n\n  function toBase64String(value) {\n    var b64 = '';\n    var encoded = util_1.utf8Encode(value);\n\n    for (var i = 0; i < encoded.length;) {\n      var i1 = encoded[i++];\n      var i2 = i < encoded.length ? encoded[i++] : null;\n      var i3 = i < encoded.length ? encoded[i++] : null;\n      b64 += toBase64Digit(i1 >> 2);\n      b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));\n      b64 += i2 === null ? '=' : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));\n      b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n    }\n\n    return b64;\n  }\n\n  exports.toBase64String = toBase64String;\n\n  function toBase64VLQ(value) {\n    value = value < 0 ? (-value << 1) + 1 : value << 1;\n    var out = '';\n\n    do {\n      var digit = value & 31;\n      value = value >> 5;\n\n      if (value > 0) {\n        digit = digit | 32;\n      }\n\n      out += toBase64Digit(digit);\n    } while (value > 0);\n\n    return out;\n  }\n\n  var B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  function toBase64Digit(value) {\n    if (value < 0 || value >= 64) {\n      throw new Error(\"Can only encode value in the range [0, 63]\");\n    }\n\n    return B64_DIGITS[value];\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/output/source_map.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {utf8Encode} from '../util';\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION = 3;\n\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\ntype Segment = {\n  col0: number,\n  sourceUrl?: string,\n  sourceLine0?: number,\n  sourceCol0?: number,\n};\n\nexport type SourceMap = {\n  version: number,\n  file?: string,\n      sourceRoot: string,\n      sources: string[],\n      sourcesContent: (string|null)[],\n      mappings: string,\n};\n\nexport class SourceMapGenerator {\n  private sourcesContent: Map<string, string|null> = new Map();\n  private lines: Segment[][] = [];\n  private lastCol0: number = 0;\n  private hasMappings = false;\n\n  constructor(private file: string|null = null) {}\n\n  // The content is `null` when the content is expected to be loaded using the URL\n  addSource(url: string, content: string|null = null): this {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n\n  addLine(): this {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n\n  addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({col0, sourceUrl, sourceLine0, sourceCol0});\n    return this;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get currentLine(): Segment[]|null {\n    return this.lines.slice(-1)[0];\n  }\n\n  toJSON(): SourceMap|null {\n    if (!this.hasMappings) {\n      return null;\n    }\n\n    const sourcesIndex = new Map<string, number>();\n    const sources: string[] = [];\n    const sourcesContent: (string|null)[] = [];\n\n    Array.from(this.sourcesContent.keys()).forEach((url: string, i: number) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n\n    let mappings: string = '';\n    let lastCol0: number = 0;\n    let lastSourceIndex: number = 0;\n    let lastSourceLine0: number = 0;\n    let lastSourceCol0: number = 0;\n\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n\n      mappings += segments\n                      .map(segment => {\n                        // zero-based starting column of the line in the generated code\n                        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                        lastCol0 = segment.col0;\n\n                        if (segment.sourceUrl != null) {\n                          // zero-based index into the “sources” list\n                          segAsStr +=\n                              toBase64VLQ(sourcesIndex.get(segment.sourceUrl)! - lastSourceIndex);\n                          lastSourceIndex = sourcesIndex.get(segment.sourceUrl)!;\n                          // the zero-based starting line in the original source\n                          segAsStr += toBase64VLQ(segment.sourceLine0! - lastSourceLine0);\n                          lastSourceLine0 = segment.sourceLine0!;\n                          // the zero-based starting column in the original source\n                          segAsStr += toBase64VLQ(segment.sourceCol0! - lastSourceCol0);\n                          lastSourceCol0 = segment.sourceCol0!;\n                        }\n\n                        return segAsStr;\n                      })\n                      .join(',');\n      mappings += ';';\n    });\n\n    mappings = mappings.slice(0, -1);\n\n    return {\n      'file': this.file || '',\n      'version': VERSION,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings,\n    };\n  }\n\n  toJsComment(): string {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n                              '';\n  }\n}\n\nexport function toBase64String(value: string): string {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length;) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value: number): string {\n  value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value: number): string {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n\n  return B64_DIGITS[value];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}