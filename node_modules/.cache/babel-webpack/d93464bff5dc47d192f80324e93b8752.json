{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitJsonSchema = exports.visitJson = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar pointer_1 = require(\"./pointer\");\n\nfunction _getObjectSubSchema(schema, key) {\n  if (typeof schema !== 'object' || schema === null) {\n    return undefined;\n  } // Is it an object schema?\n\n\n  if (typeof schema.properties == 'object' || schema.type == 'object') {\n    if (typeof schema.properties == 'object' && typeof schema.properties[key] == 'object') {\n      return schema.properties[key];\n    }\n\n    if (typeof schema.additionalProperties == 'object') {\n      return schema.additionalProperties;\n    }\n\n    return undefined;\n  } // Is it an array schema?\n\n\n  if (typeof schema.items == 'object' || schema.type == 'array') {\n    return typeof schema.items == 'object' ? schema.items : undefined;\n  }\n\n  return undefined;\n}\n\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n  if (schema === true || schema === false) {\n    // There's no schema definition, so just visit the JSON recursively.\n    schema = undefined;\n  }\n\n  if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n    if (refResolver) {\n      var resolved = refResolver(schema['$ref'], context);\n      schema = resolved.schema;\n      context = resolved.context;\n    }\n  }\n\n  var value = visitor(json, ptr, schema, root);\n  return (rxjs_1.isObservable(value) ? value : rxjs_1.of(value)).pipe(operators_1.concatMap(function (value) {\n    if (Array.isArray(value)) {\n      return rxjs_1.concat(rxjs_1.from(value).pipe(operators_1.mergeMap(function (item, i) {\n        return _visitJsonRecursive(item, visitor, pointer_1.joinJsonPointer(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe(operators_1.tap(function (x) {\n          return value[i] = x;\n        }));\n      }), operators_1.ignoreElements()), rxjs_1.of(value));\n    } else if (typeof value == 'object' && value !== null) {\n      return rxjs_1.concat(rxjs_1.from(Object.getOwnPropertyNames(value)).pipe(operators_1.mergeMap(function (key) {\n        return _visitJsonRecursive(value[key], visitor, pointer_1.joinJsonPointer(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe(operators_1.tap(function (x) {\n          var descriptor = Object.getOwnPropertyDescriptor(value, key);\n\n          if (descriptor && descriptor.writable && value[key] !== x) {\n            value[key] = x;\n          }\n        }));\n      }), operators_1.ignoreElements()), rxjs_1.of(value));\n    } else {\n      return rxjs_1.of(value);\n    }\n  }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\n\n\nfunction visitJson(json, visitor, schema, refResolver, context) {\n  return _visitJsonRecursive(json, visitor, pointer_1.buildJsonPointer([]), schema, refResolver, context);\n}\n\nexports.visitJson = visitJson;\n\nfunction visitJsonSchema(schema, visitor) {\n  if (schema === false || schema === true) {\n    // Nothing to visit.\n    return;\n  }\n\n  var keywords = {\n    additionalItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    propertyNames: true,\n    not: true\n  };\n  var arrayKeywords = {\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n  };\n  var propsKeywords = {\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    dependencies: true,\n    items: true\n  };\n\n  function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n      visitor(schema, jsonPtr, parentSchema, keyIndex);\n\n      for (var _i = 0, _Object$keys = Object.keys(schema); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var sch = schema[key];\n\n        if (key in propsKeywords) {\n          if (sch && typeof sch == 'object') {\n            for (var _i2 = 0, _Object$keys2 = Object.keys(sch); _i2 < _Object$keys2.length; _i2++) {\n              var prop = _Object$keys2[_i2];\n\n              _traverse(sch[prop], pointer_1.joinJsonPointer(jsonPtr, key, prop), rootSchema, schema, prop);\n            }\n          }\n        } else if (key in keywords) {\n          _traverse(sch, pointer_1.joinJsonPointer(jsonPtr, key), rootSchema, schema, key);\n        } else if (key in arrayKeywords) {\n          if (Array.isArray(sch)) {\n            for (var i = 0; i < sch.length; i++) {\n              _traverse(sch[i], pointer_1.joinJsonPointer(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n            }\n          }\n        } else if (Array.isArray(sch)) {\n          for (var _i3 = 0; _i3 < sch.length; _i3++) {\n            _traverse(sch[_i3], pointer_1.joinJsonPointer(jsonPtr, key, '' + _i3), rootSchema, sch, '' + _i3);\n          }\n        }\n      }\n    }\n  }\n\n  _traverse(schema, pointer_1.buildJsonPointer([]), schema);\n}\n\nexports.visitJsonSchema = visitJsonSchema;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/json/schema/visitor.js"],"names":["Object","defineProperty","exports","value","visitJsonSchema","visitJson","rxjs_1","require","operators_1","pointer_1","_getObjectSubSchema","schema","key","undefined","properties","type","additionalProperties","items","_visitJsonRecursive","json","visitor","ptr","refResolver","context","root","hasOwnProperty","resolved","isObservable","of","pipe","concatMap","Array","isArray","concat","from","mergeMap","item","i","joinJsonPointer","tap","x","ignoreElements","getOwnPropertyNames","descriptor","getOwnPropertyDescriptor","writable","buildJsonPointer","keywords","additionalItems","contains","propertyNames","not","arrayKeywords","allOf","anyOf","oneOf","propsKeywords","definitions","patternProperties","dependencies","_traverse","jsonPtr","rootSchema","parentSchema","keyIndex","keys","sch","prop","length"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,eAAR,GAA0BF,OAAO,CAACG,SAAR,GAAoB,KAAK,CAAnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,MAAM,GAAGC,OAAO,CAAC,MAAD,CAAtB;;AACA,IAAMC,WAAW,GAAGD,OAAO,CAAC,gBAAD,CAA3B;;AACA,IAAME,SAAS,GAAGF,OAAO,CAAC,WAAD,CAAzB;;AACA,SAASG,mBAAT,CAA6BC,MAA7B,EAAqCC,GAArC,EAA0C;AACtC,MAAI,OAAOD,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,KAAK,IAA7C,EAAmD;AAC/C,WAAOE,SAAP;AACH,GAHqC,CAItC;;;AACA,MAAI,OAAOF,MAAM,CAACG,UAAd,IAA4B,QAA5B,IAAwCH,MAAM,CAACI,IAAP,IAAe,QAA3D,EAAqE;AACjE,QAAI,OAAOJ,MAAM,CAACG,UAAd,IAA4B,QAA5B,IACA,OAAOH,MAAM,CAACG,UAAP,CAAkBF,GAAlB,CAAP,IAAiC,QADrC,EAC+C;AAC3C,aAAOD,MAAM,CAACG,UAAP,CAAkBF,GAAlB,CAAP;AACH;;AACD,QAAI,OAAOD,MAAM,CAACK,oBAAd,IAAsC,QAA1C,EAAoD;AAChD,aAAOL,MAAM,CAACK,oBAAd;AACH;;AACD,WAAOH,SAAP;AACH,GAdqC,CAetC;;;AACA,MAAI,OAAOF,MAAM,CAACM,KAAd,IAAuB,QAAvB,IAAmCN,MAAM,CAACI,IAAP,IAAe,OAAtD,EAA+D;AAC3D,WAAO,OAAOJ,MAAM,CAACM,KAAd,IAAuB,QAAvB,GAAkCN,MAAM,CAACM,KAAzC,GAAiDJ,SAAxD;AACH;;AACD,SAAOA,SAAP;AACH;;AACD,SAASK,mBAAT,CAA6BC,IAA7B,EAAmCC,OAAnC,EAA4CC,GAA5C,EAAiDV,MAAjD,EAAyDW,WAAzD,EAAsEC,OAAtE,EAA+EC,IAA/E,EAAqF;AACjF,MAAIb,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAlC,EAAyC;AACrC;AACAA,IAAAA,MAAM,GAAGE,SAAT;AACH;;AACD,MAAIF,MAAM,IAAIA,MAAM,CAACc,cAAP,CAAsB,MAAtB,CAAV,IAA2C,OAAOd,MAAM,CAAC,MAAD,CAAb,IAAyB,QAAxE,EAAkF;AAC9E,QAAIW,WAAJ,EAAiB;AACb,UAAMI,QAAQ,GAAGJ,WAAW,CAACX,MAAM,CAAC,MAAD,CAAP,EAAiBY,OAAjB,CAA5B;AACAZ,MAAAA,MAAM,GAAGe,QAAQ,CAACf,MAAlB;AACAY,MAAAA,OAAO,GAAGG,QAAQ,CAACH,OAAnB;AACH;AACJ;;AACD,MAAMpB,KAAK,GAAGiB,OAAO,CAACD,IAAD,EAAOE,GAAP,EAAYV,MAAZ,EAAoBa,IAApB,CAArB;AACA,SAAO,CAAClB,MAAM,CAACqB,YAAP,CAAoBxB,KAApB,IAA6BA,KAA7B,GAAqCG,MAAM,CAACsB,EAAP,CAAUzB,KAAV,CAAtC,EAAwD0B,IAAxD,CAA6DrB,WAAW,CAACsB,SAAZ,CAAsB,UAAA3B,KAAK,EAAI;AAC/F,QAAI4B,KAAK,CAACC,OAAN,CAAc7B,KAAd,CAAJ,EAA0B;AACtB,aAAOG,MAAM,CAAC2B,MAAP,CAAc3B,MAAM,CAAC4B,IAAP,CAAY/B,KAAZ,EAAmB0B,IAAnB,CAAwBrB,WAAW,CAAC2B,QAAZ,CAAqB,UAACC,IAAD,EAAOC,CAAP,EAAa;AAC3E,eAAOnB,mBAAmB,CAACkB,IAAD,EAAOhB,OAAP,EAAgBX,SAAS,CAAC6B,eAAV,CAA0BjB,GAA1B,EAA+B,KAAKgB,CAApC,CAAhB,EAAwD3B,mBAAmB,CAACC,MAAD,EAAS,KAAK0B,CAAd,CAA3E,EAA6Ff,WAA7F,EAA0GC,OAA1G,EAAmHC,IAAI,IAAIrB,KAA3H,CAAnB,CAAqJ0B,IAArJ,CAA0JrB,WAAW,CAAC+B,GAAZ,CAAgB,UAAAC,CAAC;AAAA,iBAAKrC,KAAK,CAACkC,CAAD,CAAL,GAAWG,CAAhB;AAAA,SAAjB,CAA1J,CAAP;AACH,OAF4C,CAAxB,EAEjBhC,WAAW,CAACiC,cAAZ,EAFiB,CAAd,EAE4BnC,MAAM,CAACsB,EAAP,CAAUzB,KAAV,CAF5B,CAAP;AAGH,KAJD,MAKK,IAAI,OAAOA,KAAP,IAAgB,QAAhB,IAA4BA,KAAK,KAAK,IAA1C,EAAgD;AACjD,aAAOG,MAAM,CAAC2B,MAAP,CAAc3B,MAAM,CAAC4B,IAAP,CAAYlC,MAAM,CAAC0C,mBAAP,CAA2BvC,KAA3B,CAAZ,EAA+C0B,IAA/C,CAAoDrB,WAAW,CAAC2B,QAAZ,CAAqB,UAAAvB,GAAG,EAAI;AACjG,eAAOM,mBAAmB,CAACf,KAAK,CAACS,GAAD,CAAN,EAAaQ,OAAb,EAAsBX,SAAS,CAAC6B,eAAV,CAA0BjB,GAA1B,EAA+BT,GAA/B,CAAtB,EAA2DF,mBAAmB,CAACC,MAAD,EAASC,GAAT,CAA9E,EAA6FU,WAA7F,EAA0GC,OAA1G,EAAmHC,IAAI,IAAIrB,KAA3H,CAAnB,CAAqJ0B,IAArJ,CAA0JrB,WAAW,CAAC+B,GAAZ,CAAgB,UAAAC,CAAC,EAAI;AAClL,cAAMG,UAAU,GAAG3C,MAAM,CAAC4C,wBAAP,CAAgCzC,KAAhC,EAAuCS,GAAvC,CAAnB;;AACA,cAAI+B,UAAU,IAAIA,UAAU,CAACE,QAAzB,IAAqC1C,KAAK,CAACS,GAAD,CAAL,KAAe4B,CAAxD,EAA2D;AACvDrC,YAAAA,KAAK,CAACS,GAAD,CAAL,GAAa4B,CAAb;AACH;AACJ,SALgK,CAA1J,CAAP;AAMH,OAPwE,CAApD,EAOjBhC,WAAW,CAACiC,cAAZ,EAPiB,CAAd,EAO4BnC,MAAM,CAACsB,EAAP,CAAUzB,KAAV,CAP5B,CAAP;AAQH,KATI,MAUA;AACD,aAAOG,MAAM,CAACsB,EAAP,CAAUzB,KAAV,CAAP;AACH;AACJ,GAnBmE,CAA7D,CAAP;AAoBH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,SAAT,CAAmBc,IAAnB,EAAyBC,OAAzB,EAAkCT,MAAlC,EAA0CW,WAA1C,EAAuDC,OAAvD,EAAgE;AAC5D,SAAOL,mBAAmB,CAACC,IAAD,EAAOC,OAAP,EAAgBX,SAAS,CAACqC,gBAAV,CAA2B,EAA3B,CAAhB,EAAgDnC,MAAhD,EAAwDW,WAAxD,EAAqEC,OAArE,CAA1B;AACH;;AACDrB,OAAO,CAACG,SAAR,GAAoBA,SAApB;;AACA,SAASD,eAAT,CAAyBO,MAAzB,EAAiCS,OAAjC,EAA0C;AACtC,MAAIT,MAAM,KAAK,KAAX,IAAoBA,MAAM,KAAK,IAAnC,EAAyC;AACrC;AACA;AACH;;AACD,MAAMoC,QAAQ,GAAG;AACbC,IAAAA,eAAe,EAAE,IADJ;AAEb/B,IAAAA,KAAK,EAAE,IAFM;AAGbgC,IAAAA,QAAQ,EAAE,IAHG;AAIbjC,IAAAA,oBAAoB,EAAE,IAJT;AAKbkC,IAAAA,aAAa,EAAE,IALF;AAMbC,IAAAA,GAAG,EAAE;AANQ,GAAjB;AAQA,MAAMC,aAAa,GAAG;AAClBnC,IAAAA,KAAK,EAAE,IADW;AAElBoC,IAAAA,KAAK,EAAE,IAFW;AAGlBC,IAAAA,KAAK,EAAE,IAHW;AAIlBC,IAAAA,KAAK,EAAE;AAJW,GAAtB;AAMA,MAAMC,aAAa,GAAG;AAClBC,IAAAA,WAAW,EAAE,IADK;AAElB3C,IAAAA,UAAU,EAAE,IAFM;AAGlB4C,IAAAA,iBAAiB,EAAE,IAHD;AAIlB1C,IAAAA,oBAAoB,EAAE,IAJJ;AAKlB2C,IAAAA,YAAY,EAAE,IALI;AAMlB1C,IAAAA,KAAK,EAAE;AANW,GAAtB;;AAQA,WAAS2C,SAAT,CAAmBjD,MAAnB,EAA2BkD,OAA3B,EAAoCC,UAApC,EAAgDC,YAAhD,EAA8DC,QAA9D,EAAwE;AACpE,QAAIrD,MAAM,IAAI,OAAOA,MAAP,IAAiB,QAA3B,IAAuC,CAACoB,KAAK,CAACC,OAAN,CAAcrB,MAAd,CAA5C,EAAmE;AAC/DS,MAAAA,OAAO,CAACT,MAAD,EAASkD,OAAT,EAAkBE,YAAlB,EAAgCC,QAAhC,CAAP;;AACA,sCAAkBhE,MAAM,CAACiE,IAAP,CAAYtD,MAAZ,CAAlB,kCAAuC;AAAlC,YAAMC,GAAG,mBAAT;AACD,YAAMsD,GAAG,GAAGvD,MAAM,CAACC,GAAD,CAAlB;;AACA,YAAIA,GAAG,IAAI4C,aAAX,EAA0B;AACtB,cAAIU,GAAG,IAAI,OAAOA,GAAP,IAAc,QAAzB,EAAmC;AAC/B,8CAAmBlE,MAAM,CAACiE,IAAP,CAAYC,GAAZ,CAAnB,qCAAqC;AAAhC,kBAAMC,IAAI,qBAAV;;AACDP,cAAAA,SAAS,CAACM,GAAG,CAACC,IAAD,CAAJ,EAAY1D,SAAS,CAAC6B,eAAV,CAA0BuB,OAA1B,EAAmCjD,GAAnC,EAAwCuD,IAAxC,CAAZ,EAA2DL,UAA3D,EAAuEnD,MAAvE,EAA+EwD,IAA/E,CAAT;AACH;AACJ;AACJ,SAND,MAOK,IAAIvD,GAAG,IAAImC,QAAX,EAAqB;AACtBa,UAAAA,SAAS,CAACM,GAAD,EAAMzD,SAAS,CAAC6B,eAAV,CAA0BuB,OAA1B,EAAmCjD,GAAnC,CAAN,EAA+CkD,UAA/C,EAA2DnD,MAA3D,EAAmEC,GAAnE,CAAT;AACH,SAFI,MAGA,IAAIA,GAAG,IAAIwC,aAAX,EAA0B;AAC3B,cAAIrB,KAAK,CAACC,OAAN,CAAckC,GAAd,CAAJ,EAAwB;AACpB,iBAAK,IAAI7B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6B,GAAG,CAACE,MAAxB,EAAgC/B,CAAC,EAAjC,EAAqC;AACjCuB,cAAAA,SAAS,CAACM,GAAG,CAAC7B,CAAD,CAAJ,EAAS5B,SAAS,CAAC6B,eAAV,CAA0BuB,OAA1B,EAAmCjD,GAAnC,EAAwC,KAAKyB,CAA7C,CAAT,EAA0DyB,UAA1D,EAAsEI,GAAtE,EAA2E,KAAK7B,CAAhF,CAAT;AACH;AACJ;AACJ,SANI,MAOA,IAAIN,KAAK,CAACC,OAAN,CAAckC,GAAd,CAAJ,EAAwB;AACzB,eAAK,IAAI7B,GAAC,GAAG,CAAb,EAAgBA,GAAC,GAAG6B,GAAG,CAACE,MAAxB,EAAgC/B,GAAC,EAAjC,EAAqC;AACjCuB,YAAAA,SAAS,CAACM,GAAG,CAAC7B,GAAD,CAAJ,EAAS5B,SAAS,CAAC6B,eAAV,CAA0BuB,OAA1B,EAAmCjD,GAAnC,EAAwC,KAAKyB,GAA7C,CAAT,EAA0DyB,UAA1D,EAAsEI,GAAtE,EAA2E,KAAK7B,GAAhF,CAAT;AACH;AACJ;AACJ;AACJ;AACJ;;AACDuB,EAAAA,SAAS,CAACjD,MAAD,EAASF,SAAS,CAACqC,gBAAV,CAA2B,EAA3B,CAAT,EAAyCnC,MAAzC,CAAT;AACH;;AACDT,OAAO,CAACE,eAAR,GAA0BA,eAA1B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.visitJsonSchema = exports.visitJson = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst pointer_1 = require(\"./pointer\");\nfunction _getObjectSubSchema(schema, key) {\n    if (typeof schema !== 'object' || schema === null) {\n        return undefined;\n    }\n    // Is it an object schema?\n    if (typeof schema.properties == 'object' || schema.type == 'object') {\n        if (typeof schema.properties == 'object' &&\n            typeof schema.properties[key] == 'object') {\n            return schema.properties[key];\n        }\n        if (typeof schema.additionalProperties == 'object') {\n            return schema.additionalProperties;\n        }\n        return undefined;\n    }\n    // Is it an array schema?\n    if (typeof schema.items == 'object' || schema.type == 'array') {\n        return typeof schema.items == 'object' ? schema.items : undefined;\n    }\n    return undefined;\n}\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n    if (schema === true || schema === false) {\n        // There's no schema definition, so just visit the JSON recursively.\n        schema = undefined;\n    }\n    if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n        if (refResolver) {\n            const resolved = refResolver(schema['$ref'], context);\n            schema = resolved.schema;\n            context = resolved.context;\n        }\n    }\n    const value = visitor(json, ptr, schema, root);\n    return (rxjs_1.isObservable(value) ? value : rxjs_1.of(value)).pipe(operators_1.concatMap(value => {\n        if (Array.isArray(value)) {\n            return rxjs_1.concat(rxjs_1.from(value).pipe(operators_1.mergeMap((item, i) => {\n                return _visitJsonRecursive(item, visitor, pointer_1.joinJsonPointer(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe(operators_1.tap(x => (value[i] = x)));\n            }), operators_1.ignoreElements()), rxjs_1.of(value));\n        }\n        else if (typeof value == 'object' && value !== null) {\n            return rxjs_1.concat(rxjs_1.from(Object.getOwnPropertyNames(value)).pipe(operators_1.mergeMap(key => {\n                return _visitJsonRecursive(value[key], visitor, pointer_1.joinJsonPointer(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe(operators_1.tap(x => {\n                    const descriptor = Object.getOwnPropertyDescriptor(value, key);\n                    if (descriptor && descriptor.writable && value[key] !== x) {\n                        value[key] = x;\n                    }\n                }));\n            }), operators_1.ignoreElements()), rxjs_1.of(value));\n        }\n        else {\n            return rxjs_1.of(value);\n        }\n    }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\nfunction visitJson(json, visitor, schema, refResolver, context) {\n    return _visitJsonRecursive(json, visitor, pointer_1.buildJsonPointer([]), schema, refResolver, context);\n}\nexports.visitJson = visitJson;\nfunction visitJsonSchema(schema, visitor) {\n    if (schema === false || schema === true) {\n        // Nothing to visit.\n        return;\n    }\n    const keywords = {\n        additionalItems: true,\n        items: true,\n        contains: true,\n        additionalProperties: true,\n        propertyNames: true,\n        not: true,\n    };\n    const arrayKeywords = {\n        items: true,\n        allOf: true,\n        anyOf: true,\n        oneOf: true,\n    };\n    const propsKeywords = {\n        definitions: true,\n        properties: true,\n        patternProperties: true,\n        additionalProperties: true,\n        dependencies: true,\n        items: true,\n    };\n    function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n        if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n            visitor(schema, jsonPtr, parentSchema, keyIndex);\n            for (const key of Object.keys(schema)) {\n                const sch = schema[key];\n                if (key in propsKeywords) {\n                    if (sch && typeof sch == 'object') {\n                        for (const prop of Object.keys(sch)) {\n                            _traverse(sch[prop], pointer_1.joinJsonPointer(jsonPtr, key, prop), rootSchema, schema, prop);\n                        }\n                    }\n                }\n                else if (key in keywords) {\n                    _traverse(sch, pointer_1.joinJsonPointer(jsonPtr, key), rootSchema, schema, key);\n                }\n                else if (key in arrayKeywords) {\n                    if (Array.isArray(sch)) {\n                        for (let i = 0; i < sch.length; i++) {\n                            _traverse(sch[i], pointer_1.joinJsonPointer(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n                        }\n                    }\n                }\n                else if (Array.isArray(sch)) {\n                    for (let i = 0; i < sch.length; i++) {\n                        _traverse(sch[i], pointer_1.joinJsonPointer(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n                    }\n                }\n            }\n        }\n    }\n    _traverse(schema, pointer_1.buildJsonPointer([]), schema);\n}\nexports.visitJsonSchema = visitJsonSchema;\n"]},"metadata":{},"sourceType":"script"}