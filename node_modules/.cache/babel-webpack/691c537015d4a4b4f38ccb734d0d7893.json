{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Source = require(\"./Source\");\n\nvar RawSource = require(\"./RawSource\");\n\nvar _require = require(\"source-map\"),\n    SourceNode = _require.SourceNode;\n\nvar _require2 = require(\"./helpers\"),\n    getSourceAndMap = _require2.getSourceAndMap,\n    getMap = _require2.getMap;\n\nvar REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nvar PrefixSource = /*#__PURE__*/function (_Source) {\n  _inherits(PrefixSource, _Source);\n\n  var _super = _createSuper(PrefixSource);\n\n  function PrefixSource(prefix, source) {\n    var _this;\n\n    _classCallCheck(this, PrefixSource);\n\n    _this = _super.call(this);\n    _this._source = typeof source === \"string\" || Buffer.isBuffer(source) ? new RawSource(source, true) : source;\n    _this._prefix = prefix;\n    return _this;\n  }\n\n  _createClass(PrefixSource, [{\n    key: \"getPrefix\",\n    value: function getPrefix() {\n      return this._prefix;\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      var node = this._source.source();\n\n      var prefix = this._prefix;\n      return prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n    } // TODO efficient buffer() implementation\n\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"node\",\n    value: function node(options) {\n      var node = this._source.node(options);\n\n      var prefix = this._prefix;\n      var output = [];\n      var result = new SourceNode();\n      node.walkSourceContents(function (source, content) {\n        result.setSourceContent(source, content);\n      });\n      var needPrefix = true;\n      node.walk(function (chunk, mapping) {\n        var parts = chunk.split(/(\\n)/);\n\n        for (var i = 0; i < parts.length; i += 2) {\n          var nl = i + 1 < parts.length;\n          var part = parts[i] + (nl ? \"\\n\" : \"\");\n\n          if (part) {\n            if (needPrefix) {\n              output.push(prefix);\n            }\n\n            output.push(new SourceNode(mapping.line, mapping.column, mapping.source, part, mapping.name));\n            needPrefix = nl;\n          }\n        }\n      });\n      result.add(output);\n      return result;\n    }\n  }, {\n    key: \"listMap\",\n    value: function listMap(options) {\n      var prefix = this._prefix;\n\n      var map = this._source.listMap(options);\n\n      var prefixNextLine = true;\n      return map.mapGeneratedCode(function (code) {\n        var updatedCode = code.replace(REPLACE_REGEX, \"\\n\" + prefix);\n        if (prefixNextLine) updatedCode = prefix + updatedCode;\n        prefixNextLine = code.charCodeAt(code.length - 1) === 10; // === /\\n$/.test(code)\n\n        return updatedCode;\n      });\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"PrefixSource\");\n\n      this._source.updateHash(hash);\n\n      hash.update(this._prefix);\n    }\n  }]);\n\n  return PrefixSource;\n}(Source);\n\nmodule.exports = PrefixSource;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/webpack-sources/lib/PrefixSource.js"],"names":["Source","require","RawSource","SourceNode","getSourceAndMap","getMap","REPLACE_REGEX","PrefixSource","prefix","source","_source","Buffer","isBuffer","_prefix","node","replace","options","output","result","walkSourceContents","content","setSourceContent","needPrefix","walk","chunk","mapping","parts","split","i","length","nl","part","push","line","column","name","add","map","listMap","prefixNextLine","mapGeneratedCode","code","updatedCode","charCodeAt","hash","update","updateHash","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst RawSource = require(\"./RawSource\");\nconst { SourceNode } = require(\"source-map\");\nconst { getSourceAndMap, getMap } = require(\"./helpers\");\n\nconst REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nclass PrefixSource extends Source {\n\tconstructor(prefix, source) {\n\t\tsuper();\n\t\tthis._source =\n\t\t\ttypeof source === \"string\" || Buffer.isBuffer(source)\n\t\t\t\t? new RawSource(source, true)\n\t\t\t\t: source;\n\t\tthis._prefix = prefix;\n\t}\n\n\tgetPrefix() {\n\t\treturn this._prefix;\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\tsource() {\n\t\tconst node = this._source.source();\n\t\tconst prefix = this._prefix;\n\t\treturn prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t}\n\n\t// TODO efficient buffer() implementation\n\n\tmap(options) {\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\tnode(options) {\n\t\tconst node = this._source.node(options);\n\t\tconst prefix = this._prefix;\n\t\tconst output = [];\n\t\tconst result = new SourceNode();\n\t\tnode.walkSourceContents(function (source, content) {\n\t\t\tresult.setSourceContent(source, content);\n\t\t});\n\t\tlet needPrefix = true;\n\t\tnode.walk(function (chunk, mapping) {\n\t\t\tconst parts = chunk.split(/(\\n)/);\n\t\t\tfor (let i = 0; i < parts.length; i += 2) {\n\t\t\t\tconst nl = i + 1 < parts.length;\n\t\t\t\tconst part = parts[i] + (nl ? \"\\n\" : \"\");\n\t\t\t\tif (part) {\n\t\t\t\t\tif (needPrefix) {\n\t\t\t\t\t\toutput.push(prefix);\n\t\t\t\t\t}\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tnew SourceNode(\n\t\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\t\tmapping.column,\n\t\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\t\tpart,\n\t\t\t\t\t\t\tmapping.name\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t\tneedPrefix = nl;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tresult.add(output);\n\t\treturn result;\n\t}\n\n\tlistMap(options) {\n\t\tconst prefix = this._prefix;\n\t\tconst map = this._source.listMap(options);\n\t\tlet prefixNextLine = true;\n\t\treturn map.mapGeneratedCode(function (code) {\n\t\t\tlet updatedCode = code.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t\t\tif (prefixNextLine) updatedCode = prefix + updatedCode;\n\t\t\tprefixNextLine = code.charCodeAt(code.length - 1) === 10; // === /\\n$/.test(code)\n\t\t\treturn updatedCode;\n\t\t});\n\t}\n\n\tupdateHash(hash) {\n\t\thash.update(\"PrefixSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._prefix);\n\t}\n}\n\nmodule.exports = PrefixSource;\n"]},"metadata":{},"sourceType":"script"}