{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/host/umd_host\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/ngcc/src/utils\", \"@angular/compiler-cli/ngcc/src/host/commonjs_umd_utils\", \"@angular/compiler-cli/ngcc/src/host/esm2015_host\", \"@angular/compiler-cli/ngcc/src/host/esm5_host\", \"@angular/compiler-cli/ngcc/src/host/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getImportsOfUmdModule = exports.parseStatementForUmdModule = exports.UmdReflectionHost = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/utils\");\n\n  var commonjs_umd_utils_1 = require(\"@angular/compiler-cli/ngcc/src/host/commonjs_umd_utils\");\n\n  var esm2015_host_1 = require(\"@angular/compiler-cli/ngcc/src/host/esm2015_host\");\n\n  var esm5_host_1 = require(\"@angular/compiler-cli/ngcc/src/host/esm5_host\");\n\n  var utils_2 = require(\"@angular/compiler-cli/ngcc/src/host/utils\");\n\n  var UmdReflectionHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(UmdReflectionHost, _super);\n\n    function UmdReflectionHost(logger, isCore, src, dts) {\n      if (dts === void 0) {\n        dts = null;\n      }\n\n      var _this = _super.call(this, logger, isCore, src, dts) || this;\n\n      _this.umdModules = new utils_1.FactoryMap(function (sf) {\n        return _this.computeUmdModule(sf);\n      });\n      _this.umdExports = new utils_1.FactoryMap(function (sf) {\n        return _this.computeExportsOfUmdModule(sf);\n      });\n      _this.umdImportPaths = new utils_1.FactoryMap(function (param) {\n        return _this.computeImportPath(param);\n      });\n      _this.program = src.program;\n      _this.compilerHost = src.host;\n      return _this;\n    }\n\n    UmdReflectionHost.prototype.getImportOfIdentifier = function (id) {\n      // Is `id` a namespaced property access, e.g. `Directive` in `core.Directive`?\n      // If so capture the symbol of the namespace, e.g. `core`.\n      var nsIdentifier = commonjs_umd_utils_1.findNamespaceOfIdentifier(id);\n      var importParameter = nsIdentifier && this.findUmdImportParameter(nsIdentifier);\n      var from = importParameter && this.getUmdImportPath(importParameter);\n      return from !== null ? {\n        from: from,\n        name: id.text\n      } : null;\n    };\n\n    UmdReflectionHost.prototype.getDeclarationOfIdentifier = function (id) {\n      // First we try one of the following:\n      // 1. The `exports` identifier - referring to the current file/module.\n      // 2. An identifier (e.g. `foo`) that refers to an imported UMD module.\n      // 3. A UMD style export identifier (e.g. the `foo` of `exports.foo`).\n      var declaration = this.getExportsDeclaration(id) || this.getUmdModuleDeclaration(id) || this.getUmdDeclaration(id);\n\n      if (declaration !== null) {\n        return declaration;\n      } // Try to get the declaration using the super class.\n\n\n      var superDeclaration = _super.prototype.getDeclarationOfIdentifier.call(this, id);\n\n      if (superDeclaration === null) {\n        return null;\n      } // Check to see if the declaration is the inner node of a declaration IIFE.\n\n\n      var outerNode = esm2015_host_1.getOuterNodeFromInnerDeclaration(superDeclaration.node);\n\n      if (outerNode === null) {\n        return superDeclaration;\n      } // We are only interested if the outer declaration is of the form\n      // `exports.<name> = <initializer>`.\n\n\n      if (!commonjs_umd_utils_1.isExportsAssignment(outerNode)) {\n        return superDeclaration;\n      }\n\n      return {\n        kind: 1\n        /* Inline */\n        ,\n        node: outerNode.left,\n        implementation: outerNode.right,\n        known: null,\n        viaModule: null\n      };\n    };\n\n    UmdReflectionHost.prototype.getExportsOfModule = function (module) {\n      return _super.prototype.getExportsOfModule.call(this, module) || this.umdExports.get(module.getSourceFile());\n    };\n\n    UmdReflectionHost.prototype.getUmdModule = function (sourceFile) {\n      if (sourceFile.isDeclarationFile) {\n        return null;\n      }\n\n      return this.umdModules.get(sourceFile);\n    };\n\n    UmdReflectionHost.prototype.getUmdImportPath = function (importParameter) {\n      return this.umdImportPaths.get(importParameter);\n    };\n    /**\n     * Get the top level statements for a module.\n     *\n     * In UMD modules these are the body of the UMD factory function.\n     *\n     * @param sourceFile The module whose statements we want.\n     * @returns An array of top level statements for the given module.\n     */\n\n\n    UmdReflectionHost.prototype.getModuleStatements = function (sourceFile) {\n      var umdModule = this.getUmdModule(sourceFile);\n      return umdModule !== null ? Array.from(umdModule.factoryFn.body.statements) : [];\n    };\n\n    UmdReflectionHost.prototype.getClassSymbolFromOuterDeclaration = function (declaration) {\n      var superSymbol = _super.prototype.getClassSymbolFromOuterDeclaration.call(this, declaration);\n\n      if (superSymbol) {\n        return superSymbol;\n      }\n\n      if (!commonjs_umd_utils_1.isExportsDeclaration(declaration)) {\n        return undefined;\n      }\n\n      var initializer = commonjs_umd_utils_1.skipAliases(declaration.parent.right);\n\n      if (ts.isIdentifier(initializer)) {\n        var implementation = this.getDeclarationOfIdentifier(initializer);\n\n        if (implementation !== null) {\n          var implementationSymbol = this.getClassSymbol(implementation.node);\n\n          if (implementationSymbol !== null) {\n            return implementationSymbol;\n          }\n        }\n      }\n\n      var innerDeclaration = esm2015_host_1.getInnerClassDeclaration(initializer);\n\n      if (innerDeclaration !== null) {\n        return this.createClassSymbol(declaration.name, innerDeclaration);\n      }\n\n      return undefined;\n    };\n\n    UmdReflectionHost.prototype.getClassSymbolFromInnerDeclaration = function (declaration) {\n      var superClassSymbol = _super.prototype.getClassSymbolFromInnerDeclaration.call(this, declaration);\n\n      if (superClassSymbol !== undefined) {\n        return superClassSymbol;\n      }\n\n      if (!reflection_1.isNamedFunctionDeclaration(declaration)) {\n        return undefined;\n      }\n\n      var outerNode = esm2015_host_1.getOuterNodeFromInnerDeclaration(declaration);\n\n      if (outerNode === null || !commonjs_umd_utils_1.isExportsAssignment(outerNode)) {\n        return undefined;\n      }\n\n      return this.createClassSymbol(outerNode.left.name, declaration);\n    };\n    /**\n     * Extract all \"classes\" from the `statement` and add them to the `classes` map.\n     */\n\n\n    UmdReflectionHost.prototype.addClassSymbolsFromStatement = function (classes, statement) {\n      _super.prototype.addClassSymbolsFromStatement.call(this, classes, statement); // Also check for exports of the form: `exports.<name> = <class def>;`\n\n\n      if (commonjs_umd_utils_1.isExportsStatement(statement)) {\n        var classSymbol = this.getClassSymbol(statement.expression.left);\n\n        if (classSymbol) {\n          classes.set(classSymbol.implementation, classSymbol);\n        }\n      }\n    };\n    /**\n     * Analyze the given statement to see if it corresponds with an exports declaration like\n     * `exports.MyClass = MyClass_1 = <class def>;`. If so, the declaration of `MyClass_1`\n     * is associated with the `MyClass` identifier.\n     *\n     * @param statement The statement that needs to be preprocessed.\n     */\n\n\n    UmdReflectionHost.prototype.preprocessStatement = function (statement) {\n      _super.prototype.preprocessStatement.call(this, statement);\n\n      if (!commonjs_umd_utils_1.isExportsStatement(statement)) {\n        return;\n      }\n\n      var declaration = statement.expression.left;\n      var initializer = statement.expression.right;\n\n      if (!esm2015_host_1.isAssignment(initializer) || !ts.isIdentifier(initializer.left) || !this.isClass(declaration)) {\n        return;\n      }\n\n      var aliasedIdentifier = initializer.left;\n      var aliasedDeclaration = this.getDeclarationOfIdentifier(aliasedIdentifier);\n\n      if (aliasedDeclaration === null || aliasedDeclaration.node === null) {\n        throw new Error(\"Unable to locate declaration of \" + aliasedIdentifier.text + \" in \\\"\" + statement.getText() + \"\\\"\");\n      }\n\n      this.aliasedClassDeclarations.set(aliasedDeclaration.node, declaration.name);\n    };\n\n    UmdReflectionHost.prototype.computeUmdModule = function (sourceFile) {\n      if (sourceFile.statements.length !== 1) {\n        throw new Error(\"Expected UMD module file (\" + sourceFile.fileName + \") to contain exactly one statement, \" + (\"but found \" + sourceFile.statements.length + \".\"));\n      }\n\n      return parseStatementForUmdModule(sourceFile.statements[0]);\n    };\n\n    UmdReflectionHost.prototype.computeExportsOfUmdModule = function (sourceFile) {\n      var e_1, _a, e_2, _b;\n\n      var moduleMap = new Map();\n\n      try {\n        for (var _c = tslib_1.__values(this.getModuleStatements(sourceFile)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var statement = _d.value;\n\n          if (commonjs_umd_utils_1.isExportsStatement(statement)) {\n            var exportDeclaration = this.extractBasicUmdExportDeclaration(statement);\n\n            if (!moduleMap.has(exportDeclaration.name)) {\n              // We assume that the first `exports.<name>` is the actual declaration, and that any\n              // subsequent statements that match are decorating the original declaration.\n              // For example:\n              // ```\n              // exports.foo = <declaration>;\n              // exports.foo = __decorate(<decorator>, exports.foo);\n              // ```\n              // The declaration is the first line not the second.\n              moduleMap.set(exportDeclaration.name, exportDeclaration.declaration);\n            }\n          } else if (commonjs_umd_utils_1.isWildcardReexportStatement(statement)) {\n            var reexports = this.extractUmdWildcardReexports(statement, sourceFile);\n\n            try {\n              for (var reexports_1 = (e_2 = void 0, tslib_1.__values(reexports)), reexports_1_1 = reexports_1.next(); !reexports_1_1.done; reexports_1_1 = reexports_1.next()) {\n                var reexport = reexports_1_1.value;\n                moduleMap.set(reexport.name, reexport.declaration);\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (reexports_1_1 && !reexports_1_1.done && (_b = reexports_1.return)) _b.call(reexports_1);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n          } else if (commonjs_umd_utils_1.isDefinePropertyReexportStatement(statement)) {\n            var exportDeclaration = this.extractUmdDefinePropertyExportDeclaration(statement);\n\n            if (exportDeclaration !== null) {\n              moduleMap.set(exportDeclaration.name, exportDeclaration.declaration);\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return moduleMap;\n    };\n\n    UmdReflectionHost.prototype.computeImportPath = function (param) {\n      var e_3, _a;\n\n      var umdModule = this.getUmdModule(param.getSourceFile());\n\n      if (umdModule === null) {\n        return null;\n      }\n\n      var imports = getImportsOfUmdModule(umdModule);\n\n      if (imports === null) {\n        return null;\n      }\n\n      var importPath = null;\n\n      try {\n        for (var imports_1 = tslib_1.__values(imports), imports_1_1 = imports_1.next(); !imports_1_1.done; imports_1_1 = imports_1.next()) {\n          var i = imports_1_1.value; // Add all imports to the map to speed up future look ups.\n\n          this.umdImportPaths.set(i.parameter, i.path);\n\n          if (i.parameter === param) {\n            importPath = i.path;\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (imports_1_1 && !imports_1_1.done && (_a = imports_1.return)) _a.call(imports_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return importPath;\n    };\n\n    UmdReflectionHost.prototype.extractBasicUmdExportDeclaration = function (statement) {\n      var _a;\n\n      var name = statement.expression.left.name.text;\n      var exportExpression = commonjs_umd_utils_1.skipAliases(statement.expression.right);\n      var declaration = (_a = this.getDeclarationOfExpression(exportExpression)) !== null && _a !== void 0 ? _a : {\n        kind: 1\n        /* Inline */\n        ,\n        node: statement.expression.left,\n        implementation: statement.expression.right,\n        known: null,\n        viaModule: null\n      };\n      return {\n        name: name,\n        declaration: declaration\n      };\n    };\n\n    UmdReflectionHost.prototype.extractUmdWildcardReexports = function (statement, containingFile) {\n      var reexportArg = statement.expression.arguments[0];\n      var requireCall = commonjs_umd_utils_1.isRequireCall(reexportArg) ? reexportArg : ts.isIdentifier(reexportArg) ? commonjs_umd_utils_1.findRequireCallReference(reexportArg, this.checker) : null;\n      var importPath = null;\n\n      if (requireCall !== null) {\n        importPath = requireCall.arguments[0].text;\n      } else if (ts.isIdentifier(reexportArg)) {\n        var importParameter = this.findUmdImportParameter(reexportArg);\n        importPath = importParameter && this.getUmdImportPath(importParameter);\n      }\n\n      if (importPath === null) {\n        return [];\n      }\n\n      var importedFile = this.resolveModuleName(importPath, containingFile);\n\n      if (importedFile === undefined) {\n        return [];\n      }\n\n      var importedExports = this.getExportsOfModule(importedFile);\n\n      if (importedExports === null) {\n        return [];\n      }\n\n      var viaModule = utils_1.stripExtension(importedFile.fileName);\n      var reexports = [];\n      importedExports.forEach(function (decl, name) {\n        return reexports.push({\n          name: name,\n          declaration: tslib_1.__assign(tslib_1.__assign({}, decl), {\n            viaModule: viaModule\n          })\n        });\n      });\n      return reexports;\n    };\n\n    UmdReflectionHost.prototype.extractUmdDefinePropertyExportDeclaration = function (statement) {\n      var args = statement.expression.arguments;\n      var name = args[1].text;\n      var getterFnExpression = commonjs_umd_utils_1.extractGetterFnExpression(statement);\n\n      if (getterFnExpression === null) {\n        return null;\n      }\n\n      var declaration = this.getDeclarationOfExpression(getterFnExpression);\n\n      if (declaration !== null) {\n        return {\n          name: name,\n          declaration: declaration\n        };\n      }\n\n      return {\n        name: name,\n        declaration: {\n          kind: 1\n          /* Inline */\n          ,\n          node: args[1],\n          implementation: getterFnExpression,\n          known: null,\n          viaModule: null\n        }\n      };\n    };\n    /**\n     * Is the identifier a parameter on a UMD factory function, e.g. `function factory(this, core)`?\n     * If so then return its declaration.\n     */\n\n\n    UmdReflectionHost.prototype.findUmdImportParameter = function (id) {\n      var symbol = id && this.checker.getSymbolAtLocation(id) || null;\n      var declaration = symbol && symbol.valueDeclaration;\n      return declaration && ts.isParameter(declaration) ? declaration : null;\n    };\n\n    UmdReflectionHost.prototype.getUmdDeclaration = function (id) {\n      var nsIdentifier = commonjs_umd_utils_1.findNamespaceOfIdentifier(id);\n\n      if (nsIdentifier === null) {\n        return null;\n      }\n\n      if (nsIdentifier.parent.parent && commonjs_umd_utils_1.isExportsAssignment(nsIdentifier.parent.parent)) {\n        var initializer = nsIdentifier.parent.parent.right;\n\n        if (ts.isIdentifier(initializer)) {\n          return this.getDeclarationOfIdentifier(initializer);\n        }\n\n        return this.detectKnownDeclaration({\n          kind: 1\n          /* Inline */\n          ,\n          node: nsIdentifier.parent.parent.left,\n          implementation: commonjs_umd_utils_1.skipAliases(nsIdentifier.parent.parent.right),\n          viaModule: null,\n          known: null\n        });\n      }\n\n      var moduleDeclaration = this.getUmdModuleDeclaration(nsIdentifier);\n\n      if (moduleDeclaration === null || moduleDeclaration.node === null || !ts.isSourceFile(moduleDeclaration.node)) {\n        return null;\n      }\n\n      var moduleExports = this.getExportsOfModule(moduleDeclaration.node);\n\n      if (moduleExports === null) {\n        return null;\n      } // We need to compute the `viaModule` because  the `getExportsOfModule()` call\n      // did not know that we were importing the declaration.\n\n\n      var declaration = moduleExports.get(id.text);\n\n      if (!moduleExports.has(id.text)) {\n        return null;\n      } // We need to compute the `viaModule` because  the `getExportsOfModule()` call\n      // did not know that we were importing the declaration.\n\n\n      var viaModule = declaration.viaModule === null ? moduleDeclaration.viaModule : declaration.viaModule;\n      return tslib_1.__assign(tslib_1.__assign({}, declaration), {\n        viaModule: viaModule,\n        known: utils_1.getTsHelperFnFromIdentifier(id)\n      });\n    };\n\n    UmdReflectionHost.prototype.getExportsDeclaration = function (id) {\n      if (!isExportsIdentifier(id)) {\n        return null;\n      } // Sadly, in the case of `exports.foo = bar`, we can't use `this.findUmdImportParameter(id)`\n      // to check whether this `exports` is from the IIFE body arguments, because\n      // `this.checker.getSymbolAtLocation(id)` will return the symbol for the `foo` identifier\n      // rather than the `exports` identifier.\n      //\n      // Instead we search the symbols in the current local scope.\n\n\n      var exportsSymbol = this.checker.getSymbolsInScope(id, ts.SymbolFlags.Variable).find(function (symbol) {\n        return symbol.name === 'exports';\n      });\n      var node = exportsSymbol !== undefined && !ts.isFunctionExpression(exportsSymbol.valueDeclaration.parent) ? // There is a locally defined `exports` variable that is not a function parameter.\n      // So this `exports` identifier must be a local variable and does not represent the module.\n      exportsSymbol.valueDeclaration : // There is no local symbol or it is a parameter of an IIFE.\n      // So this `exports` represents the current \"module\".\n      id.getSourceFile();\n      return {\n        kind: 0\n        /* Concrete */\n        ,\n        node: node,\n        viaModule: null,\n        known: null,\n        identity: null\n      };\n    };\n\n    UmdReflectionHost.prototype.getUmdModuleDeclaration = function (id) {\n      var importPath = this.getImportPathFromParameter(id) || this.getImportPathFromRequireCall(id);\n\n      if (importPath === null) {\n        return null;\n      }\n\n      var module = this.resolveModuleName(importPath, id.getSourceFile());\n\n      if (module === undefined) {\n        return null;\n      }\n\n      var viaModule = commonjs_umd_utils_1.isExternalImport(importPath) ? importPath : null;\n      return {\n        kind: 0\n        /* Concrete */\n        ,\n        node: module,\n        viaModule: viaModule,\n        known: null,\n        identity: null\n      };\n    };\n\n    UmdReflectionHost.prototype.getImportPathFromParameter = function (id) {\n      var importParameter = this.findUmdImportParameter(id);\n\n      if (importParameter === null) {\n        return null;\n      }\n\n      return this.getUmdImportPath(importParameter);\n    };\n\n    UmdReflectionHost.prototype.getImportPathFromRequireCall = function (id) {\n      var requireCall = commonjs_umd_utils_1.findRequireCallReference(id, this.checker);\n\n      if (requireCall === null) {\n        return null;\n      }\n\n      return requireCall.arguments[0].text;\n    };\n    /**\n     * If this is an IIFE then try to grab the outer and inner classes otherwise fallback on the super\n     * class.\n     */\n\n\n    UmdReflectionHost.prototype.getDeclarationOfExpression = function (expression) {\n      var inner = esm2015_host_1.getInnerClassDeclaration(expression);\n\n      if (inner !== null) {\n        var outer = esm2015_host_1.getOuterNodeFromInnerDeclaration(inner);\n\n        if (outer !== null && commonjs_umd_utils_1.isExportsAssignment(outer)) {\n          return {\n            kind: 1\n            /* Inline */\n            ,\n            node: outer.left,\n            implementation: inner,\n            known: null,\n            viaModule: null\n          };\n        }\n      }\n\n      return _super.prototype.getDeclarationOfExpression.call(this, expression);\n    };\n\n    UmdReflectionHost.prototype.resolveModuleName = function (moduleName, containingFile) {\n      if (this.compilerHost.resolveModuleNames) {\n        var moduleInfo = this.compilerHost.resolveModuleNames([moduleName], containingFile.fileName, undefined, undefined, this.program.getCompilerOptions())[0];\n        return moduleInfo && this.program.getSourceFile(file_system_1.absoluteFrom(moduleInfo.resolvedFileName));\n      } else {\n        var moduleInfo = ts.resolveModuleName(moduleName, containingFile.fileName, this.program.getCompilerOptions(), this.compilerHost);\n        return moduleInfo.resolvedModule && this.program.getSourceFile(file_system_1.absoluteFrom(moduleInfo.resolvedModule.resolvedFileName));\n      }\n    };\n\n    return UmdReflectionHost;\n  }(esm5_host_1.Esm5ReflectionHost);\n\n  exports.UmdReflectionHost = UmdReflectionHost;\n\n  function parseStatementForUmdModule(statement) {\n    var wrapperCall = getUmdWrapperCall(statement);\n    if (!wrapperCall) return null;\n    var wrapperFn = wrapperCall.expression;\n    if (!ts.isFunctionExpression(wrapperFn)) return null;\n    var factoryFnParamIndex = wrapperFn.parameters.findIndex(function (parameter) {\n      return ts.isIdentifier(parameter.name) && parameter.name.text === 'factory';\n    });\n    if (factoryFnParamIndex === -1) return null;\n    var factoryFn = utils_2.stripParentheses(wrapperCall.arguments[factoryFnParamIndex]);\n    if (!factoryFn || !ts.isFunctionExpression(factoryFn)) return null;\n    return {\n      wrapperFn: wrapperFn,\n      factoryFn: factoryFn\n    };\n  }\n\n  exports.parseStatementForUmdModule = parseStatementForUmdModule;\n\n  function getUmdWrapperCall(statement) {\n    if (!ts.isExpressionStatement(statement) || !ts.isParenthesizedExpression(statement.expression) || !ts.isCallExpression(statement.expression.expression) || !ts.isFunctionExpression(statement.expression.expression.expression)) {\n      return null;\n    }\n\n    return statement.expression.expression;\n  }\n\n  function getImportsOfUmdModule(umdModule) {\n    var imports = [];\n\n    for (var i = 1; i < umdModule.factoryFn.parameters.length; i++) {\n      imports.push({\n        parameter: umdModule.factoryFn.parameters[i],\n        path: getRequiredModulePath(umdModule.wrapperFn, i)\n      });\n    }\n\n    return imports;\n  }\n\n  exports.getImportsOfUmdModule = getImportsOfUmdModule;\n\n  function getRequiredModulePath(wrapperFn, paramIndex) {\n    var statement = wrapperFn.body.statements[0];\n\n    if (!ts.isExpressionStatement(statement)) {\n      throw new Error('UMD wrapper body is not an expression statement:\\n' + wrapperFn.body.getText());\n    }\n\n    var modulePaths = [];\n    findModulePaths(statement.expression); // Since we were only interested in the `require()` calls, we miss the `exports` argument, so we\n    // need to subtract 1.\n    // E.g. `function(exports, dep1, dep2)` maps to `function(exports, require('path/to/dep1'),\n    // require('path/to/dep2'))`\n\n    return modulePaths[paramIndex - 1]; // Search the statement for calls to `require('...')` and extract the string value of the first\n    // argument\n\n    function findModulePaths(node) {\n      if (commonjs_umd_utils_1.isRequireCall(node)) {\n        var argument = node.arguments[0];\n\n        if (ts.isStringLiteral(argument)) {\n          modulePaths.push(argument.text);\n        }\n      } else {\n        node.forEachChild(findModulePaths);\n      }\n    }\n  }\n  /**\n   * Is the `node` an identifier with the name \"exports\"?\n   */\n\n\n  function isExportsIdentifier(node) {\n    return ts.isIdentifier(node) && node.text === 'exports';\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/host/umd_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {absoluteFrom} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {Declaration, DeclarationKind, Import, isNamedFunctionDeclaration} from '../../../src/ngtsc/reflection';\nimport {BundleProgram} from '../packages/bundle_program';\nimport {FactoryMap, getTsHelperFnFromIdentifier, stripExtension} from '../utils';\n\nimport {DefinePropertyReexportStatement, ExportDeclaration, ExportsStatement, extractGetterFnExpression, findNamespaceOfIdentifier, findRequireCallReference, isDefinePropertyReexportStatement, isExportsAssignment, isExportsDeclaration, isExportsStatement, isExternalImport, isRequireCall, isWildcardReexportStatement, skipAliases, WildcardReexportStatement} from './commonjs_umd_utils';\nimport {getInnerClassDeclaration, getOuterNodeFromInnerDeclaration, isAssignment} from './esm2015_host';\nimport {Esm5ReflectionHost} from './esm5_host';\nimport {NgccClassSymbol} from './ngcc_host';\nimport {stripParentheses} from './utils';\n\nexport class UmdReflectionHost extends Esm5ReflectionHost {\n  protected umdModules =\n      new FactoryMap<ts.SourceFile, UmdModule|null>(sf => this.computeUmdModule(sf));\n  protected umdExports = new FactoryMap<ts.SourceFile, Map<string, Declaration>|null>(\n      sf => this.computeExportsOfUmdModule(sf));\n  protected umdImportPaths =\n      new FactoryMap<ts.ParameterDeclaration, string|null>(param => this.computeImportPath(param));\n  protected program: ts.Program;\n  protected compilerHost: ts.CompilerHost;\n\n  constructor(logger: Logger, isCore: boolean, src: BundleProgram, dts: BundleProgram|null = null) {\n    super(logger, isCore, src, dts);\n    this.program = src.program;\n    this.compilerHost = src.host;\n  }\n\n  getImportOfIdentifier(id: ts.Identifier): Import|null {\n    // Is `id` a namespaced property access, e.g. `Directive` in `core.Directive`?\n    // If so capture the symbol of the namespace, e.g. `core`.\n    const nsIdentifier = findNamespaceOfIdentifier(id);\n    const importParameter = nsIdentifier && this.findUmdImportParameter(nsIdentifier);\n    const from = importParameter && this.getUmdImportPath(importParameter);\n    return from !== null ? {from, name: id.text} : null;\n  }\n\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null {\n    // First we try one of the following:\n    // 1. The `exports` identifier - referring to the current file/module.\n    // 2. An identifier (e.g. `foo`) that refers to an imported UMD module.\n    // 3. A UMD style export identifier (e.g. the `foo` of `exports.foo`).\n    const declaration = this.getExportsDeclaration(id) || this.getUmdModuleDeclaration(id) ||\n        this.getUmdDeclaration(id);\n    if (declaration !== null) {\n      return declaration;\n    }\n\n    // Try to get the declaration using the super class.\n    const superDeclaration = super.getDeclarationOfIdentifier(id);\n    if (superDeclaration === null) {\n      return null;\n    }\n\n    // Check to see if the declaration is the inner node of a declaration IIFE.\n    const outerNode = getOuterNodeFromInnerDeclaration(superDeclaration.node);\n    if (outerNode === null) {\n      return superDeclaration;\n    }\n\n    // We are only interested if the outer declaration is of the form\n    // `exports.<name> = <initializer>`.\n    if (!isExportsAssignment(outerNode)) {\n      return superDeclaration;\n    }\n\n    return {\n      kind: DeclarationKind.Inline,\n      node: outerNode.left,\n      implementation: outerNode.right,\n      known: null,\n      viaModule: null,\n    };\n  }\n\n  getExportsOfModule(module: ts.Node): Map<string, Declaration>|null {\n    return super.getExportsOfModule(module) || this.umdExports.get(module.getSourceFile());\n  }\n\n  getUmdModule(sourceFile: ts.SourceFile): UmdModule|null {\n    if (sourceFile.isDeclarationFile) {\n      return null;\n    }\n\n    return this.umdModules.get(sourceFile);\n  }\n\n  getUmdImportPath(importParameter: ts.ParameterDeclaration): string|null {\n    return this.umdImportPaths.get(importParameter);\n  }\n\n  /**\n   * Get the top level statements for a module.\n   *\n   * In UMD modules these are the body of the UMD factory function.\n   *\n   * @param sourceFile The module whose statements we want.\n   * @returns An array of top level statements for the given module.\n   */\n  protected getModuleStatements(sourceFile: ts.SourceFile): ts.Statement[] {\n    const umdModule = this.getUmdModule(sourceFile);\n    return umdModule !== null ? Array.from(umdModule.factoryFn.body.statements) : [];\n  }\n\n  protected getClassSymbolFromOuterDeclaration(declaration: ts.Node): NgccClassSymbol|undefined {\n    const superSymbol = super.getClassSymbolFromOuterDeclaration(declaration);\n    if (superSymbol) {\n      return superSymbol;\n    }\n\n    if (!isExportsDeclaration(declaration)) {\n      return undefined;\n    }\n\n    let initializer = skipAliases(declaration.parent.right);\n\n    if (ts.isIdentifier(initializer)) {\n      const implementation = this.getDeclarationOfIdentifier(initializer);\n      if (implementation !== null) {\n        const implementationSymbol = this.getClassSymbol(implementation.node);\n        if (implementationSymbol !== null) {\n          return implementationSymbol;\n        }\n      }\n    }\n\n    const innerDeclaration = getInnerClassDeclaration(initializer);\n    if (innerDeclaration !== null) {\n      return this.createClassSymbol(declaration.name, innerDeclaration);\n    }\n\n    return undefined;\n  }\n\n\n  protected getClassSymbolFromInnerDeclaration(declaration: ts.Node): NgccClassSymbol|undefined {\n    const superClassSymbol = super.getClassSymbolFromInnerDeclaration(declaration);\n    if (superClassSymbol !== undefined) {\n      return superClassSymbol;\n    }\n\n    if (!isNamedFunctionDeclaration(declaration)) {\n      return undefined;\n    }\n\n    const outerNode = getOuterNodeFromInnerDeclaration(declaration);\n    if (outerNode === null || !isExportsAssignment(outerNode)) {\n      return undefined;\n    }\n\n    return this.createClassSymbol(outerNode.left.name, declaration);\n  }\n\n  /**\n   * Extract all \"classes\" from the `statement` and add them to the `classes` map.\n   */\n  protected addClassSymbolsFromStatement(\n      classes: Map<ts.Symbol, NgccClassSymbol>, statement: ts.Statement): void {\n    super.addClassSymbolsFromStatement(classes, statement);\n\n    // Also check for exports of the form: `exports.<name> = <class def>;`\n    if (isExportsStatement(statement)) {\n      const classSymbol = this.getClassSymbol(statement.expression.left);\n      if (classSymbol) {\n        classes.set(classSymbol.implementation, classSymbol);\n      }\n    }\n  }\n\n  /**\n   * Analyze the given statement to see if it corresponds with an exports declaration like\n   * `exports.MyClass = MyClass_1 = <class def>;`. If so, the declaration of `MyClass_1`\n   * is associated with the `MyClass` identifier.\n   *\n   * @param statement The statement that needs to be preprocessed.\n   */\n  protected preprocessStatement(statement: ts.Statement): void {\n    super.preprocessStatement(statement);\n\n    if (!isExportsStatement(statement)) {\n      return;\n    }\n\n    const declaration = statement.expression.left;\n    const initializer = statement.expression.right;\n    if (!isAssignment(initializer) || !ts.isIdentifier(initializer.left) ||\n        !this.isClass(declaration)) {\n      return;\n    }\n\n    const aliasedIdentifier = initializer.left;\n\n    const aliasedDeclaration = this.getDeclarationOfIdentifier(aliasedIdentifier);\n    if (aliasedDeclaration === null || aliasedDeclaration.node === null) {\n      throw new Error(\n          `Unable to locate declaration of ${aliasedIdentifier.text} in \"${statement.getText()}\"`);\n    }\n    this.aliasedClassDeclarations.set(aliasedDeclaration.node, declaration.name);\n  }\n\n  private computeUmdModule(sourceFile: ts.SourceFile): UmdModule|null {\n    if (sourceFile.statements.length !== 1) {\n      throw new Error(\n          `Expected UMD module file (${sourceFile.fileName}) to contain exactly one statement, ` +\n          `but found ${sourceFile.statements.length}.`);\n    }\n\n    return parseStatementForUmdModule(sourceFile.statements[0]);\n  }\n\n  private computeExportsOfUmdModule(sourceFile: ts.SourceFile): Map<string, Declaration>|null {\n    const moduleMap = new Map<string, Declaration>();\n    for (const statement of this.getModuleStatements(sourceFile)) {\n      if (isExportsStatement(statement)) {\n        const exportDeclaration = this.extractBasicUmdExportDeclaration(statement);\n        if (!moduleMap.has(exportDeclaration.name)) {\n          // We assume that the first `exports.<name>` is the actual declaration, and that any\n          // subsequent statements that match are decorating the original declaration.\n          // For example:\n          // ```\n          // exports.foo = <declaration>;\n          // exports.foo = __decorate(<decorator>, exports.foo);\n          // ```\n          // The declaration is the first line not the second.\n          moduleMap.set(exportDeclaration.name, exportDeclaration.declaration);\n        }\n      } else if (isWildcardReexportStatement(statement)) {\n        const reexports = this.extractUmdWildcardReexports(statement, sourceFile);\n        for (const reexport of reexports) {\n          moduleMap.set(reexport.name, reexport.declaration);\n        }\n      } else if (isDefinePropertyReexportStatement(statement)) {\n        const exportDeclaration = this.extractUmdDefinePropertyExportDeclaration(statement);\n        if (exportDeclaration !== null) {\n          moduleMap.set(exportDeclaration.name, exportDeclaration.declaration);\n        }\n      }\n    }\n    return moduleMap;\n  }\n\n  private computeImportPath(param: ts.ParameterDeclaration): string|null {\n    const umdModule = this.getUmdModule(param.getSourceFile());\n    if (umdModule === null) {\n      return null;\n    }\n\n    const imports = getImportsOfUmdModule(umdModule);\n    if (imports === null) {\n      return null;\n    }\n\n    let importPath: string|null = null;\n\n    for (const i of imports) {\n      // Add all imports to the map to speed up future look ups.\n      this.umdImportPaths.set(i.parameter, i.path);\n      if (i.parameter === param) {\n        importPath = i.path;\n      }\n    }\n\n    return importPath;\n  }\n\n  private extractBasicUmdExportDeclaration(statement: ExportsStatement): ExportDeclaration {\n    const name = statement.expression.left.name.text;\n    const exportExpression = skipAliases(statement.expression.right);\n    const declaration = this.getDeclarationOfExpression(exportExpression) ?? {\n      kind: DeclarationKind.Inline,\n      node: statement.expression.left,\n      implementation: statement.expression.right,\n      known: null,\n      viaModule: null,\n    };\n    return {name, declaration};\n  }\n\n  private extractUmdWildcardReexports(\n      statement: WildcardReexportStatement, containingFile: ts.SourceFile): ExportDeclaration[] {\n    const reexportArg = statement.expression.arguments[0];\n\n    const requireCall = isRequireCall(reexportArg) ?\n        reexportArg :\n        ts.isIdentifier(reexportArg) ? findRequireCallReference(reexportArg, this.checker) : null;\n\n    let importPath: string|null = null;\n\n    if (requireCall !== null) {\n      importPath = requireCall.arguments[0].text;\n    } else if (ts.isIdentifier(reexportArg)) {\n      const importParameter = this.findUmdImportParameter(reexportArg);\n      importPath = importParameter && this.getUmdImportPath(importParameter);\n    }\n\n    if (importPath === null) {\n      return [];\n    }\n\n    const importedFile = this.resolveModuleName(importPath, containingFile);\n    if (importedFile === undefined) {\n      return [];\n    }\n\n    const importedExports = this.getExportsOfModule(importedFile);\n    if (importedExports === null) {\n      return [];\n    }\n\n    const viaModule = stripExtension(importedFile.fileName);\n    const reexports: ExportDeclaration[] = [];\n    importedExports.forEach(\n        (decl, name) => reexports.push({name, declaration: {...decl, viaModule}}));\n    return reexports;\n  }\n\n  private extractUmdDefinePropertyExportDeclaration(statement: DefinePropertyReexportStatement):\n      ExportDeclaration|null {\n    const args = statement.expression.arguments;\n    const name = args[1].text;\n    const getterFnExpression = extractGetterFnExpression(statement);\n    if (getterFnExpression === null) {\n      return null;\n    }\n\n    const declaration = this.getDeclarationOfExpression(getterFnExpression);\n    if (declaration !== null) {\n      return {name, declaration};\n    }\n\n    return {\n      name,\n      declaration: {\n        kind: DeclarationKind.Inline,\n        node: args[1],\n        implementation: getterFnExpression,\n        known: null,\n        viaModule: null,\n      },\n    };\n  }\n\n  /**\n   * Is the identifier a parameter on a UMD factory function, e.g. `function factory(this, core)`?\n   * If so then return its declaration.\n   */\n  private findUmdImportParameter(id: ts.Identifier): ts.ParameterDeclaration|null {\n    const symbol = id && this.checker.getSymbolAtLocation(id) || null;\n    const declaration = symbol && symbol.valueDeclaration;\n    return declaration && ts.isParameter(declaration) ? declaration : null;\n  }\n\n  private getUmdDeclaration(id: ts.Identifier): Declaration|null {\n    const nsIdentifier = findNamespaceOfIdentifier(id);\n    if (nsIdentifier === null) {\n      return null;\n    }\n\n    if (nsIdentifier.parent.parent && isExportsAssignment(nsIdentifier.parent.parent)) {\n      const initializer = nsIdentifier.parent.parent.right;\n      if (ts.isIdentifier(initializer)) {\n        return this.getDeclarationOfIdentifier(initializer);\n      }\n      return this.detectKnownDeclaration({\n        kind: DeclarationKind.Inline,\n        node: nsIdentifier.parent.parent.left,\n        implementation: skipAliases(nsIdentifier.parent.parent.right),\n        viaModule: null,\n        known: null,\n      });\n    }\n\n    const moduleDeclaration = this.getUmdModuleDeclaration(nsIdentifier);\n    if (moduleDeclaration === null || moduleDeclaration.node === null ||\n        !ts.isSourceFile(moduleDeclaration.node)) {\n      return null;\n    }\n\n    const moduleExports = this.getExportsOfModule(moduleDeclaration.node);\n    if (moduleExports === null) {\n      return null;\n    }\n\n    // We need to compute the `viaModule` because  the `getExportsOfModule()` call\n    // did not know that we were importing the declaration.\n    const declaration = moduleExports.get(id.text)!;\n\n    if (!moduleExports.has(id.text)) {\n      return null;\n    }\n\n    // We need to compute the `viaModule` because  the `getExportsOfModule()` call\n    // did not know that we were importing the declaration.\n    const viaModule =\n        declaration.viaModule === null ? moduleDeclaration.viaModule : declaration.viaModule;\n\n    return {...declaration, viaModule, known: getTsHelperFnFromIdentifier(id)};\n  }\n\n  private getExportsDeclaration(id: ts.Identifier): Declaration|null {\n    if (!isExportsIdentifier(id)) {\n      return null;\n    }\n\n    // Sadly, in the case of `exports.foo = bar`, we can't use `this.findUmdImportParameter(id)`\n    // to check whether this `exports` is from the IIFE body arguments, because\n    // `this.checker.getSymbolAtLocation(id)` will return the symbol for the `foo` identifier\n    // rather than the `exports` identifier.\n    //\n    // Instead we search the symbols in the current local scope.\n    const exportsSymbol = this.checker.getSymbolsInScope(id, ts.SymbolFlags.Variable)\n                              .find(symbol => symbol.name === 'exports');\n\n    const node = exportsSymbol !== undefined &&\n            !ts.isFunctionExpression(exportsSymbol.valueDeclaration.parent) ?\n        // There is a locally defined `exports` variable that is not a function parameter.\n        // So this `exports` identifier must be a local variable and does not represent the module.\n        exportsSymbol.valueDeclaration :\n        // There is no local symbol or it is a parameter of an IIFE.\n        // So this `exports` represents the current \"module\".\n        id.getSourceFile();\n\n    return {\n      kind: DeclarationKind.Concrete,\n      node,\n      viaModule: null,\n      known: null,\n      identity: null,\n    };\n  }\n\n  private getUmdModuleDeclaration(id: ts.Identifier): Declaration|null {\n    const importPath = this.getImportPathFromParameter(id) || this.getImportPathFromRequireCall(id);\n    if (importPath === null) {\n      return null;\n    }\n\n    const module = this.resolveModuleName(importPath, id.getSourceFile());\n    if (module === undefined) {\n      return null;\n    }\n\n    const viaModule = isExternalImport(importPath) ? importPath : null;\n    return {kind: DeclarationKind.Concrete, node: module, viaModule, known: null, identity: null};\n  }\n\n  private getImportPathFromParameter(id: ts.Identifier): string|null {\n    const importParameter = this.findUmdImportParameter(id);\n    if (importParameter === null) {\n      return null;\n    }\n    return this.getUmdImportPath(importParameter);\n  }\n\n  private getImportPathFromRequireCall(id: ts.Identifier): string|null {\n    const requireCall = findRequireCallReference(id, this.checker);\n    if (requireCall === null) {\n      return null;\n    }\n    return requireCall.arguments[0].text;\n  }\n\n  /**\n   * If this is an IIFE then try to grab the outer and inner classes otherwise fallback on the super\n   * class.\n   */\n  protected getDeclarationOfExpression(expression: ts.Expression): Declaration|null {\n    const inner = getInnerClassDeclaration(expression);\n    if (inner !== null) {\n      const outer = getOuterNodeFromInnerDeclaration(inner);\n      if (outer !== null && isExportsAssignment(outer)) {\n        return {\n          kind: DeclarationKind.Inline,\n          node: outer.left,\n          implementation: inner,\n          known: null,\n          viaModule: null,\n        };\n      }\n    }\n    return super.getDeclarationOfExpression(expression);\n  }\n\n  private resolveModuleName(moduleName: string, containingFile: ts.SourceFile): ts.SourceFile\n      |undefined {\n    if (this.compilerHost.resolveModuleNames) {\n      const moduleInfo = this.compilerHost.resolveModuleNames(\n          [moduleName], containingFile.fileName, undefined, undefined,\n          this.program.getCompilerOptions())[0];\n      return moduleInfo && this.program.getSourceFile(absoluteFrom(moduleInfo.resolvedFileName));\n    } else {\n      const moduleInfo = ts.resolveModuleName(\n          moduleName, containingFile.fileName, this.program.getCompilerOptions(),\n          this.compilerHost);\n      return moduleInfo.resolvedModule &&\n          this.program.getSourceFile(absoluteFrom(moduleInfo.resolvedModule.resolvedFileName));\n    }\n  }\n}\n\nexport function parseStatementForUmdModule(statement: ts.Statement): UmdModule|null {\n  const wrapperCall = getUmdWrapperCall(statement);\n  if (!wrapperCall) return null;\n\n  const wrapperFn = wrapperCall.expression;\n  if (!ts.isFunctionExpression(wrapperFn)) return null;\n\n  const factoryFnParamIndex = wrapperFn.parameters.findIndex(\n      parameter => ts.isIdentifier(parameter.name) && parameter.name.text === 'factory');\n  if (factoryFnParamIndex === -1) return null;\n\n  const factoryFn = stripParentheses(wrapperCall.arguments[factoryFnParamIndex]);\n  if (!factoryFn || !ts.isFunctionExpression(factoryFn)) return null;\n\n  return {wrapperFn, factoryFn};\n}\n\nfunction getUmdWrapperCall(statement: ts.Statement): ts.CallExpression&\n    {expression: ts.FunctionExpression}|null {\n  if (!ts.isExpressionStatement(statement) || !ts.isParenthesizedExpression(statement.expression) ||\n      !ts.isCallExpression(statement.expression.expression) ||\n      !ts.isFunctionExpression(statement.expression.expression.expression)) {\n    return null;\n  }\n  return statement.expression.expression as ts.CallExpression & {expression: ts.FunctionExpression};\n}\n\n\nexport function getImportsOfUmdModule(umdModule: UmdModule):\n    {parameter: ts.ParameterDeclaration, path: string}[] {\n  const imports: {parameter: ts.ParameterDeclaration, path: string}[] = [];\n  for (let i = 1; i < umdModule.factoryFn.parameters.length; i++) {\n    imports.push({\n      parameter: umdModule.factoryFn.parameters[i],\n      path: getRequiredModulePath(umdModule.wrapperFn, i)\n    });\n  }\n  return imports;\n}\n\ninterface UmdModule {\n  wrapperFn: ts.FunctionExpression;\n  factoryFn: ts.FunctionExpression;\n}\n\nfunction getRequiredModulePath(wrapperFn: ts.FunctionExpression, paramIndex: number): string {\n  const statement = wrapperFn.body.statements[0];\n  if (!ts.isExpressionStatement(statement)) {\n    throw new Error(\n        'UMD wrapper body is not an expression statement:\\n' + wrapperFn.body.getText());\n  }\n  const modulePaths: string[] = [];\n  findModulePaths(statement.expression);\n\n  // Since we were only interested in the `require()` calls, we miss the `exports` argument, so we\n  // need to subtract 1.\n  // E.g. `function(exports, dep1, dep2)` maps to `function(exports, require('path/to/dep1'),\n  // require('path/to/dep2'))`\n  return modulePaths[paramIndex - 1];\n\n  // Search the statement for calls to `require('...')` and extract the string value of the first\n  // argument\n  function findModulePaths(node: ts.Node) {\n    if (isRequireCall(node)) {\n      const argument = node.arguments[0];\n      if (ts.isStringLiteral(argument)) {\n        modulePaths.push(argument.text);\n      }\n    } else {\n      node.forEachChild(findModulePaths);\n    }\n  }\n}\n\n/**\n * Is the `node` an identifier with the name \"exports\"?\n */\nfunction isExportsIdentifier(node: ts.Node): node is ts.Identifier {\n  return ts.isIdentifier(node) && node.text === 'exports';\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}