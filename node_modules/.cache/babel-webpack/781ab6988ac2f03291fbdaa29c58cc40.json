{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/i18n/i18n_ast\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.RecurseVisitor = exports.CloneVisitor = exports.IcuPlaceholder = exports.Placeholder = exports.TagPlaceholder = exports.Icu = exports.Container = exports.Text = exports.Message = void 0;\n\n  var Message =\n  /** @class */\n  function () {\n    /**\n     * @param nodes message AST\n     * @param placeholders maps placeholder names to static content and their source spans\n     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n     * @param meaning\n     * @param description\n     * @param customId\n     */\n    function Message(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n      this.nodes = nodes;\n      this.placeholders = placeholders;\n      this.placeholderToMessage = placeholderToMessage;\n      this.meaning = meaning;\n      this.description = description;\n      this.customId = customId;\n      this.id = this.customId;\n      /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n\n      this.legacyIds = [];\n\n      if (nodes.length) {\n        this.sources = [{\n          filePath: nodes[0].sourceSpan.start.file.url,\n          startLine: nodes[0].sourceSpan.start.line + 1,\n          startCol: nodes[0].sourceSpan.start.col + 1,\n          endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n          endCol: nodes[0].sourceSpan.start.col + 1\n        }];\n      } else {\n        this.sources = [];\n      }\n    }\n\n    return Message;\n  }();\n\n  exports.Message = Message;\n\n  var Text =\n  /** @class */\n  function () {\n    function Text(value, sourceSpan) {\n      this.value = value;\n      this.sourceSpan = sourceSpan;\n    }\n\n    Text.prototype.visit = function (visitor, context) {\n      return visitor.visitText(this, context);\n    };\n\n    return Text;\n  }();\n\n  exports.Text = Text; // TODO(vicb): do we really need this node (vs an array) ?\n\n  var Container =\n  /** @class */\n  function () {\n    function Container(children, sourceSpan) {\n      this.children = children;\n      this.sourceSpan = sourceSpan;\n    }\n\n    Container.prototype.visit = function (visitor, context) {\n      return visitor.visitContainer(this, context);\n    };\n\n    return Container;\n  }();\n\n  exports.Container = Container;\n\n  var Icu =\n  /** @class */\n  function () {\n    function Icu(expression, type, cases, sourceSpan) {\n      this.expression = expression;\n      this.type = type;\n      this.cases = cases;\n      this.sourceSpan = sourceSpan;\n    }\n\n    Icu.prototype.visit = function (visitor, context) {\n      return visitor.visitIcu(this, context);\n    };\n\n    return Icu;\n  }();\n\n  exports.Icu = Icu;\n\n  var TagPlaceholder =\n  /** @class */\n  function () {\n    function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n    sourceSpan, startSourceSpan, endSourceSpan) {\n      this.tag = tag;\n      this.attrs = attrs;\n      this.startName = startName;\n      this.closeName = closeName;\n      this.children = children;\n      this.isVoid = isVoid;\n      this.sourceSpan = sourceSpan;\n      this.startSourceSpan = startSourceSpan;\n      this.endSourceSpan = endSourceSpan;\n    }\n\n    TagPlaceholder.prototype.visit = function (visitor, context) {\n      return visitor.visitTagPlaceholder(this, context);\n    };\n\n    return TagPlaceholder;\n  }();\n\n  exports.TagPlaceholder = TagPlaceholder;\n\n  var Placeholder =\n  /** @class */\n  function () {\n    function Placeholder(value, name, sourceSpan) {\n      this.value = value;\n      this.name = name;\n      this.sourceSpan = sourceSpan;\n    }\n\n    Placeholder.prototype.visit = function (visitor, context) {\n      return visitor.visitPlaceholder(this, context);\n    };\n\n    return Placeholder;\n  }();\n\n  exports.Placeholder = Placeholder;\n\n  var IcuPlaceholder =\n  /** @class */\n  function () {\n    function IcuPlaceholder(value, name, sourceSpan) {\n      this.value = value;\n      this.name = name;\n      this.sourceSpan = sourceSpan;\n    }\n\n    IcuPlaceholder.prototype.visit = function (visitor, context) {\n      return visitor.visitIcuPlaceholder(this, context);\n    };\n\n    return IcuPlaceholder;\n  }();\n\n  exports.IcuPlaceholder = IcuPlaceholder; // Clone the AST\n\n  var CloneVisitor =\n  /** @class */\n  function () {\n    function CloneVisitor() {}\n\n    CloneVisitor.prototype.visitText = function (text, context) {\n      return new Text(text.value, text.sourceSpan);\n    };\n\n    CloneVisitor.prototype.visitContainer = function (container, context) {\n      var _this = this;\n\n      var children = container.children.map(function (n) {\n        return n.visit(_this, context);\n      });\n      return new Container(children, container.sourceSpan);\n    };\n\n    CloneVisitor.prototype.visitIcu = function (icu, context) {\n      var _this = this;\n\n      var cases = {};\n      Object.keys(icu.cases).forEach(function (key) {\n        return cases[key] = icu.cases[key].visit(_this, context);\n      });\n      var msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n      msg.expressionPlaceholder = icu.expressionPlaceholder;\n      return msg;\n    };\n\n    CloneVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n      var _this = this;\n\n      var children = ph.children.map(function (n) {\n        return n.visit(_this, context);\n      });\n      return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    };\n\n    CloneVisitor.prototype.visitPlaceholder = function (ph, context) {\n      return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    };\n\n    CloneVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n      return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    };\n\n    return CloneVisitor;\n  }();\n\n  exports.CloneVisitor = CloneVisitor; // Visit all the nodes recursively\n\n  var RecurseVisitor =\n  /** @class */\n  function () {\n    function RecurseVisitor() {}\n\n    RecurseVisitor.prototype.visitText = function (text, context) {};\n\n    RecurseVisitor.prototype.visitContainer = function (container, context) {\n      var _this = this;\n\n      container.children.forEach(function (child) {\n        return child.visit(_this);\n      });\n    };\n\n    RecurseVisitor.prototype.visitIcu = function (icu, context) {\n      var _this = this;\n\n      Object.keys(icu.cases).forEach(function (k) {\n        icu.cases[k].visit(_this);\n      });\n    };\n\n    RecurseVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n      var _this = this;\n\n      ph.children.forEach(function (child) {\n        return child.visit(_this);\n      });\n    };\n\n    RecurseVisitor.prototype.visitPlaceholder = function (ph, context) {};\n\n    RecurseVisitor.prototype.visitIcuPlaceholder = function (ph, context) {};\n\n    return RecurseVisitor;\n  }();\n\n  exports.RecurseVisitor = RecurseVisitor;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/i18n/i18n_ast.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\n/**\n * Describes the text contents of a placeholder as it appears in an ICU expression, including its\n * source span information.\n */\nexport interface MessagePlaceholder {\n  /** The text contents of the placeholder */\n  text: string;\n\n  /** The source span of the placeholder */\n  sourceSpan: ParseSourceSpan;\n}\n\nexport class Message {\n  sources: MessageSpan[];\n  id: string = this.customId;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n  legacyIds: string[] = [];\n\n  /**\n   * @param nodes message AST\n   * @param placeholders maps placeholder names to static content and their source spans\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param customId\n   */\n  constructor(\n      public nodes: Node[], public placeholders: {[phName: string]: MessagePlaceholder},\n      public placeholderToMessage: {[phName: string]: Message}, public meaning: string,\n      public description: string, public customId: string) {\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  // TODO(issue/24571): remove '!'.\n  public expressionPlaceholder!: string;\n  constructor(\n      public expression: string, public type: string, public cases: {[k: string]: Node},\n      public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n      public tag: string, public attrs: {[k: string]: string}, public startName: string,\n      public closeName: string, public children: Node[], public isVoid: boolean,\n      // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null,\n      public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  /** Used to capture a message computed from a previous processing pass (see `setI18nRefs()`). */\n  previousMessage?: Message;\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\n/**\n * Each HTML node that is affect by an i18n tag will also have an `i18n` property that is of type\n * `I18nMeta`.\n * This information is either a `Message`, which indicates it is the root of an i18n message, or a\n * `Node`, which indicates is it part of a containing `Message`.\n */\nexport type I18nMeta = Message|Node;\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n    msg.expressionPlaceholder = icu.expressionPlaceholder;\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(\n        ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan,\n        ph.startSourceSpan, ph.endSourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}