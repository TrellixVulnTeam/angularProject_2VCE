{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\", [\"require\", \"exports\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/annotations/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.generateSetClassMetadataCall = void 0;\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/util\");\n  /**\n   * Given a class declaration, generate a call to `setClassMetadata` with the Angular metadata\n   * present on the class or its member fields. An ngDevMode guard is used to allow the call to be\n   * tree-shaken away, as the `setClassMetadata` invocation is only needed for testing purposes.\n   *\n   * If no such metadata is present, this function returns `null`. Otherwise, the call is returned\n   * as a `Statement` for inclusion along with the class.\n   */\n\n\n  function generateSetClassMetadataCall(clazz, reflection, isCore, annotateForClosureCompiler) {\n    if (!reflection.isClass(clazz)) {\n      return null;\n    }\n\n    var id = reflection.getAdjacentNameOfClass(clazz); // Reflect over the class decorators. If none are present, or those that are aren't from\n    // Angular, then return null. Otherwise, turn them into metadata.\n\n    var classDecorators = reflection.getDecoratorsOfDeclaration(clazz);\n\n    if (classDecorators === null) {\n      return null;\n    }\n\n    var ngClassDecorators = classDecorators.filter(function (dec) {\n      return isAngularDecorator(dec, isCore);\n    }).map(function (decorator) {\n      return decoratorToMetadata(decorator, annotateForClosureCompiler);\n    }) // Since the `setClassMetadata` call is intended to be emitted after the class\n    // declaration, we have to strip references to the existing identifiers or\n    // TypeScript might generate invalid code when it emits to JS. In particular\n    // this can break when emitting a class to ES5 which has a custom decorator\n    // and is referenced inside of its own metadata (see #39509 for more information).\n    .map(function (decorator) {\n      return removeIdentifierReferences(decorator, id.text);\n    });\n\n    if (ngClassDecorators.length === 0) {\n      return null;\n    }\n\n    var metaDecorators = ts.createArrayLiteral(ngClassDecorators); // Convert the constructor parameters to metadata, passing null if none are present.\n\n    var metaCtorParameters = new compiler_1.LiteralExpr(null);\n    var classCtorParameters = reflection.getConstructorParameters(clazz);\n\n    if (classCtorParameters !== null) {\n      var ctorParameters = classCtorParameters.map(function (param) {\n        return ctorParameterToMetadata(param, isCore);\n      });\n      metaCtorParameters = new compiler_1.FunctionExpr([], [new compiler_1.ReturnStatement(new compiler_1.LiteralArrayExpr(ctorParameters))]);\n    } // Do the same for property decorators.\n\n\n    var metaPropDecorators = ts.createNull();\n    var classMembers = reflection.getMembersOfClass(clazz).filter(function (member) {\n      return !member.isStatic && member.decorators !== null && member.decorators.length > 0;\n    });\n    var duplicateDecoratedMemberNames = classMembers.map(function (member) {\n      return member.name;\n    }).filter(function (name, i, arr) {\n      return arr.indexOf(name) < i;\n    });\n\n    if (duplicateDecoratedMemberNames.length > 0) {\n      // This should theoretically never happen, because the only way to have duplicate instance\n      // member names is getter/setter pairs and decorators cannot appear in both a getter and the\n      // corresponding setter.\n      throw new Error(\"Duplicate decorated properties found on class '\" + clazz.name.text + \"': \" + duplicateDecoratedMemberNames.join(', '));\n    }\n\n    var decoratedMembers = classMembers.map(function (member) {\n      var _a;\n\n      return classMemberToMetadata((_a = member.nameNode) !== null && _a !== void 0 ? _a : member.name, member.decorators, isCore);\n    });\n\n    if (decoratedMembers.length > 0) {\n      metaPropDecorators = ts.createObjectLiteral(decoratedMembers);\n    } // Generate a pure call to setClassMetadata with the class identifier and its metadata.\n\n\n    var setClassMetadata = new compiler_1.ExternalExpr(compiler_1.Identifiers.setClassMetadata);\n    var fnCall = new compiler_1.InvokeFunctionExpr(\n    /* fn */\n    setClassMetadata,\n    /* args */\n    [new compiler_1.WrappedNodeExpr(id), new compiler_1.WrappedNodeExpr(metaDecorators), metaCtorParameters, new compiler_1.WrappedNodeExpr(metaPropDecorators)]);\n    var iife = new compiler_1.FunctionExpr([], [compiler_1.devOnlyGuardedExpression(fnCall).toStmt()]);\n    return iife.callFn([]).toStmt();\n  }\n\n  exports.generateSetClassMetadataCall = generateSetClassMetadataCall;\n  /**\n   * Convert a reflected constructor parameter to metadata.\n   */\n\n  function ctorParameterToMetadata(param, isCore) {\n    // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise\n    // its type is undefined.\n    var type = param.typeValueReference.kind !== 2\n    /* UNAVAILABLE */\n    ? util_1.valueReferenceToExpression(param.typeValueReference) : new compiler_1.LiteralExpr(undefined);\n    var mapEntries = [{\n      key: 'type',\n      value: type,\n      quoted: false\n    }]; // If the parameter has decorators, include the ones from Angular.\n\n    if (param.decorators !== null) {\n      var ngDecorators = param.decorators.filter(function (dec) {\n        return isAngularDecorator(dec, isCore);\n      }).map(function (decorator) {\n        return decoratorToMetadata(decorator);\n      });\n      var value = new compiler_1.WrappedNodeExpr(ts.createArrayLiteral(ngDecorators));\n      mapEntries.push({\n        key: 'decorators',\n        value: value,\n        quoted: false\n      });\n    }\n\n    return compiler_1.literalMap(mapEntries);\n  }\n  /**\n   * Convert a reflected class member to metadata.\n   */\n\n\n  function classMemberToMetadata(name, decorators, isCore) {\n    var ngDecorators = decorators.filter(function (dec) {\n      return isAngularDecorator(dec, isCore);\n    }).map(function (decorator) {\n      return decoratorToMetadata(decorator);\n    });\n    var decoratorMeta = ts.createArrayLiteral(ngDecorators);\n    return ts.createPropertyAssignment(name, decoratorMeta);\n  }\n  /**\n   * Convert a reflected decorator to metadata.\n   */\n\n\n  function decoratorToMetadata(decorator, wrapFunctionsInParens) {\n    if (decorator.identifier === null) {\n      throw new Error('Illegal state: synthesized decorator cannot be emitted in class metadata.');\n    } // Decorators have a type.\n\n\n    var properties = [ts.createPropertyAssignment('type', ts.getMutableClone(decorator.identifier))]; // Sometimes they have arguments.\n\n    if (decorator.args !== null && decorator.args.length > 0) {\n      var args = decorator.args.map(function (arg) {\n        var expr = ts.getMutableClone(arg);\n        return wrapFunctionsInParens ? util_1.wrapFunctionExpressionsInParens(expr) : expr;\n      });\n      properties.push(ts.createPropertyAssignment('args', ts.createArrayLiteral(args)));\n    }\n\n    return ts.createObjectLiteral(properties, true);\n  }\n  /**\n   * Whether a given decorator should be treated as an Angular decorator.\n   *\n   * Either it's used in @angular/core, or it's imported from there.\n   */\n\n\n  function isAngularDecorator(decorator, isCore) {\n    return isCore || decorator.import !== null && decorator.import.from === '@angular/core';\n  }\n  /**\n   * Recursively recreates all of the `Identifier` descendant nodes with a particular name inside\n   * of an AST node, thus removing any references to them. Useful if a particular node has to be t\n   * aken from one place any emitted to another one exactly as it has been written.\n   */\n\n\n  function removeIdentifierReferences(node, name) {\n    var result = ts.transform(node, [function (context) {\n      return function (root) {\n        return ts.visitNode(root, function walk(current) {\n          return ts.isIdentifier(current) && current.text === name ? ts.createIdentifier(current.text) : ts.visitEachChild(current, walk, context);\n        });\n      };\n    }]);\n    return result.transformed[0];\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/metadata.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {devOnlyGuardedExpression, Expression, ExternalExpr, FunctionExpr, Identifiers, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, literalMap, NONE_TYPE, ReturnStatement, Statement, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {CtorParameter, DeclarationNode, Decorator, ReflectionHost, TypeValueReferenceKind} from '../../reflection';\n\nimport {valueReferenceToExpression, wrapFunctionExpressionsInParens} from './util';\n\n\n/**\n * Given a class declaration, generate a call to `setClassMetadata` with the Angular metadata\n * present on the class or its member fields. An ngDevMode guard is used to allow the call to be\n * tree-shaken away, as the `setClassMetadata` invocation is only needed for testing purposes.\n *\n * If no such metadata is present, this function returns `null`. Otherwise, the call is returned\n * as a `Statement` for inclusion along with the class.\n */\nexport function generateSetClassMetadataCall(\n    clazz: DeclarationNode, reflection: ReflectionHost, isCore: boolean,\n    annotateForClosureCompiler?: boolean): Statement|null {\n  if (!reflection.isClass(clazz)) {\n    return null;\n  }\n  const id = reflection.getAdjacentNameOfClass(clazz);\n\n  // Reflect over the class decorators. If none are present, or those that are aren't from\n  // Angular, then return null. Otherwise, turn them into metadata.\n  const classDecorators = reflection.getDecoratorsOfDeclaration(clazz);\n  if (classDecorators === null) {\n    return null;\n  }\n  const ngClassDecorators =\n      classDecorators.filter(dec => isAngularDecorator(dec, isCore))\n          .map(decorator => decoratorToMetadata(decorator, annotateForClosureCompiler))\n          // Since the `setClassMetadata` call is intended to be emitted after the class\n          // declaration, we have to strip references to the existing identifiers or\n          // TypeScript might generate invalid code when it emits to JS. In particular\n          // this can break when emitting a class to ES5 which has a custom decorator\n          // and is referenced inside of its own metadata (see #39509 for more information).\n          .map(decorator => removeIdentifierReferences(decorator, id.text));\n  if (ngClassDecorators.length === 0) {\n    return null;\n  }\n  const metaDecorators = ts.createArrayLiteral(ngClassDecorators);\n\n  // Convert the constructor parameters to metadata, passing null if none are present.\n  let metaCtorParameters: Expression = new LiteralExpr(null);\n  const classCtorParameters = reflection.getConstructorParameters(clazz);\n  if (classCtorParameters !== null) {\n    const ctorParameters = classCtorParameters.map(param => ctorParameterToMetadata(param, isCore));\n    metaCtorParameters = new FunctionExpr([], [\n      new ReturnStatement(new LiteralArrayExpr(ctorParameters)),\n    ]);\n  }\n\n  // Do the same for property decorators.\n  let metaPropDecorators: ts.Expression = ts.createNull();\n  const classMembers = reflection.getMembersOfClass(clazz).filter(\n      member => !member.isStatic && member.decorators !== null && member.decorators.length > 0);\n  const duplicateDecoratedMemberNames =\n      classMembers.map(member => member.name).filter((name, i, arr) => arr.indexOf(name) < i);\n  if (duplicateDecoratedMemberNames.length > 0) {\n    // This should theoretically never happen, because the only way to have duplicate instance\n    // member names is getter/setter pairs and decorators cannot appear in both a getter and the\n    // corresponding setter.\n    throw new Error(\n        `Duplicate decorated properties found on class '${clazz.name.text}': ` +\n        duplicateDecoratedMemberNames.join(', '));\n  }\n  const decoratedMembers = classMembers.map(\n      member => classMemberToMetadata(member.nameNode ?? member.name, member.decorators!, isCore));\n  if (decoratedMembers.length > 0) {\n    metaPropDecorators = ts.createObjectLiteral(decoratedMembers);\n  }\n\n  // Generate a pure call to setClassMetadata with the class identifier and its metadata.\n  const setClassMetadata = new ExternalExpr(Identifiers.setClassMetadata);\n  const fnCall = new InvokeFunctionExpr(\n      /* fn */ setClassMetadata,\n      /* args */\n      [\n        new WrappedNodeExpr(id),\n        new WrappedNodeExpr(metaDecorators),\n        metaCtorParameters,\n        new WrappedNodeExpr(metaPropDecorators),\n      ]);\n  const iife = new FunctionExpr([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]).toStmt();\n}\n\n/**\n * Convert a reflected constructor parameter to metadata.\n */\nfunction ctorParameterToMetadata(param: CtorParameter, isCore: boolean): Expression {\n  // Parameters sometimes have a type that can be referenced. If so, then use it, otherwise\n  // its type is undefined.\n  const type = param.typeValueReference.kind !== TypeValueReferenceKind.UNAVAILABLE ?\n      valueReferenceToExpression(param.typeValueReference) :\n      new LiteralExpr(undefined);\n\n  const mapEntries: {key: string, value: Expression, quoted: false}[] = [\n    {key: 'type', value: type, quoted: false},\n  ];\n\n  // If the parameter has decorators, include the ones from Angular.\n  if (param.decorators !== null) {\n    const ngDecorators = param.decorators.filter(dec => isAngularDecorator(dec, isCore))\n                             .map((decorator: Decorator) => decoratorToMetadata(decorator));\n    const value = new WrappedNodeExpr(ts.createArrayLiteral(ngDecorators));\n    mapEntries.push({key: 'decorators', value, quoted: false});\n  }\n  return literalMap(mapEntries);\n}\n\n/**\n * Convert a reflected class member to metadata.\n */\nfunction classMemberToMetadata(\n    name: ts.PropertyName|string, decorators: Decorator[], isCore: boolean): ts.PropertyAssignment {\n  const ngDecorators = decorators.filter(dec => isAngularDecorator(dec, isCore))\n                           .map((decorator: Decorator) => decoratorToMetadata(decorator));\n  const decoratorMeta = ts.createArrayLiteral(ngDecorators);\n  return ts.createPropertyAssignment(name, decoratorMeta);\n}\n\n/**\n * Convert a reflected decorator to metadata.\n */\nfunction decoratorToMetadata(\n    decorator: Decorator, wrapFunctionsInParens?: boolean): ts.ObjectLiteralExpression {\n  if (decorator.identifier === null) {\n    throw new Error('Illegal state: synthesized decorator cannot be emitted in class metadata.');\n  }\n  // Decorators have a type.\n  const properties: ts.ObjectLiteralElementLike[] = [\n    ts.createPropertyAssignment('type', ts.getMutableClone(decorator.identifier)),\n  ];\n  // Sometimes they have arguments.\n  if (decorator.args !== null && decorator.args.length > 0) {\n    const args = decorator.args.map(arg => {\n      const expr = ts.getMutableClone(arg);\n      return wrapFunctionsInParens ? wrapFunctionExpressionsInParens(expr) : expr;\n    });\n    properties.push(ts.createPropertyAssignment('args', ts.createArrayLiteral(args)));\n  }\n  return ts.createObjectLiteral(properties, true);\n}\n\n/**\n * Whether a given decorator should be treated as an Angular decorator.\n *\n * Either it's used in @angular/core, or it's imported from there.\n */\nfunction isAngularDecorator(decorator: Decorator, isCore: boolean): boolean {\n  return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');\n}\n\n/**\n * Recursively recreates all of the `Identifier` descendant nodes with a particular name inside\n * of an AST node, thus removing any references to them. Useful if a particular node has to be t\n * aken from one place any emitted to another one exactly as it has been written.\n */\nfunction removeIdentifierReferences<T extends ts.Node>(node: T, name: string): T {\n  const result = ts.transform(\n      node, [context => root => ts.visitNode(root, function walk(current: ts.Node): ts.Node {\n        return ts.isIdentifier(current) && current.text === name ?\n            ts.createIdentifier(current.text) :\n            ts.visitEachChild(current, walk, context);\n      })]);\n\n  return result.transformed[0];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}