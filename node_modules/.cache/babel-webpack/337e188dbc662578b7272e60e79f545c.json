{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/host/commonjs_umd_utils\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.skipAliases = exports.isExportsStatement = exports.isExportsAssignment = exports.isExportsDeclaration = exports.isExternalImport = exports.isRequireCall = exports.extractGetterFnExpression = exports.isDefinePropertyReexportStatement = exports.isWildcardReexportStatement = exports.findRequireCallReference = exports.findNamespaceOfIdentifier = void 0;\n\n  var ts = require(\"typescript\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n  /**\n   * Return the \"namespace\" of the specified `ts.Identifier` if the identifier is the RHS of a\n   * property access expression, i.e. an expression of the form `<namespace>.<id>` (in which case a\n   * `ts.Identifier` corresponding to `<namespace>` will be returned). Otherwise return `null`.\n   */\n\n\n  function findNamespaceOfIdentifier(id) {\n    return id.parent && ts.isPropertyAccessExpression(id.parent) && id.parent.name === id && ts.isIdentifier(id.parent.expression) ? id.parent.expression : null;\n  }\n\n  exports.findNamespaceOfIdentifier = findNamespaceOfIdentifier;\n  /**\n   * Return the `RequireCall` that is used to initialize the specified `ts.Identifier`, if the\n   * specified indentifier was indeed initialized with a require call in a declaration of the form:\n   * `var <id> = require('...')`\n   */\n\n  function findRequireCallReference(id, checker) {\n    var _a, _b;\n\n    var symbol = checker.getSymbolAtLocation(id) || null;\n    var declaration = (_a = symbol === null || symbol === void 0 ? void 0 : symbol.valueDeclaration) !== null && _a !== void 0 ? _a : (_b = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _b === void 0 ? void 0 : _b[0];\n    var initializer = declaration && ts.isVariableDeclaration(declaration) && declaration.initializer || null;\n    return initializer && isRequireCall(initializer) ? initializer : null;\n  }\n\n  exports.findRequireCallReference = findRequireCallReference;\n  /**\n   * Check whether the specified `ts.Statement` is a wildcard re-export statement.\n   * I.E. an expression statement of one of the following forms:\n   * - `__export(<foo>)`\n   * - `__exportStar(<foo>)`\n   * - `tslib.__export(<foo>, exports)`\n   * - `tslib.__exportStar(<foo>, exports)`\n   */\n\n  function isWildcardReexportStatement(stmt) {\n    // Ensure it is a call expression statement.\n    if (!ts.isExpressionStatement(stmt) || !ts.isCallExpression(stmt.expression)) {\n      return false;\n    } // Get the called function identifier.\n    // NOTE: Currently, it seems that `__export()` is used when emitting helpers inline and\n    //       `__exportStar()` when importing them\n    //       ([source](https://github.com/microsoft/TypeScript/blob/d7c83f023/src/compiler/transformers/module/module.ts#L1796-L1797)).\n    //       So, theoretically, we only care about the formats `__export(<foo>)` and\n    //       `tslib.__exportStar(<foo>, exports)`.\n    //       The current implementation accepts the other two formats (`__exportStar(...)` and\n    //       `tslib.__export(...)`) as well to be more future-proof (given that it is unlikely that\n    //       they will introduce false positives).\n\n\n    var fnName = null;\n\n    if (ts.isIdentifier(stmt.expression.expression)) {\n      // Statement of the form `someFn(...)`.\n      fnName = stmt.expression.expression.text;\n    } else if (ts.isPropertyAccessExpression(stmt.expression.expression) && ts.isIdentifier(stmt.expression.expression.name)) {\n      // Statement of the form `tslib.someFn(...)`.\n      fnName = stmt.expression.expression.name.text;\n    } // Ensure the called function is either `__export()` or `__exportStar()`.\n\n\n    if (fnName !== '__export' && fnName !== '__exportStar') {\n      return false;\n    } // Ensure there is at least one argument.\n    // (The first argument is the exported thing and there will be a second `exports` argument in the\n    // case of imported helpers).\n\n\n    return stmt.expression.arguments.length > 0;\n  }\n\n  exports.isWildcardReexportStatement = isWildcardReexportStatement;\n  /**\n   * Check whether the statement is a re-export of the form:\n   *\n   * ```\n   * Object.defineProperty(exports, \"<export-name>\",\n   *     { enumerable: true, get: function () { return <import-name>; } });\n   * ```\n   */\n\n  function isDefinePropertyReexportStatement(stmt) {\n    if (!ts.isExpressionStatement(stmt) || !ts.isCallExpression(stmt.expression)) {\n      return false;\n    } // Check for Object.defineProperty\n\n\n    if (!ts.isPropertyAccessExpression(stmt.expression.expression) || !ts.isIdentifier(stmt.expression.expression.expression) || stmt.expression.expression.expression.text !== 'Object' || !ts.isIdentifier(stmt.expression.expression.name) || stmt.expression.expression.name.text !== 'defineProperty') {\n      return false;\n    }\n\n    var args = stmt.expression.arguments;\n\n    if (args.length !== 3) {\n      return false;\n    }\n\n    var exportsObject = args[0];\n\n    if (!ts.isIdentifier(exportsObject) || exportsObject.text !== 'exports') {\n      return false;\n    }\n\n    var propertyKey = args[1];\n\n    if (!ts.isStringLiteral(propertyKey)) {\n      return false;\n    }\n\n    var propertyDescriptor = args[2];\n\n    if (!ts.isObjectLiteralExpression(propertyDescriptor)) {\n      return false;\n    }\n\n    return propertyDescriptor.properties.some(function (prop) {\n      return prop.name !== undefined && ts.isIdentifier(prop.name) && prop.name.text === 'get';\n    });\n  }\n\n  exports.isDefinePropertyReexportStatement = isDefinePropertyReexportStatement;\n  /**\n   * Extract the \"value\" of the getter in a `defineProperty` statement.\n   *\n   * This will return the `ts.Expression` value of a single `return` statement in the `get` method\n   * of the property definition object, or `null` if that is not possible.\n   */\n\n  function extractGetterFnExpression(statement) {\n    var args = statement.expression.arguments;\n    var getterFn = args[2].properties.find(function (prop) {\n      return prop.name !== undefined && ts.isIdentifier(prop.name) && prop.name.text === 'get';\n    });\n\n    if (getterFn === undefined || !ts.isPropertyAssignment(getterFn) || !ts.isFunctionExpression(getterFn.initializer)) {\n      return null;\n    }\n\n    var returnStatement = getterFn.initializer.body.statements[0];\n\n    if (!ts.isReturnStatement(returnStatement) || returnStatement.expression === undefined) {\n      return null;\n    }\n\n    return returnStatement.expression;\n  }\n\n  exports.extractGetterFnExpression = extractGetterFnExpression;\n  /**\n   * Check whether the specified `ts.Node` represents a `require()` call, i.e. an call expression of\n   * the form: `require('<foo>')`\n   */\n\n  function isRequireCall(node) {\n    return ts.isCallExpression(node) && ts.isIdentifier(node.expression) && node.expression.text === 'require' && node.arguments.length === 1 && ts.isStringLiteral(node.arguments[0]);\n  }\n\n  exports.isRequireCall = isRequireCall;\n  /**\n   * Check whether the specified `path` is an \"external\" import.\n   * In other words, that it comes from a entry-point outside the current one.\n   */\n\n  function isExternalImport(path) {\n    return !/^\\.\\.?(\\/|$)/.test(path);\n  }\n\n  exports.isExternalImport = isExternalImport;\n  /**\n   * Check whether the specified `node` is a property access expression of the form\n   * `exports.<foo>`.\n   */\n\n  function isExportsDeclaration(expr) {\n    return expr.parent && isExportsAssignment(expr.parent);\n  }\n\n  exports.isExportsDeclaration = isExportsDeclaration;\n  /**\n   * Check whether the specified `node` is an assignment expression of the form\n   * `exports.<foo> = <bar>`.\n   */\n\n  function isExportsAssignment(expr) {\n    return typescript_1.isAssignment(expr) && ts.isPropertyAccessExpression(expr.left) && ts.isIdentifier(expr.left.expression) && expr.left.expression.text === 'exports' && ts.isIdentifier(expr.left.name);\n  }\n\n  exports.isExportsAssignment = isExportsAssignment;\n  /**\n   * Check whether the specified `stmt` is an expression statement of the form\n   * `exports.<foo> = <bar>;`.\n   */\n\n  function isExportsStatement(stmt) {\n    return ts.isExpressionStatement(stmt) && isExportsAssignment(stmt.expression);\n  }\n\n  exports.isExportsStatement = isExportsStatement;\n  /**\n   * Find the far right hand side of a sequence of aliased assignements of the form\n   *\n   * ```\n   * exports.MyClass = alias1 = alias2 = <<declaration>>\n   * ```\n   *\n   * @param node the expression to parse\n   * @returns the original `node` or the far right expression of a series of assignments.\n   */\n\n  function skipAliases(node) {\n    while (typescript_1.isAssignment(node)) {\n      node = node.right;\n    }\n\n    return node;\n  }\n\n  exports.skipAliases = skipAliases;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/host/commonjs_umd_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\nimport {Declaration} from '../../../src/ngtsc/reflection';\nimport {isAssignment} from '../../../src/ngtsc/util/src/typescript';\n\nexport interface ExportDeclaration {\n  name: string;\n  declaration: Declaration;\n}\n\n/**\n * A CommonJS or UMD wildcard re-export statement.\n *\n * The CommonJS or UMD version of `export * from 'blah';`.\n *\n * These statements can have several forms (depending, for example, on whether\n * the TypeScript helpers are imported or emitted inline). The expression can have one of the\n * following forms:\n * - `__export(firstArg)`\n * - `__exportStar(firstArg)`\n * - `tslib.__export(firstArg, exports)`\n * - `tslib.__exportStar(firstArg, exports)`\n *\n * In all cases, we only care about `firstArg`, which is the first argument of the re-export call\n * expression and can be either a `require('...')` call or an identifier (initialized via a\n * `require('...')` call).\n */\nexport interface WildcardReexportStatement extends ts.ExpressionStatement {\n  expression: ts.CallExpression;\n}\n\n/**\n * A CommonJS or UMD re-export statement using an `Object.defineProperty()` call.\n * For example:\n *\n * ```\n * Object.defineProperty(exports, \"<exported-id>\",\n *     { enumerable: true, get: function () { return <imported-id>; } });\n * ```\n */\nexport interface DefinePropertyReexportStatement extends ts.ExpressionStatement {\n  expression: ts.CallExpression&\n      {arguments: [ts.Identifier, ts.StringLiteral, ts.ObjectLiteralExpression]};\n}\n\n/**\n * A call expression that has a string literal for its first argument.\n */\nexport interface RequireCall extends ts.CallExpression {\n  arguments: ts.CallExpression['arguments']&[ts.StringLiteral];\n}\n\n\n/**\n * Return the \"namespace\" of the specified `ts.Identifier` if the identifier is the RHS of a\n * property access expression, i.e. an expression of the form `<namespace>.<id>` (in which case a\n * `ts.Identifier` corresponding to `<namespace>` will be returned). Otherwise return `null`.\n */\nexport function findNamespaceOfIdentifier(id: ts.Identifier): ts.Identifier|null {\n  return id.parent && ts.isPropertyAccessExpression(id.parent) && id.parent.name === id &&\n          ts.isIdentifier(id.parent.expression) ?\n      id.parent.expression :\n      null;\n}\n\n/**\n * Return the `RequireCall` that is used to initialize the specified `ts.Identifier`, if the\n * specified indentifier was indeed initialized with a require call in a declaration of the form:\n * `var <id> = require('...')`\n */\nexport function findRequireCallReference(id: ts.Identifier, checker: ts.TypeChecker): RequireCall|\n    null {\n  const symbol = checker.getSymbolAtLocation(id) || null;\n  const declaration = symbol?.valueDeclaration ?? symbol?.declarations?.[0];\n  const initializer =\n      declaration && ts.isVariableDeclaration(declaration) && declaration.initializer || null;\n  return initializer && isRequireCall(initializer) ? initializer : null;\n}\n\n/**\n * Check whether the specified `ts.Statement` is a wildcard re-export statement.\n * I.E. an expression statement of one of the following forms:\n * - `__export(<foo>)`\n * - `__exportStar(<foo>)`\n * - `tslib.__export(<foo>, exports)`\n * - `tslib.__exportStar(<foo>, exports)`\n */\nexport function isWildcardReexportStatement(stmt: ts.Statement): stmt is WildcardReexportStatement {\n  // Ensure it is a call expression statement.\n  if (!ts.isExpressionStatement(stmt) || !ts.isCallExpression(stmt.expression)) {\n    return false;\n  }\n\n  // Get the called function identifier.\n  // NOTE: Currently, it seems that `__export()` is used when emitting helpers inline and\n  //       `__exportStar()` when importing them\n  //       ([source](https://github.com/microsoft/TypeScript/blob/d7c83f023/src/compiler/transformers/module/module.ts#L1796-L1797)).\n  //       So, theoretically, we only care about the formats `__export(<foo>)` and\n  //       `tslib.__exportStar(<foo>, exports)`.\n  //       The current implementation accepts the other two formats (`__exportStar(...)` and\n  //       `tslib.__export(...)`) as well to be more future-proof (given that it is unlikely that\n  //       they will introduce false positives).\n  let fnName: string|null = null;\n  if (ts.isIdentifier(stmt.expression.expression)) {\n    // Statement of the form `someFn(...)`.\n    fnName = stmt.expression.expression.text;\n  } else if (\n      ts.isPropertyAccessExpression(stmt.expression.expression) &&\n      ts.isIdentifier(stmt.expression.expression.name)) {\n    // Statement of the form `tslib.someFn(...)`.\n    fnName = stmt.expression.expression.name.text;\n  }\n\n  // Ensure the called function is either `__export()` or `__exportStar()`.\n  if ((fnName !== '__export') && (fnName !== '__exportStar')) {\n    return false;\n  }\n\n  // Ensure there is at least one argument.\n  // (The first argument is the exported thing and there will be a second `exports` argument in the\n  // case of imported helpers).\n  return stmt.expression.arguments.length > 0;\n}\n\n\n/**\n * Check whether the statement is a re-export of the form:\n *\n * ```\n * Object.defineProperty(exports, \"<export-name>\",\n *     { enumerable: true, get: function () { return <import-name>; } });\n * ```\n */\nexport function isDefinePropertyReexportStatement(stmt: ts.Statement):\n    stmt is DefinePropertyReexportStatement {\n  if (!ts.isExpressionStatement(stmt) || !ts.isCallExpression(stmt.expression)) {\n    return false;\n  }\n\n  // Check for Object.defineProperty\n  if (!ts.isPropertyAccessExpression(stmt.expression.expression) ||\n      !ts.isIdentifier(stmt.expression.expression.expression) ||\n      stmt.expression.expression.expression.text !== 'Object' ||\n      !ts.isIdentifier(stmt.expression.expression.name) ||\n      stmt.expression.expression.name.text !== 'defineProperty') {\n    return false;\n  }\n\n  const args = stmt.expression.arguments;\n  if (args.length !== 3) {\n    return false;\n  }\n  const exportsObject = args[0];\n  if (!ts.isIdentifier(exportsObject) || exportsObject.text !== 'exports') {\n    return false;\n  }\n\n  const propertyKey = args[1];\n  if (!ts.isStringLiteral(propertyKey)) {\n    return false;\n  }\n\n  const propertyDescriptor = args[2];\n  if (!ts.isObjectLiteralExpression(propertyDescriptor)) {\n    return false;\n  }\n\n  return (propertyDescriptor.properties.some(\n      prop => prop.name !== undefined && ts.isIdentifier(prop.name) && prop.name.text === 'get'));\n}\n\n/**\n * Extract the \"value\" of the getter in a `defineProperty` statement.\n *\n * This will return the `ts.Expression` value of a single `return` statement in the `get` method\n * of the property definition object, or `null` if that is not possible.\n */\nexport function extractGetterFnExpression(statement: DefinePropertyReexportStatement):\n    ts.Expression|null {\n  const args = statement.expression.arguments;\n  const getterFn = args[2].properties.find(\n      prop => prop.name !== undefined && ts.isIdentifier(prop.name) && prop.name.text === 'get');\n  if (getterFn === undefined || !ts.isPropertyAssignment(getterFn) ||\n      !ts.isFunctionExpression(getterFn.initializer)) {\n    return null;\n  }\n  const returnStatement = getterFn.initializer.body.statements[0];\n  if (!ts.isReturnStatement(returnStatement) || returnStatement.expression === undefined) {\n    return null;\n  }\n  return returnStatement.expression;\n}\n\n/**\n * Check whether the specified `ts.Node` represents a `require()` call, i.e. an call expression of\n * the form: `require('<foo>')`\n */\nexport function isRequireCall(node: ts.Node): node is RequireCall {\n  return ts.isCallExpression(node) && ts.isIdentifier(node.expression) &&\n      node.expression.text === 'require' && node.arguments.length === 1 &&\n      ts.isStringLiteral(node.arguments[0]);\n}\n\n/**\n * Check whether the specified `path` is an \"external\" import.\n * In other words, that it comes from a entry-point outside the current one.\n */\nexport function isExternalImport(path: string): boolean {\n  return !/^\\.\\.?(\\/|$)/.test(path);\n}\n\n/**\n * A UMD/CommonJS style export declaration of the form `exports.<name>`.\n */\nexport interface ExportsDeclaration extends ts.PropertyAccessExpression {\n  name: ts.Identifier;\n  expression: ts.Identifier;\n  parent: ExportsAssignment;\n}\n\n/**\n * Check whether the specified `node` is a property access expression of the form\n * `exports.<foo>`.\n */\nexport function isExportsDeclaration(expr: ts.Node): expr is ExportsDeclaration {\n  return expr.parent && isExportsAssignment(expr.parent);\n}\n\n/**\n * A UMD/CommonJS style export assignment of the form `exports.<foo> = <bar>`.\n */\nexport interface ExportsAssignment extends ts.BinaryExpression {\n  left: ExportsDeclaration;\n}\n\n/**\n * Check whether the specified `node` is an assignment expression of the form\n * `exports.<foo> = <bar>`.\n */\nexport function isExportsAssignment(expr: ts.Node): expr is ExportsAssignment {\n  return isAssignment(expr) && ts.isPropertyAccessExpression(expr.left) &&\n      ts.isIdentifier(expr.left.expression) && expr.left.expression.text === 'exports' &&\n      ts.isIdentifier(expr.left.name);\n}\n\n/**\n * An expression statement of the form `exports.<foo> = <bar>;`.\n */\nexport interface ExportsStatement extends ts.ExpressionStatement {\n  expression: ExportsAssignment;\n}\n\n/**\n * Check whether the specified `stmt` is an expression statement of the form\n * `exports.<foo> = <bar>;`.\n */\nexport function isExportsStatement(stmt: ts.Node): stmt is ExportsStatement {\n  return ts.isExpressionStatement(stmt) && isExportsAssignment(stmt.expression);\n}\n\n/**\n * Find the far right hand side of a sequence of aliased assignements of the form\n *\n * ```\n * exports.MyClass = alias1 = alias2 = <<declaration>>\n * ```\n *\n * @param node the expression to parse\n * @returns the original `node` or the far right expression of a series of assignments.\n */\nexport function skipAliases(node: ts.Expression): ts.Expression {\n  while (isAssignment(node)) {\n    node = node.right;\n  }\n  return node;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}