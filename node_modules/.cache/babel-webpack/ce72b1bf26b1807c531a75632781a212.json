{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/template_parser/binding_parser\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/core\", \"@angular/compiler/src/expression_parser/ast\", \"@angular/compiler/src/ml_parser/tags\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/selector\", \"@angular/compiler/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.calcPossibleSecurityContexts = exports.PipeCollector = exports.BindingParser = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var ast_1 = require(\"@angular/compiler/src/expression_parser/ast\");\n\n  var tags_1 = require(\"@angular/compiler/src/ml_parser/tags\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var selector_1 = require(\"@angular/compiler/src/selector\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var PROPERTY_PARTS_SEPARATOR = '.';\n  var ATTRIBUTE_PREFIX = 'attr';\n  var CLASS_PREFIX = 'class';\n  var STYLE_PREFIX = 'style';\n  var TEMPLATE_ATTR_PREFIX = '*';\n  var ANIMATE_PROP_PREFIX = 'animate-';\n  /**\n   * Parses bindings in templates and in the directive host area.\n   */\n\n  var BindingParser =\n  /** @class */\n  function () {\n    function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {\n      this._exprParser = _exprParser;\n      this._interpolationConfig = _interpolationConfig;\n      this._schemaRegistry = _schemaRegistry;\n      this.errors = errors;\n      this.pipesByName = null;\n      this._usedPipes = new Map(); // When the `pipes` parameter is `null`, do not check for used pipes\n      // This is used in IVY when we might not know the available pipes at compile time\n\n      if (pipes) {\n        var pipesByName_1 = new Map();\n        pipes.forEach(function (pipe) {\n          return pipesByName_1.set(pipe.name, pipe);\n        });\n        this.pipesByName = pipesByName_1;\n      }\n    }\n\n    Object.defineProperty(BindingParser.prototype, \"interpolationConfig\", {\n      get: function get() {\n        return this._interpolationConfig;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    BindingParser.prototype.getUsedPipes = function () {\n      return Array.from(this._usedPipes.values());\n    };\n\n    BindingParser.prototype.createBoundHostProperties = function (dirMeta, sourceSpan) {\n      var _this = this;\n\n      if (dirMeta.hostProperties) {\n        var boundProps_1 = [];\n        Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n          var expression = dirMeta.hostProperties[propName];\n\n          if (typeof expression === 'string') {\n            _this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n            // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n            // source of the host binding (which doesn't exist in the template). Regardless,\n            // neither of these values are used in Ivy but are only here to satisfy the function\n            // signature. This should likely be refactored in the future so that `sourceSpan`\n            // isn't being used inaccurately.\n            boundProps_1, sourceSpan);\n          } else {\n            _this._reportError(\"Value of the host property binding \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n          }\n        });\n        return boundProps_1;\n      }\n\n      return null;\n    };\n\n    BindingParser.prototype.createDirectiveHostPropertyAsts = function (dirMeta, elementSelector, sourceSpan) {\n      var _this = this;\n\n      var boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n      return boundProps && boundProps.map(function (prop) {\n        return _this.createBoundElementProperty(elementSelector, prop);\n      });\n    };\n\n    BindingParser.prototype.createDirectiveHostEventAsts = function (dirMeta, sourceSpan) {\n      var _this = this;\n\n      if (dirMeta.hostListeners) {\n        var targetEvents_1 = [];\n        Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n          var expression = dirMeta.hostListeners[propName];\n\n          if (typeof expression === 'string') {\n            // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n            // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n            // rather than the source of the host binding (which doesn't exist in the template).\n            // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n            // function signature. This should likely be refactored in the future so that `sourceSpan`\n            // isn't being used inaccurately.\n            _this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents_1, sourceSpan);\n          } else {\n            _this._reportError(\"Value of the host listener \\\"\" + propName + \"\\\" needs to be a string representing an expression but got \\\"\" + expression + \"\\\" (\" + typeof expression + \")\", sourceSpan);\n          }\n        });\n        return targetEvents_1;\n      }\n\n      return null;\n    };\n\n    BindingParser.prototype.parseInterpolation = function (value, sourceSpan) {\n      var sourceInfo = sourceSpan.start.toString();\n      var absoluteOffset = sourceSpan.fullStart.offset;\n\n      try {\n        var ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n\n        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\" + e, sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    };\n    /**\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n     * This is used for parsing the switch expression in ICUs.\n     */\n\n\n    BindingParser.prototype.parseInterpolationExpression = function (expression, sourceSpan) {\n      var sourceInfo = sourceSpan.start.toString();\n      var absoluteOffset = sourceSpan.start.offset;\n\n      try {\n        var ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n\n        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\" + e, sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    };\n    /**\n     * Parses the bindings in a microsyntax expression, and converts them to\n     * `ParsedProperty` or `ParsedVariable`.\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteValueOffset start of the tplValue relative to the entire template\n     * @param targetMatchableAttrs potential attributes to match in the template\n     * @param targetProps target property bindings in the template\n     * @param targetVars target variables in the template\n     */\n\n\n    BindingParser.prototype.parseInlineTemplateBinding = function (tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\n      var e_1, _a;\n\n      var absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n\n      var bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n\n      try {\n        for (var bindings_1 = tslib_1.__values(bindings), bindings_1_1 = bindings_1.next(); !bindings_1_1.done; bindings_1_1 = bindings_1.next()) {\n          var binding = bindings_1_1.value; // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n          // binding within the microsyntax expression so it's more narrow than sourceSpan.\n\n          var bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n          var key = binding.key.source;\n          var keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n\n          if (binding instanceof ast_1.VariableBinding) {\n            var value = binding.value ? binding.value.source : '$implicit';\n            var valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n            targetVars.push(new ast_1.ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n          } else if (binding.value) {\n            var srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n            var valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n\n            this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n          } else {\n            targetMatchableAttrs.push([key, ''\n            /* value */\n            ]); // Since this is a literal attribute with no RHS, source span should be\n            // just the key span.\n\n            this.parseLiteralAttr(key, null\n            /* value */\n            , keySpan, absoluteValueOffset, undefined\n            /* valueSpan */\n            , targetMatchableAttrs, targetProps, keySpan);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (bindings_1_1 && !bindings_1_1.done && (_a = bindings_1.return)) _a.call(bindings_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n    /**\n     * Parses the bindings in a microsyntax expression, e.g.\n     * ```\n     *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n     * ```\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteKeyOffset start of the `tplKey`\n     * @param absoluteValueOffset start of the `tplValue`\n     */\n\n\n    BindingParser.prototype._parseTemplateBindings = function (tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n      var _this = this;\n\n      var sourceInfo = sourceSpan.start.toString();\n\n      try {\n        var bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n\n        this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n\n        bindingsResult.templateBindings.forEach(function (binding) {\n          if (binding.value instanceof ast_1.ASTWithSource) {\n            _this._checkPipes(binding.value, sourceSpan);\n          }\n        });\n        bindingsResult.warnings.forEach(function (warning) {\n          _this._reportError(warning, sourceSpan, parse_util_1.ParseErrorLevel.WARNING);\n        });\n        return bindingsResult.templateBindings;\n      } catch (e) {\n        this._reportError(\"\" + e, sourceSpan);\n\n        return [];\n      }\n    };\n\n    BindingParser.prototype.parseLiteralAttr = function (name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n    // have to change This should be required when VE is removed.\n    targetProps, keySpan) {\n      if (isAnimationLabel(name)) {\n        name = name.substring(1);\n\n        if (keySpan !== undefined) {\n          keySpan = moveParseSourceSpan(keySpan, new ast_1.AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n        }\n\n        if (value) {\n          this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" + \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, parse_util_1.ParseErrorLevel.ERROR);\n        }\n\n        this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetProps.push(new ast_1.ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ast_1.ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n      }\n    };\n\n    BindingParser.prototype.parsePropertyBinding = function (name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n    // have to change This should be required when VE is removed.\n    targetMatchableAttrs, targetProps, keySpan) {\n      if (name.length === 0) {\n        this._reportError(\"Property name is missing in binding\", sourceSpan);\n      }\n\n      var isAnimationProp = false;\n\n      if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n        isAnimationProp = true;\n        name = name.substring(ANIMATE_PROP_PREFIX.length);\n\n        if (keySpan !== undefined) {\n          keySpan = moveParseSourceSpan(keySpan, new ast_1.AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n        }\n      } else if (isAnimationLabel(name)) {\n        isAnimationProp = true;\n        name = name.substring(1);\n\n        if (keySpan !== undefined) {\n          keySpan = moveParseSourceSpan(keySpan, new ast_1.AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n        }\n      }\n\n      if (isAnimationProp) {\n        this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      }\n    };\n\n    BindingParser.prototype.parsePropertyInterpolation = function (name, value, sourceSpan, valueSpan, targetMatchableAttrs, // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n    // have to change This should be required when VE is removed.\n    targetProps, keySpan) {\n      var expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n\n      if (expr) {\n        this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n\n        return true;\n      }\n\n      return false;\n    };\n\n    BindingParser.prototype._parsePropertyAst = function (name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n      targetMatchableAttrs.push([name, ast.source]);\n      targetProps.push(new ast_1.ParsedProperty(name, ast, ast_1.ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n    };\n\n    BindingParser.prototype._parseAnimation = function (name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n      if (name.length === 0) {\n        this._reportError('Animation trigger is missing', sourceSpan);\n      } // This will occur when a @trigger is not paired with an expression.\n      // For animations it is valid to not have an expression since */void\n      // states will be applied by angular when the element is attached/detached\n\n\n      var ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n\n      targetMatchableAttrs.push([name, ast.source]);\n      targetProps.push(new ast_1.ParsedProperty(name, ast, ast_1.ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n    };\n\n    BindingParser.prototype._parseBinding = function (value, isHostBinding, sourceSpan, absoluteOffset) {\n      var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n      try {\n        var ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\" + e, sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    };\n\n    BindingParser.prototype.createBoundElementProperty = function (elementSelector, boundProp, skipValidation, mapPropertyName) {\n      if (skipValidation === void 0) {\n        skipValidation = false;\n      }\n\n      if (mapPropertyName === void 0) {\n        mapPropertyName = true;\n      }\n\n      if (boundProp.isAnimation) {\n        return new ast_1.BoundElementProperty(boundProp.name, 4\n        /* Animation */\n        , core_1.SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n      }\n\n      var unit = null;\n      var bindingType = undefined;\n      var boundPropertyName = null;\n      var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n      var securityContexts = undefined; // Check for special cases (prefix style, attr, class)\n\n      if (parts.length > 1) {\n        if (parts[0] == ATTRIBUTE_PREFIX) {\n          boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n\n          if (!skipValidation) {\n            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n          }\n\n          securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n          var nsSeparatorIdx = boundPropertyName.indexOf(':');\n\n          if (nsSeparatorIdx > -1) {\n            var ns = boundPropertyName.substring(0, nsSeparatorIdx);\n            var name_1 = boundPropertyName.substring(nsSeparatorIdx + 1);\n            boundPropertyName = tags_1.mergeNsAndName(ns, name_1);\n          }\n\n          bindingType = 1\n          /* Attribute */\n          ;\n        } else if (parts[0] == CLASS_PREFIX) {\n          boundPropertyName = parts[1];\n          bindingType = 2\n          /* Class */\n          ;\n          securityContexts = [core_1.SecurityContext.NONE];\n        } else if (parts[0] == STYLE_PREFIX) {\n          unit = parts.length > 2 ? parts[2] : null;\n          boundPropertyName = parts[1];\n          bindingType = 3\n          /* Style */\n          ;\n          securityContexts = [core_1.SecurityContext.STYLE];\n        }\n      } // If not a special case, use the full property name\n\n\n      if (boundPropertyName === null) {\n        var mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n\n        boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n        securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n        bindingType = 0\n        /* Property */\n        ;\n\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n        }\n      }\n\n      return new ast_1.BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }; // TODO: keySpan should be required but was made optional to avoid changing VE parser.\n\n\n    BindingParser.prototype.parseEvent = function (name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n      if (name.length === 0) {\n        this._reportError(\"Event name is missing in binding\", sourceSpan);\n      }\n\n      if (isAnimationLabel(name)) {\n        name = name.substr(1);\n\n        if (keySpan !== undefined) {\n          keySpan = moveParseSourceSpan(keySpan, new ast_1.AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n        }\n\n        this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);\n      } else {\n        this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n      }\n    };\n\n    BindingParser.prototype.calcPossibleSecurityContexts = function (selector, propName, isAttribute) {\n      var prop = this._schemaRegistry.getMappedPropName(propName);\n\n      return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n    };\n\n    BindingParser.prototype._parseAnimationEvent = function (name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {\n      var matches = util_1.splitAtPeriod(name, [name, '']);\n      var eventName = matches[0];\n      var phase = matches[1].toLowerCase();\n\n      var ast = this._parseAction(expression, handlerSpan);\n\n      targetEvents.push(new ast_1.ParsedEvent(eventName, phase, 1\n      /* Animation */\n      , ast, sourceSpan, handlerSpan, keySpan));\n\n      if (eventName.length === 0) {\n        this._reportError(\"Animation event name is missing in binding\", sourceSpan);\n      }\n\n      if (phase) {\n        if (phase !== 'start' && phase !== 'done') {\n          this._reportError(\"The provided animation output phase value \\\"\" + phase + \"\\\" for \\\"@\" + eventName + \"\\\" is not supported (use start or done)\", sourceSpan);\n        }\n      } else {\n        this._reportError(\"The animation trigger output event (@\" + eventName + \") is missing its phase value name (start or done are currently supported)\", sourceSpan);\n      }\n    };\n\n    BindingParser.prototype._parseRegularEvent = function (name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n      // long format: 'target: eventName'\n      var _a = tslib_1.__read(util_1.splitAtColon(name, [null, name]), 2),\n          target = _a[0],\n          eventName = _a[1];\n\n      var ast = this._parseAction(expression, handlerSpan);\n\n      targetMatchableAttrs.push([name, ast.source]);\n      targetEvents.push(new ast_1.ParsedEvent(eventName, target, 0\n      /* Regular */\n      , ast, sourceSpan, handlerSpan, keySpan)); // Don't detect directives for event names for now,\n      // so don't add the event name to the matchableAttrs\n    };\n\n    BindingParser.prototype._parseAction = function (value, sourceSpan) {\n      var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n      var absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;\n\n      try {\n        var ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n\n        if (ast) {\n          this._reportExpressionParserErrors(ast.errors, sourceSpan);\n        }\n\n        if (!ast || ast.ast instanceof ast_1.EmptyExpr) {\n          this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n\n          return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\" + e, sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    };\n\n    BindingParser.prototype._reportError = function (message, sourceSpan, level) {\n      if (level === void 0) {\n        level = parse_util_1.ParseErrorLevel.ERROR;\n      }\n\n      this.errors.push(new parse_util_1.ParseError(sourceSpan, message, level));\n    };\n\n    BindingParser.prototype._reportExpressionParserErrors = function (errors, sourceSpan) {\n      var e_2, _a;\n\n      try {\n        for (var errors_1 = tslib_1.__values(errors), errors_1_1 = errors_1.next(); !errors_1_1.done; errors_1_1 = errors_1.next()) {\n          var error = errors_1_1.value;\n\n          this._reportError(error.message, sourceSpan);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (errors_1_1 && !errors_1_1.done && (_a = errors_1.return)) _a.call(errors_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }; // Make sure all the used pipes are known in `this.pipesByName`\n\n\n    BindingParser.prototype._checkPipes = function (ast, sourceSpan) {\n      var _this = this;\n\n      if (ast && this.pipesByName) {\n        var collector = new PipeCollector();\n        ast.visit(collector);\n        collector.pipes.forEach(function (ast, pipeName) {\n          var pipeMeta = _this.pipesByName.get(pipeName);\n\n          if (!pipeMeta) {\n            _this._reportError(\"The pipe '\" + pipeName + \"' could not be found\", new parse_util_1.ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n          } else {\n            _this._usedPipes.set(pipeName, pipeMeta);\n          }\n        });\n      }\n    };\n    /**\n     * @param propName the name of the property / attribute\n     * @param sourceSpan\n     * @param isAttr true when binding to an attribute\n     */\n\n\n    BindingParser.prototype._validatePropertyOrAttributeName = function (propName, sourceSpan, isAttr) {\n      var report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);\n\n      if (report.error) {\n        this._reportError(report.msg, sourceSpan, parse_util_1.ParseErrorLevel.ERROR);\n      }\n    };\n\n    return BindingParser;\n  }();\n\n  exports.BindingParser = BindingParser;\n\n  var PipeCollector =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(PipeCollector, _super);\n\n    function PipeCollector() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.pipes = new Map();\n      return _this;\n    }\n\n    PipeCollector.prototype.visitPipe = function (ast, context) {\n      this.pipes.set(ast.name, ast);\n      ast.exp.visit(this);\n      this.visitAll(ast.args, context);\n      return null;\n    };\n\n    return PipeCollector;\n  }(ast_1.RecursiveAstVisitor);\n\n  exports.PipeCollector = PipeCollector;\n\n  function isAnimationLabel(name) {\n    return name[0] == '@';\n  }\n\n  function calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n    var ctxs = [];\n    selector_1.CssSelector.parse(selector).forEach(function (selector) {\n      var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n      var notElementNames = new Set(selector.notSelectors.filter(function (selector) {\n        return selector.isElementSelector();\n      }).map(function (selector) {\n        return selector.element;\n      }));\n      var possibleElementNames = elementNames.filter(function (elementName) {\n        return !notElementNames.has(elementName);\n      });\n      ctxs.push.apply(ctxs, tslib_1.__spread(possibleElementNames.map(function (elementName) {\n        return registry.securityContext(elementName, propName, isAttribute);\n      })));\n    });\n    return ctxs.length === 0 ? [core_1.SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n  }\n\n  exports.calcPossibleSecurityContexts = calcPossibleSecurityContexts;\n  /**\n   * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n   * absolute offsets from the specified `absoluteSpan`.\n   *\n   * @param sourceSpan original source span\n   * @param absoluteSpan absolute source span to move to\n   */\n\n  function moveParseSourceSpan(sourceSpan, absoluteSpan) {\n    // The difference of two absolute offsets provide the relative offset\n    var startDiff = absoluteSpan.start - sourceSpan.start.offset;\n    var endDiff = absoluteSpan.end - sourceSpan.end.offset;\n    return new parse_util_1.ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/template_parser/binding_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\nimport {SecurityContext} from '../core';\nimport {AbsoluteSourceSpan, ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding, VariableBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseLocation, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst ANIMATE_PROP_PREFIX = 'animate-';\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  pipesByName: Map<string, CompilePipeSummary>|null = null;\n\n  private _usedPipes: Map<string, CompilePipeSummary> = new Map();\n\n  constructor(\n      private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n      private _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[]|null,\n      public errors: ParseError[]) {\n    // When the `pipes` parameter is `null`, do not check for used pipes\n    // This is used in IVY when we might not know the available pipes at compile time\n    if (pipes) {\n      const pipesByName: Map<string, CompilePipeSummary> = new Map();\n      pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));\n      this.pipesByName = pipesByName;\n    }\n  }\n\n  get interpolationConfig(): InterpolationConfig {\n    return this._interpolationConfig;\n  }\n\n  getUsedPipes(): CompilePipeSummary[] {\n    return Array.from(this._usedPipes.values());\n  }\n\n  createBoundHostProperties(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedProperty[]|null {\n    if (dirMeta.hostProperties) {\n      const boundProps: ParsedProperty[] = [];\n      Object.keys(dirMeta.hostProperties).forEach(propName => {\n        const expression = dirMeta.hostProperties[propName];\n        if (typeof expression === 'string') {\n          this.parsePropertyBinding(\n              propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [],\n              // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n              // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n              // source of the host binding (which doesn't exist in the template). Regardless,\n              // neither of these values are used in Ivy but are only here to satisfy the function\n              // signature. This should likely be refactored in the future so that `sourceSpan`\n              // isn't being used inaccurately.\n              boundProps, sourceSpan);\n        } else {\n          this._reportError(\n              `Value of the host property binding \"${\n                  propName}\" needs to be a string representing an expression but got \"${\n                  expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return boundProps;\n    }\n    return null;\n  }\n\n  createDirectiveHostPropertyAsts(\n      dirMeta: CompileDirectiveSummary, elementSelector: string,\n      sourceSpan: ParseSourceSpan): BoundElementProperty[]|null {\n    const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n    return boundProps &&\n        boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));\n  }\n\n  createDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedEvent[]|null {\n    if (dirMeta.hostListeners) {\n      const targetEvents: ParsedEvent[] = [];\n      Object.keys(dirMeta.hostListeners).forEach(propName => {\n        const expression = dirMeta.hostListeners[propName];\n        if (typeof expression === 'string') {\n          // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n          // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n          // rather than the source of the host binding (which doesn't exist in the template).\n          // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n          // function signature. This should likely be refactored in the future so that `sourceSpan`\n          // isn't being used inaccurately.\n          this.parseEvent(\n              propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n        } else {\n          this._reportError(\n              `Value of the host listener \"${\n                  propName}\" needs to be a string representing an expression but got \"${\n                  expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return targetEvents;\n    }\n    return null;\n  }\n\n  parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n    const absoluteOffset = sourceSpan.fullStart.offset;\n\n    try {\n      const ast = this._exprParser.parseInterpolation(\n          value, sourceInfo, absoluteOffset, this._interpolationConfig)!;\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  /**\n   * Similar to `parseInterpolation`, but treats the provided string as a single expression\n   * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\n   * This is used for parsing the switch expression in ICUs.\n   */\n  parseInterpolationExpression(expression: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n    const absoluteOffset = sourceSpan.start.offset;\n\n    try {\n      const ast =\n          this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, and converts them to\n   * `ParsedProperty` or `ParsedVariable`.\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteValueOffset start of the tplValue relative to the entire template\n   * @param targetMatchableAttrs potential attributes to match in the template\n   * @param targetProps target property bindings in the template\n   * @param targetVars target variables in the template\n   */\n  parseInlineTemplateBinding(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan, absoluteValueOffset: number,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[], targetVars: ParsedVariable[],\n      isIvyAst: boolean) {\n    const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n    const bindings = this._parseTemplateBindings(\n        tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n\n    for (const binding of bindings) {\n      // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n      // binding within the microsyntax expression so it's more narrow than sourceSpan.\n      const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n      const key = binding.key.source;\n      const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n      if (binding instanceof VariableBinding) {\n        const value = binding.value ? binding.value.source : '$implicit';\n        const valueSpan =\n            binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n        targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n      } else if (binding.value) {\n        const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n        const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n        this._parsePropertyAst(\n            key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([key, '' /* value */]);\n        // Since this is a literal attribute with no RHS, source span should be\n        // just the key span.\n        this.parseLiteralAttr(\n            key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */,\n            targetMatchableAttrs, targetProps, keySpan);\n      }\n    }\n  }\n\n  /**\n   * Parses the bindings in a microsyntax expression, e.g.\n   * ```\n   *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n   * ```\n   *\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteKeyOffset start of the `tplKey`\n   * @param absoluteValueOffset start of the `tplValue`\n   */\n  private _parseTemplateBindings(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan, absoluteKeyOffset: number,\n      absoluteValueOffset: number): TemplateBinding[] {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const bindingsResult = this._exprParser.parseTemplateBindings(\n          tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.templateBindings.forEach((binding) => {\n        if (binding.value instanceof ASTWithSource) {\n          this._checkPipes(binding.value, sourceSpan);\n        }\n      });\n      bindingsResult.warnings.forEach((warning) => {\n        this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n      });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n      // have to change This should be required when VE is removed.\n      targetProps: ParsedProperty[], keySpan?: ParseSourceSpan) {\n    if (isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(\n          name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs,\n          targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset),\n          ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n    }\n  }\n\n  parsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      absoluteOffset: number, valueSpan: ParseSourceSpan|undefined,\n      // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n      // have to change This should be required when VE is removed.\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[], keySpan?: ParseSourceSpan) {\n    if (name.length === 0) {\n      this._reportError(`Property name is missing in binding`, sourceSpan);\n    }\n\n    let isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan,\n            new AbsoluteSourceSpan(\n                keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n      }\n    } else if (isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(\n          name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs,\n          targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n          sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n    }\n  }\n\n  parsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n      // have to change This should be required when VE is removed.\n      targetProps: ParsedProperty[], keySpan?: ParseSourceSpan): boolean {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n    if (expr) {\n      this._parsePropertyAst(\n          name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n      keySpan: ParseSourceSpan|undefined, valueSpan: ParseSourceSpan|undefined,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(\n        new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n  }\n\n  private _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n      keySpan: ParseSourceSpan|undefined, valueSpan: ParseSourceSpan|undefined,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    if (name.length === 0) {\n      this._reportError('Animation trigger is missing', sourceSpan);\n    }\n\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this._parseBinding(\n        expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n    targetMatchableAttrs.push([name, ast.source!]);\n    targetProps.push(new ParsedProperty(\n        name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n  }\n\n  private _parseBinding(\n      value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan,\n      absoluteOffset: number): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n    try {\n      const ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(\n              value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n          this._exprParser.parseBinding(\n              value, sourceInfo, absoluteOffset, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  createBoundElementProperty(\n      elementSelector: string, boundProp: ParsedProperty, skipValidation: boolean = false,\n      mapPropertyName: boolean = true): BoundElementProperty {\n    if (boundProp.isAnimation) {\n      return new BoundElementProperty(\n          boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n          boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    }\n\n    let unit: string|null = null;\n    let bindingType: BindingType = undefined!;\n    let boundPropertyName: string|null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined!;\n\n    // Check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, mappedPropName, false);\n      bindingType = BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n\n    return new BoundElementProperty(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n  }\n\n  // TODO: keySpan should be required but was made optional to avoid changing VE parser.\n  parseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, handlerSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[], keySpan?: ParseSourceSpan) {\n    if (name.length === 0) {\n      this._reportError(`Event name is missing in binding`, sourceSpan);\n    }\n\n    if (isAnimationLabel(name)) {\n      name = name.substr(1);\n      if (keySpan !== undefined) {\n        keySpan = moveParseSourceSpan(\n            keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n      }\n      this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);\n    } else {\n      this._parseRegularEvent(\n          name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n    }\n  }\n\n  calcPossibleSecurityContexts(selector: string, propName: string, isAttribute: boolean):\n      SecurityContext[] {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n\n  private _parseAnimationEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, handlerSpan: ParseSourceSpan,\n      targetEvents: ParsedEvent[], keySpan?: ParseSourceSpan) {\n    const matches = splitAtPeriod(name, [name, '']);\n    const eventName = matches[0];\n    const phase = matches[1].toLowerCase();\n    const ast = this._parseAction(expression, handlerSpan);\n    targetEvents.push(new ParsedEvent(\n        eventName, phase, ParsedEventType.Animation, ast, sourceSpan, handlerSpan, keySpan));\n\n    if (eventName.length === 0) {\n      this._reportError(`Animation event name is missing in binding`, sourceSpan);\n    }\n    if (phase) {\n      if (phase !== 'start' && phase !== 'done') {\n        this._reportError(\n            `The provided animation output phase value \"${phase}\" for \"@${\n                eventName}\" is not supported (use start or done)`,\n            sourceSpan);\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${\n              eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n\n  private _parseRegularEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, handlerSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[], keySpan?: ParseSourceSpan) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null!, name]);\n    const ast = this._parseAction(expression, handlerSpan);\n    targetMatchableAttrs.push([name!, ast.source!]);\n    targetEvents.push(new ParsedEvent(\n        eventName, target, ParsedEventType.Regular, ast, sourceSpan, handlerSpan, keySpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n    const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n\n    try {\n      const ast = this._exprParser.parseAction(\n          value, sourceInfo, absoluteOffset, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  private _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n\n  // Make sure all the used pipes are known in `this.pipesByName`\n  private _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan): void {\n    if (ast && this.pipesByName) {\n      const collector = new PipeCollector();\n      ast.visit(collector);\n      collector.pipes.forEach((ast, pipeName) => {\n        const pipeMeta = this.pipesByName!.get(pipeName);\n        if (!pipeMeta) {\n          this._reportError(\n              `The pipe '${pipeName}' could not be found`,\n              new ParseSourceSpan(\n                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n        } else {\n          this._usedPipes.set(pipeName, pipeMeta);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg!, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\nfunction moveParseSourceSpan(\n    sourceSpan: ParseSourceSpan, absoluteSpan: AbsoluteSourceSpan): ParseSourceSpan {\n  // The difference of two absolute offsets provide the relative offset\n  const startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  const endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(\n      sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff),\n      sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}