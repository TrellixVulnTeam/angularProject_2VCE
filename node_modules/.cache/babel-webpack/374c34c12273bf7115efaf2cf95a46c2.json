{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/entry_point_bundle\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/execution/tasks/api\", \"@angular/compiler-cli/ngcc/src/packages/bundle_program\", \"@angular/compiler-cli/ngcc/src/packages/ngcc_compiler_host\", \"@angular/compiler-cli/ngcc/src/packages/source_file_cache\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.makeEntryPointBundle = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var api_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/api\");\n\n  var bundle_program_1 = require(\"@angular/compiler-cli/ngcc/src/packages/bundle_program\");\n\n  var ngcc_compiler_host_1 = require(\"@angular/compiler-cli/ngcc/src/packages/ngcc_compiler_host\");\n\n  var source_file_cache_1 = require(\"@angular/compiler-cli/ngcc/src/packages/source_file_cache\");\n  /**\n   * Get an object that describes a formatted bundle for an entry-point.\n   * @param fs The current file-system being used.\n   * @param entryPoint The entry-point that contains the bundle.\n   * @param sharedFileCache The cache to use for source files that are shared across all entry-points.\n   * @param moduleResolutionCache The module resolution cache to use.\n   * @param formatPath The path to the source files for this bundle.\n   * @param isCore This entry point is the Angular core package.\n   * @param format The underlying format of the bundle.\n   * @param dtsProcessing Whether to transform the typings along with this bundle.\n   * @param pathMappings An optional set of mappings to use when compiling files.\n   * @param mirrorDtsFromSrc If true then the `dts` program will contain additional files that\n   * were guessed by mapping the `src` files to `dts` files.\n   * @param enableI18nLegacyMessageIdFormat Whether to render legacy message ids for i18n messages in\n   * component templates.\n   */\n\n\n  function makeEntryPointBundle(fs, entryPoint, sharedFileCache, moduleResolutionCache, formatPath, isCore, format, dtsProcessing, pathMappings, mirrorDtsFromSrc, enableI18nLegacyMessageIdFormat) {\n    if (mirrorDtsFromSrc === void 0) {\n      mirrorDtsFromSrc = false;\n    }\n\n    if (enableI18nLegacyMessageIdFormat === void 0) {\n      enableI18nLegacyMessageIdFormat = true;\n    } // Create the TS program and necessary helpers.\n\n\n    var rootDir = entryPoint.packagePath;\n\n    var options = tslib_1.__assign({\n      allowJs: true,\n      maxNodeModuleJsDepth: Infinity,\n      rootDir: rootDir\n    }, pathMappings);\n\n    var entryPointCache = new source_file_cache_1.EntryPointFileCache(fs, sharedFileCache);\n    var dtsHost = new ngcc_compiler_host_1.NgccDtsCompilerHost(fs, options, entryPointCache, moduleResolutionCache);\n    var srcHost = new ngcc_compiler_host_1.NgccSourcesCompilerHost(fs, options, entryPointCache, moduleResolutionCache, entryPoint.packagePath); // Create the bundle programs, as necessary.\n\n    var absFormatPath = fs.resolve(entryPoint.path, formatPath);\n    var typingsPath = fs.resolve(entryPoint.path, entryPoint.typings);\n    var src = bundle_program_1.makeBundleProgram(fs, isCore, entryPoint.packagePath, absFormatPath, 'r3_symbols.js', options, srcHost);\n    var additionalDtsFiles = dtsProcessing !== api_1.DtsProcessing.No && mirrorDtsFromSrc ? computePotentialDtsFilesFromJsFiles(fs, src.program, absFormatPath, typingsPath) : [];\n    var dts = dtsProcessing !== api_1.DtsProcessing.No ? bundle_program_1.makeBundleProgram(fs, isCore, entryPoint.packagePath, typingsPath, 'r3_symbols.d.ts', tslib_1.__assign(tslib_1.__assign({}, options), {\n      allowJs: false\n    }), dtsHost, additionalDtsFiles) : null;\n    var isFlatCore = isCore && src.r3SymbolsFile === null;\n    return {\n      entryPoint: entryPoint,\n      format: format,\n      rootDirs: [rootDir],\n      isCore: isCore,\n      isFlatCore: isFlatCore,\n      src: src,\n      dts: dts,\n      dtsProcessing: dtsProcessing,\n      enableI18nLegacyMessageIdFormat: enableI18nLegacyMessageIdFormat\n    };\n  }\n\n  exports.makeEntryPointBundle = makeEntryPointBundle;\n\n  function computePotentialDtsFilesFromJsFiles(fs, srcProgram, formatPath, typingsPath) {\n    var e_1, _a;\n\n    var formatRoot = fs.dirname(formatPath);\n    var typingsRoot = fs.dirname(typingsPath);\n    var additionalFiles = [];\n\n    try {\n      for (var _b = tslib_1.__values(srcProgram.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var sf = _c.value;\n\n        if (!sf.fileName.endsWith('.js')) {\n          continue;\n        } // Given a source file at e.g. `esm2015/src/some/nested/index.js`, try to resolve the\n        // declaration file under the typings root in `src/some/nested/index.d.ts`.\n\n\n        var mirroredDtsPath = fs.resolve(typingsRoot, fs.relative(formatRoot, sf.fileName.replace(/\\.js$/, '.d.ts')));\n\n        if (fs.exists(mirroredDtsPath)) {\n          additionalFiles.push(mirroredDtsPath);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return additionalFiles;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/entry_point_bundle.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AASA,MAAA,KAAA,GAAA,OAAA,CAAA,oDAAA,CAAA;;AAEA,MAAA,gBAAA,GAAA,OAAA,CAAA,wDAAA,CAAA;;AAEA,MAAA,oBAAA,GAAA,OAAA,CAAA,4DAAA,CAAA;;AACA,MAAA,mBAAA,GAAA,OAAA,CAAA,2DAAA,CAAA;AAkBA;;;;;;;;;;;;;;;AAeG;;;AACH,WAAgB,oBAAhB,CACI,EADJ,EACoB,UADpB,EAC4C,eAD5C,EAEI,qBAFJ,EAEqD,UAFrD,EAEyE,MAFzE,EAGI,MAHJ,EAG8B,aAH9B,EAG4D,YAH5D,EAII,gBAJJ,EAKI,+BALJ,EAKmD;AAD/C,QAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,gBAAA,GAAA,KAAA;AAAiC;;AACjC,QAAA,+BAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,+BAAA,GAAA,IAAA;AAA+C,KAAA,CACjD;;;AACA,QAAM,OAAO,GAAG,UAAU,CAAC,WAA3B;;AACA,QAAM,OAAO,GAAA,OAAA,CAAA,QAAA,CAAA;AACW,MAAA,OAAO,EAAE,IADpB;AAC0B,MAAA,oBAAoB,EAAE,QADhD;AAC0D,MAAA,OAAO,EAAA;AADjE,KAAA,EACsE,YADtE,CAAb;;AAEA,QAAM,eAAe,GAAG,IAAI,mBAAA,CAAA,mBAAJ,CAAwB,EAAxB,EAA4B,eAA5B,CAAxB;AACA,QAAM,OAAO,GAAG,IAAI,oBAAA,CAAA,mBAAJ,CAAwB,EAAxB,EAA4B,OAA5B,EAAqC,eAArC,EAAsD,qBAAtD,CAAhB;AACA,QAAM,OAAO,GAAG,IAAI,oBAAA,CAAA,uBAAJ,CACZ,EADY,EACR,OADQ,EACC,eADD,EACkB,qBADlB,EACyC,UAAU,CAAC,WADpD,CAAhB,CAPiD,CAUjD;;AACA,QAAM,aAAa,GAAG,EAAE,CAAC,OAAH,CAAW,UAAU,CAAC,IAAtB,EAA4B,UAA5B,CAAtB;AACA,QAAM,WAAW,GAAG,EAAE,CAAC,OAAH,CAAW,UAAU,CAAC,IAAtB,EAA4B,UAAU,CAAC,OAAvC,CAApB;AACA,QAAM,GAAG,GAAG,gBAAA,CAAA,iBAAA,CACR,EADQ,EACJ,MADI,EACI,UAAU,CAAC,WADf,EAC4B,aAD5B,EAC2C,eAD3C,EAC4D,OAD5D,EACqE,OADrE,CAAZ;AAEA,QAAM,kBAAkB,GAAG,aAAa,KAAK,KAAA,CAAA,aAAA,CAAc,EAAhC,IAAsC,gBAAtC,GACvB,mCAAmC,CAAC,EAAD,EAAK,GAAG,CAAC,OAAT,EAAkB,aAAlB,EAAiC,WAAjC,CADZ,GAEvB,EAFJ;AAGA,QAAM,GAAG,GAAG,aAAa,KAAK,KAAA,CAAA,aAAA,CAAc,EAAhC,GACR,gBAAA,CAAA,iBAAA,CACI,EADJ,EACQ,MADR,EACgB,UAAU,CAAC,WAD3B,EACwC,WADxC,EACqD,iBADrD,EACsE,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAC9D,OAD8D,CAAA,EACvD;AAAE,MAAA,OAAO,EAAE;AAAX,KADuD,CADtE,EAEkC,OAFlC,EAE2C,kBAF3C,CADQ,GAIR,IAJJ;AAKA,QAAM,UAAU,GAAG,MAAM,IAAI,GAAG,CAAC,aAAJ,KAAsB,IAAnD;AAEA,WAAO;AACL,MAAA,UAAU,EAAA,UADL;AAEL,MAAA,MAAM,EAAA,MAFD;AAGL,MAAA,QAAQ,EAAE,CAAC,OAAD,CAHL;AAIL,MAAA,MAAM,EAAA,MAJD;AAKL,MAAA,UAAU,EAAA,UALL;AAML,MAAA,GAAG,EAAA,GANE;AAOL,MAAA,GAAG,EAAA,GAPE;AAQL,MAAA,aAAa,EAAA,aARR;AASL,MAAA,+BAA+B,EAAA;AAT1B,KAAP;AAWD;;AAzCD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AA2CA,WAAS,mCAAT,CACI,EADJ,EAC4B,UAD5B,EACoD,UADpD,EAEI,WAFJ,EAE+B;;;AAC7B,QAAM,UAAU,GAAG,EAAE,CAAC,OAAH,CAAW,UAAX,CAAnB;AACA,QAAM,WAAW,GAAG,EAAE,CAAC,OAAH,CAAW,WAAX,CAApB;AACA,QAAM,eAAe,GAAqB,EAA1C;;;AACA,WAAiB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,UAAU,CAAC,cAAX,EAAA,CAAA,EAA2B,EAAA,GAAA,EAAA,CAAA,IAAA,EAA5C,EAA4C,CAAA,EAAA,CAAA,IAA5C,EAA4C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA5C,EAA8C;AAAzC,YAAM,EAAE,GAAA,EAAA,CAAA,KAAR;;AACH,YAAI,CAAC,EAAE,CAAC,QAAH,CAAY,QAAZ,CAAqB,KAArB,CAAL,EAAkC;AAChC;AACD,SAH2C,CAK5C;AACA;;;AACA,YAAM,eAAe,GACjB,EAAE,CAAC,OAAH,CAAW,WAAX,EAAwB,EAAE,CAAC,QAAH,CAAY,UAAZ,EAAwB,EAAE,CAAC,QAAH,CAAY,OAAZ,CAAoB,OAApB,EAA6B,OAA7B,CAAxB,CAAxB,CADJ;;AAEA,YAAI,EAAE,CAAC,MAAH,CAAU,eAAV,CAAJ,EAAgC;AAC9B,UAAA,eAAe,CAAC,IAAhB,CAAqB,eAArB;AACD;AACF;;;;;;;;;;;;;AACD,WAAO,eAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport {AbsoluteFsPath, FileSystem, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {DtsProcessing} from '../execution/tasks/api';\nimport {PathMappings} from '../path_mappings';\nimport {BundleProgram, makeBundleProgram} from './bundle_program';\nimport {EntryPoint, EntryPointFormat} from './entry_point';\nimport {NgccDtsCompilerHost, NgccSourcesCompilerHost} from './ngcc_compiler_host';\nimport {EntryPointFileCache, SharedFileCache} from './source_file_cache';\n\n/**\n * A bundle of files and paths (and TS programs) that correspond to a particular\n * format of a package entry-point.\n */\nexport interface EntryPointBundle {\n  entryPoint: EntryPoint;\n  format: EntryPointFormat;\n  isCore: boolean;\n  isFlatCore: boolean;\n  rootDirs: AbsoluteFsPath[];\n  src: BundleProgram;\n  dts: BundleProgram|null;\n  dtsProcessing: DtsProcessing;\n  enableI18nLegacyMessageIdFormat: boolean;\n}\n\n/**\n * Get an object that describes a formatted bundle for an entry-point.\n * @param fs The current file-system being used.\n * @param entryPoint The entry-point that contains the bundle.\n * @param sharedFileCache The cache to use for source files that are shared across all entry-points.\n * @param moduleResolutionCache The module resolution cache to use.\n * @param formatPath The path to the source files for this bundle.\n * @param isCore This entry point is the Angular core package.\n * @param format The underlying format of the bundle.\n * @param dtsProcessing Whether to transform the typings along with this bundle.\n * @param pathMappings An optional set of mappings to use when compiling files.\n * @param mirrorDtsFromSrc If true then the `dts` program will contain additional files that\n * were guessed by mapping the `src` files to `dts` files.\n * @param enableI18nLegacyMessageIdFormat Whether to render legacy message ids for i18n messages in\n * component templates.\n */\nexport function makeEntryPointBundle(\n    fs: FileSystem, entryPoint: EntryPoint, sharedFileCache: SharedFileCache,\n    moduleResolutionCache: ts.ModuleResolutionCache, formatPath: string, isCore: boolean,\n    format: EntryPointFormat, dtsProcessing: DtsProcessing, pathMappings?: PathMappings,\n    mirrorDtsFromSrc: boolean = false,\n    enableI18nLegacyMessageIdFormat: boolean = true): EntryPointBundle {\n  // Create the TS program and necessary helpers.\n  const rootDir = entryPoint.packagePath;\n  const options: ts\n      .CompilerOptions = {allowJs: true, maxNodeModuleJsDepth: Infinity, rootDir, ...pathMappings};\n  const entryPointCache = new EntryPointFileCache(fs, sharedFileCache);\n  const dtsHost = new NgccDtsCompilerHost(fs, options, entryPointCache, moduleResolutionCache);\n  const srcHost = new NgccSourcesCompilerHost(\n      fs, options, entryPointCache, moduleResolutionCache, entryPoint.packagePath);\n\n  // Create the bundle programs, as necessary.\n  const absFormatPath = fs.resolve(entryPoint.path, formatPath);\n  const typingsPath = fs.resolve(entryPoint.path, entryPoint.typings);\n  const src = makeBundleProgram(\n      fs, isCore, entryPoint.packagePath, absFormatPath, 'r3_symbols.js', options, srcHost);\n  const additionalDtsFiles = dtsProcessing !== DtsProcessing.No && mirrorDtsFromSrc ?\n      computePotentialDtsFilesFromJsFiles(fs, src.program, absFormatPath, typingsPath) :\n      [];\n  const dts = dtsProcessing !== DtsProcessing.No ?\n      makeBundleProgram(\n          fs, isCore, entryPoint.packagePath, typingsPath, 'r3_symbols.d.ts',\n          {...options, allowJs: false}, dtsHost, additionalDtsFiles) :\n      null;\n  const isFlatCore = isCore && src.r3SymbolsFile === null;\n\n  return {\n    entryPoint,\n    format,\n    rootDirs: [rootDir],\n    isCore,\n    isFlatCore,\n    src,\n    dts,\n    dtsProcessing,\n    enableI18nLegacyMessageIdFormat\n  };\n}\n\nfunction computePotentialDtsFilesFromJsFiles(\n    fs: ReadonlyFileSystem, srcProgram: ts.Program, formatPath: AbsoluteFsPath,\n    typingsPath: AbsoluteFsPath) {\n  const formatRoot = fs.dirname(formatPath);\n  const typingsRoot = fs.dirname(typingsPath);\n  const additionalFiles: AbsoluteFsPath[] = [];\n  for (const sf of srcProgram.getSourceFiles()) {\n    if (!sf.fileName.endsWith('.js')) {\n      continue;\n    }\n\n    // Given a source file at e.g. `esm2015/src/some/nested/index.js`, try to resolve the\n    // declaration file under the typings root in `src/some/nested/index.d.ts`.\n    const mirroredDtsPath =\n        fs.resolve(typingsRoot, fs.relative(formatRoot, sf.fileName.replace(/\\.js$/, '.d.ts')));\n    if (fs.exists(mirroredDtsPath)) {\n      additionalFiles.push(mirroredDtsPath);\n    }\n  }\n  return additionalFiles;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}