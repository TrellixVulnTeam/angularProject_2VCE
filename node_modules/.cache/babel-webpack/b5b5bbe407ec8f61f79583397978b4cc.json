{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/view_compiler/provider_compiler\", [\"require\", \"exports\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/lifecycle_reflector\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/output/value_util\", \"@angular/compiler/src/template_parser/template_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.componentFactoryResolverProviderDef = exports.lifecycleHookToNodeFlag = exports.depDef = exports.providerDef = void 0;\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var lifecycle_reflector_1 = require(\"@angular/compiler/src/lifecycle_reflector\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var value_util_1 = require(\"@angular/compiler/src/output/value_util\");\n\n  var template_ast_1 = require(\"@angular/compiler/src/template_parser/template_ast\");\n\n  function providerDef(ctx, providerAst) {\n    var flags = 0\n    /* None */\n    ;\n\n    if (!providerAst.eager) {\n      flags |= 4096\n      /* LazyProvider */\n      ;\n    }\n\n    if (providerAst.providerType === template_ast_1.ProviderAstType.PrivateService) {\n      flags |= 8192\n      /* PrivateProvider */\n      ;\n    }\n\n    if (providerAst.isModule) {\n      flags |= 1073741824\n      /* TypeModuleProvider */\n      ;\n    }\n\n    providerAst.lifecycleHooks.forEach(function (lifecycleHook) {\n      // for regular providers, we only support ngOnDestroy\n      if (lifecycleHook === lifecycle_reflector_1.LifecycleHooks.OnDestroy || providerAst.providerType === template_ast_1.ProviderAstType.Directive || providerAst.providerType === template_ast_1.ProviderAstType.Component) {\n        flags |= lifecycleHookToNodeFlag(lifecycleHook);\n      }\n    });\n\n    var _a = providerAst.multiProvider ? multiProviderDef(ctx, flags, providerAst.providers) : singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]),\n        providerExpr = _a.providerExpr,\n        providerFlags = _a.flags,\n        depsExpr = _a.depsExpr;\n\n    return {\n      providerExpr: providerExpr,\n      flags: providerFlags,\n      depsExpr: depsExpr,\n      tokenExpr: tokenExpr(ctx, providerAst.token)\n    };\n  }\n\n  exports.providerDef = providerDef;\n\n  function multiProviderDef(ctx, flags, providers) {\n    var allDepDefs = [];\n    var allParams = [];\n    var exprs = providers.map(function (provider, providerIndex) {\n      var expr;\n\n      if (provider.useClass) {\n        var depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n        expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n      } else if (provider.useFactory) {\n        var depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n        expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n      } else if (provider.useExisting) {\n        var depExprs = convertDeps(providerIndex, [{\n          token: provider.useExisting\n        }]);\n        expr = depExprs[0];\n      } else {\n        expr = value_util_1.convertValueToOutputAst(ctx, provider.useValue);\n      }\n\n      return expr;\n    });\n    var providerExpr = o.fn(allParams, [new o.ReturnStatement(o.literalArr(exprs))], o.INFERRED_TYPE);\n    return {\n      providerExpr: providerExpr,\n      flags: flags | 1024\n      /* TypeFactoryProvider */\n      ,\n      depsExpr: o.literalArr(allDepDefs)\n    };\n\n    function convertDeps(providerIndex, deps) {\n      return deps.map(function (dep, depIndex) {\n        var paramName = \"p\" + providerIndex + \"_\" + depIndex;\n        allParams.push(new o.FnParam(paramName, o.DYNAMIC_TYPE));\n        allDepDefs.push(depDef(ctx, dep));\n        return o.variable(paramName);\n      });\n    }\n  }\n\n  function singleProviderDef(ctx, flags, providerType, providerMeta) {\n    var providerExpr;\n    var deps;\n\n    if (providerType === template_ast_1.ProviderAstType.Directive || providerType === template_ast_1.ProviderAstType.Component) {\n      providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n      flags |= 16384\n      /* TypeDirective */\n      ;\n      deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    } else {\n      if (providerMeta.useClass) {\n        providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n        flags |= 512\n        /* TypeClassProvider */\n        ;\n        deps = providerMeta.deps || providerMeta.useClass.diDeps;\n      } else if (providerMeta.useFactory) {\n        providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n        flags |= 1024\n        /* TypeFactoryProvider */\n        ;\n        deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n      } else if (providerMeta.useExisting) {\n        providerExpr = o.NULL_EXPR;\n        flags |= 2048\n        /* TypeUseExistingProvider */\n        ;\n        deps = [{\n          token: providerMeta.useExisting\n        }];\n      } else {\n        providerExpr = value_util_1.convertValueToOutputAst(ctx, providerMeta.useValue);\n        flags |= 256\n        /* TypeValueProvider */\n        ;\n        deps = [];\n      }\n    }\n\n    var depsExpr = o.literalArr(deps.map(function (dep) {\n      return depDef(ctx, dep);\n    }));\n    return {\n      providerExpr: providerExpr,\n      flags: flags,\n      depsExpr: depsExpr\n    };\n  }\n\n  function tokenExpr(ctx, tokenMeta) {\n    return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) : o.literal(tokenMeta.value);\n  }\n\n  function depDef(ctx, dep) {\n    // Note: the following fields have already been normalized out by provider_analyzer:\n    // - isAttribute, isHost\n    var expr = dep.isValue ? value_util_1.convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token);\n    var flags = 0\n    /* None */\n    ;\n\n    if (dep.isSkipSelf) {\n      flags |= 1\n      /* SkipSelf */\n      ;\n    }\n\n    if (dep.isOptional) {\n      flags |= 2\n      /* Optional */\n      ;\n    }\n\n    if (dep.isSelf) {\n      flags |= 4\n      /* Self */\n      ;\n    }\n\n    if (dep.isValue) {\n      flags |= 8\n      /* Value */\n      ;\n    }\n\n    return flags === 0\n    /* None */\n    ? expr : o.literalArr([o.literal(flags), expr]);\n  }\n\n  exports.depDef = depDef;\n\n  function lifecycleHookToNodeFlag(lifecycleHook) {\n    var nodeFlag = 0\n    /* None */\n    ;\n\n    switch (lifecycleHook) {\n      case lifecycle_reflector_1.LifecycleHooks.AfterContentChecked:\n        nodeFlag = 2097152\n        /* AfterContentChecked */\n        ;\n        break;\n\n      case lifecycle_reflector_1.LifecycleHooks.AfterContentInit:\n        nodeFlag = 1048576\n        /* AfterContentInit */\n        ;\n        break;\n\n      case lifecycle_reflector_1.LifecycleHooks.AfterViewChecked:\n        nodeFlag = 8388608\n        /* AfterViewChecked */\n        ;\n        break;\n\n      case lifecycle_reflector_1.LifecycleHooks.AfterViewInit:\n        nodeFlag = 4194304\n        /* AfterViewInit */\n        ;\n        break;\n\n      case lifecycle_reflector_1.LifecycleHooks.DoCheck:\n        nodeFlag = 262144\n        /* DoCheck */\n        ;\n        break;\n\n      case lifecycle_reflector_1.LifecycleHooks.OnChanges:\n        nodeFlag = 524288\n        /* OnChanges */\n        ;\n        break;\n\n      case lifecycle_reflector_1.LifecycleHooks.OnDestroy:\n        nodeFlag = 131072\n        /* OnDestroy */\n        ;\n        break;\n\n      case lifecycle_reflector_1.LifecycleHooks.OnInit:\n        nodeFlag = 65536\n        /* OnInit */\n        ;\n        break;\n    }\n\n    return nodeFlag;\n  }\n\n  exports.lifecycleHookToNodeFlag = lifecycleHookToNodeFlag;\n\n  function componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {\n    var entryComponentFactories = entryComponents.map(function (entryComponent) {\n      return ctx.importExpr(entryComponent.componentFactory);\n    });\n    var token = identifiers_1.createTokenForExternalReference(reflector, identifiers_1.Identifiers.ComponentFactoryResolver);\n    var classMeta = {\n      diDeps: [{\n        isValue: true,\n        value: o.literalArr(entryComponentFactories)\n      }, {\n        token: token,\n        isSkipSelf: true,\n        isOptional: true\n      }, {\n        token: identifiers_1.createTokenForExternalReference(reflector, identifiers_1.Identifiers.NgModuleRef)\n      }],\n      lifecycleHooks: [],\n      reference: reflector.resolveExternalReference(identifiers_1.Identifiers.CodegenComponentFactoryResolver)\n    };\n\n    var _a = singleProviderDef(ctx, flags, template_ast_1.ProviderAstType.PrivateService, {\n      token: token,\n      multi: false,\n      useClass: classMeta\n    }),\n        providerExpr = _a.providerExpr,\n        providerFlags = _a.flags,\n        depsExpr = _a.depsExpr;\n\n    return {\n      providerExpr: providerExpr,\n      flags: providerFlags,\n      depsExpr: depsExpr,\n      tokenExpr: tokenExpr(ctx, token)\n    };\n  }\n\n  exports.componentFactoryResolverProviderDef = componentFactoryResolverProviderDef;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/view_compiler/provider_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDiDependencyMetadata, CompileEntryComponentMetadata, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {DepFlags, NodeFlags} from '../core';\nimport {createTokenForExternalReference, Identifiers} from '../identifiers';\nimport {LifecycleHooks} from '../lifecycle_reflector';\nimport * as o from '../output/output_ast';\nimport {convertValueToOutputAst} from '../output/value_util';\nimport {ProviderAst, ProviderAstType} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\nexport function providerDef(ctx: OutputContext, providerAst: ProviderAst): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  let flags = NodeFlags.None;\n  if (!providerAst.eager) {\n    flags |= NodeFlags.LazyProvider;\n  }\n  if (providerAst.providerType === ProviderAstType.PrivateService) {\n    flags |= NodeFlags.PrivateProvider;\n  }\n  if (providerAst.isModule) {\n    flags |= NodeFlags.TypeModuleProvider;\n  }\n  providerAst.lifecycleHooks.forEach((lifecycleHook) => {\n    // for regular providers, we only support ngOnDestroy\n    if (lifecycleHook === LifecycleHooks.OnDestroy ||\n        providerAst.providerType === ProviderAstType.Directive ||\n        providerAst.providerType === ProviderAstType.Component) {\n      flags |= lifecycleHookToNodeFlag(lifecycleHook);\n    }\n  });\n  const {providerExpr, flags: providerFlags, depsExpr} = providerAst.multiProvider ?\n      multiProviderDef(ctx, flags, providerAst.providers) :\n      singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);\n  return {\n    providerExpr,\n    flags: providerFlags,\n    depsExpr,\n    tokenExpr: tokenExpr(ctx, providerAst.token),\n  };\n}\n\nfunction multiProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providers: CompileProviderMetadata[]):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  const allDepDefs: o.Expression[] = [];\n  const allParams: o.FnParam[] = [];\n  const exprs = providers.map((provider, providerIndex) => {\n    let expr: o.Expression;\n    if (provider.useClass) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n      expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n    } else if (provider.useFactory) {\n      const depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n      expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\n    } else if (provider.useExisting) {\n      const depExprs = convertDeps(providerIndex, [{token: provider.useExisting}]);\n      expr = depExprs[0];\n    } else {\n      expr = convertValueToOutputAst(ctx, provider.useValue);\n    }\n    return expr;\n  });\n  const providerExpr =\n      o.fn(allParams, [new o.ReturnStatement(o.literalArr(exprs))], o.INFERRED_TYPE);\n  return {\n    providerExpr,\n    flags: flags | NodeFlags.TypeFactoryProvider,\n    depsExpr: o.literalArr(allDepDefs)\n  };\n\n  function convertDeps(providerIndex: number, deps: CompileDiDependencyMetadata[]) {\n    return deps.map((dep, depIndex) => {\n      const paramName = `p${providerIndex}_${depIndex}`;\n      allParams.push(new o.FnParam(paramName, o.DYNAMIC_TYPE));\n      allDepDefs.push(depDef(ctx, dep));\n      return o.variable(paramName);\n    });\n  }\n}\n\nfunction singleProviderDef(\n    ctx: OutputContext, flags: NodeFlags, providerType: ProviderAstType,\n    providerMeta: CompileProviderMetadata):\n    {providerExpr: o.Expression, flags: NodeFlags, depsExpr: o.Expression} {\n  let providerExpr: o.Expression;\n  let deps: CompileDiDependencyMetadata[];\n  if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n    providerExpr = ctx.importExpr(providerMeta.useClass!.reference);\n    flags |= NodeFlags.TypeDirective;\n    deps = providerMeta.deps || providerMeta.useClass!.diDeps;\n  } else {\n    if (providerMeta.useClass) {\n      providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n      flags |= NodeFlags.TypeClassProvider;\n      deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    } else if (providerMeta.useFactory) {\n      providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n      flags |= NodeFlags.TypeFactoryProvider;\n      deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n    } else if (providerMeta.useExisting) {\n      providerExpr = o.NULL_EXPR;\n      flags |= NodeFlags.TypeUseExistingProvider;\n      deps = [{token: providerMeta.useExisting}];\n    } else {\n      providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n      flags |= NodeFlags.TypeValueProvider;\n      deps = [];\n    }\n  }\n  const depsExpr = o.literalArr(deps.map(dep => depDef(ctx, dep)));\n  return {providerExpr, flags, depsExpr};\n}\n\nfunction tokenExpr(ctx: OutputContext, tokenMeta: CompileTokenMetadata): o.Expression {\n  return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\n                                o.literal(tokenMeta.value);\n}\n\nexport function depDef(ctx: OutputContext, dep: CompileDiDependencyMetadata): o.Expression {\n  // Note: the following fields have already been normalized out by provider_analyzer:\n  // - isAttribute, isHost\n  const expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token!);\n  let flags = DepFlags.None;\n  if (dep.isSkipSelf) {\n    flags |= DepFlags.SkipSelf;\n  }\n  if (dep.isOptional) {\n    flags |= DepFlags.Optional;\n  }\n  if (dep.isSelf) {\n    flags |= DepFlags.Self;\n  }\n  if (dep.isValue) {\n    flags |= DepFlags.Value;\n  }\n  return flags === DepFlags.None ? expr : o.literalArr([o.literal(flags), expr]);\n}\n\nexport function lifecycleHookToNodeFlag(lifecycleHook: LifecycleHooks): NodeFlags {\n  let nodeFlag = NodeFlags.None;\n  switch (lifecycleHook) {\n    case LifecycleHooks.AfterContentChecked:\n      nodeFlag = NodeFlags.AfterContentChecked;\n      break;\n    case LifecycleHooks.AfterContentInit:\n      nodeFlag = NodeFlags.AfterContentInit;\n      break;\n    case LifecycleHooks.AfterViewChecked:\n      nodeFlag = NodeFlags.AfterViewChecked;\n      break;\n    case LifecycleHooks.AfterViewInit:\n      nodeFlag = NodeFlags.AfterViewInit;\n      break;\n    case LifecycleHooks.DoCheck:\n      nodeFlag = NodeFlags.DoCheck;\n      break;\n    case LifecycleHooks.OnChanges:\n      nodeFlag = NodeFlags.OnChanges;\n      break;\n    case LifecycleHooks.OnDestroy:\n      nodeFlag = NodeFlags.OnDestroy;\n      break;\n    case LifecycleHooks.OnInit:\n      nodeFlag = NodeFlags.OnInit;\n      break;\n  }\n  return nodeFlag;\n}\n\nexport function componentFactoryResolverProviderDef(\n    reflector: CompileReflector, ctx: OutputContext, flags: NodeFlags,\n    entryComponents: CompileEntryComponentMetadata[]): {\n  providerExpr: o.Expression,\n  flags: NodeFlags,\n  depsExpr: o.Expression,\n  tokenExpr: o.Expression\n} {\n  const entryComponentFactories =\n      entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));\n  const token = createTokenForExternalReference(reflector, Identifiers.ComponentFactoryResolver);\n  const classMeta = {\n    diDeps: [\n      {isValue: true, value: o.literalArr(entryComponentFactories)},\n      {token: token, isSkipSelf: true, isOptional: true},\n      {token: createTokenForExternalReference(reflector, Identifiers.NgModuleRef)},\n    ],\n    lifecycleHooks: [],\n    reference: reflector.resolveExternalReference(Identifiers.CodegenComponentFactoryResolver)\n  };\n  const {providerExpr, flags: providerFlags, depsExpr} =\n      singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n        token,\n        multi: false,\n        useClass: classMeta,\n      });\n  return {providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token)};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}