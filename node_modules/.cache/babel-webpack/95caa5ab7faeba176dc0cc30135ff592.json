{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/source\", [\"require\", \"exports\", \"@angular/compiler\", \"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/line_mappings\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TemplateSourceManager = exports.TemplateSource = void 0;\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\");\n\n  var line_mappings_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/line_mappings\");\n  /**\n   * Represents the source of a template that was processed during type-checking. This information is\n   * used when translating parse offsets in diagnostics back to their original line/column location.\n   */\n\n\n  var TemplateSource =\n  /** @class */\n  function () {\n    function TemplateSource(mapping, file) {\n      this.mapping = mapping;\n      this.file = file;\n      this.lineStarts = null;\n    }\n\n    TemplateSource.prototype.toParseSourceSpan = function (start, end) {\n      var startLoc = this.toParseLocation(start);\n      var endLoc = this.toParseLocation(end);\n      return new compiler_1.ParseSourceSpan(startLoc, endLoc);\n    };\n\n    TemplateSource.prototype.toParseLocation = function (position) {\n      var lineStarts = this.acquireLineStarts();\n\n      var _a = line_mappings_1.getLineAndCharacterFromPosition(lineStarts, position),\n          line = _a.line,\n          character = _a.character;\n\n      return new compiler_1.ParseLocation(this.file, position, line, character);\n    };\n\n    TemplateSource.prototype.acquireLineStarts = function () {\n      if (this.lineStarts === null) {\n        this.lineStarts = line_mappings_1.computeLineStartsMap(this.file.content);\n      }\n\n      return this.lineStarts;\n    };\n\n    return TemplateSource;\n  }();\n\n  exports.TemplateSource = TemplateSource;\n  /**\n   * Assigns IDs to templates and keeps track of their origins.\n   *\n   * Implements `TemplateSourceResolver` to resolve the source of a template based on these IDs.\n   */\n\n  var TemplateSourceManager =\n  /** @class */\n  function () {\n    function TemplateSourceManager() {\n      /**\n       * This map keeps track of all template sources that have been type-checked by the id that is\n       * attached to a TCB's function declaration as leading trivia. This enables translation of\n       * diagnostics produced for TCB code to their source location in the template.\n       */\n      this.templateSources = new Map();\n    }\n\n    TemplateSourceManager.prototype.getTemplateId = function (node) {\n      return diagnostics_1.getTemplateId(node);\n    };\n\n    TemplateSourceManager.prototype.captureSource = function (node, mapping, file) {\n      var id = diagnostics_1.getTemplateId(node);\n      this.templateSources.set(id, new TemplateSource(mapping, file));\n      return id;\n    };\n\n    TemplateSourceManager.prototype.getSourceMapping = function (id) {\n      if (!this.templateSources.has(id)) {\n        throw new Error(\"Unexpected unknown template ID: \" + id);\n      }\n\n      return this.templateSources.get(id).mapping;\n    };\n\n    TemplateSourceManager.prototype.toParseSourceSpan = function (id, span) {\n      if (!this.templateSources.has(id)) {\n        return null;\n      }\n\n      var templateSource = this.templateSources.get(id);\n      return templateSource.toParseSourceSpan(span.start, span.end);\n    };\n\n    return TemplateSourceManager;\n  }();\n\n  exports.TemplateSourceManager = TemplateSourceManager;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/source.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteSourceSpan, ParseLocation, ParseSourceFile, ParseSourceSpan} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {TemplateId, TemplateSourceMapping} from '../api';\nimport {getTemplateId} from '../diagnostics';\n\nimport {computeLineStartsMap, getLineAndCharacterFromPosition} from './line_mappings';\nimport {TemplateSourceResolver} from './tcb_util';\n\n/**\n * Represents the source of a template that was processed during type-checking. This information is\n * used when translating parse offsets in diagnostics back to their original line/column location.\n */\nexport class TemplateSource {\n  private lineStarts: number[]|null = null;\n\n  constructor(readonly mapping: TemplateSourceMapping, private file: ParseSourceFile) {}\n\n  toParseSourceSpan(start: number, end: number): ParseSourceSpan {\n    const startLoc = this.toParseLocation(start);\n    const endLoc = this.toParseLocation(end);\n    return new ParseSourceSpan(startLoc, endLoc);\n  }\n\n  private toParseLocation(position: number) {\n    const lineStarts = this.acquireLineStarts();\n    const {line, character} = getLineAndCharacterFromPosition(lineStarts, position);\n    return new ParseLocation(this.file, position, line, character);\n  }\n\n  private acquireLineStarts(): number[] {\n    if (this.lineStarts === null) {\n      this.lineStarts = computeLineStartsMap(this.file.content);\n    }\n    return this.lineStarts;\n  }\n}\n\n/**\n * Assigns IDs to templates and keeps track of their origins.\n *\n * Implements `TemplateSourceResolver` to resolve the source of a template based on these IDs.\n */\nexport class TemplateSourceManager implements TemplateSourceResolver {\n  /**\n   * This map keeps track of all template sources that have been type-checked by the id that is\n   * attached to a TCB's function declaration as leading trivia. This enables translation of\n   * diagnostics produced for TCB code to their source location in the template.\n   */\n  private templateSources = new Map<TemplateId, TemplateSource>();\n\n  getTemplateId(node: ts.ClassDeclaration): TemplateId {\n    return getTemplateId(node);\n  }\n\n  captureSource(node: ts.ClassDeclaration, mapping: TemplateSourceMapping, file: ParseSourceFile):\n      TemplateId {\n    const id = getTemplateId(node);\n    this.templateSources.set(id, new TemplateSource(mapping, file));\n    return id;\n  }\n\n  getSourceMapping(id: TemplateId): TemplateSourceMapping {\n    if (!this.templateSources.has(id)) {\n      throw new Error(`Unexpected unknown template ID: ${id}`);\n    }\n    return this.templateSources.get(id)!.mapping;\n  }\n\n  toParseSourceSpan(id: TemplateId, span: AbsoluteSourceSpan): ParseSourceSpan|null {\n    if (!this.templateSources.has(id)) {\n      return null;\n    }\n    const templateSource = this.templateSources.get(id)!;\n    return templateSource.toParseSourceSpan(span.start, span.end);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}