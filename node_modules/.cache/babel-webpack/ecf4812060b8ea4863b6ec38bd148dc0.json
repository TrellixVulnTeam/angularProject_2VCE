{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar Source = require(\"./Source\");\n\nvar _require = require(\"source-map\"),\n    SourceNode = _require.SourceNode;\n\nvar _require2 = require(\"./helpers\"),\n    getSourceAndMap = _require2.getSourceAndMap,\n    getMap = _require2.getMap,\n    getNode = _require2.getNode,\n    getListMap = _require2.getListMap;\n\nvar Replacement = function Replacement(start, end, content, insertIndex, name) {\n  _classCallCheck(this, Replacement);\n\n  this.start = start;\n  this.end = end;\n  this.content = content;\n  this.insertIndex = insertIndex;\n  this.name = name;\n};\n\nvar ReplaceSource = /*#__PURE__*/function (_Source) {\n  _inherits(ReplaceSource, _Source);\n\n  var _super = _createSuper(ReplaceSource);\n\n  function ReplaceSource(source, name) {\n    var _this;\n\n    _classCallCheck(this, ReplaceSource);\n\n    _this = _super.call(this);\n    _this._source = source;\n    _this._name = name;\n    /** @type {Replacement[]} */\n\n    _this._replacements = [];\n    _this._isSorted = true;\n    return _this;\n  }\n\n  _createClass(ReplaceSource, [{\n    key: \"getName\",\n    value: function getName() {\n      return this._name;\n    }\n  }, {\n    key: \"getReplacements\",\n    value: function getReplacements() {\n      var replacements = Array.from(this._replacements);\n      replacements.sort(function (a, b) {\n        return a.insertIndex - b.insertIndex;\n      });\n      return replacements;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(start, end, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue);\n\n      this._replacements.push(new Replacement(start, end, newValue, this._replacements.length, name));\n\n      this._isSorted = false;\n    }\n  }, {\n    key: \"insert\",\n    value: function insert(pos, newValue, name) {\n      if (typeof newValue !== \"string\") throw new Error(\"insertion must be a string, but is a \" + typeof newValue + \": \" + newValue);\n\n      this._replacements.push(new Replacement(pos, pos - 1, newValue, this._replacements.length, name));\n\n      this._isSorted = false;\n    }\n  }, {\n    key: \"source\",\n    value: function source() {\n      return this._replaceString(this._source.source());\n    }\n  }, {\n    key: \"map\",\n    value: function map(options) {\n      if (this._replacements.length === 0) {\n        return this._source.map(options);\n      }\n\n      return getMap(this, options);\n    }\n  }, {\n    key: \"sourceAndMap\",\n    value: function sourceAndMap(options) {\n      if (this._replacements.length === 0) {\n        return this._source.sourceAndMap(options);\n      }\n\n      return getSourceAndMap(this, options);\n    }\n  }, {\n    key: \"original\",\n    value: function original() {\n      return this._source;\n    }\n  }, {\n    key: \"_sortReplacements\",\n    value: function _sortReplacements() {\n      if (this._isSorted) return;\n\n      this._replacements.sort(function (a, b) {\n        var diff1 = b.end - a.end;\n        if (diff1 !== 0) return diff1;\n        var diff2 = b.start - a.start;\n        if (diff2 !== 0) return diff2;\n        return b.insertIndex - a.insertIndex;\n      });\n\n      this._isSorted = true;\n    }\n  }, {\n    key: \"_replaceString\",\n    value: function _replaceString(str) {\n      if (typeof str !== \"string\") throw new Error(\"str must be a string, but is a \" + typeof str + \": \" + str);\n\n      this._sortReplacements();\n\n      var result = [str];\n\n      this._replacements.forEach(function (repl) {\n        var remSource = result.pop();\n\n        var splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n\n        var splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n\n        result.push(splitted1[1], repl.content, splitted2[0]);\n      }, this); // write out result array in reverse order\n\n\n      var resultStr = \"\";\n\n      for (var i = result.length - 1; i >= 0; --i) {\n        resultStr += result[i];\n      }\n\n      return resultStr;\n    }\n  }, {\n    key: \"node\",\n    value: function node(options) {\n      var node = getNode(this._source, options);\n\n      if (this._replacements.length === 0) {\n        return node;\n      }\n\n      this._sortReplacements();\n\n      var replace = new ReplacementEnumerator(this._replacements);\n      var output = [];\n      var position = 0;\n      var sources = Object.create(null);\n      var sourcesInLines = Object.create(null); // We build a new list of SourceNodes in \"output\"\n      // from the original mapping data\n\n      var result = new SourceNode(); // We need to add source contents manually\n      // because \"walk\" will not handle it\n\n      node.walkSourceContents(function (sourceFile, sourceContent) {\n        result.setSourceContent(sourceFile, sourceContent);\n        sources[\"$\" + sourceFile] = sourceContent;\n      });\n\n      var replaceInStringNode = this._replaceInStringNode.bind(this, output, replace, function getOriginalSource(mapping) {\n        var key = \"$\" + mapping.source;\n        var lines = sourcesInLines[key];\n\n        if (!lines) {\n          var source = sources[key];\n          if (!source) return null;\n          lines = source.split(\"\\n\").map(function (line) {\n            return line + \"\\n\";\n          });\n          sourcesInLines[key] = lines;\n        } // line is 1-based\n\n\n        if (mapping.line > lines.length) return null;\n        var line = lines[mapping.line - 1];\n        return line.substr(mapping.column);\n      });\n\n      node.walk(function (chunk, mapping) {\n        position = replaceInStringNode(chunk, position, mapping);\n      }); // If any replacements occur after the end of the original file, then we append them\n      // directly to the end of the output\n\n      var remaining = replace.footer();\n\n      if (remaining) {\n        output.push(remaining);\n      }\n\n      result.add(output);\n      return result;\n    }\n  }, {\n    key: \"listMap\",\n    value: function listMap(options) {\n      var map = getListMap(this._source, options);\n\n      this._sortReplacements();\n\n      var currentIndex = 0;\n      var replacements = this._replacements;\n      var idxReplacement = replacements.length - 1;\n      var removeChars = 0;\n      map = map.mapGeneratedCode(function (str) {\n        var newCurrentIndex = currentIndex + str.length;\n\n        if (removeChars > str.length) {\n          removeChars -= str.length;\n          str = \"\";\n        } else {\n          if (removeChars > 0) {\n            str = str.substr(removeChars);\n            currentIndex += removeChars;\n            removeChars = 0;\n          }\n\n          var finalStr = \"\";\n\n          while (idxReplacement >= 0 && replacements[idxReplacement].start < newCurrentIndex) {\n            var repl = replacements[idxReplacement];\n            var start = Math.floor(repl.start);\n            var end = Math.floor(repl.end + 1);\n            var before = str.substr(0, Math.max(0, start - currentIndex));\n\n            if (end <= newCurrentIndex) {\n              var after = str.substr(Math.max(0, end - currentIndex));\n              finalStr += before + repl.content;\n              str = after;\n              currentIndex = Math.max(currentIndex, end);\n            } else {\n              finalStr += before + repl.content;\n              str = \"\";\n              removeChars = end - newCurrentIndex;\n            }\n\n            idxReplacement--;\n          }\n\n          str = finalStr + str;\n        }\n\n        currentIndex = newCurrentIndex;\n        return str;\n      });\n      var extraCode = \"\";\n\n      while (idxReplacement >= 0) {\n        extraCode += replacements[idxReplacement].content;\n        idxReplacement--;\n      }\n\n      if (extraCode) {\n        map.add(extraCode);\n      }\n\n      return map;\n    }\n  }, {\n    key: \"_splitString\",\n    value: function _splitString(str, position) {\n      return position <= 0 ? [\"\", str] : [str.substr(0, position), str.substr(position)];\n    }\n  }, {\n    key: \"_replaceInStringNode\",\n    value: function _replaceInStringNode(output, replace, getOriginalSource, node, position, mapping) {\n      var original = undefined;\n\n      do {\n        var splitPosition = replace.position - position; // If multiple replaces occur in the same location then the splitPosition may be\n        // before the current position for the subsequent splits. Ensure it is >= 0\n\n        if (splitPosition < 0) {\n          splitPosition = 0;\n        }\n\n        if (splitPosition >= node.length || replace.done) {\n          if (replace.emit) {\n            var nodeEnd = new SourceNode(mapping.line, mapping.column, mapping.source, node, mapping.name);\n            output.push(nodeEnd);\n          }\n\n          return position + node.length;\n        }\n\n        var originalColumn = mapping.column; // Try to figure out if generated code matches original code of this segement\n        // If this is the case we assume that it's allowed to move mapping.column\n        // Because getOriginalSource can be expensive we only do it when neccessary\n\n        var nodePart = void 0;\n\n        if (splitPosition > 0) {\n          nodePart = node.slice(0, splitPosition);\n\n          if (original === undefined) {\n            original = getOriginalSource(mapping);\n          }\n\n          if (original && original.length >= splitPosition && original.startsWith(nodePart)) {\n            mapping.column += splitPosition;\n            original = original.substr(splitPosition);\n          }\n        }\n\n        var emit = replace.next();\n\n        if (!emit) {\n          // Stop emitting when we have found the beginning of the string to replace.\n          // Emit the part of the string before splitPosition\n          if (splitPosition > 0) {\n            var nodeStart = new SourceNode(mapping.line, originalColumn, mapping.source, nodePart, mapping.name);\n            output.push(nodeStart);\n          } // Emit the replacement value\n\n\n          if (replace.value) {\n            output.push(new SourceNode(mapping.line, mapping.column, mapping.source, replace.value, mapping.name || replace.name));\n          }\n        } // Recurse with remainder of the string as there may be multiple replaces within a single node\n\n\n        node = node.substr(splitPosition);\n        position += splitPosition; // eslint-disable-next-line no-constant-condition\n      } while (true);\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      this._sortReplacements();\n\n      hash.update(\"ReplaceSource\");\n\n      this._source.updateHash(hash);\n\n      hash.update(this._name || \"\");\n\n      var _iterator = _createForOfIteratorHelper(this._replacements),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var repl = _step.value;\n          hash.update(\"\".concat(repl.start));\n          hash.update(\"\".concat(repl.end));\n          hash.update(\"\".concat(repl.content));\n          hash.update(\"\".concat(repl.insertIndex));\n          hash.update(\"\".concat(repl.name));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }]);\n\n  return ReplaceSource;\n}(Source);\n\nvar ReplacementEnumerator = /*#__PURE__*/function () {\n  /**\n   * @param {Replacement[]} replacements list of replacements\n   */\n  function ReplacementEnumerator(replacements) {\n    _classCallCheck(this, ReplacementEnumerator);\n\n    this.replacements = replacements || [];\n    this.index = this.replacements.length;\n    this.done = false;\n    this.emit = false; // Set initial start position\n\n    this.next();\n  }\n\n  _createClass(ReplacementEnumerator, [{\n    key: \"next\",\n    value: function next() {\n      if (this.done) return true;\n\n      if (this.emit) {\n        // Start point found. stop emitting. set position to find end\n        var repl = this.replacements[this.index];\n        var end = Math.floor(repl.end + 1);\n        this.position = end;\n        this.value = repl.content;\n        this.name = repl.name;\n      } else {\n        // End point found. start emitting. set position to find next start\n        this.index--;\n\n        if (this.index < 0) {\n          this.done = true;\n        } else {\n          var nextRepl = this.replacements[this.index];\n          var start = Math.floor(nextRepl.start);\n          this.position = start;\n        }\n      }\n\n      if (this.position < 0) this.position = 0;\n      this.emit = !this.emit;\n      return this.emit;\n    }\n  }, {\n    key: \"footer\",\n    value: function footer() {\n      if (!this.done && !this.emit) this.next(); // If we finished _replaceInNode mid emit we advance to next entry\n\n      if (this.done) {\n        return [];\n      } else {\n        var resultStr = \"\";\n\n        for (var i = this.index; i >= 0; i--) {\n          var repl = this.replacements[i]; // this doesn't need to handle repl.name, because in SourceMaps generated code\n          // without pointer to original source can't have a name\n\n          resultStr += repl.content;\n        }\n\n        return resultStr;\n      }\n    }\n  }]);\n\n  return ReplacementEnumerator;\n}();\n\nmodule.exports = ReplaceSource;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/webpack-sources/lib/ReplaceSource.js"],"names":["Source","require","SourceNode","getSourceAndMap","getMap","getNode","getListMap","Replacement","start","end","content","insertIndex","name","ReplaceSource","source","_source","_name","_replacements","_isSorted","replacements","Array","from","sort","a","b","newValue","Error","push","length","pos","_replaceString","options","map","sourceAndMap","diff1","diff2","str","_sortReplacements","result","forEach","repl","remSource","pop","splitted1","_splitString","Math","floor","splitted2","resultStr","i","node","replace","ReplacementEnumerator","output","position","sources","Object","create","sourcesInLines","walkSourceContents","sourceFile","sourceContent","setSourceContent","replaceInStringNode","_replaceInStringNode","bind","getOriginalSource","mapping","key","lines","split","line","substr","column","walk","chunk","remaining","footer","add","currentIndex","idxReplacement","removeChars","mapGeneratedCode","newCurrentIndex","finalStr","before","max","after","extraCode","original","undefined","splitPosition","done","emit","nodeEnd","originalColumn","nodePart","slice","startsWith","next","nodeStart","value","hash","update","updateHash","index","nextRepl","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Source = require(\"./Source\");\nconst { SourceNode } = require(\"source-map\");\nconst { getSourceAndMap, getMap, getNode, getListMap } = require(\"./helpers\");\n\nclass Replacement {\n\tconstructor(start, end, content, insertIndex, name) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.content = content;\n\t\tthis.insertIndex = insertIndex;\n\t\tthis.name = name;\n\t}\n}\n\nclass ReplaceSource extends Source {\n\tconstructor(source, name) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._name = name;\n\t\t/** @type {Replacement[]} */\n\t\tthis._replacements = [];\n\t\tthis._isSorted = true;\n\t}\n\n\tgetName() {\n\t\treturn this._name;\n\t}\n\n\tgetReplacements() {\n\t\tconst replacements = Array.from(this._replacements);\n\t\treplacements.sort((a, b) => {\n\t\t\treturn a.insertIndex - b.insertIndex;\n\t\t});\n\t\treturn replacements;\n\t}\n\n\treplace(start, end, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" + typeof newValue\n\t\t\t);\n\t\tthis._replacements.push(\n\t\t\tnew Replacement(start, end, newValue, this._replacements.length, name)\n\t\t);\n\t\tthis._isSorted = false;\n\t}\n\n\tinsert(pos, newValue, name) {\n\t\tif (typeof newValue !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"insertion must be a string, but is a \" +\n\t\t\t\t\ttypeof newValue +\n\t\t\t\t\t\": \" +\n\t\t\t\t\tnewValue\n\t\t\t);\n\t\tthis._replacements.push(\n\t\t\tnew Replacement(pos, pos - 1, newValue, this._replacements.length, name)\n\t\t);\n\t\tthis._isSorted = false;\n\t}\n\n\tsource() {\n\t\treturn this._replaceString(this._source.source());\n\t}\n\n\tmap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.map(options);\n\t\t}\n\t\treturn getMap(this, options);\n\t}\n\n\tsourceAndMap(options) {\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn this._source.sourceAndMap(options);\n\t\t}\n\t\treturn getSourceAndMap(this, options);\n\t}\n\n\toriginal() {\n\t\treturn this._source;\n\t}\n\n\t_sortReplacements() {\n\t\tif (this._isSorted) return;\n\t\tthis._replacements.sort(function (a, b) {\n\t\t\tconst diff1 = b.end - a.end;\n\t\t\tif (diff1 !== 0) return diff1;\n\t\t\tconst diff2 = b.start - a.start;\n\t\t\tif (diff2 !== 0) return diff2;\n\t\t\treturn b.insertIndex - a.insertIndex;\n\t\t});\n\t\tthis._isSorted = true;\n\t}\n\n\t_replaceString(str) {\n\t\tif (typeof str !== \"string\")\n\t\t\tthrow new Error(\n\t\t\t\t\"str must be a string, but is a \" + typeof str + \": \" + str\n\t\t\t);\n\t\tthis._sortReplacements();\n\t\tconst result = [str];\n\t\tthis._replacements.forEach(function (repl) {\n\t\t\tconst remSource = result.pop();\n\t\t\tconst splitted1 = this._splitString(remSource, Math.floor(repl.end + 1));\n\t\t\tconst splitted2 = this._splitString(splitted1[0], Math.floor(repl.start));\n\t\t\tresult.push(splitted1[1], repl.content, splitted2[0]);\n\t\t}, this);\n\n\t\t// write out result array in reverse order\n\t\tlet resultStr = \"\";\n\t\tfor (let i = result.length - 1; i >= 0; --i) {\n\t\t\tresultStr += result[i];\n\t\t}\n\t\treturn resultStr;\n\t}\n\n\tnode(options) {\n\t\tconst node = getNode(this._source, options);\n\t\tif (this._replacements.length === 0) {\n\t\t\treturn node;\n\t\t}\n\t\tthis._sortReplacements();\n\t\tconst replace = new ReplacementEnumerator(this._replacements);\n\t\tconst output = [];\n\t\tlet position = 0;\n\t\tconst sources = Object.create(null);\n\t\tconst sourcesInLines = Object.create(null);\n\n\t\t// We build a new list of SourceNodes in \"output\"\n\t\t// from the original mapping data\n\n\t\tconst result = new SourceNode();\n\n\t\t// We need to add source contents manually\n\t\t// because \"walk\" will not handle it\n\t\tnode.walkSourceContents(function (sourceFile, sourceContent) {\n\t\t\tresult.setSourceContent(sourceFile, sourceContent);\n\t\t\tsources[\"$\" + sourceFile] = sourceContent;\n\t\t});\n\n\t\tconst replaceInStringNode = this._replaceInStringNode.bind(\n\t\t\tthis,\n\t\t\toutput,\n\t\t\treplace,\n\t\t\tfunction getOriginalSource(mapping) {\n\t\t\t\tconst key = \"$\" + mapping.source;\n\t\t\t\tlet lines = sourcesInLines[key];\n\t\t\t\tif (!lines) {\n\t\t\t\t\tconst source = sources[key];\n\t\t\t\t\tif (!source) return null;\n\t\t\t\t\tlines = source.split(\"\\n\").map(function (line) {\n\t\t\t\t\t\treturn line + \"\\n\";\n\t\t\t\t\t});\n\t\t\t\t\tsourcesInLines[key] = lines;\n\t\t\t\t}\n\t\t\t\t// line is 1-based\n\t\t\t\tif (mapping.line > lines.length) return null;\n\t\t\t\tconst line = lines[mapping.line - 1];\n\t\t\t\treturn line.substr(mapping.column);\n\t\t\t}\n\t\t);\n\n\t\tnode.walk(function (chunk, mapping) {\n\t\t\tposition = replaceInStringNode(chunk, position, mapping);\n\t\t});\n\n\t\t// If any replacements occur after the end of the original file, then we append them\n\t\t// directly to the end of the output\n\t\tconst remaining = replace.footer();\n\t\tif (remaining) {\n\t\t\toutput.push(remaining);\n\t\t}\n\n\t\tresult.add(output);\n\n\t\treturn result;\n\t}\n\n\tlistMap(options) {\n\t\tlet map = getListMap(this._source, options);\n\t\tthis._sortReplacements();\n\t\tlet currentIndex = 0;\n\t\tconst replacements = this._replacements;\n\t\tlet idxReplacement = replacements.length - 1;\n\t\tlet removeChars = 0;\n\t\tmap = map.mapGeneratedCode(function (str) {\n\t\t\tconst newCurrentIndex = currentIndex + str.length;\n\t\t\tif (removeChars > str.length) {\n\t\t\t\tremoveChars -= str.length;\n\t\t\t\tstr = \"\";\n\t\t\t} else {\n\t\t\t\tif (removeChars > 0) {\n\t\t\t\t\tstr = str.substr(removeChars);\n\t\t\t\t\tcurrentIndex += removeChars;\n\t\t\t\t\tremoveChars = 0;\n\t\t\t\t}\n\t\t\t\tlet finalStr = \"\";\n\t\t\t\twhile (\n\t\t\t\t\tidxReplacement >= 0 &&\n\t\t\t\t\treplacements[idxReplacement].start < newCurrentIndex\n\t\t\t\t) {\n\t\t\t\t\tconst repl = replacements[idxReplacement];\n\t\t\t\t\tconst start = Math.floor(repl.start);\n\t\t\t\t\tconst end = Math.floor(repl.end + 1);\n\t\t\t\t\tconst before = str.substr(0, Math.max(0, start - currentIndex));\n\t\t\t\t\tif (end <= newCurrentIndex) {\n\t\t\t\t\t\tconst after = str.substr(Math.max(0, end - currentIndex));\n\t\t\t\t\t\tfinalStr += before + repl.content;\n\t\t\t\t\t\tstr = after;\n\t\t\t\t\t\tcurrentIndex = Math.max(currentIndex, end);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinalStr += before + repl.content;\n\t\t\t\t\t\tstr = \"\";\n\t\t\t\t\t\tremoveChars = end - newCurrentIndex;\n\t\t\t\t\t}\n\t\t\t\t\tidxReplacement--;\n\t\t\t\t}\n\t\t\t\tstr = finalStr + str;\n\t\t\t}\n\t\t\tcurrentIndex = newCurrentIndex;\n\t\t\treturn str;\n\t\t});\n\t\tlet extraCode = \"\";\n\t\twhile (idxReplacement >= 0) {\n\t\t\textraCode += replacements[idxReplacement].content;\n\t\t\tidxReplacement--;\n\t\t}\n\t\tif (extraCode) {\n\t\t\tmap.add(extraCode);\n\t\t}\n\t\treturn map;\n\t}\n\n\t_splitString(str, position) {\n\t\treturn position <= 0\n\t\t\t? [\"\", str]\n\t\t\t: [str.substr(0, position), str.substr(position)];\n\t}\n\n\t_replaceInStringNode(\n\t\toutput,\n\t\treplace,\n\t\tgetOriginalSource,\n\t\tnode,\n\t\tposition,\n\t\tmapping\n\t) {\n\t\tlet original = undefined;\n\n\t\tdo {\n\t\t\tlet splitPosition = replace.position - position;\n\t\t\t// If multiple replaces occur in the same location then the splitPosition may be\n\t\t\t// before the current position for the subsequent splits. Ensure it is >= 0\n\t\t\tif (splitPosition < 0) {\n\t\t\t\tsplitPosition = 0;\n\t\t\t}\n\t\t\tif (splitPosition >= node.length || replace.done) {\n\t\t\t\tif (replace.emit) {\n\t\t\t\t\tconst nodeEnd = new SourceNode(\n\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\tmapping.column,\n\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tmapping.name\n\t\t\t\t\t);\n\t\t\t\t\toutput.push(nodeEnd);\n\t\t\t\t}\n\t\t\t\treturn position + node.length;\n\t\t\t}\n\n\t\t\tconst originalColumn = mapping.column;\n\n\t\t\t// Try to figure out if generated code matches original code of this segement\n\t\t\t// If this is the case we assume that it's allowed to move mapping.column\n\t\t\t// Because getOriginalSource can be expensive we only do it when neccessary\n\n\t\t\tlet nodePart;\n\t\t\tif (splitPosition > 0) {\n\t\t\t\tnodePart = node.slice(0, splitPosition);\n\t\t\t\tif (original === undefined) {\n\t\t\t\t\toriginal = getOriginalSource(mapping);\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\toriginal &&\n\t\t\t\t\toriginal.length >= splitPosition &&\n\t\t\t\t\toriginal.startsWith(nodePart)\n\t\t\t\t) {\n\t\t\t\t\tmapping.column += splitPosition;\n\t\t\t\t\toriginal = original.substr(splitPosition);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst emit = replace.next();\n\t\t\tif (!emit) {\n\t\t\t\t// Stop emitting when we have found the beginning of the string to replace.\n\t\t\t\t// Emit the part of the string before splitPosition\n\t\t\t\tif (splitPosition > 0) {\n\t\t\t\t\tconst nodeStart = new SourceNode(\n\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\toriginalColumn,\n\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\tnodePart,\n\t\t\t\t\t\tmapping.name\n\t\t\t\t\t);\n\t\t\t\t\toutput.push(nodeStart);\n\t\t\t\t}\n\n\t\t\t\t// Emit the replacement value\n\t\t\t\tif (replace.value) {\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tnew SourceNode(\n\t\t\t\t\t\t\tmapping.line,\n\t\t\t\t\t\t\tmapping.column,\n\t\t\t\t\t\t\tmapping.source,\n\t\t\t\t\t\t\treplace.value,\n\t\t\t\t\t\t\tmapping.name || replace.name\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Recurse with remainder of the string as there may be multiple replaces within a single node\n\t\t\tnode = node.substr(splitPosition);\n\t\t\tposition += splitPosition;\n\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t} while (true);\n\t}\n\n\tupdateHash(hash) {\n\t\tthis._sortReplacements();\n\t\thash.update(\"ReplaceSource\");\n\t\tthis._source.updateHash(hash);\n\t\thash.update(this._name || \"\");\n\t\tfor (const repl of this._replacements) {\n\t\t\thash.update(`${repl.start}`);\n\t\t\thash.update(`${repl.end}`);\n\t\t\thash.update(`${repl.content}`);\n\t\t\thash.update(`${repl.insertIndex}`);\n\t\t\thash.update(`${repl.name}`);\n\t\t}\n\t}\n}\n\nclass ReplacementEnumerator {\n\t/**\n\t * @param {Replacement[]} replacements list of replacements\n\t */\n\tconstructor(replacements) {\n\t\tthis.replacements = replacements || [];\n\t\tthis.index = this.replacements.length;\n\t\tthis.done = false;\n\t\tthis.emit = false;\n\t\t// Set initial start position\n\t\tthis.next();\n\t}\n\n\tnext() {\n\t\tif (this.done) return true;\n\t\tif (this.emit) {\n\t\t\t// Start point found. stop emitting. set position to find end\n\t\t\tconst repl = this.replacements[this.index];\n\t\t\tconst end = Math.floor(repl.end + 1);\n\t\t\tthis.position = end;\n\t\t\tthis.value = repl.content;\n\t\t\tthis.name = repl.name;\n\t\t} else {\n\t\t\t// End point found. start emitting. set position to find next start\n\t\t\tthis.index--;\n\t\t\tif (this.index < 0) {\n\t\t\t\tthis.done = true;\n\t\t\t} else {\n\t\t\t\tconst nextRepl = this.replacements[this.index];\n\t\t\t\tconst start = Math.floor(nextRepl.start);\n\t\t\t\tthis.position = start;\n\t\t\t}\n\t\t}\n\t\tif (this.position < 0) this.position = 0;\n\t\tthis.emit = !this.emit;\n\t\treturn this.emit;\n\t}\n\n\tfooter() {\n\t\tif (!this.done && !this.emit) this.next(); // If we finished _replaceInNode mid emit we advance to next entry\n\t\tif (this.done) {\n\t\t\treturn [];\n\t\t} else {\n\t\t\tlet resultStr = \"\";\n\t\t\tfor (let i = this.index; i >= 0; i--) {\n\t\t\t\tconst repl = this.replacements[i];\n\t\t\t\t// this doesn't need to handle repl.name, because in SourceMaps generated code\n\t\t\t\t// without pointer to original source can't have a name\n\t\t\t\tresultStr += repl.content;\n\t\t\t}\n\t\t\treturn resultStr;\n\t\t}\n\t}\n}\n\nmodule.exports = ReplaceSource;\n"]},"metadata":{},"sourceType":"script"}