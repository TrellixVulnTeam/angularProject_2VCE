{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/reflection/src/host\", [\"require\", \"exports\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isConcreteDeclaration = exports.KnownDeclaration = exports.ClassMemberKind = exports.isDecoratorIdentifier = exports.Decorator = void 0;\n\n  var ts = require(\"typescript\");\n\n  exports.Decorator = {\n    nodeForError: function nodeForError(decorator) {\n      if (decorator.node !== null) {\n        return decorator.node;\n      } else {\n        // TODO(alxhub): we can't rely on narrowing until TS 3.6 is in g3.\n        return decorator.synthesizedFor;\n      }\n    }\n  };\n\n  function isDecoratorIdentifier(exp) {\n    return ts.isIdentifier(exp) || ts.isPropertyAccessExpression(exp) && ts.isIdentifier(exp.expression) && ts.isIdentifier(exp.name);\n  }\n\n  exports.isDecoratorIdentifier = isDecoratorIdentifier;\n  /**\n   * An enumeration of possible kinds of class members.\n   */\n\n  var ClassMemberKind;\n\n  (function (ClassMemberKind) {\n    ClassMemberKind[ClassMemberKind[\"Constructor\"] = 0] = \"Constructor\";\n    ClassMemberKind[ClassMemberKind[\"Getter\"] = 1] = \"Getter\";\n    ClassMemberKind[ClassMemberKind[\"Setter\"] = 2] = \"Setter\";\n    ClassMemberKind[ClassMemberKind[\"Property\"] = 3] = \"Property\";\n    ClassMemberKind[ClassMemberKind[\"Method\"] = 4] = \"Method\";\n  })(ClassMemberKind = exports.ClassMemberKind || (exports.ClassMemberKind = {}));\n  /**\n   * Possible declarations of known values, such as built-in objects/functions or TypeScript helpers.\n   */\n\n\n  var KnownDeclaration;\n\n  (function (KnownDeclaration) {\n    /**\n     * Indicates the JavaScript global `Object` class.\n     */\n    KnownDeclaration[KnownDeclaration[\"JsGlobalObject\"] = 0] = \"JsGlobalObject\";\n    /**\n     * Indicates the `__assign` TypeScript helper function.\n     */\n\n    KnownDeclaration[KnownDeclaration[\"TsHelperAssign\"] = 1] = \"TsHelperAssign\";\n    /**\n     * Indicates the `__spread` TypeScript helper function.\n     */\n\n    KnownDeclaration[KnownDeclaration[\"TsHelperSpread\"] = 2] = \"TsHelperSpread\";\n    /**\n     * Indicates the `__spreadArrays` TypeScript helper function.\n     */\n\n    KnownDeclaration[KnownDeclaration[\"TsHelperSpreadArrays\"] = 3] = \"TsHelperSpreadArrays\";\n  })(KnownDeclaration = exports.KnownDeclaration || (exports.KnownDeclaration = {}));\n  /**\n   * Returns true if the `decl` is a `ConcreteDeclaration` (ie. that its `node` property is a\n   * `ts.Declaration`).\n   */\n\n\n  function isConcreteDeclaration(decl) {\n    return decl.kind === 0\n    /* Concrete */\n    ;\n  }\n\n  exports.isConcreteDeclaration = isConcreteDeclaration;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/reflection/src/host.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAkEa,EAAA,OAAA,CAAA,SAAA,GAAY;AACvB,IAAA,YAAY,EAAE,sBAAC,SAAD,EAAqB;AACjC,UAAI,SAAS,CAAC,IAAV,KAAmB,IAAvB,EAA6B;AAC3B,eAAO,SAAS,CAAC,IAAjB;AACD,OAFD,MAEO;AACL;AACA,eAAQ,SAAgC,CAAC,cAAzC;AACD;AACF;AARsB,GAAZ;;AAoBb,WAAgB,qBAAhB,CAAsC,GAAtC,EAAwD;AACtD,WAAO,EAAE,CAAC,YAAH,CAAgB,GAAhB,KACH,EAAE,CAAC,0BAAH,CAA8B,GAA9B,KAAsC,EAAE,CAAC,YAAH,CAAgB,GAAG,CAAC,UAApB,CAAtC,IACA,EAAE,CAAC,YAAH,CAAgB,GAAG,CAAC,IAApB,CAFJ;AAGD;;AAJD,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAuBA;;AAEG;;AACH,MAAY,eAAZ;;AAAA,GAAA,UAAY,eAAZ,EAA2B;AACzB,IAAA,eAAA,CAAA,eAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AACA,IAAA,eAAA,CAAA,eAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,IAAA,eAAA,CAAA,eAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,IAAA,eAAA,CAAA,eAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,IAAA,eAAA,CAAA,eAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACD,GAND,EAAY,eAAe,GAAf,OAAA,CAAA,eAAA,KAAA,OAAA,CAAA,eAAA,GAAe,EAAf,CAAZ;AA6UA;;AAEG;;;AACH,MAAY,gBAAZ;;AAAA,GAAA,UAAY,gBAAZ,EAA4B;AAC1B;;AAEG;AACH,IAAA,gBAAA,CAAA,gBAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,gBAAA;AAEA;;AAEG;;AACH,IAAA,gBAAA,CAAA,gBAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,gBAAA;AAEA;;AAEG;;AACH,IAAA,gBAAA,CAAA,gBAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,gBAAA;AAEA;;AAEG;;AACH,IAAA,gBAAA,CAAA,gBAAA,CAAA,sBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,sBAAA;AACD,GApBD,EAAY,gBAAgB,GAAhB,OAAA,CAAA,gBAAA,KAAA,OAAA,CAAA,gBAAA,GAAgB,EAAhB,CAAZ;AA8HA;;;AAGG;;;AACH,WAAgB,qBAAhB,CAAsC,IAAtC,EAAuD;AACrD,WAAO,IAAI,CAAC,IAAL,KAAS;AAAA;AAAhB;AACD;;AAFD,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\n/**\n * Metadata extracted from an instance of a decorator on another declaration, or synthesized from\n * other information about a class.\n */\nexport type Decorator = ConcreteDecorator|SyntheticDecorator;\n\nexport interface BaseDecorator {\n  /**\n   * Name by which the decorator was invoked in the user's code.\n   *\n   * This is distinct from the name by which the decorator was imported (though in practice they\n   * will usually be the same).\n   */\n  name: string;\n\n  /**\n   * Identifier which refers to the decorator in the user's code.\n   */\n  identifier: DecoratorIdentifier|null;\n\n/**\n * `Import` by which the decorator was brought into the module in which it was invoked, or `null`\n * if the decorator was declared in the same module and not imported.\n */\nimport: Import|null;\n\n  /**\n   * TypeScript reference to the decorator itself, or `null` if the decorator is synthesized (e.g.\n   * in ngcc).\n   */\n  node: ts.Node|null;\n\n  /**\n   * Arguments of the invocation of the decorator, if the decorator is invoked, or `null`\n   * otherwise.\n   */\n  args: ts.Expression[]|null;\n}\n\n/**\n * Metadata extracted from an instance of a decorator on another declaration, which was actually\n * present in a file.\n *\n * Concrete decorators always have an `identifier` and a `node`.\n */\nexport interface ConcreteDecorator extends BaseDecorator {\n  identifier: DecoratorIdentifier;\n  node: ts.Node;\n}\n\n/**\n * Synthetic decorators never have an `identifier` or a `node`, but know the node for which they\n * were synthesized.\n */\nexport interface SyntheticDecorator extends BaseDecorator {\n  identifier: null;\n  node: null;\n\n  /**\n   * The `ts.Node` for which this decorator was created.\n   */\n  synthesizedFor: ts.Node;\n}\n\nexport const Decorator = {\n  nodeForError: (decorator: Decorator): ts.Node => {\n    if (decorator.node !== null) {\n      return decorator.node;\n    } else {\n      // TODO(alxhub): we can't rely on narrowing until TS 3.6 is in g3.\n      return (decorator as SyntheticDecorator).synthesizedFor;\n    }\n  },\n};\n\n/**\n * A decorator is identified by either a simple identifier (e.g. `Decorator`) or, in some cases,\n * a namespaced property access (e.g. `core.Decorator`).\n */\nexport type DecoratorIdentifier = ts.Identifier|NamespacedIdentifier;\nexport type NamespacedIdentifier = ts.PropertyAccessExpression&{\n  expression: ts.Identifier;\n  name: ts.Identifier\n};\nexport function isDecoratorIdentifier(exp: ts.Expression): exp is DecoratorIdentifier {\n  return ts.isIdentifier(exp) ||\n      ts.isPropertyAccessExpression(exp) && ts.isIdentifier(exp.expression) &&\n      ts.isIdentifier(exp.name);\n}\n\n/**\n * The `ts.Declaration` of a \"class\".\n *\n * Classes are represented differently in different code formats:\n * - In TS code, they are typically defined using the `class` keyword.\n * - In ES2015 code, they are usually defined using the `class` keyword, but they can also be\n *   variable declarations, which are initialized to a class expression (e.g.\n *   `let Foo = Foo1 = class Foo {}`).\n * - In ES5 code, they are typically defined as variable declarations being assigned the return\n *   value of an IIFE. The actual \"class\" is implemented as a constructor function inside the IIFE,\n *   but the outer variable declaration represents the \"class\" to the rest of the program.\n *\n * For `ReflectionHost` purposes, a class declaration should always have a `name` identifier,\n * because we need to be able to reference it in other parts of the program.\n */\nexport type ClassDeclaration<T extends DeclarationNode = DeclarationNode> = T&{name: ts.Identifier};\n\n/**\n * An enumeration of possible kinds of class members.\n */\nexport enum ClassMemberKind {\n  Constructor,\n  Getter,\n  Setter,\n  Property,\n  Method,\n}\n\n/**\n * A member of a class, such as a property, method, or constructor.\n */\nexport interface ClassMember {\n  /**\n   * TypeScript reference to the class member itself, or null if it is not applicable.\n   */\n  node: ts.Node|null;\n\n  /**\n   * Indication of which type of member this is (property, method, etc).\n   */\n  kind: ClassMemberKind;\n\n  /**\n   * TypeScript `ts.TypeNode` representing the type of the member, or `null` if not present or\n   * applicable.\n   */\n  type: ts.TypeNode|null;\n\n  /**\n   * Name of the class member.\n   */\n  name: string;\n\n  /**\n   * TypeScript `ts.Identifier` or `ts.StringLiteral` representing the name of the member, or `null`\n   * if no such node is present.\n   *\n   * The `nameNode` is useful in writing references to this member that will be correctly source-\n   * mapped back to the original file.\n   */\n  nameNode: ts.Identifier|ts.StringLiteral|null;\n\n  /**\n   * TypeScript `ts.Expression` which represents the value of the member.\n   *\n   * If the member is a property, this will be the property initializer if there is one, or null\n   * otherwise.\n   */\n  value: ts.Expression|null;\n\n  /**\n   * TypeScript `ts.Declaration` which represents the implementation of the member.\n   *\n   * In TypeScript code this is identical to the node, but in downleveled code this should always be\n   * the Declaration which actually represents the member's runtime value.\n   *\n   * For example, the TS code:\n   *\n   * ```\n   * class Clazz {\n   *   static get property(): string {\n   *     return 'value';\n   *   }\n   * }\n   * ```\n   *\n   * Downlevels to:\n   *\n   * ```\n   * var Clazz = (function () {\n   *   function Clazz() {\n   *   }\n   *   Object.defineProperty(Clazz, \"property\", {\n   *       get: function () {\n   *           return 'value';\n   *       },\n   *       enumerable: true,\n   *       configurable: true\n   *   });\n   *   return Clazz;\n   * }());\n   * ```\n   *\n   * In this example, for the property \"property\", the node would be the entire\n   * Object.defineProperty ExpressionStatement, but the implementation would be this\n   * FunctionDeclaration:\n   *\n   * ```\n   * function () {\n   *   return 'value';\n   * },\n   * ```\n   */\n  implementation: ts.Declaration|null;\n\n  /**\n   * Whether the member is static or not.\n   */\n  isStatic: boolean;\n\n  /**\n   * Any `Decorator`s which are present on the member, or `null` if none are present.\n   */\n  decorators: Decorator[]|null;\n}\n\nexport const enum TypeValueReferenceKind {\n  LOCAL,\n  IMPORTED,\n  UNAVAILABLE,\n}\n\n/**\n * A type reference that refers to any type via a `ts.Expression` that's valid within the local file\n * where the type was referenced.\n */\nexport interface LocalTypeValueReference {\n  kind: TypeValueReferenceKind.LOCAL;\n\n  /**\n   * The synthesized expression to reference the type in a value position.\n   */\n  expression: ts.Expression;\n\n  /**\n   * If the type originates from a default import, the import statement is captured here to be able\n   * to track its usages, preventing the import from being elided if it was originally only used in\n   * a type-position. See `DefaultImportTracker` for details.\n   */\n  defaultImportStatement: ts.ImportDeclaration|null;\n}\n\n/**\n * A reference that refers to a type that was imported, and gives the symbol `name` and the\n * `moduleName` of the import. Note that this `moduleName` may be a relative path, and thus is\n * likely only valid within the context of the file which contained the original type reference.\n */\nexport interface ImportedTypeValueReference {\n  kind: TypeValueReferenceKind.IMPORTED;\n\n  /**\n   * The module specifier from which the `importedName` symbol should be imported.\n   */\n  moduleName: string;\n\n  /**\n   * The name of the top-level symbol that is imported from `moduleName`. If `nestedPath` is also\n   * present, a nested object is being referenced from the top-level symbol.\n   */\n  importedName: string;\n\n  /**\n   * If present, represents the symbol names that are referenced from the top-level import.\n   * When `null` or empty, the `importedName` itself is the symbol being referenced.\n   */\n  nestedPath: string[]|null;\n\n  valueDeclaration: DeclarationNode;\n}\n\n/**\n * A representation for a type value reference that is used when no value is available. This can\n * occur due to various reasons, which is indicated in the `reason` field.\n */\nexport interface UnavailableTypeValueReference {\n  kind: TypeValueReferenceKind.UNAVAILABLE;\n\n  /**\n   * The reason why no value reference could be determined for a type.\n   */\n  reason: UnavailableValue;\n}\n\n/**\n * The various reasons why the compiler may be unable to synthesize a value from a type reference.\n */\nexport const enum ValueUnavailableKind {\n  /**\n   * No type node was available.\n   */\n  MISSING_TYPE,\n\n  /**\n   * The type does not have a value declaration, e.g. an interface.\n   */\n  NO_VALUE_DECLARATION,\n\n  /**\n   * The type is imported using a type-only imports, so it is not suitable to be used in a\n   * value-position.\n   */\n  TYPE_ONLY_IMPORT,\n\n  /**\n   * The type reference could not be resolved to a declaration.\n   */\n  UNKNOWN_REFERENCE,\n\n  /**\n   * The type corresponds with a namespace.\n   */\n  NAMESPACE,\n\n  /**\n   * The type is not supported in the compiler, for example union types.\n   */\n  UNSUPPORTED,\n}\n\n\nexport interface UnsupportedType {\n  kind: ValueUnavailableKind.UNSUPPORTED;\n  typeNode: ts.TypeNode;\n}\n\nexport interface NoValueDeclaration {\n  kind: ValueUnavailableKind.NO_VALUE_DECLARATION;\n  typeNode: ts.TypeNode;\n  decl: ts.Declaration|null;\n}\n\nexport interface TypeOnlyImport {\n  kind: ValueUnavailableKind.TYPE_ONLY_IMPORT;\n  typeNode: ts.TypeNode;\n  importClause: ts.ImportClause;\n}\n\nexport interface NamespaceImport {\n  kind: ValueUnavailableKind.NAMESPACE;\n  typeNode: ts.TypeNode;\n  importClause: ts.ImportClause;\n}\n\nexport interface UnknownReference {\n  kind: ValueUnavailableKind.UNKNOWN_REFERENCE;\n  typeNode: ts.TypeNode;\n}\n\nexport interface MissingType {\n  kind: ValueUnavailableKind.MISSING_TYPE;\n}\n\n/**\n * The various reasons why a type node may not be referred to as a value.\n */\nexport type UnavailableValue =\n    UnsupportedType|NoValueDeclaration|TypeOnlyImport|NamespaceImport|UnknownReference|MissingType;\n\n/**\n * A reference to a value that originated from a type position.\n *\n * For example, a constructor parameter could be declared as `foo: Foo`. A `TypeValueReference`\n * extracted from this would refer to the value of the class `Foo` (assuming it was actually a\n * type).\n *\n * See the individual types for additional information.\n */\nexport type TypeValueReference =\n    LocalTypeValueReference|ImportedTypeValueReference|UnavailableTypeValueReference;\n\n/**\n * A parameter to a constructor.\n */\nexport interface CtorParameter {\n  /**\n   * Name of the parameter, if available.\n   *\n   * Some parameters don't have a simple string name (for example, parameters which are destructured\n   * into multiple variables). In these cases, `name` can be `null`.\n   */\n  name: string|null;\n\n  /**\n   * TypeScript `ts.BindingName` representing the name of the parameter.\n   *\n   * The `nameNode` is useful in writing references to this member that will be correctly source-\n   * mapped back to the original file.\n   */\n  nameNode: ts.BindingName;\n\n  /**\n   * Reference to the value of the parameter's type annotation, if it's possible to refer to the\n   * parameter's type as a value.\n   *\n   * This can either be a reference to a local value, a reference to an imported value, or no\n   * value if no is present or cannot be represented as an expression.\n   */\n  typeValueReference: TypeValueReference;\n\n  /**\n   * TypeScript `ts.TypeNode` representing the type node found in the type position.\n   *\n   * This field can be used for diagnostics reporting if `typeValueReference` is `null`.\n   *\n   * Can be null, if the param has no type declared.\n   */\n  typeNode: ts.TypeNode|null;\n\n  /**\n   * Any `Decorator`s which are present on the parameter, or `null` if none are present.\n   */\n  decorators: Decorator[]|null;\n}\n\n/**\n * Definition of a function or method, including its body if present and any parameters.\n *\n * In TypeScript code this metadata will be a simple reflection of the declarations in the node\n * itself. In ES5 code this can be more complicated, as the default values for parameters may\n * be extracted from certain body statements.\n */\nexport interface FunctionDefinition {\n  /**\n   * A reference to the node which declares the function.\n   */\n  node: ts.MethodDeclaration|ts.FunctionDeclaration|ts.FunctionExpression|ts.VariableDeclaration;\n\n  /**\n   * Statements of the function body, if a body is present, or null if no body is present or the\n   * function is identified to represent a tslib helper function, in which case `helper` will\n   * indicate which helper this function represents.\n   *\n   * This list may have been filtered to exclude statements which perform parameter default value\n   * initialization.\n   */\n  body: ts.Statement[]|null;\n\n  /**\n   * Metadata regarding the function's parameters, including possible default value expressions.\n   */\n  parameters: Parameter[];\n}\n\n/**\n * Possible declarations of known values, such as built-in objects/functions or TypeScript helpers.\n */\nexport enum KnownDeclaration {\n  /**\n   * Indicates the JavaScript global `Object` class.\n   */\n  JsGlobalObject,\n\n  /**\n   * Indicates the `__assign` TypeScript helper function.\n   */\n  TsHelperAssign,\n\n  /**\n   * Indicates the `__spread` TypeScript helper function.\n   */\n  TsHelperSpread,\n\n  /**\n   * Indicates the `__spreadArrays` TypeScript helper function.\n   */\n  TsHelperSpreadArrays,\n}\n\n/**\n * A parameter to a function or method.\n */\nexport interface Parameter {\n  /**\n   * Name of the parameter, if available.\n   */\n  name: string|null;\n\n  /**\n   * Declaration which created this parameter.\n   */\n  node: ts.ParameterDeclaration;\n\n  /**\n   * Expression which represents the default value of the parameter, if any.\n   */\n  initializer: ts.Expression|null;\n}\n\n/**\n * The source of an imported symbol, including the original symbol name and the module from which it\n * was imported.\n */\nexport interface Import {\n  /**\n   * The name of the imported symbol under which it was exported (not imported).\n   */\n  name: string;\n\n  /**\n   * The module from which the symbol was imported.\n   *\n   * This could either be an absolute module name (@angular/core for example) or a relative path.\n   */\n  from: string;\n}\n\n/**\n * A single enum member extracted from JavaScript when no `ts.EnumDeclaration` is available.\n */\nexport interface EnumMember {\n  /**\n   * The name of the enum member.\n   */\n  name: ts.PropertyName;\n\n  /**\n   * The initializer expression of the enum member. Unlike in TypeScript, this is always available\n   * in emitted JavaScript.\n   */\n  initializer: ts.Expression;\n}\n\n/**\n * A type that is used to identify a declaration.\n *\n * Declarations are normally `ts.Declaration` types such as variable declarations, class\n * declarations, function declarations etc.\n * But in some cases there is no `ts.Declaration` that can be used for a declaration, such\n * as when they are declared inline as part of an exported expression. Then we must use a\n * `ts.Expression` as the declaration.\n * An example of this is `exports.someVar = 42` where the declaration expression would be\n * `exports.someVar`.\n */\nexport type DeclarationNode = ts.Declaration|ts.Expression;\n\n/**\n * The type of a Declaration - whether its node is concrete (ts.Declaration) or inline\n * (ts.Expression). See `ConcreteDeclaration`, `InlineDeclaration` and `DeclarationNode` for more\n * information about this.\n */\nexport const enum DeclarationKind {\n  Concrete,\n  Inline,\n}\n\n/**\n * Base type for all `Declaration`s.\n */\nexport interface BaseDeclaration<T extends DeclarationNode> {\n  /**\n   * The type of the underlying `node`.\n   */\n  kind: DeclarationKind;\n\n  /**\n   * The absolute module path from which the symbol was imported into the application, if the symbol\n   * was imported via an absolute module (even through a chain of re-exports). If the symbol is part\n   * of the application and was not imported from an absolute path, this will be `null`.\n   */\n  viaModule: string|null;\n\n  /**\n   * TypeScript reference to the declaration itself, if one exists.\n   */\n  node: T;\n\n  /**\n   * If set, describes the type of the known declaration this declaration resolves to.\n   */\n  known: KnownDeclaration|null;\n}\n\n/**\n * Returns true if the `decl` is a `ConcreteDeclaration` (ie. that its `node` property is a\n * `ts.Declaration`).\n */\nexport function isConcreteDeclaration(decl: Declaration): decl is ConcreteDeclaration {\n  return decl.kind === DeclarationKind.Concrete;\n}\n\nexport interface ConcreteDeclaration<T extends ts.Declaration = ts.Declaration> extends\n    BaseDeclaration<T> {\n  kind: DeclarationKind.Concrete;\n\n  /**\n   * Optionally represents a special identity of the declaration, or `null` if the declaration\n   * does not have a special identity.\n   */\n  identity: SpecialDeclarationIdentity|null;\n}\n\nexport type SpecialDeclarationIdentity = DownleveledEnum;\n\nexport const enum SpecialDeclarationKind {\n  DownleveledEnum,\n}\n\n/**\n * A special declaration identity that represents an enum. This is used in downleveled forms where\n * a `ts.EnumDeclaration` is emitted in an alternative form, e.g. an IIFE call that declares all\n * members.\n */\nexport interface DownleveledEnum {\n  kind: SpecialDeclarationKind.DownleveledEnum;\n  enumMembers: EnumMember[];\n}\n\n/**\n * A declaration that does not have an associated TypeScript `ts.Declaration`.\n *\n * This can occur in some downlevelings when an `export const VAR = ...;` (a `ts.Declaration`) is\n * transpiled to an assignment statement (e.g. `exports.VAR = ...;`). There is no `ts.Declaration`\n * associated with `VAR` in that case, only an expression.\n */\nexport interface InlineDeclaration extends\n    BaseDeclaration<Exclude<DeclarationNode, ts.Declaration>> {\n  kind: DeclarationKind.Inline;\n  implementation?: DeclarationNode;\n}\n\n/**\n * The declaration of a symbol, along with information about how it was imported into the\n * application.\n */\nexport type Declaration<T extends ts.Declaration = ts.Declaration> =\n    ConcreteDeclaration<T>|InlineDeclaration;\n\n/**\n * Abstracts reflection operations on a TypeScript AST.\n *\n * Depending on the format of the code being interpreted, different concepts are represented\n * with different syntactical structures. The `ReflectionHost` abstracts over those differences and\n * presents a single API by which the compiler can query specific information about the AST.\n *\n * All operations on the `ReflectionHost` require the use of TypeScript `ts.Node`s with binding\n * information already available (that is, nodes that come from a `ts.Program` that has been\n * type-checked, and are not synthetically created).\n */\nexport interface ReflectionHost {\n  /**\n   * Examine a declaration (for example, of a class or function) and return metadata about any\n   * decorators present on the declaration.\n   *\n   * @param declaration a TypeScript `ts.Declaration` node representing the class or function over\n   * which to reflect. For example, if the intent is to reflect the decorators of a class and the\n   * source is in ES6 format, this will be a `ts.ClassDeclaration` node. If the source is in ES5\n   * format, this might be a `ts.VariableDeclaration` as classes in ES5 are represented as the\n   * result of an IIFE execution.\n   *\n   * @returns an array of `Decorator` metadata if decorators are present on the declaration, or\n   * `null` if either no decorators were present or if the declaration is not of a decoratable type.\n   */\n  getDecoratorsOfDeclaration(declaration: DeclarationNode): Decorator[]|null;\n\n  /**\n   * Examine a declaration which should be of a class, and return metadata about the members of the\n   * class.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns an array of `ClassMember` metadata representing the members of the class.\n   *\n   * @throws if `declaration` does not resolve to a class declaration.\n   */\n  getMembersOfClass(clazz: ClassDeclaration): ClassMember[];\n\n  /**\n   * Reflect over the constructor of a class and return metadata about its parameters.\n   *\n   * This method only looks at the constructor of a class directly and not at any inherited\n   * constructors.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns an array of `Parameter` metadata representing the parameters of the constructor, if\n   * a constructor exists. If the constructor exists and has 0 parameters, this array will be empty.\n   * If the class has no constructor, this method returns `null`.\n   */\n  getConstructorParameters(clazz: ClassDeclaration): CtorParameter[]|null;\n\n  /**\n   * Reflect over a function and return metadata about its parameters and body.\n   *\n   * Functions in TypeScript and ES5 code have different AST representations, in particular around\n   * default values for parameters. A TypeScript function has its default value as the initializer\n   * on the parameter declaration, whereas an ES5 function has its default value set in a statement\n   * of the form:\n   *\n   * if (param === void 0) { param = 3; }\n   *\n   * This method abstracts over these details, and interprets the function declaration and body to\n   * extract parameter default values and the \"real\" body.\n   *\n   * A current limitation is that this metadata has no representation for shorthand assignment of\n   * parameter objects in the function signature.\n   *\n   * @param fn a TypeScript `ts.Declaration` node representing the function over which to reflect.\n   *\n   * @returns a `FunctionDefinition` giving metadata about the function definition.\n   */\n  getDefinitionOfFunction(fn: ts.Node): FunctionDefinition|null;\n\n  /**\n   * Determine if an identifier was imported from another module and return `Import` metadata\n   * describing its origin.\n   *\n   * @param id a TypeScript `ts.Identifer` to reflect.\n   *\n   * @returns metadata about the `Import` if the identifier was imported from another module, or\n   * `null` if the identifier doesn't resolve to an import but instead is locally defined.\n   */\n  getImportOfIdentifier(id: ts.Identifier): Import|null;\n\n  /**\n   * Trace an identifier to its declaration, if possible.\n   *\n   * This method attempts to resolve the declaration of the given identifier, tracing back through\n   * imports and re-exports until the original declaration statement is found. A `Declaration`\n   * object is returned if the original declaration is found, or `null` is returned otherwise.\n   *\n   * If the declaration is in a different module, and that module is imported via an absolute path,\n   * this method also returns the absolute path of the imported module. For example, if the code is:\n   *\n   * ```\n   * import {RouterModule} from '@angular/core';\n   *\n   * export const ROUTES = RouterModule.forRoot([...]);\n   * ```\n   *\n   * and if `getDeclarationOfIdentifier` is called on `RouterModule` in the `ROUTES` expression,\n   * then it would trace `RouterModule` via its import from `@angular/core`, and note that the\n   * definition was imported from `@angular/core` into the application where it was referenced.\n   *\n   * If the definition is re-exported several times from different absolute module names, only\n   * the first one (the one by which the application refers to the module) is returned.\n   *\n   * This module name is returned in the `viaModule` field of the `Declaration`. If The declaration\n   * is relative to the application itself and there was no import through an absolute path, then\n   * `viaModule` is `null`.\n   *\n   * @param id a TypeScript `ts.Identifier` to trace back to a declaration.\n   *\n   * @returns metadata about the `Declaration` if the original declaration is found, or `null`\n   * otherwise.\n   */\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null;\n\n  /**\n   * Collect the declarations exported from a module by name.\n   *\n   * Iterates over the exports of a module (including re-exports) and returns a map of export\n   * name to its `Declaration`. If an exported value is itself re-exported from another module,\n   * the `Declaration`'s `viaModule` will reflect that.\n   *\n   * @param node a TypeScript `ts.Node` representing the module (for example a `ts.SourceFile`) for\n   * which to collect exports.\n   *\n   * @returns a map of `Declaration`s for the module's exports, by name.\n   */\n  getExportsOfModule(module: ts.Node): Map<string, Declaration>|null;\n\n  /**\n   * Check whether the given node actually represents a class.\n   */\n  isClass(node: ts.Node): node is ClassDeclaration;\n\n  /**\n   * Determines whether the given declaration, which should be a class, has a base class.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   */\n  hasBaseClass(clazz: ClassDeclaration): boolean;\n\n  /**\n   * Get an expression representing the base class (if any) of the given `clazz`.\n   *\n   * This expression is most commonly an Identifier, but is possible to inherit from a more dynamic\n   * expression.\n   *\n   * @param clazz the class whose base we want to get.\n   */\n  getBaseClassExpression(clazz: ClassDeclaration): ts.Expression|null;\n\n  /**\n   * Get the number of generic type parameters of a given class.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns the number of type parameters of the class, if known, or `null` if the declaration\n   * is not a class or has an unknown number of type parameters.\n   */\n  getGenericArityOfClass(clazz: ClassDeclaration): number|null;\n\n  /**\n   * Find the assigned value of a variable declaration.\n   *\n   * Normally this will be the initializer of the declaration, but where the variable is\n   * not a `const` we may need to look elsewhere for the variable's value.\n   *\n   * @param declaration a TypeScript variable declaration, whose value we want.\n   * @returns the value of the variable, as a TypeScript expression node, or `undefined`\n   * if the value cannot be computed.\n   */\n  getVariableValue(declaration: ts.VariableDeclaration): ts.Expression|null;\n\n  /**\n   * Take an exported declaration (maybe a class down-leveled to a variable) and look up the\n   * declaration of its type in a separate .d.ts tree.\n   *\n   * This function is allowed to return `null` if the current compilation unit does not have a\n   * separate .d.ts tree. When compiling TypeScript code this is always the case, since .d.ts files\n   * are produced only during the emit of such a compilation. When compiling .js code, however,\n   * there is frequently a parallel .d.ts tree which this method exposes.\n   *\n   * Note that the `ts.Declaration` returned from this function may not be from the same\n   * `ts.Program` as the input declaration.\n   */\n  getDtsDeclaration(declaration: DeclarationNode): ts.Declaration|null;\n\n  /**\n   * Get a `ts.Identifier` for a given `ClassDeclaration` which can be used to refer to the class\n   * within its definition (such as in static fields).\n   *\n   * This can differ from `clazz.name` when ngcc runs over ES5 code, since the class may have a\n   * different name within its IIFE wrapper than it does externally.\n   */\n  getInternalNameOfClass(clazz: ClassDeclaration): ts.Identifier;\n\n  /**\n   * Get a `ts.Identifier` for a given `ClassDeclaration` which can be used to refer to the class\n   * from statements that are \"adjacent\", and conceptually tightly bound, to the class but not\n   * actually inside it.\n   *\n   * Similar to `getInternalNameOfClass()`, this name can differ from `clazz.name` when ngcc runs\n   * over ES5 code, since these \"adjacent\" statements need to exist in the IIFE where the class may\n   * have a different name than it does externally.\n   */\n  getAdjacentNameOfClass(clazz: ClassDeclaration): ts.Identifier;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}