{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Jobs = require('qjobs');\n\nvar log = require('./logger').create('launcher');\n\nvar baseDecorator = require('./launchers/base').decoratorFactory;\n\nvar captureTimeoutDecorator = require('./launchers/capture_timeout').decoratorFactory;\n\nvar retryDecorator = require('./launchers/retry').decoratorFactory;\n\nvar processDecorator = require('./launchers/process').decoratorFactory; // TODO(vojta): remove once nobody uses it\n\n\nvar baseBrowserDecoratorFactory = function baseBrowserDecoratorFactory(baseLauncherDecorator, captureTimeoutLauncherDecorator, retryLauncherDecorator, processLauncherDecorator, processKillTimeout) {\n  return function (launcher) {\n    baseLauncherDecorator(launcher);\n    captureTimeoutLauncherDecorator(launcher);\n    retryLauncherDecorator(launcher);\n    processLauncherDecorator(launcher, processKillTimeout);\n  };\n};\n\nvar Launcher = /*#__PURE__*/function () {\n  function Launcher(server, emitter, injector) {\n    var _this = this;\n\n    _classCallCheck(this, Launcher);\n\n    this._server = server;\n    this._emitter = emitter;\n    this._injector = injector;\n    this._browsers = [];\n    this._lastStartTime = null; // Attach list of dependency injection parameters to methods.\n\n    this.launch.$inject = ['config.browsers', 'config.concurrency'];\n    this.launchSingle.$inject = ['config.protocol', 'config.hostname', 'config.port', 'config.urlRoot', 'config.upstreamProxy', 'config.processKillTimeout'];\n\n    this._emitter.on('exit', function (callback) {\n      return _this.killAll(callback);\n    });\n  }\n\n  _createClass(Launcher, [{\n    key: \"getBrowserById\",\n    value: function getBrowserById(id) {\n      return this._browsers.find(function (browser) {\n        return browser.id === id;\n      });\n    }\n  }, {\n    key: \"launchSingle\",\n    value: function launchSingle(protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {\n      var _this2 = this;\n\n      if (upstreamProxy) {\n        protocol = upstreamProxy.protocol;\n        hostname = upstreamProxy.hostname;\n        port = upstreamProxy.port;\n        urlRoot = upstreamProxy.path + urlRoot.substr(1);\n      }\n\n      return function (name) {\n        var browser;\n        var locals = {\n          id: ['value', Launcher.generateId()],\n          name: ['value', name],\n          processKillTimeout: ['value', processKillTimeout],\n          baseLauncherDecorator: ['factory', baseDecorator],\n          captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],\n          retryLauncherDecorator: ['factory', retryDecorator],\n          processLauncherDecorator: ['factory', processDecorator],\n          baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]\n        }; // TODO(vojta): determine script from name\n\n        if (name.includes('/')) {\n          name = 'Script';\n        }\n\n        try {\n          browser = _this2._injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name);\n        } catch (e) {\n          if (e.message.includes(\"No provider for \\\"launcher:\".concat(name, \"\\\"\"))) {\n            log.error(\"Cannot load browser \\\"\".concat(name, \"\\\": it is not registered! Perhaps you are missing some plugin?\"));\n          } else {\n            log.error(\"Cannot load browser \\\"\".concat(name, \"\\\"!\\n  \") + e.stack);\n          }\n\n          _this2._emitter.emit('load_error', 'launcher', name);\n\n          return;\n        }\n\n        _this2.jobs.add(function (args, done) {\n          log.info(\"Starting browser \".concat(browser.displayName || browser.name));\n          browser.on('browser_process_failure', function () {\n            return done(browser.error);\n          });\n          browser.on('done', function () {\n            if (!browser.error && browser.state !== browser.STATE_RESTARTING) {\n              done(null, browser);\n            }\n          });\n          browser.start(\"\".concat(protocol, \"//\").concat(hostname, \":\").concat(port).concat(urlRoot));\n        }, []);\n\n        _this2.jobs.run();\n\n        _this2._browsers.push(browser);\n      };\n    }\n  }, {\n    key: \"launch\",\n    value: function launch(names, concurrency) {\n      var _this3 = this;\n\n      log.info(\"Launching browsers \".concat(names.join(', '), \" with concurrency \").concat(concurrency === Infinity ? 'unlimited' : concurrency));\n      this.jobs = new Jobs({\n        maxConcurrency: concurrency\n      });\n      this._lastStartTime = Date.now();\n\n      if (this._server.loadErrors.length) {\n        this.jobs.add(function (args, done) {\n          return done();\n        }, []);\n      } else {\n        names.forEach(function (name) {\n          return _this3._injector.invoke(_this3.launchSingle, _this3)(name);\n        });\n      }\n\n      this.jobs.on('end', function (err) {\n        log.debug('Finished all browsers');\n\n        if (err) {\n          log.error(err);\n        }\n      });\n      this.jobs.run();\n      return this._browsers;\n    }\n  }, {\n    key: \"kill\",\n    value: function kill(id, callback) {\n      callback = callback || function () {};\n\n      var browser = this.getBrowserById(id);\n\n      if (browser) {\n        browser.forceKill().then(callback);\n        return true;\n      }\n\n      process.nextTick(callback);\n      return false;\n    }\n  }, {\n    key: \"restart\",\n    value: function restart(id) {\n      var browser = this.getBrowserById(id);\n\n      if (browser) {\n        browser.restart();\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"killAll\",\n    value: function killAll(callback) {\n      callback = callback || function () {};\n\n      log.debug('Disconnecting all browsers');\n\n      if (!this._browsers.length) {\n        return process.nextTick(callback);\n      }\n\n      Promise.all(this._browsers.map(function (browser) {\n        return browser.forceKill();\n      })).then(callback);\n    }\n  }, {\n    key: \"areAllCaptured\",\n    value: function areAllCaptured() {\n      return this._browsers.every(function (browser) {\n        return browser.isCaptured();\n      });\n    }\n  }, {\n    key: \"markCaptured\",\n    value: function markCaptured(id) {\n      var browser = this.getBrowserById(id);\n\n      if (browser) {\n        browser.markCaptured();\n        log.debug(\"\".concat(browser.name, \" (id \").concat(browser.id, \") captured in \").concat((Date.now() - this._lastStartTime) / 1000, \" secs\"));\n      }\n    }\n  }], [{\n    key: \"generateId\",\n    value: function generateId() {\n      return Math.floor(Math.random() * 100000000).toString();\n    }\n  }]);\n\n  return Launcher;\n}();\n\nLauncher.factory = function (server, emitter, injector) {\n  return new Launcher(server, emitter, injector);\n};\n\nLauncher.factory.$inject = ['server', 'emitter', 'injector'];\nexports.Launcher = Launcher;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/karma/lib/launcher.js"],"names":["Jobs","require","log","create","baseDecorator","decoratorFactory","captureTimeoutDecorator","retryDecorator","processDecorator","baseBrowserDecoratorFactory","baseLauncherDecorator","captureTimeoutLauncherDecorator","retryLauncherDecorator","processLauncherDecorator","processKillTimeout","launcher","Launcher","server","emitter","injector","_server","_emitter","_injector","_browsers","_lastStartTime","launch","$inject","launchSingle","on","callback","killAll","id","find","browser","protocol","hostname","port","urlRoot","upstreamProxy","path","substr","name","locals","generateId","baseBrowserDecorator","includes","createChild","get","e","message","error","stack","emit","jobs","add","args","done","info","displayName","state","STATE_RESTARTING","start","run","push","names","concurrency","join","Infinity","maxConcurrency","Date","now","loadErrors","length","forEach","invoke","err","debug","getBrowserById","forceKill","then","process","nextTick","restart","Promise","all","map","every","isCaptured","markCaptured","Math","floor","random","toString","factory","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Jobs = require('qjobs')\n\nconst log = require('./logger').create('launcher')\n\nconst baseDecorator = require('./launchers/base').decoratorFactory\nconst captureTimeoutDecorator = require('./launchers/capture_timeout').decoratorFactory\nconst retryDecorator = require('./launchers/retry').decoratorFactory\nconst processDecorator = require('./launchers/process').decoratorFactory\n\n// TODO(vojta): remove once nobody uses it\nconst baseBrowserDecoratorFactory = function (\n  baseLauncherDecorator,\n  captureTimeoutLauncherDecorator,\n  retryLauncherDecorator,\n  processLauncherDecorator,\n  processKillTimeout\n) {\n  return function (launcher) {\n    baseLauncherDecorator(launcher)\n    captureTimeoutLauncherDecorator(launcher)\n    retryLauncherDecorator(launcher)\n    processLauncherDecorator(launcher, processKillTimeout)\n  }\n}\n\nclass Launcher {\n  constructor (server, emitter, injector) {\n    this._server = server\n    this._emitter = emitter\n    this._injector = injector\n    this._browsers = []\n    this._lastStartTime = null\n\n    // Attach list of dependency injection parameters to methods.\n    this.launch.$inject = [\n      'config.browsers',\n      'config.concurrency'\n    ]\n\n    this.launchSingle.$inject = [\n      'config.protocol',\n      'config.hostname',\n      'config.port',\n      'config.urlRoot',\n      'config.upstreamProxy',\n      'config.processKillTimeout'\n    ]\n\n    this._emitter.on('exit', (callback) => this.killAll(callback))\n  }\n\n  getBrowserById (id) {\n    return this._browsers.find((browser) => browser.id === id)\n  }\n\n  launchSingle (protocol, hostname, port, urlRoot, upstreamProxy, processKillTimeout) {\n    if (upstreamProxy) {\n      protocol = upstreamProxy.protocol\n      hostname = upstreamProxy.hostname\n      port = upstreamProxy.port\n      urlRoot = upstreamProxy.path + urlRoot.substr(1)\n    }\n\n    return (name) => {\n      let browser\n      const locals = {\n        id: ['value', Launcher.generateId()],\n        name: ['value', name],\n        processKillTimeout: ['value', processKillTimeout],\n        baseLauncherDecorator: ['factory', baseDecorator],\n        captureTimeoutLauncherDecorator: ['factory', captureTimeoutDecorator],\n        retryLauncherDecorator: ['factory', retryDecorator],\n        processLauncherDecorator: ['factory', processDecorator],\n        baseBrowserDecorator: ['factory', baseBrowserDecoratorFactory]\n      }\n\n      // TODO(vojta): determine script from name\n      if (name.includes('/')) {\n        name = 'Script'\n      }\n\n      try {\n        browser = this._injector.createChild([locals], ['launcher:' + name]).get('launcher:' + name)\n      } catch (e) {\n        if (e.message.includes(`No provider for \"launcher:${name}\"`)) {\n          log.error(`Cannot load browser \"${name}\": it is not registered! Perhaps you are missing some plugin?`)\n        } else {\n          log.error(`Cannot load browser \"${name}\"!\\n  ` + e.stack)\n        }\n\n        this._emitter.emit('load_error', 'launcher', name)\n        return\n      }\n\n      this.jobs.add((args, done) => {\n        log.info(`Starting browser ${browser.displayName || browser.name}`)\n\n        browser.on('browser_process_failure', () => done(browser.error))\n\n        browser.on('done', () => {\n          if (!browser.error && browser.state !== browser.STATE_RESTARTING) {\n            done(null, browser)\n          }\n        })\n\n        browser.start(`${protocol}//${hostname}:${port}${urlRoot}`)\n      }, [])\n\n      this.jobs.run()\n      this._browsers.push(browser)\n    }\n  }\n\n  launch (names, concurrency) {\n    log.info(`Launching browsers ${names.join(', ')} with concurrency ${concurrency === Infinity ? 'unlimited' : concurrency}`)\n    this.jobs = new Jobs({ maxConcurrency: concurrency })\n\n    this._lastStartTime = Date.now()\n\n    if (this._server.loadErrors.length) {\n      this.jobs.add((args, done) => done(), [])\n    } else {\n      names.forEach((name) => this._injector.invoke(this.launchSingle, this)(name))\n    }\n\n    this.jobs.on('end', (err) => {\n      log.debug('Finished all browsers')\n\n      if (err) {\n        log.error(err)\n      }\n    })\n\n    this.jobs.run()\n\n    return this._browsers\n  }\n\n  kill (id, callback) {\n    callback = callback || function () {}\n    const browser = this.getBrowserById(id)\n\n    if (browser) {\n      browser.forceKill().then(callback)\n      return true\n    }\n    process.nextTick(callback)\n    return false\n  }\n\n  restart (id) {\n    const browser = this.getBrowserById(id)\n    if (browser) {\n      browser.restart()\n      return true\n    }\n    return false\n  }\n\n  killAll (callback) {\n    callback = callback || function () {}\n    log.debug('Disconnecting all browsers')\n\n    if (!this._browsers.length) {\n      return process.nextTick(callback)\n    }\n\n    Promise.all(\n      this._browsers\n        .map((browser) => browser.forceKill())\n    ).then(callback)\n  }\n\n  areAllCaptured () {\n    return this._browsers.every((browser) => browser.isCaptured())\n  }\n\n  markCaptured (id) {\n    const browser = this.getBrowserById(id)\n    if (browser) {\n      browser.markCaptured()\n      log.debug(`${browser.name} (id ${browser.id}) captured in ${(Date.now() - this._lastStartTime) / 1000} secs`)\n    }\n  }\n\n  static generateId () {\n    return Math.floor(Math.random() * 100000000).toString()\n  }\n}\n\nLauncher.factory = function (server, emitter, injector) {\n  return new Launcher(server, emitter, injector)\n}\n\nLauncher.factory.$inject = ['server', 'emitter', 'injector']\n\nexports.Launcher = Launcher\n"]},"metadata":{},"sourceType":"script"}