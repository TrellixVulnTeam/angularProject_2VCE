{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeScriptPathsPlugin = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar path = require(\"path\");\n\nvar getInnerRequest = require('enhanced-resolve/lib/getInnerRequest');\n\nvar TypeScriptPathsPlugin = /*#__PURE__*/function () {\n  function TypeScriptPathsPlugin(_options) {\n    _classCallCheck(this, TypeScriptPathsPlugin);\n\n    this._options = _options;\n  } // tslint:disable-next-line:no-any\n\n\n  _createClass(TypeScriptPathsPlugin, [{\n    key: \"apply\",\n    value: function apply(resolver) {\n      var _this = this;\n\n      if (!this._options.paths || Object.keys(this._options.paths).length === 0) {\n        return;\n      }\n\n      var target = resolver.ensureHook('resolve');\n\n      var resolveAsync = function resolveAsync(request, requestContext) {\n        return new Promise(function (resolve, reject) {\n          resolver.doResolve(target, request, '', requestContext, function (error, result) {\n            if (error) {\n              reject(error);\n            } else {\n              resolve(result);\n            }\n          });\n        });\n      };\n\n      resolver.getHook('described-resolve').tapPromise('TypeScriptPathsPlugin', /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(request, resolveContext) {\n          var originalRequest, replacements, _iterator, _step, potential, potentialRequest, result;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (!(!request || request.typescriptPathMapped)) {\n                    _context.next = 2;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\");\n\n                case 2:\n                  originalRequest = getInnerRequest(resolver, request);\n\n                  if (originalRequest) {\n                    _context.next = 5;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\");\n\n                case 5:\n                  if (!(!request.context.issuer || !request.context.issuer.match(/\\.[jt]sx?$/))) {\n                    _context.next = 7;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\");\n\n                case 7:\n                  if (!(originalRequest.startsWith('.') || originalRequest.startsWith('/'))) {\n                    _context.next = 9;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\");\n\n                case 9:\n                  if (!originalRequest.startsWith('!!')) {\n                    _context.next = 11;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\");\n\n                case 11:\n                  replacements = findReplacements(originalRequest, _this._options.paths || {});\n                  _iterator = _createForOfIteratorHelper(replacements);\n                  _context.prev = 13;\n\n                  _iterator.s();\n\n                case 15:\n                  if ((_step = _iterator.n()).done) {\n                    _context.next = 25;\n                    break;\n                  }\n\n                  potential = _step.value;\n                  potentialRequest = _objectSpread(_objectSpread({}, request), {}, {\n                    request: path.resolve(_this._options.baseUrl || '', potential),\n                    typescriptPathMapped: true\n                  });\n                  _context.next = 20;\n                  return resolveAsync(potentialRequest, resolveContext);\n\n                case 20:\n                  result = _context.sent;\n\n                  if (!result) {\n                    _context.next = 23;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\", result);\n\n                case 23:\n                  _context.next = 15;\n                  break;\n\n                case 25:\n                  _context.next = 30;\n                  break;\n\n                case 27:\n                  _context.prev = 27;\n                  _context.t0 = _context[\"catch\"](13);\n\n                  _iterator.e(_context.t0);\n\n                case 30:\n                  _context.prev = 30;\n\n                  _iterator.f();\n\n                  return _context.finish(30);\n\n                case 33:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[13, 27, 30, 33]]);\n        }));\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }]);\n\n  return TypeScriptPathsPlugin;\n}();\n\nexports.TypeScriptPathsPlugin = TypeScriptPathsPlugin;\n\nfunction findReplacements(originalRequest, paths) {\n  // check if any path mapping rules are relevant\n  var pathMapOptions = [];\n\n  for (var pattern in paths) {\n    // get potentials and remove duplicates; JS Set maintains insertion order\n    var potentials = Array.from(new Set(paths[pattern]));\n\n    if (potentials.length === 0) {\n      // no potential replacements so skip\n      continue;\n    } // can only contain zero or one\n\n\n    var starIndex = pattern.indexOf('*');\n\n    if (starIndex === -1) {\n      if (pattern === originalRequest) {\n        pathMapOptions.push({\n          starIndex: starIndex,\n          partial: '',\n          potentials: potentials\n        });\n      }\n    } else if (starIndex === 0 && pattern.length === 1) {\n      if (potentials.length === 1 && potentials[0] === '*') {\n        // identity mapping -> noop\n        continue;\n      }\n\n      pathMapOptions.push({\n        starIndex: starIndex,\n        partial: originalRequest,\n        potentials: potentials\n      });\n    } else if (starIndex === pattern.length - 1) {\n      if (originalRequest.startsWith(pattern.slice(0, -1))) {\n        pathMapOptions.push({\n          starIndex: starIndex,\n          partial: originalRequest.slice(pattern.length - 1),\n          potentials: potentials\n        });\n      }\n    } else {\n      var _pattern$split = pattern.split('*'),\n          _pattern$split2 = _slicedToArray(_pattern$split, 2),\n          prefix = _pattern$split2[0],\n          suffix = _pattern$split2[1];\n\n      if (originalRequest.startsWith(prefix) && originalRequest.endsWith(suffix)) {\n        pathMapOptions.push({\n          starIndex: starIndex,\n          partial: originalRequest.slice(prefix.length).slice(0, -suffix.length),\n          potentials: potentials\n        });\n      }\n    }\n  }\n\n  if (pathMapOptions.length === 0) {\n    return [];\n  } // exact matches take priority then largest prefix match\n\n\n  pathMapOptions.sort(function (a, b) {\n    if (a.starIndex === -1) {\n      return -1;\n    } else if (b.starIndex === -1) {\n      return 1;\n    } else {\n      return b.starIndex - a.starIndex;\n    }\n  });\n  var replacements = [];\n  pathMapOptions.forEach(function (option) {\n    var _iterator2 = _createForOfIteratorHelper(option.potentials),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var potential = _step2.value;\n        var replacement = void 0;\n\n        var _starIndex = potential.indexOf('*');\n\n        if (_starIndex === -1) {\n          replacement = potential;\n        } else if (_starIndex === potential.length - 1) {\n          replacement = potential.slice(0, -1) + option.partial;\n        } else {\n          var _potential$split = potential.split('*'),\n              _potential$split2 = _slicedToArray(_potential$split, 2),\n              _prefix = _potential$split2[0],\n              _suffix = _potential$split2[1];\n\n          replacement = _prefix + option.partial + _suffix;\n        }\n\n        replacements.push(replacement);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  });\n  return replacements;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/paths-plugin.js"],"names":["Object","defineProperty","exports","value","TypeScriptPathsPlugin","path","require","getInnerRequest","_options","resolver","paths","keys","length","target","ensureHook","resolveAsync","request","requestContext","Promise","resolve","reject","doResolve","error","result","getHook","tapPromise","resolveContext","typescriptPathMapped","originalRequest","context","issuer","match","startsWith","replacements","findReplacements","potential","potentialRequest","baseUrl","pathMapOptions","pattern","potentials","Array","from","Set","starIndex","indexOf","push","partial","slice","split","prefix","suffix","endsWith","sort","a","b","forEach","option","replacement"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeScriptPathsPlugin = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst path = require(\"path\");\nconst getInnerRequest = require('enhanced-resolve/lib/getInnerRequest');\nclass TypeScriptPathsPlugin {\n    constructor(_options) {\n        this._options = _options;\n    }\n    // tslint:disable-next-line:no-any\n    apply(resolver) {\n        if (!this._options.paths || Object.keys(this._options.paths).length === 0) {\n            return;\n        }\n        const target = resolver.ensureHook('resolve');\n        const resolveAsync = (request, requestContext) => {\n            return new Promise((resolve, reject) => {\n                resolver.doResolve(target, request, '', requestContext, (error, result) => {\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(result);\n                    }\n                });\n            });\n        };\n        resolver.getHook('described-resolve').tapPromise('TypeScriptPathsPlugin', async (request, resolveContext) => {\n            if (!request || request.typescriptPathMapped) {\n                return;\n            }\n            const originalRequest = getInnerRequest(resolver, request);\n            if (!originalRequest) {\n                return;\n            }\n            // Only work on Javascript/TypeScript issuers.\n            if (!request.context.issuer || !request.context.issuer.match(/\\.[jt]sx?$/)) {\n                return;\n            }\n            // Relative or absolute requests are not mapped\n            if (originalRequest.startsWith('.') || originalRequest.startsWith('/')) {\n                return;\n            }\n            // Ignore all webpack special requests\n            if (originalRequest.startsWith('!!')) {\n                return;\n            }\n            const replacements = findReplacements(originalRequest, this._options.paths || {});\n            for (const potential of replacements) {\n                const potentialRequest = {\n                    ...request,\n                    request: path.resolve(this._options.baseUrl || '', potential),\n                    typescriptPathMapped: true,\n                };\n                const result = await resolveAsync(potentialRequest, resolveContext);\n                if (result) {\n                    return result;\n                }\n            }\n        });\n    }\n}\nexports.TypeScriptPathsPlugin = TypeScriptPathsPlugin;\nfunction findReplacements(originalRequest, paths) {\n    // check if any path mapping rules are relevant\n    const pathMapOptions = [];\n    for (const pattern in paths) {\n        // get potentials and remove duplicates; JS Set maintains insertion order\n        const potentials = Array.from(new Set(paths[pattern]));\n        if (potentials.length === 0) {\n            // no potential replacements so skip\n            continue;\n        }\n        // can only contain zero or one\n        const starIndex = pattern.indexOf('*');\n        if (starIndex === -1) {\n            if (pattern === originalRequest) {\n                pathMapOptions.push({\n                    starIndex,\n                    partial: '',\n                    potentials,\n                });\n            }\n        }\n        else if (starIndex === 0 && pattern.length === 1) {\n            if (potentials.length === 1 && potentials[0] === '*') {\n                // identity mapping -> noop\n                continue;\n            }\n            pathMapOptions.push({\n                starIndex,\n                partial: originalRequest,\n                potentials,\n            });\n        }\n        else if (starIndex === pattern.length - 1) {\n            if (originalRequest.startsWith(pattern.slice(0, -1))) {\n                pathMapOptions.push({\n                    starIndex,\n                    partial: originalRequest.slice(pattern.length - 1),\n                    potentials,\n                });\n            }\n        }\n        else {\n            const [prefix, suffix] = pattern.split('*');\n            if (originalRequest.startsWith(prefix) && originalRequest.endsWith(suffix)) {\n                pathMapOptions.push({\n                    starIndex,\n                    partial: originalRequest.slice(prefix.length).slice(0, -suffix.length),\n                    potentials,\n                });\n            }\n        }\n    }\n    if (pathMapOptions.length === 0) {\n        return [];\n    }\n    // exact matches take priority then largest prefix match\n    pathMapOptions.sort((a, b) => {\n        if (a.starIndex === -1) {\n            return -1;\n        }\n        else if (b.starIndex === -1) {\n            return 1;\n        }\n        else {\n            return b.starIndex - a.starIndex;\n        }\n    });\n    const replacements = [];\n    pathMapOptions.forEach(option => {\n        for (const potential of option.potentials) {\n            let replacement;\n            const starIndex = potential.indexOf('*');\n            if (starIndex === -1) {\n                replacement = potential;\n            }\n            else if (starIndex === potential.length - 1) {\n                replacement = potential.slice(0, -1) + option.partial;\n            }\n            else {\n                const [prefix, suffix] = potential.split('*');\n                replacement = prefix + option.partial + suffix;\n            }\n            replacements.push(replacement);\n        }\n    });\n    return replacements;\n}\n"]},"metadata":{},"sourceType":"script"}