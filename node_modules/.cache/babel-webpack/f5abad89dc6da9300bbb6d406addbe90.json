{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/annotations/src/pipe\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/transform\", \"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\", \"@angular/compiler-cli/src/ngtsc/annotations/src/factory\", \"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\", \"@angular/compiler-cli/src/ngtsc/annotations/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.PipeDecoratorHandler = exports.PipeSymbol = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var semantic_graph_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var transform_1 = require(\"@angular/compiler-cli/src/ngtsc/transform\");\n\n  var diagnostics_2 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\");\n\n  var factory_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/factory\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/util\");\n  /**\n   * Represents an Angular pipe.\n   */\n\n\n  var PipeSymbol =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(PipeSymbol, _super);\n\n    function PipeSymbol(decl, name) {\n      var _this = _super.call(this, decl) || this;\n\n      _this.name = name;\n      return _this;\n    }\n\n    PipeSymbol.prototype.isPublicApiAffected = function (previousSymbol) {\n      if (!(previousSymbol instanceof PipeSymbol)) {\n        return true;\n      }\n\n      return this.name !== previousSymbol.name;\n    };\n\n    PipeSymbol.prototype.isTypeCheckApiAffected = function (previousSymbol) {\n      return this.isPublicApiAffected(previousSymbol);\n    };\n\n    return PipeSymbol;\n  }(semantic_graph_1.SemanticSymbol);\n\n  exports.PipeSymbol = PipeSymbol;\n\n  var PipeDecoratorHandler =\n  /** @class */\n  function () {\n    function PipeDecoratorHandler(reflector, evaluator, metaRegistry, scopeRegistry, injectableRegistry, isCore, perf) {\n      this.reflector = reflector;\n      this.evaluator = evaluator;\n      this.metaRegistry = metaRegistry;\n      this.scopeRegistry = scopeRegistry;\n      this.injectableRegistry = injectableRegistry;\n      this.isCore = isCore;\n      this.perf = perf;\n      this.precedence = transform_1.HandlerPrecedence.PRIMARY;\n      this.name = PipeDecoratorHandler.name;\n    }\n\n    PipeDecoratorHandler.prototype.detect = function (node, decorators) {\n      if (!decorators) {\n        return undefined;\n      }\n\n      var decorator = util_1.findAngularDecorator(decorators, 'Pipe', this.isCore);\n\n      if (decorator !== undefined) {\n        return {\n          trigger: decorator.node,\n          decorator: decorator,\n          metadata: decorator\n        };\n      } else {\n        return undefined;\n      }\n    };\n\n    PipeDecoratorHandler.prototype.analyze = function (clazz, decorator) {\n      this.perf.eventCount(perf_1.PerfEvent.AnalyzePipe);\n      var name = clazz.name.text;\n      var type = util_1.wrapTypeReference(this.reflector, clazz);\n      var internalType = new compiler_1.WrappedNodeExpr(this.reflector.getInternalNameOfClass(clazz));\n\n      if (decorator.args === null) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_NOT_CALLED, reflection_1.Decorator.nodeForError(decorator), \"@Pipe must be called\");\n      }\n\n      if (decorator.args.length !== 1) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, reflection_1.Decorator.nodeForError(decorator), '@Pipe must have exactly one argument');\n      }\n\n      var meta = util_1.unwrapExpression(decorator.args[0]);\n\n      if (!ts.isObjectLiteralExpression(meta)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@Pipe must have a literal argument');\n      }\n\n      var pipe = reflection_1.reflectObjectLiteral(meta);\n\n      if (!pipe.has('name')) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.PIPE_MISSING_NAME, meta, \"@Pipe decorator is missing name field\");\n      }\n\n      var pipeNameExpr = pipe.get('name');\n      var pipeName = this.evaluator.evaluate(pipeNameExpr);\n\n      if (typeof pipeName !== 'string') {\n        throw diagnostics_2.createValueHasWrongTypeError(pipeNameExpr, pipeName, \"@Pipe.name must be a string\");\n      }\n\n      var pure = true;\n\n      if (pipe.has('pure')) {\n        var expr = pipe.get('pure');\n        var pureValue = this.evaluator.evaluate(expr);\n\n        if (typeof pureValue !== 'boolean') {\n          throw diagnostics_2.createValueHasWrongTypeError(expr, pureValue, \"@Pipe.pure must be a boolean\");\n        }\n\n        pure = pureValue;\n      }\n\n      return {\n        analysis: {\n          meta: {\n            name: name,\n            type: type,\n            internalType: internalType,\n            typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,\n            pipeName: pipeName,\n            deps: util_1.getValidConstructorDependencies(clazz, this.reflector, this.isCore),\n            pure: pure\n          },\n          metadataStmt: metadata_1.generateSetClassMetadataCall(clazz, this.reflector, this.isCore)\n        }\n      };\n    };\n\n    PipeDecoratorHandler.prototype.symbol = function (node, analysis) {\n      return new PipeSymbol(node, analysis.meta.name);\n    };\n\n    PipeDecoratorHandler.prototype.register = function (node, analysis) {\n      var ref = new imports_1.Reference(node);\n      this.metaRegistry.registerPipeMetadata({\n        ref: ref,\n        name: analysis.meta.pipeName\n      });\n      this.injectableRegistry.registerInjectable(node);\n    };\n\n    PipeDecoratorHandler.prototype.resolve = function (node) {\n      var duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);\n\n      if (duplicateDeclData !== null) {\n        // This pipe was declared twice (or more).\n        return {\n          diagnostics: [util_1.makeDuplicateDeclarationError(node, duplicateDeclData, 'Pipe')]\n        };\n      }\n\n      return {};\n    };\n\n    PipeDecoratorHandler.prototype.compileFull = function (node, analysis) {\n      var res = compiler_1.compilePipeFromMetadata(analysis.meta);\n      return this.compilePipe(analysis, res);\n    };\n\n    PipeDecoratorHandler.prototype.compilePartial = function (node, analysis) {\n      var res = compiler_1.compileDeclarePipeFromMetadata(analysis.meta);\n      return this.compilePipe(analysis, res);\n    };\n\n    PipeDecoratorHandler.prototype.compilePipe = function (analysis, def) {\n      var factoryRes = factory_1.compileNgFactoryDefField(tslib_1.__assign(tslib_1.__assign({}, analysis.meta), {\n        injectFn: compiler_1.Identifiers.directiveInject,\n        target: compiler_1.R3FactoryTarget.Pipe\n      }));\n\n      if (analysis.metadataStmt !== null) {\n        factoryRes.statements.push(analysis.metadataStmt);\n      }\n\n      return [factoryRes, {\n        name: 'Éµpipe',\n        initializer: def.expression,\n        statements: [],\n        type: def.type\n      }];\n    };\n\n    return PipeDecoratorHandler;\n  }();\n\n  exports.PipeDecoratorHandler = PipeDecoratorHandler;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/pipe.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileDeclarePipeFromMetadata, compilePipeFromMetadata, Identifiers, R3FactoryTarget, R3PipeDef, R3PipeMetadata, Statement, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {Reference} from '../../imports';\nimport {SemanticSymbol} from '../../incremental/semantic_graph';\nimport {InjectableClassRegistry, MetadataRegistry} from '../../metadata';\nimport {PartialEvaluator} from '../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\nimport {LocalModuleScopeRegistry} from '../../scope';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult} from '../../transform';\n\nimport {createValueHasWrongTypeError} from './diagnostics';\nimport {compileNgFactoryDefField} from './factory';\nimport {generateSetClassMetadataCall} from './metadata';\nimport {findAngularDecorator, getValidConstructorDependencies, makeDuplicateDeclarationError, unwrapExpression, wrapTypeReference} from './util';\n\nexport interface PipeHandlerData {\n  meta: R3PipeMetadata;\n  metadataStmt: Statement|null;\n}\n\n/**\n * Represents an Angular pipe.\n */\nexport class PipeSymbol extends SemanticSymbol {\n  constructor(decl: ClassDeclaration, public readonly name: string) {\n    super(decl);\n  }\n\n  isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n    if (!(previousSymbol instanceof PipeSymbol)) {\n      return true;\n    }\n\n    return this.name !== previousSymbol.name;\n  }\n\n  isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n    return this.isPublicApiAffected(previousSymbol);\n  }\n}\n\nexport class PipeDecoratorHandler implements\n    DecoratorHandler<Decorator, PipeHandlerData, PipeSymbol, unknown> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private metaRegistry: MetadataRegistry, private scopeRegistry: LocalModuleScopeRegistry,\n      private injectableRegistry: InjectableClassRegistry, private isCore: boolean,\n      private perf: PerfRecorder) {}\n\n  readonly precedence = HandlerPrecedence.PRIMARY;\n  readonly name = PipeDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<Decorator>|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    const decorator = findAngularDecorator(decorators, 'Pipe', this.isCore);\n    if (decorator !== undefined) {\n      return {\n        trigger: decorator.node,\n        decorator: decorator,\n        metadata: decorator,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  analyze(clazz: ClassDeclaration, decorator: Readonly<Decorator>):\n      AnalysisOutput<PipeHandlerData> {\n    this.perf.eventCount(PerfEvent.AnalyzePipe);\n\n    const name = clazz.name.text;\n    const type = wrapTypeReference(this.reflector, clazz);\n    const internalType = new WrappedNodeExpr(this.reflector.getInternalNameOfClass(clazz));\n\n    if (decorator.args === null) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator),\n          `@Pipe must be called`);\n    }\n    if (decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator),\n          '@Pipe must have exactly one argument');\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@Pipe must have a literal argument');\n    }\n    const pipe = reflectObjectLiteral(meta);\n\n    if (!pipe.has('name')) {\n      throw new FatalDiagnosticError(\n          ErrorCode.PIPE_MISSING_NAME, meta, `@Pipe decorator is missing name field`);\n    }\n    const pipeNameExpr = pipe.get('name')!;\n    const pipeName = this.evaluator.evaluate(pipeNameExpr);\n    if (typeof pipeName !== 'string') {\n      throw createValueHasWrongTypeError(pipeNameExpr, pipeName, `@Pipe.name must be a string`);\n    }\n\n    let pure = true;\n    if (pipe.has('pure')) {\n      const expr = pipe.get('pure')!;\n      const pureValue = this.evaluator.evaluate(expr);\n      if (typeof pureValue !== 'boolean') {\n        throw createValueHasWrongTypeError(expr, pureValue, `@Pipe.pure must be a boolean`);\n      }\n      pure = pureValue;\n    }\n\n    return {\n      analysis: {\n        meta: {\n          name,\n          type,\n          internalType,\n          typeArgumentCount: this.reflector.getGenericArityOfClass(clazz) || 0,\n          pipeName,\n          deps: getValidConstructorDependencies(clazz, this.reflector, this.isCore),\n          pure,\n        },\n        metadataStmt: generateSetClassMetadataCall(clazz, this.reflector, this.isCore),\n      },\n    };\n  }\n\n  symbol(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): PipeSymbol {\n    return new PipeSymbol(node, analysis.meta.name);\n  }\n\n  register(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): void {\n    const ref = new Reference(node);\n    this.metaRegistry.registerPipeMetadata({ref, name: analysis.meta.pipeName});\n\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  resolve(node: ClassDeclaration): ResolveResult<unknown> {\n    const duplicateDeclData = this.scopeRegistry.getDuplicateDeclarations(node);\n    if (duplicateDeclData !== null) {\n      // This pipe was declared twice (or more).\n      return {\n        diagnostics: [makeDuplicateDeclarationError(node, duplicateDeclData, 'Pipe')],\n      };\n    }\n\n    return {};\n  }\n\n  compileFull(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): CompileResult[] {\n    const res = compilePipeFromMetadata(analysis.meta);\n    return this.compilePipe(analysis, res);\n  }\n\n  compilePartial(node: ClassDeclaration, analysis: Readonly<PipeHandlerData>): CompileResult[] {\n    const res = compileDeclarePipeFromMetadata(analysis.meta);\n    return this.compilePipe(analysis, res);\n  }\n\n  private compilePipe(analysis: Readonly<PipeHandlerData>, def: R3PipeDef) {\n    const factoryRes = compileNgFactoryDefField({\n      ...analysis.meta,\n      injectFn: Identifiers.directiveInject,\n      target: R3FactoryTarget.Pipe,\n    });\n    if (analysis.metadataStmt !== null) {\n      factoryRes.statements.push(analysis.metadataStmt);\n    }\n    return [\n      factoryRes, {\n        name: 'Éµpipe',\n        initializer: def.expression,\n        statements: [],\n        type: def.type,\n      }\n    ];\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}