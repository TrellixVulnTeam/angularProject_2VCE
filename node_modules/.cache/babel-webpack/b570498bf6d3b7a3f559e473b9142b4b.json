{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/single_process_executor\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SingleProcessExecutorAsync = exports.SingleProcessExecutorSync = exports.SingleProcessorExecutorBase = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var SingleProcessorExecutorBase =\n  /** @class */\n  function () {\n    function SingleProcessorExecutorBase(logger, createTaskCompletedCallback) {\n      this.logger = logger;\n      this.createTaskCompletedCallback = createTaskCompletedCallback;\n    }\n\n    SingleProcessorExecutorBase.prototype.doExecute = function (analyzeEntryPoints, createCompileFn) {\n      this.logger.debug(\"Running ngcc on \" + this.constructor.name + \".\");\n      var taskQueue = analyzeEntryPoints();\n      var onTaskCompleted = this.createTaskCompletedCallback(taskQueue);\n      var compile = createCompileFn(function () {}, onTaskCompleted); // Process all tasks.\n\n      this.logger.debug('Processing tasks...');\n      var startTime = Date.now();\n\n      while (!taskQueue.allTasksCompleted) {\n        var task = taskQueue.getNextTask();\n        compile(task);\n        taskQueue.markAsCompleted(task);\n      }\n\n      var duration = Math.round((Date.now() - startTime) / 1000);\n      this.logger.debug(\"Processed tasks in \" + duration + \"s.\");\n    };\n\n    return SingleProcessorExecutorBase;\n  }();\n\n  exports.SingleProcessorExecutorBase = SingleProcessorExecutorBase;\n  /**\n   * An `Executor` that processes all tasks serially and completes synchronously.\n   */\n\n  var SingleProcessExecutorSync =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(SingleProcessExecutorSync, _super);\n\n    function SingleProcessExecutorSync(logger, lockFile, createTaskCompletedCallback) {\n      var _this = _super.call(this, logger, createTaskCompletedCallback) || this;\n\n      _this.lockFile = lockFile;\n      return _this;\n    }\n\n    SingleProcessExecutorSync.prototype.execute = function (analyzeEntryPoints, createCompileFn) {\n      var _this = this;\n\n      this.lockFile.lock(function () {\n        return _this.doExecute(analyzeEntryPoints, createCompileFn);\n      });\n    };\n\n    return SingleProcessExecutorSync;\n  }(SingleProcessorExecutorBase);\n\n  exports.SingleProcessExecutorSync = SingleProcessExecutorSync;\n  /**\n   * An `Executor` that processes all tasks serially, but still completes asynchronously.\n   */\n\n  var SingleProcessExecutorAsync =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(SingleProcessExecutorAsync, _super);\n\n    function SingleProcessExecutorAsync(logger, lockFile, createTaskCompletedCallback) {\n      var _this = _super.call(this, logger, createTaskCompletedCallback) || this;\n\n      _this.lockFile = lockFile;\n      return _this;\n    }\n\n    SingleProcessExecutorAsync.prototype.execute = function (analyzeEntryPoints, createCompileFn) {\n      return tslib_1.__awaiter(this, void 0, void 0, function () {\n        var _this = this;\n\n        return tslib_1.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.lockFile.lock(function () {\n                return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                  return tslib_1.__generator(this, function (_a) {\n                    return [2\n                    /*return*/\n                    , this.doExecute(analyzeEntryPoints, createCompileFn)];\n                  });\n                });\n              })];\n\n            case 1:\n              _a.sent();\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    return SingleProcessExecutorAsync;\n  }(SingleProcessorExecutorBase);\n\n  exports.SingleProcessExecutorAsync = SingleProcessExecutorAsync;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/execution/single_process_executor.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AASH,MAAA,2BAAA;AAAA;AAAA,cAAA;AACE,aAAA,2BAAA,CACY,MADZ,EACoC,2BADpC,EAC4F;AAAhF,WAAA,MAAA,GAAA,MAAA;AAAwB,WAAA,2BAAA,GAAA,2BAAA;AAA4D;;AAEhG,IAAA,2BAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,kBAAV,EAAoD,eAApD,EAAoF;AAElF,WAAK,MAAL,CAAY,KAAZ,CAAkB,qBAAmB,KAAK,WAAL,CAAiB,IAApC,GAAwC,GAA1D;AAEA,UAAM,SAAS,GAAG,kBAAkB,EAApC;AACA,UAAM,eAAe,GAAG,KAAK,2BAAL,CAAiC,SAAjC,CAAxB;AACA,UAAM,OAAO,GAAG,eAAe,CAAC,YAAA,CAAQ,CAAT,EAAW,eAAX,CAA/B,CANkF,CAQlF;;AACA,WAAK,MAAL,CAAY,KAAZ,CAAkB,qBAAlB;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,GAAL,EAAlB;;AAEA,aAAO,CAAC,SAAS,CAAC,iBAAlB,EAAqC;AACnC,YAAM,IAAI,GAAG,SAAS,CAAC,WAAV,EAAb;AACA,QAAA,OAAO,CAAC,IAAD,CAAP;AACA,QAAA,SAAS,CAAC,eAAV,CAA0B,IAA1B;AACD;;AAED,UAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,IAAI,CAAC,GAAL,KAAa,SAAd,IAA2B,IAAtC,CAAjB;AACA,WAAK,MAAL,CAAY,KAAZ,CAAkB,wBAAsB,QAAtB,GAA8B,IAAhD;AACD,KApBD;;AAqBF,WAAA,2BAAA;AAAC,GAzBD,EAAA;;AAAsB,EAAA,OAAA,CAAA,2BAAA,GAAA,2BAAA;AA2BtB;;AAEG;;AACH,MAAA,yBAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAA+C,IAAA,OAAA,CAAA,SAAA,CAAA,yBAAA,EAAA,MAAA;;AAC7C,aAAA,yBAAA,CACI,MADJ,EAC4B,QAD5B,EAEI,2BAFJ,EAE4D;AAF5D,UAAA,KAAA,GAGE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,MAAN,EAAc,2BAAd,KAA0C,IAH5C;;AAC4B,MAAA,KAAA,CAAA,QAAA,GAAA,QAAA;;AAG3B;;AACD,IAAA,yBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,kBAAR,EAAkD,eAAlD,EAAkF;AAAlF,UAAA,KAAA,GAAA,IAAA;;AACE,WAAK,QAAL,CAAc,IAAd,CAAmB,YAAA;AAAM,eAAA,KAAI,CAAC,SAAL,CAAe,kBAAf,EAAA,eAAA,CAAA;AAAmD,OAA5E;AACD,KAFD;;AAGF,WAAA,yBAAA;AAAC,GATD,CAA+C,2BAA/C,CAAA;;AAAa,EAAA,OAAA,CAAA,yBAAA,GAAA,yBAAA;AAWb;;AAEG;;AACH,MAAA,0BAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAgD,IAAA,OAAA,CAAA,SAAA,CAAA,0BAAA,EAAA,MAAA;;AAC9C,aAAA,0BAAA,CACI,MADJ,EAC4B,QAD5B,EAEI,2BAFJ,EAE4D;AAF5D,UAAA,KAAA,GAGE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,MAAN,EAAc,2BAAd,KAA0C,IAH5C;;AAC4B,MAAA,KAAA,CAAA,QAAA,GAAA,QAAA;;AAG3B;;AACK,IAAA,0BAAA,CAAA,SAAA,CAAA,OAAA,GAAN,UAAc,kBAAd,EAAwD,eAAxD,EAAwF;;;;;;;AAEtF,qBAAA,CAAA;AAAA;AAAA,gBAAM,KAAK,QAAL,CAAc,IAAd,CAAmB,YAAA;AAAA,uBAAA,OAAA,CAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;AAAA,yBAAA,OAAA,CAAA,WAAA,CAAA,IAAA,EAAA,UAAA,EAAA,EAAA;AAAY,2BAAA,CAAA;AAAA;AAAA,sBAAA,KAAK,SAAL,CAAe,kBAAf,EAAmC,eAAnC,CAAA,CAAA;mBAAZ,CAAA;iBAAA,CAAA;AAA+D,eAAlF,CAAN,CAAA;;;AAAA,cAAA,EAAA,CAAA,IAAA;;;;;;;;AACD,KAHK;;AAIR,WAAA,0BAAA;AAAC,GAVD,CAAgD,2BAAhD,CAAA;;AAAa,EAAA,OAAA,CAAA,0BAAA,GAAA,0BAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {AsyncLocker} from '../locking/async_locker';\nimport {SyncLocker} from '../locking/sync_locker';\n\nimport {AnalyzeEntryPointsFn, CreateCompileFn, Executor} from './api';\nimport {CreateTaskCompletedCallback} from './tasks/api';\n\nexport abstract class SingleProcessorExecutorBase {\n  constructor(\n      private logger: Logger, private createTaskCompletedCallback: CreateTaskCompletedCallback) {}\n\n  doExecute(analyzeEntryPoints: AnalyzeEntryPointsFn, createCompileFn: CreateCompileFn):\n      void|Promise<void> {\n    this.logger.debug(`Running ngcc on ${this.constructor.name}.`);\n\n    const taskQueue = analyzeEntryPoints();\n    const onTaskCompleted = this.createTaskCompletedCallback(taskQueue);\n    const compile = createCompileFn(() => {}, onTaskCompleted);\n\n    // Process all tasks.\n    this.logger.debug('Processing tasks...');\n    const startTime = Date.now();\n\n    while (!taskQueue.allTasksCompleted) {\n      const task = taskQueue.getNextTask()!;\n      compile(task);\n      taskQueue.markAsCompleted(task);\n    }\n\n    const duration = Math.round((Date.now() - startTime) / 1000);\n    this.logger.debug(`Processed tasks in ${duration}s.`);\n  }\n}\n\n/**\n * An `Executor` that processes all tasks serially and completes synchronously.\n */\nexport class SingleProcessExecutorSync extends SingleProcessorExecutorBase implements Executor {\n  constructor(\n      logger: Logger, private lockFile: SyncLocker,\n      createTaskCompletedCallback: CreateTaskCompletedCallback) {\n    super(logger, createTaskCompletedCallback);\n  }\n  execute(analyzeEntryPoints: AnalyzeEntryPointsFn, createCompileFn: CreateCompileFn): void {\n    this.lockFile.lock(() => this.doExecute(analyzeEntryPoints, createCompileFn));\n  }\n}\n\n/**\n * An `Executor` that processes all tasks serially, but still completes asynchronously.\n */\nexport class SingleProcessExecutorAsync extends SingleProcessorExecutorBase implements Executor {\n  constructor(\n      logger: Logger, private lockFile: AsyncLocker,\n      createTaskCompletedCallback: CreateTaskCompletedCallback) {\n    super(logger, createTaskCompletedCallback);\n  }\n  async execute(analyzeEntryPoints: AnalyzeEntryPointsFn, createCompileFn: CreateCompileFn):\n      Promise<void> {\n    await this.lockFile.lock(async () => this.doExecute(analyzeEntryPoints, createCompileFn));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}