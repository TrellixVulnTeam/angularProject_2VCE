{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypesOfSchema = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar interface_1 = require(\"../interface\");\n\nvar allTypes = ['string', 'integer', 'number', 'object', 'array', 'boolean', 'null'];\n\nfunction getTypesOfSchema(schema) {\n  if (!schema) {\n    return new Set();\n  }\n\n  if (schema === true) {\n    return new Set(allTypes);\n  }\n\n  var potentials;\n\n  if (typeof schema.type === 'string') {\n    potentials = new Set([schema.type]);\n  } else if (Array.isArray(schema.type)) {\n    potentials = new Set(schema.type);\n  } else if (interface_1.isJsonArray(schema.enum)) {\n    potentials = new Set(); // Gather the type of each enum values, and use that as a starter for potential types.\n\n    var _iterator = _createForOfIteratorHelper(schema.enum),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var v = _step.value;\n\n        switch (typeof v) {\n          case 'string':\n          case 'number':\n          case 'boolean':\n            potentials.add(typeof v);\n            break;\n\n          case 'object':\n            if (Array.isArray(v)) {\n              potentials.add('array');\n            } else if (v === null) {\n              potentials.add('null');\n            } else {\n              potentials.add('object');\n            }\n\n            break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    potentials = new Set(allTypes);\n  }\n\n  if (interface_1.isJsonObject(schema.not)) {\n    var notTypes = getTypesOfSchema(schema.not);\n    potentials = new Set(_toConsumableArray(potentials).filter(function (p) {\n      return !notTypes.has(p);\n    }));\n  }\n\n  if (Array.isArray(schema.allOf)) {\n    var _iterator2 = _createForOfIteratorHelper(schema.allOf),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var sub = _step2.value;\n        var types = getTypesOfSchema(sub);\n        potentials = new Set(_toConsumableArray(types).filter(function (t) {\n          return potentials.has(t);\n        }));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  if (Array.isArray(schema.oneOf)) {\n    var options = new Set();\n\n    var _iterator3 = _createForOfIteratorHelper(schema.oneOf),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _sub = _step3.value;\n\n        var _types = getTypesOfSchema(_sub);\n\n        options = new Set([].concat(_toConsumableArray(options), _toConsumableArray(_types)));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    potentials = new Set(_toConsumableArray(options).filter(function (o) {\n      return potentials.has(o);\n    }));\n  }\n\n  if (Array.isArray(schema.anyOf)) {\n    var _options = new Set();\n\n    var _iterator4 = _createForOfIteratorHelper(schema.anyOf),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _sub2 = _step4.value;\n\n        var _types2 = getTypesOfSchema(_sub2);\n\n        _options = new Set([].concat(_toConsumableArray(_options), _toConsumableArray(_types2)));\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    potentials = new Set(_toConsumableArray(_options).filter(function (o) {\n      return potentials.has(o);\n    }));\n  }\n\n  if (schema.properties) {\n    potentials.add('object');\n  } else if (schema.items) {\n    potentials.add('array');\n  }\n\n  return potentials;\n}\n\nexports.getTypesOfSchema = getTypesOfSchema;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/json/schema/utility.js"],"names":["Object","defineProperty","exports","value","getTypesOfSchema","interface_1","require","allTypes","schema","Set","potentials","type","Array","isArray","isJsonArray","enum","v","add","isJsonObject","not","notTypes","filter","p","has","allOf","sub","types","t","oneOf","options","o","anyOf","properties","items"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getTypesOfSchema = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst interface_1 = require(\"../interface\");\nconst allTypes = ['string', 'integer', 'number', 'object', 'array', 'boolean', 'null'];\nfunction getTypesOfSchema(schema) {\n    if (!schema) {\n        return new Set();\n    }\n    if (schema === true) {\n        return new Set(allTypes);\n    }\n    let potentials;\n    if (typeof schema.type === 'string') {\n        potentials = new Set([schema.type]);\n    }\n    else if (Array.isArray(schema.type)) {\n        potentials = new Set(schema.type);\n    }\n    else if (interface_1.isJsonArray(schema.enum)) {\n        potentials = new Set();\n        // Gather the type of each enum values, and use that as a starter for potential types.\n        for (const v of schema.enum) {\n            switch (typeof v) {\n                case 'string':\n                case 'number':\n                case 'boolean':\n                    potentials.add(typeof v);\n                    break;\n                case 'object':\n                    if (Array.isArray(v)) {\n                        potentials.add('array');\n                    }\n                    else if (v === null) {\n                        potentials.add('null');\n                    }\n                    else {\n                        potentials.add('object');\n                    }\n                    break;\n            }\n        }\n    }\n    else {\n        potentials = new Set(allTypes);\n    }\n    if (interface_1.isJsonObject(schema.not)) {\n        const notTypes = getTypesOfSchema(schema.not);\n        potentials = new Set([...potentials].filter(p => !notTypes.has(p)));\n    }\n    if (Array.isArray(schema.allOf)) {\n        for (const sub of schema.allOf) {\n            const types = getTypesOfSchema(sub);\n            potentials = new Set([...types].filter(t => potentials.has(t)));\n        }\n    }\n    if (Array.isArray(schema.oneOf)) {\n        let options = new Set();\n        for (const sub of schema.oneOf) {\n            const types = getTypesOfSchema(sub);\n            options = new Set([...options, ...types]);\n        }\n        potentials = new Set([...options].filter(o => potentials.has(o)));\n    }\n    if (Array.isArray(schema.anyOf)) {\n        let options = new Set();\n        for (const sub of schema.anyOf) {\n            const types = getTypesOfSchema(sub);\n            options = new Set([...options, ...types]);\n        }\n        potentials = new Set([...options].filter(o => potentials.has(o)));\n    }\n    if (schema.properties) {\n        potentials.add('object');\n    }\n    else if (schema.items) {\n        potentials.add('array');\n    }\n    return potentials;\n}\nexports.getTypesOfSchema = getTypesOfSchema;\n"]},"metadata":{},"sourceType":"script"}