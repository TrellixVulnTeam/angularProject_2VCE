{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/i18n/i18n_parser\", [\"require\", \"exports\", \"@angular/compiler/src/expression_parser/lexer\", \"@angular/compiler/src/expression_parser/parser\", \"@angular/compiler/src/ml_parser/ast\", \"@angular/compiler/src/ml_parser/html_tags\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/i18n/i18n_ast\", \"@angular/compiler/src/i18n/serializers/placeholder\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.createI18nMessageFactory = void 0;\n\n  var lexer_1 = require(\"@angular/compiler/src/expression_parser/lexer\");\n\n  var parser_1 = require(\"@angular/compiler/src/expression_parser/parser\");\n\n  var html = require(\"@angular/compiler/src/ml_parser/ast\");\n\n  var html_tags_1 = require(\"@angular/compiler/src/ml_parser/html_tags\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var i18n = require(\"@angular/compiler/src/i18n/i18n_ast\");\n\n  var placeholder_1 = require(\"@angular/compiler/src/i18n/serializers/placeholder\");\n\n  var _expParser = new parser_1.Parser(new lexer_1.Lexer());\n  /**\n   * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n   */\n\n\n  function createI18nMessageFactory(interpolationConfig) {\n    var visitor = new _I18nVisitor(_expParser, interpolationConfig);\n    return function (nodes, meaning, description, customId, visitNodeFn) {\n      return visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n    };\n  }\n\n  exports.createI18nMessageFactory = createI18nMessageFactory;\n\n  function noopVisitNodeFn(_html, i18n) {\n    return i18n;\n  }\n\n  var _I18nVisitor =\n  /** @class */\n  function () {\n    function _I18nVisitor(_expressionParser, _interpolationConfig) {\n      this._expressionParser = _expressionParser;\n      this._interpolationConfig = _interpolationConfig;\n    }\n\n    _I18nVisitor.prototype.toI18nMessage = function (nodes, meaning, description, customId, visitNodeFn) {\n      if (meaning === void 0) {\n        meaning = '';\n      }\n\n      if (description === void 0) {\n        description = '';\n      }\n\n      if (customId === void 0) {\n        customId = '';\n      }\n\n      var context = {\n        isIcu: nodes.length == 1 && nodes[0] instanceof html.Expansion,\n        icuDepth: 0,\n        placeholderRegistry: new placeholder_1.PlaceholderRegistry(),\n        placeholderToContent: {},\n        placeholderToMessage: {},\n        visitNodeFn: visitNodeFn || noopVisitNodeFn\n      };\n      var i18nodes = html.visitAll(this, nodes, context);\n      return new i18n.Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n    };\n\n    _I18nVisitor.prototype.visitElement = function (el, context) {\n      var _a;\n\n      var children = html.visitAll(this, el.children, context);\n      var attrs = {};\n      el.attrs.forEach(function (attr) {\n        // Do not visit the attributes, translatable ones are top-level ASTs\n        attrs[attr.name] = attr.value;\n      });\n      var isVoid = html_tags_1.getHtmlTagDefinition(el.name).isVoid;\n      var startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n      context.placeholderToContent[startPhName] = {\n        text: el.startSourceSpan.toString(),\n        sourceSpan: el.startSourceSpan\n      };\n      var closePhName = '';\n\n      if (!isVoid) {\n        closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n        context.placeholderToContent[closePhName] = {\n          text: \"</\" + el.name + \">\",\n          sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan\n        };\n      }\n\n      var node = new i18n.TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n      return context.visitNodeFn(el, node);\n    };\n\n    _I18nVisitor.prototype.visitAttribute = function (attribute, context) {\n      var node = this._visitTextWithInterpolation(attribute.value, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n\n      return context.visitNodeFn(attribute, node);\n    };\n\n    _I18nVisitor.prototype.visitText = function (text, context) {\n      var node = this._visitTextWithInterpolation(text.value, text.sourceSpan, context, text.i18n);\n\n      return context.visitNodeFn(text, node);\n    };\n\n    _I18nVisitor.prototype.visitComment = function (comment, context) {\n      return null;\n    };\n\n    _I18nVisitor.prototype.visitExpansion = function (icu, context) {\n      var _this = this;\n\n      context.icuDepth++;\n      var i18nIcuCases = {};\n      var i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n      icu.cases.forEach(function (caze) {\n        i18nIcuCases[caze.value] = new i18n.Container(caze.expression.map(function (node) {\n          return node.visit(_this, context);\n        }), caze.expSourceSpan);\n      });\n      context.icuDepth--;\n\n      if (context.isIcu || context.icuDepth > 0) {\n        // Returns an ICU node when:\n        // - the message (vs a part of the message) is an ICU message, or\n        // - the ICU message is nested.\n        var expPh = context.placeholderRegistry.getUniquePlaceholder(\"VAR_\" + icu.type);\n        i18nIcu.expressionPlaceholder = expPh;\n        context.placeholderToContent[expPh] = {\n          text: icu.switchValue,\n          sourceSpan: icu.switchValueSourceSpan\n        };\n        return context.visitNodeFn(icu, i18nIcu);\n      } // Else returns a placeholder\n      // ICU placeholders should not be replaced with their original content but with the their\n      // translations.\n      // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n\n\n      var phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n      context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n      var node = new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n      return context.visitNodeFn(icu, node);\n    };\n\n    _I18nVisitor.prototype.visitExpansionCase = function (_icuCase, _context) {\n      throw new Error('Unreachable code');\n    };\n    /**\n     * Split the, potentially interpolated, text up into text and placeholder pieces.\n     *\n     * @param text The potentially interpolated string to be split.\n     * @param sourceSpan The span of the whole of the `text` string.\n     * @param context The current context of the visitor, used to compute and store placeholders.\n     * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n     */\n\n\n    _I18nVisitor.prototype._visitTextWithInterpolation = function (text, sourceSpan, context, previousI18n) {\n      var _a = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig),\n          strings = _a.strings,\n          expressions = _a.expressions; // No expressions, return a single text.\n\n\n      if (expressions.length === 0) {\n        return new i18n.Text(text, sourceSpan);\n      } // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n\n\n      var nodes = [];\n\n      for (var i = 0; i < strings.length - 1; i++) {\n        this._addText(nodes, strings[i], sourceSpan);\n\n        this._addPlaceholder(nodes, context, expressions[i], sourceSpan);\n      } // The last index contains no expression\n\n\n      this._addText(nodes, strings[strings.length - 1], sourceSpan); // Whitespace removal may have invalidated the interpolation source-spans.\n\n\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new i18n.Container(nodes, sourceSpan);\n    };\n    /**\n     * Create a new `Text` node from the `textPiece` and add it to the `nodes` collection.\n     *\n     * @param nodes The nodes to which the created `Text` node should be added.\n     * @param textPiece The text and relative span information for this `Text` node.\n     * @param interpolationSpan The span of the whole interpolated text.\n     */\n\n\n    _I18nVisitor.prototype._addText = function (nodes, textPiece, interpolationSpan) {\n      if (textPiece.text.length > 0) {\n        // No need to add empty strings\n        var stringSpan = getOffsetSourceSpan(interpolationSpan, textPiece);\n        nodes.push(new i18n.Text(textPiece.text, stringSpan));\n      }\n    };\n    /**\n     * Create a new `Placeholder` node from the `expression` and add it to the `nodes` collection.\n     *\n     * @param nodes The nodes to which the created `Text` node should be added.\n     * @param context The current context of the visitor, used to compute and store placeholders.\n     * @param expression The expression text and relative span information for this `Placeholder`\n     *     node.\n     * @param interpolationSpan The span of the whole interpolated text.\n     */\n\n\n    _I18nVisitor.prototype._addPlaceholder = function (nodes, context, expression, interpolationSpan) {\n      var sourceSpan = getOffsetSourceSpan(interpolationSpan, expression);\n      var baseName = extractPlaceholderName(expression.text) || 'INTERPOLATION';\n      var phName = context.placeholderRegistry.getPlaceholderName(baseName, expression.text);\n      var text = this._interpolationConfig.start + expression.text + this._interpolationConfig.end;\n      context.placeholderToContent[phName] = {\n        text: text,\n        sourceSpan: sourceSpan\n      };\n      nodes.push(new i18n.Placeholder(expression.text, phName, sourceSpan));\n    };\n\n    return _I18nVisitor;\n  }();\n  /**\n   * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n   *\n   * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n   * reuse the source-span stored from a previous pass before the whitespace was removed.\n   *\n   * @param nodes The `Text` and `Placeholder` nodes to be processed.\n   * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n   */\n\n\n  function reusePreviousSourceSpans(nodes, previousI18n) {\n    if (previousI18n instanceof i18n.Message) {\n      // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n      // metadata. The `Message` should consist only of a single `Container` that contains the\n      // parts (`Text` and `Placeholder`) to process.\n      assertSingleContainerMessage(previousI18n);\n      previousI18n = previousI18n.nodes[0];\n    }\n\n    if (previousI18n instanceof i18n.Container) {\n      // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n      // after whitespace has been removed from the AST ndoes.\n      assertEquivalentNodes(previousI18n.children, nodes); // Reuse the source-spans from the first pass.\n\n      for (var i = 0; i < nodes.length; i++) {\n        nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n      }\n    }\n  }\n  /**\n   * Asserts that the `message` contains exactly one `Container` node.\n   */\n\n\n  function assertSingleContainerMessage(message) {\n    var nodes = message.nodes;\n\n    if (nodes.length !== 1 || !(nodes[0] instanceof i18n.Container)) {\n      throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n    }\n  }\n  /**\n   * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n   * corresponding elements have the same node type.\n   */\n\n\n  function assertEquivalentNodes(previousNodes, nodes) {\n    if (previousNodes.length !== nodes.length) {\n      throw new Error('The number of i18n message children changed between first and second pass.');\n    }\n\n    if (previousNodes.some(function (node, i) {\n      return nodes[i].constructor !== node.constructor;\n    })) {\n      throw new Error('The types of the i18n message children changed between first and second pass.');\n    }\n  }\n  /**\n   * Create a new `ParseSourceSpan` from the `sourceSpan`, offset by the `start` and `end` values.\n   */\n\n\n  function getOffsetSourceSpan(sourceSpan, _a) {\n    var start = _a.start,\n        end = _a.end;\n    return new parse_util_1.ParseSourceSpan(sourceSpan.fullStart.moveBy(start), sourceSpan.fullStart.moveBy(end));\n  }\n\n  var _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\n  function extractPlaceholderName(input) {\n    return input.split(_CUSTOM_PH_EXP)[2];\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/i18n/i18n_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Lexer as ExpressionLexer} from '../expression_parser/lexer';\nimport {InterpolationPiece, Parser as ExpressionParser} from '../expression_parser/parser';\nimport * as html from '../ml_parser/ast';\nimport {getHtmlTagDefinition} from '../ml_parser/html_tags';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as i18n from './i18n_ast';\nimport {PlaceholderRegistry} from './serializers/placeholder';\n\nconst _expParser = new ExpressionParser(new ExpressionLexer());\n\nexport type VisitNodeFn = (html: html.Node, i18n: i18n.Node) => i18n.Node;\n\nexport interface I18nMessageFactory {\n  (nodes: html.Node[], meaning: string|undefined, description: string|undefined,\n   customId: string|undefined, visitNodeFn?: VisitNodeFn): i18n.Message;\n}\n\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\nexport function createI18nMessageFactory(interpolationConfig: InterpolationConfig):\n    I18nMessageFactory {\n  const visitor = new _I18nVisitor(_expParser, interpolationConfig);\n  return (nodes, meaning, description, customId, visitNodeFn) =>\n             visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n}\n\ninterface I18nMessageVisitorContext {\n  isIcu: boolean;\n  icuDepth: number;\n  placeholderRegistry: PlaceholderRegistry;\n  placeholderToContent: {[phName: string]: i18n.MessagePlaceholder};\n  placeholderToMessage: {[phName: string]: i18n.Message};\n  visitNodeFn: VisitNodeFn;\n}\n\nfunction noopVisitNodeFn(_html: html.Node, i18n: i18n.Node): i18n.Node {\n  return i18n;\n}\n\nclass _I18nVisitor implements html.Visitor {\n  constructor(\n      private _expressionParser: ExpressionParser,\n      private _interpolationConfig: InterpolationConfig) {}\n\n  public toI18nMessage(\n      nodes: html.Node[], meaning = '', description = '', customId = '',\n      visitNodeFn: VisitNodeFn|undefined): i18n.Message {\n    const context: I18nMessageVisitorContext = {\n      isIcu: nodes.length == 1 && nodes[0] instanceof html.Expansion,\n      icuDepth: 0,\n      placeholderRegistry: new PlaceholderRegistry(),\n      placeholderToContent: {},\n      placeholderToMessage: {},\n      visitNodeFn: visitNodeFn || noopVisitNodeFn,\n    };\n\n    const i18nodes: i18n.Node[] = html.visitAll(this, nodes, context);\n\n    return new i18n.Message(\n        i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description,\n        customId);\n  }\n\n  visitElement(el: html.Element, context: I18nMessageVisitorContext): i18n.Node {\n    const children = html.visitAll(this, el.children, context);\n    const attrs: {[k: string]: string} = {};\n    el.attrs.forEach(attr => {\n      // Do not visit the attributes, translatable ones are top-level ASTs\n      attrs[attr.name] = attr.value;\n    });\n\n    const isVoid: boolean = getHtmlTagDefinition(el.name).isVoid;\n    const startPhName =\n        context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n    context.placeholderToContent[startPhName] = {\n      text: el.startSourceSpan.toString(),\n      sourceSpan: el.startSourceSpan,\n    };\n\n    let closePhName = '';\n\n    if (!isVoid) {\n      closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n      context.placeholderToContent[closePhName] = {\n        text: `</${el.name}>`,\n        sourceSpan: el.endSourceSpan ?? el.sourceSpan,\n      };\n    }\n\n    const node = new i18n.TagPlaceholder(\n        el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan,\n        el.startSourceSpan, el.endSourceSpan);\n    return context.visitNodeFn(el, node);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: I18nMessageVisitorContext): i18n.Node {\n    const node = this._visitTextWithInterpolation(\n        attribute.value, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n    return context.visitNodeFn(attribute, node);\n  }\n\n  visitText(text: html.Text, context: I18nMessageVisitorContext): i18n.Node {\n    const node = this._visitTextWithInterpolation(text.value, text.sourceSpan, context, text.i18n);\n    return context.visitNodeFn(text, node);\n  }\n\n  visitComment(comment: html.Comment, context: I18nMessageVisitorContext): i18n.Node|null {\n    return null;\n  }\n\n  visitExpansion(icu: html.Expansion, context: I18nMessageVisitorContext): i18n.Node {\n    context.icuDepth++;\n    const i18nIcuCases: {[k: string]: i18n.Node} = {};\n    const i18nIcu = new i18n.Icu(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n    icu.cases.forEach((caze): void => {\n      i18nIcuCases[caze.value] = new i18n.Container(\n          caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);\n    });\n    context.icuDepth--;\n\n    if (context.isIcu || context.icuDepth > 0) {\n      // Returns an ICU node when:\n      // - the message (vs a part of the message) is an ICU message, or\n      // - the ICU message is nested.\n      const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\n      i18nIcu.expressionPlaceholder = expPh;\n      context.placeholderToContent[expPh] = {\n        text: icu.switchValue,\n        sourceSpan: icu.switchValueSourceSpan,\n      };\n      return context.visitNodeFn(icu, i18nIcu);\n    }\n\n    // Else returns a placeholder\n    // ICU placeholders should not be replaced with their original content but with the their\n    // translations.\n    // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n    const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n    context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n    const node = new i18n.IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n    return context.visitNodeFn(icu, node);\n  }\n\n  visitExpansionCase(_icuCase: html.ExpansionCase, _context: I18nMessageVisitorContext): i18n.Node {\n    throw new Error('Unreachable code');\n  }\n\n  /**\n   * Split the, potentially interpolated, text up into text and placeholder pieces.\n   *\n   * @param text The potentially interpolated string to be split.\n   * @param sourceSpan The span of the whole of the `text` string.\n   * @param context The current context of the visitor, used to compute and store placeholders.\n   * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\n   */\n  private _visitTextWithInterpolation(\n      text: string, sourceSpan: ParseSourceSpan, context: I18nMessageVisitorContext,\n      previousI18n: i18n.I18nMeta|undefined): i18n.Node {\n    const {strings, expressions} = this._expressionParser.splitInterpolation(\n        text, sourceSpan.start.toString(), this._interpolationConfig);\n\n    // No expressions, return a single text.\n    if (expressions.length === 0) {\n      return new i18n.Text(text, sourceSpan);\n    }\n\n    // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n    const nodes: i18n.Node[] = [];\n    for (let i = 0; i < strings.length - 1; i++) {\n      this._addText(nodes, strings[i], sourceSpan);\n      this._addPlaceholder(nodes, context, expressions[i], sourceSpan);\n    }\n    // The last index contains no expression\n    this._addText(nodes, strings[strings.length - 1], sourceSpan);\n\n    // Whitespace removal may have invalidated the interpolation source-spans.\n    reusePreviousSourceSpans(nodes, previousI18n);\n\n    return new i18n.Container(nodes, sourceSpan);\n  }\n\n  /**\n   * Create a new `Text` node from the `textPiece` and add it to the `nodes` collection.\n   *\n   * @param nodes The nodes to which the created `Text` node should be added.\n   * @param textPiece The text and relative span information for this `Text` node.\n   * @param interpolationSpan The span of the whole interpolated text.\n   */\n  private _addText(\n      nodes: i18n.Node[], textPiece: InterpolationPiece, interpolationSpan: ParseSourceSpan): void {\n    if (textPiece.text.length > 0) {\n      // No need to add empty strings\n      const stringSpan = getOffsetSourceSpan(interpolationSpan, textPiece);\n      nodes.push(new i18n.Text(textPiece.text, stringSpan));\n    }\n  }\n\n  /**\n   * Create a new `Placeholder` node from the `expression` and add it to the `nodes` collection.\n   *\n   * @param nodes The nodes to which the created `Text` node should be added.\n   * @param context The current context of the visitor, used to compute and store placeholders.\n   * @param expression The expression text and relative span information for this `Placeholder`\n   *     node.\n   * @param interpolationSpan The span of the whole interpolated text.\n   */\n  private _addPlaceholder(\n      nodes: i18n.Node[], context: I18nMessageVisitorContext, expression: InterpolationPiece,\n      interpolationSpan: ParseSourceSpan): void {\n    const sourceSpan = getOffsetSourceSpan(interpolationSpan, expression);\n    const baseName = extractPlaceholderName(expression.text) || 'INTERPOLATION';\n    const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression.text);\n    const text = this._interpolationConfig.start + expression.text + this._interpolationConfig.end;\n    context.placeholderToContent[phName] = {text, sourceSpan};\n    nodes.push(new i18n.Placeholder(expression.text, phName, sourceSpan));\n  }\n}\n\n/**\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\n *\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\n * reuse the source-span stored from a previous pass before the whitespace was removed.\n *\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\n */\nfunction reusePreviousSourceSpans(nodes: i18n.Node[], previousI18n: i18n.I18nMeta|undefined): void {\n  if (previousI18n instanceof i18n.Message) {\n    // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n    // metadata. The `Message` should consist only of a single `Container` that contains the\n    // parts (`Text` and `Placeholder`) to process.\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n\n  if (previousI18n instanceof i18n.Container) {\n    // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n    // after whitespace has been removed from the AST ndoes.\n    assertEquivalentNodes(previousI18n.children, nodes);\n\n    // Reuse the source-spans from the first pass.\n    for (let i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\n\n/**\n * Asserts that the `message` contains exactly one `Container` node.\n */\nfunction assertSingleContainerMessage(message: i18n.Message): void {\n  const nodes = message.nodes;\n  if (nodes.length !== 1 || !(nodes[0] instanceof i18n.Container)) {\n    throw new Error(\n        'Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n  }\n}\n\n/**\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\n * corresponding elements have the same node type.\n */\nfunction assertEquivalentNodes(previousNodes: i18n.Node[], nodes: i18n.Node[]): void {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error('The number of i18n message children changed between first and second pass.');\n  }\n  if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\n    throw new Error(\n        'The types of the i18n message children changed between first and second pass.');\n  }\n}\n\n/**\n * Create a new `ParseSourceSpan` from the `sourceSpan`, offset by the `start` and `end` values.\n */\nfunction getOffsetSourceSpan(\n    sourceSpan: ParseSourceSpan, {start, end}: InterpolationPiece): ParseSourceSpan {\n  return new ParseSourceSpan(sourceSpan.fullStart.moveBy(start), sourceSpan.fullStart.moveBy(end));\n}\n\nconst _CUSTOM_PH_EXP =\n    /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input: string): string {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}