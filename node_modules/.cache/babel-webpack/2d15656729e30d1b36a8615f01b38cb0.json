{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/transform/src/compilation\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/transform/src/api\", \"@angular/compiler-cli/src/ngtsc/transform/src/trait\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TraitCompiler = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/transform/src/api\");\n\n  var trait_1 = require(\"@angular/compiler-cli/src/ngtsc/transform/src/trait\");\n  /**\n   * The heart of Angular compilation.\n   *\n   * The `TraitCompiler` is responsible for processing all classes in the program. Any time a\n   * `DecoratorHandler` matches a class, a \"trait\" is created to represent that Angular aspect of the\n   * class (such as the class having a component definition).\n   *\n   * The `TraitCompiler` transitions each trait through the various phases of compilation, culminating\n   * in the production of `CompileResult`s instructing the compiler to apply various mutations to the\n   * class (like adding fields or type declarations).\n   */\n\n\n  var TraitCompiler =\n  /** @class */\n  function () {\n    function TraitCompiler(handlers, reflector, perf, incrementalBuild, compileNonExportedClasses, compilationMode, dtsTransforms, semanticDepGraphUpdater) {\n      var e_1, _a;\n\n      this.handlers = handlers;\n      this.reflector = reflector;\n      this.perf = perf;\n      this.incrementalBuild = incrementalBuild;\n      this.compileNonExportedClasses = compileNonExportedClasses;\n      this.compilationMode = compilationMode;\n      this.dtsTransforms = dtsTransforms;\n      this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n      /**\n       * Maps class declarations to their `ClassRecord`, which tracks the Ivy traits being applied to\n       * those classes.\n       */\n\n      this.classes = new Map();\n      /**\n       * Maps source files to any class declaration(s) within them which have been discovered to contain\n       * Ivy traits.\n       */\n\n      this.fileToClasses = new Map();\n      this.reexportMap = new Map();\n      this.handlersByName = new Map();\n\n      try {\n        for (var handlers_1 = tslib_1.__values(handlers), handlers_1_1 = handlers_1.next(); !handlers_1_1.done; handlers_1_1 = handlers_1.next()) {\n          var handler = handlers_1_1.value;\n          this.handlersByName.set(handler.name, handler);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (handlers_1_1 && !handlers_1_1.done && (_a = handlers_1.return)) _a.call(handlers_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    TraitCompiler.prototype.analyzeSync = function (sf) {\n      this.analyze(sf, false);\n    };\n\n    TraitCompiler.prototype.analyzeAsync = function (sf) {\n      return this.analyze(sf, true);\n    };\n\n    TraitCompiler.prototype.analyze = function (sf, preanalyze) {\n      var e_2, _a;\n\n      var _this = this; // We shouldn't analyze declaration files.\n\n\n      if (sf.isDeclarationFile) {\n        return undefined;\n      } // analyze() really wants to return `Promise<void>|void`, but TypeScript cannot narrow a return\n      // type of 'void', so `undefined` is used instead.\n\n\n      var promises = [];\n      var priorWork = this.incrementalBuild.priorWorkFor(sf);\n\n      if (priorWork !== null) {\n        try {\n          for (var priorWork_1 = tslib_1.__values(priorWork), priorWork_1_1 = priorWork_1.next(); !priorWork_1_1.done; priorWork_1_1 = priorWork_1.next()) {\n            var priorRecord = priorWork_1_1.value;\n            this.adopt(priorRecord);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (priorWork_1_1 && !priorWork_1_1.done && (_a = priorWork_1.return)) _a.call(priorWork_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        this.perf.eventCount(perf_1.PerfEvent.SourceFileReuseAnalysis);\n        this.perf.eventCount(perf_1.PerfEvent.TraitReuseAnalysis, priorWork.length); // Skip the rest of analysis, as this file's prior traits are being reused.\n\n        return;\n      }\n\n      var visit = function visit(node) {\n        if (_this.reflector.isClass(node)) {\n          _this.analyzeClass(node, preanalyze ? promises : null);\n        }\n\n        ts.forEachChild(node, visit);\n      };\n\n      visit(sf);\n\n      if (preanalyze && promises.length > 0) {\n        return Promise.all(promises).then(function () {\n          return undefined;\n        });\n      } else {\n        return undefined;\n      }\n    };\n\n    TraitCompiler.prototype.recordFor = function (clazz) {\n      if (this.classes.has(clazz)) {\n        return this.classes.get(clazz);\n      } else {\n        return null;\n      }\n    };\n\n    TraitCompiler.prototype.recordsFor = function (sf) {\n      var e_3, _a;\n\n      if (!this.fileToClasses.has(sf)) {\n        return null;\n      }\n\n      var records = [];\n\n      try {\n        for (var _b = tslib_1.__values(this.fileToClasses.get(sf)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var clazz = _c.value;\n          records.push(this.classes.get(clazz));\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return records;\n    };\n    /**\n     * Import a `ClassRecord` from a previous compilation.\n     *\n     * Traits from the `ClassRecord` have accurate metadata, but the `handler` is from the old program\n     * and needs to be updated (matching is done by name). A new pending trait is created and then\n     * transitioned to analyzed using the previous analysis. If the trait is in the errored state,\n     * instead the errors are copied over.\n     */\n\n\n    TraitCompiler.prototype.adopt = function (priorRecord) {\n      var e_4, _a;\n\n      var record = {\n        hasPrimaryHandler: priorRecord.hasPrimaryHandler,\n        hasWeakHandlers: priorRecord.hasWeakHandlers,\n        metaDiagnostics: priorRecord.metaDiagnostics,\n        node: priorRecord.node,\n        traits: []\n      };\n\n      try {\n        for (var _b = tslib_1.__values(priorRecord.traits), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var priorTrait = _c.value;\n          var handler = this.handlersByName.get(priorTrait.handler.name);\n          var trait = trait_1.Trait.pending(handler, priorTrait.detected);\n\n          if (priorTrait.state === trait_1.TraitState.Analyzed || priorTrait.state === trait_1.TraitState.Resolved) {\n            var symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);\n            trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);\n\n            if (trait.analysis !== null && trait.handler.register !== undefined) {\n              trait.handler.register(record.node, trait.analysis);\n            }\n          } else if (priorTrait.state === trait_1.TraitState.Skipped) {\n            trait = trait.toSkipped();\n          }\n\n          record.traits.push(trait);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      this.classes.set(record.node, record);\n      var sf = record.node.getSourceFile();\n\n      if (!this.fileToClasses.has(sf)) {\n        this.fileToClasses.set(sf, new Set());\n      }\n\n      this.fileToClasses.get(sf).add(record.node);\n    };\n\n    TraitCompiler.prototype.scanClassForTraits = function (clazz) {\n      if (!this.compileNonExportedClasses && !typescript_1.isExported(clazz)) {\n        return null;\n      }\n\n      var decorators = this.reflector.getDecoratorsOfDeclaration(clazz);\n      return this.detectTraits(clazz, decorators);\n    };\n\n    TraitCompiler.prototype.detectTraits = function (clazz, decorators) {\n      var e_5, _a;\n\n      var record = this.recordFor(clazz);\n      var foundTraits = [];\n\n      try {\n        for (var _b = tslib_1.__values(this.handlers), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var handler = _c.value;\n          var result = handler.detect(clazz, decorators);\n\n          if (result === undefined) {\n            continue;\n          }\n\n          var isPrimaryHandler = handler.precedence === api_1.HandlerPrecedence.PRIMARY;\n          var isWeakHandler = handler.precedence === api_1.HandlerPrecedence.WEAK;\n          var trait = trait_1.Trait.pending(handler, result);\n          foundTraits.push(trait);\n\n          if (record === null) {\n            // This is the first handler to match this class. This path is a fast path through which\n            // most classes will flow.\n            record = {\n              node: clazz,\n              traits: [trait],\n              metaDiagnostics: null,\n              hasPrimaryHandler: isPrimaryHandler,\n              hasWeakHandlers: isWeakHandler\n            };\n            this.classes.set(clazz, record);\n            var sf = clazz.getSourceFile();\n\n            if (!this.fileToClasses.has(sf)) {\n              this.fileToClasses.set(sf, new Set());\n            }\n\n            this.fileToClasses.get(sf).add(clazz);\n          } else {\n            // This is at least the second handler to match this class. This is a slower path that some\n            // classes will go through, which validates that the set of decorators applied to the class\n            // is valid.\n            // Validate according to rules as follows:\n            //\n            // * WEAK handlers are removed if a non-WEAK handler matches.\n            // * Only one PRIMARY handler can match at a time. Any other PRIMARY handler matching a\n            //   class with an existing PRIMARY handler is an error.\n            if (!isWeakHandler && record.hasWeakHandlers) {\n              // The current handler is not a WEAK handler, but the class has other WEAK handlers.\n              // Remove them.\n              record.traits = record.traits.filter(function (field) {\n                return field.handler.precedence !== api_1.HandlerPrecedence.WEAK;\n              });\n              record.hasWeakHandlers = false;\n            } else if (isWeakHandler && !record.hasWeakHandlers) {\n              // The current handler is a WEAK handler, but the class has non-WEAK handlers already.\n              // Drop the current one.\n              continue;\n            }\n\n            if (isPrimaryHandler && record.hasPrimaryHandler) {\n              // The class already has a PRIMARY handler, and another one just matched.\n              record.metaDiagnostics = [{\n                category: ts.DiagnosticCategory.Error,\n                code: Number('-99' + diagnostics_1.ErrorCode.DECORATOR_COLLISION),\n                file: typescript_1.getSourceFile(clazz),\n                start: clazz.getStart(undefined, false),\n                length: clazz.getWidth(),\n                messageText: 'Two incompatible decorators on class'\n              }];\n              record.traits = foundTraits = [];\n              break;\n            } // Otherwise, it's safe to accept the multiple decorators here. Update some of the metadata\n            // regarding this class.\n\n\n            record.traits.push(trait);\n            record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;\n          }\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      return foundTraits.length > 0 ? foundTraits : null;\n    };\n\n    TraitCompiler.prototype.makeSymbolForTrait = function (handler, decl, analysis) {\n      if (analysis === null) {\n        return null;\n      }\n\n      var symbol = handler.symbol(decl, analysis);\n\n      if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n        var isPrimary = handler.precedence === api_1.HandlerPrecedence.PRIMARY;\n\n        if (!isPrimary) {\n          throw new Error(\"AssertionError: \" + handler.name + \" returned a symbol but is not a primary handler.\");\n        }\n\n        this.semanticDepGraphUpdater.registerSymbol(symbol);\n      }\n\n      return symbol;\n    };\n\n    TraitCompiler.prototype.analyzeClass = function (clazz, preanalyzeQueue) {\n      var e_6, _a;\n\n      var _this = this;\n\n      var traits = this.scanClassForTraits(clazz);\n\n      if (traits === null) {\n        // There are no Ivy traits on the class, so it can safely be skipped.\n        return;\n      }\n\n      var _loop_1 = function _loop_1(trait) {\n        var analyze = function analyze() {\n          return _this.analyzeTrait(clazz, trait);\n        };\n\n        var preanalysis = null;\n\n        if (preanalyzeQueue !== null && trait.handler.preanalyze !== undefined) {\n          // Attempt to run preanalysis. This could fail with a `FatalDiagnosticError`; catch it if it\n          // does.\n          try {\n            preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n          } catch (err) {\n            if (err instanceof diagnostics_1.FatalDiagnosticError) {\n              trait.toAnalyzed(null, [err.toDiagnostic()], null);\n              return {\n                value: void 0\n              };\n            } else {\n              throw err;\n            }\n          }\n        }\n\n        if (preanalysis !== null) {\n          preanalyzeQueue.push(preanalysis.then(analyze));\n        } else {\n          analyze();\n        }\n      };\n\n      try {\n        for (var traits_1 = tslib_1.__values(traits), traits_1_1 = traits_1.next(); !traits_1_1.done; traits_1_1 = traits_1.next()) {\n          var trait = traits_1_1.value;\n\n          var state_1 = _loop_1(trait);\n\n          if (typeof state_1 === \"object\") return state_1.value;\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (traits_1_1 && !traits_1_1.done && (_a = traits_1.return)) _a.call(traits_1);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n    };\n\n    TraitCompiler.prototype.analyzeTrait = function (clazz, trait, flags) {\n      var _a, _b, _c;\n\n      if (trait.state !== trait_1.TraitState.Pending) {\n        throw new Error(\"Attempt to analyze trait of \" + clazz.name.text + \" in state \" + trait_1.TraitState[trait.state] + \" (expected DETECTED)\");\n      }\n\n      this.perf.eventCount(perf_1.PerfEvent.TraitAnalyze); // Attempt analysis. This could fail with a `FatalDiagnosticError`; catch it if it does.\n\n      var result;\n\n      try {\n        result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n      } catch (err) {\n        if (err instanceof diagnostics_1.FatalDiagnosticError) {\n          trait.toAnalyzed(null, [err.toDiagnostic()], null);\n          return;\n        } else {\n          throw err;\n        }\n      }\n\n      var symbol = this.makeSymbolForTrait(trait.handler, clazz, (_a = result.analysis) !== null && _a !== void 0 ? _a : null);\n\n      if (result.analysis !== undefined && trait.handler.register !== undefined) {\n        trait.handler.register(clazz, result.analysis);\n      }\n\n      trait = trait.toAnalyzed((_b = result.analysis) !== null && _b !== void 0 ? _b : null, (_c = result.diagnostics) !== null && _c !== void 0 ? _c : null, symbol);\n    };\n\n    TraitCompiler.prototype.resolve = function () {\n      var e_7, _a, e_8, _b, e_9, _c;\n\n      var _d, _e;\n\n      var classes = Array.from(this.classes.keys());\n\n      try {\n        for (var classes_1 = tslib_1.__values(classes), classes_1_1 = classes_1.next(); !classes_1_1.done; classes_1_1 = classes_1.next()) {\n          var clazz = classes_1_1.value;\n          var record = this.classes.get(clazz);\n\n          try {\n            for (var _f = (e_8 = void 0, tslib_1.__values(record.traits)), _g = _f.next(); !_g.done; _g = _f.next()) {\n              var trait = _g.value;\n              var handler = trait.handler;\n\n              switch (trait.state) {\n                case trait_1.TraitState.Skipped:\n                  continue;\n\n                case trait_1.TraitState.Pending:\n                  throw new Error(\"Resolving a trait that hasn't been analyzed: \" + clazz.name.text + \" / \" + Object.getPrototypeOf(trait.handler).constructor.name);\n\n                case trait_1.TraitState.Resolved:\n                  throw new Error(\"Resolving an already resolved trait\");\n              }\n\n              if (trait.analysis === null) {\n                // No analysis results, cannot further process this trait.\n                continue;\n              }\n\n              if (handler.resolve === undefined) {\n                // No resolution of this trait needed - it's considered successful by default.\n                trait = trait.toResolved(null, null);\n                continue;\n              }\n\n              var result = void 0;\n\n              try {\n                result = handler.resolve(clazz, trait.analysis, trait.symbol);\n              } catch (err) {\n                if (err instanceof diagnostics_1.FatalDiagnosticError) {\n                  trait = trait.toResolved(null, [err.toDiagnostic()]);\n                  continue;\n                } else {\n                  throw err;\n                }\n              }\n\n              trait = trait.toResolved((_d = result.data) !== null && _d !== void 0 ? _d : null, (_e = result.diagnostics) !== null && _e !== void 0 ? _e : null);\n\n              if (result.reexports !== undefined) {\n                var fileName = clazz.getSourceFile().fileName;\n\n                if (!this.reexportMap.has(fileName)) {\n                  this.reexportMap.set(fileName, new Map());\n                }\n\n                var fileReexports = this.reexportMap.get(fileName);\n\n                try {\n                  for (var _h = (e_9 = void 0, tslib_1.__values(result.reexports)), _j = _h.next(); !_j.done; _j = _h.next()) {\n                    var reexport = _j.value;\n                    fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);\n                  }\n                } catch (e_9_1) {\n                  e_9 = {\n                    error: e_9_1\n                  };\n                } finally {\n                  try {\n                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n                  } finally {\n                    if (e_9) throw e_9.error;\n                  }\n                }\n              }\n            }\n          } catch (e_8_1) {\n            e_8 = {\n              error: e_8_1\n            };\n          } finally {\n            try {\n              if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n            } finally {\n              if (e_8) throw e_8.error;\n            }\n          }\n        }\n      } catch (e_7_1) {\n        e_7 = {\n          error: e_7_1\n        };\n      } finally {\n        try {\n          if (classes_1_1 && !classes_1_1.done && (_a = classes_1.return)) _a.call(classes_1);\n        } finally {\n          if (e_7) throw e_7.error;\n        }\n      }\n    };\n    /**\n     * Generate type-checking code into the `TypeCheckContext` for any components within the given\n     * `ts.SourceFile`.\n     */\n\n\n    TraitCompiler.prototype.typeCheck = function (sf, ctx) {\n      var e_10, _a, e_11, _b;\n\n      if (!this.fileToClasses.has(sf)) {\n        return;\n      }\n\n      try {\n        for (var _c = tslib_1.__values(this.fileToClasses.get(sf)), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var clazz = _d.value;\n          var record = this.classes.get(clazz);\n\n          try {\n            for (var _e = (e_11 = void 0, tslib_1.__values(record.traits)), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var trait = _f.value;\n\n              if (trait.state !== trait_1.TraitState.Resolved) {\n                continue;\n              } else if (trait.handler.typeCheck === undefined) {\n                continue;\n              }\n\n              if (trait.resolution !== null) {\n                trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n              }\n            }\n          } catch (e_11_1) {\n            e_11 = {\n              error: e_11_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_11) throw e_11.error;\n            }\n          }\n        }\n      } catch (e_10_1) {\n        e_10 = {\n          error: e_10_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_10) throw e_10.error;\n        }\n      }\n    };\n\n    TraitCompiler.prototype.index = function (ctx) {\n      var e_12, _a, e_13, _b;\n\n      try {\n        for (var _c = tslib_1.__values(this.classes.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var clazz = _d.value;\n          var record = this.classes.get(clazz);\n\n          try {\n            for (var _e = (e_13 = void 0, tslib_1.__values(record.traits)), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var trait = _f.value;\n\n              if (trait.state !== trait_1.TraitState.Resolved) {\n                // Skip traits that haven't been resolved successfully.\n                continue;\n              } else if (trait.handler.index === undefined) {\n                // Skip traits that don't affect indexing.\n                continue;\n              }\n\n              if (trait.resolution !== null) {\n                trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n              }\n            }\n          } catch (e_13_1) {\n            e_13 = {\n              error: e_13_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_13) throw e_13.error;\n            }\n          }\n        }\n      } catch (e_12_1) {\n        e_12 = {\n          error: e_12_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_12) throw e_12.error;\n        }\n      }\n    };\n\n    TraitCompiler.prototype.updateResources = function (clazz) {\n      var e_14, _a;\n\n      if (!this.reflector.isClass(clazz) || !this.classes.has(clazz)) {\n        return;\n      }\n\n      var record = this.classes.get(clazz);\n\n      try {\n        for (var _b = tslib_1.__values(record.traits), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var trait = _c.value;\n\n          if (trait.state !== trait_1.TraitState.Resolved || trait.handler.updateResources === undefined) {\n            continue;\n          }\n\n          trait.handler.updateResources(clazz, trait.analysis, trait.resolution);\n        }\n      } catch (e_14_1) {\n        e_14 = {\n          error: e_14_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_14) throw e_14.error;\n        }\n      }\n    };\n\n    TraitCompiler.prototype.compile = function (clazz, constantPool) {\n      var e_15, _a;\n\n      var original = ts.getOriginalNode(clazz);\n\n      if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) || !this.classes.has(original)) {\n        return null;\n      }\n\n      var record = this.classes.get(original);\n      var res = [];\n\n      var _loop_2 = function _loop_2(trait) {\n        var e_16, _a;\n\n        if (trait.state !== trait_1.TraitState.Resolved || trait.analysisDiagnostics !== null || trait.resolveDiagnostics !== null) {\n          return \"continue\";\n        } // `trait.resolution` is non-null asserted here because TypeScript does not recognize that\n        // `Readonly<unknown>` is nullable (as `unknown` itself is nullable) due to the way that\n        // `Readonly` works.\n\n\n        var compileRes = void 0;\n\n        if (this_1.compilationMode === api_1.CompilationMode.PARTIAL && trait.handler.compilePartial !== undefined) {\n          compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution);\n        } else {\n          compileRes = trait.handler.compileFull(clazz, trait.analysis, trait.resolution, constantPool);\n        }\n\n        var compileMatchRes = compileRes;\n\n        if (Array.isArray(compileMatchRes)) {\n          var _loop_3 = function _loop_3(result) {\n            if (!res.some(function (r) {\n              return r.name === result.name;\n            })) {\n              res.push(result);\n            }\n          };\n\n          try {\n            for (var compileMatchRes_1 = (e_16 = void 0, tslib_1.__values(compileMatchRes)), compileMatchRes_1_1 = compileMatchRes_1.next(); !compileMatchRes_1_1.done; compileMatchRes_1_1 = compileMatchRes_1.next()) {\n              var result = compileMatchRes_1_1.value;\n\n              _loop_3(result);\n            }\n          } catch (e_16_1) {\n            e_16 = {\n              error: e_16_1\n            };\n          } finally {\n            try {\n              if (compileMatchRes_1_1 && !compileMatchRes_1_1.done && (_a = compileMatchRes_1.return)) _a.call(compileMatchRes_1);\n            } finally {\n              if (e_16) throw e_16.error;\n            }\n          }\n        } else if (!res.some(function (result) {\n          return result.name === compileMatchRes.name;\n        })) {\n          res.push(compileMatchRes);\n        }\n      };\n\n      var this_1 = this;\n\n      try {\n        for (var _b = tslib_1.__values(record.traits), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var trait = _c.value;\n\n          _loop_2(trait);\n        }\n      } catch (e_15_1) {\n        e_15 = {\n          error: e_15_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_15) throw e_15.error;\n        }\n      } // Look up the .d.ts transformer for the input file and record that at least one field was\n      // generated, which will allow the .d.ts to be transformed later.\n\n\n      this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile()).addFields(original, res); // Return the instruction to the transformer so the fields will be added.\n\n      return res.length > 0 ? res : null;\n    };\n\n    TraitCompiler.prototype.decoratorsFor = function (node) {\n      var e_17, _a;\n\n      var original = ts.getOriginalNode(node);\n\n      if (!this.reflector.isClass(original) || !this.classes.has(original)) {\n        return [];\n      }\n\n      var record = this.classes.get(original);\n      var decorators = [];\n\n      try {\n        for (var _b = tslib_1.__values(record.traits), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var trait = _c.value;\n\n          if (trait.state !== trait_1.TraitState.Resolved) {\n            continue;\n          }\n\n          if (trait.detected.trigger !== null && ts.isDecorator(trait.detected.trigger)) {\n            decorators.push(trait.detected.trigger);\n          }\n        }\n      } catch (e_17_1) {\n        e_17 = {\n          error: e_17_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_17) throw e_17.error;\n        }\n      }\n\n      return decorators;\n    };\n\n    Object.defineProperty(TraitCompiler.prototype, \"diagnostics\", {\n      get: function get() {\n        var e_18, _a, e_19, _b;\n\n        var diagnostics = [];\n\n        try {\n          for (var _c = tslib_1.__values(this.classes.keys()), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var clazz = _d.value;\n            var record = this.classes.get(clazz);\n\n            if (record.metaDiagnostics !== null) {\n              diagnostics.push.apply(diagnostics, tslib_1.__spread(record.metaDiagnostics));\n            }\n\n            try {\n              for (var _e = (e_19 = void 0, tslib_1.__values(record.traits)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var trait = _f.value;\n\n                if ((trait.state === trait_1.TraitState.Analyzed || trait.state === trait_1.TraitState.Resolved) && trait.analysisDiagnostics !== null) {\n                  diagnostics.push.apply(diagnostics, tslib_1.__spread(trait.analysisDiagnostics));\n                }\n\n                if (trait.state === trait_1.TraitState.Resolved && trait.resolveDiagnostics !== null) {\n                  diagnostics.push.apply(diagnostics, tslib_1.__spread(trait.resolveDiagnostics));\n                }\n              }\n            } catch (e_19_1) {\n              e_19 = {\n                error: e_19_1\n              };\n            } finally {\n              try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n              } finally {\n                if (e_19) throw e_19.error;\n              }\n            }\n          }\n        } catch (e_18_1) {\n          e_18 = {\n            error: e_18_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_18) throw e_18.error;\n          }\n        }\n\n        return diagnostics;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(TraitCompiler.prototype, \"exportStatements\", {\n      get: function get() {\n        return this.reexportMap;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return TraitCompiler;\n  }();\n\n  exports.TraitCompiler = TraitCompiler;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/compilation.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAGH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AAIA,MAAA,MAAA,GAAA,OAAA,CAAA,sCAAA,CAAA;;AAGA,MAAA,YAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AAEA,MAAA,KAAA,GAAA,OAAA,CAAA,mDAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;AAqCA;;;;;;;;;;AAUG;;;AACH,MAAA,aAAA;AAAA;AAAA,cAAA;AAkBE,aAAA,aAAA,CACY,QADZ,EAEY,SAFZ,EAE+C,IAF/C,EAGY,gBAHZ,EAIY,yBAJZ,EAIwD,eAJxD,EAKY,aALZ,EAMY,uBANZ,EAMiE;;;AALrD,WAAA,QAAA,GAAA,QAAA;AACA,WAAA,SAAA,GAAA,SAAA;AAAmC,WAAA,IAAA,GAAA,IAAA;AACnC,WAAA,gBAAA,GAAA,gBAAA;AACA,WAAA,yBAAA,GAAA,yBAAA;AAA4C,WAAA,eAAA,GAAA,eAAA;AAC5C,WAAA,aAAA,GAAA,aAAA;AACA,WAAA,uBAAA,GAAA,uBAAA;AAvBZ;;;AAGG;;AACK,WAAA,OAAA,GAAU,IAAI,GAAJ,EAAV;AAER;;;AAGG;;AACO,WAAA,aAAA,GAAgB,IAAI,GAAJ,EAAhB;AAEF,WAAA,WAAA,GAAc,IAAI,GAAJ,EAAd;AAEA,WAAA,cAAA,GACJ,IAAI,GAAJ,EADI;;;AAUN,aAAsB,IAAA,UAAA,GAAA,OAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAA8B,CAAA,YAAA,CAAA,IAA9B,EAA8B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAAgC;AAA3B,cAAM,OAAO,GAAA,YAAA,CAAA,KAAb;AACH,eAAK,cAAL,CAAoB,GAApB,CAAwB,OAAO,CAAC,IAAhC,EAAsC,OAAtC;AACD;;;;;;;;;;;;AACF;;AAED,IAAA,aAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,EAAZ,EAA6B;AAC3B,WAAK,OAAL,CAAa,EAAb,EAAiB,KAAjB;AACD,KAFD;;AAIA,IAAA,aAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,EAAb,EAA8B;AAC5B,aAAO,KAAK,OAAL,CAAa,EAAb,EAAiB,IAAjB,CAAP;AACD,KAFD;;AAMQ,IAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAR,UAAgB,EAAhB,EAAmC,UAAnC,EAAsD;;;AAAtD,UAAA,KAAA,GAAA,IAAA,CAAsD,CACpD;;;AACA,UAAI,EAAE,CAAC,iBAAP,EAA0B;AACxB,eAAO,SAAP;AACD,OAJmD,CAMpD;AACA;;;AACA,UAAM,QAAQ,GAAoB,EAAlC;AAEA,UAAM,SAAS,GAAG,KAAK,gBAAL,CAAsB,YAAtB,CAAmC,EAAnC,CAAlB;;AACA,UAAI,SAAS,KAAK,IAAlB,EAAwB;;AACtB,eAA0B,IAAA,WAAA,GAAA,OAAA,CAAA,QAAA,CAAA,SAAA,CAAA,EAAS,aAAA,GAAA,WAAA,CAAA,IAAA,EAAnC,EAAmC,CAAA,aAAA,CAAA,IAAnC,EAAmC,aAAA,GAAA,WAAA,CAAA,IAAA,EAAnC,EAAqC;AAAhC,gBAAM,WAAW,GAAA,aAAA,CAAA,KAAjB;AACH,iBAAK,KAAL,CAAW,WAAX;AACD;;;;;;;;;;;;;AAED,aAAK,IAAL,CAAU,UAAV,CAAqB,MAAA,CAAA,SAAA,CAAU,uBAA/B;AACA,aAAK,IAAL,CAAU,UAAV,CAAqB,MAAA,CAAA,SAAA,CAAU,kBAA/B,EAAmD,SAAS,CAAC,MAA7D,EANsB,CAQtB;;AACA;AACD;;AAED,UAAM,KAAK,GAAG,SAAR,KAAQ,CAAC,IAAD,EAAc;AAC1B,YAAI,KAAI,CAAC,SAAL,CAAe,OAAf,CAAuB,IAAvB,CAAJ,EAAkC;AAChC,UAAA,KAAI,CAAC,YAAL,CAAkB,IAAlB,EAAwB,UAAU,GAAG,QAAH,GAAc,IAAhD;AACD;;AACD,QAAA,EAAE,CAAC,YAAH,CAAgB,IAAhB,EAAsB,KAAtB;AACD,OALD;;AAOA,MAAA,KAAK,CAAC,EAAD,CAAL;;AAEA,UAAI,UAAU,IAAI,QAAQ,CAAC,MAAT,GAAkB,CAApC,EAAuC;AACrC,eAAO,OAAO,CAAC,GAAR,CAAY,QAAZ,EAAsB,IAAtB,CAA2B,YAAA;AAAM,iBAAA,SAAA;AAAiB,SAAlD,CAAP;AACD,OAFD,MAEO;AACL,eAAO,SAAP;AACD;AACF,KArCO;;AAuCR,IAAA,aAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,KAAV,EAAiC;AAC/B,UAAI,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAJ,EAA6B;AAC3B,eAAO,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAP;AACD,OAFD,MAEO;AACL,eAAO,IAAP;AACD;AACF,KAND;;AAQA,IAAA,aAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,EAAX,EAA4B;;;AAC1B,UAAI,CAAC,KAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,CAAL,EAAiC;AAC/B,eAAO,IAAP;AACD;;AACD,UAAM,OAAO,GAAkB,EAA/B;;;AACA,aAAoB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,CAAA,CAAA,EAA2B,EAAA,GAAA,EAAA,CAAA,IAAA,EAA/C,EAA+C,CAAA,EAAA,CAAA,IAA/C,EAA+C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA/C,EAAiD;AAA5C,cAAM,KAAK,GAAA,EAAA,CAAA,KAAX;AACH,UAAA,OAAO,CAAC,IAAR,CAAa,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAb;AACD;;;;;;;;;;;;;AACD,aAAO,OAAP;AACD,KATD;AAWA;;;;;;;AAOG;;;AACK,IAAA,aAAA,CAAA,SAAA,CAAA,KAAA,GAAR,UAAc,WAAd,EAAsC;;;AACpC,UAAM,MAAM,GAAgB;AAC1B,QAAA,iBAAiB,EAAE,WAAW,CAAC,iBADL;AAE1B,QAAA,eAAe,EAAE,WAAW,CAAC,eAFH;AAG1B,QAAA,eAAe,EAAE,WAAW,CAAC,eAHH;AAI1B,QAAA,IAAI,EAAE,WAAW,CAAC,IAJQ;AAK1B,QAAA,MAAM,EAAE;AALkB,OAA5B;;;AAQA,aAAyB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,WAAW,CAAC,MAAZ,CAAA,EAAkB,EAAA,GAAA,EAAA,CAAA,IAAA,EAA3C,EAA2C,CAAA,EAAA,CAAA,IAA3C,EAA2C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA3C,EAA6C;AAAxC,cAAM,UAAU,GAAA,EAAA,CAAA,KAAhB;AACH,cAAM,OAAO,GAAG,KAAK,cAAL,CAAoB,GAApB,CAAwB,UAAU,CAAC,OAAX,CAAmB,IAA3C,CAAhB;AACA,cAAI,KAAK,GACL,OAAA,CAAA,KAAA,CAAM,OAAN,CAAc,OAAd,EAAuB,UAAU,CAAC,QAAlC,CADJ;;AAGA,cAAI,UAAU,CAAC,KAAX,KAAqB,OAAA,CAAA,UAAA,CAAW,QAAhC,IAA4C,UAAU,CAAC,KAAX,KAAqB,OAAA,CAAA,UAAA,CAAW,QAAhF,EAA0F;AACxF,gBAAM,MAAM,GAAG,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,MAAM,CAAC,IAAxC,EAA8C,UAAU,CAAC,QAAzD,CAAf;AACA,YAAA,KAAK,GAAG,KAAK,CAAC,UAAN,CAAiB,UAAU,CAAC,QAA5B,EAAsC,UAAU,CAAC,mBAAjD,EAAsE,MAAtE,CAAR;;AACA,gBAAI,KAAK,CAAC,QAAN,KAAmB,IAAnB,IAA2B,KAAK,CAAC,OAAN,CAAc,QAAd,KAA2B,SAA1D,EAAqE;AACnE,cAAA,KAAK,CAAC,OAAN,CAAc,QAAd,CAAuB,MAAM,CAAC,IAA9B,EAAoC,KAAK,CAAC,QAA1C;AACD;AACF,WAND,MAMO,IAAI,UAAU,CAAC,KAAX,KAAqB,OAAA,CAAA,UAAA,CAAW,OAApC,EAA6C;AAClD,YAAA,KAAK,GAAG,KAAK,CAAC,SAAN,EAAR;AACD;;AAED,UAAA,MAAM,CAAC,MAAP,CAAc,IAAd,CAAmB,KAAnB;AACD;;;;;;;;;;;;;AAED,WAAK,OAAL,CAAa,GAAb,CAAiB,MAAM,CAAC,IAAxB,EAA8B,MAA9B;AACA,UAAM,EAAE,GAAG,MAAM,CAAC,IAAP,CAAY,aAAZ,EAAX;;AACA,UAAI,CAAC,KAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,CAAL,EAAiC;AAC/B,aAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,EAA2B,IAAI,GAAJ,EAA3B;AACD;;AACD,WAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,EAA4B,GAA5B,CAAgC,MAAM,CAAC,IAAvC;AACD,KAjCO;;AAmCA,IAAA,aAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,KAA3B,EAAkD;AAEhD,UAAI,CAAC,KAAK,yBAAN,IAAmC,CAAC,YAAA,CAAA,UAAA,CAAW,KAAX,CAAxC,EAA2D;AACzD,eAAO,IAAP;AACD;;AAED,UAAM,UAAU,GAAG,KAAK,SAAL,CAAe,0BAAf,CAA0C,KAA1C,CAAnB;AAEA,aAAO,KAAK,YAAL,CAAkB,KAAlB,EAAyB,UAAzB,CAAP;AACD,KATO;;AAWE,IAAA,aAAA,CAAA,SAAA,CAAA,YAAA,GAAV,UAAuB,KAAvB,EAAgD,UAAhD,EAA4E;;;AAE1E,UAAI,MAAM,GAAqB,KAAK,SAAL,CAAe,KAAf,CAA/B;AACA,UAAI,WAAW,GAAmE,EAAlF;;;AAEA,aAAsB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,QAAL,CAAA,EAAa,EAAA,GAAA,EAAA,CAAA,IAAA,EAAnC,EAAmC,CAAA,EAAA,CAAA,IAAnC,EAAmC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAnC,EAAqC;AAAhC,cAAM,OAAO,GAAA,EAAA,CAAA,KAAb;AACH,cAAM,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,KAAf,EAAsB,UAAtB,CAAf;;AACA,cAAI,MAAM,KAAK,SAAf,EAA0B;AACxB;AACD;;AAED,cAAM,gBAAgB,GAAG,OAAO,CAAC,UAAR,KAAuB,KAAA,CAAA,iBAAA,CAAkB,OAAlE;AACA,cAAM,aAAa,GAAG,OAAO,CAAC,UAAR,KAAuB,KAAA,CAAA,iBAAA,CAAkB,IAA/D;AACA,cAAM,KAAK,GAAG,OAAA,CAAA,KAAA,CAAM,OAAN,CAAc,OAAd,EAAuB,MAAvB,CAAd;AAEA,UAAA,WAAW,CAAC,IAAZ,CAAiB,KAAjB;;AAEA,cAAI,MAAM,KAAK,IAAf,EAAqB;AACnB;AACA;AACA,YAAA,MAAM,GAAG;AACP,cAAA,IAAI,EAAE,KADC;AAEP,cAAA,MAAM,EAAE,CAAC,KAAD,CAFD;AAGP,cAAA,eAAe,EAAE,IAHV;AAIP,cAAA,iBAAiB,EAAE,gBAJZ;AAKP,cAAA,eAAe,EAAE;AALV,aAAT;AAQA,iBAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,EAAwB,MAAxB;AACA,gBAAM,EAAE,GAAG,KAAK,CAAC,aAAN,EAAX;;AACA,gBAAI,CAAC,KAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,CAAL,EAAiC;AAC/B,mBAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,EAA2B,IAAI,GAAJ,EAA3B;AACD;;AACD,iBAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,EAA4B,GAA5B,CAAgC,KAAhC;AACD,WAjBD,MAiBO;AACL;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA,gBAAI,CAAC,aAAD,IAAkB,MAAM,CAAC,eAA7B,EAA8C;AAC5C;AACA;AACA,cAAA,MAAM,CAAC,MAAP,GACI,MAAM,CAAC,MAAP,CAAc,MAAd,CAAqB,UAAA,KAAA,EAAK;AAAI,uBAAA,KAAK,CAAC,OAAN,CAAc,UAAd,KAA6B,KAAA,CAAA,iBAAA,CAA7B,IAAA;AAAmD,eAAjF,CADJ;AAEA,cAAA,MAAM,CAAC,eAAP,GAAyB,KAAzB;AACD,aAND,MAMO,IAAI,aAAa,IAAI,CAAC,MAAM,CAAC,eAA7B,EAA8C;AACnD;AACA;AACA;AACD;;AAED,gBAAI,gBAAgB,IAAI,MAAM,CAAC,iBAA/B,EAAkD;AAChD;AACA,cAAA,MAAM,CAAC,eAAP,GAAyB,CAAC;AACxB,gBAAA,QAAQ,EAAE,EAAE,CAAC,kBAAH,CAAsB,KADR;AAExB,gBAAA,IAAI,EAAE,MAAM,CAAC,QAAQ,aAAA,CAAA,SAAA,CAAU,mBAAnB,CAFY;AAGxB,gBAAA,IAAI,EAAE,YAAA,CAAA,aAAA,CAAc,KAAd,CAHkB;AAIxB,gBAAA,KAAK,EAAE,KAAK,CAAC,QAAN,CAAe,SAAf,EAA0B,KAA1B,CAJiB;AAKxB,gBAAA,MAAM,EAAE,KAAK,CAAC,QAAN,EALgB;AAMxB,gBAAA,WAAW,EAAE;AANW,eAAD,CAAzB;AAQA,cAAA,MAAM,CAAC,MAAP,GAAgB,WAAW,GAAG,EAA9B;AACA;AACD,aAnCI,CAqCL;AACA;;;AACA,YAAA,MAAM,CAAC,MAAP,CAAc,IAAd,CAAmB,KAAnB;AACA,YAAA,MAAM,CAAC,iBAAP,GAA2B,MAAM,CAAC,iBAAP,IAA4B,gBAAvD;AACD;AACF;;;;;;;;;;;;;AAED,aAAO,WAAW,CAAC,MAAZ,GAAqB,CAArB,GAAyB,WAAzB,GAAuC,IAA9C;AACD,KA/ES;;AAiFF,IAAA,aAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UACI,OADJ,EAEI,IAFJ,EAE4B,QAF5B,EAE4D;AAC1D,UAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,eAAO,IAAP;AACD;;AACD,UAAM,MAAM,GAAG,OAAO,CAAC,MAAR,CAAe,IAAf,EAAqB,QAArB,CAAf;;AACA,UAAI,MAAM,KAAK,IAAX,IAAmB,KAAK,uBAAL,KAAiC,IAAxD,EAA8D;AAC5D,YAAM,SAAS,GAAG,OAAO,CAAC,UAAR,KAAuB,KAAA,CAAA,iBAAA,CAAkB,OAA3D;;AACA,YAAI,CAAC,SAAL,EAAgB;AACd,gBAAM,IAAI,KAAJ,CACF,qBAAmB,OAAO,CAAC,IAA3B,GAA+B,kDAD7B,CAAN;AAED;;AACD,aAAK,uBAAL,CAA6B,cAA7B,CAA4C,MAA5C;AACD;;AAED,aAAO,MAAP;AACD,KAjBO;;AAmBE,IAAA,aAAA,CAAA,SAAA,CAAA,YAAA,GAAV,UAAuB,KAAvB,EAAgD,eAAhD,EAAqF;;;AAArF,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,MAAM,GAAG,KAAK,kBAAL,CAAwB,KAAxB,CAAf;;AAEA,UAAI,MAAM,KAAK,IAAf,EAAqB;AACnB;AACA;AACD;;qCAEU,K,EAAK;AACd,YAAM,OAAO,GAAG,SAAV,OAAU,GAAA;AAAM,iBAAA,KAAI,CAAC,YAAL,CAAkB,KAAlB,EAAA,KAAA,CAAA;AAA+B,SAArD;;AAEA,YAAI,WAAW,GAAuB,IAAtC;;AACA,YAAI,eAAe,KAAK,IAApB,IAA4B,KAAK,CAAC,OAAN,CAAc,UAAd,KAA6B,SAA7D,EAAwE;AACtE;AACA;AACA,cAAI;AACF,YAAA,WAAW,GAAG,KAAK,CAAC,OAAN,CAAc,UAAd,CAAyB,KAAzB,EAAgC,KAAK,CAAC,QAAN,CAAe,QAA/C,KAA4D,IAA1E;AACD,WAFD,CAEE,OAAO,GAAP,EAAY;AACZ,gBAAI,GAAG,YAAY,aAAA,CAAA,oBAAnB,EAAyC;AACvC,cAAA,KAAK,CAAC,UAAN,CAAiB,IAAjB,EAAuB,CAAC,GAAG,CAAC,YAAJ,EAAD,CAAvB,EAA6C,IAA7C;;;;AAED,aAHD,MAGO;AACL,oBAAM,GAAN;AACD;AACF;AACF;;AACD,YAAI,WAAW,KAAK,IAApB,EAA0B;AACxB,UAAA,eAAgB,CAAC,IAAjB,CAAsB,WAAW,CAAC,IAAZ,CAAiB,OAAjB,CAAtB;AACD,SAFD,MAEO;AACL,UAAA,OAAO;AACR;;;;AAtBH,aAAoB,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA,MAAA,CAAA,EAAM,UAAA,GAAA,QAAA,CAAA,IAAA,EAA1B,EAA0B,CAAA,UAAA,CAAA,IAA1B,EAA0B,UAAA,GAAA,QAAA,CAAA,IAAA,EAA1B,EAA0B;AAArB,cAAM,KAAK,GAAA,UAAA,CAAA,KAAX;;gCAAM,K;;;AAuBV;;;;;;;;;;;;AACF,KAhCS;;AAkCA,IAAA,aAAA,CAAA,SAAA,CAAA,YAAA,GAAV,UACI,KADJ,EAC6B,KAD7B,EAEI,KAFJ,EAEwB;;;AACtB,UAAI,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,OAA/B,EAAwC;AACtC,cAAM,IAAI,KAAJ,CAAU,iCAA+B,KAAK,CAAC,IAAN,CAAW,IAA1C,GAA8C,YAA9C,GACZ,OAAA,CAAA,UAAA,CAAW,KAAK,CAAC,KAAjB,CADY,GACW,sBADrB,CAAN;AAED;;AAED,WAAK,IAAL,CAAU,UAAV,CAAqB,MAAA,CAAA,SAAA,CAAU,YAA/B,EANsB,CAQtB;;AACA,UAAI,MAAJ;;AACA,UAAI;AACF,QAAA,MAAM,GAAG,KAAK,CAAC,OAAN,CAAc,OAAd,CAAsB,KAAtB,EAA6B,KAAK,CAAC,QAAN,CAAe,QAA5C,EAAsD,KAAtD,CAAT;AACD,OAFD,CAEE,OAAO,GAAP,EAAY;AACZ,YAAI,GAAG,YAAY,aAAA,CAAA,oBAAnB,EAAyC;AACvC,UAAA,KAAK,CAAC,UAAN,CAAiB,IAAjB,EAAuB,CAAC,GAAG,CAAC,YAAJ,EAAD,CAAvB,EAA6C,IAA7C;AACA;AACD,SAHD,MAGO;AACL,gBAAM,GAAN;AACD;AACF;;AAED,UAAM,MAAM,GAAG,KAAK,kBAAL,CAAwB,KAAK,CAAC,OAA9B,EAAuC,KAAvC,EAA4C,CAAA,EAAA,GAAE,MAAM,CAAC,QAAT,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,EAAjB,GAAqB,IAAjE,CAAf;;AACA,UAAI,MAAM,CAAC,QAAP,KAAoB,SAApB,IAAiC,KAAK,CAAC,OAAN,CAAc,QAAd,KAA2B,SAAhE,EAA2E;AACzE,QAAA,KAAK,CAAC,OAAN,CAAc,QAAd,CAAuB,KAAvB,EAA8B,MAAM,CAAC,QAArC;AACD;;AACD,MAAA,KAAK,GAAG,KAAK,CAAC,UAAN,CAAgB,CAAA,EAAA,GAAC,MAAM,CAAC,QAAR,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,EAAhB,GAAoB,IAApC,EAAwC,CAAA,EAAA,GAAE,MAAM,CAAC,WAAT,MAAoB,IAApB,IAAoB,EAAA,KAAA,KAAA,CAApB,GAAoB,EAApB,GAAwB,IAAhE,EAAsE,MAAtE,CAAR;AACD,KA5BS;;AA8BV,IAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;;;;;AACE,UAAM,OAAO,GAAG,KAAK,CAAC,IAAN,CAAW,KAAK,OAAL,CAAa,IAAb,EAAX,CAAhB;;;AACA,aAAoB,IAAA,SAAA,GAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,EAAO,WAAA,GAAA,SAAA,CAAA,IAAA,EAA3B,EAA2B,CAAA,WAAA,CAAA,IAA3B,EAA2B,WAAA,GAAA,SAAA,CAAA,IAAA,EAA3B,EAA6B;AAAxB,cAAM,KAAK,GAAA,WAAA,CAAA,KAAX;AACH,cAAM,MAAM,GAAG,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAf;;;AACA,iBAAkB,IAAA,EAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,MAAM,CAAC,MAAP,CAAA,CAAA,EAAa,EAAA,GAAA,EAAA,CAAA,IAAA,EAA/B,EAA+B,CAAA,EAAA,CAAA,IAA/B,EAA+B,EAAA,GAAA,EAAA,CAAA,IAAA,EAA/B,EAAiC;AAA5B,kBAAI,KAAK,GAAA,EAAA,CAAA,KAAT;AACH,kBAAM,OAAO,GAAG,KAAK,CAAC,OAAtB;;AACA,sBAAQ,KAAK,CAAC,KAAd;AACE,qBAAK,OAAA,CAAA,UAAA,CAAW,OAAhB;AACE;;AACF,qBAAK,OAAA,CAAA,UAAA,CAAW,OAAhB;AACE,wBAAM,IAAI,KAAJ,CAAU,kDAAgD,KAAK,CAAC,IAAN,CAAW,IAA3D,GAA+D,KAA/D,GACZ,MAAM,CAAC,cAAP,CAAsB,KAAK,CAAC,OAA5B,EAAqC,WAArC,CAAiD,IAD/C,CAAN;;AAEF,qBAAK,OAAA,CAAA,UAAA,CAAW,QAAhB;AACE,wBAAM,IAAI,KAAJ,CAAU,qCAAV,CAAN;AAPJ;;AAUA,kBAAI,KAAK,CAAC,QAAN,KAAmB,IAAvB,EAA6B;AAC3B;AACA;AACD;;AAED,kBAAI,OAAO,CAAC,OAAR,KAAoB,SAAxB,EAAmC;AACjC;AACA,gBAAA,KAAK,GAAG,KAAK,CAAC,UAAN,CAAiB,IAAjB,EAAuB,IAAvB,CAAR;AACA;AACD;;AAED,kBAAI,MAAM,GAAA,KAAA,CAAV;;AACA,kBAAI;AACF,gBAAA,MAAM,GAAG,OAAO,CAAC,OAAR,CAAgB,KAAhB,EAAuB,KAAK,CAAC,QAA7B,EAA4D,KAAK,CAAC,MAAlE,CAAT;AACD,eAFD,CAEE,OAAO,GAAP,EAAY;AACZ,oBAAI,GAAG,YAAY,aAAA,CAAA,oBAAnB,EAAyC;AACvC,kBAAA,KAAK,GAAG,KAAK,CAAC,UAAN,CAAiB,IAAjB,EAAuB,CAAC,GAAG,CAAC,YAAJ,EAAD,CAAvB,CAAR;AACA;AACD,iBAHD,MAGO;AACL,wBAAM,GAAN;AACD;AACF;;AAED,cAAA,KAAK,GAAG,KAAK,CAAC,UAAN,CAAgB,CAAA,EAAA,GAAC,MAAM,CAAC,IAAR,MAAY,IAAZ,IAAY,EAAA,KAAA,KAAA,CAAZ,GAAY,EAAZ,GAAgB,IAAhC,EAAoC,CAAA,EAAA,GAAE,MAAM,CAAC,WAAT,MAAoB,IAApB,IAAoB,EAAA,KAAA,KAAA,CAApB,GAAoB,EAApB,GAAwB,IAA5D,CAAR;;AAEA,kBAAI,MAAM,CAAC,SAAP,KAAqB,SAAzB,EAAoC;AAClC,oBAAM,QAAQ,GAAG,KAAK,CAAC,aAAN,GAAsB,QAAvC;;AACA,oBAAI,CAAC,KAAK,WAAL,CAAiB,GAAjB,CAAqB,QAArB,CAAL,EAAqC;AACnC,uBAAK,WAAL,CAAiB,GAAjB,CAAqB,QAArB,EAA+B,IAAI,GAAJ,EAA/B;AACD;;AACD,oBAAM,aAAa,GAAG,KAAK,WAAL,CAAiB,GAAjB,CAAqB,QAArB,CAAtB;;;AACA,uBAAuB,IAAA,EAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,MAAM,CAAC,SAAP,CAAA,CAAA,EAAgB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAuC,CAAA,EAAA,CAAA,IAAvC,EAAuC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAyC;AAApC,wBAAM,QAAQ,GAAA,EAAA,CAAA,KAAd;AACH,oBAAA,aAAa,CAAC,GAAd,CAAkB,QAAQ,CAAC,OAA3B,EAAoC,CAAC,QAAQ,CAAC,UAAV,EAAsB,QAAQ,CAAC,UAA/B,CAApC;AACD;;;;;;;;;;;;AACF;AACF;;;;;;;;;;;;AACF;;;;;;;;;;;;AACF,KArDD;AAuDA;;;AAGG;;;AACH,IAAA,aAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,EAAV,EAA6B,GAA7B,EAAkD;;;AAChD,UAAI,CAAC,KAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,CAAL,EAAiC;AAC/B;AACD;;;AAED,aAAoB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,aAAL,CAAmB,GAAnB,CAAuB,EAAvB,CAAA,CAAA,EAA2B,EAAA,GAAA,EAAA,CAAA,IAAA,EAA/C,EAA+C,CAAA,EAAA,CAAA,IAA/C,EAA+C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA/C,EAAiD;AAA5C,cAAM,KAAK,GAAA,EAAA,CAAA,KAAX;AACH,cAAM,MAAM,GAAG,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAf;;;AACA,iBAAoB,IAAA,EAAA,IAAA,IAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,MAAM,CAAC,MAAP,CAAA,CAAA,EAAa,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC,CAAA,EAAA,CAAA,IAAjC,EAAiC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAmC;AAA9B,kBAAM,KAAK,GAAA,EAAA,CAAA,KAAX;;AACH,kBAAI,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,QAA/B,EAAyC;AACvC;AACD,eAFD,MAEO,IAAI,KAAK,CAAC,OAAN,CAAc,SAAd,KAA4B,SAAhC,EAA2C;AAChD;AACD;;AACD,kBAAI,KAAK,CAAC,UAAN,KAAqB,IAAzB,EAA+B;AAC7B,gBAAA,KAAK,CAAC,OAAN,CAAc,SAAd,CAAwB,GAAxB,EAA6B,KAA7B,EAAoC,KAAK,CAAC,QAA1C,EAAoD,KAAK,CAAC,UAA1D;AACD;AACF;;;;;;;;;;;;AACF;;;;;;;;;;;;AACF,KAlBD;;AAoBA,IAAA,aAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,GAAN,EAA0B;;;;AACxB,aAAoB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,OAAL,CAAa,IAAb,EAAA,CAAA,EAAmB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAuC,CAAA,EAAA,CAAA,IAAvC,EAAuC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAyC;AAApC,cAAM,KAAK,GAAA,EAAA,CAAA,KAAX;AACH,cAAM,MAAM,GAAG,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAf;;;AACA,iBAAoB,IAAA,EAAA,IAAA,IAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,MAAM,CAAC,MAAP,CAAA,CAAA,EAAa,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC,CAAA,EAAA,CAAA,IAAjC,EAAiC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAmC;AAA9B,kBAAM,KAAK,GAAA,EAAA,CAAA,KAAX;;AACH,kBAAI,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,QAA/B,EAAyC;AACvC;AACA;AACD,eAHD,MAGO,IAAI,KAAK,CAAC,OAAN,CAAc,KAAd,KAAwB,SAA5B,EAAuC;AAC5C;AACA;AACD;;AAED,kBAAI,KAAK,CAAC,UAAN,KAAqB,IAAzB,EAA+B;AAC7B,gBAAA,KAAK,CAAC,OAAN,CAAc,KAAd,CAAoB,GAApB,EAAyB,KAAzB,EAAgC,KAAK,CAAC,QAAtC,EAAgD,KAAK,CAAC,UAAtD;AACD;AACF;;;;;;;;;;;;AACF;;;;;;;;;;;;AACF,KAjBD;;AAmBA,IAAA,aAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,KAAhB,EAAsC;;;AACpC,UAAI,CAAC,KAAK,SAAL,CAAe,OAAf,CAAuB,KAAvB,CAAD,IAAkC,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAvC,EAAgE;AAC9D;AACD;;AACD,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAf;;;AACA,aAAoB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,MAAM,CAAC,MAAP,CAAA,EAAa,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC,CAAA,EAAA,CAAA,IAAjC,EAAiC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAmC;AAA9B,cAAM,KAAK,GAAA,EAAA,CAAA,KAAX;;AACH,cAAI,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,QAA3B,IAAuC,KAAK,CAAC,OAAN,CAAc,eAAd,KAAkC,SAA7E,EAAwF;AACtF;AACD;;AAED,UAAA,KAAK,CAAC,OAAN,CAAc,eAAd,CAA8B,KAA9B,EAAqC,KAAK,CAAC,QAA3C,EAAqD,KAAK,CAAC,UAA3D;AACD;;;;;;;;;;;;AACF,KAZD;;AAcA,IAAA,aAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,KAAR,EAAgC,YAAhC,EAA0D;;;AACxD,UAAM,QAAQ,GAAG,EAAE,CAAC,eAAH,CAAmB,KAAnB,CAAjB;;AACA,UAAI,CAAC,KAAK,SAAL,CAAe,OAAf,CAAuB,KAAvB,CAAD,IAAkC,CAAC,KAAK,SAAL,CAAe,OAAf,CAAuB,QAAvB,CAAnC,IACA,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,QAAjB,CADL,EACiC;AAC/B,eAAO,IAAP;AACD;;AAED,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,GAAb,CAAiB,QAAjB,CAAf;AAEA,UAAI,GAAG,GAAoB,EAA3B;;qCAEW,K,EAAK;;;AACd,YAAI,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,QAA3B,IAAuC,KAAK,CAAC,mBAAN,KAA8B,IAArE,IACA,KAAK,CAAC,kBAAN,KAA6B,IADjC,EACuC;;AAGtC,SALa,CAOd;AACA;AACA;;;AAEA,YAAI,UAAU,GAAA,KAAA,CAAd;;AACA,YAAI,MAAA,CAAK,eAAL,KAAyB,KAAA,CAAA,eAAA,CAAgB,OAAzC,IACA,KAAK,CAAC,OAAN,CAAc,cAAd,KAAiC,SADrC,EACgD;AAC9C,UAAA,UAAU,GAAG,KAAK,CAAC,OAAN,CAAc,cAAd,CAA6B,KAA7B,EAAoC,KAAK,CAAC,QAA1C,EAAoD,KAAK,CAAC,UAA1D,CAAb;AACD,SAHD,MAGO;AACL,UAAA,UAAU,GACN,KAAK,CAAC,OAAN,CAAc,WAAd,CAA0B,KAA1B,EAAiC,KAAK,CAAC,QAAvC,EAAiD,KAAK,CAAC,UAAvD,EAAoE,YAApE,CADJ;AAED;;AAED,YAAM,eAAe,GAAG,UAAxB;;AACA,YAAI,KAAK,CAAC,OAAN,CAAc,eAAd,CAAJ,EAAoC;yCACvB,M,EAAM;AACf,gBAAI,CAAC,GAAG,CAAC,IAAJ,CAAS,UAAA,CAAA,EAAC;AAAI,qBAAA,CAAC,CAAC,IAAF,KAAW,MAAM,CAAjB,IAAA;AAAsB,aAApC,CAAL,EAA4C;AAC1C,cAAA,GAAG,CAAC,IAAJ,CAAS,MAAT;AACD;;;;AAHH,iBAAqB,IAAA,iBAAA,IAAA,IAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,eAAA,CAAA,CAAA,EAAe,mBAAA,GAAA,iBAAA,CAAA,IAAA,EAApC,EAAoC,CAAA,mBAAA,CAAA,IAApC,EAAoC,mBAAA,GAAA,iBAAA,CAAA,IAAA,EAApC,EAAoC;AAA/B,kBAAM,MAAM,GAAA,mBAAA,CAAA,KAAZ;;sBAAM,M;AAIV;;;;;;;;;;;;AACF,SAND,MAMO,IAAI,CAAC,GAAG,CAAC,IAAJ,CAAS,UAAA,MAAA,EAAM;AAAI,iBAAA,MAAM,CAAC,IAAP,KAAgB,eAAe,CAA/B,IAAA;AAAoC,SAAvD,CAAL,EAA+D;AACpE,UAAA,GAAG,CAAC,IAAJ,CAAS,eAAT;AACD;;;;;;AA7BH,aAAoB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,MAAM,CAAC,MAAP,CAAA,EAAa,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC,CAAA,EAAA,CAAA,IAAjC,EAAiC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC;AAA5B,cAAM,KAAK,GAAA,EAAA,CAAA,KAAX;;kBAAM,K;AA8BV;;;;;;;;;;;OAzCuD,CA2CxD;AACA;;;AACA,WAAK,aAAL,CAAmB,0BAAnB,CAA8C,QAAQ,CAAC,aAAT,EAA9C,EACK,SADL,CACe,QADf,EACyB,GADzB,EA7CwD,CAgDxD;;AACA,aAAO,GAAG,CAAC,MAAJ,GAAa,CAAb,GAAiB,GAAjB,GAAuB,IAA9B;AACD,KAlDD;;AAoDA,IAAA,aAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,IAAd,EAAkC;;;AAChC,UAAM,QAAQ,GAAG,EAAE,CAAC,eAAH,CAAmB,IAAnB,CAAjB;;AACA,UAAI,CAAC,KAAK,SAAL,CAAe,OAAf,CAAuB,QAAvB,CAAD,IAAqC,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,QAAjB,CAA1C,EAAsE;AACpE,eAAO,EAAP;AACD;;AAED,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,GAAb,CAAiB,QAAjB,CAAf;AACA,UAAM,UAAU,GAAmB,EAAnC;;;AAEA,aAAoB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,MAAM,CAAC,MAAP,CAAA,EAAa,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC,CAAA,EAAA,CAAA,IAAjC,EAAiC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAmC;AAA9B,cAAM,KAAK,GAAA,EAAA,CAAA,KAAX;;AACH,cAAI,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,QAA/B,EAAyC;AACvC;AACD;;AAED,cAAI,KAAK,CAAC,QAAN,CAAe,OAAf,KAA2B,IAA3B,IAAmC,EAAE,CAAC,WAAH,CAAe,KAAK,CAAC,QAAN,CAAe,OAA9B,CAAvC,EAA+E;AAC7E,YAAA,UAAU,CAAC,IAAX,CAAgB,KAAK,CAAC,QAAN,CAAe,OAA/B;AACD;AACF;;;;;;;;;;;;;AAED,aAAO,UAAP;AACD,KApBD;;AAsBA,IAAA,MAAA,CAAA,cAAA,CAAI,aAAA,CAAA,SAAJ,EAAI,aAAJ,EAAe;WAAf,eAAA;;;AACE,YAAM,WAAW,GAAoB,EAArC;;;AACA,eAAoB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,OAAL,CAAa,IAAb,EAAA,CAAA,EAAmB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAuC,CAAA,EAAA,CAAA,IAAvC,EAAuC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAyC;AAApC,gBAAM,KAAK,GAAA,EAAA,CAAA,KAAX;AACH,gBAAM,MAAM,GAAG,KAAK,OAAL,CAAa,GAAb,CAAiB,KAAjB,CAAf;;AACA,gBAAI,MAAM,CAAC,eAAP,KAA2B,IAA/B,EAAqC;AACnC,cAAA,WAAW,CAAC,IAAZ,CAAgB,KAAhB,CAAA,WAAA,EAAW,OAAA,CAAA,QAAA,CAAS,MAAM,CAAC,eAAhB,CAAX;AACD;;;AACD,mBAAoB,IAAA,EAAA,IAAA,IAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,MAAM,CAAC,MAAP,CAAA,CAAA,EAAa,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAiC,CAAA,EAAA,CAAA,IAAjC,EAAiC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjC,EAAmC;AAA9B,oBAAM,KAAK,GAAA,EAAA,CAAA,KAAX;;AACH,oBAAI,CAAC,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,QAA3B,IAAuC,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,QAAnE,KACA,KAAK,CAAC,mBAAN,KAA8B,IADlC,EACwC;AACtC,kBAAA,WAAW,CAAC,IAAZ,CAAgB,KAAhB,CAAA,WAAA,EAAW,OAAA,CAAA,QAAA,CAAS,KAAK,CAAC,mBAAf,CAAX;AACD;;AACD,oBAAI,KAAK,CAAC,KAAN,KAAgB,OAAA,CAAA,UAAA,CAAW,QAA3B,IAAuC,KAAK,CAAC,kBAAN,KAA6B,IAAxE,EAA8E;AAC5E,kBAAA,WAAW,CAAC,IAAZ,CAAgB,KAAhB,CAAA,WAAA,EAAW,OAAA,CAAA,QAAA,CAAS,KAAK,CAAC,kBAAf,CAAX;AACD;AACF;;;;;;;;;;;;AACF;;;;;;;;;;;;;AACD,eAAO,WAAP;AACD,OAlBc;uBAAA;;AAAA,KAAf;AAoBA,IAAA,MAAA,CAAA,cAAA,CAAI,aAAA,CAAA,SAAJ,EAAI,kBAAJ,EAAoB;WAApB,eAAA;AACE,eAAO,KAAK,WAAZ;AACD,OAFmB;uBAAA;;AAAA,KAApB;AAGF,WAAA,aAAA;AAAC,GA7gBD,EAAA;;AAAa,EAAA,OAAA,CAAA,aAAA,GAAA,aAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {IncrementalBuild} from '../../incremental/api';\nimport {SemanticDepGraphUpdater, SemanticSymbol} from '../../incremental/semantic_graph';\nimport {IndexingContext} from '../../indexer';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, DeclarationNode, Decorator, ReflectionHost} from '../../reflection';\nimport {ProgramTypeCheckAdapter, TypeCheckContext} from '../../typecheck/api';\nimport {getSourceFile, isExported} from '../../util/src/typescript';\n\nimport {AnalysisOutput, CompilationMode, CompileResult, DecoratorHandler, HandlerFlags, HandlerPrecedence, ResolveResult} from './api';\nimport {DtsTransformRegistry} from './declaration';\nimport {PendingTrait, Trait, TraitState} from './trait';\n\n\n/**\n * Records information about a specific class that has matched traits.\n */\nexport interface ClassRecord {\n  /**\n   * The `ClassDeclaration` of the class which has Angular traits applied.\n   */\n  node: ClassDeclaration;\n\n  /**\n   * All traits which matched on the class.\n   */\n  traits: Trait<unknown, unknown, SemanticSymbol|null, unknown>[];\n\n  /**\n   * Meta-diagnostics about the class, which are usually related to whether certain combinations of\n   * Angular decorators are not permitted.\n   */\n  metaDiagnostics: ts.Diagnostic[]|null;\n\n  // Subsequent fields are \"internal\" and used during the matching of `DecoratorHandler`s. This is\n  // mutable state during the `detect`/`analyze` phases of compilation.\n\n  /**\n   * Whether `traits` contains traits matched from `DecoratorHandler`s marked as `WEAK`.\n   */\n  hasWeakHandlers: boolean;\n\n  /**\n   * Whether `traits` contains a trait from a `DecoratorHandler` matched as `PRIMARY`.\n   */\n  hasPrimaryHandler: boolean;\n}\n\n/**\n * The heart of Angular compilation.\n *\n * The `TraitCompiler` is responsible for processing all classes in the program. Any time a\n * `DecoratorHandler` matches a class, a \"trait\" is created to represent that Angular aspect of the\n * class (such as the class having a component definition).\n *\n * The `TraitCompiler` transitions each trait through the various phases of compilation, culminating\n * in the production of `CompileResult`s instructing the compiler to apply various mutations to the\n * class (like adding fields or type declarations).\n */\nexport class TraitCompiler implements ProgramTypeCheckAdapter {\n  /**\n   * Maps class declarations to their `ClassRecord`, which tracks the Ivy traits being applied to\n   * those classes.\n   */\n  private classes = new Map<ClassDeclaration, ClassRecord>();\n\n  /**\n   * Maps source files to any class declaration(s) within them which have been discovered to contain\n   * Ivy traits.\n   */\n  protected fileToClasses = new Map<ts.SourceFile, Set<ClassDeclaration>>();\n\n  private reexportMap = new Map<string, Map<string, [string, string]>>();\n\n  private handlersByName =\n      new Map<string, DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>>();\n\n  constructor(\n      private handlers: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>[],\n      private reflector: ReflectionHost, private perf: PerfRecorder,\n      private incrementalBuild: IncrementalBuild<ClassRecord, unknown>,\n      private compileNonExportedClasses: boolean, private compilationMode: CompilationMode,\n      private dtsTransforms: DtsTransformRegistry,\n      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null) {\n    for (const handler of handlers) {\n      this.handlersByName.set(handler.name, handler);\n    }\n  }\n\n  analyzeSync(sf: ts.SourceFile): void {\n    this.analyze(sf, false);\n  }\n\n  analyzeAsync(sf: ts.SourceFile): Promise<void>|undefined {\n    return this.analyze(sf, true);\n  }\n\n  private analyze(sf: ts.SourceFile, preanalyze: false): void;\n  private analyze(sf: ts.SourceFile, preanalyze: true): Promise<void>|undefined;\n  private analyze(sf: ts.SourceFile, preanalyze: boolean): Promise<void>|undefined {\n    // We shouldn't analyze declaration files.\n    if (sf.isDeclarationFile) {\n      return undefined;\n    }\n\n    // analyze() really wants to return `Promise<void>|void`, but TypeScript cannot narrow a return\n    // type of 'void', so `undefined` is used instead.\n    const promises: Promise<void>[] = [];\n\n    const priorWork = this.incrementalBuild.priorWorkFor(sf);\n    if (priorWork !== null) {\n      for (const priorRecord of priorWork) {\n        this.adopt(priorRecord);\n      }\n\n      this.perf.eventCount(PerfEvent.SourceFileReuseAnalysis);\n      this.perf.eventCount(PerfEvent.TraitReuseAnalysis, priorWork.length);\n\n      // Skip the rest of analysis, as this file's prior traits are being reused.\n      return;\n    }\n\n    const visit = (node: ts.Node): void => {\n      if (this.reflector.isClass(node)) {\n        this.analyzeClass(node, preanalyze ? promises : null);\n      }\n      ts.forEachChild(node, visit);\n    };\n\n    visit(sf);\n\n    if (preanalyze && promises.length > 0) {\n      return Promise.all(promises).then(() => undefined as void);\n    } else {\n      return undefined;\n    }\n  }\n\n  recordFor(clazz: ClassDeclaration): ClassRecord|null {\n    if (this.classes.has(clazz)) {\n      return this.classes.get(clazz)!;\n    } else {\n      return null;\n    }\n  }\n\n  recordsFor(sf: ts.SourceFile): ClassRecord[]|null {\n    if (!this.fileToClasses.has(sf)) {\n      return null;\n    }\n    const records: ClassRecord[] = [];\n    for (const clazz of this.fileToClasses.get(sf)!) {\n      records.push(this.classes.get(clazz)!);\n    }\n    return records;\n  }\n\n  /**\n   * Import a `ClassRecord` from a previous compilation.\n   *\n   * Traits from the `ClassRecord` have accurate metadata, but the `handler` is from the old program\n   * and needs to be updated (matching is done by name). A new pending trait is created and then\n   * transitioned to analyzed using the previous analysis. If the trait is in the errored state,\n   * instead the errors are copied over.\n   */\n  private adopt(priorRecord: ClassRecord): void {\n    const record: ClassRecord = {\n      hasPrimaryHandler: priorRecord.hasPrimaryHandler,\n      hasWeakHandlers: priorRecord.hasWeakHandlers,\n      metaDiagnostics: priorRecord.metaDiagnostics,\n      node: priorRecord.node,\n      traits: [],\n    };\n\n    for (const priorTrait of priorRecord.traits) {\n      const handler = this.handlersByName.get(priorTrait.handler.name)!;\n      let trait: Trait<unknown, unknown, SemanticSymbol|null, unknown> =\n          Trait.pending(handler, priorTrait.detected);\n\n      if (priorTrait.state === TraitState.Analyzed || priorTrait.state === TraitState.Resolved) {\n        const symbol = this.makeSymbolForTrait(handler, record.node, priorTrait.analysis);\n        trait = trait.toAnalyzed(priorTrait.analysis, priorTrait.analysisDiagnostics, symbol);\n        if (trait.analysis !== null && trait.handler.register !== undefined) {\n          trait.handler.register(record.node, trait.analysis);\n        }\n      } else if (priorTrait.state === TraitState.Skipped) {\n        trait = trait.toSkipped();\n      }\n\n      record.traits.push(trait);\n    }\n\n    this.classes.set(record.node, record);\n    const sf = record.node.getSourceFile();\n    if (!this.fileToClasses.has(sf)) {\n      this.fileToClasses.set(sf, new Set<ClassDeclaration>());\n    }\n    this.fileToClasses.get(sf)!.add(record.node);\n  }\n\n  private scanClassForTraits(clazz: ClassDeclaration):\n      PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[]|null {\n    if (!this.compileNonExportedClasses && !isExported(clazz)) {\n      return null;\n    }\n\n    const decorators = this.reflector.getDecoratorsOfDeclaration(clazz);\n\n    return this.detectTraits(clazz, decorators);\n  }\n\n  protected detectTraits(clazz: ClassDeclaration, decorators: Decorator[]|null):\n      PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[]|null {\n    let record: ClassRecord|null = this.recordFor(clazz);\n    let foundTraits: PendingTrait<unknown, unknown, SemanticSymbol|null, unknown>[] = [];\n\n    for (const handler of this.handlers) {\n      const result = handler.detect(clazz, decorators);\n      if (result === undefined) {\n        continue;\n      }\n\n      const isPrimaryHandler = handler.precedence === HandlerPrecedence.PRIMARY;\n      const isWeakHandler = handler.precedence === HandlerPrecedence.WEAK;\n      const trait = Trait.pending(handler, result);\n\n      foundTraits.push(trait);\n\n      if (record === null) {\n        // This is the first handler to match this class. This path is a fast path through which\n        // most classes will flow.\n        record = {\n          node: clazz,\n          traits: [trait],\n          metaDiagnostics: null,\n          hasPrimaryHandler: isPrimaryHandler,\n          hasWeakHandlers: isWeakHandler,\n        };\n\n        this.classes.set(clazz, record);\n        const sf = clazz.getSourceFile();\n        if (!this.fileToClasses.has(sf)) {\n          this.fileToClasses.set(sf, new Set<ClassDeclaration>());\n        }\n        this.fileToClasses.get(sf)!.add(clazz);\n      } else {\n        // This is at least the second handler to match this class. This is a slower path that some\n        // classes will go through, which validates that the set of decorators applied to the class\n        // is valid.\n\n        // Validate according to rules as follows:\n        //\n        // * WEAK handlers are removed if a non-WEAK handler matches.\n        // * Only one PRIMARY handler can match at a time. Any other PRIMARY handler matching a\n        //   class with an existing PRIMARY handler is an error.\n\n        if (!isWeakHandler && record.hasWeakHandlers) {\n          // The current handler is not a WEAK handler, but the class has other WEAK handlers.\n          // Remove them.\n          record.traits =\n              record.traits.filter(field => field.handler.precedence !== HandlerPrecedence.WEAK);\n          record.hasWeakHandlers = false;\n        } else if (isWeakHandler && !record.hasWeakHandlers) {\n          // The current handler is a WEAK handler, but the class has non-WEAK handlers already.\n          // Drop the current one.\n          continue;\n        }\n\n        if (isPrimaryHandler && record.hasPrimaryHandler) {\n          // The class already has a PRIMARY handler, and another one just matched.\n          record.metaDiagnostics = [{\n            category: ts.DiagnosticCategory.Error,\n            code: Number('-99' + ErrorCode.DECORATOR_COLLISION),\n            file: getSourceFile(clazz),\n            start: clazz.getStart(undefined, false),\n            length: clazz.getWidth(),\n            messageText: 'Two incompatible decorators on class',\n          }];\n          record.traits = foundTraits = [];\n          break;\n        }\n\n        // Otherwise, it's safe to accept the multiple decorators here. Update some of the metadata\n        // regarding this class.\n        record.traits.push(trait);\n        record.hasPrimaryHandler = record.hasPrimaryHandler || isPrimaryHandler;\n      }\n    }\n\n    return foundTraits.length > 0 ? foundTraits : null;\n  }\n\n  private makeSymbolForTrait(\n      handler: DecoratorHandler<unknown, unknown, SemanticSymbol|null, unknown>,\n      decl: ClassDeclaration, analysis: Readonly<unknown>|null): SemanticSymbol|null {\n    if (analysis === null) {\n      return null;\n    }\n    const symbol = handler.symbol(decl, analysis);\n    if (symbol !== null && this.semanticDepGraphUpdater !== null) {\n      const isPrimary = handler.precedence === HandlerPrecedence.PRIMARY;\n      if (!isPrimary) {\n        throw new Error(\n            `AssertionError: ${handler.name} returned a symbol but is not a primary handler.`);\n      }\n      this.semanticDepGraphUpdater.registerSymbol(symbol);\n    }\n\n    return symbol;\n  }\n\n  protected analyzeClass(clazz: ClassDeclaration, preanalyzeQueue: Promise<void>[]|null): void {\n    const traits = this.scanClassForTraits(clazz);\n\n    if (traits === null) {\n      // There are no Ivy traits on the class, so it can safely be skipped.\n      return;\n    }\n\n    for (const trait of traits) {\n      const analyze = () => this.analyzeTrait(clazz, trait);\n\n      let preanalysis: Promise<void>|null = null;\n      if (preanalyzeQueue !== null && trait.handler.preanalyze !== undefined) {\n        // Attempt to run preanalysis. This could fail with a `FatalDiagnosticError`; catch it if it\n        // does.\n        try {\n          preanalysis = trait.handler.preanalyze(clazz, trait.detected.metadata) || null;\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait.toAnalyzed(null, [err.toDiagnostic()], null);\n            return;\n          } else {\n            throw err;\n          }\n        }\n      }\n      if (preanalysis !== null) {\n        preanalyzeQueue!.push(preanalysis.then(analyze));\n      } else {\n        analyze();\n      }\n    }\n  }\n\n  protected analyzeTrait(\n      clazz: ClassDeclaration, trait: Trait<unknown, unknown, SemanticSymbol|null, unknown>,\n      flags?: HandlerFlags): void {\n    if (trait.state !== TraitState.Pending) {\n      throw new Error(`Attempt to analyze trait of ${clazz.name.text} in state ${\n          TraitState[trait.state]} (expected DETECTED)`);\n    }\n\n    this.perf.eventCount(PerfEvent.TraitAnalyze);\n\n    // Attempt analysis. This could fail with a `FatalDiagnosticError`; catch it if it does.\n    let result: AnalysisOutput<unknown>;\n    try {\n      result = trait.handler.analyze(clazz, trait.detected.metadata, flags);\n    } catch (err) {\n      if (err instanceof FatalDiagnosticError) {\n        trait.toAnalyzed(null, [err.toDiagnostic()], null);\n        return;\n      } else {\n        throw err;\n      }\n    }\n\n    const symbol = this.makeSymbolForTrait(trait.handler, clazz, result.analysis ?? null);\n    if (result.analysis !== undefined && trait.handler.register !== undefined) {\n      trait.handler.register(clazz, result.analysis);\n    }\n    trait = trait.toAnalyzed(result.analysis ?? null, result.diagnostics ?? null, symbol);\n  }\n\n  resolve(): void {\n    const classes = Array.from(this.classes.keys());\n    for (const clazz of classes) {\n      const record = this.classes.get(clazz)!;\n      for (let trait of record.traits) {\n        const handler = trait.handler;\n        switch (trait.state) {\n          case TraitState.Skipped:\n            continue;\n          case TraitState.Pending:\n            throw new Error(`Resolving a trait that hasn't been analyzed: ${clazz.name.text} / ${\n                Object.getPrototypeOf(trait.handler).constructor.name}`);\n          case TraitState.Resolved:\n            throw new Error(`Resolving an already resolved trait`);\n        }\n\n        if (trait.analysis === null) {\n          // No analysis results, cannot further process this trait.\n          continue;\n        }\n\n        if (handler.resolve === undefined) {\n          // No resolution of this trait needed - it's considered successful by default.\n          trait = trait.toResolved(null, null);\n          continue;\n        }\n\n        let result: ResolveResult<unknown>;\n        try {\n          result = handler.resolve(clazz, trait.analysis as Readonly<unknown>, trait.symbol);\n        } catch (err) {\n          if (err instanceof FatalDiagnosticError) {\n            trait = trait.toResolved(null, [err.toDiagnostic()]);\n            continue;\n          } else {\n            throw err;\n          }\n        }\n\n        trait = trait.toResolved(result.data ?? null, result.diagnostics ?? null);\n\n        if (result.reexports !== undefined) {\n          const fileName = clazz.getSourceFile().fileName;\n          if (!this.reexportMap.has(fileName)) {\n            this.reexportMap.set(fileName, new Map<string, [string, string]>());\n          }\n          const fileReexports = this.reexportMap.get(fileName)!;\n          for (const reexport of result.reexports) {\n            fileReexports.set(reexport.asAlias, [reexport.fromModule, reexport.symbolName]);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Generate type-checking code into the `TypeCheckContext` for any components within the given\n   * `ts.SourceFile`.\n   */\n  typeCheck(sf: ts.SourceFile, ctx: TypeCheckContext): void {\n    if (!this.fileToClasses.has(sf)) {\n      return;\n    }\n\n    for (const clazz of this.fileToClasses.get(sf)!) {\n      const record = this.classes.get(clazz)!;\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          continue;\n        } else if (trait.handler.typeCheck === undefined) {\n          continue;\n        }\n        if (trait.resolution !== null) {\n          trait.handler.typeCheck(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n\n  index(ctx: IndexingContext): void {\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz)!;\n      for (const trait of record.traits) {\n        if (trait.state !== TraitState.Resolved) {\n          // Skip traits that haven't been resolved successfully.\n          continue;\n        } else if (trait.handler.index === undefined) {\n          // Skip traits that don't affect indexing.\n          continue;\n        }\n\n        if (trait.resolution !== null) {\n          trait.handler.index(ctx, clazz, trait.analysis, trait.resolution);\n        }\n      }\n    }\n  }\n\n  updateResources(clazz: DeclarationNode): void {\n    if (!this.reflector.isClass(clazz) || !this.classes.has(clazz)) {\n      return;\n    }\n    const record = this.classes.get(clazz)!;\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.handler.updateResources === undefined) {\n        continue;\n      }\n\n      trait.handler.updateResources(clazz, trait.analysis, trait.resolution);\n    }\n  }\n\n  compile(clazz: DeclarationNode, constantPool: ConstantPool): CompileResult[]|null {\n    const original = ts.getOriginalNode(clazz) as typeof clazz;\n    if (!this.reflector.isClass(clazz) || !this.reflector.isClass(original) ||\n        !this.classes.has(original)) {\n      return null;\n    }\n\n    const record = this.classes.get(original)!;\n\n    let res: CompileResult[] = [];\n\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved || trait.analysisDiagnostics !== null ||\n          trait.resolveDiagnostics !== null) {\n        // Cannot compile a trait that is not resolved, or had any errors in its declaration.\n        continue;\n      }\n\n      // `trait.resolution` is non-null asserted here because TypeScript does not recognize that\n      // `Readonly<unknown>` is nullable (as `unknown` itself is nullable) due to the way that\n      // `Readonly` works.\n\n      let compileRes: CompileResult|CompileResult[];\n      if (this.compilationMode === CompilationMode.PARTIAL &&\n          trait.handler.compilePartial !== undefined) {\n        compileRes = trait.handler.compilePartial(clazz, trait.analysis, trait.resolution!);\n      } else {\n        compileRes =\n            trait.handler.compileFull(clazz, trait.analysis, trait.resolution!, constantPool);\n      }\n\n      const compileMatchRes = compileRes;\n      if (Array.isArray(compileMatchRes)) {\n        for (const result of compileMatchRes) {\n          if (!res.some(r => r.name === result.name)) {\n            res.push(result);\n          }\n        }\n      } else if (!res.some(result => result.name === compileMatchRes.name)) {\n        res.push(compileMatchRes);\n      }\n    }\n\n    // Look up the .d.ts transformer for the input file and record that at least one field was\n    // generated, which will allow the .d.ts to be transformed later.\n    this.dtsTransforms.getIvyDeclarationTransform(original.getSourceFile())\n        .addFields(original, res);\n\n    // Return the instruction to the transformer so the fields will be added.\n    return res.length > 0 ? res : null;\n  }\n\n  decoratorsFor(node: ts.Declaration): ts.Decorator[] {\n    const original = ts.getOriginalNode(node) as typeof node;\n    if (!this.reflector.isClass(original) || !this.classes.has(original)) {\n      return [];\n    }\n\n    const record = this.classes.get(original)!;\n    const decorators: ts.Decorator[] = [];\n\n    for (const trait of record.traits) {\n      if (trait.state !== TraitState.Resolved) {\n        continue;\n      }\n\n      if (trait.detected.trigger !== null && ts.isDecorator(trait.detected.trigger)) {\n        decorators.push(trait.detected.trigger);\n      }\n    }\n\n    return decorators;\n  }\n\n  get diagnostics(): ReadonlyArray<ts.Diagnostic> {\n    const diagnostics: ts.Diagnostic[] = [];\n    for (const clazz of this.classes.keys()) {\n      const record = this.classes.get(clazz)!;\n      if (record.metaDiagnostics !== null) {\n        diagnostics.push(...record.metaDiagnostics);\n      }\n      for (const trait of record.traits) {\n        if ((trait.state === TraitState.Analyzed || trait.state === TraitState.Resolved) &&\n            trait.analysisDiagnostics !== null) {\n          diagnostics.push(...trait.analysisDiagnostics);\n        }\n        if (trait.state === TraitState.Resolved && trait.resolveDiagnostics !== null) {\n          diagnostics.push(...trait.resolveDiagnostics);\n        }\n      }\n    }\n    return diagnostics;\n  }\n\n  get exportStatements(): Map<string, Map<string, [string, string]>> {\n    return this.reexportMap;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}