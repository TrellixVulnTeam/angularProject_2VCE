{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/imports/src/emitter\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/file_system/src/util\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/imports/src/find_export\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.UnifiedModulesStrategy = exports.RelativePathStrategy = exports.LogicalProjectStrategy = exports.AbsoluteModuleStrategy = exports.LocalIdentifierStrategy = exports.ReferenceEmitter = exports.ImportFlags = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system/src/util\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var find_export_1 = require(\"@angular/compiler-cli/src/ngtsc/imports/src/find_export\");\n  /**\n   * Flags which alter the imports generated by the `ReferenceEmitter`.\n   */\n\n\n  var ImportFlags;\n\n  (function (ImportFlags) {\n    ImportFlags[ImportFlags[\"None\"] = 0] = \"None\";\n    /**\n     * Force the generation of a new import when generating a reference, even if an identifier already\n     * exists in the target file which could be used instead.\n     *\n     * This is sometimes required if there's a risk TypeScript might remove imports during emit.\n     */\n\n    ImportFlags[ImportFlags[\"ForceNewImport\"] = 1] = \"ForceNewImport\";\n    /**\n     * Don't make use of any aliasing information when emitting a reference.\n     *\n     * This is sometimes required if emitting into a context where generated references will be fed\n     * into TypeScript and type-checked (such as in template type-checking).\n     */\n\n    ImportFlags[ImportFlags[\"NoAliasing\"] = 2] = \"NoAliasing\";\n    /**\n     * Indicates that an import to a type-only declaration is allowed.\n     *\n     * For references that occur in type-positions, the referred declaration may be a type-only\n     * declaration that is not retained during emit. Including this flag allows to emit references to\n     * type-only declarations as used in e.g. template type-checking.\n     */\n\n    ImportFlags[ImportFlags[\"AllowTypeImports\"] = 4] = \"AllowTypeImports\";\n  })(ImportFlags = exports.ImportFlags || (exports.ImportFlags = {}));\n  /**\n   * Generates `Expression`s which refer to `Reference`s in a given context.\n   *\n   * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an\n   * `Expression` which refers to a `Reference` in the context of a particular file.\n   */\n\n\n  var ReferenceEmitter =\n  /** @class */\n  function () {\n    function ReferenceEmitter(strategies) {\n      this.strategies = strategies;\n    }\n\n    ReferenceEmitter.prototype.emit = function (ref, context, importFlags) {\n      var e_1, _a;\n\n      if (importFlags === void 0) {\n        importFlags = ImportFlags.None;\n      }\n\n      try {\n        for (var _b = tslib_1.__values(this.strategies), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var strategy = _c.value;\n          var emitted = strategy.emit(ref, context, importFlags);\n\n          if (emitted !== null) {\n            return emitted;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      throw new Error(\"Unable to write a reference to \" + typescript_1.nodeNameForError(ref.node) + \" in \" + ref.node.getSourceFile().fileName + \" from \" + context.fileName);\n    };\n\n    return ReferenceEmitter;\n  }();\n\n  exports.ReferenceEmitter = ReferenceEmitter;\n  /**\n   * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if\n   * such identifiers are available.\n   */\n\n  var LocalIdentifierStrategy =\n  /** @class */\n  function () {\n    function LocalIdentifierStrategy() {}\n\n    LocalIdentifierStrategy.prototype.emit = function (ref, context, importFlags) {\n      var refSf = typescript_1.getSourceFile(ref.node); // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a\n      // local identifier at all, *except* in the source file where the node is actually declared.\n\n      if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {\n        return null;\n      } // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,\n      // etc) and it is in the current file then just use it directly.\n      // This is important because the reference could be a property access (e.g. `exports.foo`). In\n      // such a case, the reference's `identities` property would be `[foo]`, which would result in an\n      // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.\n\n\n      if (!typescript_1.isDeclaration(ref.node) && refSf === context) {\n        return {\n          expression: new compiler_1.WrappedNodeExpr(ref.node),\n          importedFile: null\n        };\n      } // A Reference can have multiple identities in different files, so it may already have an\n      // Identifier in the requested context file.\n\n\n      var identifier = ref.getIdentityIn(context);\n\n      if (identifier !== null) {\n        return {\n          expression: new compiler_1.WrappedNodeExpr(identifier),\n          importedFile: null\n        };\n      } else {\n        return null;\n      }\n    };\n\n    return LocalIdentifierStrategy;\n  }();\n\n  exports.LocalIdentifierStrategy = LocalIdentifierStrategy;\n  /**\n   * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using\n   * an absolute import.\n   *\n   * Part of this strategy involves looking at the target entry point and identifying the exported\n   * name of the targeted declaration, as it might be different from the declared name (e.g. a\n   * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found\n   * which maps back to the original directive, an error is thrown.\n   */\n\n  var AbsoluteModuleStrategy =\n  /** @class */\n  function () {\n    function AbsoluteModuleStrategy(program, checker, moduleResolver, reflectionHost) {\n      this.program = program;\n      this.checker = checker;\n      this.moduleResolver = moduleResolver;\n      this.reflectionHost = reflectionHost;\n      /**\n       * A cache of the exports of specific modules, because resolving a module to its exports is a\n       * costly operation.\n       */\n\n      this.moduleExportsCache = new Map();\n    }\n\n    AbsoluteModuleStrategy.prototype.emit = function (ref, context, importFlags) {\n      if (ref.bestGuessOwningModule === null) {\n        // There is no module name available for this Reference, meaning it was arrived at via a\n        // relative path.\n        return null;\n      } else if (!typescript_1.isDeclaration(ref.node)) {\n        // It's not possible to import something which isn't a declaration.\n        throw new Error(\"Debug assert: unable to import a Reference to non-declaration of type \" + ts.SyntaxKind[ref.node.kind] + \".\");\n      } else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && typescript_1.isTypeDeclaration(ref.node)) {\n        throw new Error(\"Importing a type-only declaration of type \" + ts.SyntaxKind[ref.node.kind] + \" in a value position is not allowed.\");\n      } // Try to find the exported name of the declaration, if one is available.\n\n\n      var _a = ref.bestGuessOwningModule,\n          specifier = _a.specifier,\n          resolutionContext = _a.resolutionContext;\n      var exports = this.getExportsOfModule(specifier, resolutionContext);\n\n      if (exports === null || !exports.exportMap.has(ref.node)) {\n        // TODO(alxhub): make this error a ts.Diagnostic pointing at whatever caused this import to be\n        // triggered.\n        throw new Error(\"Symbol \" + ref.debugName + \" declared in \" + typescript_1.getSourceFile(ref.node).fileName + \" is not exported from \" + specifier + \" (import into \" + context.fileName + \")\");\n      }\n\n      var symbolName = exports.exportMap.get(ref.node);\n      return {\n        expression: new compiler_1.ExternalExpr(new compiler_1.ExternalReference(specifier, symbolName)),\n        importedFile: exports.module\n      };\n    };\n\n    AbsoluteModuleStrategy.prototype.getExportsOfModule = function (moduleName, fromFile) {\n      if (!this.moduleExportsCache.has(moduleName)) {\n        this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));\n      }\n\n      return this.moduleExportsCache.get(moduleName);\n    };\n\n    AbsoluteModuleStrategy.prototype.enumerateExportsOfModule = function (specifier, fromFile) {\n      // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.\n      var entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);\n\n      if (entryPointFile === null) {\n        return null;\n      }\n\n      var exports = this.reflectionHost.getExportsOfModule(entryPointFile);\n\n      if (exports === null) {\n        return null;\n      }\n\n      var exportMap = new Map();\n      exports.forEach(function (declaration, name) {\n        exportMap.set(declaration.node, name);\n      });\n      return {\n        module: entryPointFile,\n        exportMap: exportMap\n      };\n    };\n\n    return AbsoluteModuleStrategy;\n  }();\n\n  exports.AbsoluteModuleStrategy = AbsoluteModuleStrategy;\n  /**\n   * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're\n   * both in the logical project \"space\" of paths.\n   *\n   * This is trickier than it sounds, as the two files may be in different root directories in the\n   * project. Simply calculating a file system relative path between the two is not sufficient.\n   * Instead, `LogicalProjectPath`s are used.\n   */\n\n  var LogicalProjectStrategy =\n  /** @class */\n  function () {\n    function LogicalProjectStrategy(reflector, logicalFs) {\n      this.reflector = reflector;\n      this.logicalFs = logicalFs;\n    }\n\n    LogicalProjectStrategy.prototype.emit = function (ref, context) {\n      var destSf = typescript_1.getSourceFile(ref.node); // Compute the relative path from the importing file to the file being imported. This is done\n      // as a logical path computation, because the two files might be in different rootDirs.\n\n      var destPath = this.logicalFs.logicalPathOfSf(destSf);\n\n      if (destPath === null) {\n        // The imported file is not within the logical project filesystem.\n        return null;\n      }\n\n      var originPath = this.logicalFs.logicalPathOfSf(context);\n\n      if (originPath === null) {\n        throw new Error(\"Debug assert: attempt to import from \" + context.fileName + \" but it's outside the program?\");\n      } // There's no way to emit a relative reference from a file to itself.\n\n\n      if (destPath === originPath) {\n        return null;\n      }\n\n      var name = find_export_1.findExportedNameOfNode(ref.node, destSf, this.reflector);\n\n      if (name === null) {\n        // The target declaration isn't exported from the file it's declared in. This is an issue!\n        return null;\n      } // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative\n      // path is now straightforward.\n\n\n      var moduleName = file_system_1.LogicalProjectPath.relativePathBetween(originPath, destPath);\n      return {\n        expression: new compiler_1.ExternalExpr({\n          moduleName: moduleName,\n          name: name\n        }),\n        importedFile: destSf\n      };\n    };\n\n    return LogicalProjectStrategy;\n  }();\n\n  exports.LogicalProjectStrategy = LogicalProjectStrategy;\n  /**\n   * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.\n   *\n   * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which\n   * necessitates the stronger logic of `LogicalProjectStrategy`.\n   */\n\n  var RelativePathStrategy =\n  /** @class */\n  function () {\n    function RelativePathStrategy(reflector) {\n      this.reflector = reflector;\n    }\n\n    RelativePathStrategy.prototype.emit = function (ref, context) {\n      var destSf = typescript_1.getSourceFile(ref.node);\n      var relativePath = file_system_1.relative(file_system_1.dirname(file_system_1.absoluteFromSourceFile(context)), file_system_1.absoluteFromSourceFile(destSf));\n      var moduleName = file_system_1.toRelativeImport(util_1.stripExtension(relativePath));\n      var name = find_export_1.findExportedNameOfNode(ref.node, destSf, this.reflector);\n      return {\n        expression: new compiler_1.ExternalExpr({\n          moduleName: moduleName,\n          name: name\n        }),\n        importedFile: destSf\n      };\n    };\n\n    return RelativePathStrategy;\n  }();\n\n  exports.RelativePathStrategy = RelativePathStrategy;\n  /**\n   * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import\n   * references.\n   */\n\n  var UnifiedModulesStrategy =\n  /** @class */\n  function () {\n    function UnifiedModulesStrategy(reflector, unifiedModulesHost) {\n      this.reflector = reflector;\n      this.unifiedModulesHost = unifiedModulesHost;\n    }\n\n    UnifiedModulesStrategy.prototype.emit = function (ref, context) {\n      var destSf = typescript_1.getSourceFile(ref.node);\n      var name = find_export_1.findExportedNameOfNode(ref.node, destSf, this.reflector);\n\n      if (name === null) {\n        return null;\n      }\n\n      var moduleName = this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);\n      return {\n        expression: new compiler_1.ExternalExpr({\n          moduleName: moduleName,\n          name: name\n        }),\n        importedFile: destSf\n      };\n    };\n\n    return UnifiedModulesStrategy;\n  }();\n\n  exports.UnifiedModulesStrategy = UnifiedModulesStrategy;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Expression, ExternalExpr, ExternalReference, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {UnifiedModulesHost} from '../../core/api';\nimport {absoluteFromSourceFile, dirname, LogicalFileSystem, LogicalProjectPath, relative, toRelativeImport} from '../../file_system';\nimport {stripExtension} from '../../file_system/src/util';\nimport {DeclarationNode, ReflectionHost} from '../../reflection';\nimport {getSourceFile, isDeclaration, isTypeDeclaration, nodeNameForError} from '../../util/src/typescript';\n\nimport {findExportedNameOfNode} from './find_export';\nimport {Reference} from './references';\nimport {ModuleResolver} from './resolver';\n\n\n/**\n * Flags which alter the imports generated by the `ReferenceEmitter`.\n */\nexport enum ImportFlags {\n  None = 0x00,\n\n  /**\n   * Force the generation of a new import when generating a reference, even if an identifier already\n   * exists in the target file which could be used instead.\n   *\n   * This is sometimes required if there's a risk TypeScript might remove imports during emit.\n   */\n  ForceNewImport = 0x01,\n\n  /**\n   * Don't make use of any aliasing information when emitting a reference.\n   *\n   * This is sometimes required if emitting into a context where generated references will be fed\n   * into TypeScript and type-checked (such as in template type-checking).\n   */\n  NoAliasing = 0x02,\n\n  /**\n   * Indicates that an import to a type-only declaration is allowed.\n   *\n   * For references that occur in type-positions, the referred declaration may be a type-only\n   * declaration that is not retained during emit. Including this flag allows to emit references to\n   * type-only declarations as used in e.g. template type-checking.\n   */\n  AllowTypeImports = 0x04,\n}\n\n/**\n * An emitter strategy has the ability to indicate which `ts.SourceFile` is being imported by the\n * expression that it has generated. This information is useful for consumers of the emitted\n * reference that would otherwise have to perform a relatively expensive module resolution step,\n * e.g. for cyclic import analysis. In cases the emitter is unable to definitively determine the\n * imported source file or a computation would be required to actually determine the imported\n * source file, then `'unknown'` should be returned. If the generated expression does not represent\n * an import then `null` should be used.\n */\nexport type ImportedFile = ts.SourceFile|'unknown'|null;\n\n/**\n * Represents the emitted expression of a `Reference` that is valid in the source file it was\n * emitted from.\n */\nexport interface EmittedReference {\n  /**\n   * The expression that refers to `Reference`.\n   */\n  expression: Expression;\n\n  /**\n   * The `ts.SourceFile` that is imported by `expression`. This is not necessarily the source file\n   * of the `Reference`'s declaration node, as the reference may have been rewritten through an\n   * alias export. It could also be `null` if `expression` is a local identifier, or `'unknown'` if\n   * the exact source file that is being imported is not known to the emitter.\n   */\n  importedFile: ImportedFile;\n}\n\n/**\n * A particular strategy for generating an expression which refers to a `Reference`.\n *\n * There are many potential ways a given `Reference` could be referred to in the context of a given\n * file. A local declaration could be available, the `Reference` could be importable via a relative\n * import within the project, or an absolute import into `node_modules` might be necessary.\n *\n * Different `ReferenceEmitStrategy` implementations implement specific logic for generating such\n * references. A single strategy (such as using a local declaration) may not always be able to\n * generate an expression for every `Reference` (for example, if no local identifier is available),\n * and may return `null` in such a case.\n */\nexport interface ReferenceEmitStrategy {\n  /**\n   * Emit an `Expression` which refers to the given `Reference` in the context of a particular\n   * source file, if possible.\n   *\n   * @param ref the `Reference` for which to generate an expression\n   * @param context the source file in which the `Expression` must be valid\n   * @param importFlags a flag which controls whether imports should be generated or not\n   * @returns an `EmittedReference` which refers to the `Reference`, or `null` if none can be\n   *   generated\n   */\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null;\n}\n\n/**\n * Generates `Expression`s which refer to `Reference`s in a given context.\n *\n * A `ReferenceEmitter` uses one or more `ReferenceEmitStrategy` implementations to produce an\n * `Expression` which refers to a `Reference` in the context of a particular file.\n */\nexport class ReferenceEmitter {\n  constructor(private strategies: ReferenceEmitStrategy[]) {}\n\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags = ImportFlags.None):\n      EmittedReference {\n    for (const strategy of this.strategies) {\n      const emitted = strategy.emit(ref, context, importFlags);\n      if (emitted !== null) {\n        return emitted;\n      }\n    }\n    throw new Error(`Unable to write a reference to ${nodeNameForError(ref.node)} in ${\n        ref.node.getSourceFile().fileName} from ${context.fileName}`);\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which will refer to declarations by any local `ts.Identifier`s, if\n * such identifiers are available.\n */\nexport class LocalIdentifierStrategy implements ReferenceEmitStrategy {\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null {\n    const refSf = getSourceFile(ref.node);\n\n    // If the emitter has specified ForceNewImport, then LocalIdentifierStrategy should not use a\n    // local identifier at all, *except* in the source file where the node is actually declared.\n    if (importFlags & ImportFlags.ForceNewImport && refSf !== context) {\n      return null;\n    }\n\n    // If referenced node is not an actual TS declaration (e.g. `class Foo` or `function foo() {}`,\n    // etc) and it is in the current file then just use it directly.\n    // This is important because the reference could be a property access (e.g. `exports.foo`). In\n    // such a case, the reference's `identities` property would be `[foo]`, which would result in an\n    // invalid emission of a free-standing `foo` identifier, rather than `exports.foo`.\n    if (!isDeclaration(ref.node) && refSf === context) {\n      return {\n        expression: new WrappedNodeExpr(ref.node),\n        importedFile: null,\n      };\n    }\n\n    // A Reference can have multiple identities in different files, so it may already have an\n    // Identifier in the requested context file.\n    const identifier = ref.getIdentityIn(context);\n    if (identifier !== null) {\n      return {\n        expression: new WrappedNodeExpr(identifier),\n        importedFile: null,\n      };\n    } else {\n      return null;\n    }\n  }\n}\n\n/**\n * Represents the exported declarations from a module source file.\n */\ninterface ModuleExports {\n  /**\n   * The source file of the module.\n   */\n  module: ts.SourceFile;\n\n  /**\n   * The map of declarations to their exported name.\n   */\n  exportMap: Map<DeclarationNode, string>;\n}\n\n/**\n * A `ReferenceEmitStrategy` which will refer to declarations that come from `node_modules` using\n * an absolute import.\n *\n * Part of this strategy involves looking at the target entry point and identifying the exported\n * name of the targeted declaration, as it might be different from the declared name (e.g. a\n * directive might be declared as FooDirImpl, but exported as FooDir). If no export can be found\n * which maps back to the original directive, an error is thrown.\n */\nexport class AbsoluteModuleStrategy implements ReferenceEmitStrategy {\n  /**\n   * A cache of the exports of specific modules, because resolving a module to its exports is a\n   * costly operation.\n   */\n  private moduleExportsCache = new Map<string, ModuleExports|null>();\n\n  constructor(\n      protected program: ts.Program, protected checker: ts.TypeChecker,\n      protected moduleResolver: ModuleResolver, private reflectionHost: ReflectionHost) {}\n\n  emit(ref: Reference, context: ts.SourceFile, importFlags: ImportFlags): EmittedReference|null {\n    if (ref.bestGuessOwningModule === null) {\n      // There is no module name available for this Reference, meaning it was arrived at via a\n      // relative path.\n      return null;\n    } else if (!isDeclaration(ref.node)) {\n      // It's not possible to import something which isn't a declaration.\n      throw new Error(`Debug assert: unable to import a Reference to non-declaration of type ${\n          ts.SyntaxKind[ref.node.kind]}.`);\n    } else if ((importFlags & ImportFlags.AllowTypeImports) === 0 && isTypeDeclaration(ref.node)) {\n      throw new Error(`Importing a type-only declaration of type ${\n          ts.SyntaxKind[ref.node.kind]} in a value position is not allowed.`);\n    }\n\n    // Try to find the exported name of the declaration, if one is available.\n    const {specifier, resolutionContext} = ref.bestGuessOwningModule;\n    const exports = this.getExportsOfModule(specifier, resolutionContext);\n    if (exports === null || !exports.exportMap.has(ref.node)) {\n      // TODO(alxhub): make this error a ts.Diagnostic pointing at whatever caused this import to be\n      // triggered.\n      throw new Error(`Symbol ${ref.debugName} declared in ${\n          getSourceFile(ref.node).fileName} is not exported from ${specifier} (import into ${\n          context.fileName})`);\n    }\n    const symbolName = exports.exportMap.get(ref.node)!;\n\n    return {\n      expression: new ExternalExpr(new ExternalReference(specifier, symbolName)),\n      importedFile: exports.module,\n    };\n  }\n\n  private getExportsOfModule(moduleName: string, fromFile: string): ModuleExports|null {\n    if (!this.moduleExportsCache.has(moduleName)) {\n      this.moduleExportsCache.set(moduleName, this.enumerateExportsOfModule(moduleName, fromFile));\n    }\n    return this.moduleExportsCache.get(moduleName)!;\n  }\n\n  protected enumerateExportsOfModule(specifier: string, fromFile: string): ModuleExports|null {\n    // First, resolve the module specifier to its entry point, and get the ts.Symbol for it.\n    const entryPointFile = this.moduleResolver.resolveModule(specifier, fromFile);\n    if (entryPointFile === null) {\n      return null;\n    }\n\n    const exports = this.reflectionHost.getExportsOfModule(entryPointFile);\n    if (exports === null) {\n      return null;\n    }\n    const exportMap = new Map<DeclarationNode, string>();\n    exports.forEach((declaration, name) => {\n      exportMap.set(declaration.node, name);\n    });\n    return {module: entryPointFile, exportMap};\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which will refer to declarations via relative paths, provided they're\n * both in the logical project \"space\" of paths.\n *\n * This is trickier than it sounds, as the two files may be in different root directories in the\n * project. Simply calculating a file system relative path between the two is not sufficient.\n * Instead, `LogicalProjectPath`s are used.\n */\nexport class LogicalProjectStrategy implements ReferenceEmitStrategy {\n  constructor(private reflector: ReflectionHost, private logicalFs: LogicalFileSystem) {}\n\n  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n    const destSf = getSourceFile(ref.node);\n\n    // Compute the relative path from the importing file to the file being imported. This is done\n    // as a logical path computation, because the two files might be in different rootDirs.\n    const destPath = this.logicalFs.logicalPathOfSf(destSf);\n    if (destPath === null) {\n      // The imported file is not within the logical project filesystem.\n      return null;\n    }\n\n    const originPath = this.logicalFs.logicalPathOfSf(context);\n    if (originPath === null) {\n      throw new Error(\n          `Debug assert: attempt to import from ${context.fileName} but it's outside the program?`);\n    }\n\n    // There's no way to emit a relative reference from a file to itself.\n    if (destPath === originPath) {\n      return null;\n    }\n\n    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n    if (name === null) {\n      // The target declaration isn't exported from the file it's declared in. This is an issue!\n      return null;\n    }\n\n    // With both files expressed as LogicalProjectPaths, getting the module specifier as a relative\n    // path is now straightforward.\n    const moduleName = LogicalProjectPath.relativePathBetween(originPath, destPath);\n    return {\n      expression: new ExternalExpr({moduleName, name}),\n      importedFile: destSf,\n    };\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which constructs relatives paths between `ts.SourceFile`s.\n *\n * This strategy can be used if there is no `rootDir`/`rootDirs` structure for the project which\n * necessitates the stronger logic of `LogicalProjectStrategy`.\n */\nexport class RelativePathStrategy implements ReferenceEmitStrategy {\n  constructor(private reflector: ReflectionHost) {}\n\n  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n    const destSf = getSourceFile(ref.node);\n    const relativePath =\n        relative(dirname(absoluteFromSourceFile(context)), absoluteFromSourceFile(destSf));\n    const moduleName = toRelativeImport(stripExtension(relativePath));\n\n    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n    return {expression: new ExternalExpr({moduleName, name}), importedFile: destSf};\n  }\n}\n\n/**\n * A `ReferenceEmitStrategy` which uses a `UnifiedModulesHost` to generate absolute import\n * references.\n */\nexport class UnifiedModulesStrategy implements ReferenceEmitStrategy {\n  constructor(private reflector: ReflectionHost, private unifiedModulesHost: UnifiedModulesHost) {}\n\n  emit(ref: Reference, context: ts.SourceFile): EmittedReference|null {\n    const destSf = getSourceFile(ref.node);\n    const name = findExportedNameOfNode(ref.node, destSf, this.reflector);\n    if (name === null) {\n      return null;\n    }\n\n    const moduleName =\n        this.unifiedModulesHost.fileNameToModuleName(destSf.fileName, context.fileName);\n\n    return {\n      expression: new ExternalExpr({moduleName, name}),\n      importedFile: destSf,\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}