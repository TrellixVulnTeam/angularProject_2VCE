{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/i18n/serializers/serializer\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/i18n/i18n_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SimplePlaceholderMapper = exports.Serializer = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var i18n = require(\"@angular/compiler/src/i18n/i18n_ast\");\n\n  var Serializer =\n  /** @class */\n  function () {\n    function Serializer() {} // Creates a name mapper, see `PlaceholderMapper`\n    // Returning `null` means that no name mapping is used.\n\n\n    Serializer.prototype.createNameMapper = function (message) {\n      return null;\n    };\n\n    return Serializer;\n  }();\n\n  exports.Serializer = Serializer;\n  /**\n   * A simple mapper that take a function to transform an internal name to a public name\n   */\n\n  var SimplePlaceholderMapper =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(SimplePlaceholderMapper, _super); // create a mapping from the message\n\n\n    function SimplePlaceholderMapper(message, mapName) {\n      var _this = _super.call(this) || this;\n\n      _this.mapName = mapName;\n      _this.internalToPublic = {};\n      _this.publicToNextId = {};\n      _this.publicToInternal = {};\n      message.nodes.forEach(function (node) {\n        return node.visit(_this);\n      });\n      return _this;\n    }\n\n    SimplePlaceholderMapper.prototype.toPublicName = function (internalName) {\n      return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n    };\n\n    SimplePlaceholderMapper.prototype.toInternalName = function (publicName) {\n      return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n    };\n\n    SimplePlaceholderMapper.prototype.visitText = function (text, context) {\n      return null;\n    };\n\n    SimplePlaceholderMapper.prototype.visitTagPlaceholder = function (ph, context) {\n      this.visitPlaceholderName(ph.startName);\n\n      _super.prototype.visitTagPlaceholder.call(this, ph, context);\n\n      this.visitPlaceholderName(ph.closeName);\n    };\n\n    SimplePlaceholderMapper.prototype.visitPlaceholder = function (ph, context) {\n      this.visitPlaceholderName(ph.name);\n    };\n\n    SimplePlaceholderMapper.prototype.visitIcuPlaceholder = function (ph, context) {\n      this.visitPlaceholderName(ph.name);\n    }; // XMB placeholders could only contains A-Z, 0-9 and _\n\n\n    SimplePlaceholderMapper.prototype.visitPlaceholderName = function (internalName) {\n      if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n        return;\n      }\n\n      var publicName = this.mapName(internalName);\n\n      if (this.publicToInternal.hasOwnProperty(publicName)) {\n        // Create a new XMB when it has already been used\n        var nextId = this.publicToNextId[publicName];\n        this.publicToNextId[publicName] = nextId + 1;\n        publicName = publicName + \"_\" + nextId;\n      } else {\n        this.publicToNextId[publicName] = 1;\n      }\n\n      this.internalToPublic[internalName] = publicName;\n      this.publicToInternal[publicName] = internalName;\n    };\n\n    return SimplePlaceholderMapper;\n  }(i18n.RecurseVisitor);\n\n  exports.SimplePlaceholderMapper = SimplePlaceholderMapper;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/i18n/serializers/serializer.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,IAAA,GAAA,OAAA,CAAA,qCAAA,CAAA;;AAEA,MAAA,UAAA;AAAA;AAAA,cAAA;AAAA,aAAA,UAAA,GAAA,CAgBC,CAhBD,CAWE;AACA;;;AACA,IAAA,UAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,OAAjB,EAAsC;AACpC,aAAO,IAAP;AACD,KAFD;;AAGF,WAAA,UAAA;AAAC,GAhBD,EAAA;;AAAsB,EAAA,OAAA,CAAA,UAAA,GAAA,UAAA;AA8BtB;;AAEG;;AACH,MAAA,uBAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAA6C,IAAA,OAAA,CAAA,SAAA,CAAA,uBAAA,EAAA,MAAA,EAA7C,CAKE;;;AACA,aAAA,uBAAA,CAAY,OAAZ,EAA2C,OAA3C,EAA4E;AAA5E,UAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IADT;;AAA2C,MAAA,KAAA,CAAA,OAAA,GAAA,OAAA;AALnC,MAAA,KAAA,CAAA,gBAAA,GAA0C,EAA1C;AACA,MAAA,KAAA,CAAA,cAAA,GAAwC,EAAxC;AACA,MAAA,KAAA,CAAA,gBAAA,GAA0C,EAA1C;AAKN,MAAA,OAAO,CAAC,KAAR,CAAc,OAAd,CAAsB,UAAA,IAAA,EAAI;AAAI,eAAA,IAAI,CAAC,KAAL,CAAA,KAAA,CAAA;AAAgB,OAA9C;;AACD;;AAED,IAAA,uBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,YAAb,EAAiC;AAC/B,aAAO,KAAK,gBAAL,CAAsB,cAAtB,CAAqC,YAArC,IACH,KAAK,gBAAL,CAAsB,YAAtB,CADG,GAEH,IAFJ;AAGD,KAJD;;AAMA,IAAA,uBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,UAAf,EAAiC;AAC/B,aAAO,KAAK,gBAAL,CAAsB,cAAtB,CAAqC,UAArC,IAAmD,KAAK,gBAAL,CAAsB,UAAtB,CAAnD,GACmD,IAD1D;AAED,KAHD;;AAKA,IAAA,uBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,IAAV,EAA2B,OAA3B,EAAwC;AACtC,aAAO,IAAP;AACD,KAFD;;AAIA,IAAA,uBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,EAApB,EAA6C,OAA7C,EAA0D;AACxD,WAAK,oBAAL,CAA0B,EAAE,CAAC,SAA7B;;AACA,MAAA,MAAA,CAAA,SAAA,CAAM,mBAAN,CAAyB,IAAzB,CAAyB,IAAzB,EAA0B,EAA1B,EAA8B,OAA9B;;AACA,WAAK,oBAAL,CAA0B,EAAE,CAAC,SAA7B;AACD,KAJD;;AAMA,IAAA,uBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,EAAjB,EAAuC,OAAvC,EAAoD;AAClD,WAAK,oBAAL,CAA0B,EAAE,CAAC,IAA7B;AACD,KAFD;;AAIA,IAAA,uBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,EAApB,EAA6C,OAA7C,EAA0D;AACxD,WAAK,oBAAL,CAA0B,EAAE,CAAC,IAA7B;AACD,KAFD,CApCF,CAwCE;;;AACQ,IAAA,uBAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UAA6B,YAA7B,EAAiD;AAC/C,UAAI,CAAC,YAAD,IAAiB,KAAK,gBAAL,CAAsB,cAAtB,CAAqC,YAArC,CAArB,EAAyE;AACvE;AACD;;AAED,UAAI,UAAU,GAAG,KAAK,OAAL,CAAa,YAAb,CAAjB;;AAEA,UAAI,KAAK,gBAAL,CAAsB,cAAtB,CAAqC,UAArC,CAAJ,EAAsD;AACpD;AACA,YAAM,MAAM,GAAG,KAAK,cAAL,CAAoB,UAApB,CAAf;AACA,aAAK,cAAL,CAAoB,UAApB,IAAkC,MAAM,GAAG,CAA3C;AACA,QAAA,UAAU,GAAM,UAAU,GAAA,GAAV,GAAc,MAA9B;AACD,OALD,MAKO;AACL,aAAK,cAAL,CAAoB,UAApB,IAAkC,CAAlC;AACD;;AAED,WAAK,gBAAL,CAAsB,YAAtB,IAAsC,UAAtC;AACA,WAAK,gBAAL,CAAsB,UAAtB,IAAoC,YAApC;AACD,KAlBO;;AAmBV,WAAA,uBAAA;AAAC,GA5DD,CAA6C,IAAI,CAAC,cAAlD,CAAA;;AAAa,EAAA,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from '../i18n_ast';\n\nexport abstract class Serializer {\n  // - The `placeholders` and `placeholderToMessage` properties are irrelevant in the input messages\n  // - The `id` contains the message id that the serializer is expected to use\n  // - Placeholder names are already map to public names using the provided mapper\n  abstract write(messages: i18n.Message[], locale: string|null): string;\n\n  abstract load(content: string, url: string):\n      {locale: string|null, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}};\n\n  abstract digest(message: i18n.Message): string;\n\n  // Creates a name mapper, see `PlaceholderMapper`\n  // Returning `null` means that no name mapping is used.\n  createNameMapper(message: i18n.Message): PlaceholderMapper|null {\n    return null;\n  }\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string|null;\n\n  toInternalName(publicName: string): string|null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string|null {\n    return this.internalToPublic.hasOwnProperty(internalName) ?\n        this.internalToPublic[internalName] :\n        null;\n  }\n\n  toInternalName(publicName: string): string|null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n                                                              null;\n  }\n\n  visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}