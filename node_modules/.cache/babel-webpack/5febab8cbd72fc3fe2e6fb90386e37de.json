{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/bundle_program\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/ngcc/src/packages/patch_ts_expando_initializer\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.findR3SymbolsPath = exports.makeBundleProgram = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var patch_ts_expando_initializer_1 = require(\"@angular/compiler-cli/ngcc/src/packages/patch_ts_expando_initializer\");\n  /**\n   * Create a bundle program.\n   */\n\n\n  function makeBundleProgram(fs, isCore, pkg, path, r3FileName, options, host, additionalFiles) {\n    if (additionalFiles === void 0) {\n      additionalFiles = [];\n    }\n\n    var r3SymbolsPath = isCore ? findR3SymbolsPath(fs, fs.dirname(path), r3FileName) : null;\n    var rootPaths = r3SymbolsPath ? tslib_1.__spread([path, r3SymbolsPath], additionalFiles) : tslib_1.__spread([path], additionalFiles);\n    var originalGetExpandoInitializer = patch_ts_expando_initializer_1.patchTsGetExpandoInitializer();\n    var program = ts.createProgram(rootPaths, options, host); // Ask for the typeChecker to trigger the binding phase of the compilation.\n    // This will then exercise the patched function.\n\n    program.getTypeChecker();\n    patch_ts_expando_initializer_1.restoreGetExpandoInitializer(originalGetExpandoInitializer);\n    var file = program.getSourceFile(path);\n    var r3SymbolsFile = r3SymbolsPath && program.getSourceFile(r3SymbolsPath) || null;\n    return {\n      program: program,\n      options: options,\n      host: host,\n      package: pkg,\n      path: path,\n      file: file,\n      r3SymbolsPath: r3SymbolsPath,\n      r3SymbolsFile: r3SymbolsFile\n    };\n  }\n\n  exports.makeBundleProgram = makeBundleProgram;\n  /**\n   * Search the given directory hierarchy to find the path to the `r3_symbols` file.\n   */\n\n  function findR3SymbolsPath(fs, directory, filename) {\n    var e_1, _a;\n\n    var r3SymbolsFilePath = fs.resolve(directory, filename);\n\n    if (fs.exists(r3SymbolsFilePath)) {\n      return r3SymbolsFilePath;\n    }\n\n    var subDirectories = fs.readdir(directory) // Not interested in hidden files\n    .filter(function (p) {\n      return !p.startsWith('.');\n    }) // Ignore node_modules\n    .filter(function (p) {\n      return p !== 'node_modules';\n    }) // Only interested in directories (and only those that are not symlinks)\n    .filter(function (p) {\n      var stat = fs.lstat(fs.resolve(directory, p));\n      return stat.isDirectory() && !stat.isSymbolicLink();\n    });\n\n    try {\n      for (var subDirectories_1 = tslib_1.__values(subDirectories), subDirectories_1_1 = subDirectories_1.next(); !subDirectories_1_1.done; subDirectories_1_1 = subDirectories_1.next()) {\n        var subDirectory = subDirectories_1_1.value;\n        var r3SymbolsFilePath_1 = findR3SymbolsPath(fs, fs.resolve(directory, subDirectory), filename);\n\n        if (r3SymbolsFilePath_1) {\n          return r3SymbolsFilePath_1;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (subDirectories_1_1 && !subDirectories_1_1.done && (_a = subDirectories_1.return)) _a.call(subDirectories_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return null;\n  }\n\n  exports.findR3SymbolsPath = findR3SymbolsPath;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/bundle_program.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\n\nimport {patchTsGetExpandoInitializer, restoreGetExpandoInitializer} from './patch_ts_expando_initializer';\n\n/**\n * An entry point bundle contains one or two programs, e.g. `src` and `dts`,\n * that are compiled via TypeScript.\n *\n * To aid with processing the program, this interface exposes the program itself,\n * as well as path and TS file of the entry-point to the program and the r3Symbols\n * file, if appropriate.\n */\nexport interface BundleProgram {\n  program: ts.Program;\n  options: ts.CompilerOptions;\n  host: ts.CompilerHost;\n  path: AbsoluteFsPath;\n  file: ts.SourceFile;\n  package: AbsoluteFsPath;\n  r3SymbolsPath: AbsoluteFsPath|null;\n  r3SymbolsFile: ts.SourceFile|null;\n}\n\n/**\n * Create a bundle program.\n */\nexport function makeBundleProgram(\n    fs: ReadonlyFileSystem, isCore: boolean, pkg: AbsoluteFsPath, path: AbsoluteFsPath,\n    r3FileName: string, options: ts.CompilerOptions, host: ts.CompilerHost,\n    additionalFiles: AbsoluteFsPath[] = []): BundleProgram {\n  const r3SymbolsPath = isCore ? findR3SymbolsPath(fs, fs.dirname(path), r3FileName) : null;\n  let rootPaths =\n      r3SymbolsPath ? [path, r3SymbolsPath, ...additionalFiles] : [path, ...additionalFiles];\n\n  const originalGetExpandoInitializer = patchTsGetExpandoInitializer();\n  const program = ts.createProgram(rootPaths, options, host);\n  // Ask for the typeChecker to trigger the binding phase of the compilation.\n  // This will then exercise the patched function.\n  program.getTypeChecker();\n  restoreGetExpandoInitializer(originalGetExpandoInitializer);\n\n  const file = program.getSourceFile(path)!;\n  const r3SymbolsFile = r3SymbolsPath && program.getSourceFile(r3SymbolsPath) || null;\n\n  return {program, options, host, package: pkg, path, file, r3SymbolsPath, r3SymbolsFile};\n}\n\n/**\n * Search the given directory hierarchy to find the path to the `r3_symbols` file.\n */\nexport function findR3SymbolsPath(\n    fs: ReadonlyFileSystem, directory: AbsoluteFsPath, filename: string): AbsoluteFsPath|null {\n  const r3SymbolsFilePath = fs.resolve(directory, filename);\n  if (fs.exists(r3SymbolsFilePath)) {\n    return r3SymbolsFilePath;\n  }\n\n  const subDirectories =\n      fs.readdir(directory)\n          // Not interested in hidden files\n          .filter(p => !p.startsWith('.'))\n          // Ignore node_modules\n          .filter(p => p !== 'node_modules')\n          // Only interested in directories (and only those that are not symlinks)\n          .filter(p => {\n            const stat = fs.lstat(fs.resolve(directory, p));\n            return stat.isDirectory() && !stat.isSymbolicLink();\n          });\n\n  for (const subDirectory of subDirectories) {\n    const r3SymbolsFilePath = findR3SymbolsPath(fs, fs.resolve(directory, subDirectory), filename);\n    if (r3SymbolsFilePath) {\n      return r3SymbolsFilePath;\n    }\n  }\n\n  return null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}