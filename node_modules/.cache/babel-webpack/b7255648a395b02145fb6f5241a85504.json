{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSystemPath = exports.asPosixPath = exports.asWindowsPath = exports.path = exports.noCacheNormalize = exports.normalize = exports.resetNormalizeCache = exports.fragment = exports.resolve = exports.relative = exports.isAbsolute = exports.join = exports.dirname = exports.basename = exports.extname = exports.split = exports.NormalizedRoot = exports.NormalizedSep = exports.PathCannotBeFragmentException = exports.PathMustBeAbsoluteException = exports.InvalidPathException = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar exception_1 = require(\"../exception\");\n\nvar InvalidPathException = /*#__PURE__*/function (_exception_1$BaseExce) {\n  _inherits(InvalidPathException, _exception_1$BaseExce);\n\n  var _super = _createSuper(InvalidPathException);\n\n  function InvalidPathException(path) {\n    _classCallCheck(this, InvalidPathException);\n\n    return _super.call(this, \"Path \".concat(JSON.stringify(path), \" is invalid.\"));\n  }\n\n  return InvalidPathException;\n}(exception_1.BaseException);\n\nexports.InvalidPathException = InvalidPathException;\n\nvar PathMustBeAbsoluteException = /*#__PURE__*/function (_exception_1$BaseExce2) {\n  _inherits(PathMustBeAbsoluteException, _exception_1$BaseExce2);\n\n  var _super2 = _createSuper(PathMustBeAbsoluteException);\n\n  function PathMustBeAbsoluteException(path) {\n    _classCallCheck(this, PathMustBeAbsoluteException);\n\n    return _super2.call(this, \"Path \".concat(JSON.stringify(path), \" must be absolute.\"));\n  }\n\n  return PathMustBeAbsoluteException;\n}(exception_1.BaseException);\n\nexports.PathMustBeAbsoluteException = PathMustBeAbsoluteException;\n\nvar PathCannotBeFragmentException = /*#__PURE__*/function (_exception_1$BaseExce3) {\n  _inherits(PathCannotBeFragmentException, _exception_1$BaseExce3);\n\n  var _super3 = _createSuper(PathCannotBeFragmentException);\n\n  function PathCannotBeFragmentException(path) {\n    _classCallCheck(this, PathCannotBeFragmentException);\n\n    return _super3.call(this, \"Path \".concat(JSON.stringify(path), \" cannot be made a fragment.\"));\n  }\n\n  return PathCannotBeFragmentException;\n}(exception_1.BaseException);\n\nexports.PathCannotBeFragmentException = PathCannotBeFragmentException;\n/**\n * The Separator for normalized path.\n * @type {Path}\n */\n\nexports.NormalizedSep = '/';\n/**\n * The root of a normalized path.\n * @type {Path}\n */\n\nexports.NormalizedRoot = exports.NormalizedSep;\n/**\n * Split a path into multiple path fragments. Each fragments except the last one will end with\n * a path separator.\n * @param {Path} path The path to split.\n * @returns {Path[]} An array of path fragments.\n */\n\nfunction split(path) {\n  var fragments = path.split(exports.NormalizedSep).map(function (x) {\n    return fragment(x);\n  });\n\n  if (fragments[fragments.length - 1].length === 0) {\n    fragments.pop();\n  }\n\n  return fragments;\n}\n\nexports.split = split;\n/**\n *\n */\n\nfunction extname(path) {\n  var base = basename(path);\n  var i = base.lastIndexOf('.');\n\n  if (i < 1) {\n    return '';\n  } else {\n    return base.substr(i);\n  }\n}\n\nexports.extname = extname;\n/**\n * Return the basename of the path, as a Path. See path.basename\n */\n\nfunction basename(path) {\n  var i = path.lastIndexOf(exports.NormalizedSep);\n\n  if (i == -1) {\n    return fragment(path);\n  } else {\n    return fragment(path.substr(path.lastIndexOf(exports.NormalizedSep) + 1));\n  }\n}\n\nexports.basename = basename;\n/**\n * Return the dirname of the path, as a Path. See path.dirname\n */\n\nfunction dirname(path) {\n  var index = path.lastIndexOf(exports.NormalizedSep);\n\n  if (index === -1) {\n    return '';\n  }\n\n  var endIndex = index === 0 ? 1 : index; // case of file under root: '/file'\n\n  return normalize(path.substr(0, endIndex));\n}\n\nexports.dirname = dirname;\n/**\n * Join multiple paths together, and normalize the result. Accepts strings that will be\n * normalized as well (but the original must be a path).\n */\n\nfunction join(p1) {\n  for (var _len = arguments.length, others = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    others[_key - 1] = arguments[_key];\n  }\n\n  if (others.length > 0) {\n    return normalize((p1 ? p1 + exports.NormalizedSep : '') + others.join(exports.NormalizedSep));\n  } else {\n    return p1;\n  }\n}\n\nexports.join = join;\n/**\n * Returns true if a path is absolute.\n */\n\nfunction isAbsolute(p) {\n  return p.startsWith(exports.NormalizedSep);\n}\n\nexports.isAbsolute = isAbsolute;\n/**\n * Returns a path such that `join(from, relative(from, to)) == to`.\n * Both paths must be absolute, otherwise it does not make much sense.\n */\n\nfunction relative(from, to) {\n  if (!isAbsolute(from)) {\n    throw new PathMustBeAbsoluteException(from);\n  }\n\n  if (!isAbsolute(to)) {\n    throw new PathMustBeAbsoluteException(to);\n  }\n\n  var p;\n\n  if (from == to) {\n    p = '';\n  } else {\n    var splitFrom = split(from);\n    var splitTo = split(to);\n\n    while (splitFrom.length > 0 && splitTo.length > 0 && splitFrom[0] == splitTo[0]) {\n      splitFrom.shift();\n      splitTo.shift();\n    }\n\n    if (splitFrom.length == 0) {\n      p = splitTo.join(exports.NormalizedSep);\n    } else {\n      p = splitFrom.map(function (_) {\n        return '..';\n      }).concat(splitTo).join(exports.NormalizedSep);\n    }\n  }\n\n  return normalize(p);\n}\n\nexports.relative = relative;\n/**\n * Returns a Path that is the resolution of p2, from p1. If p2 is absolute, it will return p2,\n * otherwise will join both p1 and p2.\n */\n\nfunction resolve(p1, p2) {\n  if (isAbsolute(p2)) {\n    return p2;\n  } else {\n    return join(p1, p2);\n  }\n}\n\nexports.resolve = resolve;\n\nfunction fragment(path) {\n  if (path.indexOf(exports.NormalizedSep) != -1) {\n    throw new PathCannotBeFragmentException(path);\n  }\n\n  return path;\n}\n\nexports.fragment = fragment;\n/**\n * normalize() cache to reduce computation. For now this grows and we never flush it, but in the\n * future we might want to add a few cache flush to prevent this from growing too large.\n */\n\nvar normalizedCache = new Map();\n/**\n * Reset the cache. This is only useful for testing.\n * @private\n */\n\nfunction resetNormalizeCache() {\n  normalizedCache = new Map();\n}\n\nexports.resetNormalizeCache = resetNormalizeCache;\n/**\n * Normalize a string into a Path. This is the only mean to get a Path type from a string that\n * represents a system path. This method cache the results as real world paths tend to be\n * duplicated often.\n * Normalization includes:\n *   - Windows backslashes `\\\\` are replaced with `/`.\n *   - Windows drivers are replaced with `/X/`, where X is the drive letter.\n *   - Absolute paths starts with `/`.\n *   - Multiple `/` are replaced by a single one.\n *   - Path segments `.` are removed.\n *   - Path segments `..` are resolved.\n *   - If a path is absolute, having a `..` at the start is invalid (and will throw).\n * @param path The path to be normalized.\n */\n\nfunction normalize(path) {\n  var maybePath = normalizedCache.get(path);\n\n  if (!maybePath) {\n    maybePath = noCacheNormalize(path);\n    normalizedCache.set(path, maybePath);\n  }\n\n  return maybePath;\n}\n\nexports.normalize = normalize;\n/**\n * The no cache version of the normalize() function. Used for benchmarking and testing.\n */\n\nfunction noCacheNormalize(path) {\n  if (path == '' || path == '.') {\n    return '';\n  } else if (path == exports.NormalizedRoot) {\n    return exports.NormalizedRoot;\n  } // Match absolute windows path.\n\n\n  var original = path;\n\n  if (path.match(/^[A-Z]:[\\/\\\\]/i)) {\n    path = '\\\\' + path[0] + '\\\\' + path.substr(3);\n  } // We convert Windows paths as well here.\n\n\n  var p = path.split(/[\\/\\\\]/g);\n  var relative = false;\n  var i = 1; // Special case the first one.\n\n  if (p[0] != '') {\n    p.unshift('.');\n    relative = true;\n  }\n\n  while (i < p.length) {\n    if (p[i] == '.') {\n      p.splice(i, 1);\n    } else if (p[i] == '..') {\n      if (i < 2 && !relative) {\n        throw new InvalidPathException(original);\n      } else if (i >= 2 && p[i - 1] != '..') {\n        p.splice(i - 1, 2);\n        i--;\n      } else {\n        i++;\n      }\n    } else if (p[i] == '') {\n      p.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  if (p.length == 1) {\n    return p[0] == '' ? exports.NormalizedSep : '';\n  } else {\n    if (p[0] == '.') {\n      p.shift();\n    }\n\n    return p.join(exports.NormalizedSep);\n  }\n}\n\nexports.noCacheNormalize = noCacheNormalize;\n\nexports.path = function (strings) {\n  for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    values[_key2 - 1] = arguments[_key2];\n  }\n\n  return normalize(String.raw.apply(String, [strings].concat(values)));\n};\n\nfunction asWindowsPath(path) {\n  var drive = path.match(/^\\/(\\w)(?:\\/(.*))?$/);\n\n  if (drive) {\n    var subPath = drive[2] ? drive[2].replace(/\\//g, '\\\\') : '';\n    return \"\".concat(drive[1], \":\\\\\").concat(subPath);\n  }\n\n  return path.replace(/\\//g, '\\\\');\n}\n\nexports.asWindowsPath = asWindowsPath;\n\nfunction asPosixPath(path) {\n  return path;\n}\n\nexports.asPosixPath = asPosixPath;\n\nfunction getSystemPath(path) {\n  if (process.platform.startsWith('win32')) {\n    return asWindowsPath(path);\n  } else {\n    return asPosixPath(path);\n  }\n}\n\nexports.getSystemPath = getSystemPath;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/virtual-fs/path.js"],"names":["Object","defineProperty","exports","value","getSystemPath","asPosixPath","asWindowsPath","path","noCacheNormalize","normalize","resetNormalizeCache","fragment","resolve","relative","isAbsolute","join","dirname","basename","extname","split","NormalizedRoot","NormalizedSep","PathCannotBeFragmentException","PathMustBeAbsoluteException","InvalidPathException","exception_1","require","JSON","stringify","BaseException","fragments","map","x","length","pop","base","i","lastIndexOf","substr","index","endIndex","p1","others","p","startsWith","from","to","splitFrom","splitTo","shift","_","concat","p2","indexOf","normalizedCache","Map","maybePath","get","set","original","match","unshift","splice","strings","values","String","raw","drive","subPath","replace","process","platform"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getSystemPath = exports.asPosixPath = exports.asWindowsPath = exports.path = exports.noCacheNormalize = exports.normalize = exports.resetNormalizeCache = exports.fragment = exports.resolve = exports.relative = exports.isAbsolute = exports.join = exports.dirname = exports.basename = exports.extname = exports.split = exports.NormalizedRoot = exports.NormalizedSep = exports.PathCannotBeFragmentException = exports.PathMustBeAbsoluteException = exports.InvalidPathException = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst exception_1 = require(\"../exception\");\nclass InvalidPathException extends exception_1.BaseException {\n    constructor(path) { super(`Path ${JSON.stringify(path)} is invalid.`); }\n}\nexports.InvalidPathException = InvalidPathException;\nclass PathMustBeAbsoluteException extends exception_1.BaseException {\n    constructor(path) { super(`Path ${JSON.stringify(path)} must be absolute.`); }\n}\nexports.PathMustBeAbsoluteException = PathMustBeAbsoluteException;\nclass PathCannotBeFragmentException extends exception_1.BaseException {\n    constructor(path) { super(`Path ${JSON.stringify(path)} cannot be made a fragment.`); }\n}\nexports.PathCannotBeFragmentException = PathCannotBeFragmentException;\n/**\n * The Separator for normalized path.\n * @type {Path}\n */\nexports.NormalizedSep = '/';\n/**\n * The root of a normalized path.\n * @type {Path}\n */\nexports.NormalizedRoot = exports.NormalizedSep;\n/**\n * Split a path into multiple path fragments. Each fragments except the last one will end with\n * a path separator.\n * @param {Path} path The path to split.\n * @returns {Path[]} An array of path fragments.\n */\nfunction split(path) {\n    const fragments = path.split(exports.NormalizedSep).map(x => fragment(x));\n    if (fragments[fragments.length - 1].length === 0) {\n        fragments.pop();\n    }\n    return fragments;\n}\nexports.split = split;\n/**\n *\n */\nfunction extname(path) {\n    const base = basename(path);\n    const i = base.lastIndexOf('.');\n    if (i < 1) {\n        return '';\n    }\n    else {\n        return base.substr(i);\n    }\n}\nexports.extname = extname;\n/**\n * Return the basename of the path, as a Path. See path.basename\n */\nfunction basename(path) {\n    const i = path.lastIndexOf(exports.NormalizedSep);\n    if (i == -1) {\n        return fragment(path);\n    }\n    else {\n        return fragment(path.substr(path.lastIndexOf(exports.NormalizedSep) + 1));\n    }\n}\nexports.basename = basename;\n/**\n * Return the dirname of the path, as a Path. See path.dirname\n */\nfunction dirname(path) {\n    const index = path.lastIndexOf(exports.NormalizedSep);\n    if (index === -1) {\n        return '';\n    }\n    const endIndex = index === 0 ? 1 : index; // case of file under root: '/file'\n    return normalize(path.substr(0, endIndex));\n}\nexports.dirname = dirname;\n/**\n * Join multiple paths together, and normalize the result. Accepts strings that will be\n * normalized as well (but the original must be a path).\n */\nfunction join(p1, ...others) {\n    if (others.length > 0) {\n        return normalize((p1 ? p1 + exports.NormalizedSep : '') + others.join(exports.NormalizedSep));\n    }\n    else {\n        return p1;\n    }\n}\nexports.join = join;\n/**\n * Returns true if a path is absolute.\n */\nfunction isAbsolute(p) {\n    return p.startsWith(exports.NormalizedSep);\n}\nexports.isAbsolute = isAbsolute;\n/**\n * Returns a path such that `join(from, relative(from, to)) == to`.\n * Both paths must be absolute, otherwise it does not make much sense.\n */\nfunction relative(from, to) {\n    if (!isAbsolute(from)) {\n        throw new PathMustBeAbsoluteException(from);\n    }\n    if (!isAbsolute(to)) {\n        throw new PathMustBeAbsoluteException(to);\n    }\n    let p;\n    if (from == to) {\n        p = '';\n    }\n    else {\n        const splitFrom = split(from);\n        const splitTo = split(to);\n        while (splitFrom.length > 0 && splitTo.length > 0 && splitFrom[0] == splitTo[0]) {\n            splitFrom.shift();\n            splitTo.shift();\n        }\n        if (splitFrom.length == 0) {\n            p = splitTo.join(exports.NormalizedSep);\n        }\n        else {\n            p = splitFrom.map(_ => '..').concat(splitTo).join(exports.NormalizedSep);\n        }\n    }\n    return normalize(p);\n}\nexports.relative = relative;\n/**\n * Returns a Path that is the resolution of p2, from p1. If p2 is absolute, it will return p2,\n * otherwise will join both p1 and p2.\n */\nfunction resolve(p1, p2) {\n    if (isAbsolute(p2)) {\n        return p2;\n    }\n    else {\n        return join(p1, p2);\n    }\n}\nexports.resolve = resolve;\nfunction fragment(path) {\n    if (path.indexOf(exports.NormalizedSep) != -1) {\n        throw new PathCannotBeFragmentException(path);\n    }\n    return path;\n}\nexports.fragment = fragment;\n/**\n * normalize() cache to reduce computation. For now this grows and we never flush it, but in the\n * future we might want to add a few cache flush to prevent this from growing too large.\n */\nlet normalizedCache = new Map();\n/**\n * Reset the cache. This is only useful for testing.\n * @private\n */\nfunction resetNormalizeCache() {\n    normalizedCache = new Map();\n}\nexports.resetNormalizeCache = resetNormalizeCache;\n/**\n * Normalize a string into a Path. This is the only mean to get a Path type from a string that\n * represents a system path. This method cache the results as real world paths tend to be\n * duplicated often.\n * Normalization includes:\n *   - Windows backslashes `\\\\` are replaced with `/`.\n *   - Windows drivers are replaced with `/X/`, where X is the drive letter.\n *   - Absolute paths starts with `/`.\n *   - Multiple `/` are replaced by a single one.\n *   - Path segments `.` are removed.\n *   - Path segments `..` are resolved.\n *   - If a path is absolute, having a `..` at the start is invalid (and will throw).\n * @param path The path to be normalized.\n */\nfunction normalize(path) {\n    let maybePath = normalizedCache.get(path);\n    if (!maybePath) {\n        maybePath = noCacheNormalize(path);\n        normalizedCache.set(path, maybePath);\n    }\n    return maybePath;\n}\nexports.normalize = normalize;\n/**\n * The no cache version of the normalize() function. Used for benchmarking and testing.\n */\nfunction noCacheNormalize(path) {\n    if (path == '' || path == '.') {\n        return '';\n    }\n    else if (path == exports.NormalizedRoot) {\n        return exports.NormalizedRoot;\n    }\n    // Match absolute windows path.\n    const original = path;\n    if (path.match(/^[A-Z]:[\\/\\\\]/i)) {\n        path = '\\\\' + path[0] + '\\\\' + path.substr(3);\n    }\n    // We convert Windows paths as well here.\n    const p = path.split(/[\\/\\\\]/g);\n    let relative = false;\n    let i = 1;\n    // Special case the first one.\n    if (p[0] != '') {\n        p.unshift('.');\n        relative = true;\n    }\n    while (i < p.length) {\n        if (p[i] == '.') {\n            p.splice(i, 1);\n        }\n        else if (p[i] == '..') {\n            if (i < 2 && !relative) {\n                throw new InvalidPathException(original);\n            }\n            else if (i >= 2 && p[i - 1] != '..') {\n                p.splice(i - 1, 2);\n                i--;\n            }\n            else {\n                i++;\n            }\n        }\n        else if (p[i] == '') {\n            p.splice(i, 1);\n        }\n        else {\n            i++;\n        }\n    }\n    if (p.length == 1) {\n        return p[0] == '' ? exports.NormalizedSep : '';\n    }\n    else {\n        if (p[0] == '.') {\n            p.shift();\n        }\n        return p.join(exports.NormalizedSep);\n    }\n}\nexports.noCacheNormalize = noCacheNormalize;\nexports.path = (strings, ...values) => {\n    return normalize(String.raw(strings, ...values));\n};\nfunction asWindowsPath(path) {\n    const drive = path.match(/^\\/(\\w)(?:\\/(.*))?$/);\n    if (drive) {\n        const subPath = drive[2] ? drive[2].replace(/\\//g, '\\\\') : '';\n        return `${drive[1]}:\\\\${subPath}`;\n    }\n    return path.replace(/\\//g, '\\\\');\n}\nexports.asWindowsPath = asWindowsPath;\nfunction asPosixPath(path) {\n    return path;\n}\nexports.asPosixPath = asPosixPath;\nfunction getSystemPath(path) {\n    if (process.platform.startsWith('win32')) {\n        return asWindowsPath(path);\n    }\n    else {\n        return asPosixPath(path);\n    }\n}\nexports.getSystemPath = getSystemPath;\n"]},"metadata":{},"sourceType":"script"}