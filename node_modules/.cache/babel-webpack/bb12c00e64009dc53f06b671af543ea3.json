{"ast":null,"code":"var util = require('util');\n\nvar events = require('events').EventEmitter;\n\nvar qjob = function qjob(options) {\n  if (false === this instanceof qjob) {\n    return new qjob(options);\n  }\n\n  this.maxConcurrency = 10;\n  this.jobsRunning = 0;\n  this.jobsDone = 0;\n  this.jobsTotal = 0;\n  this.timeStart;\n  this.jobId = 0;\n  this.jobsList = [];\n  this.paused = false;\n  this.pausedId = null;\n  this.lastPause = 0;\n  this.interval = null;\n  this.stopAdding = false;\n  this.sleeping = false;\n  this.aborting = false;\n\n  if (options) {\n    this.maxConcurrency = options.maxConcurrency || this.maxConcurrency;\n    this.interval = options.interval || this.interval;\n  }\n\n  events.call(this);\n};\n\nutil.inherits(qjob, events);\n/*\n * helper to set max concurrency\n */\n\nqjob.prototype.setConcurrency = function (max) {\n  this.maxConcurrency = max;\n};\n/*\n * helper to set delay between rafales\n */\n\n\nqjob.prototype.setInterval = function (delay) {\n  this.interval = delay;\n};\n/*\n * add some jobs in the queue\n */\n\n\nqjob.prototype.add = function (job, args) {\n  var self = this;\n  self.jobsList.push([job, args]);\n  self.jobsTotal++;\n};\n/*\n *\n */\n\n\nqjob.prototype.sleepDueToInterval = function () {\n  var self = this;\n\n  if (this.interval === null) {\n    return;\n  }\n\n  if (this.sleeping) {\n    return true;\n  }\n\n  if (this.stopAdding) {\n    if (this.jobsRunning > 0) {\n      //console.log('waiting for '+jobsRunning+' jobs to finish');\n      return true;\n    } //console.log('waiting for '+rafaleDelay+' ms');\n\n\n    this.sleeping = true;\n    self.emit('sleep');\n    setTimeout(function () {\n      this.stopAdding = false;\n      this.sleeping = false;\n      self.emit('continu');\n      self.run();\n    }.bind(self), this.interval);\n    return true;\n  }\n\n  if (this.jobsRunning + 1 == this.maxConcurrency) {\n    //console.log('max concurrent jobs reached');\n    this.stopAdding = true;\n    return true;\n  }\n};\n/*\n * run the queue\n */\n\n\nqjob.prototype.run = function () {\n  var self = this; // first launch, let's emit start event\n\n  if (this.jobsDone == 0) {\n    self.emit('start');\n    this.timeStart = Date.now();\n  }\n\n  if (self.sleepDueToInterval()) return;\n\n  if (self.aborting) {\n    this.jobsList = [];\n  } // while queue is empty and number of job running\n  // concurrently are less than max job running,\n  // then launch the next job\n\n\n  while (this.jobsList.length && this.jobsRunning < this.maxConcurrency) {\n    // get the next job and\n    // remove it from the queue\n    var job = self.jobsList.shift(); // increment number of job running\n\n    self.jobsRunning++; // fetch args for the job\n\n    var args = job[1]; // add jobId in args\n\n    args._jobId = this.jobId++; // emit jobStart event\n\n    self.emit('jobStart', args); // run the job\n\n    setTimeout(function () {\n      this.j(this.args, self.next.bind(self, this.args));\n    }.bind({\n      j: job[0],\n      args: args\n    }), 1);\n  } // all jobs done ? emit end event\n\n\n  if (this.jobsList.length == 0 && this.jobsRunning == 0) {\n    self.emit('end');\n  }\n};\n/*\n * a task has been terminated,\n * so 'next()' has been called\n */\n\n\nqjob.prototype.next = function (args) {\n  var self = this; // update counters\n\n  this.jobsRunning--;\n  this.jobsDone++; // emit 'jobEnd' event\n\n  self.emit('jobEnd', args); // if queue has been set to pause\n  // then do nothing\n\n  if (this.paused) return; // else, execute run() function\n\n  self.run();\n};\n/*\n * You can 'pause' jobs.\n * it will not pause running jobs, but\n * it will stop launching pending jobs\n * until paused = false\n */\n\n\nqjob.prototype.pause = function (status) {\n  var self = this;\n  this.paused = status;\n\n  if (!this.paused && this.pausedId) {\n    clearInterval(this.pausedId);\n    self.emit('unpause');\n    this.run();\n  }\n\n  if (this.paused && !this.pausedId) {\n    self.lastPause = Date.now();\n    this.pausedId = setInterval(function () {\n      var since = Date.now() - self.lastPause;\n      self.emit('pause', since);\n    }, 1000);\n    return;\n  }\n};\n\nqjob.prototype.stats = function () {\n  var now = Date.now();\n  var o = {};\n  o._timeStart = this.timeStart || 'N/A';\n  o._timeElapsed = now - this.timeStart || 'N/A';\n  o._jobsTotal = this.jobsTotal;\n  o._jobsRunning = this.jobsRunning;\n  o._jobsDone = this.jobsDone;\n  o._progress = Math.floor(this.jobsDone / this.jobsTotal * 100);\n  o._concurrency = this.maxConcurrency;\n\n  if (this.paused) {\n    o._status = 'Paused';\n    return o;\n  }\n\n  if (o._timeElapsed == 'N/A') {\n    o._status = 'Starting';\n    return o;\n  }\n\n  if (this.jobsTotal == this.jobsDone) {\n    o._status = 'Finished';\n    return o;\n  }\n\n  o._status = 'Running';\n  return o;\n};\n\nqjob.prototype.abort = function () {\n  this.aborting = true;\n};\n\nmodule.exports = qjob;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/qjobs/qjobs.js"],"names":["util","require","events","EventEmitter","qjob","options","maxConcurrency","jobsRunning","jobsDone","jobsTotal","timeStart","jobId","jobsList","paused","pausedId","lastPause","interval","stopAdding","sleeping","aborting","call","inherits","prototype","setConcurrency","max","setInterval","delay","add","job","args","self","push","sleepDueToInterval","emit","setTimeout","run","bind","Date","now","length","shift","_jobId","j","next","pause","status","clearInterval","since","stats","o","_timeStart","_timeElapsed","_jobsTotal","_jobsRunning","_jobsDone","_progress","Math","floor","_concurrency","_status","abort","module","exports"],"mappings":"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","sourcesContent":["var util = require('util');\nvar events = require('events').EventEmitter;\n\nvar qjob = function(options) {\n\n    if(false === (this instanceof qjob)) {\n        return new qjob(options);\n    }\n\n    this.maxConcurrency  = 10;\n    this.jobsRunning = 0;\n    this.jobsDone = 0;\n    this.jobsTotal = 0;\n    this.timeStart;\n    this.jobId = 0;\n    this.jobsList = [];\n    this.paused = false;\n    this.pausedId = null;\n    this.lastPause = 0;\n\n    this.interval = null;\n    this.stopAdding = false;\n    this.sleeping = false;\n\n    this.aborting = false;\n\n    if (options) {\n        this.maxConcurrency = options.maxConcurrency || this.maxConcurrency;\n        this.interval = options.interval || this.interval;\n    }\n    events.call(this);\n};\n\nutil.inherits(qjob, events);\n\n/*\n * helper to set max concurrency\n */\nqjob.prototype.setConcurrency = function(max) {\n    this.maxConcurrency = max;\n}\n\n/*\n * helper to set delay between rafales\n */\nqjob.prototype.setInterval = function(delay) {\n    this.interval = delay;\n}\n\n/*\n * add some jobs in the queue\n */\nqjob.prototype.add = function(job,args) {\n    var self = this;\n    self.jobsList.push([job,args]);\n    self.jobsTotal++;\n}\n\n/*\n *\n */\nqjob.prototype.sleepDueToInterval = function() {\n    var self = this;\n\n    if (this.interval === null) {\n        return;\n    }\n\n    if (this.sleeping) {\n        return true;\n    }\n\n    if (this.stopAdding) {\n\n        if (this.jobsRunning > 0) {\n            //console.log('waiting for '+jobsRunning+' jobs to finish');\n            return true;\n        }\n\n        //console.log('waiting for '+rafaleDelay+' ms');\n        this.sleeping = true;\n        self.emit('sleep');\n\n        setTimeout(function() {\n            this.stopAdding = false;\n            this.sleeping = false;\n            self.emit('continu');\n            self.run();\n        }.bind(self),this.interval);\n\n        return true;\n    }\n\n    if (this.jobsRunning + 1 == this.maxConcurrency) {\n        //console.log('max concurrent jobs reached');\n        this.stopAdding = true;\n        return true;\n    }\n}\n\n/*\n * run the queue\n */\nqjob.prototype.run = function() {\n\n    var self = this;\n\n    // first launch, let's emit start event\n    if (this.jobsDone == 0) {\n        self.emit('start');\n        this.timeStart = Date.now();\n    }\n\n    if (self.sleepDueToInterval()) return;\n\n    if (self.aborting) {\n        this.jobsList = [];\n    }\n\n    // while queue is empty and number of job running\n    // concurrently are less than max job running,\n    // then launch the next job\n\n    while (this.jobsList.length && this.jobsRunning < this.maxConcurrency) {\n        // get the next job and\n        // remove it from the queue\n        var job = self.jobsList.shift();\n\n        // increment number of job running\n        self.jobsRunning++;\n\n        // fetch args for the job\n        var args = job[1];\n\n        // add jobId in args\n        args._jobId = this.jobId++;\n\n        // emit jobStart event\n        self.emit('jobStart',args);\n\n        // run the job\n        setTimeout(function() {\n            this.j(this.args,self.next.bind(self,this.args));\n        }.bind({j:job[0],args:args}),1);\n    }\n\n    // all jobs done ? emit end event\n    if (this.jobsList.length == 0 && this.jobsRunning == 0) {\n        self.emit('end');\n    }\n}\n\n/*\n * a task has been terminated,\n * so 'next()' has been called\n */\nqjob.prototype.next = function(args) {\n\n    var self = this;\n\n    // update counters\n    this.jobsRunning--;\n    this.jobsDone++;\n\n    // emit 'jobEnd' event\n    self.emit('jobEnd',args);\n\n    // if queue has been set to pause\n    // then do nothing\n    if (this.paused) return;\n\n    // else, execute run() function\n    self.run();\n}\n\n/*\n * You can 'pause' jobs.\n * it will not pause running jobs, but\n * it will stop launching pending jobs\n * until paused = false\n */\nqjob.prototype.pause = function(status) {\n    var self = this;\n    this.paused = status;\n    if (!this.paused && this.pausedId) {\n        clearInterval(this.pausedId);\n        self.emit('unpause');\n        this.run();\n    }\n    if (this.paused && !this.pausedId) {\n        self.lastPause = Date.now();\n        this.pausedId = setInterval(function() {\n            var since = Date.now() - self.lastPause;\n            self.emit('pause',since);\n        },1000);\n        return;\n    }\n}\n\nqjob.prototype.stats = function() {\n\n    var now =  Date.now();\n\n    var o = {};\n    o._timeStart = this.timeStart || 'N/A';\n    o._timeElapsed = (now - this.timeStart) || 'N/A';\n    o._jobsTotal = this.jobsTotal;\n    o._jobsRunning = this.jobsRunning;\n    o._jobsDone = this.jobsDone;\n    o._progress = Math.floor((this.jobsDone/this.jobsTotal)*100);\n    o._concurrency = this.maxConcurrency;\n\n    if (this.paused) {\n        o._status = 'Paused';\n        return o;\n    }\n\n    if (o._timeElapsed == 'N/A') {\n        o._status = 'Starting';\n        return o;\n    }\n\n    if (this.jobsTotal == this.jobsDone) {\n        o._status = 'Finished';\n        return o;\n    }\n\n    o._status = 'Running';\n    return o;\n}\n\nqjob.prototype.abort = function() {\n    this.aborting = true;\n}\n\nmodule.exports = qjob;\n"]},"metadata":{},"sourceType":"script"}