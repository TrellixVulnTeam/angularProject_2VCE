{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar taskManager = require(\"./managers/tasks\");\n\nvar async_1 = require(\"./providers/async\");\n\nvar stream_1 = require(\"./providers/stream\");\n\nvar sync_1 = require(\"./providers/sync\");\n\nvar settings_1 = require(\"./settings\");\n\nvar utils = require(\"./utils\");\n\nfunction FastGlob(_x, _x2) {\n  return _FastGlob.apply(this, arguments);\n} // https://github.com/typescript-eslint/typescript-eslint/issues/60\n// eslint-disable-next-line no-redeclare\n\n\nfunction _FastGlob() {\n  _FastGlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, options) {\n    var works, result;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            assertPatternsInput(source);\n            works = getWorks(source, async_1.default, options);\n            _context.next = 4;\n            return Promise.all(works);\n\n          case 4:\n            result = _context.sent;\n            return _context.abrupt(\"return\", utils.array.flatten(result));\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _FastGlob.apply(this, arguments);\n}\n\n(function (FastGlob) {\n  function sync(source, options) {\n    assertPatternsInput(source);\n    var works = getWorks(source, sync_1.default, options);\n    return utils.array.flatten(works);\n  }\n\n  FastGlob.sync = sync;\n\n  function stream(source, options) {\n    assertPatternsInput(source);\n    var works = getWorks(source, stream_1.default, options);\n    /**\r\n     * The stream returned by the provider cannot work with an asynchronous iterator.\r\n     * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.\r\n     * This affects performance (+25%). I don't see best solution right now.\r\n     */\n\n    return utils.stream.merge(works);\n  }\n\n  FastGlob.stream = stream;\n\n  function generateTasks(source, options) {\n    assertPatternsInput(source);\n    var patterns = [].concat(source);\n    var settings = new settings_1.default(options);\n    return taskManager.generate(patterns, settings);\n  }\n\n  FastGlob.generateTasks = generateTasks;\n\n  function isDynamicPattern(source, options) {\n    assertPatternsInput(source);\n    var settings = new settings_1.default(options);\n    return utils.pattern.isDynamicPattern(source, settings);\n  }\n\n  FastGlob.isDynamicPattern = isDynamicPattern;\n\n  function escapePath(source) {\n    assertPatternsInput(source);\n    return utils.path.escape(source);\n  }\n\n  FastGlob.escapePath = escapePath;\n})(FastGlob || (FastGlob = {}));\n\nfunction getWorks(source, _Provider, options) {\n  var patterns = [].concat(source);\n  var settings = new settings_1.default(options);\n  var tasks = taskManager.generate(patterns, settings);\n  var provider = new _Provider(settings);\n  return tasks.map(provider.read, provider);\n}\n\nfunction assertPatternsInput(input) {\n  var source = [].concat(input);\n  var isValidSource = source.every(function (item) {\n    return utils.string.isString(item) && !utils.string.isEmpty(item);\n  });\n\n  if (!isValidSource) {\n    throw new TypeError('Patterns must be a string (non empty) or an array of strings');\n  }\n}\n\nmodule.exports = FastGlob;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/fast-glob/out/index.js"],"names":["taskManager","require","async_1","stream_1","sync_1","settings_1","utils","FastGlob","source","options","assertPatternsInput","works","getWorks","default","Promise","all","result","array","flatten","sync","stream","merge","generateTasks","patterns","concat","settings","generate","isDynamicPattern","pattern","escapePath","path","escape","_Provider","tasks","provider","map","read","input","isValidSource","every","item","string","isString","isEmpty","TypeError","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\r\nconst taskManager = require(\"./managers/tasks\");\r\nconst async_1 = require(\"./providers/async\");\r\nconst stream_1 = require(\"./providers/stream\");\r\nconst sync_1 = require(\"./providers/sync\");\r\nconst settings_1 = require(\"./settings\");\r\nconst utils = require(\"./utils\");\r\nasync function FastGlob(source, options) {\r\n    assertPatternsInput(source);\r\n    const works = getWorks(source, async_1.default, options);\r\n    const result = await Promise.all(works);\r\n    return utils.array.flatten(result);\r\n}\r\n// https://github.com/typescript-eslint/typescript-eslint/issues/60\r\n// eslint-disable-next-line no-redeclare\r\n(function (FastGlob) {\r\n    function sync(source, options) {\r\n        assertPatternsInput(source);\r\n        const works = getWorks(source, sync_1.default, options);\r\n        return utils.array.flatten(works);\r\n    }\r\n    FastGlob.sync = sync;\r\n    function stream(source, options) {\r\n        assertPatternsInput(source);\r\n        const works = getWorks(source, stream_1.default, options);\r\n        /**\r\n         * The stream returned by the provider cannot work with an asynchronous iterator.\r\n         * To support asynchronous iterators, regardless of the number of tasks, we always multiplex streams.\r\n         * This affects performance (+25%). I don't see best solution right now.\r\n         */\r\n        return utils.stream.merge(works);\r\n    }\r\n    FastGlob.stream = stream;\r\n    function generateTasks(source, options) {\r\n        assertPatternsInput(source);\r\n        const patterns = [].concat(source);\r\n        const settings = new settings_1.default(options);\r\n        return taskManager.generate(patterns, settings);\r\n    }\r\n    FastGlob.generateTasks = generateTasks;\r\n    function isDynamicPattern(source, options) {\r\n        assertPatternsInput(source);\r\n        const settings = new settings_1.default(options);\r\n        return utils.pattern.isDynamicPattern(source, settings);\r\n    }\r\n    FastGlob.isDynamicPattern = isDynamicPattern;\r\n    function escapePath(source) {\r\n        assertPatternsInput(source);\r\n        return utils.path.escape(source);\r\n    }\r\n    FastGlob.escapePath = escapePath;\r\n})(FastGlob || (FastGlob = {}));\r\nfunction getWorks(source, _Provider, options) {\r\n    const patterns = [].concat(source);\r\n    const settings = new settings_1.default(options);\r\n    const tasks = taskManager.generate(patterns, settings);\r\n    const provider = new _Provider(settings);\r\n    return tasks.map(provider.read, provider);\r\n}\r\nfunction assertPatternsInput(input) {\r\n    const source = [].concat(input);\r\n    const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));\r\n    if (!isValidSource) {\r\n        throw new TypeError('Patterns must be a string (non empty) or an array of strings');\r\n    }\r\n}\r\nmodule.exports = FastGlob;\r\n"]},"metadata":{},"sourceType":"script"}