{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/metadata/collector\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/metadata/evaluator\", \"@angular/compiler-cli/src/metadata/schema\", \"@angular/compiler-cli/src/metadata/symbols\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.MetadataCollector = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var evaluator_1 = require(\"@angular/compiler-cli/src/metadata/evaluator\");\n\n  var schema_1 = require(\"@angular/compiler-cli/src/metadata/schema\");\n\n  var symbols_1 = require(\"@angular/compiler-cli/src/metadata/symbols\");\n\n  var isStatic = function isStatic(node) {\n    return ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Static;\n  };\n  /**\n   * Collect decorator metadata from a TypeScript module.\n   */\n\n\n  var MetadataCollector =\n  /** @class */\n  function () {\n    function MetadataCollector(options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      this.options = options;\n    }\n    /**\n     * Returns a JSON.stringify friendly form describing the decorators of the exported classes from\n     * the source file that is expected to correspond to a module.\n     */\n\n\n    MetadataCollector.prototype.getMetadata = function (sourceFile, strict, substituteExpression) {\n      var _this = this;\n\n      if (strict === void 0) {\n        strict = false;\n      }\n\n      var locals = new symbols_1.Symbols(sourceFile);\n      var nodeMap = new Map();\n      var composedSubstituter = substituteExpression && this.options.substituteExpression ? function (value, node) {\n        return _this.options.substituteExpression(substituteExpression(value, node), node);\n      } : substituteExpression;\n      var evaluatorOptions = substituteExpression ? tslib_1.__assign(tslib_1.__assign({}, this.options), {\n        substituteExpression: composedSubstituter\n      }) : this.options;\n      var metadata;\n      var evaluator = new evaluator_1.Evaluator(locals, nodeMap, evaluatorOptions, function (name, value) {\n        if (!metadata) metadata = {};\n        metadata[name] = value;\n      });\n      var exports = undefined;\n\n      function objFromDecorator(decoratorNode) {\n        return evaluator.evaluateNode(decoratorNode.expression);\n      }\n\n      function recordEntry(entry, node) {\n        if (composedSubstituter) {\n          entry = composedSubstituter(entry, node);\n        }\n\n        return evaluator_1.recordMapEntry(entry, node, nodeMap, sourceFile);\n      }\n\n      function errorSym(message, node, context) {\n        return evaluator_1.errorSymbol(message, node, context, sourceFile);\n      }\n\n      function maybeGetSimpleFunction(functionDeclaration) {\n        if (functionDeclaration.name && functionDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n          var nameNode = functionDeclaration.name;\n          var functionName = nameNode.text;\n          var functionBody = functionDeclaration.body;\n\n          if (functionBody && functionBody.statements.length == 1) {\n            var statement = functionBody.statements[0];\n\n            if (statement.kind === ts.SyntaxKind.ReturnStatement) {\n              var returnStatement = statement;\n\n              if (returnStatement.expression) {\n                var func = {\n                  __symbolic: 'function',\n                  parameters: namesOf(functionDeclaration.parameters),\n                  value: evaluator.evaluateNode(returnStatement.expression)\n                };\n\n                if (functionDeclaration.parameters.some(function (p) {\n                  return p.initializer != null;\n                })) {\n                  func.defaults = functionDeclaration.parameters.map(function (p) {\n                    return p.initializer && evaluator.evaluateNode(p.initializer);\n                  });\n                }\n\n                return recordEntry({\n                  func: func,\n                  name: functionName\n                }, functionDeclaration);\n              }\n            }\n          }\n        }\n      }\n\n      function classMetadataOf(classDeclaration) {\n        var e_1, _a, e_2, _b;\n\n        var result = {\n          __symbolic: 'class'\n        };\n\n        function getDecorators(decorators) {\n          if (decorators && decorators.length) return decorators.map(function (decorator) {\n            return objFromDecorator(decorator);\n          });\n          return undefined;\n        }\n\n        function referenceFrom(node) {\n          var result = evaluator.evaluateNode(node);\n\n          if (schema_1.isMetadataError(result) || schema_1.isMetadataSymbolicReferenceExpression(result) || schema_1.isMetadataSymbolicSelectExpression(result)) {\n            return result;\n          } else {\n            return errorSym('Symbol reference expected', node);\n          }\n        } // Add class parents\n\n\n        if (classDeclaration.heritageClauses) {\n          classDeclaration.heritageClauses.forEach(function (hc) {\n            if (hc.token === ts.SyntaxKind.ExtendsKeyword && hc.types) {\n              hc.types.forEach(function (type) {\n                return result.extends = referenceFrom(type.expression);\n              });\n            }\n          });\n        } // Add arity if the type is generic\n\n\n        var typeParameters = classDeclaration.typeParameters;\n\n        if (typeParameters && typeParameters.length) {\n          result.arity = typeParameters.length;\n        } // Add class decorators\n\n\n        if (classDeclaration.decorators) {\n          result.decorators = getDecorators(classDeclaration.decorators);\n        } // member decorators\n\n\n        var members = null;\n\n        function recordMember(name, metadata) {\n          if (!members) members = {};\n          var data = members.hasOwnProperty(name) ? members[name] : [];\n          data.push(metadata);\n          members[name] = data;\n        } // static member\n\n\n        var statics = null;\n\n        function recordStaticMember(name, value) {\n          if (!statics) statics = {};\n          statics[name] = value;\n        }\n\n        try {\n          for (var _c = tslib_1.__values(classDeclaration.members), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var member = _d.value;\n            var isConstructor = false;\n\n            switch (member.kind) {\n              case ts.SyntaxKind.Constructor:\n              case ts.SyntaxKind.MethodDeclaration:\n                isConstructor = member.kind === ts.SyntaxKind.Constructor;\n                var method = member;\n\n                if (isStatic(method)) {\n                  var maybeFunc = maybeGetSimpleFunction(method);\n\n                  if (maybeFunc) {\n                    recordStaticMember(maybeFunc.name, maybeFunc.func);\n                  }\n\n                  continue;\n                }\n\n                var methodDecorators = getDecorators(method.decorators);\n                var parameters = method.parameters;\n                var parameterDecoratorData = [];\n                var parametersData = [];\n                var hasDecoratorData = false;\n                var hasParameterData = false;\n\n                try {\n                  for (var parameters_1 = (e_2 = void 0, tslib_1.__values(parameters)), parameters_1_1 = parameters_1.next(); !parameters_1_1.done; parameters_1_1 = parameters_1.next()) {\n                    var parameter = parameters_1_1.value;\n                    var parameterData = getDecorators(parameter.decorators);\n                    parameterDecoratorData.push(parameterData);\n                    hasDecoratorData = hasDecoratorData || !!parameterData;\n\n                    if (isConstructor) {\n                      if (parameter.type) {\n                        parametersData.push(referenceFrom(parameter.type));\n                      } else {\n                        parametersData.push(null);\n                      }\n\n                      hasParameterData = true;\n                    }\n                  }\n                } catch (e_2_1) {\n                  e_2 = {\n                    error: e_2_1\n                  };\n                } finally {\n                  try {\n                    if (parameters_1_1 && !parameters_1_1.done && (_b = parameters_1.return)) _b.call(parameters_1);\n                  } finally {\n                    if (e_2) throw e_2.error;\n                  }\n                }\n\n                var data = {\n                  __symbolic: isConstructor ? 'constructor' : 'method'\n                };\n                var name = isConstructor ? '__ctor__' : evaluator.nameOf(member.name);\n\n                if (methodDecorators) {\n                  data.decorators = methodDecorators;\n                }\n\n                if (hasDecoratorData) {\n                  data.parameterDecorators = parameterDecoratorData;\n                }\n\n                if (hasParameterData) {\n                  data.parameters = parametersData;\n                }\n\n                if (!schema_1.isMetadataError(name)) {\n                  recordMember(name, data);\n                }\n\n                break;\n\n              case ts.SyntaxKind.PropertyDeclaration:\n              case ts.SyntaxKind.GetAccessor:\n              case ts.SyntaxKind.SetAccessor:\n                var property = member;\n\n                if (isStatic(property)) {\n                  var name_1 = evaluator.nameOf(property.name);\n\n                  if (!schema_1.isMetadataError(name_1) && !shouldIgnoreStaticMember(name_1)) {\n                    if (property.initializer) {\n                      var value = evaluator.evaluateNode(property.initializer);\n                      recordStaticMember(name_1, value);\n                    } else {\n                      recordStaticMember(name_1, errorSym('Variable not initialized', property.name));\n                    }\n                  }\n                }\n\n                var propertyDecorators = getDecorators(property.decorators);\n\n                if (propertyDecorators) {\n                  var name_2 = evaluator.nameOf(property.name);\n\n                  if (!schema_1.isMetadataError(name_2)) {\n                    recordMember(name_2, {\n                      __symbolic: 'property',\n                      decorators: propertyDecorators\n                    });\n                  }\n                }\n\n                break;\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        if (members) {\n          result.members = members;\n        }\n\n        if (statics) {\n          result.statics = statics;\n        }\n\n        return recordEntry(result, classDeclaration);\n      } // Collect all exported symbols from an exports clause.\n\n\n      var exportMap = new Map();\n      ts.forEachChild(sourceFile, function (node) {\n        switch (node.kind) {\n          case ts.SyntaxKind.ExportDeclaration:\n            var exportDeclaration = node;\n            var moduleSpecifier = exportDeclaration.moduleSpecifier,\n                exportClause = exportDeclaration.exportClause;\n\n            if (!moduleSpecifier && exportClause && ts.isNamedExports(exportClause)) {\n              // If there is a module specifier there is also an exportClause\n              exportClause.elements.forEach(function (spec) {\n                var exportedAs = spec.name.text;\n                var name = (spec.propertyName || spec.name).text;\n                exportMap.set(name, exportedAs);\n              });\n            }\n\n        }\n      });\n\n      var isExport = function isExport(node) {\n        return sourceFile.isDeclarationFile || ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Export;\n      };\n\n      var isExportedIdentifier = function isExportedIdentifier(identifier) {\n        return identifier && exportMap.has(identifier.text);\n      };\n\n      var isExported = function isExported(node) {\n        return isExport(node) || isExportedIdentifier(node.name);\n      };\n\n      var exportedIdentifierName = function exportedIdentifierName(identifier) {\n        return identifier && (exportMap.get(identifier.text) || identifier.text);\n      };\n\n      var exportedName = function exportedName(node) {\n        return exportedIdentifierName(node.name);\n      }; // Pre-declare classes and functions\n\n\n      ts.forEachChild(sourceFile, function (node) {\n        switch (node.kind) {\n          case ts.SyntaxKind.ClassDeclaration:\n            var classDeclaration = node;\n\n            if (classDeclaration.name) {\n              var className = classDeclaration.name.text;\n\n              if (isExported(classDeclaration)) {\n                locals.define(className, {\n                  __symbolic: 'reference',\n                  name: exportedName(classDeclaration)\n                });\n              } else {\n                locals.define(className, errorSym('Reference to non-exported class', node, {\n                  className: className\n                }));\n              }\n            }\n\n            break;\n\n          case ts.SyntaxKind.InterfaceDeclaration:\n            var interfaceDeclaration = node;\n\n            if (interfaceDeclaration.name) {\n              var interfaceName = interfaceDeclaration.name.text; // All references to interfaces should be converted to references to `any`.\n\n              locals.define(interfaceName, {\n                __symbolic: 'reference',\n                name: 'any'\n              });\n            }\n\n            break;\n\n          case ts.SyntaxKind.FunctionDeclaration:\n            var functionDeclaration = node;\n\n            if (!isExported(functionDeclaration)) {\n              // Report references to this function as an error.\n              var nameNode = functionDeclaration.name;\n\n              if (nameNode && nameNode.text) {\n                locals.define(nameNode.text, errorSym('Reference to a non-exported function', nameNode, {\n                  name: nameNode.text\n                }));\n              }\n            }\n\n            break;\n        }\n      });\n      ts.forEachChild(sourceFile, function (node) {\n        var e_3, _a, e_4, _b;\n\n        switch (node.kind) {\n          case ts.SyntaxKind.ExportDeclaration:\n            // Record export declarations\n            var exportDeclaration = node;\n            var moduleSpecifier = exportDeclaration.moduleSpecifier,\n                exportClause = exportDeclaration.exportClause;\n\n            if (!moduleSpecifier) {\n              // no module specifier -> export {propName as name};\n              if (exportClause && ts.isNamedExports(exportClause)) {\n                exportClause.elements.forEach(function (spec) {\n                  var name = spec.name.text; // If the symbol was not already exported, export a reference since it is a\n                  // reference to an import\n\n                  if (!metadata || !metadata[name]) {\n                    var propNode = spec.propertyName || spec.name;\n                    var value = evaluator.evaluateNode(propNode);\n                    if (!metadata) metadata = {};\n                    metadata[name] = recordEntry(value, node);\n                  }\n                });\n              }\n            }\n\n            if (moduleSpecifier && moduleSpecifier.kind == ts.SyntaxKind.StringLiteral) {\n              // Ignore exports that don't have string literals as exports.\n              // This is allowed by the syntax but will be flagged as an error by the type checker.\n              var from = moduleSpecifier.text;\n              var moduleExport = {\n                from: from\n              };\n\n              if (exportClause && ts.isNamedExports(exportClause)) {\n                moduleExport.export = exportClause.elements.map(function (spec) {\n                  return spec.propertyName ? {\n                    name: spec.propertyName.text,\n                    as: spec.name.text\n                  } : spec.name.text;\n                });\n              }\n\n              if (!exports) exports = [];\n              exports.push(moduleExport);\n            }\n\n            break;\n\n          case ts.SyntaxKind.ClassDeclaration:\n            var classDeclaration = node;\n\n            if (classDeclaration.name) {\n              if (isExported(classDeclaration)) {\n                var name = exportedName(classDeclaration);\n\n                if (name) {\n                  if (!metadata) metadata = {};\n                  metadata[name] = classMetadataOf(classDeclaration);\n                }\n              }\n            } // Otherwise don't record metadata for the class.\n\n\n            break;\n\n          case ts.SyntaxKind.TypeAliasDeclaration:\n            var typeDeclaration = node;\n\n            if (typeDeclaration.name && isExported(typeDeclaration)) {\n              var name = exportedName(typeDeclaration);\n\n              if (name) {\n                if (!metadata) metadata = {};\n                metadata[name] = {\n                  __symbolic: 'interface'\n                };\n              }\n            }\n\n            break;\n\n          case ts.SyntaxKind.InterfaceDeclaration:\n            var interfaceDeclaration = node;\n\n            if (interfaceDeclaration.name && isExported(interfaceDeclaration)) {\n              var name = exportedName(interfaceDeclaration);\n\n              if (name) {\n                if (!metadata) metadata = {};\n                metadata[name] = {\n                  __symbolic: 'interface'\n                };\n              }\n            }\n\n            break;\n\n          case ts.SyntaxKind.FunctionDeclaration:\n            // Record functions that return a single value. Record the parameter\n            // names substitution will be performed by the StaticReflector.\n            var functionDeclaration = node;\n\n            if (isExported(functionDeclaration) && functionDeclaration.name) {\n              var name = exportedName(functionDeclaration);\n              var maybeFunc = maybeGetSimpleFunction(functionDeclaration);\n\n              if (name) {\n                if (!metadata) metadata = {}; // TODO(alxhub): The literal here is not valid FunctionMetadata.\n\n                metadata[name] = maybeFunc ? recordEntry(maybeFunc.func, node) : {\n                  __symbolic: 'function'\n                };\n              }\n            }\n\n            break;\n\n          case ts.SyntaxKind.EnumDeclaration:\n            var enumDeclaration = node;\n\n            if (isExported(enumDeclaration)) {\n              var enumValueHolder = {};\n              var enumName = exportedName(enumDeclaration);\n              var nextDefaultValue = 0;\n              var writtenMembers = 0;\n\n              try {\n                for (var _c = tslib_1.__values(enumDeclaration.members), _d = _c.next(); !_d.done; _d = _c.next()) {\n                  var member = _d.value;\n                  var enumValue = void 0;\n\n                  if (!member.initializer) {\n                    enumValue = nextDefaultValue;\n                  } else {\n                    enumValue = evaluator.evaluateNode(member.initializer);\n                  }\n\n                  var name = undefined;\n\n                  if (member.name.kind == ts.SyntaxKind.Identifier) {\n                    var identifier = member.name;\n                    name = identifier.text;\n                    enumValueHolder[name] = enumValue;\n                    writtenMembers++;\n                  }\n\n                  if (typeof enumValue === 'number') {\n                    nextDefaultValue = enumValue + 1;\n                  } else if (name) {\n                    // TODO(alxhub): 'left' here has a name propery which is not valid for\n                    // MetadataSymbolicSelectExpression.\n                    nextDefaultValue = {\n                      __symbolic: 'binary',\n                      operator: '+',\n                      left: {\n                        __symbolic: 'select',\n                        expression: recordEntry({\n                          __symbolic: 'reference',\n                          name: enumName\n                        }, node),\n                        name: name\n                      }\n                    };\n                  } else {\n                    nextDefaultValue = recordEntry(errorSym('Unsupported enum member name', member.name), node);\n                  }\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n\n              if (writtenMembers) {\n                if (enumName) {\n                  if (!metadata) metadata = {};\n                  metadata[enumName] = recordEntry(enumValueHolder, node);\n                }\n              }\n            }\n\n            break;\n\n          case ts.SyntaxKind.VariableStatement:\n            var variableStatement = node;\n\n            var _loop_1 = function _loop_1(variableDeclaration) {\n              if (variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n                var nameNode = variableDeclaration.name;\n                var varValue = void 0;\n\n                if (variableDeclaration.initializer) {\n                  varValue = evaluator.evaluateNode(variableDeclaration.initializer);\n                } else {\n                  varValue = recordEntry(errorSym('Variable not initialized', nameNode), nameNode);\n                }\n\n                var exported = false;\n\n                if (isExport(variableStatement) || isExport(variableDeclaration) || isExportedIdentifier(nameNode)) {\n                  var name = exportedIdentifierName(nameNode);\n\n                  if (name) {\n                    if (!metadata) metadata = {};\n                    metadata[name] = recordEntry(varValue, node);\n                  }\n\n                  exported = true;\n                }\n\n                if (typeof varValue == 'string' || typeof varValue == 'number' || typeof varValue == 'boolean') {\n                  locals.define(nameNode.text, varValue);\n\n                  if (exported) {\n                    locals.defineReference(nameNode.text, {\n                      __symbolic: 'reference',\n                      name: nameNode.text\n                    });\n                  }\n                } else if (!exported) {\n                  if (varValue && !schema_1.isMetadataError(varValue)) {\n                    locals.define(nameNode.text, recordEntry(varValue, node));\n                  } else {\n                    locals.define(nameNode.text, recordEntry(errorSym('Reference to a local symbol', nameNode, {\n                      name: nameNode.text\n                    }), node));\n                  }\n                }\n              } else {\n                // Destructuring (or binding) declarations are not supported,\n                // var {<identifier>[, <identifier>]+} = <expression>;\n                //   or\n                // var [<identifier>[, <identifier}+] = <expression>;\n                // are not supported.\n                var report_1 = function report_1(nameNode) {\n                  switch (nameNode.kind) {\n                    case ts.SyntaxKind.Identifier:\n                      var name = nameNode;\n                      var varValue = errorSym('Destructuring not supported', name);\n                      locals.define(name.text, varValue);\n\n                      if (isExport(node)) {\n                        if (!metadata) metadata = {};\n                        metadata[name.text] = varValue;\n                      }\n\n                      break;\n\n                    case ts.SyntaxKind.BindingElement:\n                      var bindingElement = nameNode;\n                      report_1(bindingElement.name);\n                      break;\n\n                    case ts.SyntaxKind.ObjectBindingPattern:\n                    case ts.SyntaxKind.ArrayBindingPattern:\n                      var bindings = nameNode;\n                      bindings.elements.forEach(report_1);\n                      break;\n                  }\n                };\n\n                report_1(variableDeclaration.name);\n              }\n            };\n\n            try {\n              for (var _e = tslib_1.__values(variableStatement.declarationList.declarations), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var variableDeclaration = _f.value;\n\n                _loop_1(variableDeclaration);\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n\n            break;\n        }\n      });\n\n      if (metadata || exports) {\n        if (!metadata) metadata = {};else if (strict) {\n          validateMetadata(sourceFile, nodeMap, metadata);\n        }\n        var result = {\n          __symbolic: 'module',\n          version: this.options.version || schema_1.METADATA_VERSION,\n          metadata: metadata\n        };\n        if (sourceFile.moduleName) result.importAs = sourceFile.moduleName;\n        if (exports) result.exports = exports;\n        return result;\n      }\n    };\n\n    return MetadataCollector;\n  }();\n\n  exports.MetadataCollector = MetadataCollector; // This will throw if the metadata entry given contains an error node.\n\n  function validateMetadata(sourceFile, nodeMap, metadata) {\n    var locals = new Set(['Array', 'Object', 'Set', 'Map', 'string', 'number', 'any']);\n\n    function validateExpression(expression) {\n      if (!expression) {\n        return;\n      } else if (Array.isArray(expression)) {\n        expression.forEach(validateExpression);\n      } else if (typeof expression === 'object' && !expression.hasOwnProperty('__symbolic')) {\n        Object.getOwnPropertyNames(expression).forEach(function (v) {\n          return validateExpression(expression[v]);\n        });\n      } else if (schema_1.isMetadataError(expression)) {\n        reportError(expression);\n      } else if (schema_1.isMetadataGlobalReferenceExpression(expression)) {\n        if (!locals.has(expression.name)) {\n          var reference = metadata[expression.name];\n\n          if (reference) {\n            validateExpression(reference);\n          }\n        }\n      } else if (schema_1.isFunctionMetadata(expression)) {\n        validateFunction(expression);\n      } else if (schema_1.isMetadataSymbolicExpression(expression)) {\n        switch (expression.__symbolic) {\n          case 'binary':\n            var binaryExpression = expression;\n            validateExpression(binaryExpression.left);\n            validateExpression(binaryExpression.right);\n            break;\n\n          case 'call':\n          case 'new':\n            var callExpression = expression;\n            validateExpression(callExpression.expression);\n            if (callExpression.arguments) callExpression.arguments.forEach(validateExpression);\n            break;\n\n          case 'index':\n            var indexExpression = expression;\n            validateExpression(indexExpression.expression);\n            validateExpression(indexExpression.index);\n            break;\n\n          case 'pre':\n            var prefixExpression = expression;\n            validateExpression(prefixExpression.operand);\n            break;\n\n          case 'select':\n            var selectExpression = expression;\n            validateExpression(selectExpression.expression);\n            break;\n\n          case 'spread':\n            var spreadExpression = expression;\n            validateExpression(spreadExpression.expression);\n            break;\n\n          case 'if':\n            var ifExpression = expression;\n            validateExpression(ifExpression.condition);\n            validateExpression(ifExpression.elseExpression);\n            validateExpression(ifExpression.thenExpression);\n            break;\n        }\n      }\n    }\n\n    function validateMember(classData, member) {\n      if (member.decorators) {\n        member.decorators.forEach(validateExpression);\n      }\n\n      if (schema_1.isMethodMetadata(member) && member.parameterDecorators) {\n        member.parameterDecorators.forEach(validateExpression);\n      } // Only validate parameters of classes for which we know that are used with our DI\n\n\n      if (classData.decorators && schema_1.isConstructorMetadata(member) && member.parameters) {\n        member.parameters.forEach(validateExpression);\n      }\n    }\n\n    function validateClass(classData) {\n      if (classData.decorators) {\n        classData.decorators.forEach(validateExpression);\n      }\n\n      if (classData.members) {\n        Object.getOwnPropertyNames(classData.members).forEach(function (name) {\n          return classData.members[name].forEach(function (m) {\n            return validateMember(classData, m);\n          });\n        });\n      }\n\n      if (classData.statics) {\n        Object.getOwnPropertyNames(classData.statics).forEach(function (name) {\n          var staticMember = classData.statics[name];\n\n          if (schema_1.isFunctionMetadata(staticMember)) {\n            validateExpression(staticMember.value);\n          } else {\n            validateExpression(staticMember);\n          }\n        });\n      }\n    }\n\n    function validateFunction(functionDeclaration) {\n      if (functionDeclaration.value) {\n        var oldLocals = locals;\n\n        if (functionDeclaration.parameters) {\n          locals = new Set(oldLocals.values());\n          if (functionDeclaration.parameters) functionDeclaration.parameters.forEach(function (n) {\n            return locals.add(n);\n          });\n        }\n\n        validateExpression(functionDeclaration.value);\n        locals = oldLocals;\n      }\n    }\n\n    function shouldReportNode(node) {\n      if (node) {\n        var nodeStart = node.getStart();\n        return !(node.pos != nodeStart && sourceFile.text.substring(node.pos, nodeStart).indexOf('@dynamic') >= 0);\n      }\n\n      return true;\n    }\n\n    function reportError(error) {\n      var node = nodeMap.get(error);\n\n      if (shouldReportNode(node)) {\n        var lineInfo = error.line != undefined ? error.character != undefined ? \":\" + (error.line + 1) + \":\" + (error.character + 1) : \":\" + (error.line + 1) : '';\n        throw new Error(\"\" + sourceFile.fileName + lineInfo + \": Metadata collected contains an error that will be reported at runtime: \" + expandedMessage(error) + \".\\n  \" + JSON.stringify(error));\n      }\n    }\n\n    Object.getOwnPropertyNames(metadata).forEach(function (name) {\n      var entry = metadata[name];\n\n      try {\n        if (schema_1.isClassMetadata(entry)) {\n          validateClass(entry);\n        }\n      } catch (e) {\n        var node = nodeMap.get(entry);\n\n        if (shouldReportNode(node)) {\n          if (node) {\n            var _a = sourceFile.getLineAndCharacterOfPosition(node.getStart()),\n                line = _a.line,\n                character = _a.character;\n\n            throw new Error(sourceFile.fileName + \":\" + (line + 1) + \":\" + (character + 1) + \": Error encountered in metadata generated for exported symbol '\" + name + \"': \\n \" + e.message);\n          }\n\n          throw new Error(\"Error encountered in metadata generated for exported symbol \" + name + \": \\n \" + e.message);\n        }\n      }\n    });\n  } // Collect parameter names from a function.\n\n\n  function namesOf(parameters) {\n    var e_5, _a;\n\n    var result = [];\n\n    function addNamesOf(name) {\n      var e_6, _a;\n\n      if (name.kind == ts.SyntaxKind.Identifier) {\n        var identifier = name;\n        result.push(identifier.text);\n      } else {\n        var bindingPattern = name;\n\n        try {\n          for (var _b = tslib_1.__values(bindingPattern.elements), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var element = _c.value;\n            var name_3 = element.name;\n\n            if (name_3) {\n              addNamesOf(name_3);\n            }\n          }\n        } catch (e_6_1) {\n          e_6 = {\n            error: e_6_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n        }\n      }\n    }\n\n    try {\n      for (var parameters_2 = tslib_1.__values(parameters), parameters_2_1 = parameters_2.next(); !parameters_2_1.done; parameters_2_1 = parameters_2.next()) {\n        var parameter = parameters_2_1.value;\n        addNamesOf(parameter.name);\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (parameters_2_1 && !parameters_2_1.done && (_a = parameters_2.return)) _a.call(parameters_2);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return result;\n  }\n\n  function shouldIgnoreStaticMember(memberName) {\n    return memberName.startsWith('ngAcceptInputType_') || memberName.startsWith('ngTemplateGuard_');\n  }\n\n  function expandedMessage(error) {\n    switch (error.message) {\n      case 'Reference to non-exported class':\n        if (error.context && error.context.className) {\n          return \"Reference to a non-exported class \" + error.context.className + \". Consider exporting the class\";\n        }\n\n        break;\n\n      case 'Variable not initialized':\n        return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n\n      case 'Destructuring not supported':\n        return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n\n      case 'Could not resolve type':\n        if (error.context && error.context.typeName) {\n          return \"Could not resolve type \" + error.context.typeName;\n        }\n\n        break;\n\n      case 'Function call not supported':\n        var prefix = error.context && error.context.name ? \"Calling function '\" + error.context.name + \"', f\" : 'F';\n        return prefix + 'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n\n      case 'Reference to a local symbol':\n        if (error.context && error.context.name) {\n          return \"Reference to a local (non-exported) symbol '\" + error.context.name + \"'. Consider exporting the symbol\";\n        }\n\n    }\n\n    return error.message;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/metadata/collector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {errorSymbol, Evaluator, recordMapEntry} from './evaluator';\nimport {ClassMetadata, ConstructorMetadata, FunctionMetadata, InterfaceMetadata, isClassMetadata, isConstructorMetadata, isFunctionMetadata, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportDefaultReference, isMetadataImportedSymbolReferenceExpression, isMetadataSymbolicExpression, isMetadataSymbolicReferenceExpression, isMetadataSymbolicSelectExpression, isMethodMetadata, MemberMetadata, METADATA_VERSION, MetadataEntry, MetadataError, MetadataMap, MetadataSymbolicBinaryExpression, MetadataSymbolicCallExpression, MetadataSymbolicExpression, MetadataSymbolicIfExpression, MetadataSymbolicIndexExpression, MetadataSymbolicPrefixExpression, MetadataSymbolicReferenceExpression, MetadataSymbolicSelectExpression, MetadataSymbolicSpreadExpression, MetadataValue, MethodMetadata, ModuleExportMetadata, ModuleMetadata} from './schema';\nimport {Symbols} from './symbols';\n\nconst isStatic = (node: ts.Declaration) =>\n    ts.getCombinedModifierFlags(node) & ts.ModifierFlags.Static;\n\n/**\n * A set of collector options to use when collecting metadata.\n */\nexport interface CollectorOptions {\n  /**\n   * Version of the metadata to collect.\n   */\n  version?: number;\n\n  /**\n   * Collect a hidden field \"$quoted$\" in objects literals that record when the key was quoted in\n   * the source.\n   */\n  quotedNames?: boolean;\n\n  /**\n   * Do not simplify invalid expressions.\n   */\n  verboseInvalidExpression?: boolean;\n\n  /**\n   * An expression substitution callback.\n   */\n  substituteExpression?: (value: MetadataValue, node: ts.Node) => MetadataValue;\n}\n\n/**\n * Collect decorator metadata from a TypeScript module.\n */\nexport class MetadataCollector {\n  constructor(private options: CollectorOptions = {}) {}\n\n  /**\n   * Returns a JSON.stringify friendly form describing the decorators of the exported classes from\n   * the source file that is expected to correspond to a module.\n   */\n  public getMetadata(\n      sourceFile: ts.SourceFile, strict: boolean = false,\n      substituteExpression?: (value: MetadataValue, node: ts.Node) => MetadataValue): ModuleMetadata\n      |undefined {\n    const locals = new Symbols(sourceFile);\n    const nodeMap =\n        new Map<MetadataValue|ClassMetadata|InterfaceMetadata|FunctionMetadata, ts.Node>();\n    const composedSubstituter = substituteExpression && this.options.substituteExpression ?\n        (value: MetadataValue, node: ts.Node) =>\n            this.options.substituteExpression!(substituteExpression(value, node), node) :\n        substituteExpression;\n    const evaluatorOptions = substituteExpression ?\n        {...this.options, substituteExpression: composedSubstituter} :\n        this.options;\n    let metadata: {[name: string]: MetadataValue|ClassMetadata|FunctionMetadata}|undefined;\n    const evaluator = new Evaluator(locals, nodeMap, evaluatorOptions, (name, value) => {\n      if (!metadata) metadata = {};\n      metadata[name] = value;\n    });\n    let exports: ModuleExportMetadata[]|undefined = undefined;\n\n    function objFromDecorator(decoratorNode: ts.Decorator): MetadataSymbolicExpression {\n      return <MetadataSymbolicExpression>evaluator.evaluateNode(decoratorNode.expression);\n    }\n\n    function recordEntry<T extends MetadataEntry>(entry: T, node: ts.Node): T {\n      if (composedSubstituter) {\n        entry = composedSubstituter(entry as MetadataValue, node) as T;\n      }\n      return recordMapEntry(entry, node, nodeMap, sourceFile);\n    }\n\n    function errorSym(\n        message: string, node?: ts.Node, context?: {[name: string]: string}): MetadataError {\n      return errorSymbol(message, node, context, sourceFile);\n    }\n\n    function maybeGetSimpleFunction(functionDeclaration: ts.FunctionDeclaration|\n                                    ts.MethodDeclaration): {func: FunctionMetadata, name: string}|\n        undefined {\n      if (functionDeclaration.name && functionDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n        const nameNode = <ts.Identifier>functionDeclaration.name;\n        const functionName = nameNode.text;\n        const functionBody = functionDeclaration.body;\n        if (functionBody && functionBody.statements.length == 1) {\n          const statement = functionBody.statements[0];\n          if (statement.kind === ts.SyntaxKind.ReturnStatement) {\n            const returnStatement = <ts.ReturnStatement>statement;\n            if (returnStatement.expression) {\n              const func: FunctionMetadata = {\n                __symbolic: 'function',\n                parameters: namesOf(functionDeclaration.parameters),\n                value: evaluator.evaluateNode(returnStatement.expression)\n              };\n              if (functionDeclaration.parameters.some(p => p.initializer != null)) {\n                func.defaults = functionDeclaration.parameters.map(\n                    p => p.initializer && evaluator.evaluateNode(p.initializer));\n              }\n              return recordEntry({func, name: functionName}, functionDeclaration);\n            }\n          }\n        }\n      }\n    }\n\n    function classMetadataOf(classDeclaration: ts.ClassDeclaration): ClassMetadata {\n      const result: ClassMetadata = {__symbolic: 'class'};\n\n      function getDecorators(decorators: ReadonlyArray<ts.Decorator>|\n                             undefined): MetadataSymbolicExpression[]|undefined {\n        if (decorators && decorators.length)\n          return decorators.map(decorator => objFromDecorator(decorator));\n        return undefined;\n      }\n\n      function referenceFrom(node: ts.Node): MetadataSymbolicReferenceExpression|MetadataError|\n          MetadataSymbolicSelectExpression {\n        const result = evaluator.evaluateNode(node);\n        if (isMetadataError(result) || isMetadataSymbolicReferenceExpression(result) ||\n            isMetadataSymbolicSelectExpression(result)) {\n          return result;\n        } else {\n          return errorSym('Symbol reference expected', node);\n        }\n      }\n\n      // Add class parents\n      if (classDeclaration.heritageClauses) {\n        classDeclaration.heritageClauses.forEach((hc) => {\n          if (hc.token === ts.SyntaxKind.ExtendsKeyword && hc.types) {\n            hc.types.forEach(type => result.extends = referenceFrom(type.expression));\n          }\n        });\n      }\n\n      // Add arity if the type is generic\n      const typeParameters = classDeclaration.typeParameters;\n      if (typeParameters && typeParameters.length) {\n        result.arity = typeParameters.length;\n      }\n\n      // Add class decorators\n      if (classDeclaration.decorators) {\n        result.decorators = getDecorators(classDeclaration.decorators);\n      }\n\n      // member decorators\n      let members: MetadataMap|null = null;\n      function recordMember(name: string, metadata: MemberMetadata) {\n        if (!members) members = {};\n        const data = members.hasOwnProperty(name) ? members[name] : [];\n        data.push(metadata);\n        members[name] = data;\n      }\n\n      // static member\n      let statics: {[name: string]: MetadataValue|FunctionMetadata}|null = null;\n      function recordStaticMember(name: string, value: MetadataValue|FunctionMetadata) {\n        if (!statics) statics = {};\n        statics[name] = value;\n      }\n\n      for (const member of classDeclaration.members) {\n        let isConstructor = false;\n        switch (member.kind) {\n          case ts.SyntaxKind.Constructor:\n          case ts.SyntaxKind.MethodDeclaration:\n            isConstructor = member.kind === ts.SyntaxKind.Constructor;\n            const method = <ts.MethodDeclaration|ts.ConstructorDeclaration>member;\n            if (isStatic(method)) {\n              const maybeFunc = maybeGetSimpleFunction(<ts.MethodDeclaration>method);\n              if (maybeFunc) {\n                recordStaticMember(maybeFunc.name, maybeFunc.func);\n              }\n              continue;\n            }\n            const methodDecorators = getDecorators(method.decorators);\n            const parameters = method.parameters;\n            const parameterDecoratorData: ((MetadataSymbolicExpression | MetadataError)[]|\n                                           undefined)[] = [];\n            const parametersData: (MetadataSymbolicReferenceExpression|MetadataError|\n                                   MetadataSymbolicSelectExpression|null)[] = [];\n            let hasDecoratorData: boolean = false;\n            let hasParameterData: boolean = false;\n            for (const parameter of parameters) {\n              const parameterData = getDecorators(parameter.decorators);\n              parameterDecoratorData.push(parameterData);\n              hasDecoratorData = hasDecoratorData || !!parameterData;\n              if (isConstructor) {\n                if (parameter.type) {\n                  parametersData.push(referenceFrom(parameter.type));\n                } else {\n                  parametersData.push(null);\n                }\n                hasParameterData = true;\n              }\n            }\n            const data: MethodMetadata = {__symbolic: isConstructor ? 'constructor' : 'method'};\n            const name = isConstructor ? '__ctor__' : evaluator.nameOf(member.name);\n            if (methodDecorators) {\n              data.decorators = methodDecorators;\n            }\n            if (hasDecoratorData) {\n              data.parameterDecorators = parameterDecoratorData;\n            }\n            if (hasParameterData) {\n              (<ConstructorMetadata>data).parameters = parametersData;\n            }\n            if (!isMetadataError(name)) {\n              recordMember(name, data);\n            }\n            break;\n          case ts.SyntaxKind.PropertyDeclaration:\n          case ts.SyntaxKind.GetAccessor:\n          case ts.SyntaxKind.SetAccessor:\n            const property = <ts.PropertyDeclaration>member;\n            if (isStatic(property)) {\n              const name = evaluator.nameOf(property.name);\n              if (!isMetadataError(name) && !shouldIgnoreStaticMember(name)) {\n                if (property.initializer) {\n                  const value = evaluator.evaluateNode(property.initializer);\n                  recordStaticMember(name, value);\n                } else {\n                  recordStaticMember(name, errorSym('Variable not initialized', property.name));\n                }\n              }\n            }\n            const propertyDecorators = getDecorators(property.decorators);\n            if (propertyDecorators) {\n              const name = evaluator.nameOf(property.name);\n              if (!isMetadataError(name)) {\n                recordMember(name, {__symbolic: 'property', decorators: propertyDecorators});\n              }\n            }\n            break;\n        }\n      }\n      if (members) {\n        result.members = members;\n      }\n      if (statics) {\n        result.statics = statics;\n      }\n\n      return recordEntry(result, classDeclaration);\n    }\n\n    // Collect all exported symbols from an exports clause.\n    const exportMap = new Map<string, string>();\n    ts.forEachChild(sourceFile, node => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ExportDeclaration:\n          const exportDeclaration = <ts.ExportDeclaration>node;\n          const {moduleSpecifier, exportClause} = exportDeclaration;\n\n          if (!moduleSpecifier && exportClause && ts.isNamedExports(exportClause)) {\n            // If there is a module specifier there is also an exportClause\n            exportClause.elements.forEach(spec => {\n              const exportedAs = spec.name.text;\n              const name = (spec.propertyName || spec.name).text;\n              exportMap.set(name, exportedAs);\n            });\n          }\n      }\n    });\n\n    const isExport = (node: ts.Node) => sourceFile.isDeclarationFile ||\n        ts.getCombinedModifierFlags(node as ts.Declaration) & ts.ModifierFlags.Export;\n    const isExportedIdentifier = (identifier?: ts.Identifier) =>\n        identifier && exportMap.has(identifier.text);\n    const isExported = (node: ts.FunctionDeclaration|ts.ClassDeclaration|ts.TypeAliasDeclaration|\n                        ts.InterfaceDeclaration|ts.EnumDeclaration) =>\n        isExport(node) || isExportedIdentifier(node.name);\n    const exportedIdentifierName = (identifier?: ts.Identifier) =>\n        identifier && (exportMap.get(identifier.text) || identifier.text);\n    const exportedName = (node: ts.FunctionDeclaration|ts.ClassDeclaration|\n                          ts.InterfaceDeclaration|ts.TypeAliasDeclaration|ts.EnumDeclaration) =>\n        exportedIdentifierName(node.name);\n\n\n    // Pre-declare classes and functions\n    ts.forEachChild(sourceFile, node => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ClassDeclaration:\n          const classDeclaration = <ts.ClassDeclaration>node;\n          if (classDeclaration.name) {\n            const className = classDeclaration.name.text;\n            if (isExported(classDeclaration)) {\n              locals.define(\n                  className, {__symbolic: 'reference', name: exportedName(classDeclaration)});\n            } else {\n              locals.define(\n                  className, errorSym('Reference to non-exported class', node, {className}));\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n          const interfaceDeclaration = <ts.InterfaceDeclaration>node;\n          if (interfaceDeclaration.name) {\n            const interfaceName = interfaceDeclaration.name.text;\n            // All references to interfaces should be converted to references to `any`.\n            locals.define(interfaceName, {__symbolic: 'reference', name: 'any'});\n          }\n          break;\n\n        case ts.SyntaxKind.FunctionDeclaration:\n          const functionDeclaration = <ts.FunctionDeclaration>node;\n          if (!isExported(functionDeclaration)) {\n            // Report references to this function as an error.\n            const nameNode = functionDeclaration.name;\n            if (nameNode && nameNode.text) {\n              locals.define(\n                  nameNode.text,\n                  errorSym(\n                      'Reference to a non-exported function', nameNode, {name: nameNode.text}));\n            }\n          }\n          break;\n      }\n    });\n\n    ts.forEachChild(sourceFile, node => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ExportDeclaration:\n          // Record export declarations\n          const exportDeclaration = <ts.ExportDeclaration>node;\n          const {moduleSpecifier, exportClause} = exportDeclaration;\n\n          if (!moduleSpecifier) {\n            // no module specifier -> export {propName as name};\n            if (exportClause && ts.isNamedExports(exportClause)) {\n              exportClause.elements.forEach(spec => {\n                const name = spec.name.text;\n                // If the symbol was not already exported, export a reference since it is a\n                // reference to an import\n                if (!metadata || !metadata[name]) {\n                  const propNode = spec.propertyName || spec.name;\n                  const value: MetadataValue = evaluator.evaluateNode(propNode);\n                  if (!metadata) metadata = {};\n                  metadata[name] = recordEntry(value, node);\n                }\n              });\n            }\n          }\n\n          if (moduleSpecifier && moduleSpecifier.kind == ts.SyntaxKind.StringLiteral) {\n            // Ignore exports that don't have string literals as exports.\n            // This is allowed by the syntax but will be flagged as an error by the type checker.\n            const from = (<ts.StringLiteral>moduleSpecifier).text;\n            const moduleExport: ModuleExportMetadata = {from};\n            if (exportClause && ts.isNamedExports(exportClause)) {\n              moduleExport.export = exportClause.elements.map(\n                  spec => spec.propertyName ? {name: spec.propertyName.text, as: spec.name.text} :\n                                              spec.name.text);\n            }\n            if (!exports) exports = [];\n            exports.push(moduleExport);\n          }\n          break;\n        case ts.SyntaxKind.ClassDeclaration:\n          const classDeclaration = <ts.ClassDeclaration>node;\n          if (classDeclaration.name) {\n            if (isExported(classDeclaration)) {\n              const name = exportedName(classDeclaration);\n              if (name) {\n                if (!metadata) metadata = {};\n                metadata[name] = classMetadataOf(classDeclaration);\n              }\n            }\n          }\n          // Otherwise don't record metadata for the class.\n          break;\n\n        case ts.SyntaxKind.TypeAliasDeclaration:\n          const typeDeclaration = <ts.TypeAliasDeclaration>node;\n          if (typeDeclaration.name && isExported(typeDeclaration)) {\n            const name = exportedName(typeDeclaration);\n            if (name) {\n              if (!metadata) metadata = {};\n              metadata[name] = {__symbolic: 'interface'};\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.InterfaceDeclaration:\n          const interfaceDeclaration = <ts.InterfaceDeclaration>node;\n          if (interfaceDeclaration.name && isExported(interfaceDeclaration)) {\n            const name = exportedName(interfaceDeclaration);\n            if (name) {\n              if (!metadata) metadata = {};\n              metadata[name] = {__symbolic: 'interface'};\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.FunctionDeclaration:\n          // Record functions that return a single value. Record the parameter\n          // names substitution will be performed by the StaticReflector.\n          const functionDeclaration = <ts.FunctionDeclaration>node;\n          if (isExported(functionDeclaration) && functionDeclaration.name) {\n            const name = exportedName(functionDeclaration);\n            const maybeFunc = maybeGetSimpleFunction(functionDeclaration);\n            if (name) {\n              if (!metadata) metadata = {};\n              // TODO(alxhub): The literal here is not valid FunctionMetadata.\n              metadata[name] =\n                  maybeFunc ? recordEntry(maybeFunc.func, node) : ({__symbolic: 'function'} as any);\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.EnumDeclaration:\n          const enumDeclaration = <ts.EnumDeclaration>node;\n          if (isExported(enumDeclaration)) {\n            const enumValueHolder: {[name: string]: MetadataValue} = {};\n            const enumName = exportedName(enumDeclaration);\n            let nextDefaultValue: MetadataValue = 0;\n            let writtenMembers = 0;\n            for (const member of enumDeclaration.members) {\n              let enumValue: MetadataValue;\n              if (!member.initializer) {\n                enumValue = nextDefaultValue;\n              } else {\n                enumValue = evaluator.evaluateNode(member.initializer);\n              }\n              let name: string|undefined = undefined;\n              if (member.name.kind == ts.SyntaxKind.Identifier) {\n                const identifier = <ts.Identifier>member.name;\n                name = identifier.text;\n                enumValueHolder[name] = enumValue;\n                writtenMembers++;\n              }\n              if (typeof enumValue === 'number') {\n                nextDefaultValue = enumValue + 1;\n              } else if (name) {\n                // TODO(alxhub): 'left' here has a name propery which is not valid for\n                // MetadataSymbolicSelectExpression.\n                nextDefaultValue = {\n                  __symbolic: 'binary',\n                  operator: '+',\n                  left: {\n                    __symbolic: 'select',\n                    expression: recordEntry({__symbolic: 'reference', name: enumName}, node),\n                    name\n                  },\n                } as any;\n              } else {\n                nextDefaultValue =\n                    recordEntry(errorSym('Unsupported enum member name', member.name), node);\n              }\n            }\n            if (writtenMembers) {\n              if (enumName) {\n                if (!metadata) metadata = {};\n                metadata[enumName] = recordEntry(enumValueHolder, node);\n              }\n            }\n          }\n          break;\n\n        case ts.SyntaxKind.VariableStatement:\n          const variableStatement = <ts.VariableStatement>node;\n          for (const variableDeclaration of variableStatement.declarationList.declarations) {\n            if (variableDeclaration.name.kind == ts.SyntaxKind.Identifier) {\n              const nameNode = <ts.Identifier>variableDeclaration.name;\n              let varValue: MetadataValue;\n              if (variableDeclaration.initializer) {\n                varValue = evaluator.evaluateNode(variableDeclaration.initializer);\n              } else {\n                varValue = recordEntry(errorSym('Variable not initialized', nameNode), nameNode);\n              }\n              let exported = false;\n              if (isExport(variableStatement) || isExport(variableDeclaration) ||\n                  isExportedIdentifier(nameNode)) {\n                const name = exportedIdentifierName(nameNode);\n                if (name) {\n                  if (!metadata) metadata = {};\n                  metadata[name] = recordEntry(varValue, node);\n                }\n                exported = true;\n              }\n              if (typeof varValue == 'string' || typeof varValue == 'number' ||\n                  typeof varValue == 'boolean') {\n                locals.define(nameNode.text, varValue);\n                if (exported) {\n                  locals.defineReference(\n                      nameNode.text, {__symbolic: 'reference', name: nameNode.text});\n                }\n              } else if (!exported) {\n                if (varValue && !isMetadataError(varValue)) {\n                  locals.define(nameNode.text, recordEntry(varValue, node));\n                } else {\n                  locals.define(\n                      nameNode.text,\n                      recordEntry(\n                          errorSym('Reference to a local symbol', nameNode, {name: nameNode.text}),\n                          node));\n                }\n              }\n            } else {\n              // Destructuring (or binding) declarations are not supported,\n              // var {<identifier>[, <identifier>]+} = <expression>;\n              //   or\n              // var [<identifier>[, <identifier}+] = <expression>;\n              // are not supported.\n              const report: (nameNode: ts.Node) => void = (nameNode: ts.Node) => {\n                switch (nameNode.kind) {\n                  case ts.SyntaxKind.Identifier:\n                    const name = <ts.Identifier>nameNode;\n                    const varValue = errorSym('Destructuring not supported', name);\n                    locals.define(name.text, varValue);\n                    if (isExport(node)) {\n                      if (!metadata) metadata = {};\n                      metadata[name.text] = varValue;\n                    }\n                    break;\n                  case ts.SyntaxKind.BindingElement:\n                    const bindingElement = <ts.BindingElement>nameNode;\n                    report(bindingElement.name);\n                    break;\n                  case ts.SyntaxKind.ObjectBindingPattern:\n                  case ts.SyntaxKind.ArrayBindingPattern:\n                    const bindings = <ts.BindingPattern>nameNode;\n                    (bindings as any).elements.forEach(report);\n                    break;\n                }\n              };\n              report(variableDeclaration.name);\n            }\n          }\n          break;\n      }\n    });\n\n    if (metadata || exports) {\n      if (!metadata)\n        metadata = {};\n      else if (strict) {\n        validateMetadata(sourceFile, nodeMap, metadata);\n      }\n      const result: ModuleMetadata = {\n        __symbolic: 'module',\n        version: this.options.version || METADATA_VERSION,\n        metadata\n      };\n      if (sourceFile.moduleName) result.importAs = sourceFile.moduleName;\n      if (exports) result.exports = exports;\n      return result;\n    }\n  }\n}\n\n// This will throw if the metadata entry given contains an error node.\nfunction validateMetadata(\n    sourceFile: ts.SourceFile, nodeMap: Map<MetadataEntry, ts.Node>,\n    metadata: {[name: string]: MetadataEntry}) {\n  let locals: Set<string> = new Set(['Array', 'Object', 'Set', 'Map', 'string', 'number', 'any']);\n\n  function validateExpression(expression: MetadataValue|MetadataSymbolicExpression|MetadataError) {\n    if (!expression) {\n      return;\n    } else if (Array.isArray(expression)) {\n      expression.forEach(validateExpression);\n    } else if (typeof expression === 'object' && !expression.hasOwnProperty('__symbolic')) {\n      Object.getOwnPropertyNames(expression).forEach(v => validateExpression((<any>expression)[v]));\n    } else if (isMetadataError(expression)) {\n      reportError(expression);\n    } else if (isMetadataGlobalReferenceExpression(expression)) {\n      if (!locals.has(expression.name)) {\n        const reference = <MetadataValue>metadata[expression.name];\n        if (reference) {\n          validateExpression(reference);\n        }\n      }\n    } else if (isFunctionMetadata(expression)) {\n      validateFunction(<any>expression);\n    } else if (isMetadataSymbolicExpression(expression)) {\n      switch (expression.__symbolic) {\n        case 'binary':\n          const binaryExpression = <MetadataSymbolicBinaryExpression>expression;\n          validateExpression(binaryExpression.left);\n          validateExpression(binaryExpression.right);\n          break;\n        case 'call':\n        case 'new':\n          const callExpression = <MetadataSymbolicCallExpression>expression;\n          validateExpression(callExpression.expression);\n          if (callExpression.arguments) callExpression.arguments.forEach(validateExpression);\n          break;\n        case 'index':\n          const indexExpression = <MetadataSymbolicIndexExpression>expression;\n          validateExpression(indexExpression.expression);\n          validateExpression(indexExpression.index);\n          break;\n        case 'pre':\n          const prefixExpression = <MetadataSymbolicPrefixExpression>expression;\n          validateExpression(prefixExpression.operand);\n          break;\n        case 'select':\n          const selectExpression = <MetadataSymbolicSelectExpression>expression;\n          validateExpression(selectExpression.expression);\n          break;\n        case 'spread':\n          const spreadExpression = <MetadataSymbolicSpreadExpression>expression;\n          validateExpression(spreadExpression.expression);\n          break;\n        case 'if':\n          const ifExpression = <MetadataSymbolicIfExpression>expression;\n          validateExpression(ifExpression.condition);\n          validateExpression(ifExpression.elseExpression);\n          validateExpression(ifExpression.thenExpression);\n          break;\n      }\n    }\n  }\n\n  function validateMember(classData: ClassMetadata, member: MemberMetadata) {\n    if (member.decorators) {\n      member.decorators.forEach(validateExpression);\n    }\n    if (isMethodMetadata(member) && member.parameterDecorators) {\n      member.parameterDecorators.forEach(validateExpression);\n    }\n    // Only validate parameters of classes for which we know that are used with our DI\n    if (classData.decorators && isConstructorMetadata(member) && member.parameters) {\n      member.parameters.forEach(validateExpression);\n    }\n  }\n\n  function validateClass(classData: ClassMetadata) {\n    if (classData.decorators) {\n      classData.decorators.forEach(validateExpression);\n    }\n    if (classData.members) {\n      Object.getOwnPropertyNames(classData.members)\n          .forEach(name => classData.members![name].forEach((m) => validateMember(classData, m)));\n    }\n    if (classData.statics) {\n      Object.getOwnPropertyNames(classData.statics).forEach(name => {\n        const staticMember = classData.statics![name];\n        if (isFunctionMetadata(staticMember)) {\n          validateExpression(staticMember.value);\n        } else {\n          validateExpression(staticMember);\n        }\n      });\n    }\n  }\n\n  function validateFunction(functionDeclaration: FunctionMetadata) {\n    if (functionDeclaration.value) {\n      const oldLocals = locals;\n      if (functionDeclaration.parameters) {\n        locals = new Set(oldLocals.values());\n        if (functionDeclaration.parameters)\n          functionDeclaration.parameters.forEach(n => locals.add(n));\n      }\n      validateExpression(functionDeclaration.value);\n      locals = oldLocals;\n    }\n  }\n\n  function shouldReportNode(node: ts.Node|undefined) {\n    if (node) {\n      const nodeStart = node.getStart();\n      return !(\n          node.pos != nodeStart &&\n          sourceFile.text.substring(node.pos, nodeStart).indexOf('@dynamic') >= 0);\n    }\n    return true;\n  }\n\n  function reportError(error: MetadataError) {\n    const node = nodeMap.get(error);\n    if (shouldReportNode(node)) {\n      const lineInfo = error.line != undefined ? error.character != undefined ?\n                                                 `:${error.line + 1}:${error.character + 1}` :\n                                                 `:${error.line + 1}` :\n                                                 '';\n      throw new Error(`${sourceFile.fileName}${\n          lineInfo}: Metadata collected contains an error that will be reported at runtime: ${\n          expandedMessage(error)}.\\n  ${JSON.stringify(error)}`);\n    }\n  }\n\n  Object.getOwnPropertyNames(metadata).forEach(name => {\n    const entry = metadata[name];\n    try {\n      if (isClassMetadata(entry)) {\n        validateClass(entry);\n      }\n    } catch (e) {\n      const node = nodeMap.get(entry);\n      if (shouldReportNode(node)) {\n        if (node) {\n          const {line, character} = sourceFile.getLineAndCharacterOfPosition(node.getStart());\n          throw new Error(`${sourceFile.fileName}:${line + 1}:${\n              character + 1}: Error encountered in metadata generated for exported symbol '${\n              name}': \\n ${e.message}`);\n        }\n        throw new Error(\n            `Error encountered in metadata generated for exported symbol ${name}: \\n ${e.message}`);\n      }\n    }\n  });\n}\n\n// Collect parameter names from a function.\nfunction namesOf(parameters: ts.NodeArray<ts.ParameterDeclaration>): string[] {\n  const result: string[] = [];\n\n  function addNamesOf(name: ts.Identifier|ts.BindingPattern) {\n    if (name.kind == ts.SyntaxKind.Identifier) {\n      const identifier = <ts.Identifier>name;\n      result.push(identifier.text);\n    } else {\n      const bindingPattern = <ts.BindingPattern>name;\n      for (const element of bindingPattern.elements) {\n        const name = (element as any).name;\n        if (name) {\n          addNamesOf(name);\n        }\n      }\n    }\n  }\n\n  for (const parameter of parameters) {\n    addNamesOf(parameter.name);\n  }\n\n  return result;\n}\n\nfunction shouldIgnoreStaticMember(memberName: string): boolean {\n  return memberName.startsWith('ngAcceptInputType_') || memberName.startsWith('ngTemplateGuard_');\n}\n\nfunction expandedMessage(error: any): string {\n  switch (error.message) {\n    case 'Reference to non-exported class':\n      if (error.context && error.context.className) {\n        return `Reference to a non-exported class ${\n            error.context.className}. Consider exporting the class`;\n      }\n      break;\n    case 'Variable not initialized':\n      return 'Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler';\n    case 'Destructuring not supported':\n      return 'Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring';\n    case 'Could not resolve type':\n      if (error.context && error.context.typeName) {\n        return `Could not resolve type ${error.context.typeName}`;\n      }\n      break;\n    case 'Function call not supported':\n      let prefix =\n          error.context && error.context.name ? `Calling function '${error.context.name}', f` : 'F';\n      return prefix +\n          'unction calls are not supported. Consider replacing the function or lambda with a reference to an exported function';\n    case 'Reference to a local symbol':\n      if (error.context && error.context.name) {\n        return `Reference to a local (non-exported) symbol '${\n            error.context.name}'. Consider exporting the symbol`;\n      }\n  }\n  return error.message;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}