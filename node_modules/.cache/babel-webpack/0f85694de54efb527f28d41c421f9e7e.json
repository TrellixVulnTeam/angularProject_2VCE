{"ast":null,"code":"var crypto = require(\"crypto\");\n\nvar path = require(\"path\");\n/**\n * Copyright (c) 2015-present, Waysact Pty Ltd\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction addIfNotExist(set, item) {\n  if (set.has(item)) return true;\n  set.add(item);\n  return false;\n}\n\nfunction findChunksWebpack4(chunk) {\n  var allChunks = new Set();\n  var groupsVisited = new Set();\n\n  (function recurseChunk(childChunk) {\n    function recurseGroup(group) {\n      if (addIfNotExist(groupsVisited, group.id)) return;\n      group.chunks.forEach(recurseChunk);\n      group.childrenIterable.forEach(recurseGroup);\n    }\n\n    if (addIfNotExist(allChunks, childChunk)) return;\n    childChunk.groupsIterable.forEach(recurseGroup);\n  })(chunk);\n\n  return allChunks;\n}\n\nfunction findChunksLegacy(chunk) {\n  var allChunks = new Set();\n\n  (function recurseChunk(childChunk) {\n    if (addIfNotExist(allChunks, childChunk)) return;\n    childChunk.chunks.forEach(recurseChunk);\n  })(chunk);\n\n  return allChunks;\n}\n\nfunction findChunks(chunk) {\n  if (chunk.groupsIterable) {\n    return findChunksWebpack4(chunk);\n  }\n\n  return findChunksLegacy(chunk);\n}\n\nfunction computeIntegrity(hashFuncNames, source) {\n  return hashFuncNames.map(function mapHashFuncName(hashFuncName) {\n    var hash = crypto.createHash(hashFuncName).update(source, \"utf8\").digest(\"base64\");\n    return hashFuncName + \"-\" + hash;\n  }).join(\" \");\n}\n\nfunction getTagSrc(tag) {\n  // Get asset path - src from scripts and href from links\n  return tag.attributes.href || tag.attributes.src;\n}\n\nfunction filterTag(tag) {\n  // Process only script and link tags with a url\n  return (tag.tagName === \"script\" || tag.tagName === \"link\") && tag.attributes && getTagSrc(tag);\n}\n\nfunction normalizePath(p) {\n  return p.replace(/\\?.*$/, \"\").split(path.sep).join(\"/\");\n}\n\nfunction getIntegrityChecksumForAsset(assets, src) {\n  var normalizedSrc;\n  var normalizedKey;\n  var asset = assets[src];\n\n  if (asset) {\n    return asset.integrity;\n  }\n\n  normalizedSrc = normalizePath(src);\n  normalizedKey = Object.keys(assets).find(function test(assetKey) {\n    return normalizePath(assetKey) === normalizedSrc;\n  });\n\n  if (normalizedKey) {\n    return assets[normalizedKey].integrity;\n  }\n\n  return null;\n}\n\nfunction isRuntimeChunk(chunk) {\n  return \"hasRuntime\" in chunk ? chunk.hasRuntime() : chunk.entry;\n}\n\nfunction makePlaceholder(hashFuncNames, id) {\n  var placeholder = \"*-*-*-CHUNK-SRI-HASH-\" + id + \"-*-*-*\";\n  return computeIntegrity(hashFuncNames, placeholder);\n}\n\nmodule.exports.computeIntegrity = computeIntegrity;\nmodule.exports.findChunks = findChunks;\nmodule.exports.filterTag = filterTag;\nmodule.exports.getTagSrc = getTagSrc;\nmodule.exports.normalizePath = normalizePath;\nmodule.exports.getIntegrityChecksumForAsset = getIntegrityChecksumForAsset;\nmodule.exports.isRuntimeChunk = isRuntimeChunk;\nmodule.exports.makePlaceholder = makePlaceholder;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack-subresource-integrity/util.js"],"names":["crypto","require","path","addIfNotExist","set","item","has","add","findChunksWebpack4","chunk","allChunks","Set","groupsVisited","recurseChunk","childChunk","recurseGroup","group","id","chunks","forEach","childrenIterable","groupsIterable","findChunksLegacy","findChunks","computeIntegrity","hashFuncNames","source","map","mapHashFuncName","hashFuncName","hash","createHash","update","digest","join","getTagSrc","tag","attributes","href","src","filterTag","tagName","normalizePath","p","replace","split","sep","getIntegrityChecksumForAsset","assets","normalizedSrc","normalizedKey","asset","integrity","Object","keys","find","test","assetKey","isRuntimeChunk","hasRuntime","entry","makePlaceholder","placeholder","module","exports"],"mappings":"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","sourcesContent":["var crypto = require(\"crypto\");\nvar path = require(\"path\");\n/**\n * Copyright (c) 2015-present, Waysact Pty Ltd\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction addIfNotExist(set, item) {\n  if (set.has(item)) return true;\n  set.add(item);\n  return false;\n}\n\nfunction findChunksWebpack4(chunk) {\n  var allChunks = new Set();\n  var groupsVisited = new Set();\n\n  (function recurseChunk(childChunk) {\n    function recurseGroup(group) {\n      if (addIfNotExist(groupsVisited, group.id)) return;\n      group.chunks.forEach(recurseChunk);\n      group.childrenIterable.forEach(recurseGroup);\n    }\n\n    if (addIfNotExist(allChunks, childChunk)) return;\n    childChunk.groupsIterable.forEach(recurseGroup);\n  })(chunk);\n\n  return allChunks;\n}\n\nfunction findChunksLegacy(chunk) {\n  var allChunks = new Set();\n  (function recurseChunk(childChunk) {\n    if (addIfNotExist(allChunks, childChunk)) return;\n    childChunk.chunks.forEach(recurseChunk);\n  })(chunk);\n  return allChunks;\n}\n\nfunction findChunks(chunk) {\n  if (chunk.groupsIterable) {\n    return findChunksWebpack4(chunk);\n  }\n  return findChunksLegacy(chunk);\n}\n\nfunction computeIntegrity(hashFuncNames, source) {\n  return hashFuncNames\n    .map(function mapHashFuncName(hashFuncName) {\n      var hash = crypto\n        .createHash(hashFuncName)\n        .update(source, \"utf8\")\n        .digest(\"base64\");\n      return hashFuncName + \"-\" + hash;\n    })\n    .join(\" \");\n}\n\nfunction getTagSrc(tag) {\n  // Get asset path - src from scripts and href from links\n  return tag.attributes.href || tag.attributes.src;\n}\n\nfunction filterTag(tag) {\n  // Process only script and link tags with a url\n  return (\n    (tag.tagName === \"script\" || tag.tagName === \"link\") &&\n    tag.attributes &&\n    getTagSrc(tag)\n  );\n}\n\nfunction normalizePath(p) {\n  return p\n    .replace(/\\?.*$/, \"\")\n    .split(path.sep)\n    .join(\"/\");\n}\n\nfunction getIntegrityChecksumForAsset(assets, src) {\n  var normalizedSrc;\n  var normalizedKey;\n  var asset = assets[src];\n  if (asset) {\n    return asset.integrity;\n  }\n  normalizedSrc = normalizePath(src);\n  normalizedKey = Object.keys(assets).find(function test(assetKey) {\n    return normalizePath(assetKey) === normalizedSrc;\n  });\n  if (normalizedKey) {\n    return assets[normalizedKey].integrity;\n  }\n  return null;\n}\n\nfunction isRuntimeChunk(chunk) {\n  return \"hasRuntime\" in chunk ? chunk.hasRuntime() : chunk.entry;\n}\n\nfunction makePlaceholder(hashFuncNames, id) {\n  var placeholder = \"*-*-*-CHUNK-SRI-HASH-\" + id + \"-*-*-*\";\n  return computeIntegrity(hashFuncNames, placeholder);\n}\n\nmodule.exports.computeIntegrity = computeIntegrity;\nmodule.exports.findChunks = findChunks;\nmodule.exports.filterTag = filterTag;\nmodule.exports.getTagSrc = getTagSrc;\nmodule.exports.normalizePath = normalizePath;\nmodule.exports.getIntegrityChecksumForAsset = getIntegrityChecksumForAsset;\nmodule.exports.isRuntimeChunk = isRuntimeChunk;\nmodule.exports.makePlaceholder = makePlaceholder;\n"]},"metadata":{},"sourceType":"script"}