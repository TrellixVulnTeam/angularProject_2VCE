{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/incremental/src/state\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\", \"@angular/compiler-cli/src/ngtsc/incremental/src/dependency_tracking\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.IncrementalDriver = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var semantic_graph_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\");\n\n  var dependency_tracking_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/src/dependency_tracking\");\n  /**\n   * Drives an incremental build, by tracking changes and determining which files need to be emitted.\n   */\n\n\n  var IncrementalDriver =\n  /** @class */\n  function () {\n    function IncrementalDriver(state, depGraph, logicalChanges) {\n      this.depGraph = depGraph;\n      this.logicalChanges = logicalChanges;\n      this.state = state;\n    }\n    /**\n     * Construct an `IncrementalDriver` with a starting state that incorporates the results of a\n     * previous build.\n     *\n     * The previous build's `BuildState` is reconciled with the new program's changes, and the results\n     * are merged into the new build's `PendingBuildState`.\n     */\n\n\n    IncrementalDriver.reconcile = function (oldProgram, oldDriver, newProgram, modifiedResourceFiles, perf) {\n      return perf.inPhase(perf_1.PerfPhase.Reconciliation, function () {\n        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e; // Initialize the state of the current build based on the previous one.\n\n\n        var state;\n\n        if (oldDriver.state.kind === BuildStateKind.Pending) {\n          // The previous build never made it past the pending state. Reuse it as the starting state\n          // for this build.\n          state = oldDriver.state;\n        } else {\n          var priorGraph = null;\n\n          if (oldDriver.state.lastGood !== null) {\n            priorGraph = oldDriver.state.lastGood.semanticDepGraph;\n          } // The previous build was successfully analyzed. `pendingEmit` is the only state carried\n          // forward into this build.\n\n\n          state = {\n            kind: BuildStateKind.Pending,\n            pendingEmit: oldDriver.state.pendingEmit,\n            pendingTypeCheckEmit: oldDriver.state.pendingTypeCheckEmit,\n            changedResourcePaths: new Set(),\n            changedTsPaths: new Set(),\n            lastGood: oldDriver.state.lastGood,\n            semanticDepGraphUpdater: new semantic_graph_1.SemanticDepGraphUpdater(priorGraph)\n          };\n        } // Merge the freshly modified resource files with any prior ones.\n\n\n        if (modifiedResourceFiles !== null) {\n          try {\n            for (var modifiedResourceFiles_1 = tslib_1.__values(modifiedResourceFiles), modifiedResourceFiles_1_1 = modifiedResourceFiles_1.next(); !modifiedResourceFiles_1_1.done; modifiedResourceFiles_1_1 = modifiedResourceFiles_1.next()) {\n              var resFile = modifiedResourceFiles_1_1.value;\n              state.changedResourcePaths.add(file_system_1.absoluteFrom(resFile));\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (modifiedResourceFiles_1_1 && !modifiedResourceFiles_1_1.done && (_a = modifiedResourceFiles_1.return)) _a.call(modifiedResourceFiles_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        } // Next, process the files in the new program, with a couple of goals:\n        // 1) Determine which TS files have changed, if any, and merge them into `changedTsFiles`.\n        // 2) Produce a list of TS files which no longer exist in the program (they've been deleted\n        //    since the previous compilation). These need to be removed from the state tracking to\n        //    avoid leaking memory.\n        // All files in the old program, for easy detection of changes.\n\n\n        var oldFiles = new Set(oldProgram.getSourceFiles().map(typescript_1.toUnredirectedSourceFile)); // Assume all the old files were deleted to begin with. Only TS files are tracked.\n\n        var deletedTsPaths = new Set(tsOnlyFiles(oldProgram).map(function (sf) {\n          return sf.fileName;\n        }));\n\n        try {\n          for (var _f = tslib_1.__values(newProgram.getSourceFiles()), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var possiblyRedirectedNewFile = _g.value;\n            var newFile = typescript_1.toUnredirectedSourceFile(possiblyRedirectedNewFile);\n\n            if (!newFile.isDeclarationFile) {\n              // This file exists in the new program, so remove it from `deletedTsPaths`.\n              deletedTsPaths.delete(newFile.fileName);\n            }\n\n            if (oldFiles.has(newFile)) {\n              // This file hasn't changed; no need to look at it further.\n              continue;\n            } // The file has changed since the last successful build. The appropriate reaction depends on\n            // what kind of file it is.\n\n\n            if (!newFile.isDeclarationFile) {\n              // It's a .ts file, so track it as a change.\n              state.changedTsPaths.add(newFile.fileName);\n            } else {\n              // It's a .d.ts file. Currently the compiler does not do a great job of tracking\n              // dependencies on .d.ts files, so bail out of incremental builds here and do a full\n              // build. This usually only happens if something in node_modules changes.\n              return IncrementalDriver.fresh(newProgram);\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        try {\n          // The next step is to remove any deleted files from the state.\n          for (var deletedTsPaths_1 = tslib_1.__values(deletedTsPaths), deletedTsPaths_1_1 = deletedTsPaths_1.next(); !deletedTsPaths_1_1.done; deletedTsPaths_1_1 = deletedTsPaths_1.next()) {\n            var filePath = deletedTsPaths_1_1.value;\n            state.pendingEmit.delete(filePath);\n            state.pendingTypeCheckEmit.delete(filePath); // Even if the file doesn't exist in the current compilation, it still might have been\n            // changed in a previous one, so delete it from the set of changed TS files, just in case.\n\n            state.changedTsPaths.delete(filePath);\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (deletedTsPaths_1_1 && !deletedTsPaths_1_1.done && (_c = deletedTsPaths_1.return)) _c.call(deletedTsPaths_1);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n\n        perf.eventCount(perf_1.PerfEvent.SourceFilePhysicalChange, state.changedTsPaths.size); // Now, changedTsPaths contains physically changed TS paths. Use the previous program's\n        // logical dependency graph to determine logically changed files.\n\n        var depGraph = new dependency_tracking_1.FileDependencyGraph(); // If a previous compilation exists, use its dependency graph to determine the set of\n        // logically changed files.\n\n        var logicalChanges = null;\n\n        if (state.lastGood !== null) {\n          // Extract the set of logically changed files. At the same time, this operation populates\n          // the current (fresh) dependency graph with information about those files which have not\n          // logically changed.\n          logicalChanges = depGraph.updateWithPhysicalChanges(state.lastGood.depGraph, state.changedTsPaths, deletedTsPaths, state.changedResourcePaths);\n          perf.eventCount(perf_1.PerfEvent.SourceFileLogicalChange, logicalChanges.size);\n\n          try {\n            for (var _h = tslib_1.__values(state.changedTsPaths), _j = _h.next(); !_j.done; _j = _h.next()) {\n              var fileName = _j.value;\n              logicalChanges.add(fileName);\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_j && !_j.done && (_d = _h.return)) _d.call(_h);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n\n          try {\n            // Any logically changed files need to be re-emitted. Most of the time this would happen\n            // regardless because the new dependency graph would _also_ identify the file as stale.\n            // However there are edge cases such as removing a component from an NgModule without adding\n            // it to another one, where the previous graph identifies the file as logically changed, but\n            // the new graph (which does not have that edge) fails to identify that the file should be\n            // re-emitted.\n            for (var logicalChanges_1 = tslib_1.__values(logicalChanges), logicalChanges_1_1 = logicalChanges_1.next(); !logicalChanges_1_1.done; logicalChanges_1_1 = logicalChanges_1.next()) {\n              var change = logicalChanges_1_1.value;\n              state.pendingEmit.add(change);\n              state.pendingTypeCheckEmit.add(change);\n            }\n          } catch (e_5_1) {\n            e_5 = {\n              error: e_5_1\n            };\n          } finally {\n            try {\n              if (logicalChanges_1_1 && !logicalChanges_1_1.done && (_e = logicalChanges_1.return)) _e.call(logicalChanges_1);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n          }\n        } // `state` now reflects the initial pending state of the current compilation.\n\n\n        return new IncrementalDriver(state, depGraph, logicalChanges);\n      });\n    };\n\n    IncrementalDriver.fresh = function (program) {\n      // Initialize the set of files which need to be emitted to the set of all TS files in the\n      // program.\n      var tsFiles = tsOnlyFiles(program);\n      var state = {\n        kind: BuildStateKind.Pending,\n        pendingEmit: new Set(tsFiles.map(function (sf) {\n          return sf.fileName;\n        })),\n        pendingTypeCheckEmit: new Set(tsFiles.map(function (sf) {\n          return sf.fileName;\n        })),\n        changedResourcePaths: new Set(),\n        changedTsPaths: new Set(),\n        lastGood: null,\n        semanticDepGraphUpdater: new semantic_graph_1.SemanticDepGraphUpdater(\n        /* priorGraph */\n        null)\n      };\n      return new IncrementalDriver(state, new dependency_tracking_1.FileDependencyGraph(),\n      /* logicalChanges */\n      null);\n    };\n\n    IncrementalDriver.prototype.getSemanticDepGraphUpdater = function () {\n      if (this.state.kind !== BuildStateKind.Pending) {\n        throw new Error('Semantic dependency updater is only available when pending analysis');\n      }\n\n      return this.state.semanticDepGraphUpdater;\n    };\n\n    IncrementalDriver.prototype.recordSuccessfulAnalysis = function (traitCompiler) {\n      var e_6, _a, e_7, _b;\n\n      if (this.state.kind !== BuildStateKind.Pending) {\n        // Changes have already been incorporated.\n        return;\n      }\n\n      var _c = this.state.semanticDepGraphUpdater.finalize(),\n          needsEmit = _c.needsEmit,\n          needsTypeCheckEmit = _c.needsTypeCheckEmit,\n          newGraph = _c.newGraph;\n\n      var pendingEmit = this.state.pendingEmit;\n\n      try {\n        for (var needsEmit_1 = tslib_1.__values(needsEmit), needsEmit_1_1 = needsEmit_1.next(); !needsEmit_1_1.done; needsEmit_1_1 = needsEmit_1.next()) {\n          var path = needsEmit_1_1.value;\n          pendingEmit.add(path);\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (needsEmit_1_1 && !needsEmit_1_1.done && (_a = needsEmit_1.return)) _a.call(needsEmit_1);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n\n      var pendingTypeCheckEmit = this.state.pendingTypeCheckEmit;\n\n      try {\n        for (var needsTypeCheckEmit_1 = tslib_1.__values(needsTypeCheckEmit), needsTypeCheckEmit_1_1 = needsTypeCheckEmit_1.next(); !needsTypeCheckEmit_1_1.done; needsTypeCheckEmit_1_1 = needsTypeCheckEmit_1.next()) {\n          var path = needsTypeCheckEmit_1_1.value;\n          pendingTypeCheckEmit.add(path);\n        }\n      } catch (e_7_1) {\n        e_7 = {\n          error: e_7_1\n        };\n      } finally {\n        try {\n          if (needsTypeCheckEmit_1_1 && !needsTypeCheckEmit_1_1.done && (_b = needsTypeCheckEmit_1.return)) _b.call(needsTypeCheckEmit_1);\n        } finally {\n          if (e_7) throw e_7.error;\n        }\n      } // Update the state to an `AnalyzedBuildState`.\n\n\n      this.state = {\n        kind: BuildStateKind.Analyzed,\n        pendingEmit: pendingEmit,\n        pendingTypeCheckEmit: pendingTypeCheckEmit,\n        // Since this compilation was successfully analyzed, update the \"last good\" artifacts to the\n        // ones from the current compilation.\n        lastGood: {\n          depGraph: this.depGraph,\n          semanticDepGraph: newGraph,\n          traitCompiler: traitCompiler,\n          typeCheckingResults: null\n        },\n        priorTypeCheckingResults: this.state.lastGood !== null ? this.state.lastGood.typeCheckingResults : null\n      };\n    };\n\n    IncrementalDriver.prototype.recordSuccessfulTypeCheck = function (results) {\n      var e_8, _a;\n\n      if (this.state.lastGood === null || this.state.kind !== BuildStateKind.Analyzed) {\n        return;\n      }\n\n      this.state.lastGood.typeCheckingResults = results;\n\n      try {\n        // Delete the files for which type-check code was generated from the set of pending type-check\n        // files.\n        for (var _b = tslib_1.__values(results.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var fileName = _c.value;\n          this.state.pendingTypeCheckEmit.delete(fileName);\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n    };\n\n    IncrementalDriver.prototype.recordSuccessfulEmit = function (sf) {\n      this.state.pendingEmit.delete(sf.fileName);\n    };\n\n    IncrementalDriver.prototype.safeToSkipEmit = function (sf) {\n      return !this.state.pendingEmit.has(sf.fileName);\n    };\n\n    IncrementalDriver.prototype.priorWorkFor = function (sf) {\n      if (this.state.lastGood === null || this.logicalChanges === null) {\n        // There is no previous good build, so no prior work exists.\n        return null;\n      } else if (this.logicalChanges.has(sf.fileName)) {\n        // Prior work might exist, but would be stale as the file in question has logically changed.\n        return null;\n      } else {\n        // Prior work might exist, and if it does then it's usable!\n        return this.state.lastGood.traitCompiler.recordsFor(sf);\n      }\n    };\n\n    IncrementalDriver.prototype.priorTypeCheckingResultsFor = function (sf) {\n      if (this.state.kind !== BuildStateKind.Analyzed || this.state.priorTypeCheckingResults === null || this.logicalChanges === null) {\n        return null;\n      }\n\n      if (this.logicalChanges.has(sf.fileName) || this.state.pendingTypeCheckEmit.has(sf.fileName)) {\n        return null;\n      }\n\n      var fileName = file_system_1.absoluteFromSourceFile(sf);\n\n      if (!this.state.priorTypeCheckingResults.has(fileName)) {\n        return null;\n      }\n\n      var data = this.state.priorTypeCheckingResults.get(fileName);\n\n      if (data.hasInlines) {\n        return null;\n      }\n\n      return data;\n    };\n\n    return IncrementalDriver;\n  }();\n\n  exports.IncrementalDriver = IncrementalDriver;\n  var BuildStateKind;\n\n  (function (BuildStateKind) {\n    BuildStateKind[BuildStateKind[\"Pending\"] = 0] = \"Pending\";\n    BuildStateKind[BuildStateKind[\"Analyzed\"] = 1] = \"Analyzed\";\n  })(BuildStateKind || (BuildStateKind = {}));\n\n  function tsOnlyFiles(program) {\n    return program.getSourceFiles().filter(function (sf) {\n      return !sf.isDeclarationFile;\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/src/state.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\nimport {PerfEvent, PerfPhase, PerfRecorder} from '../../perf';\nimport {ClassDeclaration} from '../../reflection';\nimport {ClassRecord, TraitCompiler} from '../../transform';\nimport {FileTypeCheckingData} from '../../typecheck/src/checker';\nimport {toUnredirectedSourceFile} from '../../util/src/typescript';\nimport {IncrementalBuild} from '../api';\nimport {SemanticDepGraph, SemanticDepGraphUpdater} from '../semantic_graph';\n\nimport {FileDependencyGraph} from './dependency_tracking';\n\n/**\n * Drives an incremental build, by tracking changes and determining which files need to be emitted.\n */\nexport class IncrementalDriver implements IncrementalBuild<ClassRecord, FileTypeCheckingData> {\n  /**\n   * State of the current build.\n   *\n   * This transitions as the compilation progresses.\n   */\n  private state: BuildState;\n\n  private constructor(\n      state: PendingBuildState, readonly depGraph: FileDependencyGraph,\n      private logicalChanges: Set<string>|null) {\n    this.state = state;\n  }\n\n  /**\n   * Construct an `IncrementalDriver` with a starting state that incorporates the results of a\n   * previous build.\n   *\n   * The previous build's `BuildState` is reconciled with the new program's changes, and the results\n   * are merged into the new build's `PendingBuildState`.\n   */\n  static reconcile(\n      oldProgram: ts.Program, oldDriver: IncrementalDriver, newProgram: ts.Program,\n      modifiedResourceFiles: Set<string>|null, perf: PerfRecorder): IncrementalDriver {\n    return perf.inPhase(PerfPhase.Reconciliation, () => {\n      // Initialize the state of the current build based on the previous one.\n      let state: PendingBuildState;\n      if (oldDriver.state.kind === BuildStateKind.Pending) {\n        // The previous build never made it past the pending state. Reuse it as the starting state\n        // for this build.\n        state = oldDriver.state;\n      } else {\n        let priorGraph: SemanticDepGraph|null = null;\n        if (oldDriver.state.lastGood !== null) {\n          priorGraph = oldDriver.state.lastGood.semanticDepGraph;\n        }\n\n        // The previous build was successfully analyzed. `pendingEmit` is the only state carried\n        // forward into this build.\n        state = {\n          kind: BuildStateKind.Pending,\n          pendingEmit: oldDriver.state.pendingEmit,\n          pendingTypeCheckEmit: oldDriver.state.pendingTypeCheckEmit,\n          changedResourcePaths: new Set<AbsoluteFsPath>(),\n          changedTsPaths: new Set<string>(),\n          lastGood: oldDriver.state.lastGood,\n          semanticDepGraphUpdater: new SemanticDepGraphUpdater(priorGraph),\n        };\n      }\n\n      // Merge the freshly modified resource files with any prior ones.\n      if (modifiedResourceFiles !== null) {\n        for (const resFile of modifiedResourceFiles) {\n          state.changedResourcePaths.add(absoluteFrom(resFile));\n        }\n      }\n\n      // Next, process the files in the new program, with a couple of goals:\n      // 1) Determine which TS files have changed, if any, and merge them into `changedTsFiles`.\n      // 2) Produce a list of TS files which no longer exist in the program (they've been deleted\n      //    since the previous compilation). These need to be removed from the state tracking to\n      //    avoid leaking memory.\n\n      // All files in the old program, for easy detection of changes.\n      const oldFiles =\n          new Set<ts.SourceFile>(oldProgram.getSourceFiles().map(toUnredirectedSourceFile));\n\n      // Assume all the old files were deleted to begin with. Only TS files are tracked.\n      const deletedTsPaths = new Set<string>(tsOnlyFiles(oldProgram).map(sf => sf.fileName));\n\n      for (const possiblyRedirectedNewFile of newProgram.getSourceFiles()) {\n        const newFile = toUnredirectedSourceFile(possiblyRedirectedNewFile);\n        if (!newFile.isDeclarationFile) {\n          // This file exists in the new program, so remove it from `deletedTsPaths`.\n          deletedTsPaths.delete(newFile.fileName);\n        }\n\n        if (oldFiles.has(newFile)) {\n          // This file hasn't changed; no need to look at it further.\n          continue;\n        }\n\n        // The file has changed since the last successful build. The appropriate reaction depends on\n        // what kind of file it is.\n        if (!newFile.isDeclarationFile) {\n          // It's a .ts file, so track it as a change.\n          state.changedTsPaths.add(newFile.fileName);\n        } else {\n          // It's a .d.ts file. Currently the compiler does not do a great job of tracking\n          // dependencies on .d.ts files, so bail out of incremental builds here and do a full\n          // build. This usually only happens if something in node_modules changes.\n          return IncrementalDriver.fresh(newProgram);\n        }\n      }\n\n      // The next step is to remove any deleted files from the state.\n      for (const filePath of deletedTsPaths) {\n        state.pendingEmit.delete(filePath);\n        state.pendingTypeCheckEmit.delete(filePath);\n\n        // Even if the file doesn't exist in the current compilation, it still might have been\n        // changed in a previous one, so delete it from the set of changed TS files, just in case.\n        state.changedTsPaths.delete(filePath);\n      }\n\n      perf.eventCount(PerfEvent.SourceFilePhysicalChange, state.changedTsPaths.size);\n\n      // Now, changedTsPaths contains physically changed TS paths. Use the previous program's\n      // logical dependency graph to determine logically changed files.\n      const depGraph = new FileDependencyGraph();\n\n      // If a previous compilation exists, use its dependency graph to determine the set of\n      // logically changed files.\n      let logicalChanges: Set<string>|null = null;\n      if (state.lastGood !== null) {\n        // Extract the set of logically changed files. At the same time, this operation populates\n        // the current (fresh) dependency graph with information about those files which have not\n        // logically changed.\n        logicalChanges = depGraph.updateWithPhysicalChanges(\n            state.lastGood.depGraph, state.changedTsPaths, deletedTsPaths,\n            state.changedResourcePaths);\n        perf.eventCount(PerfEvent.SourceFileLogicalChange, logicalChanges.size);\n        for (const fileName of state.changedTsPaths) {\n          logicalChanges.add(fileName);\n        }\n\n        // Any logically changed files need to be re-emitted. Most of the time this would happen\n        // regardless because the new dependency graph would _also_ identify the file as stale.\n        // However there are edge cases such as removing a component from an NgModule without adding\n        // it to another one, where the previous graph identifies the file as logically changed, but\n        // the new graph (which does not have that edge) fails to identify that the file should be\n        // re-emitted.\n        for (const change of logicalChanges) {\n          state.pendingEmit.add(change);\n          state.pendingTypeCheckEmit.add(change);\n        }\n      }\n\n      // `state` now reflects the initial pending state of the current compilation.\n      return new IncrementalDriver(state, depGraph, logicalChanges);\n    });\n  }\n\n  static fresh(program: ts.Program): IncrementalDriver {\n    // Initialize the set of files which need to be emitted to the set of all TS files in the\n    // program.\n    const tsFiles = tsOnlyFiles(program);\n\n    const state: PendingBuildState = {\n      kind: BuildStateKind.Pending,\n      pendingEmit: new Set<string>(tsFiles.map(sf => sf.fileName)),\n      pendingTypeCheckEmit: new Set<string>(tsFiles.map(sf => sf.fileName)),\n      changedResourcePaths: new Set<AbsoluteFsPath>(),\n      changedTsPaths: new Set<string>(),\n      lastGood: null,\n      semanticDepGraphUpdater: new SemanticDepGraphUpdater(/* priorGraph */ null),\n    };\n\n    return new IncrementalDriver(state, new FileDependencyGraph(), /* logicalChanges */ null);\n  }\n\n  getSemanticDepGraphUpdater(): SemanticDepGraphUpdater {\n    if (this.state.kind !== BuildStateKind.Pending) {\n      throw new Error('Semantic dependency updater is only available when pending analysis');\n    }\n    return this.state.semanticDepGraphUpdater;\n  }\n\n  recordSuccessfulAnalysis(traitCompiler: TraitCompiler): void {\n    if (this.state.kind !== BuildStateKind.Pending) {\n      // Changes have already been incorporated.\n      return;\n    }\n\n    const {needsEmit, needsTypeCheckEmit, newGraph} = this.state.semanticDepGraphUpdater.finalize();\n\n    const pendingEmit = this.state.pendingEmit;\n    for (const path of needsEmit) {\n      pendingEmit.add(path);\n    }\n\n    const pendingTypeCheckEmit = this.state.pendingTypeCheckEmit;\n    for (const path of needsTypeCheckEmit) {\n      pendingTypeCheckEmit.add(path);\n    }\n\n    // Update the state to an `AnalyzedBuildState`.\n    this.state = {\n      kind: BuildStateKind.Analyzed,\n      pendingEmit,\n      pendingTypeCheckEmit,\n\n      // Since this compilation was successfully analyzed, update the \"last good\" artifacts to the\n      // ones from the current compilation.\n      lastGood: {\n        depGraph: this.depGraph,\n        semanticDepGraph: newGraph,\n        traitCompiler: traitCompiler,\n        typeCheckingResults: null,\n      },\n\n      priorTypeCheckingResults:\n          this.state.lastGood !== null ? this.state.lastGood.typeCheckingResults : null,\n    };\n  }\n\n  recordSuccessfulTypeCheck(results: Map<AbsoluteFsPath, FileTypeCheckingData>): void {\n    if (this.state.lastGood === null || this.state.kind !== BuildStateKind.Analyzed) {\n      return;\n    }\n    this.state.lastGood.typeCheckingResults = results;\n\n    // Delete the files for which type-check code was generated from the set of pending type-check\n    // files.\n    for (const fileName of results.keys()) {\n      this.state.pendingTypeCheckEmit.delete(fileName);\n    }\n  }\n\n  recordSuccessfulEmit(sf: ts.SourceFile): void {\n    this.state.pendingEmit.delete(sf.fileName);\n  }\n\n  safeToSkipEmit(sf: ts.SourceFile): boolean {\n    return !this.state.pendingEmit.has(sf.fileName);\n  }\n\n  priorWorkFor(sf: ts.SourceFile): ClassRecord[]|null {\n    if (this.state.lastGood === null || this.logicalChanges === null) {\n      // There is no previous good build, so no prior work exists.\n      return null;\n    } else if (this.logicalChanges.has(sf.fileName)) {\n      // Prior work might exist, but would be stale as the file in question has logically changed.\n      return null;\n    } else {\n      // Prior work might exist, and if it does then it's usable!\n      return this.state.lastGood.traitCompiler.recordsFor(sf);\n    }\n  }\n\n  priorTypeCheckingResultsFor(sf: ts.SourceFile): FileTypeCheckingData|null {\n    if (this.state.kind !== BuildStateKind.Analyzed ||\n        this.state.priorTypeCheckingResults === null || this.logicalChanges === null) {\n      return null;\n    }\n\n    if (this.logicalChanges.has(sf.fileName) || this.state.pendingTypeCheckEmit.has(sf.fileName)) {\n      return null;\n    }\n\n    const fileName = absoluteFromSourceFile(sf);\n    if (!this.state.priorTypeCheckingResults.has(fileName)) {\n      return null;\n    }\n    const data = this.state.priorTypeCheckingResults.get(fileName)!;\n    if (data.hasInlines) {\n      return null;\n    }\n\n    return data;\n  }\n}\n\ntype BuildState = PendingBuildState|AnalyzedBuildState;\n\nenum BuildStateKind {\n  Pending,\n  Analyzed,\n}\n\ninterface BaseBuildState {\n  kind: BuildStateKind;\n\n  /**\n   * The heart of incremental builds. This `Set` tracks the set of files which need to be emitted\n   * during the current compilation.\n   *\n   * This starts out as the set of files which are still pending from the previous program (or the\n   * full set of .ts files on a fresh build).\n   *\n   * After analysis, it's updated to include any files which might have changed and need a re-emit\n   * as a result of incremental changes.\n   *\n   * If an emit happens, any written files are removed from the `Set`, as they're no longer\n   * pending.\n   *\n   * Thus, after compilation `pendingEmit` should be empty (on a successful build) or contain the\n   * files which still need to be emitted but have not yet been (due to errors).\n   *\n   * `pendingEmit` is tracked as as `Set<string>` instead of a `Set<ts.SourceFile>`, because the\n   * contents of the file are not important here, only whether or not the current version of it\n   * needs to be emitted. The `string`s here are TS file paths.\n   *\n   * See the README.md for more information on this algorithm.\n   */\n  pendingEmit: Set<string>;\n\n  /**\n   * Similar to `pendingEmit`, but then for representing the set of files for which the type-check\n   * file should be regenerated. It behaves identically with respect to errored compilations as\n   * `pendingEmit`.\n   */\n  pendingTypeCheckEmit: Set<string>;\n\n\n  /**\n   * Specific aspects of the last compilation which successfully completed analysis, if any.\n   */\n  lastGood: {\n    /**\n     * The dependency graph from the last successfully analyzed build.\n     *\n     * This is used to determine the logical impact of physical file changes.\n     */\n    depGraph: FileDependencyGraph;\n\n    /**\n     * The semantic dependency graph from the last successfully analyzed build.\n     *\n     * This is used to perform in-depth comparison of Angular decorated classes, to determine\n     * which files have to be re-emitted and/or re-type-checked.\n     */\n    semanticDepGraph: SemanticDepGraph;\n\n    /**\n     * The `TraitCompiler` from the last successfully analyzed build.\n     *\n     * This is used to extract \"prior work\" which might be reusable in this compilation.\n     */\n    traitCompiler: TraitCompiler;\n\n    /**\n     * Type checking results which will be passed onto the next build.\n     */\n    typeCheckingResults: Map<AbsoluteFsPath, FileTypeCheckingData>| null;\n  }|null;\n}\n\n/**\n * State of a build before the Angular analysis phase completes.\n */\ninterface PendingBuildState extends BaseBuildState {\n  kind: BuildStateKind.Pending;\n\n  /**\n   * Set of files which are known to need an emit.\n   *\n   * Before the compiler's analysis phase completes, `pendingEmit` only contains files that were\n   * still pending after the previous build.\n   */\n  pendingEmit: Set<string>;\n\n  /**\n   * Set of TypeScript file paths which have changed since the last successfully analyzed build.\n   */\n  changedTsPaths: Set<string>;\n\n  /**\n   * Set of resource file paths which have changed since the last successfully analyzed build.\n   */\n  changedResourcePaths: Set<AbsoluteFsPath>;\n\n  /**\n   * In a pending state, the semantic dependency graph is available to the compilation to register\n   * the incremental symbols into.\n   */\n  semanticDepGraphUpdater: SemanticDepGraphUpdater;\n}\n\ninterface AnalyzedBuildState extends BaseBuildState {\n  kind: BuildStateKind.Analyzed;\n\n  /**\n   * Set of files which are known to need an emit.\n   *\n   * After analysis completes (that is, the state transitions to `AnalyzedBuildState`), the\n   * `pendingEmit` set takes into account any on-disk changes made since the last successfully\n   * analyzed build.\n   */\n  pendingEmit: Set<string>;\n\n  /**\n   * Type checking results from the previous compilation, which can be reused in this one.\n   */\n  priorTypeCheckingResults: Map<AbsoluteFsPath, FileTypeCheckingData>|null;\n}\n\nfunction tsOnlyFiles(program: ts.Program): ReadonlyArray<ts.SourceFile> {\n  return program.getSourceFiles().filter(sf => !sf.isDeclarationFile);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}