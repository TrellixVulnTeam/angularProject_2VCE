{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.elideImports = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ts = require(\"typescript\");\n\nvar interfaces_1 = require(\"./interfaces\"); // Remove imports for which all identifiers have been removed.\n// Needs type checker, and works even if it's not the first transformer.\n// Works by removing imports for symbols whose identifiers have all been removed.\n// Doesn't use the `symbol.declarations` because that previous transforms might have removed nodes\n// but the type checker doesn't know.\n// See https://github.com/Microsoft/TypeScript/issues/17552 for more information.\n\n\nfunction elideImports(sourceFile, removedNodes, getTypeChecker, compilerOptions) {\n  var ops = [];\n\n  if (removedNodes.length === 0) {\n    return [];\n  }\n\n  var typeChecker = getTypeChecker(); // Collect all imports and used identifiers\n\n  var usedSymbols = new Set();\n  var imports = [];\n  ts.forEachChild(sourceFile, function visit(node) {\n    var _a, _b, _c, _d, _e; // Skip removed nodes.\n\n\n    if (removedNodes.includes(node)) {\n      return;\n    } // Consider types for 'implements' as unused.\n    // A HeritageClause token can also be an 'AbstractKeyword'\n    // which in that case we should not elide the import.\n\n\n    if (ts.isHeritageClause(node) && node.token === ts.SyntaxKind.ImplementsKeyword) {\n      return;\n    } // Record import and skip\n\n\n    if (ts.isImportDeclaration(node)) {\n      if (!((_a = node.importClause) === null || _a === void 0 ? void 0 : _a.isTypeOnly)) {\n        imports.push(node);\n      }\n\n      return;\n    }\n\n    var symbol;\n\n    if (ts.isTypeReferenceNode(node)) {\n      if (!compilerOptions.emitDecoratorMetadata) {\n        // Skip and mark as unused if emitDecoratorMetadata is disabled.\n        return;\n      }\n\n      var parent = node.parent;\n      var isTypeReferenceForDecoratoredNode = false;\n\n      switch (parent.kind) {\n        case ts.SyntaxKind.GetAccessor:\n        case ts.SyntaxKind.PropertyDeclaration:\n        case ts.SyntaxKind.MethodDeclaration:\n          isTypeReferenceForDecoratoredNode = !!((_b = parent.decorators) === null || _b === void 0 ? void 0 : _b.length);\n          break;\n\n        case ts.SyntaxKind.Parameter:\n          // - A constructor parameter can be decorated or the class itself is decorated.\n          // - The parent of the parameter is decorated example a method declaration or a set accessor.\n          // In all cases we need the type reference not to be elided.\n          isTypeReferenceForDecoratoredNode = !!(((_c = parent.decorators) === null || _c === void 0 ? void 0 : _c.length) || ts.isSetAccessor(parent.parent) && !!((_d = parent.parent.decorators) === null || _d === void 0 ? void 0 : _d.length) || ts.isConstructorDeclaration(parent.parent) && !!((_e = parent.parent.parent.decorators) === null || _e === void 0 ? void 0 : _e.length));\n          break;\n      }\n\n      if (isTypeReferenceForDecoratoredNode) {\n        symbol = typeChecker.getSymbolAtLocation(node.typeName);\n      }\n    } else {\n      switch (node.kind) {\n        case ts.SyntaxKind.Identifier:\n          var _parent = node.parent;\n\n          if (_parent && ts.isShorthandPropertyAssignment(_parent)) {\n            var shorthandSymbol = typeChecker.getShorthandAssignmentValueSymbol(_parent);\n\n            if (shorthandSymbol) {\n              symbol = shorthandSymbol;\n            }\n          } else {\n            symbol = typeChecker.getSymbolAtLocation(node);\n          }\n\n          break;\n\n        case ts.SyntaxKind.ExportSpecifier:\n          symbol = typeChecker.getExportSpecifierLocalTargetSymbol(node);\n          break;\n\n        case ts.SyntaxKind.ShorthandPropertyAssignment:\n          symbol = typeChecker.getShorthandAssignmentValueSymbol(node);\n          break;\n      }\n    }\n\n    if (symbol) {\n      usedSymbols.add(symbol);\n    }\n\n    ts.forEachChild(node, visit);\n  });\n\n  if (imports.length === 0) {\n    return [];\n  }\n\n  var isUnused = function isUnused(node) {\n    var symbol = typeChecker.getSymbolAtLocation(node);\n    return symbol && !usedSymbols.has(symbol);\n  };\n\n  for (var _i = 0, _imports = imports; _i < _imports.length; _i++) {\n    var node = _imports[_i];\n\n    if (!node.importClause) {\n      // \"import 'abc';\"\n      continue;\n    }\n\n    var namedBindings = node.importClause.namedBindings;\n\n    if (namedBindings && ts.isNamespaceImport(namedBindings)) {\n      // \"import * as XYZ from 'abc';\"\n      if (isUnused(namedBindings.name)) {\n        ops.push(new interfaces_1.RemoveNodeOperation(sourceFile, node));\n      }\n    } else {\n      var specifierOps = [];\n      var clausesCount = 0; // \"import { XYZ, ... } from 'abc';\"\n\n      if (namedBindings && ts.isNamedImports(namedBindings)) {\n        var removedClausesCount = 0;\n        clausesCount += namedBindings.elements.length;\n\n        var _iterator = _createForOfIteratorHelper(namedBindings.elements),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var specifier = _step.value;\n\n            if (isUnused(specifier.name)) {\n              removedClausesCount++; // in case we don't have any more namedImports we should remove the parent ie the {}\n\n              var nodeToRemove = clausesCount === removedClausesCount ? specifier.parent : specifier;\n              specifierOps.push(new interfaces_1.RemoveNodeOperation(sourceFile, nodeToRemove));\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } // \"import XYZ from 'abc';\"\n\n\n      if (node.importClause.name) {\n        clausesCount++;\n\n        if (isUnused(node.importClause.name)) {\n          specifierOps.push(new interfaces_1.RemoveNodeOperation(sourceFile, node.importClause.name));\n        }\n      }\n\n      if (specifierOps.length === clausesCount) {\n        ops.push(new interfaces_1.RemoveNodeOperation(sourceFile, node));\n      } else {\n        ops.push.apply(ops, specifierOps);\n      }\n    }\n  }\n\n  return ops;\n}\n\nexports.elideImports = elideImports;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/transformers/elide_imports.js"],"names":["Object","defineProperty","exports","value","elideImports","ts","require","interfaces_1","sourceFile","removedNodes","getTypeChecker","compilerOptions","ops","length","typeChecker","usedSymbols","Set","imports","forEachChild","visit","node","_a","_b","_c","_d","_e","includes","isHeritageClause","token","SyntaxKind","ImplementsKeyword","isImportDeclaration","importClause","isTypeOnly","push","symbol","isTypeReferenceNode","emitDecoratorMetadata","parent","isTypeReferenceForDecoratoredNode","kind","GetAccessor","PropertyDeclaration","MethodDeclaration","decorators","Parameter","isSetAccessor","isConstructorDeclaration","getSymbolAtLocation","typeName","Identifier","isShorthandPropertyAssignment","shorthandSymbol","getShorthandAssignmentValueSymbol","ExportSpecifier","getExportSpecifierLocalTargetSymbol","ShorthandPropertyAssignment","add","isUnused","has","namedBindings","isNamespaceImport","name","RemoveNodeOperation","specifierOps","clausesCount","isNamedImports","removedClausesCount","elements","specifier","nodeToRemove"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.elideImports = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ts = require(\"typescript\");\nconst interfaces_1 = require(\"./interfaces\");\n// Remove imports for which all identifiers have been removed.\n// Needs type checker, and works even if it's not the first transformer.\n// Works by removing imports for symbols whose identifiers have all been removed.\n// Doesn't use the `symbol.declarations` because that previous transforms might have removed nodes\n// but the type checker doesn't know.\n// See https://github.com/Microsoft/TypeScript/issues/17552 for more information.\nfunction elideImports(sourceFile, removedNodes, getTypeChecker, compilerOptions) {\n    const ops = [];\n    if (removedNodes.length === 0) {\n        return [];\n    }\n    const typeChecker = getTypeChecker();\n    // Collect all imports and used identifiers\n    const usedSymbols = new Set();\n    const imports = [];\n    ts.forEachChild(sourceFile, function visit(node) {\n        var _a, _b, _c, _d, _e;\n        // Skip removed nodes.\n        if (removedNodes.includes(node)) {\n            return;\n        }\n        // Consider types for 'implements' as unused.\n        // A HeritageClause token can also be an 'AbstractKeyword'\n        // which in that case we should not elide the import.\n        if (ts.isHeritageClause(node) && node.token === ts.SyntaxKind.ImplementsKeyword) {\n            return;\n        }\n        // Record import and skip\n        if (ts.isImportDeclaration(node)) {\n            if (!((_a = node.importClause) === null || _a === void 0 ? void 0 : _a.isTypeOnly)) {\n                imports.push(node);\n            }\n            return;\n        }\n        let symbol;\n        if (ts.isTypeReferenceNode(node)) {\n            if (!compilerOptions.emitDecoratorMetadata) {\n                // Skip and mark as unused if emitDecoratorMetadata is disabled.\n                return;\n            }\n            const parent = node.parent;\n            let isTypeReferenceForDecoratoredNode = false;\n            switch (parent.kind) {\n                case ts.SyntaxKind.GetAccessor:\n                case ts.SyntaxKind.PropertyDeclaration:\n                case ts.SyntaxKind.MethodDeclaration:\n                    isTypeReferenceForDecoratoredNode = !!((_b = parent.decorators) === null || _b === void 0 ? void 0 : _b.length);\n                    break;\n                case ts.SyntaxKind.Parameter:\n                    // - A constructor parameter can be decorated or the class itself is decorated.\n                    // - The parent of the parameter is decorated example a method declaration or a set accessor.\n                    // In all cases we need the type reference not to be elided.\n                    isTypeReferenceForDecoratoredNode = !!(((_c = parent.decorators) === null || _c === void 0 ? void 0 : _c.length) ||\n                        (ts.isSetAccessor(parent.parent) && !!((_d = parent.parent.decorators) === null || _d === void 0 ? void 0 : _d.length)) ||\n                        (ts.isConstructorDeclaration(parent.parent) && !!((_e = parent.parent.parent.decorators) === null || _e === void 0 ? void 0 : _e.length)));\n                    break;\n            }\n            if (isTypeReferenceForDecoratoredNode) {\n                symbol = typeChecker.getSymbolAtLocation(node.typeName);\n            }\n        }\n        else {\n            switch (node.kind) {\n                case ts.SyntaxKind.Identifier:\n                    const parent = node.parent;\n                    if (parent && ts.isShorthandPropertyAssignment(parent)) {\n                        const shorthandSymbol = typeChecker.getShorthandAssignmentValueSymbol(parent);\n                        if (shorthandSymbol) {\n                            symbol = shorthandSymbol;\n                        }\n                    }\n                    else {\n                        symbol = typeChecker.getSymbolAtLocation(node);\n                    }\n                    break;\n                case ts.SyntaxKind.ExportSpecifier:\n                    symbol = typeChecker.getExportSpecifierLocalTargetSymbol(node);\n                    break;\n                case ts.SyntaxKind.ShorthandPropertyAssignment:\n                    symbol = typeChecker.getShorthandAssignmentValueSymbol(node);\n                    break;\n            }\n        }\n        if (symbol) {\n            usedSymbols.add(symbol);\n        }\n        ts.forEachChild(node, visit);\n    });\n    if (imports.length === 0) {\n        return [];\n    }\n    const isUnused = (node) => {\n        const symbol = typeChecker.getSymbolAtLocation(node);\n        return symbol && !usedSymbols.has(symbol);\n    };\n    for (const node of imports) {\n        if (!node.importClause) {\n            // \"import 'abc';\"\n            continue;\n        }\n        const namedBindings = node.importClause.namedBindings;\n        if (namedBindings && ts.isNamespaceImport(namedBindings)) {\n            // \"import * as XYZ from 'abc';\"\n            if (isUnused(namedBindings.name)) {\n                ops.push(new interfaces_1.RemoveNodeOperation(sourceFile, node));\n            }\n        }\n        else {\n            const specifierOps = [];\n            let clausesCount = 0;\n            // \"import { XYZ, ... } from 'abc';\"\n            if (namedBindings && ts.isNamedImports(namedBindings)) {\n                let removedClausesCount = 0;\n                clausesCount += namedBindings.elements.length;\n                for (const specifier of namedBindings.elements) {\n                    if (isUnused(specifier.name)) {\n                        removedClausesCount++;\n                        // in case we don't have any more namedImports we should remove the parent ie the {}\n                        const nodeToRemove = clausesCount === removedClausesCount\n                            ? specifier.parent\n                            : specifier;\n                        specifierOps.push(new interfaces_1.RemoveNodeOperation(sourceFile, nodeToRemove));\n                    }\n                }\n            }\n            // \"import XYZ from 'abc';\"\n            if (node.importClause.name) {\n                clausesCount++;\n                if (isUnused(node.importClause.name)) {\n                    specifierOps.push(new interfaces_1.RemoveNodeOperation(sourceFile, node.importClause.name));\n                }\n            }\n            if (specifierOps.length === clausesCount) {\n                ops.push(new interfaces_1.RemoveNodeOperation(sourceFile, node));\n            }\n            else {\n                ops.push(...specifierOps);\n            }\n        }\n    }\n    return ops;\n}\nexports.elideImports = elideImports;\n"]},"metadata":{},"sourceType":"script"}