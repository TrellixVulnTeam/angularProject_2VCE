{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/checker\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/shims\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/typecheck/api\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/completion\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/context\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/diagnostics\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/source\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TemplateTypeCheckerImpl = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var shims_1 = require(\"@angular/compiler-cli/src/ngtsc/shims\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/api\");\n\n  var completion_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/completion\");\n\n  var context_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/context\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/diagnostics\");\n\n  var source_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/source\");\n\n  var tcb_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\");\n\n  var template_symbol_builder_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/template_symbol_builder\");\n\n  var REGISTRY = new compiler_1.DomElementSchemaRegistry();\n  /**\n   * Primary template type-checking engine, which performs type-checking using a\n   * `TypeCheckingProgramStrategy` for type-checking program maintenance, and the\n   * `ProgramTypeCheckAdapter` for generation of template type-checking code.\n   */\n\n  var TemplateTypeCheckerImpl =\n  /** @class */\n  function () {\n    function TemplateTypeCheckerImpl(originalProgram, typeCheckingStrategy, typeCheckAdapter, config, refEmitter, reflector, compilerHost, priorBuild, componentScopeReader, typeCheckScopeRegistry, perf) {\n      this.originalProgram = originalProgram;\n      this.typeCheckingStrategy = typeCheckingStrategy;\n      this.typeCheckAdapter = typeCheckAdapter;\n      this.config = config;\n      this.refEmitter = refEmitter;\n      this.reflector = reflector;\n      this.compilerHost = compilerHost;\n      this.priorBuild = priorBuild;\n      this.componentScopeReader = componentScopeReader;\n      this.typeCheckScopeRegistry = typeCheckScopeRegistry;\n      this.perf = perf;\n      this.state = new Map();\n      /**\n       * Stores the `CompletionEngine` which powers autocompletion for each component class.\n       *\n       * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation\n       * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the\n       * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n       */\n\n      this.completionCache = new Map();\n      /**\n       * Stores the `SymbolBuilder` which creates symbols for each component class.\n       *\n       * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation\n       * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the\n       * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n       */\n\n      this.symbolBuilderCache = new Map();\n      /**\n       * Stores directives and pipes that are in scope for each component.\n       *\n       * Unlike other caches, the scope of a component is not affected by its template. It will be\n       * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is\n       * destroyed and replaced.\n       */\n\n      this.scopeCache = new Map();\n      /**\n       * Stores potential element tags for each component (a union of DOM tags as well as directive\n       * tags).\n       *\n       * Unlike other caches, the scope of a component is not affected by its template. It will be\n       * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is\n       * destroyed and replaced.\n       */\n\n      this.elementTagCache = new Map();\n      this.isComplete = false;\n    }\n\n    TemplateTypeCheckerImpl.prototype.getTemplate = function (component) {\n      var data = this.getLatestComponentState(component).data;\n\n      if (data === null) {\n        return null;\n      }\n\n      return data.template;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getLatestComponentState = function (component) {\n      this.ensureShimForComponent(component);\n      var sf = component.getSourceFile();\n      var sfPath = file_system_1.absoluteFromSourceFile(sf);\n      var shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n      var fileRecord = this.getFileData(sfPath);\n\n      if (!fileRecord.shimData.has(shimPath)) {\n        return {\n          data: null,\n          tcb: null,\n          shimPath: shimPath\n        };\n      }\n\n      var templateId = fileRecord.sourceManager.getTemplateId(component);\n      var shimRecord = fileRecord.shimData.get(shimPath);\n      var id = fileRecord.sourceManager.getTemplateId(component);\n      var program = this.typeCheckingStrategy.getProgram();\n      var shimSf = typescript_1.getSourceFileOrNull(program, shimPath);\n\n      if (shimSf === null || !fileRecord.shimData.has(shimPath)) {\n        throw new Error(\"Error: no shim file in program: \" + shimPath);\n      }\n\n      var tcb = tcb_util_1.findTypeCheckBlock(shimSf, id,\n      /*isDiagnosticsRequest*/\n      false);\n\n      if (tcb === null) {\n        // Try for an inline block.\n        var inlineSf = file_system_1.getSourceFileOrError(program, sfPath);\n        tcb = tcb_util_1.findTypeCheckBlock(inlineSf, id,\n        /*isDiagnosticsRequest*/\n        false);\n      }\n\n      var data = null;\n\n      if (shimRecord.templates.has(templateId)) {\n        data = shimRecord.templates.get(templateId);\n      }\n\n      return {\n        data: data,\n        tcb: tcb,\n        shimPath: shimPath\n      };\n    };\n\n    TemplateTypeCheckerImpl.prototype.isTrackedTypeCheckFile = function (filePath) {\n      return this.getFileAndShimRecordsForPath(filePath) !== null;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getFileAndShimRecordsForPath = function (shimPath) {\n      var e_1, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.state.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var fileRecord = _c.value;\n\n          if (fileRecord.shimData.has(shimPath)) {\n            return {\n              fileRecord: fileRecord,\n              shimRecord: fileRecord.shimData.get(shimPath)\n            };\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return null;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getTemplateMappingAtShimLocation = function (_a) {\n      var shimPath = _a.shimPath,\n          positionInShimFile = _a.positionInShimFile;\n      var records = this.getFileAndShimRecordsForPath(file_system_1.absoluteFrom(shimPath));\n\n      if (records === null) {\n        return null;\n      }\n\n      var fileRecord = records.fileRecord;\n      var shimSf = this.typeCheckingStrategy.getProgram().getSourceFile(file_system_1.absoluteFrom(shimPath));\n\n      if (shimSf === undefined) {\n        return null;\n      }\n\n      return tcb_util_1.getTemplateMapping(shimSf, positionInShimFile, fileRecord.sourceManager,\n      /*isDiagnosticsRequest*/\n      false);\n    };\n\n    TemplateTypeCheckerImpl.prototype.generateAllTypeCheckBlocks = function () {\n      this.ensureAllShimsForAllFiles();\n    };\n    /**\n     * Retrieve type-checking and template parse diagnostics from the given `ts.SourceFile` using the\n     * most recent type-checking program.\n     */\n\n\n    TemplateTypeCheckerImpl.prototype.getDiagnosticsForFile = function (sf, optimizeFor) {\n      var _this = this;\n\n      switch (optimizeFor) {\n        case api_1.OptimizeFor.WholeProgram:\n          this.ensureAllShimsForAllFiles();\n          break;\n\n        case api_1.OptimizeFor.SingleFile:\n          this.ensureAllShimsForOneFile(sf);\n          break;\n      }\n\n      return this.perf.inPhase(perf_1.PerfPhase.TtcDiagnostics, function () {\n        var e_2, _a, e_3, _b;\n\n        var sfPath = file_system_1.absoluteFromSourceFile(sf);\n\n        var fileRecord = _this.state.get(sfPath);\n\n        var typeCheckProgram = _this.typeCheckingStrategy.getProgram();\n\n        var diagnostics = [];\n\n        if (fileRecord.hasInlines) {\n          var inlineSf = file_system_1.getSourceFileOrError(typeCheckProgram, sfPath);\n          diagnostics.push.apply(diagnostics, tslib_1.__spread(typeCheckProgram.getSemanticDiagnostics(inlineSf).map(function (diag) {\n            return convertDiagnostic(diag, fileRecord.sourceManager);\n          })));\n        }\n\n        try {\n          for (var _c = tslib_1.__values(fileRecord.shimData), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var _e = tslib_1.__read(_d.value, 2),\n                shimPath = _e[0],\n                shimRecord = _e[1];\n\n            var shimSf = file_system_1.getSourceFileOrError(typeCheckProgram, shimPath);\n            diagnostics.push.apply(diagnostics, tslib_1.__spread(typeCheckProgram.getSemanticDiagnostics(shimSf).map(function (diag) {\n              return convertDiagnostic(diag, fileRecord.sourceManager);\n            })));\n            diagnostics.push.apply(diagnostics, tslib_1.__spread(shimRecord.genesisDiagnostics));\n\n            try {\n              for (var _f = (e_3 = void 0, tslib_1.__values(shimRecord.templates.values())), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var templateData = _g.value;\n                diagnostics.push.apply(diagnostics, tslib_1.__spread(templateData.templateDiagnostics));\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        return diagnostics.filter(function (diag) {\n          return diag !== null;\n        });\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.getDiagnosticsForComponent = function (component) {\n      var _this = this;\n\n      this.ensureShimForComponent(component);\n      return this.perf.inPhase(perf_1.PerfPhase.TtcDiagnostics, function () {\n        var e_4, _a;\n\n        var sf = component.getSourceFile();\n        var sfPath = file_system_1.absoluteFromSourceFile(sf);\n\n        var shimPath = _this.typeCheckingStrategy.shimPathForComponent(component);\n\n        var fileRecord = _this.getFileData(sfPath);\n\n        if (!fileRecord.shimData.has(shimPath)) {\n          return [];\n        }\n\n        var templateId = fileRecord.sourceManager.getTemplateId(component);\n        var shimRecord = fileRecord.shimData.get(shimPath);\n\n        var typeCheckProgram = _this.typeCheckingStrategy.getProgram();\n\n        var diagnostics = [];\n\n        if (shimRecord.hasInlines) {\n          var inlineSf = file_system_1.getSourceFileOrError(typeCheckProgram, sfPath);\n          diagnostics.push.apply(diagnostics, tslib_1.__spread(typeCheckProgram.getSemanticDiagnostics(inlineSf).map(function (diag) {\n            return convertDiagnostic(diag, fileRecord.sourceManager);\n          })));\n        }\n\n        var shimSf = file_system_1.getSourceFileOrError(typeCheckProgram, shimPath);\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(typeCheckProgram.getSemanticDiagnostics(shimSf).map(function (diag) {\n          return convertDiagnostic(diag, fileRecord.sourceManager);\n        })));\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(shimRecord.genesisDiagnostics));\n\n        try {\n          for (var _b = tslib_1.__values(shimRecord.templates.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var templateData = _c.value;\n            diagnostics.push.apply(diagnostics, tslib_1.__spread(templateData.templateDiagnostics));\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n\n        return diagnostics.filter(function (diag) {\n          return diag !== null && diag.templateId === templateId;\n        });\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.getTypeCheckBlock = function (component) {\n      return this.getLatestComponentState(component).tcb;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getGlobalCompletions = function (context, component, node) {\n      var engine = this.getOrCreateCompletionEngine(component);\n\n      if (engine === null) {\n        return null;\n      }\n\n      return this.perf.inPhase(perf_1.PerfPhase.TtcAutocompletion, function () {\n        return engine.getGlobalCompletions(context, node);\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.getExpressionCompletionLocation = function (ast, component) {\n      var engine = this.getOrCreateCompletionEngine(component);\n\n      if (engine === null) {\n        return null;\n      }\n\n      return this.perf.inPhase(perf_1.PerfPhase.TtcAutocompletion, function () {\n        return engine.getExpressionCompletionLocation(ast);\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.invalidateClass = function (clazz) {\n      this.completionCache.delete(clazz);\n      this.symbolBuilderCache.delete(clazz);\n      this.scopeCache.delete(clazz);\n      this.elementTagCache.delete(clazz);\n      var sf = clazz.getSourceFile();\n      var sfPath = file_system_1.absoluteFromSourceFile(sf);\n      var shimPath = this.typeCheckingStrategy.shimPathForComponent(clazz);\n      var fileData = this.getFileData(sfPath);\n      var templateId = fileData.sourceManager.getTemplateId(clazz);\n      fileData.shimData.delete(shimPath);\n      fileData.isComplete = false;\n      this.isComplete = false;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getOrCreateCompletionEngine = function (component) {\n      if (this.completionCache.has(component)) {\n        return this.completionCache.get(component);\n      }\n\n      var _a = this.getLatestComponentState(component),\n          tcb = _a.tcb,\n          data = _a.data,\n          shimPath = _a.shimPath;\n\n      if (tcb === null || data === null) {\n        return null;\n      }\n\n      var engine = new completion_1.CompletionEngine(tcb, data, shimPath);\n      this.completionCache.set(component, engine);\n      return engine;\n    };\n\n    TemplateTypeCheckerImpl.prototype.maybeAdoptPriorResultsForFile = function (sf) {\n      var sfPath = file_system_1.absoluteFromSourceFile(sf);\n\n      if (this.state.has(sfPath)) {\n        var existingResults = this.state.get(sfPath);\n\n        if (existingResults.isComplete) {\n          // All data for this file has already been generated, so no need to adopt anything.\n          return;\n        }\n      }\n\n      var previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);\n\n      if (previousResults === null || !previousResults.isComplete) {\n        return;\n      }\n\n      this.perf.eventCount(perf_1.PerfEvent.ReuseTypeCheckFile);\n      this.state.set(sfPath, previousResults);\n    };\n\n    TemplateTypeCheckerImpl.prototype.ensureAllShimsForAllFiles = function () {\n      var _this = this;\n\n      if (this.isComplete) {\n        return;\n      }\n\n      this.perf.inPhase(perf_1.PerfPhase.TcbGeneration, function () {\n        var e_5, _a;\n\n        var host = new WholeProgramTypeCheckingHost(_this);\n\n        var ctx = _this.newContext(host);\n\n        try {\n          for (var _b = tslib_1.__values(_this.originalProgram.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var sf = _c.value;\n\n            if (sf.isDeclarationFile || shims_1.isShim(sf)) {\n              continue;\n            }\n\n            _this.maybeAdoptPriorResultsForFile(sf);\n\n            var sfPath = file_system_1.absoluteFromSourceFile(sf);\n\n            var fileData = _this.getFileData(sfPath);\n\n            if (fileData.isComplete) {\n              continue;\n            }\n\n            _this.typeCheckAdapter.typeCheck(sf, ctx);\n\n            fileData.isComplete = true;\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n\n        _this.updateFromContext(ctx);\n\n        _this.isComplete = true;\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.ensureAllShimsForOneFile = function (sf) {\n      var _this = this;\n\n      this.perf.inPhase(perf_1.PerfPhase.TcbGeneration, function () {\n        _this.maybeAdoptPriorResultsForFile(sf);\n\n        var sfPath = file_system_1.absoluteFromSourceFile(sf);\n\n        var fileData = _this.getFileData(sfPath);\n\n        if (fileData.isComplete) {\n          // All data for this file is present and accounted for already.\n          return;\n        }\n\n        var host = new SingleFileTypeCheckingHost(sfPath, fileData, _this.typeCheckingStrategy, _this);\n\n        var ctx = _this.newContext(host);\n\n        _this.typeCheckAdapter.typeCheck(sf, ctx);\n\n        fileData.isComplete = true;\n\n        _this.updateFromContext(ctx);\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.ensureShimForComponent = function (component) {\n      var sf = component.getSourceFile();\n      var sfPath = file_system_1.absoluteFromSourceFile(sf);\n      this.maybeAdoptPriorResultsForFile(sf);\n      var fileData = this.getFileData(sfPath);\n      var shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n\n      if (fileData.shimData.has(shimPath)) {\n        // All data for this component is available.\n        return;\n      }\n\n      var host = new SingleShimTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this, shimPath);\n      var ctx = this.newContext(host);\n      this.typeCheckAdapter.typeCheck(sf, ctx);\n      this.updateFromContext(ctx);\n    };\n\n    TemplateTypeCheckerImpl.prototype.newContext = function (host) {\n      var inlining = this.typeCheckingStrategy.supportsInlineOperations ? context_1.InliningMode.InlineOps : context_1.InliningMode.Error;\n      return new context_1.TypeCheckContextImpl(this.config, this.compilerHost, this.typeCheckingStrategy, this.refEmitter, this.reflector, host, inlining, this.perf);\n    };\n    /**\n     * Remove any shim data that depends on inline operations applied to the type-checking program.\n     *\n     * This can be useful if new inlines need to be applied, and it's not possible to guarantee that\n     * they won't overwrite or corrupt existing inlines that are used by such shims.\n     */\n\n\n    TemplateTypeCheckerImpl.prototype.clearAllShimDataUsingInlines = function () {\n      var e_6, _a, e_7, _b;\n\n      try {\n        for (var _c = tslib_1.__values(this.state.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var fileData = _d.value;\n\n          if (!fileData.hasInlines) {\n            continue;\n          }\n\n          try {\n            for (var _e = (e_7 = void 0, tslib_1.__values(fileData.shimData.entries())), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var _g = tslib_1.__read(_f.value, 2),\n                  shimFile = _g[0],\n                  shimData = _g[1];\n\n              if (shimData.hasInlines) {\n                fileData.shimData.delete(shimFile);\n              }\n            }\n          } catch (e_7_1) {\n            e_7 = {\n              error: e_7_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_7) throw e_7.error;\n            }\n          }\n\n          fileData.hasInlines = false;\n          fileData.isComplete = false;\n          this.isComplete = false;\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n    };\n\n    TemplateTypeCheckerImpl.prototype.updateFromContext = function (ctx) {\n      var _this = this;\n\n      var updates = ctx.finalize();\n      return this.perf.inPhase(perf_1.PerfPhase.TcbUpdateProgram, function () {\n        if (updates.size > 0) {\n          _this.perf.eventCount(perf_1.PerfEvent.UpdateTypeCheckProgram);\n        }\n\n        _this.typeCheckingStrategy.updateFiles(updates, api_1.UpdateMode.Incremental);\n\n        _this.priorBuild.recordSuccessfulTypeCheck(_this.state);\n\n        _this.perf.memory(perf_1.PerfCheckpoint.TtcUpdateProgram);\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.getFileData = function (path) {\n      if (!this.state.has(path)) {\n        this.state.set(path, {\n          hasInlines: false,\n          sourceManager: new source_1.TemplateSourceManager(),\n          isComplete: false,\n          shimData: new Map()\n        });\n      }\n\n      return this.state.get(path);\n    };\n\n    TemplateTypeCheckerImpl.prototype.getSymbolOfNode = function (node, component) {\n      var builder = this.getOrCreateSymbolBuilder(component);\n\n      if (builder === null) {\n        return null;\n      }\n\n      return this.perf.inPhase(perf_1.PerfPhase.TtcSymbol, function () {\n        return builder.getSymbol(node);\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.getOrCreateSymbolBuilder = function (component) {\n      var _this = this;\n\n      if (this.symbolBuilderCache.has(component)) {\n        return this.symbolBuilderCache.get(component);\n      }\n\n      var _a = this.getLatestComponentState(component),\n          tcb = _a.tcb,\n          data = _a.data,\n          shimPath = _a.shimPath;\n\n      if (tcb === null || data === null) {\n        return null;\n      }\n\n      var builder = new template_symbol_builder_1.SymbolBuilder(shimPath, tcb, data, this.componentScopeReader, function () {\n        return _this.typeCheckingStrategy.getProgram().getTypeChecker();\n      });\n      this.symbolBuilderCache.set(component, builder);\n      return builder;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getDirectivesInScope = function (component) {\n      var data = this.getScopeData(component);\n\n      if (data === null) {\n        return null;\n      }\n\n      return data.directives;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getPipesInScope = function (component) {\n      var data = this.getScopeData(component);\n\n      if (data === null) {\n        return null;\n      }\n\n      return data.pipes;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getDirectiveMetadata = function (dir) {\n      if (!reflection_1.isNamedClassDeclaration(dir)) {\n        return null;\n      }\n\n      return this.typeCheckScopeRegistry.getTypeCheckDirectiveMetadata(new imports_1.Reference(dir));\n    };\n\n    TemplateTypeCheckerImpl.prototype.getPotentialElementTags = function (component) {\n      var e_8, _a, e_9, _b, e_10, _c;\n\n      if (this.elementTagCache.has(component)) {\n        return this.elementTagCache.get(component);\n      }\n\n      var tagMap = new Map();\n\n      try {\n        for (var _d = tslib_1.__values(REGISTRY.allKnownElementNames()), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var tag = _e.value;\n          tagMap.set(tag, null);\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n\n      var scope = this.getScopeData(component);\n\n      if (scope !== null) {\n        try {\n          for (var _f = tslib_1.__values(scope.directives), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var directive = _g.value;\n\n            try {\n              for (var _h = (e_10 = void 0, tslib_1.__values(compiler_1.CssSelector.parse(directive.selector))), _j = _h.next(); !_j.done; _j = _h.next()) {\n                var selector = _j.value;\n\n                if (selector.element === null || tagMap.has(selector.element)) {\n                  // Skip this directive if it doesn't match an element tag, or if another directive has\n                  // already been included with the same element name.\n                  continue;\n                }\n\n                tagMap.set(selector.element, directive);\n              }\n            } catch (e_10_1) {\n              e_10 = {\n                error: e_10_1\n              };\n            } finally {\n              try {\n                if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n              } finally {\n                if (e_10) throw e_10.error;\n              }\n            }\n          }\n        } catch (e_9_1) {\n          e_9 = {\n            error: e_9_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_9) throw e_9.error;\n          }\n        }\n      }\n\n      this.elementTagCache.set(component, tagMap);\n      return tagMap;\n    };\n\n    TemplateTypeCheckerImpl.prototype.getPotentialDomBindings = function (tagName) {\n      var attributes = REGISTRY.allKnownAttributesOfElement(tagName);\n      return attributes.map(function (attribute) {\n        return {\n          attribute: attribute,\n          property: REGISTRY.getMappedPropName(attribute)\n        };\n      });\n    };\n\n    TemplateTypeCheckerImpl.prototype.getScopeData = function (component) {\n      var e_11, _a, e_12, _b;\n\n      if (this.scopeCache.has(component)) {\n        return this.scopeCache.get(component);\n      }\n\n      if (!reflection_1.isNamedClassDeclaration(component)) {\n        throw new Error(\"AssertionError: components must have names\");\n      }\n\n      var scope = this.componentScopeReader.getScopeForComponent(component);\n\n      if (scope === null) {\n        return null;\n      }\n\n      var data = {\n        directives: [],\n        pipes: [],\n        isPoisoned: scope.compilation.isPoisoned\n      };\n      var typeChecker = this.typeCheckingStrategy.getProgram().getTypeChecker();\n\n      try {\n        for (var _c = tslib_1.__values(scope.compilation.directives), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var dir = _d.value;\n\n          if (dir.selector === null) {\n            // Skip this directive, it can't be added to a template anyway.\n            continue;\n          }\n\n          var tsSymbol = typeChecker.getSymbolAtLocation(dir.ref.node.name);\n\n          if (tsSymbol === undefined) {\n            continue;\n          }\n\n          var ngModule = null;\n          var moduleScopeOfDir = this.componentScopeReader.getScopeForComponent(dir.ref.node);\n\n          if (moduleScopeOfDir !== null) {\n            ngModule = moduleScopeOfDir.ngModule;\n          }\n\n          data.directives.push({\n            isComponent: dir.isComponent,\n            isStructural: dir.isStructural,\n            selector: dir.selector,\n            tsSymbol: tsSymbol,\n            ngModule: ngModule\n          });\n        }\n      } catch (e_11_1) {\n        e_11 = {\n          error: e_11_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_11) throw e_11.error;\n        }\n      }\n\n      try {\n        for (var _e = tslib_1.__values(scope.compilation.pipes), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var pipe = _f.value;\n          var tsSymbol = typeChecker.getSymbolAtLocation(pipe.ref.node.name);\n\n          if (tsSymbol === undefined) {\n            continue;\n          }\n\n          data.pipes.push({\n            name: pipe.name,\n            tsSymbol: tsSymbol\n          });\n        }\n      } catch (e_12_1) {\n        e_12 = {\n          error: e_12_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_12) throw e_12.error;\n        }\n      }\n\n      this.scopeCache.set(component, data);\n      return data;\n    };\n\n    return TemplateTypeCheckerImpl;\n  }();\n\n  exports.TemplateTypeCheckerImpl = TemplateTypeCheckerImpl;\n\n  function convertDiagnostic(diag, sourceResolver) {\n    if (!diagnostics_1.shouldReportDiagnostic(diag)) {\n      return null;\n    }\n\n    return diagnostics_1.translateDiagnostic(diag, sourceResolver);\n  }\n  /**\n   * Drives a `TypeCheckContext` to generate type-checking code for every component in the program.\n   */\n\n\n  var WholeProgramTypeCheckingHost =\n  /** @class */\n  function () {\n    function WholeProgramTypeCheckingHost(impl) {\n      this.impl = impl;\n    }\n\n    WholeProgramTypeCheckingHost.prototype.getSourceManager = function (sfPath) {\n      return this.impl.getFileData(sfPath).sourceManager;\n    };\n\n    WholeProgramTypeCheckingHost.prototype.shouldCheckComponent = function (node) {\n      var fileData = this.impl.getFileData(file_system_1.absoluteFromSourceFile(node.getSourceFile()));\n      var shimPath = this.impl.typeCheckingStrategy.shimPathForComponent(node); // The component needs to be checked unless the shim which would contain it already exists.\n\n      return !fileData.shimData.has(shimPath);\n    };\n\n    WholeProgramTypeCheckingHost.prototype.recordShimData = function (sfPath, data) {\n      var fileData = this.impl.getFileData(sfPath);\n      fileData.shimData.set(data.path, data);\n\n      if (data.hasInlines) {\n        fileData.hasInlines = true;\n      }\n    };\n\n    WholeProgramTypeCheckingHost.prototype.recordComplete = function (sfPath) {\n      this.impl.getFileData(sfPath).isComplete = true;\n    };\n\n    return WholeProgramTypeCheckingHost;\n  }();\n  /**\n   * Drives a `TypeCheckContext` to generate type-checking code efficiently for a single input file.\n   */\n\n\n  var SingleFileTypeCheckingHost =\n  /** @class */\n  function () {\n    function SingleFileTypeCheckingHost(sfPath, fileData, strategy, impl) {\n      this.sfPath = sfPath;\n      this.fileData = fileData;\n      this.strategy = strategy;\n      this.impl = impl;\n      this.seenInlines = false;\n    }\n\n    SingleFileTypeCheckingHost.prototype.assertPath = function (sfPath) {\n      if (this.sfPath !== sfPath) {\n        throw new Error(\"AssertionError: querying TypeCheckingHost outside of assigned file\");\n      }\n    };\n\n    SingleFileTypeCheckingHost.prototype.getSourceManager = function (sfPath) {\n      this.assertPath(sfPath);\n      return this.fileData.sourceManager;\n    };\n\n    SingleFileTypeCheckingHost.prototype.shouldCheckComponent = function (node) {\n      if (this.sfPath !== file_system_1.absoluteFromSourceFile(node.getSourceFile())) {\n        return false;\n      }\n\n      var shimPath = this.strategy.shimPathForComponent(node); // Only need to generate a TCB for the class if no shim exists for it currently.\n\n      return !this.fileData.shimData.has(shimPath);\n    };\n\n    SingleFileTypeCheckingHost.prototype.recordShimData = function (sfPath, data) {\n      this.assertPath(sfPath); // Previous type-checking state may have required the use of inlines (assuming they were\n      // supported). If the current operation also requires inlines, this presents a problem:\n      // generating new inlines may invalidate any old inlines that old state depends on.\n      //\n      // Rather than resolve this issue by tracking specific dependencies on inlines, if the new state\n      // relies on inlines, any old state that relied on them is simply cleared. This happens when the\n      // first new state that uses inlines is encountered.\n\n      if (data.hasInlines && !this.seenInlines) {\n        this.impl.clearAllShimDataUsingInlines();\n        this.seenInlines = true;\n      }\n\n      this.fileData.shimData.set(data.path, data);\n\n      if (data.hasInlines) {\n        this.fileData.hasInlines = true;\n      }\n    };\n\n    SingleFileTypeCheckingHost.prototype.recordComplete = function (sfPath) {\n      this.assertPath(sfPath);\n      this.fileData.isComplete = true;\n    };\n\n    return SingleFileTypeCheckingHost;\n  }();\n  /**\n   * Drives a `TypeCheckContext` to generate type-checking code efficiently for only those components\n   * which map to a single shim of a single input file.\n   */\n\n\n  var SingleShimTypeCheckingHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(SingleShimTypeCheckingHost, _super);\n\n    function SingleShimTypeCheckingHost(sfPath, fileData, strategy, impl, shimPath) {\n      var _this = _super.call(this, sfPath, fileData, strategy, impl) || this;\n\n      _this.shimPath = shimPath;\n      return _this;\n    }\n\n    SingleShimTypeCheckingHost.prototype.shouldCheckNode = function (node) {\n      if (this.sfPath !== file_system_1.absoluteFromSourceFile(node.getSourceFile())) {\n        return false;\n      } // Only generate a TCB for the component if it maps to the requested shim file.\n\n\n      var shimPath = this.strategy.shimPathForComponent(node);\n\n      if (shimPath !== this.shimPath) {\n        return false;\n      } // Only need to generate a TCB for the class if no shim exists for it currently.\n\n\n      return !this.fileData.shimData.has(shimPath);\n    };\n\n    return SingleShimTypeCheckingHost;\n  }(SingleFileTypeCheckingHost);\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/checker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, CssSelector, DomElementSchemaRegistry, MethodCall, ParseError, parseTemplate, PropertyRead, SafeMethodCall, SafePropertyRead, TmplAstElement, TmplAstNode, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {absoluteFrom, absoluteFromSourceFile, AbsoluteFsPath, getSourceFileOrError} from '../../file_system';\nimport {Reference, ReferenceEmitter} from '../../imports';\nimport {IncrementalBuild} from '../../incremental/api';\nimport {PerfCheckpoint, PerfEvent, PerfPhase, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, isNamedClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ComponentScopeReader, TypeCheckScopeRegistry} from '../../scope';\nimport {isShim} from '../../shims';\nimport {getSourceFileOrNull} from '../../util/src/typescript';\nimport {DirectiveInScope, ElementSymbol, FullTemplateMapping, GlobalCompletion, OptimizeFor, PipeInScope, ProgramTypeCheckAdapter, ShimLocation, Symbol, TemplateId, TemplateSymbol, TemplateTypeChecker, TypeCheckableDirectiveMeta, TypeCheckingConfig, TypeCheckingProgramStrategy, UpdateMode} from '../api';\nimport {TemplateDiagnostic} from '../diagnostics';\n\nimport {CompletionEngine} from './completion';\nimport {InliningMode, ShimTypeCheckingData, TemplateData, TypeCheckContextImpl, TypeCheckingHost} from './context';\nimport {shouldReportDiagnostic, translateDiagnostic} from './diagnostics';\nimport {TemplateSourceManager} from './source';\nimport {findTypeCheckBlock, getTemplateMapping, TemplateSourceResolver} from './tcb_util';\nimport {SymbolBuilder} from './template_symbol_builder';\n\n\nconst REGISTRY = new DomElementSchemaRegistry();\n/**\n * Primary template type-checking engine, which performs type-checking using a\n * `TypeCheckingProgramStrategy` for type-checking program maintenance, and the\n * `ProgramTypeCheckAdapter` for generation of template type-checking code.\n */\nexport class TemplateTypeCheckerImpl implements TemplateTypeChecker {\n  private state = new Map<AbsoluteFsPath, FileTypeCheckingData>();\n\n  /**\n   * Stores the `CompletionEngine` which powers autocompletion for each component class.\n   *\n   * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation\n   * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the\n   * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n   */\n  private completionCache = new Map<ts.ClassDeclaration, CompletionEngine>();\n  /**\n   * Stores the `SymbolBuilder` which creates symbols for each component class.\n   *\n   * Must be invalidated whenever the component's template or the `ts.Program` changes. Invalidation\n   * on template changes is performed within this `TemplateTypeCheckerImpl` instance. When the\n   * `ts.Program` changes, the `TemplateTypeCheckerImpl` as a whole is destroyed and replaced.\n   */\n  private symbolBuilderCache = new Map<ts.ClassDeclaration, SymbolBuilder>();\n\n  /**\n   * Stores directives and pipes that are in scope for each component.\n   *\n   * Unlike other caches, the scope of a component is not affected by its template. It will be\n   * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is\n   * destroyed and replaced.\n   */\n  private scopeCache = new Map<ts.ClassDeclaration, ScopeData>();\n\n  /**\n   * Stores potential element tags for each component (a union of DOM tags as well as directive\n   * tags).\n   *\n   * Unlike other caches, the scope of a component is not affected by its template. It will be\n   * destroyed when the `ts.Program` changes and the `TemplateTypeCheckerImpl` as a whole is\n   * destroyed and replaced.\n   */\n  private elementTagCache = new Map<ts.ClassDeclaration, Map<string, DirectiveInScope|null>>();\n\n  private isComplete = false;\n\n  constructor(\n      private originalProgram: ts.Program,\n      readonly typeCheckingStrategy: TypeCheckingProgramStrategy,\n      private typeCheckAdapter: ProgramTypeCheckAdapter, private config: TypeCheckingConfig,\n      private refEmitter: ReferenceEmitter, private reflector: ReflectionHost,\n      private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>,\n      private priorBuild: IncrementalBuild<unknown, FileTypeCheckingData>,\n      private readonly componentScopeReader: ComponentScopeReader,\n      private readonly typeCheckScopeRegistry: TypeCheckScopeRegistry,\n      private readonly perf: PerfRecorder) {}\n\n  getTemplate(component: ts.ClassDeclaration): TmplAstNode[]|null {\n    const {data} = this.getLatestComponentState(component);\n    if (data === null) {\n      return null;\n    }\n    return data.template;\n  }\n\n  private getLatestComponentState(component: ts.ClassDeclaration):\n      {data: TemplateData|null, tcb: ts.Node|null, shimPath: AbsoluteFsPath} {\n    this.ensureShimForComponent(component);\n\n    const sf = component.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n\n    const fileRecord = this.getFileData(sfPath);\n\n    if (!fileRecord.shimData.has(shimPath)) {\n      return {data: null, tcb: null, shimPath};\n    }\n\n    const templateId = fileRecord.sourceManager.getTemplateId(component);\n    const shimRecord = fileRecord.shimData.get(shimPath)!;\n    const id = fileRecord.sourceManager.getTemplateId(component);\n\n    const program = this.typeCheckingStrategy.getProgram();\n    const shimSf = getSourceFileOrNull(program, shimPath);\n\n    if (shimSf === null || !fileRecord.shimData.has(shimPath)) {\n      throw new Error(`Error: no shim file in program: ${shimPath}`);\n    }\n\n    let tcb: ts.Node|null = findTypeCheckBlock(shimSf, id, /*isDiagnosticsRequest*/ false);\n\n    if (tcb === null) {\n      // Try for an inline block.\n      const inlineSf = getSourceFileOrError(program, sfPath);\n      tcb = findTypeCheckBlock(inlineSf, id, /*isDiagnosticsRequest*/ false);\n    }\n\n    let data: TemplateData|null = null;\n    if (shimRecord.templates.has(templateId)) {\n      data = shimRecord.templates.get(templateId)!;\n    }\n\n    return {data, tcb, shimPath};\n  }\n\n  isTrackedTypeCheckFile(filePath: AbsoluteFsPath): boolean {\n    return this.getFileAndShimRecordsForPath(filePath) !== null;\n  }\n\n  private getFileAndShimRecordsForPath(shimPath: AbsoluteFsPath):\n      {fileRecord: FileTypeCheckingData, shimRecord: ShimTypeCheckingData}|null {\n    for (const fileRecord of this.state.values()) {\n      if (fileRecord.shimData.has(shimPath)) {\n        return {fileRecord, shimRecord: fileRecord.shimData.get(shimPath)!};\n      }\n    }\n    return null;\n  }\n\n  getTemplateMappingAtShimLocation({shimPath, positionInShimFile}: ShimLocation):\n      FullTemplateMapping|null {\n    const records = this.getFileAndShimRecordsForPath(absoluteFrom(shimPath));\n    if (records === null) {\n      return null;\n    }\n    const {fileRecord} = records;\n\n    const shimSf = this.typeCheckingStrategy.getProgram().getSourceFile(absoluteFrom(shimPath));\n    if (shimSf === undefined) {\n      return null;\n    }\n    return getTemplateMapping(\n        shimSf, positionInShimFile, fileRecord.sourceManager, /*isDiagnosticsRequest*/ false);\n  }\n\n  generateAllTypeCheckBlocks() {\n    this.ensureAllShimsForAllFiles();\n  }\n\n  /**\n   * Retrieve type-checking and template parse diagnostics from the given `ts.SourceFile` using the\n   * most recent type-checking program.\n   */\n  getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[] {\n    switch (optimizeFor) {\n      case OptimizeFor.WholeProgram:\n        this.ensureAllShimsForAllFiles();\n        break;\n      case OptimizeFor.SingleFile:\n        this.ensureAllShimsForOneFile(sf);\n        break;\n    }\n\n    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n      const sfPath = absoluteFromSourceFile(sf);\n      const fileRecord = this.state.get(sfPath)!;\n\n      const typeCheckProgram = this.typeCheckingStrategy.getProgram();\n\n      const diagnostics: (ts.Diagnostic|null)[] = [];\n      if (fileRecord.hasInlines) {\n        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      }\n\n      for (const [shimPath, shimRecord] of fileRecord.shimData) {\n        const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n        diagnostics.push(...shimRecord.genesisDiagnostics);\n\n        for (const templateData of shimRecord.templates.values()) {\n          diagnostics.push(...templateData.templateDiagnostics);\n        }\n      }\n\n      return diagnostics.filter((diag: ts.Diagnostic|null): diag is ts.Diagnostic => diag !== null);\n    });\n  }\n\n  getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[] {\n    this.ensureShimForComponent(component);\n\n    return this.perf.inPhase(PerfPhase.TtcDiagnostics, () => {\n      const sf = component.getSourceFile();\n      const sfPath = absoluteFromSourceFile(sf);\n      const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n\n      const fileRecord = this.getFileData(sfPath);\n\n      if (!fileRecord.shimData.has(shimPath)) {\n        return [];\n      }\n\n      const templateId = fileRecord.sourceManager.getTemplateId(component);\n      const shimRecord = fileRecord.shimData.get(shimPath)!;\n\n      const typeCheckProgram = this.typeCheckingStrategy.getProgram();\n\n      const diagnostics: (TemplateDiagnostic|null)[] = [];\n      if (shimRecord.hasInlines) {\n        const inlineSf = getSourceFileOrError(typeCheckProgram, sfPath);\n        diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(inlineSf).map(\n            diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      }\n\n      const shimSf = getSourceFileOrError(typeCheckProgram, shimPath);\n      diagnostics.push(...typeCheckProgram.getSemanticDiagnostics(shimSf).map(\n          diag => convertDiagnostic(diag, fileRecord.sourceManager)));\n      diagnostics.push(...shimRecord.genesisDiagnostics);\n\n      for (const templateData of shimRecord.templates.values()) {\n        diagnostics.push(...templateData.templateDiagnostics);\n      }\n\n      return diagnostics.filter(\n          (diag: TemplateDiagnostic|null): diag is TemplateDiagnostic =>\n              diag !== null && diag.templateId === templateId);\n    });\n  }\n\n  getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null {\n    return this.getLatestComponentState(component).tcb;\n  }\n\n  getGlobalCompletions(\n      context: TmplAstTemplate|null, component: ts.ClassDeclaration,\n      node: AST|TmplAstNode): GlobalCompletion|null {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(\n        PerfPhase.TtcAutocompletion, () => engine.getGlobalCompletions(context, node));\n  }\n\n  getExpressionCompletionLocation(\n      ast: PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall,\n      component: ts.ClassDeclaration): ShimLocation|null {\n    const engine = this.getOrCreateCompletionEngine(component);\n    if (engine === null) {\n      return null;\n    }\n    return this.perf.inPhase(\n        PerfPhase.TtcAutocompletion, () => engine.getExpressionCompletionLocation(ast));\n  }\n\n  invalidateClass(clazz: ts.ClassDeclaration): void {\n    this.completionCache.delete(clazz);\n    this.symbolBuilderCache.delete(clazz);\n    this.scopeCache.delete(clazz);\n    this.elementTagCache.delete(clazz);\n\n    const sf = clazz.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n    const shimPath = this.typeCheckingStrategy.shimPathForComponent(clazz);\n    const fileData = this.getFileData(sfPath);\n    const templateId = fileData.sourceManager.getTemplateId(clazz);\n\n    fileData.shimData.delete(shimPath);\n    fileData.isComplete = false;\n\n    this.isComplete = false;\n  }\n\n  private getOrCreateCompletionEngine(component: ts.ClassDeclaration): CompletionEngine|null {\n    if (this.completionCache.has(component)) {\n      return this.completionCache.get(component)!;\n    }\n\n    const {tcb, data, shimPath} = this.getLatestComponentState(component);\n    if (tcb === null || data === null) {\n      return null;\n    }\n\n    const engine = new CompletionEngine(tcb, data, shimPath);\n    this.completionCache.set(component, engine);\n    return engine;\n  }\n\n  private maybeAdoptPriorResultsForFile(sf: ts.SourceFile): void {\n    const sfPath = absoluteFromSourceFile(sf);\n    if (this.state.has(sfPath)) {\n      const existingResults = this.state.get(sfPath)!;\n\n      if (existingResults.isComplete) {\n        // All data for this file has already been generated, so no need to adopt anything.\n        return;\n      }\n    }\n\n    const previousResults = this.priorBuild.priorTypeCheckingResultsFor(sf);\n    if (previousResults === null || !previousResults.isComplete) {\n      return;\n    }\n\n    this.perf.eventCount(PerfEvent.ReuseTypeCheckFile);\n    this.state.set(sfPath, previousResults);\n  }\n\n  private ensureAllShimsForAllFiles(): void {\n    if (this.isComplete) {\n      return;\n    }\n\n    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n      const host = new WholeProgramTypeCheckingHost(this);\n      const ctx = this.newContext(host);\n\n      for (const sf of this.originalProgram.getSourceFiles()) {\n        if (sf.isDeclarationFile || isShim(sf)) {\n          continue;\n        }\n\n        this.maybeAdoptPriorResultsForFile(sf);\n\n        const sfPath = absoluteFromSourceFile(sf);\n        const fileData = this.getFileData(sfPath);\n        if (fileData.isComplete) {\n          continue;\n        }\n\n        this.typeCheckAdapter.typeCheck(sf, ctx);\n\n        fileData.isComplete = true;\n      }\n\n      this.updateFromContext(ctx);\n      this.isComplete = true;\n    });\n  }\n\n  private ensureAllShimsForOneFile(sf: ts.SourceFile): void {\n    this.perf.inPhase(PerfPhase.TcbGeneration, () => {\n      this.maybeAdoptPriorResultsForFile(sf);\n\n      const sfPath = absoluteFromSourceFile(sf);\n\n      const fileData = this.getFileData(sfPath);\n      if (fileData.isComplete) {\n        // All data for this file is present and accounted for already.\n        return;\n      }\n\n      const host =\n          new SingleFileTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this);\n      const ctx = this.newContext(host);\n\n      this.typeCheckAdapter.typeCheck(sf, ctx);\n\n      fileData.isComplete = true;\n\n      this.updateFromContext(ctx);\n    });\n  }\n\n  private ensureShimForComponent(component: ts.ClassDeclaration): void {\n    const sf = component.getSourceFile();\n    const sfPath = absoluteFromSourceFile(sf);\n\n    this.maybeAdoptPriorResultsForFile(sf);\n\n    const fileData = this.getFileData(sfPath);\n    const shimPath = this.typeCheckingStrategy.shimPathForComponent(component);\n\n    if (fileData.shimData.has(shimPath)) {\n      // All data for this component is available.\n      return;\n    }\n\n    const host =\n        new SingleShimTypeCheckingHost(sfPath, fileData, this.typeCheckingStrategy, this, shimPath);\n    const ctx = this.newContext(host);\n\n    this.typeCheckAdapter.typeCheck(sf, ctx);\n    this.updateFromContext(ctx);\n  }\n\n  private newContext(host: TypeCheckingHost): TypeCheckContextImpl {\n    const inlining = this.typeCheckingStrategy.supportsInlineOperations ? InliningMode.InlineOps :\n                                                                          InliningMode.Error;\n    return new TypeCheckContextImpl(\n        this.config, this.compilerHost, this.typeCheckingStrategy, this.refEmitter, this.reflector,\n        host, inlining, this.perf);\n  }\n\n  /**\n   * Remove any shim data that depends on inline operations applied to the type-checking program.\n   *\n   * This can be useful if new inlines need to be applied, and it's not possible to guarantee that\n   * they won't overwrite or corrupt existing inlines that are used by such shims.\n   */\n  clearAllShimDataUsingInlines(): void {\n    for (const fileData of this.state.values()) {\n      if (!fileData.hasInlines) {\n        continue;\n      }\n\n      for (const [shimFile, shimData] of fileData.shimData.entries()) {\n        if (shimData.hasInlines) {\n          fileData.shimData.delete(shimFile);\n        }\n      }\n\n      fileData.hasInlines = false;\n      fileData.isComplete = false;\n      this.isComplete = false;\n    }\n  }\n\n  private updateFromContext(ctx: TypeCheckContextImpl): void {\n    const updates = ctx.finalize();\n    return this.perf.inPhase(PerfPhase.TcbUpdateProgram, () => {\n      if (updates.size > 0) {\n        this.perf.eventCount(PerfEvent.UpdateTypeCheckProgram);\n      }\n      this.typeCheckingStrategy.updateFiles(updates, UpdateMode.Incremental);\n      this.priorBuild.recordSuccessfulTypeCheck(this.state);\n      this.perf.memory(PerfCheckpoint.TtcUpdateProgram);\n    });\n  }\n\n  getFileData(path: AbsoluteFsPath): FileTypeCheckingData {\n    if (!this.state.has(path)) {\n      this.state.set(path, {\n        hasInlines: false,\n        sourceManager: new TemplateSourceManager(),\n        isComplete: false,\n        shimData: new Map(),\n      });\n    }\n    return this.state.get(path)!;\n  }\n  getSymbolOfNode(node: TmplAstTemplate, component: ts.ClassDeclaration): TemplateSymbol|null;\n  getSymbolOfNode(node: TmplAstElement, component: ts.ClassDeclaration): ElementSymbol|null;\n  getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclaration): Symbol|null {\n    const builder = this.getOrCreateSymbolBuilder(component);\n    if (builder === null) {\n      return null;\n    }\n    return this.perf.inPhase(PerfPhase.TtcSymbol, () => builder.getSymbol(node));\n  }\n\n  private getOrCreateSymbolBuilder(component: ts.ClassDeclaration): SymbolBuilder|null {\n    if (this.symbolBuilderCache.has(component)) {\n      return this.symbolBuilderCache.get(component)!;\n    }\n\n    const {tcb, data, shimPath} = this.getLatestComponentState(component);\n    if (tcb === null || data === null) {\n      return null;\n    }\n\n    const builder = new SymbolBuilder(\n        shimPath, tcb, data, this.componentScopeReader,\n        () => this.typeCheckingStrategy.getProgram().getTypeChecker());\n    this.symbolBuilderCache.set(component, builder);\n    return builder;\n  }\n\n  getDirectivesInScope(component: ts.ClassDeclaration): DirectiveInScope[]|null {\n    const data = this.getScopeData(component);\n    if (data === null) {\n      return null;\n    }\n    return data.directives;\n  }\n\n  getPipesInScope(component: ts.ClassDeclaration): PipeInScope[]|null {\n    const data = this.getScopeData(component);\n    if (data === null) {\n      return null;\n    }\n    return data.pipes;\n  }\n\n  getDirectiveMetadata(dir: ts.ClassDeclaration): TypeCheckableDirectiveMeta|null {\n    if (!isNamedClassDeclaration(dir)) {\n      return null;\n    }\n    return this.typeCheckScopeRegistry.getTypeCheckDirectiveMetadata(new Reference(dir));\n  }\n\n  getPotentialElementTags(component: ts.ClassDeclaration): Map<string, DirectiveInScope|null> {\n    if (this.elementTagCache.has(component)) {\n      return this.elementTagCache.get(component)!;\n    }\n\n    const tagMap = new Map<string, DirectiveInScope|null>();\n\n    for (const tag of REGISTRY.allKnownElementNames()) {\n      tagMap.set(tag, null);\n    }\n\n    const scope = this.getScopeData(component);\n    if (scope !== null) {\n      for (const directive of scope.directives) {\n        for (const selector of CssSelector.parse(directive.selector)) {\n          if (selector.element === null || tagMap.has(selector.element)) {\n            // Skip this directive if it doesn't match an element tag, or if another directive has\n            // already been included with the same element name.\n            continue;\n          }\n\n          tagMap.set(selector.element, directive);\n        }\n      }\n    }\n\n    this.elementTagCache.set(component, tagMap);\n    return tagMap;\n  }\n\n  getPotentialDomBindings(tagName: string): {attribute: string, property: string}[] {\n    const attributes = REGISTRY.allKnownAttributesOfElement(tagName);\n    return attributes.map(attribute => ({\n                            attribute,\n                            property: REGISTRY.getMappedPropName(attribute),\n                          }));\n  }\n\n  private getScopeData(component: ts.ClassDeclaration): ScopeData|null {\n    if (this.scopeCache.has(component)) {\n      return this.scopeCache.get(component)!;\n    }\n\n    if (!isNamedClassDeclaration(component)) {\n      throw new Error(`AssertionError: components must have names`);\n    }\n\n    const scope = this.componentScopeReader.getScopeForComponent(component);\n    if (scope === null) {\n      return null;\n    }\n\n    const data: ScopeData = {\n      directives: [],\n      pipes: [],\n      isPoisoned: scope.compilation.isPoisoned,\n    };\n\n    const typeChecker = this.typeCheckingStrategy.getProgram().getTypeChecker();\n    for (const dir of scope.compilation.directives) {\n      if (dir.selector === null) {\n        // Skip this directive, it can't be added to a template anyway.\n        continue;\n      }\n      const tsSymbol = typeChecker.getSymbolAtLocation(dir.ref.node.name);\n      if (tsSymbol === undefined) {\n        continue;\n      }\n\n      let ngModule: ClassDeclaration|null = null;\n      const moduleScopeOfDir = this.componentScopeReader.getScopeForComponent(dir.ref.node);\n      if (moduleScopeOfDir !== null) {\n        ngModule = moduleScopeOfDir.ngModule;\n      }\n\n      data.directives.push({\n        isComponent: dir.isComponent,\n        isStructural: dir.isStructural,\n        selector: dir.selector,\n        tsSymbol,\n        ngModule,\n      });\n    }\n\n    for (const pipe of scope.compilation.pipes) {\n      const tsSymbol = typeChecker.getSymbolAtLocation(pipe.ref.node.name);\n      if (tsSymbol === undefined) {\n        continue;\n      }\n      data.pipes.push({\n        name: pipe.name,\n        tsSymbol,\n      });\n    }\n\n    this.scopeCache.set(component, data);\n    return data;\n  }\n}\n\nfunction convertDiagnostic(\n    diag: ts.Diagnostic, sourceResolver: TemplateSourceResolver): TemplateDiagnostic|null {\n  if (!shouldReportDiagnostic(diag)) {\n    return null;\n  }\n  return translateDiagnostic(diag, sourceResolver);\n}\n\n/**\n * Data for template type-checking related to a specific input file in the user's program (which\n * contains components to be checked).\n */\nexport interface FileTypeCheckingData {\n  /**\n   * Whether the type-checking shim required any inline changes to the original file, which affects\n   * whether the shim can be reused.\n   */\n  hasInlines: boolean;\n\n  /**\n   * Source mapping information for mapping diagnostics from inlined type check blocks back to the\n   * original template.\n   */\n  sourceManager: TemplateSourceManager;\n\n  /**\n   * Data for each shim generated from this input file.\n   *\n   * A single input file will generate one or more shim files that actually contain template\n   * type-checking code.\n   */\n  shimData: Map<AbsoluteFsPath, ShimTypeCheckingData>;\n\n  /**\n   * Whether the template type-checker is certain that all components from this input file have had\n   * type-checking code generated into shims.\n   */\n  isComplete: boolean;\n}\n\n/**\n * Drives a `TypeCheckContext` to generate type-checking code for every component in the program.\n */\nclass WholeProgramTypeCheckingHost implements TypeCheckingHost {\n  constructor(private impl: TemplateTypeCheckerImpl) {}\n\n  getSourceManager(sfPath: AbsoluteFsPath): TemplateSourceManager {\n    return this.impl.getFileData(sfPath).sourceManager;\n  }\n\n  shouldCheckComponent(node: ts.ClassDeclaration): boolean {\n    const fileData = this.impl.getFileData(absoluteFromSourceFile(node.getSourceFile()));\n    const shimPath = this.impl.typeCheckingStrategy.shimPathForComponent(node);\n    // The component needs to be checked unless the shim which would contain it already exists.\n    return !fileData.shimData.has(shimPath);\n  }\n\n  recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n    const fileData = this.impl.getFileData(sfPath);\n    fileData.shimData.set(data.path, data);\n    if (data.hasInlines) {\n      fileData.hasInlines = true;\n    }\n  }\n\n  recordComplete(sfPath: AbsoluteFsPath): void {\n    this.impl.getFileData(sfPath).isComplete = true;\n  }\n}\n\n/**\n * Drives a `TypeCheckContext` to generate type-checking code efficiently for a single input file.\n */\nclass SingleFileTypeCheckingHost implements TypeCheckingHost {\n  private seenInlines = false;\n\n  constructor(\n      protected sfPath: AbsoluteFsPath, protected fileData: FileTypeCheckingData,\n      protected strategy: TypeCheckingProgramStrategy, protected impl: TemplateTypeCheckerImpl) {}\n\n  private assertPath(sfPath: AbsoluteFsPath): void {\n    if (this.sfPath !== sfPath) {\n      throw new Error(`AssertionError: querying TypeCheckingHost outside of assigned file`);\n    }\n  }\n\n  getSourceManager(sfPath: AbsoluteFsPath): TemplateSourceManager {\n    this.assertPath(sfPath);\n    return this.fileData.sourceManager;\n  }\n\n  shouldCheckComponent(node: ts.ClassDeclaration): boolean {\n    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n      return false;\n    }\n    const shimPath = this.strategy.shimPathForComponent(node);\n\n    // Only need to generate a TCB for the class if no shim exists for it currently.\n    return !this.fileData.shimData.has(shimPath);\n  }\n\n  recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void {\n    this.assertPath(sfPath);\n\n    // Previous type-checking state may have required the use of inlines (assuming they were\n    // supported). If the current operation also requires inlines, this presents a problem:\n    // generating new inlines may invalidate any old inlines that old state depends on.\n    //\n    // Rather than resolve this issue by tracking specific dependencies on inlines, if the new state\n    // relies on inlines, any old state that relied on them is simply cleared. This happens when the\n    // first new state that uses inlines is encountered.\n    if (data.hasInlines && !this.seenInlines) {\n      this.impl.clearAllShimDataUsingInlines();\n      this.seenInlines = true;\n    }\n\n    this.fileData.shimData.set(data.path, data);\n    if (data.hasInlines) {\n      this.fileData.hasInlines = true;\n    }\n  }\n\n  recordComplete(sfPath: AbsoluteFsPath): void {\n    this.assertPath(sfPath);\n    this.fileData.isComplete = true;\n  }\n}\n\n/**\n * Drives a `TypeCheckContext` to generate type-checking code efficiently for only those components\n * which map to a single shim of a single input file.\n */\nclass SingleShimTypeCheckingHost extends SingleFileTypeCheckingHost {\n  constructor(\n      sfPath: AbsoluteFsPath, fileData: FileTypeCheckingData, strategy: TypeCheckingProgramStrategy,\n      impl: TemplateTypeCheckerImpl, private shimPath: AbsoluteFsPath) {\n    super(sfPath, fileData, strategy, impl);\n  }\n\n  shouldCheckNode(node: ts.ClassDeclaration): boolean {\n    if (this.sfPath !== absoluteFromSourceFile(node.getSourceFile())) {\n      return false;\n    }\n\n    // Only generate a TCB for the component if it maps to the requested shim file.\n    const shimPath = this.strategy.shimPathForComponent(node);\n    if (shimPath !== this.shimPath) {\n      return false;\n    }\n\n    // Only need to generate a TCB for the class if no shim exists for it currently.\n    return !this.fileData.shimData.has(shimPath);\n  }\n}\n\n/**\n * Cached scope information for a component.\n */\ninterface ScopeData {\n  directives: DirectiveInScope[];\n  pipes: PipeInScope[];\n  isPoisoned: boolean;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}