{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/compiler\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/compiler_util/expression_converter\", \"@angular/compiler/src/core\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/selector\", \"@angular/compiler/src/shadow_css\", \"@angular/compiler/src/style_compiler\", \"@angular/compiler/src/util\", \"@angular/compiler/src/render3/r3_ast\", \"@angular/compiler/src/render3/r3_identifiers\", \"@angular/compiler/src/render3/util\", \"@angular/compiler/src/render3/view/styling_builder\", \"@angular/compiler/src/render3/view/template\", \"@angular/compiler/src/render3/view/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.verifyHostBindings = exports.parseHostBindings = exports.createDirectiveType = exports.createDirectiveTypeParams = exports.createComponentType = exports.compileComponentFromMetadata = exports.compileDirectiveFromMetadata = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var expression_converter_1 = require(\"@angular/compiler/src/compiler_util/expression_converter\");\n\n  var core = require(\"@angular/compiler/src/core\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var selector_1 = require(\"@angular/compiler/src/selector\");\n\n  var shadow_css_1 = require(\"@angular/compiler/src/shadow_css\");\n\n  var style_compiler_1 = require(\"@angular/compiler/src/style_compiler\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var r3_ast_1 = require(\"@angular/compiler/src/render3/r3_ast\");\n\n  var r3_identifiers_1 = require(\"@angular/compiler/src/render3/r3_identifiers\");\n\n  var util_2 = require(\"@angular/compiler/src/render3/util\");\n\n  var styling_builder_1 = require(\"@angular/compiler/src/render3/view/styling_builder\");\n\n  var template_1 = require(\"@angular/compiler/src/render3/view/template\");\n\n  var util_3 = require(\"@angular/compiler/src/render3/view/util\"); // This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n  // If there is a match, the first matching group will contain the attribute name to bind.\n\n\n  var ATTR_REGEX = /attr\\.([^\\]]+)/;\n\n  function baseDirectiveFields(meta, constantPool, bindingParser) {\n    var definitionMap = new util_3.DefinitionMap();\n    var selectors = core.parseSelectorToR3Selector(meta.selector); // e.g. `type: MyDirective`\n\n    definitionMap.set('type', meta.internalType); // e.g. `selectors: [['', 'someDir', '']]`\n\n    if (selectors.length > 0) {\n      definitionMap.set('selectors', util_3.asLiteral(selectors));\n    }\n\n    if (meta.queries.length > 0) {\n      // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n      definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n    }\n\n    if (meta.viewQueries.length) {\n      definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n    } // e.g. `hostBindings: (rf, ctx) => { ... }\n\n\n    definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap)); // e.g 'inputs: {a: 'a'}`\n\n    definitionMap.set('inputs', util_3.conditionallyCreateMapObjectLiteral(meta.inputs, true)); // e.g 'outputs: {a: 'a'}`\n\n    definitionMap.set('outputs', util_3.conditionallyCreateMapObjectLiteral(meta.outputs));\n\n    if (meta.exportAs !== null) {\n      definitionMap.set('exportAs', o.literalArr(meta.exportAs.map(function (e) {\n        return o.literal(e);\n      })));\n    }\n\n    return definitionMap;\n  }\n  /**\n   * Add features to the definition map.\n   */\n\n\n  function addFeatures(definitionMap, meta) {\n    // e.g. `features: [NgOnChangesFeature]`\n    var features = [];\n    var providers = meta.providers;\n    var viewProviders = meta.viewProviders;\n\n    if (providers || viewProviders) {\n      var args = [providers || new o.LiteralArrayExpr([])];\n\n      if (viewProviders) {\n        args.push(viewProviders);\n      }\n\n      features.push(o.importExpr(r3_identifiers_1.Identifiers.ProvidersFeature).callFn(args));\n    }\n\n    if (meta.usesInheritance) {\n      features.push(o.importExpr(r3_identifiers_1.Identifiers.InheritDefinitionFeature));\n    }\n\n    if (meta.fullInheritance) {\n      features.push(o.importExpr(r3_identifiers_1.Identifiers.CopyDefinitionFeature));\n    }\n\n    if (meta.lifecycle.usesOnChanges) {\n      features.push(o.importExpr(r3_identifiers_1.Identifiers.NgOnChangesFeature));\n    }\n\n    if (features.length) {\n      definitionMap.set('features', o.literalArr(features));\n    }\n  }\n  /**\n   * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n   */\n\n\n  function compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n    var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    var expression = o.importExpr(r3_identifiers_1.Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()]);\n    var type = createDirectiveType(meta);\n    return {\n      expression: expression,\n      type: type\n    };\n  }\n\n  exports.compileDirectiveFromMetadata = compileDirectiveFromMetadata;\n  /**\n   * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n   */\n\n  function compileComponentFromMetadata(meta, constantPool, bindingParser) {\n    var e_1, _a;\n\n    var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n    addFeatures(definitionMap, meta);\n    var selector = meta.selector && selector_1.CssSelector.parse(meta.selector);\n    var firstSelector = selector && selector[0]; // e.g. `attr: [\"class\", \".my.app\"]`\n    // This is optional an only included if the first selector of a component specifies attributes.\n\n    if (firstSelector) {\n      var selectorAttributes = firstSelector.getAttrs();\n\n      if (selectorAttributes.length) {\n        definitionMap.set('attrs', constantPool.getConstLiteral(o.literalArr(selectorAttributes.map(function (value) {\n          return value != null ? o.literal(value) : o.literal(undefined);\n        })),\n        /* forceShared */\n        true));\n      }\n    } // Generate the CSS matcher that recognize directive\n\n\n    var directiveMatcher = null;\n\n    if (meta.directives.length > 0) {\n      var matcher = new selector_1.SelectorMatcher();\n\n      try {\n        for (var _b = tslib_1.__values(meta.directives), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = _c.value,\n              selector_2 = _d.selector,\n              type_1 = _d.type;\n          matcher.addSelectables(selector_1.CssSelector.parse(selector_2), type_1);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      directiveMatcher = matcher;\n    } // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n\n\n    var templateTypeName = meta.name;\n    var templateName = templateTypeName ? templateTypeName + \"_Template\" : null;\n    var directivesUsed = new Set();\n    var pipesUsed = new Set();\n    var changeDetection = meta.changeDetection;\n    var template = meta.template;\n    var templateBuilder = new template_1.TemplateDefinitionBuilder(constantPool, template_1.BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, r3_identifiers_1.Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n    var templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []); // We need to provide this so that dynamically generated components know what\n    // projected content blocks to pass through to the component when it is instantiated.\n\n    var ngContentSelectors = templateBuilder.getNgContentSelectors();\n\n    if (ngContentSelectors) {\n      definitionMap.set('ngContentSelectors', ngContentSelectors);\n    } // e.g. `decls: 2`\n\n\n    definitionMap.set('decls', o.literal(templateBuilder.getConstCount())); // e.g. `vars: 2`\n\n    definitionMap.set('vars', o.literal(templateBuilder.getVarCount())); // Generate `consts` section of ComponentDef:\n    // - either as an array:\n    //   `consts: [['one', 'two'], ['three', 'four']]`\n    // - or as a factory function in case additional statements are present (to support i18n):\n    //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`\n\n    var _e = templateBuilder.getConsts(),\n        constExpressions = _e.constExpressions,\n        prepareStatements = _e.prepareStatements;\n\n    if (constExpressions.length > 0) {\n      var constsExpr = o.literalArr(constExpressions); // Prepare statements are present - turn `consts` into a function.\n\n      if (prepareStatements.length > 0) {\n        constsExpr = o.fn([], tslib_1.__spread(prepareStatements, [new o.ReturnStatement(constsExpr)]));\n      }\n\n      definitionMap.set('consts', constsExpr);\n    }\n\n    definitionMap.set('template', templateFunctionExpression); // e.g. `directives: [MyDirective]`\n\n    if (directivesUsed.size) {\n      var directivesList = o.literalArr(Array.from(directivesUsed));\n      var directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);\n      definitionMap.set('directives', directivesExpr);\n    } // e.g. `pipes: [MyPipe]`\n\n\n    if (pipesUsed.size) {\n      var pipesList = o.literalArr(Array.from(pipesUsed));\n      var pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);\n      definitionMap.set('pipes', pipesExpr);\n    }\n\n    if (meta.encapsulation === null) {\n      meta.encapsulation = core.ViewEncapsulation.Emulated;\n    } // e.g. `styles: [str1, str2]`\n\n\n    if (meta.styles && meta.styles.length) {\n      var styleValues = meta.encapsulation == core.ViewEncapsulation.Emulated ? compileStyles(meta.styles, style_compiler_1.CONTENT_ATTR, style_compiler_1.HOST_ATTR) : meta.styles;\n      var strings = styleValues.map(function (str) {\n        return constantPool.getConstLiteral(o.literal(str));\n      });\n      definitionMap.set('styles', o.literalArr(strings));\n    } else if (meta.encapsulation === core.ViewEncapsulation.Emulated) {\n      // If there is no style, don't generate css selectors on elements\n      meta.encapsulation = core.ViewEncapsulation.None;\n    } // Only set view encapsulation if it's not the default value\n\n\n    if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n      definitionMap.set('encapsulation', o.literal(meta.encapsulation));\n    } // e.g. `animation: [trigger('123', [])]`\n\n\n    if (meta.animations !== null) {\n      definitionMap.set('data', o.literalMap([{\n        key: 'animation',\n        value: meta.animations,\n        quoted: false\n      }]));\n    } // Only set the change detection flag if it's defined and it's not the default.\n\n\n    if (changeDetection != null && changeDetection !== core.ChangeDetectionStrategy.Default) {\n      definitionMap.set('changeDetection', o.literal(changeDetection));\n    }\n\n    var expression = o.importExpr(r3_identifiers_1.Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()]);\n    var type = createComponentType(meta);\n    return {\n      expression: expression,\n      type: type\n    };\n  }\n\n  exports.compileComponentFromMetadata = compileComponentFromMetadata;\n  /**\n   * Creates the type specification from the component meta. This type is inserted into .d.ts files\n   * to be consumed by upstream compilations.\n   */\n\n  function createComponentType(meta) {\n    var typeParams = createDirectiveTypeParams(meta);\n    typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n    return o.expressionType(o.importExpr(r3_identifiers_1.Identifiers.ComponentDefWithMeta, typeParams));\n  }\n\n  exports.createComponentType = createComponentType;\n  /**\n   * Compiles the array literal of declarations into an expression according to the provided emit\n   * mode.\n   */\n\n  function compileDeclarationList(list, mode) {\n    switch (mode) {\n      case 0\n      /* Direct */\n      :\n        // directives: [MyDir],\n        return list;\n\n      case 1\n      /* Closure */\n      :\n        // directives: function () { return [MyDir]; }\n        return o.fn([], [new o.ReturnStatement(list)]);\n\n      case 2\n      /* ClosureResolved */\n      :\n        // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n        var resolvedList = list.callMethod('map', [o.importExpr(r3_identifiers_1.Identifiers.resolveForwardRef)]);\n        return o.fn([], [new o.ReturnStatement(resolvedList)]);\n    }\n  }\n\n  function prepareQueryParams(query, constantPool) {\n    var parameters = [util_3.getQueryPredicate(query, constantPool), o.literal(toQueryFlags(query))];\n\n    if (query.read) {\n      parameters.push(query.read);\n    }\n\n    return parameters;\n  }\n  /**\n   * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\n   * @param query\n   */\n\n\n  function toQueryFlags(query) {\n    return (query.descendants ? 1\n    /* descendants */\n    : 0\n    /* none */\n    ) | (query.static ? 2\n    /* isStatic */\n    : 0\n    /* none */\n    ) | (query.emitDistinctChangesOnly ? 4\n    /* emitDistinctChangesOnly */\n    : 0\n    /* none */\n    );\n  }\n\n  function convertAttributesToExpressions(attributes) {\n    var e_2, _a;\n\n    var values = [];\n\n    try {\n      for (var _b = tslib_1.__values(Object.getOwnPropertyNames(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        var value = attributes[key];\n        values.push(o.literal(key), value);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return values;\n  } // Define and update any content queries\n\n\n  function createContentQueriesFunction(queries, constantPool, name) {\n    var e_3, _a;\n\n    var createStatements = [];\n    var updateStatements = [];\n    var tempAllocator = util_3.temporaryAllocator(updateStatements, util_3.TEMPORARY_NAME);\n\n    try {\n      for (var queries_1 = tslib_1.__values(queries), queries_1_1 = queries_1.next(); !queries_1_1.done; queries_1_1 = queries_1.next()) {\n        var query = queries_1_1.value; // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n\n        createStatements.push(o.importExpr(r3_identifiers_1.Identifiers.contentQuery).callFn(tslib_1.__spread([o.variable('dirIndex')], prepareQueryParams(query, constantPool))).toStmt()); // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n\n        var temporary = tempAllocator();\n        var getQueryList = o.importExpr(r3_identifiers_1.Identifiers.loadQuery).callFn([]);\n        var refresh = o.importExpr(r3_identifiers_1.Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n        var updateDirective = o.variable(util_3.CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n        updateStatements.push(refresh.and(updateDirective).toStmt());\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (queries_1_1 && !queries_1_1.done && (_a = queries_1.return)) _a.call(queries_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    var contentQueriesFnName = name ? name + \"_ContentQueries\" : null;\n    return o.fn([new o.FnParam(util_3.RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(util_3.CONTEXT_NAME, null), new o.FnParam('dirIndex', null)], [template_1.renderFlagCheckIfStmt(1\n    /* Create */\n    , createStatements), template_1.renderFlagCheckIfStmt(2\n    /* Update */\n    , updateStatements)], o.INFERRED_TYPE, null, contentQueriesFnName);\n  }\n\n  function stringAsType(str) {\n    return o.expressionType(o.literal(str));\n  }\n\n  function stringMapAsType(map) {\n    var mapValues = Object.keys(map).map(function (key) {\n      var value = Array.isArray(map[key]) ? map[key][0] : map[key];\n      return {\n        key: key,\n        value: o.literal(value),\n        quoted: true\n      };\n    });\n    return o.expressionType(o.literalMap(mapValues));\n  }\n\n  function stringArrayAsType(arr) {\n    return arr.length > 0 ? o.expressionType(o.literalArr(arr.map(function (value) {\n      return o.literal(value);\n    }))) : o.NONE_TYPE;\n  }\n\n  function createDirectiveTypeParams(meta) {\n    // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n    // string literal, which must be on one line.\n    var selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n    return [util_2.typeWithParameters(meta.type.type, meta.typeArgumentCount), selectorForType !== null ? stringAsType(selectorForType) : o.NONE_TYPE, meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : o.NONE_TYPE, stringMapAsType(meta.inputs), stringMapAsType(meta.outputs), stringArrayAsType(meta.queries.map(function (q) {\n      return q.propertyName;\n    }))];\n  }\n\n  exports.createDirectiveTypeParams = createDirectiveTypeParams;\n  /**\n   * Creates the type specification from the directive meta. This type is inserted into .d.ts files\n   * to be consumed by upstream compilations.\n   */\n\n  function createDirectiveType(meta) {\n    var typeParams = createDirectiveTypeParams(meta);\n    return o.expressionType(o.importExpr(r3_identifiers_1.Identifiers.DirectiveDefWithMeta, typeParams));\n  }\n\n  exports.createDirectiveType = createDirectiveType; // Define and update any view queries\n\n  function createViewQueriesFunction(viewQueries, constantPool, name) {\n    var createStatements = [];\n    var updateStatements = [];\n    var tempAllocator = util_3.temporaryAllocator(updateStatements, util_3.TEMPORARY_NAME);\n    viewQueries.forEach(function (query) {\n      // creation, e.g. r3.viewQuery(somePredicate, true);\n      var queryDefinition = o.importExpr(r3_identifiers_1.Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));\n      createStatements.push(queryDefinition.toStmt()); // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n\n      var temporary = tempAllocator();\n      var getQueryList = o.importExpr(r3_identifiers_1.Identifiers.loadQuery).callFn([]);\n      var refresh = o.importExpr(r3_identifiers_1.Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n      var updateDirective = o.variable(util_3.CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n      updateStatements.push(refresh.and(updateDirective).toStmt());\n    });\n    var viewQueryFnName = name ? name + \"_Query\" : null;\n    return o.fn([new o.FnParam(util_3.RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(util_3.CONTEXT_NAME, null)], [template_1.renderFlagCheckIfStmt(1\n    /* Create */\n    , createStatements), template_1.renderFlagCheckIfStmt(2\n    /* Update */\n    , updateStatements)], o.INFERRED_TYPE, null, viewQueryFnName);\n  } // Return a host binding function or null if one is not necessary.\n\n\n  function createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n    var bindingContext = o.variable(util_3.CONTEXT_NAME);\n    var styleBuilder = new styling_builder_1.StylingBuilder(bindingContext);\n    var _a = hostBindingsMetadata.specialAttributes,\n        styleAttr = _a.styleAttr,\n        classAttr = _a.classAttr;\n\n    if (styleAttr !== undefined) {\n      styleBuilder.registerStyleAttr(styleAttr);\n    }\n\n    if (classAttr !== undefined) {\n      styleBuilder.registerClassAttr(classAttr);\n    }\n\n    var createStatements = [];\n    var updateStatements = [];\n    var hostBindingSourceSpan = typeSourceSpan;\n    var directiveSummary = metadataAsSummary(hostBindingsMetadata); // Calculate host event bindings\n\n    var eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);\n\n    if (eventBindings && eventBindings.length) {\n      var listeners = createHostListeners(eventBindings, name);\n      createStatements.push.apply(createStatements, tslib_1.__spread(listeners));\n    } // Calculate the host property bindings\n\n\n    var bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);\n    var allOtherBindings = []; // We need to calculate the total amount of binding slots required by\n    // all the instructions together before any value conversions happen.\n    // Value conversions may require additional slots for interpolation and\n    // bindings with pipes. These calculates happen after this block.\n\n    var totalHostVarsCount = 0;\n    bindings && bindings.forEach(function (binding) {\n      var stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);\n\n      if (stylingInputWasSet) {\n        totalHostVarsCount += styling_builder_1.MIN_STYLING_BINDING_SLOTS_REQUIRED;\n      } else {\n        allOtherBindings.push(binding);\n        totalHostVarsCount++;\n      }\n    });\n    var valueConverter;\n\n    var getValueConverter = function getValueConverter() {\n      if (!valueConverter) {\n        var hostVarsCountFn = function hostVarsCountFn(numSlots) {\n          var originalVarsCount = totalHostVarsCount;\n          totalHostVarsCount += numSlots;\n          return originalVarsCount;\n        };\n\n        valueConverter = new template_1.ValueConverter(constantPool, function () {\n          return util_1.error('Unexpected node');\n        }, // new nodes are illegal here\n        hostVarsCountFn, function () {\n          return util_1.error('Unexpected pipe');\n        }); // pipes are illegal here\n      }\n\n      return valueConverter;\n    };\n\n    var propertyBindings = [];\n    var attributeBindings = [];\n    var syntheticHostBindings = [];\n    allOtherBindings.forEach(function (binding) {\n      // resolve literal arrays and literal objects\n      var value = binding.expression.visit(getValueConverter());\n      var bindingExpr = bindingFn(bindingContext, value);\n\n      var _a = getBindingNameAndInstruction(binding),\n          bindingName = _a.bindingName,\n          instruction = _a.instruction,\n          isAttribute = _a.isAttribute;\n\n      var securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute).filter(function (context) {\n        return context !== core.SecurityContext.NONE;\n      });\n      var sanitizerFn = null;\n\n      if (securityContexts.length) {\n        if (securityContexts.length === 2 && securityContexts.indexOf(core.SecurityContext.URL) > -1 && securityContexts.indexOf(core.SecurityContext.RESOURCE_URL) > -1) {\n          // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n          // of different security contexts. In this case we use special santitization function and\n          // select the actual sanitizer at runtime based on a tag name that is provided while\n          // invoking sanitization function.\n          sanitizerFn = o.importExpr(r3_identifiers_1.Identifiers.sanitizeUrlOrResourceUrl);\n        } else {\n          sanitizerFn = template_1.resolveSanitizationFn(securityContexts[0], isAttribute);\n        }\n      }\n\n      var instructionParams = [o.literal(bindingName), bindingExpr.currValExpr];\n\n      if (sanitizerFn) {\n        instructionParams.push(sanitizerFn);\n      }\n\n      updateStatements.push.apply(updateStatements, tslib_1.__spread(bindingExpr.stmts));\n\n      if (instruction === r3_identifiers_1.Identifiers.hostProperty) {\n        propertyBindings.push(instructionParams);\n      } else if (instruction === r3_identifiers_1.Identifiers.attribute) {\n        attributeBindings.push(instructionParams);\n      } else if (instruction === r3_identifiers_1.Identifiers.syntheticHostProperty) {\n        syntheticHostBindings.push(instructionParams);\n      } else {\n        updateStatements.push(o.importExpr(instruction).callFn(instructionParams).toStmt());\n      }\n    });\n\n    if (propertyBindings.length > 0) {\n      updateStatements.push(util_3.chainedInstruction(r3_identifiers_1.Identifiers.hostProperty, propertyBindings).toStmt());\n    }\n\n    if (attributeBindings.length > 0) {\n      updateStatements.push(util_3.chainedInstruction(r3_identifiers_1.Identifiers.attribute, attributeBindings).toStmt());\n    }\n\n    if (syntheticHostBindings.length > 0) {\n      updateStatements.push(util_3.chainedInstruction(r3_identifiers_1.Identifiers.syntheticHostProperty, syntheticHostBindings).toStmt());\n    } // since we're dealing with directives/components and both have hostBinding\n    // functions, we need to generate a special hostAttrs instruction that deals\n    // with both the assignment of styling as well as static attributes to the host\n    // element. The instruction below will instruct all initial styling (styling\n    // that is inside of a host binding within a directive/component) to be attached\n    // to the host element alongside any of the provided host attributes that were\n    // collected earlier.\n\n\n    var hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n    styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n\n    if (styleBuilder.hasBindings) {\n      // finally each binding that was registered in the statement above will need to be added to\n      // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n      // are evaluated and updated for the element.\n      styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(function (instruction) {\n        if (instruction.calls.length > 0) {\n          var calls_1 = [];\n          instruction.calls.forEach(function (call) {\n            // we subtract a value of `1` here because the binding slot was already allocated\n            // at the top of this method when all the input bindings were counted.\n            totalHostVarsCount += Math.max(call.allocateBindingSlots - styling_builder_1.MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n            calls_1.push(convertStylingCall(call, bindingContext, bindingFn));\n          });\n          updateStatements.push(util_3.chainedInstruction(instruction.reference, calls_1).toStmt());\n        }\n      });\n    }\n\n    if (totalHostVarsCount) {\n      definitionMap.set('hostVars', o.literal(totalHostVarsCount));\n    }\n\n    if (createStatements.length > 0 || updateStatements.length > 0) {\n      var hostBindingsFnName = name ? name + \"_HostBindings\" : null;\n      var statements = [];\n\n      if (createStatements.length > 0) {\n        statements.push(template_1.renderFlagCheckIfStmt(1\n        /* Create */\n        , createStatements));\n      }\n\n      if (updateStatements.length > 0) {\n        statements.push(template_1.renderFlagCheckIfStmt(2\n        /* Update */\n        , updateStatements));\n      }\n\n      return o.fn([new o.FnParam(util_3.RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(util_3.CONTEXT_NAME, null)], statements, o.INFERRED_TYPE, null, hostBindingsFnName);\n    }\n\n    return null;\n  }\n\n  function bindingFn(implicit, value) {\n    return expression_converter_1.convertPropertyBinding(null, implicit, value, 'b', expression_converter_1.BindingForm.Expression, function () {\n      return util_1.error('Unexpected interpolation');\n    });\n  }\n\n  function convertStylingCall(call, bindingContext, bindingFn) {\n    return call.params(function (value) {\n      return bindingFn(bindingContext, value).currValExpr;\n    });\n  }\n\n  function getBindingNameAndInstruction(binding) {\n    var bindingName = binding.name;\n    var instruction; // Check to see if this is an attr binding or a property binding\n\n    var attrMatches = bindingName.match(ATTR_REGEX);\n\n    if (attrMatches) {\n      bindingName = attrMatches[1];\n      instruction = r3_identifiers_1.Identifiers.attribute;\n    } else {\n      if (binding.isAnimation) {\n        bindingName = util_2.prepareSyntheticPropertyName(bindingName); // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n        // in the context of the component and not the parent. Therefore there is a special\n        // compatibility instruction available for this purpose.\n\n        instruction = r3_identifiers_1.Identifiers.syntheticHostProperty;\n      } else {\n        instruction = r3_identifiers_1.Identifiers.hostProperty;\n      }\n    }\n\n    return {\n      bindingName: bindingName,\n      instruction: instruction,\n      isAttribute: !!attrMatches\n    };\n  }\n\n  function createHostListeners(eventBindings, name) {\n    var listeners = [];\n    var syntheticListeners = [];\n    var instructions = [];\n    eventBindings.forEach(function (binding) {\n      var bindingName = binding.name && compile_metadata_1.sanitizeIdentifier(binding.name);\n      var bindingFnName = binding.type === 1\n      /* Animation */\n      ? util_2.prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) : bindingName;\n      var handlerName = name && bindingName ? name + \"_\" + bindingFnName + \"_HostBindingHandler\" : null;\n      var params = template_1.prepareEventListenerParameters(r3_ast_1.BoundEvent.fromParsedEvent(binding), handlerName);\n\n      if (binding.type == 1\n      /* Animation */\n      ) {\n          syntheticListeners.push(params);\n        } else {\n        listeners.push(params);\n      }\n    });\n\n    if (syntheticListeners.length > 0) {\n      instructions.push(util_3.chainedInstruction(r3_identifiers_1.Identifiers.syntheticHostListener, syntheticListeners).toStmt());\n    }\n\n    if (listeners.length > 0) {\n      instructions.push(util_3.chainedInstruction(r3_identifiers_1.Identifiers.listener, listeners).toStmt());\n    }\n\n    return instructions;\n  }\n\n  function metadataAsSummary(meta) {\n    // clang-format off\n    return {\n      // This is used by the BindingParser, which only deals with listeners and properties. There's no\n      // need to pass attributes to it.\n      hostAttributes: {},\n      hostListeners: meta.listeners,\n      hostProperties: meta.properties\n    }; // clang-format on\n  }\n\n  var HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\n\n  function parseHostBindings(host) {\n    var e_4, _a;\n\n    var attributes = {};\n    var listeners = {};\n    var properties = {};\n    var specialAttributes = {};\n\n    try {\n      for (var _b = tslib_1.__values(Object.keys(host)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        var value = host[key];\n        var matches = key.match(HOST_REG_EXP);\n\n        if (matches === null) {\n          switch (key) {\n            case 'class':\n              if (typeof value !== 'string') {\n                // TODO(alxhub): make this a diagnostic.\n                throw new Error(\"Class binding must be string\");\n              }\n\n              specialAttributes.classAttr = value;\n              break;\n\n            case 'style':\n              if (typeof value !== 'string') {\n                // TODO(alxhub): make this a diagnostic.\n                throw new Error(\"Style binding must be string\");\n              }\n\n              specialAttributes.styleAttr = value;\n              break;\n\n            default:\n              if (typeof value === 'string') {\n                attributes[key] = o.literal(value);\n              } else {\n                attributes[key] = value;\n              }\n\n          }\n        } else if (matches[1\n        /* Binding */\n        ] != null) {\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(\"Property binding must be string\");\n          } // synthetic properties (the ones that have a `@` as a prefix)\n          // are still treated the same as regular properties. Therefore\n          // there is no point in storing them in a separate map.\n\n\n          properties[matches[1\n          /* Binding */\n          ]] = value;\n        } else if (matches[2\n        /* Event */\n        ] != null) {\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(\"Event binding must be string\");\n          }\n\n          listeners[matches[2\n          /* Event */\n          ]] = value;\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    return {\n      attributes: attributes,\n      listeners: listeners,\n      properties: properties,\n      specialAttributes: specialAttributes\n    };\n  }\n\n  exports.parseHostBindings = parseHostBindings;\n  /**\n   * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n   * given set of host bindings has no errors.\n   *\n   * @param bindings set of host bindings to verify.\n   * @param sourceSpan source span where host bindings were defined.\n   * @returns array of errors associated with a given set of host bindings.\n   */\n\n  function verifyHostBindings(bindings, sourceSpan) {\n    var summary = metadataAsSummary(bindings); // TODO: abstract out host bindings verification logic and use it instead of\n    // creating events and properties ASTs to detect errors (FW-996)\n\n    var bindingParser = template_1.makeBindingParser();\n    bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);\n    bindingParser.createBoundHostProperties(summary, sourceSpan);\n    return bindingParser.errors;\n  }\n\n  exports.verifyHostBindings = verifyHostBindings;\n\n  function compileStyles(styles, selector, hostSelector) {\n    var shadowCss = new shadow_css_1.ShadowCss();\n    return styles.map(function (style) {\n      return shadowCss.shimCssText(style, selector, hostSelector);\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/view/compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveSummary, sanitizeIdentifier} from '../../compile_metadata';\nimport {BindingForm, convertPropertyBinding} from '../../compiler_util/expression_converter';\nimport {ConstantPool} from '../../constant_pool';\nimport * as core from '../../core';\nimport {AST, ParsedEvent, ParsedEventType, ParsedProperty} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseError, ParseSourceSpan} from '../../parse_util';\nimport {CssSelector, SelectorMatcher} from '../../selector';\nimport {ShadowCss} from '../../shadow_css';\nimport {CONTENT_ATTR, HOST_ATTR} from '../../style_compiler';\nimport {BindingParser} from '../../template_parser/binding_parser';\nimport {error} from '../../util';\nimport {BoundEvent} from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {prepareSyntheticListenerFunctionName, prepareSyntheticPropertyName, typeWithParameters} from '../util';\n\nimport {DeclarationListEmitMode, R3ComponentDef, R3ComponentMetadata, R3DirectiveDef, R3DirectiveMetadata, R3HostMetadata, R3QueryMetadata} from './api';\nimport {MIN_STYLING_BINDING_SLOTS_REQUIRED, StylingBuilder, StylingInstructionCall} from './styling_builder';\nimport {BindingScope, makeBindingParser, prepareEventListenerParameters, renderFlagCheckIfStmt, resolveSanitizationFn, TemplateDefinitionBuilder, ValueConverter} from './template';\nimport {asLiteral, chainedInstruction, conditionallyCreateMapObjectLiteral, CONTEXT_NAME, DefinitionMap, getQueryPredicate, RENDER_FLAGS, TEMPORARY_NAME, temporaryAllocator} from './util';\n\n\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\nconst ATTR_REGEX = /attr\\.([^\\]]+)/;\n\nfunction baseDirectiveFields(\n    meta: R3DirectiveMetadata, constantPool: ConstantPool,\n    bindingParser: BindingParser): DefinitionMap {\n  const definitionMap = new DefinitionMap();\n  const selectors = core.parseSelectorToR3Selector(meta.selector);\n\n  // e.g. `type: MyDirective`\n  definitionMap.set('type', meta.internalType);\n\n  // e.g. `selectors: [['', 'someDir', '']]`\n  if (selectors.length > 0) {\n    definitionMap.set('selectors', asLiteral(selectors));\n  }\n\n  if (meta.queries.length > 0) {\n    // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n    definitionMap.set(\n        'contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n  }\n\n  if (meta.viewQueries.length) {\n    definitionMap.set(\n        'viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n  }\n\n  // e.g. `hostBindings: (rf, ctx) => { ... }\n  definitionMap.set(\n      'hostBindings',\n      createHostBindingsFunction(\n          meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '',\n          meta.name, definitionMap));\n\n  // e.g 'inputs: {a: 'a'}`\n  definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n\n  // e.g 'outputs: {a: 'a'}`\n  definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', o.literalArr(meta.exportAs.map(e => o.literal(e))));\n  }\n\n  return definitionMap;\n}\n\n/**\n * Add features to the definition map.\n */\nfunction addFeatures(definitionMap: DefinitionMap, meta: R3DirectiveMetadata|R3ComponentMetadata) {\n  // e.g. `features: [NgOnChangesFeature]`\n  const features: o.Expression[] = [];\n\n  const providers = meta.providers;\n  const viewProviders = (meta as R3ComponentMetadata).viewProviders;\n  if (providers || viewProviders) {\n    const args = [providers || new o.LiteralArrayExpr([])];\n    if (viewProviders) {\n      args.push(viewProviders);\n    }\n    features.push(o.importExpr(R3.ProvidersFeature).callFn(args));\n  }\n\n  if (meta.usesInheritance) {\n    features.push(o.importExpr(R3.InheritDefinitionFeature));\n  }\n  if (meta.fullInheritance) {\n    features.push(o.importExpr(R3.CopyDefinitionFeature));\n  }\n  if (meta.lifecycle.usesOnChanges) {\n    features.push(o.importExpr(R3.NgOnChangesFeature));\n  }\n  if (features.length) {\n    definitionMap.set('features', o.literalArr(features));\n  }\n}\n\n/**\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\n */\nexport function compileDirectiveFromMetadata(\n    meta: R3DirectiveMetadata, constantPool: ConstantPool,\n    bindingParser: BindingParser): R3DirectiveDef {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  const expression = o.importExpr(R3.defineDirective).callFn([definitionMap.toLiteralMap()]);\n  const type = createDirectiveType(meta);\n\n  return {expression, type};\n}\n\n/**\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\n */\nexport function compileComponentFromMetadata(\n    meta: R3ComponentMetadata, constantPool: ConstantPool,\n    bindingParser: BindingParser): R3ComponentDef {\n  const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n\n  const selector = meta.selector && CssSelector.parse(meta.selector);\n  const firstSelector = selector && selector[0];\n\n  // e.g. `attr: [\"class\", \".my.app\"]`\n  // This is optional an only included if the first selector of a component specifies attributes.\n  if (firstSelector) {\n    const selectorAttributes = firstSelector.getAttrs();\n    if (selectorAttributes.length) {\n      definitionMap.set(\n          'attrs',\n          constantPool.getConstLiteral(\n              o.literalArr(selectorAttributes.map(\n                  value => value != null ? o.literal(value) : o.literal(undefined))),\n              /* forceShared */ true));\n    }\n  }\n\n  // Generate the CSS matcher that recognize directive\n  let directiveMatcher: SelectorMatcher|null = null;\n\n  if (meta.directives.length > 0) {\n    const matcher = new SelectorMatcher();\n    for (const {selector, type} of meta.directives) {\n      matcher.addSelectables(CssSelector.parse(selector), type);\n    }\n    directiveMatcher = matcher;\n  }\n\n  // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n  const templateTypeName = meta.name;\n  const templateName = templateTypeName ? `${templateTypeName}_Template` : null;\n\n  const directivesUsed = new Set<o.Expression>();\n  const pipesUsed = new Set<o.Expression>();\n  const changeDetection = meta.changeDetection;\n\n  const template = meta.template;\n  const templateBuilder = new TemplateDefinitionBuilder(\n      constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName,\n      directiveMatcher, directivesUsed, meta.pipes, pipesUsed, R3.namespaceHTML,\n      meta.relativeContextFilePath, meta.i18nUseExternalIds);\n\n  const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\n\n  // We need to provide this so that dynamically generated components know what\n  // projected content blocks to pass through to the component when it is instantiated.\n  const ngContentSelectors = templateBuilder.getNgContentSelectors();\n  if (ngContentSelectors) {\n    definitionMap.set('ngContentSelectors', ngContentSelectors);\n  }\n\n  // e.g. `decls: 2`\n  definitionMap.set('decls', o.literal(templateBuilder.getConstCount()));\n\n  // e.g. `vars: 2`\n  definitionMap.set('vars', o.literal(templateBuilder.getVarCount()));\n\n  // Generate `consts` section of ComponentDef:\n  // - either as an array:\n  //   `consts: [['one', 'two'], ['three', 'four']]`\n  // - or as a factory function in case additional statements are present (to support i18n):\n  //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`\n  const {constExpressions, prepareStatements} = templateBuilder.getConsts();\n  if (constExpressions.length > 0) {\n    let constsExpr: o.LiteralArrayExpr|o.FunctionExpr = o.literalArr(constExpressions);\n    // Prepare statements are present - turn `consts` into a function.\n    if (prepareStatements.length > 0) {\n      constsExpr = o.fn([], [...prepareStatements, new o.ReturnStatement(constsExpr)]);\n    }\n    definitionMap.set('consts', constsExpr);\n  }\n\n  definitionMap.set('template', templateFunctionExpression);\n\n  // e.g. `directives: [MyDirective]`\n  if (directivesUsed.size) {\n    const directivesList = o.literalArr(Array.from(directivesUsed));\n    const directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);\n    definitionMap.set('directives', directivesExpr);\n  }\n\n  // e.g. `pipes: [MyPipe]`\n  if (pipesUsed.size) {\n    const pipesList = o.literalArr(Array.from(pipesUsed));\n    const pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);\n    definitionMap.set('pipes', pipesExpr);\n  }\n\n  if (meta.encapsulation === null) {\n    meta.encapsulation = core.ViewEncapsulation.Emulated;\n  }\n\n  // e.g. `styles: [str1, str2]`\n  if (meta.styles && meta.styles.length) {\n    const styleValues = meta.encapsulation == core.ViewEncapsulation.Emulated ?\n        compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\n        meta.styles;\n    const strings = styleValues.map(str => constantPool.getConstLiteral(o.literal(str)));\n    definitionMap.set('styles', o.literalArr(strings));\n  } else if (meta.encapsulation === core.ViewEncapsulation.Emulated) {\n    // If there is no style, don't generate css selectors on elements\n    meta.encapsulation = core.ViewEncapsulation.None;\n  }\n\n  // Only set view encapsulation if it's not the default value\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set('encapsulation', o.literal(meta.encapsulation));\n  }\n\n  // e.g. `animation: [trigger('123', [])]`\n  if (meta.animations !== null) {\n    definitionMap.set(\n        'data', o.literalMap([{key: 'animation', value: meta.animations, quoted: false}]));\n  }\n\n  // Only set the change detection flag if it's defined and it's not the default.\n  if (changeDetection != null && changeDetection !== core.ChangeDetectionStrategy.Default) {\n    definitionMap.set('changeDetection', o.literal(changeDetection));\n  }\n\n  const expression = o.importExpr(R3.defineComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n\n  return {expression, type};\n}\n\n/**\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nexport function createComponentType(meta: R3ComponentMetadata): o.Type {\n  const typeParams = createDirectiveTypeParams(meta);\n  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n  return o.expressionType(o.importExpr(R3.ComponentDefWithMeta, typeParams));\n}\n\n/**\n * Compiles the array literal of declarations into an expression according to the provided emit\n * mode.\n */\nfunction compileDeclarationList(\n    list: o.LiteralArrayExpr, mode: DeclarationListEmitMode): o.Expression {\n  switch (mode) {\n    case DeclarationListEmitMode.Direct:\n      // directives: [MyDir],\n      return list;\n    case DeclarationListEmitMode.Closure:\n      // directives: function () { return [MyDir]; }\n      return o.fn([], [new o.ReturnStatement(list)]);\n    case DeclarationListEmitMode.ClosureResolved:\n      // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n      const resolvedList = list.callMethod('map', [o.importExpr(R3.resolveForwardRef)]);\n      return o.fn([], [new o.ReturnStatement(resolvedList)]);\n  }\n}\n\nfunction prepareQueryParams(query: R3QueryMetadata, constantPool: ConstantPool): o.Expression[] {\n  const parameters = [getQueryPredicate(query, constantPool), o.literal(toQueryFlags(query))];\n  if (query.read) {\n    parameters.push(query.read);\n  }\n  return parameters;\n}\n\n/**\n * A set of flags to be used with Queries.\n *\n * NOTE: Ensure changes here are in sync with `packages/core/src/render3/interfaces/query.ts`\n */\nexport const enum QueryFlags {\n  /**\n   * No flags\n   */\n  none = 0b0000,\n\n  /**\n   * Whether or not the query should descend into children.\n   */\n  descendants = 0b0001,\n\n  /**\n   * The query can be computed statically and hence can be assigned eagerly.\n   *\n   * NOTE: Backwards compatibility with ViewEngine.\n   */\n  isStatic = 0b0010,\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly = 0b0100,\n}\n\n/**\n * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\n * @param query\n */\nfunction toQueryFlags(query: R3QueryMetadata): number {\n  return (query.descendants ? QueryFlags.descendants : QueryFlags.none) |\n      (query.static ? QueryFlags.isStatic : QueryFlags.none) |\n      (query.emitDistinctChangesOnly ? QueryFlags.emitDistinctChangesOnly : QueryFlags.none);\n}\n\nfunction convertAttributesToExpressions(attributes: {[name: string]: o.Expression}):\n    o.Expression[] {\n  const values: o.Expression[] = [];\n  for (let key of Object.getOwnPropertyNames(attributes)) {\n    const value = attributes[key];\n    values.push(o.literal(key), value);\n  }\n  return values;\n}\n\n// Define and update any content queries\nfunction createContentQueriesFunction(\n    queries: R3QueryMetadata[], constantPool: ConstantPool, name?: string): o.Expression {\n  const createStatements: o.Statement[] = [];\n  const updateStatements: o.Statement[] = [];\n  const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n\n  for (const query of queries) {\n    // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n    createStatements.push(\n        o.importExpr(R3.contentQuery)\n            .callFn([o.variable('dirIndex'), ...prepareQueryParams(query, constantPool) as any])\n            .toStmt());\n\n    // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n    const temporary = tempAllocator();\n    const getQueryList = o.importExpr(R3.loadQuery).callFn([]);\n    const refresh = o.importExpr(R3.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = o.variable(CONTEXT_NAME)\n                                .prop(query.propertyName)\n                                .set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  }\n\n  const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\n  return o.fn(\n      [\n        new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null),\n        new o.FnParam('dirIndex', null)\n      ],\n      [\n        renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements),\n        renderFlagCheckIfStmt(core.RenderFlags.Update, updateStatements)\n      ],\n      o.INFERRED_TYPE, null, contentQueriesFnName);\n}\n\nfunction stringAsType(str: string): o.Type {\n  return o.expressionType(o.literal(str));\n}\n\nfunction stringMapAsType(map: {[key: string]: string|string[]}): o.Type {\n  const mapValues = Object.keys(map).map(key => {\n    const value = Array.isArray(map[key]) ? map[key][0] : map[key];\n    return {\n      key,\n      value: o.literal(value),\n      quoted: true,\n    };\n  });\n  return o.expressionType(o.literalMap(mapValues));\n}\n\nfunction stringArrayAsType(arr: ReadonlyArray<string|null>): o.Type {\n  return arr.length > 0 ? o.expressionType(o.literalArr(arr.map(value => o.literal(value)))) :\n                          o.NONE_TYPE;\n}\n\nexport function createDirectiveTypeParams(meta: R3DirectiveMetadata): o.Type[] {\n  // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n  // string literal, which must be on one line.\n  const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n\n  return [\n    typeWithParameters(meta.type.type, meta.typeArgumentCount),\n    selectorForType !== null ? stringAsType(selectorForType) : o.NONE_TYPE,\n    meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : o.NONE_TYPE,\n    stringMapAsType(meta.inputs),\n    stringMapAsType(meta.outputs),\n    stringArrayAsType(meta.queries.map(q => q.propertyName)),\n  ];\n}\n\n/**\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\n * to be consumed by upstream compilations.\n */\nexport function createDirectiveType(meta: R3DirectiveMetadata): o.Type {\n  const typeParams = createDirectiveTypeParams(meta);\n  return o.expressionType(o.importExpr(R3.DirectiveDefWithMeta, typeParams));\n}\n\n// Define and update any view queries\nfunction createViewQueriesFunction(\n    viewQueries: R3QueryMetadata[], constantPool: ConstantPool, name?: string): o.Expression {\n  const createStatements: o.Statement[] = [];\n  const updateStatements: o.Statement[] = [];\n  const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n\n  viewQueries.forEach((query: R3QueryMetadata) => {\n    // creation, e.g. r3.viewQuery(somePredicate, true);\n    const queryDefinition =\n        o.importExpr(R3.viewQuery).callFn(prepareQueryParams(query, constantPool));\n    createStatements.push(queryDefinition.toStmt());\n\n    // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n    const temporary = tempAllocator();\n    const getQueryList = o.importExpr(R3.loadQuery).callFn([]);\n    const refresh = o.importExpr(R3.queryRefresh).callFn([temporary.set(getQueryList)]);\n    const updateDirective = o.variable(CONTEXT_NAME)\n                                .prop(query.propertyName)\n                                .set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  });\n\n  const viewQueryFnName = name ? `${name}_Query` : null;\n  return o.fn(\n      [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)],\n      [\n        renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements),\n        renderFlagCheckIfStmt(core.RenderFlags.Update, updateStatements)\n      ],\n      o.INFERRED_TYPE, null, viewQueryFnName);\n}\n\n// Return a host binding function or null if one is not necessary.\nfunction createHostBindingsFunction(\n    hostBindingsMetadata: R3HostMetadata, typeSourceSpan: ParseSourceSpan,\n    bindingParser: BindingParser, constantPool: ConstantPool, selector: string, name: string,\n    definitionMap: DefinitionMap): o.Expression|null {\n  const bindingContext = o.variable(CONTEXT_NAME);\n  const styleBuilder = new StylingBuilder(bindingContext);\n\n  const {styleAttr, classAttr} = hostBindingsMetadata.specialAttributes;\n  if (styleAttr !== undefined) {\n    styleBuilder.registerStyleAttr(styleAttr);\n  }\n  if (classAttr !== undefined) {\n    styleBuilder.registerClassAttr(classAttr);\n  }\n\n  const createStatements: o.Statement[] = [];\n  const updateStatements: o.Statement[] = [];\n\n  const hostBindingSourceSpan = typeSourceSpan;\n  const directiveSummary = metadataAsSummary(hostBindingsMetadata);\n\n  // Calculate host event bindings\n  const eventBindings =\n      bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);\n  if (eventBindings && eventBindings.length) {\n    const listeners = createHostListeners(eventBindings, name);\n    createStatements.push(...listeners);\n  }\n\n  // Calculate the host property bindings\n  const bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);\n  const allOtherBindings: ParsedProperty[] = [];\n\n  // We need to calculate the total amount of binding slots required by\n  // all the instructions together before any value conversions happen.\n  // Value conversions may require additional slots for interpolation and\n  // bindings with pipes. These calculates happen after this block.\n  let totalHostVarsCount = 0;\n  bindings && bindings.forEach((binding: ParsedProperty) => {\n    const stylingInputWasSet = styleBuilder.registerInputBasedOnName(\n        binding.name, binding.expression, hostBindingSourceSpan);\n    if (stylingInputWasSet) {\n      totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n    } else {\n      allOtherBindings.push(binding);\n      totalHostVarsCount++;\n    }\n  });\n\n  let valueConverter: ValueConverter;\n  const getValueConverter = () => {\n    if (!valueConverter) {\n      const hostVarsCountFn = (numSlots: number): number => {\n        const originalVarsCount = totalHostVarsCount;\n        totalHostVarsCount += numSlots;\n        return originalVarsCount;\n      };\n      valueConverter = new ValueConverter(\n          constantPool,\n          () => error('Unexpected node'),  // new nodes are illegal here\n          hostVarsCountFn,\n          () => error('Unexpected pipe'));  // pipes are illegal here\n    }\n    return valueConverter;\n  };\n\n  const propertyBindings: o.Expression[][] = [];\n  const attributeBindings: o.Expression[][] = [];\n  const syntheticHostBindings: o.Expression[][] = [];\n  allOtherBindings.forEach((binding: ParsedProperty) => {\n    // resolve literal arrays and literal objects\n    const value = binding.expression.visit(getValueConverter());\n    const bindingExpr = bindingFn(bindingContext, value);\n\n    const {bindingName, instruction, isAttribute} = getBindingNameAndInstruction(binding);\n\n    const securityContexts =\n        bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\n            .filter(context => context !== core.SecurityContext.NONE);\n\n    let sanitizerFn: o.ExternalExpr|null = null;\n    if (securityContexts.length) {\n      if (securityContexts.length === 2 &&\n          securityContexts.indexOf(core.SecurityContext.URL) > -1 &&\n          securityContexts.indexOf(core.SecurityContext.RESOURCE_URL) > -1) {\n        // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n        // of different security contexts. In this case we use special santitization function and\n        // select the actual sanitizer at runtime based on a tag name that is provided while\n        // invoking sanitization function.\n        sanitizerFn = o.importExpr(R3.sanitizeUrlOrResourceUrl);\n      } else {\n        sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n      }\n    }\n    const instructionParams = [o.literal(bindingName), bindingExpr.currValExpr];\n    if (sanitizerFn) {\n      instructionParams.push(sanitizerFn);\n    }\n\n    updateStatements.push(...bindingExpr.stmts);\n\n    if (instruction === R3.hostProperty) {\n      propertyBindings.push(instructionParams);\n    } else if (instruction === R3.attribute) {\n      attributeBindings.push(instructionParams);\n    } else if (instruction === R3.syntheticHostProperty) {\n      syntheticHostBindings.push(instructionParams);\n    } else {\n      updateStatements.push(o.importExpr(instruction).callFn(instructionParams).toStmt());\n    }\n  });\n\n  if (propertyBindings.length > 0) {\n    updateStatements.push(chainedInstruction(R3.hostProperty, propertyBindings).toStmt());\n  }\n\n  if (attributeBindings.length > 0) {\n    updateStatements.push(chainedInstruction(R3.attribute, attributeBindings).toStmt());\n  }\n\n  if (syntheticHostBindings.length > 0) {\n    updateStatements.push(\n        chainedInstruction(R3.syntheticHostProperty, syntheticHostBindings).toStmt());\n  }\n\n  // since we're dealing with directives/components and both have hostBinding\n  // functions, we need to generate a special hostAttrs instruction that deals\n  // with both the assignment of styling as well as static attributes to the host\n  // element. The instruction below will instruct all initial styling (styling\n  // that is inside of a host binding within a directive/component) to be attached\n  // to the host element alongside any of the provided host attributes that were\n  // collected earlier.\n  const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n  styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n\n  if (styleBuilder.hasBindings) {\n    // finally each binding that was registered in the statement above will need to be added to\n    // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n    // are evaluated and updated for the element.\n    styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {\n      if (instruction.calls.length > 0) {\n        const calls: o.Expression[][] = [];\n\n        instruction.calls.forEach(call => {\n          // we subtract a value of `1` here because the binding slot was already allocated\n          // at the top of this method when all the input bindings were counted.\n          totalHostVarsCount +=\n              Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n          calls.push(convertStylingCall(call, bindingContext, bindingFn));\n        });\n\n        updateStatements.push(chainedInstruction(instruction.reference, calls).toStmt());\n      }\n    });\n  }\n\n  if (totalHostVarsCount) {\n    definitionMap.set('hostVars', o.literal(totalHostVarsCount));\n  }\n\n  if (createStatements.length > 0 || updateStatements.length > 0) {\n    const hostBindingsFnName = name ? `${name}_HostBindings` : null;\n    const statements: o.Statement[] = [];\n    if (createStatements.length > 0) {\n      statements.push(renderFlagCheckIfStmt(core.RenderFlags.Create, createStatements));\n    }\n    if (updateStatements.length > 0) {\n      statements.push(renderFlagCheckIfStmt(core.RenderFlags.Update, updateStatements));\n    }\n    return o.fn(\n        [new o.FnParam(RENDER_FLAGS, o.NUMBER_TYPE), new o.FnParam(CONTEXT_NAME, null)], statements,\n        o.INFERRED_TYPE, null, hostBindingsFnName);\n  }\n\n  return null;\n}\n\nfunction bindingFn(implicit: any, value: AST) {\n  return convertPropertyBinding(\n      null, implicit, value, 'b', BindingForm.Expression, () => error('Unexpected interpolation'));\n}\n\nfunction convertStylingCall(\n    call: StylingInstructionCall, bindingContext: any, bindingFn: Function) {\n  return call.params(value => bindingFn(bindingContext, value).currValExpr);\n}\n\nfunction getBindingNameAndInstruction(binding: ParsedProperty):\n    {bindingName: string, instruction: o.ExternalReference, isAttribute: boolean} {\n  let bindingName = binding.name;\n  let instruction!: o.ExternalReference;\n\n  // Check to see if this is an attr binding or a property binding\n  const attrMatches = bindingName.match(ATTR_REGEX);\n  if (attrMatches) {\n    bindingName = attrMatches[1];\n    instruction = R3.attribute;\n  } else {\n    if (binding.isAnimation) {\n      bindingName = prepareSyntheticPropertyName(bindingName);\n      // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n      // in the context of the component and not the parent. Therefore there is a special\n      // compatibility instruction available for this purpose.\n      instruction = R3.syntheticHostProperty;\n    } else {\n      instruction = R3.hostProperty;\n    }\n  }\n\n  return {bindingName, instruction, isAttribute: !!attrMatches};\n}\n\nfunction createHostListeners(eventBindings: ParsedEvent[], name?: string): o.Statement[] {\n  const listeners: o.Expression[][] = [];\n  const syntheticListeners: o.Expression[][] = [];\n  const instructions: o.Statement[] = [];\n\n  eventBindings.forEach(binding => {\n    let bindingName = binding.name && sanitizeIdentifier(binding.name);\n    const bindingFnName = binding.type === ParsedEventType.Animation ?\n        prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\n        bindingName;\n    const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;\n    const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n\n    if (binding.type == ParsedEventType.Animation) {\n      syntheticListeners.push(params);\n    } else {\n      listeners.push(params);\n    }\n  });\n\n  if (syntheticListeners.length > 0) {\n    instructions.push(chainedInstruction(R3.syntheticHostListener, syntheticListeners).toStmt());\n  }\n\n  if (listeners.length > 0) {\n    instructions.push(chainedInstruction(R3.listener, listeners).toStmt());\n  }\n\n  return instructions;\n}\n\nfunction metadataAsSummary(meta: R3HostMetadata): CompileDirectiveSummary {\n  // clang-format off\n  return {\n    // This is used by the BindingParser, which only deals with listeners and properties. There's no\n    // need to pass attributes to it.\n    hostAttributes: {},\n    hostListeners: meta.listeners,\n    hostProperties: meta.properties,\n  } as CompileDirectiveSummary;\n  // clang-format on\n}\n\n\n\nconst HOST_REG_EXP = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\n// Represents the groups in the above regex.\nconst enum HostBindingGroup {\n  // group 1: \"prop\" from \"[prop]\", or \"attr.role\" from \"[attr.role]\", or @anim from [@anim]\n  Binding = 1,\n\n  // group 2: \"event\" from \"(event)\"\n  Event = 2,\n}\n\n// Defines Host Bindings structure that contains attributes, listeners, and properties,\n// parsed from the `host` object defined for a Type.\nexport interface ParsedHostBindings {\n  attributes: {[key: string]: o.Expression};\n  listeners: {[key: string]: string};\n  properties: {[key: string]: string};\n  specialAttributes: {styleAttr?: string; classAttr?: string;};\n}\n\nexport function parseHostBindings(host: {[key: string]: string|o.Expression}): ParsedHostBindings {\n  const attributes: {[key: string]: o.Expression} = {};\n  const listeners: {[key: string]: string} = {};\n  const properties: {[key: string]: string} = {};\n  const specialAttributes: {styleAttr?: string; classAttr?: string;} = {};\n\n  for (const key of Object.keys(host)) {\n    const value = host[key];\n    const matches = key.match(HOST_REG_EXP);\n\n    if (matches === null) {\n      switch (key) {\n        case 'class':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(`Class binding must be string`);\n          }\n          specialAttributes.classAttr = value;\n          break;\n        case 'style':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(`Style binding must be string`);\n          }\n          specialAttributes.styleAttr = value;\n          break;\n        default:\n          if (typeof value === 'string') {\n            attributes[key] = o.literal(value);\n          } else {\n            attributes[key] = value;\n          }\n      }\n    } else if (matches[HostBindingGroup.Binding] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(`Property binding must be string`);\n      }\n      // synthetic properties (the ones that have a `@` as a prefix)\n      // are still treated the same as regular properties. Therefore\n      // there is no point in storing them in a separate map.\n      properties[matches[HostBindingGroup.Binding]] = value;\n    } else if (matches[HostBindingGroup.Event] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(`Event binding must be string`);\n      }\n      listeners[matches[HostBindingGroup.Event]] = value;\n    }\n  }\n\n  return {attributes, listeners, properties, specialAttributes};\n}\n\n/**\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\n * given set of host bindings has no errors.\n *\n * @param bindings set of host bindings to verify.\n * @param sourceSpan source span where host bindings were defined.\n * @returns array of errors associated with a given set of host bindings.\n */\nexport function verifyHostBindings(\n    bindings: ParsedHostBindings, sourceSpan: ParseSourceSpan): ParseError[] {\n  const summary = metadataAsSummary(bindings);\n  // TODO: abstract out host bindings verification logic and use it instead of\n  // creating events and properties ASTs to detect errors (FW-996)\n  const bindingParser = makeBindingParser();\n  bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);\n  bindingParser.createBoundHostProperties(summary, sourceSpan);\n  return bindingParser.errors;\n}\n\nfunction compileStyles(styles: string[], selector: string, hostSelector: string): string[] {\n  const shadowCss = new ShadowCss();\n  return styles.map(style => {\n    return shadowCss!.shimCssText(style, selector, hostSelector);\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}