{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/translator/src/import_manager\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ImportManager = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var ImportManager =\n  /** @class */\n  function () {\n    function ImportManager(rewriter, prefix) {\n      if (rewriter === void 0) {\n        rewriter = new imports_1.NoopImportRewriter();\n      }\n\n      if (prefix === void 0) {\n        prefix = 'i';\n      }\n\n      this.rewriter = rewriter;\n      this.prefix = prefix;\n      this.specifierToIdentifier = new Map();\n      this.nextIndex = 0;\n    }\n\n    ImportManager.prototype.generateNamespaceImport = function (moduleName) {\n      if (!this.specifierToIdentifier.has(moduleName)) {\n        this.specifierToIdentifier.set(moduleName, ts.createIdentifier(\"\" + this.prefix + this.nextIndex++));\n      }\n\n      return this.specifierToIdentifier.get(moduleName);\n    };\n\n    ImportManager.prototype.generateNamedImport = function (moduleName, originalSymbol) {\n      // First, rewrite the symbol name.\n      var symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName); // Ask the rewriter if this symbol should be imported at all. If not, it can be referenced\n      // directly (moduleImport: null).\n\n      if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {\n        // The symbol should be referenced directly.\n        return {\n          moduleImport: null,\n          symbol: symbol\n        };\n      } // If not, this symbol will be imported using a generated namespace import.\n\n\n      var moduleImport = this.generateNamespaceImport(moduleName);\n      return {\n        moduleImport: moduleImport,\n        symbol: symbol\n      };\n    };\n\n    ImportManager.prototype.getAllImports = function (contextPath) {\n      var e_1, _a;\n\n      var imports = [];\n\n      try {\n        for (var _b = tslib_1.__values(this.specifierToIdentifier), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = tslib_1.__read(_c.value, 2),\n              originalSpecifier = _d[0],\n              qualifier = _d[1];\n\n          var specifier = this.rewriter.rewriteSpecifier(originalSpecifier, contextPath);\n          imports.push({\n            specifier: specifier,\n            qualifier: qualifier\n          });\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return imports;\n    };\n\n    return ImportManager;\n  }();\n\n  exports.ImportManager = ImportManager;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/import_manager.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAMG;;;AACH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AAaA,MAAA,aAAA;AAAA;AAAA,cAAA;AAIE,aAAA,aAAA,CAAsB,QAAtB,EAAmF,MAAnF,EAA+F;AAAzE,UAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,QAAA,GAAA,IAA+B,SAAA,CAAA,kBAA/B,EAAA;AAAmD;;AAAU,UAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,MAAA,GAAA,GAAA;AAAY;;AAAzE,WAAA,QAAA,GAAA,QAAA;AAA6D,WAAA,MAAA,GAAA,MAAA;AAH3E,WAAA,qBAAA,GAAwB,IAAI,GAAJ,EAAxB;AACA,WAAA,SAAA,GAAY,CAAZ;AAGP;;AAED,IAAA,aAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UAAwB,UAAxB,EAA0C;AACxC,UAAI,CAAC,KAAK,qBAAL,CAA2B,GAA3B,CAA+B,UAA/B,CAAL,EAAiD;AAC/C,aAAK,qBAAL,CAA2B,GAA3B,CACI,UADJ,EACgB,EAAE,CAAC,gBAAH,CAAoB,KAAG,KAAK,MAAR,GAAiB,KAAK,SAAL,EAArC,CADhB;AAED;;AACD,aAAO,KAAK,qBAAL,CAA2B,GAA3B,CAA+B,UAA/B,CAAP;AACD,KAND;;AAQA,IAAA,aAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,UAApB,EAAwC,cAAxC,EAA8D;AAC5D;AACA,UAAM,MAAM,GAAG,KAAK,QAAL,CAAc,aAAd,CAA4B,cAA5B,EAA4C,UAA5C,CAAf,CAF4D,CAI5D;AACA;;AACA,UAAI,CAAC,KAAK,QAAL,CAAc,kBAAd,CAAiC,MAAjC,EAAyC,UAAzC,CAAL,EAA2D;AACzD;AACA,eAAO;AAAC,UAAA,YAAY,EAAE,IAAf;AAAqB,UAAA,MAAM,EAAA;AAA3B,SAAP;AACD,OAT2D,CAW5D;;;AACA,UAAM,YAAY,GAAG,KAAK,uBAAL,CAA6B,UAA7B,CAArB;AAEA,aAAO;AAAC,QAAA,YAAY,EAAA,YAAb;AAAe,QAAA,MAAM,EAAA;AAArB,OAAP;AACD,KAfD;;AAiBA,IAAA,aAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,WAAd,EAAiC;;;AAC/B,UAAM,OAAO,GAAa,EAA1B;;;AACA,aAA6C,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,qBAAL,CAAA,EAA0B,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvE,EAAuE,CAAA,EAAA,CAAA,IAAvE,EAAuE,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvE,EAAyE;AAA9D,cAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAAA,EAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,cAAC,iBAAiB,GAAA,EAAA,CAAA,CAAA,CAAlB;AAAA,cAAoB,SAAS,GAAA,EAAA,CAAA,CAAA,CAA7B;;AACT,cAAM,SAAS,GAAG,KAAK,QAAL,CAAc,gBAAd,CAA+B,iBAA/B,EAAkD,WAAlD,CAAlB;AACA,UAAA,OAAO,CAAC,IAAR,CAAa;AACX,YAAA,SAAS,EAAA,SADE;AAEX,YAAA,SAAS,EAAA;AAFE,WAAb;AAID;;;;;;;;;;;;;AACD,aAAO,OAAP;AACD,KAVD;;AAWF,WAAA,aAAA;AAAC,GA3CD,EAAA;;AAAa,EAAA,OAAA,CAAA,aAAA,GAAA,aAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport {ImportRewriter, NoopImportRewriter} from '../../imports';\nimport {ImportGenerator, NamedImport} from './api/import_generator';\n\n/**\n * Information about an import that has been added to a module.\n */\nexport interface Import {\n  /** The name of the module that has been imported. */\n  specifier: string;\n  /** The `ts.Identifer` by which the imported module is known. */\n  qualifier: ts.Identifier;\n}\n\nexport class ImportManager implements ImportGenerator<ts.Identifier> {\n  private specifierToIdentifier = new Map<string, ts.Identifier>();\n  private nextIndex = 0;\n\n  constructor(protected rewriter: ImportRewriter = new NoopImportRewriter(), private prefix = 'i') {\n  }\n\n  generateNamespaceImport(moduleName: string): ts.Identifier {\n    if (!this.specifierToIdentifier.has(moduleName)) {\n      this.specifierToIdentifier.set(\n          moduleName, ts.createIdentifier(`${this.prefix}${this.nextIndex++}`));\n    }\n    return this.specifierToIdentifier.get(moduleName)!;\n  }\n\n  generateNamedImport(moduleName: string, originalSymbol: string): NamedImport<ts.Identifier> {\n    // First, rewrite the symbol name.\n    const symbol = this.rewriter.rewriteSymbol(originalSymbol, moduleName);\n\n    // Ask the rewriter if this symbol should be imported at all. If not, it can be referenced\n    // directly (moduleImport: null).\n    if (!this.rewriter.shouldImportSymbol(symbol, moduleName)) {\n      // The symbol should be referenced directly.\n      return {moduleImport: null, symbol};\n    }\n\n    // If not, this symbol will be imported using a generated namespace import.\n    const moduleImport = this.generateNamespaceImport(moduleName);\n\n    return {moduleImport, symbol};\n  }\n\n  getAllImports(contextPath: string): Import[] {\n    const imports: Import[] = [];\n    for (const [originalSpecifier, qualifier] of this.specifierToIdentifier) {\n      const specifier = this.rewriter.rewriteSpecifier(originalSpecifier, contextPath);\n      imports.push({\n        specifier,\n        qualifier,\n      });\n    }\n    return imports;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}