{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar util = require('util');\n\nvar crypto = require('crypto');\n\nvar fs = require('fs');\n\nvar Minipass = require('minipass');\n\nvar path = require('path');\n\nvar ssri = require('ssri');\n\nvar contentPath = require('./content/path');\n\nvar fixOwner = require('./util/fix-owner');\n\nvar hashToSegments = require('./util/hash-to-segments');\n\nvar indexV = require('../package.json')['cache-version'].index;\n\nvar appendFile = util.promisify(fs.appendFile);\nvar readFile = util.promisify(fs.readFile);\nvar readdir = util.promisify(fs.readdir);\n\nmodule.exports.NotFoundError = /*#__PURE__*/function (_Error) {\n  _inherits(NotFoundError, _Error);\n\n  var _super = _createSuper(NotFoundError);\n\n  function NotFoundError(cache, key) {\n    var _this;\n\n    _classCallCheck(this, NotFoundError);\n\n    _this = _super.call(this, \"No cache entry for \".concat(key, \" found in \").concat(cache));\n    _this.code = 'ENOENT';\n    _this.cache = cache;\n    _this.key = key;\n    return _this;\n  }\n\n  return NotFoundError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nmodule.exports.insert = insert;\n\nfunction insert(cache, key, integrity) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var metadata = opts.metadata,\n      size = opts.size;\n  var bucket = bucketPath(cache, key);\n  var entry = {\n    key: key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: size,\n    metadata: metadata\n  };\n  return fixOwner.mkdirfix(cache, path.dirname(bucket)).then(function () {\n    var stringified = JSON.stringify(entry); // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n\n    return appendFile(bucket, \"\\n\".concat(hashEntry(stringified), \"\\t\").concat(stringified));\n  }).then(function () {\n    return fixOwner.chownr(cache, bucket);\n  }).catch(function (err) {\n    if (err.code === 'ENOENT') {\n      return undefined;\n    }\n\n    throw err; // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(function () {\n    return formatEntry(cache, entry);\n  });\n}\n\nmodule.exports.insert.sync = insertSync;\n\nfunction insertSync(cache, key, integrity) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var metadata = opts.metadata,\n      size = opts.size;\n  var bucket = bucketPath(cache, key);\n  var entry = {\n    key: key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: size,\n    metadata: metadata\n  };\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));\n  var stringified = JSON.stringify(entry);\n  fs.appendFileSync(bucket, \"\\n\".concat(hashEntry(stringified), \"\\t\").concat(stringified));\n\n  try {\n    fixOwner.chownr.sync(cache, bucket);\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n  }\n\n  return formatEntry(cache, entry);\n}\n\nmodule.exports.find = find;\n\nfunction find(cache, key) {\n  var bucket = bucketPath(cache, key);\n  return bucketEntries(bucket).then(function (entries) {\n    return entries.reduce(function (latest, next) {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  }).catch(function (err) {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  });\n}\n\nmodule.exports.find.sync = findSync;\n\nfunction findSync(cache, key) {\n  var bucket = bucketPath(cache, key);\n\n  try {\n    return bucketEntriesSync(bucket).reduce(function (latest, next) {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}\n\nmodule.exports.delete = del;\n\nfunction del(cache, key, opts) {\n  return insert(cache, key, null, opts);\n}\n\nmodule.exports.delete.sync = delSync;\n\nfunction delSync(cache, key, opts) {\n  return insertSync(cache, key, null, opts);\n}\n\nmodule.exports.lsStream = lsStream;\n\nfunction lsStream(cache) {\n  var indexDir = bucketDir(cache);\n  var stream = new Minipass({\n    objectMode: true\n  });\n  readdirOrEmpty(indexDir).then(function (buckets) {\n    return Promise.all(buckets.map(function (bucket) {\n      var bucketPath = path.join(indexDir, bucket);\n      return readdirOrEmpty(bucketPath).then(function (subbuckets) {\n        return Promise.all(subbuckets.map(function (subbucket) {\n          var subbucketPath = path.join(bucketPath, subbucket); // \"/cachename/<bucket 0xFF>/<bucket 0xFF>./*\"\n\n          return readdirOrEmpty(subbucketPath).then(function (entries) {\n            return Promise.all(entries.map(function (entry) {\n              var entryPath = path.join(subbucketPath, entry);\n              return bucketEntries(entryPath).then(function (entries) {\n                return (// using a Map here prevents duplicate keys from\n                  // showing up twice, I guess?\n                  entries.reduce(function (acc, entry) {\n                    acc.set(entry.key, entry);\n                    return acc;\n                  }, new Map())\n                );\n              }).then(function (reduced) {\n                // reduced is a map of key => entry\n                var _iterator = _createForOfIteratorHelper(reduced.values()),\n                    _step;\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var _entry = _step.value;\n                    var formatted = formatEntry(cache, _entry);\n\n                    if (formatted) {\n                      stream.write(formatted);\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n              }).catch(function (err) {\n                if (err.code === 'ENOENT') {\n                  return undefined;\n                }\n\n                throw err;\n              });\n            }));\n          });\n        }));\n      });\n    }));\n  }).then(function () {\n    return stream.end();\n  }, function (err) {\n    return stream.emit('error', err);\n  });\n  return stream;\n}\n\nmodule.exports.ls = ls;\n\nfunction ls(cache) {\n  return lsStream(cache).collect().then(function (entries) {\n    return entries.reduce(function (acc, xs) {\n      acc[xs.key] = xs;\n      return acc;\n    }, {});\n  });\n}\n\nfunction bucketEntries(bucket, filter) {\n  return readFile(bucket, 'utf8').then(function (data) {\n    return _bucketEntries(data, filter);\n  });\n}\n\nfunction bucketEntriesSync(bucket, filter) {\n  var data = fs.readFileSync(bucket, 'utf8');\n  return _bucketEntries(data, filter);\n}\n\nfunction _bucketEntries(data, filter) {\n  var entries = [];\n  data.split('\\n').forEach(function (entry) {\n    if (!entry) {\n      return;\n    }\n\n    var pieces = entry.split('\\t');\n\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return;\n    }\n\n    var obj;\n\n    try {\n      obj = JSON.parse(pieces[1]);\n    } catch (e) {\n      // Entry is corrupted!\n      return;\n    }\n\n    if (obj) {\n      entries.push(obj);\n    }\n  });\n  return entries;\n}\n\nmodule.exports.bucketDir = bucketDir;\n\nfunction bucketDir(cache) {\n  return path.join(cache, \"index-v\".concat(indexV));\n}\n\nmodule.exports.bucketPath = bucketPath;\n\nfunction bucketPath(cache, key) {\n  var hashed = hashKey(key);\n  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));\n}\n\nmodule.exports.hashKey = hashKey;\n\nfunction hashKey(key) {\n  return hash(key, 'sha256');\n}\n\nmodule.exports.hashEntry = hashEntry;\n\nfunction hashEntry(str) {\n  return hash(str, 'sha1');\n}\n\nfunction hash(str, digest) {\n  return crypto.createHash(digest).update(str).digest('hex');\n}\n\nfunction formatEntry(cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) {\n    return null;\n  }\n\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  };\n}\n\nfunction readdirOrEmpty(dir) {\n  return readdir(dir).catch(function (err) {\n    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {\n      return [];\n    }\n\n    throw err;\n  });\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/cacache/lib/entry-index.js"],"names":["util","require","crypto","fs","Minipass","path","ssri","contentPath","fixOwner","hashToSegments","indexV","index","appendFile","promisify","readFile","readdir","module","exports","NotFoundError","cache","key","code","Error","insert","integrity","opts","metadata","size","bucket","bucketPath","entry","stringify","time","Date","now","mkdirfix","dirname","then","stringified","JSON","hashEntry","chownr","catch","err","undefined","formatEntry","sync","insertSync","appendFileSync","find","bucketEntries","entries","reduce","latest","next","findSync","bucketEntriesSync","delete","del","delSync","lsStream","indexDir","bucketDir","stream","objectMode","readdirOrEmpty","buckets","Promise","all","map","join","subbuckets","subbucket","subbucketPath","entryPath","acc","set","Map","reduced","values","formatted","write","end","emit","ls","collect","xs","filter","data","_bucketEntries","readFileSync","split","forEach","pieces","obj","parse","e","push","hashed","hashKey","apply","concat","hash","str","digest","createHash","update","dir"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst crypto = require('crypto')\nconst fs = require('fs')\nconst Minipass = require('minipass')\nconst path = require('path')\nconst ssri = require('ssri')\nconst contentPath = require('./content/path')\nconst fixOwner = require('./util/fix-owner')\nconst hashToSegments = require('./util/hash-to-segments')\nconst indexV = require('../package.json')['cache-version'].index\n\nconst appendFile = util.promisify(fs.appendFile)\nconst readFile = util.promisify(fs.readFile)\nconst readdir = util.promisify(fs.readdir)\n\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor (cache, key) {\n    super(`No cache entry for ${key} found in ${cache}`)\n    this.code = 'ENOENT'\n    this.cache = cache\n    this.key = key\n  }\n}\n\nmodule.exports.insert = insert\n\nfunction insert (cache, key, integrity, opts = {}) {\n  const { metadata, size } = opts\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size,\n    metadata\n  }\n  return fixOwner\n    .mkdirfix(cache, path.dirname(bucket))\n    .then(() => {\n      const stringified = JSON.stringify(entry)\n      // NOTE - Cleverness ahoy!\n      //\n      // This works because it's tremendously unlikely for an entry to corrupt\n      // another while still preserving the string length of the JSON in\n      // question. So, we just slap the length in there and verify it on read.\n      //\n      // Thanks to @isaacs for the whiteboarding session that ended up with this.\n      return appendFile(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`)\n    })\n    .then(() => fixOwner.chownr(cache, bucket))\n    .catch((err) => {\n      if (err.code === 'ENOENT') {\n        return undefined\n      }\n      throw err\n      // There's a class of race conditions that happen when things get deleted\n      // during fixOwner, or between the two mkdirfix/chownr calls.\n      //\n      // It's perfectly fine to just not bother in those cases and lie\n      // that the index entry was written. Because it's a cache.\n    })\n    .then(() => {\n      return formatEntry(cache, entry)\n    })\n}\n\nmodule.exports.insert.sync = insertSync\n\nfunction insertSync (cache, key, integrity, opts = {}) {\n  const { metadata, size } = opts\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size,\n    metadata\n  }\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket))\n  const stringified = JSON.stringify(entry)\n  fs.appendFileSync(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`)\n  try {\n    fixOwner.chownr.sync(cache, bucket)\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err\n    }\n  }\n  return formatEntry(cache, entry)\n}\n\nmodule.exports.find = find\n\nfunction find (cache, key) {\n  const bucket = bucketPath(cache, key)\n  return bucketEntries(bucket)\n    .then((entries) => {\n      return entries.reduce((latest, next) => {\n        if (next && next.key === key) {\n          return formatEntry(cache, next)\n        } else {\n          return latest\n        }\n      }, null)\n    })\n    .catch((err) => {\n      if (err.code === 'ENOENT') {\n        return null\n      } else {\n        throw err\n      }\n    })\n}\n\nmodule.exports.find.sync = findSync\n\nfunction findSync (cache, key) {\n  const bucket = bucketPath(cache, key)\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports.delete = del\n\nfunction del (cache, key, opts) {\n  return insert(cache, key, null, opts)\n}\n\nmodule.exports.delete.sync = delSync\n\nfunction delSync (cache, key, opts) {\n  return insertSync(cache, key, null, opts)\n}\n\nmodule.exports.lsStream = lsStream\n\nfunction lsStream (cache) {\n  const indexDir = bucketDir(cache)\n  const stream = new Minipass({ objectMode: true })\n\n  readdirOrEmpty(indexDir).then(buckets => Promise.all(\n    buckets.map(bucket => {\n      const bucketPath = path.join(indexDir, bucket)\n      return readdirOrEmpty(bucketPath).then(subbuckets => Promise.all(\n        subbuckets.map(subbucket => {\n          const subbucketPath = path.join(bucketPath, subbucket)\n\n          // \"/cachename/<bucket 0xFF>/<bucket 0xFF>./*\"\n          return readdirOrEmpty(subbucketPath).then(entries => Promise.all(\n            entries.map(entry => {\n              const entryPath = path.join(subbucketPath, entry)\n              return bucketEntries(entryPath).then(entries =>\n                // using a Map here prevents duplicate keys from\n                // showing up twice, I guess?\n                entries.reduce((acc, entry) => {\n                  acc.set(entry.key, entry)\n                  return acc\n                }, new Map())\n              ).then(reduced => {\n                // reduced is a map of key => entry\n                for (const entry of reduced.values()) {\n                  const formatted = formatEntry(cache, entry)\n                  if (formatted) {\n                    stream.write(formatted)\n                  }\n                }\n              }).catch(err => {\n                if (err.code === 'ENOENT') { return undefined }\n                throw err\n              })\n            })\n          ))\n        })\n      ))\n    })\n  ))\n    .then(\n      () => stream.end(),\n      err => stream.emit('error', err)\n    )\n\n  return stream\n}\n\nmodule.exports.ls = ls\n\nfunction ls (cache) {\n  return lsStream(cache).collect().then(entries =>\n    entries.reduce((acc, xs) => {\n      acc[xs.key] = xs\n      return acc\n    }, {})\n  )\n}\n\nfunction bucketEntries (bucket, filter) {\n  return readFile(bucket, 'utf8').then((data) => _bucketEntries(data, filter))\n}\n\nfunction bucketEntriesSync (bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8')\n  return _bucketEntries(data, filter)\n}\n\nfunction _bucketEntries (data, filter) {\n  const entries = []\n  data.split('\\n').forEach((entry) => {\n    if (!entry) {\n      return\n    }\n    const pieces = entry.split('\\t')\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return\n    }\n    let obj\n    try {\n      obj = JSON.parse(pieces[1])\n    } catch (e) {\n      // Entry is corrupted!\n      return\n    }\n    if (obj) {\n      entries.push(obj)\n    }\n  })\n  return entries\n}\n\nmodule.exports.bucketDir = bucketDir\n\nfunction bucketDir (cache) {\n  return path.join(cache, `index-v${indexV}`)\n}\n\nmodule.exports.bucketPath = bucketPath\n\nfunction bucketPath (cache, key) {\n  const hashed = hashKey(key)\n  return path.join.apply(\n    path,\n    [bucketDir(cache)].concat(hashToSegments(hashed))\n  )\n}\n\nmodule.exports.hashKey = hashKey\n\nfunction hashKey (key) {\n  return hash(key, 'sha256')\n}\n\nmodule.exports.hashEntry = hashEntry\n\nfunction hashEntry (str) {\n  return hash(str, 'sha1')\n}\n\nfunction hash (str, digest) {\n  return crypto\n    .createHash(digest)\n    .update(str)\n    .digest('hex')\n}\n\nfunction formatEntry (cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) {\n    return null\n  }\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  }\n}\n\nfunction readdirOrEmpty (dir) {\n  return readdir(dir).catch((err) => {\n    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {\n      return []\n    }\n\n    throw err\n  })\n}\n"]},"metadata":{},"sourceType":"script"}