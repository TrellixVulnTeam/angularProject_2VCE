{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/routing/src/lazy\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/routing/src/route\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.scanForRouteEntryPoints = exports.scanForCandidateTransitiveModules = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var route_1 = require(\"@angular/compiler-cli/src/ngtsc/routing/src/route\");\n\n  var ROUTES_MARKER = '__ngRoutesMarker__';\n\n  function scanForCandidateTransitiveModules(expr, evaluator) {\n    if (expr === null) {\n      return [];\n    }\n\n    var candidateModuleKeys = [];\n    var entries = evaluator.evaluate(expr);\n\n    function recursivelyAddModules(entry) {\n      var e_1, _a;\n\n      if (Array.isArray(entry)) {\n        try {\n          for (var entry_1 = tslib_1.__values(entry), entry_1_1 = entry_1.next(); !entry_1_1.done; entry_1_1 = entry_1.next()) {\n            var e = entry_1_1.value;\n            recursivelyAddModules(e);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (entry_1_1 && !entry_1_1.done && (_a = entry_1.return)) _a.call(entry_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } else if (entry instanceof Map) {\n        if (entry.has('ngModule')) {\n          recursivelyAddModules(entry.get('ngModule'));\n        }\n      } else if (entry instanceof imports_1.Reference && hasIdentifier(entry.node)) {\n        var filePath = entry.node.getSourceFile().fileName;\n        var moduleName = entry.node.name.text;\n        candidateModuleKeys.push(route_1.entryPointKeyFor(filePath, moduleName));\n      }\n    }\n\n    recursivelyAddModules(entries);\n    return candidateModuleKeys;\n  }\n\n  exports.scanForCandidateTransitiveModules = scanForCandidateTransitiveModules;\n\n  function scanForRouteEntryPoints(ngModule, moduleName, data, entryPointManager, evaluator) {\n    var e_2, _a;\n\n    var loadChildrenIdentifiers = [];\n    var from = entryPointManager.fromNgModule(ngModule, moduleName);\n\n    if (data.providers !== null) {\n      loadChildrenIdentifiers.push.apply(loadChildrenIdentifiers, tslib_1.__spread(scanForProviders(data.providers, evaluator)));\n    }\n\n    if (data.imports !== null) {\n      loadChildrenIdentifiers.push.apply(loadChildrenIdentifiers, tslib_1.__spread(scanForRouterModuleUsage(data.imports, evaluator)));\n    }\n\n    if (data.exports !== null) {\n      loadChildrenIdentifiers.push.apply(loadChildrenIdentifiers, tslib_1.__spread(scanForRouterModuleUsage(data.exports, evaluator)));\n    }\n\n    var routes = [];\n\n    try {\n      for (var loadChildrenIdentifiers_1 = tslib_1.__values(loadChildrenIdentifiers), loadChildrenIdentifiers_1_1 = loadChildrenIdentifiers_1.next(); !loadChildrenIdentifiers_1_1.done; loadChildrenIdentifiers_1_1 = loadChildrenIdentifiers_1.next()) {\n        var loadChildren = loadChildrenIdentifiers_1_1.value;\n        var resolvedTo = entryPointManager.resolveLoadChildrenIdentifier(loadChildren, ngModule);\n\n        if (resolvedTo !== null) {\n          routes.push({\n            loadChildren: loadChildren,\n            from: from,\n            resolvedTo: resolvedTo\n          });\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (loadChildrenIdentifiers_1_1 && !loadChildrenIdentifiers_1_1.done && (_a = loadChildrenIdentifiers_1.return)) _a.call(loadChildrenIdentifiers_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return routes;\n  }\n\n  exports.scanForRouteEntryPoints = scanForRouteEntryPoints;\n\n  function scanForProviders(expr, evaluator) {\n    var loadChildrenIdentifiers = [];\n    var providers = evaluator.evaluate(expr);\n\n    function recursivelyAddProviders(provider) {\n      var e_3, _a;\n\n      if (Array.isArray(provider)) {\n        try {\n          for (var provider_1 = tslib_1.__values(provider), provider_1_1 = provider_1.next(); !provider_1_1.done; provider_1_1 = provider_1.next()) {\n            var entry = provider_1_1.value;\n            recursivelyAddProviders(entry);\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (provider_1_1 && !provider_1_1.done && (_a = provider_1.return)) _a.call(provider_1);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      } else if (provider instanceof Map) {\n        if (provider.has('provide') && provider.has('useValue')) {\n          var provide = provider.get('provide');\n          var useValue = provider.get('useValue');\n\n          if (isRouteToken(provide) && Array.isArray(useValue)) {\n            loadChildrenIdentifiers.push.apply(loadChildrenIdentifiers, tslib_1.__spread(scanForLazyRoutes(useValue)));\n          }\n        }\n      }\n    }\n\n    recursivelyAddProviders(providers);\n    return loadChildrenIdentifiers;\n  }\n\n  function scanForRouterModuleUsage(expr, evaluator) {\n    var loadChildrenIdentifiers = [];\n    var imports = evaluator.evaluate(expr, routerModuleFFR);\n\n    function recursivelyAddRoutes(imp) {\n      var e_4, _a;\n\n      if (Array.isArray(imp)) {\n        try {\n          for (var imp_1 = tslib_1.__values(imp), imp_1_1 = imp_1.next(); !imp_1_1.done; imp_1_1 = imp_1.next()) {\n            var entry = imp_1_1.value;\n            recursivelyAddRoutes(entry);\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (imp_1_1 && !imp_1_1.done && (_a = imp_1.return)) _a.call(imp_1);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n      } else if (imp instanceof Map) {\n        if (imp.has(ROUTES_MARKER) && imp.has('routes')) {\n          var routes = imp.get('routes');\n\n          if (Array.isArray(routes)) {\n            loadChildrenIdentifiers.push.apply(loadChildrenIdentifiers, tslib_1.__spread(scanForLazyRoutes(routes)));\n          }\n        }\n      }\n    }\n\n    recursivelyAddRoutes(imports);\n    return loadChildrenIdentifiers;\n  }\n\n  function scanForLazyRoutes(routes) {\n    var loadChildrenIdentifiers = [];\n\n    function recursivelyScanRoutes(routes) {\n      var e_5, _a;\n\n      try {\n        for (var routes_1 = tslib_1.__values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {\n          var route = routes_1_1.value;\n\n          if (!(route instanceof Map)) {\n            continue;\n          }\n\n          if (route.has('loadChildren')) {\n            var loadChildren = route.get('loadChildren');\n\n            if (typeof loadChildren === 'string') {\n              loadChildrenIdentifiers.push(loadChildren);\n            }\n          } else if (route.has('children')) {\n            var children = route.get('children');\n\n            if (Array.isArray(children)) {\n              recursivelyScanRoutes(children);\n            }\n          }\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n    }\n\n    recursivelyScanRoutes(routes);\n    return loadChildrenIdentifiers;\n  }\n  /**\n   * A foreign function resolver that converts `RouterModule.forRoot/forChild(X)` to a special object\n   * of the form `{__ngRoutesMarker__: true, routes: X}`.\n   *\n   * These objects are then recognizable inside the larger set of imports/exports.\n   */\n\n\n  var routerModuleFFR = function routerModuleFFR(ref, args) {\n    if (!isMethodNodeReference(ref) || !ts.isClassDeclaration(ref.node.parent)) {\n      return null;\n    } else if (ref.bestGuessOwningModule === null || ref.bestGuessOwningModule.specifier !== '@angular/router') {\n      return null;\n    } else if (ref.node.parent.name === undefined || ref.node.parent.name.text !== 'RouterModule') {\n      return null;\n    } else if (!ts.isIdentifier(ref.node.name) || ref.node.name.text !== 'forRoot' && ref.node.name.text !== 'forChild') {\n      return null;\n    }\n\n    var routes = args[0];\n    return ts.createObjectLiteral([ts.createPropertyAssignment(ROUTES_MARKER, ts.createTrue()), ts.createPropertyAssignment('routes', routes)]);\n  };\n\n  function hasIdentifier(node) {\n    var node_ = node;\n    return node_.name !== undefined && ts.isIdentifier(node_.name);\n  }\n\n  function isMethodNodeReference(ref) {\n    return ts.isMethodDeclaration(ref.node);\n  }\n\n  function isRouteToken(ref) {\n    return ref instanceof imports_1.Reference && ref.bestGuessOwningModule !== null && ref.bestGuessOwningModule.specifier === '@angular/router' && ref.debugName === 'ROUTES';\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/routing/src/lazy.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {ForeignFunctionResolver, PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\n\nimport {NgModuleRawRouteData} from './analyzer';\nimport {entryPointKeyFor, RouterEntryPoint, RouterEntryPointManager} from './route';\n\nconst ROUTES_MARKER = '__ngRoutesMarker__';\n\nexport interface LazyRouteEntry {\n  loadChildren: string;\n  from: RouterEntryPoint;\n  resolvedTo: RouterEntryPoint;\n}\n\nexport function scanForCandidateTransitiveModules(\n    expr: ts.Expression|null, evaluator: PartialEvaluator): string[] {\n  if (expr === null) {\n    return [];\n  }\n\n  const candidateModuleKeys: string[] = [];\n  const entries = evaluator.evaluate(expr);\n\n  function recursivelyAddModules(entry: ResolvedValue) {\n    if (Array.isArray(entry)) {\n      for (const e of entry) {\n        recursivelyAddModules(e);\n      }\n    } else if (entry instanceof Map) {\n      if (entry.has('ngModule')) {\n        recursivelyAddModules(entry.get('ngModule')!);\n      }\n    } else if ((entry instanceof Reference) && hasIdentifier(entry.node)) {\n      const filePath = entry.node.getSourceFile().fileName;\n      const moduleName = entry.node.name.text;\n      candidateModuleKeys.push(entryPointKeyFor(filePath, moduleName));\n    }\n  }\n\n  recursivelyAddModules(entries);\n  return candidateModuleKeys;\n}\n\nexport function scanForRouteEntryPoints(\n    ngModule: ts.SourceFile, moduleName: string, data: NgModuleRawRouteData,\n    entryPointManager: RouterEntryPointManager, evaluator: PartialEvaluator): LazyRouteEntry[] {\n  const loadChildrenIdentifiers: string[] = [];\n  const from = entryPointManager.fromNgModule(ngModule, moduleName);\n  if (data.providers !== null) {\n    loadChildrenIdentifiers.push(...scanForProviders(data.providers, evaluator));\n  }\n  if (data.imports !== null) {\n    loadChildrenIdentifiers.push(...scanForRouterModuleUsage(data.imports, evaluator));\n  }\n  if (data.exports !== null) {\n    loadChildrenIdentifiers.push(...scanForRouterModuleUsage(data.exports, evaluator));\n  }\n  const routes: LazyRouteEntry[] = [];\n  for (const loadChildren of loadChildrenIdentifiers) {\n    const resolvedTo = entryPointManager.resolveLoadChildrenIdentifier(loadChildren, ngModule);\n    if (resolvedTo !== null) {\n      routes.push({\n        loadChildren,\n        from,\n        resolvedTo,\n      });\n    }\n  }\n  return routes;\n}\n\nfunction scanForProviders(expr: ts.Expression, evaluator: PartialEvaluator): string[] {\n  const loadChildrenIdentifiers: string[] = [];\n  const providers = evaluator.evaluate(expr);\n\n  function recursivelyAddProviders(provider: ResolvedValue): void {\n    if (Array.isArray(provider)) {\n      for (const entry of provider) {\n        recursivelyAddProviders(entry);\n      }\n    } else if (provider instanceof Map) {\n      if (provider.has('provide') && provider.has('useValue')) {\n        const provide = provider.get('provide');\n        const useValue = provider.get('useValue');\n        if (isRouteToken(provide) && Array.isArray(useValue)) {\n          loadChildrenIdentifiers.push(...scanForLazyRoutes(useValue));\n        }\n      }\n    }\n  }\n\n  recursivelyAddProviders(providers);\n  return loadChildrenIdentifiers;\n}\n\nfunction scanForRouterModuleUsage(expr: ts.Expression, evaluator: PartialEvaluator): string[] {\n  const loadChildrenIdentifiers: string[] = [];\n  const imports = evaluator.evaluate(expr, routerModuleFFR);\n\n  function recursivelyAddRoutes(imp: ResolvedValue) {\n    if (Array.isArray(imp)) {\n      for (const entry of imp) {\n        recursivelyAddRoutes(entry);\n      }\n    } else if (imp instanceof Map) {\n      if (imp.has(ROUTES_MARKER) && imp.has('routes')) {\n        const routes = imp.get('routes');\n        if (Array.isArray(routes)) {\n          loadChildrenIdentifiers.push(...scanForLazyRoutes(routes));\n        }\n      }\n    }\n  }\n\n  recursivelyAddRoutes(imports);\n  return loadChildrenIdentifiers;\n}\n\nfunction scanForLazyRoutes(routes: ResolvedValue[]): string[] {\n  const loadChildrenIdentifiers: string[] = [];\n\n  function recursivelyScanRoutes(routes: ResolvedValue[]): void {\n    for (let route of routes) {\n      if (!(route instanceof Map)) {\n        continue;\n      }\n      if (route.has('loadChildren')) {\n        const loadChildren = route.get('loadChildren');\n        if (typeof loadChildren === 'string') {\n          loadChildrenIdentifiers.push(loadChildren);\n        }\n      } else if (route.has('children')) {\n        const children = route.get('children');\n        if (Array.isArray(children)) {\n          recursivelyScanRoutes(children);\n        }\n      }\n    }\n  }\n\n  recursivelyScanRoutes(routes);\n  return loadChildrenIdentifiers;\n}\n\n/**\n * A foreign function resolver that converts `RouterModule.forRoot/forChild(X)` to a special object\n * of the form `{__ngRoutesMarker__: true, routes: X}`.\n *\n * These objects are then recognizable inside the larger set of imports/exports.\n */\nconst routerModuleFFR: ForeignFunctionResolver =\n    function routerModuleFFR(\n        ref: Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression>,\n        args: ReadonlyArray<ts.Expression>): ts.Expression|null {\n  if (!isMethodNodeReference(ref) || !ts.isClassDeclaration(ref.node.parent)) {\n    return null;\n  } else if (\n      ref.bestGuessOwningModule === null ||\n      ref.bestGuessOwningModule.specifier !== '@angular/router') {\n    return null;\n  } else if (ref.node.parent.name === undefined || ref.node.parent.name.text !== 'RouterModule') {\n    return null;\n  } else if (\n      !ts.isIdentifier(ref.node.name) ||\n      (ref.node.name.text !== 'forRoot' && ref.node.name.text !== 'forChild')) {\n    return null;\n  }\n\n  const routes = args[0];\n  return ts.createObjectLiteral([\n    ts.createPropertyAssignment(ROUTES_MARKER, ts.createTrue()),\n    ts.createPropertyAssignment('routes', routes),\n  ]);\n};\n\nfunction hasIdentifier(node: ts.Node): node is ts.Node&{name: ts.Identifier} {\n  const node_ = node as ts.NamedDeclaration;\n  return (node_.name !== undefined) && ts.isIdentifier(node_.name);\n}\n\nfunction isMethodNodeReference(\n    ref: Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression>):\n    ref is Reference<ts.MethodDeclaration> {\n  return ts.isMethodDeclaration(ref.node);\n}\n\nfunction isRouteToken(ref: ResolvedValue): boolean {\n  return ref instanceof Reference && ref.bestGuessOwningModule !== null &&\n      ref.bestGuessOwningModule.specifier === '@angular/router' && ref.debugName === 'ROUTES';\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}