{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/result\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.KnownFn = exports.EnumValue = exports.ResolvedModule = void 0;\n  /**\n   * A collection of publicly exported declarations from a module. Each declaration is evaluated\n   * lazily upon request.\n   */\n\n  var ResolvedModule =\n  /** @class */\n  function () {\n    function ResolvedModule(exports, evaluate) {\n      this.exports = exports;\n      this.evaluate = evaluate;\n    }\n\n    ResolvedModule.prototype.getExport = function (name) {\n      if (!this.exports.has(name)) {\n        return undefined;\n      }\n\n      return this.evaluate(this.exports.get(name));\n    };\n\n    ResolvedModule.prototype.getExports = function () {\n      var _this = this;\n\n      var map = new Map();\n      this.exports.forEach(function (decl, name) {\n        map.set(name, _this.evaluate(decl));\n      });\n      return map;\n    };\n\n    return ResolvedModule;\n  }();\n\n  exports.ResolvedModule = ResolvedModule;\n  /**\n   * A value member of an enumeration.\n   *\n   * Contains a `Reference` to the enumeration itself, and the name of the referenced member.\n   */\n\n  var EnumValue =\n  /** @class */\n  function () {\n    function EnumValue(enumRef, name, resolved) {\n      this.enumRef = enumRef;\n      this.name = name;\n      this.resolved = resolved;\n    }\n\n    return EnumValue;\n  }();\n\n  exports.EnumValue = EnumValue;\n  /**\n   * An implementation of a known function that can be statically evaluated.\n   * It could be a built-in function or method (such as `Array.prototype.slice`) or a TypeScript\n   * helper (such as `__spread`).\n   */\n\n  var KnownFn =\n  /** @class */\n  function () {\n    function KnownFn() {}\n\n    return KnownFn;\n  }();\n\n  exports.KnownFn = KnownFn;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/result.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;AAoCH;;;AAGG;;AACH,MAAA,cAAA;AAAA;AAAA,cAAA;AACE,aAAA,cAAA,CACY,OADZ,EAEY,QAFZ,EAE0D;AAD9C,WAAA,OAAA,GAAA,OAAA;AACA,WAAA,QAAA,GAAA,QAAA;AAAkD;;AAE9D,IAAA,cAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,IAAV,EAAsB;AACpB,UAAI,CAAC,KAAK,OAAL,CAAa,GAAb,CAAiB,IAAjB,CAAL,EAA6B;AAC3B,eAAO,SAAP;AACD;;AAED,aAAO,KAAK,QAAL,CAAc,KAAK,OAAL,CAAa,GAAb,CAAiB,IAAjB,CAAd,CAAP;AACD,KAND;;AAQA,IAAA,cAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AAAA,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,GAAG,GAAG,IAAI,GAAJ,EAAZ;AACA,WAAK,OAAL,CAAa,OAAb,CAAqB,UAAC,IAAD,EAAO,IAAP,EAAW;AAC9B,QAAA,GAAG,CAAC,GAAJ,CAAQ,IAAR,EAAc,KAAI,CAAC,QAAL,CAAc,IAAd,CAAd;AACD,OAFD;AAGA,aAAO,GAAP;AACD,KAND;;AAOF,WAAA,cAAA;AAAC,GApBD,EAAA;;AAAa,EAAA,OAAA,CAAA,cAAA,GAAA,cAAA;AAsBb;;;;AAIG;;AACH,MAAA,SAAA;AAAA;AAAA,cAAA;AACE,aAAA,SAAA,CACa,OADb,EAC0D,IAD1D,EAEa,QAFb,EAEoC;AADvB,WAAA,OAAA,GAAA,OAAA;AAA6C,WAAA,IAAA,GAAA,IAAA;AAC7C,WAAA,QAAA,GAAA,QAAA;AAA2B;;AAC1C,WAAA,SAAA;AAAC,GAJD,EAAA;;AAAa,EAAA,OAAA,CAAA,SAAA,GAAA,SAAA;AAMb;;;;AAIG;;AACH,MAAA,OAAA;AAAA;AAAA,cAAA;AAAA,aAAA,OAAA,GAAA,CAEC;;AAAD,WAAA,OAAA;AAAC,GAFD,EAAA;;AAAsB,EAAA,OAAA,CAAA,OAAA,GAAA,OAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {Declaration} from '../../reflection';\n\nimport {DynamicValue} from './dynamic';\n\n\n/**\n * A value resulting from static resolution.\n *\n * This could be a primitive, collection type, reference to a `ts.Node` that declares a\n * non-primitive value, or a special `DynamicValue` type which indicates the value was not\n * available statically.\n */\nexport type ResolvedValue = number|boolean|string|null|undefined|Reference|EnumValue|\n    ResolvedValueArray|ResolvedValueMap|ResolvedModule|KnownFn|DynamicValue<unknown>;\n\n/**\n * An array of `ResolvedValue`s.\n *\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueArray`\n * -> `ResolvedValue`.\n */\nexport interface ResolvedValueArray extends Array<ResolvedValue> {}\n\n/**\n * A map of strings to `ResolvedValue`s.\n *\n * This is a reified type to allow the circular reference of `ResolvedValue` -> `ResolvedValueMap`\n * -> `ResolvedValue`.\n */\nexport interface ResolvedValueMap extends Map<string, ResolvedValue> {}\n\n/**\n * A collection of publicly exported declarations from a module. Each declaration is evaluated\n * lazily upon request.\n */\nexport class ResolvedModule {\n  constructor(\n      private exports: Map<string, Declaration>,\n      private evaluate: (decl: Declaration) => ResolvedValue) {}\n\n  getExport(name: string): ResolvedValue {\n    if (!this.exports.has(name)) {\n      return undefined;\n    }\n\n    return this.evaluate(this.exports.get(name)!);\n  }\n\n  getExports(): ResolvedValueMap {\n    const map = new Map<string, ResolvedValue>();\n    this.exports.forEach((decl, name) => {\n      map.set(name, this.evaluate(decl));\n    });\n    return map;\n  }\n}\n\n/**\n * A value member of an enumeration.\n *\n * Contains a `Reference` to the enumeration itself, and the name of the referenced member.\n */\nexport class EnumValue {\n  constructor(\n      readonly enumRef: Reference<ts.Declaration>, readonly name: string,\n      readonly resolved: ResolvedValue) {}\n}\n\n/**\n * An implementation of a known function that can be statically evaluated.\n * It could be a built-in function or method (such as `Array.prototype.slice`) or a TypeScript\n * helper (such as `__spread`).\n */\nexport abstract class KnownFn {\n  abstract evaluate(node: ts.CallExpression, args: ResolvedValueArray): ResolvedValue;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}