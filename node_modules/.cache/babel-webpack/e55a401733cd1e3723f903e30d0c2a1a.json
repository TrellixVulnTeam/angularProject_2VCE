{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/output/ts_emitter\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/output/abstract_emitter\", \"@angular/compiler/src/output/output_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeScriptEmitter = exports.debugOutputAstAsTypeScript = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var abstract_emitter_1 = require(\"@angular/compiler/src/output/abstract_emitter\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  function debugOutputAstAsTypeScript(ast) {\n    var converter = new _TsEmitterVisitor();\n    var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot();\n    var asts = Array.isArray(ast) ? ast : [ast];\n    asts.forEach(function (ast) {\n      if (ast instanceof o.Statement) {\n        ast.visitStatement(converter, ctx);\n      } else if (ast instanceof o.Expression) {\n        ast.visitExpression(converter, ctx);\n      } else if (ast instanceof o.Type) {\n        ast.visitType(converter, ctx);\n      } else {\n        throw new Error(\"Don't know how to print debug info for \" + ast);\n      }\n    });\n    return ctx.toSource();\n  }\n\n  exports.debugOutputAstAsTypeScript = debugOutputAstAsTypeScript;\n\n  var TypeScriptEmitter =\n  /** @class */\n  function () {\n    function TypeScriptEmitter() {}\n\n    TypeScriptEmitter.prototype.emitStatementsAndContext = function (genFilePath, stmts, preamble, emitSourceMaps, referenceFilter, importFilter) {\n      if (preamble === void 0) {\n        preamble = '';\n      }\n\n      if (emitSourceMaps === void 0) {\n        emitSourceMaps = true;\n      }\n\n      var converter = new _TsEmitterVisitor(referenceFilter, importFilter);\n      var ctx = abstract_emitter_1.EmitterVisitorContext.createRoot();\n      converter.visitAllStatements(stmts, ctx);\n      var preambleLines = preamble ? preamble.split('\\n') : [];\n      converter.reexports.forEach(function (reexports, exportedModuleName) {\n        var reexportsCode = reexports.map(function (reexport) {\n          return reexport.name + \" as \" + reexport.as;\n        }).join(',');\n        preambleLines.push(\"export {\" + reexportsCode + \"} from '\" + exportedModuleName + \"';\");\n      });\n      converter.importsWithPrefixes.forEach(function (prefix, importedModuleName) {\n        // Note: can't write the real word for import as it screws up system.js auto detection...\n        preambleLines.push(\"imp\" + (\"ort * as \" + prefix + \" from '\" + importedModuleName + \"';\"));\n      });\n      var sm = emitSourceMaps ? ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() : '';\n\n      var lines = tslib_1.__spread(preambleLines, [ctx.toSource(), sm]);\n\n      if (sm) {\n        // always add a newline at the end, as some tools have bugs without it.\n        lines.push('');\n      }\n\n      ctx.setPreambleLineCount(preambleLines.length);\n      return {\n        sourceText: lines.join('\\n'),\n        context: ctx\n      };\n    };\n\n    TypeScriptEmitter.prototype.emitStatements = function (genFilePath, stmts, preamble) {\n      if (preamble === void 0) {\n        preamble = '';\n      }\n\n      return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;\n    };\n\n    return TypeScriptEmitter;\n  }();\n\n  exports.TypeScriptEmitter = TypeScriptEmitter;\n\n  var _TsEmitterVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(_TsEmitterVisitor, _super);\n\n    function _TsEmitterVisitor(referenceFilter, importFilter) {\n      var _this = _super.call(this, false) || this;\n\n      _this.referenceFilter = referenceFilter;\n      _this.importFilter = importFilter;\n      _this.typeExpression = 0;\n      _this.importsWithPrefixes = new Map();\n      _this.reexports = new Map();\n      return _this;\n    }\n\n    _TsEmitterVisitor.prototype.visitType = function (t, ctx, defaultType) {\n      if (defaultType === void 0) {\n        defaultType = 'any';\n      }\n\n      if (t) {\n        this.typeExpression++;\n        t.visitType(this, ctx);\n        this.typeExpression--;\n      } else {\n        ctx.print(null, defaultType);\n      }\n    };\n\n    _TsEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n      var value = ast.value;\n\n      if (value == null && ast.type != o.INFERRED_TYPE) {\n        ctx.print(ast, \"(\" + value + \" as any)\");\n        return null;\n      }\n\n      return _super.prototype.visitLiteralExpr.call(this, ast, ctx);\n    }; // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.\n    // In SNC mode, [] have the type never[], so we cast here to any[].\n    // TODO: narrow the cast to a more explicit type, or use a pattern that does not\n    // start with [].concat. see https://github.com/angular/angular/pull/11846\n\n\n    _TsEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n      if (ast.entries.length === 0) {\n        ctx.print(ast, '(');\n      }\n\n      var result = _super.prototype.visitLiteralArrayExpr.call(this, ast, ctx);\n\n      if (ast.entries.length === 0) {\n        ctx.print(ast, ' as any[])');\n      }\n\n      return result;\n    };\n\n    _TsEmitterVisitor.prototype.visitExternalExpr = function (ast, ctx) {\n      this._visitIdentifier(ast.value, ast.typeParams, ctx);\n\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n      var result = _super.prototype.visitAssertNotNullExpr.call(this, ast, ctx);\n\n      ctx.print(ast, '!');\n      return result;\n    };\n\n    _TsEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n      if (stmt.hasModifier(o.StmtModifier.Exported) && stmt.value instanceof o.ExternalExpr && !stmt.type) {\n        // check for a reexport\n        var _a = stmt.value.value,\n            name_1 = _a.name,\n            moduleName = _a.moduleName;\n\n        if (moduleName) {\n          var reexports = this.reexports.get(moduleName);\n\n          if (!reexports) {\n            reexports = [];\n            this.reexports.set(moduleName, reexports);\n          }\n\n          reexports.push({\n            name: name_1,\n            as: stmt.name\n          });\n          return null;\n        }\n      }\n\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        ctx.print(stmt, \"export \");\n      }\n\n      if (stmt.hasModifier(o.StmtModifier.Final)) {\n        ctx.print(stmt, \"const\");\n      } else {\n        ctx.print(stmt, \"var\");\n      }\n\n      ctx.print(stmt, \" \" + stmt.name);\n\n      this._printColonType(stmt.type, ctx);\n\n      if (stmt.value) {\n        ctx.print(stmt, \" = \");\n        stmt.value.visitExpression(this, ctx);\n      }\n\n      ctx.println(stmt, \";\");\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n      throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');\n    };\n\n    _TsEmitterVisitor.prototype.visitCastExpr = function (ast, ctx) {\n      ctx.print(ast, \"(<\");\n      ast.type.visitType(this, ctx);\n      ctx.print(ast, \">\");\n      ast.value.visitExpression(this, ctx);\n      ctx.print(ast, \")\");\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n      ctx.print(ast, \"new \");\n      this.typeExpression++;\n      ast.classExpr.visitExpression(this, ctx);\n      this.typeExpression--;\n      ctx.print(ast, \"(\");\n      this.visitAllExpressions(ast.args, ctx, ',');\n      ctx.print(ast, \")\");\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n      var _this = this;\n\n      ctx.pushClass(stmt);\n\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        ctx.print(stmt, \"export \");\n      }\n\n      ctx.print(stmt, \"class \" + stmt.name);\n\n      if (stmt.parent != null) {\n        ctx.print(stmt, \" extends \");\n        this.typeExpression++;\n        stmt.parent.visitExpression(this, ctx);\n        this.typeExpression--;\n      }\n\n      ctx.println(stmt, \" {\");\n      ctx.incIndent();\n      stmt.fields.forEach(function (field) {\n        return _this._visitClassField(field, ctx);\n      });\n\n      if (stmt.constructorMethod != null) {\n        this._visitClassConstructor(stmt, ctx);\n      }\n\n      stmt.getters.forEach(function (getter) {\n        return _this._visitClassGetter(getter, ctx);\n      });\n      stmt.methods.forEach(function (method) {\n        return _this._visitClassMethod(method, ctx);\n      });\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      ctx.popClass();\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype._visitClassField = function (field, ctx) {\n      if (field.hasModifier(o.StmtModifier.Private)) {\n        // comment out as a workaround for #10967\n        ctx.print(null, \"/*private*/ \");\n      }\n\n      if (field.hasModifier(o.StmtModifier.Static)) {\n        ctx.print(null, 'static ');\n      }\n\n      ctx.print(null, field.name);\n\n      this._printColonType(field.type, ctx);\n\n      if (field.initializer) {\n        ctx.print(null, ' = ');\n        field.initializer.visitExpression(this, ctx);\n      }\n\n      ctx.println(null, \";\");\n    };\n\n    _TsEmitterVisitor.prototype._visitClassGetter = function (getter, ctx) {\n      if (getter.hasModifier(o.StmtModifier.Private)) {\n        ctx.print(null, \"private \");\n      }\n\n      ctx.print(null, \"get \" + getter.name + \"()\");\n\n      this._printColonType(getter.type, ctx);\n\n      ctx.println(null, \" {\");\n      ctx.incIndent();\n      this.visitAllStatements(getter.body, ctx);\n      ctx.decIndent();\n      ctx.println(null, \"}\");\n    };\n\n    _TsEmitterVisitor.prototype._visitClassConstructor = function (stmt, ctx) {\n      ctx.print(stmt, \"constructor(\");\n\n      this._visitParams(stmt.constructorMethod.params, ctx);\n\n      ctx.println(stmt, \") {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.constructorMethod.body, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n    };\n\n    _TsEmitterVisitor.prototype._visitClassMethod = function (method, ctx) {\n      if (method.hasModifier(o.StmtModifier.Private)) {\n        ctx.print(null, \"private \");\n      }\n\n      ctx.print(null, method.name + \"(\");\n\n      this._visitParams(method.params, ctx);\n\n      ctx.print(null, \")\");\n\n      this._printColonType(method.type, ctx, 'void');\n\n      ctx.println(null, \" {\");\n      ctx.incIndent();\n      this.visitAllStatements(method.body, ctx);\n      ctx.decIndent();\n      ctx.println(null, \"}\");\n    };\n\n    _TsEmitterVisitor.prototype.visitFunctionExpr = function (ast, ctx) {\n      if (ast.name) {\n        ctx.print(ast, 'function ');\n        ctx.print(ast, ast.name);\n      }\n\n      ctx.print(ast, \"(\");\n\n      this._visitParams(ast.params, ctx);\n\n      ctx.print(ast, \")\");\n\n      this._printColonType(ast.type, ctx, 'void');\n\n      if (!ast.name) {\n        ctx.print(ast, \" => \");\n      }\n\n      ctx.println(ast, '{');\n      ctx.incIndent();\n      this.visitAllStatements(ast.statements, ctx);\n      ctx.decIndent();\n      ctx.print(ast, \"}\");\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        ctx.print(stmt, \"export \");\n      }\n\n      ctx.print(stmt, \"function \" + stmt.name + \"(\");\n\n      this._visitParams(stmt.params, ctx);\n\n      ctx.print(stmt, \")\");\n\n      this._printColonType(stmt.type, ctx, 'void');\n\n      ctx.println(stmt, \" {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.statements, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitTryCatchStmt = function (stmt, ctx) {\n      ctx.println(stmt, \"try {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.bodyStmts, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"} catch (\" + abstract_emitter_1.CATCH_ERROR_VAR.name + \") {\");\n      ctx.incIndent();\n      var catchStmts = [abstract_emitter_1.CATCH_STACK_VAR.set(abstract_emitter_1.CATCH_ERROR_VAR.prop('stack', null)).toDeclStmt(null, [o.StmtModifier.Final])].concat(stmt.catchStmts);\n      this.visitAllStatements(catchStmts, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitBuiltinType = function (type, ctx) {\n      var typeStr;\n\n      switch (type.name) {\n        case o.BuiltinTypeName.Bool:\n          typeStr = 'boolean';\n          break;\n\n        case o.BuiltinTypeName.Dynamic:\n          typeStr = 'any';\n          break;\n\n        case o.BuiltinTypeName.Function:\n          typeStr = 'Function';\n          break;\n\n        case o.BuiltinTypeName.Number:\n          typeStr = 'number';\n          break;\n\n        case o.BuiltinTypeName.Int:\n          typeStr = 'number';\n          break;\n\n        case o.BuiltinTypeName.String:\n          typeStr = 'string';\n          break;\n\n        case o.BuiltinTypeName.None:\n          typeStr = 'never';\n          break;\n\n        default:\n          throw new Error(\"Unsupported builtin type \" + type.name);\n      }\n\n      ctx.print(null, typeStr);\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitExpressionType = function (ast, ctx) {\n      var _this = this;\n\n      ast.value.visitExpression(this, ctx);\n\n      if (ast.typeParams !== null) {\n        ctx.print(null, '<');\n        this.visitAllObjects(function (type) {\n          return _this.visitType(type, ctx);\n        }, ast.typeParams, ctx, ',');\n        ctx.print(null, '>');\n      }\n\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitArrayType = function (type, ctx) {\n      this.visitType(type.of, ctx);\n      ctx.print(null, \"[]\");\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.visitMapType = function (type, ctx) {\n      ctx.print(null, \"{[key: string]:\");\n      this.visitType(type.valueType, ctx);\n      ctx.print(null, \"}\");\n      return null;\n    };\n\n    _TsEmitterVisitor.prototype.getBuiltinMethodName = function (method) {\n      var name;\n\n      switch (method) {\n        case o.BuiltinMethod.ConcatArray:\n          name = 'concat';\n          break;\n\n        case o.BuiltinMethod.SubscribeObservable:\n          name = 'subscribe';\n          break;\n\n        case o.BuiltinMethod.Bind:\n          name = 'bind';\n          break;\n\n        default:\n          throw new Error(\"Unknown builtin method: \" + method);\n      }\n\n      return name;\n    };\n\n    _TsEmitterVisitor.prototype._visitParams = function (params, ctx) {\n      var _this = this;\n\n      this.visitAllObjects(function (param) {\n        ctx.print(null, param.name);\n\n        _this._printColonType(param.type, ctx);\n      }, params, ctx, ',');\n    };\n\n    _TsEmitterVisitor.prototype._visitIdentifier = function (value, typeParams, ctx) {\n      var _this = this;\n\n      var name = value.name,\n          moduleName = value.moduleName;\n\n      if (this.referenceFilter && this.referenceFilter(value)) {\n        ctx.print(null, '(null as any)');\n        return;\n      }\n\n      if (moduleName && (!this.importFilter || !this.importFilter(value))) {\n        var prefix = this.importsWithPrefixes.get(moduleName);\n\n        if (prefix == null) {\n          prefix = \"i\" + this.importsWithPrefixes.size;\n          this.importsWithPrefixes.set(moduleName, prefix);\n        }\n\n        ctx.print(null, prefix + \".\");\n      }\n\n      ctx.print(null, name);\n\n      if (this.typeExpression > 0) {\n        // If we are in a type expression that refers to a generic type then supply\n        // the required type parameters. If there were not enough type parameters\n        // supplied, supply any as the type. Outside a type expression the reference\n        // should not supply type parameters and be treated as a simple value reference\n        // to the constructor function itself.\n        var suppliedParameters = typeParams || [];\n\n        if (suppliedParameters.length > 0) {\n          ctx.print(null, \"<\");\n          this.visitAllObjects(function (type) {\n            return type.visitType(_this, ctx);\n          }, typeParams, ctx, ',');\n          ctx.print(null, \">\");\n        }\n      }\n    };\n\n    _TsEmitterVisitor.prototype._printColonType = function (type, ctx, defaultType) {\n      if (type !== o.INFERRED_TYPE) {\n        ctx.print(null, ':');\n        this.visitType(type, ctx, defaultType);\n      }\n    };\n\n    return _TsEmitterVisitor;\n  }(abstract_emitter_1.AbstractEmitterVisitor);\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/output/ts_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbstractEmitterVisitor, CATCH_ERROR_VAR, CATCH_STACK_VAR, EmitterVisitorContext, OutputEmitter} from './abstract_emitter';\nimport * as o from './output_ast';\n\nexport function debugOutputAstAsTypeScript(ast: o.Statement|o.Expression|o.Type|any[]): string {\n  const converter = new _TsEmitterVisitor();\n  const ctx = EmitterVisitorContext.createRoot();\n  const asts: any[] = Array.isArray(ast) ? ast : [ast];\n\n  asts.forEach((ast) => {\n    if (ast instanceof o.Statement) {\n      ast.visitStatement(converter, ctx);\n    } else if (ast instanceof o.Expression) {\n      ast.visitExpression(converter, ctx);\n    } else if (ast instanceof o.Type) {\n      ast.visitType(converter, ctx);\n    } else {\n      throw new Error(`Don't know how to print debug info for ${ast}`);\n    }\n  });\n  return ctx.toSource();\n}\n\nexport type ReferenceFilter = (reference: o.ExternalReference) => boolean;\n\nexport class TypeScriptEmitter implements OutputEmitter {\n  emitStatementsAndContext(\n      genFilePath: string, stmts: o.Statement[], preamble: string = '',\n      emitSourceMaps: boolean = true, referenceFilter?: ReferenceFilter,\n      importFilter?: ReferenceFilter): {sourceText: string, context: EmitterVisitorContext} {\n    const converter = new _TsEmitterVisitor(referenceFilter, importFilter);\n\n    const ctx = EmitterVisitorContext.createRoot();\n\n    converter.visitAllStatements(stmts, ctx);\n\n    const preambleLines = preamble ? preamble.split('\\n') : [];\n    converter.reexports.forEach((reexports, exportedModuleName) => {\n      const reexportsCode =\n          reexports.map(reexport => `${reexport.name} as ${reexport.as}`).join(',');\n      preambleLines.push(`export {${reexportsCode}} from '${exportedModuleName}';`);\n    });\n\n    converter.importsWithPrefixes.forEach((prefix, importedModuleName) => {\n      // Note: can't write the real word for import as it screws up system.js auto detection...\n      preambleLines.push(\n          `imp` +\n          `ort * as ${prefix} from '${importedModuleName}';`);\n    });\n\n    const sm = emitSourceMaps ?\n        ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() :\n        '';\n    const lines = [...preambleLines, ctx.toSource(), sm];\n    if (sm) {\n      // always add a newline at the end, as some tools have bugs without it.\n      lines.push('');\n    }\n    ctx.setPreambleLineCount(preambleLines.length);\n    return {sourceText: lines.join('\\n'), context: ctx};\n  }\n\n  emitStatements(genFilePath: string, stmts: o.Statement[], preamble: string = '') {\n    return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;\n  }\n}\n\n\nclass _TsEmitterVisitor extends AbstractEmitterVisitor implements o.TypeVisitor {\n  private typeExpression = 0;\n\n  constructor(private referenceFilter?: ReferenceFilter, private importFilter?: ReferenceFilter) {\n    super(false);\n  }\n\n  importsWithPrefixes = new Map<string, string>();\n  reexports = new Map<string, {name: string, as: string}[]>();\n\n  visitType(t: o.Type|null, ctx: EmitterVisitorContext, defaultType: string = 'any') {\n    if (t) {\n      this.typeExpression++;\n      t.visitType(this, ctx);\n      this.typeExpression--;\n    } else {\n      ctx.print(null, defaultType);\n    }\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (value == null && ast.type != o.INFERRED_TYPE) {\n      ctx.print(ast, `(${value} as any)`);\n      return null;\n    }\n    return super.visitLiteralExpr(ast, ctx);\n  }\n\n\n  // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.\n  // In SNC mode, [] have the type never[], so we cast here to any[].\n  // TODO: narrow the cast to a more explicit type, or use a pattern that does not\n  // start with [].concat. see https://github.com/angular/angular/pull/11846\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    if (ast.entries.length === 0) {\n      ctx.print(ast, '(');\n    }\n    const result = super.visitLiteralArrayExpr(ast, ctx);\n    if (ast.entries.length === 0) {\n      ctx.print(ast, ' as any[])');\n    }\n    return result;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n    this._visitIdentifier(ast.value, ast.typeParams, ctx);\n    return null;\n  }\n\n  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any {\n    const result = super.visitAssertNotNullExpr(ast, ctx);\n    ctx.print(ast, '!');\n    return result;\n  }\n\n  visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported) && stmt.value instanceof o.ExternalExpr &&\n        !stmt.type) {\n      // check for a reexport\n      const {name, moduleName} = stmt.value.value;\n      if (moduleName) {\n        let reexports = this.reexports.get(moduleName);\n        if (!reexports) {\n          reexports = [];\n          this.reexports.set(moduleName, reexports);\n        }\n        reexports.push({name: name!, as: stmt.name});\n        return null;\n      }\n    }\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      ctx.print(stmt, `export `);\n    }\n    if (stmt.hasModifier(o.StmtModifier.Final)) {\n      ctx.print(stmt, `const`);\n    } else {\n      ctx.print(stmt, `var`);\n    }\n    ctx.print(stmt, ` ${stmt.name}`);\n    this._printColonType(stmt.type, ctx);\n    if (stmt.value) {\n      ctx.print(stmt, ` = `);\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): never {\n    throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');\n  }\n\n  visitCastExpr(ast: o.CastExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(<`);\n    ast.type!.visitType(this, ctx);\n    ctx.print(ast, `>`);\n    ast.value.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    this.typeExpression++;\n    ast.classExpr.visitExpression(this, ctx);\n    this.typeExpression--;\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any {\n    ctx.pushClass(stmt);\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      ctx.print(stmt, `export `);\n    }\n    ctx.print(stmt, `class ${stmt.name}`);\n    if (stmt.parent != null) {\n      ctx.print(stmt, ` extends `);\n      this.typeExpression++;\n      stmt.parent.visitExpression(this, ctx);\n      this.typeExpression--;\n    }\n    ctx.println(stmt, ` {`);\n    ctx.incIndent();\n    stmt.fields.forEach((field) => this._visitClassField(field, ctx));\n    if (stmt.constructorMethod != null) {\n      this._visitClassConstructor(stmt, ctx);\n    }\n    stmt.getters.forEach((getter) => this._visitClassGetter(getter, ctx));\n    stmt.methods.forEach((method) => this._visitClassMethod(method, ctx));\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    ctx.popClass();\n    return null;\n  }\n\n  private _visitClassField(field: o.ClassField, ctx: EmitterVisitorContext) {\n    if (field.hasModifier(o.StmtModifier.Private)) {\n      // comment out as a workaround for #10967\n      ctx.print(null, `/*private*/ `);\n    }\n    if (field.hasModifier(o.StmtModifier.Static)) {\n      ctx.print(null, 'static ');\n    }\n    ctx.print(null, field.name);\n    this._printColonType(field.type, ctx);\n    if (field.initializer) {\n      ctx.print(null, ' = ');\n      field.initializer.visitExpression(this, ctx);\n    }\n    ctx.println(null, `;`);\n  }\n\n  private _visitClassGetter(getter: o.ClassGetter, ctx: EmitterVisitorContext) {\n    if (getter.hasModifier(o.StmtModifier.Private)) {\n      ctx.print(null, `private `);\n    }\n    ctx.print(null, `get ${getter.name}()`);\n    this._printColonType(getter.type, ctx);\n    ctx.println(null, ` {`);\n    ctx.incIndent();\n    this.visitAllStatements(getter.body, ctx);\n    ctx.decIndent();\n    ctx.println(null, `}`);\n  }\n\n  private _visitClassConstructor(stmt: o.ClassStmt, ctx: EmitterVisitorContext) {\n    ctx.print(stmt, `constructor(`);\n    this._visitParams(stmt.constructorMethod.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.constructorMethod.body, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n  }\n\n  private _visitClassMethod(method: o.ClassMethod, ctx: EmitterVisitorContext) {\n    if (method.hasModifier(o.StmtModifier.Private)) {\n      ctx.print(null, `private `);\n    }\n    ctx.print(null, `${method.name}(`);\n    this._visitParams(method.params, ctx);\n    ctx.print(null, `)`);\n    this._printColonType(method.type, ctx, 'void');\n    ctx.println(null, ` {`);\n    ctx.incIndent();\n    this.visitAllStatements(method.body, ctx);\n    ctx.decIndent();\n    ctx.println(null, `}`);\n  }\n\n  visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any {\n    if (ast.name) {\n      ctx.print(ast, 'function ');\n      ctx.print(ast, ast.name);\n    }\n    ctx.print(ast, `(`);\n    this._visitParams(ast.params, ctx);\n    ctx.print(ast, `)`);\n    this._printColonType(ast.type, ctx, 'void');\n    if (!ast.name) {\n      ctx.print(ast, ` => `);\n    }\n    ctx.println(ast, '{');\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n\n    return null;\n  }\n\n  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      ctx.print(stmt, `export `);\n    }\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.print(stmt, `)`);\n    this._printColonType(stmt.type, ctx, 'void');\n    ctx.println(stmt, ` {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any {\n    ctx.println(stmt, `try {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.bodyStmts, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `} catch (${CATCH_ERROR_VAR.name}) {`);\n    ctx.incIndent();\n    const catchStmts =\n        [<o.Statement>CATCH_STACK_VAR.set(CATCH_ERROR_VAR.prop('stack', null)).toDeclStmt(null, [\n          o.StmtModifier.Final\n        ])].concat(stmt.catchStmts);\n    this.visitAllStatements(catchStmts, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  visitBuiltinType(type: o.BuiltinType, ctx: EmitterVisitorContext): any {\n    let typeStr: string;\n    switch (type.name) {\n      case o.BuiltinTypeName.Bool:\n        typeStr = 'boolean';\n        break;\n      case o.BuiltinTypeName.Dynamic:\n        typeStr = 'any';\n        break;\n      case o.BuiltinTypeName.Function:\n        typeStr = 'Function';\n        break;\n      case o.BuiltinTypeName.Number:\n        typeStr = 'number';\n        break;\n      case o.BuiltinTypeName.Int:\n        typeStr = 'number';\n        break;\n      case o.BuiltinTypeName.String:\n        typeStr = 'string';\n        break;\n      case o.BuiltinTypeName.None:\n        typeStr = 'never';\n        break;\n      default:\n        throw new Error(`Unsupported builtin type ${type.name}`);\n    }\n    ctx.print(null, typeStr);\n    return null;\n  }\n\n  visitExpressionType(ast: o.ExpressionType, ctx: EmitterVisitorContext): any {\n    ast.value.visitExpression(this, ctx);\n    if (ast.typeParams !== null) {\n      ctx.print(null, '<');\n      this.visitAllObjects(type => this.visitType(type, ctx), ast.typeParams, ctx, ',');\n      ctx.print(null, '>');\n    }\n    return null;\n  }\n\n  visitArrayType(type: o.ArrayType, ctx: EmitterVisitorContext): any {\n    this.visitType(type.of, ctx);\n    ctx.print(null, `[]`);\n    return null;\n  }\n\n  visitMapType(type: o.MapType, ctx: EmitterVisitorContext): any {\n    ctx.print(null, `{[key: string]:`);\n    this.visitType(type.valueType, ctx);\n    ctx.print(null, `}`);\n    return null;\n  }\n\n  getBuiltinMethodName(method: o.BuiltinMethod): string {\n    let name: string;\n    switch (method) {\n      case o.BuiltinMethod.ConcatArray:\n        name = 'concat';\n        break;\n      case o.BuiltinMethod.SubscribeObservable:\n        name = 'subscribe';\n        break;\n      case o.BuiltinMethod.Bind:\n        name = 'bind';\n        break;\n      default:\n        throw new Error(`Unknown builtin method: ${method}`);\n    }\n    return name;\n  }\n\n  private _visitParams(params: o.FnParam[], ctx: EmitterVisitorContext): void {\n    this.visitAllObjects(param => {\n      ctx.print(null, param.name);\n      this._printColonType(param.type, ctx);\n    }, params, ctx, ',');\n  }\n\n  private _visitIdentifier(\n      value: o.ExternalReference, typeParams: o.Type[]|null, ctx: EmitterVisitorContext): void {\n    const {name, moduleName} = value;\n    if (this.referenceFilter && this.referenceFilter(value)) {\n      ctx.print(null, '(null as any)');\n      return;\n    }\n    if (moduleName && (!this.importFilter || !this.importFilter(value))) {\n      let prefix = this.importsWithPrefixes.get(moduleName);\n      if (prefix == null) {\n        prefix = `i${this.importsWithPrefixes.size}`;\n        this.importsWithPrefixes.set(moduleName, prefix);\n      }\n      ctx.print(null, `${prefix}.`);\n    }\n    ctx.print(null, name!);\n\n    if (this.typeExpression > 0) {\n      // If we are in a type expression that refers to a generic type then supply\n      // the required type parameters. If there were not enough type parameters\n      // supplied, supply any as the type. Outside a type expression the reference\n      // should not supply type parameters and be treated as a simple value reference\n      // to the constructor function itself.\n      const suppliedParameters = typeParams || [];\n      if (suppliedParameters.length > 0) {\n        ctx.print(null, `<`);\n        this.visitAllObjects(type => type.visitType(this, ctx), typeParams!, ctx, ',');\n        ctx.print(null, `>`);\n      }\n    }\n  }\n\n  private _printColonType(type: o.Type|null, ctx: EmitterVisitorContext, defaultType?: string) {\n    if (type !== o.INFERRED_TYPE) {\n      ctx.print(null, ':');\n      this.visitType(type, ctx, defaultType);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}