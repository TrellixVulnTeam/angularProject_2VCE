{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ngcLoader = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: fix typings.\n// tslint:disable-next-line:no-global-tslint-disable\n// tslint:disable:no-any\n\nvar path = require(\"path\");\n\nvar angular_compiler_plugin_1 = require(\"./angular_compiler_plugin\");\n\nvar benchmark_1 = require(\"./benchmark\");\n\nvar sourceMappingUrlRe = /^\\/\\/# sourceMappingURL=[^\\r\\n]*/gm;\n\nfunction ngcLoader() {\n  var _this = this;\n\n  var cb = this.async();\n  var sourceFileName = this.resourcePath;\n  var timeLabel = \"ngcLoader+\".concat(sourceFileName, \"+\");\n\n  if (!cb) {\n    throw new Error('This loader needs to support asynchronous webpack compilations.');\n  }\n\n  benchmark_1.time(timeLabel);\n  var plugin = this._compilation._ngToolsWebpackPluginInstance;\n\n  if (!plugin) {\n    throw new Error('The AngularCompilerPlugin was not found. ' + 'The @ngtools/webpack loader requires the plugin.');\n  } // We must verify that the plugin is an instance of the right class.\n  // Throw an error if it isn't, that often means multiple @ngtools/webpack installs.\n\n\n  if (!(plugin instanceof angular_compiler_plugin_1.AngularCompilerPlugin) || !plugin.done) {\n    throw new Error('Angular Compiler was detected but it was an instance of the wrong class.\\n' + 'This likely means you have several @ngtools/webpack packages installed. ' + 'You can check this with `npm ls @ngtools/webpack`, and then remove the extra copies.');\n  }\n\n  benchmark_1.time(timeLabel + '.ngcLoader.AngularCompilerPlugin');\n  plugin.done.then(function () {\n    benchmark_1.timeEnd(timeLabel + '.ngcLoader.AngularCompilerPlugin');\n    var result = plugin.getCompiledFile(sourceFileName);\n\n    if (result.sourceMap) {\n      // Process sourcemaps for Webpack.\n      // Remove the sourceMappingURL.\n      result.outputText = result.outputText.replace(sourceMappingUrlRe, ''); // Set the map source to use the full path of the file.\n\n      var sourceMap = JSON.parse(result.sourceMap);\n      sourceMap.sources = sourceMap.sources.map(function (fileName) {\n        return path.join(path.dirname(sourceFileName), fileName);\n      });\n      result.sourceMap = sourceMap;\n    } // Manually add the dependencies for TS files.\n    // Type only imports will be stripped out by compilation so we need to add them as\n    // as dependencies.\n    // Component resources files (html and css templates) also need to be added manually for\n    // AOT, so that this file is reloaded when they change.\n\n\n    if (sourceFileName.endsWith('.ts')) {\n      result.errorDependencies.forEach(function (dep) {\n        return _this.addDependency(dep);\n      });\n      var dependencies = plugin.getDependencies(sourceFileName);\n      dependencies.filter(function (d) {\n        return d.endsWith('index.ts');\n      }).forEach(function (d) {\n        return dependencies.push.apply(dependencies, _toConsumableArray(plugin.getDependencies(d)));\n      });\n\n      _toConsumableArray(new Set(dependencies)).forEach(function (dep) {\n        plugin.updateChangedFileExtensions(path.extname(dep));\n\n        _this.addDependency(dep);\n      });\n    } // NgFactory files depend on the component template, but we can't know what that file\n    // is (if any). So we add all the dependencies that the original component file has\n    // to the factory as well, which includes html and css templates, and the component\n    // itself (for inline html/templates templates).\n\n\n    var ngFactoryRe = /\\.ngfactory.js$/;\n\n    if (ngFactoryRe.test(sourceFileName)) {\n      var originalFile = sourceFileName.replace(ngFactoryRe, '.ts');\n\n      _this.addDependency(originalFile);\n\n      var origDependencies = plugin.getDependencies(originalFile);\n      origDependencies.forEach(function (dep) {\n        return _this.addDependency(dep);\n      });\n    } // NgStyle files depend on the style file they represent.\n    // E.g. `some-style.less.shim.ngstyle.js` depends on `some-style.less`.\n    // Those files can in turn depend on others, so we have to add them all.\n\n\n    var ngStyleRe = /(?:\\.shim)?\\.ngstyle\\.js$/;\n\n    if (ngStyleRe.test(sourceFileName)) {\n      var styleFile = sourceFileName.replace(ngStyleRe, '');\n\n      var _iterator = _createForOfIteratorHelper(plugin.getResourceDependencies(styleFile)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dep = _step.value;\n\n          _this.addDependency(dep);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } // Add type-only dependencies that should trigger a rebuild when they change.\n\n\n    var typeDependencies = plugin.getTypeDependencies(sourceFileName);\n    typeDependencies.forEach(function (dep) {\n      return _this.addDependency(dep);\n    });\n    benchmark_1.timeEnd(timeLabel);\n    cb(null, result.outputText, result.sourceMap);\n  }).catch(function (err) {\n    benchmark_1.timeEnd(timeLabel);\n    cb(err);\n  });\n}\n\nexports.ngcLoader = ngcLoader;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/loader.js"],"names":["Object","defineProperty","exports","value","ngcLoader","path","require","angular_compiler_plugin_1","benchmark_1","sourceMappingUrlRe","cb","async","sourceFileName","resourcePath","timeLabel","Error","time","plugin","_compilation","_ngToolsWebpackPluginInstance","AngularCompilerPlugin","done","then","timeEnd","result","getCompiledFile","sourceMap","outputText","replace","JSON","parse","sources","map","fileName","join","dirname","endsWith","errorDependencies","forEach","dep","addDependency","dependencies","getDependencies","filter","d","push","Set","updateChangedFileExtensions","extname","ngFactoryRe","test","originalFile","origDependencies","ngStyleRe","styleFile","getResourceDependencies","typeDependencies","getTypeDependencies","catch","err"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ngcLoader = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: fix typings.\n// tslint:disable-next-line:no-global-tslint-disable\n// tslint:disable:no-any\nconst path = require(\"path\");\nconst angular_compiler_plugin_1 = require(\"./angular_compiler_plugin\");\nconst benchmark_1 = require(\"./benchmark\");\nconst sourceMappingUrlRe = /^\\/\\/# sourceMappingURL=[^\\r\\n]*/gm;\nfunction ngcLoader() {\n    const cb = this.async();\n    const sourceFileName = this.resourcePath;\n    const timeLabel = `ngcLoader+${sourceFileName}+`;\n    if (!cb) {\n        throw new Error('This loader needs to support asynchronous webpack compilations.');\n    }\n    benchmark_1.time(timeLabel);\n    const plugin = this._compilation\n        ._ngToolsWebpackPluginInstance;\n    if (!plugin) {\n        throw new Error('The AngularCompilerPlugin was not found. '\n            + 'The @ngtools/webpack loader requires the plugin.');\n    }\n    // We must verify that the plugin is an instance of the right class.\n    // Throw an error if it isn't, that often means multiple @ngtools/webpack installs.\n    if (!(plugin instanceof angular_compiler_plugin_1.AngularCompilerPlugin) || !plugin.done) {\n        throw new Error('Angular Compiler was detected but it was an instance of the wrong class.\\n'\n            + 'This likely means you have several @ngtools/webpack packages installed. '\n            + 'You can check this with `npm ls @ngtools/webpack`, and then remove the extra copies.');\n    }\n    benchmark_1.time(timeLabel + '.ngcLoader.AngularCompilerPlugin');\n    plugin.done\n        .then(() => {\n        benchmark_1.timeEnd(timeLabel + '.ngcLoader.AngularCompilerPlugin');\n        const result = plugin.getCompiledFile(sourceFileName);\n        if (result.sourceMap) {\n            // Process sourcemaps for Webpack.\n            // Remove the sourceMappingURL.\n            result.outputText = result.outputText.replace(sourceMappingUrlRe, '');\n            // Set the map source to use the full path of the file.\n            const sourceMap = JSON.parse(result.sourceMap);\n            sourceMap.sources = sourceMap.sources.map((fileName) => {\n                return path.join(path.dirname(sourceFileName), fileName);\n            });\n            result.sourceMap = sourceMap;\n        }\n        // Manually add the dependencies for TS files.\n        // Type only imports will be stripped out by compilation so we need to add them as\n        // as dependencies.\n        // Component resources files (html and css templates) also need to be added manually for\n        // AOT, so that this file is reloaded when they change.\n        if (sourceFileName.endsWith('.ts')) {\n            result.errorDependencies.forEach(dep => this.addDependency(dep));\n            const dependencies = plugin.getDependencies(sourceFileName);\n            dependencies\n                .filter(d => d.endsWith('index.ts'))\n                .forEach(d => dependencies.push(...plugin.getDependencies(d)));\n            [...new Set(dependencies)].forEach(dep => {\n                plugin.updateChangedFileExtensions(path.extname(dep));\n                this.addDependency(dep);\n            });\n        }\n        // NgFactory files depend on the component template, but we can't know what that file\n        // is (if any). So we add all the dependencies that the original component file has\n        // to the factory as well, which includes html and css templates, and the component\n        // itself (for inline html/templates templates).\n        const ngFactoryRe = /\\.ngfactory.js$/;\n        if (ngFactoryRe.test(sourceFileName)) {\n            const originalFile = sourceFileName.replace(ngFactoryRe, '.ts');\n            this.addDependency(originalFile);\n            const origDependencies = plugin.getDependencies(originalFile);\n            origDependencies.forEach(dep => this.addDependency(dep));\n        }\n        // NgStyle files depend on the style file they represent.\n        // E.g. `some-style.less.shim.ngstyle.js` depends on `some-style.less`.\n        // Those files can in turn depend on others, so we have to add them all.\n        const ngStyleRe = /(?:\\.shim)?\\.ngstyle\\.js$/;\n        if (ngStyleRe.test(sourceFileName)) {\n            const styleFile = sourceFileName.replace(ngStyleRe, '');\n            for (const dep of plugin.getResourceDependencies(styleFile)) {\n                this.addDependency(dep);\n            }\n        }\n        // Add type-only dependencies that should trigger a rebuild when they change.\n        const typeDependencies = plugin.getTypeDependencies(sourceFileName);\n        typeDependencies.forEach(dep => this.addDependency(dep));\n        benchmark_1.timeEnd(timeLabel);\n        cb(null, result.outputText, result.sourceMap);\n    })\n        .catch(err => {\n        benchmark_1.timeEnd(timeLabel);\n        cb(err);\n    });\n}\nexports.ngcLoader = ngcLoader;\n"]},"metadata":{},"sourceType":"script"}