{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Naoyuki Kanezawa @nkzawa\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar MultiEntryDependency = require(\"./dependencies/MultiEntryDependency\");\n\nvar SingleEntryDependency = require(\"./dependencies/SingleEntryDependency\");\n\nvar MultiModuleFactory = require(\"./MultiModuleFactory\");\n\nvar MultiEntryPlugin = require(\"./MultiEntryPlugin\");\n\nvar SingleEntryPlugin = require(\"./SingleEntryPlugin\");\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryDynamic} EntryDynamic */\n\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryStatic} EntryStatic */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n\nvar DynamicEntryPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {string} context the context path\n   * @param {EntryDynamic} entry the entry value\n   */\n  function DynamicEntryPlugin(context, entry) {\n    _classCallCheck(this, DynamicEntryPlugin);\n\n    this.context = context;\n    this.entry = entry;\n  }\n  /**\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(DynamicEntryPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      compiler.hooks.compilation.tap(\"DynamicEntryPlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        var multiModuleFactory = new MultiModuleFactory();\n        compilation.dependencyFactories.set(MultiEntryDependency, multiModuleFactory);\n        compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory);\n      });\n      compiler.hooks.make.tapAsync(\"DynamicEntryPlugin\", function (compilation, callback) {\n        /**\n         * @param {string|string[]} entry entry value or array of entry values\n         * @param {string} name name of entry\n         * @returns {Promise<EntryStatic>} returns the promise resolving the Compilation#addEntry function\n         */\n        var addEntry = function addEntry(entry, name) {\n          var dep = DynamicEntryPlugin.createDependency(entry, name);\n          return new Promise(function (resolve, reject) {\n            compilation.addEntry(_this.context, dep, name, function (err) {\n              if (err) return reject(err);\n              resolve();\n            });\n          });\n        };\n\n        Promise.resolve(_this.entry()).then(function (entry) {\n          if (typeof entry === \"string\" || Array.isArray(entry)) {\n            addEntry(entry, \"main\").then(function () {\n              return callback();\n            }, callback);\n          } else if (typeof entry === \"object\") {\n            Promise.all(Object.keys(entry).map(function (name) {\n              return addEntry(entry[name], name);\n            })).then(function () {\n              return callback();\n            }, callback);\n          }\n        });\n      });\n    }\n  }]);\n\n  return DynamicEntryPlugin;\n}();\n\nmodule.exports = DynamicEntryPlugin;\n/**\n * @param {string|string[]} entry entry value or array of entry paths\n * @param {string} name name of entry\n * @returns {SingleEntryDependency|MultiEntryDependency} returns dep\n */\n\nDynamicEntryPlugin.createDependency = function (entry, name) {\n  if (Array.isArray(entry)) {\n    return MultiEntryPlugin.createDependency(entry, name);\n  } else {\n    return SingleEntryPlugin.createDependency(entry, name);\n  }\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/DynamicEntryPlugin.js"],"names":["MultiEntryDependency","require","SingleEntryDependency","MultiModuleFactory","MultiEntryPlugin","SingleEntryPlugin","DynamicEntryPlugin","context","entry","compiler","hooks","compilation","tap","normalModuleFactory","multiModuleFactory","dependencyFactories","set","make","tapAsync","callback","addEntry","name","dep","createDependency","Promise","resolve","reject","err","then","Array","isArray","all","Object","keys","map","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,IAAMA,oBAAoB,GAAGC,OAAO,CAAC,qCAAD,CAApC;;AACA,IAAMC,qBAAqB,GAAGD,OAAO,CAAC,sCAAD,CAArC;;AACA,IAAME,kBAAkB,GAAGF,OAAO,CAAC,sBAAD,CAAlC;;AACA,IAAMG,gBAAgB,GAAGH,OAAO,CAAC,oBAAD,CAAhC;;AACA,IAAMI,iBAAiB,GAAGJ,OAAO,CAAC,qBAAD,CAAjC;AAEA;;AACA;;AACA;;;IAEMK,kB;AACL;AACD;AACA;AACA;AACC,8BAAYC,OAAZ,EAAqBC,KAArB,EAA4B;AAAA;;AAC3B,SAAKD,OAAL,GAAeA,OAAf;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA;AAED;AACD;AACA;AACA;;;;;WACC,eAAMC,QAAN,EAAgB;AAAA;;AACfA,MAAAA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CACC,oBADD,EAEC,UAACD,WAAD,QAA0C;AAAA,YAA1BE,mBAA0B,QAA1BA,mBAA0B;AACzC,YAAMC,kBAAkB,GAAG,IAAIX,kBAAJ,EAA3B;AAEAQ,QAAAA,WAAW,CAACI,mBAAZ,CAAgCC,GAAhC,CACChB,oBADD,EAECc,kBAFD;AAIAH,QAAAA,WAAW,CAACI,mBAAZ,CAAgCC,GAAhC,CACCd,qBADD,EAECW,mBAFD;AAIA,OAbF;AAgBAJ,MAAAA,QAAQ,CAACC,KAAT,CAAeO,IAAf,CAAoBC,QAApB,CACC,oBADD,EAEC,UAACP,WAAD,EAAcQ,QAAd,EAA2B;AAC1B;AACJ;AACA;AACA;AACA;AACI,YAAMC,QAAQ,GAAG,SAAXA,QAAW,CAACZ,KAAD,EAAQa,IAAR,EAAiB;AACjC,cAAMC,GAAG,GAAGhB,kBAAkB,CAACiB,gBAAnB,CAAoCf,KAApC,EAA2Ca,IAA3C,CAAZ;AACA,iBAAO,IAAIG,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACvCf,YAAAA,WAAW,CAACS,QAAZ,CAAqB,KAAI,CAACb,OAA1B,EAAmCe,GAAnC,EAAwCD,IAAxC,EAA8C,UAAAM,GAAG,EAAI;AACpD,kBAAIA,GAAJ,EAAS,OAAOD,MAAM,CAACC,GAAD,CAAb;AACTF,cAAAA,OAAO;AACP,aAHD;AAIA,WALM,CAAP;AAMA,SARD;;AAUAD,QAAAA,OAAO,CAACC,OAAR,CAAgB,KAAI,CAACjB,KAAL,EAAhB,EAA8BoB,IAA9B,CAAmC,UAAApB,KAAK,EAAI;AAC3C,cAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BqB,KAAK,CAACC,OAAN,CAActB,KAAd,CAAjC,EAAuD;AACtDY,YAAAA,QAAQ,CAACZ,KAAD,EAAQ,MAAR,CAAR,CAAwBoB,IAAxB,CAA6B;AAAA,qBAAMT,QAAQ,EAAd;AAAA,aAA7B,EAA+CA,QAA/C;AACA,WAFD,MAEO,IAAI,OAAOX,KAAP,KAAiB,QAArB,EAA+B;AACrCgB,YAAAA,OAAO,CAACO,GAAR,CACCC,MAAM,CAACC,IAAP,CAAYzB,KAAZ,EAAmB0B,GAAnB,CAAuB,UAAAb,IAAI,EAAI;AAC9B,qBAAOD,QAAQ,CAACZ,KAAK,CAACa,IAAD,CAAN,EAAcA,IAAd,CAAf;AACA,aAFD,CADD,EAIEO,IAJF,CAIO;AAAA,qBAAMT,QAAQ,EAAd;AAAA,aAJP,EAIyBA,QAJzB;AAKA;AACD,SAVD;AAWA,OA7BF;AA+BA;;;;;;AAGFgB,MAAM,CAACC,OAAP,GAAiB9B,kBAAjB;AACA;AACA;AACA;AACA;AACA;;AACAA,kBAAkB,CAACiB,gBAAnB,GAAsC,UAACf,KAAD,EAAQa,IAAR,EAAiB;AACtD,MAAIQ,KAAK,CAACC,OAAN,CAActB,KAAd,CAAJ,EAA0B;AACzB,WAAOJ,gBAAgB,CAACmB,gBAAjB,CAAkCf,KAAlC,EAAyCa,IAAzC,CAAP;AACA,GAFD,MAEO;AACN,WAAOhB,iBAAiB,CAACkB,gBAAlB,CAAmCf,KAAnC,EAA0Ca,IAA1C,CAAP;AACA;AACD,CAND","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Naoyuki Kanezawa @nkzawa\n*/\n\"use strict\";\n\nconst MultiEntryDependency = require(\"./dependencies/MultiEntryDependency\");\nconst SingleEntryDependency = require(\"./dependencies/SingleEntryDependency\");\nconst MultiModuleFactory = require(\"./MultiModuleFactory\");\nconst MultiEntryPlugin = require(\"./MultiEntryPlugin\");\nconst SingleEntryPlugin = require(\"./SingleEntryPlugin\");\n\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryDynamic} EntryDynamic */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryStatic} EntryStatic */\n/** @typedef {import(\"./Compiler\")} Compiler */\n\nclass DynamicEntryPlugin {\n\t/**\n\t * @param {string} context the context path\n\t * @param {EntryDynamic} entry the entry value\n\t */\n\tconstructor(context, entry) {\n\t\tthis.context = context;\n\t\tthis.entry = entry;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"DynamicEntryPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst multiModuleFactory = new MultiModuleFactory();\n\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tMultiEntryDependency,\n\t\t\t\t\tmultiModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tSingleEntryDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\n\t\tcompiler.hooks.make.tapAsync(\n\t\t\t\"DynamicEntryPlugin\",\n\t\t\t(compilation, callback) => {\n\t\t\t\t/**\n\t\t\t\t * @param {string|string[]} entry entry value or array of entry values\n\t\t\t\t * @param {string} name name of entry\n\t\t\t\t * @returns {Promise<EntryStatic>} returns the promise resolving the Compilation#addEntry function\n\t\t\t\t */\n\t\t\t\tconst addEntry = (entry, name) => {\n\t\t\t\t\tconst dep = DynamicEntryPlugin.createDependency(entry, name);\n\t\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\t\tcompilation.addEntry(this.context, dep, name, err => {\n\t\t\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tPromise.resolve(this.entry()).then(entry => {\n\t\t\t\t\tif (typeof entry === \"string\" || Array.isArray(entry)) {\n\t\t\t\t\t\taddEntry(entry, \"main\").then(() => callback(), callback);\n\t\t\t\t\t} else if (typeof entry === \"object\") {\n\t\t\t\t\t\tPromise.all(\n\t\t\t\t\t\t\tObject.keys(entry).map(name => {\n\t\t\t\t\t\t\t\treturn addEntry(entry[name], name);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t).then(() => callback(), callback);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = DynamicEntryPlugin;\n/**\n * @param {string|string[]} entry entry value or array of entry paths\n * @param {string} name name of entry\n * @returns {SingleEntryDependency|MultiEntryDependency} returns dep\n */\nDynamicEntryPlugin.createDependency = (entry, name) => {\n\tif (Array.isArray(entry)) {\n\t\treturn MultiEntryPlugin.createDependency(entry, name);\n\t} else {\n\t\treturn SingleEntryPlugin.createDependency(entry, name);\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}