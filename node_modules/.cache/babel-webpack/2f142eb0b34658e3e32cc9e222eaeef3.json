{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar util = require('util');\n\nvar pMap = require('p-map');\n\nvar contentPath = require('./content/path');\n\nvar fixOwner = require('./util/fix-owner');\n\nvar fs = require('fs');\n\nvar fsm = require('fs-minipass');\n\nvar glob = util.promisify(require('glob'));\n\nvar index = require('./entry-index');\n\nvar path = require('path');\n\nvar rimraf = util.promisify(require('rimraf'));\n\nvar ssri = require('ssri');\n\nvar hasOwnProperty = function hasOwnProperty(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\n\nvar stat = util.promisify(fs.stat);\nvar truncate = util.promisify(fs.truncate);\nvar writeFile = util.promisify(fs.writeFile);\nvar readFile = util.promisify(fs.readFile);\n\nvar verifyOpts = function verifyOpts(opts) {\n  return _objectSpread({\n    concurrency: 20,\n    log: {\n      silly: function silly() {}\n    }\n  }, opts);\n};\n\nmodule.exports = verify;\n\nfunction verify(cache, opts) {\n  opts = verifyOpts(opts);\n  opts.log.silly('verify', 'verifying cache at', cache);\n  var steps = [markStartTime, fixPerms, garbageCollect, rebuildIndex, cleanTmp, writeVerifile, markEndTime];\n  return steps.reduce(function (promise, step, i) {\n    var label = step.name;\n    var start = new Date();\n    return promise.then(function (stats) {\n      return step(cache, opts).then(function (s) {\n        s && Object.keys(s).forEach(function (k) {\n          stats[k] = s[k];\n        });\n        var end = new Date();\n\n        if (!stats.runTime) {\n          stats.runTime = {};\n        }\n\n        stats.runTime[label] = end - start;\n        return Promise.resolve(stats);\n      });\n    });\n  }, Promise.resolve({})).then(function (stats) {\n    stats.runTime.total = stats.endTime - stats.startTime;\n    opts.log.silly('verify', 'verification finished for', cache, 'in', \"\".concat(stats.runTime.total, \"ms\"));\n    return stats;\n  });\n}\n\nfunction markStartTime(cache, opts) {\n  return Promise.resolve({\n    startTime: new Date()\n  });\n}\n\nfunction markEndTime(cache, opts) {\n  return Promise.resolve({\n    endTime: new Date()\n  });\n}\n\nfunction fixPerms(cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions');\n  return fixOwner.mkdirfix(cache, cache).then(function () {\n    // TODO - fix file permissions too\n    return fixOwner.chownr(cache, cache);\n  }).then(function () {\n    return null;\n  });\n} // Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\n\n\nfunction garbageCollect(cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content');\n  var indexStream = index.lsStream(cache);\n  var liveContent = new Set();\n  indexStream.on('data', function (entry) {\n    if (opts.filter && !opts.filter(entry)) {\n      return;\n    }\n\n    liveContent.add(entry.integrity.toString());\n  });\n  return new Promise(function (resolve, reject) {\n    indexStream.on('end', resolve).on('error', reject);\n  }).then(function () {\n    var contentDir = contentPath.contentDir(cache);\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    }).then(function (files) {\n      return Promise.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0\n      }).then(function (stats) {\n        return pMap(files, function (f) {\n          var split = f.split(/[/\\\\]/);\n          var digest = split.slice(split.length - 3).join('');\n          var algo = split[split.length - 4];\n          var integrity = ssri.fromHex(digest, algo);\n\n          if (liveContent.has(integrity.toString())) {\n            return verifyContent(f, integrity).then(function (info) {\n              if (!info.valid) {\n                stats.reclaimedCount++;\n                stats.badContentCount++;\n                stats.reclaimedSize += info.size;\n              } else {\n                stats.verifiedContent++;\n                stats.keptSize += info.size;\n              }\n\n              return stats;\n            });\n          } else {\n            // No entries refer to this content. We can delete.\n            stats.reclaimedCount++;\n            return stat(f).then(function (s) {\n              return rimraf(f).then(function () {\n                stats.reclaimedSize += s.size;\n                return stats;\n              });\n            });\n          }\n        }, {\n          concurrency: opts.concurrency\n        }).then(function () {\n          return stats;\n        });\n      });\n    });\n  });\n}\n\nfunction verifyContent(filepath, sri) {\n  return stat(filepath).then(function (s) {\n    var contentInfo = {\n      size: s.size,\n      valid: true\n    };\n    return ssri.checkStream(new fsm.ReadStream(filepath), sri).catch(function (err) {\n      if (err.code !== 'EINTEGRITY') {\n        throw err;\n      }\n\n      return rimraf(filepath).then(function () {\n        contentInfo.valid = false;\n      });\n    }).then(function () {\n      return contentInfo;\n    });\n  }).catch(function (err) {\n    if (err.code === 'ENOENT') {\n      return {\n        size: 0,\n        valid: false\n      };\n    }\n\n    throw err;\n  });\n}\n\nfunction rebuildIndex(cache, opts) {\n  opts.log.silly('verify', 'rebuilding index');\n  return index.ls(cache).then(function (entries) {\n    var stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    };\n    var buckets = {};\n\n    for (var k in entries) {\n      /* istanbul ignore else */\n      if (hasOwnProperty(entries, k)) {\n        var hashed = index.hashKey(k);\n        var entry = entries[k];\n        var excluded = opts.filter && !opts.filter(entry);\n        excluded && stats.rejectedEntries++;\n\n        if (buckets[hashed] && !excluded) {\n          buckets[hashed].push(entry);\n        } else if (buckets[hashed] && excluded) {// skip\n        } else if (excluded) {\n          buckets[hashed] = [];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        } else {\n          buckets[hashed] = [entry];\n          buckets[hashed]._path = index.bucketPath(cache, k);\n        }\n      }\n    }\n\n    return pMap(Object.keys(buckets), function (key) {\n      return rebuildBucket(cache, buckets[key], stats, opts);\n    }, {\n      concurrency: opts.concurrency\n    }).then(function () {\n      return stats;\n    });\n  });\n}\n\nfunction rebuildBucket(cache, bucket, stats, opts) {\n  return truncate(bucket._path).then(function () {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return bucket.reduce(function (promise, entry) {\n      return promise.then(function () {\n        var content = contentPath(cache, entry.integrity);\n        return stat(content).then(function () {\n          return index.insert(cache, entry.key, entry.integrity, {\n            metadata: entry.metadata,\n            size: entry.size\n          }).then(function () {\n            stats.totalEntries++;\n          });\n        }).catch(function (err) {\n          if (err.code === 'ENOENT') {\n            stats.rejectedEntries++;\n            stats.missingContent++;\n            return;\n          }\n\n          throw err;\n        });\n      });\n    }, Promise.resolve());\n  });\n}\n\nfunction cleanTmp(cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory');\n  return rimraf(path.join(cache, 'tmp'));\n}\n\nfunction writeVerifile(cache, opts) {\n  var verifile = path.join(cache, '_lastverified');\n  opts.log.silly('verify', 'writing verifile to ' + verifile);\n\n  try {\n    return writeFile(verifile, '' + +new Date());\n  } finally {\n    fixOwner.chownr.sync(cache, verifile);\n  }\n}\n\nmodule.exports.lastRun = lastRun;\n\nfunction lastRun(cache) {\n  return readFile(path.join(cache, '_lastverified'), 'utf8').then(function (data) {\n    return new Date(+data);\n  });\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/cacache/lib/verify.js"],"names":["util","require","pMap","contentPath","fixOwner","fs","fsm","glob","promisify","index","path","rimraf","ssri","hasOwnProperty","obj","key","Object","prototype","call","stat","truncate","writeFile","readFile","verifyOpts","opts","concurrency","log","silly","module","exports","verify","cache","steps","markStartTime","fixPerms","garbageCollect","rebuildIndex","cleanTmp","writeVerifile","markEndTime","reduce","promise","step","i","label","name","start","Date","then","stats","s","keys","forEach","k","end","runTime","Promise","resolve","total","endTime","startTime","mkdirfix","chownr","indexStream","lsStream","liveContent","Set","on","entry","filter","add","integrity","toString","reject","contentDir","join","follow","nodir","nosort","files","verifiedContent","reclaimedCount","reclaimedSize","badContentCount","keptSize","f","split","digest","slice","length","algo","fromHex","has","verifyContent","info","valid","size","filepath","sri","contentInfo","checkStream","ReadStream","catch","err","code","ls","entries","missingContent","rejectedEntries","totalEntries","buckets","hashed","hashKey","excluded","push","_path","bucketPath","rebuildBucket","bucket","content","insert","metadata","verifile","sync","lastRun","data"],"mappings":"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","sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst pMap = require('p-map')\nconst contentPath = require('./content/path')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst glob = util.promisify(require('glob'))\nconst index = require('./entry-index')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\n\nconst hasOwnProperty = (obj, key) =>\n  Object.prototype.hasOwnProperty.call(obj, key)\n\nconst stat = util.promisify(fs.stat)\nconst truncate = util.promisify(fs.truncate)\nconst writeFile = util.promisify(fs.writeFile)\nconst readFile = util.promisify(fs.readFile)\n\nconst verifyOpts = (opts) => ({\n  concurrency: 20,\n  log: { silly () {} },\n  ...opts\n})\n\nmodule.exports = verify\n\nfunction verify (cache, opts) {\n  opts = verifyOpts(opts)\n  opts.log.silly('verify', 'verifying cache at', cache)\n\n  const steps = [\n    markStartTime,\n    fixPerms,\n    garbageCollect,\n    rebuildIndex,\n    cleanTmp,\n    writeVerifile,\n    markEndTime\n  ]\n\n  return steps\n    .reduce((promise, step, i) => {\n      const label = step.name\n      const start = new Date()\n      return promise.then((stats) => {\n        return step(cache, opts).then((s) => {\n          s &&\n            Object.keys(s).forEach((k) => {\n              stats[k] = s[k]\n            })\n          const end = new Date()\n          if (!stats.runTime) {\n            stats.runTime = {}\n          }\n          stats.runTime[label] = end - start\n          return Promise.resolve(stats)\n        })\n      })\n    }, Promise.resolve({}))\n    .then((stats) => {\n      stats.runTime.total = stats.endTime - stats.startTime\n      opts.log.silly(\n        'verify',\n        'verification finished for',\n        cache,\n        'in',\n        `${stats.runTime.total}ms`\n      )\n      return stats\n    })\n}\n\nfunction markStartTime (cache, opts) {\n  return Promise.resolve({ startTime: new Date() })\n}\n\nfunction markEndTime (cache, opts) {\n  return Promise.resolve({ endTime: new Date() })\n}\n\nfunction fixPerms (cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions')\n  return fixOwner\n    .mkdirfix(cache, cache)\n    .then(() => {\n      // TODO - fix file permissions too\n      return fixOwner.chownr(cache, cache)\n    })\n    .then(() => null)\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nfunction garbageCollect (cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content')\n  const indexStream = index.lsStream(cache)\n  const liveContent = new Set()\n  indexStream.on('data', (entry) => {\n    if (opts.filter && !opts.filter(entry)) {\n      return\n    }\n    liveContent.add(entry.integrity.toString())\n  })\n  return new Promise((resolve, reject) => {\n    indexStream.on('end', resolve).on('error', reject)\n  }).then(() => {\n    const contentDir = contentPath.contentDir(cache)\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    }).then((files) => {\n      return Promise.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0\n      }).then((stats) =>\n        pMap(\n          files,\n          (f) => {\n            const split = f.split(/[/\\\\]/)\n            const digest = split.slice(split.length - 3).join('')\n            const algo = split[split.length - 4]\n            const integrity = ssri.fromHex(digest, algo)\n            if (liveContent.has(integrity.toString())) {\n              return verifyContent(f, integrity).then((info) => {\n                if (!info.valid) {\n                  stats.reclaimedCount++\n                  stats.badContentCount++\n                  stats.reclaimedSize += info.size\n                } else {\n                  stats.verifiedContent++\n                  stats.keptSize += info.size\n                }\n                return stats\n              })\n            } else {\n              // No entries refer to this content. We can delete.\n              stats.reclaimedCount++\n              return stat(f).then((s) => {\n                return rimraf(f).then(() => {\n                  stats.reclaimedSize += s.size\n                  return stats\n                })\n              })\n            }\n          },\n          { concurrency: opts.concurrency }\n        ).then(() => stats)\n      )\n    })\n  })\n}\n\nfunction verifyContent (filepath, sri) {\n  return stat(filepath)\n    .then((s) => {\n      const contentInfo = {\n        size: s.size,\n        valid: true\n      }\n      return ssri\n        .checkStream(new fsm.ReadStream(filepath), sri)\n        .catch((err) => {\n          if (err.code !== 'EINTEGRITY') {\n            throw err\n          }\n          return rimraf(filepath).then(() => {\n            contentInfo.valid = false\n          })\n        })\n        .then(() => contentInfo)\n    })\n    .catch((err) => {\n      if (err.code === 'ENOENT') {\n        return { size: 0, valid: false }\n      }\n      throw err\n    })\n}\n\nfunction rebuildIndex (cache, opts) {\n  opts.log.silly('verify', 'rebuilding index')\n  return index.ls(cache).then((entries) => {\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    }\n    const buckets = {}\n    for (const k in entries) {\n      /* istanbul ignore else */\n      if (hasOwnProperty(entries, k)) {\n        const hashed = index.hashKey(k)\n        const entry = entries[k]\n        const excluded = opts.filter && !opts.filter(entry)\n        excluded && stats.rejectedEntries++\n        if (buckets[hashed] && !excluded) {\n          buckets[hashed].push(entry)\n        } else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = []\n          buckets[hashed]._path = index.bucketPath(cache, k)\n        } else {\n          buckets[hashed] = [entry]\n          buckets[hashed]._path = index.bucketPath(cache, k)\n        }\n      }\n    }\n    return pMap(\n      Object.keys(buckets),\n      (key) => {\n        return rebuildBucket(cache, buckets[key], stats, opts)\n      },\n      { concurrency: opts.concurrency }\n    ).then(() => stats)\n  })\n}\n\nfunction rebuildBucket (cache, bucket, stats, opts) {\n  return truncate(bucket._path).then(() => {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return bucket.reduce((promise, entry) => {\n      return promise.then(() => {\n        const content = contentPath(cache, entry.integrity)\n        return stat(content)\n          .then(() => {\n            return index\n              .insert(cache, entry.key, entry.integrity, {\n                metadata: entry.metadata,\n                size: entry.size\n              })\n              .then(() => {\n                stats.totalEntries++\n              })\n          })\n          .catch((err) => {\n            if (err.code === 'ENOENT') {\n              stats.rejectedEntries++\n              stats.missingContent++\n              return\n            }\n            throw err\n          })\n      })\n    }, Promise.resolve())\n  })\n}\n\nfunction cleanTmp (cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory')\n  return rimraf(path.join(cache, 'tmp'))\n}\n\nfunction writeVerifile (cache, opts) {\n  const verifile = path.join(cache, '_lastverified')\n  opts.log.silly('verify', 'writing verifile to ' + verifile)\n  try {\n    return writeFile(verifile, '' + +new Date())\n  } finally {\n    fixOwner.chownr.sync(cache, verifile)\n  }\n}\n\nmodule.exports.lastRun = lastRun\n\nfunction lastRun (cache) {\n  return readFile(path.join(cache, '_lastverified'), 'utf8').then(\n    (data) => new Date(+data)\n  )\n}\n"]},"metadata":{},"sourceType":"script"}