{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/expression_parser/lexer\", [\"require\", \"exports\", \"@angular/compiler/src/chars\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isQuote = exports.isIdentifier = exports.EOF = exports.Token = exports.Lexer = exports.TokenType = void 0;\n\n  var chars = require(\"@angular/compiler/src/chars\");\n\n  var TokenType;\n\n  (function (TokenType) {\n    TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n    TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n    TokenType[TokenType[\"Keyword\"] = 2] = \"Keyword\";\n    TokenType[TokenType[\"String\"] = 3] = \"String\";\n    TokenType[TokenType[\"Operator\"] = 4] = \"Operator\";\n    TokenType[TokenType[\"Number\"] = 5] = \"Number\";\n    TokenType[TokenType[\"Error\"] = 6] = \"Error\";\n  })(TokenType = exports.TokenType || (exports.TokenType = {}));\n\n  var KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\n  var Lexer =\n  /** @class */\n  function () {\n    function Lexer() {}\n\n    Lexer.prototype.tokenize = function (text) {\n      var scanner = new _Scanner(text);\n      var tokens = [];\n      var token = scanner.scanToken();\n\n      while (token != null) {\n        tokens.push(token);\n        token = scanner.scanToken();\n      }\n\n      return tokens;\n    };\n\n    return Lexer;\n  }();\n\n  exports.Lexer = Lexer;\n\n  var Token =\n  /** @class */\n  function () {\n    function Token(index, end, type, numValue, strValue) {\n      this.index = index;\n      this.end = end;\n      this.type = type;\n      this.numValue = numValue;\n      this.strValue = strValue;\n    }\n\n    Token.prototype.isCharacter = function (code) {\n      return this.type == TokenType.Character && this.numValue == code;\n    };\n\n    Token.prototype.isNumber = function () {\n      return this.type == TokenType.Number;\n    };\n\n    Token.prototype.isString = function () {\n      return this.type == TokenType.String;\n    };\n\n    Token.prototype.isOperator = function (operator) {\n      return this.type == TokenType.Operator && this.strValue == operator;\n    };\n\n    Token.prototype.isIdentifier = function () {\n      return this.type == TokenType.Identifier;\n    };\n\n    Token.prototype.isKeyword = function () {\n      return this.type == TokenType.Keyword;\n    };\n\n    Token.prototype.isKeywordLet = function () {\n      return this.type == TokenType.Keyword && this.strValue == 'let';\n    };\n\n    Token.prototype.isKeywordAs = function () {\n      return this.type == TokenType.Keyword && this.strValue == 'as';\n    };\n\n    Token.prototype.isKeywordNull = function () {\n      return this.type == TokenType.Keyword && this.strValue == 'null';\n    };\n\n    Token.prototype.isKeywordUndefined = function () {\n      return this.type == TokenType.Keyword && this.strValue == 'undefined';\n    };\n\n    Token.prototype.isKeywordTrue = function () {\n      return this.type == TokenType.Keyword && this.strValue == 'true';\n    };\n\n    Token.prototype.isKeywordFalse = function () {\n      return this.type == TokenType.Keyword && this.strValue == 'false';\n    };\n\n    Token.prototype.isKeywordThis = function () {\n      return this.type == TokenType.Keyword && this.strValue == 'this';\n    };\n\n    Token.prototype.isError = function () {\n      return this.type == TokenType.Error;\n    };\n\n    Token.prototype.toNumber = function () {\n      return this.type == TokenType.Number ? this.numValue : -1;\n    };\n\n    Token.prototype.toString = function () {\n      switch (this.type) {\n        case TokenType.Character:\n        case TokenType.Identifier:\n        case TokenType.Keyword:\n        case TokenType.Operator:\n        case TokenType.String:\n        case TokenType.Error:\n          return this.strValue;\n\n        case TokenType.Number:\n          return this.numValue.toString();\n\n        default:\n          return null;\n      }\n    };\n\n    return Token;\n  }();\n\n  exports.Token = Token;\n\n  function newCharacterToken(index, end, code) {\n    return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n  }\n\n  function newIdentifierToken(index, end, text) {\n    return new Token(index, end, TokenType.Identifier, 0, text);\n  }\n\n  function newKeywordToken(index, end, text) {\n    return new Token(index, end, TokenType.Keyword, 0, text);\n  }\n\n  function newOperatorToken(index, end, text) {\n    return new Token(index, end, TokenType.Operator, 0, text);\n  }\n\n  function newStringToken(index, end, text) {\n    return new Token(index, end, TokenType.String, 0, text);\n  }\n\n  function newNumberToken(index, end, n) {\n    return new Token(index, end, TokenType.Number, n, '');\n  }\n\n  function newErrorToken(index, end, message) {\n    return new Token(index, end, TokenType.Error, 0, message);\n  }\n\n  exports.EOF = new Token(-1, -1, TokenType.Character, 0, '');\n\n  var _Scanner =\n  /** @class */\n  function () {\n    function _Scanner(input) {\n      this.input = input;\n      this.peek = 0;\n      this.index = -1;\n      this.length = input.length;\n      this.advance();\n    }\n\n    _Scanner.prototype.advance = function () {\n      this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n    };\n\n    _Scanner.prototype.scanToken = function () {\n      var input = this.input,\n          length = this.length;\n      var peek = this.peek,\n          index = this.index; // Skip whitespace.\n\n      while (peek <= chars.$SPACE) {\n        if (++index >= length) {\n          peek = chars.$EOF;\n          break;\n        } else {\n          peek = input.charCodeAt(index);\n        }\n      }\n\n      this.peek = peek;\n      this.index = index;\n\n      if (index >= length) {\n        return null;\n      } // Handle identifiers and numbers.\n\n\n      if (isIdentifierStart(peek)) return this.scanIdentifier();\n      if (chars.isDigit(peek)) return this.scanNumber(index);\n      var start = index;\n\n      switch (peek) {\n        case chars.$PERIOD:\n          this.advance();\n          return chars.isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, chars.$PERIOD);\n\n        case chars.$LPAREN:\n        case chars.$RPAREN:\n        case chars.$LBRACE:\n        case chars.$RBRACE:\n        case chars.$LBRACKET:\n        case chars.$RBRACKET:\n        case chars.$COMMA:\n        case chars.$COLON:\n        case chars.$SEMICOLON:\n          return this.scanCharacter(start, peek);\n\n        case chars.$SQ:\n        case chars.$DQ:\n          return this.scanString();\n\n        case chars.$HASH:\n        case chars.$PLUS:\n        case chars.$MINUS:\n        case chars.$STAR:\n        case chars.$SLASH:\n        case chars.$PERCENT:\n        case chars.$CARET:\n          return this.scanOperator(start, String.fromCharCode(peek));\n\n        case chars.$QUESTION:\n          return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n\n        case chars.$LT:\n        case chars.$GT:\n          return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n\n        case chars.$BANG:\n        case chars.$EQ:\n          return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n\n        case chars.$AMPERSAND:\n          return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n\n        case chars.$BAR:\n          return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n\n        case chars.$NBSP:\n          while (chars.isWhitespace(this.peek)) {\n            this.advance();\n          }\n\n          return this.scanToken();\n      }\n\n      this.advance();\n      return this.error(\"Unexpected character [\" + String.fromCharCode(peek) + \"]\", 0);\n    };\n\n    _Scanner.prototype.scanCharacter = function (start, code) {\n      this.advance();\n      return newCharacterToken(start, this.index, code);\n    };\n\n    _Scanner.prototype.scanOperator = function (start, str) {\n      this.advance();\n      return newOperatorToken(start, this.index, str);\n    };\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     */\n\n\n    _Scanner.prototype.scanComplexOperator = function (start, one, twoCode, two, threeCode, three) {\n      this.advance();\n      var str = one;\n\n      if (this.peek == twoCode) {\n        this.advance();\n        str += two;\n      }\n\n      if (threeCode != null && this.peek == threeCode) {\n        this.advance();\n        str += three;\n      }\n\n      return newOperatorToken(start, this.index, str);\n    };\n\n    _Scanner.prototype.scanIdentifier = function () {\n      var start = this.index;\n      this.advance();\n\n      while (isIdentifierPart(this.peek)) {\n        this.advance();\n      }\n\n      var str = this.input.substring(start, this.index);\n      return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);\n    };\n\n    _Scanner.prototype.scanNumber = function (start) {\n      var simple = this.index === start;\n      this.advance(); // Skip initial digit.\n\n      while (true) {\n        if (chars.isDigit(this.peek)) {// Do nothing.\n        } else if (this.peek == chars.$PERIOD) {\n          simple = false;\n        } else if (isExponentStart(this.peek)) {\n          this.advance();\n          if (isExponentSign(this.peek)) this.advance();\n          if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n          simple = false;\n        } else {\n          break;\n        }\n\n        this.advance();\n      }\n\n      var str = this.input.substring(start, this.index);\n      var value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n      return newNumberToken(start, this.index, value);\n    };\n\n    _Scanner.prototype.scanString = function () {\n      var start = this.index;\n      var quote = this.peek;\n      this.advance(); // Skip initial quote.\n\n      var buffer = '';\n      var marker = this.index;\n      var input = this.input;\n\n      while (this.peek != quote) {\n        if (this.peek == chars.$BACKSLASH) {\n          buffer += input.substring(marker, this.index);\n          this.advance();\n          var unescapedCode = void 0; // Workaround for TS2.1-introduced type strictness\n\n          this.peek = this.peek;\n\n          if (this.peek == chars.$u) {\n            // 4 character hex code for unicode character.\n            var hex = input.substring(this.index + 1, this.index + 5);\n\n            if (/^[0-9a-f]+$/i.test(hex)) {\n              unescapedCode = parseInt(hex, 16);\n            } else {\n              return this.error(\"Invalid unicode escape [\\\\u\" + hex + \"]\", 0);\n            }\n\n            for (var i = 0; i < 5; i++) {\n              this.advance();\n            }\n          } else {\n            unescapedCode = unescape(this.peek);\n            this.advance();\n          }\n\n          buffer += String.fromCharCode(unescapedCode);\n          marker = this.index;\n        } else if (this.peek == chars.$EOF) {\n          return this.error('Unterminated quote', 0);\n        } else {\n          this.advance();\n        }\n      }\n\n      var last = input.substring(marker, this.index);\n      this.advance(); // Skip terminating quote.\n\n      return newStringToken(start, this.index, buffer + last);\n    };\n\n    _Scanner.prototype.error = function (message, offset) {\n      var position = this.index + offset;\n      return newErrorToken(position, this.index, \"Lexer Error: \" + message + \" at column \" + position + \" in expression [\" + this.input + \"]\");\n    };\n\n    return _Scanner;\n  }();\n\n  function isIdentifierStart(code) {\n    return chars.$a <= code && code <= chars.$z || chars.$A <= code && code <= chars.$Z || code == chars.$_ || code == chars.$$;\n  }\n\n  function isIdentifier(input) {\n    if (input.length == 0) return false;\n    var scanner = new _Scanner(input);\n    if (!isIdentifierStart(scanner.peek)) return false;\n    scanner.advance();\n\n    while (scanner.peek !== chars.$EOF) {\n      if (!isIdentifierPart(scanner.peek)) return false;\n      scanner.advance();\n    }\n\n    return true;\n  }\n\n  exports.isIdentifier = isIdentifier;\n\n  function isIdentifierPart(code) {\n    return chars.isAsciiLetter(code) || chars.isDigit(code) || code == chars.$_ || code == chars.$$;\n  }\n\n  function isExponentStart(code) {\n    return code == chars.$e || code == chars.$E;\n  }\n\n  function isExponentSign(code) {\n    return code == chars.$MINUS || code == chars.$PLUS;\n  }\n\n  function isQuote(code) {\n    return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n  }\n\n  exports.isQuote = isQuote;\n\n  function unescape(code) {\n    switch (code) {\n      case chars.$n:\n        return chars.$LF;\n\n      case chars.$f:\n        return chars.$FF;\n\n      case chars.$r:\n        return chars.$CR;\n\n      case chars.$t:\n        return chars.$TAB;\n\n      case chars.$v:\n        return chars.$VTAB;\n\n      default:\n        return code;\n    }\n  }\n\n  function parseIntAutoRadix(text) {\n    var result = parseInt(text);\n\n    if (isNaN(result)) {\n      throw new Error('Invalid integer literal when parsing ' + text);\n    }\n\n    return result;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/expression_parser/lexer.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAEH,MAAA,KAAA,GAAA,OAAA,CAAA,6BAAA,CAAA;;AAEA,MAAY,SAAZ;;AAAA,GAAA,UAAY,SAAZ,EAAqB;AACnB,IAAA,SAAA,CAAA,SAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,IAAA,SAAA,CAAA,SAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA,IAAA,SAAA,CAAA,SAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,IAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,IAAA,SAAA,CAAA,SAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA,IAAA,SAAA,CAAA,SAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,IAAA,SAAA,CAAA,SAAA,CAAA,OAAA,CAAA,GAAA,CAAA,CAAA,GAAA,OAAA;AACD,GARD,EAAY,SAAS,GAAT,OAAA,CAAA,SAAA,KAAA,OAAA,CAAA,SAAA,GAAS,EAAT,CAAZ;;AAUA,MAAM,QAAQ,GAAG,CAAC,KAAD,EAAQ,KAAR,EAAe,IAAf,EAAqB,MAArB,EAA6B,WAA7B,EAA0C,MAA1C,EAAkD,OAAlD,EAA2D,IAA3D,EAAiE,MAAjE,EAAyE,MAAzE,CAAjB;;AAEA,MAAA,KAAA;AAAA;AAAA,cAAA;AAAA,aAAA,KAAA,GAAA,CAWC;;AAVC,IAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,IAAT,EAAqB;AACnB,UAAM,OAAO,GAAG,IAAI,QAAJ,CAAa,IAAb,CAAhB;AACA,UAAM,MAAM,GAAY,EAAxB;AACA,UAAI,KAAK,GAAG,OAAO,CAAC,SAAR,EAAZ;;AACA,aAAO,KAAK,IAAI,IAAhB,EAAsB;AACpB,QAAA,MAAM,CAAC,IAAP,CAAY,KAAZ;AACA,QAAA,KAAK,GAAG,OAAO,CAAC,SAAR,EAAR;AACD;;AACD,aAAO,MAAP;AACD,KATD;;AAUF,WAAA,KAAA;AAAC,GAXD,EAAA;;AAAa,EAAA,OAAA,CAAA,KAAA,GAAA,KAAA;;AAab,MAAA,KAAA;AAAA;AAAA,cAAA;AACE,aAAA,KAAA,CACW,KADX,EACiC,GADjC,EACqD,IADrD,EAC6E,QAD7E,EAEW,QAFX,EAE2B;AADhB,WAAA,KAAA,GAAA,KAAA;AAAsB,WAAA,GAAA,GAAA,GAAA;AAAoB,WAAA,IAAA,GAAA,IAAA;AAAwB,WAAA,QAAA,GAAA,QAAA;AAClE,WAAA,QAAA,GAAA,QAAA;AAAoB;;AAE/B,IAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,IAAZ,EAAwB;AACtB,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,SAAvB,IAAoC,KAAK,QAAL,IAAiB,IAA5D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,MAA9B;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,MAA9B;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,QAAX,EAA2B;AACzB,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,QAAvB,IAAmC,KAAK,QAAL,IAAiB,QAA3D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,UAA9B;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,OAA9B;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,YAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,OAAvB,IAAkC,KAAK,QAAL,IAAiB,KAA1D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,OAAvB,IAAkC,KAAK,QAAL,IAAiB,IAA1D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,OAAvB,IAAkC,KAAK,QAAL,IAAiB,MAA1D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,OAAvB,IAAkC,KAAK,QAAL,IAAiB,WAA1D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,OAAvB,IAAkC,KAAK,QAAL,IAAiB,MAA1D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,OAAvB,IAAkC,KAAK,QAAL,IAAiB,OAA1D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,aAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,OAAvB,IAAkC,KAAK,QAAL,IAAiB,MAA1D;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,KAA9B;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,IAAa,SAAS,CAAC,MAAvB,GAAgC,KAAK,QAArC,GAAgD,CAAC,CAAxD;AACD,KAFD;;AAIA,IAAA,KAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,cAAQ,KAAK,IAAb;AACE,aAAK,SAAS,CAAC,SAAf;AACA,aAAK,SAAS,CAAC,UAAf;AACA,aAAK,SAAS,CAAC,OAAf;AACA,aAAK,SAAS,CAAC,QAAf;AACA,aAAK,SAAS,CAAC,MAAf;AACA,aAAK,SAAS,CAAC,KAAf;AACE,iBAAO,KAAK,QAAZ;;AACF,aAAK,SAAS,CAAC,MAAf;AACE,iBAAO,KAAK,QAAL,CAAc,QAAd,EAAP;;AACF;AACE,iBAAO,IAAP;AAXJ;AAaD,KAdD;;AAeF,WAAA,KAAA;AAAC,GAhFD,EAAA;;AAAa,EAAA,OAAA,CAAA,KAAA,GAAA,KAAA;;AAkFb,WAAS,iBAAT,CAA2B,KAA3B,EAA0C,GAA1C,EAAuD,IAAvD,EAAmE;AACjE,WAAO,IAAI,KAAJ,CAAU,KAAV,EAAiB,GAAjB,EAAsB,SAAS,CAAC,SAAhC,EAA2C,IAA3C,EAAiD,MAAM,CAAC,YAAP,CAAoB,IAApB,CAAjD,CAAP;AACD;;AAED,WAAS,kBAAT,CAA4B,KAA5B,EAA2C,GAA3C,EAAwD,IAAxD,EAAoE;AAClE,WAAO,IAAI,KAAJ,CAAU,KAAV,EAAiB,GAAjB,EAAsB,SAAS,CAAC,UAAhC,EAA4C,CAA5C,EAA+C,IAA/C,CAAP;AACD;;AAED,WAAS,eAAT,CAAyB,KAAzB,EAAwC,GAAxC,EAAqD,IAArD,EAAiE;AAC/D,WAAO,IAAI,KAAJ,CAAU,KAAV,EAAiB,GAAjB,EAAsB,SAAS,CAAC,OAAhC,EAAyC,CAAzC,EAA4C,IAA5C,CAAP;AACD;;AAED,WAAS,gBAAT,CAA0B,KAA1B,EAAyC,GAAzC,EAAsD,IAAtD,EAAkE;AAChE,WAAO,IAAI,KAAJ,CAAU,KAAV,EAAiB,GAAjB,EAAsB,SAAS,CAAC,QAAhC,EAA0C,CAA1C,EAA6C,IAA7C,CAAP;AACD;;AAED,WAAS,cAAT,CAAwB,KAAxB,EAAuC,GAAvC,EAAoD,IAApD,EAAgE;AAC9D,WAAO,IAAI,KAAJ,CAAU,KAAV,EAAiB,GAAjB,EAAsB,SAAS,CAAC,MAAhC,EAAwC,CAAxC,EAA2C,IAA3C,CAAP;AACD;;AAED,WAAS,cAAT,CAAwB,KAAxB,EAAuC,GAAvC,EAAoD,CAApD,EAA6D;AAC3D,WAAO,IAAI,KAAJ,CAAU,KAAV,EAAiB,GAAjB,EAAsB,SAAS,CAAC,MAAhC,EAAwC,CAAxC,EAA2C,EAA3C,CAAP;AACD;;AAED,WAAS,aAAT,CAAuB,KAAvB,EAAsC,GAAtC,EAAmD,OAAnD,EAAkE;AAChE,WAAO,IAAI,KAAJ,CAAU,KAAV,EAAiB,GAAjB,EAAsB,SAAS,CAAC,KAAhC,EAAuC,CAAvC,EAA0C,OAA1C,CAAP;AACD;;AAEY,EAAA,OAAA,CAAA,GAAA,GAAa,IAAI,KAAJ,CAAU,CAAC,CAAX,EAAc,CAAC,CAAf,EAAkB,SAAS,CAAC,SAA5B,EAAuC,CAAvC,EAA0C,EAA1C,CAAb;;AAEb,MAAA,QAAA;AAAA;AAAA,cAAA;AAKE,aAAA,QAAA,CAAmB,KAAnB,EAAgC;AAAb,WAAA,KAAA,GAAA,KAAA;AAHnB,WAAA,IAAA,GAAe,CAAf;AACA,WAAA,KAAA,GAAgB,CAAC,CAAjB;AAGE,WAAK,MAAL,GAAc,KAAK,CAAC,MAApB;AACA,WAAK,OAAL;AACD;;AAED,IAAA,QAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,WAAK,IAAL,GAAY,EAAE,KAAK,KAAP,IAAgB,KAAK,MAArB,GAA8B,KAAK,CAAC,IAApC,GAA2C,KAAK,KAAL,CAAW,UAAX,CAAsB,KAAK,KAA3B,CAAvD;AACD,KAFD;;AAIA,IAAA,QAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;AACE,UAAM,KAAK,GAAG,KAAK,KAAnB;AAAA,UAA0B,MAAM,GAAG,KAAK,MAAxC;AACA,UAAI,IAAI,GAAG,KAAK,IAAhB;AAAA,UAAsB,KAAK,GAAG,KAAK,KAAnC,CAFF,CAIE;;AACA,aAAO,IAAI,IAAI,KAAK,CAAC,MAArB,EAA6B;AAC3B,YAAI,EAAE,KAAF,IAAW,MAAf,EAAuB;AACrB,UAAA,IAAI,GAAG,KAAK,CAAC,IAAb;AACA;AACD,SAHD,MAGO;AACL,UAAA,IAAI,GAAG,KAAK,CAAC,UAAN,CAAiB,KAAjB,CAAP;AACD;AACF;;AAED,WAAK,IAAL,GAAY,IAAZ;AACA,WAAK,KAAL,GAAa,KAAb;;AAEA,UAAI,KAAK,IAAI,MAAb,EAAqB;AACnB,eAAO,IAAP;AACD,OAnBH,CAqBE;;;AACA,UAAI,iBAAiB,CAAC,IAAD,CAArB,EAA6B,OAAO,KAAK,cAAL,EAAP;AAC7B,UAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB,OAAO,KAAK,UAAL,CAAgB,KAAhB,CAAP;AAEzB,UAAM,KAAK,GAAW,KAAtB;;AACA,cAAQ,IAAR;AACE,aAAK,KAAK,CAAC,OAAX;AACE,eAAK,OAAL;AACA,iBAAO,KAAK,CAAC,OAAN,CAAc,KAAK,IAAnB,IAA2B,KAAK,UAAL,CAAgB,KAAhB,CAA3B,GAC2B,iBAAiB,CAAC,KAAD,EAAQ,KAAK,KAAb,EAAoB,KAAK,CAAC,OAA1B,CADnD;;AAEF,aAAK,KAAK,CAAC,OAAX;AACA,aAAK,KAAK,CAAC,OAAX;AACA,aAAK,KAAK,CAAC,OAAX;AACA,aAAK,KAAK,CAAC,OAAX;AACA,aAAK,KAAK,CAAC,SAAX;AACA,aAAK,KAAK,CAAC,SAAX;AACA,aAAK,KAAK,CAAC,MAAX;AACA,aAAK,KAAK,CAAC,MAAX;AACA,aAAK,KAAK,CAAC,UAAX;AACE,iBAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,IAA1B,CAAP;;AACF,aAAK,KAAK,CAAC,GAAX;AACA,aAAK,KAAK,CAAC,GAAX;AACE,iBAAO,KAAK,UAAL,EAAP;;AACF,aAAK,KAAK,CAAC,KAAX;AACA,aAAK,KAAK,CAAC,KAAX;AACA,aAAK,KAAK,CAAC,MAAX;AACA,aAAK,KAAK,CAAC,KAAX;AACA,aAAK,KAAK,CAAC,MAAX;AACA,aAAK,KAAK,CAAC,QAAX;AACA,aAAK,KAAK,CAAC,MAAX;AACE,iBAAO,KAAK,YAAL,CAAkB,KAAlB,EAAyB,MAAM,CAAC,YAAP,CAAoB,IAApB,CAAzB,CAAP;;AACF,aAAK,KAAK,CAAC,SAAX;AACE,iBAAO,KAAK,mBAAL,CAAyB,KAAzB,EAAgC,GAAhC,EAAqC,KAAK,CAAC,OAA3C,EAAoD,GAApD,CAAP;;AACF,aAAK,KAAK,CAAC,GAAX;AACA,aAAK,KAAK,CAAC,GAAX;AACE,iBAAO,KAAK,mBAAL,CAAyB,KAAzB,EAAgC,MAAM,CAAC,YAAP,CAAoB,IAApB,CAAhC,EAA2D,KAAK,CAAC,GAAjE,EAAsE,GAAtE,CAAP;;AACF,aAAK,KAAK,CAAC,KAAX;AACA,aAAK,KAAK,CAAC,GAAX;AACE,iBAAO,KAAK,mBAAL,CACH,KADG,EACI,MAAM,CAAC,YAAP,CAAoB,IAApB,CADJ,EAC+B,KAAK,CAAC,GADrC,EAC0C,GAD1C,EAC+C,KAAK,CAAC,GADrD,EAC0D,GAD1D,CAAP;;AAEF,aAAK,KAAK,CAAC,UAAX;AACE,iBAAO,KAAK,mBAAL,CAAyB,KAAzB,EAAgC,GAAhC,EAAqC,KAAK,CAAC,UAA3C,EAAuD,GAAvD,CAAP;;AACF,aAAK,KAAK,CAAC,IAAX;AACE,iBAAO,KAAK,mBAAL,CAAyB,KAAzB,EAAgC,GAAhC,EAAqC,KAAK,CAAC,IAA3C,EAAiD,GAAjD,CAAP;;AACF,aAAK,KAAK,CAAC,KAAX;AACE,iBAAO,KAAK,CAAC,YAAN,CAAmB,KAAK,IAAxB,CAAP;AAAsC,iBAAK,OAAL;AAAtC;;AACA,iBAAO,KAAK,SAAL,EAAP;AAzCJ;;AA4CA,WAAK,OAAL;AACA,aAAO,KAAK,KAAL,CAAW,2BAAyB,MAAM,CAAC,YAAP,CAAoB,IAApB,CAAzB,GAAkD,GAA7D,EAAkE,CAAlE,CAAP;AACD,KAxED;;AA0EA,IAAA,QAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,KAAd,EAA6B,IAA7B,EAAyC;AACvC,WAAK,OAAL;AACA,aAAO,iBAAiB,CAAC,KAAD,EAAQ,KAAK,KAAb,EAAoB,IAApB,CAAxB;AACD,KAHD;;AAMA,IAAA,QAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,KAAb,EAA4B,GAA5B,EAAuC;AACrC,WAAK,OAAL;AACA,aAAO,gBAAgB,CAAC,KAAD,EAAQ,KAAK,KAAb,EAAoB,GAApB,CAAvB;AACD,KAHD;AAKA;;;;;;;;;AASG;;;AACH,IAAA,QAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UACI,KADJ,EACmB,GADnB,EACgC,OADhC,EACiD,GADjD,EAC8D,SAD9D,EAEI,KAFJ,EAEkB;AAChB,WAAK,OAAL;AACA,UAAI,GAAG,GAAW,GAAlB;;AACA,UAAI,KAAK,IAAL,IAAa,OAAjB,EAA0B;AACxB,aAAK,OAAL;AACA,QAAA,GAAG,IAAI,GAAP;AACD;;AACD,UAAI,SAAS,IAAI,IAAb,IAAqB,KAAK,IAAL,IAAa,SAAtC,EAAiD;AAC/C,aAAK,OAAL;AACA,QAAA,GAAG,IAAI,KAAP;AACD;;AACD,aAAO,gBAAgB,CAAC,KAAD,EAAQ,KAAK,KAAb,EAAoB,GAApB,CAAvB;AACD,KAdD;;AAgBA,IAAA,QAAA,CAAA,SAAA,CAAA,cAAA,GAAA,YAAA;AACE,UAAM,KAAK,GAAW,KAAK,KAA3B;AACA,WAAK,OAAL;;AACA,aAAO,gBAAgB,CAAC,KAAK,IAAN,CAAvB;AAAoC,aAAK,OAAL;AAApC;;AACA,UAAM,GAAG,GAAW,KAAK,KAAL,CAAW,SAAX,CAAqB,KAArB,EAA4B,KAAK,KAAjC,CAApB;AACA,aAAO,QAAQ,CAAC,OAAT,CAAiB,GAAjB,IAAwB,CAAC,CAAzB,GAA6B,eAAe,CAAC,KAAD,EAAQ,KAAK,KAAb,EAAoB,GAApB,CAA5C,GAC6B,kBAAkB,CAAC,KAAD,EAAQ,KAAK,KAAb,EAAoB,GAApB,CADtD;AAED,KAPD;;AASA,IAAA,QAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,KAAX,EAAwB;AACtB,UAAI,MAAM,GAAa,KAAK,KAAL,KAAe,KAAtC;AACA,WAAK,OAAL,GAFsB,CAEL;;AACjB,aAAO,IAAP,EAAa;AACX,YAAI,KAAK,CAAC,OAAN,CAAc,KAAK,IAAnB,CAAJ,EAA8B,CAC5B;AACD,SAFD,MAEO,IAAI,KAAK,IAAL,IAAa,KAAK,CAAC,OAAvB,EAAgC;AACrC,UAAA,MAAM,GAAG,KAAT;AACD,SAFM,MAEA,IAAI,eAAe,CAAC,KAAK,IAAN,CAAnB,EAAgC;AACrC,eAAK,OAAL;AACA,cAAI,cAAc,CAAC,KAAK,IAAN,CAAlB,EAA+B,KAAK,OAAL;AAC/B,cAAI,CAAC,KAAK,CAAC,OAAN,CAAc,KAAK,IAAnB,CAAL,EAA+B,OAAO,KAAK,KAAL,CAAW,kBAAX,EAA+B,CAAC,CAAhC,CAAP;AAC/B,UAAA,MAAM,GAAG,KAAT;AACD,SALM,MAKA;AACL;AACD;;AACD,aAAK,OAAL;AACD;;AACD,UAAM,GAAG,GAAW,KAAK,KAAL,CAAW,SAAX,CAAqB,KAArB,EAA4B,KAAK,KAAjC,CAApB;AACA,UAAM,KAAK,GAAW,MAAM,GAAG,iBAAiB,CAAC,GAAD,CAApB,GAA4B,UAAU,CAAC,GAAD,CAAlE;AACA,aAAO,cAAc,CAAC,KAAD,EAAQ,KAAK,KAAb,EAAoB,KAApB,CAArB;AACD,KArBD;;AAuBA,IAAA,QAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,UAAM,KAAK,GAAW,KAAK,KAA3B;AACA,UAAM,KAAK,GAAW,KAAK,IAA3B;AACA,WAAK,OAAL,GAHF,CAGmB;;AAEjB,UAAI,MAAM,GAAW,EAArB;AACA,UAAI,MAAM,GAAW,KAAK,KAA1B;AACA,UAAM,KAAK,GAAW,KAAK,KAA3B;;AAEA,aAAO,KAAK,IAAL,IAAa,KAApB,EAA2B;AACzB,YAAI,KAAK,IAAL,IAAa,KAAK,CAAC,UAAvB,EAAmC;AACjC,UAAA,MAAM,IAAI,KAAK,CAAC,SAAN,CAAgB,MAAhB,EAAwB,KAAK,KAA7B,CAAV;AACA,eAAK,OAAL;AACA,cAAI,aAAa,GAAA,KAAA,CAAjB,CAHiC,CAIjC;;AACA,eAAK,IAAL,GAAY,KAAK,IAAjB;;AACA,cAAI,KAAK,IAAL,IAAa,KAAK,CAAC,EAAvB,EAA2B;AACzB;AACA,gBAAM,GAAG,GAAW,KAAK,CAAC,SAAN,CAAgB,KAAK,KAAL,GAAa,CAA7B,EAAgC,KAAK,KAAL,GAAa,CAA7C,CAApB;;AACA,gBAAI,eAAe,IAAf,CAAoB,GAApB,CAAJ,EAA8B;AAC5B,cAAA,aAAa,GAAG,QAAQ,CAAC,GAAD,EAAM,EAAN,CAAxB;AACD,aAFD,MAEO;AACL,qBAAO,KAAK,KAAL,CAAW,gCAA8B,GAA9B,GAAiC,GAA5C,EAAiD,CAAjD,CAAP;AACD;;AACD,iBAAK,IAAI,CAAC,GAAW,CAArB,EAAwB,CAAC,GAAG,CAA5B,EAA+B,CAAC,EAAhC,EAAoC;AAClC,mBAAK,OAAL;AACD;AACF,WAXD,MAWO;AACL,YAAA,aAAa,GAAG,QAAQ,CAAC,KAAK,IAAN,CAAxB;AACA,iBAAK,OAAL;AACD;;AACD,UAAA,MAAM,IAAI,MAAM,CAAC,YAAP,CAAoB,aAApB,CAAV;AACA,UAAA,MAAM,GAAG,KAAK,KAAd;AACD,SAvBD,MAuBO,IAAI,KAAK,IAAL,IAAa,KAAK,CAAC,IAAvB,EAA6B;AAClC,iBAAO,KAAK,KAAL,CAAW,oBAAX,EAAiC,CAAjC,CAAP;AACD,SAFM,MAEA;AACL,eAAK,OAAL;AACD;AACF;;AAED,UAAM,IAAI,GAAW,KAAK,CAAC,SAAN,CAAgB,MAAhB,EAAwB,KAAK,KAA7B,CAArB;AACA,WAAK,OAAL,GAzCF,CAyCmB;;AAEjB,aAAO,cAAc,CAAC,KAAD,EAAQ,KAAK,KAAb,EAAoB,MAAM,GAAG,IAA7B,CAArB;AACD,KA5CD;;AA8CA,IAAA,QAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAuB,MAAvB,EAAqC;AACnC,UAAM,QAAQ,GAAW,KAAK,KAAL,GAAa,MAAtC;AACA,aAAO,aAAa,CAChB,QADgB,EACN,KAAK,KADC,EAEhB,kBAAgB,OAAhB,GAAuB,aAAvB,GAAqC,QAArC,GAA6C,kBAA7C,GAAgE,KAAK,KAArE,GAA0E,GAF1D,CAApB;AAGD,KALD;;AAMF,WAAA,QAAA;AAAC,GAjND,EAAA;;AAmNA,WAAS,iBAAT,CAA2B,IAA3B,EAAuC;AACrC,WAAQ,KAAK,CAAC,EAAN,IAAY,IAAZ,IAAoB,IAAI,IAAI,KAAK,CAAC,EAAnC,IAA2C,KAAK,CAAC,EAAN,IAAY,IAAZ,IAAoB,IAAI,IAAI,KAAK,CAAC,EAA7E,IACF,IAAI,IAAI,KAAK,CAAC,EADZ,IACoB,IAAI,IAAI,KAAK,CAAC,EADzC;AAED;;AAED,WAAgB,YAAhB,CAA6B,KAA7B,EAA0C;AACxC,QAAI,KAAK,CAAC,MAAN,IAAgB,CAApB,EAAuB,OAAO,KAAP;AACvB,QAAM,OAAO,GAAG,IAAI,QAAJ,CAAa,KAAb,CAAhB;AACA,QAAI,CAAC,iBAAiB,CAAC,OAAO,CAAC,IAAT,CAAtB,EAAsC,OAAO,KAAP;AACtC,IAAA,OAAO,CAAC,OAAR;;AACA,WAAO,OAAO,CAAC,IAAR,KAAiB,KAAK,CAAC,IAA9B,EAAoC;AAClC,UAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,IAAT,CAArB,EAAqC,OAAO,KAAP;AACrC,MAAA,OAAO,CAAC,OAAR;AACD;;AACD,WAAO,IAAP;AACD;;AAVD,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA;;AAYA,WAAS,gBAAT,CAA0B,IAA1B,EAAsC;AACpC,WAAO,KAAK,CAAC,aAAN,CAAoB,IAApB,KAA6B,KAAK,CAAC,OAAN,CAAc,IAAd,CAA7B,IAAqD,IAAI,IAAI,KAAK,CAAC,EAAnE,IACF,IAAI,IAAI,KAAK,CAAC,EADnB;AAED;;AAED,WAAS,eAAT,CAAyB,IAAzB,EAAqC;AACnC,WAAO,IAAI,IAAI,KAAK,CAAC,EAAd,IAAoB,IAAI,IAAI,KAAK,CAAC,EAAzC;AACD;;AAED,WAAS,cAAT,CAAwB,IAAxB,EAAoC;AAClC,WAAO,IAAI,IAAI,KAAK,CAAC,MAAd,IAAwB,IAAI,IAAI,KAAK,CAAC,KAA7C;AACD;;AAED,WAAgB,OAAhB,CAAwB,IAAxB,EAAoC;AAClC,WAAO,IAAI,KAAK,KAAK,CAAC,GAAf,IAAsB,IAAI,KAAK,KAAK,CAAC,GAArC,IAA4C,IAAI,KAAK,KAAK,CAAC,GAAlE;AACD;;AAFD,EAAA,OAAA,CAAA,OAAA,GAAA,OAAA;;AAIA,WAAS,QAAT,CAAkB,IAAlB,EAA8B;AAC5B,YAAQ,IAAR;AACE,WAAK,KAAK,CAAC,EAAX;AACE,eAAO,KAAK,CAAC,GAAb;;AACF,WAAK,KAAK,CAAC,EAAX;AACE,eAAO,KAAK,CAAC,GAAb;;AACF,WAAK,KAAK,CAAC,EAAX;AACE,eAAO,KAAK,CAAC,GAAb;;AACF,WAAK,KAAK,CAAC,EAAX;AACE,eAAO,KAAK,CAAC,IAAb;;AACF,WAAK,KAAK,CAAC,EAAX;AACE,eAAO,KAAK,CAAC,KAAb;;AACF;AACE,eAAO,IAAP;AAZJ;AAcD;;AAED,WAAS,iBAAT,CAA2B,IAA3B,EAAuC;AACrC,QAAM,MAAM,GAAW,QAAQ,CAAC,IAAD,CAA/B;;AACA,QAAI,KAAK,CAAC,MAAD,CAAT,EAAmB;AACjB,YAAM,IAAI,KAAJ,CAAU,0CAA0C,IAApD,CAAN;AACD;;AACD,WAAO,MAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\n\nexport enum TokenType {\n  Character,\n  Identifier,\n  Keyword,\n  String,\n  Operator,\n  Number,\n  Error\n}\n\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nexport class Lexer {\n  tokenize(text: string): Token[] {\n    const scanner = new _Scanner(text);\n    const tokens: Token[] = [];\n    let token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\n}\n\nexport class Token {\n  constructor(\n      public index: number, public end: number, public type: TokenType, public numValue: number,\n      public strValue: string) {}\n\n  isCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n\n  isNumber(): boolean {\n    return this.type == TokenType.Number;\n  }\n\n  isString(): boolean {\n    return this.type == TokenType.String;\n  }\n\n  isOperator(operator: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operator;\n  }\n\n  isIdentifier(): boolean {\n    return this.type == TokenType.Identifier;\n  }\n\n  isKeyword(): boolean {\n    return this.type == TokenType.Keyword;\n  }\n\n  isKeywordLet(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'let';\n  }\n\n  isKeywordAs(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'as';\n  }\n\n  isKeywordNull(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'null';\n  }\n\n  isKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n\n  isKeywordTrue(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'true';\n  }\n\n  isKeywordFalse(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'false';\n  }\n\n  isKeywordThis(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'this';\n  }\n\n  isError(): boolean {\n    return this.type == TokenType.Error;\n  }\n\n  toNumber(): number {\n    return this.type == TokenType.Number ? this.numValue : -1;\n  }\n\n  toString(): string|null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction newCharacterToken(index: number, end: number, code: number): Token {\n  return new Token(index, end, TokenType.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.Operator, 0, text);\n}\n\nfunction newStringToken(index: number, end: number, text: string): Token {\n  return new Token(index, end, TokenType.String, 0, text);\n}\n\nfunction newNumberToken(index: number, end: number, n: number): Token {\n  return new Token(index, end, TokenType.Number, n, '');\n}\n\nfunction newErrorToken(index: number, end: number, message: string): Token {\n  return new Token(index, end, TokenType.Error, 0, message);\n}\n\nexport const EOF: Token = new Token(-1, -1, TokenType.Character, 0, '');\n\nclass _Scanner {\n  length: number;\n  peek: number = 0;\n  index: number = -1;\n\n  constructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n\n  advance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n\n  scanToken(): Token|null {\n    const input = this.input, length = this.length;\n    let peek = this.peek, index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                                          newCharacterToken(start, this.index, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n            start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n\n  scanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, this.index, code);\n  }\n\n\n  scanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, this.index, str);\n  }\n\n  /**\n   * Tokenize a 2/3 char long operator\n   *\n   * @param start start index in the expression\n   * @param one first symbol (always part of the operator)\n   * @param twoCode code point for the second symbol\n   * @param two second symbol (part of the operator when the second code point matches)\n   * @param threeCode code point for the third symbol\n   * @param three third symbol (part of the operator when provided and matches source expression)\n   */\n  scanComplexOperator(\n      start: number, one: string, twoCode: number, two: string, threeCode?: number,\n      three?: string): Token {\n    this.advance();\n    let str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, this.index, str);\n  }\n\n  scanIdentifier(): Token {\n    const start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\n                                        newIdentifierToken(start, this.index, str);\n  }\n\n  scanNumber(start: number): Token {\n    let simple: boolean = (this.index === start);\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const str: string = this.input.substring(start, this.index);\n    const value: number = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, this.index, value);\n  }\n\n  scanString(): Token {\n    const start: number = this.index;\n    const quote: number = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let buffer: string = '';\n    let marker: number = this.index;\n    const input: string = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let i: number = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, this.index, buffer + last);\n  }\n\n  error(message: string, offset: number): Token {\n    const position: number = this.index + offset;\n    return newErrorToken(\n        position, this.index,\n        `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n      (code == chars.$_) || (code == chars.$$);\n}\n\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n      (code == chars.$$);\n}\n\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text: string): number {\n  const result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}