{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n/**\n * Filesystem Cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n */\n\n\nvar fs = require(\"fs\");\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n\nvar zlib = require(\"zlib\");\n\nvar crypto = require(\"crypto\");\n\nvar mkdirpOrig = require(\"mkdirp\");\n\nvar findCacheDir = require(\"find-cache-dir\");\n\nvar promisify = require(\"pify\");\n\nvar transform = require(\"./transform\"); // Lazily instantiated when needed\n\n\nvar defaultCacheDirectory = null;\nvar readFile = promisify(fs.readFile);\nvar writeFile = promisify(fs.writeFile);\nvar gunzip = promisify(zlib.gunzip);\nvar gzip = promisify(zlib.gzip);\nvar mkdirp = promisify(mkdirpOrig);\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n */\n\nvar read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(filename, compress) {\n    var data, content;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return readFile(filename + (compress ? \".gz\" : \"\"));\n\n          case 2:\n            data = _context.sent;\n\n            if (!compress) {\n              _context.next = 9;\n              break;\n            }\n\n            _context.next = 6;\n            return gunzip(data);\n\n          case 6:\n            _context.t0 = _context.sent;\n            _context.next = 10;\n            break;\n\n          case 9:\n            _context.t0 = data;\n\n          case 10:\n            content = _context.t0;\n            return _context.abrupt(\"return\", JSON.parse(content.toString()));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function read(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {String} result\n */\n\n\nvar write = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(filename, compress, result) {\n    var content, data;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            content = JSON.stringify(result);\n\n            if (!compress) {\n              _context2.next = 7;\n              break;\n            }\n\n            _context2.next = 4;\n            return gzip(content);\n\n          case 4:\n            _context2.t0 = _context2.sent;\n            _context2.next = 8;\n            break;\n\n          case 7:\n            _context2.t0 = content;\n\n          case 8:\n            data = _context2.t0;\n            _context2.next = 11;\n            return writeFile(filename + (compress ? \".gz\" : \"\"), data);\n\n          case 11:\n            return _context2.abrupt(\"return\", _context2.sent);\n\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function write(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\n\n\nvar filename = function filename(source, identifier, options) {\n  var hash = crypto.createHash(\"md4\");\n  var contents = JSON.stringify({\n    source: source,\n    options: options,\n    identifier: identifier\n  });\n  hash.update(contents);\n  return hash.digest(\"hex\") + \".json\";\n};\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n */\n\n\nvar handleCache = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(directory, params) {\n    var source, _params$options, options, cacheIdentifier, cacheDirectory, cacheCompression, file, fallback, result;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            source = params.source, _params$options = params.options, options = _params$options === void 0 ? {} : _params$options, cacheIdentifier = params.cacheIdentifier, cacheDirectory = params.cacheDirectory, cacheCompression = params.cacheCompression;\n            file = path.join(directory, filename(source, cacheIdentifier, options));\n            _context3.prev = 2;\n            _context3.next = 5;\n            return read(file, cacheCompression);\n\n          case 5:\n            return _context3.abrupt(\"return\", _context3.sent);\n\n          case 8:\n            _context3.prev = 8;\n            _context3.t0 = _context3[\"catch\"](2);\n\n          case 10:\n            fallback = typeof cacheDirectory !== \"string\" && directory !== os.tmpdir(); // Make sure the directory exists.\n\n            _context3.prev = 11;\n            _context3.next = 14;\n            return mkdirp(directory);\n\n          case 14:\n            _context3.next = 21;\n            break;\n\n          case 16:\n            _context3.prev = 16;\n            _context3.t1 = _context3[\"catch\"](11);\n\n            if (!fallback) {\n              _context3.next = 20;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", handleCache(os.tmpdir(), params));\n\n          case 20:\n            throw _context3.t1;\n\n          case 21:\n            _context3.next = 23;\n            return transform(source, options);\n\n          case 23:\n            result = _context3.sent;\n            _context3.prev = 24;\n            _context3.next = 27;\n            return write(file, cacheCompression, result);\n\n          case 27:\n            _context3.next = 34;\n            break;\n\n          case 29:\n            _context3.prev = 29;\n            _context3.t2 = _context3[\"catch\"](24);\n\n            if (!fallback) {\n              _context3.next = 33;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", handleCache(os.tmpdir(), params));\n\n          case 33:\n            throw _context3.t2;\n\n          case 34:\n            return _context3.abrupt(\"return\", result);\n\n          case 35:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[2, 8], [11, 16], [24, 29]]);\n  }));\n\n  return function handleCache(_x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.directory  Directory to store cached files\n * @param  {String}   params.identifier Unique identifier to bust cache\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n * @param  {Function} params.transform  Function that will transform the\n *                                      original file and whose result will be\n *                                      cached\n *\n * @example\n *\n *   cache({\n *     directory: '.tmp/cache',\n *     identifier: 'babel-loader-cachefile',\n *     cacheCompression: false,\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *     transform: function(source, options) {\n *       var content = *do what you need with the source*\n *       return content;\n *     }\n *   }, function(err, result) {\n *\n *   });\n */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(params) {\n    var directory;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            if (typeof params.cacheDirectory === \"string\") {\n              directory = params.cacheDirectory;\n            } else {\n              if (defaultCacheDirectory === null) {\n                defaultCacheDirectory = findCacheDir({\n                  name: \"babel-loader\"\n                }) || os.tmpdir();\n              }\n\n              directory = defaultCacheDirectory;\n            }\n\n            _context4.next = 3;\n            return handleCache(directory, params);\n\n          case 3:\n            return _context4.abrupt(\"return\", _context4.sent);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/babel-loader/lib/cache.js"],"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","_asyncToGenerator","fn","self","args","arguments","apply","err","undefined","fs","require","os","path","zlib","crypto","mkdirpOrig","findCacheDir","promisify","transform","defaultCacheDirectory","readFile","writeFile","gunzip","gzip","mkdirp","read","_ref","filename","compress","data","content","JSON","parse","toString","_x","_x2","write","_ref2","result","stringify","_x3","_x4","_x5","source","identifier","options","hash","createHash","contents","update","digest","handleCache","_ref3","directory","params","cacheIdentifier","cacheDirectory","cacheCompression","file","join","fallback","tmpdir","_x6","_x7","module","exports","_ref4","name","_x8"],"mappings":"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","sourcesContent":["\"use strict\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/**\n * Filesystem Cache\n *\n * Given a file and a transform function, cache the result into files\n * or retrieve the previously cached files if the given file is already known.\n *\n * @see https://github.com/babel/babel-loader/issues/34\n * @see https://github.com/babel/babel-loader/pull/41\n */\nconst fs = require(\"fs\");\n\nconst os = require(\"os\");\n\nconst path = require(\"path\");\n\nconst zlib = require(\"zlib\");\n\nconst crypto = require(\"crypto\");\n\nconst mkdirpOrig = require(\"mkdirp\");\n\nconst findCacheDir = require(\"find-cache-dir\");\n\nconst promisify = require(\"pify\");\n\nconst transform = require(\"./transform\"); // Lazily instantiated when needed\n\n\nlet defaultCacheDirectory = null;\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\nconst gunzip = promisify(zlib.gunzip);\nconst gzip = promisify(zlib.gzip);\nconst mkdirp = promisify(mkdirpOrig);\n/**\n * Read the contents from the compressed file.\n *\n * @async\n * @params {String} filename\n */\n\nconst read =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(function* (filename, compress) {\n    const data = yield readFile(filename + (compress ? \".gz\" : \"\"));\n    const content = compress ? yield gunzip(data) : data;\n    return JSON.parse(content.toString());\n  });\n\n  return function read(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Write contents into a compressed file.\n *\n * @async\n * @params {String} filename\n * @params {String} result\n */\n\n\nconst write =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(function* (filename, compress, result) {\n    const content = JSON.stringify(result);\n    const data = compress ? yield gzip(content) : content;\n    return yield writeFile(filename + (compress ? \".gz\" : \"\"), data);\n  });\n\n  return function write(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Build the filename for the cached file\n *\n * @params {String} source  File source code\n * @params {Object} options Options used\n *\n * @return {String}\n */\n\n\nconst filename = function (source, identifier, options) {\n  const hash = crypto.createHash(\"md4\");\n  const contents = JSON.stringify({\n    source,\n    options,\n    identifier\n  });\n  hash.update(contents);\n  return hash.digest(\"hex\") + \".json\";\n};\n/**\n * Handle the cache\n *\n * @params {String} directory\n * @params {Object} params\n */\n\n\nconst handleCache =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(function* (directory, params) {\n    const {\n      source,\n      options = {},\n      cacheIdentifier,\n      cacheDirectory,\n      cacheCompression\n    } = params;\n    const file = path.join(directory, filename(source, cacheIdentifier, options));\n\n    try {\n      // No errors mean that the file was previously cached\n      // we just need to return it\n      return yield read(file, cacheCompression);\n    } catch (err) {}\n\n    const fallback = typeof cacheDirectory !== \"string\" && directory !== os.tmpdir(); // Make sure the directory exists.\n\n    try {\n      yield mkdirp(directory);\n    } catch (err) {\n      if (fallback) {\n        return handleCache(os.tmpdir(), params);\n      }\n\n      throw err;\n    } // Otherwise just transform the file\n    // return it to the user asap and write it in cache\n\n\n    const result = yield transform(source, options);\n\n    try {\n      yield write(file, cacheCompression, result);\n    } catch (err) {\n      if (fallback) {\n        // Fallback to tmpdir if node_modules folder not writable\n        return handleCache(os.tmpdir(), params);\n      }\n\n      throw err;\n    }\n\n    return result;\n  });\n\n  return function handleCache(_x6, _x7) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Retrieve file from cache, or create a new one for future reads\n *\n * @async\n * @param  {Object}   params\n * @param  {String}   params.directory  Directory to store cached files\n * @param  {String}   params.identifier Unique identifier to bust cache\n * @param  {String}   params.source   Original contents of the file to be cached\n * @param  {Object}   params.options  Options to be given to the transform fn\n * @param  {Function} params.transform  Function that will transform the\n *                                      original file and whose result will be\n *                                      cached\n *\n * @example\n *\n *   cache({\n *     directory: '.tmp/cache',\n *     identifier: 'babel-loader-cachefile',\n *     cacheCompression: false,\n *     source: *source code from file*,\n *     options: {\n *       experimental: true,\n *       runtime: true\n *     },\n *     transform: function(source, options) {\n *       var content = *do what you need with the source*\n *       return content;\n *     }\n *   }, function(err, result) {\n *\n *   });\n */\n\n\nmodule.exports =\n/*#__PURE__*/\nfunction () {\n  var _ref4 = _asyncToGenerator(function* (params) {\n    let directory;\n\n    if (typeof params.cacheDirectory === \"string\") {\n      directory = params.cacheDirectory;\n    } else {\n      if (defaultCacheDirectory === null) {\n        defaultCacheDirectory = findCacheDir({\n          name: \"babel-loader\"\n        }) || os.tmpdir();\n      }\n\n      directory = defaultCacheDirectory;\n    }\n\n    return yield handleCache(directory, params);\n  });\n\n  return function (_x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();"]},"metadata":{},"sourceType":"script"}