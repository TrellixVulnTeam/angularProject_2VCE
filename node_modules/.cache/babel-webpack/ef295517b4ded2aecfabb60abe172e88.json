{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/constant_pool\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/output/output_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ConstantPool = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var CONSTANT_PREFIX = '_c';\n  /**\n   * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n   * We determine whether literals are identical by creating a key out of their AST using the\n   * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n   * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n   * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n   * that we use a variable, rather than something like `null` in order to avoid collisions.\n   */\n\n  var UNKNOWN_VALUE_KEY = o.variable('<unknown>');\n  /**\n   * Context to use when producing a key.\n   *\n   * This ensures we see the constant not the reference variable when producing\n   * a key.\n   */\n\n  var KEY_CONTEXT = {};\n  /**\n   * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n   * for strings that reach a certain length threshold. This constant defines the length threshold for\n   * strings.\n   */\n\n  var POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n  /**\n   * A node that is a place-holder that allows the node to be replaced when the actual\n   * node is known.\n   *\n   * This allows the constant pool to change an expression from a direct reference to\n   * a constant to a shared constant. It returns a fix-up node that is later allowed to\n   * change the referenced expression.\n   */\n\n  var FixupExpression =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(FixupExpression, _super);\n\n    function FixupExpression(resolved) {\n      var _this = _super.call(this, resolved.type) || this;\n\n      _this.resolved = resolved;\n      _this.original = resolved;\n      return _this;\n    }\n\n    FixupExpression.prototype.visitExpression = function (visitor, context) {\n      if (context === KEY_CONTEXT) {\n        // When producing a key we want to traverse the constant not the\n        // variable used to refer to it.\n        return this.original.visitExpression(visitor, context);\n      } else {\n        return this.resolved.visitExpression(visitor, context);\n      }\n    };\n\n    FixupExpression.prototype.isEquivalent = function (e) {\n      return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n    };\n\n    FixupExpression.prototype.isConstant = function () {\n      return true;\n    };\n\n    FixupExpression.prototype.fixup = function (expression) {\n      this.resolved = expression;\n      this.shared = true;\n    };\n\n    return FixupExpression;\n  }(o.Expression);\n  /**\n   * A constant pool allows a code emitter to share constant in an output context.\n   *\n   * The constant pool also supports sharing access to ivy definitions references.\n   */\n\n\n  var ConstantPool =\n  /** @class */\n  function () {\n    function ConstantPool(isClosureCompilerEnabled) {\n      if (isClosureCompilerEnabled === void 0) {\n        isClosureCompilerEnabled = false;\n      }\n\n      this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n      this.statements = [];\n      this.literals = new Map();\n      this.literalFactories = new Map();\n      this.injectorDefinitions = new Map();\n      this.directiveDefinitions = new Map();\n      this.componentDefinitions = new Map();\n      this.pipeDefinitions = new Map();\n      this.nextNameIndex = 0;\n    }\n\n    ConstantPool.prototype.getConstLiteral = function (literal, forceShared) {\n      if (literal instanceof o.LiteralExpr && !isLongStringLiteral(literal) || literal instanceof FixupExpression) {\n        // Do no put simple literals into the constant pool or try to produce a constant for a\n        // reference to a constant.\n        return literal;\n      }\n\n      var key = this.keyOf(literal);\n      var fixup = this.literals.get(key);\n      var newValue = false;\n\n      if (!fixup) {\n        fixup = new FixupExpression(literal);\n        this.literals.set(key, fixup);\n        newValue = true;\n      }\n\n      if (!newValue && !fixup.shared || newValue && forceShared) {\n        // Replace the expression with a variable\n        var name_1 = this.freshName();\n        var definition = void 0;\n        var usage = void 0;\n\n        if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n          // For string literals, Closure will **always** inline the string at\n          // **all** usages, duplicating it each time. For large strings, this\n          // unnecessarily bloats bundle size. To work around this restriction, we\n          // wrap the string in a function, and call that function for each usage.\n          // This tricks Closure into using inline logic for functions instead of\n          // string literals. Function calls are only inlined if the body is small\n          // enough to be worth it. By doing this, very large strings will be\n          // shared across multiple usages, rather than duplicating the string at\n          // each usage site.\n          //\n          // const myStr = function() { return \"very very very long string\"; };\n          // const usage1 = myStr();\n          // const usage2 = myStr();\n          definition = o.variable(name_1).set(new o.FunctionExpr([], // Params.\n          [// Statements.\n          new o.ReturnStatement(literal)]));\n          usage = o.variable(name_1).callFn([]);\n        } else {\n          // Just declare and use the variable directly, without a function call\n          // indirection. This saves a few bytes and avoids an unncessary call.\n          definition = o.variable(name_1).set(literal);\n          usage = o.variable(name_1);\n        }\n\n        this.statements.push(definition.toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n        fixup.fixup(usage);\n      }\n\n      return fixup;\n    };\n\n    ConstantPool.prototype.getDefinition = function (type, kind, ctx, forceShared) {\n      if (forceShared === void 0) {\n        forceShared = false;\n      }\n\n      var definitions = this.definitionsOf(kind);\n      var fixup = definitions.get(type);\n      var newValue = false;\n\n      if (!fixup) {\n        var property = this.propertyNameOf(kind);\n        fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n        definitions.set(type, fixup);\n        newValue = true;\n      }\n\n      if (!newValue && !fixup.shared || newValue && forceShared) {\n        var name_2 = this.freshName();\n        this.statements.push(o.variable(name_2).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n        fixup.fixup(o.variable(name_2));\n      }\n\n      return fixup;\n    };\n\n    ConstantPool.prototype.getLiteralFactory = function (literal) {\n      // Create a pure function that builds an array of a mix of constant and variable expressions\n      if (literal instanceof o.LiteralArrayExpr) {\n        var argumentsForKey = literal.entries.map(function (e) {\n          return e.isConstant() ? e : UNKNOWN_VALUE_KEY;\n        });\n        var key = this.keyOf(o.literalArr(argumentsForKey));\n        return this._getLiteralFactory(key, literal.entries, function (entries) {\n          return o.literalArr(entries);\n        });\n      } else {\n        var expressionForKey = o.literalMap(literal.entries.map(function (e) {\n          return {\n            key: e.key,\n            value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n            quoted: e.quoted\n          };\n        }));\n        var key = this.keyOf(expressionForKey);\n        return this._getLiteralFactory(key, literal.entries.map(function (e) {\n          return e.value;\n        }), function (entries) {\n          return o.literalMap(entries.map(function (value, index) {\n            return {\n              key: literal.entries[index].key,\n              value: value,\n              quoted: literal.entries[index].quoted\n            };\n          }));\n        });\n      }\n    };\n\n    ConstantPool.prototype._getLiteralFactory = function (key, values, resultMap) {\n      var _this = this;\n\n      var literalFactory = this.literalFactories.get(key);\n      var literalFactoryArguments = values.filter(function (e) {\n        return !e.isConstant();\n      });\n\n      if (!literalFactory) {\n        var resultExpressions = values.map(function (e, index) {\n          return e.isConstant() ? _this.getConstLiteral(e, true) : o.variable(\"a\" + index);\n        });\n        var parameters = resultExpressions.filter(isVariable).map(function (e) {\n          return new o.FnParam(e.name, o.DYNAMIC_TYPE);\n        });\n        var pureFunctionDeclaration = o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n        var name_3 = this.freshName();\n        this.statements.push(o.variable(name_3).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n        literalFactory = o.variable(name_3);\n        this.literalFactories.set(key, literalFactory);\n      }\n\n      return {\n        literalFactory: literalFactory,\n        literalFactoryArguments: literalFactoryArguments\n      };\n    };\n    /**\n     * Produce a unique name.\n     *\n     * The name might be unique among different prefixes if any of the prefixes end in\n     * a digit so the prefix should be a constant string (not based on user input) and\n     * must not end in a digit.\n     */\n\n\n    ConstantPool.prototype.uniqueName = function (prefix) {\n      return \"\" + prefix + this.nextNameIndex++;\n    };\n\n    ConstantPool.prototype.definitionsOf = function (kind) {\n      switch (kind) {\n        case 2\n        /* Component */\n        :\n          return this.componentDefinitions;\n\n        case 1\n        /* Directive */\n        :\n          return this.directiveDefinitions;\n\n        case 0\n        /* Injector */\n        :\n          return this.injectorDefinitions;\n\n        case 3\n        /* Pipe */\n        :\n          return this.pipeDefinitions;\n      }\n    };\n\n    ConstantPool.prototype.propertyNameOf = function (kind) {\n      switch (kind) {\n        case 2\n        /* Component */\n        :\n          return 'ɵcmp';\n\n        case 1\n        /* Directive */\n        :\n          return 'ɵdir';\n\n        case 0\n        /* Injector */\n        :\n          return 'ɵinj';\n\n        case 3\n        /* Pipe */\n        :\n          return 'ɵpipe';\n      }\n    };\n\n    ConstantPool.prototype.freshName = function () {\n      return this.uniqueName(CONSTANT_PREFIX);\n    };\n\n    ConstantPool.prototype.keyOf = function (expression) {\n      return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n    };\n\n    return ConstantPool;\n  }();\n\n  exports.ConstantPool = ConstantPool;\n  /**\n   * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n   * `ConstantPool`.\n   *\n   * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n   */\n\n  var KeyVisitor =\n  /** @class */\n  function () {\n    function KeyVisitor() {\n      this.visitWrappedNodeExpr = invalid;\n      this.visitWriteVarExpr = invalid;\n      this.visitWriteKeyExpr = invalid;\n      this.visitWritePropExpr = invalid;\n      this.visitInvokeMethodExpr = invalid;\n      this.visitInvokeFunctionExpr = invalid;\n      this.visitTaggedTemplateExpr = invalid;\n      this.visitInstantiateExpr = invalid;\n      this.visitConditionalExpr = invalid;\n      this.visitNotExpr = invalid;\n      this.visitAssertNotNullExpr = invalid;\n      this.visitCastExpr = invalid;\n      this.visitFunctionExpr = invalid;\n      this.visitUnaryOperatorExpr = invalid;\n      this.visitBinaryOperatorExpr = invalid;\n      this.visitReadPropExpr = invalid;\n      this.visitReadKeyExpr = invalid;\n      this.visitCommaExpr = invalid;\n      this.visitLocalizedString = invalid;\n    }\n\n    KeyVisitor.prototype.visitLiteralExpr = function (ast) {\n      return \"\" + (typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value);\n    };\n\n    KeyVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n      var _this = this;\n\n      return \"[\" + ast.entries.map(function (entry) {\n        return entry.visitExpression(_this, context);\n      }).join(',') + \"]\";\n    };\n\n    KeyVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n      var _this = this;\n\n      var mapKey = function mapKey(entry) {\n        var quote = entry.quoted ? '\"' : '';\n        return \"\" + quote + entry.key + quote;\n      };\n\n      var mapEntry = function mapEntry(entry) {\n        return mapKey(entry) + \":\" + entry.value.visitExpression(_this, context);\n      };\n\n      return \"{\" + ast.entries.map(mapEntry).join(',');\n    };\n\n    KeyVisitor.prototype.visitExternalExpr = function (ast) {\n      return ast.value.moduleName ? \"EX:\" + ast.value.moduleName + \":\" + ast.value.name : \"EX:\" + ast.value.runtime.name;\n    };\n\n    KeyVisitor.prototype.visitReadVarExpr = function (node) {\n      return \"VAR:\" + node.name;\n    };\n\n    KeyVisitor.prototype.visitTypeofExpr = function (node, context) {\n      return \"TYPEOF:\" + node.expr.visitExpression(this, context);\n    };\n\n    return KeyVisitor;\n  }();\n\n  function invalid(arg) {\n    throw new Error(\"Invalid state: Visitor \" + this.constructor.name + \" doesn't handle \" + arg.constructor.name);\n  }\n\n  function isVariable(e) {\n    return e instanceof o.ReadVarExpr;\n  }\n\n  function isLongStringLiteral(expr) {\n    return expr instanceof o.LiteralExpr && typeof expr.value === 'string' && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n  }\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/constant_pool.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {error, OutputContext} from './util';\n\nconst CONSTANT_PREFIX = '_c';\n\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = o.variable('<unknown>');\n\nexport const enum DefinitionKind {\n  Injector,\n  Directive,\n  Component,\n  Pipe\n}\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  // TODO(issue/24571): remove '!'.\n  shared!: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  isConstant() {\n    return true;\n  }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private injectorDefinitions = new Map<any, FixupExpression>();\n  private directiveDefinitions = new Map<any, FixupExpression>();\n  private componentDefinitions = new Map<any, FixupExpression>();\n  private pipeDefinitions = new Map<any, FixupExpression>();\n\n  private nextNameIndex = 0;\n\n  constructor(private readonly isClosureCompilerEnabled: boolean = false) {}\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if ((literal instanceof o.LiteralExpr && !isLongStringLiteral(literal)) ||\n        literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      let definition: o.WriteVarExpr;\n      let usage: o.Expression;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        // For string literals, Closure will **always** inline the string at\n        // **all** usages, duplicating it each time. For large strings, this\n        // unnecessarily bloats bundle size. To work around this restriction, we\n        // wrap the string in a function, and call that function for each usage.\n        // This tricks Closure into using inline logic for functions instead of\n        // string literals. Function calls are only inlined if the body is small\n        // enough to be worth it. By doing this, very large strings will be\n        // shared across multiple usages, rather than duplicating the string at\n        // each usage site.\n        //\n        // const myStr = function() { return \"very very very long string\"; };\n        // const usage1 = myStr();\n        // const usage2 = myStr();\n        definition = o.variable(name).set(new o.FunctionExpr(\n            [],  // Params.\n            [\n              // Statements.\n              new o.ReturnStatement(literal),\n            ],\n            ));\n        usage = o.variable(name).callFn([]);\n      } else {\n        // Just declare and use the variable directly, without a function call\n        // indirection. This saves a few bytes and avoids an unncessary call.\n        definition = o.variable(name).set(literal);\n        usage = o.variable(name);\n      }\n\n      this.statements.push(definition.toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(usage);\n    }\n\n    return fixup;\n  }\n\n  getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared: boolean = false):\n      o.Expression {\n    const definitions = this.definitionsOf(kind);\n    let fixup = definitions.get(type);\n    let newValue = false;\n    if (!fixup) {\n      const property = this.propertyNameOf(kind);\n      fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n      definitions.set(type, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name!, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [\n            o.StmtModifier.Final\n          ]));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string {\n    return `${prefix}${this.nextNameIndex++}`;\n  }\n\n  private definitionsOf(kind: DefinitionKind): Map<any, FixupExpression> {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return this.componentDefinitions;\n      case DefinitionKind.Directive:\n        return this.directiveDefinitions;\n      case DefinitionKind.Injector:\n        return this.injectorDefinitions;\n      case DefinitionKind.Pipe:\n        return this.pipeDefinitions;\n    }\n  }\n\n  public propertyNameOf(kind: DefinitionKind): string {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return 'ɵcmp';\n      case DefinitionKind.Directive:\n        return 'ɵdir';\n      case DefinitionKind.Injector:\n        return 'ɵinj';\n      case DefinitionKind.Pipe:\n        return 'ɵpipe';\n    }\n  }\n\n  private freshName(): string {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) {\n    return `VAR:${node.name}`;\n  }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeMethodExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitTaggedTemplateExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitUnaryOperatorExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n  visitLocalizedString = invalid;\n}\n\nfunction invalid<T>(this: o.ExpressionVisitor, arg: o.Expression|o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\nfunction isLongStringLiteral(expr: o.Expression): boolean {\n  return expr instanceof o.LiteralExpr && typeof expr.value === 'string' &&\n      expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}