{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar path = require(\"path\");\n\nvar _require = require(\"webpack-sources\"),\n    ConcatSource = _require.ConcatSource,\n    RawSource = _require.RawSource;\n\nvar ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\n\nvar SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\n\nvar createHash = require(\"./util/createHash\");\n\nvar _require2 = require(\"./util/identifier\"),\n    absolutify = _require2.absolutify;\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"source-map\").RawSourceMap} SourceMap */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./Compilation\")} Compilation */\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Compilation\")} SourceMapDefinition */\n\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {Array<string | Module>} [modules]\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {Chunk} chunk\n */\n\n/**\n * @param {string} name file path\n * @returns {string} file name\n */\n\n\nvar basename = function basename(name) {\n  if (!name.includes(\"/\")) return name;\n  return name.substr(name.lastIndexOf(\"/\") + 1);\n};\n/**\n * @type {WeakMap<Source, {file: string, assets: {[k: string]: ConcatSource | RawSource}}>}\n */\n\n\nvar assetsCache = new WeakMap();\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {Chunk} chunk related chunk\n * @param {SourceMapDevToolPluginOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\n\nvar getTaskForFile = function getTaskForFile(file, asset, chunk, options, compilation) {\n  var source, sourceMap;\n  /**\n   * Check if asset can build source map\n   */\n\n  if (asset.sourceAndMap) {\n    var sourceAndMap = asset.sourceAndMap(options);\n    sourceMap = sourceAndMap.map;\n    source = sourceAndMap.source;\n  } else {\n    sourceMap = asset.map(options);\n    source = asset.source();\n  }\n\n  if (!sourceMap || typeof source !== \"string\") return;\n  var context = compilation.options.context;\n  var modules = sourceMap.sources.map(function (source) {\n    if (source.startsWith(\"webpack://\")) {\n      source = absolutify(context, source.slice(10));\n    }\n\n    var module = compilation.findModule(source);\n    return module || source;\n  });\n  return {\n    chunk: chunk,\n    file: file,\n    asset: asset,\n    source: source,\n    sourceMap: sourceMap,\n    modules: modules\n  };\n};\n\nvar SourceMapDevToolPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {SourceMapDevToolPluginOptions} [options] options object\n   * @throws {Error} throws error, if got more than 1 arguments\n   */\n  function SourceMapDevToolPlugin(options) {\n    _classCallCheck(this, SourceMapDevToolPlugin);\n\n    if (arguments.length > 1) {\n      throw new Error(\"SourceMapDevToolPlugin only takes one argument (pass an options object)\");\n    }\n\n    if (!options) options = {};\n    validateOptions(schema, options, \"SourceMap DevTool Plugin\");\n    /** @type {string | false} */\n\n    this.sourceMapFilename = options.filename;\n    /** @type {string | false} */\n\n    this.sourceMappingURLComment = options.append === false ? false : options.append || \"\\n//# sourceMappingURL=[url]\";\n    /** @type {string | Function} */\n\n    this.moduleFilenameTemplate = options.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n    /** @type {string | Function} */\n\n    this.fallbackModuleFilenameTemplate = options.fallbackModuleFilenameTemplate || \"webpack://[namespace]/[resourcePath]?[hash]\";\n    /** @type {string} */\n\n    this.namespace = options.namespace || \"\";\n    /** @type {SourceMapDevToolPluginOptions} */\n\n    this.options = options;\n  }\n  /**\n   * Apply compiler\n   * @param {Compiler} compiler compiler instance\n   * @returns {void}\n   */\n\n\n  _createClass(SourceMapDevToolPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var sourceMapFilename = this.sourceMapFilename;\n      var sourceMappingURLComment = this.sourceMappingURLComment;\n      var moduleFilenameTemplate = this.moduleFilenameTemplate;\n      var namespace = this.namespace;\n      var fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n      var requestShortener = compiler.requestShortener;\n      var options = this.options;\n      options.test = options.test || /\\.(m?js|css)($|\\?)/i;\n      var matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n      compiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", function (compilation) {\n        new SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n        compilation.hooks.afterOptimizeChunkAssets.tap(\n        /** @type {TODO} */\n        {\n          name: \"SourceMapDevToolPlugin\",\n          context: true\n        },\n        /**\n         * @param {object} context hook context\n         * @param {Array<Chunk>} chunks resulted chunks\n         * @throws {Error} throws error, if `sourceMapFilename === false && sourceMappingURLComment === false`\n         * @returns {void}\n         */\n        function (context, chunks) {\n          /** @type {Map<string | Module, string>} */\n          var moduleToSourceNameMapping = new Map();\n          /**\n           * @type {Function}\n           * @returns {void}\n           */\n\n          var reportProgress = context && context.reportProgress ? context.reportProgress : function () {};\n          var files = [];\n\n          var _iterator = _createForOfIteratorHelper(chunks),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var chunk = _step.value;\n\n              var _iterator2 = _createForOfIteratorHelper(chunk.files),\n                  _step2;\n\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var file = _step2.value;\n\n                  if (matchObject(file)) {\n                    files.push({\n                      file: file,\n                      chunk: chunk\n                    });\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          reportProgress(0.0);\n          var tasks = [];\n          files.forEach(function (_ref, idx) {\n            var file = _ref.file,\n                chunk = _ref.chunk;\n            var asset = compilation.getAsset(file).source;\n            var cache = assetsCache.get(asset);\n            /**\n             * If presented in cache, reassigns assets. Cache assets already have source maps.\n             */\n\n            if (cache && cache.file === file) {\n              for (var cachedFile in cache.assets) {\n                if (cachedFile === file) {\n                  compilation.updateAsset(cachedFile, cache.assets[cachedFile]);\n                } else {\n                  compilation.emitAsset(cachedFile, cache.assets[cachedFile], {\n                    development: true\n                  });\n                }\n                /**\n                 * Add file to chunk, if not presented there\n                 */\n\n\n                if (cachedFile !== file) chunk.files.push(cachedFile);\n              }\n\n              return;\n            }\n\n            reportProgress(0.5 * idx / files.length, file, \"generate SourceMap\");\n            /** @type {SourceMapTask | undefined} */\n\n            var task = getTaskForFile(file, asset, chunk, options, compilation);\n\n            if (task) {\n              var modules = task.modules;\n\n              for (var _idx = 0; _idx < modules.length; _idx++) {\n                var _module = modules[_idx];\n\n                if (!moduleToSourceNameMapping.get(_module)) {\n                  moduleToSourceNameMapping.set(_module, ModuleFilenameHelpers.createFilename(_module, {\n                    moduleFilenameTemplate: moduleFilenameTemplate,\n                    namespace: namespace\n                  }, requestShortener));\n                }\n              }\n\n              tasks.push(task);\n            }\n          });\n          reportProgress(0.5, \"resolve sources\");\n          /** @type {Set<string>} */\n\n          var usedNamesSet = new Set(moduleToSourceNameMapping.values());\n          /** @type {Set<string>} */\n\n          var conflictDetectionSet = new Set();\n          /**\n           * all modules in defined order (longest identifier first)\n           * @type {Array<string | Module>}\n           */\n\n          var allModules = Array.from(moduleToSourceNameMapping.keys()).sort(function (a, b) {\n            var ai = typeof a === \"string\" ? a : a.identifier();\n            var bi = typeof b === \"string\" ? b : b.identifier();\n            return ai.length - bi.length;\n          }); // find modules with conflicting source names\n\n          for (var idx = 0; idx < allModules.length; idx++) {\n            var _module2 = allModules[idx];\n            var sourceName = moduleToSourceNameMapping.get(_module2);\n            var hasName = conflictDetectionSet.has(sourceName);\n\n            if (!hasName) {\n              conflictDetectionSet.add(sourceName);\n              continue;\n            } // try the fallback name first\n\n\n            sourceName = ModuleFilenameHelpers.createFilename(_module2, {\n              moduleFilenameTemplate: fallbackModuleFilenameTemplate,\n              namespace: namespace\n            }, requestShortener);\n            hasName = usedNamesSet.has(sourceName);\n\n            if (!hasName) {\n              moduleToSourceNameMapping.set(_module2, sourceName);\n              usedNamesSet.add(sourceName);\n              continue;\n            } // elsewise just append stars until we have a valid name\n\n\n            while (hasName) {\n              sourceName += \"*\";\n              hasName = usedNamesSet.has(sourceName);\n            }\n\n            moduleToSourceNameMapping.set(_module2, sourceName);\n            usedNamesSet.add(sourceName);\n          }\n\n          tasks.forEach(function (task, index) {\n            reportProgress(0.5 + 0.5 * index / tasks.length, task.file, \"attach SourceMap\");\n            var assets = Object.create(null);\n            var chunk = task.chunk;\n            var file = task.file;\n            var asset = task.asset;\n            var sourceMap = task.sourceMap;\n            var source = task.source;\n            var modules = task.modules;\n            var moduleFilenames = modules.map(function (m) {\n              return moduleToSourceNameMapping.get(m);\n            });\n            sourceMap.sources = moduleFilenames;\n\n            if (options.noSources) {\n              sourceMap.sourcesContent = undefined;\n            }\n\n            sourceMap.sourceRoot = options.sourceRoot || \"\";\n            sourceMap.file = file;\n            assetsCache.set(asset, {\n              file: file,\n              assets: assets\n            });\n            /** @type {string | false} */\n\n            var currentSourceMappingURLComment = sourceMappingURLComment;\n\n            if (currentSourceMappingURLComment !== false && /\\.css($|\\?)/i.test(file)) {\n              currentSourceMappingURLComment = currentSourceMappingURLComment.replace(/^\\n\\/\\/(.*)$/, \"\\n/*$1*/\");\n            }\n\n            var sourceMapString = JSON.stringify(sourceMap);\n\n            if (sourceMapFilename) {\n              var filename = file;\n              var query = \"\";\n\n              var _idx2 = filename.indexOf(\"?\");\n\n              if (_idx2 >= 0) {\n                query = filename.substr(_idx2);\n                filename = filename.substr(0, _idx2);\n              }\n\n              var pathParams = {\n                chunk: chunk,\n                filename: options.fileContext ? path.relative(options.fileContext, filename) : filename,\n                query: query,\n                basename: basename(filename),\n                contentHash: createHash(\"md4\").update(sourceMapString).digest(\"hex\")\n              };\n              var sourceMapFile = compilation.getPath(sourceMapFilename, pathParams);\n              var sourceMapUrl = options.publicPath ? options.publicPath + sourceMapFile.replace(/\\\\/g, \"/\") : path.relative(path.dirname(file), sourceMapFile).replace(/\\\\/g, \"/\");\n              /**\n               * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented\n               */\n\n              if (currentSourceMappingURLComment !== false) {\n                var _asset2 = new ConcatSource(new RawSource(source), compilation.getPath(currentSourceMappingURLComment, Object.assign({\n                  url: sourceMapUrl\n                }, pathParams)));\n\n                assets[file] = _asset2;\n                compilation.updateAsset(file, _asset2);\n              }\n              /**\n               * Add source map file to compilation assets and chunk files\n               */\n\n\n              var _asset = new RawSource(sourceMapString);\n\n              assets[sourceMapFile] = _asset;\n              compilation.emitAsset(sourceMapFile, _asset, {\n                development: true\n              });\n              chunk.files.push(sourceMapFile);\n            } else {\n              if (currentSourceMappingURLComment === false) {\n                throw new Error(\"SourceMapDevToolPlugin: append can't be false when no filename is provided\");\n              }\n              /**\n               * Add source map as data url to asset\n               */\n\n\n              var _asset3 = new ConcatSource(new RawSource(source), currentSourceMappingURLComment.replace(/\\[map\\]/g, function () {\n                return sourceMapString;\n              }).replace(/\\[url\\]/g, function () {\n                return \"data:application/json;charset=utf-8;base64,\".concat(Buffer.from(sourceMapString, \"utf-8\").toString(\"base64\"));\n              }));\n\n              assets[file] = _asset3;\n              compilation.updateAsset(file, _asset3);\n            }\n          });\n          reportProgress(1.0);\n        });\n      });\n    }\n  }]);\n\n  return SourceMapDevToolPlugin;\n}();\n\nmodule.exports = SourceMapDevToolPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/SourceMapDevToolPlugin.js"],"names":["path","require","ConcatSource","RawSource","ModuleFilenameHelpers","SourceMapDevToolModuleOptionsPlugin","createHash","absolutify","validateOptions","schema","basename","name","includes","substr","lastIndexOf","assetsCache","WeakMap","getTaskForFile","file","asset","chunk","options","compilation","source","sourceMap","sourceAndMap","map","context","modules","sources","startsWith","slice","module","findModule","SourceMapDevToolPlugin","arguments","length","Error","sourceMapFilename","filename","sourceMappingURLComment","append","moduleFilenameTemplate","fallbackModuleFilenameTemplate","namespace","compiler","requestShortener","test","matchObject","bind","undefined","hooks","tap","apply","afterOptimizeChunkAssets","chunks","moduleToSourceNameMapping","Map","reportProgress","files","push","tasks","forEach","idx","getAsset","cache","get","cachedFile","assets","updateAsset","emitAsset","development","task","set","createFilename","usedNamesSet","Set","values","conflictDetectionSet","allModules","Array","from","keys","sort","a","b","ai","identifier","bi","sourceName","hasName","has","add","index","Object","create","moduleFilenames","m","noSources","sourcesContent","sourceRoot","currentSourceMappingURLComment","replace","sourceMapString","JSON","stringify","query","indexOf","pathParams","fileContext","relative","contentHash","update","digest","sourceMapFile","getPath","sourceMapUrl","publicPath","dirname","assign","url","Buffer","toString","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\nconst { ConcatSource, RawSource } = require(\"webpack-sources\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst SourceMapDevToolModuleOptionsPlugin = require(\"./SourceMapDevToolModuleOptionsPlugin\");\nconst createHash = require(\"./util/createHash\");\nconst { absolutify } = require(\"./util/identifier\");\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../schemas/plugins/SourceMapDevToolPlugin.json\");\n\n/** @typedef {import(\"../declarations/plugins/SourceMapDevToolPlugin\").SourceMapDevToolPluginOptions} SourceMapDevToolPluginOptions */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"source-map\").RawSourceMap} SourceMap */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Compilation\")} Compilation */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Compilation\")} SourceMapDefinition */\n\n/**\n * @typedef {object} SourceMapTask\n * @property {Source} asset\n * @property {Array<string | Module>} [modules]\n * @property {string} source\n * @property {string} file\n * @property {SourceMap} sourceMap\n * @property {Chunk} chunk\n */\n\n/**\n * @param {string} name file path\n * @returns {string} file name\n */\nconst basename = name => {\n\tif (!name.includes(\"/\")) return name;\n\treturn name.substr(name.lastIndexOf(\"/\") + 1);\n};\n\n/**\n * @type {WeakMap<Source, {file: string, assets: {[k: string]: ConcatSource | RawSource}}>}\n */\nconst assetsCache = new WeakMap();\n\n/**\n * Creating {@link SourceMapTask} for given file\n * @param {string} file current compiled file\n * @param {Source} asset the asset\n * @param {Chunk} chunk related chunk\n * @param {SourceMapDevToolPluginOptions} options source map options\n * @param {Compilation} compilation compilation instance\n * @returns {SourceMapTask | undefined} created task instance or `undefined`\n */\nconst getTaskForFile = (file, asset, chunk, options, compilation) => {\n\tlet source, sourceMap;\n\t/**\n\t * Check if asset can build source map\n\t */\n\tif (asset.sourceAndMap) {\n\t\tconst sourceAndMap = asset.sourceAndMap(options);\n\t\tsourceMap = sourceAndMap.map;\n\t\tsource = sourceAndMap.source;\n\t} else {\n\t\tsourceMap = asset.map(options);\n\t\tsource = asset.source();\n\t}\n\tif (!sourceMap || typeof source !== \"string\") return;\n\tconst context = compilation.options.context;\n\tconst modules = sourceMap.sources.map(source => {\n\t\tif (source.startsWith(\"webpack://\")) {\n\t\t\tsource = absolutify(context, source.slice(10));\n\t\t}\n\t\tconst module = compilation.findModule(source);\n\t\treturn module || source;\n\t});\n\n\treturn {\n\t\tchunk,\n\t\tfile,\n\t\tasset,\n\t\tsource,\n\t\tsourceMap,\n\t\tmodules\n\t};\n};\n\nclass SourceMapDevToolPlugin {\n\t/**\n\t * @param {SourceMapDevToolPluginOptions} [options] options object\n\t * @throws {Error} throws error, if got more than 1 arguments\n\t */\n\tconstructor(options) {\n\t\tif (arguments.length > 1) {\n\t\t\tthrow new Error(\n\t\t\t\t\"SourceMapDevToolPlugin only takes one argument (pass an options object)\"\n\t\t\t);\n\t\t}\n\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"SourceMap DevTool Plugin\");\n\n\t\t/** @type {string | false} */\n\t\tthis.sourceMapFilename = options.filename;\n\t\t/** @type {string | false} */\n\t\tthis.sourceMappingURLComment =\n\t\t\toptions.append === false\n\t\t\t\t? false\n\t\t\t\t: options.append || \"\\n//# sourceMappingURL=[url]\";\n\t\t/** @type {string | Function} */\n\t\tthis.moduleFilenameTemplate =\n\t\t\toptions.moduleFilenameTemplate || \"webpack://[namespace]/[resourcePath]\";\n\t\t/** @type {string | Function} */\n\t\tthis.fallbackModuleFilenameTemplate =\n\t\t\toptions.fallbackModuleFilenameTemplate ||\n\t\t\t\"webpack://[namespace]/[resourcePath]?[hash]\";\n\t\t/** @type {string} */\n\t\tthis.namespace = options.namespace || \"\";\n\t\t/** @type {SourceMapDevToolPluginOptions} */\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * Apply compiler\n\t * @param {Compiler} compiler compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst sourceMapFilename = this.sourceMapFilename;\n\t\tconst sourceMappingURLComment = this.sourceMappingURLComment;\n\t\tconst moduleFilenameTemplate = this.moduleFilenameTemplate;\n\t\tconst namespace = this.namespace;\n\t\tconst fallbackModuleFilenameTemplate = this.fallbackModuleFilenameTemplate;\n\t\tconst requestShortener = compiler.requestShortener;\n\t\tconst options = this.options;\n\t\toptions.test = options.test || /\\.(m?js|css)($|\\?)/i;\n\n\t\tconst matchObject = ModuleFilenameHelpers.matchObject.bind(\n\t\t\tundefined,\n\t\t\toptions\n\t\t);\n\n\t\tcompiler.hooks.compilation.tap(\"SourceMapDevToolPlugin\", compilation => {\n\t\t\tnew SourceMapDevToolModuleOptionsPlugin(options).apply(compilation);\n\n\t\t\tcompilation.hooks.afterOptimizeChunkAssets.tap(\n\t\t\t\t/** @type {TODO} */\n\t\t\t\t({ name: \"SourceMapDevToolPlugin\", context: true }),\n\t\t\t\t/**\n\t\t\t\t * @param {object} context hook context\n\t\t\t\t * @param {Array<Chunk>} chunks resulted chunks\n\t\t\t\t * @throws {Error} throws error, if `sourceMapFilename === false && sourceMappingURLComment === false`\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(context, chunks) => {\n\t\t\t\t\t/** @type {Map<string | Module, string>} */\n\t\t\t\t\tconst moduleToSourceNameMapping = new Map();\n\t\t\t\t\t/**\n\t\t\t\t\t * @type {Function}\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst reportProgress =\n\t\t\t\t\t\tcontext && context.reportProgress\n\t\t\t\t\t\t\t? context.reportProgress\n\t\t\t\t\t\t\t: () => {};\n\n\t\t\t\t\tconst files = [];\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tfor (const file of chunk.files) {\n\t\t\t\t\t\t\tif (matchObject(file)) {\n\t\t\t\t\t\t\t\tfiles.push({\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\tchunk\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treportProgress(0.0);\n\t\t\t\t\tconst tasks = [];\n\t\t\t\t\tfiles.forEach(({ file, chunk }, idx) => {\n\t\t\t\t\t\tconst asset = compilation.getAsset(file).source;\n\t\t\t\t\t\tconst cache = assetsCache.get(asset);\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * If presented in cache, reassigns assets. Cache assets already have source maps.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tif (cache && cache.file === file) {\n\t\t\t\t\t\t\tfor (const cachedFile in cache.assets) {\n\t\t\t\t\t\t\t\tif (cachedFile === file) {\n\t\t\t\t\t\t\t\t\tcompilation.updateAsset(cachedFile, cache.assets[cachedFile]);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcompilation.emitAsset(cachedFile, cache.assets[cachedFile], {\n\t\t\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Add file to chunk, if not presented there\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tif (cachedFile !== file) chunk.files.push(cachedFile);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t(0.5 * idx) / files.length,\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\"generate SourceMap\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\t/** @type {SourceMapTask | undefined} */\n\t\t\t\t\t\tconst task = getTaskForFile(\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tasset,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tcompilation\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (task) {\n\t\t\t\t\t\t\tconst modules = task.modules;\n\n\t\t\t\t\t\t\tfor (let idx = 0; idx < modules.length; idx++) {\n\t\t\t\t\t\t\t\tconst module = modules[idx];\n\t\t\t\t\t\t\t\tif (!moduleToSourceNameMapping.get(module)) {\n\t\t\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(\n\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\tModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleFilenameTemplate: moduleFilenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttasks.push(task);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\treportProgress(0.5, \"resolve sources\");\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst usedNamesSet = new Set(moduleToSourceNameMapping.values());\n\t\t\t\t\t/** @type {Set<string>} */\n\t\t\t\t\tconst conflictDetectionSet = new Set();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * all modules in defined order (longest identifier first)\n\t\t\t\t\t * @type {Array<string | Module>}\n\t\t\t\t\t */\n\t\t\t\t\tconst allModules = Array.from(moduleToSourceNameMapping.keys()).sort(\n\t\t\t\t\t\t(a, b) => {\n\t\t\t\t\t\t\tconst ai = typeof a === \"string\" ? a : a.identifier();\n\t\t\t\t\t\t\tconst bi = typeof b === \"string\" ? b : b.identifier();\n\t\t\t\t\t\t\treturn ai.length - bi.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\t// find modules with conflicting source names\n\t\t\t\t\tfor (let idx = 0; idx < allModules.length; idx++) {\n\t\t\t\t\t\tconst module = allModules[idx];\n\t\t\t\t\t\tlet sourceName = moduleToSourceNameMapping.get(module);\n\t\t\t\t\t\tlet hasName = conflictDetectionSet.has(sourceName);\n\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\tconflictDetectionSet.add(sourceName);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// try the fallback name first\n\t\t\t\t\t\tsourceName = ModuleFilenameHelpers.createFilename(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmoduleFilenameTemplate: fallbackModuleFilenameTemplate,\n\t\t\t\t\t\t\t\tnamespace: namespace\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t);\n\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\tif (!hasName) {\n\t\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// elsewise just append stars until we have a valid name\n\t\t\t\t\t\twhile (hasName) {\n\t\t\t\t\t\t\tsourceName += \"*\";\n\t\t\t\t\t\t\thasName = usedNamesSet.has(sourceName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmoduleToSourceNameMapping.set(module, sourceName);\n\t\t\t\t\t\tusedNamesSet.add(sourceName);\n\t\t\t\t\t}\n\t\t\t\t\ttasks.forEach((task, index) => {\n\t\t\t\t\t\treportProgress(\n\t\t\t\t\t\t\t0.5 + (0.5 * index) / tasks.length,\n\t\t\t\t\t\t\ttask.file,\n\t\t\t\t\t\t\t\"attach SourceMap\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst assets = Object.create(null);\n\t\t\t\t\t\tconst chunk = task.chunk;\n\t\t\t\t\t\tconst file = task.file;\n\t\t\t\t\t\tconst asset = task.asset;\n\t\t\t\t\t\tconst sourceMap = task.sourceMap;\n\t\t\t\t\t\tconst source = task.source;\n\t\t\t\t\t\tconst modules = task.modules;\n\t\t\t\t\t\tconst moduleFilenames = modules.map(m =>\n\t\t\t\t\t\t\tmoduleToSourceNameMapping.get(m)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tsourceMap.sources = moduleFilenames;\n\t\t\t\t\t\tif (options.noSources) {\n\t\t\t\t\t\t\tsourceMap.sourcesContent = undefined;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsourceMap.sourceRoot = options.sourceRoot || \"\";\n\t\t\t\t\t\tsourceMap.file = file;\n\t\t\t\t\t\tassetsCache.set(asset, { file, assets });\n\t\t\t\t\t\t/** @type {string | false} */\n\t\t\t\t\t\tlet currentSourceMappingURLComment = sourceMappingURLComment;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcurrentSourceMappingURLComment !== false &&\n\t\t\t\t\t\t\t/\\.css($|\\?)/i.test(file)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcurrentSourceMappingURLComment = currentSourceMappingURLComment.replace(\n\t\t\t\t\t\t\t\t/^\\n\\/\\/(.*)$/,\n\t\t\t\t\t\t\t\t\"\\n/*$1*/\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst sourceMapString = JSON.stringify(sourceMap);\n\t\t\t\t\t\tif (sourceMapFilename) {\n\t\t\t\t\t\t\tlet filename = file;\n\t\t\t\t\t\t\tlet query = \"\";\n\t\t\t\t\t\t\tconst idx = filename.indexOf(\"?\");\n\t\t\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\t\t\tquery = filename.substr(idx);\n\t\t\t\t\t\t\t\tfilename = filename.substr(0, idx);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst pathParams = {\n\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\tfilename: options.fileContext\n\t\t\t\t\t\t\t\t\t? path.relative(options.fileContext, filename)\n\t\t\t\t\t\t\t\t\t: filename,\n\t\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\t\tbasename: basename(filename),\n\t\t\t\t\t\t\t\tcontentHash: createHash(\"md4\")\n\t\t\t\t\t\t\t\t\t.update(sourceMapString)\n\t\t\t\t\t\t\t\t\t.digest(\"hex\")\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlet sourceMapFile = compilation.getPath(\n\t\t\t\t\t\t\t\tsourceMapFilename,\n\t\t\t\t\t\t\t\tpathParams\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst sourceMapUrl = options.publicPath\n\t\t\t\t\t\t\t\t? options.publicPath + sourceMapFile.replace(/\\\\/g, \"/\")\n\t\t\t\t\t\t\t\t: path\n\t\t\t\t\t\t\t\t\t\t.relative(path.dirname(file), sourceMapFile)\n\t\t\t\t\t\t\t\t\t\t.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Add source map url to compilation asset, if {@link currentSourceMappingURLComment} presented\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (currentSourceMappingURLComment !== false) {\n\t\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\t\tcompilation.getPath(\n\t\t\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment,\n\t\t\t\t\t\t\t\t\t\tObject.assign({ url: sourceMapUrl }, pathParams)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Add source map file to compilation assets and chunk files\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst asset = new RawSource(sourceMapString);\n\t\t\t\t\t\t\tassets[sourceMapFile] = asset;\n\t\t\t\t\t\t\tcompilation.emitAsset(sourceMapFile, asset, {\n\t\t\t\t\t\t\t\tdevelopment: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tchunk.files.push(sourceMapFile);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (currentSourceMappingURLComment === false) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\"SourceMapDevToolPlugin: append can't be false when no filename is provided\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Add source map as data url to asset\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst asset = new ConcatSource(\n\t\t\t\t\t\t\t\tnew RawSource(source),\n\t\t\t\t\t\t\t\tcurrentSourceMappingURLComment\n\t\t\t\t\t\t\t\t\t.replace(/\\[map\\]/g, () => sourceMapString)\n\t\t\t\t\t\t\t\t\t.replace(\n\t\t\t\t\t\t\t\t\t\t/\\[url\\]/g,\n\t\t\t\t\t\t\t\t\t\t() =>\n\t\t\t\t\t\t\t\t\t\t\t`data:application/json;charset=utf-8;base64,${Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\tsourceMapString,\n\t\t\t\t\t\t\t\t\t\t\t\t\"utf-8\"\n\t\t\t\t\t\t\t\t\t\t\t).toString(\"base64\")}`\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tassets[file] = asset;\n\t\t\t\t\t\t\tcompilation.updateAsset(file, asset);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treportProgress(1.0);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\n\nmodule.exports = SourceMapDevToolPlugin;\n"]},"metadata":{},"sourceType":"script"}