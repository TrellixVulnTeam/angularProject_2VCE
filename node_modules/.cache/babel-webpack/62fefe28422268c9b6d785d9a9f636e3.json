{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/metadata/src/inheritance\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/metadata/src/property_mapping\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.flattenInheritedDirectiveMetadata = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var property_mapping_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata/src/property_mapping\");\n  /**\n   * Given a reference to a directive, return a flattened version of its `DirectiveMeta` metadata\n   * which includes metadata from its entire inheritance chain.\n   *\n   * The returned `DirectiveMeta` will either have `baseClass: null` if the inheritance chain could be\n   * fully resolved, or `baseClass: 'dynamic'` if the inheritance chain could not be completely\n   * followed.\n   */\n\n\n  function flattenInheritedDirectiveMetadata(reader, dir) {\n    var topMeta = reader.getDirectiveMetadata(dir);\n\n    if (topMeta === null) {\n      throw new Error(\"Metadata not found for directive: \" + dir.debugName);\n    }\n\n    if (topMeta.baseClass === null) {\n      return topMeta;\n    }\n\n    var coercedInputFields = new Set();\n    var undeclaredInputFields = new Set();\n    var restrictedInputFields = new Set();\n    var stringLiteralInputFields = new Set();\n    var isDynamic = false;\n    var inputs = property_mapping_1.ClassPropertyMapping.empty();\n    var outputs = property_mapping_1.ClassPropertyMapping.empty();\n    var isStructural = false;\n\n    var addMetadata = function addMetadata(meta) {\n      var e_1, _a, e_2, _b, e_3, _c, e_4, _d;\n\n      if (meta.baseClass === 'dynamic') {\n        isDynamic = true;\n      } else if (meta.baseClass !== null) {\n        var baseMeta = reader.getDirectiveMetadata(meta.baseClass);\n\n        if (baseMeta !== null) {\n          addMetadata(baseMeta);\n        } else {\n          // Missing metadata for the base class means it's effectively dynamic.\n          isDynamic = true;\n        }\n      }\n\n      isStructural = isStructural || meta.isStructural;\n      inputs = property_mapping_1.ClassPropertyMapping.merge(inputs, meta.inputs);\n      outputs = property_mapping_1.ClassPropertyMapping.merge(outputs, meta.outputs);\n\n      try {\n        for (var _e = tslib_1.__values(meta.coercedInputFields), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var coercedInputField = _f.value;\n          coercedInputFields.add(coercedInputField);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        for (var _g = tslib_1.__values(meta.undeclaredInputFields), _h = _g.next(); !_h.done; _h = _g.next()) {\n          var undeclaredInputField = _h.value;\n          undeclaredInputFields.add(undeclaredInputField);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      try {\n        for (var _j = tslib_1.__values(meta.restrictedInputFields), _k = _j.next(); !_k.done; _k = _j.next()) {\n          var restrictedInputField = _k.value;\n          restrictedInputFields.add(restrictedInputField);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      try {\n        for (var _l = tslib_1.__values(meta.stringLiteralInputFields), _m = _l.next(); !_m.done; _m = _l.next()) {\n          var field = _m.value;\n          stringLiteralInputFields.add(field);\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_m && !_m.done && (_d = _l.return)) _d.call(_l);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n    };\n\n    addMetadata(topMeta);\n    return tslib_1.__assign(tslib_1.__assign({}, topMeta), {\n      inputs: inputs,\n      outputs: outputs,\n      coercedInputFields: coercedInputFields,\n      undeclaredInputFields: undeclaredInputFields,\n      restrictedInputFields: restrictedInputFields,\n      stringLiteralInputFields: stringLiteralInputFields,\n      baseClass: isDynamic ? 'dynamic' : null,\n      isStructural: isStructural\n    });\n  }\n\n  exports.flattenInheritedDirectiveMetadata = flattenInheritedDirectiveMetadata;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/inheritance.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {DirectiveMeta, MetadataReader} from './api';\nimport {ClassPropertyMapping, ClassPropertyName} from './property_mapping';\n\n/**\n * Given a reference to a directive, return a flattened version of its `DirectiveMeta` metadata\n * which includes metadata from its entire inheritance chain.\n *\n * The returned `DirectiveMeta` will either have `baseClass: null` if the inheritance chain could be\n * fully resolved, or `baseClass: 'dynamic'` if the inheritance chain could not be completely\n * followed.\n */\nexport function flattenInheritedDirectiveMetadata(\n    reader: MetadataReader, dir: Reference<ClassDeclaration>): DirectiveMeta {\n  const topMeta = reader.getDirectiveMetadata(dir);\n  if (topMeta === null) {\n    throw new Error(`Metadata not found for directive: ${dir.debugName}`);\n  }\n  if (topMeta.baseClass === null) {\n    return topMeta;\n  }\n\n  const coercedInputFields = new Set<ClassPropertyName>();\n  const undeclaredInputFields = new Set<ClassPropertyName>();\n  const restrictedInputFields = new Set<ClassPropertyName>();\n  const stringLiteralInputFields = new Set<ClassPropertyName>();\n  let isDynamic = false;\n  let inputs = ClassPropertyMapping.empty();\n  let outputs = ClassPropertyMapping.empty();\n  let isStructural: boolean = false;\n\n  const addMetadata = (meta: DirectiveMeta): void => {\n    if (meta.baseClass === 'dynamic') {\n      isDynamic = true;\n    } else if (meta.baseClass !== null) {\n      const baseMeta = reader.getDirectiveMetadata(meta.baseClass);\n      if (baseMeta !== null) {\n        addMetadata(baseMeta);\n      } else {\n        // Missing metadata for the base class means it's effectively dynamic.\n        isDynamic = true;\n      }\n    }\n\n    isStructural = isStructural || meta.isStructural;\n\n    inputs = ClassPropertyMapping.merge(inputs, meta.inputs);\n    outputs = ClassPropertyMapping.merge(outputs, meta.outputs);\n\n    for (const coercedInputField of meta.coercedInputFields) {\n      coercedInputFields.add(coercedInputField);\n    }\n    for (const undeclaredInputField of meta.undeclaredInputFields) {\n      undeclaredInputFields.add(undeclaredInputField);\n    }\n    for (const restrictedInputField of meta.restrictedInputFields) {\n      restrictedInputFields.add(restrictedInputField);\n    }\n    for (const field of meta.stringLiteralInputFields) {\n      stringLiteralInputFields.add(field);\n    }\n  };\n\n  addMetadata(topMeta);\n\n  return {\n    ...topMeta,\n    inputs,\n    outputs,\n    coercedInputFields,\n    undeclaredInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    baseClass: isDynamic ? 'dynamic' : null,\n    isStructural,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}