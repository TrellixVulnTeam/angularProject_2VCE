{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/t2_binder\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/expression_parser/ast\", \"@angular/compiler/src/render3/r3_ast\", \"@angular/compiler/src/render3/view/template\", \"@angular/compiler/src/render3/view/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.R3BoundTarget = exports.R3TargetBinder = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ast_1 = require(\"@angular/compiler/src/expression_parser/ast\");\n\n  var r3_ast_1 = require(\"@angular/compiler/src/render3/r3_ast\");\n\n  var template_1 = require(\"@angular/compiler/src/render3/view/template\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/view/util\");\n  /**\n   * Processes `Target`s with a given set of directives and performs a binding operation, which\n   * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n   * target.\n   */\n\n\n  var R3TargetBinder =\n  /** @class */\n  function () {\n    function R3TargetBinder(directiveMatcher) {\n      this.directiveMatcher = directiveMatcher;\n    }\n    /**\n     * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n     * metadata about the types referenced in the template.\n     */\n\n\n    R3TargetBinder.prototype.bind = function (target) {\n      if (!target.template) {\n        // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n        throw new Error('Binding without a template not yet supported');\n      } // First, parse the template into a `Scope` structure. This operation captures the syntactic\n      // scopes in the template and makes them available for later use.\n\n\n      var scope = Scope.apply(target.template); // Use the `Scope` to extract the entities present at every level of the template.\n\n      var templateEntities = extractTemplateEntities(scope); // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n      //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n      //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n      //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n      //   - references: Map of #references to their targets.\n\n      var _a = DirectiveBinder.apply(target.template, this.directiveMatcher),\n          directives = _a.directives,\n          bindings = _a.bindings,\n          references = _a.references; // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n      // template. This extracts all the metadata that doesn't depend on directive matching.\n\n\n      var _b = TemplateBinder.apply(target.template, scope),\n          expressions = _b.expressions,\n          symbols = _b.symbols,\n          nestingLevel = _b.nestingLevel,\n          usedPipes = _b.usedPipes;\n\n      return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, templateEntities, usedPipes);\n    };\n\n    return R3TargetBinder;\n  }();\n\n  exports.R3TargetBinder = R3TargetBinder;\n  /**\n   * Represents a binding scope within a template.\n   *\n   * Any variables, references, or other named entities declared within the template will\n   * be captured and available by name in `namedEntities`. Additionally, child templates will\n   * be analyzed and have their child `Scope`s available in `childScopes`.\n   */\n\n  var Scope =\n  /** @class */\n  function () {\n    function Scope(parentScope, template) {\n      this.parentScope = parentScope;\n      this.template = template;\n      /**\n       * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n       */\n\n      this.namedEntities = new Map();\n      /**\n       * Child `Scope`s for immediately nested `Template`s.\n       */\n\n      this.childScopes = new Map();\n    }\n\n    Scope.newRootScope = function () {\n      return new Scope(null, null);\n    };\n    /**\n     * Process a template (either as a `Template` sub-template with variables, or a plain array of\n     * template `Node`s) and construct its `Scope`.\n     */\n\n\n    Scope.apply = function (template) {\n      var scope = Scope.newRootScope();\n      scope.ingest(template);\n      return scope;\n    };\n    /**\n     * Internal method to process the template and populate the `Scope`.\n     */\n\n\n    Scope.prototype.ingest = function (template) {\n      var _this = this;\n\n      if (template instanceof r3_ast_1.Template) {\n        // Variables on an <ng-template> are defined in the inner scope.\n        template.variables.forEach(function (node) {\n          return _this.visitVariable(node);\n        }); // Process the nodes of the template.\n\n        template.children.forEach(function (node) {\n          return node.visit(_this);\n        });\n      } else {\n        // No overarching `Template` instance, so process the nodes directly.\n        template.forEach(function (node) {\n          return node.visit(_this);\n        });\n      }\n    };\n\n    Scope.prototype.visitElement = function (element) {\n      var _this = this; // `Element`s in the template may have `Reference`s which are captured in the scope.\n\n\n      element.references.forEach(function (node) {\n        return _this.visitReference(node);\n      }); // Recurse into the `Element`'s children.\n\n      element.children.forEach(function (node) {\n        return node.visit(_this);\n      });\n    };\n\n    Scope.prototype.visitTemplate = function (template) {\n      var _this = this; // References on a <ng-template> are defined in the outer scope, so capture them before\n      // processing the template's child scope.\n\n\n      template.references.forEach(function (node) {\n        return _this.visitReference(node);\n      }); // Next, create an inner scope and process the template within it.\n\n      var scope = new Scope(this, template);\n      scope.ingest(template);\n      this.childScopes.set(template, scope);\n    };\n\n    Scope.prototype.visitVariable = function (variable) {\n      // Declare the variable if it's not already.\n      this.maybeDeclare(variable);\n    };\n\n    Scope.prototype.visitReference = function (reference) {\n      // Declare the variable if it's not already.\n      this.maybeDeclare(reference);\n    }; // Unused visitors.\n\n\n    Scope.prototype.visitContent = function (content) {};\n\n    Scope.prototype.visitBoundAttribute = function (attr) {};\n\n    Scope.prototype.visitBoundEvent = function (event) {};\n\n    Scope.prototype.visitBoundText = function (text) {};\n\n    Scope.prototype.visitText = function (text) {};\n\n    Scope.prototype.visitTextAttribute = function (attr) {};\n\n    Scope.prototype.visitIcu = function (icu) {};\n\n    Scope.prototype.maybeDeclare = function (thing) {\n      // Declare something with a name, as long as that name isn't taken.\n      if (!this.namedEntities.has(thing.name)) {\n        this.namedEntities.set(thing.name, thing);\n      }\n    };\n    /**\n     * Look up a variable within this `Scope`.\n     *\n     * This can recurse into a parent `Scope` if it's available.\n     */\n\n\n    Scope.prototype.lookup = function (name) {\n      if (this.namedEntities.has(name)) {\n        // Found in the local scope.\n        return this.namedEntities.get(name);\n      } else if (this.parentScope !== null) {\n        // Not in the local scope, but there's a parent scope so check there.\n        return this.parentScope.lookup(name);\n      } else {\n        // At the top level and it wasn't found.\n        return null;\n      }\n    };\n    /**\n     * Get the child scope for a `Template`.\n     *\n     * This should always be defined.\n     */\n\n\n    Scope.prototype.getChildScope = function (template) {\n      var res = this.childScopes.get(template);\n\n      if (res === undefined) {\n        throw new Error(\"Assertion error: child scope for \" + template + \" not found\");\n      }\n\n      return res;\n    };\n\n    return Scope;\n  }();\n  /**\n   * Processes a template and matches directives on nodes (elements and templates).\n   *\n   * Usually used via the static `apply()` method.\n   */\n\n\n  var DirectiveBinder =\n  /** @class */\n  function () {\n    function DirectiveBinder(matcher, directives, bindings, references) {\n      this.matcher = matcher;\n      this.directives = directives;\n      this.bindings = bindings;\n      this.references = references;\n    }\n    /**\n     * Process a template (list of `Node`s) and perform directive matching against each node.\n     *\n     * @param template the list of template `Node`s to match (recursively).\n     * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n     * this template.\n     * @returns three maps which contain information about directives in the template: the\n     * `directives` map which lists directives matched on each node, the `bindings` map which\n     * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n     * map which resolves #references (`Reference`s) within the template to the named directive or\n     * template node.\n     */\n\n\n    DirectiveBinder.apply = function (template, selectorMatcher) {\n      var directives = new Map();\n      var bindings = new Map();\n      var references = new Map();\n      var matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n      matcher.ingest(template);\n      return {\n        directives: directives,\n        bindings: bindings,\n        references: references\n      };\n    };\n\n    DirectiveBinder.prototype.ingest = function (template) {\n      var _this = this;\n\n      template.forEach(function (node) {\n        return node.visit(_this);\n      });\n    };\n\n    DirectiveBinder.prototype.visitElement = function (element) {\n      this.visitElementOrTemplate(element.name, element);\n    };\n\n    DirectiveBinder.prototype.visitTemplate = function (template) {\n      this.visitElementOrTemplate('ng-template', template);\n    };\n\n    DirectiveBinder.prototype.visitElementOrTemplate = function (elementName, node) {\n      var _this = this; // First, determine the HTML shape of the node for the purpose of directive matching.\n      // Do this by building up a `CssSelector` for the node.\n\n\n      var cssSelector = template_1.createCssSelector(elementName, util_1.getAttrsForDirectiveMatching(node)); // Next, use the `SelectorMatcher` to get the list of directives on the node.\n\n      var directives = [];\n      this.matcher.match(cssSelector, function (_, directive) {\n        return directives.push(directive);\n      });\n\n      if (directives.length > 0) {\n        this.directives.set(node, directives);\n      } // Resolve any references that are created on this node.\n\n\n      node.references.forEach(function (ref) {\n        var dirTarget = null; // If the reference expression is empty, then it matches the \"primary\" directive on the node\n        // (if there is one). Otherwise it matches the host node itself (either an element or\n        // <ng-template> node).\n\n        if (ref.value.trim() === '') {\n          // This could be a reference to a component if there is one.\n          dirTarget = directives.find(function (dir) {\n            return dir.isComponent;\n          }) || null;\n        } else {\n          // This should be a reference to a directive exported via exportAs.\n          dirTarget = directives.find(function (dir) {\n            return dir.exportAs !== null && dir.exportAs.some(function (value) {\n              return value === ref.value;\n            });\n          }) || null; // Check if a matching directive was found.\n\n          if (dirTarget === null) {\n            // No matching directive was found - this reference points to an unknown target. Leave it\n            // unmapped.\n            return;\n          }\n        }\n\n        if (dirTarget !== null) {\n          // This reference points to a directive.\n          _this.references.set(ref, {\n            directive: dirTarget,\n            node: node\n          });\n        } else {\n          // This reference points to the node itself.\n          _this.references.set(ref, node);\n        }\n      });\n\n      var setAttributeBinding = function setAttributeBinding(attribute, ioType) {\n        var dir = directives.find(function (dir) {\n          return dir[ioType].hasBindingPropertyName(attribute.name);\n        });\n        var binding = dir !== undefined ? dir : node;\n\n        _this.bindings.set(attribute, binding);\n      }; // Node inputs (bound attributes) and text attributes can be bound to an\n      // input on a directive.\n\n\n      node.inputs.forEach(function (input) {\n        return setAttributeBinding(input, 'inputs');\n      });\n      node.attributes.forEach(function (attr) {\n        return setAttributeBinding(attr, 'inputs');\n      });\n\n      if (node instanceof r3_ast_1.Template) {\n        node.templateAttrs.forEach(function (attr) {\n          return setAttributeBinding(attr, 'inputs');\n        });\n      } // Node outputs (bound events) can be bound to an output on a directive.\n\n\n      node.outputs.forEach(function (output) {\n        return setAttributeBinding(output, 'outputs');\n      }); // Recurse into the node's children.\n\n      node.children.forEach(function (child) {\n        return child.visit(_this);\n      });\n    }; // Unused visitors.\n\n\n    DirectiveBinder.prototype.visitContent = function (content) {};\n\n    DirectiveBinder.prototype.visitVariable = function (variable) {};\n\n    DirectiveBinder.prototype.visitReference = function (reference) {};\n\n    DirectiveBinder.prototype.visitTextAttribute = function (attribute) {};\n\n    DirectiveBinder.prototype.visitBoundAttribute = function (attribute) {};\n\n    DirectiveBinder.prototype.visitBoundEvent = function (attribute) {};\n\n    DirectiveBinder.prototype.visitBoundAttributeOrEvent = function (node) {};\n\n    DirectiveBinder.prototype.visitText = function (text) {};\n\n    DirectiveBinder.prototype.visitBoundText = function (text) {};\n\n    DirectiveBinder.prototype.visitIcu = function (icu) {};\n\n    return DirectiveBinder;\n  }();\n  /**\n   * Processes a template and extract metadata about expressions and symbols within.\n   *\n   * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n   * within the template in order to operate.\n   *\n   * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n   * by overridden methods from that visitor.\n   */\n\n\n  var TemplateBinder =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TemplateBinder, _super);\n\n    function TemplateBinder(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {\n      var _this = _super.call(this) || this;\n\n      _this.bindings = bindings;\n      _this.symbols = symbols;\n      _this.usedPipes = usedPipes;\n      _this.nestingLevel = nestingLevel;\n      _this.scope = scope;\n      _this.template = template;\n      _this.level = level;\n      _this.pipesUsed = []; // Save a bit of processing time by constructing this closure in advance.\n\n      _this.visitNode = function (node) {\n        return node.visit(_this);\n      };\n\n      return _this;\n    } // This method is defined to reconcile the type of TemplateBinder since both\n    // RecursiveAstVisitor and Visitor define the visit() method in their\n    // interfaces.\n\n\n    TemplateBinder.prototype.visit = function (node, context) {\n      if (node instanceof ast_1.AST) {\n        node.visit(this, context);\n      } else {\n        node.visit(this);\n      }\n    };\n    /**\n     * Process a template and extract metadata about expressions and symbols within.\n     *\n     * @param template the nodes of the template to process\n     * @param scope the `Scope` of the template being processed.\n     * @returns three maps which contain metadata about the template: `expressions` which interprets\n     * special `AST` nodes in expressions as pointing to references or variables declared within the\n     * template, `symbols` which maps those variables and references to the nested `Template` which\n     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n     * nesting level (how many levels deep within the template structure the `Template` is), starting\n     * at 1.\n     */\n\n\n    TemplateBinder.apply = function (template, scope) {\n      var expressions = new Map();\n      var symbols = new Map();\n      var nestingLevel = new Map();\n      var usedPipes = new Set(); // The top-level template has nesting level 0.\n\n      var binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof r3_ast_1.Template ? template : null, 0);\n      binder.ingest(template);\n      return {\n        expressions: expressions,\n        symbols: symbols,\n        nestingLevel: nestingLevel,\n        usedPipes: usedPipes\n      };\n    };\n\n    TemplateBinder.prototype.ingest = function (template) {\n      if (template instanceof r3_ast_1.Template) {\n        // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n        // and references were all processed in the scope of the containing template.\n        template.variables.forEach(this.visitNode);\n        template.children.forEach(this.visitNode); // Set the nesting level.\n\n        this.nestingLevel.set(template, this.level);\n      } else {\n        // Visit each node from the top-level template.\n        template.forEach(this.visitNode);\n      }\n    };\n\n    TemplateBinder.prototype.visitElement = function (element) {\n      // Visit the inputs, outputs, and children of the element.\n      element.inputs.forEach(this.visitNode);\n      element.outputs.forEach(this.visitNode);\n      element.children.forEach(this.visitNode);\n    };\n\n    TemplateBinder.prototype.visitTemplate = function (template) {\n      // First, visit inputs, outputs and template attributes of the template node.\n      template.inputs.forEach(this.visitNode);\n      template.outputs.forEach(this.visitNode);\n      template.templateAttrs.forEach(this.visitNode); // References are also evaluated in the outer context.\n\n      template.references.forEach(this.visitNode); // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n\n      var childScope = this.scope.getChildScope(template);\n      var binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);\n      binder.ingest(template);\n    };\n\n    TemplateBinder.prototype.visitVariable = function (variable) {\n      // Register the `Variable` as a symbol in the current `Template`.\n      if (this.template !== null) {\n        this.symbols.set(variable, this.template);\n      }\n    };\n\n    TemplateBinder.prototype.visitReference = function (reference) {\n      // Register the `Reference` as a symbol in the current `Template`.\n      if (this.template !== null) {\n        this.symbols.set(reference, this.template);\n      }\n    }; // Unused template visitors\n\n\n    TemplateBinder.prototype.visitText = function (text) {};\n\n    TemplateBinder.prototype.visitContent = function (content) {};\n\n    TemplateBinder.prototype.visitTextAttribute = function (attribute) {};\n\n    TemplateBinder.prototype.visitIcu = function (icu) {\n      var _this = this;\n\n      Object.keys(icu.vars).forEach(function (key) {\n        return icu.vars[key].visit(_this);\n      });\n      Object.keys(icu.placeholders).forEach(function (key) {\n        return icu.placeholders[key].visit(_this);\n      });\n    }; // The remaining visitors are concerned with processing AST expressions within template bindings\n\n\n    TemplateBinder.prototype.visitBoundAttribute = function (attribute) {\n      attribute.value.visit(this);\n    };\n\n    TemplateBinder.prototype.visitBoundEvent = function (event) {\n      event.handler.visit(this);\n    };\n\n    TemplateBinder.prototype.visitBoundText = function (text) {\n      text.value.visit(this);\n    };\n\n    TemplateBinder.prototype.visitPipe = function (ast, context) {\n      this.usedPipes.add(ast.name);\n      return _super.prototype.visitPipe.call(this, ast, context);\n    }; // These five types of AST expressions can refer to expression roots, which could be variables\n    // or references in the current scope.\n\n\n    TemplateBinder.prototype.visitPropertyRead = function (ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _super.prototype.visitPropertyRead.call(this, ast, context);\n    };\n\n    TemplateBinder.prototype.visitSafePropertyRead = function (ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _super.prototype.visitSafePropertyRead.call(this, ast, context);\n    };\n\n    TemplateBinder.prototype.visitPropertyWrite = function (ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _super.prototype.visitPropertyWrite.call(this, ast, context);\n    };\n\n    TemplateBinder.prototype.visitMethodCall = function (ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _super.prototype.visitMethodCall.call(this, ast, context);\n    };\n\n    TemplateBinder.prototype.visitSafeMethodCall = function (ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _super.prototype.visitSafeMethodCall.call(this, ast, context);\n    };\n\n    TemplateBinder.prototype.maybeMap = function (scope, ast, name) {\n      // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n      // `AST` expression that maps to a `Variable` or `Reference`.\n      if (!(ast.receiver instanceof ast_1.ImplicitReceiver)) {\n        return;\n      } // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n      // probably a property on the top-level component context.\n\n\n      var target = this.scope.lookup(name);\n\n      if (target !== null) {\n        this.bindings.set(ast, target);\n      }\n    };\n\n    return TemplateBinder;\n  }(ast_1.RecursiveAstVisitor);\n  /**\n   * Metadata container for a `Target` that allows queries for specific bits of metadata.\n   *\n   * See `BoundTarget` for documentation on the individual methods.\n   */\n\n\n  var R3BoundTarget =\n  /** @class */\n  function () {\n    function R3BoundTarget(target, directives, bindings, references, exprTargets, symbols, nestingLevel, templateEntities, usedPipes) {\n      this.target = target;\n      this.directives = directives;\n      this.bindings = bindings;\n      this.references = references;\n      this.exprTargets = exprTargets;\n      this.symbols = symbols;\n      this.nestingLevel = nestingLevel;\n      this.templateEntities = templateEntities;\n      this.usedPipes = usedPipes;\n    }\n\n    R3BoundTarget.prototype.getEntitiesInTemplateScope = function (template) {\n      var _a;\n\n      return (_a = this.templateEntities.get(template)) !== null && _a !== void 0 ? _a : new Set();\n    };\n\n    R3BoundTarget.prototype.getDirectivesOfNode = function (node) {\n      return this.directives.get(node) || null;\n    };\n\n    R3BoundTarget.prototype.getReferenceTarget = function (ref) {\n      return this.references.get(ref) || null;\n    };\n\n    R3BoundTarget.prototype.getConsumerOfBinding = function (binding) {\n      return this.bindings.get(binding) || null;\n    };\n\n    R3BoundTarget.prototype.getExpressionTarget = function (expr) {\n      return this.exprTargets.get(expr) || null;\n    };\n\n    R3BoundTarget.prototype.getTemplateOfSymbol = function (symbol) {\n      return this.symbols.get(symbol) || null;\n    };\n\n    R3BoundTarget.prototype.getNestingLevel = function (template) {\n      return this.nestingLevel.get(template) || 0;\n    };\n\n    R3BoundTarget.prototype.getUsedDirectives = function () {\n      var set = new Set();\n      this.directives.forEach(function (dirs) {\n        return dirs.forEach(function (dir) {\n          return set.add(dir);\n        });\n      });\n      return Array.from(set.values());\n    };\n\n    R3BoundTarget.prototype.getUsedPipes = function () {\n      return Array.from(this.usedPipes);\n    };\n\n    return R3BoundTarget;\n  }();\n\n  exports.R3BoundTarget = R3BoundTarget;\n\n  function extractTemplateEntities(rootScope) {\n    var e_1, _a, e_2, _b;\n\n    var entityMap = new Map();\n\n    function extractScopeEntities(scope) {\n      if (entityMap.has(scope.template)) {\n        return entityMap.get(scope.template);\n      }\n\n      var currentEntities = scope.namedEntities;\n      var templateEntities;\n\n      if (scope.parentScope !== null) {\n        templateEntities = new Map(tslib_1.__spread(extractScopeEntities(scope.parentScope), currentEntities));\n      } else {\n        templateEntities = new Map(currentEntities);\n      }\n\n      entityMap.set(scope.template, templateEntities);\n      return templateEntities;\n    }\n\n    var scopesToProcess = [rootScope];\n\n    while (scopesToProcess.length > 0) {\n      var scope = scopesToProcess.pop();\n\n      try {\n        for (var _c = (e_1 = void 0, tslib_1.__values(scope.childScopes.values())), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var childScope = _d.value;\n          scopesToProcess.push(childScope);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      extractScopeEntities(scope);\n    }\n\n    var templateEntities = new Map();\n\n    try {\n      for (var entityMap_1 = tslib_1.__values(entityMap), entityMap_1_1 = entityMap_1.next(); !entityMap_1_1.done; entityMap_1_1 = entityMap_1.next()) {\n        var _e = tslib_1.__read(entityMap_1_1.value, 2),\n            template = _e[0],\n            entities = _e[1];\n\n        templateEntities.set(template, new Set(entities.values()));\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (entityMap_1_1 && !entityMap_1_1.done && (_b = entityMap_1.return)) _b.call(entityMap_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return templateEntities;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/view/t2_binder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, BindingPipe, ImplicitReceiver, MethodCall, PropertyRead, PropertyWrite, RecursiveAstVisitor, SafeMethodCall, SafePropertyRead} from '../../expression_parser/ast';\nimport {SelectorMatcher} from '../../selector';\nimport {BoundAttribute, BoundEvent, BoundText, Content, Element, Icu, Node, Reference, Template, Text, TextAttribute, Variable, Visitor} from '../r3_ast';\n\nimport {BoundTarget, DirectiveMeta, Target, TargetBinder} from './t2_api';\nimport {createCssSelector} from './template';\nimport {getAttrsForDirectiveMatching} from './util';\n\n\n/**\n * Processes `Target`s with a given set of directives and performs a binding operation, which\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\n * target.\n */\nexport class R3TargetBinder<DirectiveT extends DirectiveMeta> implements TargetBinder<DirectiveT> {\n  constructor(private directiveMatcher: SelectorMatcher<DirectiveT>) {}\n\n  /**\n   * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\n   * metadata about the types referenced in the template.\n   */\n  bind(target: Target): BoundTarget<DirectiveT> {\n    if (!target.template) {\n      // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n      throw new Error('Binding without a template not yet supported');\n    }\n\n    // First, parse the template into a `Scope` structure. This operation captures the syntactic\n    // scopes in the template and makes them available for later use.\n    const scope = Scope.apply(target.template);\n\n\n    // Use the `Scope` to extract the entities present at every level of the template.\n    const templateEntities = extractTemplateEntities(scope);\n\n    // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n    //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n    //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n    //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n    //   - references: Map of #references to their targets.\n    const {directives, bindings, references} =\n        DirectiveBinder.apply(target.template, this.directiveMatcher);\n    // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n    // template. This extracts all the metadata that doesn't depend on directive matching.\n    const {expressions, symbols, nestingLevel, usedPipes} =\n        TemplateBinder.apply(target.template, scope);\n    return new R3BoundTarget(\n        target, directives, bindings, references, expressions, symbols, nestingLevel,\n        templateEntities, usedPipes);\n  }\n}\n\n/**\n * Represents a binding scope within a template.\n *\n * Any variables, references, or other named entities declared within the template will\n * be captured and available by name in `namedEntities`. Additionally, child templates will\n * be analyzed and have their child `Scope`s available in `childScopes`.\n */\nclass Scope implements Visitor {\n  /**\n   * Named members of the `Scope`, such as `Reference`s or `Variable`s.\n   */\n  readonly namedEntities = new Map<string, Reference|Variable>();\n\n  /**\n   * Child `Scope`s for immediately nested `Template`s.\n   */\n  readonly childScopes = new Map<Template, Scope>();\n\n  private constructor(readonly parentScope: Scope|null, readonly template: Template|null) {}\n\n  static newRootScope(): Scope {\n    return new Scope(null, null);\n  }\n\n  /**\n   * Process a template (either as a `Template` sub-template with variables, or a plain array of\n   * template `Node`s) and construct its `Scope`.\n   */\n  static apply(template: Node[]): Scope {\n    const scope = Scope.newRootScope();\n    scope.ingest(template);\n    return scope;\n  }\n\n  /**\n   * Internal method to process the template and populate the `Scope`.\n   */\n  private ingest(template: Template|Node[]): void {\n    if (template instanceof Template) {\n      // Variables on an <ng-template> are defined in the inner scope.\n      template.variables.forEach(node => this.visitVariable(node));\n\n      // Process the nodes of the template.\n      template.children.forEach(node => node.visit(this));\n    } else {\n      // No overarching `Template` instance, so process the nodes directly.\n      template.forEach(node => node.visit(this));\n    }\n  }\n\n  visitElement(element: Element) {\n    // `Element`s in the template may have `Reference`s which are captured in the scope.\n    element.references.forEach(node => this.visitReference(node));\n\n    // Recurse into the `Element`'s children.\n    element.children.forEach(node => node.visit(this));\n  }\n\n  visitTemplate(template: Template) {\n    // References on a <ng-template> are defined in the outer scope, so capture them before\n    // processing the template's child scope.\n    template.references.forEach(node => this.visitReference(node));\n\n    // Next, create an inner scope and process the template within it.\n    const scope = new Scope(this, template);\n    scope.ingest(template);\n    this.childScopes.set(template, scope);\n  }\n\n  visitVariable(variable: Variable) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(variable);\n  }\n\n  visitReference(reference: Reference) {\n    // Declare the variable if it's not already.\n    this.maybeDeclare(reference);\n  }\n\n  // Unused visitors.\n  visitContent(content: Content) {}\n  visitBoundAttribute(attr: BoundAttribute) {}\n  visitBoundEvent(event: BoundEvent) {}\n  visitBoundText(text: BoundText) {}\n  visitText(text: Text) {}\n  visitTextAttribute(attr: TextAttribute) {}\n  visitIcu(icu: Icu) {}\n\n  private maybeDeclare(thing: Reference|Variable) {\n    // Declare something with a name, as long as that name isn't taken.\n    if (!this.namedEntities.has(thing.name)) {\n      this.namedEntities.set(thing.name, thing);\n    }\n  }\n\n  /**\n   * Look up a variable within this `Scope`.\n   *\n   * This can recurse into a parent `Scope` if it's available.\n   */\n  lookup(name: string): Reference|Variable|null {\n    if (this.namedEntities.has(name)) {\n      // Found in the local scope.\n      return this.namedEntities.get(name)!;\n    } else if (this.parentScope !== null) {\n      // Not in the local scope, but there's a parent scope so check there.\n      return this.parentScope.lookup(name);\n    } else {\n      // At the top level and it wasn't found.\n      return null;\n    }\n  }\n\n  /**\n   * Get the child scope for a `Template`.\n   *\n   * This should always be defined.\n   */\n  getChildScope(template: Template): Scope {\n    const res = this.childScopes.get(template);\n    if (res === undefined) {\n      throw new Error(`Assertion error: child scope for ${template} not found`);\n    }\n    return res;\n  }\n}\n\n/**\n * Processes a template and matches directives on nodes (elements and templates).\n *\n * Usually used via the static `apply()` method.\n */\nclass DirectiveBinder<DirectiveT extends DirectiveMeta> implements Visitor {\n  constructor(\n      private matcher: SelectorMatcher<DirectiveT>,\n      private directives: Map<Element|Template, DirectiveT[]>,\n      private bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n      private references:\n          Map<Reference, {directive: DirectiveT, node: Element|Template}|Element|Template>) {}\n\n  /**\n   * Process a template (list of `Node`s) and perform directive matching against each node.\n   *\n   * @param template the list of template `Node`s to match (recursively).\n   * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\n   * this template.\n   * @returns three maps which contain information about directives in the template: the\n   * `directives` map which lists directives matched on each node, the `bindings` map which\n   * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\n   * map which resolves #references (`Reference`s) within the template to the named directive or\n   * template node.\n   */\n  static apply<DirectiveT extends DirectiveMeta>(\n      template: Node[], selectorMatcher: SelectorMatcher<DirectiveT>): {\n    directives: Map<Element|Template, DirectiveT[]>,\n    bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n    references: Map<Reference, {directive: DirectiveT, node: Element|Template}|Element|Template>,\n  } {\n    const directives = new Map<Element|Template, DirectiveT[]>();\n    const bindings =\n        new Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>();\n    const references =\n        new Map<Reference, {directive: DirectiveT, node: Element | Template}|Element|Template>();\n    const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n    matcher.ingest(template);\n    return {directives, bindings, references};\n  }\n\n  private ingest(template: Node[]): void {\n    template.forEach(node => node.visit(this));\n  }\n\n  visitElement(element: Element): void {\n    this.visitElementOrTemplate(element.name, element);\n  }\n\n  visitTemplate(template: Template): void {\n    this.visitElementOrTemplate('ng-template', template);\n  }\n\n  visitElementOrTemplate(elementName: string, node: Element|Template): void {\n    // First, determine the HTML shape of the node for the purpose of directive matching.\n    // Do this by building up a `CssSelector` for the node.\n    const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));\n\n    // Next, use the `SelectorMatcher` to get the list of directives on the node.\n    const directives: DirectiveT[] = [];\n    this.matcher.match(cssSelector, (_, directive) => directives.push(directive));\n    if (directives.length > 0) {\n      this.directives.set(node, directives);\n    }\n\n    // Resolve any references that are created on this node.\n    node.references.forEach(ref => {\n      let dirTarget: DirectiveT|null = null;\n\n      // If the reference expression is empty, then it matches the \"primary\" directive on the node\n      // (if there is one). Otherwise it matches the host node itself (either an element or\n      // <ng-template> node).\n      if (ref.value.trim() === '') {\n        // This could be a reference to a component if there is one.\n        dirTarget = directives.find(dir => dir.isComponent) || null;\n      } else {\n        // This should be a reference to a directive exported via exportAs.\n        dirTarget =\n            directives.find(\n                dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||\n            null;\n        // Check if a matching directive was found.\n        if (dirTarget === null) {\n          // No matching directive was found - this reference points to an unknown target. Leave it\n          // unmapped.\n          return;\n        }\n      }\n\n      if (dirTarget !== null) {\n        // This reference points to a directive.\n        this.references.set(ref, {directive: dirTarget, node});\n      } else {\n        // This reference points to the node itself.\n        this.references.set(ref, node);\n      }\n    });\n\n    // Associate attributes/bindings on the node with directives or with the node itself.\n    type BoundNode = BoundAttribute|BoundEvent|TextAttribute;\n    const setAttributeBinding =\n        (attribute: BoundNode, ioType: keyof Pick<DirectiveMeta, 'inputs'|'outputs'>) => {\n          const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\n          const binding = dir !== undefined ? dir : node;\n          this.bindings.set(attribute, binding);\n        };\n\n    // Node inputs (bound attributes) and text attributes can be bound to an\n    // input on a directive.\n    node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\n    node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    if (node instanceof Template) {\n      node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\n    }\n    // Node outputs (bound events) can be bound to an output on a directive.\n    node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\n\n    // Recurse into the node's children.\n    node.children.forEach(child => child.visit(this));\n  }\n\n  // Unused visitors.\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitBoundAttributeOrEvent(node: BoundAttribute|BoundEvent) {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\n/**\n * Processes a template and extract metadata about expressions and symbols within.\n *\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\n * within the template in order to operate.\n *\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\n * by overridden methods from that visitor.\n */\nclass TemplateBinder extends RecursiveAstVisitor implements Visitor {\n  private visitNode: (node: Node) => void;\n\n  private pipesUsed: string[] = [];\n\n  private constructor(\n      private bindings: Map<AST, Reference|Variable>,\n      private symbols: Map<Reference|Variable, Template>, private usedPipes: Set<string>,\n      private nestingLevel: Map<Template, number>, private scope: Scope,\n      private template: Template|null, private level: number) {\n    super();\n\n    // Save a bit of processing time by constructing this closure in advance.\n    this.visitNode = (node: Node) => node.visit(this);\n  }\n\n  // This method is defined to reconcile the type of TemplateBinder since both\n  // RecursiveAstVisitor and Visitor define the visit() method in their\n  // interfaces.\n  visit(node: AST|Node, context?: any) {\n    if (node instanceof AST) {\n      node.visit(this, context);\n    } else {\n      node.visit(this);\n    }\n  }\n\n  /**\n   * Process a template and extract metadata about expressions and symbols within.\n   *\n   * @param template the nodes of the template to process\n   * @param scope the `Scope` of the template being processed.\n   * @returns three maps which contain metadata about the template: `expressions` which interprets\n   * special `AST` nodes in expressions as pointing to references or variables declared within the\n   * template, `symbols` which maps those variables and references to the nested `Template` which\n   * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\n   * nesting level (how many levels deep within the template structure the `Template` is), starting\n   * at 1.\n   */\n  static apply(template: Node[], scope: Scope): {\n    expressions: Map<AST, Reference|Variable>,\n    symbols: Map<Variable|Reference, Template>,\n    nestingLevel: Map<Template, number>,\n    usedPipes: Set<string>,\n  } {\n    const expressions = new Map<AST, Reference|Variable>();\n    const symbols = new Map<Variable|Reference, Template>();\n    const nestingLevel = new Map<Template, number>();\n    const usedPipes = new Set<string>();\n    // The top-level template has nesting level 0.\n    const binder = new TemplateBinder(\n        expressions, symbols, usedPipes, nestingLevel, scope,\n        template instanceof Template ? template : null, 0);\n    binder.ingest(template);\n    return {expressions, symbols, nestingLevel, usedPipes};\n  }\n\n  private ingest(template: Template|Node[]): void {\n    if (template instanceof Template) {\n      // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n      // and references were all processed in the scope of the containing template.\n      template.variables.forEach(this.visitNode);\n      template.children.forEach(this.visitNode);\n\n      // Set the nesting level.\n      this.nestingLevel.set(template, this.level);\n    } else {\n      // Visit each node from the top-level template.\n      template.forEach(this.visitNode);\n    }\n  }\n\n  visitElement(element: Element) {\n    // Visit the inputs, outputs, and children of the element.\n    element.inputs.forEach(this.visitNode);\n    element.outputs.forEach(this.visitNode);\n    element.children.forEach(this.visitNode);\n  }\n\n  visitTemplate(template: Template) {\n    // First, visit inputs, outputs and template attributes of the template node.\n    template.inputs.forEach(this.visitNode);\n    template.outputs.forEach(this.visitNode);\n    template.templateAttrs.forEach(this.visitNode);\n\n    // References are also evaluated in the outer context.\n    template.references.forEach(this.visitNode);\n\n    // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n    const childScope = this.scope.getChildScope(template);\n    const binder = new TemplateBinder(\n        this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template,\n        this.level + 1);\n    binder.ingest(template);\n  }\n\n  visitVariable(variable: Variable) {\n    // Register the `Variable` as a symbol in the current `Template`.\n    if (this.template !== null) {\n      this.symbols.set(variable, this.template);\n    }\n  }\n\n  visitReference(reference: Reference) {\n    // Register the `Reference` as a symbol in the current `Template`.\n    if (this.template !== null) {\n      this.symbols.set(reference, this.template);\n    }\n  }\n\n  // Unused template visitors\n\n  visitText(text: Text) {}\n  visitContent(content: Content) {}\n  visitTextAttribute(attribute: TextAttribute) {}\n  visitIcu(icu: Icu): void {\n    Object.keys(icu.vars).forEach(key => icu.vars[key].visit(this));\n    Object.keys(icu.placeholders).forEach(key => icu.placeholders[key].visit(this));\n  }\n\n  // The remaining visitors are concerned with processing AST expressions within template bindings\n\n  visitBoundAttribute(attribute: BoundAttribute) {\n    attribute.value.visit(this);\n  }\n\n  visitBoundEvent(event: BoundEvent) {\n    event.handler.visit(this);\n  }\n\n  visitBoundText(text: BoundText) {\n    text.value.visit(this);\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.usedPipes.add(ast.name);\n    return super.visitPipe(ast, context);\n  }\n\n  // These five types of AST expressions can refer to expression roots, which could be variables\n  // or references in the current scope.\n\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitPropertyRead(ast, context);\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitSafePropertyRead(ast, context);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitPropertyWrite(ast, context);\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitMethodCall(ast, context);\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n    this.maybeMap(context, ast, ast.name);\n    return super.visitSafeMethodCall(ast, context);\n  }\n\n  private maybeMap(\n      scope: Scope, ast: PropertyRead|SafePropertyRead|PropertyWrite|MethodCall|SafeMethodCall,\n      name: string): void {\n    // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n    // `AST` expression that maps to a `Variable` or `Reference`.\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n\n    // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n    // probably a property on the top-level component context.\n    let target = this.scope.lookup(name);\n    if (target !== null) {\n      this.bindings.set(ast, target);\n    }\n  }\n}\n\n/**\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\n *\n * See `BoundTarget` for documentation on the individual methods.\n */\nexport class R3BoundTarget<DirectiveT extends DirectiveMeta> implements BoundTarget<DirectiveT> {\n  constructor(\n      readonly target: Target, private directives: Map<Element|Template, DirectiveT[]>,\n      private bindings: Map<BoundAttribute|BoundEvent|TextAttribute, DirectiveT|Element|Template>,\n      private references:\n          Map<BoundAttribute|BoundEvent|Reference|TextAttribute,\n              {directive: DirectiveT, node: Element|Template}|Element|Template>,\n      private exprTargets: Map<AST, Reference|Variable>,\n      private symbols: Map<Reference|Variable, Template>,\n      private nestingLevel: Map<Template, number>,\n      private templateEntities: Map<Template|null, ReadonlySet<Reference|Variable>>,\n      private usedPipes: Set<string>) {}\n\n  getEntitiesInTemplateScope(template: Template|null): ReadonlySet<Reference|Variable> {\n    return this.templateEntities.get(template) ?? new Set();\n  }\n\n  getDirectivesOfNode(node: Element|Template): DirectiveT[]|null {\n    return this.directives.get(node) || null;\n  }\n\n  getReferenceTarget(ref: Reference): {directive: DirectiveT, node: Element|Template}|Element\n      |Template|null {\n    return this.references.get(ref) || null;\n  }\n\n  getConsumerOfBinding(binding: BoundAttribute|BoundEvent|TextAttribute): DirectiveT|Element\n      |Template|null {\n    return this.bindings.get(binding) || null;\n  }\n\n  getExpressionTarget(expr: AST): Reference|Variable|null {\n    return this.exprTargets.get(expr) || null;\n  }\n\n  getTemplateOfSymbol(symbol: Reference|Variable): Template|null {\n    return this.symbols.get(symbol) || null;\n  }\n\n  getNestingLevel(template: Template): number {\n    return this.nestingLevel.get(template) || 0;\n  }\n\n  getUsedDirectives(): DirectiveT[] {\n    const set = new Set<DirectiveT>();\n    this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\n    return Array.from(set.values());\n  }\n\n  getUsedPipes(): string[] {\n    return Array.from(this.usedPipes);\n  }\n}\n\nfunction extractTemplateEntities(rootScope: Scope): Map<Template|null, Set<Reference|Variable>> {\n  const entityMap = new Map<Template|null, Map<string, Reference|Variable>>();\n\n  function extractScopeEntities(scope: Scope): Map<string, Reference|Variable> {\n    if (entityMap.has(scope.template)) {\n      return entityMap.get(scope.template)!;\n    }\n\n    const currentEntities = scope.namedEntities;\n\n    let templateEntities: Map<string, Reference|Variable>;\n    if (scope.parentScope !== null) {\n      templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\n    } else {\n      templateEntities = new Map(currentEntities);\n    }\n\n    entityMap.set(scope.template, templateEntities);\n    return templateEntities;\n  }\n\n  const scopesToProcess: Scope[] = [rootScope];\n  while (scopesToProcess.length > 0) {\n    const scope = scopesToProcess.pop()!;\n    for (const childScope of scope.childScopes.values()) {\n      scopesToProcess.push(childScope);\n    }\n    extractScopeEntities(scope);\n  }\n\n  const templateEntities = new Map<Template|null, Set<Reference|Variable>>();\n  for (const [template, entities] of entityMap) {\n    templateEntities.set(template, new Set(entities.values()));\n  }\n  return templateEntities;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}