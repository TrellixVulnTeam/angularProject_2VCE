{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleMemoryHost = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar exception_1 = require(\"../../exception\");\n\nvar path_1 = require(\"../path\");\n\nvar SimpleMemoryHost = /*#__PURE__*/function () {\n  function SimpleMemoryHost() {\n    _classCallCheck(this, SimpleMemoryHost);\n\n    this._cache = new Map();\n    this._watchers = new Map();\n\n    this._cache.set(path_1.normalize('/'), this._newDirStats());\n  }\n\n  _createClass(SimpleMemoryHost, [{\n    key: \"_newDirStats\",\n    value: function _newDirStats() {\n      return {\n        inspect: function inspect() {\n          return '<Directory>';\n        },\n        isFile: function isFile() {\n          return false;\n        },\n        isDirectory: function isDirectory() {\n          return true;\n        },\n        size: 0,\n        atime: new Date(),\n        ctime: new Date(),\n        mtime: new Date(),\n        birthtime: new Date(),\n        content: null\n      };\n    }\n  }, {\n    key: \"_newFileStats\",\n    value: function _newFileStats(content, oldStats) {\n      return {\n        inspect: function inspect() {\n          return \"<File size(\".concat(content.byteLength, \")>\");\n        },\n        isFile: function isFile() {\n          return true;\n        },\n        isDirectory: function isDirectory() {\n          return false;\n        },\n        size: content.byteLength,\n        atime: oldStats ? oldStats.atime : new Date(),\n        ctime: new Date(),\n        mtime: new Date(),\n        birthtime: oldStats ? oldStats.birthtime : new Date(),\n        content: content\n      };\n    }\n  }, {\n    key: \"_toAbsolute\",\n    value: function _toAbsolute(path) {\n      return path_1.isAbsolute(path) ? path : path_1.normalize('/' + path);\n    }\n  }, {\n    key: \"_updateWatchers\",\n    value: function _updateWatchers(path, type) {\n      var _this = this;\n\n      var time = new Date();\n      var currentPath = path;\n      var parent = null;\n\n      if (this._watchers.size == 0) {\n        // Nothing to do if there's no watchers.\n        return;\n      }\n\n      var maybeWatcher = this._watchers.get(currentPath);\n\n      if (maybeWatcher) {\n        maybeWatcher.forEach(function (watcher) {\n          var _watcher = _slicedToArray(watcher, 2),\n              options = _watcher[0],\n              subject = _watcher[1];\n\n          subject.next({\n            path: path,\n            time: time,\n            type: type\n          });\n\n          if (!options.persistent && type == 2\n          /* Deleted */\n          ) {\n              subject.complete();\n\n              _this._watchers.delete(currentPath);\n            }\n        });\n      }\n\n      do {\n        currentPath = parent !== null ? parent : currentPath;\n        parent = path_1.dirname(currentPath);\n\n        var _maybeWatcher = this._watchers.get(currentPath);\n\n        if (_maybeWatcher) {\n          _maybeWatcher.forEach(function (watcher) {\n            var _watcher2 = _slicedToArray(watcher, 2),\n                options = _watcher2[0],\n                subject = _watcher2[1];\n\n            if (!options.recursive) {\n              return;\n            }\n\n            subject.next({\n              path: path,\n              time: time,\n              type: type\n            });\n\n            if (!options.persistent && type == 2\n            /* Deleted */\n            ) {\n                subject.complete();\n\n                _this._watchers.delete(currentPath);\n              }\n          });\n        }\n      } while (parent != currentPath);\n    }\n  }, {\n    key: \"capabilities\",\n    get: function get() {\n      return {\n        synchronous: true\n      };\n    }\n    /**\n     * List of protected methods that give direct access outside the observables to the cache\n     * and internal states.\n     */\n\n  }, {\n    key: \"_write\",\n    value: function _write(path, content) {\n      path = this._toAbsolute(path);\n\n      var old = this._cache.get(path);\n\n      if (old && old.isDirectory()) {\n        throw new exception_1.PathIsDirectoryException(path);\n      } // Update all directories. If we find a file we know it's an invalid write.\n\n\n      var fragments = path_1.split(path);\n      var curr = path_1.normalize('/');\n\n      var _iterator = _createForOfIteratorHelper(fragments),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var fr = _step.value;\n          curr = path_1.join(curr, fr);\n\n          var maybeStats = this._cache.get(fr);\n\n          if (maybeStats) {\n            if (maybeStats.isFile()) {\n              throw new exception_1.PathIsFileException(curr);\n            }\n          } else {\n            this._cache.set(curr, this._newDirStats());\n          }\n        } // Create the stats.\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var stats = this._newFileStats(content, old);\n\n      this._cache.set(path, stats);\n\n      this._updateWatchers(path, old ? 0\n      /* Changed */\n      : 1\n      /* Created */\n      );\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(path) {\n      path = this._toAbsolute(path);\n\n      var maybeStats = this._cache.get(path);\n\n      if (!maybeStats) {\n        throw new exception_1.FileDoesNotExistException(path);\n      } else if (maybeStats.isDirectory()) {\n        throw new exception_1.PathIsDirectoryException(path);\n      } else if (!maybeStats.content) {\n        throw new exception_1.PathIsDirectoryException(path);\n      } else {\n        return maybeStats.content;\n      }\n    }\n  }, {\n    key: \"_delete\",\n    value: function _delete(path) {\n      path = this._toAbsolute(path);\n\n      if (this._isDirectory(path)) {\n        var _iterator2 = _createForOfIteratorHelper(this._cache.entries()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _slicedToArray(_step2.value, 1),\n                cachePath = _step2$value[0];\n\n            if (cachePath.startsWith(path + path_1.NormalizedSep) || cachePath === path) {\n              this._cache.delete(cachePath);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else {\n        this._cache.delete(path);\n      }\n\n      this._updateWatchers(path, 2\n      /* Deleted */\n      );\n    }\n  }, {\n    key: \"_rename\",\n    value: function _rename(from, to) {\n      from = this._toAbsolute(from);\n      to = this._toAbsolute(to);\n\n      if (!this._cache.has(from)) {\n        throw new exception_1.FileDoesNotExistException(from);\n      } else if (this._cache.has(to)) {\n        throw new exception_1.FileAlreadyExistException(to);\n      }\n\n      if (this._isDirectory(from)) {\n        var _iterator3 = _createForOfIteratorHelper(this._cache.keys()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var path = _step3.value;\n\n            if (path.startsWith(from + path_1.NormalizedSep)) {\n              var content = this._cache.get(path);\n\n              if (content) {\n                // We don't need to clone or extract the content, since we're moving files.\n                this._cache.set(path_1.join(to, path_1.NormalizedSep, path.slice(from.length)), content);\n              }\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      } else {\n        var _content = this._cache.get(from);\n\n        if (_content) {\n          var fragments = path_1.split(to);\n          var newDirectories = [];\n          var curr = path_1.normalize('/');\n\n          var _iterator4 = _createForOfIteratorHelper(fragments),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var fr = _step4.value;\n              curr = path_1.join(curr, fr);\n\n              var maybeStats = this._cache.get(fr);\n\n              if (maybeStats) {\n                if (maybeStats.isFile()) {\n                  throw new exception_1.PathIsFileException(curr);\n                }\n              } else {\n                newDirectories.push(curr);\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          for (var _i = 0, _newDirectories = newDirectories; _i < _newDirectories.length; _i++) {\n            var newDirectory = _newDirectories[_i];\n\n            this._cache.set(newDirectory, this._newDirStats());\n          }\n\n          this._cache.delete(from);\n\n          this._cache.set(to, _content);\n        }\n      }\n\n      this._updateWatchers(from, 3\n      /* Renamed */\n      );\n    }\n  }, {\n    key: \"_list\",\n    value: function _list(path) {\n      path = this._toAbsolute(path);\n\n      if (this._isFile(path)) {\n        throw new exception_1.PathIsFileException(path);\n      }\n\n      var fragments = path_1.split(path);\n      var result = new Set();\n\n      if (path !== path_1.NormalizedRoot) {\n        var _iterator5 = _createForOfIteratorHelper(this._cache.keys()),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var p = _step5.value;\n\n            if (p.startsWith(path + path_1.NormalizedSep)) {\n              result.add(path_1.split(p)[fragments.length]);\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      } else {\n        var _iterator6 = _createForOfIteratorHelper(this._cache.keys()),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var _p = _step6.value;\n\n            if (_p.startsWith(path_1.NormalizedSep) && _p !== path_1.NormalizedRoot) {\n              result.add(path_1.split(_p)[1]);\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n      }\n\n      return _toConsumableArray(result);\n    }\n  }, {\n    key: \"_exists\",\n    value: function _exists(path) {\n      return !!this._cache.get(this._toAbsolute(path));\n    }\n  }, {\n    key: \"_isDirectory\",\n    value: function _isDirectory(path) {\n      var maybeStats = this._cache.get(this._toAbsolute(path));\n\n      return maybeStats ? maybeStats.isDirectory() : false;\n    }\n  }, {\n    key: \"_isFile\",\n    value: function _isFile(path) {\n      var maybeStats = this._cache.get(this._toAbsolute(path));\n\n      return maybeStats ? maybeStats.isFile() : false;\n    }\n  }, {\n    key: \"_stat\",\n    value: function _stat(path) {\n      var maybeStats = this._cache.get(this._toAbsolute(path));\n\n      if (!maybeStats) {\n        return null;\n      } else {\n        return maybeStats;\n      }\n    }\n  }, {\n    key: \"_watch\",\n    value: function _watch(path, options) {\n      path = this._toAbsolute(path);\n      var subject = new rxjs_1.Subject();\n\n      var maybeWatcherArray = this._watchers.get(path);\n\n      if (!maybeWatcherArray) {\n        maybeWatcherArray = [];\n\n        this._watchers.set(path, maybeWatcherArray);\n      }\n\n      maybeWatcherArray.push([options || {}, subject]);\n      return subject.asObservable();\n    }\n  }, {\n    key: \"write\",\n    value: function write(path, content) {\n      var _this2 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        _this2._write(path, content);\n\n        obs.next();\n        obs.complete();\n      });\n    }\n  }, {\n    key: \"read\",\n    value: function read(path) {\n      var _this3 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        var content = _this3._read(path);\n\n        obs.next(content);\n        obs.complete();\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(path) {\n      var _this4 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        _this4._delete(path);\n\n        obs.next();\n        obs.complete();\n      });\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(from, to) {\n      var _this5 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        _this5._rename(from, to);\n\n        obs.next();\n        obs.complete();\n      });\n    }\n  }, {\n    key: \"list\",\n    value: function list(path) {\n      var _this6 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        obs.next(_this6._list(path));\n        obs.complete();\n      });\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(path) {\n      var _this7 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        obs.next(_this7._exists(path));\n        obs.complete();\n      });\n    }\n  }, {\n    key: \"isDirectory\",\n    value: function isDirectory(path) {\n      var _this8 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        obs.next(_this8._isDirectory(path));\n        obs.complete();\n      });\n    }\n  }, {\n    key: \"isFile\",\n    value: function isFile(path) {\n      var _this9 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        obs.next(_this9._isFile(path));\n        obs.complete();\n      });\n    } // Some hosts may not support stat.\n\n  }, {\n    key: \"stat\",\n    value: function stat(path) {\n      var _this10 = this;\n\n      return new rxjs_1.Observable(function (obs) {\n        obs.next(_this10._stat(path));\n        obs.complete();\n      });\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(path, options) {\n      return this._watch(path, options);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this._cache.clear();\n\n      this._watchers.clear();\n    }\n  }]);\n\n  return SimpleMemoryHost;\n}();\n\nexports.SimpleMemoryHost = SimpleMemoryHost;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/virtual-fs/host/memory.js"],"names":["Object","defineProperty","exports","value","SimpleMemoryHost","rxjs_1","require","exception_1","path_1","_cache","Map","_watchers","set","normalize","_newDirStats","inspect","isFile","isDirectory","size","atime","Date","ctime","mtime","birthtime","content","oldStats","byteLength","path","isAbsolute","type","time","currentPath","parent","maybeWatcher","get","forEach","watcher","options","subject","next","persistent","complete","delete","dirname","recursive","synchronous","_toAbsolute","old","PathIsDirectoryException","fragments","split","curr","fr","join","maybeStats","PathIsFileException","stats","_newFileStats","_updateWatchers","FileDoesNotExistException","_isDirectory","entries","cachePath","startsWith","NormalizedSep","from","to","has","FileAlreadyExistException","keys","slice","length","newDirectories","push","newDirectory","_isFile","result","Set","NormalizedRoot","p","add","Subject","maybeWatcherArray","asObservable","Observable","obs","_write","_read","_delete","_rename","_list","_exists","_stat","_watch","clear"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleMemoryHost = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst rxjs_1 = require(\"rxjs\");\nconst exception_1 = require(\"../../exception\");\nconst path_1 = require(\"../path\");\nclass SimpleMemoryHost {\n    constructor() {\n        this._cache = new Map();\n        this._watchers = new Map();\n        this._cache.set(path_1.normalize('/'), this._newDirStats());\n    }\n    _newDirStats() {\n        return {\n            inspect() { return '<Directory>'; },\n            isFile() { return false; },\n            isDirectory() { return true; },\n            size: 0,\n            atime: new Date(),\n            ctime: new Date(),\n            mtime: new Date(),\n            birthtime: new Date(),\n            content: null,\n        };\n    }\n    _newFileStats(content, oldStats) {\n        return {\n            inspect() { return `<File size(${content.byteLength})>`; },\n            isFile() { return true; },\n            isDirectory() { return false; },\n            size: content.byteLength,\n            atime: oldStats ? oldStats.atime : new Date(),\n            ctime: new Date(),\n            mtime: new Date(),\n            birthtime: oldStats ? oldStats.birthtime : new Date(),\n            content,\n        };\n    }\n    _toAbsolute(path) {\n        return path_1.isAbsolute(path) ? path : path_1.normalize('/' + path);\n    }\n    _updateWatchers(path, type) {\n        const time = new Date();\n        let currentPath = path;\n        let parent = null;\n        if (this._watchers.size == 0) {\n            // Nothing to do if there's no watchers.\n            return;\n        }\n        const maybeWatcher = this._watchers.get(currentPath);\n        if (maybeWatcher) {\n            maybeWatcher.forEach(watcher => {\n                const [options, subject] = watcher;\n                subject.next({ path, time, type });\n                if (!options.persistent && type == 2 /* Deleted */) {\n                    subject.complete();\n                    this._watchers.delete(currentPath);\n                }\n            });\n        }\n        do {\n            currentPath = parent !== null ? parent : currentPath;\n            parent = path_1.dirname(currentPath);\n            const maybeWatcher = this._watchers.get(currentPath);\n            if (maybeWatcher) {\n                maybeWatcher.forEach(watcher => {\n                    const [options, subject] = watcher;\n                    if (!options.recursive) {\n                        return;\n                    }\n                    subject.next({ path, time, type });\n                    if (!options.persistent && type == 2 /* Deleted */) {\n                        subject.complete();\n                        this._watchers.delete(currentPath);\n                    }\n                });\n            }\n        } while (parent != currentPath);\n    }\n    get capabilities() {\n        return { synchronous: true };\n    }\n    /**\n     * List of protected methods that give direct access outside the observables to the cache\n     * and internal states.\n     */\n    _write(path, content) {\n        path = this._toAbsolute(path);\n        const old = this._cache.get(path);\n        if (old && old.isDirectory()) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        // Update all directories. If we find a file we know it's an invalid write.\n        const fragments = path_1.split(path);\n        let curr = path_1.normalize('/');\n        for (const fr of fragments) {\n            curr = path_1.join(curr, fr);\n            const maybeStats = this._cache.get(fr);\n            if (maybeStats) {\n                if (maybeStats.isFile()) {\n                    throw new exception_1.PathIsFileException(curr);\n                }\n            }\n            else {\n                this._cache.set(curr, this._newDirStats());\n            }\n        }\n        // Create the stats.\n        const stats = this._newFileStats(content, old);\n        this._cache.set(path, stats);\n        this._updateWatchers(path, old ? 0 /* Changed */ : 1 /* Created */);\n    }\n    _read(path) {\n        path = this._toAbsolute(path);\n        const maybeStats = this._cache.get(path);\n        if (!maybeStats) {\n            throw new exception_1.FileDoesNotExistException(path);\n        }\n        else if (maybeStats.isDirectory()) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        else if (!maybeStats.content) {\n            throw new exception_1.PathIsDirectoryException(path);\n        }\n        else {\n            return maybeStats.content;\n        }\n    }\n    _delete(path) {\n        path = this._toAbsolute(path);\n        if (this._isDirectory(path)) {\n            for (const [cachePath] of this._cache.entries()) {\n                if (cachePath.startsWith(path + path_1.NormalizedSep) || cachePath === path) {\n                    this._cache.delete(cachePath);\n                }\n            }\n        }\n        else {\n            this._cache.delete(path);\n        }\n        this._updateWatchers(path, 2 /* Deleted */);\n    }\n    _rename(from, to) {\n        from = this._toAbsolute(from);\n        to = this._toAbsolute(to);\n        if (!this._cache.has(from)) {\n            throw new exception_1.FileDoesNotExistException(from);\n        }\n        else if (this._cache.has(to)) {\n            throw new exception_1.FileAlreadyExistException(to);\n        }\n        if (this._isDirectory(from)) {\n            for (const path of this._cache.keys()) {\n                if (path.startsWith(from + path_1.NormalizedSep)) {\n                    const content = this._cache.get(path);\n                    if (content) {\n                        // We don't need to clone or extract the content, since we're moving files.\n                        this._cache.set(path_1.join(to, path_1.NormalizedSep, path.slice(from.length)), content);\n                    }\n                }\n            }\n        }\n        else {\n            const content = this._cache.get(from);\n            if (content) {\n                const fragments = path_1.split(to);\n                const newDirectories = [];\n                let curr = path_1.normalize('/');\n                for (const fr of fragments) {\n                    curr = path_1.join(curr, fr);\n                    const maybeStats = this._cache.get(fr);\n                    if (maybeStats) {\n                        if (maybeStats.isFile()) {\n                            throw new exception_1.PathIsFileException(curr);\n                        }\n                    }\n                    else {\n                        newDirectories.push(curr);\n                    }\n                }\n                for (const newDirectory of newDirectories) {\n                    this._cache.set(newDirectory, this._newDirStats());\n                }\n                this._cache.delete(from);\n                this._cache.set(to, content);\n            }\n        }\n        this._updateWatchers(from, 3 /* Renamed */);\n    }\n    _list(path) {\n        path = this._toAbsolute(path);\n        if (this._isFile(path)) {\n            throw new exception_1.PathIsFileException(path);\n        }\n        const fragments = path_1.split(path);\n        const result = new Set();\n        if (path !== path_1.NormalizedRoot) {\n            for (const p of this._cache.keys()) {\n                if (p.startsWith(path + path_1.NormalizedSep)) {\n                    result.add(path_1.split(p)[fragments.length]);\n                }\n            }\n        }\n        else {\n            for (const p of this._cache.keys()) {\n                if (p.startsWith(path_1.NormalizedSep) && p !== path_1.NormalizedRoot) {\n                    result.add(path_1.split(p)[1]);\n                }\n            }\n        }\n        return [...result];\n    }\n    _exists(path) {\n        return !!this._cache.get(this._toAbsolute(path));\n    }\n    _isDirectory(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        return maybeStats ? maybeStats.isDirectory() : false;\n    }\n    _isFile(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        return maybeStats ? maybeStats.isFile() : false;\n    }\n    _stat(path) {\n        const maybeStats = this._cache.get(this._toAbsolute(path));\n        if (!maybeStats) {\n            return null;\n        }\n        else {\n            return maybeStats;\n        }\n    }\n    _watch(path, options) {\n        path = this._toAbsolute(path);\n        const subject = new rxjs_1.Subject();\n        let maybeWatcherArray = this._watchers.get(path);\n        if (!maybeWatcherArray) {\n            maybeWatcherArray = [];\n            this._watchers.set(path, maybeWatcherArray);\n        }\n        maybeWatcherArray.push([options || {}, subject]);\n        return subject.asObservable();\n    }\n    write(path, content) {\n        return new rxjs_1.Observable(obs => {\n            this._write(path, content);\n            obs.next();\n            obs.complete();\n        });\n    }\n    read(path) {\n        return new rxjs_1.Observable(obs => {\n            const content = this._read(path);\n            obs.next(content);\n            obs.complete();\n        });\n    }\n    delete(path) {\n        return new rxjs_1.Observable(obs => {\n            this._delete(path);\n            obs.next();\n            obs.complete();\n        });\n    }\n    rename(from, to) {\n        return new rxjs_1.Observable(obs => {\n            this._rename(from, to);\n            obs.next();\n            obs.complete();\n        });\n    }\n    list(path) {\n        return new rxjs_1.Observable(obs => {\n            obs.next(this._list(path));\n            obs.complete();\n        });\n    }\n    exists(path) {\n        return new rxjs_1.Observable(obs => {\n            obs.next(this._exists(path));\n            obs.complete();\n        });\n    }\n    isDirectory(path) {\n        return new rxjs_1.Observable(obs => {\n            obs.next(this._isDirectory(path));\n            obs.complete();\n        });\n    }\n    isFile(path) {\n        return new rxjs_1.Observable(obs => {\n            obs.next(this._isFile(path));\n            obs.complete();\n        });\n    }\n    // Some hosts may not support stat.\n    stat(path) {\n        return new rxjs_1.Observable(obs => {\n            obs.next(this._stat(path));\n            obs.complete();\n        });\n    }\n    watch(path, options) {\n        return this._watch(path, options);\n    }\n    reset() {\n        this._cache.clear();\n        this._watchers.clear();\n    }\n}\nexports.SimpleMemoryHost = SimpleMemoryHost;\n"]},"metadata":{},"sourceType":"script"}