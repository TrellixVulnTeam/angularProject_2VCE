{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/tasks/utils\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/execution/tasks/api\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.sortTasksByPriority = exports.getBlockedTasks = exports.getDependentsSet = exports.computeTaskDependencies = exports.stringifyTask = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var api_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/api\");\n  /** Stringify a task for debugging purposes. */\n\n\n  var stringifyTask = function stringifyTask(task) {\n    return \"{entryPoint: \" + task.entryPoint.name + \", formatProperty: \" + task.formatProperty + \", \" + (\"processDts: \" + api_1.DtsProcessing[task.processDts] + \"}\");\n  };\n\n  exports.stringifyTask = stringifyTask;\n  /**\n   * Compute a mapping of tasks to the tasks that are dependent on them (if any).\n   *\n   * Task A can depend upon task B, if either:\n   *\n   * * A and B have the same entry-point _and_ B is generating the typings for that entry-point\n   *   (i.e. has `processDts: true`).\n   * * A's entry-point depends on B's entry-point _and_ B is also generating typings.\n   *\n   * NOTE: If a task is not generating typings, then it cannot affect anything which depends on its\n   *       entry-point, regardless of the dependency graph. To put this another way, only the task\n   *       which produces the typings for a dependency needs to have been completed.\n   *\n   * As a performance optimization, we take into account the fact that `tasks` are sorted in such a\n   * way that a task can only depend on earlier tasks (i.e. dependencies always come before\n   * dependents in the list of tasks).\n   *\n   * @param tasks A (partially ordered) list of tasks.\n   * @param graph The dependency graph between entry-points.\n   * @return A map from each task to those tasks directly dependent upon it.\n   */\n\n  function computeTaskDependencies(tasks, graph) {\n    var dependencies = new api_1.TaskDependencies();\n    var candidateDependencies = new Map();\n    tasks.forEach(function (task) {\n      var e_1, _a;\n\n      var entryPointPath = task.entryPoint.path; // Find the earlier tasks (`candidateDependencies`) that this task depends upon.\n\n      var deps = graph.dependenciesOf(entryPointPath);\n      var taskDependencies = deps.filter(function (dep) {\n        return candidateDependencies.has(dep);\n      }).map(function (dep) {\n        return candidateDependencies.get(dep);\n      }); // If this task has dependencies, add it to the dependencies and dependents maps.\n\n      if (taskDependencies.length > 0) {\n        try {\n          for (var taskDependencies_1 = tslib_1.__values(taskDependencies), taskDependencies_1_1 = taskDependencies_1.next(); !taskDependencies_1_1.done; taskDependencies_1_1 = taskDependencies_1.next()) {\n            var dependency = taskDependencies_1_1.value;\n            var taskDependents = getDependentsSet(dependencies, dependency);\n            taskDependents.add(task);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (taskDependencies_1_1 && !taskDependencies_1_1.done && (_a = taskDependencies_1.return)) _a.call(taskDependencies_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n\n      if (task.processDts !== api_1.DtsProcessing.No) {\n        // SANITY CHECK:\n        // There should only be one task per entry-point that generates typings (and thus can be a\n        // dependency of other tasks), so the following should theoretically never happen, but check\n        // just in case.\n        if (candidateDependencies.has(entryPointPath)) {\n          var otherTask = candidateDependencies.get(entryPointPath);\n          throw new Error('Invariant violated: Multiple tasks are assigned generating typings for ' + (\"'\" + entryPointPath + \"':\\n  - \" + exports.stringifyTask(otherTask) + \"\\n  - \" + exports.stringifyTask(task)));\n        } // This task can potentially be a dependency (i.e. it generates typings), so add it to the\n        // list of candidate dependencies for subsequent tasks.\n\n\n        candidateDependencies.set(entryPointPath, task);\n      } else {\n        // This task is not generating typings so we need to add it to the dependents of the task that\n        // does generate typings, if that exists\n        if (candidateDependencies.has(entryPointPath)) {\n          var typingsTask = candidateDependencies.get(entryPointPath);\n          var typingsTaskDependents = getDependentsSet(dependencies, typingsTask);\n          typingsTaskDependents.add(task);\n        }\n      }\n    });\n    return dependencies;\n  }\n\n  exports.computeTaskDependencies = computeTaskDependencies;\n\n  function getDependentsSet(map, task) {\n    if (!map.has(task)) {\n      map.set(task, new Set());\n    }\n\n    return map.get(task);\n  }\n\n  exports.getDependentsSet = getDependentsSet;\n  /**\n   * Invert the given mapping of Task dependencies.\n   *\n   * @param dependencies The mapping of tasks to the tasks that depend upon them.\n   * @returns A mapping of tasks to the tasks that they depend upon.\n   */\n\n  function getBlockedTasks(dependencies) {\n    var e_2, _a, e_3, _b;\n\n    var blockedTasks = new Map();\n\n    try {\n      for (var dependencies_1 = tslib_1.__values(dependencies), dependencies_1_1 = dependencies_1.next(); !dependencies_1_1.done; dependencies_1_1 = dependencies_1.next()) {\n        var _c = tslib_1.__read(dependencies_1_1.value, 2),\n            dependency = _c[0],\n            dependents = _c[1];\n\n        try {\n          for (var dependents_1 = (e_3 = void 0, tslib_1.__values(dependents)), dependents_1_1 = dependents_1.next(); !dependents_1_1.done; dependents_1_1 = dependents_1.next()) {\n            var dependent = dependents_1_1.value;\n            var dependentSet = getDependentsSet(blockedTasks, dependent);\n            dependentSet.add(dependency);\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (dependents_1_1 && !dependents_1_1.done && (_b = dependents_1.return)) _b.call(dependents_1);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (dependencies_1_1 && !dependencies_1_1.done && (_a = dependencies_1.return)) _a.call(dependencies_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return blockedTasks;\n  }\n\n  exports.getBlockedTasks = getBlockedTasks;\n  /**\n   * Sort a list of tasks by priority.\n   *\n   * Priority is determined by the number of other tasks that a task is (transitively) blocking:\n   * The more tasks a task is blocking the higher its priority is, because processing it will\n   * potentially unblock more tasks.\n   *\n   * To keep the behavior predictable, if two tasks block the same number of other tasks, their\n   * relative order in the original `tasks` lists is preserved.\n   *\n   * @param tasks A (partially ordered) list of tasks.\n   * @param dependencies The mapping of tasks to the tasks that depend upon them.\n   * @return The list of tasks sorted by priority.\n   */\n\n  function sortTasksByPriority(tasks, dependencies) {\n    var priorityPerTask = new Map();\n\n    var computePriority = function computePriority(task, idx) {\n      return [dependencies.has(task) ? dependencies.get(task).size : 0, idx];\n    };\n\n    tasks.forEach(function (task, i) {\n      return priorityPerTask.set(task, computePriority(task, i));\n    });\n    return tasks.slice().sort(function (task1, task2) {\n      var _a = tslib_1.__read(priorityPerTask.get(task1), 2),\n          p1 = _a[0],\n          idx1 = _a[1];\n\n      var _b = tslib_1.__read(priorityPerTask.get(task2), 2),\n          p2 = _b[0],\n          idx2 = _b[1];\n\n      return p2 - p1 || idx1 - idx2;\n    });\n  }\n\n  exports.sortTasksByPriority = sortTasksByPriority;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/ngcc/src/execution/tasks/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {DepGraph} from 'dependency-graph';\nimport {EntryPoint} from '../../packages/entry_point';\nimport {DtsProcessing, PartiallyOrderedTasks, Task, TaskDependencies} from './api';\n\n/** Stringify a task for debugging purposes. */\nexport const stringifyTask = (task: Task): string =>\n    `{entryPoint: ${task.entryPoint.name}, formatProperty: ${task.formatProperty}, ` +\n    `processDts: ${DtsProcessing[task.processDts]}}`;\n\n/**\n * Compute a mapping of tasks to the tasks that are dependent on them (if any).\n *\n * Task A can depend upon task B, if either:\n *\n * * A and B have the same entry-point _and_ B is generating the typings for that entry-point\n *   (i.e. has `processDts: true`).\n * * A's entry-point depends on B's entry-point _and_ B is also generating typings.\n *\n * NOTE: If a task is not generating typings, then it cannot affect anything which depends on its\n *       entry-point, regardless of the dependency graph. To put this another way, only the task\n *       which produces the typings for a dependency needs to have been completed.\n *\n * As a performance optimization, we take into account the fact that `tasks` are sorted in such a\n * way that a task can only depend on earlier tasks (i.e. dependencies always come before\n * dependents in the list of tasks).\n *\n * @param tasks A (partially ordered) list of tasks.\n * @param graph The dependency graph between entry-points.\n * @return A map from each task to those tasks directly dependent upon it.\n */\nexport function computeTaskDependencies(\n    tasks: PartiallyOrderedTasks, graph: DepGraph<EntryPoint>): TaskDependencies {\n  const dependencies = new TaskDependencies();\n  const candidateDependencies = new Map<string, Task>();\n\n  tasks.forEach(task => {\n    const entryPointPath = task.entryPoint.path;\n\n    // Find the earlier tasks (`candidateDependencies`) that this task depends upon.\n    const deps = graph.dependenciesOf(entryPointPath);\n    const taskDependencies = deps.filter(dep => candidateDependencies.has(dep))\n                                 .map(dep => candidateDependencies.get(dep)!);\n\n    // If this task has dependencies, add it to the dependencies and dependents maps.\n    if (taskDependencies.length > 0) {\n      for (const dependency of taskDependencies) {\n        const taskDependents = getDependentsSet(dependencies, dependency);\n        taskDependents.add(task);\n      }\n    }\n\n    if (task.processDts !== DtsProcessing.No) {\n      // SANITY CHECK:\n      // There should only be one task per entry-point that generates typings (and thus can be a\n      // dependency of other tasks), so the following should theoretically never happen, but check\n      // just in case.\n      if (candidateDependencies.has(entryPointPath)) {\n        const otherTask = candidateDependencies.get(entryPointPath)!;\n        throw new Error(\n            'Invariant violated: Multiple tasks are assigned generating typings for ' +\n            `'${entryPointPath}':\\n  - ${stringifyTask(otherTask)}\\n  - ${stringifyTask(task)}`);\n      }\n      // This task can potentially be a dependency (i.e. it generates typings), so add it to the\n      // list of candidate dependencies for subsequent tasks.\n      candidateDependencies.set(entryPointPath, task);\n    } else {\n      // This task is not generating typings so we need to add it to the dependents of the task that\n      // does generate typings, if that exists\n      if (candidateDependencies.has(entryPointPath)) {\n        const typingsTask = candidateDependencies.get(entryPointPath)!;\n        const typingsTaskDependents = getDependentsSet(dependencies, typingsTask);\n        typingsTaskDependents.add(task);\n      }\n    }\n  });\n\n  return dependencies;\n}\n\nexport function getDependentsSet(map: TaskDependencies, task: Task): Set<Task> {\n  if (!map.has(task)) {\n    map.set(task, new Set());\n  }\n  return map.get(task)!;\n}\n\n/**\n * Invert the given mapping of Task dependencies.\n *\n * @param dependencies The mapping of tasks to the tasks that depend upon them.\n * @returns A mapping of tasks to the tasks that they depend upon.\n */\nexport function getBlockedTasks(dependencies: TaskDependencies): Map<Task, Set<Task>> {\n  const blockedTasks = new Map<Task, Set<Task>>();\n  for (const [dependency, dependents] of dependencies) {\n    for (const dependent of dependents) {\n      const dependentSet = getDependentsSet(blockedTasks, dependent);\n      dependentSet.add(dependency);\n    }\n  }\n  return blockedTasks;\n}\n\n/**\n * Sort a list of tasks by priority.\n *\n * Priority is determined by the number of other tasks that a task is (transitively) blocking:\n * The more tasks a task is blocking the higher its priority is, because processing it will\n * potentially unblock more tasks.\n *\n * To keep the behavior predictable, if two tasks block the same number of other tasks, their\n * relative order in the original `tasks` lists is preserved.\n *\n * @param tasks A (partially ordered) list of tasks.\n * @param dependencies The mapping of tasks to the tasks that depend upon them.\n * @return The list of tasks sorted by priority.\n */\nexport function sortTasksByPriority(\n    tasks: PartiallyOrderedTasks, dependencies: TaskDependencies): PartiallyOrderedTasks {\n  const priorityPerTask = new Map<Task, [number, number]>();\n  const computePriority = (task: Task, idx: number):\n      [number, number] => [dependencies.has(task) ? dependencies.get(task)!.size : 0, idx];\n\n  tasks.forEach((task, i) => priorityPerTask.set(task, computePriority(task, i)));\n\n  return tasks.slice().sort((task1, task2) => {\n    const [p1, idx1] = priorityPerTask.get(task1)!;\n    const [p2, idx2] = priorityPerTask.get(task2)!;\n\n    return (p2 - p1) || (idx1 - idx2);\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}