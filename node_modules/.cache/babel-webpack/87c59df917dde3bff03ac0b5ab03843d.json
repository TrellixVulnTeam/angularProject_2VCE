{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/writing/in_place_file_writer\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/file_system\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.InPlaceFileWriter = exports.NGCC_BACKUP_EXTENSION = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  exports.NGCC_BACKUP_EXTENSION = '.__ivy_ngcc_bak';\n  /**\n   * This FileWriter overwrites the transformed file, in-place, while creating\n   * a back-up of the original file with an extra `.__ivy_ngcc_bak` extension.\n   */\n\n  var InPlaceFileWriter =\n  /** @class */\n  function () {\n    function InPlaceFileWriter(fs, logger, errorOnFailedEntryPoint) {\n      this.fs = fs;\n      this.logger = logger;\n      this.errorOnFailedEntryPoint = errorOnFailedEntryPoint;\n    }\n\n    InPlaceFileWriter.prototype.writeBundle = function (_bundle, transformedFiles, _formatProperties) {\n      var _this = this;\n\n      transformedFiles.forEach(function (file) {\n        return _this.writeFileAndBackup(file);\n      });\n    };\n\n    InPlaceFileWriter.prototype.revertBundle = function (_entryPoint, transformedFilePaths, _formatProperties) {\n      var e_1, _a;\n\n      try {\n        for (var transformedFilePaths_1 = tslib_1.__values(transformedFilePaths), transformedFilePaths_1_1 = transformedFilePaths_1.next(); !transformedFilePaths_1_1.done; transformedFilePaths_1_1 = transformedFilePaths_1.next()) {\n          var filePath = transformedFilePaths_1_1.value;\n          this.revertFileAndBackup(filePath);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (transformedFilePaths_1_1 && !transformedFilePaths_1_1.done && (_a = transformedFilePaths_1.return)) _a.call(transformedFilePaths_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    InPlaceFileWriter.prototype.writeFileAndBackup = function (file) {\n      this.fs.ensureDir(file_system_1.dirname(file.path));\n      var backPath = file_system_1.absoluteFrom(\"\" + file.path + exports.NGCC_BACKUP_EXTENSION);\n\n      if (this.fs.exists(backPath)) {\n        if (this.errorOnFailedEntryPoint) {\n          throw new Error(\"Tried to overwrite \" + backPath + \" with an ngcc back up file, which is disallowed.\");\n        } else {\n          this.logger.error(\"Tried to write \" + backPath + \" with an ngcc back up file but it already exists so not writing, nor backing up, \" + file.path + \".\\n\" + \"This error may be caused by one of the following:\\n\" + \"* two or more entry-points overlap and ngcc has been asked to process some files more than once.\\n\" + \"  In this case, you should check other entry-points in this package\\n\" + \"  and set up a config to ignore any that you are not using.\\n\" + \"* a previous run of ngcc was killed in the middle of processing, in a way that cannot be recovered.\\n\" + \"  In this case, you should try cleaning the node_modules directory and any dist directories that contain local libraries. Then try again.\");\n        }\n      } else {\n        if (this.fs.exists(file.path)) {\n          this.fs.moveFile(file.path, backPath);\n        }\n\n        this.fs.writeFile(file.path, file.contents);\n      }\n    };\n\n    InPlaceFileWriter.prototype.revertFileAndBackup = function (filePath) {\n      if (this.fs.exists(filePath)) {\n        this.fs.removeFile(filePath);\n        var backPath = file_system_1.absoluteFrom(\"\" + filePath + exports.NGCC_BACKUP_EXTENSION);\n\n        if (this.fs.exists(backPath)) {\n          this.fs.moveFile(backPath, filePath);\n        }\n      }\n    };\n\n    return InPlaceFileWriter;\n  }();\n\n  exports.InPlaceFileWriter = InPlaceFileWriter;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/writing/in_place_file_writer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {absoluteFrom, AbsoluteFsPath, dirname, FileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {EntryPoint, EntryPointJsonProperty} from '../packages/entry_point';\nimport {EntryPointBundle} from '../packages/entry_point_bundle';\nimport {FileToWrite} from '../rendering/utils';\n\nimport {FileWriter} from './file_writer';\n\nexport const NGCC_BACKUP_EXTENSION = '.__ivy_ngcc_bak';\n/**\n * This FileWriter overwrites the transformed file, in-place, while creating\n * a back-up of the original file with an extra `.__ivy_ngcc_bak` extension.\n */\nexport class InPlaceFileWriter implements FileWriter {\n  constructor(\n      protected fs: FileSystem, protected logger: Logger,\n      protected errorOnFailedEntryPoint: boolean) {}\n\n  writeBundle(\n      _bundle: EntryPointBundle, transformedFiles: FileToWrite[],\n      _formatProperties?: EntryPointJsonProperty[]) {\n    transformedFiles.forEach(file => this.writeFileAndBackup(file));\n  }\n\n  revertBundle(\n      _entryPoint: EntryPoint, transformedFilePaths: AbsoluteFsPath[],\n      _formatProperties: EntryPointJsonProperty[]): void {\n    for (const filePath of transformedFilePaths) {\n      this.revertFileAndBackup(filePath);\n    }\n  }\n\n  protected writeFileAndBackup(file: FileToWrite): void {\n    this.fs.ensureDir(dirname(file.path));\n    const backPath = absoluteFrom(`${file.path}${NGCC_BACKUP_EXTENSION}`);\n    if (this.fs.exists(backPath)) {\n      if (this.errorOnFailedEntryPoint) {\n        throw new Error(\n            `Tried to overwrite ${backPath} with an ngcc back up file, which is disallowed.`);\n      } else {\n        this.logger.error(\n            `Tried to write ${\n                backPath} with an ngcc back up file but it already exists so not writing, nor backing up, ${\n                file.path}.\\n` +\n            `This error may be caused by one of the following:\\n` +\n            `* two or more entry-points overlap and ngcc has been asked to process some files more than once.\\n` +\n            `  In this case, you should check other entry-points in this package\\n` +\n            `  and set up a config to ignore any that you are not using.\\n` +\n            `* a previous run of ngcc was killed in the middle of processing, in a way that cannot be recovered.\\n` +\n            `  In this case, you should try cleaning the node_modules directory and any dist directories that contain local libraries. Then try again.`);\n      }\n    } else {\n      if (this.fs.exists(file.path)) {\n        this.fs.moveFile(file.path, backPath);\n      }\n      this.fs.writeFile(file.path, file.contents);\n    }\n  }\n\n  protected revertFileAndBackup(filePath: AbsoluteFsPath): void {\n    if (this.fs.exists(filePath)) {\n      this.fs.removeFile(filePath);\n\n      const backPath = absoluteFrom(`${filePath}${NGCC_BACKUP_EXTENSION}`);\n      if (this.fs.exists(backPath)) {\n        this.fs.moveFile(backPath, filePath);\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}