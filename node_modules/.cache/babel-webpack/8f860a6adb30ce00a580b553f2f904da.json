{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/ml_parser/lexer\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/chars\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/ml_parser/interpolation_config\", \"@angular/compiler/src/ml_parser/tags\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.CursorError = exports.tokenize = exports.TokenizeResult = exports.TokenError = exports.Token = exports.TokenType = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var chars = require(\"@angular/compiler/src/chars\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var interpolation_config_1 = require(\"@angular/compiler/src/ml_parser/interpolation_config\");\n\n  var tags_1 = require(\"@angular/compiler/src/ml_parser/tags\");\n\n  var TokenType;\n\n  (function (TokenType) {\n    TokenType[TokenType[\"TAG_OPEN_START\"] = 0] = \"TAG_OPEN_START\";\n    TokenType[TokenType[\"TAG_OPEN_END\"] = 1] = \"TAG_OPEN_END\";\n    TokenType[TokenType[\"TAG_OPEN_END_VOID\"] = 2] = \"TAG_OPEN_END_VOID\";\n    TokenType[TokenType[\"TAG_CLOSE\"] = 3] = \"TAG_CLOSE\";\n    TokenType[TokenType[\"INCOMPLETE_TAG_OPEN\"] = 4] = \"INCOMPLETE_TAG_OPEN\";\n    TokenType[TokenType[\"TEXT\"] = 5] = \"TEXT\";\n    TokenType[TokenType[\"ESCAPABLE_RAW_TEXT\"] = 6] = \"ESCAPABLE_RAW_TEXT\";\n    TokenType[TokenType[\"RAW_TEXT\"] = 7] = \"RAW_TEXT\";\n    TokenType[TokenType[\"COMMENT_START\"] = 8] = \"COMMENT_START\";\n    TokenType[TokenType[\"COMMENT_END\"] = 9] = \"COMMENT_END\";\n    TokenType[TokenType[\"CDATA_START\"] = 10] = \"CDATA_START\";\n    TokenType[TokenType[\"CDATA_END\"] = 11] = \"CDATA_END\";\n    TokenType[TokenType[\"ATTR_NAME\"] = 12] = \"ATTR_NAME\";\n    TokenType[TokenType[\"ATTR_QUOTE\"] = 13] = \"ATTR_QUOTE\";\n    TokenType[TokenType[\"ATTR_VALUE\"] = 14] = \"ATTR_VALUE\";\n    TokenType[TokenType[\"DOC_TYPE\"] = 15] = \"DOC_TYPE\";\n    TokenType[TokenType[\"EXPANSION_FORM_START\"] = 16] = \"EXPANSION_FORM_START\";\n    TokenType[TokenType[\"EXPANSION_CASE_VALUE\"] = 17] = \"EXPANSION_CASE_VALUE\";\n    TokenType[TokenType[\"EXPANSION_CASE_EXP_START\"] = 18] = \"EXPANSION_CASE_EXP_START\";\n    TokenType[TokenType[\"EXPANSION_CASE_EXP_END\"] = 19] = \"EXPANSION_CASE_EXP_END\";\n    TokenType[TokenType[\"EXPANSION_FORM_END\"] = 20] = \"EXPANSION_FORM_END\";\n    TokenType[TokenType[\"EOF\"] = 21] = \"EOF\";\n  })(TokenType = exports.TokenType || (exports.TokenType = {}));\n\n  var Token =\n  /** @class */\n  function () {\n    function Token(type, parts, sourceSpan) {\n      this.type = type;\n      this.parts = parts;\n      this.sourceSpan = sourceSpan;\n    }\n\n    return Token;\n  }();\n\n  exports.Token = Token;\n\n  var TokenError =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TokenError, _super);\n\n    function TokenError(errorMsg, tokenType, span) {\n      var _this = _super.call(this, span, errorMsg) || this;\n\n      _this.tokenType = tokenType;\n      return _this;\n    }\n\n    return TokenError;\n  }(parse_util_1.ParseError);\n\n  exports.TokenError = TokenError;\n\n  var TokenizeResult =\n  /** @class */\n  function () {\n    function TokenizeResult(tokens, errors, nonNormalizedIcuExpressions) {\n      this.tokens = tokens;\n      this.errors = errors;\n      this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n    }\n\n    return TokenizeResult;\n  }();\n\n  exports.TokenizeResult = TokenizeResult;\n\n  function tokenize(source, url, getTagDefinition, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var tokenizer = new _Tokenizer(new parse_util_1.ParseSourceFile(source, url), getTagDefinition, options);\n    tokenizer.tokenize();\n    return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n  }\n\n  exports.tokenize = tokenize;\n  var _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\n  function _unexpectedCharacterErrorMsg(charCode) {\n    var char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n    return \"Unexpected character \\\"\" + char + \"\\\"\";\n  }\n\n  function _unknownEntityErrorMsg(entitySrc) {\n    return \"Unknown entity \\\"\" + entitySrc + \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\";\n  }\n\n  function _unparsableEntityErrorMsg(type, entityStr) {\n    return \"Unable to parse entity \\\"\" + entityStr + \"\\\" - \" + type + \" character reference entities must end with \\\";\\\"\";\n  }\n\n  var CharacterReferenceType;\n\n  (function (CharacterReferenceType) {\n    CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\n    CharacterReferenceType[\"DEC\"] = \"decimal\";\n  })(CharacterReferenceType || (CharacterReferenceType = {}));\n\n  var _ControlFlowError =\n  /** @class */\n  function () {\n    function _ControlFlowError(error) {\n      this.error = error;\n    }\n\n    return _ControlFlowError;\n  }(); // See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\n\n\n  var _Tokenizer =\n  /** @class */\n  function () {\n    /**\n     * @param _file The html source file being tokenized.\n     * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n     * @param options Configuration of the tokenization.\n     */\n    function _Tokenizer(_file, _getTagDefinition, options) {\n      this._getTagDefinition = _getTagDefinition;\n      this._currentTokenStart = null;\n      this._currentTokenType = null;\n      this._expansionCaseStack = [];\n      this._inInterpolation = false;\n      this.tokens = [];\n      this.errors = [];\n      this.nonNormalizedIcuExpressions = [];\n      this._tokenizeIcu = options.tokenizeExpansionForms || false;\n      this._interpolationConfig = options.interpolationConfig || interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG;\n      this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map(function (c) {\n        return c.codePointAt(0) || 0;\n      });\n      var range = options.range || {\n        endPos: _file.content.length,\n        startPos: 0,\n        startLine: 0,\n        startCol: 0\n      };\n      this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);\n      this._preserveLineEndings = options.preserveLineEndings || false;\n      this._escapedString = options.escapedString || false;\n      this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n\n      try {\n        this._cursor.init();\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n\n    _Tokenizer.prototype._processCarriageReturns = function (content) {\n      if (this._preserveLineEndings) {\n        return content;\n      } // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n      // In order to keep the original position in the source, we can not\n      // pre-process it.\n      // Instead CRs are processed right before instantiating the tokens.\n\n\n      return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    };\n\n    _Tokenizer.prototype.tokenize = function () {\n      while (this._cursor.peek() !== chars.$EOF) {\n        var start = this._cursor.clone();\n\n        try {\n          if (this._attemptCharCode(chars.$LT)) {\n            if (this._attemptCharCode(chars.$BANG)) {\n              if (this._attemptCharCode(chars.$LBRACKET)) {\n                this._consumeCdata(start);\n              } else if (this._attemptCharCode(chars.$MINUS)) {\n                this._consumeComment(start);\n              } else {\n                this._consumeDocType(start);\n              }\n            } else if (this._attemptCharCode(chars.$SLASH)) {\n              this._consumeTagClose(start);\n            } else {\n              this._consumeTagOpen(start);\n            }\n          } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n            this._consumeText();\n          }\n        } catch (e) {\n          this.handleError(e);\n        }\n      }\n\n      this._beginToken(TokenType.EOF);\n\n      this._endToken([]);\n    };\n    /**\n     * @returns whether an ICU token has been created\n     * @internal\n     */\n\n\n    _Tokenizer.prototype._tokenizeExpansionForm = function () {\n      if (this.isExpansionFormStart()) {\n        this._consumeExpansionFormStart();\n\n        return true;\n      }\n\n      if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n        this._consumeExpansionCaseStart();\n\n        return true;\n      }\n\n      if (this._cursor.peek() === chars.$RBRACE) {\n        if (this._isInExpansionCase()) {\n          this._consumeExpansionCaseEnd();\n\n          return true;\n        }\n\n        if (this._isInExpansionForm()) {\n          this._consumeExpansionFormEnd();\n\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    _Tokenizer.prototype._beginToken = function (type, start) {\n      if (start === void 0) {\n        start = this._cursor.clone();\n      }\n\n      this._currentTokenStart = start;\n      this._currentTokenType = type;\n    };\n\n    _Tokenizer.prototype._endToken = function (parts, end) {\n      if (this._currentTokenStart === null) {\n        throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\n      }\n\n      if (this._currentTokenType === null) {\n        throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\n      }\n\n      var token = new Token(this._currentTokenType, parts, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));\n      this.tokens.push(token);\n      this._currentTokenStart = null;\n      this._currentTokenType = null;\n      return token;\n    };\n\n    _Tokenizer.prototype._createError = function (msg, span) {\n      if (this._isInExpansionForm()) {\n        msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n      }\n\n      var error = new TokenError(msg, this._currentTokenType, span);\n      this._currentTokenStart = null;\n      this._currentTokenType = null;\n      return new _ControlFlowError(error);\n    };\n\n    _Tokenizer.prototype.handleError = function (e) {\n      if (e instanceof CursorError) {\n        e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n      }\n\n      if (e instanceof _ControlFlowError) {\n        this.errors.push(e.error);\n      } else {\n        throw e;\n      }\n    };\n\n    _Tokenizer.prototype._attemptCharCode = function (charCode) {\n      if (this._cursor.peek() === charCode) {\n        this._cursor.advance();\n\n        return true;\n      }\n\n      return false;\n    };\n\n    _Tokenizer.prototype._attemptCharCodeCaseInsensitive = function (charCode) {\n      if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n        this._cursor.advance();\n\n        return true;\n      }\n\n      return false;\n    };\n\n    _Tokenizer.prototype._requireCharCode = function (charCode) {\n      var location = this._cursor.clone();\n\n      if (!this._attemptCharCode(charCode)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n      }\n    };\n\n    _Tokenizer.prototype._attemptStr = function (chars) {\n      var len = chars.length;\n\n      if (this._cursor.charsLeft() < len) {\n        return false;\n      }\n\n      var initialPosition = this._cursor.clone();\n\n      for (var i = 0; i < len; i++) {\n        if (!this._attemptCharCode(chars.charCodeAt(i))) {\n          // If attempting to parse the string fails, we want to reset the parser\n          // to where it was before the attempt\n          this._cursor = initialPosition;\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    _Tokenizer.prototype._attemptStrCaseInsensitive = function (chars) {\n      for (var i = 0; i < chars.length; i++) {\n        if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    _Tokenizer.prototype._requireStr = function (chars) {\n      var location = this._cursor.clone();\n\n      if (!this._attemptStr(chars)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n      }\n    };\n\n    _Tokenizer.prototype._attemptCharCodeUntilFn = function (predicate) {\n      while (!predicate(this._cursor.peek())) {\n        this._cursor.advance();\n      }\n    };\n\n    _Tokenizer.prototype._requireCharCodeUntilFn = function (predicate, len) {\n      var start = this._cursor.clone();\n\n      this._attemptCharCodeUntilFn(predicate);\n\n      if (this._cursor.diff(start) < len) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n      }\n    };\n\n    _Tokenizer.prototype._attemptUntilChar = function (char) {\n      while (this._cursor.peek() !== char) {\n        this._cursor.advance();\n      }\n    };\n\n    _Tokenizer.prototype._readChar = function (decodeEntities) {\n      if (decodeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n        return this._decodeEntity();\n      } else {\n        // Don't rely upon reading directly from `_input` as the actual char value\n        // may have been generated from an escape sequence.\n        var char = String.fromCodePoint(this._cursor.peek());\n\n        this._cursor.advance();\n\n        return char;\n      }\n    };\n\n    _Tokenizer.prototype._decodeEntity = function () {\n      var start = this._cursor.clone();\n\n      this._cursor.advance();\n\n      if (this._attemptCharCode(chars.$HASH)) {\n        var isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n\n        var codeStart = this._cursor.clone();\n\n        this._attemptCharCodeUntilFn(isDigitEntityEnd);\n\n        if (this._cursor.peek() != chars.$SEMICOLON) {\n          // Advance cursor to include the peeked character in the string provided to the error\n          // message.\n          this._cursor.advance();\n\n          var entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n          throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\n        }\n\n        var strNum = this._cursor.getChars(codeStart);\n\n        this._cursor.advance();\n\n        try {\n          var charCode = parseInt(strNum, isHex ? 16 : 10);\n          return String.fromCharCode(charCode);\n        } catch (_a) {\n          throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n        }\n      } else {\n        var nameStart = this._cursor.clone();\n\n        this._attemptCharCodeUntilFn(isNamedEntityEnd);\n\n        if (this._cursor.peek() != chars.$SEMICOLON) {\n          this._cursor = nameStart;\n          return '&';\n        }\n\n        var name_1 = this._cursor.getChars(nameStart);\n\n        this._cursor.advance();\n\n        var char = tags_1.NAMED_ENTITIES[name_1];\n\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name_1), this._cursor.getSpan(start));\n        }\n\n        return char;\n      }\n    };\n\n    _Tokenizer.prototype._consumeRawText = function (decodeEntities, endMarkerPredicate) {\n      this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n\n      var parts = [];\n\n      while (true) {\n        var tagCloseStart = this._cursor.clone();\n\n        var foundEndMarker = endMarkerPredicate();\n        this._cursor = tagCloseStart;\n\n        if (foundEndMarker) {\n          break;\n        }\n\n        parts.push(this._readChar(decodeEntities));\n      }\n\n      return this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n\n    _Tokenizer.prototype._consumeComment = function (start) {\n      var _this = this;\n\n      this._beginToken(TokenType.COMMENT_START, start);\n\n      this._requireCharCode(chars.$MINUS);\n\n      this._endToken([]);\n\n      this._consumeRawText(false, function () {\n        return _this._attemptStr('-->');\n      });\n\n      this._beginToken(TokenType.COMMENT_END);\n\n      this._requireStr('-->');\n\n      this._endToken([]);\n    };\n\n    _Tokenizer.prototype._consumeCdata = function (start) {\n      var _this = this;\n\n      this._beginToken(TokenType.CDATA_START, start);\n\n      this._requireStr('CDATA[');\n\n      this._endToken([]);\n\n      this._consumeRawText(false, function () {\n        return _this._attemptStr(']]>');\n      });\n\n      this._beginToken(TokenType.CDATA_END);\n\n      this._requireStr(']]>');\n\n      this._endToken([]);\n    };\n\n    _Tokenizer.prototype._consumeDocType = function (start) {\n      this._beginToken(TokenType.DOC_TYPE, start);\n\n      var contentStart = this._cursor.clone();\n\n      this._attemptUntilChar(chars.$GT);\n\n      var content = this._cursor.getChars(contentStart);\n\n      this._cursor.advance();\n\n      this._endToken([content]);\n    };\n\n    _Tokenizer.prototype._consumePrefixAndName = function () {\n      var nameOrPrefixStart = this._cursor.clone();\n\n      var prefix = '';\n\n      while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {\n        this._cursor.advance();\n      }\n\n      var nameStart;\n\n      if (this._cursor.peek() === chars.$COLON) {\n        prefix = this._cursor.getChars(nameOrPrefixStart);\n\n        this._cursor.advance();\n\n        nameStart = this._cursor.clone();\n      } else {\n        nameStart = nameOrPrefixStart;\n      }\n\n      this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n\n      var name = this._cursor.getChars(nameStart);\n\n      return [prefix, name];\n    };\n\n    _Tokenizer.prototype._consumeTagOpen = function (start) {\n      var tagName;\n      var prefix;\n      var openTagToken;\n\n      try {\n        if (!chars.isAsciiLetter(this._cursor.peek())) {\n          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n\n        openTagToken = this._consumeTagOpenStart(start);\n        prefix = openTagToken.parts[0];\n        tagName = openTagToken.parts[1];\n\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n\n        while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT && this._cursor.peek() !== chars.$LT && this._cursor.peek() !== chars.$EOF) {\n          this._consumeAttributeName();\n\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n\n          if (this._attemptCharCode(chars.$EQ)) {\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n\n            this._consumeAttributeValue();\n          }\n\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n        }\n\n        this._consumeTagOpenEnd();\n      } catch (e) {\n        if (e instanceof _ControlFlowError) {\n          if (openTagToken) {\n            // We errored before we could close the opening tag, so it is incomplete.\n            openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;\n          } else {\n            // When the start tag is invalid, assume we want a \"<\" as text.\n            // Back to back text tokens are merged at the end.\n            this._beginToken(TokenType.TEXT, start);\n\n            this._endToken(['<']);\n          }\n\n          return;\n        }\n\n        throw e;\n      }\n\n      var contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n\n      if (contentTokenType === tags_1.TagContentType.RAW_TEXT) {\n        this._consumeRawTextWithTagClose(prefix, tagName, false);\n      } else if (contentTokenType === tags_1.TagContentType.ESCAPABLE_RAW_TEXT) {\n        this._consumeRawTextWithTagClose(prefix, tagName, true);\n      }\n    };\n\n    _Tokenizer.prototype._consumeRawTextWithTagClose = function (prefix, tagName, decodeEntities) {\n      var _this = this;\n\n      this._consumeRawText(decodeEntities, function () {\n        if (!_this._attemptCharCode(chars.$LT)) return false;\n        if (!_this._attemptCharCode(chars.$SLASH)) return false;\n\n        _this._attemptCharCodeUntilFn(isNotWhitespace);\n\n        if (!_this._attemptStrCaseInsensitive(tagName)) return false;\n\n        _this._attemptCharCodeUntilFn(isNotWhitespace);\n\n        return _this._attemptCharCode(chars.$GT);\n      });\n\n      this._beginToken(TokenType.TAG_CLOSE);\n\n      this._requireCharCodeUntilFn(function (code) {\n        return code === chars.$GT;\n      }, 3);\n\n      this._cursor.advance(); // Consume the `>`\n\n\n      this._endToken([prefix, tagName]);\n    };\n\n    _Tokenizer.prototype._consumeTagOpenStart = function (start) {\n      this._beginToken(TokenType.TAG_OPEN_START, start);\n\n      var parts = this._consumePrefixAndName();\n\n      return this._endToken(parts);\n    };\n\n    _Tokenizer.prototype._consumeAttributeName = function () {\n      var attrNameStart = this._cursor.peek();\n\n      if (attrNameStart === chars.$SQ || attrNameStart === chars.$DQ) {\n        throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n      }\n\n      this._beginToken(TokenType.ATTR_NAME);\n\n      var prefixAndName = this._consumePrefixAndName();\n\n      this._endToken(prefixAndName);\n    };\n\n    _Tokenizer.prototype._consumeAttributeValue = function () {\n      var value;\n\n      if (this._cursor.peek() === chars.$SQ || this._cursor.peek() === chars.$DQ) {\n        this._beginToken(TokenType.ATTR_QUOTE);\n\n        var quoteChar = this._cursor.peek();\n\n        this._cursor.advance();\n\n        this._endToken([String.fromCodePoint(quoteChar)]);\n\n        this._beginToken(TokenType.ATTR_VALUE);\n\n        var parts = [];\n\n        while (this._cursor.peek() !== quoteChar) {\n          parts.push(this._readChar(true));\n        }\n\n        value = parts.join('');\n\n        this._endToken([this._processCarriageReturns(value)]);\n\n        this._beginToken(TokenType.ATTR_QUOTE);\n\n        this._cursor.advance();\n\n        this._endToken([String.fromCodePoint(quoteChar)]);\n      } else {\n        this._beginToken(TokenType.ATTR_VALUE);\n\n        var valueStart = this._cursor.clone();\n\n        this._requireCharCodeUntilFn(isNameEnd, 1);\n\n        value = this._cursor.getChars(valueStart);\n\n        this._endToken([this._processCarriageReturns(value)]);\n      }\n    };\n\n    _Tokenizer.prototype._consumeTagOpenEnd = function () {\n      var tokenType = this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n\n      this._beginToken(tokenType);\n\n      this._requireCharCode(chars.$GT);\n\n      this._endToken([]);\n    };\n\n    _Tokenizer.prototype._consumeTagClose = function (start) {\n      this._beginToken(TokenType.TAG_CLOSE, start);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      var prefixAndName = this._consumePrefixAndName();\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._requireCharCode(chars.$GT);\n\n      this._endToken(prefixAndName);\n    };\n\n    _Tokenizer.prototype._consumeExpansionFormStart = function () {\n      this._beginToken(TokenType.EXPANSION_FORM_START);\n\n      this._requireCharCode(chars.$LBRACE);\n\n      this._endToken([]);\n\n      this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n      this._beginToken(TokenType.RAW_TEXT);\n\n      var condition = this._readUntil(chars.$COMMA);\n\n      var normalizedCondition = this._processCarriageReturns(condition);\n\n      if (this._i18nNormalizeLineEndingsInICUs) {\n        // We explicitly want to normalize line endings for this text.\n        this._endToken([normalizedCondition]);\n      } else {\n        // We are not normalizing line endings.\n        var conditionToken = this._endToken([condition]);\n\n        if (normalizedCondition !== condition) {\n          this.nonNormalizedIcuExpressions.push(conditionToken);\n        }\n      }\n\n      this._requireCharCode(chars.$COMMA);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._beginToken(TokenType.RAW_TEXT);\n\n      var type = this._readUntil(chars.$COMMA);\n\n      this._endToken([type]);\n\n      this._requireCharCode(chars.$COMMA);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n    };\n\n    _Tokenizer.prototype._consumeExpansionCaseStart = function () {\n      this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n\n      var value = this._readUntil(chars.$LBRACE).trim();\n\n      this._endToken([value]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n\n      this._requireCharCode(chars.$LBRACE);\n\n      this._endToken([]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n    };\n\n    _Tokenizer.prototype._consumeExpansionCaseEnd = function () {\n      this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n\n      this._requireCharCode(chars.$RBRACE);\n\n      this._endToken([]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._expansionCaseStack.pop();\n    };\n\n    _Tokenizer.prototype._consumeExpansionFormEnd = function () {\n      this._beginToken(TokenType.EXPANSION_FORM_END);\n\n      this._requireCharCode(chars.$RBRACE);\n\n      this._endToken([]);\n\n      this._expansionCaseStack.pop();\n    };\n\n    _Tokenizer.prototype._consumeText = function () {\n      var start = this._cursor.clone();\n\n      this._beginToken(TokenType.TEXT, start);\n\n      var parts = [];\n\n      do {\n        if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n          parts.push(this._interpolationConfig.start);\n          this._inInterpolation = true;\n        } else if (this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end)) {\n          parts.push(this._interpolationConfig.end);\n          this._inInterpolation = false;\n        } else {\n          parts.push(this._readChar(true));\n        }\n      } while (!this._isTextEnd());\n\n      this._endToken([this._processCarriageReturns(parts.join(''))]);\n    };\n\n    _Tokenizer.prototype._isTextEnd = function () {\n      if (this._cursor.peek() === chars.$LT || this._cursor.peek() === chars.$EOF) {\n        return true;\n      }\n\n      if (this._tokenizeIcu && !this._inInterpolation) {\n        if (this.isExpansionFormStart()) {\n          // start of an expansion form\n          return true;\n        }\n\n        if (this._cursor.peek() === chars.$RBRACE && this._isInExpansionCase()) {\n          // end of and expansion case\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    _Tokenizer.prototype._readUntil = function (char) {\n      var start = this._cursor.clone();\n\n      this._attemptUntilChar(char);\n\n      return this._cursor.getChars(start);\n    };\n\n    _Tokenizer.prototype._isInExpansionCase = function () {\n      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_CASE_EXP_START;\n    };\n\n    _Tokenizer.prototype._isInExpansionForm = function () {\n      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_FORM_START;\n    };\n\n    _Tokenizer.prototype.isExpansionFormStart = function () {\n      if (this._cursor.peek() !== chars.$LBRACE) {\n        return false;\n      }\n\n      if (this._interpolationConfig) {\n        var start = this._cursor.clone();\n\n        var isInterpolation = this._attemptStr(this._interpolationConfig.start);\n\n        this._cursor = start;\n        return !isInterpolation;\n      }\n\n      return true;\n    };\n\n    return _Tokenizer;\n  }();\n\n  function isNotWhitespace(code) {\n    return !chars.isWhitespace(code) || code === chars.$EOF;\n  }\n\n  function isNameEnd(code) {\n    return chars.isWhitespace(code) || code === chars.$GT || code === chars.$LT || code === chars.$SLASH || code === chars.$SQ || code === chars.$DQ || code === chars.$EQ || code === chars.$EOF;\n  }\n\n  function isPrefixEnd(code) {\n    return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) && (code < chars.$0 || code > chars.$9);\n  }\n\n  function isDigitEntityEnd(code) {\n    return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiHexDigit(code);\n  }\n\n  function isNamedEntityEnd(code) {\n    return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiLetter(code);\n  }\n\n  function isExpansionCaseStart(peek) {\n    return peek !== chars.$RBRACE;\n  }\n\n  function compareCharCodeCaseInsensitive(code1, code2) {\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n  }\n\n  function toUpperCaseCharCode(code) {\n    return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n  }\n\n  function mergeTextTokens(srcTokens) {\n    var dstTokens = [];\n    var lastDstToken = undefined;\n\n    for (var i = 0; i < srcTokens.length; i++) {\n      var token = srcTokens[i];\n\n      if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n        lastDstToken.parts[0] += token.parts[0];\n        lastDstToken.sourceSpan.end = token.sourceSpan.end;\n      } else {\n        lastDstToken = token;\n        dstTokens.push(lastDstToken);\n      }\n    }\n\n    return dstTokens;\n  }\n\n  var PlainCharacterCursor =\n  /** @class */\n  function () {\n    function PlainCharacterCursor(fileOrCursor, range) {\n      if (fileOrCursor instanceof PlainCharacterCursor) {\n        this.file = fileOrCursor.file;\n        this.input = fileOrCursor.input;\n        this.end = fileOrCursor.end;\n        var state = fileOrCursor.state; // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n        // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n        // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n        // called in tight loops, this difference matters.\n\n        this.state = {\n          peek: state.peek,\n          offset: state.offset,\n          line: state.line,\n          column: state.column\n        };\n      } else {\n        if (!range) {\n          throw new Error('Programming error: the range argument must be provided with a file argument.');\n        }\n\n        this.file = fileOrCursor;\n        this.input = fileOrCursor.content;\n        this.end = range.endPos;\n        this.state = {\n          peek: -1,\n          offset: range.startPos,\n          line: range.startLine,\n          column: range.startCol\n        };\n      }\n    }\n\n    PlainCharacterCursor.prototype.clone = function () {\n      return new PlainCharacterCursor(this);\n    };\n\n    PlainCharacterCursor.prototype.peek = function () {\n      return this.state.peek;\n    };\n\n    PlainCharacterCursor.prototype.charsLeft = function () {\n      return this.end - this.state.offset;\n    };\n\n    PlainCharacterCursor.prototype.diff = function (other) {\n      return this.state.offset - other.state.offset;\n    };\n\n    PlainCharacterCursor.prototype.advance = function () {\n      this.advanceState(this.state);\n    };\n\n    PlainCharacterCursor.prototype.init = function () {\n      this.updatePeek(this.state);\n    };\n\n    PlainCharacterCursor.prototype.getSpan = function (start, leadingTriviaCodePoints) {\n      start = start || this;\n      var fullStart = start;\n\n      if (leadingTriviaCodePoints) {\n        while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n          if (fullStart === start) {\n            start = start.clone();\n          }\n\n          start.advance();\n        }\n      }\n\n      var startLocation = this.locationFromCursor(start);\n      var endLocation = this.locationFromCursor(this);\n      var fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n      return new parse_util_1.ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n    };\n\n    PlainCharacterCursor.prototype.getChars = function (start) {\n      return this.input.substring(start.state.offset, this.state.offset);\n    };\n\n    PlainCharacterCursor.prototype.charAt = function (pos) {\n      return this.input.charCodeAt(pos);\n    };\n\n    PlainCharacterCursor.prototype.advanceState = function (state) {\n      if (state.offset >= this.end) {\n        this.state = state;\n        throw new CursorError('Unexpected character \"EOF\"', this);\n      }\n\n      var currentChar = this.charAt(state.offset);\n\n      if (currentChar === chars.$LF) {\n        state.line++;\n        state.column = 0;\n      } else if (!chars.isNewLine(currentChar)) {\n        state.column++;\n      }\n\n      state.offset++;\n      this.updatePeek(state);\n    };\n\n    PlainCharacterCursor.prototype.updatePeek = function (state) {\n      state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);\n    };\n\n    PlainCharacterCursor.prototype.locationFromCursor = function (cursor) {\n      return new parse_util_1.ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n    };\n\n    return PlainCharacterCursor;\n  }();\n\n  var EscapedCharacterCursor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(EscapedCharacterCursor, _super);\n\n    function EscapedCharacterCursor(fileOrCursor, range) {\n      var _this = this;\n\n      if (fileOrCursor instanceof EscapedCharacterCursor) {\n        _this = _super.call(this, fileOrCursor) || this;\n        _this.internalState = tslib_1.__assign({}, fileOrCursor.internalState);\n      } else {\n        _this = _super.call(this, fileOrCursor, range) || this;\n        _this.internalState = _this.state;\n      }\n\n      return _this;\n    }\n\n    EscapedCharacterCursor.prototype.advance = function () {\n      this.state = this.internalState;\n\n      _super.prototype.advance.call(this);\n\n      this.processEscapeSequence();\n    };\n\n    EscapedCharacterCursor.prototype.init = function () {\n      _super.prototype.init.call(this);\n\n      this.processEscapeSequence();\n    };\n\n    EscapedCharacterCursor.prototype.clone = function () {\n      return new EscapedCharacterCursor(this);\n    };\n\n    EscapedCharacterCursor.prototype.getChars = function (start) {\n      var cursor = start.clone();\n      var chars = '';\n\n      while (cursor.internalState.offset < this.internalState.offset) {\n        chars += String.fromCodePoint(cursor.peek());\n        cursor.advance();\n      }\n\n      return chars;\n    };\n    /**\n     * Process the escape sequence that starts at the current position in the text.\n     *\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n     */\n\n\n    EscapedCharacterCursor.prototype.processEscapeSequence = function () {\n      var _this = this;\n\n      var peek = function peek() {\n        return _this.internalState.peek;\n      };\n\n      if (peek() === chars.$BACKSLASH) {\n        // We have hit an escape sequence so we need the internal state to become independent\n        // of the external state.\n        this.internalState = tslib_1.__assign({}, this.state); // Move past the backslash\n\n        this.advanceState(this.internalState); // First check for standard control char sequences\n\n        if (peek() === chars.$n) {\n          this.state.peek = chars.$LF;\n        } else if (peek() === chars.$r) {\n          this.state.peek = chars.$CR;\n        } else if (peek() === chars.$v) {\n          this.state.peek = chars.$VTAB;\n        } else if (peek() === chars.$t) {\n          this.state.peek = chars.$TAB;\n        } else if (peek() === chars.$b) {\n          this.state.peek = chars.$BSPACE;\n        } else if (peek() === chars.$f) {\n          this.state.peek = chars.$FF;\n        } // Now consider more complex sequences\n        else if (peek() === chars.$u) {\n            // Unicode code-point sequence\n            this.advanceState(this.internalState); // advance past the `u` char\n\n            if (peek() === chars.$LBRACE) {\n              // Variable length Unicode, e.g. `\\x{123}`\n              this.advanceState(this.internalState); // advance past the `{` char\n              // Advance past the variable number of hex digits until we hit a `}` char\n\n              var digitStart = this.clone();\n              var length_1 = 0;\n\n              while (peek() !== chars.$RBRACE) {\n                this.advanceState(this.internalState);\n                length_1++;\n              }\n\n              this.state.peek = this.decodeHexDigits(digitStart, length_1);\n            } else {\n              // Fixed length Unicode, e.g. `\\u1234`\n              var digitStart = this.clone();\n              this.advanceState(this.internalState);\n              this.advanceState(this.internalState);\n              this.advanceState(this.internalState);\n              this.state.peek = this.decodeHexDigits(digitStart, 4);\n            }\n          } else if (peek() === chars.$x) {\n            // Hex char code, e.g. `\\x2F`\n            this.advanceState(this.internalState); // advance past the `x` char\n\n            var digitStart = this.clone();\n            this.advanceState(this.internalState);\n            this.state.peek = this.decodeHexDigits(digitStart, 2);\n          } else if (chars.isOctalDigit(peek())) {\n            // Octal char code, e.g. `\\012`,\n            var octal = '';\n            var length_2 = 0;\n            var previous = this.clone();\n\n            while (chars.isOctalDigit(peek()) && length_2 < 3) {\n              previous = this.clone();\n              octal += String.fromCodePoint(peek());\n              this.advanceState(this.internalState);\n              length_2++;\n            }\n\n            this.state.peek = parseInt(octal, 8); // Backup one char\n\n            this.internalState = previous.internalState;\n          } else if (chars.isNewLine(this.internalState.peek)) {\n            // Line continuation `\\` followed by a new line\n            this.advanceState(this.internalState); // advance over the newline\n\n            this.state = this.internalState;\n          } else {\n            // If none of the `if` blocks were executed then we just have an escaped normal character.\n            // In that case we just, effectively, skip the backslash from the character.\n            this.state.peek = this.internalState.peek;\n          }\n      }\n    };\n\n    EscapedCharacterCursor.prototype.decodeHexDigits = function (start, length) {\n      var hex = this.input.substr(start.internalState.offset, length);\n      var charCode = parseInt(hex, 16);\n\n      if (!isNaN(charCode)) {\n        return charCode;\n      } else {\n        start.state = start.internalState;\n        throw new CursorError('Invalid hexadecimal escape sequence', start);\n      }\n    };\n\n    return EscapedCharacterCursor;\n  }(PlainCharacterCursor);\n\n  var CursorError =\n  /** @class */\n  function () {\n    function CursorError(msg, cursor) {\n      this.msg = msg;\n      this.cursor = cursor;\n    }\n\n    return CursorError;\n  }();\n\n  exports.CursorError = CursorError;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/ml_parser/lexer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation_config';\nimport {NAMED_ENTITIES, TagContentType, TagDefinition} from './tags';\n\nexport enum TokenType {\n  TAG_OPEN_START,\n  TAG_OPEN_END,\n  TAG_OPEN_END_VOID,\n  TAG_CLOSE,\n  INCOMPLETE_TAG_OPEN,\n  TEXT,\n  ESCAPABLE_RAW_TEXT,\n  RAW_TEXT,\n  COMMENT_START,\n  COMMENT_END,\n  CDATA_START,\n  CDATA_END,\n  ATTR_NAME,\n  ATTR_QUOTE,\n  ATTR_VALUE,\n  DOC_TYPE,\n  EXPANSION_FORM_START,\n  EXPANSION_CASE_VALUE,\n  EXPANSION_CASE_EXP_START,\n  EXPANSION_CASE_EXP_END,\n  EXPANSION_FORM_END,\n  EOF\n}\n\nexport class Token {\n  constructor(\n      public type: TokenType|null, public parts: string[], public sourceSpan: ParseSourceSpan) {}\n}\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType|null, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(\n      public tokens: Token[], public errors: TokenError[],\n      public nonNormalizedIcuExpressions: Token[]) {}\n}\n\nexport interface LexerRange {\n  startPos: number;\n  startLine: number;\n  startCol: number;\n  endPos: number;\n}\n\n/**\n * Options that modify how the text is tokenized.\n */\nexport interface TokenizeOptions {\n  /** Whether to tokenize ICU messages (considered as text nodes when false). */\n  tokenizeExpansionForms?: boolean;\n  /** How to tokenize interpolation markers. */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * If this text is stored in an external template (e.g. via `templateUrl`) then we need to decide\n   * whether or not to normalize the line-endings (from `\\r\\n` to `\\n`) when processing ICU\n   * expressions.\n   *\n   * If `true` then we will normalize ICU expression line endings.\n   * The default is `false`, but this will be switched in a future major release.\n   */\n  i18nNormalizeLineEndingsInICUs?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n  /**\n   * If true, do not convert CRLF to LF.\n   */\n  preserveLineEndings?: boolean;\n}\n\nexport function tokenize(\n    source: string, url: string, getTagDefinition: (tagName: string) => TagDefinition,\n    options: TokenizeOptions = {}): TokenizeResult {\n  const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(\n      mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nfunction _unparsableEntityErrorMsg(type: CharacterReferenceType, entityStr: string): string {\n  return `Unable to parse entity \"${entityStr}\" - ${\n      type} character reference entities must end with \";\"`;\n}\n\nenum CharacterReferenceType {\n  HEX = 'hexadecimal',\n  DEC = 'decimal',\n}\n\nclass _ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\nclass _Tokenizer {\n  private _cursor: CharacterCursor;\n  private _tokenizeIcu: boolean;\n  private _interpolationConfig: InterpolationConfig;\n  private _leadingTriviaCodePoints: number[]|undefined;\n  private _currentTokenStart: CharacterCursor|null = null;\n  private _currentTokenType: TokenType|null = null;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation: boolean = false;\n  private readonly _preserveLineEndings: boolean;\n  private readonly _escapedString: boolean;\n  private readonly _i18nNormalizeLineEndingsInICUs: boolean;\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n  nonNormalizedIcuExpressions: Token[] = [];\n\n  /**\n   * @param _file The html source file being tokenized.\n   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n   * @param options Configuration of the tokenization.\n   */\n  constructor(\n      _file: ParseSourceFile, private _getTagDefinition: (tagName: string) => TagDefinition,\n      options: TokenizeOptions) {\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    this._leadingTriviaCodePoints =\n        options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n    const range =\n        options.range || {endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0};\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n                                           new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._escapedString = options.escapedString || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n\n  private _processCarriageReturns(content: string): string {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n\n  tokenize(): void {\n    while (this._cursor.peek() !== chars.$EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeText();\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._cursor.peek() === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _beginToken(type: TokenType, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end?: CharacterCursor): Token {\n    if (this._currentTokenStart === null) {\n      throw new TokenError(\n          'Programming error - attempted to end a token when there was no start to the token',\n          this._currentTokenType, this._cursor.getSpan(end));\n    }\n    if (this._currentTokenType === null) {\n      throw new TokenError(\n          'Programming error - attempted to end a token which has no token type', null,\n          this._cursor.getSpan(this._currentTokenStart));\n    }\n    const token = new Token(\n        this._currentTokenType, parts,\n        this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): _ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return new _ControlFlowError(error);\n  }\n\n  private handleError(e: any) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof _ControlFlowError) {\n      this.errors.push(e.error);\n    } else {\n      throw e;\n    }\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n\n  private _readChar(decodeEntities: boolean): string {\n    if (decodeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n      return this._decodeEntity();\n    } else {\n      // Don't rely upon reading directly from `_input` as the actual char value\n      // may have been generated from an escape sequence.\n      const char = String.fromCodePoint(this._cursor.peek());\n      this._cursor.advance();\n      return char;\n    }\n  }\n\n  private _decodeEntity(): string {\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        // Advance cursor to include the peeked character in the string provided to the error\n        // message.\n        this._cursor.advance();\n        const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n        throw this._createError(\n            _unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)),\n            this._cursor.getSpan());\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        return String.fromCharCode(charCode);\n      } catch {\n        throw this._createError(\n            _unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        this._cursor = nameStart;\n        return '&';\n      }\n      const name = this._cursor.getChars(nameStart);\n      this._cursor.advance();\n      const char = NAMED_ENTITIES[name];\n      if (!char) {\n        throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n      }\n      return char;\n    }\n  }\n\n  private _consumeRawText(decodeEntities: boolean, endMarkerPredicate: () => boolean): Token {\n    this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n    const parts: string[] = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      parts.push(this._readChar(decodeEntities));\n    }\n    return this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _consumeComment(start: CharacterCursor) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(TokenType.COMMENT_END);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: CharacterCursor) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(TokenType.CDATA_END);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: CharacterCursor) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar(chars.$GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix: string = '';\n    while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart: CharacterCursor;\n    if (this._cursor.peek() === chars.$COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: CharacterCursor) {\n    let tagName: string;\n    let prefix: string;\n    let openTagToken: Token|undefined;\n    try {\n      if (!chars.isAsciiLetter(this._cursor.peek())) {\n        throw this._createError(\n            _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n      }\n\n      openTagToken = this._consumeTagOpenStart(start);\n      prefix = openTagToken.parts[0];\n      tagName = openTagToken.parts[1];\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT &&\n             this._cursor.peek() !== chars.$LT && this._cursor.peek() !== chars.$EOF) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof _ControlFlowError) {\n        if (openTagToken) {\n          // We errored before we could close the opening tag, so it is incomplete.\n          openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;\n        } else {\n          // When the start tag is invalid, assume we want a \"<\" as text.\n          // Back to back text tokens are merged at the end.\n          this._beginToken(TokenType.TEXT, start);\n          this._endToken(['<']);\n        }\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(prefix, tagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(prefix, tagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(prefix: string, tagName: string, decodeEntities: boolean) {\n    this._consumeRawText(decodeEntities, () => {\n      if (!this._attemptCharCode(chars.$LT)) return false;\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE);\n    this._requireCharCodeUntilFn(code => code === chars.$GT, 3);\n    this._cursor.advance();  // Consume the `>`\n    this._endToken([prefix, tagName]);\n  }\n\n  private _consumeTagOpenStart(start: CharacterCursor) {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    return this._endToken(parts);\n  }\n\n  private _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === chars.$SQ || attrNameStart === chars.$DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    let value: string;\n    if (this._cursor.peek() === chars.$SQ || this._cursor.peek() === chars.$DQ) {\n      this._beginToken(TokenType.ATTR_QUOTE);\n      const quoteChar = this._cursor.peek();\n      this._cursor.advance();\n      this._endToken([String.fromCodePoint(quoteChar)]);\n      this._beginToken(TokenType.ATTR_VALUE);\n      const parts: string[] = [];\n      while (this._cursor.peek() !== quoteChar) {\n        parts.push(this._readChar(true));\n      }\n      value = parts.join('');\n      this._endToken([this._processCarriageReturns(value)]);\n      this._beginToken(TokenType.ATTR_QUOTE);\n      this._cursor.advance();\n      this._endToken([String.fromCodePoint(quoteChar)]);\n    } else {\n      this._beginToken(TokenType.ATTR_VALUE);\n      const valueStart = this._cursor.clone();\n      this._requireCharCodeUntilFn(isNameEnd, 1);\n      value = this._cursor.getChars(valueStart);\n      this._endToken([this._processCarriageReturns(value)]);\n    }\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType =\n        this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: CharacterCursor) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const condition = this._readUntil(chars.$COMMA);\n    const normalizedCondition = this._processCarriageReturns(condition);\n    if (this._i18nNormalizeLineEndingsInICUs) {\n      // We explicitly want to normalize line endings for this text.\n      this._endToken([normalizedCondition]);\n    } else {\n      // We are not normalizing line endings.\n      const conditionToken = this._endToken([condition]);\n      if (normalizedCondition !== condition) {\n        this.nonNormalizedIcuExpressions.push(conditionToken);\n      }\n    }\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type]);\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeText() {\n    const start = this._cursor.clone();\n    this._beginToken(TokenType.TEXT, start);\n    const parts: string[] = [];\n\n    do {\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        parts.push(this._interpolationConfig.start);\n        this._inInterpolation = true;\n      } else if (\n          this._interpolationConfig && this._inInterpolation &&\n          this._attemptStr(this._interpolationConfig.end)) {\n        parts.push(this._interpolationConfig.end);\n        this._inInterpolation = false;\n      } else {\n        parts.push(this._readChar(true));\n      }\n    } while (!this._isTextEnd());\n\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._cursor.peek() === chars.$LT || this._cursor.peek() === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._cursor.peek() === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n\n  private _isInExpansionCase(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_CASE_EXP_START;\n  }\n\n  private _isInExpansionForm(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_FORM_START;\n  }\n\n  private isExpansionFormStart(): boolean {\n    if (this._cursor.peek() !== chars.$LBRACE) {\n      return false;\n    }\n    if (this._interpolationConfig) {\n      const start = this._cursor.clone();\n      const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n      this._cursor = start;\n      return !isInterpolation;\n    }\n    return true;\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return chars.isWhitespace(code) || code === chars.$GT || code === chars.$LT ||\n      code === chars.$SLASH || code === chars.$SQ || code === chars.$DQ || code === chars.$EQ ||\n      code === chars.$EOF;\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) &&\n      (code < chars.$0 || code > chars.$9);\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek !== chars.$RBRACE;\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token|undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n      lastDstToken.parts[0]! += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n\n\n/**\n * The _Tokenizer uses objects of this type to move through the input text,\n * extracting \"parsed characters\". These could be more than one actual character\n * if the text contains escape sequences.\n */\ninterface CharacterCursor {\n  /** Initialize the cursor. */\n  init(): void;\n  /** The parsed character at the current cursor position. */\n  peek(): number;\n  /** Advance the cursor by one parsed character. */\n  advance(): void;\n  /** Get a span from the marked start point to the current point. */\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan;\n  /** Get the parsed characters from the marked start point to the current point. */\n  getChars(start: this): string;\n  /** The number of characters left before the end of the cursor. */\n  charsLeft(): number;\n  /** The number of characters between `this` cursor and `other` cursor. */\n  diff(other: this): number;\n  /** Make a copy of this cursor */\n  clone(): CharacterCursor;\n}\n\ninterface CursorState {\n  peek: number;\n  offset: number;\n  line: number;\n  column: number;\n}\n\nclass PlainCharacterCursor implements CharacterCursor {\n  protected state: CursorState;\n  protected file: ParseSourceFile;\n  protected input: string;\n  protected end: number;\n\n  constructor(fileOrCursor: PlainCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile|PlainCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n\n      const state = fileOrCursor.state;\n      // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n      // called in tight loops, this difference matters.\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column,\n      };\n    } else {\n      if (!range) {\n        throw new Error(\n            'Programming error: the range argument must be provided with a file argument.');\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol,\n      };\n    }\n  }\n\n  clone(): PlainCharacterCursor {\n    return new PlainCharacterCursor(this);\n  }\n\n  peek() {\n    return this.state.peek;\n  }\n  charsLeft() {\n    return this.end - this.state.offset;\n  }\n  diff(other: this) {\n    return this.state.offset - other.state.offset;\n  }\n\n  advance(): void {\n    this.advanceState(this.state);\n  }\n\n  init(): void {\n    this.updatePeek(this.state);\n  }\n\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan {\n    start = start || this;\n    let fullStart = start;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (fullStart === start) {\n          start = start.clone() as this;\n        }\n        start.advance();\n      }\n    }\n    const startLocation = this.locationFromCursor(start);\n    const endLocation = this.locationFromCursor(this);\n    const fullStartLocation =\n        fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n    return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n  }\n\n  getChars(start: this): string {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n\n  charAt(pos: number): number {\n    return this.input.charCodeAt(pos);\n  }\n\n  protected advanceState(state: CursorState) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === chars.$LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!chars.isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n\n  protected updatePeek(state: CursorState): void {\n    state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);\n  }\n\n  private locationFromCursor(cursor: this): ParseLocation {\n    return new ParseLocation(\n        cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n  }\n}\n\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  protected internalState: CursorState;\n\n  constructor(fileOrCursor: EscapedCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile|EscapedCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {...fileOrCursor.internalState};\n    } else {\n      super(fileOrCursor, range!);\n      this.internalState = this.state;\n    }\n  }\n\n  advance(): void {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n\n  init(): void {\n    super.init();\n    this.processEscapeSequence();\n  }\n\n  clone(): EscapedCharacterCursor {\n    return new EscapedCharacterCursor(this);\n  }\n\n  getChars(start: this): string {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n\n  /**\n   * Process the escape sequence that starts at the current position in the text.\n   *\n   * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n   */\n  protected processEscapeSequence(): void {\n    const peek = () => this.internalState.peek;\n\n    if (peek() === chars.$BACKSLASH) {\n      // We have hit an escape sequence so we need the internal state to become independent\n      // of the external state.\n      this.internalState = {...this.state};\n\n      // Move past the backslash\n      this.advanceState(this.internalState);\n\n      // First check for standard control char sequences\n      if (peek() === chars.$n) {\n        this.state.peek = chars.$LF;\n      } else if (peek() === chars.$r) {\n        this.state.peek = chars.$CR;\n      } else if (peek() === chars.$v) {\n        this.state.peek = chars.$VTAB;\n      } else if (peek() === chars.$t) {\n        this.state.peek = chars.$TAB;\n      } else if (peek() === chars.$b) {\n        this.state.peek = chars.$BSPACE;\n      } else if (peek() === chars.$f) {\n        this.state.peek = chars.$FF;\n      }\n\n      // Now consider more complex sequences\n      else if (peek() === chars.$u) {\n        // Unicode code-point sequence\n        this.advanceState(this.internalState);  // advance past the `u` char\n        if (peek() === chars.$LBRACE) {\n          // Variable length Unicode, e.g. `\\x{123}`\n          this.advanceState(this.internalState);  // advance past the `{` char\n          // Advance past the variable number of hex digits until we hit a `}` char\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== chars.$RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          // Fixed length Unicode, e.g. `\\u1234`\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      }\n\n      else if (peek() === chars.$x) {\n        // Hex char code, e.g. `\\x2F`\n        this.advanceState(this.internalState);  // advance past the `x` char\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      }\n\n      else if (chars.isOctalDigit(peek())) {\n        // Octal char code, e.g. `\\012`,\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (chars.isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        // Backup one char\n        this.internalState = previous.internalState;\n      }\n\n      else if (chars.isNewLine(this.internalState.peek)) {\n        // Line continuation `\\` followed by a new line\n        this.advanceState(this.internalState);  // advance over the newline\n        this.state = this.internalState;\n      }\n\n      else {\n        // If none of the `if` blocks were executed then we just have an escaped normal character.\n        // In that case we just, effectively, skip the backslash from the character.\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n\n  protected decodeHexDigits(start: EscapedCharacterCursor, length: number): number {\n    const hex = this.input.substr(start.internalState.offset, length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\n\nexport class CursorError {\n  constructor(public msg: string, public cursor: CharacterCursor) {}\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}