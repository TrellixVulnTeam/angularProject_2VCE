{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getWrapEnumsTransformer = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ts = require(\"typescript\");\n\nvar ast_utils_1 = require(\"../helpers/ast-utils\");\n\nfunction isBlockLike(node) {\n  return node.kind === ts.SyntaxKind.Block || node.kind === ts.SyntaxKind.ModuleBlock || node.kind === ts.SyntaxKind.CaseClause || node.kind === ts.SyntaxKind.DefaultClause || node.kind === ts.SyntaxKind.SourceFile;\n}\n\nfunction getWrapEnumsTransformer() {\n  return function (context) {\n    var transformer = function transformer(sf) {\n      var result = visitBlockStatements(sf.statements, context);\n      return ts.updateSourceFileNode(sf, ts.setTextRange(result, sf.statements));\n    };\n\n    return transformer;\n  };\n}\n\nexports.getWrapEnumsTransformer = getWrapEnumsTransformer;\n\nfunction visitBlockStatements(statements, context) {\n  // copy of statements to modify; lazy initialized\n  var updatedStatements;\n\n  var visitor = function visitor(node) {\n    if (isBlockLike(node)) {\n      var result = visitBlockStatements(node.statements, context);\n\n      if (result === node.statements) {\n        return node;\n      }\n\n      result = ts.setTextRange(result, node.statements);\n\n      switch (node.kind) {\n        case ts.SyntaxKind.Block:\n          return ts.updateBlock(node, result);\n\n        case ts.SyntaxKind.ModuleBlock:\n          return ts.updateModuleBlock(node, result);\n\n        case ts.SyntaxKind.CaseClause:\n          return ts.updateCaseClause(node, node.expression, result);\n\n        case ts.SyntaxKind.DefaultClause:\n          return ts.updateDefaultClause(node, result);\n\n        default:\n          return node;\n      }\n    } else {\n      return node;\n    }\n  }; // 'oIndex' is the original statement index; 'uIndex' is the updated statement index\n\n\n  for (var oIndex = 0, uIndex = 0; oIndex < statements.length - 1; oIndex++, uIndex++) {\n    var currentStatement = statements[oIndex];\n    var newStatement = void 0;\n    var oldStatementsLength = 0; // these can't contain an enum declaration\n\n    if (currentStatement.kind === ts.SyntaxKind.ImportDeclaration) {\n      continue;\n    } // enum declarations must:\n    //   * not be last statement\n    //   * be a variable statement\n    //   * have only one declaration\n    //   * have an identifer as a declaration name\n    // ClassExpression declarations must:\n    //   * not be last statement\n    //   * be a variable statement\n    //   * have only one declaration\n    //   * have an ClassExpression or BinaryExpression and a right\n    //     of kind ClassExpression as a initializer\n\n\n    if (ts.isVariableStatement(currentStatement) && currentStatement.declarationList.declarations.length === 1) {\n      var variableDeclaration = currentStatement.declarationList.declarations[0];\n      var initializer = variableDeclaration.initializer;\n\n      if (ts.isIdentifier(variableDeclaration.name)) {\n        var name = variableDeclaration.name.text;\n\n        if (!initializer) {\n          var iife = findEnumIife(name, statements[oIndex + 1]);\n\n          if (iife) {\n            // update IIFE and replace variable statement and old IIFE\n            oldStatementsLength = 2;\n            newStatement = updateEnumIife(currentStatement, iife[0], iife[1]); // skip IIFE statement\n\n            oIndex++;\n          }\n        } else if (ts.isClassExpression(initializer) || ts.isBinaryExpression(initializer) && ts.isClassExpression(initializer.right)) {\n          var classStatements = findStatements(name, statements, oIndex);\n\n          if (!classStatements) {\n            continue;\n          }\n\n          oldStatementsLength = classStatements.length;\n          newStatement = createWrappedClass(variableDeclaration, classStatements);\n          oIndex += classStatements.length - 1;\n        }\n      }\n    } else if (ts.isClassDeclaration(currentStatement)) {\n      var _name = currentStatement.name.text;\n\n      var _classStatements = findStatements(_name, statements, oIndex);\n\n      if (!_classStatements) {\n        continue;\n      }\n\n      oldStatementsLength = _classStatements.length;\n      newStatement = createWrappedClass(currentStatement, _classStatements);\n      oIndex += _classStatements.length - 1;\n    }\n\n    if (newStatement && newStatement.length > 0) {\n      var _updatedStatements;\n\n      if (!updatedStatements) {\n        updatedStatements = _toConsumableArray(statements);\n      }\n\n      (_updatedStatements = updatedStatements).splice.apply(_updatedStatements, [uIndex, oldStatementsLength].concat(_toConsumableArray(newStatement))); // When having more than a single new statement\n      // we need to update the update Index\n\n\n      uIndex += newStatement ? newStatement.length - 1 : 0;\n    }\n\n    var result = ts.visitNode(currentStatement, visitor);\n\n    if (result !== currentStatement) {\n      if (!updatedStatements) {\n        updatedStatements = statements.slice();\n      }\n\n      updatedStatements[uIndex] = result;\n    }\n  } // if changes, return updated statements\n  // otherwise, return original array instance\n\n\n  return updatedStatements ? ts.createNodeArray(updatedStatements) : statements;\n} // TS 2.3 enums have statements that are inside a IIFE.\n\n\nfunction findEnumIife(name, statement) {\n  if (!ts.isExpressionStatement(statement)) {\n    return null;\n  }\n\n  var expression = statement.expression;\n\n  if (!expression || !ts.isCallExpression(expression) || expression.arguments.length !== 1) {\n    return null;\n  }\n\n  var callExpression = expression;\n  var exportExpression;\n\n  if (!ts.isParenthesizedExpression(callExpression.expression)) {\n    return null;\n  }\n\n  var functionExpression = callExpression.expression.expression;\n\n  if (!ts.isFunctionExpression(functionExpression)) {\n    return null;\n  } // The name of the parameter can be different than the name of the enum if it was renamed\n  // due to scope hoisting.\n\n\n  var parameter = functionExpression.parameters[0];\n\n  if (!ts.isIdentifier(parameter.name)) {\n    return null;\n  }\n\n  var parameterName = parameter.name.text;\n  var argument = callExpression.arguments[0];\n\n  if (!ts.isBinaryExpression(argument) || !ts.isIdentifier(argument.left) || argument.left.text !== name) {\n    return null;\n  }\n\n  var potentialExport = false;\n\n  if (argument.operatorToken.kind === ts.SyntaxKind.FirstAssignment) {\n    if (ts.isBinaryExpression(argument.right) && argument.right.operatorToken.kind !== ts.SyntaxKind.BarBarToken) {\n      return null;\n    }\n\n    potentialExport = true;\n    argument = argument.right;\n  }\n\n  if (!ts.isBinaryExpression(argument)) {\n    return null;\n  }\n\n  if (argument.operatorToken.kind !== ts.SyntaxKind.BarBarToken) {\n    return null;\n  }\n\n  if (potentialExport && !ts.isIdentifier(argument.left)) {\n    exportExpression = argument.left;\n  } // Go through all the statements and check that all match the name\n\n\n  var _iterator = _createForOfIteratorHelper(functionExpression.body.statements),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _statement = _step.value;\n\n      if (!ts.isExpressionStatement(_statement) || !ts.isBinaryExpression(_statement.expression) || !ts.isElementAccessExpression(_statement.expression.left)) {\n        return null;\n      }\n\n      var leftExpression = _statement.expression.left.expression;\n\n      if (!ts.isIdentifier(leftExpression) || leftExpression.text !== parameterName) {\n        return null;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return [callExpression, exportExpression];\n}\n\nfunction updateHostNode(hostNode, expression) {\n  // Update existing host node with the pure comment before the variable declaration initializer.\n  var variableDeclaration = hostNode.declarationList.declarations[0];\n  var outerVarStmt = ts.updateVariableStatement(hostNode, hostNode.modifiers, ts.updateVariableDeclarationList(hostNode.declarationList, [ts.updateVariableDeclaration(variableDeclaration, variableDeclaration.name, variableDeclaration.type, expression)]));\n  return outerVarStmt;\n}\n/**\n * Find enums, class expression or declaration statements.\n *\n * The classExpressions block to wrap in an iife must\n * - end with an ExpressionStatement\n * - it's expression must be a BinaryExpression\n * - have the same name\n *\n * ```\n let Foo = class Foo {};\n Foo = __decorate([]);\n ```\n */\n\n\nfunction findStatements(name, statements, statementIndex) {\n  var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var count = 1;\n\n  for (var index = statementIndex + 1; index < statements.length; ++index) {\n    var statement = statements[index];\n\n    if (!ts.isExpressionStatement(statement)) {\n      break;\n    }\n\n    var expression = statement.expression;\n\n    if (ts.isCallExpression(expression)) {\n      // Ex:\n      // setClassMetadata(FooClass, [{}], void 0);\n      // __decorate([propDecorator()], FooClass.prototype, \"propertyName\", void 0);\n      // __decorate([propDecorator()], FooClass, \"propertyName\", void 0);\n      // __decorate$1([propDecorator()], FooClass, \"propertyName\", void 0);\n      var args = expression.arguments;\n\n      if (args.length > 2) {\n        var isReferenced = args.some(function (arg) {\n          var potentialIdentifier = ts.isPropertyAccessExpression(arg) ? arg.expression : arg;\n          return ts.isIdentifier(potentialIdentifier) && potentialIdentifier.text === name;\n        });\n\n        if (isReferenced) {\n          count++;\n          continue;\n        }\n      }\n    } else if (ts.isBinaryExpression(expression)) {\n      var node = ts.isBinaryExpression(expression.left) ? expression.left.left : expression.left;\n      var leftExpression = ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node) // Static Properties // Ex: Foo.bar = 'value';\n      // ENUM Property // Ex:  ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = \"Default\";\n      ? node.expression // Ex: FooClass = __decorate([Component()], FooClass);\n      : node;\n\n      if (ts.isIdentifier(leftExpression) && leftExpression.text === name) {\n        count++;\n        continue;\n      }\n    }\n\n    break;\n  }\n\n  if (count > 1) {\n    return statements.slice(statementIndex + offset, statementIndex + count);\n  }\n\n  return undefined;\n}\n\nfunction updateEnumIife(hostNode, iife, exportAssignment) {\n  if (!ts.isParenthesizedExpression(iife.expression) || !ts.isFunctionExpression(iife.expression.expression)) {\n    throw new Error('Invalid IIFE Structure');\n  } // Ignore export assignment if variable is directly exported\n\n\n  if (hostNode.modifiers && hostNode.modifiers.findIndex(function (m) {\n    return m.kind == ts.SyntaxKind.ExportKeyword;\n  }) != -1) {\n    exportAssignment = undefined;\n  }\n\n  var expression = iife.expression.expression;\n  var updatedFunction = ts.updateFunctionExpression(expression, expression.modifiers, expression.asteriskToken, expression.name, expression.typeParameters, expression.parameters, expression.type, ts.updateBlock(expression.body, [].concat(_toConsumableArray(expression.body.statements), [ts.createReturn(expression.parameters[0].name)])));\n  var arg = ts.createObjectLiteral();\n\n  if (exportAssignment) {\n    arg = ts.createBinary(exportAssignment, ts.SyntaxKind.BarBarToken, arg);\n  }\n\n  var updatedIife = ts.updateCall(iife, ts.updateParen(iife.expression, updatedFunction), iife.typeArguments, [arg]);\n  var value = ast_utils_1.addPureComment(updatedIife);\n\n  if (exportAssignment) {\n    value = ts.createBinary(exportAssignment, ts.SyntaxKind.FirstAssignment, updatedIife);\n  }\n\n  return [updateHostNode(hostNode, value)];\n}\n\nfunction createWrappedEnum(name, hostNode, statements) {\n  var literalInitializer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ts.createObjectLiteral();\n  var addExportModifier = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var node = addExportModifier ? ts.updateVariableStatement(hostNode, [ts.createToken(ts.SyntaxKind.ExportKeyword)], hostNode.declarationList) : hostNode;\n  var innerVarStmt = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(name, undefined, literalInitializer)]));\n  var innerReturn = ts.createReturn(ts.createIdentifier(name));\n  var iife = ts.createImmediatelyInvokedFunctionExpression([innerVarStmt].concat(_toConsumableArray(statements), [innerReturn]));\n  return [updateHostNode(node, ast_utils_1.addPureComment(ts.createParen(iife)))];\n}\n\nfunction createWrappedClass(hostNode, statements) {\n  var name = hostNode.name.text;\n\n  var updatedStatements = _toConsumableArray(statements);\n\n  if (ts.isClassDeclaration(hostNode)) {\n    updatedStatements[0] = ts.createClassDeclaration(hostNode.decorators, undefined, hostNode.name, hostNode.typeParameters, hostNode.heritageClauses, hostNode.members);\n  }\n\n  var pureIife = ast_utils_1.addPureComment(ts.createImmediatelyInvokedArrowFunction([].concat(_toConsumableArray(updatedStatements), [ts.createReturn(ts.createIdentifier(name))])));\n  var modifiers = hostNode.modifiers;\n  var isDefault = !!modifiers && modifiers.some(function (x) {\n    return x.kind === ts.SyntaxKind.DefaultKeyword;\n  });\n  var newStatement = [];\n  newStatement.push(ts.createVariableStatement(isDefault ? undefined : modifiers, ts.createVariableDeclarationList([ts.createVariableDeclaration(name, undefined, pureIife)], ts.NodeFlags.Let)));\n\n  if (isDefault) {\n    newStatement.push(ts.createExportAssignment(undefined, undefined, false, ts.createIdentifier(name)));\n  }\n\n  return newStatement;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-optimizer/src/transforms/wrap-enums.js"],"names":["Object","defineProperty","exports","value","getWrapEnumsTransformer","ts","require","ast_utils_1","isBlockLike","node","kind","SyntaxKind","Block","ModuleBlock","CaseClause","DefaultClause","SourceFile","context","transformer","sf","result","visitBlockStatements","statements","updateSourceFileNode","setTextRange","updatedStatements","visitor","updateBlock","updateModuleBlock","updateCaseClause","expression","updateDefaultClause","oIndex","uIndex","length","currentStatement","newStatement","oldStatementsLength","ImportDeclaration","isVariableStatement","declarationList","declarations","variableDeclaration","initializer","isIdentifier","name","text","iife","findEnumIife","updateEnumIife","isClassExpression","isBinaryExpression","right","classStatements","findStatements","createWrappedClass","isClassDeclaration","splice","visitNode","slice","createNodeArray","statement","isExpressionStatement","isCallExpression","arguments","callExpression","exportExpression","isParenthesizedExpression","functionExpression","isFunctionExpression","parameter","parameters","parameterName","argument","left","potentialExport","operatorToken","FirstAssignment","BarBarToken","body","isElementAccessExpression","leftExpression","updateHostNode","hostNode","outerVarStmt","updateVariableStatement","modifiers","updateVariableDeclarationList","updateVariableDeclaration","type","statementIndex","offset","count","index","args","isReferenced","some","arg","potentialIdentifier","isPropertyAccessExpression","undefined","exportAssignment","Error","findIndex","m","ExportKeyword","updatedFunction","updateFunctionExpression","asteriskToken","typeParameters","createReturn","createObjectLiteral","createBinary","updatedIife","updateCall","updateParen","typeArguments","addPureComment","createWrappedEnum","literalInitializer","addExportModifier","createToken","innerVarStmt","createVariableStatement","createVariableDeclarationList","createVariableDeclaration","innerReturn","createIdentifier","createImmediatelyInvokedFunctionExpression","createParen","createClassDeclaration","decorators","heritageClauses","members","pureIife","createImmediatelyInvokedArrowFunction","isDefault","x","DefaultKeyword","push","NodeFlags","Let","createExportAssignment"],"mappings":"AAAA;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,uBAAR,GAAkC,KAAK,CAAvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,EAAE,GAAGC,OAAO,CAAC,YAAD,CAAlB;;AACA,IAAMC,WAAW,GAAGD,OAAO,CAAC,sBAAD,CAA3B;;AACA,SAASE,WAAT,CAAqBC,IAArB,EAA2B;AACvB,SAAOA,IAAI,CAACC,IAAL,KAAcL,EAAE,CAACM,UAAH,CAAcC,KAA5B,IACAH,IAAI,CAACC,IAAL,KAAcL,EAAE,CAACM,UAAH,CAAcE,WAD5B,IAEAJ,IAAI,CAACC,IAAL,KAAcL,EAAE,CAACM,UAAH,CAAcG,UAF5B,IAGAL,IAAI,CAACC,IAAL,KAAcL,EAAE,CAACM,UAAH,CAAcI,aAH5B,IAIAN,IAAI,CAACC,IAAL,KAAcL,EAAE,CAACM,UAAH,CAAcK,UAJnC;AAKH;;AACD,SAASZ,uBAAT,GAAmC;AAC/B,SAAO,UAACa,OAAD,EAAa;AAChB,QAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAC,EAAE,EAAI;AACtB,UAAMC,MAAM,GAAGC,oBAAoB,CAACF,EAAE,CAACG,UAAJ,EAAgBL,OAAhB,CAAnC;AACA,aAAOZ,EAAE,CAACkB,oBAAH,CAAwBJ,EAAxB,EAA4Bd,EAAE,CAACmB,YAAH,CAAgBJ,MAAhB,EAAwBD,EAAE,CAACG,UAA3B,CAA5B,CAAP;AACH,KAHD;;AAIA,WAAOJ,WAAP;AACH,GAND;AAOH;;AACDhB,OAAO,CAACE,uBAAR,GAAkCA,uBAAlC;;AACA,SAASiB,oBAAT,CAA8BC,UAA9B,EAA0CL,OAA1C,EAAmD;AAC/C;AACA,MAAIQ,iBAAJ;;AACA,MAAMC,OAAO,GAAG,SAAVA,OAAU,CAACjB,IAAD,EAAU;AACtB,QAAID,WAAW,CAACC,IAAD,CAAf,EAAuB;AACnB,UAAIW,MAAM,GAAGC,oBAAoB,CAACZ,IAAI,CAACa,UAAN,EAAkBL,OAAlB,CAAjC;;AACA,UAAIG,MAAM,KAAKX,IAAI,CAACa,UAApB,EAAgC;AAC5B,eAAOb,IAAP;AACH;;AACDW,MAAAA,MAAM,GAAGf,EAAE,CAACmB,YAAH,CAAgBJ,MAAhB,EAAwBX,IAAI,CAACa,UAA7B,CAAT;;AACA,cAAQb,IAAI,CAACC,IAAb;AACI,aAAKL,EAAE,CAACM,UAAH,CAAcC,KAAnB;AACI,iBAAOP,EAAE,CAACsB,WAAH,CAAelB,IAAf,EAAqBW,MAArB,CAAP;;AACJ,aAAKf,EAAE,CAACM,UAAH,CAAcE,WAAnB;AACI,iBAAOR,EAAE,CAACuB,iBAAH,CAAqBnB,IAArB,EAA2BW,MAA3B,CAAP;;AACJ,aAAKf,EAAE,CAACM,UAAH,CAAcG,UAAnB;AACI,iBAAOT,EAAE,CAACwB,gBAAH,CAAoBpB,IAApB,EAA0BA,IAAI,CAACqB,UAA/B,EAA2CV,MAA3C,CAAP;;AACJ,aAAKf,EAAE,CAACM,UAAH,CAAcI,aAAnB;AACI,iBAAOV,EAAE,CAAC0B,mBAAH,CAAuBtB,IAAvB,EAA6BW,MAA7B,CAAP;;AACJ;AACI,iBAAOX,IAAP;AAVR;AAYH,KAlBD,MAmBK;AACD,aAAOA,IAAP;AACH;AACJ,GAvBD,CAH+C,CA2B/C;;;AACA,OAAK,IAAIuB,MAAM,GAAG,CAAb,EAAgBC,MAAM,GAAG,CAA9B,EAAiCD,MAAM,GAAGV,UAAU,CAACY,MAAX,GAAoB,CAA9D,EAAiEF,MAAM,IAAIC,MAAM,EAAjF,EAAqF;AACjF,QAAME,gBAAgB,GAAGb,UAAU,CAACU,MAAD,CAAnC;AACA,QAAII,YAAY,SAAhB;AACA,QAAIC,mBAAmB,GAAG,CAA1B,CAHiF,CAIjF;;AACA,QAAIF,gBAAgB,CAACzB,IAAjB,KAA0BL,EAAE,CAACM,UAAH,CAAc2B,iBAA5C,EAA+D;AAC3D;AACH,KAPgF,CAQjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIjC,EAAE,CAACkC,mBAAH,CAAuBJ,gBAAvB,KACGA,gBAAgB,CAACK,eAAjB,CAAiCC,YAAjC,CAA8CP,MAA9C,KAAyD,CADhE,EACmE;AAC/D,UAAMQ,mBAAmB,GAAGP,gBAAgB,CAACK,eAAjB,CAAiCC,YAAjC,CAA8C,CAA9C,CAA5B;AACA,UAAME,WAAW,GAAGD,mBAAmB,CAACC,WAAxC;;AACA,UAAItC,EAAE,CAACuC,YAAH,CAAgBF,mBAAmB,CAACG,IAApC,CAAJ,EAA+C;AAC3C,YAAMA,IAAI,GAAGH,mBAAmB,CAACG,IAApB,CAAyBC,IAAtC;;AACA,YAAI,CAACH,WAAL,EAAkB;AACd,cAAMI,IAAI,GAAGC,YAAY,CAACH,IAAD,EAAOvB,UAAU,CAACU,MAAM,GAAG,CAAV,CAAjB,CAAzB;;AACA,cAAIe,IAAJ,EAAU;AACN;AACAV,YAAAA,mBAAmB,GAAG,CAAtB;AACAD,YAAAA,YAAY,GAAGa,cAAc,CAACd,gBAAD,EAAmBY,IAAI,CAAC,CAAD,CAAvB,EAA4BA,IAAI,CAAC,CAAD,CAAhC,CAA7B,CAHM,CAIN;;AACAf,YAAAA,MAAM;AACT;AACJ,SATD,MAUK,IAAI3B,EAAE,CAAC6C,iBAAH,CAAqBP,WAArB,KACDtC,EAAE,CAAC8C,kBAAH,CAAsBR,WAAtB,KACGtC,EAAE,CAAC6C,iBAAH,CAAqBP,WAAW,CAACS,KAAjC,CAFN,EAEgD;AACjD,cAAMC,eAAe,GAAGC,cAAc,CAACT,IAAD,EAAOvB,UAAP,EAAmBU,MAAnB,CAAtC;;AACA,cAAI,CAACqB,eAAL,EAAsB;AAClB;AACH;;AACDhB,UAAAA,mBAAmB,GAAGgB,eAAe,CAACnB,MAAtC;AACAE,UAAAA,YAAY,GAAGmB,kBAAkB,CAACb,mBAAD,EAAsBW,eAAtB,CAAjC;AACArB,UAAAA,MAAM,IAAIqB,eAAe,CAACnB,MAAhB,GAAyB,CAAnC;AACH;AACJ;AACJ,KA5BD,MA6BK,IAAI7B,EAAE,CAACmD,kBAAH,CAAsBrB,gBAAtB,CAAJ,EAA6C;AAC9C,UAAMU,KAAI,GAAGV,gBAAgB,CAACU,IAAjB,CAAsBC,IAAnC;;AACA,UAAMO,gBAAe,GAAGC,cAAc,CAACT,KAAD,EAAOvB,UAAP,EAAmBU,MAAnB,CAAtC;;AACA,UAAI,CAACqB,gBAAL,EAAsB;AAClB;AACH;;AACDhB,MAAAA,mBAAmB,GAAGgB,gBAAe,CAACnB,MAAtC;AACAE,MAAAA,YAAY,GAAGmB,kBAAkB,CAACpB,gBAAD,EAAmBkB,gBAAnB,CAAjC;AACArB,MAAAA,MAAM,IAAIqB,gBAAe,CAACnB,MAAhB,GAAyB,CAAnC;AACH;;AACD,QAAIE,YAAY,IAAIA,YAAY,CAACF,MAAb,GAAsB,CAA1C,EAA6C;AAAA;;AACzC,UAAI,CAACT,iBAAL,EAAwB;AACpBA,QAAAA,iBAAiB,sBAAOH,UAAP,CAAjB;AACH;;AACD,4BAAAG,iBAAiB,EAACgC,MAAlB,4BAAyBxB,MAAzB,EAAiCI,mBAAjC,4BAAyDD,YAAzD,IAJyC,CAKzC;AACA;;;AACAH,MAAAA,MAAM,IAAKG,YAAY,GAAGA,YAAY,CAACF,MAAb,GAAsB,CAAzB,GAA6B,CAApD;AACH;;AACD,QAAMd,MAAM,GAAGf,EAAE,CAACqD,SAAH,CAAavB,gBAAb,EAA+BT,OAA/B,CAAf;;AACA,QAAIN,MAAM,KAAKe,gBAAf,EAAiC;AAC7B,UAAI,CAACV,iBAAL,EAAwB;AACpBA,QAAAA,iBAAiB,GAAGH,UAAU,CAACqC,KAAX,EAApB;AACH;;AACDlC,MAAAA,iBAAiB,CAACQ,MAAD,CAAjB,GAA4Bb,MAA5B;AACH;AACJ,GAtG8C,CAuG/C;AACA;;;AACA,SAAOK,iBAAiB,GAAGpB,EAAE,CAACuD,eAAH,CAAmBnC,iBAAnB,CAAH,GAA2CH,UAAnE;AACH,C,CACD;;;AACA,SAAS0B,YAAT,CAAsBH,IAAtB,EAA4BgB,SAA5B,EAAuC;AACnC,MAAI,CAACxD,EAAE,CAACyD,qBAAH,CAAyBD,SAAzB,CAAL,EAA0C;AACtC,WAAO,IAAP;AACH;;AACD,MAAM/B,UAAU,GAAG+B,SAAS,CAAC/B,UAA7B;;AACA,MAAI,CAACA,UAAD,IAAe,CAACzB,EAAE,CAAC0D,gBAAH,CAAoBjC,UAApB,CAAhB,IAAmDA,UAAU,CAACkC,SAAX,CAAqB9B,MAArB,KAAgC,CAAvF,EAA0F;AACtF,WAAO,IAAP;AACH;;AACD,MAAM+B,cAAc,GAAGnC,UAAvB;AACA,MAAIoC,gBAAJ;;AACA,MAAI,CAAC7D,EAAE,CAAC8D,yBAAH,CAA6BF,cAAc,CAACnC,UAA5C,CAAL,EAA8D;AAC1D,WAAO,IAAP;AACH;;AACD,MAAMsC,kBAAkB,GAAGH,cAAc,CAACnC,UAAf,CAA0BA,UAArD;;AACA,MAAI,CAACzB,EAAE,CAACgE,oBAAH,CAAwBD,kBAAxB,CAAL,EAAkD;AAC9C,WAAO,IAAP;AACH,GAhBkC,CAiBnC;AACA;;;AACA,MAAME,SAAS,GAAGF,kBAAkB,CAACG,UAAnB,CAA8B,CAA9B,CAAlB;;AACA,MAAI,CAAClE,EAAE,CAACuC,YAAH,CAAgB0B,SAAS,CAACzB,IAA1B,CAAL,EAAsC;AAClC,WAAO,IAAP;AACH;;AACD,MAAM2B,aAAa,GAAGF,SAAS,CAACzB,IAAV,CAAeC,IAArC;AACA,MAAI2B,QAAQ,GAAGR,cAAc,CAACD,SAAf,CAAyB,CAAzB,CAAf;;AACA,MAAI,CAAC3D,EAAE,CAAC8C,kBAAH,CAAsBsB,QAAtB,CAAD,IACG,CAACpE,EAAE,CAACuC,YAAH,CAAgB6B,QAAQ,CAACC,IAAzB,CADJ,IAEGD,QAAQ,CAACC,IAAT,CAAc5B,IAAd,KAAuBD,IAF9B,EAEoC;AAChC,WAAO,IAAP;AACH;;AACD,MAAI8B,eAAe,GAAG,KAAtB;;AACA,MAAIF,QAAQ,CAACG,aAAT,CAAuBlE,IAAvB,KAAgCL,EAAE,CAACM,UAAH,CAAckE,eAAlD,EAAmE;AAC/D,QAAIxE,EAAE,CAAC8C,kBAAH,CAAsBsB,QAAQ,CAACrB,KAA/B,KAAyCqB,QAAQ,CAACrB,KAAT,CAAewB,aAAf,CAA6BlE,IAA7B,KAAsCL,EAAE,CAACM,UAAH,CAAcmE,WAAjG,EAA8G;AAC1G,aAAO,IAAP;AACH;;AACDH,IAAAA,eAAe,GAAG,IAAlB;AACAF,IAAAA,QAAQ,GAAGA,QAAQ,CAACrB,KAApB;AACH;;AACD,MAAI,CAAC/C,EAAE,CAAC8C,kBAAH,CAAsBsB,QAAtB,CAAL,EAAsC;AAClC,WAAO,IAAP;AACH;;AACD,MAAIA,QAAQ,CAACG,aAAT,CAAuBlE,IAAvB,KAAgCL,EAAE,CAACM,UAAH,CAAcmE,WAAlD,EAA+D;AAC3D,WAAO,IAAP;AACH;;AACD,MAAIH,eAAe,IAAI,CAACtE,EAAE,CAACuC,YAAH,CAAgB6B,QAAQ,CAACC,IAAzB,CAAxB,EAAwD;AACpDR,IAAAA,gBAAgB,GAAGO,QAAQ,CAACC,IAA5B;AACH,GA9CkC,CA+CnC;;;AA/CmC,6CAgDXN,kBAAkB,CAACW,IAAnB,CAAwBzD,UAhDb;AAAA;;AAAA;AAgDnC,wDAA4D;AAAA,UAAjDuC,UAAiD;;AACxD,UAAI,CAACxD,EAAE,CAACyD,qBAAH,CAAyBD,UAAzB,CAAD,IACG,CAACxD,EAAE,CAAC8C,kBAAH,CAAsBU,UAAS,CAAC/B,UAAhC,CADJ,IAEG,CAACzB,EAAE,CAAC2E,yBAAH,CAA6BnB,UAAS,CAAC/B,UAAV,CAAqB4C,IAAlD,CAFR,EAEiE;AAC7D,eAAO,IAAP;AACH;;AACD,UAAMO,cAAc,GAAGpB,UAAS,CAAC/B,UAAV,CAAqB4C,IAArB,CAA0B5C,UAAjD;;AACA,UAAI,CAACzB,EAAE,CAACuC,YAAH,CAAgBqC,cAAhB,CAAD,IAAoCA,cAAc,CAACnC,IAAf,KAAwB0B,aAAhE,EAA+E;AAC3E,eAAO,IAAP;AACH;AACJ;AA1DkC;AAAA;AAAA;AAAA;AAAA;;AA2DnC,SAAO,CAACP,cAAD,EAAiBC,gBAAjB,CAAP;AACH;;AACD,SAASgB,cAAT,CAAwBC,QAAxB,EAAkCrD,UAAlC,EAA8C;AAC1C;AACA,MAAMY,mBAAmB,GAAGyC,QAAQ,CAAC3C,eAAT,CAAyBC,YAAzB,CAAsC,CAAtC,CAA5B;AACA,MAAM2C,YAAY,GAAG/E,EAAE,CAACgF,uBAAH,CAA2BF,QAA3B,EAAqCA,QAAQ,CAACG,SAA9C,EAAyDjF,EAAE,CAACkF,6BAAH,CAAiCJ,QAAQ,CAAC3C,eAA1C,EAA2D,CACrInC,EAAE,CAACmF,yBAAH,CAA6B9C,mBAA7B,EAAkDA,mBAAmB,CAACG,IAAtE,EAA4EH,mBAAmB,CAAC+C,IAAhG,EAAsG3D,UAAtG,CADqI,CAA3D,CAAzD,CAArB;AAGA,SAAOsD,YAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS9B,cAAT,CAAwBT,IAAxB,EAA8BvB,UAA9B,EAA0CoE,cAA1C,EAAsE;AAAA,MAAZC,MAAY,uEAAH,CAAG;AAClE,MAAIC,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAIC,KAAK,GAAGH,cAAc,GAAG,CAAlC,EAAqCG,KAAK,GAAGvE,UAAU,CAACY,MAAxD,EAAgE,EAAE2D,KAAlE,EAAyE;AACrE,QAAMhC,SAAS,GAAGvC,UAAU,CAACuE,KAAD,CAA5B;;AACA,QAAI,CAACxF,EAAE,CAACyD,qBAAH,CAAyBD,SAAzB,CAAL,EAA0C;AACtC;AACH;;AACD,QAAM/B,UAAU,GAAG+B,SAAS,CAAC/B,UAA7B;;AACA,QAAIzB,EAAE,CAAC0D,gBAAH,CAAoBjC,UAApB,CAAJ,EAAqC;AACjC;AACA;AACA;AACA;AACA;AACA,UAAMgE,IAAI,GAAGhE,UAAU,CAACkC,SAAxB;;AACA,UAAI8B,IAAI,CAAC5D,MAAL,GAAc,CAAlB,EAAqB;AACjB,YAAM6D,YAAY,GAAGD,IAAI,CAACE,IAAL,CAAU,UAAAC,GAAG,EAAI;AAClC,cAAMC,mBAAmB,GAAG7F,EAAE,CAAC8F,0BAAH,CAA8BF,GAA9B,IAAqCA,GAAG,CAACnE,UAAzC,GAAsDmE,GAAlF;AACA,iBAAO5F,EAAE,CAACuC,YAAH,CAAgBsD,mBAAhB,KAAwCA,mBAAmB,CAACpD,IAApB,KAA6BD,IAA5E;AACH,SAHoB,CAArB;;AAIA,YAAIkD,YAAJ,EAAkB;AACdH,UAAAA,KAAK;AACL;AACH;AACJ;AACJ,KAjBD,MAkBK,IAAIvF,EAAE,CAAC8C,kBAAH,CAAsBrB,UAAtB,CAAJ,EAAuC;AACxC,UAAMrB,IAAI,GAAGJ,EAAE,CAAC8C,kBAAH,CAAsBrB,UAAU,CAAC4C,IAAjC,IACP5C,UAAU,CAAC4C,IAAX,CAAgBA,IADT,GAEP5C,UAAU,CAAC4C,IAFjB;AAGA,UAAMO,cAAc,GAAG5E,EAAE,CAAC8F,0BAAH,CAA8B1F,IAA9B,KAAuCJ,EAAE,CAAC2E,yBAAH,CAA6BvE,IAA7B,CAAvC,CACnB;AACA;AAFmB,QAGjBA,IAAI,CAACqB,UAHY,CAInB;AAJmB,QAKjBrB,IALN;;AAMA,UAAIJ,EAAE,CAACuC,YAAH,CAAgBqC,cAAhB,KAAmCA,cAAc,CAACnC,IAAf,KAAwBD,IAA/D,EAAqE;AACjE+C,QAAAA,KAAK;AACL;AACH;AACJ;;AACD;AACH;;AACD,MAAIA,KAAK,GAAG,CAAZ,EAAe;AACX,WAAOtE,UAAU,CAACqC,KAAX,CAAiB+B,cAAc,GAAGC,MAAlC,EAA0CD,cAAc,GAAGE,KAA3D,CAAP;AACH;;AACD,SAAOQ,SAAP;AACH;;AACD,SAASnD,cAAT,CAAwBkC,QAAxB,EAAkCpC,IAAlC,EAAwCsD,gBAAxC,EAA0D;AACtD,MAAI,CAAChG,EAAE,CAAC8D,yBAAH,CAA6BpB,IAAI,CAACjB,UAAlC,CAAD,IACG,CAACzB,EAAE,CAACgE,oBAAH,CAAwBtB,IAAI,CAACjB,UAAL,CAAgBA,UAAxC,CADR,EAC6D;AACzD,UAAM,IAAIwE,KAAJ,CAAU,wBAAV,CAAN;AACH,GAJqD,CAKtD;;;AACA,MAAInB,QAAQ,CAACG,SAAT,IACGH,QAAQ,CAACG,SAAT,CAAmBiB,SAAnB,CAA6B,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAAC9F,IAAF,IAAUL,EAAE,CAACM,UAAH,CAAc8F,aAA5B;AAAA,GAA9B,KAA4E,CAAC,CADpF,EACuF;AACnFJ,IAAAA,gBAAgB,GAAGD,SAAnB;AACH;;AACD,MAAMtE,UAAU,GAAGiB,IAAI,CAACjB,UAAL,CAAgBA,UAAnC;AACA,MAAM4E,eAAe,GAAGrG,EAAE,CAACsG,wBAAH,CAA4B7E,UAA5B,EAAwCA,UAAU,CAACwD,SAAnD,EAA8DxD,UAAU,CAAC8E,aAAzE,EAAwF9E,UAAU,CAACe,IAAnG,EAAyGf,UAAU,CAAC+E,cAApH,EAAoI/E,UAAU,CAACyC,UAA/I,EAA2JzC,UAAU,CAAC2D,IAAtK,EAA4KpF,EAAE,CAACsB,WAAH,CAAeG,UAAU,CAACiD,IAA1B,+BAC7LjD,UAAU,CAACiD,IAAX,CAAgBzD,UAD6K,IAEhMjB,EAAE,CAACyG,YAAH,CAAgBhF,UAAU,CAACyC,UAAX,CAAsB,CAAtB,EAAyB1B,IAAzC,CAFgM,GAA5K,CAAxB;AAIA,MAAIoD,GAAG,GAAG5F,EAAE,CAAC0G,mBAAH,EAAV;;AACA,MAAIV,gBAAJ,EAAsB;AAClBJ,IAAAA,GAAG,GAAG5F,EAAE,CAAC2G,YAAH,CAAgBX,gBAAhB,EAAkChG,EAAE,CAACM,UAAH,CAAcmE,WAAhD,EAA6DmB,GAA7D,CAAN;AACH;;AACD,MAAMgB,WAAW,GAAG5G,EAAE,CAAC6G,UAAH,CAAcnE,IAAd,EAAoB1C,EAAE,CAAC8G,WAAH,CAAepE,IAAI,CAACjB,UAApB,EAAgC4E,eAAhC,CAApB,EAAsE3D,IAAI,CAACqE,aAA3E,EAA0F,CAACnB,GAAD,CAA1F,CAApB;AACA,MAAI9F,KAAK,GAAGI,WAAW,CAAC8G,cAAZ,CAA2BJ,WAA3B,CAAZ;;AACA,MAAIZ,gBAAJ,EAAsB;AAClBlG,IAAAA,KAAK,GAAGE,EAAE,CAAC2G,YAAH,CAAgBX,gBAAhB,EAAkChG,EAAE,CAACM,UAAH,CAAckE,eAAhD,EAAiEoC,WAAjE,CAAR;AACH;;AACD,SAAO,CAAC/B,cAAc,CAACC,QAAD,EAAWhF,KAAX,CAAf,CAAP;AACH;;AACD,SAASmH,iBAAT,CAA2BzE,IAA3B,EAAiCsC,QAAjC,EAA2C7D,UAA3C,EAAiI;AAAA,MAA1EiG,kBAA0E,uEAArDlH,EAAE,CAAC0G,mBAAH,EAAqD;AAAA,MAA3BS,iBAA2B,uEAAP,KAAO;AAC7H,MAAM/G,IAAI,GAAG+G,iBAAiB,GACxBnH,EAAE,CAACgF,uBAAH,CAA2BF,QAA3B,EAAqC,CAAC9E,EAAE,CAACoH,WAAH,CAAepH,EAAE,CAACM,UAAH,CAAc8F,aAA7B,CAAD,CAArC,EAAoFtB,QAAQ,CAAC3C,eAA7F,CADwB,GAExB2C,QAFN;AAGA,MAAMuC,YAAY,GAAGrH,EAAE,CAACsH,uBAAH,CAA2BvB,SAA3B,EAAsC/F,EAAE,CAACuH,6BAAH,CAAiC,CACxFvH,EAAE,CAACwH,yBAAH,CAA6BhF,IAA7B,EAAmCuD,SAAnC,EAA8CmB,kBAA9C,CADwF,CAAjC,CAAtC,CAArB;AAGA,MAAMO,WAAW,GAAGzH,EAAE,CAACyG,YAAH,CAAgBzG,EAAE,CAAC0H,gBAAH,CAAoBlF,IAApB,CAAhB,CAApB;AACA,MAAME,IAAI,GAAG1C,EAAE,CAAC2H,0CAAH,EACTN,YADS,4BAENpG,UAFM,IAGTwG,WAHS,GAAb;AAKA,SAAO,CAAC5C,cAAc,CAACzE,IAAD,EAAOF,WAAW,CAAC8G,cAAZ,CAA2BhH,EAAE,CAAC4H,WAAH,CAAelF,IAAf,CAA3B,CAAP,CAAf,CAAP;AACH;;AACD,SAASQ,kBAAT,CAA4B4B,QAA5B,EAAsC7D,UAAtC,EAAkD;AAC9C,MAAMuB,IAAI,GAAGsC,QAAQ,CAACtC,IAAT,CAAcC,IAA3B;;AACA,MAAMrB,iBAAiB,sBAAOH,UAAP,CAAvB;;AACA,MAAIjB,EAAE,CAACmD,kBAAH,CAAsB2B,QAAtB,CAAJ,EAAqC;AACjC1D,IAAAA,iBAAiB,CAAC,CAAD,CAAjB,GAAuBpB,EAAE,CAAC6H,sBAAH,CAA0B/C,QAAQ,CAACgD,UAAnC,EAA+C/B,SAA/C,EAA0DjB,QAAQ,CAACtC,IAAnE,EAAyEsC,QAAQ,CAAC0B,cAAlF,EAAkG1B,QAAQ,CAACiD,eAA3G,EAA4HjD,QAAQ,CAACkD,OAArI,CAAvB;AACH;;AACD,MAAMC,QAAQ,GAAG/H,WAAW,CAAC8G,cAAZ,CAA2BhH,EAAE,CAACkI,qCAAH,8BACrC9G,iBADqC,IAExCpB,EAAE,CAACyG,YAAH,CAAgBzG,EAAE,CAAC0H,gBAAH,CAAoBlF,IAApB,CAAhB,CAFwC,GAA3B,CAAjB;AAIA,MAAMyC,SAAS,GAAGH,QAAQ,CAACG,SAA3B;AACA,MAAMkD,SAAS,GAAG,CAAC,CAAClD,SAAF,IACXA,SAAS,CAACU,IAAV,CAAe,UAAAyC,CAAC;AAAA,WAAIA,CAAC,CAAC/H,IAAF,KAAWL,EAAE,CAACM,UAAH,CAAc+H,cAA7B;AAAA,GAAhB,CADP;AAEA,MAAMtG,YAAY,GAAG,EAArB;AACAA,EAAAA,YAAY,CAACuG,IAAb,CAAkBtI,EAAE,CAACsH,uBAAH,CAA2Ba,SAAS,GAAGpC,SAAH,GAAed,SAAnD,EAA8DjF,EAAE,CAACuH,6BAAH,CAAiC,CAC7GvH,EAAE,CAACwH,yBAAH,CAA6BhF,IAA7B,EAAmCuD,SAAnC,EAA8CkC,QAA9C,CAD6G,CAAjC,EAE7EjI,EAAE,CAACuI,SAAH,CAAaC,GAFgE,CAA9D,CAAlB;;AAGA,MAAIL,SAAJ,EAAe;AACXpG,IAAAA,YAAY,CAACuG,IAAb,CAAkBtI,EAAE,CAACyI,sBAAH,CAA0B1C,SAA1B,EAAqCA,SAArC,EAAgD,KAAhD,EAAuD/F,EAAE,CAAC0H,gBAAH,CAAoBlF,IAApB,CAAvD,CAAlB;AACH;;AACD,SAAOT,YAAP;AACH","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getWrapEnumsTransformer = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ts = require(\"typescript\");\nconst ast_utils_1 = require(\"../helpers/ast-utils\");\nfunction isBlockLike(node) {\n    return node.kind === ts.SyntaxKind.Block\n        || node.kind === ts.SyntaxKind.ModuleBlock\n        || node.kind === ts.SyntaxKind.CaseClause\n        || node.kind === ts.SyntaxKind.DefaultClause\n        || node.kind === ts.SyntaxKind.SourceFile;\n}\nfunction getWrapEnumsTransformer() {\n    return (context) => {\n        const transformer = sf => {\n            const result = visitBlockStatements(sf.statements, context);\n            return ts.updateSourceFileNode(sf, ts.setTextRange(result, sf.statements));\n        };\n        return transformer;\n    };\n}\nexports.getWrapEnumsTransformer = getWrapEnumsTransformer;\nfunction visitBlockStatements(statements, context) {\n    // copy of statements to modify; lazy initialized\n    let updatedStatements;\n    const visitor = (node) => {\n        if (isBlockLike(node)) {\n            let result = visitBlockStatements(node.statements, context);\n            if (result === node.statements) {\n                return node;\n            }\n            result = ts.setTextRange(result, node.statements);\n            switch (node.kind) {\n                case ts.SyntaxKind.Block:\n                    return ts.updateBlock(node, result);\n                case ts.SyntaxKind.ModuleBlock:\n                    return ts.updateModuleBlock(node, result);\n                case ts.SyntaxKind.CaseClause:\n                    return ts.updateCaseClause(node, node.expression, result);\n                case ts.SyntaxKind.DefaultClause:\n                    return ts.updateDefaultClause(node, result);\n                default:\n                    return node;\n            }\n        }\n        else {\n            return node;\n        }\n    };\n    // 'oIndex' is the original statement index; 'uIndex' is the updated statement index\n    for (let oIndex = 0, uIndex = 0; oIndex < statements.length - 1; oIndex++, uIndex++) {\n        const currentStatement = statements[oIndex];\n        let newStatement;\n        let oldStatementsLength = 0;\n        // these can't contain an enum declaration\n        if (currentStatement.kind === ts.SyntaxKind.ImportDeclaration) {\n            continue;\n        }\n        // enum declarations must:\n        //   * not be last statement\n        //   * be a variable statement\n        //   * have only one declaration\n        //   * have an identifer as a declaration name\n        // ClassExpression declarations must:\n        //   * not be last statement\n        //   * be a variable statement\n        //   * have only one declaration\n        //   * have an ClassExpression or BinaryExpression and a right\n        //     of kind ClassExpression as a initializer\n        if (ts.isVariableStatement(currentStatement)\n            && currentStatement.declarationList.declarations.length === 1) {\n            const variableDeclaration = currentStatement.declarationList.declarations[0];\n            const initializer = variableDeclaration.initializer;\n            if (ts.isIdentifier(variableDeclaration.name)) {\n                const name = variableDeclaration.name.text;\n                if (!initializer) {\n                    const iife = findEnumIife(name, statements[oIndex + 1]);\n                    if (iife) {\n                        // update IIFE and replace variable statement and old IIFE\n                        oldStatementsLength = 2;\n                        newStatement = updateEnumIife(currentStatement, iife[0], iife[1]);\n                        // skip IIFE statement\n                        oIndex++;\n                    }\n                }\n                else if (ts.isClassExpression(initializer)\n                    || (ts.isBinaryExpression(initializer)\n                        && ts.isClassExpression(initializer.right))) {\n                    const classStatements = findStatements(name, statements, oIndex);\n                    if (!classStatements) {\n                        continue;\n                    }\n                    oldStatementsLength = classStatements.length;\n                    newStatement = createWrappedClass(variableDeclaration, classStatements);\n                    oIndex += classStatements.length - 1;\n                }\n            }\n        }\n        else if (ts.isClassDeclaration(currentStatement)) {\n            const name = currentStatement.name.text;\n            const classStatements = findStatements(name, statements, oIndex);\n            if (!classStatements) {\n                continue;\n            }\n            oldStatementsLength = classStatements.length;\n            newStatement = createWrappedClass(currentStatement, classStatements);\n            oIndex += classStatements.length - 1;\n        }\n        if (newStatement && newStatement.length > 0) {\n            if (!updatedStatements) {\n                updatedStatements = [...statements];\n            }\n            updatedStatements.splice(uIndex, oldStatementsLength, ...newStatement);\n            // When having more than a single new statement\n            // we need to update the update Index\n            uIndex += (newStatement ? newStatement.length - 1 : 0);\n        }\n        const result = ts.visitNode(currentStatement, visitor);\n        if (result !== currentStatement) {\n            if (!updatedStatements) {\n                updatedStatements = statements.slice();\n            }\n            updatedStatements[uIndex] = result;\n        }\n    }\n    // if changes, return updated statements\n    // otherwise, return original array instance\n    return updatedStatements ? ts.createNodeArray(updatedStatements) : statements;\n}\n// TS 2.3 enums have statements that are inside a IIFE.\nfunction findEnumIife(name, statement) {\n    if (!ts.isExpressionStatement(statement)) {\n        return null;\n    }\n    const expression = statement.expression;\n    if (!expression || !ts.isCallExpression(expression) || expression.arguments.length !== 1) {\n        return null;\n    }\n    const callExpression = expression;\n    let exportExpression;\n    if (!ts.isParenthesizedExpression(callExpression.expression)) {\n        return null;\n    }\n    const functionExpression = callExpression.expression.expression;\n    if (!ts.isFunctionExpression(functionExpression)) {\n        return null;\n    }\n    // The name of the parameter can be different than the name of the enum if it was renamed\n    // due to scope hoisting.\n    const parameter = functionExpression.parameters[0];\n    if (!ts.isIdentifier(parameter.name)) {\n        return null;\n    }\n    const parameterName = parameter.name.text;\n    let argument = callExpression.arguments[0];\n    if (!ts.isBinaryExpression(argument)\n        || !ts.isIdentifier(argument.left)\n        || argument.left.text !== name) {\n        return null;\n    }\n    let potentialExport = false;\n    if (argument.operatorToken.kind === ts.SyntaxKind.FirstAssignment) {\n        if (ts.isBinaryExpression(argument.right) && argument.right.operatorToken.kind !== ts.SyntaxKind.BarBarToken) {\n            return null;\n        }\n        potentialExport = true;\n        argument = argument.right;\n    }\n    if (!ts.isBinaryExpression(argument)) {\n        return null;\n    }\n    if (argument.operatorToken.kind !== ts.SyntaxKind.BarBarToken) {\n        return null;\n    }\n    if (potentialExport && !ts.isIdentifier(argument.left)) {\n        exportExpression = argument.left;\n    }\n    // Go through all the statements and check that all match the name\n    for (const statement of functionExpression.body.statements) {\n        if (!ts.isExpressionStatement(statement)\n            || !ts.isBinaryExpression(statement.expression)\n            || !ts.isElementAccessExpression(statement.expression.left)) {\n            return null;\n        }\n        const leftExpression = statement.expression.left.expression;\n        if (!ts.isIdentifier(leftExpression) || leftExpression.text !== parameterName) {\n            return null;\n        }\n    }\n    return [callExpression, exportExpression];\n}\nfunction updateHostNode(hostNode, expression) {\n    // Update existing host node with the pure comment before the variable declaration initializer.\n    const variableDeclaration = hostNode.declarationList.declarations[0];\n    const outerVarStmt = ts.updateVariableStatement(hostNode, hostNode.modifiers, ts.updateVariableDeclarationList(hostNode.declarationList, [\n        ts.updateVariableDeclaration(variableDeclaration, variableDeclaration.name, variableDeclaration.type, expression),\n    ]));\n    return outerVarStmt;\n}\n/**\n * Find enums, class expression or declaration statements.\n *\n * The classExpressions block to wrap in an iife must\n * - end with an ExpressionStatement\n * - it's expression must be a BinaryExpression\n * - have the same name\n *\n * ```\n let Foo = class Foo {};\n Foo = __decorate([]);\n ```\n */\nfunction findStatements(name, statements, statementIndex, offset = 0) {\n    let count = 1;\n    for (let index = statementIndex + 1; index < statements.length; ++index) {\n        const statement = statements[index];\n        if (!ts.isExpressionStatement(statement)) {\n            break;\n        }\n        const expression = statement.expression;\n        if (ts.isCallExpression(expression)) {\n            // Ex:\n            // setClassMetadata(FooClass, [{}], void 0);\n            // __decorate([propDecorator()], FooClass.prototype, \"propertyName\", void 0);\n            // __decorate([propDecorator()], FooClass, \"propertyName\", void 0);\n            // __decorate$1([propDecorator()], FooClass, \"propertyName\", void 0);\n            const args = expression.arguments;\n            if (args.length > 2) {\n                const isReferenced = args.some(arg => {\n                    const potentialIdentifier = ts.isPropertyAccessExpression(arg) ? arg.expression : arg;\n                    return ts.isIdentifier(potentialIdentifier) && potentialIdentifier.text === name;\n                });\n                if (isReferenced) {\n                    count++;\n                    continue;\n                }\n            }\n        }\n        else if (ts.isBinaryExpression(expression)) {\n            const node = ts.isBinaryExpression(expression.left)\n                ? expression.left.left\n                : expression.left;\n            const leftExpression = ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node)\n                // Static Properties // Ex: Foo.bar = 'value';\n                // ENUM Property // Ex:  ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = \"Default\";\n                ? node.expression\n                // Ex: FooClass = __decorate([Component()], FooClass);\n                : node;\n            if (ts.isIdentifier(leftExpression) && leftExpression.text === name) {\n                count++;\n                continue;\n            }\n        }\n        break;\n    }\n    if (count > 1) {\n        return statements.slice(statementIndex + offset, statementIndex + count);\n    }\n    return undefined;\n}\nfunction updateEnumIife(hostNode, iife, exportAssignment) {\n    if (!ts.isParenthesizedExpression(iife.expression)\n        || !ts.isFunctionExpression(iife.expression.expression)) {\n        throw new Error('Invalid IIFE Structure');\n    }\n    // Ignore export assignment if variable is directly exported\n    if (hostNode.modifiers\n        && hostNode.modifiers.findIndex(m => m.kind == ts.SyntaxKind.ExportKeyword) != -1) {\n        exportAssignment = undefined;\n    }\n    const expression = iife.expression.expression;\n    const updatedFunction = ts.updateFunctionExpression(expression, expression.modifiers, expression.asteriskToken, expression.name, expression.typeParameters, expression.parameters, expression.type, ts.updateBlock(expression.body, [\n        ...expression.body.statements,\n        ts.createReturn(expression.parameters[0].name),\n    ]));\n    let arg = ts.createObjectLiteral();\n    if (exportAssignment) {\n        arg = ts.createBinary(exportAssignment, ts.SyntaxKind.BarBarToken, arg);\n    }\n    const updatedIife = ts.updateCall(iife, ts.updateParen(iife.expression, updatedFunction), iife.typeArguments, [arg]);\n    let value = ast_utils_1.addPureComment(updatedIife);\n    if (exportAssignment) {\n        value = ts.createBinary(exportAssignment, ts.SyntaxKind.FirstAssignment, updatedIife);\n    }\n    return [updateHostNode(hostNode, value)];\n}\nfunction createWrappedEnum(name, hostNode, statements, literalInitializer = ts.createObjectLiteral(), addExportModifier = false) {\n    const node = addExportModifier\n        ? ts.updateVariableStatement(hostNode, [ts.createToken(ts.SyntaxKind.ExportKeyword)], hostNode.declarationList)\n        : hostNode;\n    const innerVarStmt = ts.createVariableStatement(undefined, ts.createVariableDeclarationList([\n        ts.createVariableDeclaration(name, undefined, literalInitializer),\n    ]));\n    const innerReturn = ts.createReturn(ts.createIdentifier(name));\n    const iife = ts.createImmediatelyInvokedFunctionExpression([\n        innerVarStmt,\n        ...statements,\n        innerReturn,\n    ]);\n    return [updateHostNode(node, ast_utils_1.addPureComment(ts.createParen(iife)))];\n}\nfunction createWrappedClass(hostNode, statements) {\n    const name = hostNode.name.text;\n    const updatedStatements = [...statements];\n    if (ts.isClassDeclaration(hostNode)) {\n        updatedStatements[0] = ts.createClassDeclaration(hostNode.decorators, undefined, hostNode.name, hostNode.typeParameters, hostNode.heritageClauses, hostNode.members);\n    }\n    const pureIife = ast_utils_1.addPureComment(ts.createImmediatelyInvokedArrowFunction([\n        ...updatedStatements,\n        ts.createReturn(ts.createIdentifier(name)),\n    ]));\n    const modifiers = hostNode.modifiers;\n    const isDefault = !!modifiers\n        && modifiers.some(x => x.kind === ts.SyntaxKind.DefaultKeyword);\n    const newStatement = [];\n    newStatement.push(ts.createVariableStatement(isDefault ? undefined : modifiers, ts.createVariableDeclarationList([\n        ts.createVariableDeclaration(name, undefined, pureIife),\n    ], ts.NodeFlags.Let)));\n    if (isDefault) {\n        newStatement.push(ts.createExportAssignment(undefined, undefined, false, ts.createIdentifier(name)));\n    }\n    return newStatement;\n}\n"]},"metadata":{},"sourceType":"script"}