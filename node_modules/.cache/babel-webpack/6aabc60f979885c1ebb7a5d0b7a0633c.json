{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar identifierUtils = require(\"./util/identifier\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {Record<number, number>=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\n\nvar RecordIdsPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {Object} options Options object\n   * @param {boolean=} options.portableIds true, when ids need to be portable\n   */\n  function RecordIdsPlugin(options) {\n    _classCallCheck(this, RecordIdsPlugin);\n\n    this.options = options || {};\n  }\n  /**\n   * @param {Compiler} compiler the Compiler\n   * @returns {void}\n   */\n\n\n  _createClass(RecordIdsPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var portableIds = this.options.portableIds;\n      compiler.hooks.compilation.tap(\"RecordIdsPlugin\", function (compilation) {\n        compilation.hooks.recordModules.tap(\"RecordIdsPlugin\",\n        /**\n         * @param {Module[]} modules the modules array\n         * @param {Records} records the records object\n         * @returns {void}\n         */\n        function (modules, records) {\n          if (!records.modules) records.modules = {};\n          if (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n          if (!records.modules.usedIds) records.modules.usedIds = {};\n\n          var _iterator = _createForOfIteratorHelper(modules),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _module = _step.value;\n              if (typeof _module.id !== \"number\") continue;\n              var identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, _module.identifier(), compilation.cache) : _module.identifier();\n              records.modules.byIdentifier[identifier] = _module.id;\n              records.modules.usedIds[_module.id] = _module.id;\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        });\n        compilation.hooks.reviveModules.tap(\"RecordIdsPlugin\",\n        /**\n         * @param {Module[]} modules the modules array\n         * @param {Records} records the records object\n         * @returns {void}\n         */\n        function (modules, records) {\n          if (!records.modules) return;\n\n          if (records.modules.byIdentifier) {\n            /** @type {Set<number>} */\n            var usedIds = new Set();\n\n            var _iterator2 = _createForOfIteratorHelper(modules),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var _module2 = _step2.value;\n                if (_module2.id !== null) continue;\n                var identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, _module2.identifier(), compilation.cache) : _module2.identifier();\n                var id = records.modules.byIdentifier[identifier];\n                if (id === undefined) continue;\n                if (usedIds.has(id)) continue;\n                usedIds.add(id);\n                _module2.id = id;\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n\n          if (Array.isArray(records.modules.usedIds)) {\n            compilation.usedModuleIds = new Set(records.modules.usedIds);\n          }\n        });\n        /**\n         * @param {Module} module the module\n         * @returns {string} the (portable) identifier\n         */\n\n        var getModuleIdentifier = function getModuleIdentifier(module) {\n          if (portableIds) {\n            return identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache);\n          }\n\n          return module.identifier();\n        };\n        /**\n         * @param {Chunk} chunk the chunk\n         * @returns {string[]} sources of the chunk\n         */\n\n\n        var getChunkSources = function getChunkSources(chunk) {\n          /** @type {string[]} */\n          var sources = [];\n\n          var _iterator3 = _createForOfIteratorHelper(chunk.groupsIterable),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var chunkGroup = _step3.value;\n              var index = chunkGroup.chunks.indexOf(chunk);\n\n              if (chunkGroup.name) {\n                sources.push(\"\".concat(index, \" \").concat(chunkGroup.name));\n              } else {\n                var _iterator4 = _createForOfIteratorHelper(chunkGroup.origins),\n                    _step4;\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    var origin = _step4.value;\n\n                    if (origin.module) {\n                      if (origin.request) {\n                        sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(origin.request));\n                      } else if (typeof origin.loc === \"string\") {\n                        sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(origin.loc));\n                      } else if (origin.loc && typeof origin.loc === \"object\" && origin.loc.start) {\n                        sources.push(\"\".concat(index, \" \").concat(getModuleIdentifier(origin.module), \" \").concat(JSON.stringify(origin.loc.start)));\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          return sources;\n        };\n\n        compilation.hooks.recordChunks.tap(\"RecordIdsPlugin\",\n        /**\n         * @param {Chunk[]} chunks the chunks array\n         * @param {Records} records the records object\n         * @returns {void}\n         */\n        function (chunks, records) {\n          if (!records.chunks) records.chunks = {};\n          if (!records.chunks.byName) records.chunks.byName = {};\n          if (!records.chunks.bySource) records.chunks.bySource = {};\n          /** @type {Set<number>} */\n\n          var usedIds = new Set();\n\n          var _iterator5 = _createForOfIteratorHelper(chunks),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var chunk = _step5.value;\n              if (typeof chunk.id !== \"number\") continue;\n              var name = chunk.name;\n              if (name) records.chunks.byName[name] = chunk.id;\n              var sources = getChunkSources(chunk);\n\n              var _iterator6 = _createForOfIteratorHelper(sources),\n                  _step6;\n\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var source = _step6.value;\n                  records.chunks.bySource[source] = chunk.id;\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n\n              usedIds.add(chunk.id);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          records.chunks.usedIds = Array.from(usedIds).sort();\n        });\n        compilation.hooks.reviveChunks.tap(\"RecordIdsPlugin\",\n        /**\n         * @param {Chunk[]} chunks the chunks array\n         * @param {Records} records the records object\n         * @returns {void}\n         */\n        function (chunks, records) {\n          if (!records.chunks) return;\n          /** @type {Set<number>} */\n\n          var usedIds = new Set();\n\n          if (records.chunks.byName) {\n            var _iterator7 = _createForOfIteratorHelper(chunks),\n                _step7;\n\n            try {\n              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                var chunk = _step7.value;\n                if (chunk.id !== null) continue;\n                if (!chunk.name) continue;\n                var id = records.chunks.byName[chunk.name];\n                if (id === undefined) continue;\n                if (usedIds.has(id)) continue;\n                usedIds.add(id);\n                chunk.id = id;\n              }\n            } catch (err) {\n              _iterator7.e(err);\n            } finally {\n              _iterator7.f();\n            }\n          }\n\n          if (records.chunks.bySource) {\n            var _iterator8 = _createForOfIteratorHelper(chunks),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var _chunk = _step8.value;\n                var sources = getChunkSources(_chunk);\n\n                var _iterator9 = _createForOfIteratorHelper(sources),\n                    _step9;\n\n                try {\n                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                    var source = _step9.value;\n                    var _id = records.chunks.bySource[source];\n                    if (_id === undefined) continue;\n                    if (usedIds.has(_id)) continue;\n                    usedIds.add(_id);\n                    _chunk.id = _id;\n                    break;\n                  }\n                } catch (err) {\n                  _iterator9.e(err);\n                } finally {\n                  _iterator9.f();\n                }\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n\n          if (Array.isArray(records.chunks.usedIds)) {\n            compilation.usedChunkIds = new Set(records.chunks.usedIds);\n          }\n        });\n      });\n    }\n  }]);\n\n  return RecordIdsPlugin;\n}();\n\nmodule.exports = RecordIdsPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/RecordIdsPlugin.js"],"names":["identifierUtils","require","RecordIdsPlugin","options","compiler","portableIds","hooks","compilation","tap","recordModules","modules","records","byIdentifier","usedIds","module","id","identifier","makePathsRelative","context","cache","reviveModules","Set","undefined","has","add","Array","isArray","usedModuleIds","getModuleIdentifier","getChunkSources","chunk","sources","groupsIterable","chunkGroup","index","chunks","indexOf","name","push","origins","origin","request","loc","start","JSON","stringify","recordChunks","byName","bySource","source","from","sort","reviveChunks","usedChunkIds","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAEA,IAAMA,eAAe,GAAGC,OAAO,CAAC,mBAAD,CAA/B;AAEA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;IAEMC,e;AACL;AACD;AACA;AACA;AACC,2BAAYC,OAAZ,EAAqB;AAAA;;AACpB,SAAKA,OAAL,GAAeA,OAAO,IAAI,EAA1B;AACA;AAED;AACD;AACA;AACA;;;;;WACC,eAAMC,QAAN,EAAgB;AACf,UAAMC,WAAW,GAAG,KAAKF,OAAL,CAAaE,WAAjC;AACAD,MAAAA,QAAQ,CAACE,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,iBAA/B,EAAkD,UAAAD,WAAW,EAAI;AAChEA,QAAAA,WAAW,CAACD,KAAZ,CAAkBG,aAAlB,CAAgCD,GAAhC,CACC,iBADD;AAEC;AACJ;AACA;AACA;AACA;AACI,kBAACE,OAAD,EAAUC,OAAV,EAAsB;AACrB,cAAI,CAACA,OAAO,CAACD,OAAb,EAAsBC,OAAO,CAACD,OAAR,GAAkB,EAAlB;AACtB,cAAI,CAACC,OAAO,CAACD,OAAR,CAAgBE,YAArB,EAAmCD,OAAO,CAACD,OAAR,CAAgBE,YAAhB,GAA+B,EAA/B;AACnC,cAAI,CAACD,OAAO,CAACD,OAAR,CAAgBG,OAArB,EAA8BF,OAAO,CAACD,OAAR,CAAgBG,OAAhB,GAA0B,EAA1B;;AAHT,qDAIAH,OAJA;AAAA;;AAAA;AAIrB,gEAA8B;AAAA,kBAAnBI,OAAmB;AAC7B,kBAAI,OAAOA,OAAM,CAACC,EAAd,KAAqB,QAAzB,EAAmC;AACnC,kBAAMC,UAAU,GAAGX,WAAW,GAC3BL,eAAe,CAACiB,iBAAhB,CACAb,QAAQ,CAACc,OADT,EAEAJ,OAAM,CAACE,UAAP,EAFA,EAGAT,WAAW,CAACY,KAHZ,CAD2B,GAM3BL,OAAM,CAACE,UAAP,EANH;AAOAL,cAAAA,OAAO,CAACD,OAAR,CAAgBE,YAAhB,CAA6BI,UAA7B,IAA2CF,OAAM,CAACC,EAAlD;AACAJ,cAAAA,OAAO,CAACD,OAAR,CAAgBG,OAAhB,CAAwBC,OAAM,CAACC,EAA/B,IAAqCD,OAAM,CAACC,EAA5C;AACA;AAfoB;AAAA;AAAA;AAAA;AAAA;AAgBrB,SAvBF;AAyBAR,QAAAA,WAAW,CAACD,KAAZ,CAAkBc,aAAlB,CAAgCZ,GAAhC,CACC,iBADD;AAEC;AACJ;AACA;AACA;AACA;AACI,kBAACE,OAAD,EAAUC,OAAV,EAAsB;AACrB,cAAI,CAACA,OAAO,CAACD,OAAb,EAAsB;;AACtB,cAAIC,OAAO,CAACD,OAAR,CAAgBE,YAApB,EAAkC;AACjC;AACA,gBAAMC,OAAO,GAAG,IAAIQ,GAAJ,EAAhB;;AAFiC,wDAGZX,OAHY;AAAA;;AAAA;AAGjC,qEAA8B;AAAA,oBAAnBI,QAAmB;AAC7B,oBAAIA,QAAM,CAACC,EAAP,KAAc,IAAlB,EAAwB;AACxB,oBAAMC,UAAU,GAAGX,WAAW,GAC3BL,eAAe,CAACiB,iBAAhB,CACAb,QAAQ,CAACc,OADT,EAEAJ,QAAM,CAACE,UAAP,EAFA,EAGAT,WAAW,CAACY,KAHZ,CAD2B,GAM3BL,QAAM,CAACE,UAAP,EANH;AAOA,oBAAMD,EAAE,GAAGJ,OAAO,CAACD,OAAR,CAAgBE,YAAhB,CAA6BI,UAA7B,CAAX;AACA,oBAAID,EAAE,KAAKO,SAAX,EAAsB;AACtB,oBAAIT,OAAO,CAACU,GAAR,CAAYR,EAAZ,CAAJ,EAAqB;AACrBF,gBAAAA,OAAO,CAACW,GAAR,CAAYT,EAAZ;AACAD,gBAAAA,QAAM,CAACC,EAAP,GAAYA,EAAZ;AACA;AAjBgC;AAAA;AAAA;AAAA;AAAA;AAkBjC;;AACD,cAAIU,KAAK,CAACC,OAAN,CAAcf,OAAO,CAACD,OAAR,CAAgBG,OAA9B,CAAJ,EAA4C;AAC3CN,YAAAA,WAAW,CAACoB,aAAZ,GAA4B,IAAIN,GAAJ,CAAQV,OAAO,CAACD,OAAR,CAAgBG,OAAxB,CAA5B;AACA;AACD,SA/BF;AAkCA;AACH;AACA;AACA;;AACG,YAAMe,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAAd,MAAM,EAAI;AACrC,cAAIT,WAAJ,EAAiB;AAChB,mBAAOL,eAAe,CAACiB,iBAAhB,CACNb,QAAQ,CAACc,OADH,EAENJ,MAAM,CAACE,UAAP,EAFM,EAGNT,WAAW,CAACY,KAHN,CAAP;AAKA;;AACD,iBAAOL,MAAM,CAACE,UAAP,EAAP;AACA,SATD;AAWA;AACH;AACA;AACA;;;AACG,YAAMa,eAAe,GAAG,SAAlBA,eAAkB,CAAAC,KAAK,EAAI;AAChC;AACA,cAAMC,OAAO,GAAG,EAAhB;;AAFgC,sDAGPD,KAAK,CAACE,cAHC;AAAA;;AAAA;AAGhC,mEAA+C;AAAA,kBAApCC,UAAoC;AAC9C,kBAAMC,KAAK,GAAGD,UAAU,CAACE,MAAX,CAAkBC,OAAlB,CAA0BN,KAA1B,CAAd;;AACA,kBAAIG,UAAU,CAACI,IAAf,EAAqB;AACpBN,gBAAAA,OAAO,CAACO,IAAR,WAAgBJ,KAAhB,cAAyBD,UAAU,CAACI,IAApC;AACA,eAFD,MAEO;AAAA,4DACeJ,UAAU,CAACM,OAD1B;AAAA;;AAAA;AACN,yEAAyC;AAAA,wBAA9BC,MAA8B;;AACxC,wBAAIA,MAAM,CAAC1B,MAAX,EAAmB;AAClB,0BAAI0B,MAAM,CAACC,OAAX,EAAoB;AACnBV,wBAAAA,OAAO,CAACO,IAAR,WACIJ,KADJ,cACaN,mBAAmB,CAACY,MAAM,CAAC1B,MAAR,CADhC,cAEE0B,MAAM,CAACC,OAFT;AAKA,uBAND,MAMO,IAAI,OAAOD,MAAM,CAACE,GAAd,KAAsB,QAA1B,EAAoC;AAC1CX,wBAAAA,OAAO,CAACO,IAAR,WACIJ,KADJ,cACaN,mBAAmB,CAACY,MAAM,CAAC1B,MAAR,CADhC,cAEE0B,MAAM,CAACE,GAFT;AAKA,uBANM,MAMA,IACNF,MAAM,CAACE,GAAP,IACA,OAAOF,MAAM,CAACE,GAAd,KAAsB,QADtB,IAEAF,MAAM,CAACE,GAAP,CAAWC,KAHL,EAIL;AACDZ,wBAAAA,OAAO,CAACO,IAAR,WACIJ,KADJ,cACaN,mBAAmB,CAC9BY,MAAM,CAAC1B,MADuB,CADhC,cAGM8B,IAAI,CAACC,SAAL,CAAeL,MAAM,CAACE,GAAP,CAAWC,KAA1B,CAHN;AAKA;AACD;AACD;AA3BK;AAAA;AAAA;AAAA;AAAA;AA4BN;AACD;AApC+B;AAAA;AAAA;AAAA;AAAA;;AAqChC,iBAAOZ,OAAP;AACA,SAtCD;;AAwCAxB,QAAAA,WAAW,CAACD,KAAZ,CAAkBwC,YAAlB,CAA+BtC,GAA/B,CACC,iBADD;AAEC;AACJ;AACA;AACA;AACA;AACI,kBAAC2B,MAAD,EAASxB,OAAT,EAAqB;AACpB,cAAI,CAACA,OAAO,CAACwB,MAAb,EAAqBxB,OAAO,CAACwB,MAAR,GAAiB,EAAjB;AACrB,cAAI,CAACxB,OAAO,CAACwB,MAAR,CAAeY,MAApB,EAA4BpC,OAAO,CAACwB,MAAR,CAAeY,MAAf,GAAwB,EAAxB;AAC5B,cAAI,CAACpC,OAAO,CAACwB,MAAR,CAAea,QAApB,EAA8BrC,OAAO,CAACwB,MAAR,CAAea,QAAf,GAA0B,EAA1B;AAC9B;;AACA,cAAMnC,OAAO,GAAG,IAAIQ,GAAJ,EAAhB;;AALoB,sDAMAc,MANA;AAAA;;AAAA;AAMpB,mEAA4B;AAAA,kBAAjBL,KAAiB;AAC3B,kBAAI,OAAOA,KAAK,CAACf,EAAb,KAAoB,QAAxB,EAAkC;AAClC,kBAAMsB,IAAI,GAAGP,KAAK,CAACO,IAAnB;AACA,kBAAIA,IAAJ,EAAU1B,OAAO,CAACwB,MAAR,CAAeY,MAAf,CAAsBV,IAAtB,IAA8BP,KAAK,CAACf,EAApC;AACV,kBAAMgB,OAAO,GAAGF,eAAe,CAACC,KAAD,CAA/B;;AAJ2B,0DAKNC,OALM;AAAA;;AAAA;AAK3B,uEAA8B;AAAA,sBAAnBkB,MAAmB;AAC7BtC,kBAAAA,OAAO,CAACwB,MAAR,CAAea,QAAf,CAAwBC,MAAxB,IAAkCnB,KAAK,CAACf,EAAxC;AACA;AAP0B;AAAA;AAAA;AAAA;AAAA;;AAQ3BF,cAAAA,OAAO,CAACW,GAAR,CAAYM,KAAK,CAACf,EAAlB;AACA;AAfmB;AAAA;AAAA;AAAA;AAAA;;AAgBpBJ,UAAAA,OAAO,CAACwB,MAAR,CAAetB,OAAf,GAAyBY,KAAK,CAACyB,IAAN,CAAWrC,OAAX,EAAoBsC,IAApB,EAAzB;AACA,SAxBF;AA0BA5C,QAAAA,WAAW,CAACD,KAAZ,CAAkB8C,YAAlB,CAA+B5C,GAA/B,CACC,iBADD;AAEC;AACJ;AACA;AACA;AACA;AACI,kBAAC2B,MAAD,EAASxB,OAAT,EAAqB;AACpB,cAAI,CAACA,OAAO,CAACwB,MAAb,EAAqB;AACrB;;AACA,cAAMtB,OAAO,GAAG,IAAIQ,GAAJ,EAAhB;;AACA,cAAIV,OAAO,CAACwB,MAAR,CAAeY,MAAnB,EAA2B;AAAA,wDACNZ,MADM;AAAA;;AAAA;AAC1B,qEAA4B;AAAA,oBAAjBL,KAAiB;AAC3B,oBAAIA,KAAK,CAACf,EAAN,KAAa,IAAjB,EAAuB;AACvB,oBAAI,CAACe,KAAK,CAACO,IAAX,EAAiB;AACjB,oBAAMtB,EAAE,GAAGJ,OAAO,CAACwB,MAAR,CAAeY,MAAf,CAAsBjB,KAAK,CAACO,IAA5B,CAAX;AACA,oBAAItB,EAAE,KAAKO,SAAX,EAAsB;AACtB,oBAAIT,OAAO,CAACU,GAAR,CAAYR,EAAZ,CAAJ,EAAqB;AACrBF,gBAAAA,OAAO,CAACW,GAAR,CAAYT,EAAZ;AACAe,gBAAAA,KAAK,CAACf,EAAN,GAAWA,EAAX;AACA;AATyB;AAAA;AAAA;AAAA;AAAA;AAU1B;;AACD,cAAIJ,OAAO,CAACwB,MAAR,CAAea,QAAnB,EAA6B;AAAA,wDACRb,MADQ;AAAA;;AAAA;AAC5B,qEAA4B;AAAA,oBAAjBL,MAAiB;AAC3B,oBAAMC,OAAO,GAAGF,eAAe,CAACC,MAAD,CAA/B;;AAD2B,4DAENC,OAFM;AAAA;;AAAA;AAE3B,yEAA8B;AAAA,wBAAnBkB,MAAmB;AAC7B,wBAAMlC,GAAE,GAAGJ,OAAO,CAACwB,MAAR,CAAea,QAAf,CAAwBC,MAAxB,CAAX;AACA,wBAAIlC,GAAE,KAAKO,SAAX,EAAsB;AACtB,wBAAIT,OAAO,CAACU,GAAR,CAAYR,GAAZ,CAAJ,EAAqB;AACrBF,oBAAAA,OAAO,CAACW,GAAR,CAAYT,GAAZ;AACAe,oBAAAA,MAAK,CAACf,EAAN,GAAWA,GAAX;AACA;AACA;AAT0B;AAAA;AAAA;AAAA;AAAA;AAU3B;AAX2B;AAAA;AAAA;AAAA;AAAA;AAY5B;;AACD,cAAIU,KAAK,CAACC,OAAN,CAAcf,OAAO,CAACwB,MAAR,CAAetB,OAA7B,CAAJ,EAA2C;AAC1CN,YAAAA,WAAW,CAAC8C,YAAZ,GAA2B,IAAIhC,GAAJ,CAAQV,OAAO,CAACwB,MAAR,CAAetB,OAAvB,CAA3B;AACA;AACD,SAtCF;AAwCA,OAzLD;AA0LA;;;;;;AAEFC,MAAM,CAACwC,OAAP,GAAiBpD,eAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {Record<number, number>=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\nclass RecordIdsPlugin {\n\t/**\n\t * @param {Object} options Options object\n\t * @param {boolean=} options.portableIds true, when ids need to be portable\n\t */\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the Compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst portableIds = this.options.portableIds;\n\t\tcompiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n\t\t\tcompilation.hooks.recordModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tif (!records.modules) records.modules = {};\n\t\t\t\t\tif (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n\t\t\t\t\tif (!records.modules.usedIds) records.modules.usedIds = {};\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tif (typeof module.id !== \"number\") continue;\n\t\t\t\t\t\tconst identifier = portableIds\n\t\t\t\t\t\t\t? identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t: module.identifier();\n\t\t\t\t\t\trecords.modules.byIdentifier[identifier] = module.id;\n\t\t\t\t\t\trecords.modules.usedIds[module.id] = module.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tif (!records.modules) return;\n\t\t\t\t\tif (records.modules.byIdentifier) {\n\t\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\tif (module.id !== null) continue;\n\t\t\t\t\t\t\tconst identifier = portableIds\n\t\t\t\t\t\t\t\t? identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t: module.identifier();\n\t\t\t\t\t\t\tconst id = records.modules.byIdentifier[identifier];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tmodule.id = id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.modules.usedIds)) {\n\t\t\t\t\t\tcompilation.usedModuleIds = new Set(records.modules.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {string} the (portable) identifier\n\t\t\t */\n\t\t\tconst getModuleIdentifier = module => {\n\t\t\t\tif (portableIds) {\n\t\t\t\t\treturn identifierUtils.makePathsRelative(\n\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn module.identifier();\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {string[]} sources of the chunk\n\t\t\t */\n\t\t\tconst getChunkSources = chunk => {\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tconst sources = [];\n\t\t\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\t\t\tconst index = chunkGroup.chunks.indexOf(chunk);\n\t\t\t\t\tif (chunkGroup.name) {\n\t\t\t\t\t\tsources.push(`${index} ${chunkGroup.name}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const origin of chunkGroup.origins) {\n\t\t\t\t\t\t\tif (origin.module) {\n\t\t\t\t\t\t\t\tif (origin.request) {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${\n\t\t\t\t\t\t\t\t\t\t\torigin.request\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (typeof origin.loc === \"string\") {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${\n\t\t\t\t\t\t\t\t\t\t\torigin.loc\n\t\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\torigin.loc &&\n\t\t\t\t\t\t\t\t\ttypeof origin.loc === \"object\" &&\n\t\t\t\t\t\t\t\t\torigin.loc.start\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(\n\t\t\t\t\t\t\t\t\t\t\torigin.module\n\t\t\t\t\t\t\t\t\t\t)} ${JSON.stringify(origin.loc.start)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sources;\n\t\t\t};\n\n\t\t\tcompilation.hooks.recordChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) records.chunks = {};\n\t\t\t\t\tif (!records.chunks.byName) records.chunks.byName = {};\n\t\t\t\t\tif (!records.chunks.bySource) records.chunks.bySource = {};\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tif (typeof chunk.id !== \"number\") continue;\n\t\t\t\t\t\tconst name = chunk.name;\n\t\t\t\t\t\tif (name) records.chunks.byName[name] = chunk.id;\n\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\trecords.chunks.bySource[source] = chunk.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t\trecords.chunks.usedIds = Array.from(usedIds).sort();\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) return;\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tif (records.chunks.byName) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tif (chunk.id !== null) continue;\n\t\t\t\t\t\t\tif (!chunk.name) continue;\n\t\t\t\t\t\t\tconst id = records.chunks.byName[chunk.name];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (records.chunks.bySource) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\t\tconst id = records.chunks.bySource[source];\n\t\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.chunks.usedIds)) {\n\t\t\t\t\t\tcompilation.usedChunkIds = new Set(records.chunks.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RecordIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}