{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/i18n/translation_bundle\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/core\", \"@angular/compiler/src/ml_parser/html_parser\", \"@angular/compiler/src/i18n/parse_util\", \"@angular/compiler/src/i18n/serializers/xml_helper\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TranslationBundle = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var html_parser_1 = require(\"@angular/compiler/src/ml_parser/html_parser\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/i18n/parse_util\");\n\n  var xml_helper_1 = require(\"@angular/compiler/src/i18n/serializers/xml_helper\");\n  /**\n   * A container for translated messages\n   */\n\n\n  var TranslationBundle =\n  /** @class */\n  function () {\n    function TranslationBundle(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console) {\n      if (_i18nNodesByMsgId === void 0) {\n        _i18nNodesByMsgId = {};\n      }\n\n      if (missingTranslationStrategy === void 0) {\n        missingTranslationStrategy = core_1.MissingTranslationStrategy.Warning;\n      }\n\n      this._i18nNodesByMsgId = _i18nNodesByMsgId;\n      this.digest = digest;\n      this.mapperFactory = mapperFactory;\n      this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n    } // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n\n\n    TranslationBundle.load = function (content, url, serializer, missingTranslationStrategy, console) {\n      var _a = serializer.load(content, url),\n          locale = _a.locale,\n          i18nNodesByMsgId = _a.i18nNodesByMsgId;\n\n      var digestFn = function digestFn(m) {\n        return serializer.digest(m);\n      };\n\n      var mapperFactory = function mapperFactory(m) {\n        return serializer.createNameMapper(m);\n      };\n\n      return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    }; // Returns the translation as HTML nodes from the given source message.\n\n\n    TranslationBundle.prototype.get = function (srcMsg) {\n      var html = this._i18nToHtml.convert(srcMsg);\n\n      if (html.errors.length) {\n        throw new Error(html.errors.join('\\n'));\n      }\n\n      return html.nodes;\n    };\n\n    TranslationBundle.prototype.has = function (srcMsg) {\n      return this.digest(srcMsg) in this._i18nNodesByMsgId;\n    };\n\n    return TranslationBundle;\n  }();\n\n  exports.TranslationBundle = TranslationBundle;\n\n  var I18nToHtmlVisitor =\n  /** @class */\n  function () {\n    function I18nToHtmlVisitor(_i18nNodesByMsgId, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\n      if (_i18nNodesByMsgId === void 0) {\n        _i18nNodesByMsgId = {};\n      }\n\n      this._i18nNodesByMsgId = _i18nNodesByMsgId;\n      this._locale = _locale;\n      this._digest = _digest;\n      this._mapperFactory = _mapperFactory;\n      this._missingTranslationStrategy = _missingTranslationStrategy;\n      this._console = _console;\n      this._contextStack = [];\n      this._errors = [];\n    }\n\n    I18nToHtmlVisitor.prototype.convert = function (srcMsg) {\n      this._contextStack.length = 0;\n      this._errors.length = 0; // i18n to text\n\n      var text = this._convertToText(srcMsg); // text to html\n\n\n      var url = srcMsg.nodes[0].sourceSpan.start.file.url;\n      var html = new html_parser_1.HtmlParser().parse(text, url, {\n        tokenizeExpansionForms: true\n      });\n      return {\n        nodes: html.rootNodes,\n        errors: tslib_1.__spread(this._errors, html.errors)\n      };\n    };\n\n    I18nToHtmlVisitor.prototype.visitText = function (text, context) {\n      // `convert()` uses an `HtmlParser` to return `html.Node`s\n      // we should then make sure that any special characters are escaped\n      return xml_helper_1.escapeXml(text.value);\n    };\n\n    I18nToHtmlVisitor.prototype.visitContainer = function (container, context) {\n      var _this = this;\n\n      return container.children.map(function (n) {\n        return n.visit(_this);\n      }).join('');\n    };\n\n    I18nToHtmlVisitor.prototype.visitIcu = function (icu, context) {\n      var _this = this;\n\n      var cases = Object.keys(icu.cases).map(function (k) {\n        return k + \" {\" + icu.cases[k].visit(_this) + \"}\";\n      }); // TODO(vicb): Once all format switch to using expression placeholders\n      // we should throw when the placeholder is not in the source message\n\n      var exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ? this._srcMsg.placeholders[icu.expression].text : icu.expression;\n      return \"{\" + exp + \", \" + icu.type + \", \" + cases.join(' ') + \"}\";\n    };\n\n    I18nToHtmlVisitor.prototype.visitPlaceholder = function (ph, context) {\n      var phName = this._mapper(ph.name);\n\n      if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n        return this._srcMsg.placeholders[phName].text;\n      }\n\n      if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n        return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n      }\n\n      this._addError(ph, \"Unknown placeholder \\\"\" + ph.name + \"\\\"\");\n\n      return '';\n    }; // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n\n\n    I18nToHtmlVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n      var _this = this;\n\n      var tag = \"\" + ph.tag;\n      var attrs = Object.keys(ph.attrs).map(function (name) {\n        return name + \"=\\\"\" + ph.attrs[name] + \"\\\"\";\n      }).join(' ');\n\n      if (ph.isVoid) {\n        return \"<\" + tag + \" \" + attrs + \"/>\";\n      }\n\n      var children = ph.children.map(function (c) {\n        return c.visit(_this);\n      }).join('');\n      return \"<\" + tag + \" \" + attrs + \">\" + children + \"</\" + tag + \">\";\n    }; // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n\n\n    I18nToHtmlVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n      // An ICU placeholder references the source message to be serialized\n      return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    };\n    /**\n     * Convert a source message to a translated text string:\n     * - text nodes are replaced with their translation,\n     * - placeholders are replaced with their content,\n     * - ICU nodes are converted to ICU expressions.\n     */\n\n\n    I18nToHtmlVisitor.prototype._convertToText = function (srcMsg) {\n      var _this = this;\n\n      var id = this._digest(srcMsg);\n\n      var mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n      var nodes;\n\n      this._contextStack.push({\n        msg: this._srcMsg,\n        mapper: this._mapper\n      });\n\n      this._srcMsg = srcMsg;\n\n      if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n        // When there is a translation use its nodes as the source\n        // And create a mapper to convert serialized placeholder names to internal names\n        nodes = this._i18nNodesByMsgId[id];\n\n        this._mapper = function (name) {\n          return mapper ? mapper.toInternalName(name) : name;\n        };\n      } else {\n        // When no translation has been found\n        // - report an error / a warning / nothing,\n        // - use the nodes from the original message\n        // - placeholders are already internal and need no mapper\n        if (this._missingTranslationStrategy === core_1.MissingTranslationStrategy.Error) {\n          var ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n\n          this._addError(srcMsg.nodes[0], \"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n        } else if (this._console && this._missingTranslationStrategy === core_1.MissingTranslationStrategy.Warning) {\n          var ctx = this._locale ? \" for locale \\\"\" + this._locale + \"\\\"\" : '';\n\n          this._console.warn(\"Missing translation for message \\\"\" + id + \"\\\"\" + ctx);\n        }\n\n        nodes = srcMsg.nodes;\n\n        this._mapper = function (name) {\n          return name;\n        };\n      }\n\n      var text = nodes.map(function (node) {\n        return node.visit(_this);\n      }).join('');\n\n      var context = this._contextStack.pop();\n\n      this._srcMsg = context.msg;\n      this._mapper = context.mapper;\n      return text;\n    };\n\n    I18nToHtmlVisitor.prototype._addError = function (el, msg) {\n      this._errors.push(new parse_util_1.I18nError(el.sourceSpan, msg));\n    };\n\n    return I18nToHtmlVisitor;\n  }();\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/i18n/translation_bundle.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {MissingTranslationStrategy} from '../core';\nimport * as html from '../ml_parser/ast';\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {Console} from '../util';\n\nimport * as i18n from './i18n_ast';\nimport {I18nError} from './parse_util';\nimport {PlaceholderMapper, Serializer} from './serializers/serializer';\nimport {escapeXml} from './serializers/xml_helper';\n\n\n/**\n * A container for translated messages\n */\nexport class TranslationBundle {\n  private _i18nToHtml: I18nToHtmlVisitor;\n\n  constructor(\n      private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {}, locale: string|null,\n      public digest: (m: i18n.Message) => string,\n      public mapperFactory?: (m: i18n.Message) => PlaceholderMapper,\n      missingTranslationStrategy: MissingTranslationStrategy = MissingTranslationStrategy.Warning,\n      console?: Console) {\n    this._i18nToHtml = new I18nToHtmlVisitor(\n        _i18nNodesByMsgId, locale, digest, mapperFactory!, missingTranslationStrategy, console);\n  }\n\n  // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n  static load(\n      content: string, url: string, serializer: Serializer,\n      missingTranslationStrategy: MissingTranslationStrategy,\n      console?: Console): TranslationBundle {\n    const {locale, i18nNodesByMsgId} = serializer.load(content, url);\n    const digestFn = (m: i18n.Message) => serializer.digest(m);\n    const mapperFactory = (m: i18n.Message) => serializer.createNameMapper(m)!;\n    return new TranslationBundle(\n        i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n  }\n\n  // Returns the translation as HTML nodes from the given source message.\n  get(srcMsg: i18n.Message): html.Node[] {\n    const html = this._i18nToHtml.convert(srcMsg);\n\n    if (html.errors.length) {\n      throw new Error(html.errors.join('\\n'));\n    }\n\n    return html.nodes;\n  }\n\n  has(srcMsg: i18n.Message): boolean {\n    return this.digest(srcMsg) in this._i18nNodesByMsgId;\n  }\n}\n\nclass I18nToHtmlVisitor implements i18n.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _srcMsg!: i18n.Message;\n  private _contextStack: {msg: i18n.Message, mapper: (name: string) => string}[] = [];\n  private _errors: I18nError[] = [];\n  // TODO(issue/24571): remove '!'.\n  private _mapper!: (name: string) => string;\n\n  constructor(\n      private _i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {}, private _locale: string|null,\n      private _digest: (m: i18n.Message) => string,\n      private _mapperFactory: (m: i18n.Message) => PlaceholderMapper,\n      private _missingTranslationStrategy: MissingTranslationStrategy, private _console?: Console) {\n  }\n\n  convert(srcMsg: i18n.Message): {nodes: html.Node[], errors: I18nError[]} {\n    this._contextStack.length = 0;\n    this._errors.length = 0;\n\n    // i18n to text\n    const text = this._convertToText(srcMsg);\n\n    // text to html\n    const url = srcMsg.nodes[0].sourceSpan.start.file.url;\n    const html = new HtmlParser().parse(text, url, {tokenizeExpansionForms: true});\n\n    return {\n      nodes: html.rootNodes,\n      errors: [...this._errors, ...html.errors],\n    };\n  }\n\n  visitText(text: i18n.Text, context?: any): string {\n    // `convert()` uses an `HtmlParser` to return `html.Node`s\n    // we should then make sure that any special characters are escaped\n    return escapeXml(text.value);\n  }\n\n  visitContainer(container: i18n.Container, context?: any): any {\n    return container.children.map(n => n.visit(this)).join('');\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): any {\n    const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\n\n    // TODO(vicb): Once all format switch to using expression placeholders\n    // we should throw when the placeholder is not in the source message\n    const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\n        this._srcMsg.placeholders[icu.expression].text :\n        icu.expression;\n\n    return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): string {\n    const phName = this._mapper(ph.name);\n    if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n      return this._srcMsg.placeholders[phName].text;\n    }\n\n    if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n      return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n    }\n\n    this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\n    return '';\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): string {\n    const tag = `${ph.tag}`;\n    const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\n    if (ph.isVoid) {\n      return `<${tag} ${attrs}/>`;\n    }\n    const children = ph.children.map((c: i18n.Node) => c.visit(this)).join('');\n    return `<${tag} ${attrs}>${children}</${tag}>`;\n  }\n\n  // Loaded message contains only placeholders (vs tag and icu placeholders).\n  // However when a translation can not be found, we need to serialize the source message\n  // which can contain tag placeholders\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): string {\n    // An ICU placeholder references the source message to be serialized\n    return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n  }\n\n  /**\n   * Convert a source message to a translated text string:\n   * - text nodes are replaced with their translation,\n   * - placeholders are replaced with their content,\n   * - ICU nodes are converted to ICU expressions.\n   */\n  private _convertToText(srcMsg: i18n.Message): string {\n    const id = this._digest(srcMsg);\n    const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n    let nodes: i18n.Node[];\n\n    this._contextStack.push({msg: this._srcMsg, mapper: this._mapper});\n    this._srcMsg = srcMsg;\n\n    if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n      // When there is a translation use its nodes as the source\n      // And create a mapper to convert serialized placeholder names to internal names\n      nodes = this._i18nNodesByMsgId[id];\n      this._mapper = (name: string) => mapper ? mapper.toInternalName(name)! : name;\n    } else {\n      // When no translation has been found\n      // - report an error / a warning / nothing,\n      // - use the nodes from the original message\n      // - placeholders are already internal and need no mapper\n      if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\n      } else if (\n          this._console &&\n          this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n        const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\n        this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\n      }\n      nodes = srcMsg.nodes;\n      this._mapper = (name: string) => name;\n    }\n    const text = nodes.map(node => node.visit(this)).join('');\n    const context = this._contextStack.pop()!;\n    this._srcMsg = context.msg;\n    this._mapper = context.mapper;\n    return text;\n  }\n\n  private _addError(el: i18n.Node, msg: string) {\n    this._errors.push(new I18nError(el.sourceSpan, msg));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}