{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/oob\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.OutOfBandDiagnosticRecorderImpl = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var diagnostics_2 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\");\n\n  var OutOfBandDiagnosticRecorderImpl =\n  /** @class */\n  function () {\n    function OutOfBandDiagnosticRecorderImpl(resolver) {\n      this.resolver = resolver;\n      this._diagnostics = [];\n      /**\n       * Tracks which `BindingPipe` nodes have already been recorded as invalid, so only one diagnostic\n       * is ever produced per node.\n       */\n\n      this.recordedPipes = new Set();\n    }\n\n    Object.defineProperty(OutOfBandDiagnosticRecorderImpl.prototype, \"diagnostics\", {\n      get: function get() {\n        return this._diagnostics;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    OutOfBandDiagnosticRecorderImpl.prototype.missingReferenceTarget = function (templateId, ref) {\n      var mapping = this.resolver.getSourceMapping(templateId);\n      var value = ref.value.trim();\n      var errorMsg = \"No directive found with exportAs '\" + value + \"'.\";\n\n      this._diagnostics.push(diagnostics_2.makeTemplateDiagnostic(templateId, mapping, ref.valueSpan || ref.sourceSpan, ts.DiagnosticCategory.Error, diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));\n    };\n\n    OutOfBandDiagnosticRecorderImpl.prototype.missingPipe = function (templateId, ast) {\n      if (this.recordedPipes.has(ast)) {\n        return;\n      }\n\n      var mapping = this.resolver.getSourceMapping(templateId);\n      var errorMsg = \"No pipe found with name '\" + ast.name + \"'.\";\n      var sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);\n\n      if (sourceSpan === null) {\n        throw new Error(\"Assertion failure: no SourceLocation found for usage of pipe '\" + ast.name + \"'.\");\n      }\n\n      this._diagnostics.push(diagnostics_2.makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error, diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.MISSING_PIPE), errorMsg));\n\n      this.recordedPipes.add(ast);\n    };\n\n    OutOfBandDiagnosticRecorderImpl.prototype.illegalAssignmentToTemplateVar = function (templateId, assignment, target) {\n      var mapping = this.resolver.getSourceMapping(templateId);\n      var errorMsg = \"Cannot use variable '\" + assignment.name + \"' as the left-hand side of an assignment expression. Template variables are read-only.\";\n      var sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);\n\n      if (sourceSpan === null) {\n        throw new Error(\"Assertion failure: no SourceLocation found for property binding.\");\n      }\n\n      this._diagnostics.push(diagnostics_2.makeTemplateDiagnostic(templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error, diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, {\n        text: \"The variable \" + assignment.name + \" is declared here.\",\n        span: target.valueSpan || target.sourceSpan\n      }));\n    };\n\n    OutOfBandDiagnosticRecorderImpl.prototype.duplicateTemplateVar = function (templateId, variable, firstDecl) {\n      var mapping = this.resolver.getSourceMapping(templateId);\n      var errorMsg = \"Cannot redeclare variable '\" + variable.name + \"' as it was previously declared elsewhere for the same template.\"; // The allocation of the error here is pretty useless for variables declared in microsyntax,\n      // since the sourceSpan refers to the entire microsyntax property, not a span for the specific\n      // variable in question.\n      //\n      // TODO(alxhub): allocate to a tighter span once one is available.\n\n      this._diagnostics.push(diagnostics_2.makeTemplateDiagnostic(templateId, mapping, variable.sourceSpan, ts.DiagnosticCategory.Error, diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, {\n        text: \"The variable '\" + firstDecl.name + \"' was first declared here.\",\n        span: firstDecl.sourceSpan\n      }));\n    };\n\n    OutOfBandDiagnosticRecorderImpl.prototype.requiresInlineTcb = function (templateId, node) {\n      this._diagnostics.push(makeInlineDiagnostic(templateId, diagnostics_1.ErrorCode.INLINE_TCB_REQUIRED, node.name, \"This component requires inline template type-checking, which is not supported by the current environment.\"));\n    };\n\n    OutOfBandDiagnosticRecorderImpl.prototype.requiresInlineTypeConstructors = function (templateId, node, directives) {\n      var message;\n\n      if (directives.length > 1) {\n        message = \"This component uses directives which require inline type constructors, which are not supported by the current environment.\";\n      } else {\n        message = \"This component uses a directive which requires an inline type constructor, which is not supported by the current environment.\";\n      }\n\n      this._diagnostics.push(makeInlineDiagnostic(templateId, diagnostics_1.ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message, directives.map(function (dir) {\n        return diagnostics_1.makeRelatedInformation(dir.name, \"Requires an inline type constructor.\");\n      })));\n    };\n\n    OutOfBandDiagnosticRecorderImpl.prototype.suboptimalTypeInference = function (templateId, variables) {\n      var e_1, _a;\n\n      var mapping = this.resolver.getSourceMapping(templateId); // Select one of the template variables that's most suitable for reporting the diagnostic. Any\n      // variable will do, but prefer one bound to the context's $implicit if present.\n\n      var diagnosticVar = null;\n\n      try {\n        for (var variables_1 = tslib_1.__values(variables), variables_1_1 = variables_1.next(); !variables_1_1.done; variables_1_1 = variables_1.next()) {\n          var variable = variables_1_1.value;\n\n          if (diagnosticVar === null || variable.value === '' || variable.value === '$implicit') {\n            diagnosticVar = variable;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (variables_1_1 && !variables_1_1.done && (_a = variables_1.return)) _a.call(variables_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      if (diagnosticVar === null) {\n        // There is no variable on which to report the diagnostic.\n        return;\n      }\n\n      var varIdentification = \"'\" + diagnosticVar.name + \"'\";\n\n      if (variables.length === 2) {\n        varIdentification += \" (and 1 other)\";\n      } else if (variables.length > 2) {\n        varIdentification += \" (and \" + (variables.length - 1) + \" others)\";\n      }\n\n      var message = \"This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable \" + varIdentification + \" will have type 'any' as a result.\\n\\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.\";\n\n      this._diagnostics.push(diagnostics_2.makeTemplateDiagnostic(templateId, mapping, diagnosticVar.keySpan, ts.DiagnosticCategory.Suggestion, diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));\n    };\n\n    return OutOfBandDiagnosticRecorderImpl;\n  }();\n\n  exports.OutOfBandDiagnosticRecorderImpl = OutOfBandDiagnosticRecorderImpl;\n\n  function makeInlineDiagnostic(templateId, code, node, messageText, relatedInformation) {\n    return tslib_1.__assign(tslib_1.__assign({}, diagnostics_1.makeDiagnostic(code, node, messageText, relatedInformation)), {\n      componentFile: node.getSourceFile(),\n      templateId: templateId\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/oob.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BindingPipe, PropertyWrite, TmplAstReference, TmplAstVariable} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, makeDiagnostic, makeRelatedInformation, ngErrorCode} from '../../diagnostics';\nimport {ClassDeclaration} from '../../reflection';\nimport {TemplateId} from '../api';\nimport {makeTemplateDiagnostic, TemplateDiagnostic} from '../diagnostics';\n\nimport {TemplateSourceResolver} from './tcb_util';\n\n\n\n/**\n * Collects `ts.Diagnostic`s on problems which occur in the template which aren't directly sourced\n * from Type Check Blocks.\n *\n * During the creation of a Type Check Block, the template is traversed and the\n * `OutOfBandDiagnosticRecorder` is called to record cases when a correct interpretation for the\n * template cannot be found. These operations create `ts.Diagnostic`s which are stored by the\n * recorder for later display.\n */\nexport interface OutOfBandDiagnosticRecorder {\n  readonly diagnostics: ReadonlyArray<TemplateDiagnostic>;\n\n  /**\n   * Reports a `#ref=\"target\"` expression in the template for which a target directive could not be\n   * found.\n   *\n   * @param templateId the template type-checking ID of the template which contains the broken\n   * reference.\n   * @param ref the `TmplAstReference` which could not be matched to a directive.\n   */\n  missingReferenceTarget(templateId: TemplateId, ref: TmplAstReference): void;\n\n  /**\n   * Reports usage of a `| pipe` expression in the template for which the named pipe could not be\n   * found.\n   *\n   * @param templateId the template type-checking ID of the template which contains the unknown\n   * pipe.\n   * @param ast the `BindingPipe` invocation of the pipe which could not be found.\n   */\n  missingPipe(templateId: TemplateId, ast: BindingPipe): void;\n\n  illegalAssignmentToTemplateVar(\n      templateId: TemplateId, assignment: PropertyWrite, target: TmplAstVariable): void;\n\n  /**\n   * Reports a duplicate declaration of a template variable.\n   *\n   * @param templateId the template type-checking ID of the template which contains the duplicate\n   * declaration.\n   * @param variable the `TmplAstVariable` which duplicates a previously declared variable.\n   * @param firstDecl the first variable declaration which uses the same name as `variable`.\n   */\n  duplicateTemplateVar(\n      templateId: TemplateId, variable: TmplAstVariable, firstDecl: TmplAstVariable): void;\n\n  requiresInlineTcb(templateId: TemplateId, node: ClassDeclaration): void;\n\n  requiresInlineTypeConstructors(\n      templateId: TemplateId, node: ClassDeclaration, directives: ClassDeclaration[]): void;\n\n  /**\n   * Report a warning when structural directives support context guards, but the current\n   * type-checking configuration prohibits their usage.\n   */\n  suboptimalTypeInference(templateId: TemplateId, variables: TmplAstVariable[]): void;\n}\n\nexport class OutOfBandDiagnosticRecorderImpl implements OutOfBandDiagnosticRecorder {\n  private _diagnostics: TemplateDiagnostic[] = [];\n\n  /**\n   * Tracks which `BindingPipe` nodes have already been recorded as invalid, so only one diagnostic\n   * is ever produced per node.\n   */\n  private recordedPipes = new Set<BindingPipe>();\n\n  constructor(private resolver: TemplateSourceResolver) {}\n\n  get diagnostics(): ReadonlyArray<TemplateDiagnostic> {\n    return this._diagnostics;\n  }\n\n  missingReferenceTarget(templateId: TemplateId, ref: TmplAstReference): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const value = ref.value.trim();\n\n    const errorMsg = `No directive found with exportAs '${value}'.`;\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, ref.valueSpan || ref.sourceSpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.MISSING_REFERENCE_TARGET), errorMsg));\n  }\n\n  missingPipe(templateId: TemplateId, ast: BindingPipe): void {\n    if (this.recordedPipes.has(ast)) {\n      return;\n    }\n\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `No pipe found with name '${ast.name}'.`;\n\n    const sourceSpan = this.resolver.toParseSourceSpan(templateId, ast.nameSpan);\n    if (sourceSpan === null) {\n      throw new Error(\n          `Assertion failure: no SourceLocation found for usage of pipe '${ast.name}'.`);\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.MISSING_PIPE), errorMsg));\n    this.recordedPipes.add(ast);\n  }\n\n  illegalAssignmentToTemplateVar(\n      templateId: TemplateId, assignment: PropertyWrite, target: TmplAstVariable): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `Cannot use variable '${\n        assignment\n            .name}' as the left-hand side of an assignment expression. Template variables are read-only.`;\n\n    const sourceSpan = this.resolver.toParseSourceSpan(templateId, assignment.sourceSpan);\n    if (sourceSpan === null) {\n      throw new Error(`Assertion failure: no SourceLocation found for property binding.`);\n    }\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, sourceSpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.WRITE_TO_READ_ONLY_VARIABLE), errorMsg, {\n          text: `The variable ${assignment.name} is declared here.`,\n          span: target.valueSpan || target.sourceSpan,\n        }));\n  }\n\n  duplicateTemplateVar(\n      templateId: TemplateId, variable: TmplAstVariable, firstDecl: TmplAstVariable): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n    const errorMsg = `Cannot redeclare variable '${\n        variable.name}' as it was previously declared elsewhere for the same template.`;\n\n    // The allocation of the error here is pretty useless for variables declared in microsyntax,\n    // since the sourceSpan refers to the entire microsyntax property, not a span for the specific\n    // variable in question.\n    //\n    // TODO(alxhub): allocate to a tighter span once one is available.\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, variable.sourceSpan, ts.DiagnosticCategory.Error,\n        ngErrorCode(ErrorCode.DUPLICATE_VARIABLE_DECLARATION), errorMsg, {\n          text: `The variable '${firstDecl.name}' was first declared here.`,\n          span: firstDecl.sourceSpan,\n        }));\n  }\n\n  requiresInlineTcb(templateId: TemplateId, node: ClassDeclaration): void {\n    this._diagnostics.push(makeInlineDiagnostic(\n        templateId, ErrorCode.INLINE_TCB_REQUIRED, node.name,\n        `This component requires inline template type-checking, which is not supported by the current environment.`));\n  }\n\n  requiresInlineTypeConstructors(\n      templateId: TemplateId, node: ClassDeclaration, directives: ClassDeclaration[]): void {\n    let message: string;\n    if (directives.length > 1) {\n      message =\n          `This component uses directives which require inline type constructors, which are not supported by the current environment.`;\n    } else {\n      message =\n          `This component uses a directive which requires an inline type constructor, which is not supported by the current environment.`;\n    }\n\n    this._diagnostics.push(makeInlineDiagnostic(\n        templateId, ErrorCode.INLINE_TYPE_CTOR_REQUIRED, node.name, message,\n        directives.map(\n            dir => makeRelatedInformation(dir.name, `Requires an inline type constructor.`))));\n  }\n\n  suboptimalTypeInference(templateId: TemplateId, variables: TmplAstVariable[]): void {\n    const mapping = this.resolver.getSourceMapping(templateId);\n\n    // Select one of the template variables that's most suitable for reporting the diagnostic. Any\n    // variable will do, but prefer one bound to the context's $implicit if present.\n    let diagnosticVar: TmplAstVariable|null = null;\n    for (const variable of variables) {\n      if (diagnosticVar === null || (variable.value === '' || variable.value === '$implicit')) {\n        diagnosticVar = variable;\n      }\n    }\n    if (diagnosticVar === null) {\n      // There is no variable on which to report the diagnostic.\n      return;\n    }\n\n    let varIdentification = `'${diagnosticVar.name}'`;\n    if (variables.length === 2) {\n      varIdentification += ` (and 1 other)`;\n    } else if (variables.length > 2) {\n      varIdentification += ` (and ${variables.length - 1} others)`;\n    }\n    const message =\n        `This structural directive supports advanced type inference, but the current compiler configuration prevents its usage. The variable ${\n            varIdentification} will have type 'any' as a result.\\n\\nConsider enabling the 'strictTemplates' option in your tsconfig.json for better type inference within this template.`;\n\n    this._diagnostics.push(makeTemplateDiagnostic(\n        templateId, mapping, diagnosticVar.keySpan, ts.DiagnosticCategory.Suggestion,\n        ngErrorCode(ErrorCode.SUGGEST_SUBOPTIMAL_TYPE_INFERENCE), message));\n  }\n}\n\nfunction makeInlineDiagnostic(\n    templateId: TemplateId, code: ErrorCode.INLINE_TCB_REQUIRED|ErrorCode.INLINE_TYPE_CTOR_REQUIRED,\n    node: ts.Node, messageText: string|ts.DiagnosticMessageChain,\n    relatedInformation?: ts.DiagnosticRelatedInformation[]): TemplateDiagnostic {\n  return {\n    ...makeDiagnostic(code, node, messageText, relatedInformation),\n    componentFile: node.getSourceFile(),\n    templateId,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}