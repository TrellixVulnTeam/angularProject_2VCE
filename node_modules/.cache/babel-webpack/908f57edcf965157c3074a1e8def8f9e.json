{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/entry_point/src/private_export_checker\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.checkForPrivateExports = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n  /**\n   * Produce `ts.Diagnostic`s for classes that are visible from exported types (e.g. directives\n   * exposed by exported `NgModule`s) that are not themselves exported.\n   *\n   * This function reconciles two concepts:\n   *\n   * A class is Exported if it's exported from the main library `entryPoint` file.\n   * A class is Visible if, via Angular semantics, a downstream consumer can import an Exported class\n   * and be affected by the class in question. For example, an Exported NgModule may expose a\n   * directive class to its consumers. Consumers that import the NgModule may have the directive\n   * applied to elements in their templates. In this case, the directive is considered Visible.\n   *\n   * `checkForPrivateExports` attempts to verify that all Visible classes are Exported, and report\n   * `ts.Diagnostic`s for those that aren't.\n   *\n   * @param entryPoint `ts.SourceFile` of the library's entrypoint, which should export the library's\n   * public API.\n   * @param checker `ts.TypeChecker` for the current program.\n   * @param refGraph `ReferenceGraph` tracking the visibility of Angular types.\n   * @returns an array of `ts.Diagnostic`s representing errors when visible classes are not exported\n   * properly.\n   */\n\n\n  function checkForPrivateExports(entryPoint, checker, refGraph) {\n    var diagnostics = []; // Firstly, compute the exports of the entry point. These are all the Exported classes.\n\n    var topLevelExports = new Set(); // Do this via `ts.TypeChecker.getExportsOfModule`.\n\n    var moduleSymbol = checker.getSymbolAtLocation(entryPoint);\n\n    if (moduleSymbol === undefined) {\n      throw new Error(\"Internal error: failed to get symbol for entrypoint\");\n    }\n\n    var exportedSymbols = checker.getExportsOfModule(moduleSymbol); // Loop through the exported symbols, de-alias if needed, and add them to `topLevelExports`.\n    // TODO(alxhub): use proper iteration when build.sh is removed. (#27762)\n\n    exportedSymbols.forEach(function (symbol) {\n      if (symbol.flags & ts.SymbolFlags.Alias) {\n        symbol = checker.getAliasedSymbol(symbol);\n      }\n\n      var decl = symbol.valueDeclaration;\n\n      if (decl !== undefined) {\n        topLevelExports.add(decl);\n      }\n    }); // Next, go through each exported class and expand it to the set of classes it makes Visible,\n    // using the `ReferenceGraph`. For each Visible class, verify that it's also Exported, and queue\n    // an error if it isn't. `checkedSet` ensures only one error is queued per class.\n\n    var checkedSet = new Set(); // Loop through each Exported class.\n    // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n\n    topLevelExports.forEach(function (mainExport) {\n      // Loop through each class made Visible by the Exported class.\n      refGraph.transitiveReferencesOf(mainExport).forEach(function (transitiveReference) {\n        // Skip classes which have already been checked.\n        if (checkedSet.has(transitiveReference)) {\n          return;\n        }\n\n        checkedSet.add(transitiveReference); // Verify that the Visible class is also Exported.\n\n        if (!topLevelExports.has(transitiveReference)) {\n          // This is an error, `mainExport` makes `transitiveReference` Visible, but\n          // `transitiveReference` is not Exported from the entrypoint. Construct a diagnostic to\n          // give to the user explaining the situation.\n          var descriptor = getDescriptorOfDeclaration(transitiveReference);\n          var name_1 = getNameOfDeclaration(transitiveReference); // Construct the path of visibility, from `mainExport` to `transitiveReference`.\n\n          var visibleVia = 'NgModule exports';\n          var transitivePath = refGraph.pathFrom(mainExport, transitiveReference);\n\n          if (transitivePath !== null) {\n            visibleVia = transitivePath.map(function (seg) {\n              return getNameOfDeclaration(seg);\n            }).join(' -> ');\n          }\n\n          var diagnostic = tslib_1.__assign(tslib_1.__assign({\n            category: ts.DiagnosticCategory.Error,\n            code: diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.SYMBOL_NOT_EXPORTED),\n            file: transitiveReference.getSourceFile()\n          }, getPosOfDeclaration(transitiveReference)), {\n            messageText: \"Unsupported private \" + descriptor + \" \" + name_1 + \". This \" + descriptor + \" is visible to consumers via \" + visibleVia + \", but is not exported from the top-level library entrypoint.\"\n          });\n\n          diagnostics.push(diagnostic);\n        }\n      });\n    });\n    return diagnostics;\n  }\n\n  exports.checkForPrivateExports = checkForPrivateExports;\n\n  function getPosOfDeclaration(decl) {\n    var node = getIdentifierOfDeclaration(decl) || decl;\n    return {\n      start: node.getStart(),\n      length: node.getEnd() + 1 - node.getStart()\n    };\n  }\n\n  function getIdentifierOfDeclaration(decl) {\n    if ((ts.isClassDeclaration(decl) || ts.isVariableDeclaration(decl) || ts.isFunctionDeclaration(decl)) && decl.name !== undefined && ts.isIdentifier(decl.name)) {\n      return decl.name;\n    } else {\n      return null;\n    }\n  }\n\n  function getNameOfDeclaration(decl) {\n    var id = getIdentifierOfDeclaration(decl);\n    return id !== null ? id.text : '(unnamed)';\n  }\n\n  function getDescriptorOfDeclaration(decl) {\n    switch (decl.kind) {\n      case ts.SyntaxKind.ClassDeclaration:\n        return 'class';\n\n      case ts.SyntaxKind.FunctionDeclaration:\n        return 'function';\n\n      case ts.SyntaxKind.VariableDeclaration:\n        return 'variable';\n\n      case ts.SyntaxKind.EnumDeclaration:\n        return 'enum';\n\n      default:\n        return 'declaration';\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/entry_point/src/private_export_checker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ErrorCode, ngErrorCode} from '../../diagnostics';\nimport {DeclarationNode} from '../../reflection';\n\nimport {ReferenceGraph} from './reference_graph';\n\n/**\n * Produce `ts.Diagnostic`s for classes that are visible from exported types (e.g. directives\n * exposed by exported `NgModule`s) that are not themselves exported.\n *\n * This function reconciles two concepts:\n *\n * A class is Exported if it's exported from the main library `entryPoint` file.\n * A class is Visible if, via Angular semantics, a downstream consumer can import an Exported class\n * and be affected by the class in question. For example, an Exported NgModule may expose a\n * directive class to its consumers. Consumers that import the NgModule may have the directive\n * applied to elements in their templates. In this case, the directive is considered Visible.\n *\n * `checkForPrivateExports` attempts to verify that all Visible classes are Exported, and report\n * `ts.Diagnostic`s for those that aren't.\n *\n * @param entryPoint `ts.SourceFile` of the library's entrypoint, which should export the library's\n * public API.\n * @param checker `ts.TypeChecker` for the current program.\n * @param refGraph `ReferenceGraph` tracking the visibility of Angular types.\n * @returns an array of `ts.Diagnostic`s representing errors when visible classes are not exported\n * properly.\n */\nexport function checkForPrivateExports(\n    entryPoint: ts.SourceFile, checker: ts.TypeChecker, refGraph: ReferenceGraph): ts.Diagnostic[] {\n  const diagnostics: ts.Diagnostic[] = [];\n\n  // Firstly, compute the exports of the entry point. These are all the Exported classes.\n  const topLevelExports = new Set<DeclarationNode>();\n\n  // Do this via `ts.TypeChecker.getExportsOfModule`.\n  const moduleSymbol = checker.getSymbolAtLocation(entryPoint);\n  if (moduleSymbol === undefined) {\n    throw new Error(`Internal error: failed to get symbol for entrypoint`);\n  }\n  const exportedSymbols = checker.getExportsOfModule(moduleSymbol);\n\n  // Loop through the exported symbols, de-alias if needed, and add them to `topLevelExports`.\n  // TODO(alxhub): use proper iteration when build.sh is removed. (#27762)\n  exportedSymbols.forEach(symbol => {\n    if (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = checker.getAliasedSymbol(symbol);\n    }\n    const decl = symbol.valueDeclaration;\n    if (decl !== undefined) {\n      topLevelExports.add(decl);\n    }\n  });\n\n  // Next, go through each exported class and expand it to the set of classes it makes Visible,\n  // using the `ReferenceGraph`. For each Visible class, verify that it's also Exported, and queue\n  // an error if it isn't. `checkedSet` ensures only one error is queued per class.\n  const checkedSet = new Set<DeclarationNode>();\n\n  // Loop through each Exported class.\n  // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n  topLevelExports.forEach(mainExport => {\n    // Loop through each class made Visible by the Exported class.\n    refGraph.transitiveReferencesOf(mainExport).forEach(transitiveReference => {\n      // Skip classes which have already been checked.\n      if (checkedSet.has(transitiveReference)) {\n        return;\n      }\n      checkedSet.add(transitiveReference);\n\n      // Verify that the Visible class is also Exported.\n      if (!topLevelExports.has(transitiveReference)) {\n        // This is an error, `mainExport` makes `transitiveReference` Visible, but\n        // `transitiveReference` is not Exported from the entrypoint. Construct a diagnostic to\n        // give to the user explaining the situation.\n\n        const descriptor = getDescriptorOfDeclaration(transitiveReference);\n        const name = getNameOfDeclaration(transitiveReference);\n\n        // Construct the path of visibility, from `mainExport` to `transitiveReference`.\n        let visibleVia = 'NgModule exports';\n        const transitivePath = refGraph.pathFrom(mainExport, transitiveReference);\n        if (transitivePath !== null) {\n          visibleVia = transitivePath.map(seg => getNameOfDeclaration(seg)).join(' -> ');\n        }\n\n        const diagnostic: ts.Diagnostic = {\n          category: ts.DiagnosticCategory.Error,\n          code: ngErrorCode(ErrorCode.SYMBOL_NOT_EXPORTED),\n          file: transitiveReference.getSourceFile(),\n          ...getPosOfDeclaration(transitiveReference),\n          messageText: `Unsupported private ${descriptor} ${name}. This ${\n              descriptor} is visible to consumers via ${\n              visibleVia}, but is not exported from the top-level library entrypoint.`,\n        };\n\n        diagnostics.push(diagnostic);\n      }\n    });\n  });\n\n  return diagnostics;\n}\n\nfunction getPosOfDeclaration(decl: DeclarationNode): {start: number, length: number} {\n  const node: ts.Node = getIdentifierOfDeclaration(decl) || decl;\n  return {\n    start: node.getStart(),\n    length: node.getEnd() + 1 - node.getStart(),\n  };\n}\n\nfunction getIdentifierOfDeclaration(decl: DeclarationNode): ts.Identifier|null {\n  if ((ts.isClassDeclaration(decl) || ts.isVariableDeclaration(decl) ||\n       ts.isFunctionDeclaration(decl)) &&\n      decl.name !== undefined && ts.isIdentifier(decl.name)) {\n    return decl.name;\n  } else {\n    return null;\n  }\n}\n\nfunction getNameOfDeclaration(decl: DeclarationNode): string {\n  const id = getIdentifierOfDeclaration(decl);\n  return id !== null ? id.text : '(unnamed)';\n}\n\nfunction getDescriptorOfDeclaration(decl: DeclarationNode): string {\n  switch (decl.kind) {\n    case ts.SyntaxKind.ClassDeclaration:\n      return 'class';\n    case ts.SyntaxKind.FunctionDeclaration:\n      return 'function';\n    case ts.SyntaxKind.VariableDeclaration:\n      return 'variable';\n    case ts.SyntaxKind.EnumDeclaration:\n      return 'enum';\n    default:\n      return 'declaration';\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}