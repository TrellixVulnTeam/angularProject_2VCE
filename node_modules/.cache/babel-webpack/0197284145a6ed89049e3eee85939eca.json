{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/tasks/api\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TaskDependencies = exports.DtsProcessing = void 0;\n  /**\n   * The options for processing Typescript typings (.d.ts) files.\n   */\n\n  var DtsProcessing;\n\n  (function (DtsProcessing) {\n    /**\n     * Yes, process the typings for this entry point as part of the task.\n     */\n    DtsProcessing[DtsProcessing[\"Yes\"] = 0] = \"Yes\";\n    /**\n     * No, do not process the typings as part of this task - they must have already been processed by\n     * another task or previous ngcc process.\n     */\n\n    DtsProcessing[DtsProcessing[\"No\"] = 1] = \"No\";\n    /**\n     * Only process the typings for this entry-point; do not render any JavaScript files for the\n     * `formatProperty` of this task.\n     */\n\n    DtsProcessing[DtsProcessing[\"Only\"] = 2] = \"Only\";\n  })(DtsProcessing = exports.DtsProcessing || (exports.DtsProcessing = {}));\n\n  exports.TaskDependencies = Map;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/ngcc/src/execution/tasks/api.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAwCA;;AAEG;;AACH,MAAY,aAAZ;;AAAA,GAAA,UAAY,aAAZ,EAAyB;AACvB;;AAEG;AACH,IAAA,aAAA,CAAA,aAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,GAAA,KAAA;AACA;;;AAGG;;AACH,IAAA,aAAA,CAAA,aAAA,CAAA,IAAA,CAAA,GAAA,CAAA,CAAA,GAAA,IAAA;AACA;;;AAGG;;AACH,IAAA,aAAA,CAAA,aAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACD,GAfD,EAAY,aAAa,GAAb,OAAA,CAAA,aAAA,KAAA,OAAA,CAAA,aAAA,GAAa,EAAb,CAAZ;;AAoCa,EAAA,OAAA,CAAA,gBAAA,GAAmB,GAAnB","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {EntryPoint, EntryPointJsonProperty, JsonObject} from '../../packages/entry_point';\nimport {PartiallyOrderedList} from '../../utils';\n\n/**\n * Represents a unit of work to be undertaken by an `Executor`.\n *\n * A task consists of processing a specific format property of an entry-point.\n * This may or may not also include processing the typings for that entry-point, which only needs to\n * happen once across all the formats.\n */\nexport interface Task extends JsonObject {\n  /** The `EntryPoint` which needs to be processed as part of the task. */\n  entryPoint: EntryPoint;\n\n  /**\n   * The `package.json` format property to process (i.e. the property which points to the file that\n   * is the program entry-point).\n   */\n  formatProperty: EntryPointJsonProperty;\n\n  /**\n   * The list of all format properties (including `task.formatProperty`) that should be marked as\n   * processed once the task has been completed, because they point to the format-path that will be\n   * processed as part of the task.\n   */\n  formatPropertiesToMarkAsProcessed: EntryPointJsonProperty[];\n\n  /**\n   * Whether to process typings for this entry-point as part of the task.\n   */\n  processDts: DtsProcessing;\n}\n\n/**\n * The options for processing Typescript typings (.d.ts) files.\n */\nexport enum DtsProcessing {\n  /**\n   * Yes, process the typings for this entry point as part of the task.\n   */\n  Yes,\n  /**\n   * No, do not process the typings as part of this task - they must have already been processed by\n   * another task or previous ngcc process.\n   */\n  No,\n  /**\n   * Only process the typings for this entry-point; do not render any JavaScript files for the\n   * `formatProperty` of this task.\n   */\n  Only,\n}\n\n/**\n * Represents a partially ordered list of tasks.\n *\n * The ordering/precedence of tasks is determined by the inter-dependencies between their associated\n * entry-points. Specifically, the tasks' order/precedence is such that tasks associated to\n * dependent entry-points always come after tasks associated with their dependencies.\n *\n * As result of this ordering, it is guaranteed that - by processing tasks in the order in which\n * they appear in the list - a task's dependencies will always have been processed before processing\n * the task itself.\n *\n * See `DependencyResolver#sortEntryPointsByDependency()`.\n */\nexport type PartiallyOrderedTasks = PartiallyOrderedList<Task>;\n\n/**\n * A mapping from Tasks to the Tasks that depend upon them (dependents).\n */\nexport type TaskDependencies = Map<Task, Set<Task>>;\nexport const TaskDependencies = Map;\n\n/**\n * A function to create a TaskCompletedCallback function.\n */\nexport type CreateTaskCompletedCallback = (taskQueue: TaskQueue) => TaskCompletedCallback;\n\n/**\n * A function to be called once a task has been processed.\n */\nexport type TaskCompletedCallback =\n    (task: Task, outcome: TaskProcessingOutcome, message: string|null) => void;\n\n/**\n * Represents the outcome of processing a `Task`.\n */\nexport const enum TaskProcessingOutcome {\n  /** Successfully processed the target format property. */\n  Processed,\n  /** Failed to process the target format. */\n  Failed,\n}\n\n/**\n * A wrapper around a list of tasks and providing utility methods for getting the next task of\n * interest and determining when all tasks have been completed.\n *\n * (This allows different implementations to impose different constraints on when a task's\n * processing can start.)\n */\nexport interface TaskQueue {\n  /** Whether all tasks have been completed. */\n  allTasksCompleted: boolean;\n\n  /**\n   * Get the next task whose processing can start (if any).\n   *\n   * This implicitly marks the task as in-progress.\n   * (This information is used to determine whether all tasks have been completed.)\n   *\n   * @return The next task available for processing or `null`, if no task can be processed at the\n   *         moment (including if there are no more unprocessed tasks).\n   */\n  getNextTask(): Task|null;\n\n  /**\n   * Mark a task as completed.\n   *\n   * This removes the task from the internal list of in-progress tasks.\n   * (This information is used to determine whether all tasks have been completed.)\n   *\n   * @param task The task to mark as completed.\n   */\n  markAsCompleted(task: Task): void;\n\n  /**\n   * Mark a task as failed.\n   *\n   * Do not process the tasks that depend upon the given task.\n   */\n  markAsFailed(task: Task): void;\n\n  /**\n   * Mark a task as not processed (i.e. add an in-progress task back to the queue).\n   *\n   * This removes the task from the internal list of in-progress tasks and adds it back to the list\n   * of pending tasks.\n   *\n   * @param task The task to mark as not processed.\n   */\n  markAsUnprocessed(task: Task): void;\n\n  /**\n   * Return a string representation of the task queue (for debugging purposes).\n   *\n   * @return A string representation of the task queue.\n   */\n  toString(): string;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}