{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nvar _schema = require(\"@istanbuljs/schema\");\n\nvar _visitor = _interopRequireDefault(require(\"./visitor\"));\n\nvar _readCoverage = _interopRequireDefault(require(\"./read-coverage\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n */\n\n\nvar Instrumenter = /*#__PURE__*/function () {\n  function Instrumenter() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Instrumenter);\n\n    this.opts = _objectSpread(_objectSpread({}, _schema.defaults.instrumenter), opts);\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  _createClass(Instrumenter, [{\n    key: \"instrumentSync\",\n    value: function instrumentSync(code, filename, inputSourceMap) {\n      if (typeof code !== 'string') {\n        throw new Error('Code must be a string');\n      }\n\n      filename = filename || String(new Date().getTime()) + '.js';\n      var opts = this.opts;\n      var output = {};\n      var babelOpts = {\n        configFile: false,\n        babelrc: false,\n        ast: true,\n        filename: filename || String(new Date().getTime()) + '.js',\n        inputSourceMap: inputSourceMap,\n        sourceMaps: opts.produceSourceMap,\n        compact: opts.compact,\n        comments: opts.preserveComments,\n        parserOpts: {\n          allowReturnOutsideFunction: opts.autoWrap,\n          sourceType: opts.esModules ? 'module' : 'script',\n          plugins: opts.parserPlugins\n        },\n        plugins: [[function (_ref) {\n          var types = _ref.types;\n          var ee = (0, _visitor.default)(types, filename, {\n            coverageVariable: opts.coverageVariable,\n            coverageGlobalScope: opts.coverageGlobalScope,\n            coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n            ignoreClassMethods: opts.ignoreClassMethods,\n            inputSourceMap: inputSourceMap\n          });\n          return {\n            visitor: {\n              Program: {\n                enter: ee.enter,\n                exit: function exit(path) {\n                  output = ee.exit(path);\n                }\n              }\n            }\n          };\n        }]]\n      };\n      var codeMap = (0, _core.transformSync)(code, babelOpts);\n\n      if (!output || !output.fileCoverage) {\n        var initialCoverage = (0, _readCoverage.default)(codeMap.ast) ||\n        /* istanbul ignore next: paranoid check */\n        {};\n        this.fileCoverage = initialCoverage.coverageData;\n        this.sourceMap = inputSourceMap;\n        return code;\n      }\n\n      this.fileCoverage = output.fileCoverage;\n      this.sourceMap = codeMap.map;\n      var cb = this.opts.sourceMapUrlCallback;\n\n      if (cb && output.sourceMappingURL) {\n        cb(filename, output.sourceMappingURL);\n      }\n\n      return codeMap.code;\n    }\n    /**\n     * callback-style instrument method that calls back with an error\n     * as opposed to throwing one. Note that in the current implementation,\n     * the callback will be called in the same process tick and is not asynchronous.\n     *\n     * @param {string} code - the code to instrument\n     * @param {string} filename - the filename against which to track coverage.\n     * @param {Function} callback - the callback\n     * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n     * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n     * coverage to the untranspiled source.\n     */\n\n  }, {\n    key: \"instrument\",\n    value: function instrument(code, filename, callback, inputSourceMap) {\n      if (!callback && typeof filename === 'function') {\n        callback = filename;\n        filename = null;\n      }\n\n      try {\n        var out = this.instrumentSync(code, filename, inputSourceMap);\n        callback(null, out);\n      } catch (ex) {\n        callback(ex);\n      }\n    }\n    /**\n     * returns the file coverage object for the last file instrumented.\n     * @returns {Object} the file coverage object.\n     */\n\n  }, {\n    key: \"lastFileCoverage\",\n    value: function lastFileCoverage() {\n      return this.fileCoverage;\n    }\n    /**\n     * returns the source map produced for the last file instrumented.\n     * @returns {null|Object} the source map object.\n     */\n\n  }, {\n    key: \"lastSourceMap\",\n    value: function lastSourceMap() {\n      return this.sourceMap;\n    }\n  }]);\n\n  return Instrumenter;\n}();\n\nvar _default = Instrumenter;\nexports.default = _default;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/istanbul-lib-instrument/dist/instrumenter.js"],"names":["Object","defineProperty","exports","value","default","_core","require","_schema","_visitor","_interopRequireDefault","_readCoverage","obj","__esModule","Instrumenter","opts","defaults","instrumenter","fileCoverage","sourceMap","code","filename","inputSourceMap","Error","String","Date","getTime","output","babelOpts","configFile","babelrc","ast","sourceMaps","produceSourceMap","compact","comments","preserveComments","parserOpts","allowReturnOutsideFunction","autoWrap","sourceType","esModules","plugins","parserPlugins","types","ee","coverageVariable","coverageGlobalScope","coverageGlobalScopeFunc","ignoreClassMethods","visitor","Program","enter","exit","path","codeMap","transformSync","initialCoverage","coverageData","map","cb","sourceMapUrlCallback","sourceMappingURL","callback","out","instrumentSync","ex","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _core = require(\"@babel/core\");\n\nvar _schema = require(\"@istanbuljs/schema\");\n\nvar _visitor = _interopRequireDefault(require(\"./visitor\"));\n\nvar _readCoverage = _interopRequireDefault(require(\"./read-coverage\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n\n/**\n * Instrumenter is the public API for the instrument library.\n * It is typically used for ES5 code. For ES6 code that you\n * are already running under `babel` use the coverage plugin\n * instead.\n * @param {Object} opts optional.\n * @param {string} [opts.coverageVariable=__coverage__] name of global coverage variable.\n * @param {boolean} [opts.preserveComments=false] preserve comments in output\n * @param {boolean} [opts.compact=true] generate compact code.\n * @param {boolean} [opts.esModules=false] set to true to instrument ES6 modules.\n * @param {boolean} [opts.autoWrap=false] set to true to allow `return` statements outside of functions.\n * @param {boolean} [opts.produceSourceMap=false] set to true to produce a source map for the instrumented code.\n * @param {Array} [opts.ignoreClassMethods=[]] set to array of class method names to ignore for coverage.\n * @param {Function} [opts.sourceMapUrlCallback=null] a callback function that is called when a source map URL\n *     is found in the original code. This function is called with the source file name and the source map URL.\n * @param {boolean} [opts.debug=false] - turn debugging on\n * @param {array} [opts.parserPlugins] - set babel parser plugins, see @istanbuljs/schema for defaults.\n */\nclass Instrumenter {\n  constructor(opts = {}) {\n    this.opts = { ..._schema.defaults.instrumenter,\n      ...opts\n    };\n    this.fileCoverage = null;\n    this.sourceMap = null;\n  }\n  /**\n   * instrument the supplied code and track coverage against the supplied\n   * filename. It throws if invalid code is passed to it. ES5 and ES6 syntax\n   * is supported. To instrument ES6 modules, make sure that you set the\n   * `esModules` property to `true` when creating the instrumenter.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {object} [inputSourceMap] - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   * @returns {string} the instrumented code.\n   */\n\n\n  instrumentSync(code, filename, inputSourceMap) {\n    if (typeof code !== 'string') {\n      throw new Error('Code must be a string');\n    }\n\n    filename = filename || String(new Date().getTime()) + '.js';\n    const {\n      opts\n    } = this;\n    let output = {};\n    const babelOpts = {\n      configFile: false,\n      babelrc: false,\n      ast: true,\n      filename: filename || String(new Date().getTime()) + '.js',\n      inputSourceMap,\n      sourceMaps: opts.produceSourceMap,\n      compact: opts.compact,\n      comments: opts.preserveComments,\n      parserOpts: {\n        allowReturnOutsideFunction: opts.autoWrap,\n        sourceType: opts.esModules ? 'module' : 'script',\n        plugins: opts.parserPlugins\n      },\n      plugins: [[({\n        types\n      }) => {\n        const ee = (0, _visitor.default)(types, filename, {\n          coverageVariable: opts.coverageVariable,\n          coverageGlobalScope: opts.coverageGlobalScope,\n          coverageGlobalScopeFunc: opts.coverageGlobalScopeFunc,\n          ignoreClassMethods: opts.ignoreClassMethods,\n          inputSourceMap\n        });\n        return {\n          visitor: {\n            Program: {\n              enter: ee.enter,\n\n              exit(path) {\n                output = ee.exit(path);\n              }\n\n            }\n          }\n        };\n      }]]\n    };\n    const codeMap = (0, _core.transformSync)(code, babelOpts);\n\n    if (!output || !output.fileCoverage) {\n      const initialCoverage = (0, _readCoverage.default)(codeMap.ast) ||\n      /* istanbul ignore next: paranoid check */\n      {};\n      this.fileCoverage = initialCoverage.coverageData;\n      this.sourceMap = inputSourceMap;\n      return code;\n    }\n\n    this.fileCoverage = output.fileCoverage;\n    this.sourceMap = codeMap.map;\n    const cb = this.opts.sourceMapUrlCallback;\n\n    if (cb && output.sourceMappingURL) {\n      cb(filename, output.sourceMappingURL);\n    }\n\n    return codeMap.code;\n  }\n  /**\n   * callback-style instrument method that calls back with an error\n   * as opposed to throwing one. Note that in the current implementation,\n   * the callback will be called in the same process tick and is not asynchronous.\n   *\n   * @param {string} code - the code to instrument\n   * @param {string} filename - the filename against which to track coverage.\n   * @param {Function} callback - the callback\n   * @param {Object} inputSourceMap - the source map that maps the not instrumented code back to it's original form.\n   * Is assigned to the coverage object and therefore, is available in the json output and can be used to remap the\n   * coverage to the untranspiled source.\n   */\n\n\n  instrument(code, filename, callback, inputSourceMap) {\n    if (!callback && typeof filename === 'function') {\n      callback = filename;\n      filename = null;\n    }\n\n    try {\n      const out = this.instrumentSync(code, filename, inputSourceMap);\n      callback(null, out);\n    } catch (ex) {\n      callback(ex);\n    }\n  }\n  /**\n   * returns the file coverage object for the last file instrumented.\n   * @returns {Object} the file coverage object.\n   */\n\n\n  lastFileCoverage() {\n    return this.fileCoverage;\n  }\n  /**\n   * returns the source map produced for the last file instrumented.\n   * @returns {null|Object} the source map object.\n   */\n\n\n  lastSourceMap() {\n    return this.sourceMap;\n  }\n\n}\n\nvar _default = Instrumenter;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}