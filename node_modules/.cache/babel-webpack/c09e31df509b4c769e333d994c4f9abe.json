{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/ngcc_compiler_host\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/ngcc/src/analysis/util\", \"@angular/compiler-cli/ngcc/src/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NgccDtsCompilerHost = exports.NgccSourcesCompilerHost = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var util_1 = require(\"@angular/compiler-cli/ngcc/src/analysis/util\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/utils\");\n  /**\n   * Represents a compiler host that resolves a module import as a JavaScript source file if\n   * available, instead of the .d.ts typings file that would have been resolved by TypeScript. This\n   * is necessary for packages that have their typings in the same directory as the sources, which\n   * would otherwise let TypeScript prefer the .d.ts file instead of the JavaScript source file.\n   */\n\n\n  var NgccSourcesCompilerHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(NgccSourcesCompilerHost, _super);\n\n    function NgccSourcesCompilerHost(fs, options, cache, moduleResolutionCache, packagePath) {\n      var _this = _super.call(this, fs, options) || this;\n\n      _this.cache = cache;\n      _this.moduleResolutionCache = moduleResolutionCache;\n      _this.packagePath = packagePath;\n      return _this;\n    }\n\n    NgccSourcesCompilerHost.prototype.getSourceFile = function (fileName, languageVersion) {\n      return this.cache.getCachedSourceFile(fileName, languageVersion);\n    };\n\n    NgccSourcesCompilerHost.prototype.resolveModuleNames = function (moduleNames, containingFile, reusedNames, redirectedReference) {\n      var _this = this;\n\n      return moduleNames.map(function (moduleName) {\n        var resolvedModule = ts.resolveModuleName(moduleName, containingFile, _this.options, _this, _this.moduleResolutionCache, redirectedReference).resolvedModule; // If the module request originated from a relative import in a JavaScript source file,\n        // TypeScript may have resolved the module to its .d.ts declaration file if the .js source\n        // file was in the same directory. This is undesirable, as we need to have the actual\n        // JavaScript being present in the program. This logic recognizes this scenario and rewrites\n        // the resolved .d.ts declaration file to its .js counterpart, if it exists.\n\n        if ((resolvedModule === null || resolvedModule === void 0 ? void 0 : resolvedModule.extension) === ts.Extension.Dts && containingFile.endsWith('.js') && utils_1.isRelativePath(moduleName)) {\n          var jsFile = resolvedModule.resolvedFileName.replace(/\\.d\\.ts$/, '.js');\n\n          if (_this.fileExists(jsFile)) {\n            return tslib_1.__assign(tslib_1.__assign({}, resolvedModule), {\n              resolvedFileName: jsFile,\n              extension: ts.Extension.Js\n            });\n          }\n        } // Prevent loading JavaScript source files outside of the package root, which would happen for\n        // packages that don't have .d.ts files. As ngcc should only operate on the .js files\n        // contained within the package, any files outside the package are simply discarded. This does\n        // result in a partial program with error diagnostics, however ngcc won't gather diagnostics\n        // for the program it creates so these diagnostics won't be reported.\n\n\n        if ((resolvedModule === null || resolvedModule === void 0 ? void 0 : resolvedModule.extension) === ts.Extension.Js && !util_1.isWithinPackage(_this.packagePath, _this.fs.resolve(resolvedModule.resolvedFileName))) {\n          return undefined;\n        }\n\n        return resolvedModule;\n      });\n    };\n\n    return NgccSourcesCompilerHost;\n  }(file_system_1.NgtscCompilerHost);\n\n  exports.NgccSourcesCompilerHost = NgccSourcesCompilerHost;\n  /**\n   * A compiler host implementation that is used for the typings program. It leverages the entry-point\n   * cache for source files and module resolution, as these results can be reused across the sources\n   * program.\n   */\n\n  var NgccDtsCompilerHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(NgccDtsCompilerHost, _super);\n\n    function NgccDtsCompilerHost(fs, options, cache, moduleResolutionCache) {\n      var _this = _super.call(this, fs, options) || this;\n\n      _this.cache = cache;\n      _this.moduleResolutionCache = moduleResolutionCache;\n      return _this;\n    }\n\n    NgccDtsCompilerHost.prototype.getSourceFile = function (fileName, languageVersion) {\n      return this.cache.getCachedSourceFile(fileName, languageVersion);\n    };\n\n    NgccDtsCompilerHost.prototype.resolveModuleNames = function (moduleNames, containingFile, reusedNames, redirectedReference) {\n      var _this = this;\n\n      return moduleNames.map(function (moduleName) {\n        var resolvedModule = ts.resolveModuleName(moduleName, containingFile, _this.options, _this, _this.moduleResolutionCache, redirectedReference).resolvedModule;\n        return resolvedModule;\n      });\n    };\n\n    return NgccDtsCompilerHost;\n  }(file_system_1.NgtscCompilerHost);\n\n  exports.NgccDtsCompilerHost = NgccDtsCompilerHost;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/ngcc_compiler_host.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAMG;;;AACH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,sCAAA,CAAA;AAGA;;;;;AAKG;;;AACH,MAAA,uBAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAA6C,IAAA,OAAA,CAAA,SAAA,CAAA,uBAAA,EAAA,MAAA;;AAC3C,aAAA,uBAAA,CACI,EADJ,EACoB,OADpB,EACyD,KADzD,EAEY,qBAFZ,EAGc,WAHd,EAGyC;AAHzC,UAAA,KAAA,GAIE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,EAAN,EAAU,OAAV,KAAkB,IAJpB;;AACyD,MAAA,KAAA,CAAA,KAAA,GAAA,KAAA;AAC7C,MAAA,KAAA,CAAA,qBAAA,GAAA,qBAAA;AACE,MAAA,KAAA,CAAA,WAAA,GAAA,WAAA;;AAEb;;AAED,IAAA,uBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,QAAd,EAAgC,eAAhC,EAAgE;AAC9D,aAAO,KAAK,KAAL,CAAW,mBAAX,CAA+B,QAA/B,EAAyC,eAAzC,CAAP;AACD,KAFD;;AAIA,IAAA,uBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UACI,WADJ,EAC2B,cAD3B,EACmD,WADnD,EAEI,mBAFJ,EAEqD;AAFrD,UAAA,KAAA,GAAA,IAAA;;AAGE,aAAO,WAAW,CAAC,GAAZ,CAAgB,UAAA,UAAA,EAAU;AACxB,YAAA,cAAc,GAAI,EAAE,CAAC,iBAAH,CACrB,UADqB,EACT,cADS,EACO,KAAI,CAAC,OADZ,EACqB,KADrB,EAC2B,KAAI,CAAC,qBADhC,EAErB,mBAFqB,EAAJ,cAAd,CADwB,CAK/B;AACA;AACA;AACA;AACA;;AACA,YAAI,CAAA,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAA,cAAc,CAAE,SAAhB,MAA8B,EAAE,CAAC,SAAH,CAAa,GAA3C,IAAkD,cAAc,CAAC,QAAf,CAAwB,KAAxB,CAAlD,IACA,OAAA,CAAA,cAAA,CAAe,UAAf,CADJ,EACgC;AAC9B,cAAM,MAAM,GAAG,cAAc,CAAC,gBAAf,CAAgC,OAAhC,CAAwC,UAAxC,EAAoD,KAApD,CAAf;;AACA,cAAI,KAAI,CAAC,UAAL,CAAgB,MAAhB,CAAJ,EAA6B;AAC3B,mBAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAAW,cAAX,CAAA,EAAyB;AAAE,cAAA,gBAAgB,EAAE,MAApB;AAA4B,cAAA,SAAS,EAAE,EAAE,CAAC,SAAH,CAAa;AAApD,aAAzB,CAAA;AACD;AACF,SAhB8B,CAkB/B;AACA;AACA;AACA;AACA;;;AACA,YAAI,CAAA,cAAc,KAAA,IAAd,IAAA,cAAc,KAAA,KAAA,CAAd,GAAc,KAAA,CAAd,GAAA,cAAc,CAAE,SAAhB,MAA8B,EAAE,CAAC,SAAH,CAAa,EAA3C,IACA,CAAC,MAAA,CAAA,eAAA,CAAgB,KAAI,CAAC,WAArB,EAAkC,KAAI,CAAC,EAAL,CAAQ,OAAR,CAAgB,cAAc,CAAC,gBAA/B,CAAlC,CADL,EAC0F;AACxF,iBAAO,SAAP;AACD;;AAED,eAAO,cAAP;AACD,OA7BM,CAAP;AA8BD,KAjCD;;AAkCF,WAAA,uBAAA;AAAC,GA9CD,CAA6C,aAAA,CAAA,iBAA7C,CAAA;;AAAa,EAAA,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAgDb;;;;AAIG;;AACH,MAAA,mBAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAyC,IAAA,OAAA,CAAA,SAAA,CAAA,mBAAA,EAAA,MAAA;;AACvC,aAAA,mBAAA,CACI,EADJ,EACoB,OADpB,EACyD,KADzD,EAEY,qBAFZ,EAE2D;AAF3D,UAAA,KAAA,GAGE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,EAAN,EAAU,OAAV,KAAkB,IAHpB;;AACyD,MAAA,KAAA,CAAA,KAAA,GAAA,KAAA;AAC7C,MAAA,KAAA,CAAA,qBAAA,GAAA,qBAAA;;AAEX;;AAED,IAAA,mBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,QAAd,EAAgC,eAAhC,EAAgE;AAC9D,aAAO,KAAK,KAAL,CAAW,mBAAX,CAA+B,QAA/B,EAAyC,eAAzC,CAAP;AACD,KAFD;;AAIA,IAAA,mBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UACI,WADJ,EAC2B,cAD3B,EACmD,WADnD,EAEI,mBAFJ,EAEqD;AAFrD,UAAA,KAAA,GAAA,IAAA;;AAGE,aAAO,WAAW,CAAC,GAAZ,CAAgB,UAAA,UAAA,EAAU;AACxB,YAAA,cAAc,GAAI,EAAE,CAAC,iBAAH,CACrB,UADqB,EACT,cADS,EACO,KAAI,CAAC,OADZ,EACqB,KADrB,EAC2B,KAAI,CAAC,qBADhC,EAErB,mBAFqB,EAAJ,cAAd;AAGP,eAAO,cAAP;AACD,OALM,CAAP;AAMD,KATD;;AAUF,WAAA,mBAAA;AAAC,GArBD,CAAyC,aAAA,CAAA,iBAAzC,CAAA;;AAAa,EAAA,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath, FileSystem, NgtscCompilerHost} from '../../../src/ngtsc/file_system';\nimport {isWithinPackage} from '../analysis/util';\nimport {isRelativePath} from '../utils';\nimport {EntryPointFileCache} from './source_file_cache';\n\n/**\n * Represents a compiler host that resolves a module import as a JavaScript source file if\n * available, instead of the .d.ts typings file that would have been resolved by TypeScript. This\n * is necessary for packages that have their typings in the same directory as the sources, which\n * would otherwise let TypeScript prefer the .d.ts file instead of the JavaScript source file.\n */\nexport class NgccSourcesCompilerHost extends NgtscCompilerHost {\n  constructor(\n      fs: FileSystem, options: ts.CompilerOptions, private cache: EntryPointFileCache,\n      private moduleResolutionCache: ts.ModuleResolutionCache,\n      protected packagePath: AbsoluteFsPath) {\n    super(fs, options);\n  }\n\n  getSourceFile(fileName: string, languageVersion: ts.ScriptTarget): ts.SourceFile|undefined {\n    return this.cache.getCachedSourceFile(fileName, languageVersion);\n  }\n\n  resolveModuleNames(\n      moduleNames: string[], containingFile: string, reusedNames?: string[],\n      redirectedReference?: ts.ResolvedProjectReference): Array<ts.ResolvedModule|undefined> {\n    return moduleNames.map(moduleName => {\n      const {resolvedModule} = ts.resolveModuleName(\n          moduleName, containingFile, this.options, this, this.moduleResolutionCache,\n          redirectedReference);\n\n      // If the module request originated from a relative import in a JavaScript source file,\n      // TypeScript may have resolved the module to its .d.ts declaration file if the .js source\n      // file was in the same directory. This is undesirable, as we need to have the actual\n      // JavaScript being present in the program. This logic recognizes this scenario and rewrites\n      // the resolved .d.ts declaration file to its .js counterpart, if it exists.\n      if (resolvedModule?.extension === ts.Extension.Dts && containingFile.endsWith('.js') &&\n          isRelativePath(moduleName)) {\n        const jsFile = resolvedModule.resolvedFileName.replace(/\\.d\\.ts$/, '.js');\n        if (this.fileExists(jsFile)) {\n          return {...resolvedModule, resolvedFileName: jsFile, extension: ts.Extension.Js};\n        }\n      }\n\n      // Prevent loading JavaScript source files outside of the package root, which would happen for\n      // packages that don't have .d.ts files. As ngcc should only operate on the .js files\n      // contained within the package, any files outside the package are simply discarded. This does\n      // result in a partial program with error diagnostics, however ngcc won't gather diagnostics\n      // for the program it creates so these diagnostics won't be reported.\n      if (resolvedModule?.extension === ts.Extension.Js &&\n          !isWithinPackage(this.packagePath, this.fs.resolve(resolvedModule.resolvedFileName))) {\n        return undefined;\n      }\n\n      return resolvedModule;\n    });\n  }\n}\n\n/**\n * A compiler host implementation that is used for the typings program. It leverages the entry-point\n * cache for source files and module resolution, as these results can be reused across the sources\n * program.\n */\nexport class NgccDtsCompilerHost extends NgtscCompilerHost {\n  constructor(\n      fs: FileSystem, options: ts.CompilerOptions, private cache: EntryPointFileCache,\n      private moduleResolutionCache: ts.ModuleResolutionCache) {\n    super(fs, options);\n  }\n\n  getSourceFile(fileName: string, languageVersion: ts.ScriptTarget): ts.SourceFile|undefined {\n    return this.cache.getCachedSourceFile(fileName, languageVersion);\n  }\n\n  resolveModuleNames(\n      moduleNames: string[], containingFile: string, reusedNames?: string[],\n      redirectedReference?: ts.ResolvedProjectReference): Array<ts.ResolvedModule|undefined> {\n    return moduleNames.map(moduleName => {\n      const {resolvedModule} = ts.resolveModuleName(\n          moduleName, containingFile, this.options, this, this.moduleResolutionCache,\n          redirectedReference);\n      return resolvedModule;\n    });\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}