{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/metadata/index_writer\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.privateEntriesToIndex = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var INDEX_HEADER = \"/**\\n * Generated bundle index. Do not edit.\\n */\\n\";\n\n  function privateEntriesToIndex(index, privates) {\n    var e_1, _a, e_2, _b;\n\n    var results = [INDEX_HEADER]; // Export all of the index symbols.\n\n    results.push(\"export * from '\" + index + \"';\", ''); // Simplify the exports\n\n    var exports = new Map();\n\n    try {\n      for (var privates_1 = tslib_1.__values(privates), privates_1_1 = privates_1.next(); !privates_1_1.done; privates_1_1 = privates_1.next()) {\n        var entry = privates_1_1.value;\n        var entries = exports.get(entry.module);\n\n        if (!entries) {\n          entries = [];\n          exports.set(entry.module, entries);\n        }\n\n        entries.push(entry);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (privates_1_1 && !privates_1_1.done && (_a = privates_1.return)) _a.call(privates_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var compareEntries = compare(function (e) {\n      return e.name;\n    });\n    var compareModules = compare(function (e) {\n      return e[0];\n    });\n    var orderedExports = Array.from(exports).map(function (_a) {\n      var _b = tslib_1.__read(_a, 2),\n          module = _b[0],\n          entries = _b[1];\n\n      return [module, entries.sort(compareEntries)];\n    }).sort(compareModules);\n\n    try {\n      for (var orderedExports_1 = tslib_1.__values(orderedExports), orderedExports_1_1 = orderedExports_1.next(); !orderedExports_1_1.done; orderedExports_1_1 = orderedExports_1.next()) {\n        var _c = tslib_1.__read(orderedExports_1_1.value, 2),\n            module_1 = _c[0],\n            entries = _c[1];\n\n        var symbols = entries.map(function (e) {\n          return e.name + \" as \" + e.privateName;\n        });\n        results.push(\"export {\" + symbols + \"} from '\" + module_1 + \"';\");\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (orderedExports_1_1 && !orderedExports_1_1.done && (_b = orderedExports_1.return)) _b.call(orderedExports_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return results.join('\\n');\n  }\n\n  exports.privateEntriesToIndex = privateEntriesToIndex;\n\n  function compare(select) {\n    return function (a, b) {\n      var ak = select(a);\n      var bk = select(b);\n      return ak > bk ? 1 : ak < bk ? -1 : 0;\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/metadata/index_writer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BundlePrivateEntry} from './bundler';\n\nconst INDEX_HEADER = `/**\n * Generated bundle index. Do not edit.\n */\n`;\n\ntype MapEntry = [string, BundlePrivateEntry[]];\n\nexport function privateEntriesToIndex(index: string, privates: BundlePrivateEntry[]): string {\n  const results: string[] = [INDEX_HEADER];\n\n  // Export all of the index symbols.\n  results.push(`export * from '${index}';`, '');\n\n  // Simplify the exports\n  const exports = new Map<string, BundlePrivateEntry[]>();\n\n  for (const entry of privates) {\n    let entries = exports.get(entry.module);\n    if (!entries) {\n      entries = [];\n      exports.set(entry.module, entries);\n    }\n    entries.push(entry);\n  }\n\n\n  const compareEntries = compare((e: BundlePrivateEntry) => e.name);\n  const compareModules = compare((e: MapEntry) => e[0]);\n  const orderedExports =\n      Array.from(exports)\n          .map(([module, entries]) => <MapEntry>[module, entries.sort(compareEntries)])\n          .sort(compareModules);\n\n  for (const [module, entries] of orderedExports) {\n    let symbols = entries.map(e => `${e.name} as ${e.privateName}`);\n    results.push(`export {${symbols}} from '${module}';`);\n  }\n\n  return results.join('\\n');\n}\n\nfunction compare<E, T>(select: (e: E) => T): (a: E, b: E) => number {\n  return (a, b) => {\n    const ak = select(a);\n    const bk = select(b);\n    return ak > bk ? 1 : ak < bk ? -1 : 0;\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}