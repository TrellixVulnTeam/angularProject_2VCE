{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _require = require('./file-coverage'),\n    FileCoverage = _require.FileCoverage;\n\nvar _require2 = require('./coverage-summary'),\n    CoverageSummary = _require2.CoverageSummary;\n\nfunction maybeConstruct(obj, klass) {\n  if (obj instanceof klass) {\n    return obj;\n  }\n\n  return new klass(obj);\n}\n\nfunction loadMap(source) {\n  var data = Object.create(null);\n\n  if (!source) {\n    return data;\n  }\n\n  Object.entries(source).forEach(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        k = _ref2[0],\n        cov = _ref2[1];\n\n    data[k] = maybeConstruct(cov, FileCoverage);\n  });\n  return data;\n}\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\n\n\nvar CoverageMap = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n   * map's contents. This can be the raw global coverage object.\n   */\n  function CoverageMap(obj) {\n    _classCallCheck(this, CoverageMap);\n\n    if (obj instanceof CoverageMap) {\n      this.data = obj.data;\n    } else {\n      this.data = loadMap(obj);\n    }\n  }\n  /**\n   * merges a second coverage map into this one\n   * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n   *  correctly for the same files and additional file coverage keys are created\n   *  as needed.\n   */\n\n\n  _createClass(CoverageMap, [{\n    key: \"merge\",\n    value: function merge(obj) {\n      var _this = this;\n\n      var other = maybeConstruct(obj, CoverageMap);\n      Object.values(other.data).forEach(function (fc) {\n        _this.addFileCoverage(fc);\n      });\n    }\n    /**\n     * filter the coveragemap based on the callback provided\n     * @param {Function (filename)} callback - Returns true if the path\n     *  should be included in the coveragemap. False if it should be\n     *  removed.\n     */\n\n  }, {\n    key: \"filter\",\n    value: function filter(callback) {\n      var _this2 = this;\n\n      Object.keys(this.data).forEach(function (k) {\n        if (!callback(k)) {\n          delete _this2.data[k];\n        }\n      });\n    }\n    /**\n     * returns a JSON-serializable POJO for this coverage map\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.data;\n    }\n    /**\n     * returns an array for file paths for which this map has coverage\n     * @returns {Array{string}} - array of files\n     */\n\n  }, {\n    key: \"files\",\n    value: function files() {\n      return Object.keys(this.data);\n    }\n    /**\n     * returns the file coverage for the specified file.\n     * @param {String} file\n     * @returns {FileCoverage}\n     */\n\n  }, {\n    key: \"fileCoverageFor\",\n    value: function fileCoverageFor(file) {\n      var fc = this.data[file];\n\n      if (!fc) {\n        throw new Error(\"No file coverage available for: \".concat(file));\n      }\n\n      return fc;\n    }\n    /**\n     * adds a file coverage object to this map. If the path for the object,\n     * already exists in the map, it is merged with the existing coverage\n     * otherwise a new key is added to the map.\n     * @param {FileCoverage} fc the file coverage to add\n     */\n\n  }, {\n    key: \"addFileCoverage\",\n    value: function addFileCoverage(fc) {\n      var cov = new FileCoverage(fc);\n      var path = cov.path;\n\n      if (this.data[path]) {\n        this.data[path].merge(cov);\n      } else {\n        this.data[path] = cov;\n      }\n    }\n    /**\n     * returns the coverage summary for all the file coverage objects in this map.\n     * @returns {CoverageSummary}\n     */\n\n  }, {\n    key: \"getCoverageSummary\",\n    value: function getCoverageSummary() {\n      var ret = new CoverageSummary();\n      Object.values(this.data).forEach(function (fc) {\n        ret.merge(fc.toSummary());\n      });\n      return ret;\n    }\n  }]);\n\n  return CoverageMap;\n}();\n\nmodule.exports = {\n  CoverageMap: CoverageMap\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/istanbul-lib-coverage/lib/coverage-map.js"],"names":["require","FileCoverage","CoverageSummary","maybeConstruct","obj","klass","loadMap","source","data","Object","create","entries","forEach","k","cov","CoverageMap","other","values","fc","addFileCoverage","callback","keys","file","Error","path","merge","ret","toSummary","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst { FileCoverage } = require('./file-coverage');\nconst { CoverageSummary } = require('./coverage-summary');\n\nfunction maybeConstruct(obj, klass) {\n    if (obj instanceof klass) {\n        return obj;\n    }\n\n    return new klass(obj);\n}\n\nfunction loadMap(source) {\n    const data = Object.create(null);\n    if (!source) {\n        return data;\n    }\n\n    Object.entries(source).forEach(([k, cov]) => {\n        data[k] = maybeConstruct(cov, FileCoverage);\n    });\n\n    return data;\n}\n\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\nclass CoverageMap {\n    /**\n     * @constructor\n     * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n     * map's contents. This can be the raw global coverage object.\n     */\n    constructor(obj) {\n        if (obj instanceof CoverageMap) {\n            this.data = obj.data;\n        } else {\n            this.data = loadMap(obj);\n        }\n    }\n\n    /**\n     * merges a second coverage map into this one\n     * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n     *  correctly for the same files and additional file coverage keys are created\n     *  as needed.\n     */\n    merge(obj) {\n        const other = maybeConstruct(obj, CoverageMap);\n        Object.values(other.data).forEach(fc => {\n            this.addFileCoverage(fc);\n        });\n    }\n\n    /**\n     * filter the coveragemap based on the callback provided\n     * @param {Function (filename)} callback - Returns true if the path\n     *  should be included in the coveragemap. False if it should be\n     *  removed.\n     */\n    filter(callback) {\n        Object.keys(this.data).forEach(k => {\n            if (!callback(k)) {\n                delete this.data[k];\n            }\n        });\n    }\n\n    /**\n     * returns a JSON-serializable POJO for this coverage map\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * returns an array for file paths for which this map has coverage\n     * @returns {Array{string}} - array of files\n     */\n    files() {\n        return Object.keys(this.data);\n    }\n\n    /**\n     * returns the file coverage for the specified file.\n     * @param {String} file\n     * @returns {FileCoverage}\n     */\n    fileCoverageFor(file) {\n        const fc = this.data[file];\n        if (!fc) {\n            throw new Error(`No file coverage available for: ${file}`);\n        }\n        return fc;\n    }\n\n    /**\n     * adds a file coverage object to this map. If the path for the object,\n     * already exists in the map, it is merged with the existing coverage\n     * otherwise a new key is added to the map.\n     * @param {FileCoverage} fc the file coverage to add\n     */\n    addFileCoverage(fc) {\n        const cov = new FileCoverage(fc);\n        const { path } = cov;\n        if (this.data[path]) {\n            this.data[path].merge(cov);\n        } else {\n            this.data[path] = cov;\n        }\n    }\n\n    /**\n     * returns the coverage summary for all the file coverage objects in this map.\n     * @returns {CoverageSummary}\n     */\n    getCoverageSummary() {\n        const ret = new CoverageSummary();\n        Object.values(this.data).forEach(fc => {\n            ret.merge(fc.toSummary());\n        });\n\n        return ret;\n    }\n}\n\nmodule.exports = {\n    CoverageMap\n};\n"]},"metadata":{},"sourceType":"script"}