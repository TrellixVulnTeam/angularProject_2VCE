{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Source = require(\"./Source\");\n\nvar SourceNode = require(\"source-map\").SourceNode;\n\nvar REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nfunction cloneAndPrefix(node, prefix, append) {\n  if (typeof node === \"string\") {\n    var result = node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n    if (append.length > 0) result = append.pop() + result;\n    if (/\\n$/.test(node)) append.push(prefix);\n    return result;\n  } else {\n    var newNode = new SourceNode(node.line, node.column, node.source, node.children.map(function (node) {\n      return cloneAndPrefix(node, prefix, append);\n    }), node.name);\n    newNode.sourceContents = node.sourceContents;\n    return newNode;\n  }\n}\n\n;\n\nvar PrefixSource = /*#__PURE__*/function (_Source) {\n  _inherits(PrefixSource, _Source);\n\n  var _super = _createSuper(PrefixSource);\n\n  function PrefixSource(prefix, source) {\n    var _this;\n\n    _classCallCheck(this, PrefixSource);\n\n    _this = _super.call(this);\n    _this._source = source;\n    _this._prefix = prefix;\n    return _this;\n  }\n\n  _createClass(PrefixSource, [{\n    key: \"source\",\n    value: function source() {\n      var node = typeof this._source === \"string\" ? this._source : this._source.source();\n      var prefix = this._prefix;\n      return prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n    }\n  }, {\n    key: \"node\",\n    value: function node(options) {\n      var node = this._source.node(options);\n\n      var prefix = this._prefix;\n      var output = [];\n      var result = new SourceNode();\n      node.walkSourceContents(function (source, content) {\n        result.setSourceContent(source, content);\n      });\n      var needPrefix = true;\n      node.walk(function (chunk, mapping) {\n        var parts = chunk.split(/(\\n)/);\n\n        for (var i = 0; i < parts.length; i += 2) {\n          var nl = i + 1 < parts.length;\n          var part = parts[i] + (nl ? \"\\n\" : \"\");\n\n          if (part) {\n            if (needPrefix) {\n              output.push(prefix);\n            }\n\n            output.push(new SourceNode(mapping.line, mapping.column, mapping.source, part, mapping.name));\n            needPrefix = nl;\n          }\n        }\n      });\n      result.add(output);\n      return result;\n    }\n  }, {\n    key: \"listMap\",\n    value: function listMap(options) {\n      var prefix = this._prefix;\n\n      var map = this._source.listMap(options);\n\n      return map.mapGeneratedCode(function (code) {\n        return prefix + code.replace(REPLACE_REGEX, \"\\n\" + prefix);\n      });\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      if (typeof this._source === \"string\") hash.update(this._source);else this._source.updateHash(hash);\n      if (typeof this._prefix === \"string\") hash.update(this._prefix);else this._prefix.updateHash(hash);\n    }\n  }]);\n\n  return PrefixSource;\n}(Source);\n\nrequire(\"./SourceAndMapMixin\")(PrefixSource.prototype);\n\nmodule.exports = PrefixSource;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack-sources/lib/PrefixSource.js"],"names":["Source","require","SourceNode","REPLACE_REGEX","cloneAndPrefix","node","prefix","append","result","replace","length","pop","test","push","newNode","line","column","source","children","map","name","sourceContents","PrefixSource","_source","_prefix","options","output","walkSourceContents","content","setSourceContent","needPrefix","walk","chunk","mapping","parts","split","i","nl","part","add","listMap","mapGeneratedCode","code","hash","update","updateHash","prototype","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar Source = require(\"./Source\");\nvar SourceNode = require(\"source-map\").SourceNode;\n\nvar REPLACE_REGEX = /\\n(?=.|\\s)/g;\n\nfunction cloneAndPrefix(node, prefix, append) {\n\tif(typeof node === \"string\") {\n\t\tvar result = node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t\tif(append.length > 0) result = append.pop() + result;\n\t\tif(/\\n$/.test(node)) append.push(prefix);\n\t\treturn result;\n\t} else {\n\t\tvar newNode = new SourceNode(\n\t\t\tnode.line,\n\t\t\tnode.column,\n\t\t\tnode.source,\n\t\t\tnode.children.map(function(node) {\n\t\t\t\treturn cloneAndPrefix(node, prefix, append);\n\t\t\t}),\n\t\t\tnode.name\n\t\t);\n\t\tnewNode.sourceContents = node.sourceContents;\n\t\treturn newNode;\n\t}\n};\n\nclass PrefixSource extends Source {\n\tconstructor(prefix, source) {\n\t\tsuper();\n\t\tthis._source = source;\n\t\tthis._prefix = prefix;\n\t}\n\n\tsource() {\n\t\tvar node = typeof this._source === \"string\" ? this._source : this._source.source();\n\t\tvar prefix = this._prefix;\n\t\treturn prefix + node.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t}\n\n\tnode(options) {\n\t\tvar node = this._source.node(options);\n\t\tvar prefix = this._prefix;\n\t\tvar output = [];\n\t\tvar result = new SourceNode();\n\t\tnode.walkSourceContents(function(source, content) {\n\t\t\tresult.setSourceContent(source, content);\n\t\t});\n\t\tvar needPrefix = true;\n\t\tnode.walk(function(chunk, mapping) {\n\t\t\tvar parts = chunk.split(/(\\n)/);\n\t\t\tfor(var i = 0; i < parts.length; i += 2) {\n\t\t\t\tvar nl = i + 1 < parts.length;\n\t\t\t\tvar part = parts[i] + (nl ? \"\\n\" : \"\");\n\t\t\t\tif(part) {\n\t\t\t\t\tif(needPrefix) {\n\t\t\t\t\t\toutput.push(prefix);\n\t\t\t\t\t}\n\t\t\t\t\toutput.push(new SourceNode(mapping.line, mapping.column, mapping.source, part, mapping.name));\n\t\t\t\t\tneedPrefix = nl;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tresult.add(output);\n\t\treturn result;\n\t}\n\n\tlistMap(options) {\n\t\tvar prefix = this._prefix;\n\t\tvar map = this._source.listMap(options);\n\t\treturn map.mapGeneratedCode(function(code) {\n\t\t\treturn prefix + code.replace(REPLACE_REGEX, \"\\n\" + prefix);\n\t\t});\n\t}\n\n\tupdateHash(hash) {\n\t\tif(typeof this._source === \"string\")\n\t\t\thash.update(this._source);\n\t\telse\n\t\t\tthis._source.updateHash(hash);\n\t\tif(typeof this._prefix === \"string\")\n\t\t\thash.update(this._prefix);\n\t\telse\n\t\t\tthis._prefix.updateHash(hash);\n\t}\n}\n\nrequire(\"./SourceAndMapMixin\")(PrefixSource.prototype);\n\nmodule.exports = PrefixSource;\n"]},"metadata":{},"sourceType":"script"}