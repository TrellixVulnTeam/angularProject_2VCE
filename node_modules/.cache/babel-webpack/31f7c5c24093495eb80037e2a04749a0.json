{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/reflection/src/typescript\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/reflection/src/host\", \"@angular/compiler-cli/src/ngtsc/reflection/src/type_to_value\", \"@angular/compiler-cli/src/ngtsc/reflection/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.reflectObjectLiteral = exports.findMember = exports.filterToMembersWithDecorator = exports.reflectTypeEntityToDeclaration = exports.reflectIdentifierOfDeclaration = exports.reflectNameOfDeclaration = exports.TypeScriptReflectionHost = void 0;\n\n  var ts = require(\"typescript\");\n\n  var host_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection/src/host\");\n\n  var type_to_value_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection/src/type_to_value\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection/src/util\");\n  /**\n   * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.\n   */\n\n\n  var TypeScriptReflectionHost =\n  /** @class */\n  function () {\n    function TypeScriptReflectionHost(checker) {\n      this.checker = checker;\n    }\n\n    TypeScriptReflectionHost.prototype.getDecoratorsOfDeclaration = function (declaration) {\n      var _this = this;\n\n      if (declaration.decorators === undefined || declaration.decorators.length === 0) {\n        return null;\n      }\n\n      return declaration.decorators.map(function (decorator) {\n        return _this._reflectDecorator(decorator);\n      }).filter(function (dec) {\n        return dec !== null;\n      });\n    };\n\n    TypeScriptReflectionHost.prototype.getMembersOfClass = function (clazz) {\n      var _this = this;\n\n      var tsClazz = castDeclarationToClassOrDie(clazz);\n      return tsClazz.members.map(function (member) {\n        return _this._reflectMember(member);\n      }).filter(function (member) {\n        return member !== null;\n      });\n    };\n\n    TypeScriptReflectionHost.prototype.getConstructorParameters = function (clazz) {\n      var _this = this;\n\n      var tsClazz = castDeclarationToClassOrDie(clazz);\n      var isDeclaration = tsClazz.getSourceFile().isDeclarationFile; // For non-declaration files, we want to find the constructor with a `body`. The constructors\n      // without a `body` are overloads whereas we want the implementation since it's the one that'll\n      // be executed and which can have decorators. For declaration files, we take the first one that\n      // we get.\n\n      var ctor = tsClazz.members.find(function (member) {\n        return ts.isConstructorDeclaration(member) && (isDeclaration || member.body !== undefined);\n      });\n\n      if (ctor === undefined) {\n        return null;\n      }\n\n      return ctor.parameters.map(function (node) {\n        // The name of the parameter is easy.\n        var name = parameterName(node.name);\n\n        var decorators = _this.getDecoratorsOfDeclaration(node); // It may or may not be possible to write an expression that refers to the value side of the\n        // type named for the parameter.\n\n\n        var originalTypeNode = node.type || null;\n        var typeNode = originalTypeNode; // Check if we are dealing with a simple nullable union type e.g. `foo: Foo|null`\n        // and extract the type. More complex union types e.g. `foo: Foo|Bar` are not supported.\n        // We also don't need to support `foo: Foo|undefined` because Angular's DI injects `null` for\n        // optional tokes that don't have providers.\n\n        if (typeNode && ts.isUnionTypeNode(typeNode)) {\n          var childTypeNodes = typeNode.types.filter(function (childTypeNode) {\n            return !(ts.isLiteralTypeNode(childTypeNode) && childTypeNode.literal.kind === ts.SyntaxKind.NullKeyword);\n          });\n\n          if (childTypeNodes.length === 1) {\n            typeNode = childTypeNodes[0];\n          }\n        }\n\n        var typeValueReference = type_to_value_1.typeToValue(typeNode, _this.checker);\n        return {\n          name: name,\n          nameNode: node.name,\n          typeValueReference: typeValueReference,\n          typeNode: originalTypeNode,\n          decorators: decorators\n        };\n      });\n    };\n\n    TypeScriptReflectionHost.prototype.getImportOfIdentifier = function (id) {\n      var directImport = this.getDirectImportOfIdentifier(id);\n\n      if (directImport !== null) {\n        return directImport;\n      } else if (ts.isQualifiedName(id.parent) && id.parent.right === id) {\n        return this.getImportOfNamespacedIdentifier(id, getQualifiedNameRoot(id.parent));\n      } else if (ts.isPropertyAccessExpression(id.parent) && id.parent.name === id) {\n        return this.getImportOfNamespacedIdentifier(id, getFarLeftIdentifier(id.parent));\n      } else {\n        return null;\n      }\n    };\n\n    TypeScriptReflectionHost.prototype.getExportsOfModule = function (node) {\n      var _this = this; // In TypeScript code, modules are only ts.SourceFiles. Throw if the node isn't a module.\n\n\n      if (!ts.isSourceFile(node)) {\n        throw new Error(\"getExportsOfModule() called on non-SourceFile in TS code\");\n      } // Reflect the module to a Symbol, and use getExportsOfModule() to get a list of exported\n      // Symbols.\n\n\n      var symbol = this.checker.getSymbolAtLocation(node);\n\n      if (symbol === undefined) {\n        return null;\n      }\n\n      var map = new Map();\n      this.checker.getExportsOfModule(symbol).forEach(function (exportSymbol) {\n        // Map each exported Symbol to a Declaration and add it to the map.\n        var decl = _this.getDeclarationOfSymbol(exportSymbol, null);\n\n        if (decl !== null) {\n          map.set(exportSymbol.name, decl);\n        }\n      });\n      return map;\n    };\n\n    TypeScriptReflectionHost.prototype.isClass = function (node) {\n      // For our purposes, classes are \"named\" ts.ClassDeclarations;\n      // (`node.name` can be undefined in unnamed default exports: `default export class { ... }`).\n      return util_1.isNamedClassDeclaration(node);\n    };\n\n    TypeScriptReflectionHost.prototype.hasBaseClass = function (clazz) {\n      return this.getBaseClassExpression(clazz) !== null;\n    };\n\n    TypeScriptReflectionHost.prototype.getBaseClassExpression = function (clazz) {\n      if (!(ts.isClassDeclaration(clazz) || ts.isClassExpression(clazz)) || clazz.heritageClauses === undefined) {\n        return null;\n      }\n\n      var extendsClause = clazz.heritageClauses.find(function (clause) {\n        return clause.token === ts.SyntaxKind.ExtendsKeyword;\n      });\n\n      if (extendsClause === undefined) {\n        return null;\n      }\n\n      var extendsType = extendsClause.types[0];\n\n      if (extendsType === undefined) {\n        return null;\n      }\n\n      return extendsType.expression;\n    };\n\n    TypeScriptReflectionHost.prototype.getDeclarationOfIdentifier = function (id) {\n      // Resolve the identifier to a Symbol, and return the declaration of that.\n      var symbol = this.checker.getSymbolAtLocation(id);\n\n      if (symbol === undefined) {\n        return null;\n      }\n\n      return this.getDeclarationOfSymbol(symbol, id);\n    };\n\n    TypeScriptReflectionHost.prototype.getDefinitionOfFunction = function (node) {\n      if (!ts.isFunctionDeclaration(node) && !ts.isMethodDeclaration(node) && !ts.isFunctionExpression(node)) {\n        return null;\n      }\n\n      return {\n        node: node,\n        body: node.body !== undefined ? Array.from(node.body.statements) : null,\n        parameters: node.parameters.map(function (param) {\n          var name = parameterName(param.name);\n          var initializer = param.initializer || null;\n          return {\n            name: name,\n            node: param,\n            initializer: initializer\n          };\n        })\n      };\n    };\n\n    TypeScriptReflectionHost.prototype.getGenericArityOfClass = function (clazz) {\n      if (!ts.isClassDeclaration(clazz)) {\n        return null;\n      }\n\n      return clazz.typeParameters !== undefined ? clazz.typeParameters.length : 0;\n    };\n\n    TypeScriptReflectionHost.prototype.getVariableValue = function (declaration) {\n      return declaration.initializer || null;\n    };\n\n    TypeScriptReflectionHost.prototype.getDtsDeclaration = function (_) {\n      return null;\n    };\n\n    TypeScriptReflectionHost.prototype.getInternalNameOfClass = function (clazz) {\n      return clazz.name;\n    };\n\n    TypeScriptReflectionHost.prototype.getAdjacentNameOfClass = function (clazz) {\n      return clazz.name;\n    };\n\n    TypeScriptReflectionHost.prototype.getDirectImportOfIdentifier = function (id) {\n      var symbol = this.checker.getSymbolAtLocation(id);\n\n      if (symbol === undefined || symbol.declarations === undefined || symbol.declarations.length !== 1) {\n        return null;\n      }\n\n      var decl = symbol.declarations[0];\n      var importDecl = getContainingImportDeclaration(decl); // Ignore declarations that are defined locally (not imported).\n\n      if (importDecl === null) {\n        return null;\n      } // The module specifier is guaranteed to be a string literal, so this should always pass.\n\n\n      if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n        // Not allowed to happen in TypeScript ASTs.\n        return null;\n      }\n\n      return {\n        from: importDecl.moduleSpecifier.text,\n        name: getExportedName(decl, id)\n      };\n    };\n    /**\n     * Try to get the import info for this identifier as though it is a namespaced import.\n     *\n     * For example, if the identifier is the `Directive` part of a qualified type chain like:\n     *\n     * ```\n     * core.Directive\n     * ```\n     *\n     * then it might be that `core` is a namespace import such as:\n     *\n     * ```\n     * import * as core from 'tslib';\n     * ```\n     *\n     * @param id the TypeScript identifier to find the import info for.\n     * @returns The import info if this is a namespaced import or `null`.\n     */\n\n\n    TypeScriptReflectionHost.prototype.getImportOfNamespacedIdentifier = function (id, namespaceIdentifier) {\n      if (namespaceIdentifier === null) {\n        return null;\n      }\n\n      var namespaceSymbol = this.checker.getSymbolAtLocation(namespaceIdentifier);\n\n      if (!namespaceSymbol) {\n        return null;\n      }\n\n      var declaration = namespaceSymbol.declarations.length === 1 ? namespaceSymbol.declarations[0] : null;\n\n      if (!declaration) {\n        return null;\n      }\n\n      var namespaceDeclaration = ts.isNamespaceImport(declaration) ? declaration : null;\n\n      if (!namespaceDeclaration) {\n        return null;\n      }\n\n      var importDeclaration = namespaceDeclaration.parent.parent;\n\n      if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) {\n        // Should not happen as this would be invalid TypesScript\n        return null;\n      }\n\n      return {\n        from: importDeclaration.moduleSpecifier.text,\n        name: id.text\n      };\n    };\n    /**\n     * Resolve a `ts.Symbol` to its declaration, keeping track of the `viaModule` along the way.\n     */\n\n\n    TypeScriptReflectionHost.prototype.getDeclarationOfSymbol = function (symbol, originalId) {\n      // If the symbol points to a ShorthandPropertyAssignment, resolve it.\n      var valueDeclaration = undefined;\n\n      if (symbol.valueDeclaration !== undefined) {\n        valueDeclaration = symbol.valueDeclaration;\n      } else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {\n        valueDeclaration = symbol.declarations[0];\n      }\n\n      if (valueDeclaration !== undefined && ts.isShorthandPropertyAssignment(valueDeclaration)) {\n        var shorthandSymbol = this.checker.getShorthandAssignmentValueSymbol(valueDeclaration);\n\n        if (shorthandSymbol === undefined) {\n          return null;\n        }\n\n        return this.getDeclarationOfSymbol(shorthandSymbol, originalId);\n      } else if (valueDeclaration !== undefined && ts.isExportSpecifier(valueDeclaration)) {\n        var targetSymbol = this.checker.getExportSpecifierLocalTargetSymbol(valueDeclaration);\n\n        if (targetSymbol === undefined) {\n          return null;\n        }\n\n        return this.getDeclarationOfSymbol(targetSymbol, originalId);\n      }\n\n      var importInfo = originalId && this.getImportOfIdentifier(originalId);\n      var viaModule = importInfo !== null && importInfo.from !== null && !importInfo.from.startsWith('.') ? importInfo.from : null; // Now, resolve the Symbol to its declaration by following any and all aliases.\n\n      while (symbol.flags & ts.SymbolFlags.Alias) {\n        symbol = this.checker.getAliasedSymbol(symbol);\n      } // Look at the resolved Symbol's declarations and pick one of them to return. Value declarations\n      // are given precedence over type declarations.\n\n\n      if (symbol.valueDeclaration !== undefined) {\n        return {\n          node: symbol.valueDeclaration,\n          known: null,\n          viaModule: viaModule,\n          identity: null,\n          kind: 0\n          /* Concrete */\n\n        };\n      } else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {\n        return {\n          node: symbol.declarations[0],\n          known: null,\n          viaModule: viaModule,\n          identity: null,\n          kind: 0\n          /* Concrete */\n\n        };\n      } else {\n        return null;\n      }\n    };\n\n    TypeScriptReflectionHost.prototype._reflectDecorator = function (node) {\n      // Attempt to resolve the decorator expression into a reference to a concrete Identifier. The\n      // expression may contain a call to a function which returns the decorator function, in which\n      // case we want to return the arguments.\n      var decoratorExpr = node.expression;\n      var args = null; // Check for call expressions.\n\n      if (ts.isCallExpression(decoratorExpr)) {\n        args = Array.from(decoratorExpr.arguments);\n        decoratorExpr = decoratorExpr.expression;\n      } // The final resolved decorator should be a `ts.Identifier` - if it's not, then something is\n      // wrong and the decorator can't be resolved statically.\n\n\n      if (!host_1.isDecoratorIdentifier(decoratorExpr)) {\n        return null;\n      }\n\n      var decoratorIdentifier = ts.isIdentifier(decoratorExpr) ? decoratorExpr : decoratorExpr.name;\n      var importDecl = this.getImportOfIdentifier(decoratorIdentifier);\n      return {\n        name: decoratorIdentifier.text,\n        identifier: decoratorExpr,\n        import: importDecl,\n        node: node,\n        args: args\n      };\n    };\n\n    TypeScriptReflectionHost.prototype._reflectMember = function (node) {\n      var kind = null;\n      var value = null;\n      var name = null;\n      var nameNode = null;\n\n      if (ts.isPropertyDeclaration(node)) {\n        kind = host_1.ClassMemberKind.Property;\n        value = node.initializer || null;\n      } else if (ts.isGetAccessorDeclaration(node)) {\n        kind = host_1.ClassMemberKind.Getter;\n      } else if (ts.isSetAccessorDeclaration(node)) {\n        kind = host_1.ClassMemberKind.Setter;\n      } else if (ts.isMethodDeclaration(node)) {\n        kind = host_1.ClassMemberKind.Method;\n      } else if (ts.isConstructorDeclaration(node)) {\n        kind = host_1.ClassMemberKind.Constructor;\n      } else {\n        return null;\n      }\n\n      if (ts.isConstructorDeclaration(node)) {\n        name = 'constructor';\n      } else if (ts.isIdentifier(node.name)) {\n        name = node.name.text;\n        nameNode = node.name;\n      } else if (ts.isStringLiteral(node.name)) {\n        name = node.name.text;\n        nameNode = node.name;\n      } else {\n        return null;\n      }\n\n      var decorators = this.getDecoratorsOfDeclaration(node);\n      var isStatic = node.modifiers !== undefined && node.modifiers.some(function (mod) {\n        return mod.kind === ts.SyntaxKind.StaticKeyword;\n      });\n      return {\n        node: node,\n        implementation: node,\n        kind: kind,\n        type: node.type || null,\n        name: name,\n        nameNode: nameNode,\n        decorators: decorators,\n        value: value,\n        isStatic: isStatic\n      };\n    };\n\n    return TypeScriptReflectionHost;\n  }();\n\n  exports.TypeScriptReflectionHost = TypeScriptReflectionHost;\n\n  function reflectNameOfDeclaration(decl) {\n    var id = reflectIdentifierOfDeclaration(decl);\n    return id && id.text || null;\n  }\n\n  exports.reflectNameOfDeclaration = reflectNameOfDeclaration;\n\n  function reflectIdentifierOfDeclaration(decl) {\n    if (ts.isClassDeclaration(decl) || ts.isFunctionDeclaration(decl)) {\n      return decl.name || null;\n    } else if (ts.isVariableDeclaration(decl)) {\n      if (ts.isIdentifier(decl.name)) {\n        return decl.name;\n      }\n    }\n\n    return null;\n  }\n\n  exports.reflectIdentifierOfDeclaration = reflectIdentifierOfDeclaration;\n\n  function reflectTypeEntityToDeclaration(type, checker) {\n    var realSymbol = checker.getSymbolAtLocation(type);\n\n    if (realSymbol === undefined) {\n      throw new Error(\"Cannot resolve type entity \" + type.getText() + \" to symbol\");\n    }\n\n    while (realSymbol.flags & ts.SymbolFlags.Alias) {\n      realSymbol = checker.getAliasedSymbol(realSymbol);\n    }\n\n    var node = null;\n\n    if (realSymbol.valueDeclaration !== undefined) {\n      node = realSymbol.valueDeclaration;\n    } else if (realSymbol.declarations !== undefined && realSymbol.declarations.length === 1) {\n      node = realSymbol.declarations[0];\n    } else {\n      throw new Error(\"Cannot resolve type entity symbol to declaration\");\n    }\n\n    if (ts.isQualifiedName(type)) {\n      if (!ts.isIdentifier(type.left)) {\n        throw new Error(\"Cannot handle qualified name with non-identifier lhs\");\n      }\n\n      var symbol = checker.getSymbolAtLocation(type.left);\n\n      if (symbol === undefined || symbol.declarations === undefined || symbol.declarations.length !== 1) {\n        throw new Error(\"Cannot resolve qualified type entity lhs to symbol\");\n      }\n\n      var decl = symbol.declarations[0];\n\n      if (ts.isNamespaceImport(decl)) {\n        var clause = decl.parent;\n        var importDecl = clause.parent;\n\n        if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n          throw new Error(\"Module specifier is not a string\");\n        }\n\n        return {\n          node: node,\n          from: importDecl.moduleSpecifier.text\n        };\n      } else {\n        throw new Error(\"Unknown import type?\");\n      }\n    } else {\n      return {\n        node: node,\n        from: null\n      };\n    }\n  }\n\n  exports.reflectTypeEntityToDeclaration = reflectTypeEntityToDeclaration;\n\n  function filterToMembersWithDecorator(members, name, module) {\n    return members.filter(function (member) {\n      return !member.isStatic;\n    }).map(function (member) {\n      if (member.decorators === null) {\n        return null;\n      }\n\n      var decorators = member.decorators.filter(function (dec) {\n        if (dec.import !== null) {\n          return dec.import.name === name && (module === undefined || dec.import.from === module);\n        } else {\n          return dec.name === name && module === undefined;\n        }\n      });\n\n      if (decorators.length === 0) {\n        return null;\n      }\n\n      return {\n        member: member,\n        decorators: decorators\n      };\n    }).filter(function (value) {\n      return value !== null;\n    });\n  }\n\n  exports.filterToMembersWithDecorator = filterToMembersWithDecorator;\n\n  function findMember(members, name, isStatic) {\n    if (isStatic === void 0) {\n      isStatic = false;\n    }\n\n    return members.find(function (member) {\n      return member.isStatic === isStatic && member.name === name;\n    }) || null;\n  }\n\n  exports.findMember = findMember;\n\n  function reflectObjectLiteral(node) {\n    var map = new Map();\n    node.properties.forEach(function (prop) {\n      if (ts.isPropertyAssignment(prop)) {\n        var name_1 = propertyNameToString(prop.name);\n\n        if (name_1 === null) {\n          return;\n        }\n\n        map.set(name_1, prop.initializer);\n      } else if (ts.isShorthandPropertyAssignment(prop)) {\n        map.set(prop.name.text, prop.name);\n      } else {\n        return;\n      }\n    });\n    return map;\n  }\n\n  exports.reflectObjectLiteral = reflectObjectLiteral;\n\n  function castDeclarationToClassOrDie(declaration) {\n    if (!ts.isClassDeclaration(declaration)) {\n      throw new Error(\"Reflecting on a \" + ts.SyntaxKind[declaration.kind] + \" instead of a ClassDeclaration.\");\n    }\n\n    return declaration;\n  }\n\n  function parameterName(name) {\n    if (ts.isIdentifier(name)) {\n      return name.text;\n    } else {\n      return null;\n    }\n  }\n\n  function propertyNameToString(node) {\n    if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n      return node.text;\n    } else {\n      return null;\n    }\n  }\n  /**\n   * Compute the left most identifier in a qualified type chain. E.g. the `a` of `a.b.c.SomeType`.\n   * @param qualifiedName The starting property access expression from which we want to compute\n   * the left most identifier.\n   * @returns the left most identifier in the chain or `null` if it is not an identifier.\n   */\n\n\n  function getQualifiedNameRoot(qualifiedName) {\n    while (ts.isQualifiedName(qualifiedName.left)) {\n      qualifiedName = qualifiedName.left;\n    }\n\n    return ts.isIdentifier(qualifiedName.left) ? qualifiedName.left : null;\n  }\n  /**\n   * Compute the left most identifier in a property access chain. E.g. the `a` of `a.b.c.d`.\n   * @param propertyAccess The starting property access expression from which we want to compute\n   * the left most identifier.\n   * @returns the left most identifier in the chain or `null` if it is not an identifier.\n   */\n\n\n  function getFarLeftIdentifier(propertyAccess) {\n    while (ts.isPropertyAccessExpression(propertyAccess.expression)) {\n      propertyAccess = propertyAccess.expression;\n    }\n\n    return ts.isIdentifier(propertyAccess.expression) ? propertyAccess.expression : null;\n  }\n  /**\n   * Return the ImportDeclaration for the given `node` if it is either an `ImportSpecifier` or a\n   * `NamespaceImport`. If not return `null`.\n   */\n\n\n  function getContainingImportDeclaration(node) {\n    return ts.isImportSpecifier(node) ? node.parent.parent.parent : ts.isNamespaceImport(node) ? node.parent.parent : null;\n  }\n  /**\n   * Compute the name by which the `decl` was exported, not imported.\n   * If no such declaration can be found (e.g. it is a namespace import)\n   * then fallback to the `originalId`.\n   */\n\n\n  function getExportedName(decl, originalId) {\n    return ts.isImportSpecifier(decl) ? (decl.propertyName !== undefined ? decl.propertyName : decl.name).text : originalId.text;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/reflection/src/typescript.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ClassDeclaration, ClassMember, ClassMemberKind, CtorParameter, Declaration, DeclarationKind, DeclarationNode, Decorator, FunctionDefinition, Import, isDecoratorIdentifier, ReflectionHost} from './host';\nimport {typeToValue} from './type_to_value';\nimport {isNamedClassDeclaration} from './util';\n\n/**\n * reflector.ts implements static reflection of declarations using the TypeScript `ts.TypeChecker`.\n */\n\nexport class TypeScriptReflectionHost implements ReflectionHost {\n  constructor(protected checker: ts.TypeChecker) {}\n\n  getDecoratorsOfDeclaration(declaration: DeclarationNode): Decorator[]|null {\n    if (declaration.decorators === undefined || declaration.decorators.length === 0) {\n      return null;\n    }\n    return declaration.decorators.map(decorator => this._reflectDecorator(decorator))\n        .filter((dec): dec is Decorator => dec !== null);\n  }\n\n  getMembersOfClass(clazz: ClassDeclaration): ClassMember[] {\n    const tsClazz = castDeclarationToClassOrDie(clazz);\n    return tsClazz.members.map(member => this._reflectMember(member))\n        .filter((member): member is ClassMember => member !== null);\n  }\n\n  getConstructorParameters(clazz: ClassDeclaration): CtorParameter[]|null {\n    const tsClazz = castDeclarationToClassOrDie(clazz);\n\n    const isDeclaration = tsClazz.getSourceFile().isDeclarationFile;\n    // For non-declaration files, we want to find the constructor with a `body`. The constructors\n    // without a `body` are overloads whereas we want the implementation since it's the one that'll\n    // be executed and which can have decorators. For declaration files, we take the first one that\n    // we get.\n    const ctor = tsClazz.members.find(\n        (member): member is ts.ConstructorDeclaration =>\n            ts.isConstructorDeclaration(member) && (isDeclaration || member.body !== undefined));\n    if (ctor === undefined) {\n      return null;\n    }\n\n    return ctor.parameters.map(node => {\n      // The name of the parameter is easy.\n      const name = parameterName(node.name);\n\n      const decorators = this.getDecoratorsOfDeclaration(node);\n\n      // It may or may not be possible to write an expression that refers to the value side of the\n      // type named for the parameter.\n\n      let originalTypeNode = node.type || null;\n      let typeNode = originalTypeNode;\n\n      // Check if we are dealing with a simple nullable union type e.g. `foo: Foo|null`\n      // and extract the type. More complex union types e.g. `foo: Foo|Bar` are not supported.\n      // We also don't need to support `foo: Foo|undefined` because Angular's DI injects `null` for\n      // optional tokes that don't have providers.\n      if (typeNode && ts.isUnionTypeNode(typeNode)) {\n        let childTypeNodes = typeNode.types.filter(\n            childTypeNode =>\n                !(ts.isLiteralTypeNode(childTypeNode) &&\n                  childTypeNode.literal.kind === ts.SyntaxKind.NullKeyword));\n\n        if (childTypeNodes.length === 1) {\n          typeNode = childTypeNodes[0];\n        }\n      }\n\n      const typeValueReference = typeToValue(typeNode, this.checker);\n\n      return {\n        name,\n        nameNode: node.name,\n        typeValueReference,\n        typeNode: originalTypeNode,\n        decorators,\n      };\n    });\n  }\n\n  getImportOfIdentifier(id: ts.Identifier): Import|null {\n    const directImport = this.getDirectImportOfIdentifier(id);\n    if (directImport !== null) {\n      return directImport;\n    } else if (ts.isQualifiedName(id.parent) && id.parent.right === id) {\n      return this.getImportOfNamespacedIdentifier(id, getQualifiedNameRoot(id.parent));\n    } else if (ts.isPropertyAccessExpression(id.parent) && id.parent.name === id) {\n      return this.getImportOfNamespacedIdentifier(id, getFarLeftIdentifier(id.parent));\n    } else {\n      return null;\n    }\n  }\n\n  getExportsOfModule(node: ts.Node): Map<string, Declaration>|null {\n    // In TypeScript code, modules are only ts.SourceFiles. Throw if the node isn't a module.\n    if (!ts.isSourceFile(node)) {\n      throw new Error(`getExportsOfModule() called on non-SourceFile in TS code`);\n    }\n\n    // Reflect the module to a Symbol, and use getExportsOfModule() to get a list of exported\n    // Symbols.\n    const symbol = this.checker.getSymbolAtLocation(node);\n    if (symbol === undefined) {\n      return null;\n    }\n\n    const map = new Map<string, Declaration>();\n    this.checker.getExportsOfModule(symbol).forEach(exportSymbol => {\n      // Map each exported Symbol to a Declaration and add it to the map.\n      const decl = this.getDeclarationOfSymbol(exportSymbol, null);\n      if (decl !== null) {\n        map.set(exportSymbol.name, decl);\n      }\n    });\n    return map;\n  }\n\n  isClass(node: ts.Node): node is ClassDeclaration {\n    // For our purposes, classes are \"named\" ts.ClassDeclarations;\n    // (`node.name` can be undefined in unnamed default exports: `default export class { ... }`).\n    return isNamedClassDeclaration(node);\n  }\n\n  hasBaseClass(clazz: ClassDeclaration): boolean {\n    return this.getBaseClassExpression(clazz) !== null;\n  }\n\n  getBaseClassExpression(clazz: ClassDeclaration): ts.Expression|null {\n    if (!(ts.isClassDeclaration(clazz) || ts.isClassExpression(clazz)) ||\n        clazz.heritageClauses === undefined) {\n      return null;\n    }\n    const extendsClause =\n        clazz.heritageClauses.find(clause => clause.token === ts.SyntaxKind.ExtendsKeyword);\n    if (extendsClause === undefined) {\n      return null;\n    }\n    const extendsType = extendsClause.types[0];\n    if (extendsType === undefined) {\n      return null;\n    }\n    return extendsType.expression;\n  }\n\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null {\n    // Resolve the identifier to a Symbol, and return the declaration of that.\n    let symbol: ts.Symbol|undefined = this.checker.getSymbolAtLocation(id);\n    if (symbol === undefined) {\n      return null;\n    }\n    return this.getDeclarationOfSymbol(symbol, id);\n  }\n\n  getDefinitionOfFunction(node: ts.Node): FunctionDefinition|null {\n    if (!ts.isFunctionDeclaration(node) && !ts.isMethodDeclaration(node) &&\n        !ts.isFunctionExpression(node)) {\n      return null;\n    }\n    return {\n      node,\n      body: node.body !== undefined ? Array.from(node.body.statements) : null,\n      parameters: node.parameters.map(param => {\n        const name = parameterName(param.name);\n        const initializer = param.initializer || null;\n        return {name, node: param, initializer};\n      }),\n    };\n  }\n\n  getGenericArityOfClass(clazz: ClassDeclaration): number|null {\n    if (!ts.isClassDeclaration(clazz)) {\n      return null;\n    }\n    return clazz.typeParameters !== undefined ? clazz.typeParameters.length : 0;\n  }\n\n  getVariableValue(declaration: ts.VariableDeclaration): ts.Expression|null {\n    return declaration.initializer || null;\n  }\n\n  getDtsDeclaration(_: ClassDeclaration): ts.Declaration|null {\n    return null;\n  }\n\n  getInternalNameOfClass(clazz: ClassDeclaration): ts.Identifier {\n    return clazz.name;\n  }\n\n  getAdjacentNameOfClass(clazz: ClassDeclaration): ts.Identifier {\n    return clazz.name;\n  }\n\n  protected getDirectImportOfIdentifier(id: ts.Identifier): Import|null {\n    const symbol = this.checker.getSymbolAtLocation(id);\n\n    if (symbol === undefined || symbol.declarations === undefined ||\n        symbol.declarations.length !== 1) {\n      return null;\n    }\n\n    const decl = symbol.declarations[0];\n    const importDecl = getContainingImportDeclaration(decl);\n\n    // Ignore declarations that are defined locally (not imported).\n    if (importDecl === null) {\n      return null;\n    }\n\n    // The module specifier is guaranteed to be a string literal, so this should always pass.\n    if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n      // Not allowed to happen in TypeScript ASTs.\n      return null;\n    }\n\n    return {from: importDecl.moduleSpecifier.text, name: getExportedName(decl, id)};\n  }\n\n  /**\n   * Try to get the import info for this identifier as though it is a namespaced import.\n   *\n   * For example, if the identifier is the `Directive` part of a qualified type chain like:\n   *\n   * ```\n   * core.Directive\n   * ```\n   *\n   * then it might be that `core` is a namespace import such as:\n   *\n   * ```\n   * import * as core from 'tslib';\n   * ```\n   *\n   * @param id the TypeScript identifier to find the import info for.\n   * @returns The import info if this is a namespaced import or `null`.\n   */\n  protected getImportOfNamespacedIdentifier(\n      id: ts.Identifier, namespaceIdentifier: ts.Identifier|null): Import|null {\n    if (namespaceIdentifier === null) {\n      return null;\n    }\n    const namespaceSymbol = this.checker.getSymbolAtLocation(namespaceIdentifier);\n    if (!namespaceSymbol) {\n      return null;\n    }\n    const declaration =\n        namespaceSymbol.declarations.length === 1 ? namespaceSymbol.declarations[0] : null;\n    if (!declaration) {\n      return null;\n    }\n    const namespaceDeclaration = ts.isNamespaceImport(declaration) ? declaration : null;\n    if (!namespaceDeclaration) {\n      return null;\n    }\n\n    const importDeclaration = namespaceDeclaration.parent.parent;\n    if (!ts.isStringLiteral(importDeclaration.moduleSpecifier)) {\n      // Should not happen as this would be invalid TypesScript\n      return null;\n    }\n\n    return {\n      from: importDeclaration.moduleSpecifier.text,\n      name: id.text,\n    };\n  }\n\n  /**\n   * Resolve a `ts.Symbol` to its declaration, keeping track of the `viaModule` along the way.\n   */\n  protected getDeclarationOfSymbol(symbol: ts.Symbol, originalId: ts.Identifier|null): Declaration\n      |null {\n    // If the symbol points to a ShorthandPropertyAssignment, resolve it.\n    let valueDeclaration: ts.Declaration|undefined = undefined;\n    if (symbol.valueDeclaration !== undefined) {\n      valueDeclaration = symbol.valueDeclaration;\n    } else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {\n      valueDeclaration = symbol.declarations[0];\n    }\n    if (valueDeclaration !== undefined && ts.isShorthandPropertyAssignment(valueDeclaration)) {\n      const shorthandSymbol = this.checker.getShorthandAssignmentValueSymbol(valueDeclaration);\n      if (shorthandSymbol === undefined) {\n        return null;\n      }\n      return this.getDeclarationOfSymbol(shorthandSymbol, originalId);\n    } else if (valueDeclaration !== undefined && ts.isExportSpecifier(valueDeclaration)) {\n      const targetSymbol = this.checker.getExportSpecifierLocalTargetSymbol(valueDeclaration);\n      if (targetSymbol === undefined) {\n        return null;\n      }\n      return this.getDeclarationOfSymbol(targetSymbol, originalId);\n    }\n\n    const importInfo = originalId && this.getImportOfIdentifier(originalId);\n    const viaModule =\n        importInfo !== null && importInfo.from !== null && !importInfo.from.startsWith('.') ?\n        importInfo.from :\n        null;\n\n    // Now, resolve the Symbol to its declaration by following any and all aliases.\n    while (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = this.checker.getAliasedSymbol(symbol);\n    }\n\n    // Look at the resolved Symbol's declarations and pick one of them to return. Value declarations\n    // are given precedence over type declarations.\n    if (symbol.valueDeclaration !== undefined) {\n      return {\n        node: symbol.valueDeclaration,\n        known: null,\n        viaModule,\n        identity: null,\n        kind: DeclarationKind.Concrete,\n      };\n    } else if (symbol.declarations !== undefined && symbol.declarations.length > 0) {\n      return {\n        node: symbol.declarations[0],\n        known: null,\n        viaModule,\n        identity: null,\n        kind: DeclarationKind.Concrete,\n      };\n    } else {\n      return null;\n    }\n  }\n\n  private _reflectDecorator(node: ts.Decorator): Decorator|null {\n    // Attempt to resolve the decorator expression into a reference to a concrete Identifier. The\n    // expression may contain a call to a function which returns the decorator function, in which\n    // case we want to return the arguments.\n    let decoratorExpr: ts.Expression = node.expression;\n    let args: ts.Expression[]|null = null;\n\n    // Check for call expressions.\n    if (ts.isCallExpression(decoratorExpr)) {\n      args = Array.from(decoratorExpr.arguments);\n      decoratorExpr = decoratorExpr.expression;\n    }\n\n    // The final resolved decorator should be a `ts.Identifier` - if it's not, then something is\n    // wrong and the decorator can't be resolved statically.\n    if (!isDecoratorIdentifier(decoratorExpr)) {\n      return null;\n    }\n\n    const decoratorIdentifier = ts.isIdentifier(decoratorExpr) ? decoratorExpr : decoratorExpr.name;\n    const importDecl = this.getImportOfIdentifier(decoratorIdentifier);\n\n    return {\n      name: decoratorIdentifier.text,\n      identifier: decoratorExpr,\n      import: importDecl,\n      node,\n      args,\n    };\n  }\n\n  private _reflectMember(node: ts.ClassElement): ClassMember|null {\n    let kind: ClassMemberKind|null = null;\n    let value: ts.Expression|null = null;\n    let name: string|null = null;\n    let nameNode: ts.Identifier|ts.StringLiteral|null = null;\n\n    if (ts.isPropertyDeclaration(node)) {\n      kind = ClassMemberKind.Property;\n      value = node.initializer || null;\n    } else if (ts.isGetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Getter;\n    } else if (ts.isSetAccessorDeclaration(node)) {\n      kind = ClassMemberKind.Setter;\n    } else if (ts.isMethodDeclaration(node)) {\n      kind = ClassMemberKind.Method;\n    } else if (ts.isConstructorDeclaration(node)) {\n      kind = ClassMemberKind.Constructor;\n    } else {\n      return null;\n    }\n\n    if (ts.isConstructorDeclaration(node)) {\n      name = 'constructor';\n    } else if (ts.isIdentifier(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else if (ts.isStringLiteral(node.name)) {\n      name = node.name.text;\n      nameNode = node.name;\n    } else {\n      return null;\n    }\n\n    const decorators = this.getDecoratorsOfDeclaration(node);\n    const isStatic = node.modifiers !== undefined &&\n        node.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);\n\n    return {\n      node,\n      implementation: node,\n      kind,\n      type: node.type || null,\n      name,\n      nameNode,\n      decorators,\n      value,\n      isStatic,\n    };\n  }\n}\n\nexport function reflectNameOfDeclaration(decl: ts.Declaration): string|null {\n  const id = reflectIdentifierOfDeclaration(decl);\n  return id && id.text || null;\n}\n\nexport function reflectIdentifierOfDeclaration(decl: ts.Declaration): ts.Identifier|null {\n  if (ts.isClassDeclaration(decl) || ts.isFunctionDeclaration(decl)) {\n    return decl.name || null;\n  } else if (ts.isVariableDeclaration(decl)) {\n    if (ts.isIdentifier(decl.name)) {\n      return decl.name;\n    }\n  }\n  return null;\n}\n\nexport function reflectTypeEntityToDeclaration(\n    type: ts.EntityName, checker: ts.TypeChecker): {node: ts.Declaration, from: string|null} {\n  let realSymbol = checker.getSymbolAtLocation(type);\n  if (realSymbol === undefined) {\n    throw new Error(`Cannot resolve type entity ${type.getText()} to symbol`);\n  }\n  while (realSymbol.flags & ts.SymbolFlags.Alias) {\n    realSymbol = checker.getAliasedSymbol(realSymbol);\n  }\n\n  let node: ts.Declaration|null = null;\n  if (realSymbol.valueDeclaration !== undefined) {\n    node = realSymbol.valueDeclaration;\n  } else if (realSymbol.declarations !== undefined && realSymbol.declarations.length === 1) {\n    node = realSymbol.declarations[0];\n  } else {\n    throw new Error(`Cannot resolve type entity symbol to declaration`);\n  }\n\n  if (ts.isQualifiedName(type)) {\n    if (!ts.isIdentifier(type.left)) {\n      throw new Error(`Cannot handle qualified name with non-identifier lhs`);\n    }\n    const symbol = checker.getSymbolAtLocation(type.left);\n    if (symbol === undefined || symbol.declarations === undefined ||\n        symbol.declarations.length !== 1) {\n      throw new Error(`Cannot resolve qualified type entity lhs to symbol`);\n    }\n    const decl = symbol.declarations[0];\n    if (ts.isNamespaceImport(decl)) {\n      const clause = decl.parent!;\n      const importDecl = clause.parent!;\n      if (!ts.isStringLiteral(importDecl.moduleSpecifier)) {\n        throw new Error(`Module specifier is not a string`);\n      }\n      return {node, from: importDecl.moduleSpecifier.text};\n    } else {\n      throw new Error(`Unknown import type?`);\n    }\n  } else {\n    return {node, from: null};\n  }\n}\n\nexport function filterToMembersWithDecorator(members: ClassMember[], name: string, module?: string):\n    {member: ClassMember, decorators: Decorator[]}[] {\n  return members.filter(member => !member.isStatic)\n      .map(member => {\n        if (member.decorators === null) {\n          return null;\n        }\n\n        const decorators = member.decorators.filter(dec => {\n          if (dec.import !== null) {\n            return dec.import.name === name && (module === undefined || dec.import.from === module);\n          } else {\n            return dec.name === name && module === undefined;\n          }\n        });\n\n        if (decorators.length === 0) {\n          return null;\n        }\n\n        return {member, decorators};\n      })\n      .filter((value): value is {member: ClassMember, decorators: Decorator[]} => value !== null);\n}\n\nexport function findMember(\n    members: ClassMember[], name: string, isStatic: boolean = false): ClassMember|null {\n  return members.find(member => member.isStatic === isStatic && member.name === name) || null;\n}\n\nexport function reflectObjectLiteral(node: ts.ObjectLiteralExpression): Map<string, ts.Expression> {\n  const map = new Map<string, ts.Expression>();\n  node.properties.forEach(prop => {\n    if (ts.isPropertyAssignment(prop)) {\n      const name = propertyNameToString(prop.name);\n      if (name === null) {\n        return;\n      }\n      map.set(name, prop.initializer);\n    } else if (ts.isShorthandPropertyAssignment(prop)) {\n      map.set(prop.name.text, prop.name);\n    } else {\n      return;\n    }\n  });\n  return map;\n}\n\nfunction castDeclarationToClassOrDie(declaration: ClassDeclaration):\n    ClassDeclaration<ts.ClassDeclaration> {\n  if (!ts.isClassDeclaration(declaration)) {\n    throw new Error(\n        `Reflecting on a ${ts.SyntaxKind[declaration.kind]} instead of a ClassDeclaration.`);\n  }\n  return declaration;\n}\n\nfunction parameterName(name: ts.BindingName): string|null {\n  if (ts.isIdentifier(name)) {\n    return name.text;\n  } else {\n    return null;\n  }\n}\n\nfunction propertyNameToString(node: ts.PropertyName): string|null {\n  if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n    return node.text;\n  } else {\n    return null;\n  }\n}\n\n/**\n * Compute the left most identifier in a qualified type chain. E.g. the `a` of `a.b.c.SomeType`.\n * @param qualifiedName The starting property access expression from which we want to compute\n * the left most identifier.\n * @returns the left most identifier in the chain or `null` if it is not an identifier.\n */\nfunction getQualifiedNameRoot(qualifiedName: ts.QualifiedName): ts.Identifier|null {\n  while (ts.isQualifiedName(qualifiedName.left)) {\n    qualifiedName = qualifiedName.left;\n  }\n  return ts.isIdentifier(qualifiedName.left) ? qualifiedName.left : null;\n}\n\n/**\n * Compute the left most identifier in a property access chain. E.g. the `a` of `a.b.c.d`.\n * @param propertyAccess The starting property access expression from which we want to compute\n * the left most identifier.\n * @returns the left most identifier in the chain or `null` if it is not an identifier.\n */\nfunction getFarLeftIdentifier(propertyAccess: ts.PropertyAccessExpression): ts.Identifier|null {\n  while (ts.isPropertyAccessExpression(propertyAccess.expression)) {\n    propertyAccess = propertyAccess.expression;\n  }\n  return ts.isIdentifier(propertyAccess.expression) ? propertyAccess.expression : null;\n}\n\n/**\n * Return the ImportDeclaration for the given `node` if it is either an `ImportSpecifier` or a\n * `NamespaceImport`. If not return `null`.\n */\nfunction getContainingImportDeclaration(node: ts.Node): ts.ImportDeclaration|null {\n  return ts.isImportSpecifier(node) ? node.parent!.parent!.parent! :\n                                      ts.isNamespaceImport(node) ? node.parent.parent : null;\n}\n\n/**\n * Compute the name by which the `decl` was exported, not imported.\n * If no such declaration can be found (e.g. it is a namespace import)\n * then fallback to the `originalId`.\n */\nfunction getExportedName(decl: ts.Declaration, originalId: ts.Identifier): string {\n  return ts.isImportSpecifier(decl) ?\n      (decl.propertyName !== undefined ? decl.propertyName : decl.name).text :\n      originalId.text;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}