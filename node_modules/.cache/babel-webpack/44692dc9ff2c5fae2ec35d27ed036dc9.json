{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncIterator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.i18nInlineEmittedFiles = void 0;\n\nvar fs = require(\"fs\");\n\nvar path = require(\"path\");\n\nvar action_executor_1 = require(\"./action-executor\");\n\nvar copy_assets_1 = require(\"./copy-assets\");\n\nvar spinner_1 = require(\"./spinner\");\n\nfunction emittedFilesToInlineOptions(emittedFiles, scriptsEntryPointName, emittedPath, outputPath, es5, missingTranslation) {\n  var options = [];\n  var originalFiles = [];\n\n  var _iterator3 = _createForOfIteratorHelper(emittedFiles),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var emittedFile = _step3.value;\n\n      if (emittedFile.asset || emittedFile.extension !== '.js' || emittedFile.name && scriptsEntryPointName.includes(emittedFile.name)) {\n        continue;\n      }\n\n      var originalPath = path.join(emittedPath, emittedFile.file);\n      var action = {\n        filename: emittedFile.file,\n        code: fs.readFileSync(originalPath, 'utf8'),\n        es5: es5,\n        outputPath: outputPath,\n        missingTranslation: missingTranslation,\n        setLocale: emittedFile.name === 'main' || emittedFile.name === 'vendor'\n      };\n      originalFiles.push(originalPath);\n\n      try {\n        var originalMapPath = originalPath + '.map';\n        action.map = fs.readFileSync(originalMapPath, 'utf8');\n        originalFiles.push(originalMapPath);\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n\n      options.push(action);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return {\n    options: options,\n    originalFiles: originalFiles\n  };\n}\n\nfunction i18nInlineEmittedFiles(context, emittedFiles, i18n, baseOutputPath, outputPaths, scriptsEntryPointName, emittedPath, es5, missingTranslation) {\n  var executor, hasErrors, spinner, _emittedFilesToInline, options, processedFiles, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, result, _iterator2, _step2, diagnostic;\n\n  return _regeneratorRuntime.async(function i18nInlineEmittedFiles$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          executor = new action_executor_1.BundleActionExecutor({\n            i18n: i18n\n          });\n          hasErrors = false;\n          spinner = new spinner_1.Spinner();\n          spinner.start('Generating localized bundles...');\n          _context.prev = 4;\n          _emittedFilesToInline = emittedFilesToInlineOptions(emittedFiles, scriptsEntryPointName, emittedPath, baseOutputPath, es5, missingTranslation), options = _emittedFilesToInline.options, processedFiles = _emittedFilesToInline.originalFiles;\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _context.prev = 8;\n          _iterator = _asyncIterator(executor.inlineAll(options));\n\n        case 10:\n          _context.next = 12;\n          return _regeneratorRuntime.awrap(_iterator.next());\n\n        case 12:\n          _step = _context.sent;\n          _iteratorNormalCompletion = _step.done;\n          _context.next = 16;\n          return _regeneratorRuntime.awrap(_step.value);\n\n        case 16:\n          _value = _context.sent;\n\n          if (_iteratorNormalCompletion) {\n            _context.next = 24;\n            break;\n          }\n\n          result = _value;\n          _iterator2 = _createForOfIteratorHelper(result.diagnostics);\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              diagnostic = _step2.value;\n              spinner.stop();\n\n              if (diagnostic.type === 'error') {\n                hasErrors = true;\n                context.logger.error(diagnostic.message);\n              } else {\n                context.logger.warn(diagnostic.message);\n              }\n\n              spinner.start();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n        case 21:\n          _iteratorNormalCompletion = true;\n          _context.next = 10;\n          break;\n\n        case 24:\n          _context.next = 30;\n          break;\n\n        case 26:\n          _context.prev = 26;\n          _context.t0 = _context[\"catch\"](8);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n\n        case 30:\n          _context.prev = 30;\n          _context.prev = 31;\n\n          if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n            _context.next = 35;\n            break;\n          }\n\n          _context.next = 35;\n          return _regeneratorRuntime.awrap(_iterator.return());\n\n        case 35:\n          _context.prev = 35;\n\n          if (!_didIteratorError) {\n            _context.next = 38;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 38:\n          return _context.finish(35);\n\n        case 39:\n          return _context.finish(30);\n\n        case 40:\n          _context.next = 42;\n          return _regeneratorRuntime.awrap(copy_assets_1.copyAssets([{\n            glob: '**/*',\n            input: emittedPath,\n            output: '',\n            ignore: _toConsumableArray(processedFiles).map(function (f) {\n              return path.relative(emittedPath, f);\n            })\n          }], outputPaths, ''));\n\n        case 42:\n          _context.next = 48;\n          break;\n\n        case 44:\n          _context.prev = 44;\n          _context.t1 = _context[\"catch\"](4);\n          spinner.fail('Localized bundle generation failed: ' + _context.t1.message);\n          return _context.abrupt(\"return\", false);\n\n        case 48:\n          _context.prev = 48;\n          executor.stop();\n          return _context.finish(48);\n\n        case 51:\n          if (hasErrors) {\n            spinner.fail('Localized bundle generation failed.');\n          } else {\n            spinner.succeed('Localized bundle generation complete.');\n          }\n\n          return _context.abrupt(\"return\", !hasErrors);\n\n        case 53:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[4, 44, 48, 51], [8, 26, 30, 40], [31,, 35, 39]], Promise);\n}\n\nexports.i18nInlineEmittedFiles = i18nInlineEmittedFiles;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/src/utils/i18n-inlining.js"],"names":["Object","defineProperty","exports","value","i18nInlineEmittedFiles","fs","require","path","action_executor_1","copy_assets_1","spinner_1","emittedFilesToInlineOptions","emittedFiles","scriptsEntryPointName","emittedPath","outputPath","es5","missingTranslation","options","originalFiles","emittedFile","asset","extension","name","includes","originalPath","join","file","action","filename","code","readFileSync","setLocale","push","originalMapPath","map","err","context","i18n","baseOutputPath","outputPaths","executor","BundleActionExecutor","hasErrors","spinner","Spinner","start","processedFiles","inlineAll","result","diagnostics","diagnostic","stop","type","logger","error","message","warn","copyAssets","glob","input","output","ignore","f","relative","fail","succeed"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.i18nInlineEmittedFiles = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst action_executor_1 = require(\"./action-executor\");\nconst copy_assets_1 = require(\"./copy-assets\");\nconst spinner_1 = require(\"./spinner\");\nfunction emittedFilesToInlineOptions(emittedFiles, scriptsEntryPointName, emittedPath, outputPath, es5, missingTranslation) {\n    const options = [];\n    const originalFiles = [];\n    for (const emittedFile of emittedFiles) {\n        if (emittedFile.asset ||\n            emittedFile.extension !== '.js' ||\n            (emittedFile.name && scriptsEntryPointName.includes(emittedFile.name))) {\n            continue;\n        }\n        const originalPath = path.join(emittedPath, emittedFile.file);\n        const action = {\n            filename: emittedFile.file,\n            code: fs.readFileSync(originalPath, 'utf8'),\n            es5,\n            outputPath,\n            missingTranslation,\n            setLocale: emittedFile.name === 'main' || emittedFile.name === 'vendor',\n        };\n        originalFiles.push(originalPath);\n        try {\n            const originalMapPath = originalPath + '.map';\n            action.map = fs.readFileSync(originalMapPath, 'utf8');\n            originalFiles.push(originalMapPath);\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                throw err;\n            }\n        }\n        options.push(action);\n    }\n    return { options, originalFiles };\n}\nasync function i18nInlineEmittedFiles(context, emittedFiles, i18n, baseOutputPath, outputPaths, scriptsEntryPointName, emittedPath, es5, missingTranslation) {\n    const executor = new action_executor_1.BundleActionExecutor({ i18n });\n    let hasErrors = false;\n    const spinner = new spinner_1.Spinner();\n    spinner.start('Generating localized bundles...');\n    try {\n        const { options, originalFiles: processedFiles } = emittedFilesToInlineOptions(emittedFiles, scriptsEntryPointName, emittedPath, baseOutputPath, es5, missingTranslation);\n        for await (const result of executor.inlineAll(options)) {\n            for (const diagnostic of result.diagnostics) {\n                spinner.stop();\n                if (diagnostic.type === 'error') {\n                    hasErrors = true;\n                    context.logger.error(diagnostic.message);\n                }\n                else {\n                    context.logger.warn(diagnostic.message);\n                }\n                spinner.start();\n            }\n        }\n        // Copy any non-processed files into the output locations\n        await copy_assets_1.copyAssets([\n            {\n                glob: '**/*',\n                input: emittedPath,\n                output: '',\n                ignore: [...processedFiles].map(f => path.relative(emittedPath, f)),\n            },\n        ], outputPaths, '');\n    }\n    catch (err) {\n        spinner.fail('Localized bundle generation failed: ' + err.message);\n        return false;\n    }\n    finally {\n        executor.stop();\n    }\n    if (hasErrors) {\n        spinner.fail('Localized bundle generation failed.');\n    }\n    else {\n        spinner.succeed('Localized bundle generation complete.');\n    }\n    return !hasErrors;\n}\nexports.i18nInlineEmittedFiles = i18nInlineEmittedFiles;\n"]},"metadata":{},"sourceType":"script"}