{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.checkIfGenericTypeBoundsAreContextFree = exports.findSourceLocation = exports.findTypeCheckBlock = exports.getTemplateMapping = exports.requiresInlineTypeCheckBlock = exports.TcbInliningRequirement = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var comments_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\");\n\n  var ts_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\");\n\n  var type_parameter_emitter_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter\");\n  /**\n   * Indicates whether a particular component requires an inline type check block.\n   *\n   * This is not a boolean state as inlining might only be required to get the best possible\n   * type-checking, but the component could theoretically still be checked without it.\n   */\n\n\n  var TcbInliningRequirement;\n\n  (function (TcbInliningRequirement) {\n    /**\n     * There is no way to type check this component without inlining.\n     */\n    TcbInliningRequirement[TcbInliningRequirement[\"MustInline\"] = 0] = \"MustInline\";\n    /**\n     * Inlining should be used due to the component's generic bounds, but a non-inlining fallback\n     * method can be used if that's not possible.\n     */\n\n    TcbInliningRequirement[TcbInliningRequirement[\"ShouldInlineForGenericBounds\"] = 1] = \"ShouldInlineForGenericBounds\";\n    /**\n     * There is no requirement for this component's TCB to be inlined.\n     */\n\n    TcbInliningRequirement[TcbInliningRequirement[\"None\"] = 2] = \"None\";\n  })(TcbInliningRequirement = exports.TcbInliningRequirement || (exports.TcbInliningRequirement = {}));\n\n  function requiresInlineTypeCheckBlock(node, usedPipes, reflector) {\n    // In order to qualify for a declared TCB (not inline) two conditions must be met:\n    // 1) the class must be exported\n    // 2) it must not have contextual generic type bounds\n    if (!ts_util_1.checkIfClassIsExported(node)) {\n      // Condition 1 is false, the class is not exported.\n      return TcbInliningRequirement.MustInline;\n    } else if (!checkIfGenericTypeBoundsAreContextFree(node, reflector)) {\n      // Condition 2 is false, the class has constrained generic types. It should be checked with an\n      // inline TCB if possible, but can potentially use fallbacks to avoid inlining if not.\n      return TcbInliningRequirement.ShouldInlineForGenericBounds;\n    } else if (Array.from(usedPipes.values()).some(function (pipeRef) {\n      return !ts_util_1.checkIfClassIsExported(pipeRef.node);\n    })) {\n      // If one of the pipes used by the component is not exported, a non-inline TCB will not be able\n      // to import it, so this requires an inline TCB.\n      return TcbInliningRequirement.MustInline;\n    } else {\n      return TcbInliningRequirement.None;\n    }\n  }\n\n  exports.requiresInlineTypeCheckBlock = requiresInlineTypeCheckBlock;\n  /** Maps a shim position back to a template location. */\n\n  function getTemplateMapping(shimSf, position, resolver, isDiagnosticRequest) {\n    var node = typescript_1.getTokenAtPosition(shimSf, position);\n    var sourceLocation = findSourceLocation(node, shimSf, isDiagnosticRequest);\n\n    if (sourceLocation === null) {\n      return null;\n    }\n\n    var mapping = resolver.getSourceMapping(sourceLocation.id);\n    var span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);\n\n    if (span === null) {\n      return null;\n    } // TODO(atscott): Consider adding a context span by walking up from `node` until we get a\n    // different span.\n\n\n    return {\n      sourceLocation: sourceLocation,\n      templateSourceMapping: mapping,\n      span: span\n    };\n  }\n\n  exports.getTemplateMapping = getTemplateMapping;\n\n  function findTypeCheckBlock(file, id, isDiagnosticRequest) {\n    var e_1, _a;\n\n    try {\n      for (var _b = tslib_1.__values(file.statements), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var stmt = _c.value;\n\n        if (ts.isFunctionDeclaration(stmt) && getTemplateId(stmt, file, isDiagnosticRequest) === id) {\n          return stmt;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return null;\n  }\n\n  exports.findTypeCheckBlock = findTypeCheckBlock;\n  /**\n   * Traverses up the AST starting from the given node to extract the source location from comments\n   * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore\n   * marker comment is found up the tree (and this is part of a diagnostic request), this function\n   * returns null.\n   */\n\n  function findSourceLocation(node, sourceFile, isDiagnosticsRequest) {\n    // Search for comments until the TCB's function declaration is encountered.\n    while (node !== undefined && !ts.isFunctionDeclaration(node)) {\n      if (comments_1.hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticsRequest) {\n        // There's an ignore marker on this node, so the diagnostic should not be reported.\n        return null;\n      }\n\n      var span = comments_1.readSpanComment(node, sourceFile);\n\n      if (span !== null) {\n        // Once the positional information has been extracted, search further up the TCB to extract\n        // the unique id that is attached with the TCB's function declaration.\n        var id = getTemplateId(node, sourceFile, isDiagnosticsRequest);\n\n        if (id === null) {\n          return null;\n        }\n\n        return {\n          id: id,\n          span: span\n        };\n      }\n\n      node = node.parent;\n    }\n\n    return null;\n  }\n\n  exports.findSourceLocation = findSourceLocation;\n\n  function getTemplateId(node, sourceFile, isDiagnosticRequest) {\n    // Walk up to the function declaration of the TCB, the file information is attached there.\n    while (!ts.isFunctionDeclaration(node)) {\n      if (comments_1.hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticRequest) {\n        // There's an ignore marker on this node, so the diagnostic should not be reported.\n        return null;\n      }\n\n      node = node.parent; // Bail once we have reached the root.\n\n      if (node === undefined) {\n        return null;\n      }\n    }\n\n    var start = node.getFullStart();\n    return ts.forEachLeadingCommentRange(sourceFile.text, start, function (pos, end, kind) {\n      if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n        return null;\n      }\n\n      var commentText = sourceFile.text.substring(pos + 2, end - 2);\n      return commentText;\n    }) || null;\n  }\n\n  function checkIfGenericTypeBoundsAreContextFree(node, reflector) {\n    // Generic type parameters are considered context free if they can be emitted into any context.\n    return new type_parameter_emitter_1.TypeParameterEmitter(node.typeParameters, reflector).canEmit();\n  }\n\n  exports.checkIfGenericTypeBoundsAreContextFree = checkIfGenericTypeBoundsAreContextFree;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/tcb_util.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAIH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAGA,MAAA,YAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AAGA,MAAA,UAAA,GAAA,OAAA,CAAA,wDAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,uDAAA,CAAA;;AACA,MAAA,wBAAA,GAAA,OAAA,CAAA,sEAAA,CAAA;AAuBA;;;;;AAKG;;;AACH,MAAY,sBAAZ;;AAAA,GAAA,UAAY,sBAAZ,EAAkC;AAChC;;AAEG;AACH,IAAA,sBAAA,CAAA,sBAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AAEA;;;AAGG;;AACH,IAAA,sBAAA,CAAA,sBAAA,CAAA,8BAAA,CAAA,GAAA,CAAA,CAAA,GAAA,8BAAA;AAEA;;AAEG;;AACH,IAAA,sBAAA,CAAA,sBAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACD,GAhBD,EAAY,sBAAsB,GAAtB,OAAA,CAAA,sBAAA,KAAA,OAAA,CAAA,sBAAA,GAAsB,EAAtB,CAAZ;;AAkBA,WAAgB,4BAAhB,CACI,IADJ,EAEI,SAFJ,EAGI,SAHJ,EAG6B;AAC3B;AACA;AACA;AACA,QAAI,CAAC,SAAA,CAAA,sBAAA,CAAuB,IAAvB,CAAL,EAAmC;AACjC;AACA,aAAO,sBAAsB,CAAC,UAA9B;AACD,KAHD,MAGO,IAAI,CAAC,sCAAsC,CAAC,IAAD,EAAO,SAAP,CAA3C,EAA8D;AACnE;AACA;AACA,aAAO,sBAAsB,CAAC,4BAA9B;AACD,KAJM,MAIA,IAAI,KAAK,CAAC,IAAN,CAAW,SAAS,CAAC,MAAV,EAAX,EACK,IADL,CACU,UAAA,OAAA,EAAO;AAAI,aAAA,CAAC,SAAA,CAAA,sBAAA,CAAuB,OAAO,CAA/B,IAAC,CAAD;AAAqC,KAD1D,CAAJ,EACiE;AACtE;AACA;AACA,aAAO,sBAAsB,CAAC,UAA9B;AACD,KALM,MAKA;AACL,aAAO,sBAAsB,CAAC,IAA9B;AACD;AACF;;AAtBD,EAAA,OAAA,CAAA,4BAAA,GAAA,4BAAA;AAwBA;;AACA,WAAgB,kBAAhB,CACI,MADJ,EAC2B,QAD3B,EAC6C,QAD7C,EAEI,mBAFJ,EAEgC;AAC9B,QAAM,IAAI,GAAG,YAAA,CAAA,kBAAA,CAAmB,MAAnB,EAA2B,QAA3B,CAAb;AACA,QAAM,cAAc,GAAG,kBAAkB,CAAC,IAAD,EAAO,MAAP,EAAe,mBAAf,CAAzC;;AACA,QAAI,cAAc,KAAK,IAAvB,EAA6B;AAC3B,aAAO,IAAP;AACD;;AAED,QAAM,OAAO,GAAG,QAAQ,CAAC,gBAAT,CAA0B,cAAc,CAAC,EAAzC,CAAhB;AACA,QAAM,IAAI,GAAG,QAAQ,CAAC,iBAAT,CAA2B,cAAc,CAAC,EAA1C,EAA8C,cAAc,CAAC,IAA7D,CAAb;;AACA,QAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,aAAO,IAAP;AACD,KAX6B,CAY9B;AACA;;;AACA,WAAO;AAAC,MAAA,cAAc,EAAA,cAAf;AAAiB,MAAA,qBAAqB,EAAE,OAAxC;AAAiD,MAAA,IAAI,EAAA;AAArD,KAAP;AACD;;AAjBD,EAAA,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAmBA,WAAgB,kBAAhB,CACI,IADJ,EACyB,EADzB,EACyC,mBADzC,EACqE;;;;AACnE,WAAmB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,IAAI,CAAC,UAAL,CAAA,EAAe,EAAA,GAAA,EAAA,CAAA,IAAA,EAAlC,EAAkC,CAAA,EAAA,CAAA,IAAlC,EAAkC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAlC,EAAoC;AAA/B,YAAM,IAAI,GAAA,EAAA,CAAA,KAAV;;AACH,YAAI,EAAE,CAAC,qBAAH,CAAyB,IAAzB,KAAkC,aAAa,CAAC,IAAD,EAAO,IAAP,EAAa,mBAAb,CAAb,KAAmD,EAAzF,EAA6F;AAC3F,iBAAO,IAAP;AACD;AACF;;;;;;;;;;;;;AACD,WAAO,IAAP;AACD;;AARD,EAAA,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAUA;;;;;AAKG;;AACH,WAAgB,kBAAhB,CACI,IADJ,EACmB,UADnB,EAC8C,oBAD9C,EAC2E;AACzE;AACA,WAAO,IAAI,KAAK,SAAT,IAAsB,CAAC,EAAE,CAAC,qBAAH,CAAyB,IAAzB,CAA9B,EAA8D;AAC5D,UAAI,UAAA,CAAA,6BAAA,CAA8B,IAA9B,EAAoC,UAApC,KAAmD,oBAAvD,EAA6E;AAC3E;AACA,eAAO,IAAP;AACD;;AAED,UAAM,IAAI,GAAG,UAAA,CAAA,eAAA,CAAgB,IAAhB,EAAsB,UAAtB,CAAb;;AACA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB;AACA;AACA,YAAM,EAAE,GAAG,aAAa,CAAC,IAAD,EAAO,UAAP,EAAmB,oBAAnB,CAAxB;;AACA,YAAI,EAAE,KAAK,IAAX,EAAiB;AACf,iBAAO,IAAP;AACD;;AACD,eAAO;AAAC,UAAA,EAAE,EAAA,EAAH;AAAK,UAAA,IAAI,EAAA;AAAT,SAAP;AACD;;AAED,MAAA,IAAI,GAAG,IAAI,CAAC,MAAZ;AACD;;AAED,WAAO,IAAP;AACD;;AAxBD,EAAA,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AA0BA,WAAS,aAAT,CACI,IADJ,EACmB,UADnB,EAC8C,mBAD9C,EAC0E;AACxE;AACA,WAAO,CAAC,EAAE,CAAC,qBAAH,CAAyB,IAAzB,CAAR,EAAwC;AACtC,UAAI,UAAA,CAAA,6BAAA,CAA8B,IAA9B,EAAoC,UAApC,KAAmD,mBAAvD,EAA4E;AAC1E;AACA,eAAO,IAAP;AACD;;AACD,MAAA,IAAI,GAAG,IAAI,CAAC,MAAZ,CALsC,CAOtC;;AACA,UAAI,IAAI,KAAK,SAAb,EAAwB;AACtB,eAAO,IAAP;AACD;AACF;;AAED,QAAM,KAAK,GAAG,IAAI,CAAC,YAAL,EAAd;AACA,WAAO,EAAE,CAAC,0BAAH,CAA8B,UAAU,CAAC,IAAzC,EAA+C,KAA/C,EAAsD,UAAC,GAAD,EAAM,GAAN,EAAW,IAAX,EAAe;AAC1E,UAAI,IAAI,KAAK,EAAE,CAAC,UAAH,CAAc,sBAA3B,EAAmD;AACjD,eAAO,IAAP;AACD;;AACD,UAAM,WAAW,GAAG,UAAU,CAAC,IAAX,CAAgB,SAAhB,CAA0B,GAAG,GAAG,CAAhC,EAAmC,GAAG,GAAG,CAAzC,CAApB;AACA,aAAO,WAAP;AACD,KANM,KAMa,IANpB;AAOD;;AAED,WAAgB,sCAAhB,CACI,IADJ,EACiD,SADjD,EAC0E;AACxE;AACA,WAAO,IAAI,wBAAA,CAAA,oBAAJ,CAAyB,IAAI,CAAC,cAA9B,EAA8C,SAA9C,EAAyD,OAAzD,EAAP;AACD;;AAJD,EAAA,OAAA,CAAA,sCAAA,GAAA,sCAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\nimport {ClassDeclaration, ReflectionHost} from '@angular/compiler-cli/src/ngtsc/reflection';\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {getTokenAtPosition} from '../../util/src/typescript';\nimport {FullTemplateMapping, SourceLocation, TemplateId, TemplateSourceMapping} from '../api';\n\nimport {hasIgnoreForDiagnosticsMarker, readSpanComment} from './comments';\nimport {checkIfClassIsExported, checkIfGenericTypesAreUnbound} from './ts_util';\nimport {TypeParameterEmitter} from './type_parameter_emitter';\n\n/**\n * Adapter interface which allows the template type-checking diagnostics code to interpret offsets\n * in a TCB and map them back to original locations in the template.\n */\nexport interface TemplateSourceResolver {\n  getTemplateId(node: ts.ClassDeclaration): TemplateId;\n\n  /**\n   * For the given template id, retrieve the original source mapping which describes how the offsets\n   * in the template should be interpreted.\n   */\n  getSourceMapping(id: TemplateId): TemplateSourceMapping;\n\n  /**\n   * Convert an absolute source span associated with the given template id into a full\n   * `ParseSourceSpan`. The returned parse span has line and column numbers in addition to only\n   * absolute offsets and gives access to the original template source.\n   */\n  toParseSourceSpan(id: TemplateId, span: AbsoluteSourceSpan): ParseSourceSpan|null;\n}\n\n/**\n * Indicates whether a particular component requires an inline type check block.\n *\n * This is not a boolean state as inlining might only be required to get the best possible\n * type-checking, but the component could theoretically still be checked without it.\n */\nexport enum TcbInliningRequirement {\n  /**\n   * There is no way to type check this component without inlining.\n   */\n  MustInline,\n\n  /**\n   * Inlining should be used due to the component's generic bounds, but a non-inlining fallback\n   * method can be used if that's not possible.\n   */\n  ShouldInlineForGenericBounds,\n\n  /**\n   * There is no requirement for this component's TCB to be inlined.\n   */\n  None,\n}\n\nexport function requiresInlineTypeCheckBlock(\n    node: ClassDeclaration<ts.ClassDeclaration>,\n    usedPipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,\n    reflector: ReflectionHost): TcbInliningRequirement {\n  // In order to qualify for a declared TCB (not inline) two conditions must be met:\n  // 1) the class must be exported\n  // 2) it must not have contextual generic type bounds\n  if (!checkIfClassIsExported(node)) {\n    // Condition 1 is false, the class is not exported.\n    return TcbInliningRequirement.MustInline;\n  } else if (!checkIfGenericTypeBoundsAreContextFree(node, reflector)) {\n    // Condition 2 is false, the class has constrained generic types. It should be checked with an\n    // inline TCB if possible, but can potentially use fallbacks to avoid inlining if not.\n    return TcbInliningRequirement.ShouldInlineForGenericBounds;\n  } else if (Array.from(usedPipes.values())\n                 .some(pipeRef => !checkIfClassIsExported(pipeRef.node))) {\n    // If one of the pipes used by the component is not exported, a non-inline TCB will not be able\n    // to import it, so this requires an inline TCB.\n    return TcbInliningRequirement.MustInline;\n  } else {\n    return TcbInliningRequirement.None;\n  }\n}\n\n/** Maps a shim position back to a template location. */\nexport function getTemplateMapping(\n    shimSf: ts.SourceFile, position: number, resolver: TemplateSourceResolver,\n    isDiagnosticRequest: boolean): FullTemplateMapping|null {\n  const node = getTokenAtPosition(shimSf, position);\n  const sourceLocation = findSourceLocation(node, shimSf, isDiagnosticRequest);\n  if (sourceLocation === null) {\n    return null;\n  }\n\n  const mapping = resolver.getSourceMapping(sourceLocation.id);\n  const span = resolver.toParseSourceSpan(sourceLocation.id, sourceLocation.span);\n  if (span === null) {\n    return null;\n  }\n  // TODO(atscott): Consider adding a context span by walking up from `node` until we get a\n  // different span.\n  return {sourceLocation, templateSourceMapping: mapping, span};\n}\n\nexport function findTypeCheckBlock(\n    file: ts.SourceFile, id: TemplateId, isDiagnosticRequest: boolean): ts.Node|null {\n  for (const stmt of file.statements) {\n    if (ts.isFunctionDeclaration(stmt) && getTemplateId(stmt, file, isDiagnosticRequest) === id) {\n      return stmt;\n    }\n  }\n  return null;\n}\n\n/**\n * Traverses up the AST starting from the given node to extract the source location from comments\n * that have been emitted into the TCB. If the node does not exist within a TCB, or if an ignore\n * marker comment is found up the tree (and this is part of a diagnostic request), this function\n * returns null.\n */\nexport function findSourceLocation(\n    node: ts.Node, sourceFile: ts.SourceFile, isDiagnosticsRequest: boolean): SourceLocation|null {\n  // Search for comments until the TCB's function declaration is encountered.\n  while (node !== undefined && !ts.isFunctionDeclaration(node)) {\n    if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticsRequest) {\n      // There's an ignore marker on this node, so the diagnostic should not be reported.\n      return null;\n    }\n\n    const span = readSpanComment(node, sourceFile);\n    if (span !== null) {\n      // Once the positional information has been extracted, search further up the TCB to extract\n      // the unique id that is attached with the TCB's function declaration.\n      const id = getTemplateId(node, sourceFile, isDiagnosticsRequest);\n      if (id === null) {\n        return null;\n      }\n      return {id, span};\n    }\n\n    node = node.parent;\n  }\n\n  return null;\n}\n\nfunction getTemplateId(\n    node: ts.Node, sourceFile: ts.SourceFile, isDiagnosticRequest: boolean): TemplateId|null {\n  // Walk up to the function declaration of the TCB, the file information is attached there.\n  while (!ts.isFunctionDeclaration(node)) {\n    if (hasIgnoreForDiagnosticsMarker(node, sourceFile) && isDiagnosticRequest) {\n      // There's an ignore marker on this node, so the diagnostic should not be reported.\n      return null;\n    }\n    node = node.parent;\n\n    // Bail once we have reached the root.\n    if (node === undefined) {\n      return null;\n    }\n  }\n\n  const start = node.getFullStart();\n  return ts.forEachLeadingCommentRange(sourceFile.text, start, (pos, end, kind) => {\n    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText;\n  }) as TemplateId || null;\n}\n\nexport function checkIfGenericTypeBoundsAreContextFree(\n    node: ClassDeclaration<ts.ClassDeclaration>, reflector: ReflectionHost): boolean {\n  // Generic type parameters are considered context free if they can be emitted into any context.\n  return new TypeParameterEmitter(node.typeParameters, reflector).canEmit();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}