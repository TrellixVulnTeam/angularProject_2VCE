{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/aot/formatted_error\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isFormattedError = exports.formattedError = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var FORMATTED_MESSAGE = 'ngFormattedMessage';\n\n  function indentStr(level) {\n    if (level <= 0) return '';\n    if (level < 6) return ['', ' ', '  ', '   ', '    ', '     '][level];\n    var half = indentStr(Math.floor(level / 2));\n    return half + half + (level % 2 === 1 ? ' ' : '');\n  }\n\n  function formatChain(chain, indent) {\n    var e_1, _a;\n\n    if (indent === void 0) {\n      indent = 0;\n    }\n\n    if (!chain) return '';\n    var position = chain.position ? chain.position.fileName + \"(\" + (chain.position.line + 1) + \",\" + (chain.position.column + 1) + \")\" : '';\n    var prefix = position && indent === 0 ? position + \": \" : '';\n    var postfix = position && indent !== 0 ? \" at \" + position : '';\n    var message = \"\" + prefix + chain.message + postfix;\n\n    if (chain.next) {\n      try {\n        for (var _b = tslib_1.__values(chain.next), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var kid = _c.value;\n          message += '\\n' + formatChain(kid, indent + 2);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    return \"\" + indentStr(indent) + message;\n  }\n\n  function formattedError(chain) {\n    var message = formatChain(chain) + '.';\n    var error = util_1.syntaxError(message);\n    error[FORMATTED_MESSAGE] = true;\n    error.chain = chain;\n    error.position = chain.position;\n    return error;\n  }\n\n  exports.formattedError = formattedError;\n\n  function isFormattedError(error) {\n    return !!error[FORMATTED_MESSAGE];\n  }\n\n  exports.isFormattedError = isFormattedError;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/formatted_error.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,MAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAmBA,MAAM,iBAAiB,GAAG,oBAA1B;;AAEA,WAAS,SAAT,CAAmB,KAAnB,EAAgC;AAC9B,QAAI,KAAK,IAAI,CAAb,EAAgB,OAAO,EAAP;AAChB,QAAI,KAAK,GAAG,CAAZ,EAAe,OAAO,CAAC,EAAD,EAAK,GAAL,EAAU,IAAV,EAAgB,KAAhB,EAAuB,MAAvB,EAA+B,OAA/B,EAAwC,KAAxC,CAAP;AACf,QAAM,IAAI,GAAG,SAAS,CAAC,IAAI,CAAC,KAAL,CAAW,KAAK,GAAG,CAAnB,CAAD,CAAtB;AACA,WAAO,IAAI,GAAG,IAAP,IAAe,KAAK,GAAG,CAAR,KAAc,CAAd,GAAkB,GAAlB,GAAwB,EAAvC,CAAP;AACD;;AAED,WAAS,WAAT,CAAqB,KAArB,EAA6D,MAA7D,EAA+E;;;AAAlB,QAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,MAAA,GAAA,CAAA;AAAkB;;AAC7E,QAAI,CAAC,KAAL,EAAY,OAAO,EAAP;AACZ,QAAM,QAAQ,GAAG,KAAK,CAAC,QAAN,GACV,KAAK,CAAC,QAAN,CAAe,QAAf,GAAuB,GAAvB,IAA2B,KAAK,CAAC,QAAN,CAAe,IAAf,GAAsB,CAAjD,IAAkD,GAAlD,IAAsD,KAAK,CAAC,QAAN,CAAe,MAAf,GAAwB,CAA9E,IAA+E,GADrE,GAEb,EAFJ;AAGA,QAAM,MAAM,GAAG,QAAQ,IAAI,MAAM,KAAK,CAAvB,GAA8B,QAAQ,GAAA,IAAtC,GAA6C,EAA5D;AACA,QAAM,OAAO,GAAG,QAAQ,IAAI,MAAM,KAAK,CAAvB,GAA2B,SAAO,QAAlC,GAA+C,EAA/D;AACA,QAAI,OAAO,GAAG,KAAG,MAAH,GAAY,KAAK,CAAC,OAAlB,GAA4B,OAA1C;;AAEA,QAAI,KAAK,CAAC,IAAV,EAAgB;;AACd,aAAkB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,CAAC,IAAN,CAAA,EAAU,EAAA,GAAA,EAAA,CAAA,IAAA,EAA5B,EAA4B,CAAA,EAAA,CAAA,IAA5B,EAA4B,EAAA,GAAA,EAAA,CAAA,IAAA,EAA5B,EAA8B;AAAzB,cAAM,GAAG,GAAA,EAAA,CAAA,KAAT;AACH,UAAA,OAAO,IAAI,OAAO,WAAW,CAAC,GAAD,EAAM,MAAM,GAAG,CAAf,CAA7B;AACD;;;;;;;;;;;;AACF;;AAED,WAAO,KAAG,SAAS,CAAC,MAAD,CAAZ,GAAuB,OAA9B;AACD;;AAED,WAAgB,cAAhB,CAA+B,KAA/B,EAA2D;AACzD,QAAM,OAAO,GAAG,WAAW,CAAC,KAAD,CAAX,GAAqB,GAArC;AACA,QAAM,KAAK,GAAG,MAAA,CAAA,WAAA,CAAY,OAAZ,CAAd;AACC,IAAA,KAAa,CAAC,iBAAD,CAAb,GAAmC,IAAnC;AACD,IAAA,KAAK,CAAC,KAAN,GAAc,KAAd;AACA,IAAA,KAAK,CAAC,QAAN,GAAiB,KAAK,CAAC,QAAvB;AACA,WAAO,KAAP;AACD;;AAPD,EAAA,OAAA,CAAA,cAAA,GAAA,cAAA;;AASA,WAAgB,gBAAhB,CAAiC,KAAjC,EAA6C;AAC3C,WAAO,CAAC,CAAE,KAAa,CAAC,iBAAD,CAAvB;AACD;;AAFD,EAAA,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {syntaxError} from '../util';\n\nexport interface Position {\n  fileName: string;\n  line: number;\n  column: number;\n}\n\nexport interface FormattedMessageChain {\n  message: string;\n  position?: Position;\n  next?: FormattedMessageChain[];\n}\n\nexport type FormattedError = Error&{\n  chain: FormattedMessageChain;\n  position?: Position;\n};\n\nconst FORMATTED_MESSAGE = 'ngFormattedMessage';\n\nfunction indentStr(level: number): string {\n  if (level <= 0) return '';\n  if (level < 6) return ['', ' ', '  ', '   ', '    ', '     '][level];\n  const half = indentStr(Math.floor(level / 2));\n  return half + half + (level % 2 === 1 ? ' ' : '');\n}\n\nfunction formatChain(chain: FormattedMessageChain|undefined, indent: number = 0): string {\n  if (!chain) return '';\n  const position = chain.position ?\n      `${chain.position.fileName}(${chain.position.line + 1},${chain.position.column + 1})` :\n      '';\n  const prefix = position && indent === 0 ? `${position}: ` : '';\n  const postfix = position && indent !== 0 ? ` at ${position}` : '';\n  let message = `${prefix}${chain.message}${postfix}`;\n\n  if (chain.next) {\n    for (const kid of chain.next) {\n      message += '\\n' + formatChain(kid, indent + 2);\n    }\n  }\n\n  return `${indentStr(indent)}${message}`;\n}\n\nexport function formattedError(chain: FormattedMessageChain): FormattedError {\n  const message = formatChain(chain) + '.';\n  const error = syntaxError(message) as FormattedError;\n  (error as any)[FORMATTED_MESSAGE] = true;\n  error.chain = chain;\n  error.position = chain.position;\n  return error;\n}\n\nexport function isFormattedError(error: Error): error is FormattedError {\n  return !!(error as any)[FORMATTED_MESSAGE];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}