{"ast":null,"code":"var _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('path'),\n    dirname = _require.dirname,\n    join = _require.join,\n    resolve = _require.resolve,\n    relative = _require.relative,\n    isAbsolute = _require.isAbsolute;\n\nvar rimraf_ = require('rimraf');\n\nvar _require2 = require('util'),\n    promisify = _require2.promisify;\n\nvar _require3 = require('fs'),\n    access_ = _require3.access,\n    accessSync = _require3.accessSync,\n    copyFile_ = _require3.copyFile,\n    copyFileSync = _require3.copyFileSync,\n    unlink_ = _require3.unlink,\n    unlinkSync = _require3.unlinkSync,\n    readdir_ = _require3.readdir,\n    readdirSync = _require3.readdirSync,\n    rename_ = _require3.rename,\n    renameSync = _require3.renameSync,\n    stat_ = _require3.stat,\n    statSync = _require3.statSync,\n    lstat_ = _require3.lstat,\n    lstatSync = _require3.lstatSync,\n    symlink_ = _require3.symlink,\n    symlinkSync = _require3.symlinkSync,\n    readlink_ = _require3.readlink,\n    readlinkSync = _require3.readlinkSync;\n\nvar access = promisify(access_);\nvar copyFile = promisify(copyFile_);\nvar unlink = promisify(unlink_);\nvar readdir = promisify(readdir_);\nvar rename = promisify(rename_);\nvar stat = promisify(stat_);\nvar lstat = promisify(lstat_);\nvar symlink = promisify(symlink_);\nvar readlink = promisify(readlink_);\nvar rimraf = promisify(rimraf_);\nvar rimrafSync = rimraf_.sync;\n\nvar mkdirp = require('mkdirp');\n\nvar pathExists = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            _context.next = 3;\n            return access(path);\n\n          case 3:\n            return _context.abrupt(\"return\", true);\n\n          case 6:\n            _context.prev = 6;\n            _context.t0 = _context[\"catch\"](0);\n            return _context.abrupt(\"return\", _context.t0.code !== 'ENOENT');\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 6]]);\n  }));\n\n  return function pathExists(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar pathExistsSync = function pathExistsSync(path) {\n  try {\n    accessSync(path);\n    return true;\n  } catch (er) {\n    return er.code !== 'ENOENT';\n  }\n};\n\nvar moveFile = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(source, destination) {\n    var options,\n        root,\n        symlinks,\n        sourceStat,\n        files,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};\n            root = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : true;\n            symlinks = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : [];\n\n            if (!(!source || !destination)) {\n              _context3.next = 5;\n              break;\n            }\n\n            throw new TypeError('`source` and `destination` file required');\n\n          case 5:\n            options = _objectSpread({\n              overwrite: true\n            }, options);\n            _context3.t0 = !options.overwrite;\n\n            if (!_context3.t0) {\n              _context3.next = 11;\n              break;\n            }\n\n            _context3.next = 10;\n            return pathExists(destination);\n\n          case 10:\n            _context3.t0 = _context3.sent;\n\n          case 11:\n            if (!_context3.t0) {\n              _context3.next = 13;\n              break;\n            }\n\n            throw new Error(\"The destination file exists: \".concat(destination));\n\n          case 13:\n            _context3.next = 15;\n            return mkdirp(dirname(destination));\n\n          case 15:\n            _context3.prev = 15;\n            _context3.next = 18;\n            return rename(source, destination);\n\n          case 18:\n            _context3.next = 43;\n            break;\n\n          case 20:\n            _context3.prev = 20;\n            _context3.t1 = _context3[\"catch\"](15);\n\n            if (!(_context3.t1.code === 'EXDEV' || _context3.t1.code === 'EPERM')) {\n              _context3.next = 42;\n              break;\n            }\n\n            _context3.next = 25;\n            return lstat(source);\n\n          case 25:\n            sourceStat = _context3.sent;\n\n            if (!sourceStat.isDirectory()) {\n              _context3.next = 34;\n              break;\n            }\n\n            _context3.next = 29;\n            return readdir(source);\n\n          case 29:\n            files = _context3.sent;\n            _context3.next = 32;\n            return Promise.all(files.map(function (file) {\n              return moveFile(join(source, file), join(destination, file), options, false, symlinks);\n            }));\n\n          case 32:\n            _context3.next = 40;\n            break;\n\n          case 34:\n            if (!sourceStat.isSymbolicLink()) {\n              _context3.next = 38;\n              break;\n            }\n\n            symlinks.push({\n              source: source,\n              destination: destination\n            });\n            _context3.next = 40;\n            break;\n\n          case 38:\n            _context3.next = 40;\n            return copyFile(source, destination);\n\n          case 40:\n            _context3.next = 43;\n            break;\n\n          case 42:\n            throw _context3.t1;\n\n          case 43:\n            if (!root) {\n              _context3.next = 48;\n              break;\n            }\n\n            _context3.next = 46;\n            return Promise.all(symlinks.map( /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {\n                var source, destination, target, targetStat;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        source = _ref3.source, destination = _ref3.destination;\n                        _context2.next = 3;\n                        return readlink(source);\n\n                      case 3:\n                        target = _context2.sent;\n                        // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n                        if (isAbsolute(target)) target = resolve(destination, relative(source, target)); // try to determine what the actual file is so we can create the correct type of symlink in windows\n\n                        _context2.prev = 5;\n                        _context2.next = 8;\n                        return stat(resolve(dirname(source), target));\n\n                      case 8:\n                        targetStat = _context2.sent;\n                        _context2.next = 13;\n                        break;\n\n                      case 11:\n                        _context2.prev = 11;\n                        _context2.t0 = _context2[\"catch\"](5);\n\n                      case 13:\n                        _context2.next = 15;\n                        return symlink(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file');\n\n                      case 15:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, null, [[5, 11]]);\n              }));\n\n              return function (_x4) {\n                return _ref4.apply(this, arguments);\n              };\n            }()));\n\n          case 46:\n            _context3.next = 48;\n            return rimraf(source);\n\n          case 48:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[15, 20]]);\n  }));\n\n  return function moveFile(_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar moveFileSync = function moveFileSync(source, destination) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var root = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  var symlinks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required');\n  }\n\n  options = _objectSpread({\n    overwrite: true\n  }, options);\n\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(\"The destination file exists: \".concat(destination));\n  }\n\n  mkdirp.sync(dirname(destination));\n\n  try {\n    renameSync(source, destination);\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      var sourceStat = lstatSync(source);\n\n      if (sourceStat.isDirectory()) {\n        var files = readdirSync(source);\n\n        var _iterator = _createForOfIteratorHelper(files),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var file = _step.value;\n            moveFileSync(join(source, file), join(destination, file), options, false, symlinks);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({\n          source: source,\n          destination: destination\n        });\n      } else {\n        copyFileSync(source, destination);\n      }\n    } else {\n      throw error;\n    }\n  }\n\n  if (root) {\n    var _iterator2 = _createForOfIteratorHelper(symlinks),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _step2.value,\n            _source = _step2$value.source,\n            _destination = _step2$value.destination;\n        var target = readlinkSync(_source); // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n\n        if (isAbsolute(target)) target = resolve(_destination, relative(_source, target)); // try to determine what the actual file is so we can create the correct type of symlink in windows\n\n        var targetStat = void 0;\n\n        try {\n          targetStat = statSync(resolve(dirname(_source), target));\n        } catch (err) {}\n\n        symlinkSync(target, _destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file');\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    rimrafSync(source);\n  }\n};\n\nmodule.exports = moveFile;\nmodule.exports.sync = moveFileSync;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@npmcli/move-file/index.js"],"names":["require","dirname","join","resolve","relative","isAbsolute","rimraf_","promisify","access_","access","accessSync","copyFile_","copyFile","copyFileSync","unlink_","unlink","unlinkSync","readdir_","readdir","readdirSync","rename_","rename","renameSync","stat_","stat","statSync","lstat_","lstat","lstatSync","symlink_","symlink","symlinkSync","readlink_","readlink","readlinkSync","rimraf","rimrafSync","sync","mkdirp","pathExists","path","code","pathExistsSync","er","moveFile","source","destination","options","root","symlinks","TypeError","overwrite","Error","sourceStat","isDirectory","files","Promise","all","map","file","isSymbolicLink","push","target","targetStat","moveFileSync","error","err","module","exports"],"mappings":"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","sourcesContent":["const { dirname, join, resolve, relative, isAbsolute } = require('path')\nconst rimraf_ = require('rimraf')\nconst { promisify } = require('util')\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  unlink: unlink_,\n  unlinkSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync\n} = require('fs')\n\nconst access = promisify(access_)\nconst copyFile = promisify(copyFile_)\nconst unlink = promisify(unlink_)\nconst readdir = promisify(readdir_)\nconst rename = promisify(rename_)\nconst stat = promisify(stat_)\nconst lstat = promisify(lstat_)\nconst symlink = promisify(symlink_)\nconst readlink = promisify(readlink_)\nconst rimraf = promisify(rimraf_)\nconst rimrafSync = rimraf_.sync\n\nconst mkdirp = require('mkdirp')\n\nconst pathExists = async path => {\n  try {\n    await access(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst pathExistsSync = path => {\n  try {\n    accessSync(path)\n    return true\n  } catch (er) {\n    return er.code !== 'ENOENT'\n  }\n}\n\nconst moveFile = async (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  }\n\n  if (!options.overwrite && await pathExists(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  await mkdirp(dirname(destination))\n\n  try {\n    await rename(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = await lstat(source)\n      if (sourceStat.isDirectory()) {\n        const files = await readdir(source)\n        await Promise.all(files.map((file) => moveFile(join(source, file), join(destination, file), options, false, symlinks)))\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        await copyFile(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    await Promise.all(symlinks.map(async ({ source, destination }) => {\n      let target = await readlink(source)\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target))\n        target = resolve(destination, relative(source, target))\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat\n      try {\n        targetStat = await stat(resolve(dirname(source), target))\n      } catch (err) {}\n      await symlink(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file')\n    }))\n    await rimraf(source)\n  }\n}\n\nconst moveFileSync = (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required')\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  }\n\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`)\n  }\n\n  mkdirp.sync(dirname(destination))\n\n  try {\n    renameSync(source, destination)\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source)\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source)\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks)\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({ source, destination })\n      } else {\n        copyFileSync(source, destination)\n      }\n    } else {\n      throw error\n    }\n  }\n\n  if (root) {\n    for (const { source, destination } of symlinks) {\n      let target = readlinkSync(source)\n      // junction symlinks in windows will be absolute paths, so we need to make sure they point to the destination\n      if (isAbsolute(target))\n        target = resolve(destination, relative(source, target))\n      // try to determine what the actual file is so we can create the correct type of symlink in windows\n      let targetStat\n      try {\n        targetStat = statSync(resolve(dirname(source), target))\n      } catch (err) {}\n      symlinkSync(target, destination, targetStat && targetStat.isDirectory() ? 'junction' : 'file')\n    }\n    rimrafSync(source)\n  }\n}\n\nmodule.exports = moveFile\nmodule.exports.sync = moveFileSync\n"]},"metadata":{},"sourceType":"script"}