{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/downlevel_decorators_transform\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/transformers/patch_alias_reference_resolution\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getDownlevelDecoratorsTransform = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var patch_alias_reference_resolution_1 = require(\"@angular/compiler-cli/src/transformers/patch_alias_reference_resolution\");\n  /**\n   * Whether a given decorator should be treated as an Angular decorator.\n   * Either it's used in @angular/core, or it's imported from there.\n   */\n\n\n  function isAngularDecorator(decorator, isCore) {\n    return isCore || decorator.import !== null && decorator.import.from === '@angular/core';\n  }\n  /*\n   #####################################################################\n    Code below has been extracted from the tsickle decorator downlevel transformer\n    and a few local modifications have been applied:\n  \n      1. Tsickle by default processed all decorators that had the `@Annotation` JSDoc.\n         We modified the transform to only be concerned with known Angular decorators.\n      2. Tsickle by default added `@nocollapse` to all generated `ctorParameters` properties.\n         We only do this when `annotateForClosureCompiler` is enabled.\n      3. Tsickle does not handle union types for dependency injection. i.e. if a injected type\n         is denoted with `@Optional`, the actual type could be set to `T | null`.\n         See: https://github.com/angular/angular-cli/commit/826803d0736b807867caff9f8903e508970ad5e4.\n      4. Tsickle relied on `emitDecoratorMetadata` to be set to `true`. This is due to a limitation\n         in TypeScript transformers that never has been fixed. We were able to work around this\n         limitation so that `emitDecoratorMetadata` doesn't need to be specified.\n         See: `patchAliasReferenceResolution` for more details.\n  \n    Here is a link to the tsickle revision on which this transformer is based:\n    https://github.com/angular/tsickle/blob/fae06becb1570f491806060d83f29f2d50c43cdd/src/decorator_downlevel_transformer.ts\n   #####################################################################\n  */\n\n  /**\n   * Creates the AST for the decorator field type annotation, which has the form\n   *     { type: Function, args?: any[] }[]\n   */\n\n\n  function createDecoratorInvocationType() {\n    var typeElements = [];\n    typeElements.push(ts.createPropertySignature(undefined, 'type', undefined, ts.createTypeReferenceNode(ts.createIdentifier('Function'), undefined), undefined));\n    typeElements.push(ts.createPropertySignature(undefined, 'args', ts.createToken(ts.SyntaxKind.QuestionToken), ts.createArrayTypeNode(ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)), undefined));\n    return ts.createArrayTypeNode(ts.createTypeLiteralNode(typeElements));\n  }\n  /**\n   * Extracts the type of the decorator (the function or expression invoked), as well as all the\n   * arguments passed to the decorator. Returns an AST with the form:\n   *\n   *     // For @decorator(arg1, arg2)\n   *     { type: decorator, args: [arg1, arg2] }\n   */\n\n\n  function extractMetadataFromSingleDecorator(decorator, diagnostics) {\n    var e_1, _a;\n\n    var metadataProperties = [];\n    var expr = decorator.expression;\n\n    switch (expr.kind) {\n      case ts.SyntaxKind.Identifier:\n        // The decorator was a plain @Foo.\n        metadataProperties.push(ts.createPropertyAssignment('type', expr));\n        break;\n\n      case ts.SyntaxKind.CallExpression:\n        // The decorator was a call, like @Foo(bar).\n        var call = expr;\n        metadataProperties.push(ts.createPropertyAssignment('type', call.expression));\n\n        if (call.arguments.length) {\n          var args = [];\n\n          try {\n            for (var _b = tslib_1.__values(call.arguments), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var arg = _c.value;\n              args.push(arg);\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n\n          var argsArrayLiteral = ts.createArrayLiteral(args);\n          argsArrayLiteral.elements.hasTrailingComma = true;\n          metadataProperties.push(ts.createPropertyAssignment('args', argsArrayLiteral));\n        }\n\n        break;\n\n      default:\n        diagnostics.push({\n          file: decorator.getSourceFile(),\n          start: decorator.getStart(),\n          length: decorator.getEnd() - decorator.getStart(),\n          messageText: ts.SyntaxKind[decorator.kind] + \" not implemented in gathering decorator metadata.\",\n          category: ts.DiagnosticCategory.Error,\n          code: 0\n        });\n        break;\n    }\n\n    return ts.createObjectLiteral(metadataProperties);\n  }\n  /**\n   * Takes a list of decorator metadata object ASTs and produces an AST for a\n   * static class property of an array of those metadata objects.\n   */\n\n\n  function createDecoratorClassProperty(decoratorList) {\n    var modifier = ts.createToken(ts.SyntaxKind.StaticKeyword);\n    var type = createDecoratorInvocationType();\n    var initializer = ts.createArrayLiteral(decoratorList, true); // NB: the .decorators property does not get a @nocollapse property. There is\n    // no good reason why - it means .decorators is not runtime accessible if you\n    // compile with collapse properties, whereas propDecorators is, which doesn't\n    // follow any stringent logic. However this has been the case previously, and\n    // adding it back in leads to substantial code size increases as Closure fails\n    // to tree shake these props without @nocollapse.\n\n    return ts.createProperty(undefined, [modifier], 'decorators', undefined, type, initializer);\n  }\n  /**\n   * Creates the AST for the 'ctorParameters' field type annotation:\n   *   () => ({ type: any, decorators?: {type: Function, args?: any[]}[] }|null)[]\n   */\n\n\n  function createCtorParametersClassPropertyType() {\n    // Sorry about this. Try reading just the string literals below.\n    var typeElements = [];\n    typeElements.push(ts.createPropertySignature(undefined, 'type', undefined, ts.createTypeReferenceNode(ts.createIdentifier('any'), undefined), undefined));\n    typeElements.push(ts.createPropertySignature(undefined, 'decorators', ts.createToken(ts.SyntaxKind.QuestionToken), ts.createArrayTypeNode(ts.createTypeLiteralNode([ts.createPropertySignature(undefined, 'type', undefined, ts.createTypeReferenceNode(ts.createIdentifier('Function'), undefined), undefined), ts.createPropertySignature(undefined, 'args', ts.createToken(ts.SyntaxKind.QuestionToken), ts.createArrayTypeNode(ts.createTypeReferenceNode(ts.createIdentifier('any'), undefined)), undefined)])), undefined));\n    return ts.createFunctionTypeNode(undefined, [], ts.createArrayTypeNode(ts.createUnionTypeNode([ts.createTypeLiteralNode(typeElements), ts.createLiteralTypeNode(ts.createNull())])));\n  }\n  /**\n   * Sets a Closure \\@nocollapse synthetic comment on the given node. This prevents Closure Compiler\n   * from collapsing the apparently static property, which would make it impossible to find for code\n   * trying to detect it at runtime.\n   */\n\n\n  function addNoCollapseComment(n) {\n    ts.setSyntheticLeadingComments(n, [{\n      kind: ts.SyntaxKind.MultiLineCommentTrivia,\n      text: '* @nocollapse ',\n      pos: -1,\n      end: -1,\n      hasTrailingNewLine: true\n    }]);\n  }\n  /**\n   * createCtorParametersClassProperty creates a static 'ctorParameters' property containing\n   * downleveled decorator information.\n   *\n   * The property contains an arrow function that returns an array of object literals of the shape:\n   *     static ctorParameters = () => [{\n   *       type: SomeClass|undefined,  // the type of the param that's decorated, if it's a value.\n   *       decorators: [{\n   *         type: DecoratorFn,  // the type of the decorator that's invoked.\n   *         args: [ARGS],       // the arguments passed to the decorator.\n   *       }]\n   *     }];\n   */\n\n\n  function createCtorParametersClassProperty(diagnostics, entityNameToExpression, ctorParameters, isClosureCompilerEnabled) {\n    var e_2, _a, e_3, _b;\n\n    var params = [];\n\n    try {\n      for (var ctorParameters_1 = tslib_1.__values(ctorParameters), ctorParameters_1_1 = ctorParameters_1.next(); !ctorParameters_1_1.done; ctorParameters_1_1 = ctorParameters_1.next()) {\n        var ctorParam = ctorParameters_1_1.value;\n\n        if (!ctorParam.type && ctorParam.decorators.length === 0) {\n          params.push(ts.createNull());\n          continue;\n        }\n\n        var paramType = ctorParam.type ? typeReferenceToExpression(entityNameToExpression, ctorParam.type) : undefined;\n        var members = [ts.createPropertyAssignment('type', paramType || ts.createIdentifier('undefined'))];\n        var decorators = [];\n\n        try {\n          for (var _c = (e_3 = void 0, tslib_1.__values(ctorParam.decorators)), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var deco = _d.value;\n            decorators.push(extractMetadataFromSingleDecorator(deco, diagnostics));\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n\n        if (decorators.length) {\n          members.push(ts.createPropertyAssignment('decorators', ts.createArrayLiteral(decorators)));\n        }\n\n        params.push(ts.createObjectLiteral(members));\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (ctorParameters_1_1 && !ctorParameters_1_1.done && (_a = ctorParameters_1.return)) _a.call(ctorParameters_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    var initializer = ts.createArrowFunction(undefined, undefined, [], undefined, ts.createToken(ts.SyntaxKind.EqualsGreaterThanToken), ts.createArrayLiteral(params, true));\n    var type = createCtorParametersClassPropertyType();\n    var ctorProp = ts.createProperty(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], 'ctorParameters', undefined, type, initializer);\n\n    if (isClosureCompilerEnabled) {\n      addNoCollapseComment(ctorProp);\n    }\n\n    return ctorProp;\n  }\n  /**\n   * createPropDecoratorsClassProperty creates a static 'propDecorators' property containing type\n   * information for every property that has a decorator applied.\n   *\n   *     static propDecorators: {[key: string]: {type: Function, args?: any[]}[]} = {\n   *       propA: [{type: MyDecorator, args: [1, 2]}, ...],\n   *       ...\n   *     };\n   */\n\n\n  function createPropDecoratorsClassProperty(diagnostics, properties) {\n    var e_4, _a; //  `static propDecorators: {[key: string]: ` + {type: Function, args?: any[]}[] + `} = {\\n`);\n\n\n    var entries = [];\n\n    try {\n      for (var _b = tslib_1.__values(properties.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = tslib_1.__read(_c.value, 2),\n            name = _d[0],\n            decorators = _d[1];\n\n        entries.push(ts.createPropertyAssignment(name, ts.createArrayLiteral(decorators.map(function (deco) {\n          return extractMetadataFromSingleDecorator(deco, diagnostics);\n        }))));\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    var initializer = ts.createObjectLiteral(entries, true);\n    var type = ts.createTypeLiteralNode([ts.createIndexSignature(undefined, undefined, [ts.createParameter(undefined, undefined, undefined, 'key', undefined, ts.createTypeReferenceNode('string', undefined), undefined)], createDecoratorInvocationType())]);\n    return ts.createProperty(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], 'propDecorators', undefined, type, initializer);\n  }\n  /**\n   * Returns an expression representing the (potentially) value part for the given node.\n   *\n   * This is a partial re-implementation of TypeScript's serializeTypeReferenceNode. This is a\n   * workaround for https://github.com/Microsoft/TypeScript/issues/17516 (serializeTypeReferenceNode\n   * not being exposed). In practice this implementation is sufficient for Angular's use of type\n   * metadata.\n   */\n\n\n  function typeReferenceToExpression(entityNameToExpression, node) {\n    var kind = node.kind;\n\n    if (ts.isLiteralTypeNode(node)) {\n      // Treat literal types like their base type (boolean, string, number).\n      kind = node.literal.kind;\n    }\n\n    switch (kind) {\n      case ts.SyntaxKind.FunctionType:\n      case ts.SyntaxKind.ConstructorType:\n        return ts.createIdentifier('Function');\n\n      case ts.SyntaxKind.ArrayType:\n      case ts.SyntaxKind.TupleType:\n        return ts.createIdentifier('Array');\n\n      case ts.SyntaxKind.TypePredicate:\n      case ts.SyntaxKind.TrueKeyword:\n      case ts.SyntaxKind.FalseKeyword:\n      case ts.SyntaxKind.BooleanKeyword:\n        return ts.createIdentifier('Boolean');\n\n      case ts.SyntaxKind.StringLiteral:\n      case ts.SyntaxKind.StringKeyword:\n        return ts.createIdentifier('String');\n\n      case ts.SyntaxKind.ObjectKeyword:\n        return ts.createIdentifier('Object');\n\n      case ts.SyntaxKind.NumberKeyword:\n      case ts.SyntaxKind.NumericLiteral:\n        return ts.createIdentifier('Number');\n\n      case ts.SyntaxKind.TypeReference:\n        var typeRef = node; // Ignore any generic types, just return the base type.\n\n        return entityNameToExpression(typeRef.typeName);\n\n      case ts.SyntaxKind.UnionType:\n        var childTypeNodes = node.types.filter(function (t) {\n          return !(ts.isLiteralTypeNode(t) && t.literal.kind === ts.SyntaxKind.NullKeyword);\n        });\n        return childTypeNodes.length === 1 ? typeReferenceToExpression(entityNameToExpression, childTypeNodes[0]) : undefined;\n\n      default:\n        return undefined;\n    }\n  }\n  /**\n   * Checks whether a given symbol refers to a value that exists at runtime (as distinct from a type).\n   *\n   * Expands aliases, which is important for the case where\n   *   import * as x from 'some-module';\n   * and x is now a value (the module object).\n   */\n\n\n  function symbolIsRuntimeValue(typeChecker, symbol) {\n    if (symbol.flags & ts.SymbolFlags.Alias) {\n      symbol = typeChecker.getAliasedSymbol(symbol);\n    } // Note that const enums are a special case, because\n    // while they have a value, they don't exist at runtime.\n\n\n    return (symbol.flags & ts.SymbolFlags.Value & ts.SymbolFlags.ConstEnumExcludes) !== 0;\n  }\n  /**\n   * Gets a transformer for downleveling Angular decorators.\n   * @param typeChecker Reference to the program's type checker.\n   * @param host Reflection host that is used for determining decorators.\n   * @param diagnostics List which will be populated with diagnostics if any.\n   * @param isCore Whether the current TypeScript program is for the `@angular/core` package.\n   * @param isClosureCompilerEnabled Whether closure annotations need to be added where needed.\n   * @param skipClassDecorators Whether class decorators should be skipped from downleveling.\n   *   This is useful for JIT mode where class decorators should be preserved as they could rely\n   *   on immediate execution. e.g. downleveling `@Injectable` means that the injectable factory\n   *   is not created, and injecting the token will not work. If this decorator would not be\n   *   downleveled, the `Injectable` decorator will execute immediately on file load, and\n   *   Angular will generate the corresponding injectable factory.\n   */\n\n\n  function getDownlevelDecoratorsTransform(typeChecker, host, diagnostics, isCore, isClosureCompilerEnabled, skipClassDecorators) {\n    return function (context) {\n      // Ensure that referenced type symbols are not elided by TypeScript. Imports for\n      // such parameter type symbols previously could be type-only, but now might be also\n      // used in the `ctorParameters` static property as a value. We want to make sure\n      // that TypeScript does not elide imports for such type references. Read more\n      // about this in the description for `loadIsReferencedAliasDeclarationPatch`.\n      var referencedParameterTypes = patch_alias_reference_resolution_1.loadIsReferencedAliasDeclarationPatch(context);\n      /**\n       * Converts an EntityName (from a type annotation) to an expression (accessing a value).\n       *\n       * For a given qualified name, this walks depth first to find the leftmost identifier,\n       * and then converts the path into a property access that can be used as expression.\n       */\n\n      function entityNameToExpression(name) {\n        var symbol = typeChecker.getSymbolAtLocation(name); // Check if the entity name references a symbol that is an actual value. If it is not, it\n        // cannot be referenced by an expression, so return undefined.\n\n        if (!symbol || !symbolIsRuntimeValue(typeChecker, symbol) || !symbol.declarations || symbol.declarations.length === 0) {\n          return undefined;\n        } // If we deal with a qualified name, build up a property access expression\n        // that could be used in the JavaScript output.\n\n\n        if (ts.isQualifiedName(name)) {\n          var containerExpr = entityNameToExpression(name.left);\n\n          if (containerExpr === undefined) {\n            return undefined;\n          }\n\n          return ts.createPropertyAccess(containerExpr, name.right);\n        }\n\n        var decl = symbol.declarations[0]; // If the given entity name has been resolved to an alias import declaration,\n        // ensure that the alias declaration is not elided by TypeScript, and use its\n        // name identifier to reference it at runtime.\n\n        if (patch_alias_reference_resolution_1.isAliasImportDeclaration(decl)) {\n          referencedParameterTypes.add(decl); // If the entity name resolves to an alias import declaration, we reference the\n          // entity based on the alias import name. This ensures that TypeScript properly\n          // resolves the link to the import. Cloning the original entity name identifier\n          // could lead to an incorrect resolution at local scope. e.g. Consider the following\n          // snippet: `constructor(Dep: Dep) {}`. In such a case, the local `Dep` identifier\n          // would resolve to the actual parameter name, and not to the desired import.\n          // This happens because the entity name identifier symbol is internally considered\n          // as type-only and therefore TypeScript tries to resolve it as value manually.\n          // We can help TypeScript and avoid this non-reliable resolution by using an identifier\n          // that is not type-only and is directly linked to the import alias declaration.\n\n          if (decl.name !== undefined) {\n            return ts.getMutableClone(decl.name);\n          }\n        } // Clone the original entity name identifier so that it can be used to reference\n        // its value at runtime. This is used when the identifier is resolving to a file\n        // local declaration (otherwise it would resolve to an alias import declaration).\n\n\n        return ts.getMutableClone(name);\n      }\n      /**\n       * Transforms a class element. Returns a three tuple of name, transformed element, and\n       * decorators found. Returns an undefined name if there are no decorators to lower on the\n       * element, or the element has an exotic name.\n       */\n\n\n      function transformClassElement(element) {\n        var e_5, _a;\n\n        element = ts.visitEachChild(element, decoratorDownlevelVisitor, context);\n        var decoratorsToKeep = [];\n        var toLower = [];\n        var decorators = host.getDecoratorsOfDeclaration(element) || [];\n\n        try {\n          for (var decorators_1 = tslib_1.__values(decorators), decorators_1_1 = decorators_1.next(); !decorators_1_1.done; decorators_1_1 = decorators_1.next()) {\n            var decorator = decorators_1_1.value; // We only deal with concrete nodes in TypeScript sources, so we don't\n            // need to handle synthetically created decorators.\n\n            var decoratorNode = decorator.node;\n\n            if (!isAngularDecorator(decorator, isCore)) {\n              decoratorsToKeep.push(decoratorNode);\n              continue;\n            }\n\n            toLower.push(decoratorNode);\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (decorators_1_1 && !decorators_1_1.done && (_a = decorators_1.return)) _a.call(decorators_1);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n\n        if (!toLower.length) return [undefined, element, []];\n\n        if (!element.name || !ts.isIdentifier(element.name)) {\n          // Method has a weird name, e.g.\n          //   [Symbol.foo]() {...}\n          diagnostics.push({\n            file: element.getSourceFile(),\n            start: element.getStart(),\n            length: element.getEnd() - element.getStart(),\n            messageText: \"Cannot process decorators for class element with non-analyzable name.\",\n            category: ts.DiagnosticCategory.Error,\n            code: 0\n          });\n          return [undefined, element, []];\n        }\n\n        var name = element.name.text;\n        var mutable = ts.getMutableClone(element);\n        mutable.decorators = decoratorsToKeep.length ? ts.setTextRange(ts.createNodeArray(decoratorsToKeep), mutable.decorators) : undefined;\n        return [name, mutable, toLower];\n      }\n      /**\n       * Transforms a constructor. Returns the transformed constructor and the list of parameter\n       * information collected, consisting of decorators and optional type.\n       */\n\n\n      function transformConstructor(ctor) {\n        var e_6, _a, e_7, _b;\n\n        ctor = ts.visitEachChild(ctor, decoratorDownlevelVisitor, context);\n        var newParameters = [];\n        var oldParameters = ts.visitParameterList(ctor.parameters, decoratorDownlevelVisitor, context);\n        var parametersInfo = [];\n\n        try {\n          for (var oldParameters_1 = tslib_1.__values(oldParameters), oldParameters_1_1 = oldParameters_1.next(); !oldParameters_1_1.done; oldParameters_1_1 = oldParameters_1.next()) {\n            var param = oldParameters_1_1.value;\n            var decoratorsToKeep = [];\n            var paramInfo = {\n              decorators: [],\n              type: null\n            };\n            var decorators = host.getDecoratorsOfDeclaration(param) || [];\n\n            try {\n              for (var decorators_2 = (e_7 = void 0, tslib_1.__values(decorators)), decorators_2_1 = decorators_2.next(); !decorators_2_1.done; decorators_2_1 = decorators_2.next()) {\n                var decorator = decorators_2_1.value; // We only deal with concrete nodes in TypeScript sources, so we don't\n                // need to handle synthetically created decorators.\n\n                var decoratorNode = decorator.node;\n\n                if (!isAngularDecorator(decorator, isCore)) {\n                  decoratorsToKeep.push(decoratorNode);\n                  continue;\n                }\n\n                paramInfo.decorators.push(decoratorNode);\n              }\n            } catch (e_7_1) {\n              e_7 = {\n                error: e_7_1\n              };\n            } finally {\n              try {\n                if (decorators_2_1 && !decorators_2_1.done && (_b = decorators_2.return)) _b.call(decorators_2);\n              } finally {\n                if (e_7) throw e_7.error;\n              }\n            }\n\n            if (param.type) {\n              // param has a type provided, e.g. \"foo: Bar\".\n              // The type will be emitted as a value expression in entityNameToExpression, which takes\n              // care not to emit anything for types that cannot be expressed as a value (e.g.\n              // interfaces).\n              paramInfo.type = param.type;\n            }\n\n            parametersInfo.push(paramInfo);\n            var newParam = ts.updateParameter(param, // Must pass 'undefined' to avoid emitting decorator metadata.\n            decoratorsToKeep.length ? decoratorsToKeep : undefined, param.modifiers, param.dotDotDotToken, param.name, param.questionToken, param.type, param.initializer);\n            newParameters.push(newParam);\n          }\n        } catch (e_6_1) {\n          e_6 = {\n            error: e_6_1\n          };\n        } finally {\n          try {\n            if (oldParameters_1_1 && !oldParameters_1_1.done && (_a = oldParameters_1.return)) _a.call(oldParameters_1);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n        }\n\n        var updated = ts.updateConstructor(ctor, ctor.decorators, ctor.modifiers, newParameters, ts.visitFunctionBody(ctor.body, decoratorDownlevelVisitor, context));\n        return [updated, parametersInfo];\n      }\n      /**\n       * Transforms a single class declaration:\n       * - dispatches to strip decorators on members\n       * - converts decorators on the class to annotations\n       * - creates a ctorParameters property\n       * - creates a propDecorators property\n       */\n\n\n      function transformClassDeclaration(classDecl) {\n        var e_8, _a, e_9, _b;\n\n        classDecl = ts.getMutableClone(classDecl);\n        var newMembers = [];\n        var decoratedProperties = new Map();\n        var classParameters = null;\n\n        try {\n          for (var _c = tslib_1.__values(classDecl.members), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var member = _d.value;\n\n            switch (member.kind) {\n              case ts.SyntaxKind.PropertyDeclaration:\n              case ts.SyntaxKind.GetAccessor:\n              case ts.SyntaxKind.SetAccessor:\n              case ts.SyntaxKind.MethodDeclaration:\n                {\n                  var _e = tslib_1.__read(transformClassElement(member), 3),\n                      name = _e[0],\n                      newMember = _e[1],\n                      decorators = _e[2];\n\n                  newMembers.push(newMember);\n                  if (name) decoratedProperties.set(name, decorators);\n                  continue;\n                }\n\n              case ts.SyntaxKind.Constructor:\n                {\n                  var ctor = member;\n                  if (!ctor.body) break;\n\n                  var _f = tslib_1.__read(transformConstructor(member), 2),\n                      newMember = _f[0],\n                      parametersInfo = _f[1];\n\n                  classParameters = parametersInfo;\n                  newMembers.push(newMember);\n                  continue;\n                }\n\n              default:\n                break;\n            }\n\n            newMembers.push(ts.visitEachChild(member, decoratorDownlevelVisitor, context));\n          }\n        } catch (e_8_1) {\n          e_8 = {\n            error: e_8_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_8) throw e_8.error;\n          }\n        } // The `ReflectionHost.getDecoratorsOfDeclaration()` method will not return certain kinds of\n        // decorators that will never be Angular decorators. So we cannot rely on it to capture all\n        // the decorators that should be kept. Instead we start off with a set of the raw decorators\n        // on the class, and only remove the ones that have been identified for downleveling.\n\n\n        var decoratorsToKeep = new Set(classDecl.decorators);\n        var possibleAngularDecorators = host.getDecoratorsOfDeclaration(classDecl) || [];\n        var hasAngularDecorator = false;\n        var decoratorsToLower = [];\n\n        try {\n          for (var possibleAngularDecorators_1 = tslib_1.__values(possibleAngularDecorators), possibleAngularDecorators_1_1 = possibleAngularDecorators_1.next(); !possibleAngularDecorators_1_1.done; possibleAngularDecorators_1_1 = possibleAngularDecorators_1.next()) {\n            var decorator = possibleAngularDecorators_1_1.value; // We only deal with concrete nodes in TypeScript sources, so we don't\n            // need to handle synthetically created decorators.\n\n            var decoratorNode = decorator.node;\n            var isNgDecorator = isAngularDecorator(decorator, isCore); // Keep track if we come across an Angular class decorator. This is used\n            // for to determine whether constructor parameters should be captured or not.\n\n            if (isNgDecorator) {\n              hasAngularDecorator = true;\n            }\n\n            if (isNgDecorator && !skipClassDecorators) {\n              decoratorsToLower.push(extractMetadataFromSingleDecorator(decoratorNode, diagnostics));\n              decoratorsToKeep.delete(decoratorNode);\n            }\n          }\n        } catch (e_9_1) {\n          e_9 = {\n            error: e_9_1\n          };\n        } finally {\n          try {\n            if (possibleAngularDecorators_1_1 && !possibleAngularDecorators_1_1.done && (_b = possibleAngularDecorators_1.return)) _b.call(possibleAngularDecorators_1);\n          } finally {\n            if (e_9) throw e_9.error;\n          }\n        }\n\n        if (decoratorsToLower.length) {\n          newMembers.push(createDecoratorClassProperty(decoratorsToLower));\n        }\n\n        if (classParameters) {\n          if (hasAngularDecorator || classParameters.some(function (p) {\n            return !!p.decorators.length;\n          })) {\n            // Capture constructor parameters if the class has Angular decorator applied,\n            // or if any of the parameters has decorators applied directly.\n            newMembers.push(createCtorParametersClassProperty(diagnostics, entityNameToExpression, classParameters, isClosureCompilerEnabled));\n          }\n        }\n\n        if (decoratedProperties.size) {\n          newMembers.push(createPropDecoratorsClassProperty(diagnostics, decoratedProperties));\n        }\n\n        var members = ts.setTextRange(ts.createNodeArray(newMembers, classDecl.members.hasTrailingComma), classDecl.members);\n        return ts.updateClassDeclaration(classDecl, decoratorsToKeep.size ? Array.from(decoratorsToKeep) : undefined, classDecl.modifiers, classDecl.name, classDecl.typeParameters, classDecl.heritageClauses, members);\n      }\n      /**\n       * Transformer visitor that looks for Angular decorators and replaces them with\n       * downleveled static properties. Also collects constructor type metadata for\n       * class declaration that are decorated with an Angular decorator.\n       */\n\n\n      function decoratorDownlevelVisitor(node) {\n        if (ts.isClassDeclaration(node)) {\n          return transformClassDeclaration(node);\n        }\n\n        return ts.visitEachChild(node, decoratorDownlevelVisitor, context);\n      }\n\n      return function (sf) {\n        // Downlevel decorators and constructor parameter types. We will keep track of all\n        // referenced constructor parameter types so that we can instruct TypeScript to\n        // not elide their imports if they previously were only type-only.\n        return ts.visitEachChild(sf, decoratorDownlevelVisitor, context);\n      };\n    };\n  }\n\n  exports.getDownlevelDecoratorsTransform = getDownlevelDecoratorsTransform;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/downlevel_decorators_transform.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\nimport {Decorator, ReflectionHost} from '../ngtsc/reflection';\nimport {isAliasImportDeclaration, loadIsReferencedAliasDeclarationPatch} from './patch_alias_reference_resolution';\n\n/**\n * Whether a given decorator should be treated as an Angular decorator.\n * Either it's used in @angular/core, or it's imported from there.\n */\nfunction isAngularDecorator(decorator: Decorator, isCore: boolean): boolean {\n  return isCore || (decorator.import !== null && decorator.import.from === '@angular/core');\n}\n\n/*\n #####################################################################\n  Code below has been extracted from the tsickle decorator downlevel transformer\n  and a few local modifications have been applied:\n\n    1. Tsickle by default processed all decorators that had the `@Annotation` JSDoc.\n       We modified the transform to only be concerned with known Angular decorators.\n    2. Tsickle by default added `@nocollapse` to all generated `ctorParameters` properties.\n       We only do this when `annotateForClosureCompiler` is enabled.\n    3. Tsickle does not handle union types for dependency injection. i.e. if a injected type\n       is denoted with `@Optional`, the actual type could be set to `T | null`.\n       See: https://github.com/angular/angular-cli/commit/826803d0736b807867caff9f8903e508970ad5e4.\n    4. Tsickle relied on `emitDecoratorMetadata` to be set to `true`. This is due to a limitation\n       in TypeScript transformers that never has been fixed. We were able to work around this\n       limitation so that `emitDecoratorMetadata` doesn't need to be specified.\n       See: `patchAliasReferenceResolution` for more details.\n\n  Here is a link to the tsickle revision on which this transformer is based:\n  https://github.com/angular/tsickle/blob/fae06becb1570f491806060d83f29f2d50c43cdd/src/decorator_downlevel_transformer.ts\n #####################################################################\n*/\n\n/**\n * Creates the AST for the decorator field type annotation, which has the form\n *     { type: Function, args?: any[] }[]\n */\nfunction createDecoratorInvocationType(): ts.TypeNode {\n  const typeElements: ts.TypeElement[] = [];\n  typeElements.push(ts.createPropertySignature(\n      undefined, 'type', undefined,\n      ts.createTypeReferenceNode(ts.createIdentifier('Function'), undefined), undefined));\n  typeElements.push(ts.createPropertySignature(\n      undefined, 'args', ts.createToken(ts.SyntaxKind.QuestionToken),\n      ts.createArrayTypeNode(ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword)), undefined));\n  return ts.createArrayTypeNode(ts.createTypeLiteralNode(typeElements));\n}\n\n/**\n * Extracts the type of the decorator (the function or expression invoked), as well as all the\n * arguments passed to the decorator. Returns an AST with the form:\n *\n *     // For @decorator(arg1, arg2)\n *     { type: decorator, args: [arg1, arg2] }\n */\nfunction extractMetadataFromSingleDecorator(\n    decorator: ts.Decorator, diagnostics: ts.Diagnostic[]): ts.ObjectLiteralExpression {\n  const metadataProperties: ts.ObjectLiteralElementLike[] = [];\n  const expr = decorator.expression;\n  switch (expr.kind) {\n    case ts.SyntaxKind.Identifier:\n      // The decorator was a plain @Foo.\n      metadataProperties.push(ts.createPropertyAssignment('type', expr));\n      break;\n    case ts.SyntaxKind.CallExpression:\n      // The decorator was a call, like @Foo(bar).\n      const call = expr as ts.CallExpression;\n      metadataProperties.push(ts.createPropertyAssignment('type', call.expression));\n      if (call.arguments.length) {\n        const args: ts.Expression[] = [];\n        for (const arg of call.arguments) {\n          args.push(arg);\n        }\n        const argsArrayLiteral = ts.createArrayLiteral(args);\n        argsArrayLiteral.elements.hasTrailingComma = true;\n        metadataProperties.push(ts.createPropertyAssignment('args', argsArrayLiteral));\n      }\n      break;\n    default:\n      diagnostics.push({\n        file: decorator.getSourceFile(),\n        start: decorator.getStart(),\n        length: decorator.getEnd() - decorator.getStart(),\n        messageText:\n            `${ts.SyntaxKind[decorator.kind]} not implemented in gathering decorator metadata.`,\n        category: ts.DiagnosticCategory.Error,\n        code: 0,\n      });\n      break;\n  }\n  return ts.createObjectLiteral(metadataProperties);\n}\n\n/**\n * Takes a list of decorator metadata object ASTs and produces an AST for a\n * static class property of an array of those metadata objects.\n */\nfunction createDecoratorClassProperty(decoratorList: ts.ObjectLiteralExpression[]) {\n  const modifier = ts.createToken(ts.SyntaxKind.StaticKeyword);\n  const type = createDecoratorInvocationType();\n  const initializer = ts.createArrayLiteral(decoratorList, true);\n  // NB: the .decorators property does not get a @nocollapse property. There is\n  // no good reason why - it means .decorators is not runtime accessible if you\n  // compile with collapse properties, whereas propDecorators is, which doesn't\n  // follow any stringent logic. However this has been the case previously, and\n  // adding it back in leads to substantial code size increases as Closure fails\n  // to tree shake these props without @nocollapse.\n  return ts.createProperty(undefined, [modifier], 'decorators', undefined, type, initializer);\n}\n\n/**\n * Creates the AST for the 'ctorParameters' field type annotation:\n *   () => ({ type: any, decorators?: {type: Function, args?: any[]}[] }|null)[]\n */\nfunction createCtorParametersClassPropertyType(): ts.TypeNode {\n  // Sorry about this. Try reading just the string literals below.\n  const typeElements: ts.TypeElement[] = [];\n  typeElements.push(ts.createPropertySignature(\n      undefined, 'type', undefined,\n      ts.createTypeReferenceNode(ts.createIdentifier('any'), undefined), undefined));\n  typeElements.push(ts.createPropertySignature(\n      undefined, 'decorators', ts.createToken(ts.SyntaxKind.QuestionToken),\n      ts.createArrayTypeNode(ts.createTypeLiteralNode([\n        ts.createPropertySignature(\n            undefined, 'type', undefined,\n            ts.createTypeReferenceNode(ts.createIdentifier('Function'), undefined), undefined),\n        ts.createPropertySignature(\n            undefined, 'args', ts.createToken(ts.SyntaxKind.QuestionToken),\n            ts.createArrayTypeNode(\n                ts.createTypeReferenceNode(ts.createIdentifier('any'), undefined)),\n            undefined),\n      ])),\n      undefined));\n\n  return ts.createFunctionTypeNode(undefined, [], ts.createArrayTypeNode(ts.createUnionTypeNode([\n    ts.createTypeLiteralNode(typeElements),\n    ts.createLiteralTypeNode(ts.createNull()),\n  ])));\n}\n\n/**\n * Sets a Closure \\@nocollapse synthetic comment on the given node. This prevents Closure Compiler\n * from collapsing the apparently static property, which would make it impossible to find for code\n * trying to detect it at runtime.\n */\nfunction addNoCollapseComment(n: ts.Node) {\n  ts.setSyntheticLeadingComments(n, [{\n                                   kind: ts.SyntaxKind.MultiLineCommentTrivia,\n                                   text: '* @nocollapse ',\n                                   pos: -1,\n                                   end: -1,\n                                   hasTrailingNewLine: true\n                                 }]);\n}\n\n/**\n * createCtorParametersClassProperty creates a static 'ctorParameters' property containing\n * downleveled decorator information.\n *\n * The property contains an arrow function that returns an array of object literals of the shape:\n *     static ctorParameters = () => [{\n *       type: SomeClass|undefined,  // the type of the param that's decorated, if it's a value.\n *       decorators: [{\n *         type: DecoratorFn,  // the type of the decorator that's invoked.\n *         args: [ARGS],       // the arguments passed to the decorator.\n *       }]\n *     }];\n */\nfunction createCtorParametersClassProperty(\n    diagnostics: ts.Diagnostic[],\n    entityNameToExpression: (n: ts.EntityName) => ts.Expression | undefined,\n    ctorParameters: ParameterDecorationInfo[],\n    isClosureCompilerEnabled: boolean): ts.PropertyDeclaration {\n  const params: ts.Expression[] = [];\n\n  for (const ctorParam of ctorParameters) {\n    if (!ctorParam.type && ctorParam.decorators.length === 0) {\n      params.push(ts.createNull());\n      continue;\n    }\n\n    const paramType = ctorParam.type ?\n        typeReferenceToExpression(entityNameToExpression, ctorParam.type) :\n        undefined;\n    const members =\n        [ts.createPropertyAssignment('type', paramType || ts.createIdentifier('undefined'))];\n\n    const decorators: ts.ObjectLiteralExpression[] = [];\n    for (const deco of ctorParam.decorators) {\n      decorators.push(extractMetadataFromSingleDecorator(deco, diagnostics));\n    }\n    if (decorators.length) {\n      members.push(ts.createPropertyAssignment('decorators', ts.createArrayLiteral(decorators)));\n    }\n    params.push(ts.createObjectLiteral(members));\n  }\n\n  const initializer = ts.createArrowFunction(\n      undefined, undefined, [], undefined, ts.createToken(ts.SyntaxKind.EqualsGreaterThanToken),\n      ts.createArrayLiteral(params, true));\n  const type = createCtorParametersClassPropertyType();\n  const ctorProp = ts.createProperty(\n      undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], 'ctorParameters', undefined, type,\n      initializer);\n  if (isClosureCompilerEnabled) {\n    addNoCollapseComment(ctorProp);\n  }\n  return ctorProp;\n}\n\n/**\n * createPropDecoratorsClassProperty creates a static 'propDecorators' property containing type\n * information for every property that has a decorator applied.\n *\n *     static propDecorators: {[key: string]: {type: Function, args?: any[]}[]} = {\n *       propA: [{type: MyDecorator, args: [1, 2]}, ...],\n *       ...\n *     };\n */\nfunction createPropDecoratorsClassProperty(\n    diagnostics: ts.Diagnostic[], properties: Map<string, ts.Decorator[]>): ts.PropertyDeclaration {\n  //  `static propDecorators: {[key: string]: ` + {type: Function, args?: any[]}[] + `} = {\\n`);\n  const entries: ts.ObjectLiteralElementLike[] = [];\n  for (const [name, decorators] of properties.entries()) {\n    entries.push(ts.createPropertyAssignment(\n        name,\n        ts.createArrayLiteral(\n            decorators.map(deco => extractMetadataFromSingleDecorator(deco, diagnostics)))));\n  }\n  const initializer = ts.createObjectLiteral(entries, true);\n  const type = ts.createTypeLiteralNode([ts.createIndexSignature(\n      undefined, undefined, [ts.createParameter(\n                                undefined, undefined, undefined, 'key', undefined,\n                                ts.createTypeReferenceNode('string', undefined), undefined)],\n      createDecoratorInvocationType())]);\n  return ts.createProperty(\n      undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], 'propDecorators', undefined, type,\n      initializer);\n}\n\n/**\n * Returns an expression representing the (potentially) value part for the given node.\n *\n * This is a partial re-implementation of TypeScript's serializeTypeReferenceNode. This is a\n * workaround for https://github.com/Microsoft/TypeScript/issues/17516 (serializeTypeReferenceNode\n * not being exposed). In practice this implementation is sufficient for Angular's use of type\n * metadata.\n */\nfunction typeReferenceToExpression(\n    entityNameToExpression: (n: ts.EntityName) => ts.Expression | undefined,\n    node: ts.TypeNode): ts.Expression|undefined {\n  let kind = node.kind;\n  if (ts.isLiteralTypeNode(node)) {\n    // Treat literal types like their base type (boolean, string, number).\n    kind = node.literal.kind;\n  }\n  switch (kind) {\n    case ts.SyntaxKind.FunctionType:\n    case ts.SyntaxKind.ConstructorType:\n      return ts.createIdentifier('Function');\n    case ts.SyntaxKind.ArrayType:\n    case ts.SyntaxKind.TupleType:\n      return ts.createIdentifier('Array');\n    case ts.SyntaxKind.TypePredicate:\n    case ts.SyntaxKind.TrueKeyword:\n    case ts.SyntaxKind.FalseKeyword:\n    case ts.SyntaxKind.BooleanKeyword:\n      return ts.createIdentifier('Boolean');\n    case ts.SyntaxKind.StringLiteral:\n    case ts.SyntaxKind.StringKeyword:\n      return ts.createIdentifier('String');\n    case ts.SyntaxKind.ObjectKeyword:\n      return ts.createIdentifier('Object');\n    case ts.SyntaxKind.NumberKeyword:\n    case ts.SyntaxKind.NumericLiteral:\n      return ts.createIdentifier('Number');\n    case ts.SyntaxKind.TypeReference:\n      const typeRef = node as ts.TypeReferenceNode;\n      // Ignore any generic types, just return the base type.\n      return entityNameToExpression(typeRef.typeName);\n    case ts.SyntaxKind.UnionType:\n      const childTypeNodes =\n          (node as ts.UnionTypeNode)\n              .types.filter(\n                  t => !(ts.isLiteralTypeNode(t) && t.literal.kind === ts.SyntaxKind.NullKeyword));\n      return childTypeNodes.length === 1 ?\n          typeReferenceToExpression(entityNameToExpression, childTypeNodes[0]) :\n          undefined;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Checks whether a given symbol refers to a value that exists at runtime (as distinct from a type).\n *\n * Expands aliases, which is important for the case where\n *   import * as x from 'some-module';\n * and x is now a value (the module object).\n */\nfunction symbolIsRuntimeValue(typeChecker: ts.TypeChecker, symbol: ts.Symbol): boolean {\n  if (symbol.flags & ts.SymbolFlags.Alias) {\n    symbol = typeChecker.getAliasedSymbol(symbol);\n  }\n\n  // Note that const enums are a special case, because\n  // while they have a value, they don't exist at runtime.\n  return (symbol.flags & ts.SymbolFlags.Value & ts.SymbolFlags.ConstEnumExcludes) !== 0;\n}\n\n/** ParameterDecorationInfo describes the information for a single constructor parameter. */\ninterface ParameterDecorationInfo {\n  /**\n   * The type declaration for the parameter. Only set if the type is a value (e.g. a class, not an\n   * interface).\n   */\n  type: ts.TypeNode|null;\n  /** The list of decorators found on the parameter, null if none. */\n  decorators: ts.Decorator[];\n}\n\n/**\n * Gets a transformer for downleveling Angular decorators.\n * @param typeChecker Reference to the program's type checker.\n * @param host Reflection host that is used for determining decorators.\n * @param diagnostics List which will be populated with diagnostics if any.\n * @param isCore Whether the current TypeScript program is for the `@angular/core` package.\n * @param isClosureCompilerEnabled Whether closure annotations need to be added where needed.\n * @param skipClassDecorators Whether class decorators should be skipped from downleveling.\n *   This is useful for JIT mode where class decorators should be preserved as they could rely\n *   on immediate execution. e.g. downleveling `@Injectable` means that the injectable factory\n *   is not created, and injecting the token will not work. If this decorator would not be\n *   downleveled, the `Injectable` decorator will execute immediately on file load, and\n *   Angular will generate the corresponding injectable factory.\n */\nexport function getDownlevelDecoratorsTransform(\n    typeChecker: ts.TypeChecker, host: ReflectionHost, diagnostics: ts.Diagnostic[],\n    isCore: boolean, isClosureCompilerEnabled: boolean,\n    skipClassDecorators: boolean): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    // Ensure that referenced type symbols are not elided by TypeScript. Imports for\n    // such parameter type symbols previously could be type-only, but now might be also\n    // used in the `ctorParameters` static property as a value. We want to make sure\n    // that TypeScript does not elide imports for such type references. Read more\n    // about this in the description for `loadIsReferencedAliasDeclarationPatch`.\n    const referencedParameterTypes = loadIsReferencedAliasDeclarationPatch(context);\n\n    /**\n     * Converts an EntityName (from a type annotation) to an expression (accessing a value).\n     *\n     * For a given qualified name, this walks depth first to find the leftmost identifier,\n     * and then converts the path into a property access that can be used as expression.\n     */\n    function entityNameToExpression(name: ts.EntityName): ts.Expression|undefined {\n      const symbol = typeChecker.getSymbolAtLocation(name);\n      // Check if the entity name references a symbol that is an actual value. If it is not, it\n      // cannot be referenced by an expression, so return undefined.\n      if (!symbol || !symbolIsRuntimeValue(typeChecker, symbol) || !symbol.declarations ||\n          symbol.declarations.length === 0) {\n        return undefined;\n      }\n      // If we deal with a qualified name, build up a property access expression\n      // that could be used in the JavaScript output.\n      if (ts.isQualifiedName(name)) {\n        const containerExpr = entityNameToExpression(name.left);\n        if (containerExpr === undefined) {\n          return undefined;\n        }\n        return ts.createPropertyAccess(containerExpr, name.right);\n      }\n      const decl = symbol.declarations[0];\n      // If the given entity name has been resolved to an alias import declaration,\n      // ensure that the alias declaration is not elided by TypeScript, and use its\n      // name identifier to reference it at runtime.\n      if (isAliasImportDeclaration(decl)) {\n        referencedParameterTypes.add(decl);\n        // If the entity name resolves to an alias import declaration, we reference the\n        // entity based on the alias import name. This ensures that TypeScript properly\n        // resolves the link to the import. Cloning the original entity name identifier\n        // could lead to an incorrect resolution at local scope. e.g. Consider the following\n        // snippet: `constructor(Dep: Dep) {}`. In such a case, the local `Dep` identifier\n        // would resolve to the actual parameter name, and not to the desired import.\n        // This happens because the entity name identifier symbol is internally considered\n        // as type-only and therefore TypeScript tries to resolve it as value manually.\n        // We can help TypeScript and avoid this non-reliable resolution by using an identifier\n        // that is not type-only and is directly linked to the import alias declaration.\n        if (decl.name !== undefined) {\n          return ts.getMutableClone(decl.name);\n        }\n      }\n      // Clone the original entity name identifier so that it can be used to reference\n      // its value at runtime. This is used when the identifier is resolving to a file\n      // local declaration (otherwise it would resolve to an alias import declaration).\n      return ts.getMutableClone(name);\n    }\n\n    /**\n     * Transforms a class element. Returns a three tuple of name, transformed element, and\n     * decorators found. Returns an undefined name if there are no decorators to lower on the\n     * element, or the element has an exotic name.\n     */\n    function transformClassElement(element: ts.ClassElement):\n        [string|undefined, ts.ClassElement, ts.Decorator[]] {\n      element = ts.visitEachChild(element, decoratorDownlevelVisitor, context);\n      const decoratorsToKeep: ts.Decorator[] = [];\n      const toLower: ts.Decorator[] = [];\n      const decorators = host.getDecoratorsOfDeclaration(element) || [];\n      for (const decorator of decorators) {\n        // We only deal with concrete nodes in TypeScript sources, so we don't\n        // need to handle synthetically created decorators.\n        const decoratorNode = decorator.node! as ts.Decorator;\n        if (!isAngularDecorator(decorator, isCore)) {\n          decoratorsToKeep.push(decoratorNode);\n          continue;\n        }\n        toLower.push(decoratorNode);\n      }\n      if (!toLower.length) return [undefined, element, []];\n\n      if (!element.name || !ts.isIdentifier(element.name)) {\n        // Method has a weird name, e.g.\n        //   [Symbol.foo]() {...}\n        diagnostics.push({\n          file: element.getSourceFile(),\n          start: element.getStart(),\n          length: element.getEnd() - element.getStart(),\n          messageText: `Cannot process decorators for class element with non-analyzable name.`,\n          category: ts.DiagnosticCategory.Error,\n          code: 0,\n        });\n        return [undefined, element, []];\n      }\n\n      const name = (element.name as ts.Identifier).text;\n      const mutable = ts.getMutableClone(element);\n      (mutable as any).decorators = decoratorsToKeep.length ?\n          ts.setTextRange(ts.createNodeArray(decoratorsToKeep), mutable.decorators) :\n          undefined;\n      return [name, mutable, toLower];\n    }\n\n    /**\n     * Transforms a constructor. Returns the transformed constructor and the list of parameter\n     * information collected, consisting of decorators and optional type.\n     */\n    function transformConstructor(ctor: ts.ConstructorDeclaration):\n        [ts.ConstructorDeclaration, ParameterDecorationInfo[]] {\n      ctor = ts.visitEachChild(ctor, decoratorDownlevelVisitor, context);\n\n      const newParameters: ts.ParameterDeclaration[] = [];\n      const oldParameters =\n          ts.visitParameterList(ctor.parameters, decoratorDownlevelVisitor, context);\n      const parametersInfo: ParameterDecorationInfo[] = [];\n      for (const param of oldParameters) {\n        const decoratorsToKeep: ts.Decorator[] = [];\n        const paramInfo: ParameterDecorationInfo = {decorators: [], type: null};\n        const decorators = host.getDecoratorsOfDeclaration(param) || [];\n\n        for (const decorator of decorators) {\n          // We only deal with concrete nodes in TypeScript sources, so we don't\n          // need to handle synthetically created decorators.\n          const decoratorNode = decorator.node! as ts.Decorator;\n          if (!isAngularDecorator(decorator, isCore)) {\n            decoratorsToKeep.push(decoratorNode);\n            continue;\n          }\n          paramInfo!.decorators.push(decoratorNode);\n        }\n        if (param.type) {\n          // param has a type provided, e.g. \"foo: Bar\".\n          // The type will be emitted as a value expression in entityNameToExpression, which takes\n          // care not to emit anything for types that cannot be expressed as a value (e.g.\n          // interfaces).\n          paramInfo!.type = param.type;\n        }\n        parametersInfo.push(paramInfo);\n        const newParam = ts.updateParameter(\n            param,\n            // Must pass 'undefined' to avoid emitting decorator metadata.\n            decoratorsToKeep.length ? decoratorsToKeep : undefined, param.modifiers,\n            param.dotDotDotToken, param.name, param.questionToken, param.type, param.initializer);\n        newParameters.push(newParam);\n      }\n      const updated = ts.updateConstructor(\n          ctor, ctor.decorators, ctor.modifiers, newParameters,\n          ts.visitFunctionBody(ctor.body, decoratorDownlevelVisitor, context));\n      return [updated, parametersInfo];\n    }\n\n    /**\n     * Transforms a single class declaration:\n     * - dispatches to strip decorators on members\n     * - converts decorators on the class to annotations\n     * - creates a ctorParameters property\n     * - creates a propDecorators property\n     */\n    function transformClassDeclaration(classDecl: ts.ClassDeclaration): ts.ClassDeclaration {\n      classDecl = ts.getMutableClone(classDecl);\n\n      const newMembers: ts.ClassElement[] = [];\n      const decoratedProperties = new Map<string, ts.Decorator[]>();\n      let classParameters: ParameterDecorationInfo[]|null = null;\n\n      for (const member of classDecl.members) {\n        switch (member.kind) {\n          case ts.SyntaxKind.PropertyDeclaration:\n          case ts.SyntaxKind.GetAccessor:\n          case ts.SyntaxKind.SetAccessor:\n          case ts.SyntaxKind.MethodDeclaration: {\n            const [name, newMember, decorators] = transformClassElement(member);\n            newMembers.push(newMember);\n            if (name) decoratedProperties.set(name, decorators);\n            continue;\n          }\n          case ts.SyntaxKind.Constructor: {\n            const ctor = member as ts.ConstructorDeclaration;\n            if (!ctor.body) break;\n            const [newMember, parametersInfo] =\n                transformConstructor(member as ts.ConstructorDeclaration);\n            classParameters = parametersInfo;\n            newMembers.push(newMember);\n            continue;\n          }\n          default:\n            break;\n        }\n        newMembers.push(ts.visitEachChild(member, decoratorDownlevelVisitor, context));\n      }\n\n      // The `ReflectionHost.getDecoratorsOfDeclaration()` method will not return certain kinds of\n      // decorators that will never be Angular decorators. So we cannot rely on it to capture all\n      // the decorators that should be kept. Instead we start off with a set of the raw decorators\n      // on the class, and only remove the ones that have been identified for downleveling.\n      const decoratorsToKeep = new Set<ts.Decorator>(classDecl.decorators);\n      const possibleAngularDecorators = host.getDecoratorsOfDeclaration(classDecl) || [];\n\n      let hasAngularDecorator = false;\n      const decoratorsToLower = [];\n      for (const decorator of possibleAngularDecorators) {\n        // We only deal with concrete nodes in TypeScript sources, so we don't\n        // need to handle synthetically created decorators.\n        const decoratorNode = decorator.node! as ts.Decorator;\n        const isNgDecorator = isAngularDecorator(decorator, isCore);\n\n        // Keep track if we come across an Angular class decorator. This is used\n        // for to determine whether constructor parameters should be captured or not.\n        if (isNgDecorator) {\n          hasAngularDecorator = true;\n        }\n\n        if (isNgDecorator && !skipClassDecorators) {\n          decoratorsToLower.push(extractMetadataFromSingleDecorator(decoratorNode, diagnostics));\n          decoratorsToKeep.delete(decoratorNode);\n        }\n      }\n\n      if (decoratorsToLower.length) {\n        newMembers.push(createDecoratorClassProperty(decoratorsToLower));\n      }\n      if (classParameters) {\n        if (hasAngularDecorator || classParameters.some(p => !!p.decorators.length)) {\n          // Capture constructor parameters if the class has Angular decorator applied,\n          // or if any of the parameters has decorators applied directly.\n          newMembers.push(createCtorParametersClassProperty(\n              diagnostics, entityNameToExpression, classParameters, isClosureCompilerEnabled));\n        }\n      }\n      if (decoratedProperties.size) {\n        newMembers.push(createPropDecoratorsClassProperty(diagnostics, decoratedProperties));\n      }\n\n      const members = ts.setTextRange(\n          ts.createNodeArray(newMembers, classDecl.members.hasTrailingComma), classDecl.members);\n\n      return ts.updateClassDeclaration(\n          classDecl, decoratorsToKeep.size ? Array.from(decoratorsToKeep) : undefined,\n          classDecl.modifiers, classDecl.name, classDecl.typeParameters, classDecl.heritageClauses,\n          members);\n    }\n\n    /**\n     * Transformer visitor that looks for Angular decorators and replaces them with\n     * downleveled static properties. Also collects constructor type metadata for\n     * class declaration that are decorated with an Angular decorator.\n     */\n    function decoratorDownlevelVisitor(node: ts.Node): ts.Node {\n      if (ts.isClassDeclaration(node)) {\n        return transformClassDeclaration(node);\n      }\n      return ts.visitEachChild(node, decoratorDownlevelVisitor, context);\n    }\n\n    return (sf: ts.SourceFile) => {\n      // Downlevel decorators and constructor parameter types. We will keep track of all\n      // referenced constructor parameter types so that we can instruct TypeScript to\n      // not elide their imports if they previously were only type-only.\n      return ts.visitEachChild(sf, decoratorDownlevelVisitor, context);\n    };\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}