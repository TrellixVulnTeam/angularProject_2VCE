{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/output/abstract_emitter\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/output/source_map\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.escapeIdentifier = exports.AbstractEmitterVisitor = exports.EmitterVisitorContext = exports.CATCH_STACK_VAR = exports.CATCH_ERROR_VAR = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var source_map_1 = require(\"@angular/compiler/src/output/source_map\");\n\n  var _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\n  var _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\n  var _INDENT_WITH = '  ';\n  exports.CATCH_ERROR_VAR = o.variable('error', null, null);\n  exports.CATCH_STACK_VAR = o.variable('stack', null, null);\n\n  var _EmittedLine =\n  /** @class */\n  function () {\n    function _EmittedLine(indent) {\n      this.indent = indent;\n      this.partsLength = 0;\n      this.parts = [];\n      this.srcSpans = [];\n    }\n\n    return _EmittedLine;\n  }();\n\n  var EmitterVisitorContext =\n  /** @class */\n  function () {\n    function EmitterVisitorContext(_indent) {\n      this._indent = _indent;\n      this._classes = [];\n      this._preambleLineCount = 0;\n      this._lines = [new _EmittedLine(_indent)];\n    }\n\n    EmitterVisitorContext.createRoot = function () {\n      return new EmitterVisitorContext(0);\n    };\n\n    Object.defineProperty(EmitterVisitorContext.prototype, \"_currentLine\", {\n      /**\n       * @internal strip this from published d.ts files due to\n       * https://github.com/microsoft/TypeScript/issues/36216\n       */\n      get: function get() {\n        return this._lines[this._lines.length - 1];\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    EmitterVisitorContext.prototype.println = function (from, lastPart) {\n      if (lastPart === void 0) {\n        lastPart = '';\n      }\n\n      this.print(from || null, lastPart, true);\n    };\n\n    EmitterVisitorContext.prototype.lineIsEmpty = function () {\n      return this._currentLine.parts.length === 0;\n    };\n\n    EmitterVisitorContext.prototype.lineLength = function () {\n      return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    };\n\n    EmitterVisitorContext.prototype.print = function (from, part, newLine) {\n      if (newLine === void 0) {\n        newLine = false;\n      }\n\n      if (part.length > 0) {\n        this._currentLine.parts.push(part);\n\n        this._currentLine.partsLength += part.length;\n\n        this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n      }\n\n      if (newLine) {\n        this._lines.push(new _EmittedLine(this._indent));\n      }\n    };\n\n    EmitterVisitorContext.prototype.removeEmptyLastLine = function () {\n      if (this.lineIsEmpty()) {\n        this._lines.pop();\n      }\n    };\n\n    EmitterVisitorContext.prototype.incIndent = function () {\n      this._indent++;\n\n      if (this.lineIsEmpty()) {\n        this._currentLine.indent = this._indent;\n      }\n    };\n\n    EmitterVisitorContext.prototype.decIndent = function () {\n      this._indent--;\n\n      if (this.lineIsEmpty()) {\n        this._currentLine.indent = this._indent;\n      }\n    };\n\n    EmitterVisitorContext.prototype.pushClass = function (clazz) {\n      this._classes.push(clazz);\n    };\n\n    EmitterVisitorContext.prototype.popClass = function () {\n      return this._classes.pop();\n    };\n\n    Object.defineProperty(EmitterVisitorContext.prototype, \"currentClass\", {\n      get: function get() {\n        return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    EmitterVisitorContext.prototype.toSource = function () {\n      return this.sourceLines.map(function (l) {\n        return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '';\n      }).join('\\n');\n    };\n\n    EmitterVisitorContext.prototype.toSourceMapGenerator = function (genFilePath, startsAtLine) {\n      if (startsAtLine === void 0) {\n        startsAtLine = 0;\n      }\n\n      var map = new source_map_1.SourceMapGenerator(genFilePath);\n      var firstOffsetMapped = false;\n\n      var mapFirstOffsetIfNeeded = function mapFirstOffsetIfNeeded() {\n        if (!firstOffsetMapped) {\n          // Add a single space so that tools won't try to load the file from disk.\n          // Note: We are using virtual urls like `ng:///`, so we have to\n          // provide a content here.\n          map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n          firstOffsetMapped = true;\n        }\n      };\n\n      for (var i = 0; i < startsAtLine; i++) {\n        map.addLine();\n        mapFirstOffsetIfNeeded();\n      }\n\n      this.sourceLines.forEach(function (line, lineIdx) {\n        map.addLine();\n        var spans = line.srcSpans;\n        var parts = line.parts;\n        var col0 = line.indent * _INDENT_WITH.length;\n        var spanIdx = 0; // skip leading parts without source spans\n\n        while (spanIdx < spans.length && !spans[spanIdx]) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n\n        if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n          firstOffsetMapped = true;\n        } else {\n          mapFirstOffsetIfNeeded();\n        }\n\n        while (spanIdx < spans.length) {\n          var span = spans[spanIdx];\n          var source = span.start.file;\n          var sourceLine = span.start.line;\n          var sourceCol = span.start.col;\n          map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);\n          col0 += parts[spanIdx].length;\n          spanIdx++; // assign parts without span or the same span to the previous segment\n\n          while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n            col0 += parts[spanIdx].length;\n            spanIdx++;\n          }\n        }\n      });\n      return map;\n    };\n\n    EmitterVisitorContext.prototype.setPreambleLineCount = function (count) {\n      return this._preambleLineCount = count;\n    };\n\n    EmitterVisitorContext.prototype.spanOf = function (line, column) {\n      var emittedLine = this._lines[line - this._preambleLineCount];\n\n      if (emittedLine) {\n        var columnsLeft = column - _createIndent(emittedLine.indent).length;\n\n        for (var partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n          var part = emittedLine.parts[partIndex];\n\n          if (part.length > columnsLeft) {\n            return emittedLine.srcSpans[partIndex];\n          }\n\n          columnsLeft -= part.length;\n        }\n      }\n\n      return null;\n    };\n\n    Object.defineProperty(EmitterVisitorContext.prototype, \"sourceLines\", {\n      /**\n       * @internal strip this from published d.ts files due to\n       * https://github.com/microsoft/TypeScript/issues/36216\n       */\n      get: function get() {\n        if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n          return this._lines.slice(0, -1);\n        }\n\n        return this._lines;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return EmitterVisitorContext;\n  }();\n\n  exports.EmitterVisitorContext = EmitterVisitorContext;\n\n  var AbstractEmitterVisitor =\n  /** @class */\n  function () {\n    function AbstractEmitterVisitor(_escapeDollarInStrings) {\n      this._escapeDollarInStrings = _escapeDollarInStrings;\n    }\n\n    AbstractEmitterVisitor.prototype.printLeadingComments = function (stmt, ctx) {\n      var e_1, _a;\n\n      if (stmt.leadingComments === undefined) {\n        return;\n      }\n\n      try {\n        for (var _b = tslib_1.__values(stmt.leadingComments), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var comment = _c.value;\n\n          if (comment instanceof o.JSDocComment) {\n            ctx.print(stmt, \"/*\" + comment.toString() + \"*/\", comment.trailingNewline);\n          } else {\n            if (comment.multiline) {\n              ctx.print(stmt, \"/* \" + comment.text + \" */\", comment.trailingNewline);\n            } else {\n              comment.text.split('\\n').forEach(function (line) {\n                ctx.println(stmt, \"// \" + line);\n              });\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    AbstractEmitterVisitor.prototype.visitExpressionStmt = function (stmt, ctx) {\n      this.printLeadingComments(stmt, ctx);\n      stmt.expr.visitExpression(this, ctx);\n      ctx.println(stmt, ';');\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitReturnStmt = function (stmt, ctx) {\n      this.printLeadingComments(stmt, ctx);\n      ctx.print(stmt, \"return \");\n      stmt.value.visitExpression(this, ctx);\n      ctx.println(stmt, ';');\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitIfStmt = function (stmt, ctx) {\n      this.printLeadingComments(stmt, ctx);\n      ctx.print(stmt, \"if (\");\n      stmt.condition.visitExpression(this, ctx);\n      ctx.print(stmt, \") {\");\n      var hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n\n      if (stmt.trueCase.length <= 1 && !hasElseCase) {\n        ctx.print(stmt, \" \");\n        this.visitAllStatements(stmt.trueCase, ctx);\n        ctx.removeEmptyLastLine();\n        ctx.print(stmt, \" \");\n      } else {\n        ctx.println();\n        ctx.incIndent();\n        this.visitAllStatements(stmt.trueCase, ctx);\n        ctx.decIndent();\n\n        if (hasElseCase) {\n          ctx.println(stmt, \"} else {\");\n          ctx.incIndent();\n          this.visitAllStatements(stmt.falseCase, ctx);\n          ctx.decIndent();\n        }\n      }\n\n      ctx.println(stmt, \"}\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitThrowStmt = function (stmt, ctx) {\n      this.printLeadingComments(stmt, ctx);\n      ctx.print(stmt, \"throw \");\n      stmt.error.visitExpression(this, ctx);\n      ctx.println(stmt, \";\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitWriteVarExpr = function (expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      ctx.print(expr, expr.name + \" = \");\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitWriteKeyExpr = function (expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      expr.receiver.visitExpression(this, ctx);\n      ctx.print(expr, \"[\");\n      expr.index.visitExpression(this, ctx);\n      ctx.print(expr, \"] = \");\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitWritePropExpr = function (expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      expr.receiver.visitExpression(this, ctx);\n      ctx.print(expr, \".\" + expr.name + \" = \");\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n      expr.receiver.visitExpression(this, ctx);\n      var name = expr.name;\n\n      if (expr.builtin != null) {\n        name = this.getBuiltinMethodName(expr.builtin);\n\n        if (name == null) {\n          // some builtins just mean to skip the call.\n          return null;\n        }\n      }\n\n      ctx.print(expr, \".\" + name + \"(\");\n      this.visitAllExpressions(expr.args, ctx, \",\");\n      ctx.print(expr, \")\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr, ctx) {\n      expr.fn.visitExpression(this, ctx);\n      ctx.print(expr, \"(\");\n      this.visitAllExpressions(expr.args, ctx, ',');\n      ctx.print(expr, \")\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitTaggedTemplateExpr = function (expr, ctx) {\n      expr.tag.visitExpression(this, ctx);\n      ctx.print(expr, '`' + expr.template.elements[0].rawText);\n\n      for (var i = 1; i < expr.template.elements.length; i++) {\n        ctx.print(expr, '${');\n        expr.template.expressions[i - 1].visitExpression(this, ctx);\n        ctx.print(expr, \"}\" + expr.template.elements[i].rawText);\n      }\n\n      ctx.print(expr, '`');\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n      throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n    };\n\n    AbstractEmitterVisitor.prototype.visitTypeofExpr = function (expr, ctx) {\n      ctx.print(expr, 'typeof ');\n      expr.expr.visitExpression(this, ctx);\n    };\n\n    AbstractEmitterVisitor.prototype.visitReadVarExpr = function (ast, ctx) {\n      var varName = ast.name;\n\n      if (ast.builtin != null) {\n        switch (ast.builtin) {\n          case o.BuiltinVar.Super:\n            varName = 'super';\n            break;\n\n          case o.BuiltinVar.This:\n            varName = 'this';\n            break;\n\n          case o.BuiltinVar.CatchError:\n            varName = exports.CATCH_ERROR_VAR.name;\n            break;\n\n          case o.BuiltinVar.CatchStack:\n            varName = exports.CATCH_STACK_VAR.name;\n            break;\n\n          default:\n            throw new Error(\"Unknown builtin variable \" + ast.builtin);\n        }\n      }\n\n      ctx.print(ast, varName);\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitInstantiateExpr = function (ast, ctx) {\n      ctx.print(ast, \"new \");\n      ast.classExpr.visitExpression(this, ctx);\n      ctx.print(ast, \"(\");\n      this.visitAllExpressions(ast.args, ctx, ',');\n      ctx.print(ast, \")\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitLiteralExpr = function (ast, ctx) {\n      var value = ast.value;\n\n      if (typeof value === 'string') {\n        ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n      } else {\n        ctx.print(ast, \"\" + value);\n      }\n\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitLocalizedString = function (ast, ctx) {\n      var head = ast.serializeI18nHead();\n      ctx.print(ast, '$localize `' + head.raw);\n\n      for (var i = 1; i < ast.messageParts.length; i++) {\n        ctx.print(ast, '${');\n        ast.expressions[i - 1].visitExpression(this, ctx);\n        ctx.print(ast, \"}\" + ast.serializeI18nTemplatePart(i).raw);\n      }\n\n      ctx.print(ast, '`');\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitConditionalExpr = function (ast, ctx) {\n      ctx.print(ast, \"(\");\n      ast.condition.visitExpression(this, ctx);\n      ctx.print(ast, '? ');\n      ast.trueCase.visitExpression(this, ctx);\n      ctx.print(ast, ': ');\n      ast.falseCase.visitExpression(this, ctx);\n      ctx.print(ast, \")\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitNotExpr = function (ast, ctx) {\n      ctx.print(ast, '!');\n      ast.condition.visitExpression(this, ctx);\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n      ast.condition.visitExpression(this, ctx);\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitUnaryOperatorExpr = function (ast, ctx) {\n      var opStr;\n\n      switch (ast.operator) {\n        case o.UnaryOperator.Plus:\n          opStr = '+';\n          break;\n\n        case o.UnaryOperator.Minus:\n          opStr = '-';\n          break;\n\n        default:\n          throw new Error(\"Unknown operator \" + ast.operator);\n      }\n\n      if (ast.parens) ctx.print(ast, \"(\");\n      ctx.print(ast, opStr);\n      ast.expr.visitExpression(this, ctx);\n      if (ast.parens) ctx.print(ast, \")\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n      var opStr;\n\n      switch (ast.operator) {\n        case o.BinaryOperator.Equals:\n          opStr = '==';\n          break;\n\n        case o.BinaryOperator.Identical:\n          opStr = '===';\n          break;\n\n        case o.BinaryOperator.NotEquals:\n          opStr = '!=';\n          break;\n\n        case o.BinaryOperator.NotIdentical:\n          opStr = '!==';\n          break;\n\n        case o.BinaryOperator.And:\n          opStr = '&&';\n          break;\n\n        case o.BinaryOperator.BitwiseAnd:\n          opStr = '&';\n          break;\n\n        case o.BinaryOperator.Or:\n          opStr = '||';\n          break;\n\n        case o.BinaryOperator.Plus:\n          opStr = '+';\n          break;\n\n        case o.BinaryOperator.Minus:\n          opStr = '-';\n          break;\n\n        case o.BinaryOperator.Divide:\n          opStr = '/';\n          break;\n\n        case o.BinaryOperator.Multiply:\n          opStr = '*';\n          break;\n\n        case o.BinaryOperator.Modulo:\n          opStr = '%';\n          break;\n\n        case o.BinaryOperator.Lower:\n          opStr = '<';\n          break;\n\n        case o.BinaryOperator.LowerEquals:\n          opStr = '<=';\n          break;\n\n        case o.BinaryOperator.Bigger:\n          opStr = '>';\n          break;\n\n        case o.BinaryOperator.BiggerEquals:\n          opStr = '>=';\n          break;\n\n        default:\n          throw new Error(\"Unknown operator \" + ast.operator);\n      }\n\n      if (ast.parens) ctx.print(ast, \"(\");\n      ast.lhs.visitExpression(this, ctx);\n      ctx.print(ast, \" \" + opStr + \" \");\n      ast.rhs.visitExpression(this, ctx);\n      if (ast.parens) ctx.print(ast, \")\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitReadPropExpr = function (ast, ctx) {\n      ast.receiver.visitExpression(this, ctx);\n      ctx.print(ast, \".\");\n      ctx.print(ast, ast.name);\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitReadKeyExpr = function (ast, ctx) {\n      ast.receiver.visitExpression(this, ctx);\n      ctx.print(ast, \"[\");\n      ast.index.visitExpression(this, ctx);\n      ctx.print(ast, \"]\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n      ctx.print(ast, \"[\");\n      this.visitAllExpressions(ast.entries, ctx, ',');\n      ctx.print(ast, \"]\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitLiteralMapExpr = function (ast, ctx) {\n      var _this = this;\n\n      ctx.print(ast, \"{\");\n      this.visitAllObjects(function (entry) {\n        ctx.print(ast, escapeIdentifier(entry.key, _this._escapeDollarInStrings, entry.quoted) + \":\");\n        entry.value.visitExpression(_this, ctx);\n      }, ast.entries, ctx, ',');\n      ctx.print(ast, \"}\");\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitCommaExpr = function (ast, ctx) {\n      ctx.print(ast, '(');\n      this.visitAllExpressions(ast.parts, ctx, ',');\n      ctx.print(ast, ')');\n      return null;\n    };\n\n    AbstractEmitterVisitor.prototype.visitAllExpressions = function (expressions, ctx, separator) {\n      var _this = this;\n\n      this.visitAllObjects(function (expr) {\n        return expr.visitExpression(_this, ctx);\n      }, expressions, ctx, separator);\n    };\n\n    AbstractEmitterVisitor.prototype.visitAllObjects = function (handler, expressions, ctx, separator) {\n      var incrementedIndent = false;\n\n      for (var i = 0; i < expressions.length; i++) {\n        if (i > 0) {\n          if (ctx.lineLength() > 80) {\n            ctx.print(null, separator, true);\n\n            if (!incrementedIndent) {\n              // continuation are marked with double indent.\n              ctx.incIndent();\n              ctx.incIndent();\n              incrementedIndent = true;\n            }\n          } else {\n            ctx.print(null, separator, false);\n          }\n        }\n\n        handler(expressions[i]);\n      }\n\n      if (incrementedIndent) {\n        // continuation are marked with double indent.\n        ctx.decIndent();\n        ctx.decIndent();\n      }\n    };\n\n    AbstractEmitterVisitor.prototype.visitAllStatements = function (statements, ctx) {\n      var _this = this;\n\n      statements.forEach(function (stmt) {\n        return stmt.visitStatement(_this, ctx);\n      });\n    };\n\n    return AbstractEmitterVisitor;\n  }();\n\n  exports.AbstractEmitterVisitor = AbstractEmitterVisitor;\n\n  function escapeIdentifier(input, escapeDollar, alwaysQuote) {\n    if (alwaysQuote === void 0) {\n      alwaysQuote = true;\n    }\n\n    if (input == null) {\n      return null;\n    }\n\n    var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n      var match = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        match[_i] = arguments[_i];\n      }\n\n      if (match[0] == '$') {\n        return escapeDollar ? '\\\\$' : '$';\n      } else if (match[0] == '\\n') {\n        return '\\\\n';\n      } else if (match[0] == '\\r') {\n        return '\\\\r';\n      } else {\n        return \"\\\\\" + match[0];\n      }\n    });\n    var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n    return requiresQuotes ? \"'\" + body + \"'\" : body;\n  }\n\n  exports.escapeIdentifier = escapeIdentifier;\n\n  function _createIndent(count) {\n    var res = '';\n\n    for (var i = 0; i < count; i++) {\n      res += _INDENT_WITH;\n    }\n\n    return res;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/output/abstract_emitter.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAGH,MAAA,CAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AAEA,MAAM,8BAA8B,GAAG,gBAAvC;AACA,MAAM,oBAAoB,GAAG,uBAA7B;AACA,MAAM,YAAY,GAAG,IAArB;AACa,EAAA,OAAA,CAAA,eAAA,GAAkB,CAAC,CAAC,QAAF,CAAW,OAAX,EAAoB,IAApB,EAA0B,IAA1B,CAAlB;AACA,EAAA,OAAA,CAAA,eAAA,GAAkB,CAAC,CAAC,QAAF,CAAW,OAAX,EAAoB,IAApB,EAA0B,IAA1B,CAAlB;;AAMb,MAAA,YAAA;AAAA;AAAA,cAAA;AAIE,aAAA,YAAA,CAAmB,MAAnB,EAAiC;AAAd,WAAA,MAAA,GAAA,MAAA;AAHnB,WAAA,WAAA,GAAc,CAAd;AACA,WAAA,KAAA,GAAkB,EAAlB;AACA,WAAA,QAAA,GAAqC,EAArC;AACqC;;AACvC,WAAA,YAAA;AAAC,GALD,EAAA;;AAOA,MAAA,qBAAA;AAAA;AAAA,cAAA;AASE,aAAA,qBAAA,CAAoB,OAApB,EAAmC;AAAf,WAAA,OAAA,GAAA,OAAA;AAHZ,WAAA,QAAA,GAA0B,EAA1B;AACA,WAAA,kBAAA,GAAqB,CAArB;AAGN,WAAK,MAAL,GAAc,CAAC,IAAI,YAAJ,CAAiB,OAAjB,CAAD,CAAd;AACD;;AAVM,IAAA,qBAAA,CAAA,UAAA,GAAP,YAAA;AACE,aAAO,IAAI,qBAAJ,CAA0B,CAA1B,CAAP;AACD,KAFM;;AAgBP,IAAA,MAAA,CAAA,cAAA,CAAY,qBAAA,CAAA,SAAZ,EAAY,cAAZ,EAAwB;AAJxB;;;AAGG;WACH,eAAA;AACE,eAAO,KAAK,MAAL,CAAY,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAjC,CAAP;AACD,OAFuB;uBAAA;;AAAA,KAAxB;;AAIA,IAAA,qBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,IAAR,EAAwD,QAAxD,EAA6E;AAArB,UAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,QAAA,GAAA,EAAA;AAAqB;;AAC3E,WAAK,KAAL,CAAW,IAAI,IAAI,IAAnB,EAAyB,QAAzB,EAAmC,IAAnC;AACD,KAFD;;AAIA,IAAA,qBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,YAAA;AACE,aAAO,KAAK,YAAL,CAAkB,KAAlB,CAAwB,MAAxB,KAAmC,CAA1C;AACD,KAFD;;AAIA,IAAA,qBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,aAAO,KAAK,YAAL,CAAkB,MAAlB,GAA2B,YAAY,CAAC,MAAxC,GAAiD,KAAK,YAAL,CAAkB,WAA1E;AACD,KAFD;;AAIA,IAAA,qBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,IAAN,EAAqD,IAArD,EAAmE,OAAnE,EAA2F;AAAxB,UAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,OAAA,GAAA,KAAA;AAAwB;;AACzF,UAAI,IAAI,CAAC,MAAL,GAAc,CAAlB,EAAqB;AACnB,aAAK,YAAL,CAAkB,KAAlB,CAAwB,IAAxB,CAA6B,IAA7B;;AACA,aAAK,YAAL,CAAkB,WAAlB,IAAiC,IAAI,CAAC,MAAtC;;AACA,aAAK,YAAL,CAAkB,QAAlB,CAA2B,IAA3B,CAAgC,IAAI,IAAI,IAAI,CAAC,UAAb,IAA2B,IAA3D;AACD;;AACD,UAAI,OAAJ,EAAa;AACX,aAAK,MAAL,CAAY,IAAZ,CAAiB,IAAI,YAAJ,CAAiB,KAAK,OAAtB,CAAjB;AACD;AACF,KATD;;AAWA,IAAA,qBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,YAAA;AACE,UAAI,KAAK,WAAL,EAAJ,EAAwB;AACtB,aAAK,MAAL,CAAY,GAAZ;AACD;AACF,KAJD;;AAMA,IAAA,qBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;AACE,WAAK,OAAL;;AACA,UAAI,KAAK,WAAL,EAAJ,EAAwB;AACtB,aAAK,YAAL,CAAkB,MAAlB,GAA2B,KAAK,OAAhC;AACD;AACF,KALD;;AAOA,IAAA,qBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,YAAA;AACE,WAAK,OAAL;;AACA,UAAI,KAAK,WAAL,EAAJ,EAAwB;AACtB,aAAK,YAAL,CAAkB,MAAlB,GAA2B,KAAK,OAAhC;AACD;AACF,KALD;;AAOA,IAAA,qBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,KAAV,EAA4B;AAC1B,WAAK,QAAL,CAAc,IAAd,CAAmB,KAAnB;AACD,KAFD;;AAIA,IAAA,qBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,aAAO,KAAK,QAAL,CAAc,GAAd,EAAP;AACD,KAFD;;AAIA,IAAA,MAAA,CAAA,cAAA,CAAI,qBAAA,CAAA,SAAJ,EAAI,cAAJ,EAAgB;WAAhB,eAAA;AACE,eAAO,KAAK,QAAL,CAAc,MAAd,GAAuB,CAAvB,GAA2B,KAAK,QAAL,CAAc,KAAK,QAAL,CAAc,MAAd,GAAuB,CAArC,CAA3B,GAAqE,IAA5E;AACD,OAFe;uBAAA;;AAAA,KAAhB;;AAIA,IAAA,qBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,aAAO,KAAK,WAAL,CACF,GADE,CACE,UAAA,CAAA,EAAC;AAAI,eAAA,CAAC,CAAC,KAAF,CAAQ,MAAR,GAAiB,CAAjB,GAAqB,aAAa,CAAC,CAAC,CAAC,MAAH,CAAb,GAA0B,CAAC,CAAC,KAAF,CAAQ,IAAR,CAAa,EAAb,CAA/C,GAAA,EAAA;AAAoE,OAD3E,EAEF,IAFE,CAEG,IAFH,CAAP;AAGD,KAJD;;AAMA,IAAA,qBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,WAArB,EAA0C,YAA1C,EAAkE;AAAxB,UAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,YAAA,GAAA,CAAA;AAAwB;;AAChE,UAAM,GAAG,GAAG,IAAI,YAAA,CAAA,kBAAJ,CAAuB,WAAvB,CAAZ;AAEA,UAAI,iBAAiB,GAAG,KAAxB;;AACA,UAAM,sBAAsB,GAAG,SAAzB,sBAAyB,GAAA;AAC7B,YAAI,CAAC,iBAAL,EAAwB;AACtB;AACA;AACA;AACA,UAAA,GAAG,CAAC,SAAJ,CAAc,WAAd,EAA2B,GAA3B,EAAgC,UAAhC,CAA2C,CAA3C,EAA8C,WAA9C,EAA2D,CAA3D,EAA8D,CAA9D;AACA,UAAA,iBAAiB,GAAG,IAApB;AACD;AACF,OARD;;AAUA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,YAApB,EAAkC,CAAC,EAAnC,EAAuC;AACrC,QAAA,GAAG,CAAC,OAAJ;AACA,QAAA,sBAAsB;AACvB;;AAED,WAAK,WAAL,CAAiB,OAAjB,CAAyB,UAAC,IAAD,EAAO,OAAP,EAAc;AACrC,QAAA,GAAG,CAAC,OAAJ;AAEA,YAAM,KAAK,GAAG,IAAI,CAAC,QAAnB;AACA,YAAM,KAAK,GAAG,IAAI,CAAC,KAAnB;AACA,YAAI,IAAI,GAAG,IAAI,CAAC,MAAL,GAAc,YAAY,CAAC,MAAtC;AACA,YAAI,OAAO,GAAG,CAAd,CANqC,CAOrC;;AACA,eAAO,OAAO,GAAG,KAAK,CAAC,MAAhB,IAA0B,CAAC,KAAK,CAAC,OAAD,CAAvC,EAAkD;AAChD,UAAA,IAAI,IAAI,KAAK,CAAC,OAAD,CAAL,CAAe,MAAvB;AACA,UAAA,OAAO;AACR;;AACD,YAAI,OAAO,GAAG,KAAK,CAAC,MAAhB,IAA0B,OAAO,KAAK,CAAtC,IAA2C,IAAI,KAAK,CAAxD,EAA2D;AACzD,UAAA,iBAAiB,GAAG,IAApB;AACD,SAFD,MAEO;AACL,UAAA,sBAAsB;AACvB;;AAED,eAAO,OAAO,GAAG,KAAK,CAAC,MAAvB,EAA+B;AAC7B,cAAM,IAAI,GAAG,KAAK,CAAC,OAAD,CAAlB;AACA,cAAM,MAAM,GAAG,IAAI,CAAC,KAAL,CAAW,IAA1B;AACA,cAAM,UAAU,GAAG,IAAI,CAAC,KAAL,CAAW,IAA9B;AACA,cAAM,SAAS,GAAG,IAAI,CAAC,KAAL,CAAW,GAA7B;AACA,UAAA,GAAG,CAAC,SAAJ,CAAc,MAAM,CAAC,GAArB,EAA0B,MAAM,CAAC,OAAjC,EACK,UADL,CACgB,IADhB,EACsB,MAAM,CAAC,GAD7B,EACkC,UADlC,EAC8C,SAD9C;AAGA,UAAA,IAAI,IAAI,KAAK,CAAC,OAAD,CAAL,CAAe,MAAvB;AACA,UAAA,OAAO,GATsB,CAW7B;;AACA,iBAAO,OAAO,GAAG,KAAK,CAAC,MAAhB,KAA2B,IAAI,KAAK,KAAK,CAAC,OAAD,CAAd,IAA2B,CAAC,KAAK,CAAC,OAAD,CAA5D,CAAP,EAA+E;AAC7E,YAAA,IAAI,IAAI,KAAK,CAAC,OAAD,CAAL,CAAe,MAAvB;AACA,YAAA,OAAO;AACR;AACF;AACF,OAnCD;AAqCA,aAAO,GAAP;AACD,KAzDD;;AA2DA,IAAA,qBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,KAArB,EAAkC;AAChC,aAAO,KAAK,kBAAL,GAA0B,KAAjC;AACD,KAFD;;AAIA,IAAA,qBAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,IAAP,EAAqB,MAArB,EAAmC;AACjC,UAAM,WAAW,GAAG,KAAK,MAAL,CAAY,IAAI,GAAG,KAAK,kBAAxB,CAApB;;AACA,UAAI,WAAJ,EAAiB;AACf,YAAI,WAAW,GAAG,MAAM,GAAG,aAAa,CAAC,WAAW,CAAC,MAAb,CAAb,CAAkC,MAA7D;;AACA,aAAK,IAAI,SAAS,GAAG,CAArB,EAAwB,SAAS,GAAG,WAAW,CAAC,KAAZ,CAAkB,MAAtD,EAA8D,SAAS,EAAvE,EAA2E;AACzE,cAAM,IAAI,GAAG,WAAW,CAAC,KAAZ,CAAkB,SAAlB,CAAb;;AACA,cAAI,IAAI,CAAC,MAAL,GAAc,WAAlB,EAA+B;AAC7B,mBAAO,WAAW,CAAC,QAAZ,CAAqB,SAArB,CAAP;AACD;;AACD,UAAA,WAAW,IAAI,IAAI,CAAC,MAApB;AACD;AACF;;AACD,aAAO,IAAP;AACD,KAbD;;AAmBA,IAAA,MAAA,CAAA,cAAA,CAAY,qBAAA,CAAA,SAAZ,EAAY,aAAZ,EAAuB;AAJvB;;;AAGG;WACH,eAAA;AACE,YAAI,KAAK,MAAL,CAAY,MAAZ,IAAsB,KAAK,MAAL,CAAY,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAjC,EAAoC,KAApC,CAA0C,MAA1C,KAAqD,CAA/E,EAAkF;AAChF,iBAAO,KAAK,MAAL,CAAY,KAAZ,CAAkB,CAAlB,EAAqB,CAAC,CAAtB,CAAP;AACD;;AACD,eAAO,KAAK,MAAZ;AACD,OALsB;uBAAA;;AAAA,KAAvB;AAMF,WAAA,qBAAA;AAAC,GA1KD,EAAA;;AAAa,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA;;AA4Kb,MAAA,sBAAA;AAAA;AAAA,cAAA;AACE,aAAA,sBAAA,CAAoB,sBAApB,EAAmD;AAA/B,WAAA,sBAAA,GAAA,sBAAA;AAAmC;;AAE7C,IAAA,sBAAA,CAAA,SAAA,CAAA,oBAAA,GAAV,UAA+B,IAA/B,EAAkD,GAAlD,EAA4E;;;AAC1E,UAAI,IAAI,CAAC,eAAL,KAAyB,SAA7B,EAAwC;AACtC;AACD;;;AACD,aAAsB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,IAAI,CAAC,eAAL,CAAA,EAAoB,EAAA,GAAA,EAAA,CAAA,IAAA,EAA1C,EAA0C,CAAA,EAAA,CAAA,IAA1C,EAA0C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA1C,EAA4C;AAAvC,cAAM,OAAO,GAAA,EAAA,CAAA,KAAb;;AACH,cAAI,OAAO,YAAY,CAAC,CAAC,YAAzB,EAAuC;AACrC,YAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,OAAK,OAAO,CAAC,QAAR,EAAL,GAAuB,IAAvC,EAA6C,OAAO,CAAC,eAArD;AACD,WAFD,MAEO;AACL,gBAAI,OAAO,CAAC,SAAZ,EAAuB;AACrB,cAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,QAAM,OAAO,CAAC,IAAd,GAAkB,KAAlC,EAAyC,OAAO,CAAC,eAAjD;AACD,aAFD,MAEO;AACL,cAAA,OAAO,CAAC,IAAR,CAAa,KAAb,CAAmB,IAAnB,EAAyB,OAAzB,CAAiC,UAAC,IAAD,EAAK;AACpC,gBAAA,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,QAAM,IAAxB;AACD,eAFD;AAGD;AACF;AACF;;;;;;;;;;;;AACF,KAjBS;;AAmBV,IAAA,sBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,IAApB,EAAiD,GAAjD,EAA2E;AACzE,WAAK,oBAAL,CAA0B,IAA1B,EAAgC,GAAhC;AACA,MAAA,IAAI,CAAC,IAAL,CAAU,eAAV,CAA0B,IAA1B,EAAgC,GAAhC;AACA,MAAA,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,GAAlB;AACA,aAAO,IAAP;AACD,KALD;;AAOA,IAAA,sBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,IAAhB,EAAyC,GAAzC,EAAmE;AACjE,WAAK,oBAAL,CAA0B,IAA1B,EAAgC,GAAhC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,SAAhB;AACA,MAAA,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,MAAA,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,GAAlB;AACA,aAAO,IAAP;AACD,KAND;;AAYA,IAAA,sBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,IAAZ,EAA4B,GAA5B,EAAsD;AACpD,WAAK,oBAAL,CAA0B,IAA1B,EAAgC,GAAhC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,MAAhB;AACA,MAAA,IAAI,CAAC,SAAL,CAAe,eAAf,CAA+B,IAA/B,EAAqC,GAArC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,KAAhB;AACA,UAAM,WAAW,GAAG,IAAI,CAAC,SAAL,IAAkB,IAAlB,IAA0B,IAAI,CAAC,SAAL,CAAe,MAAf,GAAwB,CAAtE;;AACA,UAAI,IAAI,CAAC,QAAL,CAAc,MAAd,IAAwB,CAAxB,IAA6B,CAAC,WAAlC,EAA+C;AAC7C,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,aAAK,kBAAL,CAAwB,IAAI,CAAC,QAA7B,EAAuC,GAAvC;AACA,QAAA,GAAG,CAAC,mBAAJ;AACA,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD,OALD,MAKO;AACL,QAAA,GAAG,CAAC,OAAJ;AACA,QAAA,GAAG,CAAC,SAAJ;AACA,aAAK,kBAAL,CAAwB,IAAI,CAAC,QAA7B,EAAuC,GAAvC;AACA,QAAA,GAAG,CAAC,SAAJ;;AACA,YAAI,WAAJ,EAAiB;AACf,UAAA,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,UAAlB;AACA,UAAA,GAAG,CAAC,SAAJ;AACA,eAAK,kBAAL,CAAwB,IAAI,CAAC,SAA7B,EAAwC,GAAxC;AACA,UAAA,GAAG,CAAC,SAAJ;AACD;AACF;;AACD,MAAA,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,GAAlB;AACA,aAAO,IAAP;AACD,KAzBD;;AA6BA,IAAA,sBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,IAAf,EAAkC,GAAlC,EAA4D;AAC1D,WAAK,oBAAL,CAA0B,IAA1B,EAAgC,GAAhC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,QAAhB;AACA,MAAA,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,MAAA,GAAG,CAAC,OAAJ,CAAY,IAAZ,EAAkB,GAAlB;AACA,aAAO,IAAP;AACD,KAND;;AAUA,IAAA,sBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,IAAlB,EAAwC,GAAxC,EAAkE;AAChE,UAAM,YAAY,GAAG,GAAG,CAAC,WAAJ,EAArB;;AACA,UAAI,CAAC,YAAL,EAAmB;AACjB,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;;AACD,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAmB,IAAI,CAAC,IAAL,GAAS,KAA5B;AACA,MAAA,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;;AACA,UAAI,CAAC,YAAL,EAAmB;AACjB,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;;AACD,aAAO,IAAP;AACD,KAXD;;AAYA,IAAA,sBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,IAAlB,EAAwC,GAAxC,EAAkE;AAChE,UAAM,YAAY,GAAG,GAAG,CAAC,WAAJ,EAArB;;AACA,UAAI,CAAC,YAAL,EAAmB;AACjB,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;;AACD,MAAA,IAAI,CAAC,QAAL,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,MAAA,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,MAAhB;AACA,MAAA,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;;AACA,UAAI,CAAC,YAAL,EAAmB;AACjB,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;;AACD,aAAO,IAAP;AACD,KAdD;;AAeA,IAAA,sBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,IAAnB,EAA0C,GAA1C,EAAoE;AAClE,UAAM,YAAY,GAAG,GAAG,CAAC,WAAJ,EAArB;;AACA,UAAI,CAAC,YAAL,EAAmB;AACjB,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;;AACD,MAAA,IAAI,CAAC,QAAL,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,MAAI,IAAI,CAAC,IAAT,GAAa,KAA7B;AACA,MAAA,IAAI,CAAC,KAAL,CAAW,eAAX,CAA2B,IAA3B,EAAiC,GAAjC;;AACA,UAAI,CAAC,YAAL,EAAmB;AACjB,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACD;;AACD,aAAO,IAAP;AACD,KAZD;;AAaA,IAAA,sBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,IAAtB,EAAgD,GAAhD,EAA0E;AACxE,MAAA,IAAI,CAAC,QAAL,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,UAAI,IAAI,GAAG,IAAI,CAAC,IAAhB;;AACA,UAAI,IAAI,CAAC,OAAL,IAAgB,IAApB,EAA0B;AACxB,QAAA,IAAI,GAAG,KAAK,oBAAL,CAA0B,IAAI,CAAC,OAA/B,CAAP;;AACA,YAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB;AACA,iBAAO,IAAP;AACD;AACF;;AACD,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,MAAI,IAAJ,GAAQ,GAAxB;AACA,WAAK,mBAAL,CAAyB,IAAI,CAAC,IAA9B,EAAoC,GAApC,EAAyC,GAAzC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,aAAO,IAAP;AACD,KAdD;;AAkBA,IAAA,sBAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UAAwB,IAAxB,EAAoD,GAApD,EAA8E;AAC5E,MAAA,IAAI,CAAC,EAAL,CAAQ,eAAR,CAAwB,IAAxB,EAA8B,GAA9B;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,WAAK,mBAAL,CAAyB,IAAI,CAAC,IAA9B,EAAoC,GAApC,EAAyC,GAAzC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,aAAO,IAAP;AACD,KAND;;AAOA,IAAA,sBAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UAAwB,IAAxB,EAAoD,GAApD,EAA8E;AAC5E,MAAA,IAAI,CAAC,GAAL,CAAS,eAAT,CAAyB,IAAzB,EAA+B,GAA/B;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,MAAM,IAAI,CAAC,QAAL,CAAc,QAAd,CAAuB,CAAvB,EAA0B,OAAhD;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,QAAL,CAAc,QAAd,CAAuB,MAA3C,EAAmD,CAAC,EAApD,EAAwD;AACtD,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,IAAhB;AACA,QAAA,IAAI,CAAC,QAAL,CAAc,WAAd,CAA0B,CAAC,GAAG,CAA9B,EAAiC,eAAjC,CAAiD,IAAjD,EAAuD,GAAvD;AACA,QAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,MAAI,IAAI,CAAC,QAAL,CAAc,QAAd,CAAuB,CAAvB,EAA0B,OAA9C;AACD;;AACD,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,GAAhB;AACA,aAAO,IAAP;AACD,KAVD;;AAWA,IAAA,sBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,GAArB,EAAkD,GAAlD,EAA4E;AAC1E,YAAM,IAAI,KAAJ,CAAU,gDAAV,CAAN;AACD,KAFD;;AAGA,IAAA,sBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UAAgB,IAAhB,EAAoC,GAApC,EAA8D;AAC5D,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,SAAhB;AACA,MAAA,IAAI,CAAC,IAAL,CAAU,eAAV,CAA0B,IAA1B,EAAgC,GAAhC;AACD,KAHD;;AAIA,IAAA,sBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,GAAjB,EAAqC,GAArC,EAA+D;AAC7D,UAAI,OAAO,GAAG,GAAG,CAAC,IAAlB;;AACA,UAAI,GAAG,CAAC,OAAJ,IAAe,IAAnB,EAAyB;AACvB,gBAAQ,GAAG,CAAC,OAAZ;AACE,eAAK,CAAC,CAAC,UAAF,CAAa,KAAlB;AACE,YAAA,OAAO,GAAG,OAAV;AACA;;AACF,eAAK,CAAC,CAAC,UAAF,CAAa,IAAlB;AACE,YAAA,OAAO,GAAG,MAAV;AACA;;AACF,eAAK,CAAC,CAAC,UAAF,CAAa,UAAlB;AACE,YAAA,OAAO,GAAG,OAAA,CAAA,eAAA,CAAgB,IAA1B;AACA;;AACF,eAAK,CAAC,CAAC,UAAF,CAAa,UAAlB;AACE,YAAA,OAAO,GAAG,OAAA,CAAA,eAAA,CAAgB,IAA1B;AACA;;AACF;AACE,kBAAM,IAAI,KAAJ,CAAU,8BAA4B,GAAG,CAAC,OAA1C,CAAN;AAdJ;AAgBD;;AACD,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,OAAf;AACA,aAAO,IAAP;AACD,KAtBD;;AAuBA,IAAA,sBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,GAArB,EAA6C,GAA7C,EAAuE;AACrE,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,MAAf;AACA,MAAA,GAAG,CAAC,SAAJ,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,WAAK,mBAAL,CAAyB,GAAG,CAAC,IAA7B,EAAmC,GAAnC,EAAwC,GAAxC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,aAAO,IAAP;AACD,KAPD;;AASA,IAAA,sBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,GAAjB,EAAqC,GAArC,EAA+D;AAC7D,UAAM,KAAK,GAAG,GAAG,CAAC,KAAlB;;AACA,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,QAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,gBAAgB,CAAC,KAAD,EAAQ,KAAK,sBAAb,CAA/B;AACD,OAFD,MAEO;AACL,QAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,KAAG,KAAlB;AACD;;AACD,aAAO,IAAP;AACD,KARD;;AAUA,IAAA,sBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,GAArB,EAA6C,GAA7C,EAAuE;AACrE,UAAM,IAAI,GAAG,GAAG,CAAC,iBAAJ,EAAb;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,gBAAgB,IAAI,CAAC,GAApC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,YAAJ,CAAiB,MAArC,EAA6C,CAAC,EAA9C,EAAkD;AAChD,QAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,IAAf;AACA,QAAA,GAAG,CAAC,WAAJ,CAAgB,CAAC,GAAG,CAApB,EAAuB,eAAvB,CAAuC,IAAvC,EAA6C,GAA7C;AACA,QAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,MAAI,GAAG,CAAC,yBAAJ,CAA8B,CAA9B,EAAiC,GAApD;AACD;;AACD,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,aAAO,IAAP;AACD,KAVD;;AAcA,IAAA,sBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,GAArB,EAA6C,GAA7C,EAAuE;AACrE,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,MAAA,GAAG,CAAC,SAAJ,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,IAAf;AACA,MAAA,GAAG,CAAC,QAAJ,CAAa,eAAb,CAA6B,IAA7B,EAAmC,GAAnC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,IAAf;AACA,MAAA,GAAG,CAAC,SAAJ,CAAe,eAAf,CAA+B,IAA/B,EAAqC,GAArC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,aAAO,IAAP;AACD,KATD;;AAUA,IAAA,sBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,GAAb,EAA6B,GAA7B,EAAuD;AACrD,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,MAAA,GAAG,CAAC,SAAJ,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,aAAO,IAAP;AACD,KAJD;;AAKA,IAAA,sBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,GAAvB,EAA6C,GAA7C,EAAuE;AACrE,MAAA,GAAG,CAAC,SAAJ,CAAc,eAAd,CAA8B,IAA9B,EAAoC,GAApC;AACA,aAAO,IAAP;AACD,KAHD;;AAOA,IAAA,sBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,GAAvB,EAAiD,GAAjD,EAA2E;AACzE,UAAI,KAAJ;;AACA,cAAQ,GAAG,CAAC,QAAZ;AACE,aAAK,CAAC,CAAC,aAAF,CAAgB,IAArB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,aAAF,CAAgB,KAArB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF;AACE,gBAAM,IAAI,KAAJ,CAAU,sBAAoB,GAAG,CAAC,QAAlC,CAAN;AARJ;;AAUA,UAAI,GAAG,CAAC,MAAR,EAAgB,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AAChB,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,KAAf;AACA,MAAA,GAAG,CAAC,IAAJ,CAAS,eAAT,CAAyB,IAAzB,EAA+B,GAA/B;AACA,UAAI,GAAG,CAAC,MAAR,EAAgB,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AAChB,aAAO,IAAP;AACD,KAjBD;;AAmBA,IAAA,sBAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UAAwB,GAAxB,EAAmD,GAAnD,EAA6E;AAC3E,UAAI,KAAJ;;AACA,cAAQ,GAAG,CAAC,QAAZ;AACE,aAAK,CAAC,CAAC,cAAF,CAAiB,MAAtB;AACE,UAAA,KAAK,GAAG,IAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,SAAtB;AACE,UAAA,KAAK,GAAG,KAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,SAAtB;AACE,UAAA,KAAK,GAAG,IAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,YAAtB;AACE,UAAA,KAAK,GAAG,KAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,GAAtB;AACE,UAAA,KAAK,GAAG,IAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,UAAtB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,EAAtB;AACE,UAAA,KAAK,GAAG,IAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,IAAtB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,KAAtB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,MAAtB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,QAAtB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,MAAtB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,KAAtB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,WAAtB;AACE,UAAA,KAAK,GAAG,IAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,MAAtB;AACE,UAAA,KAAK,GAAG,GAAR;AACA;;AACF,aAAK,CAAC,CAAC,cAAF,CAAiB,YAAtB;AACE,UAAA,KAAK,GAAG,IAAR;AACA;;AACF;AACE,gBAAM,IAAI,KAAJ,CAAU,sBAAoB,GAAG,CAAC,QAAlC,CAAN;AAlDJ;;AAoDA,UAAI,GAAG,CAAC,MAAR,EAAgB,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AAChB,MAAA,GAAG,CAAC,GAAJ,CAAQ,eAAR,CAAwB,IAAxB,EAA8B,GAA9B;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,MAAI,KAAJ,GAAS,GAAxB;AACA,MAAA,GAAG,CAAC,GAAJ,CAAQ,eAAR,CAAwB,IAAxB,EAA8B,GAA9B;AACA,UAAI,GAAG,CAAC,MAAR,EAAgB,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AAChB,aAAO,IAAP;AACD,KA5DD;;AA8DA,IAAA,sBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,GAAlB,EAAuC,GAAvC,EAAiE;AAC/D,MAAA,GAAG,CAAC,QAAJ,CAAa,eAAb,CAA6B,IAA7B,EAAmC,GAAnC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAG,CAAC,IAAnB;AACA,aAAO,IAAP;AACD,KALD;;AAMA,IAAA,sBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,GAAjB,EAAqC,GAArC,EAA+D;AAC7D,MAAA,GAAG,CAAC,QAAJ,CAAa,eAAb,CAA6B,IAA7B,EAAmC,GAAnC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,eAAV,CAA0B,IAA1B,EAAgC,GAAhC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,aAAO,IAAP;AACD,KAND;;AAOA,IAAA,sBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,GAAtB,EAA+C,GAA/C,EAAyE;AACvE,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,WAAK,mBAAL,CAAyB,GAAG,CAAC,OAA7B,EAAsC,GAAtC,EAA2C,GAA3C;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,aAAO,IAAP;AACD,KALD;;AAMA,IAAA,sBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,GAApB,EAA2C,GAA3C,EAAqE;AAArE,UAAA,KAAA,GAAA,IAAA;;AACE,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,WAAK,eAAL,CAAqB,UAAA,KAAA,EAAK;AACxB,QAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAkB,gBAAgB,CAAC,KAAK,CAAC,GAAP,EAAY,KAAI,CAAC,sBAAjB,EAAyC,KAAK,CAAC,MAA/C,CAAhB,GAAsE,GAAxF;AACA,QAAA,KAAK,CAAC,KAAN,CAAY,eAAZ,CAA4B,KAA5B,EAAkC,GAAlC;AACD,OAHD,EAGG,GAAG,CAAC,OAHP,EAGgB,GAHhB,EAGqB,GAHrB;AAIA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,aAAO,IAAP;AACD,KARD;;AASA,IAAA,sBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAAiC,GAAjC,EAA2D;AACzD,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,WAAK,mBAAL,CAAyB,GAAG,CAAC,KAA7B,EAAoC,GAApC,EAAyC,GAAzC;AACA,MAAA,GAAG,CAAC,KAAJ,CAAU,GAAV,EAAe,GAAf;AACA,aAAO,IAAP;AACD,KALD;;AAMA,IAAA,sBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,WAApB,EAAiD,GAAjD,EAA6E,SAA7E,EAA8F;AAA9F,UAAA,KAAA,GAAA,IAAA;;AAEE,WAAK,eAAL,CAAqB,UAAA,IAAA,EAAI;AAAI,eAAA,IAAI,CAAC,eAAL,CAAqB,KAArB,EAAA,GAAA,CAAA;AAA+B,OAA5D,EAA8D,WAA9D,EAA2E,GAA3E,EAAgF,SAAhF;AACD,KAHD;;AAKA,IAAA,sBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,UACI,OADJ,EAC6B,WAD7B,EAC+C,GAD/C,EAEI,SAFJ,EAEqB;AACnB,UAAI,iBAAiB,GAAG,KAAxB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,EAAzC,EAA6C;AAC3C,YAAI,CAAC,GAAG,CAAR,EAAW;AACT,cAAI,GAAG,CAAC,UAAJ,KAAmB,EAAvB,EAA2B;AACzB,YAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,SAAhB,EAA2B,IAA3B;;AACA,gBAAI,CAAC,iBAAL,EAAwB;AACtB;AACA,cAAA,GAAG,CAAC,SAAJ;AACA,cAAA,GAAG,CAAC,SAAJ;AACA,cAAA,iBAAiB,GAAG,IAApB;AACD;AACF,WARD,MAQO;AACL,YAAA,GAAG,CAAC,KAAJ,CAAU,IAAV,EAAgB,SAAhB,EAA2B,KAA3B;AACD;AACF;;AACD,QAAA,OAAO,CAAC,WAAW,CAAC,CAAD,CAAZ,CAAP;AACD;;AACD,UAAI,iBAAJ,EAAuB;AACrB;AACA,QAAA,GAAG,CAAC,SAAJ;AACA,QAAA,GAAG,CAAC,SAAJ;AACD;AACF,KAzBD;;AA2BA,IAAA,sBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,UAAnB,EAA8C,GAA9C,EAAwE;AAAxE,UAAA,KAAA,GAAA,IAAA;;AACE,MAAA,UAAU,CAAC,OAAX,CAAmB,UAAC,IAAD,EAAK;AAAK,eAAA,IAAI,CAAC,cAAL,CAAoB,KAApB,EAAA,GAAA,CAAA;AAA8B,OAA3D;AACD,KAFD;;AAGF,WAAA,sBAAA;AAAC,GAvYD,EAAA;;AAAsB,EAAA,OAAA,CAAA,sBAAA,GAAA,sBAAA;;AAyYtB,WAAgB,gBAAhB,CACI,KADJ,EACmB,YADnB,EAC0C,WAD1C,EACqE;AAA3B,QAAA,WAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,WAAA,GAAA,IAAA;AAA2B;;AACnE,QAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,aAAO,IAAP;AACD;;AACD,QAAM,IAAI,GAAG,KAAK,CAAC,OAAN,CAAc,8BAAd,EAA8C,YAAA;AAAC,UAAA,KAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAkB;AAAlB,QAAA,KAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AAC1D,UAAI,KAAK,CAAC,CAAD,CAAL,IAAY,GAAhB,EAAqB;AACnB,eAAO,YAAY,GAAG,KAAH,GAAW,GAA9B;AACD,OAFD,MAEO,IAAI,KAAK,CAAC,CAAD,CAAL,IAAY,IAAhB,EAAsB;AAC3B,eAAO,KAAP;AACD,OAFM,MAEA,IAAI,KAAK,CAAC,CAAD,CAAL,IAAY,IAAhB,EAAsB;AAC3B,eAAO,KAAP;AACD,OAFM,MAEA;AACL,eAAO,OAAK,KAAK,CAAC,CAAD,CAAjB;AACD;AACF,KAVY,CAAb;AAWA,QAAM,cAAc,GAAG,WAAW,IAAI,CAAC,oBAAoB,CAAC,IAArB,CAA0B,IAA1B,CAAvC;AACA,WAAO,cAAc,GAAG,MAAI,IAAJ,GAAQ,GAAX,GAAiB,IAAtC;AACD;;AAlBD,EAAA,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAoBA,WAAS,aAAT,CAAuB,KAAvB,EAAoC;AAClC,QAAI,GAAG,GAAG,EAAV;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAApB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,MAAA,GAAG,IAAI,YAAP;AACD;;AACD,WAAO,GAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nexport const CATCH_ERROR_VAR = o.variable('error', null, null);\nexport const CATCH_STACK_VAR = o.variable('stack', null, null);\n\nexport interface OutputEmitter {\n  emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string|null): string;\n}\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext {\n    return new EmitterVisitorContext(0);\n  }\n\n  private _lines: _EmittedLine[];\n  private _classes: o.ClassStmt[] = [];\n  private _preambleLineCount = 0;\n\n  constructor(private _indent: number) {\n    this._lines = [new _EmittedLine(_indent)];\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get _currentLine(): _EmittedLine {\n    return this._lines[this._lines.length - 1];\n  }\n\n  println(from?: {sourceSpan: ParseSourceSpan|null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean {\n    return this._currentLine.parts.length === 0;\n  }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan|null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  pushClass(clazz: o.ClassStmt) {\n    this._classes.push(clazz);\n  }\n\n  popClass(): o.ClassStmt {\n    return this._classes.pop()!;\n  }\n\n  get currentClass(): o.ClassStmt|null {\n    return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx]!;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  setPreambleLineCount(count: number) {\n    return this._preambleLineCount = count;\n  }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line - this._preambleLineCount];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  protected printLeadingComments(stmt: o.Statement, ctx: EmitterVisitorContext): void {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof o.JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach((line) => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  abstract visitCastExpr(ast: o.CastExpr, context: any): any;\n\n  abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\n\n  visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `throw `);\n    stmt.error.visitExpression(this, ctx);\n    ctx.println(stmt, `;`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any {\n    expr.receiver.visitExpression(this, ctx);\n    let name = expr.name;\n    if (expr.builtin != null) {\n      name = this.getBuiltinMethodName(expr.builtin);\n      if (name == null) {\n        // some builtins just mean to skip the call.\n        return null;\n      }\n    }\n    ctx.print(expr, `.${name}(`);\n    this.visitAllExpressions(expr.args, ctx, `,`);\n    ctx.print(expr, `)`);\n    return null;\n  }\n\n  abstract getBuiltinMethodName(method: o.BuiltinMethod): string;\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateExpr(expr: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    expr.tag.visitExpression(this, ctx);\n    ctx.print(expr, '`' + expr.template.elements[0].rawText);\n    for (let i = 1; i < expr.template.elements.length; i++) {\n      ctx.print(expr, '${');\n      expr.template.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(expr, `}${expr.template.elements[i].rawText}`);\n    }\n    ctx.print(expr, '`');\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    let varName = ast.name!;\n    if (ast.builtin != null) {\n      switch (ast.builtin) {\n        case o.BuiltinVar.Super:\n          varName = 'super';\n          break;\n        case o.BuiltinVar.This:\n          varName = 'this';\n          break;\n        case o.BuiltinVar.CatchError:\n          varName = CATCH_ERROR_VAR.name!;\n          break;\n        case o.BuiltinVar.CatchStack:\n          varName = CATCH_STACK_VAR.name!;\n          break;\n        default:\n          throw new Error(`Unknown builtin variable ${ast.builtin}`);\n      }\n    }\n    ctx.print(ast, varName);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase!.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any {\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}