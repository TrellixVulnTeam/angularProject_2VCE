{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readFile = readFile;\nexports.readFileSync = readFileSync;\n\nvar _fs = _interopRequireDefault(require(\"fs\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction fsReadFileAsync(_x, _x2) {\n  return _fsReadFileAsync.apply(this, arguments);\n}\n\nfunction _fsReadFileAsync() {\n  _fsReadFileAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(pathname, encoding) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n              _fs.default.readFile(pathname, encoding, function (error, contents) {\n                if (error) {\n                  reject(error);\n                  return;\n                }\n\n                resolve(contents);\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _fsReadFileAsync.apply(this, arguments);\n}\n\nfunction readFile(_x3) {\n  return _readFile.apply(this, arguments);\n}\n\nfunction _readFile() {\n  _readFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(filepath) {\n    var options,\n        throwNotFound,\n        content,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            throwNotFound = options.throwNotFound === true;\n            _context2.prev = 2;\n            _context2.next = 5;\n            return fsReadFileAsync(filepath, 'utf8');\n\n          case 5:\n            content = _context2.sent;\n            return _context2.abrupt(\"return\", content);\n\n          case 9:\n            _context2.prev = 9;\n            _context2.t0 = _context2[\"catch\"](2);\n\n            if (!(throwNotFound === false && _context2.t0.code === 'ENOENT')) {\n              _context2.next = 13;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", null);\n\n          case 13:\n            throw _context2.t0;\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[2, 9]]);\n  }));\n  return _readFile.apply(this, arguments);\n}\n\nfunction readFileSync(filepath) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var throwNotFound = options.throwNotFound === true;\n\n  try {\n    var content = _fs.default.readFileSync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && error.code === 'ENOENT') {\n      return null;\n    }\n\n    throw error;\n  }\n}","map":{"version":3,"sources":["../src/readFile.ts"],"names":["fs","reject","resolve","options","throwNotFound","content","fsReadFileAsync","error"],"mappings":";;;;;;;;;;;;AAAA,IAAA,GAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,IAAA,CAAA,CAAA;;;;;;;;SAEA,e;;;;;8EAAA,iBAAA,QAAA,EAAA,QAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6CAIS,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAA2B;AAC5CA,cAAAA,GAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,QAAAA,EAAAA,QAAAA,EAAgC,UAAA,KAAA,EAAA,QAAA,EAA2B;AACzD,oBAAA,KAAA,EAAW;AACTC,kBAAAA,MAAM,CAANA,KAAM,CAANA;AACA;AACD;;AAEDC,gBAAAA,OAAO,CAAPA,QAAO,CAAPA;AANFF,eAAAA;AADF,aAAO,CAJT;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;SAoBA,Q;;;;;uEAAA,kBAAA,QAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEEG,YAAAA,OAFF,8DAAA,EAAA;AAIQC,YAAAA,aAJR,GAIwBD,OAAO,CAAPA,aAAAA,KAAtB,IAJF;AAAA;AAAA;AAAA,mBAO0BG,eAAe,CAAA,QAAA,EAArC,MAAqC,CAPzC;;AAAA;AAOUD,YAAAA,OAPV;AAAA,8CASI,OATJ;;AAAA;AAAA;AAAA;;AAAA,kBAWQD,aAAa,KAAbA,KAAAA,IAA2BG,aAAAA,IAAAA,KAA/B,QAXJ;AAAA;AAAA;AAAA;;AAAA,8CAYM,IAZN;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAmBA,SAAA,YAAA,CAAA,QAAA,EAA8E;AAAA,MAAtCJ,OAAsC,uEAA9E,EAA8E;AAC5E,MAAMC,aAAa,GAAGD,OAAO,CAAPA,aAAAA,KAAtB,IAAA;;AAEA,MAAI;AACF,QAAME,OAAO,GAAGL,GAAAA,CAAAA,OAAAA,CAAAA,YAAAA,CAAAA,QAAAA,EAAhB,MAAgBA,CAAhB;;AAEA,WAAA,OAAA;AAHF,GAAA,CAIE,OAAA,KAAA,EAAc;AACd,QAAII,aAAa,KAAbA,KAAAA,IAA2BG,KAAK,CAALA,IAAAA,KAA/B,QAAA,EAAwD;AACtD,aAAA,IAAA;AACD;;AAED,UAAA,KAAA;AACD;AACF","sourcesContent":["import fs from 'fs';\n\nasync function fsReadFileAsync(\n  pathname: string,\n  encoding: string,\n): Promise<string> {\n  return new Promise((resolve, reject): void => {\n    fs.readFile(pathname, encoding, (error, contents): void => {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      resolve(contents);\n    });\n  });\n}\n\ninterface Options {\n  throwNotFound?: boolean;\n}\n\nasync function readFile(\n  filepath: string,\n  options: Options = {},\n): Promise<string | null> {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = await fsReadFileAsync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && error.code === 'ENOENT') {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nfunction readFileSync(filepath: string, options: Options = {}): string | null {\n  const throwNotFound = options.throwNotFound === true;\n\n  try {\n    const content = fs.readFileSync(filepath, 'utf8');\n\n    return content;\n  } catch (error) {\n    if (throwNotFound === false && error.code === 'ENOENT') {\n      return null;\n    }\n\n    throw error;\n  }\n}\n\nexport { readFile, readFileSync };\n"]},"metadata":{},"sourceType":"script"}