{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar sortByIndex = function sortByIndex(a, b) {\n  return a.index - b.index;\n};\n\nvar sortByIndex2 = function sortByIndex2(a, b) {\n  return a.index2 - b.index2;\n};\n\nvar ChunkModuleIdRangePlugin = /*#__PURE__*/function () {\n  function ChunkModuleIdRangePlugin(options) {\n    _classCallCheck(this, ChunkModuleIdRangePlugin);\n\n    this.options = options;\n  }\n\n  _createClass(ChunkModuleIdRangePlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      compiler.hooks.compilation.tap(\"ChunkModuleIdRangePlugin\", function (compilation) {\n        compilation.hooks.moduleIds.tap(\"ChunkModuleIdRangePlugin\", function (modules) {\n          var chunk = compilation.chunks.find(function (chunk) {\n            return chunk.name === options.name;\n          });\n\n          if (!chunk) {\n            throw new Error(\"ChunkModuleIdRangePlugin: Chunk with name '\".concat(options.name, \"\\\"' was not found\"));\n          }\n\n          var chunkModules;\n\n          if (options.order) {\n            chunkModules = Array.from(chunk.modulesIterable);\n\n            switch (options.order) {\n              case \"index\":\n                chunkModules.sort(sortByIndex);\n                break;\n\n              case \"index2\":\n                chunkModules.sort(sortByIndex2);\n                break;\n\n              default:\n                throw new Error(\"ChunkModuleIdRangePlugin: unexpected value of order\");\n            }\n          } else {\n            chunkModules = modules.filter(function (m) {\n              return m.chunksIterable.has(chunk);\n            });\n          }\n\n          var currentId = options.start || 0;\n\n          for (var i = 0; i < chunkModules.length; i++) {\n            var m = chunkModules[i];\n\n            if (m.id === null) {\n              m.id = currentId++;\n            }\n\n            if (options.end && currentId > options.end) break;\n          }\n        });\n      });\n    }\n  }]);\n\n  return ChunkModuleIdRangePlugin;\n}();\n\nmodule.exports = ChunkModuleIdRangePlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/optimize/ChunkModuleIdRangePlugin.js"],"names":["sortByIndex","a","b","index","sortByIndex2","index2","ChunkModuleIdRangePlugin","options","compiler","hooks","compilation","tap","moduleIds","modules","chunk","chunks","find","name","Error","chunkModules","order","Array","from","modulesIterable","sort","filter","m","chunksIterable","has","currentId","start","i","length","id","end","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;AAEA,IAAMA,WAAW,GAAG,SAAdA,WAAc,CAACC,CAAD,EAAIC,CAAJ,EAAU;AAC7B,SAAOD,CAAC,CAACE,KAAF,GAAUD,CAAC,CAACC,KAAnB;AACA,CAFD;;AAIA,IAAMC,YAAY,GAAG,SAAfA,YAAe,CAACH,CAAD,EAAIC,CAAJ,EAAU;AAC9B,SAAOD,CAAC,CAACI,MAAF,GAAWH,CAAC,CAACG,MAApB;AACA,CAFD;;IAIMC,wB;AACL,oCAAYC,OAAZ,EAAqB;AAAA;;AACpB,SAAKA,OAAL,GAAeA,OAAf;AACA;;;;WAED,eAAMC,QAAN,EAAgB;AACf,UAAMD,OAAO,GAAG,KAAKA,OAArB;AACAC,MAAAA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,0BAA/B,EAA2D,UAAAD,WAAW,EAAI;AACzEA,QAAAA,WAAW,CAACD,KAAZ,CAAkBG,SAAlB,CAA4BD,GAA5B,CAAgC,0BAAhC,EAA4D,UAAAE,OAAO,EAAI;AACtE,cAAMC,KAAK,GAAGJ,WAAW,CAACK,MAAZ,CAAmBC,IAAnB,CACb,UAAAF,KAAK;AAAA,mBAAIA,KAAK,CAACG,IAAN,KAAeV,OAAO,CAACU,IAA3B;AAAA,WADQ,CAAd;;AAGA,cAAI,CAACH,KAAL,EAAY;AACX,kBAAM,IAAII,KAAJ,sDACyCX,OAAO,CAACU,IADjD,uBAAN;AAGA;;AAED,cAAIE,YAAJ;;AACA,cAAIZ,OAAO,CAACa,KAAZ,EAAmB;AAClBD,YAAAA,YAAY,GAAGE,KAAK,CAACC,IAAN,CAAWR,KAAK,CAACS,eAAjB,CAAf;;AACA,oBAAQhB,OAAO,CAACa,KAAhB;AACC,mBAAK,OAAL;AACCD,gBAAAA,YAAY,CAACK,IAAb,CAAkBxB,WAAlB;AACA;;AACD,mBAAK,QAAL;AACCmB,gBAAAA,YAAY,CAACK,IAAb,CAAkBpB,YAAlB;AACA;;AACD;AACC,sBAAM,IAAIc,KAAJ,CACL,qDADK,CAAN;AARF;AAYA,WAdD,MAcO;AACNC,YAAAA,YAAY,GAAGN,OAAO,CAACY,MAAR,CAAe,UAAAC,CAAC,EAAI;AAClC,qBAAOA,CAAC,CAACC,cAAF,CAAiBC,GAAjB,CAAqBd,KAArB,CAAP;AACA,aAFc,CAAf;AAGA;;AAED,cAAIe,SAAS,GAAGtB,OAAO,CAACuB,KAAR,IAAiB,CAAjC;;AACA,eAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,YAAY,CAACa,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC7C,gBAAML,CAAC,GAAGP,YAAY,CAACY,CAAD,CAAtB;;AACA,gBAAIL,CAAC,CAACO,EAAF,KAAS,IAAb,EAAmB;AAClBP,cAAAA,CAAC,CAACO,EAAF,GAAOJ,SAAS,EAAhB;AACA;;AACD,gBAAItB,OAAO,CAAC2B,GAAR,IAAeL,SAAS,GAAGtB,OAAO,CAAC2B,GAAvC,EAA4C;AAC5C;AACD,SAvCD;AAwCA,OAzCD;AA0CA;;;;;;AAEFC,MAAM,CAACC,OAAP,GAAiB9B,wBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst sortByIndex = (a, b) => {\n\treturn a.index - b.index;\n};\n\nconst sortByIndex2 = (a, b) => {\n\treturn a.index2 - b.index2;\n};\n\nclass ChunkModuleIdRangePlugin {\n\tconstructor(options) {\n\t\tthis.options = options;\n\t}\n\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"ChunkModuleIdRangePlugin\", compilation => {\n\t\t\tcompilation.hooks.moduleIds.tap(\"ChunkModuleIdRangePlugin\", modules => {\n\t\t\t\tconst chunk = compilation.chunks.find(\n\t\t\t\t\tchunk => chunk.name === options.name\n\t\t\t\t);\n\t\t\t\tif (!chunk) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`ChunkModuleIdRangePlugin: Chunk with name '${options.name}\"' was not found`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet chunkModules;\n\t\t\t\tif (options.order) {\n\t\t\t\t\tchunkModules = Array.from(chunk.modulesIterable);\n\t\t\t\t\tswitch (options.order) {\n\t\t\t\t\t\tcase \"index\":\n\t\t\t\t\t\t\tchunkModules.sort(sortByIndex);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"index2\":\n\t\t\t\t\t\t\tchunkModules.sort(sortByIndex2);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\"ChunkModuleIdRangePlugin: unexpected value of order\"\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tchunkModules = modules.filter(m => {\n\t\t\t\t\t\treturn m.chunksIterable.has(chunk);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tlet currentId = options.start || 0;\n\t\t\t\tfor (let i = 0; i < chunkModules.length; i++) {\n\t\t\t\t\tconst m = chunkModules[i];\n\t\t\t\t\tif (m.id === null) {\n\t\t\t\t\t\tm.id = currentId++;\n\t\t\t\t\t}\n\t\t\t\t\tif (options.end && currentId > options.end) break;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\nmodule.exports = ChunkModuleIdRangePlugin;\n"]},"metadata":{},"sourceType":"script"}