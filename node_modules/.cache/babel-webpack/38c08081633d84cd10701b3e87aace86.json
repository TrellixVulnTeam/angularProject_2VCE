{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/modulewithproviders/src/scanner\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ModuleWithProvidersScanner = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var ModuleWithProvidersScanner =\n  /** @class */\n  function () {\n    function ModuleWithProvidersScanner(host, evaluator, emitter) {\n      this.host = host;\n      this.evaluator = evaluator;\n      this.emitter = emitter;\n    }\n\n    ModuleWithProvidersScanner.prototype.scan = function (sf, dts) {\n      var e_1, _a;\n\n      try {\n        for (var _b = tslib_1.__values(sf.statements), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var stmt = _c.value;\n          this.visitStatement(dts, stmt);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    ModuleWithProvidersScanner.prototype.visitStatement = function (dts, stmt) {\n      var e_2, _a; // Detect whether a statement is exported, which is used as one of the hints whether to look\n      // more closely at possible MWP functions within. This is a syntactic check, not a semantic\n      // check, so it won't detect cases like:\n      //\n      // var X = ...;\n      // export {X}\n      //\n      // This is intentional, because the alternative is slow and this will catch 99% of the cases we\n      // need to handle.\n\n\n      var isExported = stmt.modifiers !== undefined && stmt.modifiers.some(function (mod) {\n        return mod.kind === ts.SyntaxKind.ExportKeyword;\n      });\n\n      if (!isExported) {\n        return;\n      }\n\n      if (ts.isClassDeclaration(stmt)) {\n        try {\n          for (var _b = tslib_1.__values(stmt.members), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var member = _c.value;\n\n            if (!ts.isMethodDeclaration(member) || !isStatic(member)) {\n              continue;\n            }\n\n            this.visitFunctionOrMethodDeclaration(dts, member);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      } else if (ts.isFunctionDeclaration(stmt)) {\n        this.visitFunctionOrMethodDeclaration(dts, stmt);\n      }\n    };\n\n    ModuleWithProvidersScanner.prototype.visitFunctionOrMethodDeclaration = function (dts, decl) {\n      // First, some sanity. This should have a method body with a single return statement.\n      if (decl.body === undefined || decl.body.statements.length !== 1) {\n        return;\n      }\n\n      var retStmt = decl.body.statements[0];\n\n      if (!ts.isReturnStatement(retStmt) || retStmt.expression === undefined) {\n        return;\n      }\n\n      var retValue = retStmt.expression; // Now, look at the return type of the method. Maybe bail if the type is already marked, or if\n      // it's incompatible with a MWP function.\n\n      var returnType = this.returnTypeOf(decl);\n\n      if (returnType === ReturnType.OTHER || returnType === ReturnType.MWP_WITH_TYPE) {\n        // Don't process this declaration, it either already declares the right return type, or an\n        // incompatible one.\n        return;\n      }\n\n      var value = this.evaluator.evaluate(retValue);\n\n      if (!(value instanceof Map) || !value.has('ngModule')) {\n        // The return value does not provide sufficient information to be able to add a generic type.\n        return;\n      }\n\n      if (returnType === ReturnType.INFERRED && !isModuleWithProvidersType(value)) {\n        // The return type is inferred but the returned object is not of the correct shape, so we\n        // shouldn's modify the return type to become `ModuleWithProviders`.\n        return;\n      } // The return type has been verified to represent the `ModuleWithProviders` type, but either the\n      // return type is inferred or the generic type argument is missing. In both cases, a new return\n      // type is created where the `ngModule` type is included as generic type argument.\n\n\n      var ngModule = value.get('ngModule');\n\n      if (!(ngModule instanceof imports_1.Reference) || !ts.isClassDeclaration(ngModule.node)) {\n        return;\n      }\n\n      var ngModuleExpr = this.emitter.emit(ngModule, decl.getSourceFile(), imports_1.ImportFlags.ForceNewImport);\n      var ngModuleType = new compiler_1.ExpressionType(ngModuleExpr.expression);\n      var mwpNgType = new compiler_1.ExpressionType(new compiler_1.ExternalExpr(compiler_1.R3Identifiers.ModuleWithProviders), [\n        /* modifiers */\n      ], [ngModuleType]);\n      dts.addTypeReplacement(decl, mwpNgType);\n    };\n\n    ModuleWithProvidersScanner.prototype.returnTypeOf = function (decl) {\n      if (decl.type === undefined) {\n        return ReturnType.INFERRED;\n      } else if (!ts.isTypeReferenceNode(decl.type)) {\n        return ReturnType.OTHER;\n      } // Try to figure out if the type is of a familiar form, something that looks like it was\n      // imported.\n\n\n      var typeId;\n\n      if (ts.isIdentifier(decl.type.typeName)) {\n        // def: ModuleWithProviders\n        typeId = decl.type.typeName;\n      } else if (ts.isQualifiedName(decl.type.typeName) && ts.isIdentifier(decl.type.typeName.left)) {\n        // def: i0.ModuleWithProviders\n        typeId = decl.type.typeName.right;\n      } else {\n        return ReturnType.OTHER;\n      }\n\n      var importDecl = this.host.getImportOfIdentifier(typeId);\n\n      if (importDecl === null || importDecl.from !== '@angular/core' || importDecl.name !== 'ModuleWithProviders') {\n        return ReturnType.OTHER;\n      }\n\n      if (decl.type.typeArguments === undefined || decl.type.typeArguments.length === 0) {\n        // The return type is indeed ModuleWithProviders, but no generic type parameter was found.\n        return ReturnType.MWP_NO_TYPE;\n      } else {\n        // The return type is ModuleWithProviders, and the user has already specified a generic type.\n        return ReturnType.MWP_WITH_TYPE;\n      }\n    };\n\n    return ModuleWithProvidersScanner;\n  }();\n\n  exports.ModuleWithProvidersScanner = ModuleWithProvidersScanner;\n  var ReturnType;\n\n  (function (ReturnType) {\n    ReturnType[ReturnType[\"INFERRED\"] = 0] = \"INFERRED\";\n    ReturnType[ReturnType[\"MWP_NO_TYPE\"] = 1] = \"MWP_NO_TYPE\";\n    ReturnType[ReturnType[\"MWP_WITH_TYPE\"] = 2] = \"MWP_WITH_TYPE\";\n    ReturnType[ReturnType[\"OTHER\"] = 3] = \"OTHER\";\n  })(ReturnType || (ReturnType = {}));\n  /** Whether the resolved value map represents a ModuleWithProviders object */\n\n\n  function isModuleWithProvidersType(value) {\n    var ngModule = value.has('ngModule');\n    var providers = value.has('providers');\n    return ngModule && (value.size === 1 || providers && value.size === 2);\n  }\n\n  function isStatic(node) {\n    return node.modifiers !== undefined && node.modifiers.some(function (mod) {\n      return mod.kind === ts.SyntaxKind.StaticKeyword;\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/modulewithproviders/src/scanner.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ExpressionType, ExternalExpr, R3Identifiers as Identifiers, Type} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ImportFlags, Reference, ReferenceEmitter} from '../../imports';\nimport {PartialEvaluator, ResolvedValueMap} from '../../partial_evaluator';\nimport {ReflectionHost} from '../../reflection';\n\nexport interface DtsHandler {\n  addTypeReplacement(node: ts.Declaration, type: Type): void;\n}\n\nexport class ModuleWithProvidersScanner {\n  constructor(\n      private host: ReflectionHost, private evaluator: PartialEvaluator,\n      private emitter: ReferenceEmitter) {}\n\n  scan(sf: ts.SourceFile, dts: DtsHandler): void {\n    for (const stmt of sf.statements) {\n      this.visitStatement(dts, stmt);\n    }\n  }\n\n  private visitStatement(dts: DtsHandler, stmt: ts.Statement): void {\n    // Detect whether a statement is exported, which is used as one of the hints whether to look\n    // more closely at possible MWP functions within. This is a syntactic check, not a semantic\n    // check, so it won't detect cases like:\n    //\n    // var X = ...;\n    // export {X}\n    //\n    // This is intentional, because the alternative is slow and this will catch 99% of the cases we\n    // need to handle.\n    const isExported = stmt.modifiers !== undefined &&\n        stmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);\n\n    if (!isExported) {\n      return;\n    }\n\n    if (ts.isClassDeclaration(stmt)) {\n      for (const member of stmt.members) {\n        if (!ts.isMethodDeclaration(member) || !isStatic(member)) {\n          continue;\n        }\n\n        this.visitFunctionOrMethodDeclaration(dts, member);\n      }\n    } else if (ts.isFunctionDeclaration(stmt)) {\n      this.visitFunctionOrMethodDeclaration(dts, stmt);\n    }\n  }\n\n  private visitFunctionOrMethodDeclaration(\n      dts: DtsHandler, decl: ts.MethodDeclaration|ts.FunctionDeclaration): void {\n    // First, some sanity. This should have a method body with a single return statement.\n    if (decl.body === undefined || decl.body.statements.length !== 1) {\n      return;\n    }\n    const retStmt = decl.body.statements[0];\n    if (!ts.isReturnStatement(retStmt) || retStmt.expression === undefined) {\n      return;\n    }\n    const retValue = retStmt.expression;\n\n    // Now, look at the return type of the method. Maybe bail if the type is already marked, or if\n    // it's incompatible with a MWP function.\n    const returnType = this.returnTypeOf(decl);\n    if (returnType === ReturnType.OTHER || returnType === ReturnType.MWP_WITH_TYPE) {\n      // Don't process this declaration, it either already declares the right return type, or an\n      // incompatible one.\n      return;\n    }\n\n    const value = this.evaluator.evaluate(retValue);\n    if (!(value instanceof Map) || !value.has('ngModule')) {\n      // The return value does not provide sufficient information to be able to add a generic type.\n      return;\n    }\n\n    if (returnType === ReturnType.INFERRED && !isModuleWithProvidersType(value)) {\n      // The return type is inferred but the returned object is not of the correct shape, so we\n      // shouldn's modify the return type to become `ModuleWithProviders`.\n      return;\n    }\n\n    // The return type has been verified to represent the `ModuleWithProviders` type, but either the\n    // return type is inferred or the generic type argument is missing. In both cases, a new return\n    // type is created where the `ngModule` type is included as generic type argument.\n    const ngModule = value.get('ngModule');\n    if (!(ngModule instanceof Reference) || !ts.isClassDeclaration(ngModule.node)) {\n      return;\n    }\n\n    const ngModuleExpr =\n        this.emitter.emit(ngModule, decl.getSourceFile(), ImportFlags.ForceNewImport);\n    const ngModuleType = new ExpressionType(ngModuleExpr.expression);\n    const mwpNgType = new ExpressionType(\n        new ExternalExpr(Identifiers.ModuleWithProviders), [/* modifiers */], [ngModuleType]);\n\n    dts.addTypeReplacement(decl, mwpNgType);\n  }\n\n  private returnTypeOf(decl: ts.FunctionDeclaration|ts.MethodDeclaration|\n                       ts.VariableDeclaration): ReturnType {\n    if (decl.type === undefined) {\n      return ReturnType.INFERRED;\n    } else if (!ts.isTypeReferenceNode(decl.type)) {\n      return ReturnType.OTHER;\n    }\n\n    // Try to figure out if the type is of a familiar form, something that looks like it was\n    // imported.\n    let typeId: ts.Identifier;\n    if (ts.isIdentifier(decl.type.typeName)) {\n      // def: ModuleWithProviders\n      typeId = decl.type.typeName;\n    } else if (ts.isQualifiedName(decl.type.typeName) && ts.isIdentifier(decl.type.typeName.left)) {\n      // def: i0.ModuleWithProviders\n      typeId = decl.type.typeName.right;\n    } else {\n      return ReturnType.OTHER;\n    }\n\n    const importDecl = this.host.getImportOfIdentifier(typeId);\n    if (importDecl === null || importDecl.from !== '@angular/core' ||\n        importDecl.name !== 'ModuleWithProviders') {\n      return ReturnType.OTHER;\n    }\n\n    if (decl.type.typeArguments === undefined || decl.type.typeArguments.length === 0) {\n      // The return type is indeed ModuleWithProviders, but no generic type parameter was found.\n      return ReturnType.MWP_NO_TYPE;\n    } else {\n      // The return type is ModuleWithProviders, and the user has already specified a generic type.\n      return ReturnType.MWP_WITH_TYPE;\n    }\n  }\n}\n\nenum ReturnType {\n  INFERRED,\n  MWP_NO_TYPE,\n  MWP_WITH_TYPE,\n  OTHER,\n}\n\n/** Whether the resolved value map represents a ModuleWithProviders object */\nfunction isModuleWithProvidersType(value: ResolvedValueMap): boolean {\n  const ngModule = value.has('ngModule');\n  const providers = value.has('providers');\n\n  return ngModule && (value.size === 1 || (providers && value.size === 2));\n}\n\nfunction isStatic(node: ts.Node): boolean {\n  return node.modifiers !== undefined &&\n      node.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}