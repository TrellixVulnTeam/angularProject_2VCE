{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/lifecycle_reflector\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getAllLifecycleHooks = exports.hasLifecycleHook = exports.LIFECYCLE_HOOKS_VALUES = exports.LifecycleHooks = void 0;\n  var LifecycleHooks;\n\n  (function (LifecycleHooks) {\n    LifecycleHooks[LifecycleHooks[\"OnInit\"] = 0] = \"OnInit\";\n    LifecycleHooks[LifecycleHooks[\"OnDestroy\"] = 1] = \"OnDestroy\";\n    LifecycleHooks[LifecycleHooks[\"DoCheck\"] = 2] = \"DoCheck\";\n    LifecycleHooks[LifecycleHooks[\"OnChanges\"] = 3] = \"OnChanges\";\n    LifecycleHooks[LifecycleHooks[\"AfterContentInit\"] = 4] = \"AfterContentInit\";\n    LifecycleHooks[LifecycleHooks[\"AfterContentChecked\"] = 5] = \"AfterContentChecked\";\n    LifecycleHooks[LifecycleHooks[\"AfterViewInit\"] = 6] = \"AfterViewInit\";\n    LifecycleHooks[LifecycleHooks[\"AfterViewChecked\"] = 7] = \"AfterViewChecked\";\n  })(LifecycleHooks = exports.LifecycleHooks || (exports.LifecycleHooks = {}));\n\n  exports.LIFECYCLE_HOOKS_VALUES = [LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges, LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit, LifecycleHooks.AfterViewChecked];\n\n  function hasLifecycleHook(reflector, hook, token) {\n    return reflector.hasLifecycleHook(token, getHookName(hook));\n  }\n\n  exports.hasLifecycleHook = hasLifecycleHook;\n\n  function getAllLifecycleHooks(reflector, token) {\n    return exports.LIFECYCLE_HOOKS_VALUES.filter(function (hook) {\n      return hasLifecycleHook(reflector, hook, token);\n    });\n  }\n\n  exports.getAllLifecycleHooks = getAllLifecycleHooks;\n\n  function getHookName(hook) {\n    switch (hook) {\n      case LifecycleHooks.OnInit:\n        return 'ngOnInit';\n\n      case LifecycleHooks.OnDestroy:\n        return 'ngOnDestroy';\n\n      case LifecycleHooks.DoCheck:\n        return 'ngDoCheck';\n\n      case LifecycleHooks.OnChanges:\n        return 'ngOnChanges';\n\n      case LifecycleHooks.AfterContentInit:\n        return 'ngAfterContentInit';\n\n      case LifecycleHooks.AfterContentChecked:\n        return 'ngAfterContentChecked';\n\n      case LifecycleHooks.AfterViewInit:\n        return 'ngAfterViewInit';\n\n      case LifecycleHooks.AfterViewChecked:\n        return 'ngAfterViewChecked';\n\n      default:\n        // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n        // However Closure Compiler does not understand that and reports an error in typed mode.\n        // The `throw new Error` below works around the problem, and the unexpected: never variable\n        // makes sure tsc still checks this code is unreachable.\n        var unexpected = hook;\n        throw new Error(\"unexpected \" + unexpected);\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/lifecycle_reflector.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;AAIH,MAAY,cAAZ;;AAAA,GAAA,UAAY,cAAZ,EAA0B;AACxB,IAAA,cAAA,CAAA,cAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,IAAA,cAAA,CAAA,cAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,IAAA,cAAA,CAAA,cAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA,IAAA,cAAA,CAAA,cAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,IAAA,cAAA,CAAA,cAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;AACA,IAAA,cAAA,CAAA,cAAA,CAAA,qBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,qBAAA;AACA,IAAA,cAAA,CAAA,cAAA,CAAA,eAAA,CAAA,GAAA,CAAA,CAAA,GAAA,eAAA;AACA,IAAA,cAAA,CAAA,cAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;AACD,GATD,EAAY,cAAc,GAAd,OAAA,CAAA,cAAA,KAAA,OAAA,CAAA,cAAA,GAAc,EAAd,CAAZ;;AAWa,EAAA,OAAA,CAAA,sBAAA,GAAyB,CACpC,cAAc,CAAC,MADqB,EACb,cAAc,CAAC,SADF,EACa,cAAc,CAAC,OAD5B,EACqC,cAAc,CAAC,SADpD,EAEpC,cAAc,CAAC,gBAFqB,EAEH,cAAc,CAAC,mBAFZ,EAEiC,cAAc,CAAC,aAFhD,EAGpC,cAAc,CAAC,gBAHqB,CAAzB;;AAMb,WAAgB,gBAAhB,CACI,SADJ,EACiC,IADjC,EACuD,KADvD,EACiE;AAC/D,WAAO,SAAS,CAAC,gBAAV,CAA2B,KAA3B,EAAkC,WAAW,CAAC,IAAD,CAA7C,CAAP;AACD;;AAHD,EAAA,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAKA,WAAgB,oBAAhB,CAAqC,SAArC,EAAkE,KAAlE,EAA4E;AAC1E,WAAO,OAAA,CAAA,sBAAA,CAAuB,MAAvB,CAA8B,UAAA,IAAA,EAAI;AAAI,aAAA,gBAAgB,CAAC,SAAD,EAAY,IAAZ,EAAhB,KAAgB,CAAhB;AAAwC,KAA9E,CAAP;AACD;;AAFD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAIA,WAAS,WAAT,CAAqB,IAArB,EAAyC;AACvC,YAAQ,IAAR;AACE,WAAK,cAAc,CAAC,MAApB;AACE,eAAO,UAAP;;AACF,WAAK,cAAc,CAAC,SAApB;AACE,eAAO,aAAP;;AACF,WAAK,cAAc,CAAC,OAApB;AACE,eAAO,WAAP;;AACF,WAAK,cAAc,CAAC,SAApB;AACE,eAAO,aAAP;;AACF,WAAK,cAAc,CAAC,gBAApB;AACE,eAAO,oBAAP;;AACF,WAAK,cAAc,CAAC,mBAApB;AACE,eAAO,uBAAP;;AACF,WAAK,cAAc,CAAC,aAApB;AACE,eAAO,iBAAP;;AACF,WAAK,cAAc,CAAC,gBAApB;AACE,eAAO,oBAAP;;AACF;AACE;AACA;AACA;AACA;AACA,YAAM,UAAU,GAAU,IAA1B;AACA,cAAM,IAAI,KAAJ,CAAU,gBAAc,UAAxB,CAAN;AAvBJ;AAyBD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileReflector} from './compile_reflector';\n\nexport enum LifecycleHooks {\n  OnInit,\n  OnDestroy,\n  DoCheck,\n  OnChanges,\n  AfterContentInit,\n  AfterContentChecked,\n  AfterViewInit,\n  AfterViewChecked\n}\n\nexport const LIFECYCLE_HOOKS_VALUES = [\n  LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\n  LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\n  LifecycleHooks.AfterViewChecked\n];\n\nexport function hasLifecycleHook(\n    reflector: CompileReflector, hook: LifecycleHooks, token: any): boolean {\n  return reflector.hasLifecycleHook(token, getHookName(hook));\n}\n\nexport function getAllLifecycleHooks(reflector: CompileReflector, token: any): LifecycleHooks[] {\n  return LIFECYCLE_HOOKS_VALUES.filter(hook => hasLifecycleHook(reflector, hook, token));\n}\n\nfunction getHookName(hook: LifecycleHooks): string {\n  switch (hook) {\n    case LifecycleHooks.OnInit:\n      return 'ngOnInit';\n    case LifecycleHooks.OnDestroy:\n      return 'ngOnDestroy';\n    case LifecycleHooks.DoCheck:\n      return 'ngDoCheck';\n    case LifecycleHooks.OnChanges:\n      return 'ngOnChanges';\n    case LifecycleHooks.AfterContentInit:\n      return 'ngAfterContentInit';\n    case LifecycleHooks.AfterContentChecked:\n      return 'ngAfterContentChecked';\n    case LifecycleHooks.AfterViewInit:\n      return 'ngAfterViewInit';\n    case LifecycleHooks.AfterViewChecked:\n      return 'ngAfterViewChecked';\n    default:\n      // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n      // However Closure Compiler does not understand that and reports an error in typed mode.\n      // The `throw new Error` below works around the problem, and the unexpected: never variable\n      // makes sure tsc still checks this code is unreachable.\n      const unexpected: never = hook;\n      throw new Error(`unexpected ${unexpected}`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}