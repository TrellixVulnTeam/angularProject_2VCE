{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar identifierUtils = require(\"../util/identifier\");\n\nvar _require = require(\"../util/SetHelpers\"),\n    intersect = _require.intersect;\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\n\nvar moveModuleBetween = function moveModuleBetween(oldChunk, newChunk) {\n  return function (module) {\n    oldChunk.moveModule(module, newChunk);\n  };\n};\n\nvar isNotAEntryModule = function isNotAEntryModule(entryModule) {\n  return function (module) {\n    return entryModule !== module;\n  };\n};\n\nvar AggressiveSplittingPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {AggressiveSplittingPluginOptions=} options options object\n   */\n  function AggressiveSplittingPlugin(options) {\n    _classCallCheck(this, AggressiveSplittingPlugin);\n\n    if (!options) options = {};\n    validateOptions(schema, options, \"Aggressive Splitting Plugin\");\n    this.options = options;\n\n    if (typeof this.options.minSize !== \"number\") {\n      this.options.minSize = 30 * 1024;\n    }\n\n    if (typeof this.options.maxSize !== \"number\") {\n      this.options.maxSize = 50 * 1024;\n    }\n\n    if (typeof this.options.chunkOverhead !== \"number\") {\n      this.options.chunkOverhead = 0;\n    }\n\n    if (typeof this.options.entryChunkMultiplicator !== \"number\") {\n      this.options.entryChunkMultiplicator = 1;\n    }\n  }\n\n  _createClass(AggressiveSplittingPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var _this = this;\n\n      compiler.hooks.thisCompilation.tap(\"AggressiveSplittingPlugin\", function (compilation) {\n        var needAdditionalSeal = false;\n        var newSplits;\n        var fromAggressiveSplittingSet;\n        var chunkSplitDataMap;\n        compilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", function () {\n          newSplits = [];\n          fromAggressiveSplittingSet = new Set();\n          chunkSplitDataMap = new Map();\n        });\n        compilation.hooks.optimizeChunksAdvanced.tap(\"AggressiveSplittingPlugin\", function (chunks) {\n          // Precompute stuff\n          var nameToModuleMap = new Map();\n          var moduleToNameMap = new Map();\n\n          var _iterator = _createForOfIteratorHelper(compilation.modules),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var m = _step.value;\n              var name = identifierUtils.makePathsRelative(compiler.context, m.identifier(), compilation.cache);\n              nameToModuleMap.set(name, m);\n              moduleToNameMap.set(m, name);\n            } // Check used chunk ids\n\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var usedIds = new Set();\n\n          var _iterator2 = _createForOfIteratorHelper(chunks),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var chunk = _step2.value;\n              usedIds.add(chunk.id);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          var recordedSplits = compilation.records && compilation.records.aggressiveSplits || [];\n          var usedSplits = newSplits ? recordedSplits.concat(newSplits) : recordedSplits;\n          var minSize = _this.options.minSize;\n          var maxSize = _this.options.maxSize;\n\n          var applySplit = function applySplit(splitData) {\n            // Cannot split if id is already taken\n            if (splitData.id !== undefined && usedIds.has(splitData.id)) {\n              return false;\n            } // Get module objects from names\n\n\n            var selectedModules = splitData.modules.map(function (name) {\n              return nameToModuleMap.get(name);\n            }); // Does the modules exist at all?\n\n            if (!selectedModules.every(Boolean)) return false; // Check if size matches (faster than waiting for hash)\n\n            var size = selectedModules.reduce(function (sum, m) {\n              return sum + m.size();\n            }, 0);\n            if (size !== splitData.size) return false; // get chunks with all modules\n\n            var selectedChunks = intersect(selectedModules.map(function (m) {\n              return new Set(m.chunksIterable);\n            })); // No relevant chunks found\n\n            if (selectedChunks.size === 0) return false; // The found chunk is already the split or similar\n\n            if (selectedChunks.size === 1 && Array.from(selectedChunks)[0].getNumberOfModules() === selectedModules.length) {\n              var chunk = Array.from(selectedChunks)[0];\n              if (fromAggressiveSplittingSet.has(chunk)) return false;\n              fromAggressiveSplittingSet.add(chunk);\n              chunkSplitDataMap.set(chunk, splitData);\n              return true;\n            } // split the chunk into two parts\n\n\n            var newChunk = compilation.addChunk();\n            newChunk.chunkReason = \"aggressive splitted\";\n\n            var _iterator3 = _createForOfIteratorHelper(selectedChunks),\n                _step3;\n\n            try {\n              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                var _chunk = _step3.value;\n                selectedModules.forEach(moveModuleBetween(_chunk, newChunk));\n\n                _chunk.split(newChunk);\n\n                _chunk.name = null;\n              }\n            } catch (err) {\n              _iterator3.e(err);\n            } finally {\n              _iterator3.f();\n            }\n\n            fromAggressiveSplittingSet.add(newChunk);\n            chunkSplitDataMap.set(newChunk, splitData);\n\n            if (splitData.id !== null && splitData.id !== undefined) {\n              newChunk.id = splitData.id;\n            }\n\n            return true;\n          }; // try to restore to recorded splitting\n\n\n          var changed = false;\n\n          for (var j = 0; j < usedSplits.length; j++) {\n            var splitData = usedSplits[j];\n            if (applySplit(splitData)) changed = true;\n          } // for any chunk which isn't splitted yet, split it and create a new entry\n          // start with the biggest chunk\n\n\n          var sortedChunks = chunks.slice().sort(function (a, b) {\n            var diff1 = b.modulesSize() - a.modulesSize();\n            if (diff1) return diff1;\n            var diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n            if (diff2) return diff2;\n            var modulesA = Array.from(a.modulesIterable);\n            var modulesB = Array.from(b.modulesIterable);\n            modulesA.sort();\n            modulesB.sort();\n            var aI = modulesA[Symbol.iterator]();\n            var bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n            while (true) {\n              var aItem = aI.next();\n              var bItem = bI.next();\n              if (aItem.done) return 0;\n              var aModuleIdentifier = aItem.value.identifier();\n              var bModuleIdentifier = bItem.value.identifier();\n              if (aModuleIdentifier > bModuleIdentifier) return -1;\n              if (aModuleIdentifier < bModuleIdentifier) return 1;\n            }\n          });\n\n          var _iterator4 = _createForOfIteratorHelper(sortedChunks),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _chunk2 = _step4.value;\n              if (fromAggressiveSplittingSet.has(_chunk2)) continue;\n\n              var size = _chunk2.modulesSize();\n\n              if (size > maxSize && _chunk2.getNumberOfModules() > 1) {\n                var modules = _chunk2.getModules().filter(isNotAEntryModule(_chunk2.entryModule)).sort(function (a, b) {\n                  a = a.identifier();\n                  b = b.identifier();\n                  if (a > b) return 1;\n                  if (a < b) return -1;\n                  return 0;\n                });\n\n                var selectedModules = [];\n                var selectedModulesSize = 0;\n\n                for (var k = 0; k < modules.length; k++) {\n                  var _module = modules[k];\n\n                  var newSize = selectedModulesSize + _module.size();\n\n                  if (newSize > maxSize && selectedModulesSize >= minSize) {\n                    break;\n                  }\n\n                  selectedModulesSize = newSize;\n                  selectedModules.push(_module);\n                }\n\n                if (selectedModules.length === 0) continue;\n                var _splitData = {\n                  modules: selectedModules.map(function (m) {\n                    return moduleToNameMap.get(m);\n                  }).sort(),\n                  size: selectedModulesSize\n                };\n\n                if (applySplit(_splitData)) {\n                  newSplits = (newSplits || []).concat(_splitData);\n                  changed = true;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          if (changed) return true;\n        });\n        compilation.hooks.recordHash.tap(\"AggressiveSplittingPlugin\", function (records) {\n          // 4. save made splittings to records\n          var allSplits = new Set();\n          var invalidSplits = new Set(); // Check if some splittings are invalid\n          // We remove invalid splittings and try again\n\n          var _iterator5 = _createForOfIteratorHelper(compilation.chunks),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _chunk3 = _step5.value;\n\n              var _splitData3 = chunkSplitDataMap.get(_chunk3);\n\n              if (_splitData3 !== undefined) {\n                if (_splitData3.hash && _chunk3.hash !== _splitData3.hash) {\n                  // Split was successful, but hash doesn't equal\n                  // We can throw away the split since it's useless now\n                  invalidSplits.add(_splitData3);\n                }\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          if (invalidSplits.size > 0) {\n            records.aggressiveSplits = records.aggressiveSplits.filter(function (splitData) {\n              return !invalidSplits.has(splitData);\n            });\n            needAdditionalSeal = true;\n          } else {\n            // set hash and id values on all (new) splittings\n            var _iterator6 = _createForOfIteratorHelper(compilation.chunks),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var chunk = _step6.value;\n\n                var _splitData2 = chunkSplitDataMap.get(chunk);\n\n                if (_splitData2 !== undefined) {\n                  _splitData2.hash = chunk.hash;\n                  _splitData2.id = chunk.id;\n                  allSplits.add(_splitData2); // set flag for stats\n\n                  chunk.recorded = true;\n                }\n              } // Also add all unused historial splits (after the used ones)\n              // They can still be used in some future compilation\n\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n\n            var recordedSplits = compilation.records && compilation.records.aggressiveSplits;\n\n            if (recordedSplits) {\n              var _iterator7 = _createForOfIteratorHelper(recordedSplits),\n                  _step7;\n\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var splitData = _step7.value;\n                  if (!invalidSplits.has(splitData)) allSplits.add(splitData);\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            } // record all splits\n\n\n            records.aggressiveSplits = Array.from(allSplits);\n            needAdditionalSeal = false;\n          }\n        });\n        compilation.hooks.needAdditionalSeal.tap(\"AggressiveSplittingPlugin\", function () {\n          if (needAdditionalSeal) {\n            needAdditionalSeal = false;\n            return true;\n          }\n        });\n      });\n    }\n  }]);\n\n  return AggressiveSplittingPlugin;\n}();\n\nmodule.exports = AggressiveSplittingPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/optimize/AggressiveSplittingPlugin.js"],"names":["identifierUtils","require","intersect","validateOptions","schema","moveModuleBetween","oldChunk","newChunk","module","moveModule","isNotAEntryModule","entryModule","AggressiveSplittingPlugin","options","minSize","maxSize","chunkOverhead","entryChunkMultiplicator","compiler","hooks","thisCompilation","tap","compilation","needAdditionalSeal","newSplits","fromAggressiveSplittingSet","chunkSplitDataMap","optimize","Set","Map","optimizeChunksAdvanced","chunks","nameToModuleMap","moduleToNameMap","modules","m","name","makePathsRelative","context","identifier","cache","set","usedIds","chunk","add","id","recordedSplits","records","aggressiveSplits","usedSplits","concat","applySplit","splitData","undefined","has","selectedModules","map","get","every","Boolean","size","reduce","sum","selectedChunks","chunksIterable","Array","from","getNumberOfModules","length","addChunk","chunkReason","forEach","split","changed","j","sortedChunks","slice","sort","a","b","diff1","modulesSize","diff2","modulesA","modulesIterable","modulesB","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","getModules","filter","selectedModulesSize","k","newSize","push","recordHash","allSplits","invalidSplits","hash","recorded","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"../util/identifier\");\nconst { intersect } = require(\"../util/SetHelpers\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/AggressiveSplittingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/AggressiveSplittingPlugin\").AggressiveSplittingPluginOptions} AggressiveSplittingPluginOptions */\n\nconst moveModuleBetween = (oldChunk, newChunk) => {\n\treturn module => {\n\t\toldChunk.moveModule(module, newChunk);\n\t};\n};\n\nconst isNotAEntryModule = entryModule => {\n\treturn module => {\n\t\treturn entryModule !== module;\n\t};\n};\n\nclass AggressiveSplittingPlugin {\n\t/**\n\t * @param {AggressiveSplittingPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Aggressive Splitting Plugin\");\n\n\t\tthis.options = options;\n\t\tif (typeof this.options.minSize !== \"number\") {\n\t\t\tthis.options.minSize = 30 * 1024;\n\t\t}\n\t\tif (typeof this.options.maxSize !== \"number\") {\n\t\t\tthis.options.maxSize = 50 * 1024;\n\t\t}\n\t\tif (typeof this.options.chunkOverhead !== \"number\") {\n\t\t\tthis.options.chunkOverhead = 0;\n\t\t}\n\t\tif (typeof this.options.entryChunkMultiplicator !== \"number\") {\n\t\t\tthis.options.entryChunkMultiplicator = 1;\n\t\t}\n\t}\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\n\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tlet needAdditionalSeal = false;\n\t\t\t\tlet newSplits;\n\t\t\t\tlet fromAggressiveSplittingSet;\n\t\t\t\tlet chunkSplitDataMap;\n\t\t\t\tcompilation.hooks.optimize.tap(\"AggressiveSplittingPlugin\", () => {\n\t\t\t\t\tnewSplits = [];\n\t\t\t\t\tfromAggressiveSplittingSet = new Set();\n\t\t\t\t\tchunkSplitDataMap = new Map();\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\tchunks => {\n\t\t\t\t\t\t// Precompute stuff\n\t\t\t\t\t\tconst nameToModuleMap = new Map();\n\t\t\t\t\t\tconst moduleToNameMap = new Map();\n\t\t\t\t\t\tfor (const m of compilation.modules) {\n\t\t\t\t\t\t\tconst name = identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\tm.identifier(),\n\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tnameToModuleMap.set(name, m);\n\t\t\t\t\t\t\tmoduleToNameMap.set(m, name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check used chunk ids\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t(compilation.records && compilation.records.aggressiveSplits) ||\n\t\t\t\t\t\t\t[];\n\t\t\t\t\t\tconst usedSplits = newSplits\n\t\t\t\t\t\t\t? recordedSplits.concat(newSplits)\n\t\t\t\t\t\t\t: recordedSplits;\n\n\t\t\t\t\t\tconst minSize = this.options.minSize;\n\t\t\t\t\t\tconst maxSize = this.options.maxSize;\n\n\t\t\t\t\t\tconst applySplit = splitData => {\n\t\t\t\t\t\t\t// Cannot split if id is already taken\n\t\t\t\t\t\t\tif (splitData.id !== undefined && usedIds.has(splitData.id)) {\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Get module objects from names\n\t\t\t\t\t\t\tconst selectedModules = splitData.modules.map(name =>\n\t\t\t\t\t\t\t\tnameToModuleMap.get(name)\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Does the modules exist at all?\n\t\t\t\t\t\t\tif (!selectedModules.every(Boolean)) return false;\n\n\t\t\t\t\t\t\t// Check if size matches (faster than waiting for hash)\n\t\t\t\t\t\t\tconst size = selectedModules.reduce(\n\t\t\t\t\t\t\t\t(sum, m) => sum + m.size(),\n\t\t\t\t\t\t\t\t0\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (size !== splitData.size) return false;\n\n\t\t\t\t\t\t\t// get chunks with all modules\n\t\t\t\t\t\t\tconst selectedChunks = intersect(\n\t\t\t\t\t\t\t\tselectedModules.map(m => new Set(m.chunksIterable))\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// No relevant chunks found\n\t\t\t\t\t\t\tif (selectedChunks.size === 0) return false;\n\n\t\t\t\t\t\t\t// The found chunk is already the split or similar\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tselectedChunks.size === 1 &&\n\t\t\t\t\t\t\t\tArray.from(selectedChunks)[0].getNumberOfModules() ===\n\t\t\t\t\t\t\t\t\tselectedModules.length\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst chunk = Array.from(selectedChunks)[0];\n\t\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) return false;\n\t\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(chunk);\n\t\t\t\t\t\t\t\tchunkSplitDataMap.set(chunk, splitData);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// split the chunk into two parts\n\t\t\t\t\t\t\tconst newChunk = compilation.addChunk();\n\t\t\t\t\t\t\tnewChunk.chunkReason = \"aggressive splitted\";\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tselectedModules.forEach(moveModuleBetween(chunk, newChunk));\n\t\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t\t\tchunk.name = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfromAggressiveSplittingSet.add(newChunk);\n\t\t\t\t\t\t\tchunkSplitDataMap.set(newChunk, splitData);\n\n\t\t\t\t\t\t\tif (splitData.id !== null && splitData.id !== undefined) {\n\t\t\t\t\t\t\t\tnewChunk.id = splitData.id;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// try to restore to recorded splitting\n\t\t\t\t\t\tlet changed = false;\n\t\t\t\t\t\tfor (let j = 0; j < usedSplits.length; j++) {\n\t\t\t\t\t\t\tconst splitData = usedSplits[j];\n\t\t\t\t\t\t\tif (applySplit(splitData)) changed = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for any chunk which isn't splitted yet, split it and create a new entry\n\t\t\t\t\t\t// start with the biggest chunk\n\t\t\t\t\t\tconst sortedChunks = chunks.slice().sort((a, b) => {\n\t\t\t\t\t\t\tconst diff1 = b.modulesSize() - a.modulesSize();\n\t\t\t\t\t\t\tif (diff1) return diff1;\n\t\t\t\t\t\t\tconst diff2 = a.getNumberOfModules() - b.getNumberOfModules();\n\t\t\t\t\t\t\tif (diff2) return diff2;\n\t\t\t\t\t\t\tconst modulesA = Array.from(a.modulesIterable);\n\t\t\t\t\t\t\tconst modulesB = Array.from(b.modulesIterable);\n\t\t\t\t\t\t\tmodulesA.sort();\n\t\t\t\t\t\t\tmodulesB.sort();\n\t\t\t\t\t\t\tconst aI = modulesA[Symbol.iterator]();\n\t\t\t\t\t\t\tconst bI = modulesB[Symbol.iterator]();\n\t\t\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tconst aItem = aI.next();\n\t\t\t\t\t\t\t\tconst bItem = bI.next();\n\t\t\t\t\t\t\t\tif (aItem.done) return 0;\n\t\t\t\t\t\t\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\t\t\t\t\t\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\t\t\t\t\t\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\t\t\t\t\t\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (const chunk of sortedChunks) {\n\t\t\t\t\t\t\tif (fromAggressiveSplittingSet.has(chunk)) continue;\n\t\t\t\t\t\t\tconst size = chunk.modulesSize();\n\t\t\t\t\t\t\tif (size > maxSize && chunk.getNumberOfModules() > 1) {\n\t\t\t\t\t\t\t\tconst modules = chunk\n\t\t\t\t\t\t\t\t\t.getModules()\n\t\t\t\t\t\t\t\t\t.filter(isNotAEntryModule(chunk.entryModule))\n\t\t\t\t\t\t\t\t\t.sort((a, b) => {\n\t\t\t\t\t\t\t\t\t\ta = a.identifier();\n\t\t\t\t\t\t\t\t\t\tb = b.identifier();\n\t\t\t\t\t\t\t\t\t\tif (a > b) return 1;\n\t\t\t\t\t\t\t\t\t\tif (a < b) return -1;\n\t\t\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst selectedModules = [];\n\t\t\t\t\t\t\t\tlet selectedModulesSize = 0;\n\t\t\t\t\t\t\t\tfor (let k = 0; k < modules.length; k++) {\n\t\t\t\t\t\t\t\t\tconst module = modules[k];\n\t\t\t\t\t\t\t\t\tconst newSize = selectedModulesSize + module.size();\n\t\t\t\t\t\t\t\t\tif (newSize > maxSize && selectedModulesSize >= minSize) {\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tselectedModulesSize = newSize;\n\t\t\t\t\t\t\t\t\tselectedModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (selectedModules.length === 0) continue;\n\t\t\t\t\t\t\t\tconst splitData = {\n\t\t\t\t\t\t\t\t\tmodules: selectedModules\n\t\t\t\t\t\t\t\t\t\t.map(m => moduleToNameMap.get(m))\n\t\t\t\t\t\t\t\t\t\t.sort(),\n\t\t\t\t\t\t\t\t\tsize: selectedModulesSize\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tif (applySplit(splitData)) {\n\t\t\t\t\t\t\t\t\tnewSplits = (newSplits || []).concat(splitData);\n\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (changed) return true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.recordHash.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\trecords => {\n\t\t\t\t\t\t// 4. save made splittings to records\n\t\t\t\t\t\tconst allSplits = new Set();\n\t\t\t\t\t\tconst invalidSplits = new Set();\n\n\t\t\t\t\t\t// Check if some splittings are invalid\n\t\t\t\t\t\t// We remove invalid splittings and try again\n\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\tif (splitData.hash && chunk.hash !== splitData.hash) {\n\t\t\t\t\t\t\t\t\t// Split was successful, but hash doesn't equal\n\t\t\t\t\t\t\t\t\t// We can throw away the split since it's useless now\n\t\t\t\t\t\t\t\t\tinvalidSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (invalidSplits.size > 0) {\n\t\t\t\t\t\t\trecords.aggressiveSplits = records.aggressiveSplits.filter(\n\t\t\t\t\t\t\t\tsplitData => !invalidSplits.has(splitData)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tneedAdditionalSeal = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// set hash and id values on all (new) splittings\n\t\t\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t\t\tconst splitData = chunkSplitDataMap.get(chunk);\n\t\t\t\t\t\t\t\tif (splitData !== undefined) {\n\t\t\t\t\t\t\t\t\tsplitData.hash = chunk.hash;\n\t\t\t\t\t\t\t\t\tsplitData.id = chunk.id;\n\t\t\t\t\t\t\t\t\tallSplits.add(splitData);\n\t\t\t\t\t\t\t\t\t// set flag for stats\n\t\t\t\t\t\t\t\t\tchunk.recorded = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Also add all unused historial splits (after the used ones)\n\t\t\t\t\t\t\t// They can still be used in some future compilation\n\t\t\t\t\t\t\tconst recordedSplits =\n\t\t\t\t\t\t\t\tcompilation.records && compilation.records.aggressiveSplits;\n\t\t\t\t\t\t\tif (recordedSplits) {\n\t\t\t\t\t\t\t\tfor (const splitData of recordedSplits) {\n\t\t\t\t\t\t\t\t\tif (!invalidSplits.has(splitData)) allSplits.add(splitData);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// record all splits\n\t\t\t\t\t\t\trecords.aggressiveSplits = Array.from(allSplits);\n\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t\tcompilation.hooks.needAdditionalSeal.tap(\n\t\t\t\t\t\"AggressiveSplittingPlugin\",\n\t\t\t\t\t() => {\n\t\t\t\t\t\tif (needAdditionalSeal) {\n\t\t\t\t\t\t\tneedAdditionalSeal = false;\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = AggressiveSplittingPlugin;\n"]},"metadata":{},"sourceType":"script"}