{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/i18n/context\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/render3/view/i18n/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.I18nContext = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/view/i18n/util\");\n\n  var TagType;\n\n  (function (TagType) {\n    TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\n    TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\n  })(TagType || (TagType = {}));\n  /**\n   * Generates an object that is used as a shared state between parent and all child contexts.\n   */\n\n\n  function setupRegistry() {\n    return {\n      getUniqueId: util_1.getSeqNumberGenerator(),\n      icus: new Map()\n    };\n  }\n  /**\n   * I18nContext is a helper class which keeps track of all i18n-related aspects\n   * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n   *\n   * When we enter a nested template, the top-level context is being passed down\n   * to the nested component, which uses this context to generate a child instance\n   * of I18nContext class (to handle nested template) and at the end, reconciles it back\n   * with the parent context.\n   *\n   * @param index Instruction index of i18nStart, which initiates this context\n   * @param ref Reference to a translation const that represents the content if thus context\n   * @param level Nestng level defined for child contexts\n   * @param templateIndex Instruction index of a template which this context belongs to\n   * @param meta Meta information (id, meaning, description, etc) associated with this context\n   */\n\n\n  var I18nContext =\n  /** @class */\n  function () {\n    function I18nContext(index, ref, level, templateIndex, meta, registry) {\n      if (level === void 0) {\n        level = 0;\n      }\n\n      if (templateIndex === void 0) {\n        templateIndex = null;\n      }\n\n      this.index = index;\n      this.ref = ref;\n      this.level = level;\n      this.templateIndex = templateIndex;\n      this.meta = meta;\n      this.registry = registry;\n      this.bindings = new Set();\n      this.placeholders = new Map();\n      this.isEmitted = false;\n      this._unresolvedCtxCount = 0;\n      this._registry = registry || setupRegistry();\n      this.id = this._registry.getUniqueId();\n    }\n\n    I18nContext.prototype.appendTag = function (type, node, index, closed) {\n      if (node.isVoid && closed) {\n        return; // ignore \"close\" for void tags\n      }\n\n      var ph = node.isVoid || !closed ? node.startName : node.closeName;\n      var content = {\n        type: type,\n        index: index,\n        ctx: this.id,\n        isVoid: node.isVoid,\n        closed: closed\n      };\n      util_1.updatePlaceholderMap(this.placeholders, ph, content);\n    };\n\n    Object.defineProperty(I18nContext.prototype, \"icus\", {\n      get: function get() {\n        return this._registry.icus;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(I18nContext.prototype, \"isRoot\", {\n      get: function get() {\n        return this.level === 0;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(I18nContext.prototype, \"isResolved\", {\n      get: function get() {\n        return this._unresolvedCtxCount === 0;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    I18nContext.prototype.getSerializedPlaceholders = function () {\n      var result = new Map();\n      this.placeholders.forEach(function (values, key) {\n        return result.set(key, values.map(serializePlaceholderValue));\n      });\n      return result;\n    }; // public API to accumulate i18n-related content\n\n\n    I18nContext.prototype.appendBinding = function (binding) {\n      this.bindings.add(binding);\n    };\n\n    I18nContext.prototype.appendIcu = function (name, ref) {\n      util_1.updatePlaceholderMap(this._registry.icus, name, ref);\n    };\n\n    I18nContext.prototype.appendBoundText = function (node) {\n      var _this = this;\n\n      var phs = util_1.assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n      phs.forEach(function (values, key) {\n        return util_1.updatePlaceholderMap.apply(void 0, tslib_1.__spread([_this.placeholders, key], values));\n      });\n    };\n\n    I18nContext.prototype.appendTemplate = function (node, index) {\n      // add open and close tags at the same time,\n      // since we process nested templates separately\n      this.appendTag(TagType.TEMPLATE, node, index, false);\n      this.appendTag(TagType.TEMPLATE, node, index, true);\n      this._unresolvedCtxCount++;\n    };\n\n    I18nContext.prototype.appendElement = function (node, index, closed) {\n      this.appendTag(TagType.ELEMENT, node, index, closed);\n    };\n\n    I18nContext.prototype.appendProjection = function (node, index) {\n      // Add open and close tags at the same time, since `<ng-content>` has no content,\n      // so when we come across `<ng-content>` we can register both open and close tags.\n      // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\n      // regular element tag placeholders, so we generate element placeholders for both types.\n      this.appendTag(TagType.ELEMENT, node, index, false);\n      this.appendTag(TagType.ELEMENT, node, index, true);\n    };\n    /**\n     * Generates an instance of a child context based on the root one,\n     * when we enter a nested template within I18n section.\n     *\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\n     * @param templateIndex Instruction index of a template which this context belongs to\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\n     *\n     * @returns I18nContext instance\n     */\n\n\n    I18nContext.prototype.forkChildContext = function (index, templateIndex, meta) {\n      return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n    };\n    /**\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n     *\n     * @param context Child I18nContext instance to be reconciled with parent context.\n     */\n\n\n    I18nContext.prototype.reconcileChildContext = function (context) {\n      var _this = this; // set the right context id for open and close\n      // template tags, so we can use it as sub-block ids\n\n\n      ['start', 'close'].forEach(function (op) {\n        var key = context.meta[op + \"Name\"];\n        var phs = _this.placeholders.get(key) || [];\n        var tag = phs.find(findTemplateFn(_this.id, context.templateIndex));\n\n        if (tag) {\n          tag.ctx = context.id;\n        }\n      }); // reconcile placeholders\n\n      var childPhs = context.placeholders;\n      childPhs.forEach(function (values, key) {\n        var phs = _this.placeholders.get(key);\n\n        if (!phs) {\n          _this.placeholders.set(key, values);\n\n          return;\n        } // try to find matching template...\n\n\n        var tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n\n        if (tmplIdx >= 0) {\n          // ... if found - replace it with nested template content\n          var isCloseTag = key.startsWith('CLOSE');\n          var isTemplateTag = key.endsWith('NG-TEMPLATE');\n\n          if (isTemplateTag) {\n            // current template's content is placed before or after\n            // parent template tag, depending on the open/close atrribute\n            phs.splice.apply(phs, tslib_1.__spread([tmplIdx + (isCloseTag ? 0 : 1), 0], values));\n          } else {\n            var idx = isCloseTag ? values.length - 1 : 0;\n            values[idx].tmpl = phs[tmplIdx];\n            phs.splice.apply(phs, tslib_1.__spread([tmplIdx, 1], values));\n          }\n        } else {\n          // ... otherwise just append content to placeholder value\n          phs.push.apply(phs, tslib_1.__spread(values));\n        }\n\n        _this.placeholders.set(key, phs);\n      });\n      this._unresolvedCtxCount--;\n    };\n\n    return I18nContext;\n  }();\n\n  exports.I18nContext = I18nContext; //\n  // Helper methods\n  //\n\n  function wrap(symbol, index, contextId, closed) {\n    var state = closed ? '/' : '';\n    return util_1.wrapI18nPlaceholder(\"\" + state + symbol + index, contextId);\n  }\n\n  function wrapTag(symbol, _a, closed) {\n    var index = _a.index,\n        ctx = _a.ctx,\n        isVoid = _a.isVoid;\n    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) : wrap(symbol, index, ctx, closed);\n  }\n\n  function findTemplateFn(ctx, templateIndex) {\n    return function (token) {\n      return typeof token === 'object' && token.type === TagType.TEMPLATE && token.index === templateIndex && token.ctx === ctx;\n    };\n  }\n\n  function serializePlaceholderValue(value) {\n    var element = function element(data, closed) {\n      return wrapTag('#', data, closed);\n    };\n\n    var template = function template(data, closed) {\n      return wrapTag('*', data, closed);\n    };\n\n    var projection = function projection(data, closed) {\n      return wrapTag('!', data, closed);\n    };\n\n    switch (value.type) {\n      case TagType.ELEMENT:\n        // close element tag\n        if (value.closed) {\n          return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n        } // open element tag that also initiates a template\n\n\n        if (value.tmpl) {\n          return template(value.tmpl) + element(value) + (value.isVoid ? template(value.tmpl, true) : '');\n        }\n\n        return element(value);\n\n      case TagType.TEMPLATE:\n        return template(value, value.closed);\n\n      default:\n        return value;\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler/src/render3/view/i18n/context.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST} from '../../../expression_parser/ast';\nimport * as i18n from '../../../i18n/i18n_ast';\nimport * as o from '../../../output/output_ast';\n\nimport {assembleBoundTextPlaceholders, getSeqNumberGenerator, updatePlaceholderMap, wrapI18nPlaceholder} from './util';\n\nenum TagType {\n  ELEMENT,\n  TEMPLATE,\n}\n\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\nfunction setupRegistry() {\n  return {getUniqueId: getSeqNumberGenerator(), icus: new Map<string, any[]>()};\n}\n\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nestng level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\nexport class I18nContext {\n  public readonly id: number;\n  public bindings = new Set<AST>();\n  public placeholders = new Map<string, any[]>();\n  public isEmitted: boolean = false;\n\n  private _registry!: any;\n  private _unresolvedCtxCount: number = 0;\n\n  constructor(\n      readonly index: number, readonly ref: o.ReadVarExpr, readonly level: number = 0,\n      readonly templateIndex: number|null = null, readonly meta: i18n.I18nMeta,\n      private registry?: any) {\n    this._registry = registry || setupRegistry();\n    this.id = this._registry.getUniqueId();\n  }\n\n  private appendTag(type: TagType, node: i18n.TagPlaceholder, index: number, closed?: boolean) {\n    if (node.isVoid && closed) {\n      return;  // ignore \"close\" for void tags\n    }\n    const ph = node.isVoid || !closed ? node.startName : node.closeName;\n    const content = {type, index, ctx: this.id, isVoid: node.isVoid, closed};\n    updatePlaceholderMap(this.placeholders, ph, content);\n  }\n\n  get icus() {\n    return this._registry.icus;\n  }\n  get isRoot() {\n    return this.level === 0;\n  }\n  get isResolved() {\n    return this._unresolvedCtxCount === 0;\n  }\n\n  getSerializedPlaceholders() {\n    const result = new Map<string, any[]>();\n    this.placeholders.forEach(\n        (values, key) => result.set(key, values.map(serializePlaceholderValue)));\n    return result;\n  }\n\n  // public API to accumulate i18n-related content\n  appendBinding(binding: AST) {\n    this.bindings.add(binding);\n  }\n  appendIcu(name: string, ref: o.Expression) {\n    updatePlaceholderMap(this._registry.icus, name, ref);\n  }\n  appendBoundText(node: i18n.I18nMeta) {\n    const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n    phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));\n  }\n  appendTemplate(node: i18n.I18nMeta, index: number) {\n    // add open and close tags at the same time,\n    // since we process nested templates separately\n    this.appendTag(TagType.TEMPLATE, node as i18n.TagPlaceholder, index, false);\n    this.appendTag(TagType.TEMPLATE, node as i18n.TagPlaceholder, index, true);\n    this._unresolvedCtxCount++;\n  }\n  appendElement(node: i18n.I18nMeta, index: number, closed?: boolean) {\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, closed);\n  }\n  appendProjection(node: i18n.I18nMeta, index: number) {\n    // Add open and close tags at the same time, since `<ng-content>` has no content,\n    // so when we come across `<ng-content>` we can register both open and close tags.\n    // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\n    // regular element tag placeholders, so we generate element placeholders for both types.\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, false);\n    this.appendTag(TagType.ELEMENT, node as i18n.TagPlaceholder, index, true);\n  }\n\n  /**\n   * Generates an instance of a child context based on the root one,\n   * when we enter a nested template within I18n section.\n   *\n   * @param index Instruction index of corresponding i18nStart, which initiates this context\n   * @param templateIndex Instruction index of a template which this context belongs to\n   * @param meta Meta information (id, meaning, description, etc) associated with this context\n   *\n   * @returns I18nContext instance\n   */\n  forkChildContext(index: number, templateIndex: number, meta: i18n.I18nMeta) {\n    return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n  }\n\n  /**\n   * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n   *\n   * @param context Child I18nContext instance to be reconciled with parent context.\n   */\n  reconcileChildContext(context: I18nContext) {\n    // set the right context id for open and close\n    // template tags, so we can use it as sub-block ids\n    ['start', 'close'].forEach((op: string) => {\n      const key = (context.meta as any)[`${op}Name`];\n      const phs = this.placeholders.get(key) || [];\n      const tag = phs.find(findTemplateFn(this.id, context.templateIndex));\n      if (tag) {\n        tag.ctx = context.id;\n      }\n    });\n\n    // reconcile placeholders\n    const childPhs = context.placeholders;\n    childPhs.forEach((values: any[], key: string) => {\n      const phs = this.placeholders.get(key);\n      if (!phs) {\n        this.placeholders.set(key, values);\n        return;\n      }\n      // try to find matching template...\n      const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n      if (tmplIdx >= 0) {\n        // ... if found - replace it with nested template content\n        const isCloseTag = key.startsWith('CLOSE');\n        const isTemplateTag = key.endsWith('NG-TEMPLATE');\n        if (isTemplateTag) {\n          // current template's content is placed before or after\n          // parent template tag, depending on the open/close atrribute\n          phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);\n        } else {\n          const idx = isCloseTag ? values.length - 1 : 0;\n          values[idx].tmpl = phs[tmplIdx];\n          phs.splice(tmplIdx, 1, ...values);\n        }\n      } else {\n        // ... otherwise just append content to placeholder value\n        phs.push(...values);\n      }\n      this.placeholders.set(key, phs);\n    });\n    this._unresolvedCtxCount--;\n  }\n}\n\n//\n// Helper methods\n//\n\nfunction wrap(symbol: string, index: number, contextId: number, closed?: boolean): string {\n  const state = closed ? '/' : '';\n  return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);\n}\n\nfunction wrapTag(symbol: string, {index, ctx, isVoid}: any, closed?: boolean): string {\n  return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\n                  wrap(symbol, index, ctx, closed);\n}\n\nfunction findTemplateFn(ctx: number, templateIndex: number|null) {\n  return (token: any) => typeof token === 'object' && token.type === TagType.TEMPLATE &&\n      token.index === templateIndex && token.ctx === ctx;\n}\n\nfunction serializePlaceholderValue(value: any): string {\n  const element = (data: any, closed?: boolean) => wrapTag('#', data, closed);\n  const template = (data: any, closed?: boolean) => wrapTag('*', data, closed);\n  const projection = (data: any, closed?: boolean) => wrapTag('!', data, closed);\n\n  switch (value.type) {\n    case TagType.ELEMENT:\n      // close element tag\n      if (value.closed) {\n        return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n      }\n      // open element tag that also initiates a template\n      if (value.tmpl) {\n        return template(value.tmpl) + element(value) +\n            (value.isVoid ? template(value.tmpl, true) : '');\n      }\n      return element(value);\n\n    case TagType.TEMPLATE:\n      return template(value, value.closed);\n\n    default:\n      return value;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}