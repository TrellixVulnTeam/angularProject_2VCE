{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/tsc_plugin\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/core\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/incremental\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/shims\", \"@angular/compiler-cli/src/ngtsc/typecheck/api\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/augmented_program\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NgTscPlugin = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var core_1 = require(\"@angular/compiler-cli/src/ngtsc/core\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var incremental_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var shims_1 = require(\"@angular/compiler-cli/src/ngtsc/shims\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/api\");\n\n  var augmented_program_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/augmented_program\");\n  /**\n   * A plugin for `tsc_wrapped` which allows Angular compilation from a plain `ts_library`.\n   */\n\n\n  var NgTscPlugin =\n  /** @class */\n  function () {\n    function NgTscPlugin(ngOptions) {\n      this.ngOptions = ngOptions;\n      this.name = 'ngtsc';\n      this.options = null;\n      this.host = null;\n      this._compiler = null;\n      file_system_1.setFileSystem(new file_system_1.NodeJSFileSystem());\n    }\n\n    Object.defineProperty(NgTscPlugin.prototype, \"compiler\", {\n      get: function get() {\n        if (this._compiler === null) {\n          throw new Error('Lifecycle error: setupCompilation() must be called first.');\n        }\n\n        return this._compiler;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    NgTscPlugin.prototype.wrapHost = function (host, inputFiles, options) {\n      // TODO(alxhub): Eventually the `wrapHost()` API will accept the old `ts.Program` (if one is\n      // available). When it does, its `ts.SourceFile`s need to be re-tagged to enable proper\n      // incremental compilation.\n      this.options = tslib_1.__assign(tslib_1.__assign({}, this.ngOptions), options);\n      this.host = core_1.NgCompilerHost.wrap(host, inputFiles, this.options,\n      /* oldProgram */\n      null);\n      return this.host;\n    };\n\n    NgTscPlugin.prototype.setupCompilation = function (program, oldProgram) {\n      // TODO(alxhub): we provide a `PerfRecorder` to the compiler, but because we're not driving the\n      // compilation, the information captured within it is incomplete, and may not include timings\n      // for phases such as emit.\n      //\n      // Additionally, nothing actually captures the perf results here, so recording stats at all is\n      // somewhat moot for now :)\n      var perfRecorder = perf_1.ActivePerfRecorder.zeroedToNow();\n\n      if (this.host === null || this.options === null) {\n        throw new Error('Lifecycle error: setupCompilation() before wrapHost().');\n      }\n\n      this.host.postProgramCreationCleanup();\n      shims_1.untagAllTsFiles(program);\n      var typeCheckStrategy = new augmented_program_1.ReusedProgramStrategy(program, this.host, this.options, this.host.shimExtensionPrefixes);\n      var strategy = new incremental_1.PatchedProgramIncrementalBuildStrategy();\n      var oldDriver = oldProgram !== undefined ? strategy.getIncrementalDriver(oldProgram) : null;\n      var ticket;\n      var modifiedResourceFiles = undefined;\n\n      if (this.host.getModifiedResourceFiles !== undefined) {\n        modifiedResourceFiles = this.host.getModifiedResourceFiles();\n      }\n\n      if (modifiedResourceFiles === undefined) {\n        modifiedResourceFiles = new Set();\n      }\n\n      if (oldProgram === undefined || oldDriver === null) {\n        ticket = core_1.freshCompilationTicket(program, this.options, strategy, typeCheckStrategy, perfRecorder,\n        /* enableTemplateTypeChecker */\n        false,\n        /* usePoisonedData */\n        false);\n      } else {\n        strategy.toNextBuildStrategy().getIncrementalDriver(oldProgram);\n        ticket = core_1.incrementalFromDriverTicket(oldProgram, oldDriver, program, this.options, strategy, typeCheckStrategy, modifiedResourceFiles, perfRecorder, false, false);\n      }\n\n      this._compiler = core_1.NgCompiler.fromTicket(ticket, this.host);\n      return {\n        ignoreForDiagnostics: this._compiler.ignoreForDiagnostics,\n        ignoreForEmit: this._compiler.ignoreForEmit\n      };\n    };\n\n    NgTscPlugin.prototype.getDiagnostics = function (file) {\n      if (file === undefined) {\n        return this.compiler.getDiagnostics();\n      }\n\n      return this.compiler.getDiagnosticsForFile(file, api_1.OptimizeFor.WholeProgram);\n    };\n\n    NgTscPlugin.prototype.getOptionDiagnostics = function () {\n      return this.compiler.getOptionDiagnostics();\n    };\n\n    NgTscPlugin.prototype.getNextProgram = function () {\n      return this.compiler.getNextProgram();\n    };\n\n    NgTscPlugin.prototype.createTransformers = function () {\n      // The plugin consumer doesn't know about our perf tracing system, so we consider the emit phase\n      // as beginning now.\n      this.compiler.perfRecorder.phase(perf_1.PerfPhase.TypeScriptEmit);\n      return this.compiler.prepareEmit().transformers;\n    };\n\n    return NgTscPlugin;\n  }();\n\n  exports.NgTscPlugin = NgTscPlugin;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/ngtsc/tsc_plugin.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {CompilationTicket, freshCompilationTicket, incrementalFromDriverTicket, NgCompiler, NgCompilerHost} from './core';\nimport {NgCompilerOptions, UnifiedModulesHost} from './core/api';\nimport {NodeJSFileSystem, setFileSystem} from './file_system';\nimport {PatchedProgramIncrementalBuildStrategy} from './incremental';\nimport {ActivePerfRecorder, NOOP_PERF_RECORDER, PerfPhase} from './perf';\nimport {untagAllTsFiles} from './shims';\nimport {OptimizeFor} from './typecheck/api';\nimport {ReusedProgramStrategy} from './typecheck/src/augmented_program';\n\n// The following is needed to fix a the chicken-and-egg issue where the sync (into g3) script will\n// refuse to accept this file unless the following string appears:\n// import * as plugin from '@bazel/typescript/internal/tsc_wrapped/plugin_api';\n\n/**\n * A `ts.CompilerHost` which also returns a list of input files, out of which the `ts.Program`\n * should be created.\n *\n * Currently mirrored from @bazel/typescript/internal/tsc_wrapped/plugin_api (with the naming of\n * `fileNameToModuleName` corrected).\n */\ninterface PluginCompilerHost extends ts.CompilerHost, Partial<UnifiedModulesHost> {\n  readonly inputFiles: ReadonlyArray<string>;\n}\n\n/**\n * Mirrors the plugin interface from tsc_wrapped which is currently under active development. To\n * enable progress to be made in parallel, the upstream interface isn't implemented directly.\n * Instead, `TscPlugin` here is structurally assignable to what tsc_wrapped expects.\n */\ninterface TscPlugin {\n  readonly name: string;\n\n  wrapHost(\n      host: ts.CompilerHost&Partial<UnifiedModulesHost>, inputFiles: ReadonlyArray<string>,\n      options: ts.CompilerOptions): PluginCompilerHost;\n\n  setupCompilation(program: ts.Program, oldProgram?: ts.Program): {\n    ignoreForDiagnostics: Set<ts.SourceFile>,\n    ignoreForEmit: Set<ts.SourceFile>,\n  };\n\n  getDiagnostics(file?: ts.SourceFile): ts.Diagnostic[];\n\n  getOptionDiagnostics(): ts.Diagnostic[];\n\n  getNextProgram(): ts.Program;\n\n  createTransformers(): ts.CustomTransformers;\n}\n\n/**\n * A plugin for `tsc_wrapped` which allows Angular compilation from a plain `ts_library`.\n */\nexport class NgTscPlugin implements TscPlugin {\n  name = 'ngtsc';\n\n  private options: NgCompilerOptions|null = null;\n  private host: NgCompilerHost|null = null;\n  private _compiler: NgCompiler|null = null;\n\n  get compiler(): NgCompiler {\n    if (this._compiler === null) {\n      throw new Error('Lifecycle error: setupCompilation() must be called first.');\n    }\n    return this._compiler;\n  }\n\n  constructor(private ngOptions: {}) {\n    setFileSystem(new NodeJSFileSystem());\n  }\n\n  wrapHost(\n      host: ts.CompilerHost&Partial<UnifiedModulesHost>, inputFiles: readonly string[],\n      options: ts.CompilerOptions): PluginCompilerHost {\n    // TODO(alxhub): Eventually the `wrapHost()` API will accept the old `ts.Program` (if one is\n    // available). When it does, its `ts.SourceFile`s need to be re-tagged to enable proper\n    // incremental compilation.\n    this.options = {...this.ngOptions, ...options} as NgCompilerOptions;\n    this.host = NgCompilerHost.wrap(host, inputFiles, this.options, /* oldProgram */ null);\n    return this.host;\n  }\n\n  setupCompilation(program: ts.Program, oldProgram?: ts.Program): {\n    ignoreForDiagnostics: Set<ts.SourceFile>,\n    ignoreForEmit: Set<ts.SourceFile>,\n  } {\n    // TODO(alxhub): we provide a `PerfRecorder` to the compiler, but because we're not driving the\n    // compilation, the information captured within it is incomplete, and may not include timings\n    // for phases such as emit.\n    //\n    // Additionally, nothing actually captures the perf results here, so recording stats at all is\n    // somewhat moot for now :)\n    const perfRecorder = ActivePerfRecorder.zeroedToNow();\n    if (this.host === null || this.options === null) {\n      throw new Error('Lifecycle error: setupCompilation() before wrapHost().');\n    }\n    this.host.postProgramCreationCleanup();\n    untagAllTsFiles(program);\n    const typeCheckStrategy = new ReusedProgramStrategy(\n        program, this.host, this.options, this.host.shimExtensionPrefixes);\n    const strategy = new PatchedProgramIncrementalBuildStrategy();\n    const oldDriver = oldProgram !== undefined ? strategy.getIncrementalDriver(oldProgram) : null;\n    let ticket: CompilationTicket;\n\n    let modifiedResourceFiles: Set<string>|undefined = undefined;\n    if (this.host.getModifiedResourceFiles !== undefined) {\n      modifiedResourceFiles = this.host.getModifiedResourceFiles();\n    }\n    if (modifiedResourceFiles === undefined) {\n      modifiedResourceFiles = new Set<string>();\n    }\n\n    if (oldProgram === undefined || oldDriver === null) {\n      ticket = freshCompilationTicket(\n          program, this.options, strategy, typeCheckStrategy, perfRecorder,\n          /* enableTemplateTypeChecker */ false, /* usePoisonedData */ false);\n    } else {\n      strategy.toNextBuildStrategy().getIncrementalDriver(oldProgram);\n      ticket = incrementalFromDriverTicket(\n          oldProgram, oldDriver, program, this.options, strategy, typeCheckStrategy,\n          modifiedResourceFiles, perfRecorder, false, false);\n    }\n    this._compiler = NgCompiler.fromTicket(ticket, this.host);\n    return {\n      ignoreForDiagnostics: this._compiler.ignoreForDiagnostics,\n      ignoreForEmit: this._compiler.ignoreForEmit,\n    };\n  }\n\n  getDiagnostics(file?: ts.SourceFile): ts.Diagnostic[] {\n    if (file === undefined) {\n      return this.compiler.getDiagnostics();\n    }\n    return this.compiler.getDiagnosticsForFile(file, OptimizeFor.WholeProgram);\n  }\n\n  getOptionDiagnostics(): ts.Diagnostic[] {\n    return this.compiler.getOptionDiagnostics();\n  }\n\n  getNextProgram(): ts.Program {\n    return this.compiler.getNextProgram();\n  }\n\n  createTransformers(): ts.CustomTransformers {\n    // The plugin consumer doesn't know about our perf tracing system, so we consider the emit phase\n    // as beginning now.\n    this.compiler.perfRecorder.phase(PerfPhase.TypeScriptEmit);\n    return this.compiler.prepareEmit().transformers;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}