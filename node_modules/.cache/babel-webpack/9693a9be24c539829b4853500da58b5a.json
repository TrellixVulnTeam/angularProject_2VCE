{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar SourceNode = require(\"source-map\").SourceNode;\n\nvar SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nvar applySourceMap = function applySourceMap(sourceNode, sourceMapConsumer, sourceFile, removeGeneratedCodeForSourceFile) {\n  // The following notations are used to name stuff:\n  // Left <------------> Middle <-------------------> Right\n  // Input arguments:\n  //        sourceNode                                       - Code mapping from Left to Middle\n  //                   sourceFile                            - Name of a Middle file\n  //                              sourceMapConsumer          - Code mapping from Middle to Right\n  // Variables:\n  //           l2m                      m2r\n  // Left <-----------------------------------------> Right\n  // Variables:\n  //                       l2r\n  var l2rResult = new SourceNode();\n  var l2rOutput = [];\n  var middleSourceContents = {};\n  var m2rMappingsByLine = {};\n  var rightSourceContentsSet = {};\n  var rightSourceContentsLines = {}; // Store all mappings by generated line\n\n  sourceMapConsumer.eachMapping(function (mapping) {\n    (m2rMappingsByLine[mapping.generatedLine] = m2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n  }, null, SourceMapConsumer.GENERATED_ORDER); // Store all source contents\n\n  sourceNode.walkSourceContents(function (source, content) {\n    middleSourceContents[\"$\" + source] = content;\n  });\n  var middleSource = middleSourceContents[\"$\" + sourceFile];\n  var middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined; // Walk all left to middle mappings\n\n  sourceNode.walk(function (chunk, middleMapping) {\n    // Find a mapping from middle to right\n    if (middleMapping.source === sourceFile && middleMapping.line && m2rMappingsByLine[middleMapping.line]) {\n      var m2rBestFit;\n      var m2rMappings = m2rMappingsByLine[middleMapping.line]; // Note: if this becomes a performance problem, use binary search\n\n      for (var i = 0; i < m2rMappings.length; i++) {\n        if (m2rMappings[i].generatedColumn <= middleMapping.column) {\n          m2rBestFit = m2rMappings[i];\n        }\n      }\n\n      if (m2rBestFit) {\n        var allowMiddleName = false;\n        var middleLine;\n        var rightSourceContent;\n        var rightSourceContentLines;\n        var rightSource = m2rBestFit.source; // Check if we have middle and right source for this mapping\n        // Then we could have an \"identify\" mapping\n\n        if (middleSourceLines && rightSource && (middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) && ((rightSourceContentLines = rightSourceContentsLines[rightSource]) || (rightSourceContent = sourceMapConsumer.sourceContentFor(rightSource, true)))) {\n          if (!rightSourceContentLines) {\n            rightSourceContentLines = rightSourceContentsLines[rightSource] = rightSourceContent.split(\"\\n\");\n          }\n\n          var rightLine = rightSourceContentLines[m2rBestFit.originalLine - 1];\n\n          if (rightLine) {\n            var offset = middleMapping.column - m2rBestFit.generatedColumn;\n\n            if (offset > 0) {\n              var middlePart = middleLine.slice(m2rBestFit.generatedColumn, middleMapping.column);\n              var rightPart = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + offset);\n\n              if (middlePart === rightPart) {\n                // When original and generated code is equal we assume we have an \"identity\" mapping\n                // In this case we can offset the original position\n                m2rBestFit = Object.assign({}, m2rBestFit, {\n                  originalColumn: m2rBestFit.originalColumn + offset,\n                  generatedColumn: middleMapping.column,\n                  name: undefined\n                });\n              }\n            }\n\n            if (!m2rBestFit.name && middleMapping.name) {\n              allowMiddleName = rightLine.slice(m2rBestFit.originalColumn, m2rBestFit.originalColumn + middleMapping.name.length) === middleMapping.name;\n            }\n          }\n        } // Construct a left to right node from the found middle to right mapping\n\n\n        var _source = m2rBestFit.source; // Workaround for bug in source-map\n        // null sources are incorrectly normalized to \".\"\n\n        if (_source && _source !== \".\") {\n          l2rOutput.push(new SourceNode(m2rBestFit.originalLine, m2rBestFit.originalColumn, _source, chunk, allowMiddleName ? middleMapping.name : m2rBestFit.name)); // Set the source contents once\n\n          if (!(\"$\" + _source in rightSourceContentsSet)) {\n            rightSourceContentsSet[\"$\" + _source] = true;\n            var sourceContent = sourceMapConsumer.sourceContentFor(_source, true);\n\n            if (sourceContent) {\n              l2rResult.setSourceContent(_source, sourceContent);\n            }\n          }\n\n          return;\n        }\n      }\n    }\n\n    if (removeGeneratedCodeForSourceFile && middleMapping.source === sourceFile || !middleMapping.source) {\n      // Construct a left to middle node with only generated code\n      // Because user do not want mappings to middle sources\n      // Or this chunk has no mapping\n      l2rOutput.push(chunk);\n      return;\n    } // Construct a left to middle node\n\n\n    var source = middleMapping.source;\n    l2rOutput.push(new SourceNode(middleMapping.line, middleMapping.column, source, chunk, middleMapping.name));\n\n    if (\"$\" + source in middleSourceContents) {\n      if (!(\"$\" + source in rightSourceContentsSet)) {\n        l2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n        delete middleSourceContents[\"$\" + source];\n      }\n    }\n  }); // Put output into the resulting SourceNode\n\n  l2rResult.add(l2rOutput);\n  return l2rResult;\n};\n\nmodule.exports = applySourceMap;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/webpack-sources/lib/applySourceMap.js"],"names":["SourceNode","require","SourceMapConsumer","applySourceMap","sourceNode","sourceMapConsumer","sourceFile","removeGeneratedCodeForSourceFile","l2rResult","l2rOutput","middleSourceContents","m2rMappingsByLine","rightSourceContentsSet","rightSourceContentsLines","eachMapping","mapping","generatedLine","push","GENERATED_ORDER","walkSourceContents","source","content","middleSource","middleSourceLines","split","undefined","walk","chunk","middleMapping","line","m2rBestFit","m2rMappings","i","length","generatedColumn","column","allowMiddleName","middleLine","rightSourceContent","rightSourceContentLines","rightSource","sourceContentFor","rightLine","originalLine","offset","middlePart","slice","rightPart","originalColumn","Object","assign","name","sourceContent","setSourceContent","add","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst SourceNode = require(\"source-map\").SourceNode;\nconst SourceMapConsumer = require(\"source-map\").SourceMapConsumer;\n\nconst applySourceMap = function (\n\tsourceNode,\n\tsourceMapConsumer,\n\tsourceFile,\n\tremoveGeneratedCodeForSourceFile\n) {\n\t// The following notations are used to name stuff:\n\t// Left <------------> Middle <-------------------> Right\n\t// Input arguments:\n\t//        sourceNode                                       - Code mapping from Left to Middle\n\t//                   sourceFile                            - Name of a Middle file\n\t//                              sourceMapConsumer          - Code mapping from Middle to Right\n\t// Variables:\n\t//           l2m                      m2r\n\t// Left <-----------------------------------------> Right\n\t// Variables:\n\t//                       l2r\n\n\tconst l2rResult = new SourceNode();\n\tconst l2rOutput = [];\n\n\tconst middleSourceContents = {};\n\n\tconst m2rMappingsByLine = {};\n\n\tconst rightSourceContentsSet = {};\n\tconst rightSourceContentsLines = {};\n\n\t// Store all mappings by generated line\n\tsourceMapConsumer.eachMapping(\n\t\tfunction (mapping) {\n\t\t\t(m2rMappingsByLine[mapping.generatedLine] =\n\t\t\t\tm2rMappingsByLine[mapping.generatedLine] || []).push(mapping);\n\t\t},\n\t\tnull,\n\t\tSourceMapConsumer.GENERATED_ORDER\n\t);\n\n\t// Store all source contents\n\tsourceNode.walkSourceContents(function (source, content) {\n\t\tmiddleSourceContents[\"$\" + source] = content;\n\t});\n\n\tconst middleSource = middleSourceContents[\"$\" + sourceFile];\n\tconst middleSourceLines = middleSource ? middleSource.split(\"\\n\") : undefined;\n\n\t// Walk all left to middle mappings\n\tsourceNode.walk(function (chunk, middleMapping) {\n\t\t// Find a mapping from middle to right\n\t\tif (\n\t\t\tmiddleMapping.source === sourceFile &&\n\t\t\tmiddleMapping.line &&\n\t\t\tm2rMappingsByLine[middleMapping.line]\n\t\t) {\n\t\t\tlet m2rBestFit;\n\t\t\tconst m2rMappings = m2rMappingsByLine[middleMapping.line];\n\t\t\t// Note: if this becomes a performance problem, use binary search\n\t\t\tfor (let i = 0; i < m2rMappings.length; i++) {\n\t\t\t\tif (m2rMappings[i].generatedColumn <= middleMapping.column) {\n\t\t\t\t\tm2rBestFit = m2rMappings[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m2rBestFit) {\n\t\t\t\tlet allowMiddleName = false;\n\t\t\t\tlet middleLine;\n\t\t\t\tlet rightSourceContent;\n\t\t\t\tlet rightSourceContentLines;\n\t\t\t\tconst rightSource = m2rBestFit.source;\n\t\t\t\t// Check if we have middle and right source for this mapping\n\t\t\t\t// Then we could have an \"identify\" mapping\n\t\t\t\tif (\n\t\t\t\t\tmiddleSourceLines &&\n\t\t\t\t\trightSource &&\n\t\t\t\t\t(middleLine = middleSourceLines[m2rBestFit.generatedLine - 1]) &&\n\t\t\t\t\t((rightSourceContentLines = rightSourceContentsLines[rightSource]) ||\n\t\t\t\t\t\t(rightSourceContent = sourceMapConsumer.sourceContentFor(\n\t\t\t\t\t\t\trightSource,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t)))\n\t\t\t\t) {\n\t\t\t\t\tif (!rightSourceContentLines) {\n\t\t\t\t\t\trightSourceContentLines = rightSourceContentsLines[\n\t\t\t\t\t\t\trightSource\n\t\t\t\t\t\t] = rightSourceContent.split(\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\tconst rightLine =\n\t\t\t\t\t\trightSourceContentLines[m2rBestFit.originalLine - 1];\n\t\t\t\t\tif (rightLine) {\n\t\t\t\t\t\tconst offset = middleMapping.column - m2rBestFit.generatedColumn;\n\t\t\t\t\t\tif (offset > 0) {\n\t\t\t\t\t\t\tconst middlePart = middleLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.generatedColumn,\n\t\t\t\t\t\t\t\tmiddleMapping.column\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst rightPart = rightLine.slice(\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + offset\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (middlePart === rightPart) {\n\t\t\t\t\t\t\t\t// When original and generated code is equal we assume we have an \"identity\" mapping\n\t\t\t\t\t\t\t\t// In this case we can offset the original position\n\t\t\t\t\t\t\t\tm2rBestFit = Object.assign({}, m2rBestFit, {\n\t\t\t\t\t\t\t\t\toriginalColumn: m2rBestFit.originalColumn + offset,\n\t\t\t\t\t\t\t\t\tgeneratedColumn: middleMapping.column,\n\t\t\t\t\t\t\t\t\tname: undefined\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!m2rBestFit.name && middleMapping.name) {\n\t\t\t\t\t\t\tallowMiddleName =\n\t\t\t\t\t\t\t\trightLine.slice(\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\t\t\tm2rBestFit.originalColumn + middleMapping.name.length\n\t\t\t\t\t\t\t\t) === middleMapping.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Construct a left to right node from the found middle to right mapping\n\t\t\t\tlet source = m2rBestFit.source;\n\t\t\t\t// Workaround for bug in source-map\n\t\t\t\t// null sources are incorrectly normalized to \".\"\n\t\t\t\tif (source && source !== \".\") {\n\t\t\t\t\tl2rOutput.push(\n\t\t\t\t\t\tnew SourceNode(\n\t\t\t\t\t\t\tm2rBestFit.originalLine,\n\t\t\t\t\t\t\tm2rBestFit.originalColumn,\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tallowMiddleName ? middleMapping.name : m2rBestFit.name\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\n\t\t\t\t\t// Set the source contents once\n\t\t\t\t\tif (!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\t\t\trightSourceContentsSet[\"$\" + source] = true;\n\t\t\t\t\t\tconst sourceContent = sourceMapConsumer.sourceContentFor(\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (sourceContent) {\n\t\t\t\t\t\t\tl2rResult.setSourceContent(source, sourceContent);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (\n\t\t\t(removeGeneratedCodeForSourceFile &&\n\t\t\t\tmiddleMapping.source === sourceFile) ||\n\t\t\t!middleMapping.source\n\t\t) {\n\t\t\t// Construct a left to middle node with only generated code\n\t\t\t// Because user do not want mappings to middle sources\n\t\t\t// Or this chunk has no mapping\n\t\t\tl2rOutput.push(chunk);\n\t\t\treturn;\n\t\t}\n\n\t\t// Construct a left to middle node\n\t\tconst source = middleMapping.source;\n\t\tl2rOutput.push(\n\t\t\tnew SourceNode(\n\t\t\t\tmiddleMapping.line,\n\t\t\t\tmiddleMapping.column,\n\t\t\t\tsource,\n\t\t\t\tchunk,\n\t\t\t\tmiddleMapping.name\n\t\t\t)\n\t\t);\n\t\tif (\"$\" + source in middleSourceContents) {\n\t\t\tif (!(\"$\" + source in rightSourceContentsSet)) {\n\t\t\t\tl2rResult.setSourceContent(source, middleSourceContents[\"$\" + source]);\n\t\t\t\tdelete middleSourceContents[\"$\" + source];\n\t\t\t}\n\t\t}\n\t});\n\n\t// Put output into the resulting SourceNode\n\tl2rResult.add(l2rOutput);\n\treturn l2rResult;\n};\n\nmodule.exports = applySourceMap;\n"]},"metadata":{},"sourceType":"script"}