{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/transform/src/trait\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Trait = exports.TraitState = void 0;\n  var TraitState;\n\n  (function (TraitState) {\n    /**\n     * Pending traits are freshly created and have never been analyzed.\n     */\n    TraitState[TraitState[\"Pending\"] = 0] = \"Pending\";\n    /**\n     * Analyzed traits have successfully been analyzed, but are pending resolution.\n     */\n\n    TraitState[TraitState[\"Analyzed\"] = 1] = \"Analyzed\";\n    /**\n     * Resolved traits have successfully been analyzed and resolved and are ready for compilation.\n     */\n\n    TraitState[TraitState[\"Resolved\"] = 2] = \"Resolved\";\n    /**\n     * Skipped traits are no longer considered for compilation.\n     */\n\n    TraitState[TraitState[\"Skipped\"] = 3] = \"Skipped\";\n  })(TraitState = exports.TraitState || (exports.TraitState = {}));\n  /**\n   * The value side of `Trait` exposes a helper to create a `Trait` in a pending state (by delegating\n   * to `TraitImpl`).\n   */\n\n\n  exports.Trait = {\n    pending: function pending(handler, detected) {\n      return TraitImpl.pending(handler, detected);\n    }\n  };\n  /**\n   * An implementation of the `Trait` type which transitions safely between the various\n   * `TraitState`s.\n   */\n\n  var TraitImpl =\n  /** @class */\n  function () {\n    function TraitImpl(handler, detected) {\n      this.state = TraitState.Pending;\n      this.analysis = null;\n      this.symbol = null;\n      this.resolution = null;\n      this.analysisDiagnostics = null;\n      this.resolveDiagnostics = null;\n      this.handler = handler;\n      this.detected = detected;\n    }\n\n    TraitImpl.prototype.toAnalyzed = function (analysis, diagnostics, symbol) {\n      // Only pending traits can be analyzed.\n      this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n      this.analysis = analysis;\n      this.analysisDiagnostics = diagnostics;\n      this.symbol = symbol;\n      this.state = TraitState.Analyzed;\n      return this;\n    };\n\n    TraitImpl.prototype.toResolved = function (resolution, diagnostics) {\n      // Only analyzed traits can be resolved.\n      this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n\n      if (this.analysis === null) {\n        throw new Error(\"Cannot transition an Analyzed trait with a null analysis to Resolved\");\n      }\n\n      this.resolution = resolution;\n      this.state = TraitState.Resolved;\n      this.resolveDiagnostics = diagnostics;\n      return this;\n    };\n\n    TraitImpl.prototype.toSkipped = function () {\n      // Only pending traits can be skipped.\n      this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n      this.state = TraitState.Skipped;\n      return this;\n    };\n    /**\n     * Verifies that the trait is currently in one of the `allowedState`s.\n     *\n     * If correctly used, the `Trait` type and transition methods prevent illegal transitions from\n     * occurring. However, if a reference to the `TraitImpl` instance typed with the previous\n     * interface is retained after calling one of its transition methods, it will allow for illegal\n     * transitions to take place. Hence, this assertion provides a little extra runtime protection.\n     */\n\n\n    TraitImpl.prototype.assertTransitionLegal = function (allowedState, transitionTo) {\n      if (!(this.state === allowedState)) {\n        throw new Error(\"Assertion failure: cannot transition from \" + TraitState[this.state] + \" to \" + TraitState[transitionTo] + \".\");\n      }\n    };\n    /**\n     * Construct a new `TraitImpl` in the pending state.\n     */\n\n\n    TraitImpl.pending = function (handler, detected) {\n      return new TraitImpl(handler, detected);\n    };\n\n    return TraitImpl;\n  }();\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/trait.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\nimport {SemanticSymbol} from '../../incremental/semantic_graph';\nimport {DecoratorHandler, DetectResult} from './api';\n\nexport enum TraitState {\n  /**\n   * Pending traits are freshly created and have never been analyzed.\n   */\n  Pending,\n\n  /**\n   * Analyzed traits have successfully been analyzed, but are pending resolution.\n   */\n  Analyzed,\n\n  /**\n   * Resolved traits have successfully been analyzed and resolved and are ready for compilation.\n   */\n  Resolved,\n\n  /**\n   * Skipped traits are no longer considered for compilation.\n   */\n  Skipped,\n}\n\n/**\n * An Ivy aspect added to a class (for example, the compilation of a component definition).\n *\n * Traits are created when a `DecoratorHandler` matches a class. Each trait begins in a pending\n * state and undergoes transitions as compilation proceeds through the various steps.\n *\n * In practice, traits are instances of the private class `TraitImpl` declared below. Through the\n * various interfaces included in this union type, the legal API of a trait in any given state is\n * represented in the type system. This includes any possible transitions from one type to the next.\n *\n * This not only simplifies the implementation, but ensures traits are monomorphic objects as\n * they're all just \"views\" in the type system of the same object (which never changes shape).\n */\nexport type Trait<D, A, S extends SemanticSymbol|null, R> = PendingTrait<D, A, S, R>|\n    SkippedTrait<D, A, S, R>|AnalyzedTrait<D, A, S, R>|ResolvedTrait<D, A, S, R>;\n\n/**\n * The value side of `Trait` exposes a helper to create a `Trait` in a pending state (by delegating\n * to `TraitImpl`).\n */\nexport const Trait = {\n  pending: <D, A, S extends SemanticSymbol|null, R>(\n      handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>): PendingTrait<D, A, S, R> =>\n      TraitImpl.pending(handler, detected),\n};\n\n/**\n * The part of the `Trait` interface that's common to all trait states.\n */\nexport interface TraitBase<D, A, S extends SemanticSymbol|null, R> {\n  /**\n   * Current state of the trait.\n   *\n   * This will be narrowed in the interfaces for each specific state.\n   */\n  state: TraitState;\n\n  /**\n   * The `DecoratorHandler` which matched on the class to create this trait.\n   */\n  handler: DecoratorHandler<D, A, S, R>;\n\n  /**\n   * The detection result (of `handler.detect`) which indicated that this trait applied to the\n   * class.\n   *\n   * This is mainly used to cache the detection between pre-analysis and analysis.\n   */\n  detected: DetectResult<D>;\n}\n\n/**\n * A trait in the pending state.\n *\n * Pending traits have yet to be analyzed in any way.\n */\nexport interface PendingTrait<D, A, S extends SemanticSymbol|null, R> extends\n    TraitBase<D, A, S, R> {\n  state: TraitState.Pending;\n\n  /**\n   * This pending trait has been successfully analyzed, and should transition to the \"analyzed\"\n   * state.\n   */\n  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null, symbol: S):\n      AnalyzedTrait<D, A, S, R>;\n\n  /**\n   * During analysis it was determined that this trait is not eligible for compilation after all,\n   * and should be transitioned to the \"skipped\" state.\n   */\n  toSkipped(): SkippedTrait<D, A, S, R>;\n}\n\n/**\n * A trait in the \"skipped\" state.\n *\n * Skipped traits aren't considered for compilation.\n *\n * This is a terminal state.\n */\nexport interface SkippedTrait<D, A, S extends SemanticSymbol|null, R> extends\n    TraitBase<D, A, S, R> {\n  state: TraitState.Skipped;\n}\n\n/**\n * A trait in the \"analyzed\" state.\n *\n * Analyzed traits have analysis results available, and are eligible for resolution.\n */\nexport interface AnalyzedTrait<D, A, S extends SemanticSymbol|null, R> extends\n    TraitBase<D, A, S, R> {\n  state: TraitState.Analyzed;\n  symbol: S;\n\n  /**\n   * Analysis results of the given trait (if able to be produced), or `null` if analysis failed\n   * completely.\n   */\n  analysis: Readonly<A>|null;\n\n  /**\n   * Any diagnostics that resulted from analysis, or `null` if none.\n   */\n  analysisDiagnostics: ts.Diagnostic[]|null;\n\n  /**\n   * This analyzed trait has been successfully resolved, and should be transitioned to the\n   * \"resolved\" state.\n   */\n  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, S, R>;\n}\n\n/**\n * A trait in the \"resolved\" state.\n *\n * Resolved traits have been successfully analyzed and resolved, contain no errors, and are ready\n * for the compilation phase.\n *\n * This is a terminal state.\n */\nexport interface ResolvedTrait<D, A, S extends SemanticSymbol|null, R> extends\n    TraitBase<D, A, S, R> {\n  state: TraitState.Resolved;\n  symbol: S;\n\n  /**\n   * Resolved traits must have produced valid analysis results.\n   */\n  analysis: Readonly<A>;\n\n  /**\n   * Analysis may have still resulted in diagnostics.\n   */\n  analysisDiagnostics: ts.Diagnostic[]|null;\n\n  /**\n   * Diagnostics resulting from resolution are tracked separately from\n   */\n  resolveDiagnostics: ts.Diagnostic[]|null;\n\n  /**\n   * The results returned by a successful resolution of the given class/`DecoratorHandler`\n   * combination.\n   */\n  resolution: Readonly<R>|null;\n}\n\n/**\n * An implementation of the `Trait` type which transitions safely between the various\n * `TraitState`s.\n */\nclass TraitImpl<D, A, S extends SemanticSymbol|null, R> {\n  state: TraitState = TraitState.Pending;\n  handler: DecoratorHandler<D, A, S, R>;\n  detected: DetectResult<D>;\n  analysis: Readonly<A>|null = null;\n  symbol: S|null = null;\n  resolution: Readonly<R>|null = null;\n  analysisDiagnostics: ts.Diagnostic[]|null = null;\n  resolveDiagnostics: ts.Diagnostic[]|null = null;\n\n  constructor(handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>) {\n    this.handler = handler;\n    this.detected = detected;\n  }\n\n  toAnalyzed(analysis: A|null, diagnostics: ts.Diagnostic[]|null, symbol: S):\n      AnalyzedTrait<D, A, S, R> {\n    // Only pending traits can be analyzed.\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Analyzed);\n    this.analysis = analysis;\n    this.analysisDiagnostics = diagnostics;\n    this.symbol = symbol;\n    this.state = TraitState.Analyzed;\n    return this as AnalyzedTrait<D, A, S, R>;\n  }\n\n  toResolved(resolution: R|null, diagnostics: ts.Diagnostic[]|null): ResolvedTrait<D, A, S, R> {\n    // Only analyzed traits can be resolved.\n    this.assertTransitionLegal(TraitState.Analyzed, TraitState.Resolved);\n    if (this.analysis === null) {\n      throw new Error(`Cannot transition an Analyzed trait with a null analysis to Resolved`);\n    }\n    this.resolution = resolution;\n    this.state = TraitState.Resolved;\n    this.resolveDiagnostics = diagnostics;\n    return this as ResolvedTrait<D, A, S, R>;\n  }\n\n  toSkipped(): SkippedTrait<D, A, S, R> {\n    // Only pending traits can be skipped.\n    this.assertTransitionLegal(TraitState.Pending, TraitState.Skipped);\n    this.state = TraitState.Skipped;\n    return this as SkippedTrait<D, A, S, R>;\n  }\n\n  /**\n   * Verifies that the trait is currently in one of the `allowedState`s.\n   *\n   * If correctly used, the `Trait` type and transition methods prevent illegal transitions from\n   * occurring. However, if a reference to the `TraitImpl` instance typed with the previous\n   * interface is retained after calling one of its transition methods, it will allow for illegal\n   * transitions to take place. Hence, this assertion provides a little extra runtime protection.\n   */\n  private assertTransitionLegal(allowedState: TraitState, transitionTo: TraitState): void {\n    if (!(this.state === allowedState)) {\n      throw new Error(`Assertion failure: cannot transition from ${TraitState[this.state]} to ${\n          TraitState[transitionTo]}.`);\n    }\n  }\n\n  /**\n   * Construct a new `TraitImpl` in the pending state.\n   */\n  static pending<D, A, S extends SemanticSymbol|null, R>(\n      handler: DecoratorHandler<D, A, S, R>, detected: DetectResult<D>): PendingTrait<D, A, S, R> {\n    return new TraitImpl(handler, detected) as PendingTrait<D, A, S, R>;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}