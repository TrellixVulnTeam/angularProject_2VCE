{"ast":null,"code":"\"use strict\";\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Range = /*#__PURE__*/function () {\n  function Range() {\n    _classCallCheck(this, Range);\n\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  _createClass(Range, [{\n    key: \"left\",\n    value: function left(value) {\n      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._left.push([value, exclusive]);\n    }\n    /**\n     * @param {number} value\n     * @param {boolean=} exclusive\n     */\n\n  }, {\n    key: \"right\",\n    value: function right(value) {\n      var exclusive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      this._right.push([value, exclusive]);\n    }\n    /**\n     * @param {boolean} logic is not logic applied\n     * @return {string} \"smart\" range string representation\n     */\n\n  }, {\n    key: \"format\",\n    value: function format() {\n      var logic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      var _Range$getRangeValue = Range.getRangeValue(this._left, logic),\n          _Range$getRangeValue2 = _slicedToArray(_Range$getRangeValue, 2),\n          start = _Range$getRangeValue2[0],\n          leftExclusive = _Range$getRangeValue2[1];\n\n      var _Range$getRangeValue3 = Range.getRangeValue(this._right, !logic),\n          _Range$getRangeValue4 = _slicedToArray(_Range$getRangeValue3, 2),\n          end = _Range$getRangeValue4[0],\n          rightExclusive = _Range$getRangeValue4[1];\n\n      if (!Number.isFinite(start) && !Number.isFinite(end)) {\n        return '';\n      }\n\n      var realStart = leftExclusive ? start + 1 : start;\n      var realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n      if (realStart === realEnd) {\n        return \"should be \".concat(logic ? '' : '!', \"= \").concat(realStart);\n      } // e.g. 4 < x < ∞\n\n\n      if (Number.isFinite(start) && !Number.isFinite(end)) {\n        return Range.formatLeft(start, logic, leftExclusive);\n      } // e.g. ∞ < x < 4\n\n\n      if (!Number.isFinite(start) && Number.isFinite(end)) {\n        return Range.formatRight(end, logic, rightExclusive);\n      }\n\n      return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n    }\n  }], [{\n    key: \"getOperator\",\n    value:\n    /**\n     * @param {\"left\" | \"right\"} side\n     * @param {boolean} exclusive\n     * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n     */\n    function getOperator(side, exclusive) {\n      if (side === 'left') {\n        return exclusive ? '>' : '>=';\n      }\n\n      return exclusive ? '<' : '<=';\n    }\n    /**\n     * @param {number} value\n     * @param {boolean} logic is not logic applied\n     * @param {boolean} exclusive is range exclusive\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatRight\",\n    value: function formatRight(value, logic, exclusive) {\n      if (logic === false) {\n        return Range.formatLeft(value, !logic, !exclusive);\n      }\n\n      return \"should be \".concat(Range.getOperator('right', exclusive), \" \").concat(value);\n    }\n    /**\n     * @param {number} value\n     * @param {boolean} logic is not logic applied\n     * @param {boolean} exclusive is range exclusive\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatLeft\",\n    value: function formatLeft(value, logic, exclusive) {\n      if (logic === false) {\n        return Range.formatRight(value, !logic, !exclusive);\n      }\n\n      return \"should be \".concat(Range.getOperator('left', exclusive), \" \").concat(value);\n    }\n    /**\n     * @param {number} start left side value\n     * @param {number} end right side value\n     * @param {boolean} startExclusive is range exclusive from left side\n     * @param {boolean} endExclusive is range exclusive from right side\n     * @param {boolean} logic is not logic applied\n     * @returns {string}\n     */\n\n  }, {\n    key: \"formatRange\",\n    value: function formatRange(start, end, startExclusive, endExclusive, logic) {\n      var result = 'should be';\n      result += \" \".concat(Range.getOperator(logic ? 'left' : 'right', logic ? startExclusive : !startExclusive), \" \").concat(start, \" \");\n      result += logic ? 'and' : 'or';\n      result += \" \".concat(Range.getOperator(logic ? 'right' : 'left', logic ? endExclusive : !endExclusive), \" \").concat(end);\n      return result;\n    }\n    /**\n     * @param {Array<RangeValue>} values\n     * @param {boolean} logic is not logic applied\n     * @return {RangeValue} computed value and it's exclusive flag\n     */\n\n  }, {\n    key: \"getRangeValue\",\n    value: function getRangeValue(values, logic) {\n      var minMax = logic ? Infinity : -Infinity;\n      var j = -1;\n      var predicate = logic ?\n      /** @type {RangeValueCallback} */\n      function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            value = _ref2[0];\n\n        return value <= minMax;\n      } :\n      /** @type {RangeValueCallback} */\n      function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            value = _ref4[0];\n\n        return value >= minMax;\n      };\n\n      for (var i = 0; i < values.length; i++) {\n        if (predicate(values[i])) {\n          var _values$i = _slicedToArray(values[i], 1);\n\n          minMax = _values$i[0];\n          j = i;\n        }\n      }\n\n      if (j > -1) {\n        return values[j];\n      }\n\n      return [Infinity, true];\n    }\n  }]);\n\n  return Range;\n}();\n\nmodule.exports = Range;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/babel-loader/node_modules/schema-utils/dist/util/Range.js"],"names":["Range","_left","_right","value","exclusive","push","logic","getRangeValue","start","leftExclusive","end","rightExclusive","Number","isFinite","realStart","realEnd","formatLeft","formatRight","formatRange","side","getOperator","startExclusive","endExclusive","result","values","minMax","Infinity","j","predicate","i","length","module","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\n/**\n * @typedef {[number, boolean]} RangeValue\n */\n\n/**\n * @callback RangeValueCallback\n * @param {RangeValue} rangeValue\n * @returns {boolean}\n */\nclass Range {\n  /**\n   * @param {\"left\" | \"right\"} side\n   * @param {boolean} exclusive\n   * @returns {\">\" | \">=\" | \"<\" | \"<=\"}\n   */\n  static getOperator(side, exclusive) {\n    if (side === 'left') {\n      return exclusive ? '>' : '>=';\n    }\n\n    return exclusive ? '<' : '<=';\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatRight(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatLeft(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator('right', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} value\n   * @param {boolean} logic is not logic applied\n   * @param {boolean} exclusive is range exclusive\n   * @returns {string}\n   */\n\n\n  static formatLeft(value, logic, exclusive) {\n    if (logic === false) {\n      return Range.formatRight(value, !logic, !exclusive);\n    }\n\n    return `should be ${Range.getOperator('left', exclusive)} ${value}`;\n  }\n  /**\n   * @param {number} start left side value\n   * @param {number} end right side value\n   * @param {boolean} startExclusive is range exclusive from left side\n   * @param {boolean} endExclusive is range exclusive from right side\n   * @param {boolean} logic is not logic applied\n   * @returns {string}\n   */\n\n\n  static formatRange(start, end, startExclusive, endExclusive, logic) {\n    let result = 'should be';\n    result += ` ${Range.getOperator(logic ? 'left' : 'right', logic ? startExclusive : !startExclusive)} ${start} `;\n    result += logic ? 'and' : 'or';\n    result += ` ${Range.getOperator(logic ? 'right' : 'left', logic ? endExclusive : !endExclusive)} ${end}`;\n    return result;\n  }\n  /**\n   * @param {Array<RangeValue>} values\n   * @param {boolean} logic is not logic applied\n   * @return {RangeValue} computed value and it's exclusive flag\n   */\n\n\n  static getRangeValue(values, logic) {\n    let minMax = logic ? Infinity : -Infinity;\n    let j = -1;\n    const predicate = logic ?\n    /** @type {RangeValueCallback} */\n    ([value]) => value <= minMax :\n    /** @type {RangeValueCallback} */\n    ([value]) => value >= minMax;\n\n    for (let i = 0; i < values.length; i++) {\n      if (predicate(values[i])) {\n        [minMax] = values[i];\n        j = i;\n      }\n    }\n\n    if (j > -1) {\n      return values[j];\n    }\n\n    return [Infinity, true];\n  }\n\n  constructor() {\n    /** @type {Array<RangeValue>} */\n    this._left = [];\n    /** @type {Array<RangeValue>} */\n\n    this._right = [];\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  left(value, exclusive = false) {\n    this._left.push([value, exclusive]);\n  }\n  /**\n   * @param {number} value\n   * @param {boolean=} exclusive\n   */\n\n\n  right(value, exclusive = false) {\n    this._right.push([value, exclusive]);\n  }\n  /**\n   * @param {boolean} logic is not logic applied\n   * @return {string} \"smart\" range string representation\n   */\n\n\n  format(logic = true) {\n    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);\n    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);\n\n    if (!Number.isFinite(start) && !Number.isFinite(end)) {\n      return '';\n    }\n\n    const realStart = leftExclusive ? start + 1 : start;\n    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6\n\n    if (realStart === realEnd) {\n      return `should be ${logic ? '' : '!'}= ${realStart}`;\n    } // e.g. 4 < x < ∞\n\n\n    if (Number.isFinite(start) && !Number.isFinite(end)) {\n      return Range.formatLeft(start, logic, leftExclusive);\n    } // e.g. ∞ < x < 4\n\n\n    if (!Number.isFinite(start) && Number.isFinite(end)) {\n      return Range.formatRight(end, logic, rightExclusive);\n    }\n\n    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);\n  }\n\n}\n\nmodule.exports = Range;"]},"metadata":{},"sourceType":"script"}