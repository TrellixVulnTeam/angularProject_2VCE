{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/template_semantics\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ExpressionSemanticVisitor = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n  /**\n   * Visits a template and records any semantic errors within its expressions.\n   */\n\n\n  var ExpressionSemanticVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ExpressionSemanticVisitor, _super);\n\n    function ExpressionSemanticVisitor(templateId, boundTarget, oob) {\n      var _this = _super.call(this) || this;\n\n      _this.templateId = templateId;\n      _this.boundTarget = boundTarget;\n      _this.oob = oob;\n      return _this;\n    }\n\n    ExpressionSemanticVisitor.prototype.visitPropertyWrite = function (ast, context) {\n      _super.prototype.visitPropertyWrite.call(this, ast, context);\n\n      if (!(ast.receiver instanceof compiler_1.ImplicitReceiver)) {\n        return;\n      }\n\n      var target = this.boundTarget.getExpressionTarget(ast);\n\n      if (target instanceof compiler_1.TmplAstVariable) {\n        // Template variables are read-only.\n        this.oob.illegalAssignmentToTemplateVar(this.templateId, ast, target);\n      }\n    };\n\n    ExpressionSemanticVisitor.visit = function (ast, id, boundTarget, oob) {\n      ast.visit(new ExpressionSemanticVisitor(id, boundTarget, oob));\n    };\n\n    return ExpressionSemanticVisitor;\n  }(compiler_1.RecursiveAstVisitor);\n\n  exports.ExpressionSemanticVisitor = ExpressionSemanticVisitor;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/template_semantics.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;AAMA;;AAEG;;;AACH,MAAA,yBAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAA+C,IAAA,OAAA,CAAA,SAAA,CAAA,yBAAA,EAAA,MAAA;;AAC7C,aAAA,yBAAA,CACY,UADZ,EAC4C,WAD5C,EAEY,GAFZ,EAE4C;AAF5C,UAAA,KAAA,GAGE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IAHT;;AACY,MAAA,KAAA,CAAA,UAAA,GAAA,UAAA;AAAgC,MAAA,KAAA,CAAA,WAAA,GAAA,WAAA;AAChC,MAAA,KAAA,CAAA,GAAA,GAAA,GAAA;;AAEX;;AAED,IAAA,yBAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,GAAnB,EAAuC,OAAvC,EAAmD;AACjD,MAAA,MAAA,CAAA,SAAA,CAAM,kBAAN,CAAwB,IAAxB,CAAwB,IAAxB,EAAyB,GAAzB,EAA8B,OAA9B;;AAEA,UAAI,EAAE,GAAG,CAAC,QAAJ,YAAwB,UAAA,CAAA,gBAA1B,CAAJ,EAAiD;AAC/C;AACD;;AAED,UAAM,MAAM,GAAG,KAAK,WAAL,CAAiB,mBAAjB,CAAqC,GAArC,CAAf;;AACA,UAAI,MAAM,YAAY,UAAA,CAAA,eAAtB,EAAuC;AACrC;AACA,aAAK,GAAL,CAAS,8BAAT,CAAwC,KAAK,UAA7C,EAAyD,GAAzD,EAA8D,MAA9D;AACD;AACF,KAZD;;AAcO,IAAA,yBAAA,CAAA,KAAA,GAAP,UACI,GADJ,EACc,EADd,EAC8B,WAD9B,EAEI,GAFJ,EAEoC;AAClC,MAAA,GAAG,CAAC,KAAJ,CAAU,IAAI,yBAAJ,CAA8B,EAA9B,EAAkC,WAAlC,EAA+C,GAA/C,CAAV;AACD,KAJM;;AAKT,WAAA,yBAAA;AAAC,GA1BD,CAA+C,UAAA,CAAA,mBAA/C,CAAA;;AAAa,EAAA,OAAA,CAAA,yBAAA,GAAA,yBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, BoundTarget, ImplicitReceiver, PropertyWrite, RecursiveAstVisitor, TmplAstVariable} from '@angular/compiler';\n\nimport {TemplateId} from '../api';\n\nimport {OutOfBandDiagnosticRecorder} from './oob';\n\n/**\n * Visits a template and records any semantic errors within its expressions.\n */\nexport class ExpressionSemanticVisitor extends RecursiveAstVisitor {\n  constructor(\n      private templateId: TemplateId, private boundTarget: BoundTarget<any>,\n      private oob: OutOfBandDiagnosticRecorder) {\n    super();\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): void {\n    super.visitPropertyWrite(ast, context);\n\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n\n    const target = this.boundTarget.getExpressionTarget(ast);\n    if (target instanceof TmplAstVariable) {\n      // Template variables are read-only.\n      this.oob.illegalAssignmentToTemplateVar(this.templateId, ast, target);\n    }\n  }\n\n  static visit(\n      ast: AST, id: TemplateId, boundTarget: BoundTarget<any>,\n      oob: OutOfBandDiagnosticRecorder): void {\n    ast.visit(new ExpressionSemanticVisitor(id, boundTarget, oob));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}