{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/annotations/src/util\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/imports/src/default\", \"@angular/compiler-cli/src/ngtsc/reflection\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.createSourceSpan = exports.wrapTypeReference = exports.resolveProvidersRequiringFactory = exports.makeDuplicateDeclarationError = exports.wrapFunctionExpressionsInParens = exports.readBaseClass = exports.isWrappedTsNodeExpr = exports.isExpressionForwardReference = exports.combineResolvers = exports.forwardRefResolver = exports.unwrapForwardRef = exports.unwrapExpression = exports.isAngularDecorator = exports.findAngularDecorator = exports.isAngularCoreReference = exports.isAngularCore = exports.toR3Reference = exports.validateConstructorDependencies = exports.getValidConstructorDependencies = exports.unwrapConstructorDependencies = exports.valueReferenceToExpression = exports.getConstructorDependencies = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var default_1 = require(\"@angular/compiler-cli/src/ngtsc/imports/src/default\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  function getConstructorDependencies(clazz, reflector, isCore) {\n    var deps = [];\n    var errors = [];\n    var ctorParams = reflector.getConstructorParameters(clazz);\n\n    if (ctorParams === null) {\n      if (reflector.hasBaseClass(clazz)) {\n        return null;\n      } else {\n        ctorParams = [];\n      }\n    }\n\n    ctorParams.forEach(function (param, idx) {\n      var token = valueReferenceToExpression(param.typeValueReference);\n      var attribute = null;\n      var optional = false,\n          self = false,\n          skipSelf = false,\n          host = false;\n      var resolved = compiler_1.R3ResolvedDependencyType.Token;\n      (param.decorators || []).filter(function (dec) {\n        return isCore || isAngularCore(dec);\n      }).forEach(function (dec) {\n        var name = isCore || dec.import === null ? dec.name : dec.import.name;\n\n        if (name === 'Inject') {\n          if (dec.args === null || dec.args.length !== 1) {\n            throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, reflection_1.Decorator.nodeForError(dec), \"Unexpected number of arguments to @Inject().\");\n          }\n\n          token = new compiler_1.WrappedNodeExpr(dec.args[0]);\n        } else if (name === 'Optional') {\n          optional = true;\n        } else if (name === 'SkipSelf') {\n          skipSelf = true;\n        } else if (name === 'Self') {\n          self = true;\n        } else if (name === 'Host') {\n          host = true;\n        } else if (name === 'Attribute') {\n          if (dec.args === null || dec.args.length !== 1) {\n            throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, reflection_1.Decorator.nodeForError(dec), \"Unexpected number of arguments to @Attribute().\");\n          }\n\n          var attributeName = dec.args[0];\n          token = new compiler_1.WrappedNodeExpr(attributeName);\n\n          if (ts.isStringLiteralLike(attributeName)) {\n            attribute = new compiler_1.LiteralExpr(attributeName.text);\n          } else {\n            attribute = new compiler_1.WrappedNodeExpr(ts.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword));\n          }\n\n          resolved = compiler_1.R3ResolvedDependencyType.Attribute;\n        } else {\n          throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_UNEXPECTED, reflection_1.Decorator.nodeForError(dec), \"Unexpected decorator \" + name + \" on parameter.\");\n        }\n      });\n\n      if (token instanceof compiler_1.ExternalExpr && token.value.name === 'ChangeDetectorRef' && token.value.moduleName === '@angular/core') {\n        resolved = compiler_1.R3ResolvedDependencyType.ChangeDetectorRef;\n      }\n\n      if (token === null) {\n        if (param.typeValueReference.kind !== 2\n        /* UNAVAILABLE */\n        ) {\n            throw new Error('Illegal state: expected value reference to be unavailable if no token is present');\n          }\n\n        errors.push({\n          index: idx,\n          param: param,\n          reason: param.typeValueReference.reason\n        });\n      } else {\n        deps.push({\n          token: token,\n          attribute: attribute,\n          optional: optional,\n          self: self,\n          skipSelf: skipSelf,\n          host: host,\n          resolved: resolved\n        });\n      }\n    });\n\n    if (errors.length === 0) {\n      return {\n        deps: deps\n      };\n    } else {\n      return {\n        deps: null,\n        errors: errors\n      };\n    }\n  }\n\n  exports.getConstructorDependencies = getConstructorDependencies;\n\n  function valueReferenceToExpression(valueRef) {\n    var e_1, _a;\n\n    if (valueRef.kind === 2\n    /* UNAVAILABLE */\n    ) {\n        return null;\n      } else if (valueRef.kind === 0\n    /* LOCAL */\n    ) {\n        var expr = new compiler_1.WrappedNodeExpr(valueRef.expression);\n\n        if (valueRef.defaultImportStatement !== null) {\n          default_1.attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);\n        }\n\n        return expr;\n      } else {\n      var importExpr = new compiler_1.ExternalExpr({\n        moduleName: valueRef.moduleName,\n        name: valueRef.importedName\n      });\n\n      if (valueRef.nestedPath !== null) {\n        try {\n          for (var _b = tslib_1.__values(valueRef.nestedPath), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var property = _c.value;\n            importExpr = new compiler_1.ReadPropExpr(importExpr, property);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n\n      return importExpr;\n    }\n  }\n\n  exports.valueReferenceToExpression = valueReferenceToExpression;\n  /**\n   * Convert `ConstructorDeps` into the `R3DependencyMetadata` array for those deps if they're valid,\n   * or into an `'invalid'` signal if they're not.\n   *\n   * This is a companion function to `validateConstructorDependencies` which accepts invalid deps.\n   */\n\n  function unwrapConstructorDependencies(deps) {\n    if (deps === null) {\n      return null;\n    } else if (deps.deps !== null) {\n      // These constructor dependencies are valid.\n      return deps.deps;\n    } else {\n      // These deps are invalid.\n      return 'invalid';\n    }\n  }\n\n  exports.unwrapConstructorDependencies = unwrapConstructorDependencies;\n\n  function getValidConstructorDependencies(clazz, reflector, isCore) {\n    return validateConstructorDependencies(clazz, getConstructorDependencies(clazz, reflector, isCore));\n  }\n\n  exports.getValidConstructorDependencies = getValidConstructorDependencies;\n  /**\n   * Validate that `ConstructorDeps` does not have any invalid dependencies and convert them into the\n   * `R3DependencyMetadata` array if so, or raise a diagnostic if some deps are invalid.\n   *\n   * This is a companion function to `unwrapConstructorDependencies` which does not accept invalid\n   * deps.\n   */\n\n  function validateConstructorDependencies(clazz, deps) {\n    if (deps === null) {\n      return null;\n    } else if (deps.deps !== null) {\n      return deps.deps;\n    } else {\n      // TODO(alxhub): this cast is necessary because the g3 typescript version doesn't narrow here.\n      // There is at least one error.\n      var error = deps.errors[0];\n      throw createUnsuitableInjectionTokenError(clazz, error);\n    }\n  }\n\n  exports.validateConstructorDependencies = validateConstructorDependencies;\n  /**\n   * Creates a fatal error with diagnostic for an invalid injection token.\n   * @param clazz The class for which the injection token was unavailable.\n   * @param error The reason why no valid injection token is available.\n   */\n\n  function createUnsuitableInjectionTokenError(clazz, error) {\n    var param = error.param,\n        index = error.index,\n        reason = error.reason;\n    var chainMessage = undefined;\n    var hints = undefined;\n\n    switch (reason.kind) {\n      case 5\n      /* UNSUPPORTED */\n      :\n        chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n        hints = [diagnostics_1.makeRelatedInformation(reason.typeNode, 'This type is not supported as injection token.')];\n        break;\n\n      case 1\n      /* NO_VALUE_DECLARATION */\n      :\n        chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n        hints = [diagnostics_1.makeRelatedInformation(reason.typeNode, 'This type does not have a value, so it cannot be used as injection token.')];\n\n        if (reason.decl !== null) {\n          hints.push(diagnostics_1.makeRelatedInformation(reason.decl, 'The type is declared here.'));\n        }\n\n        break;\n\n      case 2\n      /* TYPE_ONLY_IMPORT */\n      :\n        chainMessage = 'Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.';\n        hints = [diagnostics_1.makeRelatedInformation(reason.typeNode, 'This type is imported using a type-only import, which prevents it from being usable as an injection token.'), diagnostics_1.makeRelatedInformation(reason.importClause, 'The type-only import occurs here.')];\n        break;\n\n      case 4\n      /* NAMESPACE */\n      :\n        chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n        hints = [diagnostics_1.makeRelatedInformation(reason.typeNode, 'This type corresponds with a namespace, which cannot be used as injection token.'), diagnostics_1.makeRelatedInformation(reason.importClause, 'The namespace import occurs here.')];\n        break;\n\n      case 3\n      /* UNKNOWN_REFERENCE */\n      :\n        chainMessage = 'The type should reference a known declaration.';\n        hints = [diagnostics_1.makeRelatedInformation(reason.typeNode, 'This type could not be resolved.')];\n        break;\n\n      case 0\n      /* MISSING_TYPE */\n      :\n        chainMessage = 'Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.';\n        break;\n    }\n\n    var chain = {\n      messageText: \"No suitable injection token for parameter '\" + (param.name || index) + \"' of class '\" + clazz.name.text + \"'.\",\n      category: ts.DiagnosticCategory.Error,\n      code: 0,\n      next: [{\n        messageText: chainMessage,\n        category: ts.DiagnosticCategory.Message,\n        code: 0\n      }]\n    };\n    return new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);\n  }\n\n  function toR3Reference(valueRef, typeRef, valueContext, typeContext, refEmitter) {\n    return {\n      value: refEmitter.emit(valueRef, valueContext).expression,\n      type: refEmitter.emit(typeRef, typeContext, imports_1.ImportFlags.ForceNewImport | imports_1.ImportFlags.AllowTypeImports).expression\n    };\n  }\n\n  exports.toR3Reference = toR3Reference;\n\n  function isAngularCore(decorator) {\n    return decorator.import !== null && decorator.import.from === '@angular/core';\n  }\n\n  exports.isAngularCore = isAngularCore;\n\n  function isAngularCoreReference(reference, symbolName) {\n    return reference.ownedByModuleGuess === '@angular/core' && reference.debugName === symbolName;\n  }\n\n  exports.isAngularCoreReference = isAngularCoreReference;\n\n  function findAngularDecorator(decorators, name, isCore) {\n    return decorators.find(function (decorator) {\n      return isAngularDecorator(decorator, name, isCore);\n    });\n  }\n\n  exports.findAngularDecorator = findAngularDecorator;\n\n  function isAngularDecorator(decorator, name, isCore) {\n    if (isCore) {\n      return decorator.name === name;\n    } else if (isAngularCore(decorator)) {\n      return decorator.import.name === name;\n    }\n\n    return false;\n  }\n\n  exports.isAngularDecorator = isAngularDecorator;\n  /**\n   * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its\n   * lowest level form.\n   *\n   * For example, the expression \"(foo as Type)\" unwraps to \"foo\".\n   */\n\n  function unwrapExpression(node) {\n    while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {\n      node = node.expression;\n    }\n\n    return node;\n  }\n\n  exports.unwrapExpression = unwrapExpression;\n\n  function expandForwardRef(arg) {\n    arg = unwrapExpression(arg);\n\n    if (!ts.isArrowFunction(arg) && !ts.isFunctionExpression(arg)) {\n      return null;\n    }\n\n    var body = arg.body; // Either the body is a ts.Expression directly, or a block with a single return statement.\n\n    if (ts.isBlock(body)) {\n      // Block body - look for a single return statement.\n      if (body.statements.length !== 1) {\n        return null;\n      }\n\n      var stmt = body.statements[0];\n\n      if (!ts.isReturnStatement(stmt) || stmt.expression === undefined) {\n        return null;\n      }\n\n      return stmt.expression;\n    } else {\n      // Shorthand body - return as an expression.\n      return body;\n    }\n  }\n  /**\n   * Possibly resolve a forwardRef() expression into the inner value.\n   *\n   * @param node the forwardRef() expression to resolve\n   * @param reflector a ReflectionHost\n   * @returns the resolved expression, if the original expression was a forwardRef(), or the original\n   * expression otherwise\n   */\n\n\n  function unwrapForwardRef(node, reflector) {\n    node = unwrapExpression(node);\n\n    if (!ts.isCallExpression(node) || node.arguments.length !== 1) {\n      return node;\n    }\n\n    var fn = ts.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;\n\n    if (!ts.isIdentifier(fn)) {\n      return node;\n    }\n\n    var expr = expandForwardRef(node.arguments[0]);\n\n    if (expr === null) {\n      return node;\n    }\n\n    var imp = reflector.getImportOfIdentifier(fn);\n\n    if (imp === null || imp.from !== '@angular/core' || imp.name !== 'forwardRef') {\n      return node;\n    } else {\n      return expr;\n    }\n  }\n\n  exports.unwrapForwardRef = unwrapForwardRef;\n  /**\n   * A foreign function resolver for `staticallyResolve` which unwraps forwardRef() expressions.\n   *\n   * @param ref a Reference to the declaration of the function being called (which might be\n   * forwardRef)\n   * @param args the arguments to the invocation of the forwardRef expression\n   * @returns an unwrapped argument if `ref` pointed to forwardRef, or null otherwise\n   */\n\n  function forwardRefResolver(ref, args) {\n    if (!isAngularCoreReference(ref, 'forwardRef') || args.length !== 1) {\n      return null;\n    }\n\n    return expandForwardRef(args[0]);\n  }\n\n  exports.forwardRefResolver = forwardRefResolver;\n  /**\n   * Combines an array of resolver functions into a one.\n   * @param resolvers Resolvers to be combined.\n   */\n\n  function combineResolvers(resolvers) {\n    return function (ref, args) {\n      var e_2, _a;\n\n      try {\n        for (var resolvers_1 = tslib_1.__values(resolvers), resolvers_1_1 = resolvers_1.next(); !resolvers_1_1.done; resolvers_1_1 = resolvers_1.next()) {\n          var resolver = resolvers_1_1.value;\n          var resolved = resolver(ref, args);\n\n          if (resolved !== null) {\n            return resolved;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (resolvers_1_1 && !resolvers_1_1.done && (_a = resolvers_1.return)) _a.call(resolvers_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return null;\n    };\n  }\n\n  exports.combineResolvers = combineResolvers;\n\n  function isExpressionForwardReference(expr, context, contextSource) {\n    if (isWrappedTsNodeExpr(expr)) {\n      var node = ts.getOriginalNode(expr.node);\n      return node.getSourceFile() === contextSource && context.pos < node.pos;\n    } else {\n      return false;\n    }\n  }\n\n  exports.isExpressionForwardReference = isExpressionForwardReference;\n\n  function isWrappedTsNodeExpr(expr) {\n    return expr instanceof compiler_1.WrappedNodeExpr;\n  }\n\n  exports.isWrappedTsNodeExpr = isWrappedTsNodeExpr;\n\n  function readBaseClass(node, reflector, evaluator) {\n    var baseExpression = reflector.getBaseClassExpression(node);\n\n    if (baseExpression !== null) {\n      var baseClass = evaluator.evaluate(baseExpression);\n\n      if (baseClass instanceof imports_1.Reference && reflector.isClass(baseClass.node)) {\n        return baseClass;\n      } else {\n        return 'dynamic';\n      }\n    }\n\n    return null;\n  }\n\n  exports.readBaseClass = readBaseClass;\n\n  var parensWrapperTransformerFactory = function parensWrapperTransformerFactory(context) {\n    var visitor = function visitor(node) {\n      var visited = ts.visitEachChild(node, visitor, context);\n\n      if (ts.isArrowFunction(visited) || ts.isFunctionExpression(visited)) {\n        return ts.createParen(visited);\n      }\n\n      return visited;\n    };\n\n    return function (node) {\n      return ts.visitEachChild(node, visitor, context);\n    };\n  };\n  /**\n   * Wraps all functions in a given expression in parentheses. This is needed to avoid problems\n   * where Tsickle annotations added between analyse and transform phases in Angular may trigger\n   * automatic semicolon insertion, e.g. if a function is the expression in a `return` statement.\n   * More\n   * info can be found in Tsickle source code here:\n   * https://github.com/angular/tsickle/blob/d7974262571c8a17d684e5ba07680e1b1993afdd/src/jsdoc_transformer.ts#L1021\n   *\n   * @param expression Expression where functions should be wrapped in parentheses\n   */\n\n\n  function wrapFunctionExpressionsInParens(expression) {\n    return ts.transform(expression, [parensWrapperTransformerFactory]).transformed[0];\n  }\n\n  exports.wrapFunctionExpressionsInParens = wrapFunctionExpressionsInParens;\n  /**\n   * Create a `ts.Diagnostic` which indicates the given class is part of the declarations of two or\n   * more NgModules.\n   *\n   * The resulting `ts.Diagnostic` will have a context entry for each NgModule showing the point where\n   * the directive/pipe exists in its `declarations` (if possible).\n   */\n\n  function makeDuplicateDeclarationError(node, data, kind) {\n    var e_3, _a;\n\n    var context = [];\n\n    try {\n      for (var data_1 = tslib_1.__values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {\n        var decl = data_1_1.value;\n\n        if (decl.rawDeclarations === null) {\n          continue;\n        } // Try to find the reference to the declaration within the declarations array, to hang the\n        // error there. If it can't be found, fall back on using the NgModule's name.\n\n\n        var contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);\n        context.push(diagnostics_1.makeRelatedInformation(contextNode, \"'\" + node.name.text + \"' is listed in the declarations of the NgModule '\" + decl.ngModule.name.text + \"'.\"));\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    } // Finally, produce the diagnostic.\n\n\n    return diagnostics_1.makeDiagnostic(diagnostics_1.ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name, \"The \" + kind + \" '\" + node.name.text + \"' is declared by more than one NgModule.\", context);\n  }\n\n  exports.makeDuplicateDeclarationError = makeDuplicateDeclarationError;\n  /**\n   * Resolves the given `rawProviders` into `ClassDeclarations` and returns\n   * a set containing those that are known to require a factory definition.\n   * @param rawProviders Expression that declared the providers array in the source.\n   */\n\n  function resolveProvidersRequiringFactory(rawProviders, reflector, evaluator) {\n    var providers = new Set();\n    var resolvedProviders = evaluator.evaluate(rawProviders);\n\n    if (!Array.isArray(resolvedProviders)) {\n      return providers;\n    }\n\n    resolvedProviders.forEach(function processProviders(provider) {\n      var tokenClass = null;\n\n      if (Array.isArray(provider)) {\n        // If we ran into an array, recurse into it until we've resolve all the classes.\n        provider.forEach(processProviders);\n      } else if (provider instanceof imports_1.Reference) {\n        tokenClass = provider;\n      } else if (provider instanceof Map && provider.has('useClass') && !provider.has('deps')) {\n        var useExisting = provider.get('useClass');\n\n        if (useExisting instanceof imports_1.Reference) {\n          tokenClass = useExisting;\n        }\n      } // TODO(alxhub): there was a bug where `getConstructorParameters` would return `null` for a\n      // class in a .d.ts file, always, even if the class had a constructor. This was fixed for\n      // `getConstructorParameters`, but that fix causes more classes to be recognized here as needing\n      // provider checks, which is a breaking change in g3. Avoid this breakage for now by skipping\n      // classes from .d.ts files here directly, until g3 can be cleaned up.\n\n\n      if (tokenClass !== null && !tokenClass.node.getSourceFile().isDeclarationFile && reflector.isClass(tokenClass.node)) {\n        var constructorParameters = reflector.getConstructorParameters(tokenClass.node); // Note that we only want to capture providers with a non-trivial constructor,\n        // because they're the ones that might be using DI and need to be decorated.\n\n        if (constructorParameters !== null && constructorParameters.length > 0) {\n          providers.add(tokenClass);\n        }\n      }\n    });\n    return providers;\n  }\n\n  exports.resolveProvidersRequiringFactory = resolveProvidersRequiringFactory;\n  /**\n   * Create an R3Reference for a class.\n   *\n   * The `value` is the exported declaration of the class from its source file.\n   * The `type` is an expression that would be used by ngcc in the typings (.d.ts) files.\n   */\n\n  function wrapTypeReference(reflector, clazz) {\n    var dtsClass = reflector.getDtsDeclaration(clazz);\n    var value = new compiler_1.WrappedNodeExpr(clazz.name);\n    var type = dtsClass !== null && reflection_1.isNamedClassDeclaration(dtsClass) ? new compiler_1.WrappedNodeExpr(dtsClass.name) : value;\n    return {\n      value: value,\n      type: type\n    };\n  }\n\n  exports.wrapTypeReference = wrapTypeReference;\n  /** Creates a ParseSourceSpan for a TypeScript node. */\n\n  function createSourceSpan(node) {\n    var sf = node.getSourceFile();\n\n    var _a = tslib_1.__read([node.getStart(), node.getEnd()], 2),\n        startOffset = _a[0],\n        endOffset = _a[1];\n\n    var _b = sf.getLineAndCharacterOfPosition(startOffset),\n        startLine = _b.line,\n        startCol = _b.character;\n\n    var _c = sf.getLineAndCharacterOfPosition(endOffset),\n        endLine = _c.line,\n        endCol = _c.character;\n\n    var parseSf = new compiler_1.ParseSourceFile(sf.getFullText(), sf.fileName); // +1 because values are zero-indexed.\n\n    return new compiler_1.ParseSourceSpan(new compiler_1.ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1), new compiler_1.ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));\n  }\n\n  exports.createSourceSpan = createSourceSpan;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, ExternalExpr, LiteralExpr, ParseLocation, ParseSourceFile, ParseSourceSpan, R3DependencyMetadata, R3Reference, R3ResolvedDependencyType, ReadPropExpr, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\nimport {ImportFlags, Reference, ReferenceEmitter} from '../../imports';\nimport {attachDefaultImportDeclaration} from '../../imports/src/default';\nimport {ForeignFunctionResolver, PartialEvaluator} from '../../partial_evaluator';\nimport {ClassDeclaration, CtorParameter, Decorator, Import, ImportedTypeValueReference, isNamedClassDeclaration, LocalTypeValueReference, ReflectionHost, TypeValueReference, TypeValueReferenceKind, UnavailableValue, ValueUnavailableKind} from '../../reflection';\nimport {DeclarationData} from '../../scope';\n\nexport type ConstructorDeps = {\n  deps: R3DependencyMetadata[];\n}|{\n  deps: null;\n  errors: ConstructorDepError[];\n};\n\nexport interface ConstructorDepError {\n  index: number;\n  param: CtorParameter;\n  reason: UnavailableValue;\n}\n\nexport function getConstructorDependencies(\n    clazz: ClassDeclaration, reflector: ReflectionHost, isCore: boolean): ConstructorDeps|null {\n  const deps: R3DependencyMetadata[] = [];\n  const errors: ConstructorDepError[] = [];\n  let ctorParams = reflector.getConstructorParameters(clazz);\n  if (ctorParams === null) {\n    if (reflector.hasBaseClass(clazz)) {\n      return null;\n    } else {\n      ctorParams = [];\n    }\n  }\n  ctorParams.forEach((param, idx) => {\n    let token = valueReferenceToExpression(param.typeValueReference);\n    let attribute: Expression|null = null;\n    let optional = false, self = false, skipSelf = false, host = false;\n    let resolved = R3ResolvedDependencyType.Token;\n\n    (param.decorators || []).filter(dec => isCore || isAngularCore(dec)).forEach(dec => {\n      const name = isCore || dec.import === null ? dec.name : dec.import!.name;\n      if (name === 'Inject') {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(\n              ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec),\n              `Unexpected number of arguments to @Inject().`);\n        }\n        token = new WrappedNodeExpr(dec.args[0]);\n      } else if (name === 'Optional') {\n        optional = true;\n      } else if (name === 'SkipSelf') {\n        skipSelf = true;\n      } else if (name === 'Self') {\n        self = true;\n      } else if (name === 'Host') {\n        host = true;\n      } else if (name === 'Attribute') {\n        if (dec.args === null || dec.args.length !== 1) {\n          throw new FatalDiagnosticError(\n              ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(dec),\n              `Unexpected number of arguments to @Attribute().`);\n        }\n        const attributeName = dec.args[0];\n        token = new WrappedNodeExpr(attributeName);\n        if (ts.isStringLiteralLike(attributeName)) {\n          attribute = new LiteralExpr(attributeName.text);\n        } else {\n          attribute = new WrappedNodeExpr(ts.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword));\n        }\n        resolved = R3ResolvedDependencyType.Attribute;\n      } else {\n        throw new FatalDiagnosticError(\n            ErrorCode.DECORATOR_UNEXPECTED, Decorator.nodeForError(dec),\n            `Unexpected decorator ${name} on parameter.`);\n      }\n    });\n\n    if (token instanceof ExternalExpr && token.value.name === 'ChangeDetectorRef' &&\n        token.value.moduleName === '@angular/core') {\n      resolved = R3ResolvedDependencyType.ChangeDetectorRef;\n    }\n    if (token === null) {\n      if (param.typeValueReference.kind !== TypeValueReferenceKind.UNAVAILABLE) {\n        throw new Error(\n            'Illegal state: expected value reference to be unavailable if no token is present');\n      }\n      errors.push({\n        index: idx,\n        param,\n        reason: param.typeValueReference.reason,\n      });\n    } else {\n      deps.push({token, attribute, optional, self, skipSelf, host, resolved});\n    }\n  });\n  if (errors.length === 0) {\n    return {deps};\n  } else {\n    return {deps: null, errors};\n  }\n}\n\n/**\n * Convert a `TypeValueReference` to an `Expression` which refers to the type as a value.\n *\n * Local references are converted to a `WrappedNodeExpr` of the TypeScript expression, and non-local\n * references are converted to an `ExternalExpr`. Note that this is only valid in the context of the\n * file in which the `TypeValueReference` originated.\n */\nexport function valueReferenceToExpression(valueRef: LocalTypeValueReference|\n                                           ImportedTypeValueReference): Expression;\nexport function valueReferenceToExpression(valueRef: TypeValueReference): Expression|null;\nexport function valueReferenceToExpression(valueRef: TypeValueReference): Expression|null {\n  if (valueRef.kind === TypeValueReferenceKind.UNAVAILABLE) {\n    return null;\n  } else if (valueRef.kind === TypeValueReferenceKind.LOCAL) {\n    const expr = new WrappedNodeExpr(valueRef.expression);\n    if (valueRef.defaultImportStatement !== null) {\n      attachDefaultImportDeclaration(expr, valueRef.defaultImportStatement);\n    }\n    return expr;\n  } else {\n    let importExpr: Expression =\n        new ExternalExpr({moduleName: valueRef.moduleName, name: valueRef.importedName});\n    if (valueRef.nestedPath !== null) {\n      for (const property of valueRef.nestedPath) {\n        importExpr = new ReadPropExpr(importExpr, property);\n      }\n    }\n    return importExpr;\n  }\n}\n\n/**\n * Convert `ConstructorDeps` into the `R3DependencyMetadata` array for those deps if they're valid,\n * or into an `'invalid'` signal if they're not.\n *\n * This is a companion function to `validateConstructorDependencies` which accepts invalid deps.\n */\nexport function unwrapConstructorDependencies(deps: ConstructorDeps|null): R3DependencyMetadata[]|\n    'invalid'|null {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    // These constructor dependencies are valid.\n    return deps.deps;\n  } else {\n    // These deps are invalid.\n    return 'invalid';\n  }\n}\n\nexport function getValidConstructorDependencies(\n    clazz: ClassDeclaration, reflector: ReflectionHost, isCore: boolean): R3DependencyMetadata[]|\n    null {\n  return validateConstructorDependencies(\n      clazz, getConstructorDependencies(clazz, reflector, isCore));\n}\n\n/**\n * Validate that `ConstructorDeps` does not have any invalid dependencies and convert them into the\n * `R3DependencyMetadata` array if so, or raise a diagnostic if some deps are invalid.\n *\n * This is a companion function to `unwrapConstructorDependencies` which does not accept invalid\n * deps.\n */\nexport function validateConstructorDependencies(\n    clazz: ClassDeclaration, deps: ConstructorDeps|null): R3DependencyMetadata[]|null {\n  if (deps === null) {\n    return null;\n  } else if (deps.deps !== null) {\n    return deps.deps;\n  } else {\n    // TODO(alxhub): this cast is necessary because the g3 typescript version doesn't narrow here.\n    // There is at least one error.\n    const error = (deps as {errors: ConstructorDepError[]}).errors[0];\n    throw createUnsuitableInjectionTokenError(clazz, error);\n  }\n}\n\n/**\n * Creates a fatal error with diagnostic for an invalid injection token.\n * @param clazz The class for which the injection token was unavailable.\n * @param error The reason why no valid injection token is available.\n */\nfunction createUnsuitableInjectionTokenError(\n    clazz: ClassDeclaration, error: ConstructorDepError): FatalDiagnosticError {\n  const {param, index, reason} = error;\n  let chainMessage: string|undefined = undefined;\n  let hints: ts.DiagnosticRelatedInformation[]|undefined = undefined;\n  switch (reason.kind) {\n    case ValueUnavailableKind.UNSUPPORTED:\n      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n      hints = [\n        makeRelatedInformation(reason.typeNode, 'This type is not supported as injection token.'),\n      ];\n      break;\n    case ValueUnavailableKind.NO_VALUE_DECLARATION:\n      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n      hints = [\n        makeRelatedInformation(\n            reason.typeNode,\n            'This type does not have a value, so it cannot be used as injection token.'),\n      ];\n      if (reason.decl !== null) {\n        hints.push(makeRelatedInformation(reason.decl, 'The type is declared here.'));\n      }\n      break;\n    case ValueUnavailableKind.TYPE_ONLY_IMPORT:\n      chainMessage =\n          'Consider changing the type-only import to a regular import, or use the @Inject decorator to specify an injection token.';\n      hints = [\n        makeRelatedInformation(\n            reason.typeNode,\n            'This type is imported using a type-only import, which prevents it from being usable as an injection token.'),\n        makeRelatedInformation(reason.importClause, 'The type-only import occurs here.'),\n      ];\n      break;\n    case ValueUnavailableKind.NAMESPACE:\n      chainMessage = 'Consider using the @Inject decorator to specify an injection token.';\n      hints = [\n        makeRelatedInformation(\n            reason.typeNode,\n            'This type corresponds with a namespace, which cannot be used as injection token.'),\n        makeRelatedInformation(reason.importClause, 'The namespace import occurs here.'),\n      ];\n      break;\n    case ValueUnavailableKind.UNKNOWN_REFERENCE:\n      chainMessage = 'The type should reference a known declaration.';\n      hints = [makeRelatedInformation(reason.typeNode, 'This type could not be resolved.')];\n      break;\n    case ValueUnavailableKind.MISSING_TYPE:\n      chainMessage =\n          'Consider adding a type to the parameter or use the @Inject decorator to specify an injection token.';\n      break;\n  }\n\n  const chain: ts.DiagnosticMessageChain = {\n    messageText: `No suitable injection token for parameter '${param.name || index}' of class '${\n        clazz.name.text}'.`,\n    category: ts.DiagnosticCategory.Error,\n    code: 0,\n    next: [{\n      messageText: chainMessage,\n      category: ts.DiagnosticCategory.Message,\n      code: 0,\n    }],\n  };\n\n  return new FatalDiagnosticError(ErrorCode.PARAM_MISSING_TOKEN, param.nameNode, chain, hints);\n}\n\nexport function toR3Reference(\n    valueRef: Reference, typeRef: Reference, valueContext: ts.SourceFile,\n    typeContext: ts.SourceFile, refEmitter: ReferenceEmitter): R3Reference {\n  return {\n    value: refEmitter.emit(valueRef, valueContext).expression,\n    type: refEmitter\n              .emit(typeRef, typeContext, ImportFlags.ForceNewImport | ImportFlags.AllowTypeImports)\n              .expression,\n  };\n}\n\nexport function isAngularCore(decorator: Decorator): decorator is Decorator&{import: Import} {\n  return decorator.import !== null && decorator.import.from === '@angular/core';\n}\n\nexport function isAngularCoreReference(reference: Reference, symbolName: string): boolean {\n  return reference.ownedByModuleGuess === '@angular/core' && reference.debugName === symbolName;\n}\n\nexport function findAngularDecorator(\n    decorators: Decorator[], name: string, isCore: boolean): Decorator|undefined {\n  return decorators.find(decorator => isAngularDecorator(decorator, name, isCore));\n}\n\nexport function isAngularDecorator(decorator: Decorator, name: string, isCore: boolean): boolean {\n  if (isCore) {\n    return decorator.name === name;\n  } else if (isAngularCore(decorator)) {\n    return decorator.import.name === name;\n  }\n  return false;\n}\n\n/**\n * Unwrap a `ts.Expression`, removing outer type-casts or parentheses until the expression is in its\n * lowest level form.\n *\n * For example, the expression \"(foo as Type)\" unwraps to \"foo\".\n */\nexport function unwrapExpression(node: ts.Expression): ts.Expression {\n  while (ts.isAsExpression(node) || ts.isParenthesizedExpression(node)) {\n    node = node.expression;\n  }\n  return node;\n}\n\nfunction expandForwardRef(arg: ts.Expression): ts.Expression|null {\n  arg = unwrapExpression(arg);\n  if (!ts.isArrowFunction(arg) && !ts.isFunctionExpression(arg)) {\n    return null;\n  }\n\n  const body = arg.body;\n  // Either the body is a ts.Expression directly, or a block with a single return statement.\n  if (ts.isBlock(body)) {\n    // Block body - look for a single return statement.\n    if (body.statements.length !== 1) {\n      return null;\n    }\n    const stmt = body.statements[0];\n    if (!ts.isReturnStatement(stmt) || stmt.expression === undefined) {\n      return null;\n    }\n    return stmt.expression;\n  } else {\n    // Shorthand body - return as an expression.\n    return body;\n  }\n}\n\n/**\n * Possibly resolve a forwardRef() expression into the inner value.\n *\n * @param node the forwardRef() expression to resolve\n * @param reflector a ReflectionHost\n * @returns the resolved expression, if the original expression was a forwardRef(), or the original\n * expression otherwise\n */\nexport function unwrapForwardRef(node: ts.Expression, reflector: ReflectionHost): ts.Expression {\n  node = unwrapExpression(node);\n  if (!ts.isCallExpression(node) || node.arguments.length !== 1) {\n    return node;\n  }\n\n  const fn =\n      ts.isPropertyAccessExpression(node.expression) ? node.expression.name : node.expression;\n  if (!ts.isIdentifier(fn)) {\n    return node;\n  }\n\n  const expr = expandForwardRef(node.arguments[0]);\n  if (expr === null) {\n    return node;\n  }\n  const imp = reflector.getImportOfIdentifier(fn);\n  if (imp === null || imp.from !== '@angular/core' || imp.name !== 'forwardRef') {\n    return node;\n  } else {\n    return expr;\n  }\n}\n\n/**\n * A foreign function resolver for `staticallyResolve` which unwraps forwardRef() expressions.\n *\n * @param ref a Reference to the declaration of the function being called (which might be\n * forwardRef)\n * @param args the arguments to the invocation of the forwardRef expression\n * @returns an unwrapped argument if `ref` pointed to forwardRef, or null otherwise\n */\nexport function forwardRefResolver(\n    ref: Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression>,\n    args: ReadonlyArray<ts.Expression>): ts.Expression|null {\n  if (!isAngularCoreReference(ref, 'forwardRef') || args.length !== 1) {\n    return null;\n  }\n  return expandForwardRef(args[0]);\n}\n\n/**\n * Combines an array of resolver functions into a one.\n * @param resolvers Resolvers to be combined.\n */\nexport function combineResolvers(resolvers: ForeignFunctionResolver[]): ForeignFunctionResolver {\n  return (ref: Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression>,\n          args: ReadonlyArray<ts.Expression>): ts.Expression|null => {\n    for (const resolver of resolvers) {\n      const resolved = resolver(ref, args);\n      if (resolved !== null) {\n        return resolved;\n      }\n    }\n    return null;\n  };\n}\n\nexport function isExpressionForwardReference(\n    expr: Expression, context: ts.Node, contextSource: ts.SourceFile): boolean {\n  if (isWrappedTsNodeExpr(expr)) {\n    const node = ts.getOriginalNode(expr.node);\n    return node.getSourceFile() === contextSource && context.pos < node.pos;\n  } else {\n    return false;\n  }\n}\n\nexport function isWrappedTsNodeExpr(expr: Expression): expr is WrappedNodeExpr<ts.Node> {\n  return expr instanceof WrappedNodeExpr;\n}\n\nexport function readBaseClass(\n    node: ClassDeclaration, reflector: ReflectionHost,\n    evaluator: PartialEvaluator): Reference<ClassDeclaration>|'dynamic'|null {\n  const baseExpression = reflector.getBaseClassExpression(node);\n  if (baseExpression !== null) {\n    const baseClass = evaluator.evaluate(baseExpression);\n    if (baseClass instanceof Reference && reflector.isClass(baseClass.node)) {\n      return baseClass as Reference<ClassDeclaration>;\n    } else {\n      return 'dynamic';\n    }\n  }\n\n  return null;\n}\n\nconst parensWrapperTransformerFactory: ts.TransformerFactory<ts.Expression> =\n    (context: ts.TransformationContext) => {\n      const visitor: ts.Visitor = (node: ts.Node): ts.Node => {\n        const visited = ts.visitEachChild(node, visitor, context);\n        if (ts.isArrowFunction(visited) || ts.isFunctionExpression(visited)) {\n          return ts.createParen(visited);\n        }\n        return visited;\n      };\n      return (node: ts.Expression) => ts.visitEachChild(node, visitor, context);\n    };\n\n/**\n * Wraps all functions in a given expression in parentheses. This is needed to avoid problems\n * where Tsickle annotations added between analyse and transform phases in Angular may trigger\n * automatic semicolon insertion, e.g. if a function is the expression in a `return` statement.\n * More\n * info can be found in Tsickle source code here:\n * https://github.com/angular/tsickle/blob/d7974262571c8a17d684e5ba07680e1b1993afdd/src/jsdoc_transformer.ts#L1021\n *\n * @param expression Expression where functions should be wrapped in parentheses\n */\nexport function wrapFunctionExpressionsInParens(expression: ts.Expression): ts.Expression {\n  return ts.transform(expression, [parensWrapperTransformerFactory]).transformed[0];\n}\n\n/**\n * Create a `ts.Diagnostic` which indicates the given class is part of the declarations of two or\n * more NgModules.\n *\n * The resulting `ts.Diagnostic` will have a context entry for each NgModule showing the point where\n * the directive/pipe exists in its `declarations` (if possible).\n */\nexport function makeDuplicateDeclarationError(\n    node: ClassDeclaration, data: DeclarationData[], kind: string): ts.Diagnostic {\n  const context: ts.DiagnosticRelatedInformation[] = [];\n  for (const decl of data) {\n    if (decl.rawDeclarations === null) {\n      continue;\n    }\n    // Try to find the reference to the declaration within the declarations array, to hang the\n    // error there. If it can't be found, fall back on using the NgModule's name.\n    const contextNode = decl.ref.getOriginForDiagnostics(decl.rawDeclarations, decl.ngModule.name);\n    context.push(makeRelatedInformation(\n        contextNode,\n        `'${node.name.text}' is listed in the declarations of the NgModule '${\n            decl.ngModule.name.text}'.`));\n  }\n\n  // Finally, produce the diagnostic.\n  return makeDiagnostic(\n      ErrorCode.NGMODULE_DECLARATION_NOT_UNIQUE, node.name,\n      `The ${kind} '${node.name.text}' is declared by more than one NgModule.`, context);\n}\n\n/**\n * Resolves the given `rawProviders` into `ClassDeclarations` and returns\n * a set containing those that are known to require a factory definition.\n * @param rawProviders Expression that declared the providers array in the source.\n */\nexport function resolveProvidersRequiringFactory(\n    rawProviders: ts.Expression, reflector: ReflectionHost,\n    evaluator: PartialEvaluator): Set<Reference<ClassDeclaration>> {\n  const providers = new Set<Reference<ClassDeclaration>>();\n  const resolvedProviders = evaluator.evaluate(rawProviders);\n\n  if (!Array.isArray(resolvedProviders)) {\n    return providers;\n  }\n\n  resolvedProviders.forEach(function processProviders(provider) {\n    let tokenClass: Reference|null = null;\n\n    if (Array.isArray(provider)) {\n      // If we ran into an array, recurse into it until we've resolve all the classes.\n      provider.forEach(processProviders);\n    } else if (provider instanceof Reference) {\n      tokenClass = provider;\n    } else if (provider instanceof Map && provider.has('useClass') && !provider.has('deps')) {\n      const useExisting = provider.get('useClass')!;\n      if (useExisting instanceof Reference) {\n        tokenClass = useExisting;\n      }\n    }\n\n    // TODO(alxhub): there was a bug where `getConstructorParameters` would return `null` for a\n    // class in a .d.ts file, always, even if the class had a constructor. This was fixed for\n    // `getConstructorParameters`, but that fix causes more classes to be recognized here as needing\n    // provider checks, which is a breaking change in g3. Avoid this breakage for now by skipping\n    // classes from .d.ts files here directly, until g3 can be cleaned up.\n    if (tokenClass !== null && !tokenClass.node.getSourceFile().isDeclarationFile &&\n        reflector.isClass(tokenClass.node)) {\n      const constructorParameters = reflector.getConstructorParameters(tokenClass.node);\n\n      // Note that we only want to capture providers with a non-trivial constructor,\n      // because they're the ones that might be using DI and need to be decorated.\n      if (constructorParameters !== null && constructorParameters.length > 0) {\n        providers.add(tokenClass as Reference<ClassDeclaration>);\n      }\n    }\n  });\n\n  return providers;\n}\n\n/**\n * Create an R3Reference for a class.\n *\n * The `value` is the exported declaration of the class from its source file.\n * The `type` is an expression that would be used by ngcc in the typings (.d.ts) files.\n */\nexport function wrapTypeReference(reflector: ReflectionHost, clazz: ClassDeclaration): R3Reference {\n  const dtsClass = reflector.getDtsDeclaration(clazz);\n  const value = new WrappedNodeExpr(clazz.name);\n  const type = dtsClass !== null && isNamedClassDeclaration(dtsClass) ?\n      new WrappedNodeExpr(dtsClass.name) :\n      value;\n  return {value, type};\n}\n\n/** Creates a ParseSourceSpan for a TypeScript node. */\nexport function createSourceSpan(node: ts.Node): ParseSourceSpan {\n  const sf = node.getSourceFile();\n  const [startOffset, endOffset] = [node.getStart(), node.getEnd()];\n  const {line: startLine, character: startCol} = sf.getLineAndCharacterOfPosition(startOffset);\n  const {line: endLine, character: endCol} = sf.getLineAndCharacterOfPosition(endOffset);\n  const parseSf = new ParseSourceFile(sf.getFullText(), sf.fileName);\n\n  // +1 because values are zero-indexed.\n  return new ParseSourceSpan(\n      new ParseLocation(parseSf, startOffset, startLine + 1, startCol + 1),\n      new ParseLocation(parseSf, endOffset, endLine + 1, endCol + 1));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}