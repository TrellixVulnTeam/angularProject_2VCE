{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar utils = require(\"../../utils\");\n\nvar Matcher = /*#__PURE__*/function () {\n  function Matcher(_patterns, _settings, _micromatchOptions) {\n    _classCallCheck(this, Matcher);\n\n    this._patterns = _patterns;\n    this._settings = _settings;\n    this._micromatchOptions = _micromatchOptions;\n    this._storage = [];\n\n    this._fillStorage();\n  }\n\n  _createClass(Matcher, [{\n    key: \"_fillStorage\",\n    value: function _fillStorage() {\n      /**\r\n       * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n       * So, before expand patterns with brace expansion into separated patterns.\r\n       */\n      var patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\n\n      var _iterator = _createForOfIteratorHelper(patterns),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pattern = _step.value;\n\n          var segments = this._getPatternSegments(pattern);\n\n          var sections = this._splitSegmentsIntoSections(segments);\n\n          this._storage.push({\n            complete: sections.length <= 1,\n            pattern: pattern,\n            segments: segments,\n            sections: sections\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_getPatternSegments\",\n    value: function _getPatternSegments(pattern) {\n      var _this = this;\n\n      var parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\n      return parts.map(function (part) {\n        var dynamic = utils.pattern.isDynamicPattern(part, _this._settings);\n\n        if (!dynamic) {\n          return {\n            dynamic: false,\n            pattern: part\n          };\n        }\n\n        return {\n          dynamic: true,\n          pattern: part,\n          patternRe: utils.pattern.makeRe(part, _this._micromatchOptions)\n        };\n      });\n    }\n  }, {\n    key: \"_splitSegmentsIntoSections\",\n    value: function _splitSegmentsIntoSections(segments) {\n      return utils.array.splitWhen(segments, function (segment) {\n        return segment.dynamic && utils.pattern.hasGlobStar(segment.pattern);\n      });\n    }\n  }]);\n\n  return Matcher;\n}();\n\nexports.default = Matcher;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/fast-glob/out/providers/matchers/matcher.js"],"names":["Object","defineProperty","exports","value","utils","require","Matcher","_patterns","_settings","_micromatchOptions","_storage","_fillStorage","patterns","pattern","expandPatternsWithBraceExpansion","segments","_getPatternSegments","sections","_splitSegmentsIntoSections","push","complete","length","parts","getPatternParts","map","part","dynamic","isDynamicPattern","patternRe","makeRe","array","splitWhen","segment","hasGlobStar","default"],"mappings":"AAAA;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,KAAK,GAAGC,OAAO,CAAC,aAAD,CAArB;;IACMC,O;AACF,mBAAYC,SAAZ,EAAuBC,SAAvB,EAAkCC,kBAAlC,EAAsD;AAAA;;AAClD,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,kBAAL,GAA0BA,kBAA1B;AACA,SAAKC,QAAL,GAAgB,EAAhB;;AACA,SAAKC,YAAL;AACH;;;;WACD,wBAAe;AACX;AACR;AACA;AACA;AACQ,UAAMC,QAAQ,GAAGR,KAAK,CAACS,OAAN,CAAcC,gCAAd,CAA+C,KAAKP,SAApD,CAAjB;;AALW,iDAMWK,QANX;AAAA;;AAAA;AAMX,4DAAgC;AAAA,cAArBC,OAAqB;;AAC5B,cAAME,QAAQ,GAAG,KAAKC,mBAAL,CAAyBH,OAAzB,CAAjB;;AACA,cAAMI,QAAQ,GAAG,KAAKC,0BAAL,CAAgCH,QAAhC,CAAjB;;AACA,eAAKL,QAAL,CAAcS,IAAd,CAAmB;AACfC,YAAAA,QAAQ,EAAEH,QAAQ,CAACI,MAAT,IAAmB,CADd;AAEfR,YAAAA,OAAO,EAAPA,OAFe;AAGfE,YAAAA,QAAQ,EAARA,QAHe;AAIfE,YAAAA,QAAQ,EAARA;AAJe,WAAnB;AAMH;AAfU;AAAA;AAAA;AAAA;AAAA;AAgBd;;;WACD,6BAAoBJ,OAApB,EAA6B;AAAA;;AACzB,UAAMS,KAAK,GAAGlB,KAAK,CAACS,OAAN,CAAcU,eAAd,CAA8BV,OAA9B,EAAuC,KAAKJ,kBAA5C,CAAd;AACA,aAAOa,KAAK,CAACE,GAAN,CAAU,UAACC,IAAD,EAAU;AACvB,YAAMC,OAAO,GAAGtB,KAAK,CAACS,OAAN,CAAcc,gBAAd,CAA+BF,IAA/B,EAAqC,KAAI,CAACjB,SAA1C,CAAhB;;AACA,YAAI,CAACkB,OAAL,EAAc;AACV,iBAAO;AACHA,YAAAA,OAAO,EAAE,KADN;AAEHb,YAAAA,OAAO,EAAEY;AAFN,WAAP;AAIH;;AACD,eAAO;AACHC,UAAAA,OAAO,EAAE,IADN;AAEHb,UAAAA,OAAO,EAAEY,IAFN;AAGHG,UAAAA,SAAS,EAAExB,KAAK,CAACS,OAAN,CAAcgB,MAAd,CAAqBJ,IAArB,EAA2B,KAAI,CAAChB,kBAAhC;AAHR,SAAP;AAKH,OAbM,CAAP;AAcH;;;WACD,oCAA2BM,QAA3B,EAAqC;AACjC,aAAOX,KAAK,CAAC0B,KAAN,CAAYC,SAAZ,CAAsBhB,QAAtB,EAAgC,UAACiB,OAAD;AAAA,eAAaA,OAAO,CAACN,OAAR,IAAmBtB,KAAK,CAACS,OAAN,CAAcoB,WAAd,CAA0BD,OAAO,CAACnB,OAAlC,CAAhC;AAAA,OAAhC,CAAP;AACH;;;;;;AAELX,OAAO,CAACgC,OAAR,GAAkB5B,OAAlB","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils = require(\"../../utils\");\r\nclass Matcher {\r\n    constructor(_patterns, _settings, _micromatchOptions) {\r\n        this._patterns = _patterns;\r\n        this._settings = _settings;\r\n        this._micromatchOptions = _micromatchOptions;\r\n        this._storage = [];\r\n        this._fillStorage();\r\n    }\r\n    _fillStorage() {\r\n        /**\r\n         * The original pattern may include `{,*,**,a/*}`, which will lead to problems with matching (unresolved level).\r\n         * So, before expand patterns with brace expansion into separated patterns.\r\n         */\r\n        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);\r\n        for (const pattern of patterns) {\r\n            const segments = this._getPatternSegments(pattern);\r\n            const sections = this._splitSegmentsIntoSections(segments);\r\n            this._storage.push({\r\n                complete: sections.length <= 1,\r\n                pattern,\r\n                segments,\r\n                sections\r\n            });\r\n        }\r\n    }\r\n    _getPatternSegments(pattern) {\r\n        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);\r\n        return parts.map((part) => {\r\n            const dynamic = utils.pattern.isDynamicPattern(part, this._settings);\r\n            if (!dynamic) {\r\n                return {\r\n                    dynamic: false,\r\n                    pattern: part\r\n                };\r\n            }\r\n            return {\r\n                dynamic: true,\r\n                pattern: part,\r\n                patternRe: utils.pattern.makeRe(part, this._micromatchOptions)\r\n            };\r\n        });\r\n    }\r\n    _splitSegmentsIntoSections(segments) {\r\n        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));\r\n    }\r\n}\r\nexports.default = Matcher;\r\n"]},"metadata":{},"sourceType":"script"}