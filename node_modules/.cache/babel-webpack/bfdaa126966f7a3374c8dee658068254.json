{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/aot/static_symbol\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.StaticSymbolCache = exports.StaticSymbol = void 0;\n  /**\n   * A token representing the a reference to a static type.\n   *\n   * This token is unique for a filePath and name and can be used as a hash table key.\n   */\n\n  var StaticSymbol =\n  /** @class */\n  function () {\n    function StaticSymbol(filePath, name, members) {\n      this.filePath = filePath;\n      this.name = name;\n      this.members = members;\n    }\n\n    StaticSymbol.prototype.assertNoMembers = function () {\n      if (this.members.length) {\n        throw new Error(\"Illegal state: symbol without members expected, but got \" + JSON.stringify(this) + \".\");\n      }\n    };\n\n    return StaticSymbol;\n  }();\n\n  exports.StaticSymbol = StaticSymbol;\n  /**\n   * A cache of static symbol used by the StaticReflector to return the same symbol for the\n   * same symbol values.\n   */\n\n  var StaticSymbolCache =\n  /** @class */\n  function () {\n    function StaticSymbolCache() {\n      this.cache = new Map();\n    }\n\n    StaticSymbolCache.prototype.get = function (declarationFile, name, members) {\n      members = members || [];\n      var memberSuffix = members.length ? \".\" + members.join('.') : '';\n      var key = \"\\\"\" + declarationFile + \"\\\".\" + name + memberSuffix;\n      var result = this.cache.get(key);\n\n      if (!result) {\n        result = new StaticSymbol(declarationFile, name, members);\n        this.cache.set(key, result);\n      }\n\n      return result;\n    };\n\n    return StaticSymbolCache;\n  }();\n\n  exports.StaticSymbolCache = StaticSymbolCache;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/static_symbol.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;AAEH;;;;AAIG;;AACH,MAAA,YAAA;AAAA;AAAA,cAAA;AACE,aAAA,YAAA,CAAmB,QAAnB,EAA4C,IAA5C,EAAiE,OAAjE,EAAkF;AAA/D,WAAA,QAAA,GAAA,QAAA;AAAyB,WAAA,IAAA,GAAA,IAAA;AAAqB,WAAA,OAAA,GAAA,OAAA;AAAqB;;AAEtF,IAAA,YAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,UAAI,KAAK,OAAL,CAAa,MAAjB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CACF,6DAA2D,IAAI,CAAC,SAAL,CAAe,IAAf,CAA3D,GAA+E,GAD7E,CAAN;AAED;AACF,KALD;;AAMF,WAAA,YAAA;AAAC,GATD,EAAA;;AAAa,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA;AAWb;;;AAGG;;AACH,MAAA,iBAAA;AAAA;AAAA,cAAA;AAAA,aAAA,iBAAA,GAAA;AACU,WAAA,KAAA,GAAQ,IAAI,GAAJ,EAAR;AAaT;;AAXC,IAAA,iBAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,eAAJ,EAA6B,IAA7B,EAA2C,OAA3C,EAA6D;AAC3D,MAAA,OAAO,GAAG,OAAO,IAAI,EAArB;AACA,UAAM,YAAY,GAAG,OAAO,CAAC,MAAR,GAAiB,MAAI,OAAO,CAAC,IAAR,CAAa,GAAb,CAArB,GAA2C,EAAhE;AACA,UAAM,GAAG,GAAG,OAAI,eAAJ,GAAmB,KAAnB,GAAwB,IAAxB,GAA+B,YAA3C;AACA,UAAI,MAAM,GAAG,KAAK,KAAL,CAAW,GAAX,CAAe,GAAf,CAAb;;AACA,UAAI,CAAC,MAAL,EAAa;AACX,QAAA,MAAM,GAAG,IAAI,YAAJ,CAAiB,eAAjB,EAAkC,IAAlC,EAAwC,OAAxC,CAAT;AACA,aAAK,KAAL,CAAW,GAAX,CAAe,GAAf,EAAoB,MAApB;AACD;;AACD,aAAO,MAAP;AACD,KAVD;;AAWF,WAAA,iBAAA;AAAC,GAdD,EAAA;;AAAa,EAAA,OAAA,CAAA,iBAAA,GAAA,iBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nexport class StaticSymbol {\n  constructor(public filePath: string, public name: string, public members: string[]) {}\n\n  assertNoMembers() {\n    if (this.members.length) {\n      throw new Error(\n          `Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);\n    }\n  }\n}\n\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nexport class StaticSymbolCache {\n  private cache = new Map<string, StaticSymbol>();\n\n  get(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    members = members || [];\n    const memberSuffix = members.length ? `.${members.join('.')}` : '';\n    const key = `\"${declarationFile}\".${name}${memberSuffix}`;\n    let result = this.cache.get(key);\n    if (!result) {\n      result = new StaticSymbol(declarationFile, name, members);\n      this.cache.set(key, result);\n    }\n    return result;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}