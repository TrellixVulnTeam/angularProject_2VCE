{"ast":null,"code":"'use strict';\n/* eslint-disable\n  arrow-parens,\n  multiline-ternary,\n  consistent-return,\n  no-param-reassign,\n  prefer-destructuring\n*/\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar noop = function noop() {};\n\nvar levels = Symbol('levels');\nvar instance = Symbol('instance');\n\nvar MethodFactory = /*#__PURE__*/function () {\n  function MethodFactory(logger) {\n    _classCallCheck(this, MethodFactory);\n\n    this[levels] = {\n      TRACE: 0,\n      DEBUG: 1,\n      INFO: 2,\n      WARN: 3,\n      ERROR: 4,\n      SILENT: 5\n    };\n    this[instance] = logger;\n  }\n\n  _createClass(MethodFactory, [{\n    key: \"logger\",\n    get: function get() {\n      return this[instance];\n    },\n    set: function set(logger) {\n      this[instance] = logger;\n    }\n  }, {\n    key: \"levels\",\n    get: function get() {\n      return this[levels];\n    }\n  }, {\n    key: \"methods\",\n    get: function get() {\n      return Object.keys(this.levels).map(function (key) {\n        return key.toLowerCase();\n      }).filter(function (key) {\n        return key !== 'silent';\n      });\n    }\n  }, {\n    key: \"distillLevel\",\n    value: function distillLevel(level) {\n      var result = level;\n\n      if (typeof result === 'string' && typeof this.levels[result.toUpperCase()] !== 'undefined') {\n        result = this.levels[result.toUpperCase()];\n      }\n\n      if (this.levelValid(result)) {\n        return result;\n      }\n    }\n  }, {\n    key: \"levelValid\",\n    value: function levelValid(level) {\n      if (typeof level === 'number' && level >= 0 && level <= this.levels.SILENT) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Build the best logging method possible for this env\n     * Wherever possible we want to bind, not wrap, to preserve stack traces.\n     * Since we're targeting modern browsers, there's no need to wait for the\n     * console to become available.\n     */\n    // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"make\",\n    value: function make(method) {\n      if (method === 'debug') {\n        method = 'log';\n      }\n      /* eslint-disable no-console */\n\n\n      if (typeof console[method] !== 'undefined') {\n        return this.bindMethod(console, method);\n      } else if (typeof console.log !== 'undefined') {\n        return this.bindMethod(console, 'log');\n      }\n      /* eslint-enable no-console */\n\n\n      return noop;\n    } // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"bindMethod\",\n    value: function bindMethod(obj, name) {\n      var method = obj[name];\n\n      if (typeof method.bind === 'function') {\n        return method.bind(obj);\n      }\n\n      try {\n        return Function.prototype.bind.call(method, obj);\n      } catch (err) {\n        // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n        return function result() {\n          // eslint-disable-next-line prefer-rest-params\n          return Function.prototype.apply.apply(method, [obj, arguments]);\n        };\n      }\n    }\n  }, {\n    key: \"replaceMethods\",\n    value: function replaceMethods(logLevel) {\n      var _this = this;\n\n      var level = this.distillLevel(logLevel);\n\n      if (level == null) {\n        throw new Error(\"loglevel: replaceMethods() called with invalid level: \".concat(logLevel));\n      }\n\n      if (!this.logger || this.logger.type !== 'LogLevel') {\n        throw new TypeError('loglevel: Logger is undefined or invalid. Please specify a valid Logger instance.');\n      }\n\n      this.methods.forEach(function (method) {\n        _this.logger[method] = _this.levels[method.toUpperCase()] < level ? noop : _this.make(method);\n      }); // Define log.log as an alias for log.debug\n\n      this.logger.log = this.logger.debug;\n    }\n  }]);\n\n  return MethodFactory;\n}();\n\nmodule.exports = MethodFactory;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack-log/src/loglevel/MethodFactory.js"],"names":["noop","levels","Symbol","instance","MethodFactory","logger","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","Object","keys","map","key","toLowerCase","filter","level","result","toUpperCase","levelValid","method","console","bindMethod","log","obj","name","bind","Function","prototype","call","err","apply","arguments","logLevel","distillLevel","Error","type","TypeError","methods","forEach","make","debug","module","exports"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AACA,IAAMA,IAAI,GAAG,SAAPA,IAAO,GAAM,CAAE,CAArB;;AAEA,IAAMC,MAAM,GAAGC,MAAM,CAAC,QAAD,CAArB;AACA,IAAMC,QAAQ,GAAGD,MAAM,CAAC,UAAD,CAAvB;;IAEME,a;AACJ,yBAAYC,MAAZ,EAAoB;AAAA;;AAClB,SAAKJ,MAAL,IAAe;AACbK,MAAAA,KAAK,EAAE,CADM;AAEbC,MAAAA,KAAK,EAAE,CAFM;AAGbC,MAAAA,IAAI,EAAE,CAHO;AAIbC,MAAAA,IAAI,EAAE,CAJO;AAKbC,MAAAA,KAAK,EAAE,CALM;AAMbC,MAAAA,MAAM,EAAE;AANK,KAAf;AASA,SAAKR,QAAL,IAAiBE,MAAjB;AACD;;;;SAMD,eAAa;AACX,aAAO,KAAKF,QAAL,CAAP;AACD,K;SAND,aAAWE,MAAX,EAAmB;AACjB,WAAKF,QAAL,IAAiBE,MAAjB;AACD;;;SAMD,eAAa;AACX,aAAO,KAAKJ,MAAL,CAAP;AACD;;;SAED,eAAc;AACZ,aAAOW,MAAM,CAACC,IAAP,CAAY,KAAKZ,MAAjB,EACJa,GADI,CACA,UAACC,GAAD;AAAA,eAASA,GAAG,CAACC,WAAJ,EAAT;AAAA,OADA,EAEJC,MAFI,CAEG,UAACF,GAAD;AAAA,eAASA,GAAG,KAAK,QAAjB;AAAA,OAFH,CAAP;AAGD;;;WAED,sBAAaG,KAAb,EAAoB;AAClB,UAAIC,MAAM,GAAGD,KAAb;;AAEA,UACE,OAAOC,MAAP,KAAkB,QAAlB,IACA,OAAO,KAAKlB,MAAL,CAAYkB,MAAM,CAACC,WAAP,EAAZ,CAAP,KAA6C,WAF/C,EAGE;AACAD,QAAAA,MAAM,GAAG,KAAKlB,MAAL,CAAYkB,MAAM,CAACC,WAAP,EAAZ,CAAT;AACD;;AAED,UAAI,KAAKC,UAAL,CAAgBF,MAAhB,CAAJ,EAA6B;AAC3B,eAAOA,MAAP;AACD;AACF;;;WAED,oBAAWD,KAAX,EAAkB;AAChB,UACE,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,IAAI,CAAtC,IACAA,KAAK,IAAI,KAAKjB,MAAL,CAAYU,MAFvB,EAGE;AACA,eAAO,IAAP;AACD;;AAED,aAAO,KAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACE;;;;WACA,cAAKW,MAAL,EAAa;AACX,UAAIA,MAAM,KAAK,OAAf,EAAwB;AACtBA,QAAAA,MAAM,GAAG,KAAT;AACD;AAED;;;AACA,UAAI,OAAOC,OAAO,CAACD,MAAD,CAAd,KAA2B,WAA/B,EAA4C;AAC1C,eAAO,KAAKE,UAAL,CAAgBD,OAAhB,EAAyBD,MAAzB,CAAP;AACD,OAFD,MAEO,IAAI,OAAOC,OAAO,CAACE,GAAf,KAAuB,WAA3B,EAAwC;AAC7C,eAAO,KAAKD,UAAL,CAAgBD,OAAhB,EAAyB,KAAzB,CAAP;AACD;AAED;;;AACA,aAAOvB,IAAP;AACD,K,CAED;;;;WACA,oBAAW0B,GAAX,EAAgBC,IAAhB,EAAsB;AACpB,UAAML,MAAM,GAAGI,GAAG,CAACC,IAAD,CAAlB;;AAEA,UAAI,OAAOL,MAAM,CAACM,IAAd,KAAuB,UAA3B,EAAuC;AACrC,eAAON,MAAM,CAACM,IAAP,CAAYF,GAAZ,CAAP;AACD;;AAED,UAAI;AACF,eAAOG,QAAQ,CAACC,SAAT,CAAmBF,IAAnB,CAAwBG,IAAxB,CAA6BT,MAA7B,EAAqCI,GAArC,CAAP;AACD,OAFD,CAEE,OAAOM,GAAP,EAAY;AACZ;AACA,eAAO,SAASb,MAAT,GAAkB;AACvB;AACA,iBAAOU,QAAQ,CAACC,SAAT,CAAmBG,KAAnB,CAAyBA,KAAzB,CAA+BX,MAA/B,EAAuC,CAACI,GAAD,EAAMQ,SAAN,CAAvC,CAAP;AACD,SAHD;AAID;AACF;;;WAED,wBAAeC,QAAf,EAAyB;AAAA;;AACvB,UAAMjB,KAAK,GAAG,KAAKkB,YAAL,CAAkBD,QAAlB,CAAd;;AAEA,UAAIjB,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAM,IAAImB,KAAJ,iEACqDF,QADrD,EAAN;AAGD;;AAED,UAAI,CAAC,KAAK9B,MAAN,IAAgB,KAAKA,MAAL,CAAYiC,IAAZ,KAAqB,UAAzC,EAAqD;AACnD,cAAM,IAAIC,SAAJ,CACJ,mFADI,CAAN;AAGD;;AAED,WAAKC,OAAL,CAAaC,OAAb,CAAqB,UAACnB,MAAD,EAAY;AAC/B,QAAA,KAAI,CAACjB,MAAL,CAAYiB,MAAZ,IAAuB,KAAI,CAACrB,MAAL,CAAYqB,MAAM,CAACF,WAAP,EAAZ,IAAoCF,KAArC,GAClBlB,IADkB,GAElB,KAAI,CAAC0C,IAAL,CAAUpB,MAAV,CAFJ;AAGD,OAJD,EAfuB,CAqBvB;;AACA,WAAKjB,MAAL,CAAYoB,GAAZ,GAAkB,KAAKpB,MAAL,CAAYsC,KAA9B;AACD;;;;;;AAGHC,MAAM,CAACC,OAAP,GAAiBzC,aAAjB","sourcesContent":["'use strict';\n\n/* eslint-disable\n  arrow-parens,\n  multiline-ternary,\n  consistent-return,\n  no-param-reassign,\n  prefer-destructuring\n*/\nconst noop = () => {};\n\nconst levels = Symbol('levels');\nconst instance = Symbol('instance');\n\nclass MethodFactory {\n  constructor(logger) {\n    this[levels] = {\n      TRACE: 0,\n      DEBUG: 1,\n      INFO: 2,\n      WARN: 3,\n      ERROR: 4,\n      SILENT: 5\n    };\n\n    this[instance] = logger;\n  }\n\n  set logger(logger) {\n    this[instance] = logger;\n  }\n\n  get logger() {\n    return this[instance];\n  }\n\n  get levels() {\n    return this[levels];\n  }\n\n  get methods() {\n    return Object.keys(this.levels)\n      .map((key) => key.toLowerCase())\n      .filter((key) => key !== 'silent');\n  }\n\n  distillLevel(level) {\n    let result = level;\n\n    if (\n      typeof result === 'string' &&\n      typeof this.levels[result.toUpperCase()] !== 'undefined'\n    ) {\n      result = this.levels[result.toUpperCase()];\n    }\n\n    if (this.levelValid(result)) {\n      return result;\n    }\n  }\n\n  levelValid(level) {\n    if (\n      typeof level === 'number' && level >= 0 &&\n      level <= this.levels.SILENT\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Build the best logging method possible for this env\n   * Wherever possible we want to bind, not wrap, to preserve stack traces.\n   * Since we're targeting modern browsers, there's no need to wait for the\n   * console to become available.\n   */\n  // eslint-disable-next-line class-methods-use-this\n  make(method) {\n    if (method === 'debug') {\n      method = 'log';\n    }\n\n    /* eslint-disable no-console */\n    if (typeof console[method] !== 'undefined') {\n      return this.bindMethod(console, method);\n    } else if (typeof console.log !== 'undefined') {\n      return this.bindMethod(console, 'log');\n    }\n\n    /* eslint-enable no-console */\n    return noop;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  bindMethod(obj, name) {\n    const method = obj[name];\n\n    if (typeof method.bind === 'function') {\n      return method.bind(obj);\n    }\n\n    try {\n      return Function.prototype.bind.call(method, obj);\n    } catch (err) {\n      // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n      return function result() {\n        // eslint-disable-next-line prefer-rest-params\n        return Function.prototype.apply.apply(method, [obj, arguments]);\n      };\n    }\n  }\n\n  replaceMethods(logLevel) {\n    const level = this.distillLevel(logLevel);\n\n    if (level == null) {\n      throw new Error(\n        `loglevel: replaceMethods() called with invalid level: ${logLevel}`\n      );\n    }\n\n    if (!this.logger || this.logger.type !== 'LogLevel') {\n      throw new TypeError(\n        'loglevel: Logger is undefined or invalid. Please specify a valid Logger instance.'\n      );\n    }\n\n    this.methods.forEach((method) => {\n      this.logger[method] = (this.levels[method.toUpperCase()] < level)\n        ? noop\n        : this.make(method);\n    });\n\n    // Define log.log as an alias for log.debug\n    this.logger.log = this.logger.debug;\n  }\n}\n\nmodule.exports = MethodFactory;\n"]},"metadata":{},"sourceType":"script"}