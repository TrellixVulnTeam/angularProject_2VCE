{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/ngcc_options\", [\"require\", \"exports\", \"os\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/logging\", \"@angular/compiler-cli/src/perform_compile\", \"@angular/compiler-cli/ngcc/src/packages/entry_point\", \"@angular/compiler-cli/ngcc/src/path_mappings\", \"@angular/compiler-cli/ngcc/src/writing/in_place_file_writer\", \"@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getMaxNumberOfWorkers = exports.clearTsConfigCache = exports.getSharedSetup = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var os = require(\"os\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var logging_1 = require(\"@angular/compiler-cli/src/ngtsc/logging\");\n\n  var perform_compile_1 = require(\"@angular/compiler-cli/src/perform_compile\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point\");\n\n  var path_mappings_1 = require(\"@angular/compiler-cli/ngcc/src/path_mappings\");\n\n  var in_place_file_writer_1 = require(\"@angular/compiler-cli/ngcc/src/writing/in_place_file_writer\");\n\n  var new_entry_point_file_writer_1 = require(\"@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer\");\n  /**\n   * Instantiate common utilities that are always used and fix up options with defaults, as necessary.\n   *\n   * NOTE: Avoid eagerly instantiating anything that might not be used when running sync/async.\n   */\n\n\n  function getSharedSetup(options) {\n    var fileSystem = file_system_1.getFileSystem();\n    var absBasePath = file_system_1.absoluteFrom(options.basePath);\n    var projectPath = fileSystem.dirname(absBasePath);\n    var tsConfig = options.tsConfigPath !== null ? getTsConfig(options.tsConfigPath || projectPath) : null;\n    var basePath = options.basePath,\n        targetEntryPointPath = options.targetEntryPointPath,\n        _a = options.propertiesToConsider,\n        propertiesToConsider = _a === void 0 ? entry_point_1.SUPPORTED_FORMAT_PROPERTIES : _a,\n        _b = options.typingsOnly,\n        typingsOnly = _b === void 0 ? false : _b,\n        _c = options.compileAllFormats,\n        compileAllFormats = _c === void 0 ? true : _c,\n        _d = options.createNewEntryPointFormats,\n        createNewEntryPointFormats = _d === void 0 ? false : _d,\n        _e = options.logger,\n        logger = _e === void 0 ? new logging_1.ConsoleLogger(logging_1.LogLevel.info) : _e,\n        _f = options.pathMappings,\n        pathMappings = _f === void 0 ? path_mappings_1.getPathMappingsFromTsConfig(fileSystem, tsConfig, projectPath) : _f,\n        _g = options.async,\n        async = _g === void 0 ? false : _g,\n        _h = options.errorOnFailedEntryPoint,\n        errorOnFailedEntryPoint = _h === void 0 ? false : _h,\n        _j = options.enableI18nLegacyMessageIdFormat,\n        enableI18nLegacyMessageIdFormat = _j === void 0 ? true : _j,\n        _k = options.invalidateEntryPointManifest,\n        invalidateEntryPointManifest = _k === void 0 ? false : _k,\n        tsConfigPath = options.tsConfigPath;\n\n    if (!!targetEntryPointPath) {\n      // targetEntryPointPath forces us to error if an entry-point fails.\n      errorOnFailedEntryPoint = true;\n    }\n\n    if (typingsOnly) {\n      // If we only want to process the typings then we do not want to waste time trying to process\n      // multiple JS formats.\n      compileAllFormats = false;\n    }\n\n    checkForSolutionStyleTsConfig(fileSystem, logger, projectPath, options.tsConfigPath, tsConfig);\n    return {\n      basePath: basePath,\n      targetEntryPointPath: targetEntryPointPath,\n      propertiesToConsider: propertiesToConsider,\n      typingsOnly: typingsOnly,\n      compileAllFormats: compileAllFormats,\n      createNewEntryPointFormats: createNewEntryPointFormats,\n      logger: logger,\n      pathMappings: pathMappings,\n      async: async,\n      errorOnFailedEntryPoint: errorOnFailedEntryPoint,\n      enableI18nLegacyMessageIdFormat: enableI18nLegacyMessageIdFormat,\n      invalidateEntryPointManifest: invalidateEntryPointManifest,\n      tsConfigPath: tsConfigPath,\n      fileSystem: fileSystem,\n      absBasePath: absBasePath,\n      projectPath: projectPath,\n      tsConfig: tsConfig,\n      getFileWriter: function getFileWriter(pkgJsonUpdater) {\n        return createNewEntryPointFormats ? new new_entry_point_file_writer_1.NewEntryPointFileWriter(fileSystem, logger, errorOnFailedEntryPoint, pkgJsonUpdater) : new in_place_file_writer_1.InPlaceFileWriter(fileSystem, logger, errorOnFailedEntryPoint);\n      }\n    };\n  }\n\n  exports.getSharedSetup = getSharedSetup;\n  var tsConfigCache = null;\n  var tsConfigPathCache = null;\n  /**\n   * Get the parsed configuration object for the given `tsConfigPath`.\n   *\n   * This function will cache the previous parsed configuration object to avoid unnecessary processing\n   * of the tsconfig.json in the case that it is requested repeatedly.\n   *\n   * This makes the assumption, which is true as of writing, that the contents of tsconfig.json and\n   * its dependencies will not change during the life of the process running ngcc.\n   */\n\n  function getTsConfig(tsConfigPath) {\n    if (tsConfigPath !== tsConfigPathCache) {\n      tsConfigPathCache = tsConfigPath;\n      tsConfigCache = perform_compile_1.readConfiguration(tsConfigPath);\n    }\n\n    return tsConfigCache;\n  }\n\n  function clearTsConfigCache() {\n    tsConfigPathCache = null;\n    tsConfigCache = null;\n  }\n\n  exports.clearTsConfigCache = clearTsConfigCache;\n\n  function checkForSolutionStyleTsConfig(fileSystem, logger, projectPath, tsConfigPath, tsConfig) {\n    if (tsConfigPath !== null && !tsConfigPath && tsConfig !== null && tsConfig.rootNames.length === 0 && tsConfig.projectReferences !== undefined && tsConfig.projectReferences.length > 0) {\n      logger.warn(\"The inferred tsconfig file \\\"\" + tsConfig.project + \"\\\" appears to be \\\"solution-style\\\" \" + \"since it contains no root files but does contain project references.\\n\" + \"This is probably not wanted, since ngcc is unable to infer settings like \\\"paths\\\" mappings from such a file.\\n\" + \"Perhaps you should have explicitly specified one of the referenced projects using the --tsconfig option. For example:\\n\\n\" + tsConfig.projectReferences.map(function (ref) {\n        return \"  ngcc ... --tsconfig \\\"\" + ref.originalPath + \"\\\"\\n\";\n      }).join('') + \"\\nFind out more about solution-style tsconfig at https://devblogs.microsoft.com/typescript/announcing-typescript-3-9/#solution-style-tsconfig.\\n\" + \"If you did intend to use this file, then you can hide this warning by providing it explicitly:\\n\\n\" + (\"  ngcc ... --tsconfig \\\"\" + fileSystem.relative(projectPath, tsConfig.project) + \"\\\"\"));\n    }\n  }\n  /**\n   * Determines the maximum number of workers to use for parallel execution. This can be set using the\n   * NGCC_MAX_WORKERS environment variable, or is computed based on the number of available CPUs. One\n   * CPU core is always reserved for the master process, so we take the number of CPUs minus one, with\n   * a maximum of 4 workers. We don't scale the number of workers beyond 4 by default, as it takes\n   * considerably more memory and CPU cycles while not offering a substantial improvement in time.\n   */\n\n\n  function getMaxNumberOfWorkers() {\n    var maxWorkers = process.env.NGCC_MAX_WORKERS;\n\n    if (maxWorkers === undefined) {\n      // Use up to 4 CPU cores for workers, always reserving one for master.\n      return Math.max(1, Math.min(4, os.cpus().length - 1));\n    }\n\n    var numericMaxWorkers = +maxWorkers.trim();\n\n    if (!Number.isInteger(numericMaxWorkers)) {\n      throw new Error('NGCC_MAX_WORKERS should be an integer.');\n    } else if (numericMaxWorkers < 1) {\n      throw new Error('NGCC_MAX_WORKERS should be at least 1.');\n    }\n\n    return numericMaxWorkers;\n  }\n\n  exports.getMaxNumberOfWorkers = getMaxNumberOfWorkers;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/ngcc/src/ngcc_options.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;;;;;AAMG;;AACH,MAAA,EAAA,GAAA,OAAA,CAAA,IAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,OAAA,CAAA,2CAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AACA,MAAA,eAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AAEA,MAAA,sBAAA,GAAA,OAAA,CAAA,6DAAA,CAAA;;AACA,MAAA,6BAAA,GAAA,OAAA,CAAA,oEAAA,CAAA;AAwJA;;;;AAIG;;;AACH,WAAgB,cAAhB,CAA+B,OAA/B,EAAmD;AAEjD,QAAM,UAAU,GAAG,aAAA,CAAA,aAAA,EAAnB;AACA,QAAM,WAAW,GAAG,aAAA,CAAA,YAAA,CAAa,OAAO,CAAC,QAArB,CAApB;AACA,QAAM,WAAW,GAAG,UAAU,CAAC,OAAX,CAAmB,WAAnB,CAApB;AACA,QAAM,QAAQ,GACV,OAAO,CAAC,YAAR,KAAyB,IAAzB,GAAgC,WAAW,CAAC,OAAO,CAAC,YAAR,IAAwB,WAAzB,CAA3C,GAAmF,IADvF;AAIE,QAAA,QAAQ,GAaN,OAAO,CAbD,QAAR;AAAA,QACA,oBAAoB,GAYlB,OAAO,CAZW,oBADpB;AAAA,QAEA,EAAA,GAWE,OAAO,CAXyC,oBAFlD;AAAA,QAEA,oBAAoB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,aAAA,CAAA,2BAAH,GAA8B,EAFlD;AAAA,QAGA,EAAA,GAUE,OAAO,CAVU,WAHnB;AAAA,QAGA,WAAW,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EAHnB;AAAA,QAIA,EAAA,GASE,OAAO,CATe,iBAJxB;AAAA,QAIA,iBAAiB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,IAAH,GAAO,EAJxB;AAAA,QAKA,EAAA,GAQE,OAAO,CARyB,0BALlC;AAAA,QAKA,0BAA0B,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EALlC;AAAA,QAMA,EAAA,GAOE,OAAO,CAPgC,MANzC;AAAA,QAMA,MAAM,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,IAAI,SAAA,CAAA,aAAJ,CAAkB,SAAA,CAAA,QAAA,CAAS,IAA3B,CAAH,GAAmC,EANzC;AAAA,QAOA,EAAA,GAME,OAAO,CANoE,YAP7E;AAAA,QAOA,YAAY,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,eAAA,CAAA,2BAAA,CAA4B,UAA5B,EAAwC,QAAxC,EAAkD,WAAlD,CAAH,GAAiE,EAP7E;AAAA,QAQA,EAAA,GAKE,OAAO,CALI,KARb;AAAA,QAQA,KAAK,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EARb;AAAA,QASA,EAAA,GAIE,OAAO,CAJsB,uBAT/B;AAAA,QASA,uBAAuB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EAT/B;AAAA,QAUA,EAAA,GAGE,OAAO,CAH6B,+BAVtC;AAAA,QAUA,+BAA+B,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,IAAH,GAAO,EAVtC;AAAA,QAWA,EAAA,GAEE,OAAO,CAF2B,4BAXpC;AAAA,QAWA,4BAA4B,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EAXpC;AAAA,QAYA,YAAY,GACV,OAAO,CADG,YAZZ;;AAeF,QAAI,CAAC,CAAC,oBAAN,EAA4B;AAC1B;AACA,MAAA,uBAAuB,GAAG,IAA1B;AACD;;AAED,QAAI,WAAJ,EAAiB;AACf;AACA;AACA,MAAA,iBAAiB,GAAG,KAApB;AACD;;AAED,IAAA,6BAA6B,CAAC,UAAD,EAAa,MAAb,EAAqB,WAArB,EAAkC,OAAO,CAAC,YAA1C,EAAwD,QAAxD,CAA7B;AAEA,WAAO;AACL,MAAA,QAAQ,EAAA,QADH;AAEL,MAAA,oBAAoB,EAAA,oBAFf;AAGL,MAAA,oBAAoB,EAAA,oBAHf;AAIL,MAAA,WAAW,EAAA,WAJN;AAKL,MAAA,iBAAiB,EAAA,iBALZ;AAML,MAAA,0BAA0B,EAAA,0BANrB;AAOL,MAAA,MAAM,EAAA,MAPD;AAQL,MAAA,YAAY,EAAA,YARP;AASL,MAAA,KAAK,EAAA,KATA;AAUL,MAAA,uBAAuB,EAAA,uBAVlB;AAWL,MAAA,+BAA+B,EAAA,+BAX1B;AAYL,MAAA,4BAA4B,EAAA,4BAZvB;AAaL,MAAA,YAAY,EAAA,YAbP;AAcL,MAAA,UAAU,EAAA,UAdL;AAeL,MAAA,WAAW,EAAA,WAfN;AAgBL,MAAA,WAAW,EAAA,WAhBN;AAiBL,MAAA,QAAQ,EAAA,QAjBH;AAkBL,MAAA,aAAa,EAAE,uBAAC,cAAD,EAAmC;AAAK,eAAA,0BAA0B,GAC7E,IAAI,6BAAA,CAAA,uBAAJ,CAA4B,UAA5B,EAAwC,MAAxC,EAAgD,uBAAhD,EAAyE,cAAzE,CAD6E,GAE7E,IAAI,sBAAA,CAAA,iBAAJ,CAAsB,UAAtB,EAAkC,MAAlC,EAFmD,uBAEnD,CAFmD;AAEe;AApBjE,KAAP;AAsBD;;AA3DD,EAAA,OAAA,CAAA,cAAA,GAAA,cAAA;AA6DA,MAAI,aAAa,GAA6B,IAA9C;AACA,MAAI,iBAAiB,GAAgB,IAArC;AAEA;;;;;;;;AAQG;;AACH,WAAS,WAAT,CAAqB,YAArB,EAAyC;AACvC,QAAI,YAAY,KAAK,iBAArB,EAAwC;AACtC,MAAA,iBAAiB,GAAG,YAApB;AACA,MAAA,aAAa,GAAG,iBAAA,CAAA,iBAAA,CAAkB,YAAlB,CAAhB;AACD;;AACD,WAAO,aAAP;AACD;;AAED,WAAgB,kBAAhB,GAAkC;AAChC,IAAA,iBAAiB,GAAG,IAApB;AACA,IAAA,aAAa,GAAG,IAAhB;AACD;;AAHD,EAAA,OAAA,CAAA,kBAAA,GAAA,kBAAA;;AAKA,WAAS,6BAAT,CACI,UADJ,EACkC,MADlC,EACkD,WADlD,EAEI,YAFJ,EAEyC,QAFzC,EAE2E;AACzE,QAAI,YAAY,KAAK,IAAjB,IAAyB,CAAC,YAA1B,IAA0C,QAAQ,KAAK,IAAvD,IACA,QAAQ,CAAC,SAAT,CAAmB,MAAnB,KAA8B,CAD9B,IACmC,QAAQ,CAAC,iBAAT,KAA+B,SADlE,IAEA,QAAQ,CAAC,iBAAT,CAA2B,MAA3B,GAAoC,CAFxC,EAE2C;AACzC,MAAA,MAAM,CAAC,IAAP,CACI,kCAA+B,QAAQ,CAAC,OAAxC,GAA+C,sCAA/C,GACA,wEADA,GAEA,iHAFA,GAGA,2HAHA,GAIA,QAAQ,CAAC,iBAAT,CAA2B,GAA3B,CAA+B,UAAA,GAAA,EAAG;AAAI,eAAA,6BAA0B,GAAG,CAAC,YAA9B,GAAA,MAAA;AAA+C,OAArF,EACK,IADL,CACU,EADV,CAJA,GAMA,kJANA,GAOA,oGAPA,IAQA,6BAA0B,UAAU,CAAC,QAAX,CAAoB,WAApB,EAAiC,QAAQ,CAAC,OAA1C,CAA1B,GAA4E,IAR5E,CADJ;AAUD;AACF;AAED;;;;;;AAMG;;;AACH,WAAgB,qBAAhB,GAAqC;AACnC,QAAM,UAAU,GAAG,OAAO,CAAC,GAAR,CAAY,gBAA/B;;AACA,QAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B;AACA,aAAO,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,IAAI,CAAC,GAAL,CAAS,CAAT,EAAY,EAAE,CAAC,IAAH,GAAU,MAAV,GAAmB,CAA/B,CAAZ,CAAP;AACD;;AAED,QAAM,iBAAiB,GAAG,CAAC,UAAU,CAAC,IAAX,EAA3B;;AACA,QAAI,CAAC,MAAM,CAAC,SAAP,CAAiB,iBAAjB,CAAL,EAA0C;AACxC,YAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD,KAFD,MAEO,IAAI,iBAAiB,GAAG,CAAxB,EAA2B;AAChC,YAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACD;;AACD,WAAO,iBAAP;AACD;;AAdD,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as os from 'os';\n\nimport {absoluteFrom, AbsoluteFsPath, FileSystem, getFileSystem, PathManipulation} from '../../src/ngtsc/file_system';\nimport {ConsoleLogger, Logger, LogLevel} from '../../src/ngtsc/logging';\nimport {ParsedConfiguration, readConfiguration} from '../../src/perform_compile';\n\nimport {SUPPORTED_FORMAT_PROPERTIES} from './packages/entry_point';\nimport {getPathMappingsFromTsConfig, PathMappings} from './path_mappings';\nimport {FileWriter} from './writing/file_writer';\nimport {InPlaceFileWriter} from './writing/in_place_file_writer';\nimport {NewEntryPointFileWriter} from './writing/new_entry_point_file_writer';\nimport {PackageJsonUpdater} from './writing/package_json_updater';\n\n/**\n * The options to configure the ngcc compiler for synchronous execution.\n */\nexport interface SyncNgccOptions {\n  /** The absolute path to the `node_modules` folder that contains the packages to process. */\n  basePath: string;\n\n  /**\n   * The path to the primary package to be processed. If not absolute then it must be relative to\n   * `basePath`.\n   *\n   * All its dependencies will need to be processed too.\n   *\n   * If this property is provided then `errorOnFailedEntryPoint` is forced to true.\n   */\n  targetEntryPointPath?: string;\n\n  /**\n   * Which entry-point properties in the package.json to consider when processing an entry-point.\n   * Each property should hold a path to the particular bundle format for the entry-point.\n   * Defaults to all the properties in the package.json.\n   */\n  propertiesToConsider?: string[];\n\n  /**\n   * Whether to only process the typings files for this entry-point.\n   *\n   * This is useful when running ngcc only to provide typings files to downstream tooling such as\n   * the Angular Language Service or ng-packagr. Defaults to `false`.\n   *\n   * If this is set to `true` then `compileAllFormats` is forced to `false`.\n   */\n  typingsOnly?: boolean;\n\n  /**\n   * Whether to process all formats specified by (`propertiesToConsider`)  or to stop processing\n   * this entry-point at the first matching format.\n   *\n   * Defaults to `true`, but is forced to `false` if `typingsOnly` is `true`.\n   */\n  compileAllFormats?: boolean;\n\n  /**\n   * Whether to create new entry-points bundles rather than overwriting the original files.\n   */\n  createNewEntryPointFormats?: boolean;\n\n  /**\n   * Provide a logger that will be called with log messages.\n   */\n  logger?: Logger;\n\n  /**\n   * Paths mapping configuration (`paths` and `baseUrl`), as found in `ts.CompilerOptions`.\n   * These are used to resolve paths to locally built Angular libraries.\n   *\n   * Note that `pathMappings` specified here take precedence over any `pathMappings` loaded from a\n   * TS config file.\n   */\n  pathMappings?: PathMappings;\n\n  /**\n   * Provide a file-system service that will be used by ngcc for all file interactions.\n   */\n  fileSystem?: FileSystem;\n\n  /**\n   * Whether the compilation should run and return asynchronously. Allowing asynchronous execution\n   * may speed up the compilation by utilizing multiple CPU cores (if available).\n   *\n   * Default: `false` (i.e. run synchronously)\n   */\n  async?: false;\n\n  /**\n   * Set to true in order to terminate immediately with an error code if an entry-point fails to be\n   * processed.\n   *\n   * If `targetEntryPointPath` is provided then this property is always true and cannot be\n   * changed. Otherwise the default is false.\n   *\n   * When set to false, ngcc will continue to process entry-points after a failure. In which case it\n   * will log an error and resume processing other entry-points.\n   */\n  errorOnFailedEntryPoint?: boolean;\n\n  /**\n   * Render `$localize` messages with legacy format ids.\n   *\n   * The default value is `true`. Only set this to `false` if you do not want legacy message ids to\n   * be rendered. For example, if you are not using legacy message ids in your translation files\n   * AND are not doing compile-time inlining of translations, in which case the extra message ids\n   * would add unwanted size to the final source bundle.\n   *\n   * It is safe to leave this set to true if you are doing compile-time inlining because the extra\n   * legacy message ids will all be stripped during translation.\n   */\n  enableI18nLegacyMessageIdFormat?: boolean;\n\n  /**\n   * Whether to invalidate any entry-point manifest file that is on disk. Instead, walk the\n   * directory tree looking for entry-points, and then write a new entry-point manifest, if\n   * possible.\n   *\n   * Default: `false` (i.e. the manifest will be used if available)\n   */\n  invalidateEntryPointManifest?: boolean;\n\n  /**\n   * An absolute path to a TS config file (e.g. `tsconfig.json`) or a directory containing one, that\n   * will be used to configure module resolution with things like path mappings, if not specified\n   * explicitly via the `pathMappings` property to `mainNgcc`.\n   *\n   * If `undefined`, ngcc will attempt to load a `tsconfig.json` file from the directory above the\n   * `basePath`.\n   *\n   * If `null`, ngcc will not attempt to load any TS config file at all.\n   */\n  tsConfigPath?: string|null;\n\n  /**\n   * Use the program defined in the loaded tsconfig.json (if available - see\n   * `tsConfigPath` option) to identify the entry-points that should be processed.\n   * If this is set to `true` then only the entry-points reachable from the given\n   * program (and their dependencies) will be processed.\n   */\n  findEntryPointsFromTsConfigProgram?: boolean;\n}\n\n/**\n * The options to configure the ngcc compiler for asynchronous execution.\n */\nexport type AsyncNgccOptions = Omit<SyncNgccOptions, 'async'>&{async: true};\n\n/**\n * The options to configure the ngcc compiler.\n */\nexport type NgccOptions = AsyncNgccOptions|SyncNgccOptions;\n\nexport type OptionalNgccOptionKeys =\n    'targetEntryPointPath'|'tsConfigPath'|'pathMappings'|'findEntryPointsFromTsConfigProgram';\nexport type RequiredNgccOptions = Required<Omit<NgccOptions, OptionalNgccOptionKeys>>;\nexport type OptionalNgccOptions = Pick<NgccOptions, OptionalNgccOptionKeys>;\nexport type SharedSetup = {\n  fileSystem: FileSystem; absBasePath: AbsoluteFsPath; projectPath: AbsoluteFsPath;\n  tsConfig: ParsedConfiguration | null;\n  getFileWriter(pkgJsonUpdater: PackageJsonUpdater): FileWriter;\n};\n\n/**\n * Instantiate common utilities that are always used and fix up options with defaults, as necessary.\n *\n * NOTE: Avoid eagerly instantiating anything that might not be used when running sync/async.\n */\nexport function getSharedSetup(options: NgccOptions): SharedSetup&RequiredNgccOptions&\n    OptionalNgccOptions {\n  const fileSystem = getFileSystem();\n  const absBasePath = absoluteFrom(options.basePath);\n  const projectPath = fileSystem.dirname(absBasePath);\n  const tsConfig =\n      options.tsConfigPath !== null ? getTsConfig(options.tsConfigPath || projectPath) : null;\n\n  let {\n    basePath,\n    targetEntryPointPath,\n    propertiesToConsider = SUPPORTED_FORMAT_PROPERTIES,\n    typingsOnly = false,\n    compileAllFormats = true,\n    createNewEntryPointFormats = false,\n    logger = new ConsoleLogger(LogLevel.info),\n    pathMappings = getPathMappingsFromTsConfig(fileSystem, tsConfig, projectPath),\n    async = false,\n    errorOnFailedEntryPoint = false,\n    enableI18nLegacyMessageIdFormat = true,\n    invalidateEntryPointManifest = false,\n    tsConfigPath,\n  } = options;\n\n  if (!!targetEntryPointPath) {\n    // targetEntryPointPath forces us to error if an entry-point fails.\n    errorOnFailedEntryPoint = true;\n  }\n\n  if (typingsOnly) {\n    // If we only want to process the typings then we do not want to waste time trying to process\n    // multiple JS formats.\n    compileAllFormats = false;\n  }\n\n  checkForSolutionStyleTsConfig(fileSystem, logger, projectPath, options.tsConfigPath, tsConfig);\n\n  return {\n    basePath,\n    targetEntryPointPath,\n    propertiesToConsider,\n    typingsOnly,\n    compileAllFormats,\n    createNewEntryPointFormats,\n    logger,\n    pathMappings,\n    async,\n    errorOnFailedEntryPoint,\n    enableI18nLegacyMessageIdFormat,\n    invalidateEntryPointManifest,\n    tsConfigPath,\n    fileSystem,\n    absBasePath,\n    projectPath,\n    tsConfig,\n    getFileWriter: (pkgJsonUpdater: PackageJsonUpdater) => createNewEntryPointFormats ?\n        new NewEntryPointFileWriter(fileSystem, logger, errorOnFailedEntryPoint, pkgJsonUpdater) :\n        new InPlaceFileWriter(fileSystem, logger, errorOnFailedEntryPoint),\n  };\n}\n\nlet tsConfigCache: ParsedConfiguration|null = null;\nlet tsConfigPathCache: string|null = null;\n\n/**\n * Get the parsed configuration object for the given `tsConfigPath`.\n *\n * This function will cache the previous parsed configuration object to avoid unnecessary processing\n * of the tsconfig.json in the case that it is requested repeatedly.\n *\n * This makes the assumption, which is true as of writing, that the contents of tsconfig.json and\n * its dependencies will not change during the life of the process running ngcc.\n */\nfunction getTsConfig(tsConfigPath: string): ParsedConfiguration|null {\n  if (tsConfigPath !== tsConfigPathCache) {\n    tsConfigPathCache = tsConfigPath;\n    tsConfigCache = readConfiguration(tsConfigPath);\n  }\n  return tsConfigCache;\n}\n\nexport function clearTsConfigCache() {\n  tsConfigPathCache = null;\n  tsConfigCache = null;\n}\n\nfunction checkForSolutionStyleTsConfig(\n    fileSystem: PathManipulation, logger: Logger, projectPath: AbsoluteFsPath,\n    tsConfigPath: string|null|undefined, tsConfig: ParsedConfiguration|null): void {\n  if (tsConfigPath !== null && !tsConfigPath && tsConfig !== null &&\n      tsConfig.rootNames.length === 0 && tsConfig.projectReferences !== undefined &&\n      tsConfig.projectReferences.length > 0) {\n    logger.warn(\n        `The inferred tsconfig file \"${tsConfig.project}\" appears to be \"solution-style\" ` +\n        `since it contains no root files but does contain project references.\\n` +\n        `This is probably not wanted, since ngcc is unable to infer settings like \"paths\" mappings from such a file.\\n` +\n        `Perhaps you should have explicitly specified one of the referenced projects using the --tsconfig option. For example:\\n\\n` +\n        tsConfig.projectReferences.map(ref => `  ngcc ... --tsconfig \"${ref.originalPath}\"\\n`)\n            .join('') +\n        `\\nFind out more about solution-style tsconfig at https://devblogs.microsoft.com/typescript/announcing-typescript-3-9/#solution-style-tsconfig.\\n` +\n        `If you did intend to use this file, then you can hide this warning by providing it explicitly:\\n\\n` +\n        `  ngcc ... --tsconfig \"${fileSystem.relative(projectPath, tsConfig.project)}\"`);\n  }\n}\n\n/**\n * Determines the maximum number of workers to use for parallel execution. This can be set using the\n * NGCC_MAX_WORKERS environment variable, or is computed based on the number of available CPUs. One\n * CPU core is always reserved for the master process, so we take the number of CPUs minus one, with\n * a maximum of 4 workers. We don't scale the number of workers beyond 4 by default, as it takes\n * considerably more memory and CPU cycles while not offering a substantial improvement in time.\n */\nexport function getMaxNumberOfWorkers(): number {\n  const maxWorkers = process.env.NGCC_MAX_WORKERS;\n  if (maxWorkers === undefined) {\n    // Use up to 4 CPU cores for workers, always reserving one for master.\n    return Math.max(1, Math.min(4, os.cpus().length - 1));\n  }\n\n  const numericMaxWorkers = +maxWorkers.trim();\n  if (!Number.isInteger(numericMaxWorkers)) {\n    throw new Error('NGCC_MAX_WORKERS should be an integer.');\n  } else if (numericMaxWorkers < 1) {\n    throw new Error('NGCC_MAX_WORKERS should be at least 1.');\n  }\n  return numericMaxWorkers;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}