{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _util = require(\"./util.js\");\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar mMap = new WeakMap();\n\nfunction m(node) {\n  if (!mMap.has(node)) {\n    mMap.set(node, {});\n  }\n\n  return mMap.get(node);\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    var t = (0, _util.getTypes)();\n    t.assertNode(node); // Assume no side effects until we find out otherwise.\n\n    var result = false;\n\n    function check(child) {\n      if (result) {// Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        _assert[\"default\"].strictEqual(result, false);\n\n        result = predicate(child);\n      }\n\n      return result;\n    }\n\n    var keys = t.VISITOR_KEYS[node.type];\n\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    (0, _util.getTypes)().assertNode(node);\n    var meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName]; // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n  return predicate;\n}\n\nvar opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n}; // These types potentially have side effects regardless of what side\n// effects their subexpressions have.\n\nvar sideEffectTypes = {\n  CallExpression: true,\n  // Anything could happen!\n  ForInStatement: true,\n  // Modifies the key variable.\n  UnaryExpression: true,\n  // Think delete.\n  BinaryExpression: true,\n  // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true,\n  // Side-effecting by definition.\n  UpdateExpression: true,\n  // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n\n}; // These types are the direct cause of all leaps in control flow.\n\nvar leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n}; // All leap types are also side effect types.\n\nfor (var type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/regenerator-transform/lib/meta.js"],"names":["_interopRequireDefault","require","_assert","_util","mMap","WeakMap","m","node","has","set","get","hasOwn","Object","prototype","hasOwnProperty","makePredicate","propertyName","knownTypes","onlyChildren","t","getTypes","assertNode","result","check","child","Array","isArray","some","isNode","strictEqual","predicate","keys","VISITOR_KEYS","type","i","length","key","meta","call","opaqueTypes","FunctionExpression","ArrowFunctionExpression","sideEffectTypes","CallExpression","ForInStatement","UnaryExpression","BinaryExpression","AssignmentExpression","UpdateExpression","NewExpression","leapTypes","YieldExpression","BreakStatement","ContinueStatement","ReturnStatement","ThrowStatement","exports","hasSideEffects","containsLeap"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _assert = _interopRequireDefault(require(\"assert\"));\n\nvar _util = require(\"./util.js\");\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar mMap = new WeakMap();\n\nfunction m(node) {\n  if (!mMap.has(node)) {\n    mMap.set(node, {});\n  }\n\n  return mMap.get(node);\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction makePredicate(propertyName, knownTypes) {\n  function onlyChildren(node) {\n    var t = (0, _util.getTypes)();\n    t.assertNode(node); // Assume no side effects until we find out otherwise.\n\n    var result = false;\n\n    function check(child) {\n      if (result) {// Do nothing.\n      } else if (Array.isArray(child)) {\n        child.some(check);\n      } else if (t.isNode(child)) {\n        _assert[\"default\"].strictEqual(result, false);\n\n        result = predicate(child);\n      }\n\n      return result;\n    }\n\n    var keys = t.VISITOR_KEYS[node.type];\n\n    if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var child = node[key];\n        check(child);\n      }\n    }\n\n    return result;\n  }\n\n  function predicate(node) {\n    (0, _util.getTypes)().assertNode(node);\n    var meta = m(node);\n    if (hasOwn.call(meta, propertyName)) return meta[propertyName]; // Certain types are \"opaque,\" which means they have no side\n    // effects or leaps and we don't care about their subexpressions.\n\n    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;\n    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;\n    return meta[propertyName] = onlyChildren(node);\n  }\n\n  predicate.onlyChildren = onlyChildren;\n  return predicate;\n}\n\nvar opaqueTypes = {\n  FunctionExpression: true,\n  ArrowFunctionExpression: true\n}; // These types potentially have side effects regardless of what side\n// effects their subexpressions have.\n\nvar sideEffectTypes = {\n  CallExpression: true,\n  // Anything could happen!\n  ForInStatement: true,\n  // Modifies the key variable.\n  UnaryExpression: true,\n  // Think delete.\n  BinaryExpression: true,\n  // Might invoke .toString() or .valueOf().\n  AssignmentExpression: true,\n  // Side-effecting by definition.\n  UpdateExpression: true,\n  // Updates are essentially assignments.\n  NewExpression: true // Similar to CallExpression.\n\n}; // These types are the direct cause of all leaps in control flow.\n\nvar leapTypes = {\n  YieldExpression: true,\n  BreakStatement: true,\n  ContinueStatement: true,\n  ReturnStatement: true,\n  ThrowStatement: true\n}; // All leap types are also side effect types.\n\nfor (var type in leapTypes) {\n  if (hasOwn.call(leapTypes, type)) {\n    sideEffectTypes[type] = leapTypes[type];\n  }\n}\n\nexports.hasSideEffects = makePredicate(\"hasSideEffects\", sideEffectTypes);\nexports.containsLeap = makePredicate(\"containsLeap\", leapTypes);"]},"metadata":{},"sourceType":"script"}