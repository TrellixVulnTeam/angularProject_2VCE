{"ast":null,"code":"\"use strict\"; // Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar similarity = function similarity(a, b) {\n  var l = Math.min(a.length, b.length);\n  var dist = 0;\n\n  for (var i = 0; i < l; i++) {\n    var ca = a.charCodeAt(i);\n    var cb = b.charCodeAt(i);\n    dist += Math.max(0, 10 - Math.abs(ca - cb));\n  }\n\n  return dist;\n};\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\n\n\nvar getName = function getName(a, b) {\n  var l = Math.min(a.length, b.length);\n  var r = \"\";\n\n  for (var i = 0; i < l; i++) {\n    var ca = a.charAt(i);\n    var cb = b.charAt(i);\n    r += ca;\n\n    if (ca === cb) {\n      continue;\n    }\n\n    return r;\n  }\n\n  return a;\n};\n/**\n * @template T\n */\n\n\nvar Node =\n/**\n * @param {T} item item\n * @param {string} key key\n * @param {number} size size\n */\nfunction Node(item, key, size) {\n  _classCallCheck(this, Node);\n\n  this.item = item;\n  this.key = key;\n  this.size = size;\n};\n/**\n * @template T\n */\n\n\nvar Group =\n/**\n * @param {Node<T>[]} nodes nodes\n * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n */\nfunction Group(nodes, similarities) {\n  _classCallCheck(this, Group);\n\n  this.nodes = nodes;\n  this.similarities = similarities;\n  this.size = nodes.reduce(function (size, node) {\n    return size + node.size;\n  }, 0);\n  /** @type {string} */\n\n  this.key = undefined;\n};\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\n\n\nmodule.exports = function (_ref) {\n  var maxSize = _ref.maxSize,\n      minSize = _ref.minSize,\n      items = _ref.items,\n      getSize = _ref.getSize,\n      getKey = _ref.getKey;\n\n  /** @type {Group<T>[]} */\n  var result = [];\n  var nodes = Array.from(items, function (item) {\n    return new Node(item, getKey(item), getSize(item));\n  });\n  /** @type {Node<T>[]} */\n\n  var initialNodes = []; // lexically ordering of keys\n\n  nodes.sort(function (a, b) {\n    if (a.key < b.key) return -1;\n    if (a.key > b.key) return 1;\n    return 0;\n  }); // return nodes bigger than maxSize directly as group\n\n  for (var _i = 0, _nodes = nodes; _i < _nodes.length; _i++) {\n    var node = _nodes[_i];\n\n    if (node.size >= maxSize) {\n      result.push(new Group([node], []));\n    } else {\n      initialNodes.push(node);\n    }\n  }\n\n  if (initialNodes.length > 0) {\n    // calculate similarities between lexically adjacent nodes\n\n    /** @type {number[]} */\n    var similarities = [];\n\n    for (var i = 1; i < initialNodes.length; i++) {\n      var a = initialNodes[i - 1];\n      var b = initialNodes[i];\n      similarities.push(similarity(a.key, b.key));\n    }\n\n    var initialGroup = new Group(initialNodes, similarities);\n\n    if (initialGroup.size < minSize) {\n      // We hit an edgecase where the working set is already smaller than minSize\n      // We merge it with the smallest result node to keep minSize intact\n      if (result.length > 0) {\n        var smallestGroup = result.reduce(function (min, group) {\n          return min.size > group.size ? group : min;\n        });\n\n        var _iterator = _createForOfIteratorHelper(initialGroup.nodes),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _node = _step.value;\n            smallestGroup.nodes.push(_node);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        smallestGroup.nodes.sort(function (a, b) {\n          if (a.key < b.key) return -1;\n          if (a.key > b.key) return 1;\n          return 0;\n        });\n      } else {\n        // There are no other nodes\n        // We use all nodes and have to accept that it's smaller than minSize\n        result.push(initialGroup);\n      }\n    } else {\n      var queue = [initialGroup];\n\n      while (queue.length) {\n        var group = queue.pop(); // only groups bigger than maxSize need to be splitted\n\n        if (group.size < maxSize) {\n          result.push(group);\n          continue;\n        } // find unsplittable area from left and right\n        // going minSize from left and right\n        // at least one node need to be included otherwise we get stuck\n\n\n        var left = 0;\n        var leftSize = 0;\n\n        while (leftSize <= minSize) {\n          leftSize += group.nodes[left].size;\n          left++;\n        }\n\n        var right = group.nodes.length - 1;\n        var rightSize = 0;\n\n        while (rightSize <= minSize) {\n          rightSize += group.nodes[right].size;\n          right--;\n        }\n\n        if (left - 1 > right) {\n          // can't split group while holding minSize\n          // because minSize is preferred of maxSize we return\n          // the group here even while it's too big\n          // To avoid this make sure maxSize > minSize * 3\n          result.push(group);\n          continue;\n        }\n\n        if (left <= right) {\n          // when there is a area between left and right\n          // we look for best split point\n          // we split at the minimum similarity\n          // here key space is separated the most\n          var best = left - 1;\n          var bestSimilarity = group.similarities[best];\n\n          for (var _i2 = left; _i2 <= right; _i2++) {\n            var _similarity = group.similarities[_i2];\n\n            if (_similarity < bestSimilarity) {\n              best = _i2;\n              bestSimilarity = _similarity;\n            }\n          }\n\n          left = best + 1;\n          right = best;\n        } // create two new groups for left and right area\n        // and queue them up\n\n\n        var rightNodes = [group.nodes[right + 1]];\n        /** @type {number[]} */\n\n        var rightSimilaries = [];\n\n        for (var _i3 = right + 2; _i3 < group.nodes.length; _i3++) {\n          rightSimilaries.push(group.similarities[_i3 - 1]);\n          rightNodes.push(group.nodes[_i3]);\n        }\n\n        queue.push(new Group(rightNodes, rightSimilaries));\n        var leftNodes = [group.nodes[0]];\n        /** @type {number[]} */\n\n        var leftSimilaries = [];\n\n        for (var _i4 = 1; _i4 < left; _i4++) {\n          leftSimilaries.push(group.similarities[_i4 - 1]);\n          leftNodes.push(group.nodes[_i4]);\n        }\n\n        queue.push(new Group(leftNodes, leftSimilaries));\n      }\n    }\n  } // lexically ordering\n\n\n  result.sort(function (a, b) {\n    if (a.nodes[0].key < b.nodes[0].key) return -1;\n    if (a.nodes[0].key > b.nodes[0].key) return 1;\n    return 0;\n  }); // give every group a name\n\n  for (var _i5 = 0; _i5 < result.length; _i5++) {\n    var _group = result[_i5];\n    var first = _group.nodes[0];\n    var last = _group.nodes[_group.nodes.length - 1];\n    var name = getName(first.key, last.key);\n    _group.key = name;\n  } // return the results\n\n\n  return result.map(function (group) {\n    /** @type {GroupedItems} */\n    return {\n      key: group.key,\n      items: group.nodes.map(function (node) {\n        return node.item;\n      }),\n      size: group.size\n    };\n  });\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/util/deterministicGrouping.js"],"names":["similarity","a","b","l","Math","min","length","dist","i","ca","charCodeAt","cb","max","abs","getName","r","charAt","Node","item","key","size","Group","nodes","similarities","reduce","node","undefined","module","exports","maxSize","minSize","items","getSize","getKey","result","Array","from","initialNodes","sort","push","initialGroup","smallestGroup","group","queue","pop","left","leftSize","right","rightSize","best","bestSimilarity","rightNodes","rightSimilaries","leftNodes","leftSimilaries","first","last","name","map"],"mappings":"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","sourcesContent":["\"use strict\";\n\n// Simulations show these probabilities for a single change\n// 93.1% that one group is invalidated\n// 4.8% that two groups are invalidated\n// 1.1% that 3 groups are invalidated\n// 0.1% that 4 or more groups are invalidated\n//\n// And these for removing/adding 10 lexically adjacent files\n// 64.5% that one group is invalidated\n// 24.8% that two groups are invalidated\n// 7.8% that 3 groups are invalidated\n// 2.7% that 4 or more groups are invalidated\n//\n// And these for removing/adding 3 random files\n// 0% that one group is invalidated\n// 3.7% that two groups are invalidated\n// 80.8% that 3 groups are invalidated\n// 12.3% that 4 groups are invalidated\n// 3.2% that 5 or more groups are invalidated\n\n/**\n *\n * @param {string} a key\n * @param {string} b key\n * @returns {number} the similarity as number\n */\nconst similarity = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet dist = 0;\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charCodeAt(i);\n\t\tconst cb = b.charCodeAt(i);\n\t\tdist += Math.max(0, 10 - Math.abs(ca - cb));\n\t}\n\treturn dist;\n};\n\n/**\n * @param {string} a key\n * @param {string} b key\n * @returns {string} the common part and a single char for the difference\n */\nconst getName = (a, b) => {\n\tconst l = Math.min(a.length, b.length);\n\tlet r = \"\";\n\tfor (let i = 0; i < l; i++) {\n\t\tconst ca = a.charAt(i);\n\t\tconst cb = b.charAt(i);\n\t\tr += ca;\n\t\tif (ca === cb) {\n\t\t\tcontinue;\n\t\t}\n\t\treturn r;\n\t}\n\treturn a;\n};\n\n/**\n * @template T\n */\nclass Node {\n\t/**\n\t * @param {T} item item\n\t * @param {string} key key\n\t * @param {number} size size\n\t */\n\tconstructor(item, key, size) {\n\t\tthis.item = item;\n\t\tthis.key = key;\n\t\tthis.size = size;\n\t}\n}\n\n/**\n * @template T\n */\nclass Group {\n\t/**\n\t * @param {Node<T>[]} nodes nodes\n\t * @param {number[]} similarities similarities between the nodes (length = nodes.length - 1)\n\t */\n\tconstructor(nodes, similarities) {\n\t\tthis.nodes = nodes;\n\t\tthis.similarities = similarities;\n\t\tthis.size = nodes.reduce((size, node) => size + node.size, 0);\n\t\t/** @type {string} */\n\t\tthis.key = undefined;\n\t}\n}\n\n/**\n * @template T\n * @typedef {Object} GroupedItems<T>\n * @property {string} key\n * @property {T[]} items\n * @property {number} size\n */\n\n/**\n * @template T\n * @typedef {Object} Options\n * @property {number} maxSize maximum size of a group\n * @property {number} minSize minimum size of a group (preferred over maximum size)\n * @property {Iterable<T>} items a list of items\n * @property {function(T): number} getSize function to get size of an item\n * @property {function(T): string} getKey function to get the key of an item\n */\n\n/**\n * @template T\n * @param {Options<T>} options options object\n * @returns {GroupedItems<T>[]} grouped items\n */\nmodule.exports = ({ maxSize, minSize, items, getSize, getKey }) => {\n\t/** @type {Group<T>[]} */\n\tconst result = [];\n\n\tconst nodes = Array.from(\n\t\titems,\n\t\titem => new Node(item, getKey(item), getSize(item))\n\t);\n\n\t/** @type {Node<T>[]} */\n\tconst initialNodes = [];\n\n\t// lexically ordering of keys\n\tnodes.sort((a, b) => {\n\t\tif (a.key < b.key) return -1;\n\t\tif (a.key > b.key) return 1;\n\t\treturn 0;\n\t});\n\n\t// return nodes bigger than maxSize directly as group\n\tfor (const node of nodes) {\n\t\tif (node.size >= maxSize) {\n\t\t\tresult.push(new Group([node], []));\n\t\t} else {\n\t\t\tinitialNodes.push(node);\n\t\t}\n\t}\n\n\tif (initialNodes.length > 0) {\n\t\t// calculate similarities between lexically adjacent nodes\n\t\t/** @type {number[]} */\n\t\tconst similarities = [];\n\t\tfor (let i = 1; i < initialNodes.length; i++) {\n\t\t\tconst a = initialNodes[i - 1];\n\t\t\tconst b = initialNodes[i];\n\t\t\tsimilarities.push(similarity(a.key, b.key));\n\t\t}\n\n\t\tconst initialGroup = new Group(initialNodes, similarities);\n\n\t\tif (initialGroup.size < minSize) {\n\t\t\t// We hit an edgecase where the working set is already smaller than minSize\n\t\t\t// We merge it with the smallest result node to keep minSize intact\n\t\t\tif (result.length > 0) {\n\t\t\t\tconst smallestGroup = result.reduce((min, group) =>\n\t\t\t\t\tmin.size > group.size ? group : min\n\t\t\t\t);\n\t\t\t\tfor (const node of initialGroup.nodes) smallestGroup.nodes.push(node);\n\t\t\t\tsmallestGroup.nodes.sort((a, b) => {\n\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// There are no other nodes\n\t\t\t\t// We use all nodes and have to accept that it's smaller than minSize\n\t\t\t\tresult.push(initialGroup);\n\t\t\t}\n\t\t} else {\n\t\t\tconst queue = [initialGroup];\n\n\t\t\twhile (queue.length) {\n\t\t\t\tconst group = queue.pop();\n\t\t\t\t// only groups bigger than maxSize need to be splitted\n\t\t\t\tif (group.size < maxSize) {\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// find unsplittable area from left and right\n\t\t\t\t// going minSize from left and right\n\t\t\t\t// at least one node need to be included otherwise we get stuck\n\t\t\t\tlet left = 0;\n\t\t\t\tlet leftSize = 0;\n\t\t\t\twhile (leftSize <= minSize) {\n\t\t\t\t\tleftSize += group.nodes[left].size;\n\t\t\t\t\tleft++;\n\t\t\t\t}\n\t\t\t\tlet right = group.nodes.length - 1;\n\t\t\t\tlet rightSize = 0;\n\t\t\t\twhile (rightSize <= minSize) {\n\t\t\t\t\trightSize += group.nodes[right].size;\n\t\t\t\t\tright--;\n\t\t\t\t}\n\n\t\t\t\tif (left - 1 > right) {\n\t\t\t\t\t// can't split group while holding minSize\n\t\t\t\t\t// because minSize is preferred of maxSize we return\n\t\t\t\t\t// the group here even while it's too big\n\t\t\t\t\t// To avoid this make sure maxSize > minSize * 3\n\t\t\t\t\tresult.push(group);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (left <= right) {\n\t\t\t\t\t// when there is a area between left and right\n\t\t\t\t\t// we look for best split point\n\t\t\t\t\t// we split at the minimum similarity\n\t\t\t\t\t// here key space is separated the most\n\t\t\t\t\tlet best = left - 1;\n\t\t\t\t\tlet bestSimilarity = group.similarities[best];\n\t\t\t\t\tfor (let i = left; i <= right; i++) {\n\t\t\t\t\t\tconst similarity = group.similarities[i];\n\t\t\t\t\t\tif (similarity < bestSimilarity) {\n\t\t\t\t\t\t\tbest = i;\n\t\t\t\t\t\t\tbestSimilarity = similarity;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tleft = best + 1;\n\t\t\t\t\tright = best;\n\t\t\t\t}\n\n\t\t\t\t// create two new groups for left and right area\n\t\t\t\t// and queue them up\n\t\t\t\tconst rightNodes = [group.nodes[right + 1]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst rightSimilaries = [];\n\t\t\t\tfor (let i = right + 2; i < group.nodes.length; i++) {\n\t\t\t\t\trightSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\trightNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(rightNodes, rightSimilaries));\n\n\t\t\t\tconst leftNodes = [group.nodes[0]];\n\t\t\t\t/** @type {number[]} */\n\t\t\t\tconst leftSimilaries = [];\n\t\t\t\tfor (let i = 1; i < left; i++) {\n\t\t\t\t\tleftSimilaries.push(group.similarities[i - 1]);\n\t\t\t\t\tleftNodes.push(group.nodes[i]);\n\t\t\t\t}\n\t\t\t\tqueue.push(new Group(leftNodes, leftSimilaries));\n\t\t\t}\n\t\t}\n\t}\n\n\t// lexically ordering\n\tresult.sort((a, b) => {\n\t\tif (a.nodes[0].key < b.nodes[0].key) return -1;\n\t\tif (a.nodes[0].key > b.nodes[0].key) return 1;\n\t\treturn 0;\n\t});\n\n\t// give every group a name\n\tfor (let i = 0; i < result.length; i++) {\n\t\tconst group = result[i];\n\t\tconst first = group.nodes[0];\n\t\tconst last = group.nodes[group.nodes.length - 1];\n\t\tlet name = getName(first.key, last.key);\n\t\tgroup.key = name;\n\t}\n\n\t// return the results\n\treturn result.map(group => {\n\t\t/** @type {GroupedItems} */\n\t\treturn {\n\t\t\tkey: group.key,\n\t\t\titems: group.nodes.map(node => node.item),\n\t\t\tsize: group.size\n\t\t};\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}