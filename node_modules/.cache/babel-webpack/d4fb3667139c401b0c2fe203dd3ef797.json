{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _convertUnit = _interopRequireDefault(require(\"./convertUnit\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction isValueType(type) {\n  switch (type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Number':\n      return true;\n  }\n\n  return false;\n}\n\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n\nfunction isAddSubOperator(operator) {\n  return operator === '+' || operator === '-';\n}\n\nfunction collectAddSubItems(preOperator, node, collected, precision) {\n  if (!isAddSubOperator(preOperator)) {\n    throw new Error(\"invalid operator \".concat(preOperator));\n  }\n\n  var type = node.type;\n\n  if (isValueType(type)) {\n    var itemIndex = collected.findIndex(function (x) {\n      return x.node.type === type;\n    });\n\n    if (itemIndex >= 0) {\n      if (node.value === 0) {\n        return;\n      }\n\n      var _covertNodesUnits = covertNodesUnits(collected[itemIndex].node, node, precision),\n          reducedNode = _covertNodesUnits.left,\n          current = _covertNodesUnits.right;\n\n      if (collected[itemIndex].preOperator === '-') {\n        collected[itemIndex].preOperator = '+';\n        reducedNode.value *= -1;\n      }\n\n      if (preOperator === \"+\") {\n        reducedNode.value += current.value;\n      } else {\n        reducedNode.value -= current.value;\n      } // make sure reducedNode.value >= 0\n\n\n      if (reducedNode.value >= 0) {\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '+'\n        };\n      } else {\n        reducedNode.value *= -1;\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '-'\n        };\n      }\n    } else {\n      // make sure node.value >= 0\n      if (node.value >= 0) {\n        collected.push({\n          node: node,\n          preOperator: preOperator\n        });\n      } else {\n        node.value *= -1;\n        collected.push({\n          node: node,\n          preOperator: flip(preOperator)\n        });\n      }\n    }\n  } else if (type === \"MathExpression\") {\n    if (isAddSubOperator(node.operator)) {\n      collectAddSubItems(preOperator, node.left, collected, precision);\n      var collectRightOperator = preOperator === '-' ? flip(node.operator) : node.operator;\n      collectAddSubItems(collectRightOperator, node.right, collected, precision);\n    } else {\n      // * or /\n      var _reducedNode = reduce(node, precision); // prevent infinite recursive call\n\n\n      if (_reducedNode.type !== \"MathExpression\" || isAddSubOperator(_reducedNode.operator)) {\n        collectAddSubItems(preOperator, _reducedNode, collected, precision);\n      } else {\n        collected.push({\n          node: _reducedNode,\n          preOperator: preOperator\n        });\n      }\n    }\n  } else {\n    collected.push({\n      node: node,\n      preOperator: preOperator\n    });\n  }\n}\n\nfunction reduceAddSubExpression(node, precision) {\n  var collected = [];\n  collectAddSubItems('+', node, collected, precision);\n  var withoutZeroItem = collected.filter(function (item) {\n    return !(isValueType(item.node.type) && item.node.value === 0);\n  });\n  var firstNonZeroItem = withoutZeroItem[0]; // could be undefined\n  // prevent producing \"calc(-var(--a))\" or \"calc()\"\n  // which is invalid css\n\n  if (!firstNonZeroItem || firstNonZeroItem.preOperator === '-' && !isValueType(firstNonZeroItem.node.type)) {\n    var firstZeroItem = collected.find(function (item) {\n      return isValueType(item.node.type) && item.node.value === 0;\n    });\n    withoutZeroItem.unshift(firstZeroItem);\n  } // make sure the preOperator of the first item is +\n\n\n  if (withoutZeroItem[0].preOperator === '-' && isValueType(withoutZeroItem[0].node.type)) {\n    withoutZeroItem[0].node.value *= -1;\n    withoutZeroItem[0].preOperator = '+';\n  }\n\n  var root = withoutZeroItem[0].node;\n\n  for (var i = 1; i < withoutZeroItem.length; i++) {\n    root = {\n      type: 'MathExpression',\n      operator: withoutZeroItem[i].preOperator,\n      left: root,\n      right: withoutZeroItem[i].node\n    };\n  }\n\n  return root;\n}\n\nfunction reduceDivisionExpression(node) {\n  if (!isValueType(node.right.type)) {\n    return node;\n  }\n\n  if (node.right.type !== 'Number') {\n    throw new Error(\"Cannot divide by \\\"\".concat(node.right.unit, \"\\\", number expected\"));\n  }\n\n  return applyNumberDivision(node.left, node.right.value);\n} // apply (expr) / number\n\n\nfunction applyNumberDivision(node, divisor) {\n  if (divisor === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n\n  if (isValueType(node.type)) {\n    node.value /= divisor;\n    return node;\n  }\n\n  if (node.type === \"MathExpression\" && isAddSubOperator(node.operator)) {\n    // turn (a + b) / num into a/num + b/num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce division before reducing additions\"\n    return {\n      type: \"MathExpression\",\n      operator: node.operator,\n      left: applyNumberDivision(node.left, divisor),\n      right: applyNumberDivision(node.right, divisor)\n    };\n  } // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n\n\n  return {\n    type: \"MathExpression\",\n    operator: '/',\n    left: node,\n    right: {\n      type: \"Number\",\n      value: divisor\n    }\n  };\n}\n\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * number\n  if (node.right.type === 'Number') {\n    return applyNumberMultiplication(node.left, node.right.value);\n  } // number * (expr)\n\n\n  if (node.left.type === 'Number') {\n    return applyNumberMultiplication(node.right, node.left.value);\n  }\n\n  return node;\n} // apply (expr) / number\n\n\nfunction applyNumberMultiplication(node, multiplier) {\n  if (isValueType(node.type)) {\n    node.value *= multiplier;\n    return node;\n  }\n\n  if (node.type === \"MathExpression\" && isAddSubOperator(node.operator)) {\n    // turn (a + b) * num into a*num + b*num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce multiplication before reducing additions\"\n    return {\n      type: \"MathExpression\",\n      operator: node.operator,\n      left: applyNumberMultiplication(node.left, multiplier),\n      right: applyNumberMultiplication(node.right, multiplier)\n    };\n  } // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n\n\n  return {\n    type: \"MathExpression\",\n    operator: '*',\n    left: node,\n    right: {\n      type: \"Number\",\n      value: multiplier\n    }\n  };\n}\n\nfunction covertNodesUnits(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      if (right.type === left.type && right.unit && left.unit) {\n        var converted = (0, _convertUnit.default)(right.value, right.unit, left.unit, precision);\n        right = {\n          type: left.type,\n          value: converted,\n          unit: left.unit\n        };\n      }\n\n      return {\n        left: left,\n        right: right\n      };\n\n    default:\n      return {\n        left: left,\n        right: right\n      };\n  }\n}\n\nfunction reduce(node, precision) {\n  if (node.type === \"MathExpression\") {\n    if (isAddSubOperator(node.operator)) {\n      // reduceAddSubExpression will call reduce recursively\n      return reduceAddSubExpression(node, precision);\n    }\n\n    node.left = reduce(node.left, precision);\n    node.right = reduce(node.right, precision);\n\n    switch (node.operator) {\n      case \"/\":\n        return reduceDivisionExpression(node, precision);\n\n      case \"*\":\n        return reduceMultiplicationExpression(node, precision);\n    }\n\n    return node;\n  }\n\n  return node;\n}\n\nvar _default = reduce;\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/postcss-calc/dist/lib/reducer.js"],"names":["Object","defineProperty","exports","value","default","_convertUnit","_interopRequireDefault","require","obj","__esModule","isValueType","type","flip","operator","isAddSubOperator","collectAddSubItems","preOperator","node","collected","precision","Error","itemIndex","findIndex","x","_covertNodesUnits","covertNodesUnits","reducedNode","left","current","right","push","collectRightOperator","_reducedNode","reduce","reduceAddSubExpression","withoutZeroItem","filter","item","firstNonZeroItem","firstZeroItem","find","unshift","root","i","length","reduceDivisionExpression","unit","applyNumberDivision","divisor","reduceMultiplicationExpression","applyNumberMultiplication","multiplier","converted","_default","module"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,YAAY,GAAGC,sBAAsB,CAACC,OAAO,CAAC,eAAD,CAAR,CAAzC;;AAEA,SAASD,sBAAT,CAAgCE,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEJ,IAAAA,OAAO,EAAEI;AAAX,GAArC;AAAwD;;AAE/F,SAASE,WAAT,CAAqBC,IAArB,EAA2B;AACzB,UAAQA,IAAR;AACE,SAAK,aAAL;AACA,SAAK,YAAL;AACA,SAAK,WAAL;AACA,SAAK,gBAAL;AACA,SAAK,iBAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AACA,SAAK,UAAL;AACA,SAAK,SAAL;AACA,SAAK,SAAL;AACA,SAAK,WAAL;AACA,SAAK,WAAL;AACA,SAAK,iBAAL;AACA,SAAK,QAAL;AACE,aAAO,IAAP;AAhBJ;;AAmBA,SAAO,KAAP;AACD;;AAED,SAASC,IAAT,CAAcC,QAAd,EAAwB;AACtB,SAAOA,QAAQ,KAAK,GAAb,GAAmB,GAAnB,GAAyB,GAAhC;AACD;;AAED,SAASC,gBAAT,CAA0BD,QAA1B,EAAoC;AAClC,SAAOA,QAAQ,KAAK,GAAb,IAAoBA,QAAQ,KAAK,GAAxC;AACD;;AAED,SAASE,kBAAT,CAA4BC,WAA5B,EAAyCC,IAAzC,EAA+CC,SAA/C,EAA0DC,SAA1D,EAAqE;AACnE,MAAI,CAACL,gBAAgB,CAACE,WAAD,CAArB,EAAoC;AAClC,UAAM,IAAII,KAAJ,4BAA8BJ,WAA9B,EAAN;AACD;;AAED,MAAIL,IAAI,GAAGM,IAAI,CAACN,IAAhB;;AAEA,MAAID,WAAW,CAACC,IAAD,CAAf,EAAuB;AACrB,QAAIU,SAAS,GAAGH,SAAS,CAACI,SAAV,CAAoB,UAAUC,CAAV,EAAa;AAC/C,aAAOA,CAAC,CAACN,IAAF,CAAON,IAAP,KAAgBA,IAAvB;AACD,KAFe,CAAhB;;AAIA,QAAIU,SAAS,IAAI,CAAjB,EAAoB;AAClB,UAAIJ,IAAI,CAACd,KAAL,KAAe,CAAnB,EAAsB;AACpB;AACD;;AAED,UAAIqB,iBAAiB,GAAGC,gBAAgB,CAACP,SAAS,CAACG,SAAD,CAAT,CAAqBJ,IAAtB,EAA4BA,IAA5B,EAAkCE,SAAlC,CAAxC;AAAA,UACIO,WAAW,GAAGF,iBAAiB,CAACG,IADpC;AAAA,UAEIC,OAAO,GAAGJ,iBAAiB,CAACK,KAFhC;;AAIA,UAAIX,SAAS,CAACG,SAAD,CAAT,CAAqBL,WAArB,KAAqC,GAAzC,EAA8C;AAC5CE,QAAAA,SAAS,CAACG,SAAD,CAAT,CAAqBL,WAArB,GAAmC,GAAnC;AACAU,QAAAA,WAAW,CAACvB,KAAZ,IAAqB,CAAC,CAAtB;AACD;;AAED,UAAIa,WAAW,KAAK,GAApB,EAAyB;AACvBU,QAAAA,WAAW,CAACvB,KAAZ,IAAqByB,OAAO,CAACzB,KAA7B;AACD,OAFD,MAEO;AACLuB,QAAAA,WAAW,CAACvB,KAAZ,IAAqByB,OAAO,CAACzB,KAA7B;AACD,OAlBiB,CAkBhB;;;AAGF,UAAIuB,WAAW,CAACvB,KAAZ,IAAqB,CAAzB,EAA4B;AAC1Be,QAAAA,SAAS,CAACG,SAAD,CAAT,GAAuB;AACrBJ,UAAAA,IAAI,EAAES,WADe;AAErBV,UAAAA,WAAW,EAAE;AAFQ,SAAvB;AAID,OALD,MAKO;AACLU,QAAAA,WAAW,CAACvB,KAAZ,IAAqB,CAAC,CAAtB;AACAe,QAAAA,SAAS,CAACG,SAAD,CAAT,GAAuB;AACrBJ,UAAAA,IAAI,EAAES,WADe;AAErBV,UAAAA,WAAW,EAAE;AAFQ,SAAvB;AAID;AACF,KAjCD,MAiCO;AACL;AACA,UAAIC,IAAI,CAACd,KAAL,IAAc,CAAlB,EAAqB;AACnBe,QAAAA,SAAS,CAACY,IAAV,CAAe;AACbb,UAAAA,IAAI,EAAJA,IADa;AAEbD,UAAAA,WAAW,EAAXA;AAFa,SAAf;AAID,OALD,MAKO;AACLC,QAAAA,IAAI,CAACd,KAAL,IAAc,CAAC,CAAf;AACAe,QAAAA,SAAS,CAACY,IAAV,CAAe;AACbb,UAAAA,IAAI,EAAJA,IADa;AAEbD,UAAAA,WAAW,EAAEJ,IAAI,CAACI,WAAD;AAFJ,SAAf;AAID;AACF;AACF,GArDD,MAqDO,IAAIL,IAAI,KAAK,gBAAb,EAA+B;AACpC,QAAIG,gBAAgB,CAACG,IAAI,CAACJ,QAAN,CAApB,EAAqC;AACnCE,MAAAA,kBAAkB,CAACC,WAAD,EAAcC,IAAI,CAACU,IAAnB,EAAyBT,SAAzB,EAAoCC,SAApC,CAAlB;AACA,UAAIY,oBAAoB,GAAGf,WAAW,KAAK,GAAhB,GAAsBJ,IAAI,CAACK,IAAI,CAACJ,QAAN,CAA1B,GAA4CI,IAAI,CAACJ,QAA5E;AACAE,MAAAA,kBAAkB,CAACgB,oBAAD,EAAuBd,IAAI,CAACY,KAA5B,EAAmCX,SAAnC,EAA8CC,SAA9C,CAAlB;AACD,KAJD,MAIO;AACL;AACA,UAAIa,YAAY,GAAGC,MAAM,CAAChB,IAAD,EAAOE,SAAP,CAAzB,CAFK,CAEuC;;;AAG5C,UAAIa,YAAY,CAACrB,IAAb,KAAsB,gBAAtB,IAA0CG,gBAAgB,CAACkB,YAAY,CAACnB,QAAd,CAA9D,EAAuF;AACrFE,QAAAA,kBAAkB,CAACC,WAAD,EAAcgB,YAAd,EAA4Bd,SAA5B,EAAuCC,SAAvC,CAAlB;AACD,OAFD,MAEO;AACLD,QAAAA,SAAS,CAACY,IAAV,CAAe;AACbb,UAAAA,IAAI,EAAEe,YADO;AAEbhB,UAAAA,WAAW,EAAXA;AAFa,SAAf;AAID;AACF;AACF,GAnBM,MAmBA;AACLE,IAAAA,SAAS,CAACY,IAAV,CAAe;AACbb,MAAAA,IAAI,EAAJA,IADa;AAEbD,MAAAA,WAAW,EAAXA;AAFa,KAAf;AAID;AACF;;AAED,SAASkB,sBAAT,CAAgCjB,IAAhC,EAAsCE,SAAtC,EAAiD;AAC/C,MAAID,SAAS,GAAG,EAAhB;AACAH,EAAAA,kBAAkB,CAAC,GAAD,EAAME,IAAN,EAAYC,SAAZ,EAAuBC,SAAvB,CAAlB;AACA,MAAIgB,eAAe,GAAGjB,SAAS,CAACkB,MAAV,CAAiB,UAAUC,IAAV,EAAgB;AACrD,WAAO,EAAE3B,WAAW,CAAC2B,IAAI,CAACpB,IAAL,CAAUN,IAAX,CAAX,IAA+B0B,IAAI,CAACpB,IAAL,CAAUd,KAAV,KAAoB,CAArD,CAAP;AACD,GAFqB,CAAtB;AAGA,MAAImC,gBAAgB,GAAGH,eAAe,CAAC,CAAD,CAAtC,CAN+C,CAMJ;AAC3C;AACA;;AAEA,MAAI,CAACG,gBAAD,IAAqBA,gBAAgB,CAACtB,WAAjB,KAAiC,GAAjC,IAAwC,CAACN,WAAW,CAAC4B,gBAAgB,CAACrB,IAAjB,CAAsBN,IAAvB,CAA7E,EAA2G;AACzG,QAAI4B,aAAa,GAAGrB,SAAS,CAACsB,IAAV,CAAe,UAAUH,IAAV,EAAgB;AACjD,aAAO3B,WAAW,CAAC2B,IAAI,CAACpB,IAAL,CAAUN,IAAX,CAAX,IAA+B0B,IAAI,CAACpB,IAAL,CAAUd,KAAV,KAAoB,CAA1D;AACD,KAFmB,CAApB;AAGAgC,IAAAA,eAAe,CAACM,OAAhB,CAAwBF,aAAxB;AACD,GAf8C,CAe7C;;;AAGF,MAAIJ,eAAe,CAAC,CAAD,CAAf,CAAmBnB,WAAnB,KAAmC,GAAnC,IAA0CN,WAAW,CAACyB,eAAe,CAAC,CAAD,CAAf,CAAmBlB,IAAnB,CAAwBN,IAAzB,CAAzD,EAAyF;AACvFwB,IAAAA,eAAe,CAAC,CAAD,CAAf,CAAmBlB,IAAnB,CAAwBd,KAAxB,IAAiC,CAAC,CAAlC;AACAgC,IAAAA,eAAe,CAAC,CAAD,CAAf,CAAmBnB,WAAnB,GAAiC,GAAjC;AACD;;AAED,MAAI0B,IAAI,GAAGP,eAAe,CAAC,CAAD,CAAf,CAAmBlB,IAA9B;;AAEA,OAAK,IAAI0B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,eAAe,CAACS,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;AAC/CD,IAAAA,IAAI,GAAG;AACL/B,MAAAA,IAAI,EAAE,gBADD;AAELE,MAAAA,QAAQ,EAAEsB,eAAe,CAACQ,CAAD,CAAf,CAAmB3B,WAFxB;AAGLW,MAAAA,IAAI,EAAEe,IAHD;AAILb,MAAAA,KAAK,EAAEM,eAAe,CAACQ,CAAD,CAAf,CAAmB1B;AAJrB,KAAP;AAMD;;AAED,SAAOyB,IAAP;AACD;;AAED,SAASG,wBAAT,CAAkC5B,IAAlC,EAAwC;AACtC,MAAI,CAACP,WAAW,CAACO,IAAI,CAACY,KAAL,CAAWlB,IAAZ,CAAhB,EAAmC;AACjC,WAAOM,IAAP;AACD;;AAED,MAAIA,IAAI,CAACY,KAAL,CAAWlB,IAAX,KAAoB,QAAxB,EAAkC;AAChC,UAAM,IAAIS,KAAJ,8BAA+BH,IAAI,CAACY,KAAL,CAAWiB,IAA1C,yBAAN;AACD;;AAED,SAAOC,mBAAmB,CAAC9B,IAAI,CAACU,IAAN,EAAYV,IAAI,CAACY,KAAL,CAAW1B,KAAvB,CAA1B;AACD,C,CAAC;;;AAGF,SAAS4C,mBAAT,CAA6B9B,IAA7B,EAAmC+B,OAAnC,EAA4C;AAC1C,MAAIA,OAAO,KAAK,CAAhB,EAAmB;AACjB,UAAM,IAAI5B,KAAJ,CAAU,uBAAV,CAAN;AACD;;AAED,MAAIV,WAAW,CAACO,IAAI,CAACN,IAAN,CAAf,EAA4B;AAC1BM,IAAAA,IAAI,CAACd,KAAL,IAAc6C,OAAd;AACA,WAAO/B,IAAP;AACD;;AAED,MAAIA,IAAI,CAACN,IAAL,KAAc,gBAAd,IAAkCG,gBAAgB,CAACG,IAAI,CAACJ,QAAN,CAAtD,EAAuE;AACrE;AACA;AACA;AACA;AACA,WAAO;AACLF,MAAAA,IAAI,EAAE,gBADD;AAELE,MAAAA,QAAQ,EAAEI,IAAI,CAACJ,QAFV;AAGLc,MAAAA,IAAI,EAAEoB,mBAAmB,CAAC9B,IAAI,CAACU,IAAN,EAAYqB,OAAZ,CAHpB;AAILnB,MAAAA,KAAK,EAAEkB,mBAAmB,CAAC9B,IAAI,CAACY,KAAN,EAAamB,OAAb;AAJrB,KAAP;AAMD,GArByC,CAqBxC;AACF;AACA;;;AAGA,SAAO;AACLrC,IAAAA,IAAI,EAAE,gBADD;AAELE,IAAAA,QAAQ,EAAE,GAFL;AAGLc,IAAAA,IAAI,EAAEV,IAHD;AAILY,IAAAA,KAAK,EAAE;AACLlB,MAAAA,IAAI,EAAE,QADD;AAELR,MAAAA,KAAK,EAAE6C;AAFF;AAJF,GAAP;AASD;;AAED,SAASC,8BAAT,CAAwChC,IAAxC,EAA8C;AAC5C;AACA,MAAIA,IAAI,CAACY,KAAL,CAAWlB,IAAX,KAAoB,QAAxB,EAAkC;AAChC,WAAOuC,yBAAyB,CAACjC,IAAI,CAACU,IAAN,EAAYV,IAAI,CAACY,KAAL,CAAW1B,KAAvB,CAAhC;AACD,GAJ2C,CAI1C;;;AAGF,MAAIc,IAAI,CAACU,IAAL,CAAUhB,IAAV,KAAmB,QAAvB,EAAiC;AAC/B,WAAOuC,yBAAyB,CAACjC,IAAI,CAACY,KAAN,EAAaZ,IAAI,CAACU,IAAL,CAAUxB,KAAvB,CAAhC;AACD;;AAED,SAAOc,IAAP;AACD,C,CAAC;;;AAGF,SAASiC,yBAAT,CAAmCjC,IAAnC,EAAyCkC,UAAzC,EAAqD;AACnD,MAAIzC,WAAW,CAACO,IAAI,CAACN,IAAN,CAAf,EAA4B;AAC1BM,IAAAA,IAAI,CAACd,KAAL,IAAcgD,UAAd;AACA,WAAOlC,IAAP;AACD;;AAED,MAAIA,IAAI,CAACN,IAAL,KAAc,gBAAd,IAAkCG,gBAAgB,CAACG,IAAI,CAACJ,QAAN,CAAtD,EAAuE;AACrE;AACA;AACA;AACA;AACA,WAAO;AACLF,MAAAA,IAAI,EAAE,gBADD;AAELE,MAAAA,QAAQ,EAAEI,IAAI,CAACJ,QAFV;AAGLc,MAAAA,IAAI,EAAEuB,yBAAyB,CAACjC,IAAI,CAACU,IAAN,EAAYwB,UAAZ,CAH1B;AAILtB,MAAAA,KAAK,EAAEqB,yBAAyB,CAACjC,IAAI,CAACY,KAAN,EAAasB,UAAb;AAJ3B,KAAP;AAMD,GAjBkD,CAiBjD;AACF;AACA;;;AAGA,SAAO;AACLxC,IAAAA,IAAI,EAAE,gBADD;AAELE,IAAAA,QAAQ,EAAE,GAFL;AAGLc,IAAAA,IAAI,EAAEV,IAHD;AAILY,IAAAA,KAAK,EAAE;AACLlB,MAAAA,IAAI,EAAE,QADD;AAELR,MAAAA,KAAK,EAAEgD;AAFF;AAJF,GAAP;AASD;;AAED,SAAS1B,gBAAT,CAA0BE,IAA1B,EAAgCE,KAAhC,EAAuCV,SAAvC,EAAkD;AAChD,UAAQQ,IAAI,CAAChB,IAAb;AACE,SAAK,aAAL;AACA,SAAK,YAAL;AACA,SAAK,WAAL;AACA,SAAK,gBAAL;AACA,SAAK,iBAAL;AACE,UAAIkB,KAAK,CAAClB,IAAN,KAAegB,IAAI,CAAChB,IAApB,IAA4BkB,KAAK,CAACiB,IAAlC,IAA0CnB,IAAI,CAACmB,IAAnD,EAAyD;AACvD,YAAIM,SAAS,GAAG,CAAC,GAAG/C,YAAY,CAACD,OAAjB,EAA0ByB,KAAK,CAAC1B,KAAhC,EAAuC0B,KAAK,CAACiB,IAA7C,EAAmDnB,IAAI,CAACmB,IAAxD,EAA8D3B,SAA9D,CAAhB;AACAU,QAAAA,KAAK,GAAG;AACNlB,UAAAA,IAAI,EAAEgB,IAAI,CAAChB,IADL;AAENR,UAAAA,KAAK,EAAEiD,SAFD;AAGNN,UAAAA,IAAI,EAAEnB,IAAI,CAACmB;AAHL,SAAR;AAKD;;AAED,aAAO;AACLnB,QAAAA,IAAI,EAAJA,IADK;AAELE,QAAAA,KAAK,EAALA;AAFK,OAAP;;AAKF;AACE,aAAO;AACLF,QAAAA,IAAI,EAAJA,IADK;AAELE,QAAAA,KAAK,EAALA;AAFK,OAAP;AArBJ;AA0BD;;AAED,SAASI,MAAT,CAAgBhB,IAAhB,EAAsBE,SAAtB,EAAiC;AAC/B,MAAIF,IAAI,CAACN,IAAL,KAAc,gBAAlB,EAAoC;AAClC,QAAIG,gBAAgB,CAACG,IAAI,CAACJ,QAAN,CAApB,EAAqC;AACnC;AACA,aAAOqB,sBAAsB,CAACjB,IAAD,EAAOE,SAAP,CAA7B;AACD;;AAEDF,IAAAA,IAAI,CAACU,IAAL,GAAYM,MAAM,CAAChB,IAAI,CAACU,IAAN,EAAYR,SAAZ,CAAlB;AACAF,IAAAA,IAAI,CAACY,KAAL,GAAaI,MAAM,CAAChB,IAAI,CAACY,KAAN,EAAaV,SAAb,CAAnB;;AAEA,YAAQF,IAAI,CAACJ,QAAb;AACE,WAAK,GAAL;AACE,eAAOgC,wBAAwB,CAAC5B,IAAD,EAAOE,SAAP,CAA/B;;AAEF,WAAK,GAAL;AACE,eAAO8B,8BAA8B,CAAChC,IAAD,EAAOE,SAAP,CAArC;AALJ;;AAQA,WAAOF,IAAP;AACD;;AAED,SAAOA,IAAP;AACD;;AAED,IAAIoC,QAAQ,GAAGpB,MAAf;AACA/B,OAAO,CAACE,OAAR,GAAkBiD,QAAlB;AACAC,MAAM,CAACpD,OAAP,GAAiBA,OAAO,CAACE,OAAzB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _convertUnit = _interopRequireDefault(require(\"./convertUnit\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isValueType(type) {\n  switch (type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n    case 'EmValue':\n    case 'ExValue':\n    case 'ChValue':\n    case 'RemValue':\n    case 'VhValue':\n    case 'VwValue':\n    case 'VminValue':\n    case 'VmaxValue':\n    case 'PercentageValue':\n    case 'Number':\n      return true;\n  }\n\n  return false;\n}\n\nfunction flip(operator) {\n  return operator === '+' ? '-' : '+';\n}\n\nfunction isAddSubOperator(operator) {\n  return operator === '+' || operator === '-';\n}\n\nfunction collectAddSubItems(preOperator, node, collected, precision) {\n  if (!isAddSubOperator(preOperator)) {\n    throw new Error(`invalid operator ${preOperator}`);\n  }\n\n  var type = node.type;\n\n  if (isValueType(type)) {\n    var itemIndex = collected.findIndex(function (x) {\n      return x.node.type === type;\n    });\n\n    if (itemIndex >= 0) {\n      if (node.value === 0) {\n        return;\n      }\n\n      var _covertNodesUnits = covertNodesUnits(collected[itemIndex].node, node, precision),\n          reducedNode = _covertNodesUnits.left,\n          current = _covertNodesUnits.right;\n\n      if (collected[itemIndex].preOperator === '-') {\n        collected[itemIndex].preOperator = '+';\n        reducedNode.value *= -1;\n      }\n\n      if (preOperator === \"+\") {\n        reducedNode.value += current.value;\n      } else {\n        reducedNode.value -= current.value;\n      } // make sure reducedNode.value >= 0\n\n\n      if (reducedNode.value >= 0) {\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '+'\n        };\n      } else {\n        reducedNode.value *= -1;\n        collected[itemIndex] = {\n          node: reducedNode,\n          preOperator: '-'\n        };\n      }\n    } else {\n      // make sure node.value >= 0\n      if (node.value >= 0) {\n        collected.push({\n          node,\n          preOperator\n        });\n      } else {\n        node.value *= -1;\n        collected.push({\n          node,\n          preOperator: flip(preOperator)\n        });\n      }\n    }\n  } else if (type === \"MathExpression\") {\n    if (isAddSubOperator(node.operator)) {\n      collectAddSubItems(preOperator, node.left, collected, precision);\n      var collectRightOperator = preOperator === '-' ? flip(node.operator) : node.operator;\n      collectAddSubItems(collectRightOperator, node.right, collected, precision);\n    } else {\n      // * or /\n      var _reducedNode = reduce(node, precision); // prevent infinite recursive call\n\n\n      if (_reducedNode.type !== \"MathExpression\" || isAddSubOperator(_reducedNode.operator)) {\n        collectAddSubItems(preOperator, _reducedNode, collected, precision);\n      } else {\n        collected.push({\n          node: _reducedNode,\n          preOperator\n        });\n      }\n    }\n  } else {\n    collected.push({\n      node,\n      preOperator\n    });\n  }\n}\n\nfunction reduceAddSubExpression(node, precision) {\n  var collected = [];\n  collectAddSubItems('+', node, collected, precision);\n  var withoutZeroItem = collected.filter(function (item) {\n    return !(isValueType(item.node.type) && item.node.value === 0);\n  });\n  var firstNonZeroItem = withoutZeroItem[0]; // could be undefined\n  // prevent producing \"calc(-var(--a))\" or \"calc()\"\n  // which is invalid css\n\n  if (!firstNonZeroItem || firstNonZeroItem.preOperator === '-' && !isValueType(firstNonZeroItem.node.type)) {\n    var firstZeroItem = collected.find(function (item) {\n      return isValueType(item.node.type) && item.node.value === 0;\n    });\n    withoutZeroItem.unshift(firstZeroItem);\n  } // make sure the preOperator of the first item is +\n\n\n  if (withoutZeroItem[0].preOperator === '-' && isValueType(withoutZeroItem[0].node.type)) {\n    withoutZeroItem[0].node.value *= -1;\n    withoutZeroItem[0].preOperator = '+';\n  }\n\n  var root = withoutZeroItem[0].node;\n\n  for (var i = 1; i < withoutZeroItem.length; i++) {\n    root = {\n      type: 'MathExpression',\n      operator: withoutZeroItem[i].preOperator,\n      left: root,\n      right: withoutZeroItem[i].node\n    };\n  }\n\n  return root;\n}\n\nfunction reduceDivisionExpression(node) {\n  if (!isValueType(node.right.type)) {\n    return node;\n  }\n\n  if (node.right.type !== 'Number') {\n    throw new Error(`Cannot divide by \"${node.right.unit}\", number expected`);\n  }\n\n  return applyNumberDivision(node.left, node.right.value);\n} // apply (expr) / number\n\n\nfunction applyNumberDivision(node, divisor) {\n  if (divisor === 0) {\n    throw new Error('Cannot divide by zero');\n  }\n\n  if (isValueType(node.type)) {\n    node.value /= divisor;\n    return node;\n  }\n\n  if (node.type === \"MathExpression\" && isAddSubOperator(node.operator)) {\n    // turn (a + b) / num into a/num + b/num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce division before reducing additions\"\n    return {\n      type: \"MathExpression\",\n      operator: node.operator,\n      left: applyNumberDivision(node.left, divisor),\n      right: applyNumberDivision(node.right, divisor)\n    };\n  } // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n\n\n  return {\n    type: \"MathExpression\",\n    operator: '/',\n    left: node,\n    right: {\n      type: \"Number\",\n      value: divisor\n    }\n  };\n}\n\nfunction reduceMultiplicationExpression(node) {\n  // (expr) * number\n  if (node.right.type === 'Number') {\n    return applyNumberMultiplication(node.left, node.right.value);\n  } // number * (expr)\n\n\n  if (node.left.type === 'Number') {\n    return applyNumberMultiplication(node.right, node.left.value);\n  }\n\n  return node;\n} // apply (expr) / number\n\n\nfunction applyNumberMultiplication(node, multiplier) {\n  if (isValueType(node.type)) {\n    node.value *= multiplier;\n    return node;\n  }\n\n  if (node.type === \"MathExpression\" && isAddSubOperator(node.operator)) {\n    // turn (a + b) * num into a*num + b*num\n    // is good for further reduction\n    // checkout the test case\n    // \"should reduce multiplication before reducing additions\"\n    return {\n      type: \"MathExpression\",\n      operator: node.operator,\n      left: applyNumberMultiplication(node.left, multiplier),\n      right: applyNumberMultiplication(node.right, multiplier)\n    };\n  } // it is impossible to reduce it into a single value\n  // .e.g the node contains css variable\n  // so we just preserve the division and let browser do it\n\n\n  return {\n    type: \"MathExpression\",\n    operator: '*',\n    left: node,\n    right: {\n      type: \"Number\",\n      value: multiplier\n    }\n  };\n}\n\nfunction covertNodesUnits(left, right, precision) {\n  switch (left.type) {\n    case 'LengthValue':\n    case 'AngleValue':\n    case 'TimeValue':\n    case 'FrequencyValue':\n    case 'ResolutionValue':\n      if (right.type === left.type && right.unit && left.unit) {\n        var converted = (0, _convertUnit.default)(right.value, right.unit, left.unit, precision);\n        right = {\n          type: left.type,\n          value: converted,\n          unit: left.unit\n        };\n      }\n\n      return {\n        left,\n        right\n      };\n\n    default:\n      return {\n        left,\n        right\n      };\n  }\n}\n\nfunction reduce(node, precision) {\n  if (node.type === \"MathExpression\") {\n    if (isAddSubOperator(node.operator)) {\n      // reduceAddSubExpression will call reduce recursively\n      return reduceAddSubExpression(node, precision);\n    }\n\n    node.left = reduce(node.left, precision);\n    node.right = reduce(node.right, precision);\n\n    switch (node.operator) {\n      case \"/\":\n        return reduceDivisionExpression(node, precision);\n\n      case \"*\":\n        return reduceMultiplicationExpression(node, precision);\n    }\n\n    return node;\n  }\n\n  return node;\n}\n\nvar _default = reduce;\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}