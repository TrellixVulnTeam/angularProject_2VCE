{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/dom\", [\"require\", \"exports\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.RegistryDomSchemaChecker = void 0;\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var diagnostics_2 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\");\n\n  var REGISTRY = new compiler_1.DomElementSchemaRegistry();\n  var REMOVE_XHTML_REGEX = /^:xhtml:/;\n  /**\n   * Checks non-Angular elements and properties against the `DomElementSchemaRegistry`, a schema\n   * maintained by the Angular team via extraction from a browser IDL.\n   */\n\n  var RegistryDomSchemaChecker =\n  /** @class */\n  function () {\n    function RegistryDomSchemaChecker(resolver) {\n      this.resolver = resolver;\n      this._diagnostics = [];\n    }\n\n    Object.defineProperty(RegistryDomSchemaChecker.prototype, \"diagnostics\", {\n      get: function get() {\n        return this._diagnostics;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    RegistryDomSchemaChecker.prototype.checkElement = function (id, element, schemas) {\n      // HTML elements inside an SVG `foreignObject` are declared in the `xhtml` namespace.\n      // We need to strip it before handing it over to the registry because all HTML tag names\n      // in the registry are without a namespace.\n      var name = element.name.replace(REMOVE_XHTML_REGEX, '');\n\n      if (!REGISTRY.hasElement(name, schemas)) {\n        var mapping = this.resolver.getSourceMapping(id);\n        var errorMsg = \"'\" + name + \"' is not a known element:\\n\";\n        errorMsg += \"1. If '\" + name + \"' is an Angular component, then verify that it is part of this module.\\n\";\n\n        if (name.indexOf('-') > -1) {\n          errorMsg += \"2. If '\" + name + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\";\n        } else {\n          errorMsg += \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n        }\n\n        var diag = diagnostics_2.makeTemplateDiagnostic(id, mapping, element.startSourceSpan, ts.DiagnosticCategory.Error, diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.SCHEMA_INVALID_ELEMENT), errorMsg);\n\n        this._diagnostics.push(diag);\n      }\n    };\n\n    RegistryDomSchemaChecker.prototype.checkProperty = function (id, element, name, span, schemas) {\n      if (!REGISTRY.hasProperty(element.name, name, schemas)) {\n        var mapping = this.resolver.getSourceMapping(id);\n        var errorMsg = \"Can't bind to '\" + name + \"' since it isn't a known property of '\" + element.name + \"'.\";\n\n        if (element.name.startsWith('ng-')) {\n          errorMsg += \"\\n1. If '\" + name + \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\" + \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n        } else if (element.name.indexOf('-') > -1) {\n          errorMsg += \"\\n1. If '\" + element.name + \"' is an Angular component and it has '\" + name + \"' input, then verify that it is part of this module.\" + (\"\\n2. If '\" + element.name + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") + \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n        }\n\n        var diag = diagnostics_2.makeTemplateDiagnostic(id, mapping, span, ts.DiagnosticCategory.Error, diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMsg);\n\n        this._diagnostics.push(diag);\n      }\n    };\n\n    return RegistryDomSchemaChecker;\n  }();\n\n  exports.RegistryDomSchemaChecker = RegistryDomSchemaChecker;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/dom.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DomElementSchemaRegistry, ParseSourceSpan, SchemaMetadata, TmplAstElement} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, ngErrorCode} from '../../diagnostics';\nimport {TemplateId} from '../api';\nimport {makeTemplateDiagnostic, TemplateDiagnostic} from '../diagnostics';\n\nimport {TemplateSourceResolver} from './tcb_util';\n\nconst REGISTRY = new DomElementSchemaRegistry();\nconst REMOVE_XHTML_REGEX = /^:xhtml:/;\n\n/**\n * Checks every non-Angular element/property processed in a template and potentially produces\n * `ts.Diagnostic`s related to improper usage.\n *\n * A `DomSchemaChecker`'s job is to check DOM nodes and their attributes written used in templates\n * and produce `ts.Diagnostic`s if the nodes don't conform to the DOM specification. It acts as a\n * collector for these diagnostics, and can be queried later to retrieve the list of any that have\n * been generated.\n */\nexport interface DomSchemaChecker {\n  /**\n   * Get the `ts.Diagnostic`s that have been generated via `checkElement` and `checkProperty` calls\n   * thus far.\n   */\n  readonly diagnostics: ReadonlyArray<TemplateDiagnostic>;\n\n  /**\n   * Check a non-Angular element and record any diagnostics about it.\n   *\n   * @param id the template ID, suitable for resolution with a `TcbSourceResolver`.\n   * @param element the element node in question.\n   * @param schemas any active schemas for the template, which might affect the validity of the\n   * element.\n   */\n  checkElement(id: string, element: TmplAstElement, schemas: SchemaMetadata[]): void;\n\n  /**\n   * Check a property binding on an element and record any diagnostics about it.\n   *\n   * @param id the template ID, suitable for resolution with a `TcbSourceResolver`.\n   * @param element the element node in question.\n   * @param name the name of the property being checked.\n   * @param span the source span of the binding. This is redundant with `element.attributes` but is\n   * passed separately to avoid having to look up the particular property name.\n   * @param schemas any active schemas for the template, which might affect the validity of the\n   * property.\n   */\n  checkProperty(\n      id: string, element: TmplAstElement, name: string, span: ParseSourceSpan,\n      schemas: SchemaMetadata[]): void;\n}\n\n/**\n * Checks non-Angular elements and properties against the `DomElementSchemaRegistry`, a schema\n * maintained by the Angular team via extraction from a browser IDL.\n */\nexport class RegistryDomSchemaChecker implements DomSchemaChecker {\n  private _diagnostics: TemplateDiagnostic[] = [];\n\n  get diagnostics(): ReadonlyArray<TemplateDiagnostic> {\n    return this._diagnostics;\n  }\n\n  constructor(private resolver: TemplateSourceResolver) {}\n\n  checkElement(id: TemplateId, element: TmplAstElement, schemas: SchemaMetadata[]): void {\n    // HTML elements inside an SVG `foreignObject` are declared in the `xhtml` namespace.\n    // We need to strip it before handing it over to the registry because all HTML tag names\n    // in the registry are without a namespace.\n    const name = element.name.replace(REMOVE_XHTML_REGEX, '');\n\n    if (!REGISTRY.hasElement(name, schemas)) {\n      const mapping = this.resolver.getSourceMapping(id);\n\n      let errorMsg = `'${name}' is not a known element:\\n`;\n      errorMsg +=\n          `1. If '${name}' is an Angular component, then verify that it is part of this module.\\n`;\n      if (name.indexOf('-') > -1) {\n        errorMsg += `2. If '${\n            name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;\n      } else {\n        errorMsg +=\n            `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n      }\n\n      const diag = makeTemplateDiagnostic(\n          id, mapping, element.startSourceSpan, ts.DiagnosticCategory.Error,\n          ngErrorCode(ErrorCode.SCHEMA_INVALID_ELEMENT), errorMsg);\n      this._diagnostics.push(diag);\n    }\n  }\n\n  checkProperty(\n      id: TemplateId, element: TmplAstElement, name: string, span: ParseSourceSpan,\n      schemas: SchemaMetadata[]): void {\n    if (!REGISTRY.hasProperty(element.name, name, schemas)) {\n      const mapping = this.resolver.getSourceMapping(id);\n\n      let errorMsg =\n          `Can't bind to '${name}' since it isn't a known property of '${element.name}'.`;\n      if (element.name.startsWith('ng-')) {\n        errorMsg +=\n            `\\n1. If '${\n                name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +\n            `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n      } else if (element.name.indexOf('-') > -1) {\n        errorMsg +=\n            `\\n1. If '${element.name}' is an Angular component and it has '${\n                name}' input, then verify that it is part of this module.` +\n            `\\n2. If '${\n                element\n                    .name}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +\n            `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n      }\n\n      const diag = makeTemplateDiagnostic(\n          id, mapping, span, ts.DiagnosticCategory.Error,\n          ngErrorCode(ErrorCode.SCHEMA_INVALID_ATTRIBUTE), errorMsg);\n      this._diagnostics.push(diag);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}