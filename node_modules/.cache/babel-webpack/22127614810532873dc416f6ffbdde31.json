{"ast":null,"code":"'use strict';\n/* global window: true */\n\n/* eslint-disable\n  multiline-ternary,\n  no-param-reassign\n*/\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PrefixFactory = require('./PrefixFactory');\n\nvar MethodFactory = require('./MethodFactory');\n\nvar defaults = {\n  name: +new Date(),\n  level: 'warn',\n  prefix: null,\n  factory: null\n};\n\nvar LogLevel = /*#__PURE__*/function () {\n  function LogLevel(options) {\n    _classCallCheck(this, LogLevel);\n\n    // implement for some _very_ loose type checking. avoids getting into a\n    // circular require between MethodFactory and LogLevel\n    this.type = 'LogLevel';\n    this.options = Object.assign({}, defaults, options);\n    this.methodFactory = options.factory;\n\n    if (!this.methodFactory) {\n      var factory = options.prefix ? new PrefixFactory(this, options.prefix) : new MethodFactory(this);\n      this.methodFactory = factory;\n    }\n\n    if (!this.methodFactory.logger) {\n      this.methodFactory.logger = this;\n    }\n\n    this.name = options.name || '<unknown>'; // this.level is a setter, do this after setting up the factory\n\n    this.level = this.options.level;\n  }\n\n  _createClass(LogLevel, [{\n    key: \"factory\",\n    get: function get() {\n      return this.methodFactory;\n    },\n    set: function set(factory) {\n      factory.logger = this;\n      this.methodFactory = factory;\n      this.methodFactory.replaceMethods(this.level);\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      this.level = this.levels.TRACE;\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.level = this.levels.SILENT;\n    }\n  }, {\n    key: \"level\",\n    get: function get() {\n      return this.currentLevel;\n    },\n    set: function set(logLevel) {\n      var level = this.methodFactory.distillLevel(logLevel);\n\n      if (level == null) {\n        throw new Error(\"loglevel: setLevel() called with invalid level: \".concat(logLevel));\n      }\n\n      this.currentLevel = level;\n      this.methodFactory.replaceMethods(level);\n\n      if (typeof console === 'undefined' && level < this.levels.SILENT) {\n        // eslint-disable-next-line no-console\n        console.warn('loglevel: console is undefined. The log will produce no output');\n      }\n    }\n  }, {\n    key: \"levels\",\n    get: function get() {\n      // eslint-disable-line class-methods-use-this\n      return this.methodFactory.levels;\n    }\n  }]);\n\n  return LogLevel;\n}();\n\nmodule.exports = LogLevel;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack-log/src/loglevel/LogLevel.js"],"names":["PrefixFactory","require","MethodFactory","defaults","name","Date","level","prefix","factory","LogLevel","options","type","Object","assign","methodFactory","logger","replaceMethods","levels","TRACE","SILENT","currentLevel","logLevel","distillLevel","Error","console","warn","module","exports"],"mappings":"AAAA;AAEA;;AACA;AACA;AACA;AACA;;;;;;AACA,IAAMA,aAAa,GAAGC,OAAO,CAAC,iBAAD,CAA7B;;AACA,IAAMC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA7B;;AAEA,IAAME,QAAQ,GAAG;AACfC,EAAAA,IAAI,EAAE,CAAC,IAAIC,IAAJ,EADQ;AAEfC,EAAAA,KAAK,EAAE,MAFQ;AAGfC,EAAAA,MAAM,EAAE,IAHO;AAIfC,EAAAA,OAAO,EAAE;AAJM,CAAjB;;IAOMC,Q;AACJ,oBAAYC,OAAZ,EAAqB;AAAA;;AACnB;AACA;AACA,SAAKC,IAAL,GAAY,UAAZ;AACA,SAAKD,OAAL,GAAeE,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBV,QAAlB,EAA4BO,OAA5B,CAAf;AACA,SAAKI,aAAL,GAAqBJ,OAAO,CAACF,OAA7B;;AAEA,QAAI,CAAC,KAAKM,aAAV,EAAyB;AACvB,UAAMN,OAAO,GAAGE,OAAO,CAACH,MAAR,GACZ,IAAIP,aAAJ,CAAkB,IAAlB,EAAwBU,OAAO,CAACH,MAAhC,CADY,GAEZ,IAAIL,aAAJ,CAAkB,IAAlB,CAFJ;AAIA,WAAKY,aAAL,GAAqBN,OAArB;AACD;;AAED,QAAI,CAAC,KAAKM,aAAL,CAAmBC,MAAxB,EAAgC;AAC9B,WAAKD,aAAL,CAAmBC,MAAnB,GAA4B,IAA5B;AACD;;AAED,SAAKX,IAAL,GAAYM,OAAO,CAACN,IAAR,IAAgB,WAA5B,CAnBmB,CAoBnB;;AACA,SAAKE,KAAL,GAAa,KAAKI,OAAL,CAAaJ,KAA1B;AACD;;;;SAED,eAAc;AACZ,aAAO,KAAKQ,aAAZ;AACD,K;SAED,aAAYN,OAAZ,EAAqB;AACnBA,MAAAA,OAAO,CAACO,MAAR,GAAiB,IAAjB;AAEA,WAAKD,aAAL,GAAqBN,OAArB;AACA,WAAKM,aAAL,CAAmBE,cAAnB,CAAkC,KAAKV,KAAvC;AACD;;;WAED,kBAAS;AACP,WAAKA,KAAL,GAAa,KAAKW,MAAL,CAAYC,KAAzB;AACD;;;WAED,mBAAU;AACR,WAAKZ,KAAL,GAAa,KAAKW,MAAL,CAAYE,MAAzB;AACD;;;SAED,eAAY;AACV,aAAO,KAAKC,YAAZ;AACD,K;SAED,aAAUC,QAAV,EAAoB;AAClB,UAAMf,KAAK,GAAG,KAAKQ,aAAL,CAAmBQ,YAAnB,CAAgCD,QAAhC,CAAd;;AAEA,UAAIf,KAAK,IAAI,IAAb,EAAmB;AACjB,cAAM,IAAIiB,KAAJ,2DAC+CF,QAD/C,EAAN;AAGD;;AAED,WAAKD,YAAL,GAAoBd,KAApB;AACA,WAAKQ,aAAL,CAAmBE,cAAnB,CAAkCV,KAAlC;;AAEA,UAAI,OAAOkB,OAAP,KAAmB,WAAnB,IAAkClB,KAAK,GAAG,KAAKW,MAAL,CAAYE,MAA1D,EAAkE;AAChE;AACAK,QAAAA,OAAO,CAACC,IAAR,CACE,gEADF;AAGD;AACF;;;SAED,eAAa;AAAE;AACb,aAAO,KAAKX,aAAL,CAAmBG,MAA1B;AACD;;;;;;AAGHS,MAAM,CAACC,OAAP,GAAiBlB,QAAjB","sourcesContent":["'use strict';\n\n/* global window: true */\n/* eslint-disable\n  multiline-ternary,\n  no-param-reassign\n*/\nconst PrefixFactory = require('./PrefixFactory');\nconst MethodFactory = require('./MethodFactory');\n\nconst defaults = {\n  name: +new Date(),\n  level: 'warn',\n  prefix: null,\n  factory: null\n};\n\nclass LogLevel {\n  constructor(options) {\n    // implement for some _very_ loose type checking. avoids getting into a\n    // circular require between MethodFactory and LogLevel\n    this.type = 'LogLevel';\n    this.options = Object.assign({}, defaults, options);\n    this.methodFactory = options.factory;\n\n    if (!this.methodFactory) {\n      const factory = options.prefix\n        ? new PrefixFactory(this, options.prefix)\n        : new MethodFactory(this);\n\n      this.methodFactory = factory;\n    }\n\n    if (!this.methodFactory.logger) {\n      this.methodFactory.logger = this;\n    }\n\n    this.name = options.name || '<unknown>';\n    // this.level is a setter, do this after setting up the factory\n    this.level = this.options.level;\n  }\n\n  get factory() {\n    return this.methodFactory;\n  }\n\n  set factory(factory) {\n    factory.logger = this;\n\n    this.methodFactory = factory;\n    this.methodFactory.replaceMethods(this.level);\n  }\n\n  enable() {\n    this.level = this.levels.TRACE;\n  }\n\n  disable() {\n    this.level = this.levels.SILENT;\n  }\n\n  get level() {\n    return this.currentLevel;\n  }\n\n  set level(logLevel) {\n    const level = this.methodFactory.distillLevel(logLevel);\n\n    if (level == null) {\n      throw new Error(\n        `loglevel: setLevel() called with invalid level: ${logLevel}`\n      );\n    }\n\n    this.currentLevel = level;\n    this.methodFactory.replaceMethods(level);\n\n    if (typeof console === 'undefined' && level < this.levels.SILENT) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'loglevel: console is undefined. The log will produce no output'\n      );\n    }\n  }\n\n  get levels() { // eslint-disable-line class-methods-use-this\n    return this.methodFactory.levels;\n  }\n}\n\nmodule.exports = LogLevel;\n"]},"metadata":{},"sourceType":"script"}