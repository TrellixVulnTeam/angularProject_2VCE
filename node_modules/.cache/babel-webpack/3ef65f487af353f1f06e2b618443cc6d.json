{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    HookMap = _require.HookMap,\n    SyncHook = _require.SyncHook,\n    SyncWaterfallHook = _require.SyncWaterfallHook;\n\nvar Factory = require(\"enhanced-resolve\").ResolverFactory;\n\nvar _require2 = require(\"./util/cleverMerge\"),\n    cachedCleverMerge = _require2.cachedCleverMerge;\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\n\nvar EMTPY_RESOLVE_OPTIONS = {};\n\nmodule.exports = /*#__PURE__*/function (_Tapable) {\n  _inherits(ResolverFactory, _Tapable);\n\n  var _super = _createSuper(ResolverFactory);\n\n  function ResolverFactory() {\n    var _this;\n\n    _classCallCheck(this, ResolverFactory);\n\n    _this = _super.call(this);\n    _this.hooks = {\n      resolveOptions: new HookMap(function () {\n        return new SyncWaterfallHook([\"resolveOptions\"]);\n      }),\n      resolver: new HookMap(function () {\n        return new SyncHook([\"resolver\", \"resolveOptions\"]);\n      })\n    };\n\n    _this._pluginCompat.tap(\"ResolverFactory\", function (options) {\n      var match;\n      match = /^resolve-options (.+)$/.exec(options.name);\n\n      if (match) {\n        _this.hooks.resolveOptions.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\n        return true;\n      }\n\n      match = /^resolver (.+)$/.exec(options.name);\n\n      if (match) {\n        _this.hooks.resolver.for(match[1]).tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\n        return true;\n      }\n    });\n\n    _this.cache2 = new Map();\n    return _this;\n  }\n\n  _createClass(ResolverFactory, [{\n    key: \"get\",\n    value: function get(type, resolveOptions) {\n      resolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;\n      var ident = \"\".concat(type, \"|\").concat(JSON.stringify(resolveOptions));\n      var resolver = this.cache2.get(ident);\n      if (resolver) return resolver;\n\n      var newResolver = this._create(type, resolveOptions);\n\n      this.cache2.set(ident, newResolver);\n      return newResolver;\n    }\n  }, {\n    key: \"_create\",\n    value: function _create(type, resolveOptions) {\n      var _this2 = this;\n\n      var originalResolveOptions = Object.assign({}, resolveOptions);\n      resolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n      var resolver = Factory.createResolver(resolveOptions);\n\n      if (!resolver) {\n        throw new Error(\"No resolver created\");\n      }\n      /** @type {Map<Object, Resolver>} */\n\n\n      var childCache = new Map();\n\n      resolver.withOptions = function (options) {\n        var cacheEntry = childCache.get(options);\n        if (cacheEntry !== undefined) return cacheEntry;\n        var mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n\n        var resolver = _this2.get(type, mergedOptions);\n\n        childCache.set(options, resolver);\n        return resolver;\n      };\n\n      this.hooks.resolver.for(type).call(resolver, resolveOptions);\n      return resolver;\n    }\n  }]);\n\n  return ResolverFactory;\n}(Tapable);","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/ResolverFactory.js"],"names":["require","Tapable","HookMap","SyncHook","SyncWaterfallHook","Factory","ResolverFactory","cachedCleverMerge","EMTPY_RESOLVE_OPTIONS","module","exports","hooks","resolveOptions","resolver","_pluginCompat","tap","options","match","exec","name","for","fn","cache2","Map","type","ident","JSON","stringify","get","newResolver","_create","set","originalResolveOptions","Object","assign","call","createResolver","Error","childCache","withOptions","cacheEntry","undefined","mergedOptions"],"mappings":"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","sourcesContent":["/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\"use strict\";\n\nconst { Tapable, HookMap, SyncHook, SyncWaterfallHook } = require(\"tapable\");\nconst Factory = require(\"enhanced-resolve\").ResolverFactory;\nconst { cachedCleverMerge } = require(\"./util/cleverMerge\");\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n\nconst EMTPY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ResolverFactory extends Tapable {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tresolveOptions: new HookMap(\n\t\t\t\t() => new SyncWaterfallHook([\"resolveOptions\"])\n\t\t\t),\n\t\t\tresolver: new HookMap(() => new SyncHook([\"resolver\", \"resolveOptions\"]))\n\t\t};\n\t\tthis._pluginCompat.tap(\"ResolverFactory\", options => {\n\t\t\tlet match;\n\t\t\tmatch = /^resolve-options (.+)$/.exec(options.name);\n\t\t\tif (match) {\n\t\t\t\tthis.hooks.resolveOptions\n\t\t\t\t\t.for(match[1])\n\t\t\t\t\t.tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tmatch = /^resolver (.+)$/.exec(options.name);\n\t\t\tif (match) {\n\t\t\t\tthis.hooks.resolver\n\t\t\t\t\t.for(match[1])\n\t\t\t\t\t.tap(options.fn.name || \"unnamed compat plugin\", options.fn);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tthis.cache2 = new Map();\n\t}\n\n\tget(type, resolveOptions) {\n\t\tresolveOptions = resolveOptions || EMTPY_RESOLVE_OPTIONS;\n\t\tconst ident = `${type}|${JSON.stringify(resolveOptions)}`;\n\t\tconst resolver = this.cache2.get(ident);\n\t\tif (resolver) return resolver;\n\t\tconst newResolver = this._create(type, resolveOptions);\n\t\tthis.cache2.set(ident, newResolver);\n\t\treturn newResolver;\n\t}\n\n\t_create(type, resolveOptions) {\n\t\tconst originalResolveOptions = Object.assign({}, resolveOptions);\n\t\tresolveOptions = this.hooks.resolveOptions.for(type).call(resolveOptions);\n\t\tconst resolver = Factory.createResolver(resolveOptions);\n\t\tif (!resolver) {\n\t\t\tthrow new Error(\"No resolver created\");\n\t\t}\n\t\t/** @type {Map<Object, Resolver>} */\n\t\tconst childCache = new Map();\n\t\tresolver.withOptions = options => {\n\t\t\tconst cacheEntry = childCache.get(options);\n\t\t\tif (cacheEntry !== undefined) return cacheEntry;\n\t\t\tconst mergedOptions = cachedCleverMerge(originalResolveOptions, options);\n\t\t\tconst resolver = this.get(type, mergedOptions);\n\t\t\tchildCache.set(options, resolver);\n\t\t\treturn resolver;\n\t\t};\n\t\tthis.hooks.resolver.for(type).call(resolver, resolveOptions);\n\t\treturn resolver;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}