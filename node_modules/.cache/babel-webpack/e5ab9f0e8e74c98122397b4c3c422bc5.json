{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/builtin\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/known_declaration\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/result\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.StaticInterpreter = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var builtin_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/builtin\");\n\n  var dynamic_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic\");\n\n  var known_declaration_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/known_declaration\");\n\n  var result_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/result\");\n\n  function literalBinaryOp(op) {\n    return {\n      op: op,\n      literal: true\n    };\n  }\n\n  function referenceBinaryOp(op) {\n    return {\n      op: op,\n      literal: false\n    };\n  }\n\n  var BINARY_OPERATORS = new Map([[ts.SyntaxKind.PlusToken, literalBinaryOp(function (a, b) {\n    return a + b;\n  })], [ts.SyntaxKind.MinusToken, literalBinaryOp(function (a, b) {\n    return a - b;\n  })], [ts.SyntaxKind.AsteriskToken, literalBinaryOp(function (a, b) {\n    return a * b;\n  })], [ts.SyntaxKind.SlashToken, literalBinaryOp(function (a, b) {\n    return a / b;\n  })], [ts.SyntaxKind.PercentToken, literalBinaryOp(function (a, b) {\n    return a % b;\n  })], [ts.SyntaxKind.AmpersandToken, literalBinaryOp(function (a, b) {\n    return a & b;\n  })], [ts.SyntaxKind.BarToken, literalBinaryOp(function (a, b) {\n    return a | b;\n  })], [ts.SyntaxKind.CaretToken, literalBinaryOp(function (a, b) {\n    return a ^ b;\n  })], [ts.SyntaxKind.LessThanToken, literalBinaryOp(function (a, b) {\n    return a < b;\n  })], [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp(function (a, b) {\n    return a <= b;\n  })], [ts.SyntaxKind.GreaterThanToken, literalBinaryOp(function (a, b) {\n    return a > b;\n  })], [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp(function (a, b) {\n    return a >= b;\n  })], [ts.SyntaxKind.EqualsEqualsToken, literalBinaryOp(function (a, b) {\n    return a == b;\n  })], [ts.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp(function (a, b) {\n    return a === b;\n  })], [ts.SyntaxKind.ExclamationEqualsToken, literalBinaryOp(function (a, b) {\n    return a != b;\n  })], [ts.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp(function (a, b) {\n    return a !== b;\n  })], [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp(function (a, b) {\n    return a << b;\n  })], [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp(function (a, b) {\n    return a >> b;\n  })], [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp(function (a, b) {\n    return a >>> b;\n  })], [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp(function (a, b) {\n    return Math.pow(a, b);\n  })], [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp(function (a, b) {\n    return a && b;\n  })], [ts.SyntaxKind.BarBarToken, referenceBinaryOp(function (a, b) {\n    return a || b;\n  })]]);\n  var UNARY_OPERATORS = new Map([[ts.SyntaxKind.TildeToken, function (a) {\n    return ~a;\n  }], [ts.SyntaxKind.MinusToken, function (a) {\n    return -a;\n  }], [ts.SyntaxKind.PlusToken, function (a) {\n    return +a;\n  }], [ts.SyntaxKind.ExclamationToken, function (a) {\n    return !a;\n  }]]);\n\n  var StaticInterpreter =\n  /** @class */\n  function () {\n    function StaticInterpreter(host, checker, dependencyTracker) {\n      this.host = host;\n      this.checker = checker;\n      this.dependencyTracker = dependencyTracker;\n    }\n\n    StaticInterpreter.prototype.visit = function (node, context) {\n      return this.visitExpression(node, context);\n    };\n\n    StaticInterpreter.prototype.visitExpression = function (node, context) {\n      var result;\n\n      if (node.kind === ts.SyntaxKind.TrueKeyword) {\n        return true;\n      } else if (node.kind === ts.SyntaxKind.FalseKeyword) {\n        return false;\n      } else if (node.kind === ts.SyntaxKind.NullKeyword) {\n        return null;\n      } else if (ts.isStringLiteral(node)) {\n        return node.text;\n      } else if (ts.isNoSubstitutionTemplateLiteral(node)) {\n        return node.text;\n      } else if (ts.isTemplateExpression(node)) {\n        result = this.visitTemplateExpression(node, context);\n      } else if (ts.isNumericLiteral(node)) {\n        return parseFloat(node.text);\n      } else if (ts.isObjectLiteralExpression(node)) {\n        result = this.visitObjectLiteralExpression(node, context);\n      } else if (ts.isIdentifier(node)) {\n        result = this.visitIdentifier(node, context);\n      } else if (ts.isPropertyAccessExpression(node)) {\n        result = this.visitPropertyAccessExpression(node, context);\n      } else if (ts.isCallExpression(node)) {\n        result = this.visitCallExpression(node, context);\n      } else if (ts.isConditionalExpression(node)) {\n        result = this.visitConditionalExpression(node, context);\n      } else if (ts.isPrefixUnaryExpression(node)) {\n        result = this.visitPrefixUnaryExpression(node, context);\n      } else if (ts.isBinaryExpression(node)) {\n        result = this.visitBinaryExpression(node, context);\n      } else if (ts.isArrayLiteralExpression(node)) {\n        result = this.visitArrayLiteralExpression(node, context);\n      } else if (ts.isParenthesizedExpression(node)) {\n        result = this.visitParenthesizedExpression(node, context);\n      } else if (ts.isElementAccessExpression(node)) {\n        result = this.visitElementAccessExpression(node, context);\n      } else if (ts.isAsExpression(node)) {\n        result = this.visitExpression(node.expression, context);\n      } else if (ts.isNonNullExpression(node)) {\n        result = this.visitExpression(node.expression, context);\n      } else if (this.host.isClass(node)) {\n        result = this.visitDeclaration(node, context);\n      } else {\n        return dynamic_1.DynamicValue.fromUnsupportedSyntax(node);\n      }\n\n      if (result instanceof dynamic_1.DynamicValue && result.node !== node) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, result);\n      }\n\n      return result;\n    };\n\n    StaticInterpreter.prototype.visitArrayLiteralExpression = function (node, context) {\n      var array = [];\n\n      for (var i = 0; i < node.elements.length; i++) {\n        var element = node.elements[i];\n\n        if (ts.isSpreadElement(element)) {\n          array.push.apply(array, tslib_1.__spread(this.visitSpreadElement(element, context)));\n        } else {\n          array.push(this.visitExpression(element, context));\n        }\n      }\n\n      return array;\n    };\n\n    StaticInterpreter.prototype.visitObjectLiteralExpression = function (node, context) {\n      var map = new Map();\n\n      for (var i = 0; i < node.properties.length; i++) {\n        var property = node.properties[i];\n\n        if (ts.isPropertyAssignment(property)) {\n          var name_1 = this.stringNameFromPropertyName(property.name, context); // Check whether the name can be determined statically.\n\n          if (name_1 === undefined) {\n            return dynamic_1.DynamicValue.fromDynamicInput(node, dynamic_1.DynamicValue.fromDynamicString(property.name));\n          }\n\n          map.set(name_1, this.visitExpression(property.initializer, context));\n        } else if (ts.isShorthandPropertyAssignment(property)) {\n          var symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n\n          if (symbol === undefined || symbol.valueDeclaration === undefined) {\n            map.set(property.name.text, dynamic_1.DynamicValue.fromUnknown(property));\n          } else {\n            map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));\n          }\n        } else if (ts.isSpreadAssignment(property)) {\n          var spread = this.visitExpression(property.expression, context);\n\n          if (spread instanceof dynamic_1.DynamicValue) {\n            return dynamic_1.DynamicValue.fromDynamicInput(node, spread);\n          } else if (spread instanceof Map) {\n            spread.forEach(function (value, key) {\n              return map.set(key, value);\n            });\n          } else if (spread instanceof result_1.ResolvedModule) {\n            spread.getExports().forEach(function (value, key) {\n              return map.set(key, value);\n            });\n          } else {\n            return dynamic_1.DynamicValue.fromDynamicInput(node, dynamic_1.DynamicValue.fromInvalidExpressionType(property, spread));\n          }\n        } else {\n          return dynamic_1.DynamicValue.fromUnknown(node);\n        }\n      }\n\n      return map;\n    };\n\n    StaticInterpreter.prototype.visitTemplateExpression = function (node, context) {\n      var pieces = [node.head.text];\n\n      var _loop_1 = function _loop_1(i) {\n        var span = node.templateSpans[i];\n        var value = literal(this_1.visit(span.expression, context), function () {\n          return dynamic_1.DynamicValue.fromDynamicString(span.expression);\n        });\n\n        if (value instanceof dynamic_1.DynamicValue) {\n          return {\n            value: dynamic_1.DynamicValue.fromDynamicInput(node, value)\n          };\n        }\n\n        pieces.push(\"\" + value, span.literal.text);\n      };\n\n      var this_1 = this;\n\n      for (var i = 0; i < node.templateSpans.length; i++) {\n        var state_1 = _loop_1(i);\n\n        if (typeof state_1 === \"object\") return state_1.value;\n      }\n\n      return pieces.join('');\n    };\n\n    StaticInterpreter.prototype.visitIdentifier = function (node, context) {\n      var decl = this.host.getDeclarationOfIdentifier(node);\n\n      if (decl === null) {\n        if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {\n          return undefined;\n        } else {\n          // Check if the symbol here is imported.\n          if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {\n            // It was, but no declaration for the node could be found. This means that the dependency\n            // graph for the current file cannot be properly updated to account for this (broken)\n            // import. Instead, the originating file is reported as failing dependency analysis,\n            // ensuring that future compilations will always attempt to re-resolve the previously\n            // broken identifier.\n            this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);\n          }\n\n          return dynamic_1.DynamicValue.fromUnknownIdentifier(node);\n        }\n      }\n\n      if (decl.known !== null) {\n        return known_declaration_1.resolveKnownDeclaration(decl.known);\n      } else if (reflection_1.isConcreteDeclaration(decl) && decl.identity !== null && decl.identity.kind === 0\n      /* DownleveledEnum */\n      ) {\n          return this.getResolvedEnum(decl.node, decl.identity.enumMembers, context);\n        }\n\n      var declContext = tslib_1.__assign(tslib_1.__assign({}, context), joinModuleContext(context, node, decl));\n\n      var result = this.visitAmbiguousDeclaration(decl, declContext);\n\n      if (result instanceof imports_1.Reference) {\n        // Only record identifiers to non-synthetic references. Synthetic references may not have the\n        // same value at runtime as they do at compile time, so it's not legal to refer to them by the\n        // identifier here.\n        if (!result.synthetic) {\n          result.addIdentifier(node);\n        }\n      } else if (result instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, result);\n      }\n\n      return result;\n    };\n\n    StaticInterpreter.prototype.visitDeclaration = function (node, context) {\n      if (this.dependencyTracker !== null) {\n        this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());\n      }\n\n      if (this.host.isClass(node)) {\n        return this.getReference(node, context);\n      } else if (ts.isVariableDeclaration(node)) {\n        return this.visitVariableDeclaration(node, context);\n      } else if (ts.isParameter(node) && context.scope.has(node)) {\n        return context.scope.get(node);\n      } else if (ts.isExportAssignment(node)) {\n        return this.visitExpression(node.expression, context);\n      } else if (ts.isEnumDeclaration(node)) {\n        return this.visitEnumDeclaration(node, context);\n      } else if (ts.isSourceFile(node)) {\n        return this.visitSourceFile(node, context);\n      } else if (ts.isBindingElement(node)) {\n        return this.visitBindingElement(node, context);\n      } else {\n        return this.getReference(node, context);\n      }\n    };\n\n    StaticInterpreter.prototype.visitVariableDeclaration = function (node, context) {\n      var value = this.host.getVariableValue(node);\n\n      if (value !== null) {\n        return this.visitExpression(value, context);\n      } else if (isVariableDeclarationDeclared(node)) {\n        return this.getReference(node, context);\n      } else {\n        return undefined;\n      }\n    };\n\n    StaticInterpreter.prototype.visitEnumDeclaration = function (node, context) {\n      var _this = this;\n\n      var enumRef = this.getReference(node, context);\n      var map = new Map();\n      node.members.forEach(function (member) {\n        var name = _this.stringNameFromPropertyName(member.name, context);\n\n        if (name !== undefined) {\n          var resolved = member.initializer && _this.visit(member.initializer, context);\n\n          map.set(name, new result_1.EnumValue(enumRef, name, resolved));\n        }\n      });\n      return map;\n    };\n\n    StaticInterpreter.prototype.visitElementAccessExpression = function (node, context) {\n      var lhs = this.visitExpression(node.expression, context);\n\n      if (lhs instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, lhs);\n      }\n\n      var rhs = this.visitExpression(node.argumentExpression, context);\n\n      if (rhs instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, rhs);\n      }\n\n      if (typeof rhs !== 'string' && typeof rhs !== 'number') {\n        return dynamic_1.DynamicValue.fromInvalidExpressionType(node, rhs);\n      }\n\n      return this.accessHelper(node, lhs, rhs, context);\n    };\n\n    StaticInterpreter.prototype.visitPropertyAccessExpression = function (node, context) {\n      var lhs = this.visitExpression(node.expression, context);\n      var rhs = node.name.text; // TODO: handle reference to class declaration.\n\n      if (lhs instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, lhs);\n      }\n\n      return this.accessHelper(node, lhs, rhs, context);\n    };\n\n    StaticInterpreter.prototype.visitSourceFile = function (node, context) {\n      var _this = this;\n\n      var declarations = this.host.getExportsOfModule(node);\n\n      if (declarations === null) {\n        return dynamic_1.DynamicValue.fromUnknown(node);\n      }\n\n      return new result_1.ResolvedModule(declarations, function (decl) {\n        if (decl.known !== null) {\n          return known_declaration_1.resolveKnownDeclaration(decl.known);\n        }\n\n        var declContext = tslib_1.__assign(tslib_1.__assign({}, context), joinModuleContext(context, node, decl)); // Visit both concrete and inline declarations.\n\n\n        return _this.visitAmbiguousDeclaration(decl, declContext);\n      });\n    };\n\n    StaticInterpreter.prototype.visitAmbiguousDeclaration = function (decl, declContext) {\n      return decl.kind === 1\n      /* Inline */\n      && decl.implementation !== undefined && !typescript_1.isDeclaration(decl.implementation) ? // Inline declarations whose `implementation` is a `ts.Expression` should be visited as\n      // an expression.\n      this.visitExpression(decl.implementation, declContext) : // Otherwise just visit the `node` as a declaration.\n      this.visitDeclaration(decl.node, declContext);\n    };\n\n    StaticInterpreter.prototype.accessHelper = function (node, lhs, rhs, context) {\n      var strIndex = \"\" + rhs;\n\n      if (lhs instanceof Map) {\n        if (lhs.has(strIndex)) {\n          return lhs.get(strIndex);\n        } else {\n          return undefined;\n        }\n      } else if (lhs instanceof result_1.ResolvedModule) {\n        return lhs.getExport(strIndex);\n      } else if (Array.isArray(lhs)) {\n        if (rhs === 'length') {\n          return lhs.length;\n        } else if (rhs === 'slice') {\n          return new builtin_1.ArraySliceBuiltinFn(lhs);\n        } else if (rhs === 'concat') {\n          return new builtin_1.ArrayConcatBuiltinFn(lhs);\n        }\n\n        if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {\n          return dynamic_1.DynamicValue.fromInvalidExpressionType(node, rhs);\n        }\n\n        return lhs[rhs];\n      } else if (lhs instanceof imports_1.Reference) {\n        var ref = lhs.node;\n\n        if (this.host.isClass(ref)) {\n          var module_1 = owningModule(context, lhs.bestGuessOwningModule);\n          var value = undefined;\n          var member = this.host.getMembersOfClass(ref).find(function (member) {\n            return member.isStatic && member.name === strIndex;\n          });\n\n          if (member !== undefined) {\n            if (member.value !== null) {\n              value = this.visitExpression(member.value, context);\n            } else if (member.implementation !== null) {\n              value = new imports_1.Reference(member.implementation, module_1);\n            } else if (member.node) {\n              value = new imports_1.Reference(member.node, module_1);\n            }\n          }\n\n          return value;\n        } else if (typescript_1.isDeclaration(ref)) {\n          return dynamic_1.DynamicValue.fromDynamicInput(node, dynamic_1.DynamicValue.fromExternalReference(ref, lhs));\n        }\n      } else if (lhs instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, lhs);\n      }\n\n      return dynamic_1.DynamicValue.fromUnknown(node);\n    };\n\n    StaticInterpreter.prototype.visitCallExpression = function (node, context) {\n      var lhs = this.visitExpression(node.expression, context);\n\n      if (lhs instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, lhs);\n      } // If the call refers to a builtin function, attempt to evaluate the function.\n\n\n      if (lhs instanceof result_1.KnownFn) {\n        return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));\n      }\n\n      if (!(lhs instanceof imports_1.Reference)) {\n        return dynamic_1.DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n      }\n\n      var fn = this.host.getDefinitionOfFunction(lhs.node);\n\n      if (fn === null) {\n        return dynamic_1.DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n      }\n\n      if (!isFunctionOrMethodReference(lhs)) {\n        return dynamic_1.DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n      } // If the function is foreign (declared through a d.ts file), attempt to resolve it with the\n      // foreignFunctionResolver, if one is specified.\n\n\n      if (fn.body === null) {\n        var expr = null;\n\n        if (context.foreignFunctionResolver) {\n          expr = context.foreignFunctionResolver(lhs, node.arguments);\n        }\n\n        if (expr === null) {\n          return dynamic_1.DynamicValue.fromDynamicInput(node, dynamic_1.DynamicValue.fromExternalReference(node.expression, lhs));\n        } // If the function is declared in a different file, resolve the foreign function expression\n        // using the absolute module name of that file (if any).\n\n\n        if (lhs.bestGuessOwningModule !== null) {\n          context = tslib_1.__assign(tslib_1.__assign({}, context), {\n            absoluteModuleName: lhs.bestGuessOwningModule.specifier,\n            resolutionContext: node.getSourceFile().fileName\n          });\n        }\n\n        return this.visitFfrExpression(expr, context);\n      }\n\n      var res = this.visitFunctionBody(node, fn, context); // If the result of attempting to resolve the function body was a DynamicValue, attempt to use\n      // the foreignFunctionResolver if one is present. This could still potentially yield a usable\n      // value.\n\n      if (res instanceof dynamic_1.DynamicValue && context.foreignFunctionResolver !== undefined) {\n        var ffrExpr = context.foreignFunctionResolver(lhs, node.arguments);\n\n        if (ffrExpr !== null) {\n          // The foreign function resolver was able to extract an expression from this function. See\n          // if that expression leads to a non-dynamic result.\n          var ffrRes = this.visitFfrExpression(ffrExpr, context);\n\n          if (!(ffrRes instanceof dynamic_1.DynamicValue)) {\n            // FFR yielded an actual result that's not dynamic, so use that instead of the original\n            // resolution.\n            res = ffrRes;\n          }\n        }\n      }\n\n      return res;\n    };\n    /**\n     * Visit an expression which was extracted from a foreign-function resolver.\n     *\n     * This will process the result and ensure it's correct for FFR-resolved values, including marking\n     * `Reference`s as synthetic.\n     */\n\n\n    StaticInterpreter.prototype.visitFfrExpression = function (expr, context) {\n      var res = this.visitExpression(expr, context);\n\n      if (res instanceof imports_1.Reference) {\n        // This Reference was created synthetically, via a foreign function resolver. The real\n        // runtime value of the function expression may be different than the foreign function\n        // resolved value, so mark the Reference as synthetic to avoid it being misinterpreted.\n        res.synthetic = true;\n      }\n\n      return res;\n    };\n\n    StaticInterpreter.prototype.visitFunctionBody = function (node, fn, context) {\n      var _this = this;\n\n      if (fn.body === null) {\n        return dynamic_1.DynamicValue.fromUnknown(node);\n      } else if (fn.body.length !== 1 || !ts.isReturnStatement(fn.body[0])) {\n        return dynamic_1.DynamicValue.fromComplexFunctionCall(node, fn);\n      }\n\n      var ret = fn.body[0];\n      var args = this.evaluateFunctionArguments(node, context);\n      var newScope = new Map();\n\n      var calleeContext = tslib_1.__assign(tslib_1.__assign({}, context), {\n        scope: newScope\n      });\n\n      fn.parameters.forEach(function (param, index) {\n        var arg = args[index];\n\n        if (param.node.dotDotDotToken !== undefined) {\n          arg = args.slice(index);\n        }\n\n        if (arg === undefined && param.initializer !== null) {\n          arg = _this.visitExpression(param.initializer, calleeContext);\n        }\n\n        newScope.set(param.node, arg);\n      });\n      return ret.expression !== undefined ? this.visitExpression(ret.expression, calleeContext) : undefined;\n    };\n\n    StaticInterpreter.prototype.visitConditionalExpression = function (node, context) {\n      var condition = this.visitExpression(node.condition, context);\n\n      if (condition instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, condition);\n      }\n\n      if (condition) {\n        return this.visitExpression(node.whenTrue, context);\n      } else {\n        return this.visitExpression(node.whenFalse, context);\n      }\n    };\n\n    StaticInterpreter.prototype.visitPrefixUnaryExpression = function (node, context) {\n      var operatorKind = node.operator;\n\n      if (!UNARY_OPERATORS.has(operatorKind)) {\n        return dynamic_1.DynamicValue.fromUnsupportedSyntax(node);\n      }\n\n      var op = UNARY_OPERATORS.get(operatorKind);\n      var value = this.visitExpression(node.operand, context);\n\n      if (value instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, value);\n      } else {\n        return op(value);\n      }\n    };\n\n    StaticInterpreter.prototype.visitBinaryExpression = function (node, context) {\n      var tokenKind = node.operatorToken.kind;\n\n      if (!BINARY_OPERATORS.has(tokenKind)) {\n        return dynamic_1.DynamicValue.fromUnsupportedSyntax(node);\n      }\n\n      var opRecord = BINARY_OPERATORS.get(tokenKind);\n      var lhs, rhs;\n\n      if (opRecord.literal) {\n        lhs = literal(this.visitExpression(node.left, context), function (value) {\n          return dynamic_1.DynamicValue.fromInvalidExpressionType(node.left, value);\n        });\n        rhs = literal(this.visitExpression(node.right, context), function (value) {\n          return dynamic_1.DynamicValue.fromInvalidExpressionType(node.right, value);\n        });\n      } else {\n        lhs = this.visitExpression(node.left, context);\n        rhs = this.visitExpression(node.right, context);\n      }\n\n      if (lhs instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, lhs);\n      } else if (rhs instanceof dynamic_1.DynamicValue) {\n        return dynamic_1.DynamicValue.fromDynamicInput(node, rhs);\n      } else {\n        return opRecord.op(lhs, rhs);\n      }\n    };\n\n    StaticInterpreter.prototype.visitParenthesizedExpression = function (node, context) {\n      return this.visitExpression(node.expression, context);\n    };\n\n    StaticInterpreter.prototype.evaluateFunctionArguments = function (node, context) {\n      var e_1, _a;\n\n      var args = [];\n\n      try {\n        for (var _b = tslib_1.__values(node.arguments), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var arg = _c.value;\n\n          if (ts.isSpreadElement(arg)) {\n            args.push.apply(args, tslib_1.__spread(this.visitSpreadElement(arg, context)));\n          } else {\n            args.push(this.visitExpression(arg, context));\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return args;\n    };\n\n    StaticInterpreter.prototype.visitSpreadElement = function (node, context) {\n      var spread = this.visitExpression(node.expression, context);\n\n      if (spread instanceof dynamic_1.DynamicValue) {\n        return [dynamic_1.DynamicValue.fromDynamicInput(node, spread)];\n      } else if (!Array.isArray(spread)) {\n        return [dynamic_1.DynamicValue.fromInvalidExpressionType(node, spread)];\n      } else {\n        return spread;\n      }\n    };\n\n    StaticInterpreter.prototype.visitBindingElement = function (node, context) {\n      var e_2, _a;\n\n      var path = [];\n      var closestDeclaration = node;\n\n      while (ts.isBindingElement(closestDeclaration) || ts.isArrayBindingPattern(closestDeclaration) || ts.isObjectBindingPattern(closestDeclaration)) {\n        if (ts.isBindingElement(closestDeclaration)) {\n          path.unshift(closestDeclaration);\n        }\n\n        closestDeclaration = closestDeclaration.parent;\n      }\n\n      if (!ts.isVariableDeclaration(closestDeclaration) || closestDeclaration.initializer === undefined) {\n        return dynamic_1.DynamicValue.fromUnknown(node);\n      }\n\n      var value = this.visit(closestDeclaration.initializer, context);\n\n      try {\n        for (var path_1 = tslib_1.__values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {\n          var element = path_1_1.value;\n          var key = void 0;\n\n          if (ts.isArrayBindingPattern(element.parent)) {\n            key = element.parent.elements.indexOf(element);\n          } else {\n            var name_2 = element.propertyName || element.name;\n\n            if (ts.isIdentifier(name_2)) {\n              key = name_2.text;\n            } else {\n              return dynamic_1.DynamicValue.fromUnknown(element);\n            }\n          }\n\n          value = this.accessHelper(element, value, key, context);\n\n          if (value instanceof dynamic_1.DynamicValue) {\n            return value;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return value;\n    };\n\n    StaticInterpreter.prototype.stringNameFromPropertyName = function (node, context) {\n      if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n        return node.text;\n      } else if (ts.isComputedPropertyName(node)) {\n        var literal_1 = this.visitExpression(node.expression, context);\n        return typeof literal_1 === 'string' ? literal_1 : undefined;\n      } else {\n        return undefined;\n      }\n    };\n\n    StaticInterpreter.prototype.getResolvedEnum = function (node, enumMembers, context) {\n      var _this = this;\n\n      var enumRef = this.getReference(node, context);\n      var map = new Map();\n      enumMembers.forEach(function (member) {\n        var name = _this.stringNameFromPropertyName(member.name, context);\n\n        if (name !== undefined) {\n          var resolved = _this.visit(member.initializer, context);\n\n          map.set(name, new result_1.EnumValue(enumRef, name, resolved));\n        }\n      });\n      return map;\n    };\n\n    StaticInterpreter.prototype.getReference = function (node, context) {\n      return new imports_1.Reference(node, owningModule(context));\n    };\n\n    return StaticInterpreter;\n  }();\n\n  exports.StaticInterpreter = StaticInterpreter;\n\n  function isFunctionOrMethodReference(ref) {\n    return ts.isFunctionDeclaration(ref.node) || ts.isMethodDeclaration(ref.node) || ts.isFunctionExpression(ref.node);\n  }\n\n  function literal(value, reject) {\n    if (value instanceof result_1.EnumValue) {\n      value = value.resolved;\n    }\n\n    if (value instanceof dynamic_1.DynamicValue || value === null || value === undefined || typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n      return value;\n    }\n\n    return reject(value);\n  }\n\n  function isVariableDeclarationDeclared(node) {\n    if (node.parent === undefined || !ts.isVariableDeclarationList(node.parent)) {\n      return false;\n    }\n\n    var declList = node.parent;\n\n    if (declList.parent === undefined || !ts.isVariableStatement(declList.parent)) {\n      return false;\n    }\n\n    var varStmt = declList.parent;\n    return varStmt.modifiers !== undefined && varStmt.modifiers.some(function (mod) {\n      return mod.kind === ts.SyntaxKind.DeclareKeyword;\n    });\n  }\n\n  var EMPTY = {};\n\n  function joinModuleContext(existing, node, decl) {\n    if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {\n      return {\n        absoluteModuleName: decl.viaModule,\n        resolutionContext: node.getSourceFile().fileName\n      };\n    } else {\n      return EMPTY;\n    }\n  }\n\n  function owningModule(context, override) {\n    if (override === void 0) {\n      override = null;\n    }\n\n    var specifier = context.absoluteModuleName;\n\n    if (override !== null) {\n      specifier = override.specifier;\n    }\n\n    if (specifier !== null) {\n      return {\n        specifier: specifier,\n        resolutionContext: context.resolutionContext\n      };\n    } else {\n      return null;\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/interpreter.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AAGA,MAAA,YAAA,GAAA,OAAA,CAAA,4CAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;;AAEA,MAAA,SAAA,GAAA,OAAA,CAAA,+DAAA,CAAA;;AACA,MAAA,SAAA,GAAA,OAAA,CAAA,+DAAA,CAAA;;AAEA,MAAA,mBAAA,GAAA,OAAA,CAAA,yEAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,8DAAA,CAAA;;AAeA,WAAS,eAAT,CAAyB,EAAzB,EAAoD;AAClD,WAAO;AAAC,MAAA,EAAE,EAAA,EAAH;AAAK,MAAA,OAAO,EAAE;AAAd,KAAP;AACD;;AAED,WAAS,iBAAT,CAA2B,EAA3B,EAAsD;AACpD,WAAO;AAAC,MAAA,EAAE,EAAA,EAAH;AAAK,MAAA,OAAO,EAAE;AAAd,KAAP;AACD;;AAED,MAAM,gBAAgB,GAAG,IAAI,GAAJ,CAA0C,CACjE,CAAC,EAAE,CAAC,UAAH,CAAc,SAAf,EAA0B,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAAzC,CADiE,EAEjE,CAAC,EAAE,CAAC,UAAH,CAAc,UAAf,EAA2B,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAA1C,CAFiE,EAGjE,CAAC,EAAE,CAAC,UAAH,CAAc,aAAf,EAA8B,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAA7C,CAHiE,EAIjE,CAAC,EAAE,CAAC,UAAH,CAAc,UAAf,EAA2B,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAA1C,CAJiE,EAKjE,CAAC,EAAE,CAAC,UAAH,CAAc,YAAf,EAA6B,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAA5C,CALiE,EAMjE,CAAC,EAAE,CAAC,UAAH,CAAc,cAAf,EAA+B,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAA9C,CANiE,EAOjE,CAAC,EAAE,CAAC,UAAH,CAAc,QAAf,EAAyB,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAAxC,CAPiE,EAQjE,CAAC,EAAE,CAAC,UAAH,CAAc,UAAf,EAA2B,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAA1C,CARiE,EASjE,CAAC,EAAE,CAAC,UAAH,CAAc,aAAf,EAA8B,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAA7C,CATiE,EAUjE,CAAC,EAAE,CAAC,UAAH,CAAc,mBAAf,EAAoC,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,IAAD,CAAA;AAAM,GAAjB,CAAnD,CAViE,EAWjE,CAAC,EAAE,CAAC,UAAH,CAAc,gBAAf,EAAiC,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,GAAD,CAAA;AAAK,GAAhB,CAAhD,CAXiE,EAYjE,CAAC,EAAE,CAAC,UAAH,CAAc,sBAAf,EAAuC,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,IAAD,CAAA;AAAM,GAAjB,CAAtD,CAZiE,EAajE,CAAC,EAAE,CAAC,UAAH,CAAc,iBAAf,EAAkC,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,IAAD,CAAA;AAAM,GAAjB,CAAjD,CAbiE,EAcjE,CAAC,EAAE,CAAC,UAAH,CAAc,uBAAf,EAAwC,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,KAAD,CAAA;AAAO,GAAlB,CAAvD,CAdiE,EAejE,CAAC,EAAE,CAAC,UAAH,CAAc,sBAAf,EAAuC,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,IAAD,CAAA;AAAM,GAAjB,CAAtD,CAfiE,EAgBjE,CAAC,EAAE,CAAC,UAAH,CAAc,4BAAf,EAA6C,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,KAAD,CAAA;AAAO,GAAlB,CAA5D,CAhBiE,EAiBjE,CAAC,EAAE,CAAC,UAAH,CAAc,qBAAf,EAAsC,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,IAAD,CAAA;AAAM,GAAjB,CAArD,CAjBiE,EAkBjE,CAAC,EAAE,CAAC,UAAH,CAAc,2BAAf,EAA4C,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,IAAD,CAAA;AAAM,GAAjB,CAA3D,CAlBiE,EAmBjE,CAAC,EAAE,CAAC,UAAH,CAAc,sCAAf,EAAuD,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,KAAD,CAAA;AAAO,GAAlB,CAAtE,CAnBiE,EAoBjE,CAAC,EAAE,CAAC,UAAH,CAAc,qBAAf,EAAsC,eAAe,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,IAAI,CAAC,GAAL,CAAS,CAAT,EAAA,CAAA,CAAA;AAAc,GAAzB,CAArD,CApBiE,EAqBjE,CAAC,EAAE,CAAC,UAAH,CAAc,uBAAf,EAAwC,iBAAiB,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,IAAD,CAAA;AAAM,GAAjB,CAAzD,CArBiE,EAsBjE,CAAC,EAAE,CAAC,UAAH,CAAc,WAAf,EAA4B,iBAAiB,CAAC,UAAC,CAAD,EAAI,CAAJ,EAAK;AAAK,WAAA,CAAC,IAAD,CAAA;AAAM,GAAjB,CAA7C,CAtBiE,CAA1C,CAAzB;AAyBA,MAAM,eAAe,GAAG,IAAI,GAAJ,CAAwC,CAC9D,CAAC,EAAE,CAAC,UAAH,CAAc,UAAf,EAA2B,UAAA,CAAA,EAAC;AAAI,WAAA,CAAA,CAAA;AAAE,GAAlC,CAD8D,EACzB,CAAC,EAAE,CAAC,UAAH,CAAc,UAAf,EAA2B,UAAA,CAAA,EAAC;AAAI,WAAA,CAAA,CAAA;AAAE,GAAlC,CADyB,EAE9D,CAAC,EAAE,CAAC,UAAH,CAAc,SAAf,EAA0B,UAAA,CAAA,EAAC;AAAI,WAAA,CAAA,CAAA;AAAE,GAAjC,CAF8D,EAE1B,CAAC,EAAE,CAAC,UAAH,CAAc,gBAAf,EAAiC,UAAA,CAAA,EAAC;AAAI,WAAA,CAAA,CAAA;AAAE,GAAxC,CAF0B,CAAxC,CAAxB;;AAqBA,MAAA,iBAAA;AAAA;AAAA,cAAA;AACE,aAAA,iBAAA,CACY,IADZ,EAC0C,OAD1C,EAEY,iBAFZ,EAEqD;AADzC,WAAA,IAAA,GAAA,IAAA;AAA8B,WAAA,OAAA,GAAA,OAAA;AAC9B,WAAA,iBAAA,GAAA,iBAAA;AAA6C;;AAEzD,IAAA,iBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,IAAN,EAA2B,OAA3B,EAA2C;AACzC,aAAO,KAAK,eAAL,CAAqB,IAArB,EAA2B,OAA3B,CAAP;AACD,KAFD;;AAIQ,IAAA,iBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,IAAxB,EAA6C,OAA7C,EAA6D;AAC3D,UAAI,MAAJ;;AACA,UAAI,IAAI,CAAC,IAAL,KAAc,EAAE,CAAC,UAAH,CAAc,WAAhC,EAA6C;AAC3C,eAAO,IAAP;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,IAAL,KAAc,EAAE,CAAC,UAAH,CAAc,YAAhC,EAA8C;AACnD,eAAO,KAAP;AACD,OAFM,MAEA,IAAI,IAAI,CAAC,IAAL,KAAc,EAAE,CAAC,UAAH,CAAc,WAAhC,EAA6C;AAClD,eAAO,IAAP;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,eAAH,CAAmB,IAAnB,CAAJ,EAA8B;AACnC,eAAO,IAAI,CAAC,IAAZ;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,+BAAH,CAAmC,IAAnC,CAAJ,EAA8C;AACnD,eAAO,IAAI,CAAC,IAAZ;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,oBAAH,CAAwB,IAAxB,CAAJ,EAAmC;AACxC,QAAA,MAAM,GAAG,KAAK,uBAAL,CAA6B,IAA7B,EAAmC,OAAnC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,gBAAH,CAAoB,IAApB,CAAJ,EAA+B;AACpC,eAAO,UAAU,CAAC,IAAI,CAAC,IAAN,CAAjB;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAJ,EAAwC;AAC7C,QAAA,MAAM,GAAG,KAAK,4BAAL,CAAkC,IAAlC,EAAwC,OAAxC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,YAAH,CAAgB,IAAhB,CAAJ,EAA2B;AAChC,QAAA,MAAM,GAAG,KAAK,eAAL,CAAqB,IAArB,EAA2B,OAA3B,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,0BAAH,CAA8B,IAA9B,CAAJ,EAAyC;AAC9C,QAAA,MAAM,GAAG,KAAK,6BAAL,CAAmC,IAAnC,EAAyC,OAAzC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,gBAAH,CAAoB,IAApB,CAAJ,EAA+B;AACpC,QAAA,MAAM,GAAG,KAAK,mBAAL,CAAyB,IAAzB,EAA+B,OAA/B,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,uBAAH,CAA2B,IAA3B,CAAJ,EAAsC;AAC3C,QAAA,MAAM,GAAG,KAAK,0BAAL,CAAgC,IAAhC,EAAsC,OAAtC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,uBAAH,CAA2B,IAA3B,CAAJ,EAAsC;AAC3C,QAAA,MAAM,GAAG,KAAK,0BAAL,CAAgC,IAAhC,EAAsC,OAAtC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,kBAAH,CAAsB,IAAtB,CAAJ,EAAiC;AACtC,QAAA,MAAM,GAAG,KAAK,qBAAL,CAA2B,IAA3B,EAAiC,OAAjC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,wBAAH,CAA4B,IAA5B,CAAJ,EAAuC;AAC5C,QAAA,MAAM,GAAG,KAAK,2BAAL,CAAiC,IAAjC,EAAuC,OAAvC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAJ,EAAwC;AAC7C,QAAA,MAAM,GAAG,KAAK,4BAAL,CAAkC,IAAlC,EAAwC,OAAxC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAJ,EAAwC;AAC7C,QAAA,MAAM,GAAG,KAAK,4BAAL,CAAkC,IAAlC,EAAwC,OAAxC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,cAAH,CAAkB,IAAlB,CAAJ,EAA6B;AAClC,QAAA,MAAM,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAT;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,mBAAH,CAAuB,IAAvB,CAAJ,EAAkC;AACvC,QAAA,MAAM,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAT;AACD,OAFM,MAEA,IAAI,KAAK,IAAL,CAAU,OAAV,CAAkB,IAAlB,CAAJ,EAA6B;AAClC,QAAA,MAAM,GAAG,KAAK,gBAAL,CAAsB,IAAtB,EAA4B,OAA5B,CAAT;AACD,OAFM,MAEA;AACL,eAAO,SAAA,CAAA,YAAA,CAAa,qBAAb,CAAmC,IAAnC,CAAP;AACD;;AACD,UAAI,MAAM,YAAY,SAAA,CAAA,YAAlB,IAAkC,MAAM,CAAC,IAAP,KAAgB,IAAtD,EAA4D;AAC1D,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,MAApC,CAAP;AACD;;AACD,aAAO,MAAP;AACD,KAjDO;;AAmDA,IAAA,iBAAA,CAAA,SAAA,CAAA,2BAAA,GAAR,UAAoC,IAApC,EAAqE,OAArE,EAAqF;AAEnF,UAAM,KAAK,GAAuB,EAAlC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,QAAL,CAAc,MAAlC,EAA0C,CAAC,EAA3C,EAA+C;AAC7C,YAAM,OAAO,GAAG,IAAI,CAAC,QAAL,CAAc,CAAd,CAAhB;;AACA,YAAI,EAAE,CAAC,eAAH,CAAmB,OAAnB,CAAJ,EAAiC;AAC/B,UAAA,KAAK,CAAC,IAAN,CAAU,KAAV,CAAA,KAAA,EAAK,OAAA,CAAA,QAAA,CAAS,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,OAAjC,CAAT,CAAL;AACD,SAFD,MAEO;AACL,UAAA,KAAK,CAAC,IAAN,CAAW,KAAK,eAAL,CAAqB,OAArB,EAA8B,OAA9B,CAAX;AACD;AACF;;AACD,aAAO,KAAP;AACD,KAZO;;AAcE,IAAA,iBAAA,CAAA,SAAA,CAAA,4BAAA,GAAV,UAAuC,IAAvC,EAAyE,OAAzE,EAAyF;AAEvF,UAAM,GAAG,GAAqB,IAAI,GAAJ,EAA9B;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,UAAL,CAAgB,MAApC,EAA4C,CAAC,EAA7C,EAAiD;AAC/C,YAAM,QAAQ,GAAG,IAAI,CAAC,UAAL,CAAgB,CAAhB,CAAjB;;AACA,YAAI,EAAE,CAAC,oBAAH,CAAwB,QAAxB,CAAJ,EAAuC;AACrC,cAAM,MAAI,GAAG,KAAK,0BAAL,CAAgC,QAAQ,CAAC,IAAzC,EAA+C,OAA/C,CAAb,CADqC,CAErC;;AACA,cAAI,MAAI,KAAK,SAAb,EAAwB;AACtB,mBAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,SAAA,CAAA,YAAA,CAAa,iBAAb,CAA+B,QAAQ,CAAC,IAAxC,CAApC,CAAP;AACD;;AACD,UAAA,GAAG,CAAC,GAAJ,CAAQ,MAAR,EAAc,KAAK,eAAL,CAAqB,QAAQ,CAAC,WAA9B,EAA2C,OAA3C,CAAd;AACD,SAPD,MAOO,IAAI,EAAE,CAAC,6BAAH,CAAiC,QAAjC,CAAJ,EAAgD;AACrD,cAAM,MAAM,GAAG,KAAK,OAAL,CAAa,iCAAb,CAA+C,QAA/C,CAAf;;AACA,cAAI,MAAM,KAAK,SAAX,IAAwB,MAAM,CAAC,gBAAP,KAA4B,SAAxD,EAAmE;AACjE,YAAA,GAAG,CAAC,GAAJ,CAAQ,QAAQ,CAAC,IAAT,CAAc,IAAtB,EAA4B,SAAA,CAAA,YAAA,CAAa,WAAb,CAAyB,QAAzB,CAA5B;AACD,WAFD,MAEO;AACL,YAAA,GAAG,CAAC,GAAJ,CAAQ,QAAQ,CAAC,IAAT,CAAc,IAAtB,EAA4B,KAAK,gBAAL,CAAsB,MAAM,CAAC,gBAA7B,EAA+C,OAA/C,CAA5B;AACD;AACF,SAPM,MAOA,IAAI,EAAE,CAAC,kBAAH,CAAsB,QAAtB,CAAJ,EAAqC;AAC1C,cAAM,MAAM,GAAG,KAAK,eAAL,CAAqB,QAAQ,CAAC,UAA9B,EAA0C,OAA1C,CAAf;;AACA,cAAI,MAAM,YAAY,SAAA,CAAA,YAAtB,EAAoC;AAClC,mBAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,MAApC,CAAP;AACD,WAFD,MAEO,IAAI,MAAM,YAAY,GAAtB,EAA2B;AAChC,YAAA,MAAM,CAAC,OAAP,CAAe,UAAC,KAAD,EAAQ,GAAR,EAAW;AAAK,qBAAA,GAAG,CAAC,GAAJ,CAAQ,GAAR,EAAA,KAAA,CAAA;AAAmB,aAAlD;AACD,WAFM,MAEA,IAAI,MAAM,YAAY,QAAA,CAAA,cAAtB,EAAsC;AAC3C,YAAA,MAAM,CAAC,UAAP,GAAoB,OAApB,CAA4B,UAAC,KAAD,EAAQ,GAAR,EAAW;AAAK,qBAAA,GAAG,CAAC,GAAJ,CAAQ,GAAR,EAAA,KAAA,CAAA;AAAmB,aAA/D;AACD,WAFM,MAEA;AACL,mBAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CACH,IADG,EACG,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,QAAvC,EAAiD,MAAjD,CADH,CAAP;AAED;AACF,SAZM,MAYA;AACL,iBAAO,SAAA,CAAA,YAAA,CAAa,WAAb,CAAyB,IAAzB,CAAP;AACD;AACF;;AACD,aAAO,GAAP;AACD,KApCS;;AAsCF,IAAA,iBAAA,CAAA,SAAA,CAAA,uBAAA,GAAR,UAAgC,IAAhC,EAA6D,OAA7D,EAA6E;AAC3E,UAAM,MAAM,GAAa,CAAC,IAAI,CAAC,IAAL,CAAU,IAAX,CAAzB;;qCACS,C,EAAC;AACR,YAAM,IAAI,GAAG,IAAI,CAAC,aAAL,CAAmB,CAAnB,CAAb;AACA,YAAM,KAAK,GAAG,OAAO,CACjB,MAAA,CAAK,KAAL,CAAW,IAAI,CAAC,UAAhB,EAA4B,OAA5B,CADiB,EAEjB,YAAA;AAAM,iBAAA,SAAA,CAAA,YAAA,CAAa,iBAAb,CAA+B,IAAI,CAAnC,UAAA,CAAA;AAA+C,SAFpC,CAArB;;AAGA,YAAI,KAAK,YAAY,SAAA,CAAA,YAArB,EAAmC;;mBAC1B,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,KAApC;;AACR;;AACD,QAAA,MAAM,CAAC,IAAP,CAAY,KAAG,KAAf,EAAwB,IAAI,CAAC,OAAL,CAAa,IAArC;;;;;AARF,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,aAAL,CAAmB,MAAvC,EAA+C,CAAC,EAAhD,EAAkD;8BAAzC,C;;;AASR;;AACD,aAAO,MAAM,CAAC,IAAP,CAAY,EAAZ,CAAP;AACD,KAbO;;AAeA,IAAA,iBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,IAAxB,EAA6C,OAA7C,EAA6D;AAC3D,UAAM,IAAI,GAAG,KAAK,IAAL,CAAU,0BAAV,CAAqC,IAArC,CAAb;;AACA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,YAAI,IAAI,CAAC,mBAAL,KAA6B,EAAE,CAAC,UAAH,CAAc,gBAA/C,EAAiE;AAC/D,iBAAO,SAAP;AACD,SAFD,MAEO;AACL;AACA,cAAI,KAAK,iBAAL,KAA2B,IAA3B,IAAmC,KAAK,IAAL,CAAU,qBAAV,CAAgC,IAAhC,MAA0C,IAAjF,EAAuF;AACrF;AACA;AACA;AACA;AACA;AACA,iBAAK,iBAAL,CAAuB,+BAAvB,CAAuD,OAAO,CAAC,eAA/D;AACD;;AACD,iBAAO,SAAA,CAAA,YAAA,CAAa,qBAAb,CAAmC,IAAnC,CAAP;AACD;AACF;;AACD,UAAI,IAAI,CAAC,KAAL,KAAe,IAAnB,EAAyB;AACvB,eAAO,mBAAA,CAAA,uBAAA,CAAwB,IAAI,CAAC,KAA7B,CAAP;AACD,OAFD,MAEO,IACH,YAAA,CAAA,qBAAA,CAAsB,IAAtB,KAA+B,IAAI,CAAC,QAAL,KAAkB,IAAjD,IACA,IAAI,CAAC,QAAL,CAAc,IAAd,KAAkB;AAAA;AAFf,QAE4D;AACjE,iBAAO,KAAK,eAAL,CAAqB,IAAI,CAAC,IAA1B,EAAgC,IAAI,CAAC,QAAL,CAAc,WAA9C,EAA2D,OAA3D,CAAP;AACD;;AACD,UAAM,WAAW,GAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAAO,OAAP,CAAA,EAAmB,iBAAiB,CAAC,OAAD,EAAU,IAAV,EAAgB,IAAhB,CAApC,CAAjB;;AACA,UAAM,MAAM,GAAG,KAAK,yBAAL,CAA+B,IAA/B,EAAqC,WAArC,CAAf;;AACA,UAAI,MAAM,YAAY,SAAA,CAAA,SAAtB,EAAiC;AAC/B;AACA;AACA;AACA,YAAI,CAAC,MAAM,CAAC,SAAZ,EAAuB;AACrB,UAAA,MAAM,CAAC,aAAP,CAAqB,IAArB;AACD;AACF,OAPD,MAOO,IAAI,MAAM,YAAY,SAAA,CAAA,YAAtB,EAAoC;AACzC,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,MAApC,CAAP;AACD;;AACD,aAAO,MAAP;AACD,KAtCO;;AAwCA,IAAA,iBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,IAAzB,EAAgD,OAAhD,EAAgE;AAC9D,UAAI,KAAK,iBAAL,KAA2B,IAA/B,EAAqC;AACnC,aAAK,iBAAL,CAAuB,aAAvB,CAAqC,OAAO,CAAC,eAA7C,EAA8D,IAAI,CAAC,aAAL,EAA9D;AACD;;AACD,UAAI,KAAK,IAAL,CAAU,OAAV,CAAkB,IAAlB,CAAJ,EAA6B;AAC3B,eAAO,KAAK,YAAL,CAAkB,IAAlB,EAAwB,OAAxB,CAAP;AACD,OAFD,MAEO,IAAI,EAAE,CAAC,qBAAH,CAAyB,IAAzB,CAAJ,EAAoC;AACzC,eAAO,KAAK,wBAAL,CAA8B,IAA9B,EAAoC,OAApC,CAAP;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,WAAH,CAAe,IAAf,KAAwB,OAAO,CAAC,KAAR,CAAc,GAAd,CAAkB,IAAlB,CAA5B,EAAqD;AAC1D,eAAO,OAAO,CAAC,KAAR,CAAc,GAAd,CAAkB,IAAlB,CAAP;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,kBAAH,CAAsB,IAAtB,CAAJ,EAAiC;AACtC,eAAO,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAP;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,iBAAH,CAAqB,IAArB,CAAJ,EAAgC;AACrC,eAAO,KAAK,oBAAL,CAA0B,IAA1B,EAAgC,OAAhC,CAAP;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,YAAH,CAAgB,IAAhB,CAAJ,EAA2B;AAChC,eAAO,KAAK,eAAL,CAAqB,IAArB,EAA2B,OAA3B,CAAP;AACD,OAFM,MAEA,IAAI,EAAE,CAAC,gBAAH,CAAoB,IAApB,CAAJ,EAA+B;AACpC,eAAO,KAAK,mBAAL,CAAyB,IAAzB,EAA+B,OAA/B,CAAP;AACD,OAFM,MAEA;AACL,eAAO,KAAK,YAAL,CAAkB,IAAlB,EAAwB,OAAxB,CAAP;AACD;AACF,KArBO;;AAuBA,IAAA,iBAAA,CAAA,SAAA,CAAA,wBAAA,GAAR,UAAiC,IAAjC,EAA+D,OAA/D,EAA+E;AAC7E,UAAM,KAAK,GAAG,KAAK,IAAL,CAAU,gBAAV,CAA2B,IAA3B,CAAd;;AACA,UAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,eAAO,KAAK,eAAL,CAAqB,KAArB,EAA4B,OAA5B,CAAP;AACD,OAFD,MAEO,IAAI,6BAA6B,CAAC,IAAD,CAAjC,EAAyC;AAC9C,eAAO,KAAK,YAAL,CAAkB,IAAlB,EAAwB,OAAxB,CAAP;AACD,OAFM,MAEA;AACL,eAAO,SAAP;AACD;AACF,KATO;;AAWA,IAAA,iBAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UAA6B,IAA7B,EAAuD,OAAvD,EAAuE;AAAvE,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,OAAO,GAAG,KAAK,YAAL,CAAkB,IAAlB,EAAwB,OAAxB,CAAhB;AACA,UAAM,GAAG,GAAG,IAAI,GAAJ,EAAZ;AACA,MAAA,IAAI,CAAC,OAAL,CAAa,OAAb,CAAqB,UAAA,MAAA,EAAM;AACzB,YAAM,IAAI,GAAG,KAAI,CAAC,0BAAL,CAAgC,MAAM,CAAC,IAAvC,EAA6C,OAA7C,CAAb;;AACA,YAAI,IAAI,KAAK,SAAb,EAAwB;AACtB,cAAM,QAAQ,GAAG,MAAM,CAAC,WAAP,IAAsB,KAAI,CAAC,KAAL,CAAW,MAAM,CAAC,WAAlB,EAA+B,OAA/B,CAAvC;;AACA,UAAA,GAAG,CAAC,GAAJ,CAAQ,IAAR,EAAc,IAAI,QAAA,CAAA,SAAJ,CAAc,OAAd,EAAuB,IAAvB,EAA6B,QAA7B,CAAd;AACD;AACF,OAND;AAOA,aAAO,GAAP;AACD,KAXO;;AAaA,IAAA,iBAAA,CAAA,SAAA,CAAA,4BAAA,GAAR,UAAqC,IAArC,EAAuE,OAAvE,EAAuF;AAErF,UAAM,GAAG,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAZ;;AACA,UAAI,GAAG,YAAY,SAAA,CAAA,YAAnB,EAAiC;AAC/B,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,GAApC,CAAP;AACD;;AACD,UAAM,GAAG,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,kBAA1B,EAA8C,OAA9C,CAAZ;;AACA,UAAI,GAAG,YAAY,SAAA,CAAA,YAAnB,EAAiC;AAC/B,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,GAApC,CAAP;AACD;;AACD,UAAI,OAAO,GAAP,KAAe,QAAf,IAA2B,OAAO,GAAP,KAAe,QAA9C,EAAwD;AACtD,eAAO,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,IAAvC,EAA6C,GAA7C,CAAP;AACD;;AAED,aAAO,KAAK,YAAL,CAAkB,IAAlB,EAAwB,GAAxB,EAA6B,GAA7B,EAAkC,OAAlC,CAAP;AACD,KAfO;;AAiBA,IAAA,iBAAA,CAAA,SAAA,CAAA,6BAAA,GAAR,UAAsC,IAAtC,EAAyE,OAAzE,EAAyF;AAEvF,UAAM,GAAG,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAZ;AACA,UAAM,GAAG,GAAG,IAAI,CAAC,IAAL,CAAU,IAAtB,CAHuF,CAIvF;;AACA,UAAI,GAAG,YAAY,SAAA,CAAA,YAAnB,EAAiC;AAC/B,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,GAApC,CAAP;AACD;;AACD,aAAO,KAAK,YAAL,CAAkB,IAAlB,EAAwB,GAAxB,EAA6B,GAA7B,EAAkC,OAAlC,CAAP;AACD,KATO;;AAWA,IAAA,iBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,IAAxB,EAA6C,OAA7C,EAA6D;AAA7D,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,YAAY,GAAG,KAAK,IAAL,CAAU,kBAAV,CAA6B,IAA7B,CAArB;;AACA,UAAI,YAAY,KAAK,IAArB,EAA2B;AACzB,eAAO,SAAA,CAAA,YAAA,CAAa,WAAb,CAAyB,IAAzB,CAAP;AACD;;AAED,aAAO,IAAI,QAAA,CAAA,cAAJ,CAAmB,YAAnB,EAAiC,UAAA,IAAA,EAAI;AAC1C,YAAI,IAAI,CAAC,KAAL,KAAe,IAAnB,EAAyB;AACvB,iBAAO,mBAAA,CAAA,uBAAA,CAAwB,IAAI,CAAC,KAA7B,CAAP;AACD;;AAED,YAAM,WAAW,GAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACZ,OADY,CAAA,EAEZ,iBAAiB,CAAC,OAAD,EAAU,IAAV,EAAgB,IAAhB,CAFL,CAAjB,CAL0C,CAU1C;;;AACA,eAAO,KAAI,CAAC,yBAAL,CAA+B,IAA/B,EAAqC,WAArC,CAAP;AACD,OAZM,CAAP;AAaD,KAnBO;;AAqBA,IAAA,iBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,IAAlC,EAAqD,WAArD,EAAyE;AACvE,aAAO,IAAI,CAAC,IAAL,KAAS;AAAA;AAAT,SAAwC,IAAI,CAAC,cAAL,KAAwB,SAAhE,IACC,CAAC,YAAA,CAAA,aAAA,CAAc,IAAI,CAAC,cAAnB,CADF,GAEH;AACA;AACA,WAAK,eAAL,CAAqB,IAAI,CAAC,cAA1B,EAA0C,WAA1C,CAJG,GAKH;AACA,WAAK,gBAAL,CAAsB,IAAI,CAAC,IAA3B,EAAiC,WAAjC,CANJ;AAOD,KARO;;AAUA,IAAA,iBAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAqB,IAArB,EAAoC,GAApC,EAAwD,GAAxD,EAA4E,OAA5E,EAA4F;AAE1F,UAAM,QAAQ,GAAG,KAAG,GAApB;;AACA,UAAI,GAAG,YAAY,GAAnB,EAAwB;AACtB,YAAI,GAAG,CAAC,GAAJ,CAAQ,QAAR,CAAJ,EAAuB;AACrB,iBAAO,GAAG,CAAC,GAAJ,CAAQ,QAAR,CAAP;AACD,SAFD,MAEO;AACL,iBAAO,SAAP;AACD;AACF,OAND,MAMO,IAAI,GAAG,YAAY,QAAA,CAAA,cAAnB,EAAmC;AACxC,eAAO,GAAG,CAAC,SAAJ,CAAc,QAAd,CAAP;AACD,OAFM,MAEA,IAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB;AAC7B,YAAI,GAAG,KAAK,QAAZ,EAAsB;AACpB,iBAAO,GAAG,CAAC,MAAX;AACD,SAFD,MAEO,IAAI,GAAG,KAAK,OAAZ,EAAqB;AAC1B,iBAAO,IAAI,SAAA,CAAA,mBAAJ,CAAwB,GAAxB,CAAP;AACD,SAFM,MAEA,IAAI,GAAG,KAAK,QAAZ,EAAsB;AAC3B,iBAAO,IAAI,SAAA,CAAA,oBAAJ,CAAyB,GAAzB,CAAP;AACD;;AACD,YAAI,OAAO,GAAP,KAAe,QAAf,IAA2B,CAAC,MAAM,CAAC,SAAP,CAAiB,GAAjB,CAAhC,EAAuD;AACrD,iBAAO,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,IAAvC,EAA6C,GAA7C,CAAP;AACD;;AACD,eAAO,GAAG,CAAC,GAAD,CAAV;AACD,OAZM,MAYA,IAAI,GAAG,YAAY,SAAA,CAAA,SAAnB,EAA8B;AACnC,YAAM,GAAG,GAAG,GAAG,CAAC,IAAhB;;AACA,YAAI,KAAK,IAAL,CAAU,OAAV,CAAkB,GAAlB,CAAJ,EAA4B;AAC1B,cAAM,QAAM,GAAG,YAAY,CAAC,OAAD,EAAU,GAAG,CAAC,qBAAd,CAA3B;AACA,cAAI,KAAK,GAAkB,SAA3B;AACA,cAAM,MAAM,GAAG,KAAK,IAAL,CAAU,iBAAV,CAA4B,GAA5B,EAAiC,IAAjC,CACX,UAAA,MAAA,EAAM;AAAI,mBAAA,MAAM,CAAC,QAAP,IAAmB,MAAM,CAAC,IAAP,KAAnB,QAAA;AAA2C,WAD1C,CAAf;;AAEA,cAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,gBAAI,MAAM,CAAC,KAAP,KAAiB,IAArB,EAA2B;AACzB,cAAA,KAAK,GAAG,KAAK,eAAL,CAAqB,MAAM,CAAC,KAA5B,EAAmC,OAAnC,CAAR;AACD,aAFD,MAEO,IAAI,MAAM,CAAC,cAAP,KAA0B,IAA9B,EAAoC;AACzC,cAAA,KAAK,GAAG,IAAI,SAAA,CAAA,SAAJ,CAAc,MAAM,CAAC,cAArB,EAAqC,QAArC,CAAR;AACD,aAFM,MAEA,IAAI,MAAM,CAAC,IAAX,EAAiB;AACtB,cAAA,KAAK,GAAG,IAAI,SAAA,CAAA,SAAJ,CAAc,MAAM,CAAC,IAArB,EAA2B,QAA3B,CAAR;AACD;AACF;;AACD,iBAAO,KAAP;AACD,SAfD,MAeO,IAAI,YAAA,CAAA,aAAA,CAAc,GAAd,CAAJ,EAAwB;AAC7B,iBAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CACH,IADG,EACG,SAAA,CAAA,YAAA,CAAa,qBAAb,CAAmC,GAAnC,EAAwC,GAAxC,CADH,CAAP;AAED;AACF,OArBM,MAqBA,IAAI,GAAG,YAAY,SAAA,CAAA,YAAnB,EAAiC;AACtC,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,GAApC,CAAP;AACD;;AAED,aAAO,SAAA,CAAA,YAAA,CAAa,WAAb,CAAyB,IAAzB,CAAP;AACD,KAjDO;;AAmDA,IAAA,iBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,IAA5B,EAAqD,OAArD,EAAqE;AACnE,UAAM,GAAG,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAZ;;AACA,UAAI,GAAG,YAAY,SAAA,CAAA,YAAnB,EAAiC;AAC/B,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,GAApC,CAAP;AACD,OAJkE,CAMnE;;;AACA,UAAI,GAAG,YAAY,QAAA,CAAA,OAAnB,EAA4B;AAC1B,eAAO,GAAG,CAAC,QAAJ,CAAa,IAAb,EAAmB,KAAK,yBAAL,CAA+B,IAA/B,EAAqC,OAArC,CAAnB,CAAP;AACD;;AAED,UAAI,EAAE,GAAG,YAAY,SAAA,CAAA,SAAjB,CAAJ,EAAiC;AAC/B,eAAO,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,IAAI,CAAC,UAA5C,EAAwD,GAAxD,CAAP;AACD;;AAED,UAAM,EAAE,GAAG,KAAK,IAAL,CAAU,uBAAV,CAAkC,GAAG,CAAC,IAAtC,CAAX;;AACA,UAAI,EAAE,KAAK,IAAX,EAAiB;AACf,eAAO,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,IAAI,CAAC,UAA5C,EAAwD,GAAxD,CAAP;AACD;;AAED,UAAI,CAAC,2BAA2B,CAAC,GAAD,CAAhC,EAAuC;AACrC,eAAO,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,IAAI,CAAC,UAA5C,EAAwD,GAAxD,CAAP;AACD,OAtBkE,CAwBnE;AACA;;;AACA,UAAI,EAAE,CAAC,IAAH,KAAY,IAAhB,EAAsB;AACpB,YAAI,IAAI,GAAuB,IAA/B;;AACA,YAAI,OAAO,CAAC,uBAAZ,EAAqC;AACnC,UAAA,IAAI,GAAG,OAAO,CAAC,uBAAR,CAAgC,GAAhC,EAAqC,IAAI,CAAC,SAA1C,CAAP;AACD;;AACD,YAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,iBAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CACH,IADG,EACG,SAAA,CAAA,YAAA,CAAa,qBAAb,CAAmC,IAAI,CAAC,UAAxC,EAAoD,GAApD,CADH,CAAP;AAED,SARmB,CAUpB;AACA;;;AACA,YAAI,GAAG,CAAC,qBAAJ,KAA8B,IAAlC,EAAwC;AACtC,UAAA,OAAO,GAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACF,OADE,CAAA,EACK;AACV,YAAA,kBAAkB,EAAE,GAAG,CAAC,qBAAJ,CAA0B,SADpC;AAEV,YAAA,iBAAiB,EAAE,IAAI,CAAC,aAAL,GAAqB;AAF9B,WADL,CAAP;AAKD;;AAED,eAAO,KAAK,kBAAL,CAAwB,IAAxB,EAA8B,OAA9B,CAAP;AACD;;AAED,UAAI,GAAG,GAAkB,KAAK,iBAAL,CAAuB,IAAvB,EAA6B,EAA7B,EAAiC,OAAjC,CAAzB,CAjDmE,CAmDnE;AACA;AACA;;AACA,UAAI,GAAG,YAAY,SAAA,CAAA,YAAf,IAA+B,OAAO,CAAC,uBAAR,KAAoC,SAAvE,EAAkF;AAChF,YAAM,OAAO,GAAG,OAAO,CAAC,uBAAR,CAAgC,GAAhC,EAAqC,IAAI,CAAC,SAA1C,CAAhB;;AACA,YAAI,OAAO,KAAK,IAAhB,EAAsB;AACpB;AACA;AACA,cAAM,MAAM,GAAG,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,OAAjC,CAAf;;AACA,cAAI,EAAE,MAAM,YAAY,SAAA,CAAA,YAApB,CAAJ,EAAuC;AACrC;AACA;AACA,YAAA,GAAG,GAAG,MAAN;AACD;AACF;AACF;;AAED,aAAO,GAAP;AACD,KArEO;AAuER;;;;;AAKG;;;AACK,IAAA,iBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,IAA3B,EAAgD,OAAhD,EAAgE;AAC9D,UAAM,GAAG,GAAG,KAAK,eAAL,CAAqB,IAArB,EAA2B,OAA3B,CAAZ;;AACA,UAAI,GAAG,YAAY,SAAA,CAAA,SAAnB,EAA8B;AAC5B;AACA;AACA;AACA,QAAA,GAAG,CAAC,SAAJ,GAAgB,IAAhB;AACD;;AACD,aAAO,GAAP;AACD,KATO;;AAWA,IAAA,iBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,IAA1B,EAAmD,EAAnD,EAA2E,OAA3E,EAA2F;AAA3F,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAI,EAAE,CAAC,IAAH,KAAY,IAAhB,EAAsB;AACpB,eAAO,SAAA,CAAA,YAAA,CAAa,WAAb,CAAyB,IAAzB,CAAP;AACD,OAFD,MAEO,IAAI,EAAE,CAAC,IAAH,CAAQ,MAAR,KAAmB,CAAnB,IAAwB,CAAC,EAAE,CAAC,iBAAH,CAAqB,EAAE,CAAC,IAAH,CAAQ,CAAR,CAArB,CAA7B,EAA+D;AACpE,eAAO,SAAA,CAAA,YAAA,CAAa,uBAAb,CAAqC,IAArC,EAA2C,EAA3C,CAAP;AACD;;AACD,UAAM,GAAG,GAAG,EAAE,CAAC,IAAH,CAAQ,CAAR,CAAZ;AAEA,UAAM,IAAI,GAAG,KAAK,yBAAL,CAA+B,IAA/B,EAAqC,OAArC,CAAb;AACA,UAAM,QAAQ,GAAU,IAAI,GAAJ,EAAxB;;AACA,UAAM,aAAa,GAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAAO,OAAP,CAAA,EAAc;AAAE,QAAA,KAAK,EAAE;AAAT,OAAd,CAAnB;;AACA,MAAA,EAAE,CAAC,UAAH,CAAc,OAAd,CAAsB,UAAC,KAAD,EAAQ,KAAR,EAAa;AACjC,YAAI,GAAG,GAAG,IAAI,CAAC,KAAD,CAAd;;AACA,YAAI,KAAK,CAAC,IAAN,CAAW,cAAX,KAA8B,SAAlC,EAA6C;AAC3C,UAAA,GAAG,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAN;AACD;;AACD,YAAI,GAAG,KAAK,SAAR,IAAqB,KAAK,CAAC,WAAN,KAAsB,IAA/C,EAAqD;AACnD,UAAA,GAAG,GAAG,KAAI,CAAC,eAAL,CAAqB,KAAK,CAAC,WAA3B,EAAwC,aAAxC,CAAN;AACD;;AACD,QAAA,QAAQ,CAAC,GAAT,CAAa,KAAK,CAAC,IAAnB,EAAyB,GAAzB;AACD,OATD;AAWA,aAAO,GAAG,CAAC,UAAJ,KAAmB,SAAnB,GAA+B,KAAK,eAAL,CAAqB,GAAG,CAAC,UAAzB,EAAqC,aAArC,CAA/B,GAC+B,SADtC;AAED,KAzBO;;AA2BA,IAAA,iBAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,UAAmC,IAAnC,EAAmE,OAAnE,EAAmF;AAEjF,UAAM,SAAS,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,SAA1B,EAAqC,OAArC,CAAlB;;AACA,UAAI,SAAS,YAAY,SAAA,CAAA,YAAzB,EAAuC;AACrC,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,SAApC,CAAP;AACD;;AAED,UAAI,SAAJ,EAAe;AACb,eAAO,KAAK,eAAL,CAAqB,IAAI,CAAC,QAA1B,EAAoC,OAApC,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAK,eAAL,CAAqB,IAAI,CAAC,SAA1B,EAAqC,OAArC,CAAP;AACD;AACF,KAZO;;AAcA,IAAA,iBAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,UAAmC,IAAnC,EAAmE,OAAnE,EAAmF;AAEjF,UAAM,YAAY,GAAG,IAAI,CAAC,QAA1B;;AACA,UAAI,CAAC,eAAe,CAAC,GAAhB,CAAoB,YAApB,CAAL,EAAwC;AACtC,eAAO,SAAA,CAAA,YAAA,CAAa,qBAAb,CAAmC,IAAnC,CAAP;AACD;;AAED,UAAM,EAAE,GAAG,eAAe,CAAC,GAAhB,CAAoB,YAApB,CAAX;AACA,UAAM,KAAK,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,OAA1B,EAAmC,OAAnC,CAAd;;AACA,UAAI,KAAK,YAAY,SAAA,CAAA,YAArB,EAAmC;AACjC,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,KAApC,CAAP;AACD,OAFD,MAEO;AACL,eAAO,EAAE,CAAC,KAAD,CAAT;AACD;AACF,KAdO;;AAgBA,IAAA,iBAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,UAA8B,IAA9B,EAAyD,OAAzD,EAAyE;AACvE,UAAM,SAAS,GAAG,IAAI,CAAC,aAAL,CAAmB,IAArC;;AACA,UAAI,CAAC,gBAAgB,CAAC,GAAjB,CAAqB,SAArB,CAAL,EAAsC;AACpC,eAAO,SAAA,CAAA,YAAA,CAAa,qBAAb,CAAmC,IAAnC,CAAP;AACD;;AAED,UAAM,QAAQ,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,SAArB,CAAjB;AACA,UAAI,GAAJ,EAAwB,GAAxB;;AACA,UAAI,QAAQ,CAAC,OAAb,EAAsB;AACpB,QAAA,GAAG,GAAG,OAAO,CACT,KAAK,eAAL,CAAqB,IAAI,CAAC,IAA1B,EAAgC,OAAhC,CADS,EAET,UAAA,KAAA,EAAK;AAAI,iBAAA,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,IAAI,CAAC,IAA5C,EAAA,KAAA,CAAA;AAAwD,SAFxD,CAAb;AAGA,QAAA,GAAG,GAAG,OAAO,CACT,KAAK,eAAL,CAAqB,IAAI,CAAC,KAA1B,EAAiC,OAAjC,CADS,EAET,UAAA,KAAA,EAAK;AAAI,iBAAA,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,IAAI,CAAC,KAA5C,EAAA,KAAA,CAAA;AAAyD,SAFzD,CAAb;AAGD,OAPD,MAOO;AACL,QAAA,GAAG,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,IAA1B,EAAgC,OAAhC,CAAN;AACA,QAAA,GAAG,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,KAA1B,EAAiC,OAAjC,CAAN;AACD;;AACD,UAAI,GAAG,YAAY,SAAA,CAAA,YAAnB,EAAiC;AAC/B,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,GAApC,CAAP;AACD,OAFD,MAEO,IAAI,GAAG,YAAY,SAAA,CAAA,YAAnB,EAAiC;AACtC,eAAO,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,GAApC,CAAP;AACD,OAFM,MAEA;AACL,eAAO,QAAQ,CAAC,EAAT,CAAY,GAAZ,EAAiB,GAAjB,CAAP;AACD;AACF,KA1BO;;AA4BA,IAAA,iBAAA,CAAA,SAAA,CAAA,4BAAA,GAAR,UAAqC,IAArC,EAAuE,OAAvE,EAAuF;AAErF,aAAO,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAP;AACD,KAHO;;AAKA,IAAA,iBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,IAAlC,EAA2D,OAA3D,EAA2E;;;AACzE,UAAM,IAAI,GAAuB,EAAjC;;;AACA,aAAkB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,IAAI,CAAC,SAAL,CAAA,EAAc,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhC,EAAgC,CAAA,EAAA,CAAA,IAAhC,EAAgC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhC,EAAkC;AAA7B,cAAM,GAAG,GAAA,EAAA,CAAA,KAAT;;AACH,cAAI,EAAE,CAAC,eAAH,CAAmB,GAAnB,CAAJ,EAA6B;AAC3B,YAAA,IAAI,CAAC,IAAL,CAAS,KAAT,CAAA,IAAA,EAAI,OAAA,CAAA,QAAA,CAAS,KAAK,kBAAL,CAAwB,GAAxB,EAA6B,OAA7B,CAAT,CAAJ;AACD,WAFD,MAEO;AACL,YAAA,IAAI,CAAC,IAAL,CAAU,KAAK,eAAL,CAAqB,GAArB,EAA0B,OAA1B,CAAV;AACD;AACF;;;;;;;;;;;;;AACD,aAAO,IAAP;AACD,KAVO;;AAYA,IAAA,iBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,IAA3B,EAAmD,OAAnD,EAAmE;AACjE,UAAM,MAAM,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAf;;AACA,UAAI,MAAM,YAAY,SAAA,CAAA,YAAtB,EAAoC;AAClC,eAAO,CAAC,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,IAA9B,EAAoC,MAApC,CAAD,CAAP;AACD,OAFD,MAEO,IAAI,CAAC,KAAK,CAAC,OAAN,CAAc,MAAd,CAAL,EAA4B;AACjC,eAAO,CAAC,SAAA,CAAA,YAAA,CAAa,yBAAb,CAAuC,IAAvC,EAA6C,MAA7C,CAAD,CAAP;AACD,OAFM,MAEA;AACL,eAAO,MAAP;AACD;AACF,KATO;;AAWA,IAAA,iBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,IAA5B,EAAqD,OAArD,EAAqE;;;AACnE,UAAM,IAAI,GAAwB,EAAlC;AACA,UAAI,kBAAkB,GAAY,IAAlC;;AAEA,aAAO,EAAE,CAAC,gBAAH,CAAoB,kBAApB,KACA,EAAE,CAAC,qBAAH,CAAyB,kBAAzB,CADA,IAEA,EAAE,CAAC,sBAAH,CAA0B,kBAA1B,CAFP,EAEsD;AACpD,YAAI,EAAE,CAAC,gBAAH,CAAoB,kBAApB,CAAJ,EAA6C;AAC3C,UAAA,IAAI,CAAC,OAAL,CAAa,kBAAb;AACD;;AAED,QAAA,kBAAkB,GAAG,kBAAkB,CAAC,MAAxC;AACD;;AAED,UAAI,CAAC,EAAE,CAAC,qBAAH,CAAyB,kBAAzB,CAAD,IACA,kBAAkB,CAAC,WAAnB,KAAmC,SADvC,EACkD;AAChD,eAAO,SAAA,CAAA,YAAA,CAAa,WAAb,CAAyB,IAAzB,CAAP;AACD;;AAED,UAAI,KAAK,GAAG,KAAK,KAAL,CAAW,kBAAkB,CAAC,WAA9B,EAA2C,OAA3C,CAAZ;;;AACA,aAAsB,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA,IAAA,CAAA,EAAI,QAAA,GAAA,MAAA,CAAA,IAAA,EAA1B,EAA0B,CAAA,QAAA,CAAA,IAA1B,EAA0B,QAAA,GAAA,MAAA,CAAA,IAAA,EAA1B,EAA4B;AAAvB,cAAM,OAAO,GAAA,QAAA,CAAA,KAAb;AACH,cAAI,GAAG,GAAA,KAAA,CAAP;;AACA,cAAI,EAAE,CAAC,qBAAH,CAAyB,OAAO,CAAC,MAAjC,CAAJ,EAA8C;AAC5C,YAAA,GAAG,GAAG,OAAO,CAAC,MAAR,CAAe,QAAf,CAAwB,OAAxB,CAAgC,OAAhC,CAAN;AACD,WAFD,MAEO;AACL,gBAAM,MAAI,GAAG,OAAO,CAAC,YAAR,IAAwB,OAAO,CAAC,IAA7C;;AACA,gBAAI,EAAE,CAAC,YAAH,CAAgB,MAAhB,CAAJ,EAA2B;AACzB,cAAA,GAAG,GAAG,MAAI,CAAC,IAAX;AACD,aAFD,MAEO;AACL,qBAAO,SAAA,CAAA,YAAA,CAAa,WAAb,CAAyB,OAAzB,CAAP;AACD;AACF;;AACD,UAAA,KAAK,GAAG,KAAK,YAAL,CAAkB,OAAlB,EAA2B,KAA3B,EAAkC,GAAlC,EAAuC,OAAvC,CAAR;;AACA,cAAI,KAAK,YAAY,SAAA,CAAA,YAArB,EAAmC;AACjC,mBAAO,KAAP;AACD;AACF;;;;;;;;;;;;;AAED,aAAO,KAAP;AACD,KAvCO;;AAyCA,IAAA,iBAAA,CAAA,SAAA,CAAA,0BAAA,GAAR,UAAmC,IAAnC,EAA0D,OAA1D,EAA0E;AACxE,UAAI,EAAE,CAAC,YAAH,CAAgB,IAAhB,KAAyB,EAAE,CAAC,eAAH,CAAmB,IAAnB,CAAzB,IAAqD,EAAE,CAAC,gBAAH,CAAoB,IAApB,CAAzD,EAAoF;AAClF,eAAO,IAAI,CAAC,IAAZ;AACD,OAFD,MAEO,IAAI,EAAE,CAAC,sBAAH,CAA0B,IAA1B,CAAJ,EAAqC;AAC1C,YAAM,SAAO,GAAG,KAAK,eAAL,CAAqB,IAAI,CAAC,UAA1B,EAAsC,OAAtC,CAAhB;AACA,eAAO,OAAO,SAAP,KAAmB,QAAnB,GAA8B,SAA9B,GAAwC,SAA/C;AACD,OAHM,MAGA;AACL,eAAO,SAAP;AACD;AACF,KATO;;AAWA,IAAA,iBAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,IAAxB,EAA8C,WAA9C,EAAyE,OAAzE,EAAyF;AAAzF,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAM,OAAO,GAAG,KAAK,YAAL,CAAkB,IAAlB,EAAwB,OAAxB,CAAhB;AACA,UAAM,GAAG,GAAG,IAAI,GAAJ,EAAZ;AACA,MAAA,WAAW,CAAC,OAAZ,CAAoB,UAAA,MAAA,EAAM;AACxB,YAAM,IAAI,GAAG,KAAI,CAAC,0BAAL,CAAgC,MAAM,CAAC,IAAvC,EAA6C,OAA7C,CAAb;;AACA,YAAI,IAAI,KAAK,SAAb,EAAwB;AACtB,cAAM,QAAQ,GAAG,KAAI,CAAC,KAAL,CAAW,MAAM,CAAC,WAAlB,EAA+B,OAA/B,CAAjB;;AACA,UAAA,GAAG,CAAC,GAAJ,CAAQ,IAAR,EAAc,IAAI,QAAA,CAAA,SAAJ,CAAc,OAAd,EAAuB,IAAvB,EAA6B,QAA7B,CAAd;AACD;AACF,OAND;AAOA,aAAO,GAAP;AACD,KAZO;;AAcA,IAAA,iBAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAgD,IAAhD,EAAyD,OAAzD,EAAyE;AACvE,aAAO,IAAI,SAAA,CAAA,SAAJ,CAAc,IAAd,EAAoB,YAAY,CAAC,OAAD,CAAhC,CAAP;AACD,KAFO;;AAGV,WAAA,iBAAA;AAAC,GAllBD,EAAA;;AAAa,EAAA,OAAA,CAAA,iBAAA,GAAA,iBAAA;;AAolBb,WAAS,2BAAT,CAAqC,GAArC,EAA4D;AAE1D,WAAO,EAAE,CAAC,qBAAH,CAAyB,GAAG,CAAC,IAA7B,KAAsC,EAAE,CAAC,mBAAH,CAAuB,GAAG,CAAC,IAA3B,CAAtC,IACH,EAAE,CAAC,oBAAH,CAAwB,GAAG,CAAC,IAA5B,CADJ;AAED;;AAED,WAAS,OAAT,CACI,KADJ,EAC0B,MAD1B,EACyE;AACvE,QAAI,KAAK,YAAY,QAAA,CAAA,SAArB,EAAgC;AAC9B,MAAA,KAAK,GAAG,KAAK,CAAC,QAAd;AACD;;AACD,QAAI,KAAK,YAAY,SAAA,CAAA,YAAjB,IAAiC,KAAK,KAAK,IAA3C,IAAmD,KAAK,KAAK,SAA7D,IACA,OAAO,KAAP,KAAiB,QADjB,IAC6B,OAAO,KAAP,KAAiB,QAD9C,IAC0D,OAAO,KAAP,KAAiB,SAD/E,EAC0F;AACxF,aAAO,KAAP;AACD;;AACD,WAAO,MAAM,CAAC,KAAD,CAAb;AACD;;AAED,WAAS,6BAAT,CAAuC,IAAvC,EAAmE;AACjE,QAAI,IAAI,CAAC,MAAL,KAAgB,SAAhB,IAA6B,CAAC,EAAE,CAAC,yBAAH,CAA6B,IAAI,CAAC,MAAlC,CAAlC,EAA6E;AAC3E,aAAO,KAAP;AACD;;AACD,QAAM,QAAQ,GAAG,IAAI,CAAC,MAAtB;;AACA,QAAI,QAAQ,CAAC,MAAT,KAAoB,SAApB,IAAiC,CAAC,EAAE,CAAC,mBAAH,CAAuB,QAAQ,CAAC,MAAhC,CAAtC,EAA+E;AAC7E,aAAO,KAAP;AACD;;AACD,QAAM,OAAO,GAAG,QAAQ,CAAC,MAAzB;AACA,WAAO,OAAO,CAAC,SAAR,KAAsB,SAAtB,IACH,OAAO,CAAC,SAAR,CAAkB,IAAlB,CAAuB,UAAA,GAAA,EAAG;AAAI,aAAA,GAAG,CAAC,IAAJ,KAAa,EAAE,CAAC,UAAH,CAAb,cAAA;AAAyC,KAAvE,CADJ;AAED;;AAED,MAAM,KAAK,GAAG,EAAd;;AAEA,WAAS,iBAAT,CAA2B,QAA3B,EAA8C,IAA9C,EAA6D,IAA7D,EAA8E;AAI5E,QAAI,IAAI,CAAC,SAAL,KAAmB,IAAnB,IAA2B,IAAI,CAAC,SAAL,KAAmB,QAAQ,CAAC,kBAA3D,EAA+E;AAC7E,aAAO;AACL,QAAA,kBAAkB,EAAE,IAAI,CAAC,SADpB;AAEL,QAAA,iBAAiB,EAAE,IAAI,CAAC,aAAL,GAAqB;AAFnC,OAAP;AAID,KALD,MAKO;AACL,aAAO,KAAP;AACD;AACF;;AAED,WAAS,YAAT,CAAsB,OAAtB,EAAwC,QAAxC,EAA0E;AAAlC,QAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,QAAA,GAAA,IAAA;AAAkC;;AACxE,QAAI,SAAS,GAAG,OAAO,CAAC,kBAAxB;;AACA,QAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,MAAA,SAAS,GAAG,QAAQ,CAAC,SAArB;AACD;;AACD,QAAI,SAAS,KAAK,IAAlB,EAAwB;AACtB,aAAO;AACL,QAAA,SAAS,EAAA,SADJ;AAEL,QAAA,iBAAiB,EAAE,OAAO,CAAC;AAFtB,OAAP;AAID,KALD,MAKO;AACL,aAAO,IAAP;AACD;AACF","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {OwningModule} from '../../imports/src/references';\nimport {DependencyTracker} from '../../incremental/api';\nimport {Declaration, DeclarationKind, DeclarationNode, EnumMember, FunctionDefinition, isConcreteDeclaration, ReflectionHost, SpecialDeclarationKind} from '../../reflection';\nimport {isDeclaration} from '../../util/src/typescript';\n\nimport {ArrayConcatBuiltinFn, ArraySliceBuiltinFn} from './builtin';\nimport {DynamicValue} from './dynamic';\nimport {ForeignFunctionResolver} from './interface';\nimport {resolveKnownDeclaration} from './known_declaration';\nimport {EnumValue, KnownFn, ResolvedModule, ResolvedValue, ResolvedValueArray, ResolvedValueMap} from './result';\n\n\n\n/**\n * Tracks the scope of a function body, which includes `ResolvedValue`s for the parameters of that\n * body.\n */\ntype Scope = Map<ts.ParameterDeclaration, ResolvedValue>;\n\ninterface BinaryOperatorDef {\n  literal: boolean;\n  op: (a: any, b: any) => ResolvedValue;\n}\n\nfunction literalBinaryOp(op: (a: any, b: any) => any): BinaryOperatorDef {\n  return {op, literal: true};\n}\n\nfunction referenceBinaryOp(op: (a: any, b: any) => any): BinaryOperatorDef {\n  return {op, literal: false};\n}\n\nconst BINARY_OPERATORS = new Map<ts.SyntaxKind, BinaryOperatorDef>([\n  [ts.SyntaxKind.PlusToken, literalBinaryOp((a, b) => a + b)],\n  [ts.SyntaxKind.MinusToken, literalBinaryOp((a, b) => a - b)],\n  [ts.SyntaxKind.AsteriskToken, literalBinaryOp((a, b) => a * b)],\n  [ts.SyntaxKind.SlashToken, literalBinaryOp((a, b) => a / b)],\n  [ts.SyntaxKind.PercentToken, literalBinaryOp((a, b) => a % b)],\n  [ts.SyntaxKind.AmpersandToken, literalBinaryOp((a, b) => a & b)],\n  [ts.SyntaxKind.BarToken, literalBinaryOp((a, b) => a | b)],\n  [ts.SyntaxKind.CaretToken, literalBinaryOp((a, b) => a ^ b)],\n  [ts.SyntaxKind.LessThanToken, literalBinaryOp((a, b) => a < b)],\n  [ts.SyntaxKind.LessThanEqualsToken, literalBinaryOp((a, b) => a <= b)],\n  [ts.SyntaxKind.GreaterThanToken, literalBinaryOp((a, b) => a > b)],\n  [ts.SyntaxKind.GreaterThanEqualsToken, literalBinaryOp((a, b) => a >= b)],\n  [ts.SyntaxKind.EqualsEqualsToken, literalBinaryOp((a, b) => a == b)],\n  [ts.SyntaxKind.EqualsEqualsEqualsToken, literalBinaryOp((a, b) => a === b)],\n  [ts.SyntaxKind.ExclamationEqualsToken, literalBinaryOp((a, b) => a != b)],\n  [ts.SyntaxKind.ExclamationEqualsEqualsToken, literalBinaryOp((a, b) => a !== b)],\n  [ts.SyntaxKind.LessThanLessThanToken, literalBinaryOp((a, b) => a << b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >> b)],\n  [ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, literalBinaryOp((a, b) => a >>> b)],\n  [ts.SyntaxKind.AsteriskAsteriskToken, literalBinaryOp((a, b) => Math.pow(a, b))],\n  [ts.SyntaxKind.AmpersandAmpersandToken, referenceBinaryOp((a, b) => a && b)],\n  [ts.SyntaxKind.BarBarToken, referenceBinaryOp((a, b) => a || b)]\n]);\n\nconst UNARY_OPERATORS = new Map<ts.SyntaxKind, (a: any) => any>([\n  [ts.SyntaxKind.TildeToken, a => ~a], [ts.SyntaxKind.MinusToken, a => -a],\n  [ts.SyntaxKind.PlusToken, a => +a], [ts.SyntaxKind.ExclamationToken, a => !a]\n]);\n\ninterface Context {\n  originatingFile: ts.SourceFile;\n  /**\n   * The module name (if any) which was used to reach the currently resolving symbols.\n   */\n  absoluteModuleName: string|null;\n\n  /**\n   * A file name representing the context in which the current `absoluteModuleName`, if any, was\n   * resolved.\n   */\n  resolutionContext: string;\n  scope: Scope;\n  foreignFunctionResolver?: ForeignFunctionResolver;\n}\n\nexport class StaticInterpreter {\n  constructor(\n      private host: ReflectionHost, private checker: ts.TypeChecker,\n      private dependencyTracker: DependencyTracker|null) {}\n\n  visit(node: ts.Expression, context: Context): ResolvedValue {\n    return this.visitExpression(node, context);\n  }\n\n  private visitExpression(node: ts.Expression, context: Context): ResolvedValue {\n    let result: ResolvedValue;\n    if (node.kind === ts.SyntaxKind.TrueKeyword) {\n      return true;\n    } else if (node.kind === ts.SyntaxKind.FalseKeyword) {\n      return false;\n    } else if (node.kind === ts.SyntaxKind.NullKeyword) {\n      return null;\n    } else if (ts.isStringLiteral(node)) {\n      return node.text;\n    } else if (ts.isNoSubstitutionTemplateLiteral(node)) {\n      return node.text;\n    } else if (ts.isTemplateExpression(node)) {\n      result = this.visitTemplateExpression(node, context);\n    } else if (ts.isNumericLiteral(node)) {\n      return parseFloat(node.text);\n    } else if (ts.isObjectLiteralExpression(node)) {\n      result = this.visitObjectLiteralExpression(node, context);\n    } else if (ts.isIdentifier(node)) {\n      result = this.visitIdentifier(node, context);\n    } else if (ts.isPropertyAccessExpression(node)) {\n      result = this.visitPropertyAccessExpression(node, context);\n    } else if (ts.isCallExpression(node)) {\n      result = this.visitCallExpression(node, context);\n    } else if (ts.isConditionalExpression(node)) {\n      result = this.visitConditionalExpression(node, context);\n    } else if (ts.isPrefixUnaryExpression(node)) {\n      result = this.visitPrefixUnaryExpression(node, context);\n    } else if (ts.isBinaryExpression(node)) {\n      result = this.visitBinaryExpression(node, context);\n    } else if (ts.isArrayLiteralExpression(node)) {\n      result = this.visitArrayLiteralExpression(node, context);\n    } else if (ts.isParenthesizedExpression(node)) {\n      result = this.visitParenthesizedExpression(node, context);\n    } else if (ts.isElementAccessExpression(node)) {\n      result = this.visitElementAccessExpression(node, context);\n    } else if (ts.isAsExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (ts.isNonNullExpression(node)) {\n      result = this.visitExpression(node.expression, context);\n    } else if (this.host.isClass(node)) {\n      result = this.visitDeclaration(node, context);\n    } else {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n    if (result instanceof DynamicValue && result.node !== node) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n\n  private visitArrayLiteralExpression(node: ts.ArrayLiteralExpression, context: Context):\n      ResolvedValue {\n    const array: ResolvedValueArray = [];\n    for (let i = 0; i < node.elements.length; i++) {\n      const element = node.elements[i];\n      if (ts.isSpreadElement(element)) {\n        array.push(...this.visitSpreadElement(element, context));\n      } else {\n        array.push(this.visitExpression(element, context));\n      }\n    }\n    return array;\n  }\n\n  protected visitObjectLiteralExpression(node: ts.ObjectLiteralExpression, context: Context):\n      ResolvedValue {\n    const map: ResolvedValueMap = new Map<string, ResolvedValue>();\n    for (let i = 0; i < node.properties.length; i++) {\n      const property = node.properties[i];\n      if (ts.isPropertyAssignment(property)) {\n        const name = this.stringNameFromPropertyName(property.name, context);\n        // Check whether the name can be determined statically.\n        if (name === undefined) {\n          return DynamicValue.fromDynamicInput(node, DynamicValue.fromDynamicString(property.name));\n        }\n        map.set(name, this.visitExpression(property.initializer, context));\n      } else if (ts.isShorthandPropertyAssignment(property)) {\n        const symbol = this.checker.getShorthandAssignmentValueSymbol(property);\n        if (symbol === undefined || symbol.valueDeclaration === undefined) {\n          map.set(property.name.text, DynamicValue.fromUnknown(property));\n        } else {\n          map.set(property.name.text, this.visitDeclaration(symbol.valueDeclaration, context));\n        }\n      } else if (ts.isSpreadAssignment(property)) {\n        const spread = this.visitExpression(property.expression, context);\n        if (spread instanceof DynamicValue) {\n          return DynamicValue.fromDynamicInput(node, spread);\n        } else if (spread instanceof Map) {\n          spread.forEach((value, key) => map.set(key, value));\n        } else if (spread instanceof ResolvedModule) {\n          spread.getExports().forEach((value, key) => map.set(key, value));\n        } else {\n          return DynamicValue.fromDynamicInput(\n              node, DynamicValue.fromInvalidExpressionType(property, spread));\n        }\n      } else {\n        return DynamicValue.fromUnknown(node);\n      }\n    }\n    return map;\n  }\n\n  private visitTemplateExpression(node: ts.TemplateExpression, context: Context): ResolvedValue {\n    const pieces: string[] = [node.head.text];\n    for (let i = 0; i < node.templateSpans.length; i++) {\n      const span = node.templateSpans[i];\n      const value = literal(\n          this.visit(span.expression, context),\n          () => DynamicValue.fromDynamicString(span.expression));\n      if (value instanceof DynamicValue) {\n        return DynamicValue.fromDynamicInput(node, value);\n      }\n      pieces.push(`${value}`, span.literal.text);\n    }\n    return pieces.join('');\n  }\n\n  private visitIdentifier(node: ts.Identifier, context: Context): ResolvedValue {\n    const decl = this.host.getDeclarationOfIdentifier(node);\n    if (decl === null) {\n      if (node.originalKeywordKind === ts.SyntaxKind.UndefinedKeyword) {\n        return undefined;\n      } else {\n        // Check if the symbol here is imported.\n        if (this.dependencyTracker !== null && this.host.getImportOfIdentifier(node) !== null) {\n          // It was, but no declaration for the node could be found. This means that the dependency\n          // graph for the current file cannot be properly updated to account for this (broken)\n          // import. Instead, the originating file is reported as failing dependency analysis,\n          // ensuring that future compilations will always attempt to re-resolve the previously\n          // broken identifier.\n          this.dependencyTracker.recordDependencyAnalysisFailure(context.originatingFile);\n        }\n        return DynamicValue.fromUnknownIdentifier(node);\n      }\n    }\n    if (decl.known !== null) {\n      return resolveKnownDeclaration(decl.known);\n    } else if (\n        isConcreteDeclaration(decl) && decl.identity !== null &&\n        decl.identity.kind === SpecialDeclarationKind.DownleveledEnum) {\n      return this.getResolvedEnum(decl.node, decl.identity.enumMembers, context);\n    }\n    const declContext = {...context, ...joinModuleContext(context, node, decl)};\n    const result = this.visitAmbiguousDeclaration(decl, declContext);\n    if (result instanceof Reference) {\n      // Only record identifiers to non-synthetic references. Synthetic references may not have the\n      // same value at runtime as they do at compile time, so it's not legal to refer to them by the\n      // identifier here.\n      if (!result.synthetic) {\n        result.addIdentifier(node);\n      }\n    } else if (result instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, result);\n    }\n    return result;\n  }\n\n  private visitDeclaration(node: DeclarationNode, context: Context): ResolvedValue {\n    if (this.dependencyTracker !== null) {\n      this.dependencyTracker.addDependency(context.originatingFile, node.getSourceFile());\n    }\n    if (this.host.isClass(node)) {\n      return this.getReference(node, context);\n    } else if (ts.isVariableDeclaration(node)) {\n      return this.visitVariableDeclaration(node, context);\n    } else if (ts.isParameter(node) && context.scope.has(node)) {\n      return context.scope.get(node)!;\n    } else if (ts.isExportAssignment(node)) {\n      return this.visitExpression(node.expression, context);\n    } else if (ts.isEnumDeclaration(node)) {\n      return this.visitEnumDeclaration(node, context);\n    } else if (ts.isSourceFile(node)) {\n      return this.visitSourceFile(node, context);\n    } else if (ts.isBindingElement(node)) {\n      return this.visitBindingElement(node, context);\n    } else {\n      return this.getReference(node, context);\n    }\n  }\n\n  private visitVariableDeclaration(node: ts.VariableDeclaration, context: Context): ResolvedValue {\n    const value = this.host.getVariableValue(node);\n    if (value !== null) {\n      return this.visitExpression(value, context);\n    } else if (isVariableDeclarationDeclared(node)) {\n      return this.getReference(node, context);\n    } else {\n      return undefined;\n    }\n  }\n\n  private visitEnumDeclaration(node: ts.EnumDeclaration, context: Context): ResolvedValue {\n    const enumRef = this.getReference(node, context);\n    const map = new Map<string, EnumValue>();\n    node.members.forEach(member => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n      if (name !== undefined) {\n        const resolved = member.initializer && this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n\n  private visitElementAccessExpression(node: ts.ElementAccessExpression, context: Context):\n      ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    const rhs = this.visitExpression(node.argumentExpression, context);\n    if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    }\n    if (typeof rhs !== 'string' && typeof rhs !== 'number') {\n      return DynamicValue.fromInvalidExpressionType(node, rhs);\n    }\n\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n\n  private visitPropertyAccessExpression(node: ts.PropertyAccessExpression, context: Context):\n      ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    const rhs = node.name.text;\n    // TODO: handle reference to class declaration.\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n    return this.accessHelper(node, lhs, rhs, context);\n  }\n\n  private visitSourceFile(node: ts.SourceFile, context: Context): ResolvedValue {\n    const declarations = this.host.getExportsOfModule(node);\n    if (declarations === null) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    return new ResolvedModule(declarations, decl => {\n      if (decl.known !== null) {\n        return resolveKnownDeclaration(decl.known);\n      }\n\n      const declContext = {\n        ...context,\n        ...joinModuleContext(context, node, decl),\n      };\n\n      // Visit both concrete and inline declarations.\n      return this.visitAmbiguousDeclaration(decl, declContext);\n    });\n  }\n\n  private visitAmbiguousDeclaration(decl: Declaration, declContext: Context) {\n    return decl.kind === DeclarationKind.Inline && decl.implementation !== undefined &&\n            !isDeclaration(decl.implementation) ?\n        // Inline declarations whose `implementation` is a `ts.Expression` should be visited as\n        // an expression.\n        this.visitExpression(decl.implementation, declContext) :\n        // Otherwise just visit the `node` as a declaration.\n        this.visitDeclaration(decl.node, declContext);\n  }\n\n  private accessHelper(node: ts.Node, lhs: ResolvedValue, rhs: string|number, context: Context):\n      ResolvedValue {\n    const strIndex = `${rhs}`;\n    if (lhs instanceof Map) {\n      if (lhs.has(strIndex)) {\n        return lhs.get(strIndex)!;\n      } else {\n        return undefined;\n      }\n    } else if (lhs instanceof ResolvedModule) {\n      return lhs.getExport(strIndex);\n    } else if (Array.isArray(lhs)) {\n      if (rhs === 'length') {\n        return lhs.length;\n      } else if (rhs === 'slice') {\n        return new ArraySliceBuiltinFn(lhs);\n      } else if (rhs === 'concat') {\n        return new ArrayConcatBuiltinFn(lhs);\n      }\n      if (typeof rhs !== 'number' || !Number.isInteger(rhs)) {\n        return DynamicValue.fromInvalidExpressionType(node, rhs);\n      }\n      return lhs[rhs];\n    } else if (lhs instanceof Reference) {\n      const ref = lhs.node;\n      if (this.host.isClass(ref)) {\n        const module = owningModule(context, lhs.bestGuessOwningModule);\n        let value: ResolvedValue = undefined;\n        const member = this.host.getMembersOfClass(ref).find(\n            member => member.isStatic && member.name === strIndex);\n        if (member !== undefined) {\n          if (member.value !== null) {\n            value = this.visitExpression(member.value, context);\n          } else if (member.implementation !== null) {\n            value = new Reference(member.implementation, module);\n          } else if (member.node) {\n            value = new Reference(member.node, module);\n          }\n        }\n        return value;\n      } else if (isDeclaration(ref)) {\n        return DynamicValue.fromDynamicInput(\n            node, DynamicValue.fromExternalReference(ref, lhs as Reference<ts.Declaration>));\n      }\n    } else if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n\n    return DynamicValue.fromUnknown(node);\n  }\n\n  private visitCallExpression(node: ts.CallExpression, context: Context): ResolvedValue {\n    const lhs = this.visitExpression(node.expression, context);\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    }\n\n    // If the call refers to a builtin function, attempt to evaluate the function.\n    if (lhs instanceof KnownFn) {\n      return lhs.evaluate(node, this.evaluateFunctionArguments(node, context));\n    }\n\n    if (!(lhs instanceof Reference)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    const fn = this.host.getDefinitionOfFunction(lhs.node);\n    if (fn === null) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    if (!isFunctionOrMethodReference(lhs)) {\n      return DynamicValue.fromInvalidExpressionType(node.expression, lhs);\n    }\n\n    // If the function is foreign (declared through a d.ts file), attempt to resolve it with the\n    // foreignFunctionResolver, if one is specified.\n    if (fn.body === null) {\n      let expr: ts.Expression|null = null;\n      if (context.foreignFunctionResolver) {\n        expr = context.foreignFunctionResolver(lhs, node.arguments);\n      }\n      if (expr === null) {\n        return DynamicValue.fromDynamicInput(\n            node, DynamicValue.fromExternalReference(node.expression, lhs));\n      }\n\n      // If the function is declared in a different file, resolve the foreign function expression\n      // using the absolute module name of that file (if any).\n      if (lhs.bestGuessOwningModule !== null) {\n        context = {\n          ...context,\n          absoluteModuleName: lhs.bestGuessOwningModule.specifier,\n          resolutionContext: node.getSourceFile().fileName,\n        };\n      }\n\n      return this.visitFfrExpression(expr, context);\n    }\n\n    let res: ResolvedValue = this.visitFunctionBody(node, fn, context);\n\n    // If the result of attempting to resolve the function body was a DynamicValue, attempt to use\n    // the foreignFunctionResolver if one is present. This could still potentially yield a usable\n    // value.\n    if (res instanceof DynamicValue && context.foreignFunctionResolver !== undefined) {\n      const ffrExpr = context.foreignFunctionResolver(lhs, node.arguments);\n      if (ffrExpr !== null) {\n        // The foreign function resolver was able to extract an expression from this function. See\n        // if that expression leads to a non-dynamic result.\n        const ffrRes = this.visitFfrExpression(ffrExpr, context);\n        if (!(ffrRes instanceof DynamicValue)) {\n          // FFR yielded an actual result that's not dynamic, so use that instead of the original\n          // resolution.\n          res = ffrRes;\n        }\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * Visit an expression which was extracted from a foreign-function resolver.\n   *\n   * This will process the result and ensure it's correct for FFR-resolved values, including marking\n   * `Reference`s as synthetic.\n   */\n  private visitFfrExpression(expr: ts.Expression, context: Context): ResolvedValue {\n    const res = this.visitExpression(expr, context);\n    if (res instanceof Reference) {\n      // This Reference was created synthetically, via a foreign function resolver. The real\n      // runtime value of the function expression may be different than the foreign function\n      // resolved value, so mark the Reference as synthetic to avoid it being misinterpreted.\n      res.synthetic = true;\n    }\n    return res;\n  }\n\n  private visitFunctionBody(node: ts.CallExpression, fn: FunctionDefinition, context: Context):\n      ResolvedValue {\n    if (fn.body === null) {\n      return DynamicValue.fromUnknown(node);\n    } else if (fn.body.length !== 1 || !ts.isReturnStatement(fn.body[0])) {\n      return DynamicValue.fromComplexFunctionCall(node, fn);\n    }\n    const ret = fn.body[0] as ts.ReturnStatement;\n\n    const args = this.evaluateFunctionArguments(node, context);\n    const newScope: Scope = new Map<ts.ParameterDeclaration, ResolvedValue>();\n    const calleeContext = {...context, scope: newScope};\n    fn.parameters.forEach((param, index) => {\n      let arg = args[index];\n      if (param.node.dotDotDotToken !== undefined) {\n        arg = args.slice(index);\n      }\n      if (arg === undefined && param.initializer !== null) {\n        arg = this.visitExpression(param.initializer, calleeContext);\n      }\n      newScope.set(param.node, arg);\n    });\n\n    return ret.expression !== undefined ? this.visitExpression(ret.expression, calleeContext) :\n                                          undefined;\n  }\n\n  private visitConditionalExpression(node: ts.ConditionalExpression, context: Context):\n      ResolvedValue {\n    const condition = this.visitExpression(node.condition, context);\n    if (condition instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, condition);\n    }\n\n    if (condition) {\n      return this.visitExpression(node.whenTrue, context);\n    } else {\n      return this.visitExpression(node.whenFalse, context);\n    }\n  }\n\n  private visitPrefixUnaryExpression(node: ts.PrefixUnaryExpression, context: Context):\n      ResolvedValue {\n    const operatorKind = node.operator;\n    if (!UNARY_OPERATORS.has(operatorKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n\n    const op = UNARY_OPERATORS.get(operatorKind)!;\n    const value = this.visitExpression(node.operand, context);\n    if (value instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, value);\n    } else {\n      return op(value);\n    }\n  }\n\n  private visitBinaryExpression(node: ts.BinaryExpression, context: Context): ResolvedValue {\n    const tokenKind = node.operatorToken.kind;\n    if (!BINARY_OPERATORS.has(tokenKind)) {\n      return DynamicValue.fromUnsupportedSyntax(node);\n    }\n\n    const opRecord = BINARY_OPERATORS.get(tokenKind)!;\n    let lhs: ResolvedValue, rhs: ResolvedValue;\n    if (opRecord.literal) {\n      lhs = literal(\n          this.visitExpression(node.left, context),\n          value => DynamicValue.fromInvalidExpressionType(node.left, value));\n      rhs = literal(\n          this.visitExpression(node.right, context),\n          value => DynamicValue.fromInvalidExpressionType(node.right, value));\n    } else {\n      lhs = this.visitExpression(node.left, context);\n      rhs = this.visitExpression(node.right, context);\n    }\n    if (lhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, lhs);\n    } else if (rhs instanceof DynamicValue) {\n      return DynamicValue.fromDynamicInput(node, rhs);\n    } else {\n      return opRecord.op(lhs, rhs);\n    }\n  }\n\n  private visitParenthesizedExpression(node: ts.ParenthesizedExpression, context: Context):\n      ResolvedValue {\n    return this.visitExpression(node.expression, context);\n  }\n\n  private evaluateFunctionArguments(node: ts.CallExpression, context: Context): ResolvedValueArray {\n    const args: ResolvedValueArray = [];\n    for (const arg of node.arguments) {\n      if (ts.isSpreadElement(arg)) {\n        args.push(...this.visitSpreadElement(arg, context));\n      } else {\n        args.push(this.visitExpression(arg, context));\n      }\n    }\n    return args;\n  }\n\n  private visitSpreadElement(node: ts.SpreadElement, context: Context): ResolvedValueArray {\n    const spread = this.visitExpression(node.expression, context);\n    if (spread instanceof DynamicValue) {\n      return [DynamicValue.fromDynamicInput(node, spread)];\n    } else if (!Array.isArray(spread)) {\n      return [DynamicValue.fromInvalidExpressionType(node, spread)];\n    } else {\n      return spread;\n    }\n  }\n\n  private visitBindingElement(node: ts.BindingElement, context: Context): ResolvedValue {\n    const path: ts.BindingElement[] = [];\n    let closestDeclaration: ts.Node = node;\n\n    while (ts.isBindingElement(closestDeclaration) ||\n           ts.isArrayBindingPattern(closestDeclaration) ||\n           ts.isObjectBindingPattern(closestDeclaration)) {\n      if (ts.isBindingElement(closestDeclaration)) {\n        path.unshift(closestDeclaration);\n      }\n\n      closestDeclaration = closestDeclaration.parent;\n    }\n\n    if (!ts.isVariableDeclaration(closestDeclaration) ||\n        closestDeclaration.initializer === undefined) {\n      return DynamicValue.fromUnknown(node);\n    }\n\n    let value = this.visit(closestDeclaration.initializer, context);\n    for (const element of path) {\n      let key: number|string;\n      if (ts.isArrayBindingPattern(element.parent)) {\n        key = element.parent.elements.indexOf(element);\n      } else {\n        const name = element.propertyName || element.name;\n        if (ts.isIdentifier(name)) {\n          key = name.text;\n        } else {\n          return DynamicValue.fromUnknown(element);\n        }\n      }\n      value = this.accessHelper(element, value, key, context);\n      if (value instanceof DynamicValue) {\n        return value;\n      }\n    }\n\n    return value;\n  }\n\n  private stringNameFromPropertyName(node: ts.PropertyName, context: Context): string|undefined {\n    if (ts.isIdentifier(node) || ts.isStringLiteral(node) || ts.isNumericLiteral(node)) {\n      return node.text;\n    } else if (ts.isComputedPropertyName(node)) {\n      const literal = this.visitExpression(node.expression, context);\n      return typeof literal === 'string' ? literal : undefined;\n    } else {\n      return undefined;\n    }\n  }\n\n  private getResolvedEnum(node: ts.Declaration, enumMembers: EnumMember[], context: Context):\n      ResolvedValue {\n    const enumRef = this.getReference(node, context);\n    const map = new Map<string, EnumValue>();\n    enumMembers.forEach(member => {\n      const name = this.stringNameFromPropertyName(member.name, context);\n      if (name !== undefined) {\n        const resolved = this.visit(member.initializer, context);\n        map.set(name, new EnumValue(enumRef, name, resolved));\n      }\n    });\n    return map;\n  }\n\n  private getReference<T extends DeclarationNode>(node: T, context: Context): Reference<T> {\n    return new Reference(node, owningModule(context));\n  }\n}\n\nfunction isFunctionOrMethodReference(ref: Reference<ts.Node>):\n    ref is Reference<ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression> {\n  return ts.isFunctionDeclaration(ref.node) || ts.isMethodDeclaration(ref.node) ||\n      ts.isFunctionExpression(ref.node);\n}\n\nfunction literal(\n    value: ResolvedValue, reject: (value: ResolvedValue) => ResolvedValue): ResolvedValue {\n  if (value instanceof EnumValue) {\n    value = value.resolved;\n  }\n  if (value instanceof DynamicValue || value === null || value === undefined ||\n      typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n    return value;\n  }\n  return reject(value);\n}\n\nfunction isVariableDeclarationDeclared(node: ts.VariableDeclaration): boolean {\n  if (node.parent === undefined || !ts.isVariableDeclarationList(node.parent)) {\n    return false;\n  }\n  const declList = node.parent;\n  if (declList.parent === undefined || !ts.isVariableStatement(declList.parent)) {\n    return false;\n  }\n  const varStmt = declList.parent;\n  return varStmt.modifiers !== undefined &&\n      varStmt.modifiers.some(mod => mod.kind === ts.SyntaxKind.DeclareKeyword);\n}\n\nconst EMPTY = {};\n\nfunction joinModuleContext(existing: Context, node: ts.Node, decl: Declaration): {\n  absoluteModuleName?: string,\n  resolutionContext?: string,\n} {\n  if (decl.viaModule !== null && decl.viaModule !== existing.absoluteModuleName) {\n    return {\n      absoluteModuleName: decl.viaModule,\n      resolutionContext: node.getSourceFile().fileName,\n    };\n  } else {\n    return EMPTY;\n  }\n}\n\nfunction owningModule(context: Context, override: OwningModule|null = null): OwningModule|null {\n  let specifier = context.absoluteModuleName;\n  if (override !== null) {\n    specifier = override.specifier;\n  }\n  if (specifier !== null) {\n    return {\n      specifier,\n      resolutionContext: context.resolutionContext,\n    };\n  } else {\n    return null;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}