{"ast":null,"code":"/**\n * A simple dependency graph\n */\n\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n * @param circular A boolean to allow circular dependencies\n */\nfunction createDFS(edges, leavesOnly, result, circular) {\n  var currentPath = [];\n  var visited = {};\n  return function DFS(currentNode) {\n    visited[currentNode] = true;\n    currentPath.push(currentNode);\n    edges[currentNode].forEach(function (node) {\n      if (!visited[node]) {\n        DFS(node);\n      } else if (currentPath.indexOf(node) >= 0) {\n        currentPath.push(node);\n\n        if (!circular) {\n          throw new Error('Dependency Cycle Found: ' + currentPath.join(' -> '));\n        }\n      }\n    });\n    currentPath.pop();\n\n    if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {\n      result.push(currentNode);\n    }\n  };\n}\n/**\n * Simple Dependency Graph\n */\n\n\nvar DepGraph = exports.DepGraph = function DepGraph(opts) {\n  this.nodes = {}; // Node -> Node/Data (treated like a Set)\n\n  this.outgoingEdges = {}; // Node -> [Dependency Node]\n\n  this.incomingEdges = {}; // Node -> [Dependant Node]\n\n  this.circular = opts && !!opts.circular; // Allows circular deps\n};\n\nDepGraph.prototype = {\n  /**\n   * The number of nodes in the graph.\n   */\n  size: function size() {\n    return Object.keys(this.nodes).length;\n  },\n\n  /**\n   * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n   */\n  addNode: function addNode(node, data) {\n    if (!this.hasNode(node)) {\n      // Checking the arguments length allows the user to add a node with undefined data\n      if (arguments.length === 2) {\n        this.nodes[node] = data;\n      } else {\n        this.nodes[node] = node;\n      }\n\n      this.outgoingEdges[node] = [];\n      this.incomingEdges[node] = [];\n    }\n  },\n\n  /**\n   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n   */\n  removeNode: function removeNode(node) {\n    if (this.hasNode(node)) {\n      delete this.nodes[node];\n      delete this.outgoingEdges[node];\n      delete this.incomingEdges[node];\n      [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n        Object.keys(edgeList).forEach(function (key) {\n          var idx = edgeList[key].indexOf(node);\n\n          if (idx >= 0) {\n            edgeList[key].splice(idx, 1);\n          }\n        }, this);\n      });\n    }\n  },\n\n  /**\n   * Check if a node exists in the graph\n   */\n  hasNode: function hasNode(node) {\n    return this.nodes.hasOwnProperty(node);\n  },\n\n  /**\n   * Get the data associated with a node name\n   */\n  getNodeData: function getNodeData(node) {\n    if (this.hasNode(node)) {\n      return this.nodes[node];\n    } else {\n      throw new Error('Node does not exist: ' + node);\n    }\n  },\n\n  /**\n   * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n   */\n  setNodeData: function setNodeData(node, data) {\n    if (this.hasNode(node)) {\n      this.nodes[node] = data;\n    } else {\n      throw new Error('Node does not exist: ' + node);\n    }\n  },\n\n  /**\n   * Add a dependency between two nodes. If either of the nodes does not exist,\n   * an Error will be thrown.\n   */\n  addDependency: function addDependency(from, to) {\n    if (!this.hasNode(from)) {\n      throw new Error('Node does not exist: ' + from);\n    }\n\n    if (!this.hasNode(to)) {\n      throw new Error('Node does not exist: ' + to);\n    }\n\n    if (this.outgoingEdges[from].indexOf(to) === -1) {\n      this.outgoingEdges[from].push(to);\n    }\n\n    if (this.incomingEdges[to].indexOf(from) === -1) {\n      this.incomingEdges[to].push(from);\n    }\n\n    return true;\n  },\n\n  /**\n   * Remove a dependency between two nodes.\n   */\n  removeDependency: function removeDependency(from, to) {\n    var idx;\n\n    if (this.hasNode(from)) {\n      idx = this.outgoingEdges[from].indexOf(to);\n\n      if (idx >= 0) {\n        this.outgoingEdges[from].splice(idx, 1);\n      }\n    }\n\n    if (this.hasNode(to)) {\n      idx = this.incomingEdges[to].indexOf(from);\n\n      if (idx >= 0) {\n        this.incomingEdges[to].splice(idx, 1);\n      }\n    }\n  },\n\n  /**\n   * Return a clone of the dependency graph. If any custom data is attached\n   * to the nodes, it will only be shallow copied.\n   */\n  clone: function clone() {\n    var source = this;\n    var result = new DepGraph();\n    var keys = Object.keys(source.nodes);\n    keys.forEach(function (n) {\n      result.nodes[n] = source.nodes[n];\n      result.outgoingEdges[n] = source.outgoingEdges[n].slice(0);\n      result.incomingEdges[n] = source.incomingEdges[n].slice(0);\n    });\n    return result;\n  },\n\n  /**\n   * Get an array containing the nodes that the specified node depends on (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n   * in the array.\n   */\n  dependenciesOf: function dependenciesOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      var result = [];\n      var DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);\n      DFS(node);\n      var idx = result.indexOf(node);\n\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n\n      return result;\n    } else {\n      throw new Error('Node does not exist: ' + node);\n    }\n  },\n\n  /**\n   * get an array containing the nodes that depend on the specified node (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n   */\n  dependantsOf: function dependantsOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      var result = [];\n      var DFS = createDFS(this.incomingEdges, leavesOnly, result, this.circular);\n      DFS(node);\n      var idx = result.indexOf(node);\n\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n\n      return result;\n    } else {\n      throw new Error('Node does not exist: ' + node);\n    }\n  },\n\n  /**\n   * Construct the overall processing order for the dependency graph.\n   *\n   * Throws an Error if the graph has a cycle.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n   */\n  overallOrder: function overallOrder(leavesOnly) {\n    var self = this;\n    var result = [];\n    var keys = Object.keys(this.nodes);\n\n    if (keys.length === 0) {\n      return result; // Empty graph\n    } else {\n      // Look for cycles - we run the DFS starting at all the nodes in case there\n      // are several disconnected subgraphs inside this dependency graph.\n      var CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);\n      keys.forEach(function (n) {\n        CycleDFS(n);\n      });\n      var DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular); // Find all potential starting points (nodes with nothing depending on them) an\n      // run a DFS starting at these points to get the order\n\n      keys.filter(function (node) {\n        return self.incomingEdges[node].length === 0;\n      }).forEach(function (n) {\n        DFS(n);\n      });\n      return result;\n    }\n  }\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/dependency-graph/lib/dep_graph.js"],"names":["createDFS","edges","leavesOnly","result","circular","currentPath","visited","DFS","currentNode","push","forEach","node","indexOf","Error","join","pop","length","DepGraph","exports","opts","nodes","outgoingEdges","incomingEdges","prototype","size","Object","keys","addNode","data","hasNode","arguments","removeNode","edgeList","key","idx","splice","hasOwnProperty","getNodeData","setNodeData","addDependency","from","to","removeDependency","clone","source","n","slice","dependenciesOf","dependantsOf","overallOrder","self","CycleDFS","filter"],"mappings":"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","sourcesContent":["/**\n * A simple dependency graph\n */\n\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n * @param circular A boolean to allow circular dependencies\n */\nfunction createDFS(edges, leavesOnly, result, circular) {\n  var currentPath = [];\n  var visited = {};\n  return function DFS(currentNode) {\n    visited[currentNode] = true;\n    currentPath.push(currentNode);\n    edges[currentNode].forEach(function (node) {\n      if (!visited[node]) {\n        DFS(node);\n      } else if (currentPath.indexOf(node) >= 0) {\n        currentPath.push(node);\n        if (!circular) {\n          throw new Error('Dependency Cycle Found: ' + currentPath.join(' -> '));\n        }\n      }\n    });\n    currentPath.pop();\n    if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {\n      result.push(currentNode);\n    }\n  };\n}\n\n/**\n * Simple Dependency Graph\n */\nvar DepGraph = exports.DepGraph = function DepGraph(opts) {\n  this.nodes = {}; // Node -> Node/Data (treated like a Set)\n  this.outgoingEdges = {}; // Node -> [Dependency Node]\n  this.incomingEdges = {}; // Node -> [Dependant Node]\n  this.circular = opts && !!opts.circular; // Allows circular deps\n};\nDepGraph.prototype = {\n  /**\n   * The number of nodes in the graph.\n   */\n  size:function () {\n    return Object.keys(this.nodes).length;\n  },\n  /**\n   * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n   */\n  addNode:function (node, data) {\n    if (!this.hasNode(node)) {\n      // Checking the arguments length allows the user to add a node with undefined data\n      if (arguments.length === 2) {\n        this.nodes[node] = data;\n      } else {\n        this.nodes[node] = node;\n      }\n      this.outgoingEdges[node] = [];\n      this.incomingEdges[node] = [];\n    }\n  },\n  /**\n   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n   */\n  removeNode:function (node) {\n    if (this.hasNode(node)) {\n      delete this.nodes[node];\n      delete this.outgoingEdges[node];\n      delete this.incomingEdges[node];\n      [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n        Object.keys(edgeList).forEach(function (key) {\n          var idx = edgeList[key].indexOf(node);\n          if (idx >= 0) {\n            edgeList[key].splice(idx, 1);\n          }\n        }, this);\n      });\n    }\n  },\n  /**\n   * Check if a node exists in the graph\n   */\n  hasNode:function (node) {\n    return this.nodes.hasOwnProperty(node);\n  },\n  /**\n   * Get the data associated with a node name\n   */\n  getNodeData:function (node) {\n    if (this.hasNode(node)) {\n      return this.nodes[node];\n    } else {\n      throw new Error('Node does not exist: ' + node);\n    }\n  },\n  /**\n   * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n   */\n  setNodeData:function (node, data) {\n    if (this.hasNode(node)) {\n      this.nodes[node] = data;\n    } else {\n      throw new Error('Node does not exist: ' + node);\n    }\n  },\n  /**\n   * Add a dependency between two nodes. If either of the nodes does not exist,\n   * an Error will be thrown.\n   */\n  addDependency:function (from, to) {\n    if (!this.hasNode(from)) {\n      throw new Error('Node does not exist: ' + from);\n    }\n    if (!this.hasNode(to)) {\n      throw new Error('Node does not exist: ' + to);\n    }\n    if (this.outgoingEdges[from].indexOf(to) === -1) {\n      this.outgoingEdges[from].push(to);\n    }\n    if (this.incomingEdges[to].indexOf(from) === -1) {\n      this.incomingEdges[to].push(from);\n    }\n    return true;\n  },\n  /**\n   * Remove a dependency between two nodes.\n   */\n  removeDependency:function (from, to) {\n    var idx;\n    if (this.hasNode(from)) {\n      idx = this.outgoingEdges[from].indexOf(to);\n      if (idx >= 0) {\n        this.outgoingEdges[from].splice(idx, 1);\n      }\n    }\n\n    if (this.hasNode(to)) {\n      idx = this.incomingEdges[to].indexOf(from);\n      if (idx >= 0) {\n        this.incomingEdges[to].splice(idx, 1);\n      }\n    }\n  },\n  /**\n   * Return a clone of the dependency graph. If any custom data is attached\n   * to the nodes, it will only be shallow copied.\n   */\n  clone:function () {\n    var source = this;\n    var result = new DepGraph();\n    var keys = Object.keys(source.nodes);\n    keys.forEach(function (n) {\n      result.nodes[n] = source.nodes[n];\n      result.outgoingEdges[n] = source.outgoingEdges[n].slice(0);\n      result.incomingEdges[n] = source.incomingEdges[n].slice(0);\n    });\n    return result;\n  },\n  /**\n   * Get an array containing the nodes that the specified node depends on (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n   * in the array.\n   */\n  dependenciesOf:function (node, leavesOnly) {\n    if (this.hasNode(node)) {\n      var result = [];\n      var DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);\n      DFS(node);\n      var idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    }\n    else {\n      throw new Error('Node does not exist: ' + node);\n    }\n  },\n  /**\n   * get an array containing the nodes that depend on the specified node (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n   */\n  dependantsOf:function (node, leavesOnly) {\n    if (this.hasNode(node)) {\n      var result = [];\n      var DFS = createDFS(this.incomingEdges, leavesOnly, result, this.circular);\n      DFS(node);\n      var idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    } else {\n      throw new Error('Node does not exist: ' + node);\n    }\n  },\n  /**\n   * Construct the overall processing order for the dependency graph.\n   *\n   * Throws an Error if the graph has a cycle.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n   */\n  overallOrder:function (leavesOnly) {\n    var self = this;\n    var result = [];\n    var keys = Object.keys(this.nodes);\n    if (keys.length === 0) {\n      return result; // Empty graph\n    } else {\n      // Look for cycles - we run the DFS starting at all the nodes in case there\n      // are several disconnected subgraphs inside this dependency graph.\n      var CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);\n      keys.forEach(function(n) {\n        CycleDFS(n);\n      });\n\n      var DFS = createDFS(this.outgoingEdges, leavesOnly, result, this.circular);\n      // Find all potential starting points (nodes with nothing depending on them) an\n      // run a DFS starting at these points to get the order\n      keys.filter(function (node) {\n        return self.incomingEdges[node].length === 0;\n      }).forEach(function (n) {\n        DFS(n);\n      });\n\n      return result;\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}