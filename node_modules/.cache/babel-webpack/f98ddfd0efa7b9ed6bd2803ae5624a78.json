{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/imports/src/references\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Reference = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n  /**\n   * A `ts.Node` plus the context in which it was discovered.\n   *\n   * A `Reference` is a pointer to a `ts.Node` that was extracted from the program somehow. It\n   * contains not only the node itself, but the information regarding how the node was located. In\n   * particular, it might track different identifiers by which the node is exposed, as well as\n   * potentially a module specifier which might expose the node.\n   *\n   * The Angular compiler uses `Reference`s instead of `ts.Node`s when tracking classes or generating\n   * imports.\n   */\n\n\n  var Reference =\n  /** @class */\n  function () {\n    function Reference(node, bestGuessOwningModule) {\n      if (bestGuessOwningModule === void 0) {\n        bestGuessOwningModule = null;\n      }\n\n      this.node = node;\n      this.identifiers = [];\n      /**\n       * Indicates that the Reference was created synthetically, not as a result of natural value\n       * resolution.\n       *\n       * This is used to avoid misinterpreting the Reference in certain contexts.\n       */\n\n      this.synthetic = false;\n      this._alias = null;\n      this.bestGuessOwningModule = bestGuessOwningModule;\n      var id = typescript_1.identifierOfNode(node);\n\n      if (id !== null) {\n        this.identifiers.push(id);\n      }\n    }\n\n    Object.defineProperty(Reference.prototype, \"ownedByModuleGuess\", {\n      /**\n       * The best guess at which module specifier owns this particular reference, or `null` if there\n       * isn't one.\n       */\n      get: function get() {\n        if (this.bestGuessOwningModule !== null) {\n          return this.bestGuessOwningModule.specifier;\n        } else {\n          return null;\n        }\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Reference.prototype, \"hasOwningModuleGuess\", {\n      /**\n       * Whether this reference has a potential owning module or not.\n       *\n       * See `bestGuessOwningModule`.\n       */\n      get: function get() {\n        return this.bestGuessOwningModule !== null;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Reference.prototype, \"debugName\", {\n      /**\n       * A name for the node, if one is available.\n       *\n       * This is only suited for debugging. Any actual references to this node should be made with\n       * `ts.Identifier`s (see `getIdentityIn`).\n       */\n      get: function get() {\n        var id = typescript_1.identifierOfNode(this.node);\n        return id !== null ? id.text : null;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(Reference.prototype, \"alias\", {\n      get: function get() {\n        return this._alias;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    /**\n     * Record a `ts.Identifier` by which it's valid to refer to this node, within the context of this\n     * `Reference`.\n     */\n\n    Reference.prototype.addIdentifier = function (identifier) {\n      this.identifiers.push(identifier);\n    };\n    /**\n     * Get a `ts.Identifier` within this `Reference` that can be used to refer within the context of a\n     * given `ts.SourceFile`, if any.\n     */\n\n\n    Reference.prototype.getIdentityIn = function (context) {\n      return this.identifiers.find(function (id) {\n        return id.getSourceFile() === context;\n      }) || null;\n    };\n    /**\n     * Get a `ts.Identifier` for this `Reference` that exists within the given expression.\n     *\n     * This is very useful for producing `ts.Diagnostic`s that reference `Reference`s that were\n     * extracted from some larger expression, as it can be used to pinpoint the `ts.Identifier` within\n     * the expression from which the `Reference` originated.\n     */\n\n\n    Reference.prototype.getIdentityInExpression = function (expr) {\n      var sf = expr.getSourceFile();\n      return this.identifiers.find(function (id) {\n        if (id.getSourceFile() !== sf) {\n          return false;\n        } // This identifier is a match if its position lies within the given expression.\n\n\n        return id.pos >= expr.pos && id.end <= expr.end;\n      }) || null;\n    };\n    /**\n     * Given the 'container' expression from which this `Reference` was extracted, produce a\n     * `ts.Expression` to use in a diagnostic which best indicates the position within the container\n     * expression that generated the `Reference`.\n     *\n     * For example, given a `Reference` to the class 'Bar' and the containing expression:\n     * `[Foo, Bar, Baz]`, this function would attempt to return the `ts.Identifier` for `Bar` within\n     * the array. This could be used to produce a nice diagnostic context:\n     *\n     * ```text\n     * [Foo, Bar, Baz]\n     *       ~~~\n     * ```\n     *\n     * If no specific node can be found, then the `fallback` expression is used, which defaults to the\n     * entire containing expression.\n     */\n\n\n    Reference.prototype.getOriginForDiagnostics = function (container, fallback) {\n      if (fallback === void 0) {\n        fallback = container;\n      }\n\n      var id = this.getIdentityInExpression(container);\n      return id !== null ? id : fallback;\n    };\n\n    Reference.prototype.cloneWithAlias = function (alias) {\n      var ref = new Reference(this.node, this.bestGuessOwningModule);\n      ref.identifiers = tslib_1.__spread(this.identifiers);\n      ref._alias = alias;\n      return ref;\n    };\n\n    Reference.prototype.cloneWithNoIdentifiers = function () {\n      var ref = new Reference(this.node, this.bestGuessOwningModule);\n      ref._alias = this._alias;\n      ref.identifiers = [];\n      return ref;\n    };\n\n    return Reference;\n  }();\n\n  exports.Reference = Reference;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/references.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {identifierOfNode} from '../../util/src/typescript';\n\nexport interface OwningModule {\n  specifier: string;\n  resolutionContext: string;\n}\n\n/**\n * A `ts.Node` plus the context in which it was discovered.\n *\n * A `Reference` is a pointer to a `ts.Node` that was extracted from the program somehow. It\n * contains not only the node itself, but the information regarding how the node was located. In\n * particular, it might track different identifiers by which the node is exposed, as well as\n * potentially a module specifier which might expose the node.\n *\n * The Angular compiler uses `Reference`s instead of `ts.Node`s when tracking classes or generating\n * imports.\n */\nexport class Reference<T extends ts.Node = ts.Node> {\n  /**\n   * The compiler's best guess at an absolute module specifier which owns this `Reference`.\n   *\n   * This is usually determined by tracking the import statements which led the compiler to a given\n   * node. If any of these imports are absolute, it's an indication that the node being imported\n   * might come from that module.\n   *\n   * It is not _guaranteed_ that the node in question is exported from its `bestGuessOwningModule` -\n   * that is mostly a convention that applies in certain package formats.\n   *\n   * If `bestGuessOwningModule` is `null`, then it's likely the node came from the current program.\n   */\n  readonly bestGuessOwningModule: OwningModule|null;\n\n  private identifiers: ts.Identifier[] = [];\n\n  /**\n   * Indicates that the Reference was created synthetically, not as a result of natural value\n   * resolution.\n   *\n   * This is used to avoid misinterpreting the Reference in certain contexts.\n   */\n  synthetic = false;\n\n  private _alias: Expression|null = null;\n\n  constructor(readonly node: T, bestGuessOwningModule: OwningModule|null = null) {\n    this.bestGuessOwningModule = bestGuessOwningModule;\n\n    const id = identifierOfNode(node);\n    if (id !== null) {\n      this.identifiers.push(id);\n    }\n  }\n\n  /**\n   * The best guess at which module specifier owns this particular reference, or `null` if there\n   * isn't one.\n   */\n  get ownedByModuleGuess(): string|null {\n    if (this.bestGuessOwningModule !== null) {\n      return this.bestGuessOwningModule.specifier;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Whether this reference has a potential owning module or not.\n   *\n   * See `bestGuessOwningModule`.\n   */\n  get hasOwningModuleGuess(): boolean {\n    return this.bestGuessOwningModule !== null;\n  }\n\n  /**\n   * A name for the node, if one is available.\n   *\n   * This is only suited for debugging. Any actual references to this node should be made with\n   * `ts.Identifier`s (see `getIdentityIn`).\n   */\n  get debugName(): string|null {\n    const id = identifierOfNode(this.node);\n    return id !== null ? id.text : null;\n  }\n\n  get alias(): Expression|null {\n    return this._alias;\n  }\n\n\n  /**\n   * Record a `ts.Identifier` by which it's valid to refer to this node, within the context of this\n   * `Reference`.\n   */\n  addIdentifier(identifier: ts.Identifier): void {\n    this.identifiers.push(identifier);\n  }\n\n  /**\n   * Get a `ts.Identifier` within this `Reference` that can be used to refer within the context of a\n   * given `ts.SourceFile`, if any.\n   */\n  getIdentityIn(context: ts.SourceFile): ts.Identifier|null {\n    return this.identifiers.find(id => id.getSourceFile() === context) || null;\n  }\n\n  /**\n   * Get a `ts.Identifier` for this `Reference` that exists within the given expression.\n   *\n   * This is very useful for producing `ts.Diagnostic`s that reference `Reference`s that were\n   * extracted from some larger expression, as it can be used to pinpoint the `ts.Identifier` within\n   * the expression from which the `Reference` originated.\n   */\n  getIdentityInExpression(expr: ts.Expression): ts.Identifier|null {\n    const sf = expr.getSourceFile();\n    return this.identifiers.find(id => {\n      if (id.getSourceFile() !== sf) {\n        return false;\n      }\n\n      // This identifier is a match if its position lies within the given expression.\n      return id.pos >= expr.pos && id.end <= expr.end;\n    }) ||\n        null;\n  }\n\n  /**\n   * Given the 'container' expression from which this `Reference` was extracted, produce a\n   * `ts.Expression` to use in a diagnostic which best indicates the position within the container\n   * expression that generated the `Reference`.\n   *\n   * For example, given a `Reference` to the class 'Bar' and the containing expression:\n   * `[Foo, Bar, Baz]`, this function would attempt to return the `ts.Identifier` for `Bar` within\n   * the array. This could be used to produce a nice diagnostic context:\n   *\n   * ```text\n   * [Foo, Bar, Baz]\n   *       ~~~\n   * ```\n   *\n   * If no specific node can be found, then the `fallback` expression is used, which defaults to the\n   * entire containing expression.\n   */\n  getOriginForDiagnostics(container: ts.Expression, fallback: ts.Expression = container):\n      ts.Expression {\n    const id = this.getIdentityInExpression(container);\n    return id !== null ? id : fallback;\n  }\n\n  cloneWithAlias(alias: Expression): Reference<T> {\n    const ref = new Reference(this.node, this.bestGuessOwningModule);\n    ref.identifiers = [...this.identifiers];\n    ref._alias = alias;\n    return ref;\n  }\n\n  cloneWithNoIdentifiers(): Reference<T> {\n    const ref = new Reference(this.node, this.bestGuessOwningModule);\n    ref._alias = this._alias;\n    ref.identifiers = [];\n    return ref;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}