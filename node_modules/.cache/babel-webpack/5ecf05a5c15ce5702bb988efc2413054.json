{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveEntryModuleFromMain = void 0;\n\nvar core_1 = require(\"@angular-devkit/core\");\n\nvar ts = require(\"typescript\");\n\nvar refactor_1 = require(\"./refactor\");\n\nfunction _recursiveSymbolExportLookup(refactor, symbolName, host, program) {\n  // Check this file.\n  var hasSymbol = refactor_1.findAstNodes(null, refactor.sourceFile, ts.isClassDeclaration).some(function (cd) {\n    return cd.name != undefined && cd.name.text == symbolName;\n  });\n\n  if (hasSymbol) {\n    return refactor.fileName;\n  } // We found the bootstrap variable, now we just need to get where it's imported.\n\n\n  var exports = refactor.findAstNodes(null, ts.SyntaxKind.ExportDeclaration).map(function (node) {\n    return node;\n  });\n\n  var _iterator = _createForOfIteratorHelper(exports),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var decl = _step.value;\n\n      if (!decl.moduleSpecifier || decl.moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {\n        continue;\n      }\n\n      var modulePath = decl.moduleSpecifier.text;\n      var resolvedModule = ts.resolveModuleName(modulePath, refactor.fileName, program.getCompilerOptions(), host);\n\n      if (!resolvedModule.resolvedModule || !resolvedModule.resolvedModule.resolvedFileName) {\n        return null;\n      }\n\n      var module = resolvedModule.resolvedModule.resolvedFileName;\n\n      if (!decl.exportClause) {\n        var moduleRefactor = new refactor_1.TypeScriptFileRefactor(module, host, program);\n\n        var maybeModule = _recursiveSymbolExportLookup(moduleRefactor, symbolName, host, program);\n\n        if (maybeModule) {\n          return maybeModule;\n        }\n\n        continue;\n      }\n\n      var binding = decl.exportClause;\n\n      var _iterator2 = _createForOfIteratorHelper(binding.elements),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var specifier = _step2.value;\n\n          if (specifier.name.text == symbolName) {\n            // If it's a directory, load its index and recursively lookup.\n            // If it's a file it will return false\n            if (host.directoryExists && host.directoryExists(module)) {\n              var indexModule = core_1.join(module, 'index.ts');\n\n              if (host.fileExists(indexModule)) {\n                var indexRefactor = new refactor_1.TypeScriptFileRefactor(indexModule, host, program);\n\n                var _maybeModule = _recursiveSymbolExportLookup(indexRefactor, symbolName, host, program);\n\n                if (_maybeModule) {\n                  return _maybeModule;\n                }\n              }\n            } // Create the source and verify that the symbol is at least a class.\n\n\n            var source = new refactor_1.TypeScriptFileRefactor(module, host, program);\n\n            var _hasSymbol = refactor_1.findAstNodes(null, source.sourceFile, ts.isClassDeclaration).some(function (cd) {\n              return cd.name != undefined && cd.name.text == symbolName;\n            });\n\n            if (_hasSymbol) {\n              return module;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n}\n\nfunction _symbolImportLookup(refactor, symbolName, host, program) {\n  // We found the bootstrap variable, now we just need to get where it's imported.\n  var imports = refactor.findAstNodes(null, ts.SyntaxKind.ImportDeclaration).map(function (node) {\n    return node;\n  });\n\n  var _iterator3 = _createForOfIteratorHelper(imports),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var decl = _step3.value;\n\n      if (!decl.importClause || !decl.moduleSpecifier) {\n        continue;\n      }\n\n      if (decl.moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {\n        continue;\n      }\n\n      var resolvedModule = ts.resolveModuleName(decl.moduleSpecifier.text, refactor.fileName, program.getCompilerOptions(), host);\n\n      if (!resolvedModule.resolvedModule || !resolvedModule.resolvedModule.resolvedFileName) {\n        continue;\n      }\n\n      var module = resolvedModule.resolvedModule.resolvedFileName;\n\n      if (decl.importClause.namedBindings && decl.importClause.namedBindings.kind == ts.SyntaxKind.NamespaceImport) {\n        var binding = decl.importClause.namedBindings;\n\n        if (binding.name.text == symbolName) {\n          // This is a default export.\n          return module;\n        }\n      } else if (decl.importClause.namedBindings && decl.importClause.namedBindings.kind == ts.SyntaxKind.NamedImports) {\n        var _binding = decl.importClause.namedBindings;\n\n        var _iterator4 = _createForOfIteratorHelper(_binding.elements),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var specifier = _step4.value;\n\n            if (specifier.name.text == symbolName) {\n              // Create the source and recursively lookup the import.\n              var source = new refactor_1.TypeScriptFileRefactor(module, host, program);\n\n              var maybeModule = _recursiveSymbolExportLookup(source, symbolName, host, program);\n\n              if (maybeModule) {\n                return maybeModule;\n              }\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return null;\n}\n\nfunction resolveEntryModuleFromMain(mainPath, host, program) {\n  var source = new refactor_1.TypeScriptFileRefactor(mainPath, host, program);\n  var bootstrap = source.findAstNodes(source.sourceFile, ts.SyntaxKind.CallExpression, true).map(function (node) {\n    return node;\n  }).filter(function (call) {\n    var access = call.expression;\n    return access.kind == ts.SyntaxKind.PropertyAccessExpression && access.name.kind == ts.SyntaxKind.Identifier && (access.name.text == 'bootstrapModule' || access.name.text == 'bootstrapModuleFactory');\n  }).map(function (node) {\n    return node.arguments[0];\n  }).filter(function (node) {\n    return node.kind == ts.SyntaxKind.Identifier;\n  });\n\n  if (bootstrap.length === 1) {\n    var bootstrapSymbolName = bootstrap[0].text;\n\n    var module = _symbolImportLookup(source, bootstrapSymbolName, host, program);\n\n    if (module) {\n      return \"\".concat(module.replace(/\\.ts$/, ''), \"#\").concat(bootstrapSymbolName);\n    }\n  }\n\n  return null;\n}\n\nexports.resolveEntryModuleFromMain = resolveEntryModuleFromMain;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/entry_resolver.js"],"names":["Object","defineProperty","exports","value","resolveEntryModuleFromMain","core_1","require","ts","refactor_1","_recursiveSymbolExportLookup","refactor","symbolName","host","program","hasSymbol","findAstNodes","sourceFile","isClassDeclaration","some","cd","name","undefined","text","fileName","SyntaxKind","ExportDeclaration","map","node","decl","moduleSpecifier","kind","StringLiteral","modulePath","resolvedModule","resolveModuleName","getCompilerOptions","resolvedFileName","module","exportClause","moduleRefactor","TypeScriptFileRefactor","maybeModule","binding","elements","specifier","directoryExists","indexModule","join","fileExists","indexRefactor","source","_symbolImportLookup","imports","ImportDeclaration","importClause","namedBindings","NamespaceImport","NamedImports","mainPath","bootstrap","CallExpression","filter","call","access","expression","PropertyAccessExpression","Identifier","arguments","length","bootstrapSymbolName","replace"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,0BAAR,GAAqC,KAAK,CAA1C;;AACA,IAAMC,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAAtB;;AACA,IAAMC,EAAE,GAAGD,OAAO,CAAC,YAAD,CAAlB;;AACA,IAAME,UAAU,GAAGF,OAAO,CAAC,YAAD,CAA1B;;AACA,SAASG,4BAAT,CAAsCC,QAAtC,EAAgDC,UAAhD,EAA4DC,IAA5D,EAAkEC,OAAlE,EAA2E;AACvE;AACA,MAAMC,SAAS,GAAGN,UAAU,CAACO,YAAX,CAAwB,IAAxB,EAA8BL,QAAQ,CAACM,UAAvC,EAAmDT,EAAE,CAACU,kBAAtD,EACbC,IADa,CACR,UAACC,EAAD,EAAQ;AACd,WAAOA,EAAE,CAACC,IAAH,IAAWC,SAAX,IAAwBF,EAAE,CAACC,IAAH,CAAQE,IAAR,IAAgBX,UAA/C;AACH,GAHiB,CAAlB;;AAIA,MAAIG,SAAJ,EAAe;AACX,WAAOJ,QAAQ,CAACa,QAAhB;AACH,GARsE,CASvE;;;AACA,MAAMrB,OAAO,GAAGQ,QAAQ,CAACK,YAAT,CAAsB,IAAtB,EAA4BR,EAAE,CAACiB,UAAH,CAAcC,iBAA1C,EACXC,GADW,CACP,UAAAC,IAAI;AAAA,WAAIA,IAAJ;AAAA,GADG,CAAhB;;AAVuE,6CAYpDzB,OAZoD;AAAA;;AAAA;AAYvE,wDAA4B;AAAA,UAAjB0B,IAAiB;;AACxB,UAAI,CAACA,IAAI,CAACC,eAAN,IAAyBD,IAAI,CAACC,eAAL,CAAqBC,IAArB,KAA8BvB,EAAE,CAACiB,UAAH,CAAcO,aAAzE,EAAwF;AACpF;AACH;;AACD,UAAMC,UAAU,GAAGJ,IAAI,CAACC,eAAL,CAAqBP,IAAxC;AACA,UAAMW,cAAc,GAAG1B,EAAE,CAAC2B,iBAAH,CAAqBF,UAArB,EAAiCtB,QAAQ,CAACa,QAA1C,EAAoDV,OAAO,CAACsB,kBAAR,EAApD,EAAkFvB,IAAlF,CAAvB;;AACA,UAAI,CAACqB,cAAc,CAACA,cAAhB,IAAkC,CAACA,cAAc,CAACA,cAAf,CAA8BG,gBAArE,EAAuF;AACnF,eAAO,IAAP;AACH;;AACD,UAAMC,MAAM,GAAGJ,cAAc,CAACA,cAAf,CAA8BG,gBAA7C;;AACA,UAAI,CAACR,IAAI,CAACU,YAAV,EAAwB;AACpB,YAAMC,cAAc,GAAG,IAAI/B,UAAU,CAACgC,sBAAf,CAAsCH,MAAtC,EAA8CzB,IAA9C,EAAoDC,OAApD,CAAvB;;AACA,YAAM4B,WAAW,GAAGhC,4BAA4B,CAAC8B,cAAD,EAAiB5B,UAAjB,EAA6BC,IAA7B,EAAmCC,OAAnC,CAAhD;;AACA,YAAI4B,WAAJ,EAAiB;AACb,iBAAOA,WAAP;AACH;;AACD;AACH;;AACD,UAAMC,OAAO,GAAGd,IAAI,CAACU,YAArB;;AAlBwB,kDAmBAI,OAAO,CAACC,QAnBR;AAAA;;AAAA;AAmBxB,+DAA0C;AAAA,cAA/BC,SAA+B;;AACtC,cAAIA,SAAS,CAACxB,IAAV,CAAeE,IAAf,IAAuBX,UAA3B,EAAuC;AACnC;AACA;AACA,gBAAIC,IAAI,CAACiC,eAAL,IAAwBjC,IAAI,CAACiC,eAAL,CAAqBR,MAArB,CAA5B,EAA0D;AACtD,kBAAMS,WAAW,GAAGzC,MAAM,CAAC0C,IAAP,CAAYV,MAAZ,EAAoB,UAApB,CAApB;;AACA,kBAAIzB,IAAI,CAACoC,UAAL,CAAgBF,WAAhB,CAAJ,EAAkC;AAC9B,oBAAMG,aAAa,GAAG,IAAIzC,UAAU,CAACgC,sBAAf,CAAsCM,WAAtC,EAAmDlC,IAAnD,EAAyDC,OAAzD,CAAtB;;AACA,oBAAM4B,YAAW,GAAGhC,4BAA4B,CAACwC,aAAD,EAAgBtC,UAAhB,EAA4BC,IAA5B,EAAkCC,OAAlC,CAAhD;;AACA,oBAAI4B,YAAJ,EAAiB;AACb,yBAAOA,YAAP;AACH;AACJ;AACJ,aAZkC,CAanC;;;AACA,gBAAMS,MAAM,GAAG,IAAI1C,UAAU,CAACgC,sBAAf,CAAsCH,MAAtC,EAA8CzB,IAA9C,EAAoDC,OAApD,CAAf;;AACA,gBAAMC,UAAS,GAAGN,UAAU,CAACO,YAAX,CAAwB,IAAxB,EAA8BmC,MAAM,CAAClC,UAArC,EAAiDT,EAAE,CAACU,kBAApD,EACbC,IADa,CACR,UAACC,EAAD,EAAQ;AACd,qBAAOA,EAAE,CAACC,IAAH,IAAWC,SAAX,IAAwBF,EAAE,CAACC,IAAH,CAAQE,IAAR,IAAgBX,UAA/C;AACH,aAHiB,CAAlB;;AAIA,gBAAIG,UAAJ,EAAe;AACX,qBAAOuB,MAAP;AACH;AACJ;AACJ;AA3CuB;AAAA;AAAA;AAAA;AAAA;AA4C3B;AAxDsE;AAAA;AAAA;AAAA;AAAA;;AAyDvE,SAAO,IAAP;AACH;;AACD,SAASc,mBAAT,CAA6BzC,QAA7B,EAAuCC,UAAvC,EAAmDC,IAAnD,EAAyDC,OAAzD,EAAkE;AAC9D;AACA,MAAMuC,OAAO,GAAG1C,QAAQ,CAACK,YAAT,CAAsB,IAAtB,EAA4BR,EAAE,CAACiB,UAAH,CAAc6B,iBAA1C,EACX3B,GADW,CACP,UAAAC,IAAI;AAAA,WAAIA,IAAJ;AAAA,GADG,CAAhB;;AAF8D,8CAI3CyB,OAJ2C;AAAA;;AAAA;AAI9D,2DAA4B;AAAA,UAAjBxB,IAAiB;;AACxB,UAAI,CAACA,IAAI,CAAC0B,YAAN,IAAsB,CAAC1B,IAAI,CAACC,eAAhC,EAAiD;AAC7C;AACH;;AACD,UAAID,IAAI,CAACC,eAAL,CAAqBC,IAArB,KAA8BvB,EAAE,CAACiB,UAAH,CAAcO,aAAhD,EAA+D;AAC3D;AACH;;AACD,UAAME,cAAc,GAAG1B,EAAE,CAAC2B,iBAAH,CAAqBN,IAAI,CAACC,eAAL,CAAqBP,IAA1C,EAAgDZ,QAAQ,CAACa,QAAzD,EAAmEV,OAAO,CAACsB,kBAAR,EAAnE,EAAiGvB,IAAjG,CAAvB;;AACA,UAAI,CAACqB,cAAc,CAACA,cAAhB,IAAkC,CAACA,cAAc,CAACA,cAAf,CAA8BG,gBAArE,EAAuF;AACnF;AACH;;AACD,UAAMC,MAAM,GAAGJ,cAAc,CAACA,cAAf,CAA8BG,gBAA7C;;AACA,UAAIR,IAAI,CAAC0B,YAAL,CAAkBC,aAAlB,IACG3B,IAAI,CAAC0B,YAAL,CAAkBC,aAAlB,CAAgCzB,IAAhC,IAAwCvB,EAAE,CAACiB,UAAH,CAAcgC,eAD7D,EAC8E;AAC1E,YAAMd,OAAO,GAAGd,IAAI,CAAC0B,YAAL,CAAkBC,aAAlC;;AACA,YAAIb,OAAO,CAACtB,IAAR,CAAaE,IAAb,IAAqBX,UAAzB,EAAqC;AACjC;AACA,iBAAO0B,MAAP;AACH;AACJ,OAPD,MAQK,IAAIT,IAAI,CAAC0B,YAAL,CAAkBC,aAAlB,IACF3B,IAAI,CAAC0B,YAAL,CAAkBC,aAAlB,CAAgCzB,IAAhC,IAAwCvB,EAAE,CAACiB,UAAH,CAAciC,YADxD,EACsE;AACvE,YAAMf,QAAO,GAAGd,IAAI,CAAC0B,YAAL,CAAkBC,aAAlC;;AADuE,oDAE/Cb,QAAO,CAACC,QAFuC;AAAA;;AAAA;AAEvE,iEAA0C;AAAA,gBAA/BC,SAA+B;;AACtC,gBAAIA,SAAS,CAACxB,IAAV,CAAeE,IAAf,IAAuBX,UAA3B,EAAuC;AACnC;AACA,kBAAMuC,MAAM,GAAG,IAAI1C,UAAU,CAACgC,sBAAf,CAAsCH,MAAtC,EAA8CzB,IAA9C,EAAoDC,OAApD,CAAf;;AACA,kBAAM4B,WAAW,GAAGhC,4BAA4B,CAACyC,MAAD,EAASvC,UAAT,EAAqBC,IAArB,EAA2BC,OAA3B,CAAhD;;AACA,kBAAI4B,WAAJ,EAAiB;AACb,uBAAOA,WAAP;AACH;AACJ;AACJ;AAXsE;AAAA;AAAA;AAAA;AAAA;AAY1E;AACJ;AAtC6D;AAAA;AAAA;AAAA;AAAA;;AAuC9D,SAAO,IAAP;AACH;;AACD,SAASrC,0BAAT,CAAoCsD,QAApC,EAA8C9C,IAA9C,EAAoDC,OAApD,EAA6D;AACzD,MAAMqC,MAAM,GAAG,IAAI1C,UAAU,CAACgC,sBAAf,CAAsCkB,QAAtC,EAAgD9C,IAAhD,EAAsDC,OAAtD,CAAf;AACA,MAAM8C,SAAS,GAAGT,MAAM,CAACnC,YAAP,CAAoBmC,MAAM,CAAClC,UAA3B,EAAuCT,EAAE,CAACiB,UAAH,CAAcoC,cAArD,EAAqE,IAArE,EACblC,GADa,CACT,UAAAC,IAAI;AAAA,WAAIA,IAAJ;AAAA,GADK,EAEbkC,MAFa,CAEN,UAAAC,IAAI,EAAI;AAChB,QAAMC,MAAM,GAAGD,IAAI,CAACE,UAApB;AACA,WAAOD,MAAM,CAACjC,IAAP,IAAevB,EAAE,CAACiB,UAAH,CAAcyC,wBAA7B,IACAF,MAAM,CAAC3C,IAAP,CAAYU,IAAZ,IAAoBvB,EAAE,CAACiB,UAAH,CAAc0C,UADlC,KAECH,MAAM,CAAC3C,IAAP,CAAYE,IAAZ,IAAoB,iBAApB,IACGyC,MAAM,CAAC3C,IAAP,CAAYE,IAAZ,IAAoB,wBAHxB,CAAP;AAIH,GARiB,EASbI,GATa,CAST,UAAAC,IAAI;AAAA,WAAIA,IAAI,CAACwC,SAAL,CAAe,CAAf,CAAJ;AAAA,GATK,EAUbN,MAVa,CAUN,UAAAlC,IAAI;AAAA,WAAIA,IAAI,CAACG,IAAL,IAAavB,EAAE,CAACiB,UAAH,CAAc0C,UAA/B;AAAA,GAVE,CAAlB;;AAWA,MAAIP,SAAS,CAACS,MAAV,KAAqB,CAAzB,EAA4B;AACxB,QAAMC,mBAAmB,GAAGV,SAAS,CAAC,CAAD,CAAT,CAAarC,IAAzC;;AACA,QAAMe,MAAM,GAAGc,mBAAmB,CAACD,MAAD,EAASmB,mBAAT,EAA8BzD,IAA9B,EAAoCC,OAApC,CAAlC;;AACA,QAAIwB,MAAJ,EAAY;AACR,uBAAUA,MAAM,CAACiC,OAAP,CAAe,OAAf,EAAwB,EAAxB,CAAV,cAAyCD,mBAAzC;AACH;AACJ;;AACD,SAAO,IAAP;AACH;;AACDnE,OAAO,CAACE,0BAAR,GAAqCA,0BAArC","sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveEntryModuleFromMain = void 0;\nconst core_1 = require(\"@angular-devkit/core\");\nconst ts = require(\"typescript\");\nconst refactor_1 = require(\"./refactor\");\nfunction _recursiveSymbolExportLookup(refactor, symbolName, host, program) {\n    // Check this file.\n    const hasSymbol = refactor_1.findAstNodes(null, refactor.sourceFile, ts.isClassDeclaration)\n        .some((cd) => {\n        return cd.name != undefined && cd.name.text == symbolName;\n    });\n    if (hasSymbol) {\n        return refactor.fileName;\n    }\n    // We found the bootstrap variable, now we just need to get where it's imported.\n    const exports = refactor.findAstNodes(null, ts.SyntaxKind.ExportDeclaration)\n        .map(node => node);\n    for (const decl of exports) {\n        if (!decl.moduleSpecifier || decl.moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {\n            continue;\n        }\n        const modulePath = decl.moduleSpecifier.text;\n        const resolvedModule = ts.resolveModuleName(modulePath, refactor.fileName, program.getCompilerOptions(), host);\n        if (!resolvedModule.resolvedModule || !resolvedModule.resolvedModule.resolvedFileName) {\n            return null;\n        }\n        const module = resolvedModule.resolvedModule.resolvedFileName;\n        if (!decl.exportClause) {\n            const moduleRefactor = new refactor_1.TypeScriptFileRefactor(module, host, program);\n            const maybeModule = _recursiveSymbolExportLookup(moduleRefactor, symbolName, host, program);\n            if (maybeModule) {\n                return maybeModule;\n            }\n            continue;\n        }\n        const binding = decl.exportClause;\n        for (const specifier of binding.elements) {\n            if (specifier.name.text == symbolName) {\n                // If it's a directory, load its index and recursively lookup.\n                // If it's a file it will return false\n                if (host.directoryExists && host.directoryExists(module)) {\n                    const indexModule = core_1.join(module, 'index.ts');\n                    if (host.fileExists(indexModule)) {\n                        const indexRefactor = new refactor_1.TypeScriptFileRefactor(indexModule, host, program);\n                        const maybeModule = _recursiveSymbolExportLookup(indexRefactor, symbolName, host, program);\n                        if (maybeModule) {\n                            return maybeModule;\n                        }\n                    }\n                }\n                // Create the source and verify that the symbol is at least a class.\n                const source = new refactor_1.TypeScriptFileRefactor(module, host, program);\n                const hasSymbol = refactor_1.findAstNodes(null, source.sourceFile, ts.isClassDeclaration)\n                    .some((cd) => {\n                    return cd.name != undefined && cd.name.text == symbolName;\n                });\n                if (hasSymbol) {\n                    return module;\n                }\n            }\n        }\n    }\n    return null;\n}\nfunction _symbolImportLookup(refactor, symbolName, host, program) {\n    // We found the bootstrap variable, now we just need to get where it's imported.\n    const imports = refactor.findAstNodes(null, ts.SyntaxKind.ImportDeclaration)\n        .map(node => node);\n    for (const decl of imports) {\n        if (!decl.importClause || !decl.moduleSpecifier) {\n            continue;\n        }\n        if (decl.moduleSpecifier.kind !== ts.SyntaxKind.StringLiteral) {\n            continue;\n        }\n        const resolvedModule = ts.resolveModuleName(decl.moduleSpecifier.text, refactor.fileName, program.getCompilerOptions(), host);\n        if (!resolvedModule.resolvedModule || !resolvedModule.resolvedModule.resolvedFileName) {\n            continue;\n        }\n        const module = resolvedModule.resolvedModule.resolvedFileName;\n        if (decl.importClause.namedBindings\n            && decl.importClause.namedBindings.kind == ts.SyntaxKind.NamespaceImport) {\n            const binding = decl.importClause.namedBindings;\n            if (binding.name.text == symbolName) {\n                // This is a default export.\n                return module;\n            }\n        }\n        else if (decl.importClause.namedBindings\n            && decl.importClause.namedBindings.kind == ts.SyntaxKind.NamedImports) {\n            const binding = decl.importClause.namedBindings;\n            for (const specifier of binding.elements) {\n                if (specifier.name.text == symbolName) {\n                    // Create the source and recursively lookup the import.\n                    const source = new refactor_1.TypeScriptFileRefactor(module, host, program);\n                    const maybeModule = _recursiveSymbolExportLookup(source, symbolName, host, program);\n                    if (maybeModule) {\n                        return maybeModule;\n                    }\n                }\n            }\n        }\n    }\n    return null;\n}\nfunction resolveEntryModuleFromMain(mainPath, host, program) {\n    const source = new refactor_1.TypeScriptFileRefactor(mainPath, host, program);\n    const bootstrap = source.findAstNodes(source.sourceFile, ts.SyntaxKind.CallExpression, true)\n        .map(node => node)\n        .filter(call => {\n        const access = call.expression;\n        return access.kind == ts.SyntaxKind.PropertyAccessExpression\n            && access.name.kind == ts.SyntaxKind.Identifier\n            && (access.name.text == 'bootstrapModule'\n                || access.name.text == 'bootstrapModuleFactory');\n    })\n        .map(node => node.arguments[0])\n        .filter(node => node.kind == ts.SyntaxKind.Identifier);\n    if (bootstrap.length === 1) {\n        const bootstrapSymbolName = bootstrap[0].text;\n        const module = _symbolImportLookup(source, bootstrapSymbolName, host, program);\n        if (module) {\n            return `${module.replace(/\\.ts$/, '')}#${bootstrapSymbolName}`;\n        }\n    }\n    return null;\n}\nexports.resolveEntryModuleFromMain = resolveEntryModuleFromMain;\n"]},"metadata":{},"sourceType":"script"}