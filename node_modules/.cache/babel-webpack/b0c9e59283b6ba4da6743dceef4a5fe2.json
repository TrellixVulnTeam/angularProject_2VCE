{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/translator/src/type_translator\", [\"require\", \"exports\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/translator/src/context\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeTranslatorVisitor = exports.translateType = void 0;\n\n  var o = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var context_1 = require(\"@angular/compiler-cli/src/ngtsc/translator/src/context\");\n\n  function translateType(type, imports) {\n    return type.visitType(new TypeTranslatorVisitor(imports), new context_1.Context(false));\n  }\n\n  exports.translateType = translateType;\n\n  var TypeTranslatorVisitor =\n  /** @class */\n  function () {\n    function TypeTranslatorVisitor(imports) {\n      this.imports = imports;\n    }\n\n    TypeTranslatorVisitor.prototype.visitBuiltinType = function (type, context) {\n      switch (type.name) {\n        case o.BuiltinTypeName.Bool:\n          return ts.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n\n        case o.BuiltinTypeName.Dynamic:\n          return ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n\n        case o.BuiltinTypeName.Int:\n        case o.BuiltinTypeName.Number:\n          return ts.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n\n        case o.BuiltinTypeName.String:\n          return ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n\n        case o.BuiltinTypeName.None:\n          return ts.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\n\n        default:\n          throw new Error(\"Unsupported builtin type: \" + o.BuiltinTypeName[type.name]);\n      }\n    };\n\n    TypeTranslatorVisitor.prototype.visitExpressionType = function (type, context) {\n      var _this = this;\n\n      var typeNode = this.translateExpression(type.value, context);\n\n      if (type.typeParams === null) {\n        return typeNode;\n      }\n\n      if (!ts.isTypeReferenceNode(typeNode)) {\n        throw new Error('An ExpressionType with type arguments must translate into a TypeReferenceNode');\n      } else if (typeNode.typeArguments !== undefined) {\n        throw new Error(\"An ExpressionType with type arguments cannot have multiple levels of type arguments\");\n      }\n\n      var typeArgs = type.typeParams.map(function (param) {\n        return _this.translateType(param, context);\n      });\n      return ts.createTypeReferenceNode(typeNode.typeName, typeArgs);\n    };\n\n    TypeTranslatorVisitor.prototype.visitArrayType = function (type, context) {\n      return ts.createArrayTypeNode(this.translateType(type.of, context));\n    };\n\n    TypeTranslatorVisitor.prototype.visitMapType = function (type, context) {\n      var parameter = ts.createParameter(undefined, undefined, undefined, 'key', undefined, ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword));\n      var typeArgs = type.valueType !== null ? this.translateType(type.valueType, context) : ts.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n      var indexSignature = ts.createIndexSignature(undefined, undefined, [parameter], typeArgs);\n      return ts.createTypeLiteralNode([indexSignature]);\n    };\n\n    TypeTranslatorVisitor.prototype.visitReadVarExpr = function (ast, context) {\n      if (ast.name === null) {\n        throw new Error(\"ReadVarExpr with no variable name in type\");\n      }\n\n      return ts.createTypeQueryNode(ts.createIdentifier(ast.name));\n    };\n\n    TypeTranslatorVisitor.prototype.visitWriteVarExpr = function (expr, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitWriteKeyExpr = function (expr, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitWritePropExpr = function (expr, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitTaggedTemplateExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitInstantiateExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitLiteralExpr = function (ast, context) {\n      if (ast.value === null) {\n        return ts.createLiteralTypeNode(ts.createNull());\n      } else if (ast.value === undefined) {\n        return ts.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n      } else if (typeof ast.value === 'boolean') {\n        return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n      } else if (typeof ast.value === 'number') {\n        return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n      } else {\n        return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n      }\n    };\n\n    TypeTranslatorVisitor.prototype.visitLocalizedString = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitExternalExpr = function (ast, context) {\n      var _this = this;\n\n      if (ast.value.moduleName === null || ast.value.name === null) {\n        throw new Error(\"Import unknown module or symbol\");\n      }\n\n      var _a = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name),\n          moduleImport = _a.moduleImport,\n          symbol = _a.symbol;\n\n      var symbolIdentifier = ts.createIdentifier(symbol);\n      var typeName = moduleImport ? ts.createQualifiedName(moduleImport, symbolIdentifier) : symbolIdentifier;\n      var typeArguments = ast.typeParams !== null ? ast.typeParams.map(function (type) {\n        return _this.translateType(type, context);\n      }) : undefined;\n      return ts.createTypeReferenceNode(typeName, typeArguments);\n    };\n\n    TypeTranslatorVisitor.prototype.visitConditionalExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitNotExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitAssertNotNullExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitCastExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitFunctionExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitUnaryOperatorExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitReadPropExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitReadKeyExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n      var _this = this;\n\n      var values = ast.entries.map(function (expr) {\n        return _this.translateExpression(expr, context);\n      });\n      return ts.createTupleTypeNode(values);\n    };\n\n    TypeTranslatorVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n      var _this = this;\n\n      var entries = ast.entries.map(function (entry) {\n        var key = entry.key,\n            quoted = entry.quoted;\n\n        var type = _this.translateExpression(entry.value, context);\n\n        return ts.createPropertySignature(\n        /* modifiers */\n        undefined,\n        /* name */\n        quoted ? ts.createStringLiteral(key) : key,\n        /* questionToken */\n        undefined,\n        /* type */\n        type,\n        /* initializer */\n        undefined);\n      });\n      return ts.createTypeLiteralNode(entries);\n    };\n\n    TypeTranslatorVisitor.prototype.visitCommaExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    TypeTranslatorVisitor.prototype.visitWrappedNodeExpr = function (ast, context) {\n      var node = ast.node;\n\n      if (ts.isEntityName(node)) {\n        return ts.createTypeReferenceNode(node,\n        /* typeArguments */\n        undefined);\n      } else if (ts.isTypeNode(node)) {\n        return node;\n      } else if (ts.isLiteralExpression(node)) {\n        return ts.createLiteralTypeNode(node);\n      } else {\n        throw new Error(\"Unsupported WrappedNodeExpr in TypeTranslatorVisitor: \" + ts.SyntaxKind[node.kind]);\n      }\n    };\n\n    TypeTranslatorVisitor.prototype.visitTypeofExpr = function (ast, context) {\n      var typeNode = this.translateExpression(ast.expr, context);\n\n      if (!ts.isTypeReferenceNode(typeNode)) {\n        throw new Error(\"The target of a typeof expression must be a type reference, but it was\\n          \" + ts.SyntaxKind[typeNode.kind]);\n      }\n\n      return ts.createTypeQueryNode(typeNode.typeName);\n    };\n\n    TypeTranslatorVisitor.prototype.translateType = function (type, context) {\n      var typeNode = type.visitType(this, context);\n\n      if (!ts.isTypeNode(typeNode)) {\n        throw new Error(\"A Type must translate to a TypeNode, but was \" + ts.SyntaxKind[typeNode.kind]);\n      }\n\n      return typeNode;\n    };\n\n    TypeTranslatorVisitor.prototype.translateExpression = function (expr, context) {\n      var typeNode = expr.visitExpression(this, context);\n\n      if (!ts.isTypeNode(typeNode)) {\n        throw new Error(\"An Expression must translate to a TypeNode, but was \" + ts.SyntaxKind[typeNode.kind]);\n      }\n\n      return typeNode;\n    };\n\n    return TypeTranslatorVisitor;\n  }();\n\n  exports.TypeTranslatorVisitor = TypeTranslatorVisitor;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/type_translator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Context} from './context';\nimport {ImportManager} from './import_manager';\n\n\nexport function translateType(type: o.Type, imports: ImportManager): ts.TypeNode {\n  return type.visitType(new TypeTranslatorVisitor(imports), new Context(false));\n}\n\nexport class TypeTranslatorVisitor implements o.ExpressionVisitor, o.TypeVisitor {\n  constructor(private imports: ImportManager) {}\n\n  visitBuiltinType(type: o.BuiltinType, context: Context): ts.KeywordTypeNode {\n    switch (type.name) {\n      case o.BuiltinTypeName.Bool:\n        return ts.createKeywordTypeNode(ts.SyntaxKind.BooleanKeyword);\n      case o.BuiltinTypeName.Dynamic:\n        return ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword);\n      case o.BuiltinTypeName.Int:\n      case o.BuiltinTypeName.Number:\n        return ts.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword);\n      case o.BuiltinTypeName.String:\n        return ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);\n      case o.BuiltinTypeName.None:\n        return ts.createKeywordTypeNode(ts.SyntaxKind.NeverKeyword);\n      default:\n        throw new Error(`Unsupported builtin type: ${o.BuiltinTypeName[type.name]}`);\n    }\n  }\n\n  visitExpressionType(type: o.ExpressionType, context: Context): ts.TypeNode {\n    const typeNode = this.translateExpression(type.value, context);\n    if (type.typeParams === null) {\n      return typeNode;\n    }\n\n    if (!ts.isTypeReferenceNode(typeNode)) {\n      throw new Error(\n          'An ExpressionType with type arguments must translate into a TypeReferenceNode');\n    } else if (typeNode.typeArguments !== undefined) {\n      throw new Error(\n          `An ExpressionType with type arguments cannot have multiple levels of type arguments`);\n    }\n\n    const typeArgs = type.typeParams.map(param => this.translateType(param, context));\n    return ts.createTypeReferenceNode(typeNode.typeName, typeArgs);\n  }\n\n  visitArrayType(type: o.ArrayType, context: Context): ts.ArrayTypeNode {\n    return ts.createArrayTypeNode(this.translateType(type.of, context));\n  }\n\n  visitMapType(type: o.MapType, context: Context): ts.TypeLiteralNode {\n    const parameter = ts.createParameter(\n        undefined, undefined, undefined, 'key', undefined,\n        ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword));\n    const typeArgs = type.valueType !== null ?\n        this.translateType(type.valueType, context) :\n        ts.createKeywordTypeNode(ts.SyntaxKind.UnknownKeyword);\n    const indexSignature = ts.createIndexSignature(undefined, undefined, [parameter], typeArgs);\n    return ts.createTypeLiteralNode([indexSignature]);\n  }\n\n  visitReadVarExpr(ast: o.ReadVarExpr, context: Context): ts.TypeQueryNode {\n    if (ast.name === null) {\n      throw new Error(`ReadVarExpr with no variable name in type`);\n    }\n    return ts.createTypeQueryNode(ts.createIdentifier(ast.name));\n  }\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWritePropExpr(expr: o.WritePropExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeMethodExpr(ast: o.InvokeMethodExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInvokeFunctionExpr(ast: o.InvokeFunctionExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitTaggedTemplateExpr(ast: o.TaggedTemplateExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInstantiateExpr(ast: o.InstantiateExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, context: Context): ts.TypeNode {\n    if (ast.value === null) {\n      return ts.createLiteralTypeNode(ts.createNull());\n    } else if (ast.value === undefined) {\n      return ts.createKeywordTypeNode(ts.SyntaxKind.UndefinedKeyword);\n    } else if (typeof ast.value === 'boolean') {\n      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n    } else if (typeof ast.value === 'number') {\n      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n    } else {\n      return ts.createLiteralTypeNode(ts.createLiteral(ast.value));\n    }\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr, context: Context): ts.EntityName|ts.TypeReferenceNode {\n    if (ast.value.moduleName === null || ast.value.name === null) {\n      throw new Error(`Import unknown module or symbol`);\n    }\n    const {moduleImport, symbol} =\n        this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n    const symbolIdentifier = ts.createIdentifier(symbol);\n\n    const typeName =\n        moduleImport ? ts.createQualifiedName(moduleImport, symbolIdentifier) : symbolIdentifier;\n\n    const typeArguments = ast.typeParams !== null ?\n        ast.typeParams.map(type => this.translateType(type, context)) :\n        undefined;\n    return ts.createTypeReferenceNode(typeName, typeArguments);\n  }\n\n  visitConditionalExpr(ast: o.ConditionalExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitNotExpr(ast: o.NotExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitAssertNotNullExpr(ast: o.AssertNotNull, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitCastExpr(ast: o.CastExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitFunctionExpr(ast: o.FunctionExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitReadKeyExpr(ast: o.ReadKeyExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: Context): ts.TupleTypeNode {\n    const values = ast.entries.map(expr => this.translateExpression(expr, context));\n    return ts.createTupleTypeNode(values);\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: Context): ts.TypeLiteralNode {\n    const entries = ast.entries.map(entry => {\n      const {key, quoted} = entry;\n      const type = this.translateExpression(entry.value, context);\n      return ts.createPropertySignature(\n          /* modifiers */ undefined,\n          /* name */ quoted ? ts.createStringLiteral(key) : key,\n          /* questionToken */ undefined,\n          /* type */ type,\n          /* initializer */ undefined);\n    });\n    return ts.createTypeLiteralNode(entries);\n  }\n\n  visitCommaExpr(ast: o.CommaExpr, context: Context) {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, context: Context): ts.TypeNode {\n    const node: ts.Node = ast.node;\n    if (ts.isEntityName(node)) {\n      return ts.createTypeReferenceNode(node, /* typeArguments */ undefined);\n    } else if (ts.isTypeNode(node)) {\n      return node;\n    } else if (ts.isLiteralExpression(node)) {\n      return ts.createLiteralTypeNode(node);\n    } else {\n      throw new Error(\n          `Unsupported WrappedNodeExpr in TypeTranslatorVisitor: ${ts.SyntaxKind[node.kind]}`);\n    }\n  }\n\n  visitTypeofExpr(ast: o.TypeofExpr, context: Context): ts.TypeQueryNode {\n    const typeNode = this.translateExpression(ast.expr, context);\n    if (!ts.isTypeReferenceNode(typeNode)) {\n      throw new Error(`The target of a typeof expression must be a type reference, but it was\n          ${ts.SyntaxKind[typeNode.kind]}`);\n    }\n    return ts.createTypeQueryNode(typeNode.typeName);\n  }\n\n  private translateType(type: o.Type, context: Context): ts.TypeNode {\n    const typeNode = type.visitType(this, context);\n    if (!ts.isTypeNode(typeNode)) {\n      throw new Error(\n          `A Type must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);\n    }\n    return typeNode;\n  }\n\n  private translateExpression(expr: o.Expression, context: Context): ts.TypeNode {\n    const typeNode = expr.visitExpression(this, context);\n    if (!ts.isTypeNode(typeNode)) {\n      throw new Error(\n          `An Expression must translate to a TypeNode, but was ${ts.SyntaxKind[typeNode.kind]}`);\n    }\n    return typeNode;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}