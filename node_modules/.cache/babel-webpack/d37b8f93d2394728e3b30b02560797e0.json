{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/locking/async_locker\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/constants\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.AsyncLocker = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var constants_1 = require(\"@angular/compiler-cli/ngcc/src/constants\");\n\n  var TimeoutError =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TimeoutError, _super);\n\n    function TimeoutError() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.code = constants_1.NGCC_TIMED_OUT_EXIT_CODE;\n      return _this;\n    }\n\n    return TimeoutError;\n  }(Error);\n  /**\n   * AsyncLocker is used to prevent more than one instance of ngcc executing at the same time,\n   * when being called in an asynchronous context.\n   *\n   * * When ngcc starts executing, it creates a file in the `compiler-cli/ngcc` folder.\n   * * If it finds one is already there then it pauses and waits for the file to be removed by the\n   *   other process. If the file is not removed within a set timeout period given by\n   *   `retryDelay*retryAttempts` an error is thrown with a suitable error message.\n   * * If the process locking the file changes, then we restart the timeout.\n   * * When ngcc completes executing, it removes the file so that future ngcc executions can start.\n   */\n\n\n  var AsyncLocker =\n  /** @class */\n  function () {\n    function AsyncLocker(lockFile, logger, retryDelay, retryAttempts) {\n      this.lockFile = lockFile;\n      this.logger = logger;\n      this.retryDelay = retryDelay;\n      this.retryAttempts = retryAttempts;\n    }\n    /**\n     * Run a function guarded by the lock file.\n     *\n     * @param fn The function to run.\n     */\n\n\n    AsyncLocker.prototype.lock = function (fn) {\n      return tslib_1.__awaiter(this, void 0, void 0, function () {\n        return tslib_1.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.create()];\n\n            case 1:\n              _a.sent();\n\n              _a.label = 2;\n\n            case 2:\n              _a.trys.push([2,, 4, 5]);\n\n              return [4\n              /*yield*/\n              , fn()];\n\n            case 3:\n              return [2\n              /*return*/\n              , _a.sent()];\n\n            case 4:\n              this.lockFile.remove();\n              return [7\n              /*endfinally*/\n              ];\n\n            case 5:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n\n    AsyncLocker.prototype.create = function () {\n      return tslib_1.__awaiter(this, void 0, void 0, function () {\n        var pid, attempts, e_1, newPid;\n\n        var _this = this;\n\n        return tslib_1.__generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              pid = '';\n              attempts = 0;\n              _a.label = 1;\n\n            case 1:\n              if (!(attempts < this.retryAttempts)) return [3\n              /*break*/\n              , 6];\n              _a.label = 2;\n\n            case 2:\n              _a.trys.push([2, 3,, 5]);\n\n              return [2\n              /*return*/\n              , this.lockFile.write()];\n\n            case 3:\n              e_1 = _a.sent();\n\n              if (e_1.code !== 'EEXIST') {\n                throw e_1;\n              }\n\n              newPid = this.lockFile.read();\n\n              if (newPid !== pid) {\n                // The process locking the file has changed, so restart the timeout\n                attempts = 0;\n                pid = newPid;\n              }\n\n              if (attempts === 0) {\n                this.logger.info(\"Another process, with id \" + pid + \", is currently running ngcc.\\n\" + (\"Waiting up to \" + this.retryDelay * this.retryAttempts / 1000 + \"s for it to finish.\\n\") + (\"(If you are sure no ngcc process is running then you should delete the lock-file at \" + this.lockFile.path + \".)\"));\n              } // The file is still locked by another process so wait for a bit and retry\n\n\n              return [4\n              /*yield*/\n              , new Promise(function (resolve) {\n                return setTimeout(resolve, _this.retryDelay);\n              })];\n\n            case 4:\n              // The file is still locked by another process so wait for a bit and retry\n              _a.sent();\n\n              return [3\n              /*break*/\n              , 5];\n\n            case 5:\n              attempts++;\n              return [3\n              /*break*/\n              , 1];\n\n            case 6:\n              // If we fall out of the loop then we ran out of rety attempts\n              throw new TimeoutError(\"Timed out waiting \" + this.retryAttempts * this.retryDelay / 1000 + \"s for another ngcc process, with id \" + pid + \", to complete.\\n\" + (\"(If you are sure no ngcc process is running then you should delete the lock-file at \" + this.lockFile.path + \".)\"));\n          }\n        });\n      });\n    };\n\n    return AsyncLocker;\n  }();\n\n  exports.AsyncLocker = AsyncLocker;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/locking/async_locker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {NGCC_TIMED_OUT_EXIT_CODE} from '../constants';\n\nimport {LockFile} from './lock_file';\n\nclass TimeoutError extends Error {\n  code = NGCC_TIMED_OUT_EXIT_CODE;\n}\n\n/**\n * AsyncLocker is used to prevent more than one instance of ngcc executing at the same time,\n * when being called in an asynchronous context.\n *\n * * When ngcc starts executing, it creates a file in the `compiler-cli/ngcc` folder.\n * * If it finds one is already there then it pauses and waits for the file to be removed by the\n *   other process. If the file is not removed within a set timeout period given by\n *   `retryDelay*retryAttempts` an error is thrown with a suitable error message.\n * * If the process locking the file changes, then we restart the timeout.\n * * When ngcc completes executing, it removes the file so that future ngcc executions can start.\n */\nexport class AsyncLocker {\n  constructor(\n      private lockFile: LockFile, protected logger: Logger, private retryDelay: number,\n      private retryAttempts: number) {}\n\n  /**\n   * Run a function guarded by the lock file.\n   *\n   * @param fn The function to run.\n   */\n  async lock<T>(fn: () => Promise<T>): Promise<T> {\n    await this.create();\n    try {\n      return await fn();\n    } finally {\n      this.lockFile.remove();\n    }\n  }\n\n  protected async create() {\n    let pid: string = '';\n    for (let attempts = 0; attempts < this.retryAttempts; attempts++) {\n      try {\n        return this.lockFile.write();\n      } catch (e) {\n        if (e.code !== 'EEXIST') {\n          throw e;\n        }\n        const newPid = this.lockFile.read();\n        if (newPid !== pid) {\n          // The process locking the file has changed, so restart the timeout\n          attempts = 0;\n          pid = newPid;\n        }\n        if (attempts === 0) {\n          this.logger.info(\n              `Another process, with id ${pid}, is currently running ngcc.\\n` +\n              `Waiting up to ${this.retryDelay * this.retryAttempts / 1000}s for it to finish.\\n` +\n              `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n                  this.lockFile.path}.)`);\n        }\n        // The file is still locked by another process so wait for a bit and retry\n        await new Promise(resolve => setTimeout(resolve, this.retryDelay));\n      }\n    }\n    // If we fall out of the loop then we ran out of rety attempts\n    throw new TimeoutError(\n        `Timed out waiting ${\n            this.retryAttempts * this.retryDelay /\n            1000}s for another ngcc process, with id ${pid}, to complete.\\n` +\n        `(If you are sure no ngcc process is running then you should delete the lock-file at ${\n            this.lockFile.path}.)`);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}