{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/host/esm2015_host\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/ngcc/src/analysis/util\", \"@angular/compiler-cli/ngcc/src/utils\", \"@angular/compiler-cli/ngcc/src/host/ngcc_host\", \"@angular/compiler-cli/ngcc/src/host/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getOuterNodeFromInnerDeclaration = exports.getContainingStatement = exports.getInnerClassDeclaration = exports.skipClassAliases = exports.getPropertyValueFromSymbol = exports.isMemberDecorateCall = exports.isClassDecorateCall = exports.isAssignment = exports.getIifeBody = exports.isAssignmentStatement = exports.Esm2015ReflectionHost = exports.CONSTRUCTOR_PARAMS = exports.CONSTRUCTOR = exports.PROP_DECORATORS = exports.DECORATORS = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var util_1 = require(\"@angular/compiler-cli/ngcc/src/analysis/util\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/utils\");\n\n  var ngcc_host_1 = require(\"@angular/compiler-cli/ngcc/src/host/ngcc_host\");\n\n  var utils_2 = require(\"@angular/compiler-cli/ngcc/src/host/utils\");\n\n  exports.DECORATORS = 'decorators';\n  exports.PROP_DECORATORS = 'propDecorators';\n  exports.CONSTRUCTOR = '__constructor';\n  exports.CONSTRUCTOR_PARAMS = 'ctorParameters';\n  /**\n   * Esm2015 packages contain ECMAScript 2015 classes, etc.\n   * Decorators are defined via static properties on the class. For example:\n   *\n   * ```\n   * class SomeDirective {\n   * }\n   * SomeDirective.decorators = [\n   *   { type: Directive, args: [{ selector: '[someDirective]' },] }\n   * ];\n   * SomeDirective.ctorParameters = () => [\n   *   { type: ViewContainerRef, },\n   *   { type: TemplateRef, },\n   *   { type: undefined, decorators: [{ type: Inject, args: [INJECTED_TOKEN,] },] },\n   * ];\n   * SomeDirective.propDecorators = {\n   *   \"input1\": [{ type: Input },],\n   *   \"input2\": [{ type: Input },],\n   * };\n   * ```\n   *\n   * * Classes are decorated if they have a static property called `decorators`.\n   * * Members are decorated if there is a matching key on a static property\n   *   called `propDecorators`.\n   * * Constructor parameters decorators are found on an object returned from\n   *   a static method called `ctorParameters`.\n   */\n\n  var Esm2015ReflectionHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Esm2015ReflectionHost, _super);\n\n    function Esm2015ReflectionHost(logger, isCore, src, dts) {\n      if (dts === void 0) {\n        dts = null;\n      }\n\n      var _this = _super.call(this, src.program.getTypeChecker()) || this;\n\n      _this.logger = logger;\n      _this.isCore = isCore;\n      _this.src = src;\n      _this.dts = dts;\n      /**\n       * A mapping from source declarations to typings declarations, which are both publicly exported.\n       *\n       * There should be one entry for every public export visible from the root file of the source\n       * tree. Note that by definition the key and value declarations will not be in the same TS\n       * program.\n       */\n\n      _this.publicDtsDeclarationMap = null;\n      /**\n       * A mapping from source declarations to typings declarations, which are not publicly exported.\n       *\n       * This mapping is a best guess between declarations that happen to be exported from their file by\n       * the same name in both the source and the dts file. Note that by definition the key and value\n       * declarations will not be in the same TS program.\n       */\n\n      _this.privateDtsDeclarationMap = null;\n      /**\n       * The set of source files that have already been preprocessed.\n       */\n\n      _this.preprocessedSourceFiles = new Set();\n      /**\n       * In ES2015, class declarations may have been down-leveled into variable declarations,\n       * initialized using a class expression. In certain scenarios, an additional variable\n       * is introduced that represents the class so that results in code such as:\n       *\n       * ```\n       * let MyClass_1; let MyClass = MyClass_1 = class MyClass {};\n       * ```\n       *\n       * This map tracks those aliased variables to their original identifier, i.e. the key\n       * corresponds with the declaration of `MyClass_1` and its value becomes the `MyClass` identifier\n       * of the variable declaration.\n       *\n       * This map is populated during the preprocessing of each source file.\n       */\n\n      _this.aliasedClassDeclarations = new Map();\n      /**\n       * Caches the information of the decorators on a class, as the work involved with extracting\n       * decorators is complex and frequently used.\n       *\n       * This map is lazily populated during the first call to `acquireDecoratorInfo` for a given class.\n       */\n\n      _this.decoratorCache = new Map();\n      return _this;\n    }\n    /**\n     * Find a symbol for a node that we think is a class.\n     * Classes should have a `name` identifier, because they may need to be referenced in other parts\n     * of the program.\n     *\n     * In ES2015, a class may be declared using a variable declaration of the following structures:\n     *\n     * ```\n     * var MyClass = MyClass_1 = class MyClass {};\n     * ```\n     *\n     * or\n     *\n     * ```\n     * var MyClass = MyClass_1 = (() => { class MyClass {} ... return MyClass; })()\n     * ```\n     *\n     * Here, the intermediate `MyClass_1` assignment is optional. In the above example, the\n     * `class MyClass {}` node is returned as declaration of `MyClass`.\n     *\n     * @param declaration the declaration node whose symbol we are finding.\n     * @returns the symbol for the node or `undefined` if it is not a \"class\" or has no symbol.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getClassSymbol = function (declaration) {\n      var symbol = this.getClassSymbolFromOuterDeclaration(declaration);\n\n      if (symbol !== undefined) {\n        return symbol;\n      }\n\n      var innerDeclaration = this.getInnerDeclarationFromAliasOrInner(declaration);\n      return this.getClassSymbolFromInnerDeclaration(innerDeclaration);\n    };\n    /**\n     * Examine a declaration (for example, of a class or function) and return metadata about any\n     * decorators present on the declaration.\n     *\n     * @param declaration a TypeScript node representing the class or function over which to reflect.\n     *     For example, if the intent is to reflect the decorators of a class and the source is in ES6\n     *     format, this will be a `ts.ClassDeclaration` node. If the source is in ES5 format, this\n     *     might be a `ts.VariableDeclaration` as classes in ES5 are represented as the result of an\n     *     IIFE execution.\n     *\n     * @returns an array of `Decorator` metadata if decorators are present on the declaration, or\n     *     `null` if either no decorators were present or if the declaration is not of a decoratable\n     *     type.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getDecoratorsOfDeclaration = function (declaration) {\n      var symbol = this.getClassSymbol(declaration);\n\n      if (!symbol) {\n        return null;\n      }\n\n      return this.getDecoratorsOfSymbol(symbol);\n    };\n    /**\n     * Examine a declaration which should be of a class, and return metadata about the members of the\n     * class.\n     *\n     * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n     *\n     * @returns an array of `ClassMember` metadata representing the members of the class.\n     *\n     * @throws if `declaration` does not resolve to a class declaration.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getMembersOfClass = function (clazz) {\n      var classSymbol = this.getClassSymbol(clazz);\n\n      if (!classSymbol) {\n        throw new Error(\"Attempted to get members of a non-class: \\\"\" + clazz.getText() + \"\\\"\");\n      }\n\n      return this.getMembersOfSymbol(classSymbol);\n    };\n    /**\n     * Reflect over the constructor of a class and return metadata about its parameters.\n     *\n     * This method only looks at the constructor of a class directly and not at any inherited\n     * constructors.\n     *\n     * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n     *\n     * @returns an array of `Parameter` metadata representing the parameters of the constructor, if\n     * a constructor exists. If the constructor exists and has 0 parameters, this array will be empty.\n     * If the class has no constructor, this method returns `null`.\n     *\n     * @throws if `declaration` does not resolve to a class declaration.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getConstructorParameters = function (clazz) {\n      var classSymbol = this.getClassSymbol(clazz);\n\n      if (!classSymbol) {\n        throw new Error(\"Attempted to get constructor parameters of a non-class: \\\"\" + clazz.getText() + \"\\\"\");\n      }\n\n      var parameterNodes = this.getConstructorParameterDeclarations(classSymbol);\n\n      if (parameterNodes) {\n        return this.getConstructorParamInfo(classSymbol, parameterNodes);\n      }\n\n      return null;\n    };\n\n    Esm2015ReflectionHost.prototype.getBaseClassExpression = function (clazz) {\n      // First try getting the base class from an ES2015 class declaration\n      var superBaseClassIdentifier = _super.prototype.getBaseClassExpression.call(this, clazz);\n\n      if (superBaseClassIdentifier) {\n        return superBaseClassIdentifier;\n      } // That didn't work so now try getting it from the \"inner\" declaration.\n\n\n      var classSymbol = this.getClassSymbol(clazz);\n\n      if (classSymbol === undefined || !isNamedDeclaration(classSymbol.implementation.valueDeclaration)) {\n        return null;\n      }\n\n      return _super.prototype.getBaseClassExpression.call(this, classSymbol.implementation.valueDeclaration);\n    };\n\n    Esm2015ReflectionHost.prototype.getInternalNameOfClass = function (clazz) {\n      var classSymbol = this.getClassSymbol(clazz);\n\n      if (classSymbol === undefined) {\n        throw new Error(\"getInternalNameOfClass() called on a non-class: expected \" + clazz.name.text + \" to be a class declaration.\");\n      }\n\n      return this.getNameFromClassSymbolDeclaration(classSymbol, classSymbol.implementation.valueDeclaration);\n    };\n\n    Esm2015ReflectionHost.prototype.getAdjacentNameOfClass = function (clazz) {\n      var classSymbol = this.getClassSymbol(clazz);\n\n      if (classSymbol === undefined) {\n        throw new Error(\"getAdjacentNameOfClass() called on a non-class: expected \" + clazz.name.text + \" to be a class declaration.\");\n      }\n\n      return this.getAdjacentNameOfClassSymbol(classSymbol);\n    };\n\n    Esm2015ReflectionHost.prototype.getNameFromClassSymbolDeclaration = function (classSymbol, declaration) {\n      if (declaration === undefined) {\n        throw new Error(\"getInternalNameOfClass() called on a class with an undefined internal declaration. External class name: \" + classSymbol.name + \"; internal class name: \" + classSymbol.implementation.name + \".\");\n      }\n\n      if (!isNamedDeclaration(declaration)) {\n        throw new Error(\"getInternalNameOfClass() called on a class with an anonymous inner declaration: expected a name on:\\n\" + declaration.getText());\n      }\n\n      return declaration.name;\n    };\n    /**\n     * Check whether the given node actually represents a class.\n     */\n\n\n    Esm2015ReflectionHost.prototype.isClass = function (node) {\n      return _super.prototype.isClass.call(this, node) || this.getClassSymbol(node) !== undefined;\n    };\n    /**\n     * Trace an identifier to its declaration, if possible.\n     *\n     * This method attempts to resolve the declaration of the given identifier, tracing back through\n     * imports and re-exports until the original declaration statement is found. A `Declaration`\n     * object is returned if the original declaration is found, or `null` is returned otherwise.\n     *\n     * In ES2015, we need to account for identifiers that refer to aliased class declarations such as\n     * `MyClass_1`. Since such declarations are only available within the module itself, we need to\n     * find the original class declaration, e.g. `MyClass`, that is associated with the aliased one.\n     *\n     * @param id a TypeScript `ts.Identifier` to trace back to a declaration.\n     *\n     * @returns metadata about the `Declaration` if the original declaration is found, or `null`\n     * otherwise.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getDeclarationOfIdentifier = function (id) {\n      var superDeclaration = _super.prototype.getDeclarationOfIdentifier.call(this, id); // If no declaration was found, return.\n\n\n      if (superDeclaration === null) {\n        return superDeclaration;\n      } // If the declaration already has traits assigned to it, return as is.\n\n\n      if (superDeclaration.known !== null || reflection_1.isConcreteDeclaration(superDeclaration) && superDeclaration.identity !== null) {\n        return superDeclaration;\n      }\n\n      var declarationNode = superDeclaration.node;\n\n      if (reflection_1.isNamedVariableDeclaration(superDeclaration.node) && !isTopLevel(superDeclaration.node)) {\n        var variableValue = this.getVariableValue(superDeclaration.node);\n\n        if (variableValue !== null && ts.isClassExpression(variableValue)) {\n          declarationNode = getContainingStatement(variableValue);\n        }\n      }\n\n      var outerNode = getOuterNodeFromInnerDeclaration(declarationNode);\n      var declaration = outerNode !== null && reflection_1.isNamedVariableDeclaration(outerNode) ? this.getDeclarationOfIdentifier(outerNode.name) : superDeclaration;\n\n      if (declaration === null || declaration.known !== null || reflection_1.isConcreteDeclaration(declaration) && declaration.identity !== null) {\n        return declaration;\n      } // The identifier may have been of an additional class assignment such as `MyClass_1` that was\n      // present as alias for `MyClass`. If so, resolve such aliases to their original declaration.\n\n\n      var aliasedIdentifier = this.resolveAliasedClassIdentifier(declaration.node);\n\n      if (aliasedIdentifier !== null) {\n        return this.getDeclarationOfIdentifier(aliasedIdentifier);\n      } // Variable declarations may represent an enum declaration, so attempt to resolve its members.\n\n\n      if (reflection_1.isConcreteDeclaration(declaration) && ts.isVariableDeclaration(declaration.node)) {\n        var enumMembers = this.resolveEnumMembers(declaration.node);\n\n        if (enumMembers !== null) {\n          declaration.identity = {\n            kind: 0\n            /* DownleveledEnum */\n            ,\n            enumMembers: enumMembers\n          };\n        }\n      }\n\n      return declaration;\n    };\n    /**\n     * Gets all decorators of the given class symbol. Any decorator that have been synthetically\n     * injected by a migration will not be present in the returned collection.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getDecoratorsOfSymbol = function (symbol) {\n      var classDecorators = this.acquireDecoratorInfo(symbol).classDecorators;\n\n      if (classDecorators === null) {\n        return null;\n      } // Return a clone of the array to prevent consumers from mutating the cache.\n\n\n      return Array.from(classDecorators);\n    };\n    /**\n     * Search the given module for variable declarations in which the initializer\n     * is an identifier marked with the `PRE_R3_MARKER`.\n     * @param module the module in which to search for switchable declarations.\n     * @returns an array of variable declarations that match.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getSwitchableDeclarations = function (module) {\n      // Don't bother to walk the AST if the marker is not found in the text\n      return module.getText().indexOf(ngcc_host_1.PRE_R3_MARKER) >= 0 ? utils_1.findAll(module, ngcc_host_1.isSwitchableVariableDeclaration) : [];\n    };\n\n    Esm2015ReflectionHost.prototype.getVariableValue = function (declaration) {\n      var value = _super.prototype.getVariableValue.call(this, declaration);\n\n      if (value) {\n        return value;\n      } // We have a variable declaration that has no initializer. For example:\n      //\n      // ```\n      // var HttpClientXsrfModule_1;\n      // ```\n      //\n      // So look for the special scenario where the variable is being assigned in\n      // a nearby statement to the return value of a call to `__decorate`.\n      // Then find the 2nd argument of that call, the \"target\", which will be the\n      // actual class identifier. For example:\n      //\n      // ```\n      // HttpClientXsrfModule = HttpClientXsrfModule_1 = tslib_1.__decorate([\n      //   NgModule({\n      //     providers: [],\n      //   })\n      // ], HttpClientXsrfModule);\n      // ```\n      //\n      // And finally, find the declaration of the identifier in that argument.\n      // Note also that the assignment can occur within another assignment.\n      //\n\n\n      var block = declaration.parent.parent.parent;\n      var symbol = this.checker.getSymbolAtLocation(declaration.name);\n\n      if (symbol && (ts.isBlock(block) || ts.isSourceFile(block))) {\n        var decorateCall = this.findDecoratedVariableValue(block, symbol);\n        var target = decorateCall && decorateCall.arguments[1];\n\n        if (target && ts.isIdentifier(target)) {\n          var targetSymbol = this.checker.getSymbolAtLocation(target);\n          var targetDeclaration = targetSymbol && targetSymbol.valueDeclaration;\n\n          if (targetDeclaration) {\n            if (ts.isClassDeclaration(targetDeclaration) || ts.isFunctionDeclaration(targetDeclaration)) {\n              // The target is just a function or class declaration\n              // so return its identifier as the variable value.\n              return targetDeclaration.name || null;\n            } else if (ts.isVariableDeclaration(targetDeclaration)) {\n              // The target is a variable declaration, so find the far right expression,\n              // in the case of multiple assignments (e.g. `var1 = var2 = value`).\n              var targetValue = targetDeclaration.initializer;\n\n              while (targetValue && isAssignment(targetValue)) {\n                targetValue = targetValue.right;\n              }\n\n              if (targetValue) {\n                return targetValue;\n              }\n            }\n          }\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Find all top-level class symbols in the given file.\n     * @param sourceFile The source file to search for classes.\n     * @returns An array of class symbols.\n     */\n\n\n    Esm2015ReflectionHost.prototype.findClassSymbols = function (sourceFile) {\n      var _this = this;\n\n      var classes = new Map();\n      this.getModuleStatements(sourceFile).forEach(function (statement) {\n        return _this.addClassSymbolsFromStatement(classes, statement);\n      });\n      return Array.from(classes.values());\n    };\n    /**\n     * Get the number of generic type parameters of a given class.\n     *\n     * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n     *\n     * @returns the number of type parameters of the class, if known, or `null` if the declaration\n     * is not a class or has an unknown number of type parameters.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getGenericArityOfClass = function (clazz) {\n      var dtsDeclaration = this.getDtsDeclaration(clazz);\n\n      if (dtsDeclaration && ts.isClassDeclaration(dtsDeclaration)) {\n        return dtsDeclaration.typeParameters ? dtsDeclaration.typeParameters.length : 0;\n      }\n\n      return null;\n    };\n    /**\n     * Take an exported declaration of a class (maybe down-leveled to a variable) and look up the\n     * declaration of its type in a separate .d.ts tree.\n     *\n     * This function is allowed to return `null` if the current compilation unit does not have a\n     * separate .d.ts tree. When compiling TypeScript code this is always the case, since .d.ts files\n     * are produced only during the emit of such a compilation. When compiling .js code, however,\n     * there is frequently a parallel .d.ts tree which this method exposes.\n     *\n     * Note that the `ts.ClassDeclaration` returned from this function may not be from the same\n     * `ts.Program` as the input declaration.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getDtsDeclaration = function (declaration) {\n      if (this.dts === null) {\n        return null;\n      }\n\n      if (!isNamedDeclaration(declaration)) {\n        throw new Error(\"Cannot get the dts file for a declaration that has no name: \" + declaration.getText() + \" in \" + declaration.getSourceFile().fileName);\n      }\n\n      var decl = this.getDeclarationOfIdentifier(declaration.name);\n\n      if (decl === null) {\n        throw new Error(\"Cannot get the dts file for a node that cannot be associated with a declaration \" + declaration.getText() + \" in \" + declaration.getSourceFile().fileName);\n      } // Try to retrieve the dts declaration from the public map\n\n\n      if (this.publicDtsDeclarationMap === null) {\n        this.publicDtsDeclarationMap = this.computePublicDtsDeclarationMap(this.src, this.dts);\n      }\n\n      if (this.publicDtsDeclarationMap.has(decl.node)) {\n        return this.publicDtsDeclarationMap.get(decl.node);\n      } // No public export, try the private map\n\n\n      if (this.privateDtsDeclarationMap === null) {\n        this.privateDtsDeclarationMap = this.computePrivateDtsDeclarationMap(this.src, this.dts);\n      }\n\n      if (this.privateDtsDeclarationMap.has(decl.node)) {\n        return this.privateDtsDeclarationMap.get(decl.node);\n      } // No declaration found at all\n\n\n      return null;\n    };\n\n    Esm2015ReflectionHost.prototype.getEndOfClass = function (classSymbol) {\n      var implementation = classSymbol.implementation;\n      var last = implementation.valueDeclaration;\n      var implementationStatement = getContainingStatement(last);\n      if (implementationStatement === null) return last;\n      var container = implementationStatement.parent;\n\n      if (ts.isBlock(container)) {\n        // Assume that the implementation is inside an IIFE\n        var returnStatementIndex = container.statements.findIndex(ts.isReturnStatement);\n\n        if (returnStatementIndex === -1) {\n          throw new Error(\"Compiled class wrapper IIFE does not have a return statement: \" + classSymbol.name + \" in \" + classSymbol.declaration.valueDeclaration.getSourceFile().fileName);\n        } // Return the statement before the IIFE return statement\n\n\n        last = container.statements[returnStatementIndex - 1];\n      } else if (ts.isSourceFile(container)) {\n        // If there are static members on this class then find the last one\n        if (implementation.exports !== undefined) {\n          implementation.exports.forEach(function (exportSymbol) {\n            if (exportSymbol.valueDeclaration === undefined) {\n              return;\n            }\n\n            var exportStatement = getContainingStatement(exportSymbol.valueDeclaration);\n\n            if (exportStatement !== null && last.getEnd() < exportStatement.getEnd()) {\n              last = exportStatement;\n            }\n          });\n        } // If there are helper calls for this class then find the last one\n\n\n        var helpers = this.getHelperCallsForClass(classSymbol, ['__decorate', '__extends', '__param', '__metadata']);\n        helpers.forEach(function (helper) {\n          var helperStatement = getContainingStatement(helper);\n\n          if (helperStatement !== null && last.getEnd() < helperStatement.getEnd()) {\n            last = helperStatement;\n          }\n        });\n      }\n\n      return last;\n    };\n    /**\n     * Check whether a `Declaration` corresponds with a known declaration, such as `Object`, and set\n     * its `known` property to the appropriate `KnownDeclaration`.\n     *\n     * @param decl The `Declaration` to check.\n     * @return The passed in `Declaration` (potentially enhanced with a `KnownDeclaration`).\n     */\n\n\n    Esm2015ReflectionHost.prototype.detectKnownDeclaration = function (decl) {\n      if (decl.known === null && this.isJavaScriptObjectDeclaration(decl)) {\n        // If the identifier resolves to the global JavaScript `Object`, update the declaration to\n        // denote it as the known `JsGlobalObject` declaration.\n        decl.known = reflection_1.KnownDeclaration.JsGlobalObject;\n      }\n\n      return decl;\n    }; ///////////// Protected Helpers /////////////\n\n    /**\n     * Extract all the \"classes\" from the `statement` and add them to the `classes` map.\n     */\n\n\n    Esm2015ReflectionHost.prototype.addClassSymbolsFromStatement = function (classes, statement) {\n      var _this = this;\n\n      if (ts.isVariableStatement(statement)) {\n        statement.declarationList.declarations.forEach(function (declaration) {\n          var classSymbol = _this.getClassSymbol(declaration);\n\n          if (classSymbol) {\n            classes.set(classSymbol.implementation, classSymbol);\n          }\n        });\n      } else if (ts.isClassDeclaration(statement)) {\n        var classSymbol = this.getClassSymbol(statement);\n\n        if (classSymbol) {\n          classes.set(classSymbol.implementation, classSymbol);\n        }\n      }\n    };\n    /**\n     * Compute the inner declaration node of a \"class\" from the given `declaration` node.\n     *\n     * @param declaration a node that is either an inner declaration or an alias of a class.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getInnerDeclarationFromAliasOrInner = function (declaration) {\n      if (declaration.parent !== undefined && reflection_1.isNamedVariableDeclaration(declaration.parent)) {\n        var variableValue = this.getVariableValue(declaration.parent);\n\n        if (variableValue !== null) {\n          declaration = variableValue;\n        }\n      }\n\n      return declaration;\n    };\n    /**\n     * A class may be declared as a top level class declaration:\n     *\n     * ```\n     * class OuterClass { ... }\n     * ```\n     *\n     * or in a variable declaration to a class expression:\n     *\n     * ```\n     * var OuterClass = ClassAlias = class InnerClass {};\n     * ```\n     *\n     * or in a variable declaration to an IIFE containing a class declaration\n     *\n     * ```\n     * var OuterClass = ClassAlias = (() => {\n     *   class InnerClass {}\n     *   ...\n     *   return InnerClass;\n     * })()\n     * ```\n     *\n     * or in a variable declaration to an IIFE containing a function declaration\n     *\n     * ```\n     * var OuterClass = ClassAlias = (() => {\n     *   function InnerClass() {}\n     *   ...\n     *   return InnerClass;\n     * })()\n     * ```\n     *\n     * This method returns an `NgccClassSymbol` when provided with one of these cases.\n     *\n     * @param declaration the declaration whose symbol we are finding.\n     * @returns the symbol for the class or `undefined` if `declaration` does not represent an outer\n     *     declaration of a class.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getClassSymbolFromOuterDeclaration = function (declaration) {\n      // Return a class symbol without an inner declaration if it is a regular \"top level\" class\n      if (reflection_1.isNamedClassDeclaration(declaration) && isTopLevel(declaration)) {\n        return this.createClassSymbol(declaration.name, null);\n      } // Otherwise, an outer class declaration must be an initialized variable declaration:\n\n\n      if (!isInitializedVariableClassDeclaration(declaration)) {\n        return undefined;\n      }\n\n      var innerDeclaration = getInnerClassDeclaration(skipClassAliases(declaration));\n\n      if (innerDeclaration === null) {\n        return undefined;\n      }\n\n      return this.createClassSymbol(declaration.name, innerDeclaration);\n    };\n    /**\n     * In ES2015, a class may be declared using a variable declaration of the following structures:\n     *\n     * ```\n     * let MyClass = MyClass_1 = class MyClass {};\n     * ```\n     *\n     * or\n     *\n     * ```\n     * let MyClass = MyClass_1 = (() => { class MyClass {} ... return MyClass; })()\n     * ```\n     *\n     * or\n     *\n     * ```\n     * let MyClass = MyClass_1 = (() => { let MyClass = class MyClass {}; ... return MyClass; })()\n     * ```\n     *\n     * This method extracts the `NgccClassSymbol` for `MyClass` when provided with the\n     * `class MyClass {}` declaration node. When the `var MyClass` node or any other node is given,\n     * this method will return undefined instead.\n     *\n     * @param declaration the declaration whose symbol we are finding.\n     * @returns the symbol for the node or `undefined` if it does not represent an inner declaration\n     * of a class.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getClassSymbolFromInnerDeclaration = function (declaration) {\n      var outerDeclaration = undefined;\n\n      if (ts.isClassExpression(declaration) && utils_1.hasNameIdentifier(declaration)) {\n        // Handle `let MyClass = MyClass_1 = class MyClass {};`\n        outerDeclaration = getFarLeftHandSideOfAssignment(declaration); // Handle this being in an IIFE\n\n        if (outerDeclaration !== undefined && !isTopLevel(outerDeclaration)) {\n          outerDeclaration = getContainingVariableDeclaration(outerDeclaration);\n        }\n      } else if (reflection_1.isNamedClassDeclaration(declaration)) {\n        // Handle `class MyClass {}` statement\n        if (isTopLevel(declaration)) {\n          // At the top level\n          outerDeclaration = declaration;\n        } else {\n          // Or inside an IIFE\n          outerDeclaration = getContainingVariableDeclaration(declaration);\n        }\n      }\n\n      if (outerDeclaration === undefined || !utils_1.hasNameIdentifier(outerDeclaration)) {\n        return undefined;\n      }\n\n      return this.createClassSymbol(outerDeclaration.name, declaration);\n    };\n    /**\n     * Creates an `NgccClassSymbol` from an outer and inner declaration. If a class only has an outer\n     * declaration, the \"implementation\" symbol of the created `NgccClassSymbol` will be set equal to\n     * the \"declaration\" symbol.\n     *\n     * @param outerDeclaration The outer declaration node of the class.\n     * @param innerDeclaration The inner declaration node of the class, or undefined if no inner\n     * declaration is present.\n     * @returns the `NgccClassSymbol` representing the class, or undefined if a `ts.Symbol` for any of\n     * the declarations could not be resolved.\n     */\n\n\n    Esm2015ReflectionHost.prototype.createClassSymbol = function (outerDeclaration, innerDeclaration) {\n      var declarationSymbol = this.checker.getSymbolAtLocation(outerDeclaration);\n\n      if (declarationSymbol === undefined) {\n        return undefined;\n      }\n\n      var implementationSymbol = declarationSymbol;\n\n      if (innerDeclaration !== null && isNamedDeclaration(innerDeclaration)) {\n        implementationSymbol = this.checker.getSymbolAtLocation(innerDeclaration.name);\n      }\n\n      if (implementationSymbol === undefined) {\n        return undefined;\n      }\n\n      var classSymbol = {\n        name: declarationSymbol.name,\n        declaration: declarationSymbol,\n        implementation: implementationSymbol,\n        adjacent: this.getAdjacentSymbol(declarationSymbol, implementationSymbol)\n      };\n      return classSymbol;\n    };\n\n    Esm2015ReflectionHost.prototype.getAdjacentSymbol = function (declarationSymbol, implementationSymbol) {\n      if (declarationSymbol === implementationSymbol) {\n        return undefined;\n      }\n\n      var innerDeclaration = implementationSymbol.valueDeclaration;\n\n      if (!ts.isClassExpression(innerDeclaration) && !ts.isFunctionExpression(innerDeclaration)) {\n        return undefined;\n      } // Deal with the inner class looking like this inside an IIFE:\n      // `let MyClass = class MyClass {};` or `var MyClass = function MyClass() {};`\n\n\n      var adjacentDeclaration = getFarLeftHandSideOfAssignment(innerDeclaration);\n\n      if (adjacentDeclaration === undefined || !reflection_1.isNamedVariableDeclaration(adjacentDeclaration)) {\n        return undefined;\n      }\n\n      var adjacentSymbol = this.checker.getSymbolAtLocation(adjacentDeclaration.name);\n\n      if (adjacentSymbol === declarationSymbol || adjacentSymbol === implementationSymbol) {\n        return undefined;\n      }\n\n      return adjacentSymbol;\n    };\n    /**\n     * Resolve a `ts.Symbol` to its declaration and detect whether it corresponds with a known\n     * declaration.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getDeclarationOfSymbol = function (symbol, originalId) {\n      var declaration = _super.prototype.getDeclarationOfSymbol.call(this, symbol, originalId);\n\n      if (declaration === null) {\n        return null;\n      }\n\n      return this.detectKnownDeclaration(declaration);\n    };\n    /**\n     * Finds the identifier of the actual class declaration for a potentially aliased declaration of a\n     * class.\n     *\n     * If the given declaration is for an alias of a class, this function will determine an identifier\n     * to the original declaration that represents this class.\n     *\n     * @param declaration The declaration to resolve.\n     * @returns The original identifier that the given class declaration resolves to, or `undefined`\n     * if the declaration does not represent an aliased class.\n     */\n\n\n    Esm2015ReflectionHost.prototype.resolveAliasedClassIdentifier = function (declaration) {\n      this.ensurePreprocessed(declaration.getSourceFile());\n      return this.aliasedClassDeclarations.has(declaration) ? this.aliasedClassDeclarations.get(declaration) : null;\n    };\n    /**\n     * Ensures that the source file that `node` is part of has been preprocessed.\n     *\n     * During preprocessing, all statements in the source file will be visited such that certain\n     * processing steps can be done up-front and cached for subsequent usages.\n     *\n     * @param sourceFile The source file that needs to have gone through preprocessing.\n     */\n\n\n    Esm2015ReflectionHost.prototype.ensurePreprocessed = function (sourceFile) {\n      var e_1, _a;\n\n      if (!this.preprocessedSourceFiles.has(sourceFile)) {\n        this.preprocessedSourceFiles.add(sourceFile);\n\n        try {\n          for (var _b = tslib_1.__values(this.getModuleStatements(sourceFile)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var statement = _c.value;\n            this.preprocessStatement(statement);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    };\n    /**\n     * Analyzes the given statement to see if it corresponds with a variable declaration like\n     * `let MyClass = MyClass_1 = class MyClass {};`. If so, the declaration of `MyClass_1`\n     * is associated with the `MyClass` identifier.\n     *\n     * @param statement The statement that needs to be preprocessed.\n     */\n\n\n    Esm2015ReflectionHost.prototype.preprocessStatement = function (statement) {\n      if (!ts.isVariableStatement(statement)) {\n        return;\n      }\n\n      var declarations = statement.declarationList.declarations;\n\n      if (declarations.length !== 1) {\n        return;\n      }\n\n      var declaration = declarations[0];\n      var initializer = declaration.initializer;\n\n      if (!ts.isIdentifier(declaration.name) || !initializer || !isAssignment(initializer) || !ts.isIdentifier(initializer.left) || !this.isClass(declaration)) {\n        return;\n      }\n\n      var aliasedIdentifier = initializer.left;\n      var aliasedDeclaration = this.getDeclarationOfIdentifier(aliasedIdentifier);\n\n      if (aliasedDeclaration === null) {\n        throw new Error(\"Unable to locate declaration of \" + aliasedIdentifier.text + \" in \\\"\" + statement.getText() + \"\\\"\");\n      }\n\n      this.aliasedClassDeclarations.set(aliasedDeclaration.node, declaration.name);\n    };\n    /**\n     * Get the top level statements for a module.\n     *\n     * In ES5 and ES2015 this is just the top level statements of the file.\n     * @param sourceFile The module whose statements we want.\n     * @returns An array of top level statements for the given module.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getModuleStatements = function (sourceFile) {\n      return Array.from(sourceFile.statements);\n    };\n    /**\n     * Walk the AST looking for an assignment to the specified symbol.\n     * @param node The current node we are searching.\n     * @returns an expression that represents the value of the variable, or undefined if none can be\n     * found.\n     */\n\n\n    Esm2015ReflectionHost.prototype.findDecoratedVariableValue = function (node, symbol) {\n      var _this = this;\n\n      if (!node) {\n        return null;\n      }\n\n      if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n        var left = node.left;\n        var right = node.right;\n\n        if (ts.isIdentifier(left) && this.checker.getSymbolAtLocation(left) === symbol) {\n          return ts.isCallExpression(right) && getCalleeName(right) === '__decorate' ? right : null;\n        }\n\n        return this.findDecoratedVariableValue(right, symbol);\n      }\n\n      return node.forEachChild(function (node) {\n        return _this.findDecoratedVariableValue(node, symbol);\n      }) || null;\n    };\n    /**\n     * Try to retrieve the symbol of a static property on a class.\n     *\n     * In some cases, a static property can either be set on the inner (implementation or adjacent)\n     * declaration inside the class' IIFE, or it can be set on the outer variable declaration.\n     * Therefore, the host checks all places, first looking up the property on the inner symbols, and\n     * if the property is not found it will fall back to looking up the property on the outer symbol.\n     *\n     * @param symbol the class whose property we are interested in.\n     * @param propertyName the name of static property.\n     * @returns the symbol if it is found or `undefined` if not.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getStaticProperty = function (symbol, propertyName) {\n      var _a, _b, _c, _d;\n\n      return ((_a = symbol.implementation.exports) === null || _a === void 0 ? void 0 : _a.get(propertyName)) || ((_c = (_b = symbol.adjacent) === null || _b === void 0 ? void 0 : _b.exports) === null || _c === void 0 ? void 0 : _c.get(propertyName)) || ((_d = symbol.declaration.exports) === null || _d === void 0 ? void 0 : _d.get(propertyName));\n    };\n    /**\n     * This is the main entry-point for obtaining information on the decorators of a given class. This\n     * information is computed either from static properties if present, or using `tslib.__decorate`\n     * helper calls otherwise. The computed result is cached per class.\n     *\n     * @param classSymbol the class for which decorators should be acquired.\n     * @returns all information of the decorators on the class.\n     */\n\n\n    Esm2015ReflectionHost.prototype.acquireDecoratorInfo = function (classSymbol) {\n      var decl = classSymbol.declaration.valueDeclaration;\n\n      if (this.decoratorCache.has(decl)) {\n        return this.decoratorCache.get(decl);\n      } // Extract decorators from static properties and `__decorate` helper calls, then merge them\n      // together where the information from the static properties is preferred.\n\n\n      var staticProps = this.computeDecoratorInfoFromStaticProperties(classSymbol);\n      var helperCalls = this.computeDecoratorInfoFromHelperCalls(classSymbol);\n      var decoratorInfo = {\n        classDecorators: staticProps.classDecorators || helperCalls.classDecorators,\n        memberDecorators: staticProps.memberDecorators || helperCalls.memberDecorators,\n        constructorParamInfo: staticProps.constructorParamInfo || helperCalls.constructorParamInfo\n      };\n      this.decoratorCache.set(decl, decoratorInfo);\n      return decoratorInfo;\n    };\n    /**\n     * Attempts to compute decorator information from static properties \"decorators\", \"propDecorators\"\n     * and \"ctorParameters\" on the class. If neither of these static properties is present the\n     * library is likely not compiled using tsickle for usage with Closure compiler, in which case\n     * `null` is returned.\n     *\n     * @param classSymbol The class symbol to compute the decorators information for.\n     * @returns All information on the decorators as extracted from static properties, or `null` if\n     * none of the static properties exist.\n     */\n\n\n    Esm2015ReflectionHost.prototype.computeDecoratorInfoFromStaticProperties = function (classSymbol) {\n      var classDecorators = null;\n      var memberDecorators = null;\n      var constructorParamInfo = null;\n      var decoratorsProperty = this.getStaticProperty(classSymbol, exports.DECORATORS);\n\n      if (decoratorsProperty !== undefined) {\n        classDecorators = this.getClassDecoratorsFromStaticProperty(decoratorsProperty);\n      }\n\n      var propDecoratorsProperty = this.getStaticProperty(classSymbol, exports.PROP_DECORATORS);\n\n      if (propDecoratorsProperty !== undefined) {\n        memberDecorators = this.getMemberDecoratorsFromStaticProperty(propDecoratorsProperty);\n      }\n\n      var constructorParamsProperty = this.getStaticProperty(classSymbol, exports.CONSTRUCTOR_PARAMS);\n\n      if (constructorParamsProperty !== undefined) {\n        constructorParamInfo = this.getParamInfoFromStaticProperty(constructorParamsProperty);\n      }\n\n      return {\n        classDecorators: classDecorators,\n        memberDecorators: memberDecorators,\n        constructorParamInfo: constructorParamInfo\n      };\n    };\n    /**\n     * Get all class decorators for the given class, where the decorators are declared\n     * via a static property. For example:\n     *\n     * ```\n     * class SomeDirective {}\n     * SomeDirective.decorators = [\n     *   { type: Directive, args: [{ selector: '[someDirective]' },] }\n     * ];\n     * ```\n     *\n     * @param decoratorsSymbol the property containing the decorators we want to get.\n     * @returns an array of decorators or null if none where found.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getClassDecoratorsFromStaticProperty = function (decoratorsSymbol) {\n      var _this = this;\n\n      var decoratorsIdentifier = decoratorsSymbol.valueDeclaration;\n\n      if (decoratorsIdentifier && decoratorsIdentifier.parent) {\n        if (ts.isBinaryExpression(decoratorsIdentifier.parent) && decoratorsIdentifier.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n          // AST of the array of decorator values\n          var decoratorsArray = decoratorsIdentifier.parent.right;\n          return this.reflectDecorators(decoratorsArray).filter(function (decorator) {\n            return _this.isFromCore(decorator);\n          });\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Examine a symbol which should be of a class, and return metadata about its members.\n     *\n     * @param symbol the `ClassSymbol` representing the class over which to reflect.\n     * @returns an array of `ClassMember` metadata representing the members of the class.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getMembersOfSymbol = function (symbol) {\n      var _this = this;\n\n      var members = []; // The decorators map contains all the properties that are decorated\n\n      var memberDecorators = this.acquireDecoratorInfo(symbol).memberDecorators; // Make a copy of the decorators as successfully reflected members delete themselves from the\n      // map, so that any leftovers can be easily dealt with.\n\n      var decoratorsMap = new Map(memberDecorators); // The member map contains all the method (instance and static); and any instance properties\n      // that are initialized in the class.\n\n      if (symbol.implementation.members) {\n        symbol.implementation.members.forEach(function (value, key) {\n          var decorators = decoratorsMap.get(key);\n\n          var reflectedMembers = _this.reflectMembers(value, decorators);\n\n          if (reflectedMembers) {\n            decoratorsMap.delete(key);\n            members.push.apply(members, tslib_1.__spread(reflectedMembers));\n          }\n        });\n      } // The static property map contains all the static properties\n\n\n      if (symbol.implementation.exports) {\n        symbol.implementation.exports.forEach(function (value, key) {\n          var decorators = decoratorsMap.get(key);\n\n          var reflectedMembers = _this.reflectMembers(value, decorators, true);\n\n          if (reflectedMembers) {\n            decoratorsMap.delete(key);\n            members.push.apply(members, tslib_1.__spread(reflectedMembers));\n          }\n        });\n      } // If this class was declared as a VariableDeclaration then it may have static properties\n      // attached to the variable rather than the class itself\n      // For example:\n      // ```\n      // let MyClass = class MyClass {\n      //   // no static properties here!\n      // }\n      // MyClass.staticProperty = ...;\n      // ```\n\n\n      if (ts.isVariableDeclaration(symbol.declaration.valueDeclaration)) {\n        if (symbol.declaration.exports) {\n          symbol.declaration.exports.forEach(function (value, key) {\n            var decorators = decoratorsMap.get(key);\n\n            var reflectedMembers = _this.reflectMembers(value, decorators, true);\n\n            if (reflectedMembers) {\n              decoratorsMap.delete(key);\n              members.push.apply(members, tslib_1.__spread(reflectedMembers));\n            }\n          });\n        }\n      } // If this class was declared as a VariableDeclaration inside an IIFE, then it may have static\n      // properties attached to the variable rather than the class itself.\n      //\n      // For example:\n      // ```\n      // let OuterClass = (() => {\n      //   let AdjacentClass = class InternalClass {\n      //     // no static properties here!\n      //   }\n      //   AdjacentClass.staticProperty = ...;\n      // })();\n      // ```\n\n\n      if (symbol.adjacent !== undefined) {\n        if (ts.isVariableDeclaration(symbol.adjacent.valueDeclaration)) {\n          if (symbol.adjacent.exports !== undefined) {\n            symbol.adjacent.exports.forEach(function (value, key) {\n              var decorators = decoratorsMap.get(key);\n\n              var reflectedMembers = _this.reflectMembers(value, decorators, true);\n\n              if (reflectedMembers) {\n                decoratorsMap.delete(key);\n                members.push.apply(members, tslib_1.__spread(reflectedMembers));\n              }\n            });\n          }\n        }\n      } // Deal with any decorated properties that were not initialized in the class\n\n\n      decoratorsMap.forEach(function (value, key) {\n        members.push({\n          implementation: null,\n          decorators: value,\n          isStatic: false,\n          kind: reflection_1.ClassMemberKind.Property,\n          name: key,\n          nameNode: null,\n          node: null,\n          type: null,\n          value: null\n        });\n      });\n      return members;\n    };\n    /**\n     * Member decorators may be declared as static properties of the class:\n     *\n     * ```\n     * SomeDirective.propDecorators = {\n     *   \"ngForOf\": [{ type: Input },],\n     *   \"ngForTrackBy\": [{ type: Input },],\n     *   \"ngForTemplate\": [{ type: Input },],\n     * };\n     * ```\n     *\n     * @param decoratorsProperty the class whose member decorators we are interested in.\n     * @returns a map whose keys are the name of the members and whose values are collections of\n     * decorators for the given member.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getMemberDecoratorsFromStaticProperty = function (decoratorsProperty) {\n      var _this = this;\n\n      var memberDecorators = new Map(); // Symbol of the identifier for `SomeDirective.propDecorators`.\n\n      var propDecoratorsMap = getPropertyValueFromSymbol(decoratorsProperty);\n\n      if (propDecoratorsMap && ts.isObjectLiteralExpression(propDecoratorsMap)) {\n        var propertiesMap = reflection_1.reflectObjectLiteral(propDecoratorsMap);\n        propertiesMap.forEach(function (value, name) {\n          var decorators = _this.reflectDecorators(value).filter(function (decorator) {\n            return _this.isFromCore(decorator);\n          });\n\n          if (decorators.length) {\n            memberDecorators.set(name, decorators);\n          }\n        });\n      }\n\n      return memberDecorators;\n    };\n    /**\n     * For a given class symbol, collects all decorator information from tslib helper methods, as\n     * generated by TypeScript into emitted JavaScript files.\n     *\n     * Class decorators are extracted from calls to `tslib.__decorate` that look as follows:\n     *\n     * ```\n     * let SomeDirective = class SomeDirective {}\n     * SomeDirective = __decorate([\n     *   Directive({ selector: '[someDirective]' }),\n     * ], SomeDirective);\n     * ```\n     *\n     * The extraction of member decorators is similar, with the distinction that its 2nd and 3rd\n     * argument correspond with a \"prototype\" target and the name of the member to which the\n     * decorators apply.\n     *\n     * ```\n     * __decorate([\n     *     Input(),\n     *     __metadata(\"design:type\", String)\n     * ], SomeDirective.prototype, \"input1\", void 0);\n     * ```\n     *\n     * @param classSymbol The class symbol for which decorators should be extracted.\n     * @returns All information on the decorators of the class.\n     */\n\n\n    Esm2015ReflectionHost.prototype.computeDecoratorInfoFromHelperCalls = function (classSymbol) {\n      var e_2, _a, e_3, _b, e_4, _c;\n\n      var _this = this;\n\n      var classDecorators = null;\n      var memberDecorators = new Map();\n      var constructorParamInfo = [];\n\n      var getConstructorParamInfo = function getConstructorParamInfo(index) {\n        var param = constructorParamInfo[index];\n\n        if (param === undefined) {\n          param = constructorParamInfo[index] = {\n            decorators: null,\n            typeExpression: null\n          };\n        }\n\n        return param;\n      }; // All relevant information can be extracted from calls to `__decorate`, obtain these first.\n      // Note that although the helper calls are retrieved using the class symbol, the result may\n      // contain helper calls corresponding with unrelated classes. Therefore, each helper call still\n      // has to be checked to actually correspond with the class symbol.\n\n\n      var helperCalls = this.getHelperCallsForClass(classSymbol, ['__decorate']);\n      var outerDeclaration = classSymbol.declaration.valueDeclaration;\n      var innerDeclaration = classSymbol.implementation.valueDeclaration;\n      var adjacentDeclaration = this.getAdjacentNameOfClassSymbol(classSymbol).parent;\n\n      var matchesClass = function matchesClass(identifier) {\n        var decl = _this.getDeclarationOfIdentifier(identifier);\n\n        return decl !== null && (decl.node === adjacentDeclaration || decl.node === outerDeclaration || decl.node === innerDeclaration);\n      };\n\n      try {\n        for (var helperCalls_1 = tslib_1.__values(helperCalls), helperCalls_1_1 = helperCalls_1.next(); !helperCalls_1_1.done; helperCalls_1_1 = helperCalls_1.next()) {\n          var helperCall = helperCalls_1_1.value;\n\n          if (isClassDecorateCall(helperCall, matchesClass)) {\n            // This `__decorate` call is targeting the class itself.\n            var helperArgs = helperCall.arguments[0];\n\n            try {\n              for (var _d = (e_3 = void 0, tslib_1.__values(helperArgs.elements)), _e = _d.next(); !_e.done; _e = _d.next()) {\n                var element = _e.value;\n                var entry = this.reflectDecorateHelperEntry(element);\n\n                if (entry === null) {\n                  continue;\n                }\n\n                if (entry.type === 'decorator') {\n                  // The helper arg was reflected to represent an actual decorator\n                  if (this.isFromCore(entry.decorator)) {\n                    (classDecorators || (classDecorators = [])).push(entry.decorator);\n                  }\n                } else if (entry.type === 'param:decorators') {\n                  // The helper arg represents a decorator for a parameter. Since it's applied to the\n                  // class, it corresponds with a constructor parameter of the class.\n                  var param = getConstructorParamInfo(entry.index);\n                  (param.decorators || (param.decorators = [])).push(entry.decorator);\n                } else if (entry.type === 'params') {\n                  // The helper arg represents the types of the parameters. Since it's applied to the\n                  // class, it corresponds with the constructor parameters of the class.\n                  entry.types.forEach(function (type, index) {\n                    return getConstructorParamInfo(index).typeExpression = type;\n                  });\n                }\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n          } else if (isMemberDecorateCall(helperCall, matchesClass)) {\n            // The `__decorate` call is targeting a member of the class\n            var helperArgs = helperCall.arguments[0];\n            var memberName = helperCall.arguments[2].text;\n\n            try {\n              for (var _f = (e_4 = void 0, tslib_1.__values(helperArgs.elements)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                var element = _g.value;\n                var entry = this.reflectDecorateHelperEntry(element);\n\n                if (entry === null) {\n                  continue;\n                }\n\n                if (entry.type === 'decorator') {\n                  // The helper arg was reflected to represent an actual decorator.\n                  if (this.isFromCore(entry.decorator)) {\n                    var decorators = memberDecorators.has(memberName) ? memberDecorators.get(memberName) : [];\n                    decorators.push(entry.decorator);\n                    memberDecorators.set(memberName, decorators);\n                  }\n                } else {// Information on decorated parameters is not interesting for ngcc, so it's ignored.\n                }\n              }\n            } catch (e_4_1) {\n              e_4 = {\n                error: e_4_1\n              };\n            } finally {\n              try {\n                if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n              } finally {\n                if (e_4) throw e_4.error;\n              }\n            }\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (helperCalls_1_1 && !helperCalls_1_1.done && (_a = helperCalls_1.return)) _a.call(helperCalls_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return {\n        classDecorators: classDecorators,\n        memberDecorators: memberDecorators,\n        constructorParamInfo: constructorParamInfo\n      };\n    };\n    /**\n     * Extract the details of an entry within a `__decorate` helper call. For example, given the\n     * following code:\n     *\n     * ```\n     * __decorate([\n     *   Directive({ selector: '[someDirective]' }),\n     *   tslib_1.__param(2, Inject(INJECTED_TOKEN)),\n     *   tslib_1.__metadata(\"design:paramtypes\", [ViewContainerRef, TemplateRef, String])\n     * ], SomeDirective);\n     * ```\n     *\n     * it can be seen that there are calls to regular decorators (the `Directive`) and calls into\n     * `tslib` functions which have been inserted by TypeScript. Therefore, this function classifies\n     * a call to correspond with\n     *   1. a real decorator like `Directive` above, or\n     *   2. a decorated parameter, corresponding with `__param` calls from `tslib`, or\n     *   3. the type information of parameters, corresponding with `__metadata` call from `tslib`\n     *\n     * @param expression the expression that needs to be reflected into a `DecorateHelperEntry`\n     * @returns an object that indicates which of the three categories the call represents, together\n     * with the reflected information of the call, or null if the call is not a valid decorate call.\n     */\n\n\n    Esm2015ReflectionHost.prototype.reflectDecorateHelperEntry = function (expression) {\n      // We only care about those elements that are actual calls\n      if (!ts.isCallExpression(expression)) {\n        return null;\n      }\n\n      var call = expression;\n      var helperName = getCalleeName(call);\n\n      if (helperName === '__metadata') {\n        // This is a `tslib.__metadata` call, reflect to arguments into a `ParameterTypes` object\n        // if the metadata key is \"design:paramtypes\".\n        var key = call.arguments[0];\n\n        if (key === undefined || !ts.isStringLiteral(key) || key.text !== 'design:paramtypes') {\n          return null;\n        }\n\n        var value = call.arguments[1];\n\n        if (value === undefined || !ts.isArrayLiteralExpression(value)) {\n          return null;\n        }\n\n        return {\n          type: 'params',\n          types: Array.from(value.elements)\n        };\n      }\n\n      if (helperName === '__param') {\n        // This is a `tslib.__param` call that is reflected into a `ParameterDecorators` object.\n        var indexArg = call.arguments[0];\n        var index = indexArg && ts.isNumericLiteral(indexArg) ? parseInt(indexArg.text, 10) : NaN;\n\n        if (isNaN(index)) {\n          return null;\n        }\n\n        var decoratorCall = call.arguments[1];\n\n        if (decoratorCall === undefined || !ts.isCallExpression(decoratorCall)) {\n          return null;\n        }\n\n        var decorator_1 = this.reflectDecoratorCall(decoratorCall);\n\n        if (decorator_1 === null) {\n          return null;\n        }\n\n        return {\n          type: 'param:decorators',\n          index: index,\n          decorator: decorator_1\n        };\n      } // Otherwise attempt to reflect it as a regular decorator.\n\n\n      var decorator = this.reflectDecoratorCall(call);\n\n      if (decorator === null) {\n        return null;\n      }\n\n      return {\n        type: 'decorator',\n        decorator: decorator\n      };\n    };\n\n    Esm2015ReflectionHost.prototype.reflectDecoratorCall = function (call) {\n      var decoratorExpression = call.expression;\n\n      if (!reflection_1.isDecoratorIdentifier(decoratorExpression)) {\n        return null;\n      } // We found a decorator!\n\n\n      var decoratorIdentifier = ts.isIdentifier(decoratorExpression) ? decoratorExpression : decoratorExpression.name;\n      return {\n        name: decoratorIdentifier.text,\n        identifier: decoratorExpression,\n        import: this.getImportOfIdentifier(decoratorIdentifier),\n        node: call,\n        args: Array.from(call.arguments)\n      };\n    };\n    /**\n     * Check the given statement to see if it is a call to any of the specified helper functions or\n     * null if not found.\n     *\n     * Matching statements will look like:  `tslib_1.__decorate(...);`.\n     * @param statement the statement that may contain the call.\n     * @param helperNames the names of the helper we are looking for.\n     * @returns the node that corresponds to the `__decorate(...)` call or null if the statement\n     * does not match.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getHelperCall = function (statement, helperNames) {\n      if ((ts.isExpressionStatement(statement) || ts.isReturnStatement(statement)) && statement.expression) {\n        var expression = statement.expression;\n\n        while (isAssignment(expression)) {\n          expression = expression.right;\n        }\n\n        if (ts.isCallExpression(expression)) {\n          var calleeName = getCalleeName(expression);\n\n          if (calleeName !== null && helperNames.includes(calleeName)) {\n            return expression;\n          }\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Reflect over the given array node and extract decorator information from each element.\n     *\n     * This is used for decorators that are defined in static properties. For example:\n     *\n     * ```\n     * SomeDirective.decorators = [\n     *   { type: Directive, args: [{ selector: '[someDirective]' },] }\n     * ];\n     * ```\n     *\n     * @param decoratorsArray an expression that contains decorator information.\n     * @returns an array of decorator info that was reflected from the array node.\n     */\n\n\n    Esm2015ReflectionHost.prototype.reflectDecorators = function (decoratorsArray) {\n      var _this = this;\n\n      var decorators = [];\n\n      if (ts.isArrayLiteralExpression(decoratorsArray)) {\n        // Add each decorator that is imported from `@angular/core` into the `decorators` array\n        decoratorsArray.elements.forEach(function (node) {\n          // If the decorator is not an object literal expression then we are not interested\n          if (ts.isObjectLiteralExpression(node)) {\n            // We are only interested in objects of the form: `{ type: DecoratorType, args: [...] }`\n            var decorator = reflection_1.reflectObjectLiteral(node); // Is the value of the `type` property an identifier?\n\n            if (decorator.has('type')) {\n              var decoratorType = decorator.get('type');\n\n              if (reflection_1.isDecoratorIdentifier(decoratorType)) {\n                var decoratorIdentifier = ts.isIdentifier(decoratorType) ? decoratorType : decoratorType.name;\n                decorators.push({\n                  name: decoratorIdentifier.text,\n                  identifier: decoratorType,\n                  import: _this.getImportOfIdentifier(decoratorIdentifier),\n                  node: node,\n                  args: getDecoratorArgs(node)\n                });\n              }\n            }\n          }\n        });\n      }\n\n      return decorators;\n    };\n    /**\n     * Reflect over a symbol and extract the member information, combining it with the\n     * provided decorator information, and whether it is a static member.\n     *\n     * A single symbol may represent multiple class members in the case of accessors;\n     * an equally named getter/setter accessor pair is combined into a single symbol.\n     * When the symbol is recognized as representing an accessor, its declarations are\n     * analyzed such that both the setter and getter accessor are returned as separate\n     * class members.\n     *\n     * One difference wrt the TypeScript host is that in ES2015, we cannot see which\n     * accessor originally had any decorators applied to them, as decorators are applied\n     * to the property descriptor in general, not a specific accessor. If an accessor\n     * has both a setter and getter, any decorators are only attached to the setter member.\n     *\n     * @param symbol the symbol for the member to reflect over.\n     * @param decorators an array of decorators associated with the member.\n     * @param isStatic true if this member is static, false if it is an instance property.\n     * @returns the reflected member information, or null if the symbol is not a member.\n     */\n\n\n    Esm2015ReflectionHost.prototype.reflectMembers = function (symbol, decorators, isStatic) {\n      if (symbol.flags & ts.SymbolFlags.Accessor) {\n        var members = [];\n        var setter = symbol.declarations && symbol.declarations.find(ts.isSetAccessor);\n        var getter = symbol.declarations && symbol.declarations.find(ts.isGetAccessor);\n        var setterMember = setter && this.reflectMember(setter, reflection_1.ClassMemberKind.Setter, decorators, isStatic);\n\n        if (setterMember) {\n          members.push(setterMember); // Prevent attaching the decorators to a potential getter. In ES2015, we can't tell where\n          // the decorators were originally attached to, however we only want to attach them to a\n          // single `ClassMember` as otherwise ngtsc would handle the same decorators twice.\n\n          decorators = undefined;\n        }\n\n        var getterMember = getter && this.reflectMember(getter, reflection_1.ClassMemberKind.Getter, decorators, isStatic);\n\n        if (getterMember) {\n          members.push(getterMember);\n        }\n\n        return members;\n      }\n\n      var kind = null;\n\n      if (symbol.flags & ts.SymbolFlags.Method) {\n        kind = reflection_1.ClassMemberKind.Method;\n      } else if (symbol.flags & ts.SymbolFlags.Property) {\n        kind = reflection_1.ClassMemberKind.Property;\n      }\n\n      var node = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];\n\n      if (!node) {\n        // If the symbol has been imported from a TypeScript typings file then the compiler\n        // may pass the `prototype` symbol as an export of the class.\n        // But this has no declaration. In this case we just quietly ignore it.\n        return null;\n      }\n\n      var member = this.reflectMember(node, kind, decorators, isStatic);\n\n      if (!member) {\n        return null;\n      }\n\n      return [member];\n    };\n    /**\n     * Reflect over a symbol and extract the member information, combining it with the\n     * provided decorator information, and whether it is a static member.\n     * @param node the declaration node for the member to reflect over.\n     * @param kind the assumed kind of the member, may become more accurate during reflection.\n     * @param decorators an array of decorators associated with the member.\n     * @param isStatic true if this member is static, false if it is an instance property.\n     * @returns the reflected member information, or null if the symbol is not a member.\n     */\n\n\n    Esm2015ReflectionHost.prototype.reflectMember = function (node, kind, decorators, isStatic) {\n      var value = null;\n      var name = null;\n      var nameNode = null;\n\n      if (!isClassMemberType(node)) {\n        return null;\n      }\n\n      if (isStatic && isPropertyAccess(node)) {\n        name = node.name.text;\n        value = kind === reflection_1.ClassMemberKind.Property ? node.parent.right : null;\n      } else if (isThisAssignment(node)) {\n        kind = reflection_1.ClassMemberKind.Property;\n        name = node.left.name.text;\n        value = node.right;\n        isStatic = false;\n      } else if (ts.isConstructorDeclaration(node)) {\n        kind = reflection_1.ClassMemberKind.Constructor;\n        name = 'constructor';\n        isStatic = false;\n      }\n\n      if (kind === null) {\n        this.logger.warn(\"Unknown member type: \\\"\" + node.getText());\n        return null;\n      }\n\n      if (!name) {\n        if (isNamedDeclaration(node)) {\n          name = node.name.text;\n          nameNode = node.name;\n        } else {\n          return null;\n        }\n      } // If we have still not determined if this is a static or instance member then\n      // look for the `static` keyword on the declaration\n\n\n      if (isStatic === undefined) {\n        isStatic = node.modifiers !== undefined && node.modifiers.some(function (mod) {\n          return mod.kind === ts.SyntaxKind.StaticKeyword;\n        });\n      }\n\n      var type = node.type || null;\n      return {\n        node: node,\n        implementation: node,\n        kind: kind,\n        type: type,\n        name: name,\n        nameNode: nameNode,\n        value: value,\n        isStatic: isStatic,\n        decorators: decorators || []\n      };\n    };\n    /**\n     * Find the declarations of the constructor parameters of a class identified by its symbol.\n     * @param classSymbol the class whose parameters we want to find.\n     * @returns an array of `ts.ParameterDeclaration` objects representing each of the parameters in\n     * the class's constructor or null if there is no constructor.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getConstructorParameterDeclarations = function (classSymbol) {\n      var members = classSymbol.implementation.members;\n\n      if (members && members.has(exports.CONSTRUCTOR)) {\n        var constructorSymbol = members.get(exports.CONSTRUCTOR); // For some reason the constructor does not have a `valueDeclaration` ?!?\n\n        var constructor = constructorSymbol.declarations && constructorSymbol.declarations[0];\n\n        if (!constructor) {\n          return [];\n        }\n\n        if (constructor.parameters.length > 0) {\n          return Array.from(constructor.parameters);\n        }\n\n        if (isSynthesizedConstructor(constructor)) {\n          return null;\n        }\n\n        return [];\n      }\n\n      return null;\n    };\n    /**\n     * Get the parameter decorators of a class constructor.\n     *\n     * @param classSymbol the class whose parameter info we want to get.\n     * @param parameterNodes the array of TypeScript parameter nodes for this class's constructor.\n     * @returns an array of constructor parameter info objects.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getConstructorParamInfo = function (classSymbol, parameterNodes) {\n      var _this = this;\n\n      var constructorParamInfo = this.acquireDecoratorInfo(classSymbol).constructorParamInfo;\n      return parameterNodes.map(function (node, index) {\n        var _a = constructorParamInfo[index] ? constructorParamInfo[index] : {\n          decorators: null,\n          typeExpression: null\n        },\n            decorators = _a.decorators,\n            typeExpression = _a.typeExpression;\n\n        var nameNode = node.name;\n\n        var typeValueReference = _this.typeToValue(typeExpression);\n\n        return {\n          name: utils_1.getNameText(nameNode),\n          nameNode: nameNode,\n          typeValueReference: typeValueReference,\n          typeNode: null,\n          decorators: decorators\n        };\n      });\n    };\n    /**\n     * Compute the `TypeValueReference` for the given `typeExpression`.\n     *\n     * Although `typeExpression` is a valid `ts.Expression` that could be emitted directly into the\n     * generated code, ngcc still needs to resolve the declaration and create an `IMPORTED` type\n     * value reference as the compiler has specialized handling for some symbols, for example\n     * `ChangeDetectorRef` from `@angular/core`. Such an `IMPORTED` type value reference will result\n     * in a newly generated namespace import, instead of emitting the original `typeExpression` as is.\n     */\n\n\n    Esm2015ReflectionHost.prototype.typeToValue = function (typeExpression) {\n      if (typeExpression === null) {\n        return {\n          kind: 2\n          /* UNAVAILABLE */\n          ,\n          reason: {\n            kind: 0\n            /* MISSING_TYPE */\n\n          }\n        };\n      }\n\n      var imp = this.getImportOfExpression(typeExpression);\n      var decl = this.getDeclarationOfExpression(typeExpression);\n\n      if (imp === null || decl === null) {\n        return {\n          kind: 0\n          /* LOCAL */\n          ,\n          expression: typeExpression,\n          defaultImportStatement: null\n        };\n      }\n\n      return {\n        kind: 1\n        /* IMPORTED */\n        ,\n        valueDeclaration: decl.node,\n        moduleName: imp.from,\n        importedName: imp.name,\n        nestedPath: null\n      };\n    };\n    /**\n     * Determines where the `expression` is imported from.\n     *\n     * @param expression the expression to determine the import details for.\n     * @returns the `Import` for the expression, or `null` if the expression is not imported or the\n     * expression syntax is not supported.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getImportOfExpression = function (expression) {\n      if (ts.isIdentifier(expression)) {\n        return this.getImportOfIdentifier(expression);\n      } else if (ts.isPropertyAccessExpression(expression) && ts.isIdentifier(expression.name)) {\n        return this.getImportOfIdentifier(expression.name);\n      } else {\n        return null;\n      }\n    };\n    /**\n     * Get the parameter type and decorators for the constructor of a class,\n     * where the information is stored on a static property of the class.\n     *\n     * Note that in ESM2015, the property is defined an array, or by an arrow function that returns\n     * an array, of decorator and type information.\n     *\n     * For example,\n     *\n     * ```\n     * SomeDirective.ctorParameters = () => [\n     *   {type: ViewContainerRef},\n     *   {type: TemplateRef},\n     *   {type: undefined, decorators: [{ type: Inject, args: [INJECTED_TOKEN]}]},\n     * ];\n     * ```\n     *\n     * or\n     *\n     * ```\n     * SomeDirective.ctorParameters = [\n     *   {type: ViewContainerRef},\n     *   {type: TemplateRef},\n     *   {type: undefined, decorators: [{type: Inject, args: [INJECTED_TOKEN]}]},\n     * ];\n     * ```\n     *\n     * @param paramDecoratorsProperty the property that holds the parameter info we want to get.\n     * @returns an array of objects containing the type and decorators for each parameter.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getParamInfoFromStaticProperty = function (paramDecoratorsProperty) {\n      var _this = this;\n\n      var paramDecorators = getPropertyValueFromSymbol(paramDecoratorsProperty);\n\n      if (paramDecorators) {\n        // The decorators array may be wrapped in an arrow function. If so unwrap it.\n        var container = ts.isArrowFunction(paramDecorators) ? paramDecorators.body : paramDecorators;\n\n        if (ts.isArrayLiteralExpression(container)) {\n          var elements = container.elements;\n          return elements.map(function (element) {\n            return ts.isObjectLiteralExpression(element) ? reflection_1.reflectObjectLiteral(element) : null;\n          }).map(function (paramInfo) {\n            var typeExpression = paramInfo && paramInfo.has('type') ? paramInfo.get('type') : null;\n            var decoratorInfo = paramInfo && paramInfo.has('decorators') ? paramInfo.get('decorators') : null;\n\n            var decorators = decoratorInfo && _this.reflectDecorators(decoratorInfo).filter(function (decorator) {\n              return _this.isFromCore(decorator);\n            });\n\n            return {\n              typeExpression: typeExpression,\n              decorators: decorators\n            };\n          });\n        } else if (paramDecorators !== undefined) {\n          this.logger.warn('Invalid constructor parameter decorator in ' + paramDecorators.getSourceFile().fileName + ':\\n', paramDecorators.getText());\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Search statements related to the given class for calls to the specified helper.\n     * @param classSymbol the class whose helper calls we are interested in.\n     * @param helperNames the names of the helpers (e.g. `__decorate`) whose calls we are interested\n     * in.\n     * @returns an array of CallExpression nodes for each matching helper call.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getHelperCallsForClass = function (classSymbol, helperNames) {\n      var _this = this;\n\n      return this.getStatementsForClass(classSymbol).map(function (statement) {\n        return _this.getHelperCall(statement, helperNames);\n      }).filter(utils_1.isDefined);\n    };\n    /**\n     * Find statements related to the given class that may contain calls to a helper.\n     *\n     * In ESM2015 code the helper calls are in the top level module, so we have to consider\n     * all the statements in the module.\n     *\n     * @param classSymbol the class whose helper calls we are interested in.\n     * @returns an array of statements that may contain helper calls.\n     */\n\n\n    Esm2015ReflectionHost.prototype.getStatementsForClass = function (classSymbol) {\n      var classNode = classSymbol.implementation.valueDeclaration;\n\n      if (isTopLevel(classNode)) {\n        return this.getModuleStatements(classNode.getSourceFile());\n      }\n\n      var statement = getContainingStatement(classNode);\n\n      if (ts.isBlock(statement.parent)) {\n        return Array.from(statement.parent.statements);\n      } // We should never arrive here\n\n\n      throw new Error(\"Unable to find adjacent statements for \" + classSymbol.name);\n    };\n    /**\n     * Test whether a decorator was imported from `@angular/core`.\n     *\n     * Is the decorator:\n     * * externally imported from `@angular/core`?\n     * * the current hosted program is actually `@angular/core` and\n     *   - relatively internally imported; or\n     *   - not imported, from the current file.\n     *\n     * @param decorator the decorator to test.\n     */\n\n\n    Esm2015ReflectionHost.prototype.isFromCore = function (decorator) {\n      if (this.isCore) {\n        return !decorator.import || /^\\./.test(decorator.import.from);\n      } else {\n        return !!decorator.import && decorator.import.from === '@angular/core';\n      }\n    };\n    /**\n     * Create a mapping between the public exports in a src program and the public exports of a dts\n     * program.\n     *\n     * @param src the program bundle containing the source files.\n     * @param dts the program bundle containing the typings files.\n     * @returns a map of source declarations to typings declarations.\n     */\n\n\n    Esm2015ReflectionHost.prototype.computePublicDtsDeclarationMap = function (src, dts) {\n      var declarationMap = new Map();\n      var dtsDeclarationMap = new Map();\n      var rootDts = getRootFileOrFail(dts);\n      this.collectDtsExportedDeclarations(dtsDeclarationMap, rootDts, dts.program.getTypeChecker());\n      var rootSrc = getRootFileOrFail(src);\n      this.collectSrcExportedDeclarations(declarationMap, dtsDeclarationMap, rootSrc);\n      return declarationMap;\n    };\n    /**\n     * Create a mapping between the \"private\" exports in a src program and the \"private\" exports of a\n     * dts program. These exports may be exported from individual files in the src or dts programs,\n     * but not exported from the root file (i.e publicly from the entry-point).\n     *\n     * This mapping is a \"best guess\" since we cannot guarantee that two declarations that happen to\n     * be exported from a file with the same name are actually equivalent. But this is a reasonable\n     * estimate for the purposes of ngcc.\n     *\n     * @param src the program bundle containing the source files.\n     * @param dts the program bundle containing the typings files.\n     * @returns a map of source declarations to typings declarations.\n     */\n\n\n    Esm2015ReflectionHost.prototype.computePrivateDtsDeclarationMap = function (src, dts) {\n      var e_5, _a, e_6, _b;\n\n      var declarationMap = new Map();\n      var dtsDeclarationMap = new Map();\n      var typeChecker = dts.program.getTypeChecker();\n      var dtsFiles = getNonRootPackageFiles(dts);\n\n      try {\n        for (var dtsFiles_1 = tslib_1.__values(dtsFiles), dtsFiles_1_1 = dtsFiles_1.next(); !dtsFiles_1_1.done; dtsFiles_1_1 = dtsFiles_1.next()) {\n          var dtsFile = dtsFiles_1_1.value;\n          this.collectDtsExportedDeclarations(dtsDeclarationMap, dtsFile, typeChecker);\n        }\n      } catch (e_5_1) {\n        e_5 = {\n          error: e_5_1\n        };\n      } finally {\n        try {\n          if (dtsFiles_1_1 && !dtsFiles_1_1.done && (_a = dtsFiles_1.return)) _a.call(dtsFiles_1);\n        } finally {\n          if (e_5) throw e_5.error;\n        }\n      }\n\n      var srcFiles = getNonRootPackageFiles(src);\n\n      try {\n        for (var srcFiles_1 = tslib_1.__values(srcFiles), srcFiles_1_1 = srcFiles_1.next(); !srcFiles_1_1.done; srcFiles_1_1 = srcFiles_1.next()) {\n          var srcFile = srcFiles_1_1.value;\n          this.collectSrcExportedDeclarations(declarationMap, dtsDeclarationMap, srcFile);\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (srcFiles_1_1 && !srcFiles_1_1.done && (_b = srcFiles_1.return)) _b.call(srcFiles_1);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n\n      return declarationMap;\n    };\n    /**\n     * Collect mappings between names of exported declarations in a file and its actual declaration.\n     *\n     * Any new mappings are added to the `dtsDeclarationMap`.\n     */\n\n\n    Esm2015ReflectionHost.prototype.collectDtsExportedDeclarations = function (dtsDeclarationMap, srcFile, checker) {\n      var srcModule = srcFile && checker.getSymbolAtLocation(srcFile);\n      var moduleExports = srcModule && checker.getExportsOfModule(srcModule);\n\n      if (moduleExports) {\n        moduleExports.forEach(function (exportedSymbol) {\n          var name = exportedSymbol.name;\n\n          if (exportedSymbol.flags & ts.SymbolFlags.Alias) {\n            exportedSymbol = checker.getAliasedSymbol(exportedSymbol);\n          }\n\n          var declaration = exportedSymbol.valueDeclaration;\n\n          if (declaration && !dtsDeclarationMap.has(name)) {\n            dtsDeclarationMap.set(name, declaration);\n          }\n        });\n      }\n    };\n\n    Esm2015ReflectionHost.prototype.collectSrcExportedDeclarations = function (declarationMap, dtsDeclarationMap, srcFile) {\n      var e_7, _a;\n\n      var fileExports = this.getExportsOfModule(srcFile);\n\n      if (fileExports !== null) {\n        try {\n          for (var fileExports_1 = tslib_1.__values(fileExports), fileExports_1_1 = fileExports_1.next(); !fileExports_1_1.done; fileExports_1_1 = fileExports_1.next()) {\n            var _b = tslib_1.__read(fileExports_1_1.value, 2),\n                exportName = _b[0],\n                declarationNode = _b[1].node;\n\n            if (dtsDeclarationMap.has(exportName)) {\n              declarationMap.set(declarationNode, dtsDeclarationMap.get(exportName));\n            }\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (fileExports_1_1 && !fileExports_1_1.done && (_a = fileExports_1.return)) _a.call(fileExports_1);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n      }\n    };\n\n    Esm2015ReflectionHost.prototype.getDeclarationOfExpression = function (expression) {\n      if (ts.isIdentifier(expression)) {\n        return this.getDeclarationOfIdentifier(expression);\n      }\n\n      if (!ts.isPropertyAccessExpression(expression) || !ts.isIdentifier(expression.expression)) {\n        return null;\n      }\n\n      var namespaceDecl = this.getDeclarationOfIdentifier(expression.expression);\n\n      if (!namespaceDecl || !ts.isSourceFile(namespaceDecl.node)) {\n        return null;\n      }\n\n      var namespaceExports = this.getExportsOfModule(namespaceDecl.node);\n\n      if (namespaceExports === null) {\n        return null;\n      }\n\n      if (!namespaceExports.has(expression.name.text)) {\n        return null;\n      }\n\n      var exportDecl = namespaceExports.get(expression.name.text);\n      return tslib_1.__assign(tslib_1.__assign({}, exportDecl), {\n        viaModule: namespaceDecl.viaModule\n      });\n    };\n    /** Checks if the specified declaration resolves to the known JavaScript global `Object`. */\n\n\n    Esm2015ReflectionHost.prototype.isJavaScriptObjectDeclaration = function (decl) {\n      var node = decl.node; // The default TypeScript library types the global `Object` variable through\n      // a variable declaration with a type reference resolving to `ObjectConstructor`.\n\n      if (!ts.isVariableDeclaration(node) || !ts.isIdentifier(node.name) || node.name.text !== 'Object' || node.type === undefined) {\n        return false;\n      }\n\n      var typeNode = node.type; // If the variable declaration does not have a type resolving to `ObjectConstructor`,\n      // we cannot guarantee that the declaration resolves to the global `Object` variable.\n\n      if (!ts.isTypeReferenceNode(typeNode) || !ts.isIdentifier(typeNode.typeName) || typeNode.typeName.text !== 'ObjectConstructor') {\n        return false;\n      } // Finally, check if the type definition for `Object` originates from a default library\n      // definition file. This requires default types to be enabled for the host program.\n\n\n      return this.src.program.isSourceFileDefaultLibrary(node.getSourceFile());\n    };\n    /**\n     * In JavaScript, enum declarations are emitted as a regular variable declaration followed by an\n     * IIFE in which the enum members are assigned.\n     *\n     *   export var Enum;\n     *   (function (Enum) {\n     *     Enum[\"a\"] = \"A\";\n     *     Enum[\"b\"] = \"B\";\n     *   })(Enum || (Enum = {}));\n     *\n     * @param declaration A variable declaration that may represent an enum\n     * @returns An array of enum members if the variable declaration is followed by an IIFE that\n     * declares the enum members, or null otherwise.\n     */\n\n\n    Esm2015ReflectionHost.prototype.resolveEnumMembers = function (declaration) {\n      // Initialized variables don't represent enum declarations.\n      if (declaration.initializer !== undefined) return null;\n      var variableStmt = declaration.parent.parent;\n      if (!ts.isVariableStatement(variableStmt)) return null;\n      var block = variableStmt.parent;\n      if (!ts.isBlock(block) && !ts.isSourceFile(block)) return null;\n      var declarationIndex = block.statements.findIndex(function (statement) {\n        return statement === variableStmt;\n      });\n      if (declarationIndex === -1 || declarationIndex === block.statements.length - 1) return null;\n      var subsequentStmt = block.statements[declarationIndex + 1];\n      if (!ts.isExpressionStatement(subsequentStmt)) return null;\n      var iife = utils_2.stripParentheses(subsequentStmt.expression);\n      if (!ts.isCallExpression(iife) || !isEnumDeclarationIife(iife)) return null;\n      var fn = utils_2.stripParentheses(iife.expression);\n      if (!ts.isFunctionExpression(fn)) return null;\n      return this.reflectEnumMembers(fn);\n    };\n    /**\n     * Attempts to extract all `EnumMember`s from a function that is according to the JavaScript emit\n     * format for enums:\n     *\n     *   function (Enum) {\n     *     Enum[\"MemberA\"] = \"a\";\n     *     Enum[\"MemberB\"] = \"b\";\n     *   }\n     *\n     * @param fn The function expression that is assumed to contain enum members.\n     * @returns All enum members if the function is according to the correct syntax, null otherwise.\n     */\n\n\n    Esm2015ReflectionHost.prototype.reflectEnumMembers = function (fn) {\n      var e_8, _a;\n\n      if (fn.parameters.length !== 1) return null;\n      var enumName = fn.parameters[0].name;\n      if (!ts.isIdentifier(enumName)) return null;\n      var enumMembers = [];\n\n      try {\n        for (var _b = tslib_1.__values(fn.body.statements), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var statement = _c.value;\n          var enumMember = this.reflectEnumMember(enumName, statement);\n\n          if (enumMember === null) {\n            return null;\n          }\n\n          enumMembers.push(enumMember);\n        }\n      } catch (e_8_1) {\n        e_8 = {\n          error: e_8_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_8) throw e_8.error;\n        }\n      }\n\n      return enumMembers;\n    };\n    /**\n     * Attempts to extract a single `EnumMember` from a statement in the following syntax:\n     *\n     *   Enum[\"MemberA\"] = \"a\";\n     *\n     * or, for enum member with numeric values:\n     *\n     *   Enum[Enum[\"MemberA\"] = 0] = \"MemberA\";\n     *\n     * @param enumName The identifier of the enum that the members should be set on.\n     * @param statement The statement to inspect.\n     * @returns An `EnumMember` if the statement is according to the expected syntax, null otherwise.\n     */\n\n\n    Esm2015ReflectionHost.prototype.reflectEnumMember = function (enumName, statement) {\n      if (!ts.isExpressionStatement(statement)) return null;\n      var expression = statement.expression; // Check for the `Enum[X] = Y;` case.\n\n      if (!isEnumAssignment(enumName, expression)) {\n        return null;\n      }\n\n      var assignment = reflectEnumAssignment(expression);\n\n      if (assignment != null) {\n        return assignment;\n      } // Check for the `Enum[Enum[X] = Y] = ...;` case.\n\n\n      var innerExpression = expression.left.argumentExpression;\n\n      if (!isEnumAssignment(enumName, innerExpression)) {\n        return null;\n      }\n\n      return reflectEnumAssignment(innerExpression);\n    };\n\n    Esm2015ReflectionHost.prototype.getAdjacentNameOfClassSymbol = function (classSymbol) {\n      if (classSymbol.adjacent !== undefined) {\n        return this.getNameFromClassSymbolDeclaration(classSymbol, classSymbol.adjacent.valueDeclaration);\n      } else {\n        return this.getNameFromClassSymbolDeclaration(classSymbol, classSymbol.implementation.valueDeclaration);\n      }\n    };\n\n    return Esm2015ReflectionHost;\n  }(reflection_1.TypeScriptReflectionHost);\n\n  exports.Esm2015ReflectionHost = Esm2015ReflectionHost; ///////////// Exported Helpers /////////////\n\n  /**\n   * Checks whether the iife has the following call signature:\n   *\n   *   (Enum || (Enum = {})\n   *\n   * Note that the `Enum` identifier is not checked, as it could also be something\n   * like `exports.Enum`. Instead, only the structure of binary operators is checked.\n   *\n   * @param iife The call expression to check.\n   * @returns true if the iife has a call signature that corresponds with a potential\n   * enum declaration.\n   */\n\n  function isEnumDeclarationIife(iife) {\n    if (iife.arguments.length !== 1) return false;\n    var arg = iife.arguments[0];\n\n    if (!ts.isBinaryExpression(arg) || arg.operatorToken.kind !== ts.SyntaxKind.BarBarToken || !ts.isParenthesizedExpression(arg.right)) {\n      return false;\n    }\n\n    var right = arg.right.expression;\n\n    if (!ts.isBinaryExpression(right) || right.operatorToken.kind !== ts.SyntaxKind.EqualsToken) {\n      return false;\n    }\n\n    if (!ts.isObjectLiteralExpression(right.right) || right.right.properties.length !== 0) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Checks whether the expression looks like an enum member assignment targeting `Enum`:\n   *\n   *   Enum[X] = Y;\n   *\n   * Here, X and Y can be any expression.\n   *\n   * @param enumName The identifier of the enum that the members should be set on.\n   * @param expression The expression that should be checked to conform to the above form.\n   * @returns true if the expression is of the correct form, false otherwise.\n   */\n\n\n  function isEnumAssignment(enumName, expression) {\n    if (!ts.isBinaryExpression(expression) || expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken || !ts.isElementAccessExpression(expression.left)) {\n      return false;\n    } // Verify that the outer assignment corresponds with the enum declaration.\n\n\n    var enumIdentifier = expression.left.expression;\n    return ts.isIdentifier(enumIdentifier) && enumIdentifier.text === enumName.text;\n  }\n  /**\n   * Attempts to create an `EnumMember` from an expression that is believed to represent an enum\n   * assignment.\n   *\n   * @param expression The expression that is believed to be an enum assignment.\n   * @returns An `EnumMember` or null if the expression did not represent an enum member after all.\n   */\n\n\n  function reflectEnumAssignment(expression) {\n    var memberName = expression.left.argumentExpression;\n    if (!ts.isPropertyName(memberName)) return null;\n    return {\n      name: memberName,\n      initializer: expression.right\n    };\n  }\n  /**\n   * Test whether a statement node is an assignment statement.\n   * @param statement the statement to test.\n   */\n\n\n  function isAssignmentStatement(statement) {\n    return ts.isExpressionStatement(statement) && isAssignment(statement.expression) && ts.isIdentifier(statement.expression.left);\n  }\n\n  exports.isAssignmentStatement = isAssignmentStatement;\n  /**\n   * Parse the `expression` that is believed to be an IIFE and return the AST node that corresponds to\n   * the body of the IIFE.\n   *\n   * The expression may be wrapped in parentheses, which are stripped off.\n   *\n   * If the IIFE is an arrow function then its body could be a `ts.Expression` rather than a\n   * `ts.FunctionBody`.\n   *\n   * @param expression the expression to parse.\n   * @returns the `ts.Expression` or `ts.FunctionBody` that holds the body of the IIFE or `undefined`\n   *     if the `expression` did not have the correct shape.\n   */\n\n  function getIifeBody(expression) {\n    var call = utils_2.stripParentheses(expression);\n\n    if (!ts.isCallExpression(call)) {\n      return undefined;\n    }\n\n    var fn = utils_2.stripParentheses(call.expression);\n\n    if (!ts.isFunctionExpression(fn) && !ts.isArrowFunction(fn)) {\n      return undefined;\n    }\n\n    return fn.body;\n  }\n\n  exports.getIifeBody = getIifeBody;\n  /**\n   * Returns true if the `node` is an assignment of the form `a = b`.\n   *\n   * @param node The AST node to check.\n   */\n\n  function isAssignment(node) {\n    return ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n  }\n\n  exports.isAssignment = isAssignment;\n  /**\n   * Tests whether the provided call expression targets a class, by verifying its arguments are\n   * according to the following form:\n   *\n   * ```\n   * __decorate([], SomeDirective);\n   * ```\n   *\n   * @param call the call expression that is tested to represent a class decorator call.\n   * @param matches predicate function to test whether the call is associated with the desired class.\n   */\n\n  function isClassDecorateCall(call, matches) {\n    var helperArgs = call.arguments[0];\n\n    if (helperArgs === undefined || !ts.isArrayLiteralExpression(helperArgs)) {\n      return false;\n    }\n\n    var target = call.arguments[1];\n    return target !== undefined && ts.isIdentifier(target) && matches(target);\n  }\n\n  exports.isClassDecorateCall = isClassDecorateCall;\n  /**\n   * Tests whether the provided call expression targets a member of the class, by verifying its\n   * arguments are according to the following form:\n   *\n   * ```\n   * __decorate([], SomeDirective.prototype, \"member\", void 0);\n   * ```\n   *\n   * @param call the call expression that is tested to represent a member decorator call.\n   * @param matches predicate function to test whether the call is associated with the desired class.\n   */\n\n  function isMemberDecorateCall(call, matches) {\n    var helperArgs = call.arguments[0];\n\n    if (helperArgs === undefined || !ts.isArrayLiteralExpression(helperArgs)) {\n      return false;\n    }\n\n    var target = call.arguments[1];\n\n    if (target === undefined || !ts.isPropertyAccessExpression(target) || !ts.isIdentifier(target.expression) || !matches(target.expression) || target.name.text !== 'prototype') {\n      return false;\n    }\n\n    var memberName = call.arguments[2];\n    return memberName !== undefined && ts.isStringLiteral(memberName);\n  }\n\n  exports.isMemberDecorateCall = isMemberDecorateCall;\n  /**\n   * Helper method to extract the value of a property given the property's \"symbol\",\n   * which is actually the symbol of the identifier of the property.\n   */\n\n  function getPropertyValueFromSymbol(propSymbol) {\n    var propIdentifier = propSymbol.valueDeclaration;\n    var parent = propIdentifier && propIdentifier.parent;\n    return parent && ts.isBinaryExpression(parent) ? parent.right : undefined;\n  }\n\n  exports.getPropertyValueFromSymbol = getPropertyValueFromSymbol;\n  /**\n   * A callee could be one of: `__decorate(...)` or `tslib_1.__decorate`.\n   */\n\n  function getCalleeName(call) {\n    if (ts.isIdentifier(call.expression)) {\n      return utils_1.stripDollarSuffix(call.expression.text);\n    }\n\n    if (ts.isPropertyAccessExpression(call.expression)) {\n      return utils_1.stripDollarSuffix(call.expression.name.text);\n    }\n\n    return null;\n  }\n\n  function isInitializedVariableClassDeclaration(node) {\n    return reflection_1.isNamedVariableDeclaration(node) && node.initializer !== undefined;\n  }\n  /**\n   * Handle a variable declaration of the form\n   *\n   * ```\n   * var MyClass = alias1 = alias2 = <<declaration>>\n   * ```\n   *\n   * @param node the LHS of a variable declaration.\n   * @returns the original AST node or the RHS of a series of assignments in a variable\n   *     declaration.\n   */\n\n\n  function skipClassAliases(node) {\n    var expression = node.initializer;\n\n    while (isAssignment(expression)) {\n      expression = expression.right;\n    }\n\n    return expression;\n  }\n\n  exports.skipClassAliases = skipClassAliases;\n  /**\n   * This expression could either be a class expression\n   *\n   * ```\n   * class MyClass {};\n   * ```\n   *\n   * or an IIFE wrapped class expression\n   *\n   * ```\n   * (() => {\n   *   class MyClass {}\n   *   ...\n   *   return MyClass;\n   * })()\n   * ```\n   *\n   * or an IIFE wrapped aliased class expression\n   *\n   * ```\n   * (() => {\n   *   let MyClass = class MyClass {}\n   *   ...\n   *   return MyClass;\n   * })()\n   * ```\n   *\n   * or an IFFE wrapped ES5 class function\n   *\n   * ```\n   * (function () {\n   *  function MyClass() {}\n   *  ...\n   *  return MyClass\n   * })()\n   * ```\n   *\n   * @param expression the node that represents the class whose declaration we are finding.\n   * @returns the declaration of the class or `null` if it is not a \"class\".\n   */\n\n  function getInnerClassDeclaration(expression) {\n    var e_9, _a, e_10, _b;\n\n    if (ts.isClassExpression(expression) && utils_1.hasNameIdentifier(expression)) {\n      return expression;\n    }\n\n    var iifeBody = getIifeBody(expression);\n\n    if (iifeBody === undefined) {\n      return null;\n    }\n\n    if (!ts.isBlock(iifeBody)) {\n      // Handle the fat arrow expression case: `() => ClassExpression`\n      return ts.isClassExpression(iifeBody) && isNamedDeclaration(iifeBody) ? iifeBody : null;\n    } else {\n      try {\n        // Handle the case of a normal or fat-arrow function with a body.\n        // Return the first ClassDeclaration/VariableDeclaration inside the body\n        for (var _c = tslib_1.__values(iifeBody.statements), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var statement = _d.value;\n\n          if (reflection_1.isNamedClassDeclaration(statement) || reflection_1.isNamedFunctionDeclaration(statement)) {\n            return statement;\n          }\n\n          if (ts.isVariableStatement(statement)) {\n            try {\n              for (var _e = (e_10 = void 0, tslib_1.__values(statement.declarationList.declarations)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var declaration = _f.value;\n\n                if (isInitializedVariableClassDeclaration(declaration)) {\n                  var expression_1 = skipClassAliases(declaration);\n\n                  if (ts.isClassExpression(expression_1) && utils_1.hasNameIdentifier(expression_1)) {\n                    return expression_1;\n                  }\n                }\n              }\n            } catch (e_10_1) {\n              e_10 = {\n                error: e_10_1\n              };\n            } finally {\n              try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n              } finally {\n                if (e_10) throw e_10.error;\n              }\n            }\n          }\n        }\n      } catch (e_9_1) {\n        e_9 = {\n          error: e_9_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_9) throw e_9.error;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  exports.getInnerClassDeclaration = getInnerClassDeclaration;\n\n  function getDecoratorArgs(node) {\n    // The arguments of a decorator are held in the `args` property of its declaration object.\n    var argsProperty = node.properties.filter(ts.isPropertyAssignment).find(function (property) {\n      return utils_1.getNameText(property.name) === 'args';\n    });\n    var argsExpression = argsProperty && argsProperty.initializer;\n    return argsExpression && ts.isArrayLiteralExpression(argsExpression) ? Array.from(argsExpression.elements) : [];\n  }\n\n  function isPropertyAccess(node) {\n    return !!node.parent && ts.isBinaryExpression(node.parent) && ts.isPropertyAccessExpression(node);\n  }\n\n  function isThisAssignment(node) {\n    return ts.isBinaryExpression(node) && ts.isPropertyAccessExpression(node.left) && node.left.expression.kind === ts.SyntaxKind.ThisKeyword;\n  }\n\n  function isNamedDeclaration(node) {\n    var anyNode = node;\n    return !!anyNode.name && ts.isIdentifier(anyNode.name);\n  }\n\n  function isClassMemberType(node) {\n    return (ts.isClassElement(node) || isPropertyAccess(node) || ts.isBinaryExpression(node)) && // Additionally, ensure `node` is not an index signature, for example on an abstract class:\n    // `abstract class Foo { [key: string]: any; }`\n    !ts.isIndexSignatureDeclaration(node);\n  }\n  /**\n   * Attempt to resolve the variable declaration that the given declaration is assigned to.\n   * For example, for the following code:\n   *\n   * ```\n   * var MyClass = MyClass_1 = class MyClass {};\n   * ```\n   *\n   * or\n   *\n   * ```\n   * var MyClass = MyClass_1 = (() => {\n   *   class MyClass {}\n   *   ...\n   *   return MyClass;\n   * })()\n    ```\n   *\n   * and the provided declaration being `class MyClass {}`, this will return the `var MyClass`\n   * declaration.\n   *\n   * @param declaration The declaration for which any variable declaration should be obtained.\n   * @returns the outer variable declaration if found, undefined otherwise.\n   */\n\n\n  function getFarLeftHandSideOfAssignment(declaration) {\n    var node = declaration.parent; // Detect an intermediary variable assignment and skip over it.\n\n    if (isAssignment(node) && ts.isIdentifier(node.left)) {\n      node = node.parent;\n    }\n\n    return ts.isVariableDeclaration(node) ? node : undefined;\n  }\n\n  function getContainingVariableDeclaration(node) {\n    node = node.parent;\n\n    while (node !== undefined) {\n      if (reflection_1.isNamedVariableDeclaration(node)) {\n        return node;\n      }\n\n      node = node.parent;\n    }\n\n    return undefined;\n  }\n  /**\n   * A constructor function may have been \"synthesized\" by TypeScript during JavaScript emit,\n   * in the case no user-defined constructor exists and e.g. property initializers are used.\n   * Those initializers need to be emitted into a constructor in JavaScript, so the TypeScript\n   * compiler generates a synthetic constructor.\n   *\n   * We need to identify such constructors as ngcc needs to be able to tell if a class did\n   * originally have a constructor in the TypeScript source. When a class has a superclass,\n   * a synthesized constructor must not be considered as a user-defined constructor as that\n   * prevents a base factory call from being created by ngtsc, resulting in a factory function\n   * that does not inject the dependencies of the superclass. Hence, we identify a default\n   * synthesized super call in the constructor body, according to the structure that TypeScript\n   * emits during JavaScript emit:\n   * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/ts.ts#L1068-L1082\n   *\n   * @param constructor a constructor function to test\n   * @returns true if the constructor appears to have been synthesized\n   */\n\n\n  function isSynthesizedConstructor(constructor) {\n    if (!constructor.body) return false;\n    var firstStatement = constructor.body.statements[0];\n    if (!firstStatement || !ts.isExpressionStatement(firstStatement)) return false;\n    return isSynthesizedSuperCall(firstStatement.expression);\n  }\n  /**\n   * Tests whether the expression appears to have been synthesized by TypeScript, i.e. whether\n   * it is of the following form:\n   *\n   * ```\n   * super(...arguments);\n   * ```\n   *\n   * @param expression the expression that is to be tested\n   * @returns true if the expression appears to be a synthesized super call\n   */\n\n\n  function isSynthesizedSuperCall(expression) {\n    if (!ts.isCallExpression(expression)) return false;\n    if (expression.expression.kind !== ts.SyntaxKind.SuperKeyword) return false;\n    if (expression.arguments.length !== 1) return false;\n    var argument = expression.arguments[0];\n    return ts.isSpreadElement(argument) && ts.isIdentifier(argument.expression) && argument.expression.text === 'arguments';\n  }\n  /**\n   * Find the statement that contains the given node\n   * @param node a node whose containing statement we wish to find\n   */\n\n\n  function getContainingStatement(node) {\n    while (node.parent) {\n      if (ts.isBlock(node.parent) || ts.isSourceFile(node.parent)) {\n        break;\n      }\n\n      node = node.parent;\n    }\n\n    return node;\n  }\n\n  exports.getContainingStatement = getContainingStatement;\n\n  function getRootFileOrFail(bundle) {\n    var rootFile = bundle.program.getSourceFile(bundle.path);\n\n    if (rootFile === undefined) {\n      throw new Error(\"The given rootPath \" + rootFile + \" is not a file of the program.\");\n    }\n\n    return rootFile;\n  }\n\n  function getNonRootPackageFiles(bundle) {\n    var rootFile = bundle.program.getSourceFile(bundle.path);\n    return bundle.program.getSourceFiles().filter(function (f) {\n      return f !== rootFile && util_1.isWithinPackage(bundle.package, file_system_1.absoluteFromSourceFile(f));\n    });\n  }\n\n  function isTopLevel(node) {\n    while (node = node.parent) {\n      if (ts.isBlock(node)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Get a node that represents the actual (outer) declaration of a class from its implementation.\n   *\n   * Sometimes, the implementation of a class is an expression that is hidden inside an IIFE and\n   * assigned to a variable outside the IIFE, which is what the rest of the program interacts with.\n   * For example,\n   *\n   * ```\n   * OuterNode = Alias = (function() { function InnerNode() {} return InnerNode; })();\n   * ```\n   *\n   * @param node a node that could be the implementation inside an IIFE.\n   * @returns a node that represents the outer declaration, or `null` if it is does not match the IIFE\n   *     format shown above.\n   */\n\n\n  function getOuterNodeFromInnerDeclaration(node) {\n    if (!ts.isFunctionDeclaration(node) && !ts.isClassDeclaration(node) && !ts.isVariableStatement(node)) {\n      return null;\n    } // It might be the function expression inside the IIFE. We need to go 5 levels up...\n    // - IIFE body.\n\n\n    var outerNode = node.parent;\n    if (!outerNode || !ts.isBlock(outerNode)) return null; // - IIFE function expression.\n\n    outerNode = outerNode.parent;\n\n    if (!outerNode || !ts.isFunctionExpression(outerNode) && !ts.isArrowFunction(outerNode)) {\n      return null;\n    }\n\n    outerNode = outerNode.parent; // - Parenthesis inside IIFE.\n\n    if (outerNode && ts.isParenthesizedExpression(outerNode)) outerNode = outerNode.parent; // - IIFE call expression.\n\n    if (!outerNode || !ts.isCallExpression(outerNode)) return null;\n    outerNode = outerNode.parent; // - Parenthesis around IIFE.\n\n    if (outerNode && ts.isParenthesizedExpression(outerNode)) outerNode = outerNode.parent; // - Skip any aliases between the IIFE and the far left hand side of any assignments.\n\n    while (isAssignment(outerNode.parent)) {\n      outerNode = outerNode.parent;\n    }\n\n    return outerNode;\n  }\n\n  exports.getOuterNodeFromInnerDeclaration = getOuterNodeFromInnerDeclaration;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/host/esm2015_host.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AAEA,MAAA,YAAA,GAAA,OAAA,CAAA,4CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,sCAAA,CAAA;;AAEA,MAAA,WAAA,GAAA,OAAA,CAAA,+CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,2CAAA,CAAA;;AAEa,EAAA,OAAA,CAAA,UAAA,GAAa,YAAb;AACA,EAAA,OAAA,CAAA,eAAA,GAAkB,gBAAlB;AACA,EAAA,OAAA,CAAA,WAAA,GAAc,eAAd;AACA,EAAA,OAAA,CAAA,kBAAA,GAAqB,gBAArB;AAEb;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BG;;AACH,MAAA,qBAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAA2C,IAAA,OAAA,CAAA,SAAA,CAAA,qBAAA,EAAA,MAAA;;AAgDzC,aAAA,qBAAA,CACc,MADd,EACwC,MADxC,EACmE,GADnE,EAEc,GAFd,EAE4C;AAA9B,UAAA,GAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,GAAA,GAAA,IAAA;AAA8B;;AAF5C,UAAA,KAAA,GAGE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,GAAG,CAAC,OAAJ,CAAY,cAAZ,EAAN,KAAmC,IAHrC;;AACc,MAAA,KAAA,CAAA,MAAA,GAAA,MAAA;AAA0B,MAAA,KAAA,CAAA,MAAA,GAAA,MAAA;AAA2B,MAAA,KAAA,CAAA,GAAA,GAAA,GAAA;AACrD,MAAA,KAAA,CAAA,GAAA,GAAA,GAAA;AAjDd;;;;;;AAMG;;AACO,MAAA,KAAA,CAAA,uBAAA,GAAqE,IAArE;AACV;;;;;;AAMG;;AACO,MAAA,KAAA,CAAA,wBAAA,GAAsE,IAAtE;AAEV;;AAEG;;AACO,MAAA,KAAA,CAAA,uBAAA,GAA0B,IAAI,GAAJ,EAA1B;AAEV;;;;;;;;;;;;;;AAcG;;AACO,MAAA,KAAA,CAAA,wBAAA,GAA2B,IAAI,GAAJ,EAA3B;AAEV;;;;;AAKG;;AACO,MAAA,KAAA,CAAA,cAAA,GAAiB,IAAI,GAAJ,EAAjB;;AAMT;AAED;;;;;;;;;;;;;;;;;;;;;;AAsBG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,WAAf,EAAmC;AACjC,UAAM,MAAM,GAAG,KAAK,kCAAL,CAAwC,WAAxC,CAAf;;AACA,UAAI,MAAM,KAAK,SAAf,EAA0B;AACxB,eAAO,MAAP;AACD;;AACD,UAAM,gBAAgB,GAAG,KAAK,mCAAL,CAAyC,WAAzC,CAAzB;AACA,aAAO,KAAK,kCAAL,CAAwC,gBAAxC,CAAP;AACD,KAPD;AASA;;;;;;;;;;;;;AAaG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,0BAAA,GAAA,UAA2B,WAA3B,EAAuD;AACrD,UAAM,MAAM,GAAG,KAAK,cAAL,CAAoB,WAApB,CAAf;;AACA,UAAI,CAAC,MAAL,EAAa;AACX,eAAO,IAAP;AACD;;AACD,aAAO,KAAK,qBAAL,CAA2B,MAA3B,CAAP;AACD,KAND;AAQA;;;;;;;;;AASG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,KAAlB,EAAyC;AACvC,UAAM,WAAW,GAAG,KAAK,cAAL,CAAoB,KAApB,CAApB;;AACA,UAAI,CAAC,WAAL,EAAkB;AAChB,cAAM,IAAI,KAAJ,CAAU,gDAA6C,KAAK,CAAC,OAAN,EAA7C,GAA4D,IAAtE,CAAN;AACD;;AAED,aAAO,KAAK,kBAAL,CAAwB,WAAxB,CAAP;AACD,KAPD;AASA;;;;;;;;;;;;;AAaG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,wBAAA,GAAA,UAAyB,KAAzB,EAAgD;AAC9C,UAAM,WAAW,GAAG,KAAK,cAAL,CAAoB,KAApB,CAApB;;AACA,UAAI,CAAC,WAAL,EAAkB;AAChB,cAAM,IAAI,KAAJ,CACF,+DAA4D,KAAK,CAAC,OAAN,EAA5D,GAA2E,IADzE,CAAN;AAED;;AACD,UAAM,cAAc,GAAG,KAAK,mCAAL,CAAyC,WAAzC,CAAvB;;AACA,UAAI,cAAJ,EAAoB;AAClB,eAAO,KAAK,uBAAL,CAA6B,WAA7B,EAA0C,cAA1C,CAAP;AACD;;AACD,aAAO,IAAP;AACD,KAXD;;AAaA,IAAA,qBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,KAAvB,EAA8C;AAC5C;AACA,UAAM,wBAAwB,GAAG,MAAA,CAAA,SAAA,CAAM,sBAAN,CAA4B,IAA5B,CAA4B,IAA5B,EAA6B,KAA7B,CAAjC;;AACA,UAAI,wBAAJ,EAA8B;AAC5B,eAAO,wBAAP;AACD,OAL2C,CAO5C;;;AACA,UAAM,WAAW,GAAG,KAAK,cAAL,CAAoB,KAApB,CAApB;;AACA,UAAI,WAAW,KAAK,SAAhB,IACA,CAAC,kBAAkB,CAAC,WAAW,CAAC,cAAZ,CAA2B,gBAA5B,CADvB,EACsE;AACpE,eAAO,IAAP;AACD;;AACD,aAAO,MAAA,CAAA,SAAA,CAAM,sBAAN,CAA4B,IAA5B,CAA4B,IAA5B,EAA6B,WAAW,CAAC,cAAZ,CAA2B,gBAAxD,CAAP;AACD,KAdD;;AAgBA,IAAA,qBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,KAAvB,EAA8C;AAC5C,UAAM,WAAW,GAAG,KAAK,cAAL,CAAoB,KAApB,CAApB;;AACA,UAAI,WAAW,KAAK,SAApB,EAA+B;AAC7B,cAAM,IAAI,KAAJ,CAAU,8DACZ,KAAK,CAAC,IAAN,CAAW,IADC,GACG,6BADb,CAAN;AAED;;AACD,aAAO,KAAK,iCAAL,CACH,WADG,EACU,WAAW,CAAC,cAAZ,CAA2B,gBADrC,CAAP;AAED,KARD;;AAUA,IAAA,qBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,KAAvB,EAA8C;AAC5C,UAAM,WAAW,GAAG,KAAK,cAAL,CAAoB,KAApB,CAApB;;AACA,UAAI,WAAW,KAAK,SAApB,EAA+B;AAC7B,cAAM,IAAI,KAAJ,CAAU,8DACZ,KAAK,CAAC,IAAN,CAAW,IADC,GACG,6BADb,CAAN;AAED;;AAED,aAAO,KAAK,4BAAL,CAAkC,WAAlC,CAAP;AACD,KARD;;AAUQ,IAAA,qBAAA,CAAA,SAAA,CAAA,iCAAA,GAAR,UACI,WADJ,EACkC,WADlC,EAC6D;AAC3D,UAAI,WAAW,KAAK,SAApB,EAA+B;AAC7B,cAAM,IAAI,KAAJ,CACF,6GACI,WAAW,CAAC,IADhB,GACoB,yBADpB,GAC8C,WAAW,CAAC,cAAZ,CAA2B,IADzE,GAC6E,GAF3E,CAAN;AAGD;;AACD,UAAI,CAAC,kBAAkB,CAAC,WAAD,CAAvB,EAAsC;AACpC,cAAM,IAAI,KAAJ,CACF,0GACI,WAAW,CAAC,OAAZ,EAFF,CAAN;AAGD;;AACD,aAAO,WAAW,CAAC,IAAnB;AACD,KAbO;AAeR;;AAEG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,IAAR,EAAqB;AACnB,aAAO,MAAA,CAAA,SAAA,CAAM,OAAN,CAAa,IAAb,CAAa,IAAb,EAAc,IAAd,KAAuB,KAAK,cAAL,CAAoB,IAApB,MAA8B,SAA5D;AACD,KAFD;AAIA;;;;;;;;;;;;;;;AAeG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,0BAAA,GAAA,UAA2B,EAA3B,EAA4C;AAC1C,UAAM,gBAAgB,GAAG,MAAA,CAAA,SAAA,CAAM,0BAAN,CAAgC,IAAhC,CAAgC,IAAhC,EAAiC,EAAjC,CAAzB,CAD0C,CAG1C;;;AACA,UAAI,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,eAAO,gBAAP;AACD,OANyC,CAQ1C;;;AACA,UAAI,gBAAgB,CAAC,KAAjB,KAA2B,IAA3B,IACA,YAAA,CAAA,qBAAA,CAAsB,gBAAtB,KAA2C,gBAAgB,CAAC,QAAjB,KAA8B,IAD7E,EACmF;AACjF,eAAO,gBAAP;AACD;;AAED,UAAI,eAAe,GAAY,gBAAgB,CAAC,IAAhD;;AACA,UAAI,YAAA,CAAA,0BAAA,CAA2B,gBAAgB,CAAC,IAA5C,KAAqD,CAAC,UAAU,CAAC,gBAAgB,CAAC,IAAlB,CAApE,EAA6F;AAC3F,YAAM,aAAa,GAAG,KAAK,gBAAL,CAAsB,gBAAgB,CAAC,IAAvC,CAAtB;;AACA,YAAI,aAAa,KAAK,IAAlB,IAA0B,EAAE,CAAC,iBAAH,CAAqB,aAArB,CAA9B,EAAmE;AACjE,UAAA,eAAe,GAAG,sBAAsB,CAAC,aAAD,CAAxC;AACD;AACF;;AAED,UAAM,SAAS,GAAG,gCAAgC,CAAC,eAAD,CAAlD;AACA,UAAM,WAAW,GAAG,SAAS,KAAK,IAAd,IAAsB,YAAA,CAAA,0BAAA,CAA2B,SAA3B,CAAtB,GAChB,KAAK,0BAAL,CAAgC,SAAS,CAAC,IAA1C,CADgB,GAEhB,gBAFJ;;AAGA,UAAI,WAAW,KAAK,IAAhB,IAAwB,WAAW,CAAC,KAAZ,KAAsB,IAA9C,IACA,YAAA,CAAA,qBAAA,CAAsB,WAAtB,KAAsC,WAAW,CAAC,QAAZ,KAAyB,IADnE,EACyE;AACvE,eAAO,WAAP;AACD,OA7ByC,CA+B1C;AACA;;;AACA,UAAM,iBAAiB,GAAG,KAAK,6BAAL,CAAmC,WAAW,CAAC,IAA/C,CAA1B;;AACA,UAAI,iBAAiB,KAAK,IAA1B,EAAgC;AAC9B,eAAO,KAAK,0BAAL,CAAgC,iBAAhC,CAAP;AACD,OApCyC,CAsC1C;;;AACA,UAAI,YAAA,CAAA,qBAAA,CAAsB,WAAtB,KAAsC,EAAE,CAAC,qBAAH,CAAyB,WAAW,CAAC,IAArC,CAA1C,EAAsF;AACpF,YAAM,WAAW,GAAG,KAAK,kBAAL,CAAwB,WAAW,CAAC,IAApC,CAApB;;AACA,YAAI,WAAW,KAAK,IAApB,EAA0B;AACxB,UAAA,WAAW,CAAC,QAAZ,GAAuB;AAAC,YAAA,IAAI,EAAA;AAAA;AAAL;AAA+C,YAAA,WAAW,EAAA;AAA1D,WAAvB;AACD;AACF;;AAED,aAAO,WAAP;AACD,KA/CD;AAiDA;;;AAGG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,MAAtB,EAA6C;AACpC,UAAA,eAAe,GAAI,KAAK,oBAAL,CAA0B,MAA1B,EAAJ,eAAf;;AACP,UAAI,eAAe,KAAK,IAAxB,EAA8B;AAC5B,eAAO,IAAP;AACD,OAJ0C,CAM3C;;;AACA,aAAO,KAAK,CAAC,IAAN,CAAW,eAAX,CAAP;AACD,KARD;AAUA;;;;;AAKG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UAA0B,MAA1B,EAAyC;AACvC;AACA,aAAO,MAAM,CAAC,OAAP,GAAiB,OAAjB,CAAyB,WAAA,CAAA,aAAzB,KAA2C,CAA3C,GACH,OAAA,CAAA,OAAA,CAAQ,MAAR,EAAgB,WAAA,CAAA,+BAAhB,CADG,GAEH,EAFJ;AAGD,KALD;;AAOA,IAAA,qBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,WAAjB,EAAoD;AAClD,UAAM,KAAK,GAAG,MAAA,CAAA,SAAA,CAAM,gBAAN,CAAsB,IAAtB,CAAsB,IAAtB,EAAuB,WAAvB,CAAd;;AACA,UAAI,KAAJ,EAAW;AACT,eAAO,KAAP;AACD,OAJiD,CAMlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAM,KAAK,GAAG,WAAW,CAAC,MAAZ,CAAmB,MAAnB,CAA0B,MAAxC;AACA,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,mBAAb,CAAiC,WAAW,CAAC,IAA7C,CAAf;;AACA,UAAI,MAAM,KAAK,EAAE,CAAC,OAAH,CAAW,KAAX,KAAqB,EAAE,CAAC,YAAH,CAAgB,KAAhB,CAA1B,CAAV,EAA6D;AAC3D,YAAM,YAAY,GAAG,KAAK,0BAAL,CAAgC,KAAhC,EAAuC,MAAvC,CAArB;AACA,YAAM,MAAM,GAAG,YAAY,IAAI,YAAY,CAAC,SAAb,CAAuB,CAAvB,CAA/B;;AACA,YAAI,MAAM,IAAI,EAAE,CAAC,YAAH,CAAgB,MAAhB,CAAd,EAAuC;AACrC,cAAM,YAAY,GAAG,KAAK,OAAL,CAAa,mBAAb,CAAiC,MAAjC,CAArB;AACA,cAAM,iBAAiB,GAAG,YAAY,IAAI,YAAY,CAAC,gBAAvD;;AACA,cAAI,iBAAJ,EAAuB;AACrB,gBAAI,EAAE,CAAC,kBAAH,CAAsB,iBAAtB,KACA,EAAE,CAAC,qBAAH,CAAyB,iBAAzB,CADJ,EACiD;AAC/C;AACA;AACA,qBAAO,iBAAiB,CAAC,IAAlB,IAA0B,IAAjC;AACD,aALD,MAKO,IAAI,EAAE,CAAC,qBAAH,CAAyB,iBAAzB,CAAJ,EAAiD;AACtD;AACA;AACA,kBAAI,WAAW,GAAG,iBAAiB,CAAC,WAApC;;AACA,qBAAO,WAAW,IAAI,YAAY,CAAC,WAAD,CAAlC,EAAiD;AAC/C,gBAAA,WAAW,GAAG,WAAW,CAAC,KAA1B;AACD;;AACD,kBAAI,WAAJ,EAAiB;AACf,uBAAO,WAAP;AACD;AACF;AACF;AACF;AACF;;AACD,aAAO,IAAP;AACD,KAzDD;AA2DA;;;;AAIG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,UAAjB,EAA0C;AAA1C,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,OAAO,GAAG,IAAI,GAAJ,EAAhB;AACA,WAAK,mBAAL,CAAyB,UAAzB,EACK,OADL,CACa,UAAA,SAAA,EAAS;AAAI,eAAA,KAAI,CAAC,4BAAL,CAAkC,OAAlC,EAAA,SAAA,CAAA;AAAqD,OAD/E;AAEA,aAAO,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,MAAR,EAAX,CAAP;AACD,KALD;AAOA;;;;;;;AAOG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,KAAvB,EAA8C;AAC5C,UAAM,cAAc,GAAG,KAAK,iBAAL,CAAuB,KAAvB,CAAvB;;AACA,UAAI,cAAc,IAAI,EAAE,CAAC,kBAAH,CAAsB,cAAtB,CAAtB,EAA6D;AAC3D,eAAO,cAAc,CAAC,cAAf,GAAgC,cAAc,CAAC,cAAf,CAA8B,MAA9D,GAAuE,CAA9E;AACD;;AACD,aAAO,IAAP;AACD,KAND;AAQA;;;;;;;;;;;AAWG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAkB,WAAlB,EAA8C;AAC5C,UAAI,KAAK,GAAL,KAAa,IAAjB,EAAuB;AACrB,eAAO,IAAP;AACD;;AACD,UAAI,CAAC,kBAAkB,CAAC,WAAD,CAAvB,EAAsC;AACpC,cAAM,IAAI,KAAJ,CAAU,iEACZ,WAAW,CAAC,OAAZ,EADY,GACS,MADT,GACgB,WAAW,CAAC,aAAZ,GAA4B,QADtD,CAAN;AAED;;AAED,UAAM,IAAI,GAAG,KAAK,0BAAL,CAAgC,WAAW,CAAC,IAA5C,CAAb;;AACA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,cAAM,IAAI,KAAJ,CACF,qFACI,WAAW,CAAC,OAAZ,EADJ,GACyB,MADzB,GACgC,WAAW,CAAC,aAAZ,GAA4B,QAF1D,CAAN;AAGD,OAd2C,CAgB5C;;;AACA,UAAI,KAAK,uBAAL,KAAiC,IAArC,EAA2C;AACzC,aAAK,uBAAL,GAA+B,KAAK,8BAAL,CAAoC,KAAK,GAAzC,EAA8C,KAAK,GAAnD,CAA/B;AACD;;AACD,UAAI,KAAK,uBAAL,CAA6B,GAA7B,CAAiC,IAAI,CAAC,IAAtC,CAAJ,EAAiD;AAC/C,eAAO,KAAK,uBAAL,CAA6B,GAA7B,CAAiC,IAAI,CAAC,IAAtC,CAAP;AACD,OAtB2C,CAwB5C;;;AACA,UAAI,KAAK,wBAAL,KAAkC,IAAtC,EAA4C;AAC1C,aAAK,wBAAL,GAAgC,KAAK,+BAAL,CAAqC,KAAK,GAA1C,EAA+C,KAAK,GAApD,CAAhC;AACD;;AACD,UAAI,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,IAAI,CAAC,IAAvC,CAAJ,EAAkD;AAChD,eAAO,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,IAAI,CAAC,IAAvC,CAAP;AACD,OA9B2C,CAgC5C;;;AACA,aAAO,IAAP;AACD,KAlCD;;AAoCA,IAAA,qBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,WAAd,EAA0C;AACxC,UAAM,cAAc,GAAG,WAAW,CAAC,cAAnC;AACA,UAAI,IAAI,GAAY,cAAc,CAAC,gBAAnC;AACA,UAAM,uBAAuB,GAAG,sBAAsB,CAAC,IAAD,CAAtD;AACA,UAAI,uBAAuB,KAAK,IAAhC,EAAsC,OAAO,IAAP;AAEtC,UAAM,SAAS,GAAG,uBAAuB,CAAC,MAA1C;;AACA,UAAI,EAAE,CAAC,OAAH,CAAW,SAAX,CAAJ,EAA2B;AACzB;AACA,YAAM,oBAAoB,GAAG,SAAS,CAAC,UAAV,CAAqB,SAArB,CAA+B,EAAE,CAAC,iBAAlC,CAA7B;;AACA,YAAI,oBAAoB,KAAK,CAAC,CAA9B,EAAiC;AAC/B,gBAAM,IAAI,KAAJ,CACF,mEAAiE,WAAW,CAAC,IAA7E,GAAiF,MAAjF,GACI,WAAW,CAAC,WAAZ,CAAwB,gBAAxB,CAAyC,aAAzC,GAAyD,QAF3D,CAAN;AAGD,SAPwB,CASzB;;;AACA,QAAA,IAAI,GAAG,SAAS,CAAC,UAAV,CAAqB,oBAAoB,GAAG,CAA5C,CAAP;AACD,OAXD,MAWO,IAAI,EAAE,CAAC,YAAH,CAAgB,SAAhB,CAAJ,EAAgC;AACrC;AACA,YAAI,cAAc,CAAC,OAAf,KAA2B,SAA/B,EAA0C;AACxC,UAAA,cAAc,CAAC,OAAf,CAAuB,OAAvB,CAA+B,UAAA,YAAA,EAAY;AACzC,gBAAI,YAAY,CAAC,gBAAb,KAAkC,SAAtC,EAAiD;AAC/C;AACD;;AACD,gBAAM,eAAe,GAAG,sBAAsB,CAAC,YAAY,CAAC,gBAAd,CAA9C;;AACA,gBAAI,eAAe,KAAK,IAApB,IAA4B,IAAI,CAAC,MAAL,KAAgB,eAAe,CAAC,MAAhB,EAAhD,EAA0E;AACxE,cAAA,IAAI,GAAG,eAAP;AACD;AACF,WARD;AASD,SAZoC,CAcrC;;;AACA,YAAM,OAAO,GAAG,KAAK,sBAAL,CACZ,WADY,EACC,CAAC,YAAD,EAAe,WAAf,EAA4B,SAA5B,EAAuC,YAAvC,CADD,CAAhB;AAEA,QAAA,OAAO,CAAC,OAAR,CAAgB,UAAA,MAAA,EAAM;AACpB,cAAM,eAAe,GAAG,sBAAsB,CAAC,MAAD,CAA9C;;AACA,cAAI,eAAe,KAAK,IAApB,IAA4B,IAAI,CAAC,MAAL,KAAgB,eAAe,CAAC,MAAhB,EAAhD,EAA0E;AACxE,YAAA,IAAI,GAAG,eAAP;AACD;AACF,SALD;AAMD;;AACD,aAAO,IAAP;AACD,KA3CD;AA6CA;;;;;;AAMG;;;AACH,IAAA,qBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAA8C,IAA9C,EAAqD;AACnD,UAAI,IAAI,CAAC,KAAL,KAAe,IAAf,IAAuB,KAAK,6BAAL,CAAmC,IAAnC,CAA3B,EAAqE;AACnE;AACA;AACA,QAAA,IAAI,CAAC,KAAL,GAAa,YAAA,CAAA,gBAAA,CAAiB,cAA9B;AACD;;AACD,aAAO,IAAP;AACD,KAPD,CA3eF,CAqfE;;AAEA;;AAEG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,4BAAA,GAAV,UACI,OADJ,EAC8C,SAD9C,EACqE;AADrE,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAI,EAAE,CAAC,mBAAH,CAAuB,SAAvB,CAAJ,EAAuC;AACrC,QAAA,SAAS,CAAC,eAAV,CAA0B,YAA1B,CAAuC,OAAvC,CAA+C,UAAA,WAAA,EAAW;AACxD,cAAM,WAAW,GAAG,KAAI,CAAC,cAAL,CAAoB,WAApB,CAApB;;AACA,cAAI,WAAJ,EAAiB;AACf,YAAA,OAAO,CAAC,GAAR,CAAY,WAAW,CAAC,cAAxB,EAAwC,WAAxC;AACD;AACF,SALD;AAMD,OAPD,MAOO,IAAI,EAAE,CAAC,kBAAH,CAAsB,SAAtB,CAAJ,EAAsC;AAC3C,YAAM,WAAW,GAAG,KAAK,cAAL,CAAoB,SAApB,CAApB;;AACA,YAAI,WAAJ,EAAiB;AACf,UAAA,OAAO,CAAC,GAAR,CAAY,WAAW,CAAC,cAAxB,EAAwC,WAAxC;AACD;AACF;AACF,KAfS;AAiBV;;;;AAIG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,mCAAA,GAAV,UAA8C,WAA9C,EAAkE;AAChE,UAAI,WAAW,CAAC,MAAZ,KAAuB,SAAvB,IAAoC,YAAA,CAAA,0BAAA,CAA2B,WAAW,CAAC,MAAvC,CAAxC,EAAwF;AACtF,YAAM,aAAa,GAAG,KAAK,gBAAL,CAAsB,WAAW,CAAC,MAAlC,CAAtB;;AACA,YAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,UAAA,WAAW,GAAG,aAAd;AACD;AACF;;AACD,aAAO,WAAP;AACD,KARS;AAUV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,kCAAA,GAAV,UAA6C,WAA7C,EAAiE;AAC/D;AACA,UAAI,YAAA,CAAA,uBAAA,CAAwB,WAAxB,KAAwC,UAAU,CAAC,WAAD,CAAtD,EAAqE;AACnE,eAAO,KAAK,iBAAL,CAAuB,WAAW,CAAC,IAAnC,EAAyC,IAAzC,CAAP;AACD,OAJ8D,CAM/D;;;AACA,UAAI,CAAC,qCAAqC,CAAC,WAAD,CAA1C,EAAyD;AACvD,eAAO,SAAP;AACD;;AAED,UAAM,gBAAgB,GAAG,wBAAwB,CAAC,gBAAgB,CAAC,WAAD,CAAjB,CAAjD;;AACA,UAAI,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,eAAO,SAAP;AACD;;AAED,aAAO,KAAK,iBAAL,CAAuB,WAAW,CAAC,IAAnC,EAAyC,gBAAzC,CAAP;AACD,KAjBS;AAmBV;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,kCAAA,GAAV,UAA6C,WAA7C,EAAiE;AAC/D,UAAI,gBAAgB,GAAyD,SAA7E;;AAEA,UAAI,EAAE,CAAC,iBAAH,CAAqB,WAArB,KAAqC,OAAA,CAAA,iBAAA,CAAkB,WAAlB,CAAzC,EAAyE;AACvE;AACA,QAAA,gBAAgB,GAAG,8BAA8B,CAAC,WAAD,CAAjD,CAFuE,CAIvE;;AACA,YAAI,gBAAgB,KAAK,SAArB,IAAkC,CAAC,UAAU,CAAC,gBAAD,CAAjD,EAAqE;AACnE,UAAA,gBAAgB,GAAG,gCAAgC,CAAC,gBAAD,CAAnD;AACD;AACF,OARD,MAQO,IAAI,YAAA,CAAA,uBAAA,CAAwB,WAAxB,CAAJ,EAA0C;AAC/C;AACA,YAAI,UAAU,CAAC,WAAD,CAAd,EAA6B;AAC3B;AACA,UAAA,gBAAgB,GAAG,WAAnB;AACD,SAHD,MAGO;AACL;AACA,UAAA,gBAAgB,GAAG,gCAAgC,CAAC,WAAD,CAAnD;AACD;AACF;;AAED,UAAI,gBAAgB,KAAK,SAArB,IAAkC,CAAC,OAAA,CAAA,iBAAA,CAAkB,gBAAlB,CAAvC,EAA4E;AAC1E,eAAO,SAAP;AACD;;AAED,aAAO,KAAK,iBAAL,CAAuB,gBAAgB,CAAC,IAAxC,EAA8C,WAA9C,CAAP;AACD,KA3BS;AA6BV;;;;;;;;;;AAUG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,iBAAA,GAAV,UAA4B,gBAA5B,EAA6D,gBAA7D,EAA2F;AAEzF,UAAM,iBAAiB,GACnB,KAAK,OAAL,CAAa,mBAAb,CAAiC,gBAAjC,CADJ;;AAEA,UAAI,iBAAiB,KAAK,SAA1B,EAAqC;AACnC,eAAO,SAAP;AACD;;AAED,UAAI,oBAAoB,GAAG,iBAA3B;;AACA,UAAI,gBAAgB,KAAK,IAArB,IAA6B,kBAAkB,CAAC,gBAAD,CAAnD,EAAuE;AACrE,QAAA,oBAAoB,GAAG,KAAK,OAAL,CAAa,mBAAb,CAAiC,gBAAgB,CAAC,IAAlD,CAAvB;AACD;;AAED,UAAI,oBAAoB,KAAK,SAA7B,EAAwC;AACtC,eAAO,SAAP;AACD;;AAED,UAAM,WAAW,GAAoB;AACnC,QAAA,IAAI,EAAE,iBAAiB,CAAC,IADW;AAEnC,QAAA,WAAW,EAAE,iBAFsB;AAGnC,QAAA,cAAc,EAAE,oBAHmB;AAInC,QAAA,QAAQ,EAAE,KAAK,iBAAL,CAAuB,iBAAvB,EAA0C,oBAA1C;AAJyB,OAArC;AAOA,aAAO,WAAP;AACD,KAzBS;;AA2BF,IAAA,qBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,iBAA1B,EAA0D,oBAA1D,EAA2F;AAEzF,UAAI,iBAAiB,KAAK,oBAA1B,EAAgD;AAC9C,eAAO,SAAP;AACD;;AACD,UAAM,gBAAgB,GAAG,oBAAoB,CAAC,gBAA9C;;AACA,UAAI,CAAC,EAAE,CAAC,iBAAH,CAAqB,gBAArB,CAAD,IAA2C,CAAC,EAAE,CAAC,oBAAH,CAAwB,gBAAxB,CAAhD,EAA2F;AACzF,eAAO,SAAP;AACD,OARwF,CASzF;AACA;;;AACA,UAAM,mBAAmB,GAAG,8BAA8B,CAAC,gBAAD,CAA1D;;AACA,UAAI,mBAAmB,KAAK,SAAxB,IAAqC,CAAC,YAAA,CAAA,0BAAA,CAA2B,mBAA3B,CAA1C,EAA2F;AACzF,eAAO,SAAP;AACD;;AACD,UAAM,cAAc,GAChB,KAAK,OAAL,CAAa,mBAAb,CAAiC,mBAAmB,CAAC,IAArD,CADJ;;AAEA,UAAI,cAAc,KAAK,iBAAnB,IAAwC,cAAc,KAAK,oBAA/D,EAAqF;AACnF,eAAO,SAAP;AACD;;AACD,aAAO,cAAP;AACD,KArBO;AAuBR;;;AAGG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,sBAAA,GAAV,UAAiC,MAAjC,EAAoD,UAApD,EAAkF;AAEhF,UAAM,WAAW,GAAG,MAAA,CAAA,SAAA,CAAM,sBAAN,CAA4B,IAA5B,CAA4B,IAA5B,EAA6B,MAA7B,EAAqC,UAArC,CAApB;;AACA,UAAI,WAAW,KAAK,IAApB,EAA0B;AACxB,eAAO,IAAP;AACD;;AACD,aAAO,KAAK,sBAAL,CAA4B,WAA5B,CAAP;AACD,KAPS;AASV;;;;;;;;;;AAUG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,6BAAA,GAAV,UAAwC,WAAxC,EAAoE;AAClE,WAAK,kBAAL,CAAwB,WAAW,CAAC,aAAZ,EAAxB;AACA,aAAO,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,WAAlC,IACH,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,WAAlC,CADG,GAEH,IAFJ;AAGD,KALS;AAOV;;;;;;;AAOG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,kBAAA,GAAV,UAA6B,UAA7B,EAAsD;;;AACpD,UAAI,CAAC,KAAK,uBAAL,CAA6B,GAA7B,CAAiC,UAAjC,CAAL,EAAmD;AACjD,aAAK,uBAAL,CAA6B,GAA7B,CAAiC,UAAjC;;;AAEA,eAAwB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAK,mBAAL,CAAyB,UAAzB,CAAA,CAAA,EAAoC,EAAA,GAAA,EAAA,CAAA,IAAA,EAA5D,EAA4D,CAAA,EAAA,CAAA,IAA5D,EAA4D,EAAA,GAAA,EAAA,CAAA,IAAA,EAA5D,EAA8D;AAAzD,gBAAM,SAAS,GAAA,EAAA,CAAA,KAAf;AACH,iBAAK,mBAAL,CAAyB,SAAzB;AACD;;;;;;;;;;;;AACF;AACF,KARS;AAUV;;;;;;AAMG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,mBAAA,GAAV,UAA8B,SAA9B,EAAqD;AACnD,UAAI,CAAC,EAAE,CAAC,mBAAH,CAAuB,SAAvB,CAAL,EAAwC;AACtC;AACD;;AAED,UAAM,YAAY,GAAG,SAAS,CAAC,eAAV,CAA0B,YAA/C;;AACA,UAAI,YAAY,CAAC,MAAb,KAAwB,CAA5B,EAA+B;AAC7B;AACD;;AAED,UAAM,WAAW,GAAG,YAAY,CAAC,CAAD,CAAhC;AACA,UAAM,WAAW,GAAG,WAAW,CAAC,WAAhC;;AACA,UAAI,CAAC,EAAE,CAAC,YAAH,CAAgB,WAAW,CAAC,IAA5B,CAAD,IAAsC,CAAC,WAAvC,IAAsD,CAAC,YAAY,CAAC,WAAD,CAAnE,IACA,CAAC,EAAE,CAAC,YAAH,CAAgB,WAAW,CAAC,IAA5B,CADD,IACsC,CAAC,KAAK,OAAL,CAAa,WAAb,CAD3C,EACsE;AACpE;AACD;;AAED,UAAM,iBAAiB,GAAG,WAAW,CAAC,IAAtC;AAEA,UAAM,kBAAkB,GAAG,KAAK,0BAAL,CAAgC,iBAAhC,CAA3B;;AACA,UAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC/B,cAAM,IAAI,KAAJ,CACF,qCAAmC,iBAAiB,CAAC,IAArD,GAAyD,QAAzD,GAAiE,SAAS,CAAC,OAAV,EAAjE,GAAoF,IADlF,CAAN;AAED;;AACD,WAAK,wBAAL,CAA8B,GAA9B,CAAkC,kBAAkB,CAAC,IAArD,EAA2D,WAAW,CAAC,IAAvE;AACD,KAzBS;AA2BV;;;;;;AAMG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,mBAAA,GAAV,UAA8B,UAA9B,EAAuD;AACrD,aAAO,KAAK,CAAC,IAAN,CAAW,UAAU,CAAC,UAAtB,CAAP;AACD,KAFS;AAIV;;;;;AAKG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,0BAAA,GAAV,UAAqC,IAArC,EAA8D,MAA9D,EAA+E;AAA/E,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAI,CAAC,IAAL,EAAW;AACT,eAAO,IAAP;AACD;;AACD,UAAI,EAAE,CAAC,kBAAH,CAAsB,IAAtB,KAA+B,IAAI,CAAC,aAAL,CAAmB,IAAnB,KAA4B,EAAE,CAAC,UAAH,CAAc,WAA7E,EAA0F;AACxF,YAAM,IAAI,GAAG,IAAI,CAAC,IAAlB;AACA,YAAM,KAAK,GAAG,IAAI,CAAC,KAAnB;;AACA,YAAI,EAAE,CAAC,YAAH,CAAgB,IAAhB,KAAyB,KAAK,OAAL,CAAa,mBAAb,CAAiC,IAAjC,MAA2C,MAAxE,EAAgF;AAC9E,iBAAQ,EAAE,CAAC,gBAAH,CAAoB,KAApB,KAA8B,aAAa,CAAC,KAAD,CAAb,KAAyB,YAAxD,GAAwE,KAAxE,GAAgF,IAAvF;AACD;;AACD,eAAO,KAAK,0BAAL,CAAgC,KAAhC,EAAuC,MAAvC,CAAP;AACD;;AACD,aAAO,IAAI,CAAC,YAAL,CAAkB,UAAA,IAAA,EAAI;AAAI,eAAA,KAAI,CAAC,0BAAL,CAAgC,IAAhC,EAAA,MAAA,CAAA;AAA6C,OAAvE,KAA4E,IAAnF;AACD,KAdS;AAgBV;;;;;;;;;;;AAWG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,iBAAA,GAAV,UAA4B,MAA5B,EAAqD,YAArD,EAA8E;;;AAE5E,aAAO,CAAA,CAAA,EAAA,GAAA,MAAM,CAAC,cAAP,CAAsB,OAAtB,MAA6B,IAA7B,IAA6B,EAAA,KAAA,KAAA,CAA7B,GAA6B,KAAA,CAA7B,GAA6B,EAAA,CAAE,GAAF,CAAM,YAAN,CAA7B,MAA+C,CAAA,EAAA,GAAA,CAAA,EAAA,GAClD,MAAM,CAAC,QAD2C,MACnC,IADmC,IACnC,EAAA,KAAA,KAAA,CADmC,GACnC,KAAA,CADmC,GACnC,EAAA,CAAE,OADiC,MAC1B,IAD0B,IAC1B,EAAA,KAAA,KAAA,CAD0B,GAC1B,KAAA,CAD0B,GAC1B,EAAA,CAAE,GAAF,CAAM,YAAN,CADrB,MACwC,CAAA,EAAA,GAC3C,MAAM,CAAC,WAAP,CAAmB,OADwB,MACjB,IADiB,IACjB,EAAA,KAAA,KAAA,CADiB,GACjB,KAAA,CADiB,GACjB,EAAA,CAAE,GAAF,CAAM,YAAN,CAFvB,CAAP;AAGD,KALS;AAOV;;;;;;;AAOG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,oBAAA,GAAV,UAA+B,WAA/B,EAA2D;AACzD,UAAM,IAAI,GAAG,WAAW,CAAC,WAAZ,CAAwB,gBAArC;;AACA,UAAI,KAAK,cAAL,CAAoB,GAApB,CAAwB,IAAxB,CAAJ,EAAmC;AACjC,eAAO,KAAK,cAAL,CAAoB,GAApB,CAAwB,IAAxB,CAAP;AACD,OAJwD,CAMzD;AACA;;;AACA,UAAM,WAAW,GAAG,KAAK,wCAAL,CAA8C,WAA9C,CAApB;AACA,UAAM,WAAW,GAAG,KAAK,mCAAL,CAAyC,WAAzC,CAApB;AAEA,UAAM,aAAa,GAAkB;AACnC,QAAA,eAAe,EAAE,WAAW,CAAC,eAAZ,IAA+B,WAAW,CAAC,eADzB;AAEnC,QAAA,gBAAgB,EAAE,WAAW,CAAC,gBAAZ,IAAgC,WAAW,CAAC,gBAF3B;AAGnC,QAAA,oBAAoB,EAAE,WAAW,CAAC,oBAAZ,IAAoC,WAAW,CAAC;AAHnC,OAArC;AAMA,WAAK,cAAL,CAAoB,GAApB,CAAwB,IAAxB,EAA8B,aAA9B;AACA,aAAO,aAAP;AACD,KAnBS;AAqBV;;;;;;;;;AASG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,wCAAA,GAAV,UAAmD,WAAnD,EAA+E;AAI7E,UAAI,eAAe,GAAqB,IAAxC;AACA,UAAI,gBAAgB,GAAkC,IAAtD;AACA,UAAI,oBAAoB,GAAqB,IAA7C;AAEA,UAAM,kBAAkB,GAAG,KAAK,iBAAL,CAAuB,WAAvB,EAAoC,OAAA,CAAA,UAApC,CAA3B;;AACA,UAAI,kBAAkB,KAAK,SAA3B,EAAsC;AACpC,QAAA,eAAe,GAAG,KAAK,oCAAL,CAA0C,kBAA1C,CAAlB;AACD;;AAED,UAAM,sBAAsB,GAAG,KAAK,iBAAL,CAAuB,WAAvB,EAAoC,OAAA,CAAA,eAApC,CAA/B;;AACA,UAAI,sBAAsB,KAAK,SAA/B,EAA0C;AACxC,QAAA,gBAAgB,GAAG,KAAK,qCAAL,CAA2C,sBAA3C,CAAnB;AACD;;AAED,UAAM,yBAAyB,GAAG,KAAK,iBAAL,CAAuB,WAAvB,EAAoC,OAAA,CAAA,kBAApC,CAAlC;;AACA,UAAI,yBAAyB,KAAK,SAAlC,EAA6C;AAC3C,QAAA,oBAAoB,GAAG,KAAK,8BAAL,CAAoC,yBAApC,CAAvB;AACD;;AAED,aAAO;AAAC,QAAA,eAAe,EAAA,eAAhB;AAAkB,QAAA,gBAAgB,EAAA,gBAAlC;AAAoC,QAAA,oBAAoB,EAAA;AAAxD,OAAP;AACD,KAxBS;AA0BV;;;;;;;;;;;;;AAaG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,oCAAA,GAAV,UAA+C,gBAA/C,EAA0E;AAA1E,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,oBAAoB,GAAG,gBAAgB,CAAC,gBAA9C;;AACA,UAAI,oBAAoB,IAAI,oBAAoB,CAAC,MAAjD,EAAyD;AACvD,YAAI,EAAE,CAAC,kBAAH,CAAsB,oBAAoB,CAAC,MAA3C,KACA,oBAAoB,CAAC,MAArB,CAA4B,aAA5B,CAA0C,IAA1C,KAAmD,EAAE,CAAC,UAAH,CAAc,WADrE,EACkF;AAChF;AACA,cAAM,eAAe,GAAG,oBAAoB,CAAC,MAArB,CAA4B,KAApD;AACA,iBAAO,KAAK,iBAAL,CAAuB,eAAvB,EACF,MADE,CACK,UAAA,SAAA,EAAS;AAAI,mBAAA,KAAI,CAAC,UAAL,CAAA,SAAA,CAAA;AAA0B,WAD5C,CAAP;AAED;AACF;;AACD,aAAO,IAAP;AACD,KAZS;AAcV;;;;;AAKG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,kBAAA,GAAV,UAA6B,MAA7B,EAAoD;AAApD,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,OAAO,GAAkB,EAA/B,CADkD,CAGlD;;AACO,UAAA,gBAAgB,GAAI,KAAK,oBAAL,CAA0B,MAA1B,EAAJ,gBAAhB,CAJ2C,CAMlD;AACA;;AACA,UAAM,aAAa,GAAG,IAAI,GAAJ,CAAQ,gBAAR,CAAtB,CARkD,CAUlD;AACA;;AACA,UAAI,MAAM,CAAC,cAAP,CAAsB,OAA1B,EAAmC;AACjC,QAAA,MAAM,CAAC,cAAP,CAAsB,OAAtB,CAA8B,OAA9B,CAAsC,UAAC,KAAD,EAAQ,GAAR,EAAW;AAC/C,cAAM,UAAU,GAAG,aAAa,CAAC,GAAd,CAAkB,GAAlB,CAAnB;;AACA,cAAM,gBAAgB,GAAG,KAAI,CAAC,cAAL,CAAoB,KAApB,EAA2B,UAA3B,CAAzB;;AACA,cAAI,gBAAJ,EAAsB;AACpB,YAAA,aAAa,CAAC,MAAd,CAAqB,GAArB;AACA,YAAA,OAAO,CAAC,IAAR,CAAY,KAAZ,CAAA,OAAA,EAAO,OAAA,CAAA,QAAA,CAAS,gBAAT,CAAP;AACD;AACF,SAPD;AAQD,OArBiD,CAuBlD;;;AACA,UAAI,MAAM,CAAC,cAAP,CAAsB,OAA1B,EAAmC;AACjC,QAAA,MAAM,CAAC,cAAP,CAAsB,OAAtB,CAA8B,OAA9B,CAAsC,UAAC,KAAD,EAAQ,GAAR,EAAW;AAC/C,cAAM,UAAU,GAAG,aAAa,CAAC,GAAd,CAAkB,GAAlB,CAAnB;;AACA,cAAM,gBAAgB,GAAG,KAAI,CAAC,cAAL,CAAoB,KAApB,EAA2B,UAA3B,EAAuC,IAAvC,CAAzB;;AACA,cAAI,gBAAJ,EAAsB;AACpB,YAAA,aAAa,CAAC,MAAd,CAAqB,GAArB;AACA,YAAA,OAAO,CAAC,IAAR,CAAY,KAAZ,CAAA,OAAA,EAAO,OAAA,CAAA,QAAA,CAAS,gBAAT,CAAP;AACD;AACF,SAPD;AAQD,OAjCiD,CAmClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAI,EAAE,CAAC,qBAAH,CAAyB,MAAM,CAAC,WAAP,CAAmB,gBAA5C,CAAJ,EAAmE;AACjE,YAAI,MAAM,CAAC,WAAP,CAAmB,OAAvB,EAAgC;AAC9B,UAAA,MAAM,CAAC,WAAP,CAAmB,OAAnB,CAA2B,OAA3B,CAAmC,UAAC,KAAD,EAAQ,GAAR,EAAW;AAC5C,gBAAM,UAAU,GAAG,aAAa,CAAC,GAAd,CAAkB,GAAlB,CAAnB;;AACA,gBAAM,gBAAgB,GAAG,KAAI,CAAC,cAAL,CAAoB,KAApB,EAA2B,UAA3B,EAAuC,IAAvC,CAAzB;;AACA,gBAAI,gBAAJ,EAAsB;AACpB,cAAA,aAAa,CAAC,MAAd,CAAqB,GAArB;AACA,cAAA,OAAO,CAAC,IAAR,CAAY,KAAZ,CAAA,OAAA,EAAO,OAAA,CAAA,QAAA,CAAS,gBAAT,CAAP;AACD;AACF,WAPD;AAQD;AACF,OAvDiD,CAyDlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAI,MAAM,CAAC,QAAP,KAAoB,SAAxB,EAAmC;AACjC,YAAI,EAAE,CAAC,qBAAH,CAAyB,MAAM,CAAC,QAAP,CAAgB,gBAAzC,CAAJ,EAAgE;AAC9D,cAAI,MAAM,CAAC,QAAP,CAAgB,OAAhB,KAA4B,SAAhC,EAA2C;AACzC,YAAA,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAAwB,OAAxB,CAAgC,UAAC,KAAD,EAAQ,GAAR,EAAW;AACzC,kBAAM,UAAU,GAAG,aAAa,CAAC,GAAd,CAAkB,GAAlB,CAAnB;;AACA,kBAAM,gBAAgB,GAAG,KAAI,CAAC,cAAL,CAAoB,KAApB,EAA2B,UAA3B,EAAuC,IAAvC,CAAzB;;AACA,kBAAI,gBAAJ,EAAsB;AACpB,gBAAA,aAAa,CAAC,MAAd,CAAqB,GAArB;AACA,gBAAA,OAAO,CAAC,IAAR,CAAY,KAAZ,CAAA,OAAA,EAAO,OAAA,CAAA,QAAA,CAAS,gBAAT,CAAP;AACD;AACF,aAPD;AAQD;AACF;AACF,OAlFiD,CAoFlD;;;AACA,MAAA,aAAa,CAAC,OAAd,CAAsB,UAAC,KAAD,EAAQ,GAAR,EAAW;AAC/B,QAAA,OAAO,CAAC,IAAR,CAAa;AACX,UAAA,cAAc,EAAE,IADL;AAEX,UAAA,UAAU,EAAE,KAFD;AAGX,UAAA,QAAQ,EAAE,KAHC;AAIX,UAAA,IAAI,EAAE,YAAA,CAAA,eAAA,CAAgB,QAJX;AAKX,UAAA,IAAI,EAAE,GALK;AAMX,UAAA,QAAQ,EAAE,IANC;AAOX,UAAA,IAAI,EAAE,IAPK;AAQX,UAAA,IAAI,EAAE,IARK;AASX,UAAA,KAAK,EAAE;AATI,SAAb;AAWD,OAZD;AAcA,aAAO,OAAP;AACD,KApGS;AAsGV;;;;;;;;;;;;;;AAcG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,qCAAA,GAAV,UAAgD,kBAAhD,EAA6E;AAA7E,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAM,gBAAgB,GAAG,IAAI,GAAJ,EAAzB,CAF2E,CAG3E;;AACA,UAAM,iBAAiB,GAAG,0BAA0B,CAAC,kBAAD,CAApD;;AACA,UAAI,iBAAiB,IAAI,EAAE,CAAC,yBAAH,CAA6B,iBAA7B,CAAzB,EAA0E;AACxE,YAAM,aAAa,GAAG,YAAA,CAAA,oBAAA,CAAqB,iBAArB,CAAtB;AACA,QAAA,aAAa,CAAC,OAAd,CAAsB,UAAC,KAAD,EAAQ,IAAR,EAAY;AAChC,cAAM,UAAU,GACZ,KAAI,CAAC,iBAAL,CAAuB,KAAvB,EAA8B,MAA9B,CAAqC,UAAA,SAAA,EAAS;AAAI,mBAAA,KAAI,CAAC,UAAL,CAAA,SAAA,CAAA;AAA0B,WAA5E,CADJ;;AAEA,cAAI,UAAU,CAAC,MAAf,EAAuB;AACrB,YAAA,gBAAgB,CAAC,GAAjB,CAAqB,IAArB,EAA2B,UAA3B;AACD;AACF,SAND;AAOD;;AACD,aAAO,gBAAP;AACD,KAhBS;AAkBV;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,mCAAA,GAAV,UAA8C,WAA9C,EAA0E;;;AAA1E,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,eAAe,GAAqB,IAAxC;AACA,UAAM,gBAAgB,GAAG,IAAI,GAAJ,EAAzB;AACA,UAAM,oBAAoB,GAAgB,EAA1C;;AAEA,UAAM,uBAAuB,GAAG,SAA1B,uBAA0B,CAAC,KAAD,EAAc;AAC5C,YAAI,KAAK,GAAG,oBAAoB,CAAC,KAAD,CAAhC;;AACA,YAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,UAAA,KAAK,GAAG,oBAAoB,CAAC,KAAD,CAApB,GAA8B;AAAC,YAAA,UAAU,EAAE,IAAb;AAAmB,YAAA,cAAc,EAAE;AAAnC,WAAtC;AACD;;AACD,eAAO,KAAP;AACD,OAND,CALwE,CAaxE;AACA;AACA;AACA;;;AACA,UAAM,WAAW,GAAG,KAAK,sBAAL,CAA4B,WAA5B,EAAyC,CAAC,YAAD,CAAzC,CAApB;AAEA,UAAM,gBAAgB,GAAG,WAAW,CAAC,WAAZ,CAAwB,gBAAjD;AACA,UAAM,gBAAgB,GAAG,WAAW,CAAC,cAAZ,CAA2B,gBAApD;AACA,UAAM,mBAAmB,GAAG,KAAK,4BAAL,CAAkC,WAAlC,EAA+C,MAA3E;;AACA,UAAM,YAAY,GAAG,SAAf,YAAe,CAAC,UAAD,EAA0B;AAC7C,YAAM,IAAI,GAAG,KAAI,CAAC,0BAAL,CAAgC,UAAhC,CAAb;;AACA,eAAO,IAAI,KAAK,IAAT,KACF,IAAI,CAAC,IAAL,KAAc,mBAAd,IAAqC,IAAI,CAAC,IAAL,KAAc,gBAAnD,IACA,IAAI,CAAC,IAAL,KAAc,gBAFZ,CAAP;AAGD,OALD;;;AAOA,aAAyB,IAAA,aAAA,GAAA,OAAA,CAAA,QAAA,CAAA,WAAA,CAAA,EAAW,eAAA,GAAA,aAAA,CAAA,IAAA,EAApC,EAAoC,CAAA,eAAA,CAAA,IAApC,EAAoC,eAAA,GAAA,aAAA,CAAA,IAAA,EAApC,EAAsC;AAAjC,cAAM,UAAU,GAAA,eAAA,CAAA,KAAhB;;AACH,cAAI,mBAAmB,CAAC,UAAD,EAAa,YAAb,CAAvB,EAAmD;AACjD;AACA,gBAAM,UAAU,GAAG,UAAU,CAAC,SAAX,CAAqB,CAArB,CAAnB;;;AAEA,mBAAsB,IAAA,EAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,UAAU,CAAC,QAAX,CAAA,CAAA,EAAmB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAzC,EAAyC,CAAA,EAAA,CAAA,IAAzC,EAAyC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAzC,EAA2C;AAAtC,oBAAM,OAAO,GAAA,EAAA,CAAA,KAAb;AACH,oBAAM,KAAK,GAAG,KAAK,0BAAL,CAAgC,OAAhC,CAAd;;AACA,oBAAI,KAAK,KAAK,IAAd,EAAoB;AAClB;AACD;;AAED,oBAAI,KAAK,CAAC,IAAN,KAAe,WAAnB,EAAgC;AAC9B;AACA,sBAAI,KAAK,UAAL,CAAgB,KAAK,CAAC,SAAtB,CAAJ,EAAsC;AACpC,qBAAC,eAAe,KAAK,eAAe,GAAG,EAAvB,CAAhB,EAA4C,IAA5C,CAAiD,KAAK,CAAC,SAAvD;AACD;AACF,iBALD,MAKO,IAAI,KAAK,CAAC,IAAN,KAAe,kBAAnB,EAAuC;AAC5C;AACA;AACA,sBAAM,KAAK,GAAG,uBAAuB,CAAC,KAAK,CAAC,KAAP,CAArC;AACA,mBAAC,KAAK,CAAC,UAAN,KAAqB,KAAK,CAAC,UAAN,GAAmB,EAAxC,CAAD,EAA8C,IAA9C,CAAmD,KAAK,CAAC,SAAzD;AACD,iBALM,MAKA,IAAI,KAAK,CAAC,IAAN,KAAe,QAAnB,EAA6B;AAClC;AACA;AACA,kBAAA,KAAK,CAAC,KAAN,CAAY,OAAZ,CACI,UAAC,IAAD,EAAO,KAAP,EAAY;AAAK,2BAAA,uBAAuB,CAAC,KAAD,CAAvB,CAA+B,cAA/B,GAAA,IAAA;AAAoD,mBADzE;AAED;AACF;;;;;;;;;;;;AACF,WA3BD,MA2BO,IAAI,oBAAoB,CAAC,UAAD,EAAa,YAAb,CAAxB,EAAoD;AACzD;AACA,gBAAM,UAAU,GAAG,UAAU,CAAC,SAAX,CAAqB,CAArB,CAAnB;AACA,gBAAM,UAAU,GAAG,UAAU,CAAC,SAAX,CAAqB,CAArB,EAAwB,IAA3C;;;AAEA,mBAAsB,IAAA,EAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,UAAU,CAAC,QAAX,CAAA,CAAA,EAAmB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAzC,EAAyC,CAAA,EAAA,CAAA,IAAzC,EAAyC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAzC,EAA2C;AAAtC,oBAAM,OAAO,GAAA,EAAA,CAAA,KAAb;AACH,oBAAM,KAAK,GAAG,KAAK,0BAAL,CAAgC,OAAhC,CAAd;;AACA,oBAAI,KAAK,KAAK,IAAd,EAAoB;AAClB;AACD;;AAED,oBAAI,KAAK,CAAC,IAAN,KAAe,WAAnB,EAAgC;AAC9B;AACA,sBAAI,KAAK,UAAL,CAAgB,KAAK,CAAC,SAAtB,CAAJ,EAAsC;AACpC,wBAAM,UAAU,GACZ,gBAAgB,CAAC,GAAjB,CAAqB,UAArB,IAAmC,gBAAgB,CAAC,GAAjB,CAAqB,UAArB,CAAnC,GAAuE,EAD3E;AAEA,oBAAA,UAAU,CAAC,IAAX,CAAgB,KAAK,CAAC,SAAtB;AACA,oBAAA,gBAAgB,CAAC,GAAjB,CAAqB,UAArB,EAAiC,UAAjC;AACD;AACF,iBARD,MAQO,CACL;AACD;AACF;;;;;;;;;;;;AACF;AACF;;;;;;;;;;;;;AAED,aAAO;AAAC,QAAA,eAAe,EAAA,eAAhB;AAAkB,QAAA,gBAAgB,EAAA,gBAAlC;AAAoC,QAAA,oBAAoB,EAAA;AAAxD,OAAP;AACD,KApFS;AAsFV;;;;;;;;;;;;;;;;;;;;;;AAsBG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,0BAAA,GAAV,UAAqC,UAArC,EAA8D;AAC5D;AACA,UAAI,CAAC,EAAE,CAAC,gBAAH,CAAoB,UAApB,CAAL,EAAsC;AACpC,eAAO,IAAP;AACD;;AACD,UAAM,IAAI,GAAG,UAAb;AAEA,UAAM,UAAU,GAAG,aAAa,CAAC,IAAD,CAAhC;;AACA,UAAI,UAAU,KAAK,YAAnB,EAAiC;AAC/B;AACA;AACA,YAAM,GAAG,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAZ;;AACA,YAAI,GAAG,KAAK,SAAR,IAAqB,CAAC,EAAE,CAAC,eAAH,CAAmB,GAAnB,CAAtB,IAAiD,GAAG,CAAC,IAAJ,KAAa,mBAAlE,EAAuF;AACrF,iBAAO,IAAP;AACD;;AAED,YAAM,KAAK,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAd;;AACA,YAAI,KAAK,KAAK,SAAV,IAAuB,CAAC,EAAE,CAAC,wBAAH,CAA4B,KAA5B,CAA5B,EAAgE;AAC9D,iBAAO,IAAP;AACD;;AAED,eAAO;AACL,UAAA,IAAI,EAAE,QADD;AAEL,UAAA,KAAK,EAAE,KAAK,CAAC,IAAN,CAAW,KAAK,CAAC,QAAjB;AAFF,SAAP;AAID;;AAED,UAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B;AACA,YAAM,QAAQ,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAjB;AACA,YAAM,KAAK,GAAG,QAAQ,IAAI,EAAE,CAAC,gBAAH,CAAoB,QAApB,CAAZ,GAA4C,QAAQ,CAAC,QAAQ,CAAC,IAAV,EAAgB,EAAhB,CAApD,GAA0E,GAAxF;;AACA,YAAI,KAAK,CAAC,KAAD,CAAT,EAAkB;AAChB,iBAAO,IAAP;AACD;;AAED,YAAM,aAAa,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAtB;;AACA,YAAI,aAAa,KAAK,SAAlB,IAA+B,CAAC,EAAE,CAAC,gBAAH,CAAoB,aAApB,CAApC,EAAwE;AACtE,iBAAO,IAAP;AACD;;AAED,YAAM,WAAS,GAAG,KAAK,oBAAL,CAA0B,aAA1B,CAAlB;;AACA,YAAI,WAAS,KAAK,IAAlB,EAAwB;AACtB,iBAAO,IAAP;AACD;;AAED,eAAO;AACL,UAAA,IAAI,EAAE,kBADD;AAEL,UAAA,KAAK,EAAA,KAFA;AAGL,UAAA,SAAS,EAAA;AAHJ,SAAP;AAKD,OAlD2D,CAoD5D;;;AACA,UAAM,SAAS,GAAG,KAAK,oBAAL,CAA0B,IAA1B,CAAlB;;AACA,UAAI,SAAS,KAAK,IAAlB,EAAwB;AACtB,eAAO,IAAP;AACD;;AACD,aAAO;AACL,QAAA,IAAI,EAAE,WADD;AAEL,QAAA,SAAS,EAAA;AAFJ,OAAP;AAID,KA7DS;;AA+DA,IAAA,qBAAA,CAAA,SAAA,CAAA,oBAAA,GAAV,UAA+B,IAA/B,EAAsD;AACpD,UAAM,mBAAmB,GAAG,IAAI,CAAC,UAAjC;;AACA,UAAI,CAAC,YAAA,CAAA,qBAAA,CAAsB,mBAAtB,CAAL,EAAiD;AAC/C,eAAO,IAAP;AACD,OAJmD,CAMpD;;;AACA,UAAM,mBAAmB,GACrB,EAAE,CAAC,YAAH,CAAgB,mBAAhB,IAAuC,mBAAvC,GAA6D,mBAAmB,CAAC,IADrF;AAGA,aAAO;AACL,QAAA,IAAI,EAAE,mBAAmB,CAAC,IADrB;AAEL,QAAA,UAAU,EAAE,mBAFP;AAGL,QAAA,MAAM,EAAE,KAAK,qBAAL,CAA2B,mBAA3B,CAHH;AAIL,QAAA,IAAI,EAAE,IAJD;AAKL,QAAA,IAAI,EAAE,KAAK,CAAC,IAAN,CAAW,IAAI,CAAC,SAAhB;AALD,OAAP;AAOD,KAjBS;AAmBV;;;;;;;;;AASG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UAAwB,SAAxB,EAAiD,WAAjD,EAAsE;AACpE,UAAI,CAAC,EAAE,CAAC,qBAAH,CAAyB,SAAzB,KAAuC,EAAE,CAAC,iBAAH,CAAqB,SAArB,CAAxC,KACA,SAAS,CAAC,UADd,EAC0B;AACxB,YAAI,UAAU,GAAG,SAAS,CAAC,UAA3B;;AACA,eAAO,YAAY,CAAC,UAAD,CAAnB,EAAiC;AAC/B,UAAA,UAAU,GAAG,UAAU,CAAC,KAAxB;AACD;;AACD,YAAI,EAAE,CAAC,gBAAH,CAAoB,UAApB,CAAJ,EAAqC;AACnC,cAAM,UAAU,GAAG,aAAa,CAAC,UAAD,CAAhC;;AACA,cAAI,UAAU,KAAK,IAAf,IAAuB,WAAW,CAAC,QAAZ,CAAqB,UAArB,CAA3B,EAA6D;AAC3D,mBAAO,UAAP;AACD;AACF;AACF;;AACD,aAAO,IAAP;AACD,KAfS;AAkBV;;;;;;;;;;;;;AAaG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,iBAAA,GAAV,UAA4B,eAA5B,EAA0D;AAA1D,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,UAAU,GAAgB,EAAhC;;AAEA,UAAI,EAAE,CAAC,wBAAH,CAA4B,eAA5B,CAAJ,EAAkD;AAChD;AACA,QAAA,eAAe,CAAC,QAAhB,CAAyB,OAAzB,CAAiC,UAAA,IAAA,EAAI;AACnC;AACA,cAAI,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAJ,EAAwC;AACtC;AACA,gBAAM,SAAS,GAAG,YAAA,CAAA,oBAAA,CAAqB,IAArB,CAAlB,CAFsC,CAItC;;AACA,gBAAI,SAAS,CAAC,GAAV,CAAc,MAAd,CAAJ,EAA2B;AACzB,kBAAI,aAAa,GAAG,SAAS,CAAC,GAAV,CAAc,MAAd,CAApB;;AACA,kBAAI,YAAA,CAAA,qBAAA,CAAsB,aAAtB,CAAJ,EAA0C;AACxC,oBAAM,mBAAmB,GACrB,EAAE,CAAC,YAAH,CAAgB,aAAhB,IAAiC,aAAjC,GAAiD,aAAa,CAAC,IADnE;AAEA,gBAAA,UAAU,CAAC,IAAX,CAAgB;AACd,kBAAA,IAAI,EAAE,mBAAmB,CAAC,IADZ;AAEd,kBAAA,UAAU,EAAE,aAFE;AAGd,kBAAA,MAAM,EAAE,KAAI,CAAC,qBAAL,CAA2B,mBAA3B,CAHM;AAId,kBAAA,IAAI,EAAA,IAJU;AAKd,kBAAA,IAAI,EAAE,gBAAgB,CAAC,IAAD;AALR,iBAAhB;AAOD;AACF;AACF;AACF,SAtBD;AAuBD;;AACD,aAAO,UAAP;AACD,KA9BS;AAgCV;;;;;;;;;;;;;;;;;;;AAmBG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,cAAA,GAAV,UAAyB,MAAzB,EAA4C,UAA5C,EAAsE,QAAtE,EAAwF;AAEtF,UAAI,MAAM,CAAC,KAAP,GAAe,EAAE,CAAC,WAAH,CAAe,QAAlC,EAA4C;AAC1C,YAAM,OAAO,GAAkB,EAA/B;AACA,YAAM,MAAM,GAAG,MAAM,CAAC,YAAP,IAAuB,MAAM,CAAC,YAAP,CAAoB,IAApB,CAAyB,EAAE,CAAC,aAA5B,CAAtC;AACA,YAAM,MAAM,GAAG,MAAM,CAAC,YAAP,IAAuB,MAAM,CAAC,YAAP,CAAoB,IAApB,CAAyB,EAAE,CAAC,aAA5B,CAAtC;AAEA,YAAM,YAAY,GACd,MAAM,IAAI,KAAK,aAAL,CAAmB,MAAnB,EAA2B,YAAA,CAAA,eAAA,CAAgB,MAA3C,EAAmD,UAAnD,EAA+D,QAA/D,CADd;;AAEA,YAAI,YAAJ,EAAkB;AAChB,UAAA,OAAO,CAAC,IAAR,CAAa,YAAb,EADgB,CAGhB;AACA;AACA;;AACA,UAAA,UAAU,GAAG,SAAb;AACD;;AAED,YAAM,YAAY,GACd,MAAM,IAAI,KAAK,aAAL,CAAmB,MAAnB,EAA2B,YAAA,CAAA,eAAA,CAAgB,MAA3C,EAAmD,UAAnD,EAA+D,QAA/D,CADd;;AAEA,YAAI,YAAJ,EAAkB;AAChB,UAAA,OAAO,CAAC,IAAR,CAAa,YAAb;AACD;;AAED,eAAO,OAAP;AACD;;AAED,UAAI,IAAI,GAAyB,IAAjC;;AACA,UAAI,MAAM,CAAC,KAAP,GAAe,EAAE,CAAC,WAAH,CAAe,MAAlC,EAA0C;AACxC,QAAA,IAAI,GAAG,YAAA,CAAA,eAAA,CAAgB,MAAvB;AACD,OAFD,MAEO,IAAI,MAAM,CAAC,KAAP,GAAe,EAAE,CAAC,WAAH,CAAe,QAAlC,EAA4C;AACjD,QAAA,IAAI,GAAG,YAAA,CAAA,eAAA,CAAgB,QAAvB;AACD;;AAED,UAAM,IAAI,GAAG,MAAM,CAAC,gBAAP,IAA2B,MAAM,CAAC,YAAP,IAAuB,MAAM,CAAC,YAAP,CAAoB,CAApB,CAA/D;;AACA,UAAI,CAAC,IAAL,EAAW;AACT;AACA;AACA;AACA,eAAO,IAAP;AACD;;AAED,UAAM,MAAM,GAAG,KAAK,aAAL,CAAmB,IAAnB,EAAyB,IAAzB,EAA+B,UAA/B,EAA2C,QAA3C,CAAf;;AACA,UAAI,CAAC,MAAL,EAAa;AACX,eAAO,IAAP;AACD;;AAED,aAAO,CAAC,MAAD,CAAP;AACD,KAhDS;AAkDV;;;;;;;;AAQG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UACI,IADJ,EAC0B,IAD1B,EACsD,UADtD,EAEI,QAFJ,EAEsB;AACpB,UAAI,KAAK,GAAuB,IAAhC;AACA,UAAI,IAAI,GAAgB,IAAxB;AACA,UAAI,QAAQ,GAAuB,IAAnC;;AAEA,UAAI,CAAC,iBAAiB,CAAC,IAAD,CAAtB,EAA8B;AAC5B,eAAO,IAAP;AACD;;AAED,UAAI,QAAQ,IAAI,gBAAgB,CAAC,IAAD,CAAhC,EAAwC;AACtC,QAAA,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,IAAjB;AACA,QAAA,KAAK,GAAG,IAAI,KAAK,YAAA,CAAA,eAAA,CAAgB,QAAzB,GAAoC,IAAI,CAAC,MAAL,CAAY,KAAhD,GAAwD,IAAhE;AACD,OAHD,MAGO,IAAI,gBAAgB,CAAC,IAAD,CAApB,EAA4B;AACjC,QAAA,IAAI,GAAG,YAAA,CAAA,eAAA,CAAgB,QAAvB;AACA,QAAA,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe,IAAtB;AACA,QAAA,KAAK,GAAG,IAAI,CAAC,KAAb;AACA,QAAA,QAAQ,GAAG,KAAX;AACD,OALM,MAKA,IAAI,EAAE,CAAC,wBAAH,CAA4B,IAA5B,CAAJ,EAAuC;AAC5C,QAAA,IAAI,GAAG,YAAA,CAAA,eAAA,CAAgB,WAAvB;AACA,QAAA,IAAI,GAAG,aAAP;AACA,QAAA,QAAQ,GAAG,KAAX;AACD;;AAED,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,aAAK,MAAL,CAAY,IAAZ,CAAiB,4BAAyB,IAAI,CAAC,OAAL,EAA1C;AACA,eAAO,IAAP;AACD;;AAED,UAAI,CAAC,IAAL,EAAW;AACT,YAAI,kBAAkB,CAAC,IAAD,CAAtB,EAA8B;AAC5B,UAAA,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,IAAjB;AACA,UAAA,QAAQ,GAAG,IAAI,CAAC,IAAhB;AACD,SAHD,MAGO;AACL,iBAAO,IAAP;AACD;AACF,OAnCmB,CAqCpB;AACA;;;AACA,UAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,QAAA,QAAQ,GAAG,IAAI,CAAC,SAAL,KAAmB,SAAnB,IACP,IAAI,CAAC,SAAL,CAAe,IAAf,CAAoB,UAAA,GAAA,EAAG;AAAI,iBAAA,GAAG,CAAC,IAAJ,KAAa,EAAE,CAAC,UAAH,CAAb,aAAA;AAAwC,SAAnE,CADJ;AAED;;AAED,UAAM,IAAI,GAAiB,IAAY,CAAC,IAAb,IAAqB,IAAhD;AACA,aAAO;AACL,QAAA,IAAI,EAAA,IADC;AAEL,QAAA,cAAc,EAAE,IAFX;AAGL,QAAA,IAAI,EAAA,IAHC;AAIL,QAAA,IAAI,EAAA,IAJC;AAKL,QAAA,IAAI,EAAA,IALC;AAML,QAAA,QAAQ,EAAA,QANH;AAOL,QAAA,KAAK,EAAA,KAPA;AAQL,QAAA,QAAQ,EAAA,QARH;AASL,QAAA,UAAU,EAAE,UAAU,IAAI;AATrB,OAAP;AAWD,KA1DS;AA4DV;;;;;AAKG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,mCAAA,GAAV,UAA8C,WAA9C,EAA0E;AAExE,UAAM,OAAO,GAAG,WAAW,CAAC,cAAZ,CAA2B,OAA3C;;AACA,UAAI,OAAO,IAAI,OAAO,CAAC,GAAR,CAAY,OAAA,CAAA,WAAZ,CAAf,EAAyC;AACvC,YAAM,iBAAiB,GAAG,OAAO,CAAC,GAAR,CAAY,OAAA,CAAA,WAAZ,CAA1B,CADuC,CAEvC;;AACA,YAAM,WAAW,GAAG,iBAAiB,CAAC,YAAlB,IAChB,iBAAiB,CAAC,YAAlB,CAA+B,CAA/B,CADJ;;AAEA,YAAI,CAAC,WAAL,EAAkB;AAChB,iBAAO,EAAP;AACD;;AACD,YAAI,WAAW,CAAC,UAAZ,CAAuB,MAAvB,GAAgC,CAApC,EAAuC;AACrC,iBAAO,KAAK,CAAC,IAAN,CAAW,WAAW,CAAC,UAAvB,CAAP;AACD;;AACD,YAAI,wBAAwB,CAAC,WAAD,CAA5B,EAA2C;AACzC,iBAAO,IAAP;AACD;;AACD,eAAO,EAAP;AACD;;AACD,aAAO,IAAP;AACD,KApBS;AAsBV;;;;;;AAMG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,uBAAA,GAAV,UACI,WADJ,EACkC,cADlC,EAC2E;AAD3E,UAAA,KAAA,GAAA,IAAA;;AAES,UAAA,oBAAoB,GAAI,KAAK,oBAAL,CAA0B,WAA1B,EAAJ,oBAApB;AAEP,aAAO,cAAc,CAAC,GAAf,CAAmB,UAAC,IAAD,EAAO,KAAP,EAAY;AAC9B,YAAA,EAAA,GAA+B,oBAAoB,CAAC,KAAD,CAApB,GACjC,oBAAoB,CAAC,KAAD,CADa,GAEjC;AAAC,UAAA,UAAU,EAAE,IAAb;AAAmB,UAAA,cAAc,EAAE;AAAnC,SAFE;AAAA,YAAC,UAAU,GAAA,EAAA,CAAA,UAAX;AAAA,YAAa,cAAc,GAAA,EAAA,CAAA,cAA3B;;AAGN,YAAM,QAAQ,GAAG,IAAI,CAAC,IAAtB;;AACA,YAAM,kBAAkB,GAAG,KAAI,CAAC,WAAL,CAAiB,cAAjB,CAA3B;;AAEA,eAAO;AACL,UAAA,IAAI,EAAE,OAAA,CAAA,WAAA,CAAY,QAAZ,CADD;AAEL,UAAA,QAAQ,EAAA,QAFH;AAGL,UAAA,kBAAkB,EAAA,kBAHb;AAIL,UAAA,QAAQ,EAAE,IAJL;AAKL,UAAA,UAAU,EAAA;AALL,SAAP;AAOD,OAdM,CAAP;AAeD,KAnBS;AAqBV;;;;;;;;AAQG;;;AACK,IAAA,qBAAA,CAAA,SAAA,CAAA,WAAA,GAAR,UAAoB,cAApB,EAAsD;AACpD,UAAI,cAAc,KAAK,IAAvB,EAA6B;AAC3B,eAAO;AACL,UAAA,IAAI,EAAA;AAAA;AADC;AAEL,UAAA,MAAM,EAAE;AAAC,YAAA,IAAI,EAAA;AAAA;;AAAL;AAFH,SAAP;AAID;;AAED,UAAM,GAAG,GAAG,KAAK,qBAAL,CAA2B,cAA3B,CAAZ;AACA,UAAM,IAAI,GAAG,KAAK,0BAAL,CAAgC,cAAhC,CAAb;;AACA,UAAI,GAAG,KAAK,IAAR,IAAgB,IAAI,KAAK,IAA7B,EAAmC;AACjC,eAAO;AACL,UAAA,IAAI,EAAA;AAAA;AADC;AAEL,UAAA,UAAU,EAAE,cAFP;AAGL,UAAA,sBAAsB,EAAE;AAHnB,SAAP;AAKD;;AAED,aAAO;AACL,QAAA,IAAI,EAAA;AAAA;AADC;AAEL,QAAA,gBAAgB,EAAE,IAAI,CAAC,IAFlB;AAGL,QAAA,UAAU,EAAE,GAAG,CAAC,IAHX;AAIL,QAAA,YAAY,EAAE,GAAG,CAAC,IAJb;AAKL,QAAA,UAAU,EAAE;AALP,OAAP;AAOD,KAzBO;AA2BR;;;;;;AAMG;;;AACK,IAAA,qBAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,UAA8B,UAA9B,EAAuD;AACrD,UAAI,EAAE,CAAC,YAAH,CAAgB,UAAhB,CAAJ,EAAiC;AAC/B,eAAO,KAAK,qBAAL,CAA2B,UAA3B,CAAP;AACD,OAFD,MAEO,IAAI,EAAE,CAAC,0BAAH,CAA8B,UAA9B,KAA6C,EAAE,CAAC,YAAH,CAAgB,UAAU,CAAC,IAA3B,CAAjD,EAAmF;AACxF,eAAO,KAAK,qBAAL,CAA2B,UAAU,CAAC,IAAtC,CAAP;AACD,OAFM,MAEA;AACL,eAAO,IAAP;AACD;AACF,KARO;AAUR;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,8BAAA,GAAV,UAAyC,uBAAzC,EAA2E;AAA3E,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,eAAe,GAAG,0BAA0B,CAAC,uBAAD,CAAlD;;AACA,UAAI,eAAJ,EAAqB;AACnB;AACA,YAAM,SAAS,GACX,EAAE,CAAC,eAAH,CAAmB,eAAnB,IAAsC,eAAe,CAAC,IAAtD,GAA6D,eADjE;;AAEA,YAAI,EAAE,CAAC,wBAAH,CAA4B,SAA5B,CAAJ,EAA4C;AAC1C,cAAM,QAAQ,GAAG,SAAS,CAAC,QAA3B;AACA,iBAAO,QAAQ,CACV,GADE,CAEC,UAAA,OAAA,EAAO;AACH,mBAAA,EAAE,CAAC,yBAAH,CAA6B,OAA7B,IAAwC,YAAA,CAAA,oBAAA,CAAqB,OAArB,CAAxC,GAAwE,IAAxE;AAA4E,WAHjF,EAIF,GAJE,CAIE,UAAA,SAAA,EAAS;AACZ,gBAAM,cAAc,GAChB,SAAS,IAAI,SAAS,CAAC,GAAV,CAAc,MAAd,CAAb,GAAqC,SAAS,CAAC,GAAV,CAAc,MAAd,CAArC,GAA8D,IADlE;AAEA,gBAAM,aAAa,GACf,SAAS,IAAI,SAAS,CAAC,GAAV,CAAc,YAAd,CAAb,GAA2C,SAAS,CAAC,GAAV,CAAc,YAAd,CAA3C,GAA0E,IAD9E;;AAEA,gBAAM,UAAU,GAAG,aAAa,IAC5B,KAAI,CAAC,iBAAL,CAAuB,aAAvB,EACK,MADL,CACY,UAAA,SAAA,EAAS;AAAI,qBAAA,KAAI,CAAC,UAAL,CAAA,SAAA,CAAA;AAA0B,aADnD,CADJ;;AAGA,mBAAO;AAAC,cAAA,cAAc,EAAA,cAAf;AAAiB,cAAA,UAAU,EAAA;AAA3B,aAAP;AACD,WAbE,CAAP;AAcD,SAhBD,MAgBO,IAAI,eAAe,KAAK,SAAxB,EAAmC;AACxC,eAAK,MAAL,CAAY,IAAZ,CACI,gDACI,eAAe,CAAC,aAAhB,GAAgC,QADpC,GAC+C,KAFnD,EAGI,eAAe,CAAC,OAAhB,EAHJ;AAID;AACF;;AACD,aAAO,IAAP;AACD,KA9BS;AAgCV;;;;;;AAMG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,sBAAA,GAAV,UAAiC,WAAjC,EAA+D,WAA/D,EAAoF;AAApF,UAAA,KAAA,GAAA,IAAA;;AAEE,aAAO,KAAK,qBAAL,CAA2B,WAA3B,EACF,GADE,CACE,UAAA,SAAA,EAAS;AAAI,eAAA,KAAI,CAAC,aAAL,CAAmB,SAAnB,EAAA,WAAA,CAAA;AAA0C,OADzD,EAEF,MAFE,CAEK,OAAA,CAAA,SAFL,CAAP;AAGD,KALS;AAOV;;;;;;;;AAQG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,qBAAA,GAAV,UAAgC,WAAhC,EAA4D;AAC1D,UAAM,SAAS,GAAG,WAAW,CAAC,cAAZ,CAA2B,gBAA7C;;AACA,UAAI,UAAU,CAAC,SAAD,CAAd,EAA2B;AACzB,eAAO,KAAK,mBAAL,CAAyB,SAAS,CAAC,aAAV,EAAzB,CAAP;AACD;;AACD,UAAM,SAAS,GAAG,sBAAsB,CAAC,SAAD,CAAxC;;AACA,UAAI,EAAE,CAAC,OAAH,CAAW,SAAS,CAAC,MAArB,CAAJ,EAAkC;AAChC,eAAO,KAAK,CAAC,IAAN,CAAW,SAAS,CAAC,MAAV,CAAiB,UAA5B,CAAP;AACD,OARyD,CAS1D;;;AACA,YAAM,IAAI,KAAJ,CAAU,4CAA0C,WAAW,CAAC,IAAhE,CAAN;AACD,KAXS;AAaV;;;;;;;;;;AAUG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,UAAA,GAAV,UAAqB,SAArB,EAAyC;AACvC,UAAI,KAAK,MAAT,EAAiB;AACf,eAAO,CAAC,SAAS,CAAC,MAAX,IAAqB,MAAM,IAAN,CAAW,SAAS,CAAC,MAAV,CAAiB,IAA5B,CAA5B;AACD,OAFD,MAEO;AACL,eAAO,CAAC,CAAC,SAAS,CAAC,MAAZ,IAAsB,SAAS,CAAC,MAAV,CAAiB,IAAjB,KAA0B,eAAvD;AACD;AACF,KANS;AAQV;;;;;;;AAOG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,8BAAA,GAAV,UAAyC,GAAzC,EAA6D,GAA7D,EAA+E;AAE7E,UAAM,cAAc,GAAG,IAAI,GAAJ,EAAvB;AACA,UAAM,iBAAiB,GAAG,IAAI,GAAJ,EAA1B;AACA,UAAM,OAAO,GAAG,iBAAiB,CAAC,GAAD,CAAjC;AACA,WAAK,8BAAL,CAAoC,iBAApC,EAAuD,OAAvD,EAAgE,GAAG,CAAC,OAAJ,CAAY,cAAZ,EAAhE;AACA,UAAM,OAAO,GAAG,iBAAiB,CAAC,GAAD,CAAjC;AACA,WAAK,8BAAL,CAAoC,cAApC,EAAoD,iBAApD,EAAuE,OAAvE;AACA,aAAO,cAAP;AACD,KATS;AAWV;;;;;;;;;;;;AAYG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,+BAAA,GAAV,UAA0C,GAA1C,EAA8D,GAA9D,EAAgF;;;AAE9E,UAAM,cAAc,GAAG,IAAI,GAAJ,EAAvB;AACA,UAAM,iBAAiB,GAAG,IAAI,GAAJ,EAA1B;AACA,UAAM,WAAW,GAAG,GAAG,CAAC,OAAJ,CAAY,cAAZ,EAApB;AAEA,UAAM,QAAQ,GAAG,sBAAsB,CAAC,GAAD,CAAvC;;;AACA,aAAsB,IAAA,UAAA,GAAA,OAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAA8B,CAAA,YAAA,CAAA,IAA9B,EAA8B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAAgC;AAA3B,cAAM,OAAO,GAAA,YAAA,CAAA,KAAb;AACH,eAAK,8BAAL,CAAoC,iBAApC,EAAuD,OAAvD,EAAgE,WAAhE;AACD;;;;;;;;;;;;;AAED,UAAM,QAAQ,GAAG,sBAAsB,CAAC,GAAD,CAAvC;;;AACA,aAAsB,IAAA,UAAA,GAAA,OAAA,CAAA,QAAA,CAAA,QAAA,CAAA,EAAQ,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAA8B,CAAA,YAAA,CAAA,IAA9B,EAA8B,YAAA,GAAA,UAAA,CAAA,IAAA,EAA9B,EAAgC;AAA3B,cAAM,OAAO,GAAA,YAAA,CAAA,KAAb;AACH,eAAK,8BAAL,CAAoC,cAApC,EAAoD,iBAApD,EAAuE,OAAvE;AACD;;;;;;;;;;;;;AACD,aAAO,cAAP;AACD,KAhBS;AAkBV;;;;AAIG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,8BAAA,GAAV,UACI,iBADJ,EACoD,OADpD,EAEI,OAFJ,EAE2B;AACzB,UAAM,SAAS,GAAG,OAAO,IAAI,OAAO,CAAC,mBAAR,CAA4B,OAA5B,CAA7B;AACA,UAAM,aAAa,GAAG,SAAS,IAAI,OAAO,CAAC,kBAAR,CAA2B,SAA3B,CAAnC;;AACA,UAAI,aAAJ,EAAmB;AACjB,QAAA,aAAa,CAAC,OAAd,CAAsB,UAAA,cAAA,EAAc;AAClC,cAAM,IAAI,GAAG,cAAc,CAAC,IAA5B;;AACA,cAAI,cAAc,CAAC,KAAf,GAAuB,EAAE,CAAC,WAAH,CAAe,KAA1C,EAAiD;AAC/C,YAAA,cAAc,GAAG,OAAO,CAAC,gBAAR,CAAyB,cAAzB,CAAjB;AACD;;AACD,cAAM,WAAW,GAAG,cAAc,CAAC,gBAAnC;;AACA,cAAI,WAAW,IAAI,CAAC,iBAAiB,CAAC,GAAlB,CAAsB,IAAtB,CAApB,EAAiD;AAC/C,YAAA,iBAAiB,CAAC,GAAlB,CAAsB,IAAtB,EAA4B,WAA5B;AACD;AACF,SATD;AAUD;AACF,KAjBS;;AAoBA,IAAA,qBAAA,CAAA,SAAA,CAAA,8BAAA,GAAV,UACI,cADJ,EAEI,iBAFJ,EAEoD,OAFpD,EAE0E;;;AACxE,UAAM,WAAW,GAAG,KAAK,kBAAL,CAAwB,OAAxB,CAApB;;AACA,UAAI,WAAW,KAAK,IAApB,EAA0B;;AACxB,eAAoD,IAAA,aAAA,GAAA,OAAA,CAAA,QAAA,CAAA,WAAA,CAAA,EAAW,eAAA,GAAA,aAAA,CAAA,IAAA,EAA/D,EAA+D,CAAA,eAAA,CAAA,IAA/D,EAA+D,eAAA,GAAA,aAAA,CAAA,IAAA,EAA/D,EAAiE;AAAtD,gBAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAAA,eAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,gBAAC,UAAU,GAAA,EAAA,CAAA,CAAA,CAAX;AAAA,gBAAoB,eAAe,GAAA,EAAA,CAAA,CAAA,CAAA,CAAA,IAAnC;;AACT,gBAAI,iBAAiB,CAAC,GAAlB,CAAsB,UAAtB,CAAJ,EAAuC;AACrC,cAAA,cAAc,CAAC,GAAf,CAAmB,eAAnB,EAAoC,iBAAiB,CAAC,GAAlB,CAAsB,UAAtB,CAApC;AACD;AACF;;;;;;;;;;;;AACF;AACF,KAXS;;AAaA,IAAA,qBAAA,CAAA,SAAA,CAAA,0BAAA,GAAV,UAAqC,UAArC,EAA8D;AAC5D,UAAI,EAAE,CAAC,YAAH,CAAgB,UAAhB,CAAJ,EAAiC;AAC/B,eAAO,KAAK,0BAAL,CAAgC,UAAhC,CAAP;AACD;;AAED,UAAI,CAAC,EAAE,CAAC,0BAAH,CAA8B,UAA9B,CAAD,IAA8C,CAAC,EAAE,CAAC,YAAH,CAAgB,UAAU,CAAC,UAA3B,CAAnD,EAA2F;AACzF,eAAO,IAAP;AACD;;AAED,UAAM,aAAa,GAAG,KAAK,0BAAL,CAAgC,UAAU,CAAC,UAA3C,CAAtB;;AACA,UAAI,CAAC,aAAD,IAAkB,CAAC,EAAE,CAAC,YAAH,CAAgB,aAAa,CAAC,IAA9B,CAAvB,EAA4D;AAC1D,eAAO,IAAP;AACD;;AAED,UAAM,gBAAgB,GAAG,KAAK,kBAAL,CAAwB,aAAa,CAAC,IAAtC,CAAzB;;AACA,UAAI,gBAAgB,KAAK,IAAzB,EAA+B;AAC7B,eAAO,IAAP;AACD;;AAED,UAAI,CAAC,gBAAgB,CAAC,GAAjB,CAAqB,UAAU,CAAC,IAAX,CAAgB,IAArC,CAAL,EAAiD;AAC/C,eAAO,IAAP;AACD;;AAED,UAAM,UAAU,GAAG,gBAAgB,CAAC,GAAjB,CAAqB,UAAU,CAAC,IAAX,CAAgB,IAArC,CAAnB;AACA,aAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAAW,UAAX,CAAA,EAAqB;AAAE,QAAA,SAAS,EAAE,aAAa,CAAC;AAA3B,OAArB,CAAA;AACD,KAzBS;AA2BV;;;AACU,IAAA,qBAAA,CAAA,SAAA,CAAA,6BAAA,GAAV,UAAwC,IAAxC,EAAyD;AACvD,UAAM,IAAI,GAAG,IAAI,CAAC,IAAlB,CADuD,CAEvD;AACA;;AACA,UAAI,CAAC,EAAE,CAAC,qBAAH,CAAyB,IAAzB,CAAD,IAAmC,CAAC,EAAE,CAAC,YAAH,CAAgB,IAAI,CAAC,IAArB,CAApC,IACA,IAAI,CAAC,IAAL,CAAU,IAAV,KAAmB,QADnB,IAC+B,IAAI,CAAC,IAAL,KAAc,SADjD,EAC4D;AAC1D,eAAO,KAAP;AACD;;AACD,UAAM,QAAQ,GAAG,IAAI,CAAC,IAAtB,CARuD,CASvD;AACA;;AACA,UAAI,CAAC,EAAE,CAAC,mBAAH,CAAuB,QAAvB,CAAD,IAAqC,CAAC,EAAE,CAAC,YAAH,CAAgB,QAAQ,CAAC,QAAzB,CAAtC,IACA,QAAQ,CAAC,QAAT,CAAkB,IAAlB,KAA2B,mBAD/B,EACoD;AAClD,eAAO,KAAP;AACD,OAdsD,CAevD;AACA;;;AACA,aAAO,KAAK,GAAL,CAAS,OAAT,CAAiB,0BAAjB,CAA4C,IAAI,CAAC,aAAL,EAA5C,CAAP;AACD,KAlBS;AAoBV;;;;;;;;;;;;;AAaG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,kBAAA,GAAV,UAA6B,WAA7B,EAAgE;AAC9D;AACA,UAAI,WAAW,CAAC,WAAZ,KAA4B,SAAhC,EAA2C,OAAO,IAAP;AAE3C,UAAM,YAAY,GAAG,WAAW,CAAC,MAAZ,CAAmB,MAAxC;AACA,UAAI,CAAC,EAAE,CAAC,mBAAH,CAAuB,YAAvB,CAAL,EAA2C,OAAO,IAAP;AAE3C,UAAM,KAAK,GAAG,YAAY,CAAC,MAA3B;AACA,UAAI,CAAC,EAAE,CAAC,OAAH,CAAW,KAAX,CAAD,IAAsB,CAAC,EAAE,CAAC,YAAH,CAAgB,KAAhB,CAA3B,EAAmD,OAAO,IAAP;AAEnD,UAAM,gBAAgB,GAAG,KAAK,CAAC,UAAN,CAAiB,SAAjB,CAA2B,UAAA,SAAA,EAAS;AAAI,eAAA,SAAS,KAAT,YAAA;AAA0B,OAAlE,CAAzB;AACA,UAAI,gBAAgB,KAAK,CAAC,CAAtB,IAA2B,gBAAgB,KAAK,KAAK,CAAC,UAAN,CAAiB,MAAjB,GAA0B,CAA9E,EAAiF,OAAO,IAAP;AAEjF,UAAM,cAAc,GAAG,KAAK,CAAC,UAAN,CAAiB,gBAAgB,GAAG,CAApC,CAAvB;AACA,UAAI,CAAC,EAAE,CAAC,qBAAH,CAAyB,cAAzB,CAAL,EAA+C,OAAO,IAAP;AAE/C,UAAM,IAAI,GAAG,OAAA,CAAA,gBAAA,CAAiB,cAAc,CAAC,UAAhC,CAAb;AACA,UAAI,CAAC,EAAE,CAAC,gBAAH,CAAoB,IAApB,CAAD,IAA8B,CAAC,qBAAqB,CAAC,IAAD,CAAxD,EAAgE,OAAO,IAAP;AAEhE,UAAM,EAAE,GAAG,OAAA,CAAA,gBAAA,CAAiB,IAAI,CAAC,UAAtB,CAAX;AACA,UAAI,CAAC,EAAE,CAAC,oBAAH,CAAwB,EAAxB,CAAL,EAAkC,OAAO,IAAP;AAElC,aAAO,KAAK,kBAAL,CAAwB,EAAxB,CAAP;AACD,KAvBS;AAyBV;;;;;;;;;;;AAWG;;;AACK,IAAA,qBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,UAA2B,EAA3B,EAAoD;;;AAClD,UAAI,EAAE,CAAC,UAAH,CAAc,MAAd,KAAyB,CAA7B,EAAgC,OAAO,IAAP;AAEhC,UAAM,QAAQ,GAAG,EAAE,CAAC,UAAH,CAAc,CAAd,EAAiB,IAAlC;AACA,UAAI,CAAC,EAAE,CAAC,YAAH,CAAgB,QAAhB,CAAL,EAAgC,OAAO,IAAP;AAEhC,UAAM,WAAW,GAAiB,EAAlC;;;AACA,aAAwB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,EAAE,CAAC,IAAH,CAAQ,UAAR,CAAA,EAAkB,EAAA,GAAA,EAAA,CAAA,IAAA,EAA1C,EAA0C,CAAA,EAAA,CAAA,IAA1C,EAA0C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA1C,EAA4C;AAAvC,cAAM,SAAS,GAAA,EAAA,CAAA,KAAf;AACH,cAAM,UAAU,GAAG,KAAK,iBAAL,CAAuB,QAAvB,EAAiC,SAAjC,CAAnB;;AACA,cAAI,UAAU,KAAK,IAAnB,EAAyB;AACvB,mBAAO,IAAP;AACD;;AACD,UAAA,WAAW,CAAC,IAAZ,CAAiB,UAAjB;AACD;;;;;;;;;;;;;AACD,aAAO,WAAP;AACD,KAfO;AAiBR;;;;;;;;;;;;AAYG;;;AACO,IAAA,qBAAA,CAAA,SAAA,CAAA,iBAAA,GAAV,UAA4B,QAA5B,EAAqD,SAArD,EAA4E;AAC1E,UAAI,CAAC,EAAE,CAAC,qBAAH,CAAyB,SAAzB,CAAL,EAA0C,OAAO,IAAP;AAE1C,UAAM,UAAU,GAAG,SAAS,CAAC,UAA7B,CAH0E,CAK1E;;AACA,UAAI,CAAC,gBAAgB,CAAC,QAAD,EAAW,UAAX,CAArB,EAA6C;AAC3C,eAAO,IAAP;AACD;;AACD,UAAM,UAAU,GAAG,qBAAqB,CAAC,UAAD,CAAxC;;AACA,UAAI,UAAU,IAAI,IAAlB,EAAwB;AACtB,eAAO,UAAP;AACD,OAZyE,CAc1E;;;AACA,UAAM,eAAe,GAAG,UAAU,CAAC,IAAX,CAAgB,kBAAxC;;AACA,UAAI,CAAC,gBAAgB,CAAC,QAAD,EAAW,eAAX,CAArB,EAAkD;AAChD,eAAO,IAAP;AACD;;AACD,aAAO,qBAAqB,CAAC,eAAD,CAA5B;AACD,KApBS;;AAsBF,IAAA,qBAAA,CAAA,SAAA,CAAA,4BAAA,GAAR,UAAqC,WAArC,EAAiE;AAC/D,UAAI,WAAW,CAAC,QAAZ,KAAyB,SAA7B,EAAwC;AACtC,eAAO,KAAK,iCAAL,CACH,WADG,EACU,WAAW,CAAC,QAAZ,CAAqB,gBAD/B,CAAP;AAED,OAHD,MAGO;AACL,eAAO,KAAK,iCAAL,CACH,WADG,EACU,WAAW,CAAC,cAAZ,CAA2B,gBADrC,CAAP;AAED;AACF,KARO;;AASV,WAAA,qBAAA;AAAC,GAn8DD,CAA2C,YAAA,CAAA,wBAA3C,CAAA;;AAAa,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA,C,CAq8Db;;AAEA;;;;;;;;;;;AAWG;;AACH,WAAS,qBAAT,CAA+B,IAA/B,EAAsD;AACpD,QAAI,IAAI,CAAC,SAAL,CAAe,MAAf,KAA0B,CAA9B,EAAiC,OAAO,KAAP;AAEjC,QAAM,GAAG,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAZ;;AACA,QAAI,CAAC,EAAE,CAAC,kBAAH,CAAsB,GAAtB,CAAD,IAA+B,GAAG,CAAC,aAAJ,CAAkB,IAAlB,KAA2B,EAAE,CAAC,UAAH,CAAc,WAAxE,IACA,CAAC,EAAE,CAAC,yBAAH,CAA6B,GAAG,CAAC,KAAjC,CADL,EAC8C;AAC5C,aAAO,KAAP;AACD;;AAED,QAAM,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,UAAxB;;AACA,QAAI,CAAC,EAAE,CAAC,kBAAH,CAAsB,KAAtB,CAAD,IAAiC,KAAK,CAAC,aAAN,CAAoB,IAApB,KAA6B,EAAE,CAAC,UAAH,CAAc,WAAhF,EAA6F;AAC3F,aAAO,KAAP;AACD;;AAED,QAAI,CAAC,EAAE,CAAC,yBAAH,CAA6B,KAAK,CAAC,KAAnC,CAAD,IAA8C,KAAK,CAAC,KAAN,CAAY,UAAZ,CAAuB,MAAvB,KAAkC,CAApF,EAAuF;AACrF,aAAO,KAAP;AACD;;AAED,WAAO,IAAP;AACD;AAOD;;;;;;;;;;AAUG;;;AACH,WAAS,gBAAT,CACI,QADJ,EAC6B,UAD7B,EACsD;AACpD,QAAI,CAAC,EAAE,CAAC,kBAAH,CAAsB,UAAtB,CAAD,IACA,UAAU,CAAC,aAAX,CAAyB,IAAzB,KAAkC,EAAE,CAAC,UAAH,CAAc,WADhD,IAEA,CAAC,EAAE,CAAC,yBAAH,CAA6B,UAAU,CAAC,IAAxC,CAFL,EAEoD;AAClD,aAAO,KAAP;AACD,KALmD,CAOpD;;;AACA,QAAM,cAAc,GAAG,UAAU,CAAC,IAAX,CAAgB,UAAvC;AACA,WAAO,EAAE,CAAC,YAAH,CAAgB,cAAhB,KAAmC,cAAc,CAAC,IAAf,KAAwB,QAAQ,CAAC,IAA3E;AACD;AAED;;;;;;AAMG;;;AACH,WAAS,qBAAT,CAA+B,UAA/B,EAA+D;AAC7D,QAAM,UAAU,GAAG,UAAU,CAAC,IAAX,CAAgB,kBAAnC;AACA,QAAI,CAAC,EAAE,CAAC,cAAH,CAAkB,UAAlB,CAAL,EAAoC,OAAO,IAAP;AAEpC,WAAO;AAAC,MAAA,IAAI,EAAE,UAAP;AAAmB,MAAA,WAAW,EAAE,UAAU,CAAC;AAA3C,KAAP;AACD;AA+ED;;;AAGG;;;AACH,WAAgB,qBAAhB,CAAsC,SAAtC,EAA6D;AAC3D,WAAO,EAAE,CAAC,qBAAH,CAAyB,SAAzB,KAAuC,YAAY,CAAC,SAAS,CAAC,UAAX,CAAnD,IACH,EAAE,CAAC,YAAH,CAAgB,SAAS,CAAC,UAAV,CAAqB,IAArC,CADJ;AAED;;AAHD,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAKA;;;;;;;;;;;;AAYG;;AACH,WAAgB,WAAhB,CAA4B,UAA5B,EAAqD;AACnD,QAAM,IAAI,GAAG,OAAA,CAAA,gBAAA,CAAiB,UAAjB,CAAb;;AACA,QAAI,CAAC,EAAE,CAAC,gBAAH,CAAoB,IAApB,CAAL,EAAgC;AAC9B,aAAO,SAAP;AACD;;AAED,QAAM,EAAE,GAAG,OAAA,CAAA,gBAAA,CAAiB,IAAI,CAAC,UAAtB,CAAX;;AACA,QAAI,CAAC,EAAE,CAAC,oBAAH,CAAwB,EAAxB,CAAD,IAAgC,CAAC,EAAE,CAAC,eAAH,CAAmB,EAAnB,CAArC,EAA6D;AAC3D,aAAO,SAAP;AACD;;AAED,WAAO,EAAE,CAAC,IAAV;AACD;;AAZD,EAAA,OAAA,CAAA,WAAA,GAAA,WAAA;AAcA;;;;AAIG;;AACH,WAAgB,YAAhB,CAA6B,IAA7B,EAA0C;AACxC,WAAO,EAAE,CAAC,kBAAH,CAAsB,IAAtB,KAA+B,IAAI,CAAC,aAAL,CAAmB,IAAnB,KAA4B,EAAE,CAAC,UAAH,CAAc,WAAhF;AACD;;AAFD,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA;AAIA;;;;;;;;;;AAUG;;AACH,WAAgB,mBAAhB,CACI,IADJ,EAC6B,OAD7B,EAC4E;AAE1E,QAAM,UAAU,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAnB;;AACA,QAAI,UAAU,KAAK,SAAf,IAA4B,CAAC,EAAE,CAAC,wBAAH,CAA4B,UAA5B,CAAjC,EAA0E;AACxE,aAAO,KAAP;AACD;;AAED,QAAM,MAAM,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAf;AACA,WAAO,MAAM,KAAK,SAAX,IAAwB,EAAE,CAAC,YAAH,CAAgB,MAAhB,CAAxB,IAAmD,OAAO,CAAC,MAAD,CAAjE;AACD;;AAVD,EAAA,OAAA,CAAA,mBAAA,GAAA,mBAAA;AAYA;;;;;;;;;;AAUG;;AACH,WAAgB,oBAAhB,CACI,IADJ,EAC6B,OAD7B,EAC4E;AAG1E,QAAM,UAAU,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAnB;;AACA,QAAI,UAAU,KAAK,SAAf,IAA4B,CAAC,EAAE,CAAC,wBAAH,CAA4B,UAA5B,CAAjC,EAA0E;AACxE,aAAO,KAAP;AACD;;AAED,QAAM,MAAM,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAf;;AACA,QAAI,MAAM,KAAK,SAAX,IAAwB,CAAC,EAAE,CAAC,0BAAH,CAA8B,MAA9B,CAAzB,IACA,CAAC,EAAE,CAAC,YAAH,CAAgB,MAAM,CAAC,UAAvB,CADD,IACuC,CAAC,OAAO,CAAC,MAAM,CAAC,UAAR,CAD/C,IAEA,MAAM,CAAC,IAAP,CAAY,IAAZ,KAAqB,WAFzB,EAEsC;AACpC,aAAO,KAAP;AACD;;AAED,QAAM,UAAU,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAnB;AACA,WAAO,UAAU,KAAK,SAAf,IAA4B,EAAE,CAAC,eAAH,CAAmB,UAAnB,CAAnC;AACD;;AAlBD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA;AAoBA;;;AAGG;;AACH,WAAgB,0BAAhB,CAA2C,UAA3C,EAAgE;AAC9D,QAAM,cAAc,GAAG,UAAU,CAAC,gBAAlC;AACA,QAAM,MAAM,GAAG,cAAc,IAAI,cAAc,CAAC,MAAhD;AACA,WAAO,MAAM,IAAI,EAAE,CAAC,kBAAH,CAAsB,MAAtB,CAAV,GAA0C,MAAM,CAAC,KAAjD,GAAyD,SAAhE;AACD;;AAJD,EAAA,OAAA,CAAA,0BAAA,GAAA,0BAAA;AAMA;;AAEG;;AACH,WAAS,aAAT,CAAuB,IAAvB,EAA8C;AAC5C,QAAI,EAAE,CAAC,YAAH,CAAgB,IAAI,CAAC,UAArB,CAAJ,EAAsC;AACpC,aAAO,OAAA,CAAA,iBAAA,CAAkB,IAAI,CAAC,UAAL,CAAgB,IAAlC,CAAP;AACD;;AACD,QAAI,EAAE,CAAC,0BAAH,CAA8B,IAAI,CAAC,UAAnC,CAAJ,EAAoD;AAClD,aAAO,OAAA,CAAA,iBAAA,CAAkB,IAAI,CAAC,UAAL,CAAgB,IAAhB,CAAqB,IAAvC,CAAP;AACD;;AACD,WAAO,IAAP;AACD;;AAOD,WAAS,qCAAT,CAA+C,IAA/C,EAA4D;AAE1D,WAAO,YAAA,CAAA,0BAAA,CAA2B,IAA3B,KAAoC,IAAI,CAAC,WAAL,KAAqB,SAAhE;AACD;AAED;;;;;;;;;;AAUG;;;AACH,WAAgB,gBAAhB,CAAiC,IAAjC,EAA0E;AACxE,QAAI,UAAU,GAAG,IAAI,CAAC,WAAtB;;AACA,WAAO,YAAY,CAAC,UAAD,CAAnB,EAAiC;AAC/B,MAAA,UAAU,GAAG,UAAU,CAAC,KAAxB;AACD;;AACD,WAAO,UAAP;AACD;;AAND,EAAA,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCG;;AACH,WAAgB,wBAAhB,CAAyC,UAAzC,EAAkE;;;AAEhE,QAAI,EAAE,CAAC,iBAAH,CAAqB,UAArB,KAAoC,OAAA,CAAA,iBAAA,CAAkB,UAAlB,CAAxC,EAAuE;AACrE,aAAO,UAAP;AACD;;AAED,QAAM,QAAQ,GAAG,WAAW,CAAC,UAAD,CAA5B;;AACA,QAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,aAAO,IAAP;AACD;;AAED,QAAI,CAAC,EAAE,CAAC,OAAH,CAAW,QAAX,CAAL,EAA2B;AACzB;AACA,aAAO,EAAE,CAAC,iBAAH,CAAqB,QAArB,KAAkC,kBAAkB,CAAC,QAAD,CAApD,GAAiE,QAAjE,GAA4E,IAAnF;AACD,KAHD,MAGO;;AACL;AACA;AACA,aAAwB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,QAAQ,CAAC,UAAT,CAAA,EAAmB,EAAA,GAAA,EAAA,CAAA,IAAA,EAA3C,EAA2C,CAAA,EAAA,CAAA,IAA3C,EAA2C,EAAA,GAAA,EAAA,CAAA,IAAA,EAA3C,EAA6C;AAAxC,cAAM,SAAS,GAAA,EAAA,CAAA,KAAf;;AACH,cAAI,YAAA,CAAA,uBAAA,CAAwB,SAAxB,KAAsC,YAAA,CAAA,0BAAA,CAA2B,SAA3B,CAA1C,EAAiF;AAC/E,mBAAO,SAAP;AACD;;AACD,cAAI,EAAE,CAAC,mBAAH,CAAuB,SAAvB,CAAJ,EAAuC;;AACrC,mBAA0B,IAAA,EAAA,IAAA,IAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,SAAS,CAAC,eAAV,CAA0B,YAA1B,CAAA,CAAA,EAAsC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhE,EAAgE,CAAA,EAAA,CAAA,IAAhE,EAAgE,EAAA,GAAA,EAAA,CAAA,IAAA,EAAhE,EAAkE;AAA7D,oBAAM,WAAW,GAAA,EAAA,CAAA,KAAjB;;AACH,oBAAI,qCAAqC,CAAC,WAAD,CAAzC,EAAwD;AACtD,sBAAM,YAAU,GAAG,gBAAgB,CAAC,WAAD,CAAnC;;AACA,sBAAI,EAAE,CAAC,iBAAH,CAAqB,YAArB,KAAoC,OAAA,CAAA,iBAAA,CAAkB,YAAlB,CAAxC,EAAuE;AACrE,2BAAO,YAAP;AACD;AACF;AACF;;;;;;;;;;;;AACF;AACF;;;;;;;;;;;;AACF;;AAED,WAAO,IAAP;AACD;;AAnCD,EAAA,OAAA,CAAA,wBAAA,GAAA,wBAAA;;AAqCA,WAAS,gBAAT,CAA0B,IAA1B,EAA0D;AACxD;AACA,QAAM,YAAY,GAAG,IAAI,CAAC,UAAL,CAAgB,MAAhB,CAAuB,EAAE,CAAC,oBAA1B,EACK,IADL,CACU,UAAA,QAAA,EAAQ;AAAI,aAAA,OAAA,CAAA,WAAA,CAAY,QAAQ,CAAC,IAArB,MAAA,MAAA;AAAqC,KAD3D,CAArB;AAEA,QAAM,cAAc,GAAG,YAAY,IAAI,YAAY,CAAC,WAApD;AACA,WAAO,cAAc,IAAI,EAAE,CAAC,wBAAH,CAA4B,cAA5B,CAAlB,GACH,KAAK,CAAC,IAAN,CAAW,cAAc,CAAC,QAA1B,CADG,GAEH,EAFJ;AAGD;;AAED,WAAS,gBAAT,CAA0B,IAA1B,EAAuC;AAErC,WAAO,CAAC,CAAC,IAAI,CAAC,MAAP,IAAiB,EAAE,CAAC,kBAAH,CAAsB,IAAI,CAAC,MAA3B,CAAjB,IAAuD,EAAE,CAAC,0BAAH,CAA8B,IAA9B,CAA9D;AACD;;AAED,WAAS,gBAAT,CAA0B,IAA1B,EAA8C;AAE5C,WAAO,EAAE,CAAC,kBAAH,CAAsB,IAAtB,KAA+B,EAAE,CAAC,0BAAH,CAA8B,IAAI,CAAC,IAAnC,CAA/B,IACH,IAAI,CAAC,IAAL,CAAU,UAAV,CAAqB,IAArB,KAA8B,EAAE,CAAC,UAAH,CAAc,WADhD;AAED;;AAED,WAAS,kBAAT,CAA4B,IAA5B,EAAyC;AACvC,QAAM,OAAO,GAAQ,IAArB;AACA,WAAO,CAAC,CAAC,OAAO,CAAC,IAAV,IAAkB,EAAE,CAAC,YAAH,CAAgB,OAAO,CAAC,IAAxB,CAAzB;AACD;;AAGD,WAAS,iBAAT,CAA2B,IAA3B,EAA+C;AAE7C,WAAO,CAAC,EAAE,CAAC,cAAH,CAAkB,IAAlB,KAA2B,gBAAgB,CAAC,IAAD,CAA3C,IAAqD,EAAE,CAAC,kBAAH,CAAsB,IAAtB,CAAtD,KACH;AACA;AACA,KAAC,EAAE,CAAC,2BAAH,CAA+B,IAA/B,CAHL;AAID;AAED;;;;;;;;;;;;;;;;;;;;;;;AAuBG;;;AACH,WAAS,8BAAT,CAAwC,WAAxC,EAAmE;AAEjE,QAAI,IAAI,GAAG,WAAW,CAAC,MAAvB,CAFiE,CAIjE;;AACA,QAAI,YAAY,CAAC,IAAD,CAAZ,IAAsB,EAAE,CAAC,YAAH,CAAgB,IAAI,CAAC,IAArB,CAA1B,EAAsD;AACpD,MAAA,IAAI,GAAG,IAAI,CAAC,MAAZ;AACD;;AAED,WAAO,EAAE,CAAC,qBAAH,CAAyB,IAAzB,IAAiC,IAAjC,GAAwC,SAA/C;AACD;;AAED,WAAS,gCAAT,CAA0C,IAA1C,EAAuD;AAErD,IAAA,IAAI,GAAG,IAAI,CAAC,MAAZ;;AACA,WAAO,IAAI,KAAK,SAAhB,EAA2B;AACzB,UAAI,YAAA,CAAA,0BAAA,CAA2B,IAA3B,CAAJ,EAAsC;AACpC,eAAO,IAAP;AACD;;AACD,MAAA,IAAI,GAAG,IAAI,CAAC,MAAZ;AACD;;AACD,WAAO,SAAP;AACD;AAED;;;;;;;;;;;;;;;;;AAiBG;;;AACH,WAAS,wBAAT,CAAkC,WAAlC,EAAwE;AACtE,QAAI,CAAC,WAAW,CAAC,IAAjB,EAAuB,OAAO,KAAP;AAEvB,QAAM,cAAc,GAAG,WAAW,CAAC,IAAZ,CAAiB,UAAjB,CAA4B,CAA5B,CAAvB;AACA,QAAI,CAAC,cAAD,IAAmB,CAAC,EAAE,CAAC,qBAAH,CAAyB,cAAzB,CAAxB,EAAkE,OAAO,KAAP;AAElE,WAAO,sBAAsB,CAAC,cAAc,CAAC,UAAhB,CAA7B;AACD;AAED;;;;;;;;;;AAUG;;;AACH,WAAS,sBAAT,CAAgC,UAAhC,EAAyD;AACvD,QAAI,CAAC,EAAE,CAAC,gBAAH,CAAoB,UAApB,CAAL,EAAsC,OAAO,KAAP;AACtC,QAAI,UAAU,CAAC,UAAX,CAAsB,IAAtB,KAA+B,EAAE,CAAC,UAAH,CAAc,YAAjD,EAA+D,OAAO,KAAP;AAC/D,QAAI,UAAU,CAAC,SAAX,CAAqB,MAArB,KAAgC,CAApC,EAAuC,OAAO,KAAP;AAEvC,QAAM,QAAQ,GAAG,UAAU,CAAC,SAAX,CAAqB,CAArB,CAAjB;AACA,WAAO,EAAE,CAAC,eAAH,CAAmB,QAAnB,KAAgC,EAAE,CAAC,YAAH,CAAgB,QAAQ,CAAC,UAAzB,CAAhC,IACH,QAAQ,CAAC,UAAT,CAAoB,IAApB,KAA6B,WADjC;AAED;AAED;;;AAGG;;;AACH,WAAgB,sBAAhB,CAAuC,IAAvC,EAAoD;AAClD,WAAO,IAAI,CAAC,MAAZ,EAAoB;AAClB,UAAI,EAAE,CAAC,OAAH,CAAW,IAAI,CAAC,MAAhB,KAA2B,EAAE,CAAC,YAAH,CAAgB,IAAI,CAAC,MAArB,CAA/B,EAA6D;AAC3D;AACD;;AACD,MAAA,IAAI,GAAG,IAAI,CAAC,MAAZ;AACD;;AACD,WAAO,IAAP;AACD;;AARD,EAAA,OAAA,CAAA,sBAAA,GAAA,sBAAA;;AAUA,WAAS,iBAAT,CAA2B,MAA3B,EAAgD;AAC9C,QAAM,QAAQ,GAAG,MAAM,CAAC,OAAP,CAAe,aAAf,CAA6B,MAAM,CAAC,IAApC,CAAjB;;AACA,QAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,YAAM,IAAI,KAAJ,CAAU,wBAAsB,QAAtB,GAA8B,gCAAxC,CAAN;AACD;;AACD,WAAO,QAAP;AACD;;AAED,WAAS,sBAAT,CAAgC,MAAhC,EAAqD;AACnD,QAAM,QAAQ,GAAG,MAAM,CAAC,OAAP,CAAe,aAAf,CAA6B,MAAM,CAAC,IAApC,CAAjB;AACA,WAAO,MAAM,CAAC,OAAP,CAAe,cAAf,GAAgC,MAAhC,CACH,UAAA,CAAA,EAAC;AAAI,aAAC,CAAC,KAAK,QAAP,IAAoB,MAAA,CAAA,eAAA,CAAgB,MAAM,CAAC,OAAvB,EAAgC,aAAA,CAAA,sBAAA,CAApD,CAAoD,CAAhC,CAApB;AAA8E,KADhF,CAAP;AAED;;AAED,WAAS,UAAT,CAAoB,IAApB,EAAiC;AAC/B,WAAO,IAAI,GAAG,IAAI,CAAC,MAAnB,EAA2B;AACzB,UAAI,EAAE,CAAC,OAAH,CAAW,IAAX,CAAJ,EAAsB;AACpB,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD;AAED;;;;;;;;;;;;;;AAcG;;;AACH,WAAgB,gCAAhB,CAAiD,IAAjD,EAA8D;AAC5D,QAAI,CAAC,EAAE,CAAC,qBAAH,CAAyB,IAAzB,CAAD,IAAmC,CAAC,EAAE,CAAC,kBAAH,CAAsB,IAAtB,CAApC,IACA,CAAC,EAAE,CAAC,mBAAH,CAAuB,IAAvB,CADL,EACmC;AACjC,aAAO,IAAP;AACD,KAJ2D,CAM5D;AAEA;;;AACA,QAAI,SAAS,GAAG,IAAI,CAAC,MAArB;AACA,QAAI,CAAC,SAAD,IAAc,CAAC,EAAE,CAAC,OAAH,CAAW,SAAX,CAAnB,EAA0C,OAAO,IAAP,CAVkB,CAY5D;;AACA,IAAA,SAAS,GAAG,SAAS,CAAC,MAAtB;;AACA,QAAI,CAAC,SAAD,IAAe,CAAC,EAAE,CAAC,oBAAH,CAAwB,SAAxB,CAAD,IAAuC,CAAC,EAAE,CAAC,eAAH,CAAmB,SAAnB,CAA3D,EAA2F;AACzF,aAAO,IAAP;AACD;;AACD,IAAA,SAAS,GAAG,SAAS,CAAC,MAAtB,CAjB4D,CAmB5D;;AACA,QAAI,SAAS,IAAI,EAAE,CAAC,yBAAH,CAA6B,SAA7B,CAAjB,EAA0D,SAAS,GAAG,SAAS,CAAC,MAAtB,CApBE,CAsB5D;;AACA,QAAI,CAAC,SAAD,IAAc,CAAC,EAAE,CAAC,gBAAH,CAAoB,SAApB,CAAnB,EAAmD,OAAO,IAAP;AACnD,IAAA,SAAS,GAAG,SAAS,CAAC,MAAtB,CAxB4D,CA0B5D;;AACA,QAAI,SAAS,IAAI,EAAE,CAAC,yBAAH,CAA6B,SAA7B,CAAjB,EAA0D,SAAS,GAAG,SAAS,CAAC,MAAtB,CA3BE,CA6B5D;;AACA,WAAO,YAAY,CAAC,SAAS,CAAC,MAAX,CAAnB,EAAuC;AACrC,MAAA,SAAS,GAAG,SAAS,CAAC,MAAtB;AACD;;AAED,WAAO,SAAP;AACD;;AAnCD,EAAA,OAAA,CAAA,gCAAA,GAAA,gCAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {absoluteFromSourceFile} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {ClassDeclaration, ClassMember, ClassMemberKind, CtorParameter, Declaration, DeclarationNode, Decorator, EnumMember, Import, isConcreteDeclaration, isDecoratorIdentifier, isNamedClassDeclaration, isNamedFunctionDeclaration, isNamedVariableDeclaration, KnownDeclaration, reflectObjectLiteral, SpecialDeclarationKind, TypeScriptReflectionHost, TypeValueReference, TypeValueReferenceKind, ValueUnavailableKind} from '../../../src/ngtsc/reflection';\nimport {isWithinPackage} from '../analysis/util';\nimport {BundleProgram} from '../packages/bundle_program';\nimport {findAll, getNameText, hasNameIdentifier, isDefined, stripDollarSuffix} from '../utils';\n\nimport {ClassSymbol, isSwitchableVariableDeclaration, NgccClassSymbol, NgccReflectionHost, PRE_R3_MARKER, SwitchableVariableDeclaration} from './ngcc_host';\nimport {stripParentheses} from './utils';\n\nexport const DECORATORS = 'decorators' as ts.__String;\nexport const PROP_DECORATORS = 'propDecorators' as ts.__String;\nexport const CONSTRUCTOR = '__constructor' as ts.__String;\nexport const CONSTRUCTOR_PARAMS = 'ctorParameters' as ts.__String;\n\n/**\n * Esm2015 packages contain ECMAScript 2015 classes, etc.\n * Decorators are defined via static properties on the class. For example:\n *\n * ```\n * class SomeDirective {\n * }\n * SomeDirective.decorators = [\n *   { type: Directive, args: [{ selector: '[someDirective]' },] }\n * ];\n * SomeDirective.ctorParameters = () => [\n *   { type: ViewContainerRef, },\n *   { type: TemplateRef, },\n *   { type: undefined, decorators: [{ type: Inject, args: [INJECTED_TOKEN,] },] },\n * ];\n * SomeDirective.propDecorators = {\n *   \"input1\": [{ type: Input },],\n *   \"input2\": [{ type: Input },],\n * };\n * ```\n *\n * * Classes are decorated if they have a static property called `decorators`.\n * * Members are decorated if there is a matching key on a static property\n *   called `propDecorators`.\n * * Constructor parameters decorators are found on an object returned from\n *   a static method called `ctorParameters`.\n */\nexport class Esm2015ReflectionHost extends TypeScriptReflectionHost implements NgccReflectionHost {\n  /**\n   * A mapping from source declarations to typings declarations, which are both publicly exported.\n   *\n   * There should be one entry for every public export visible from the root file of the source\n   * tree. Note that by definition the key and value declarations will not be in the same TS\n   * program.\n   */\n  protected publicDtsDeclarationMap: Map<DeclarationNode, ts.Declaration>|null = null;\n  /**\n   * A mapping from source declarations to typings declarations, which are not publicly exported.\n   *\n   * This mapping is a best guess between declarations that happen to be exported from their file by\n   * the same name in both the source and the dts file. Note that by definition the key and value\n   * declarations will not be in the same TS program.\n   */\n  protected privateDtsDeclarationMap: Map<DeclarationNode, ts.Declaration>|null = null;\n\n  /**\n   * The set of source files that have already been preprocessed.\n   */\n  protected preprocessedSourceFiles = new Set<ts.SourceFile>();\n\n  /**\n   * In ES2015, class declarations may have been down-leveled into variable declarations,\n   * initialized using a class expression. In certain scenarios, an additional variable\n   * is introduced that represents the class so that results in code such as:\n   *\n   * ```\n   * let MyClass_1; let MyClass = MyClass_1 = class MyClass {};\n   * ```\n   *\n   * This map tracks those aliased variables to their original identifier, i.e. the key\n   * corresponds with the declaration of `MyClass_1` and its value becomes the `MyClass` identifier\n   * of the variable declaration.\n   *\n   * This map is populated during the preprocessing of each source file.\n   */\n  protected aliasedClassDeclarations = new Map<DeclarationNode, ts.Identifier>();\n\n  /**\n   * Caches the information of the decorators on a class, as the work involved with extracting\n   * decorators is complex and frequently used.\n   *\n   * This map is lazily populated during the first call to `acquireDecoratorInfo` for a given class.\n   */\n  protected decoratorCache = new Map<ClassDeclaration, DecoratorInfo>();\n\n  constructor(\n      protected logger: Logger, protected isCore: boolean, protected src: BundleProgram,\n      protected dts: BundleProgram|null = null) {\n    super(src.program.getTypeChecker());\n  }\n\n  /**\n   * Find a symbol for a node that we think is a class.\n   * Classes should have a `name` identifier, because they may need to be referenced in other parts\n   * of the program.\n   *\n   * In ES2015, a class may be declared using a variable declaration of the following structures:\n   *\n   * ```\n   * var MyClass = MyClass_1 = class MyClass {};\n   * ```\n   *\n   * or\n   *\n   * ```\n   * var MyClass = MyClass_1 = (() => { class MyClass {} ... return MyClass; })()\n   * ```\n   *\n   * Here, the intermediate `MyClass_1` assignment is optional. In the above example, the\n   * `class MyClass {}` node is returned as declaration of `MyClass`.\n   *\n   * @param declaration the declaration node whose symbol we are finding.\n   * @returns the symbol for the node or `undefined` if it is not a \"class\" or has no symbol.\n   */\n  getClassSymbol(declaration: ts.Node): NgccClassSymbol|undefined {\n    const symbol = this.getClassSymbolFromOuterDeclaration(declaration);\n    if (symbol !== undefined) {\n      return symbol;\n    }\n    const innerDeclaration = this.getInnerDeclarationFromAliasOrInner(declaration);\n    return this.getClassSymbolFromInnerDeclaration(innerDeclaration);\n  }\n\n  /**\n   * Examine a declaration (for example, of a class or function) and return metadata about any\n   * decorators present on the declaration.\n   *\n   * @param declaration a TypeScript node representing the class or function over which to reflect.\n   *     For example, if the intent is to reflect the decorators of a class and the source is in ES6\n   *     format, this will be a `ts.ClassDeclaration` node. If the source is in ES5 format, this\n   *     might be a `ts.VariableDeclaration` as classes in ES5 are represented as the result of an\n   *     IIFE execution.\n   *\n   * @returns an array of `Decorator` metadata if decorators are present on the declaration, or\n   *     `null` if either no decorators were present or if the declaration is not of a decoratable\n   *     type.\n   */\n  getDecoratorsOfDeclaration(declaration: DeclarationNode): Decorator[]|null {\n    const symbol = this.getClassSymbol(declaration);\n    if (!symbol) {\n      return null;\n    }\n    return this.getDecoratorsOfSymbol(symbol);\n  }\n\n  /**\n   * Examine a declaration which should be of a class, and return metadata about the members of the\n   * class.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns an array of `ClassMember` metadata representing the members of the class.\n   *\n   * @throws if `declaration` does not resolve to a class declaration.\n   */\n  getMembersOfClass(clazz: ClassDeclaration): ClassMember[] {\n    const classSymbol = this.getClassSymbol(clazz);\n    if (!classSymbol) {\n      throw new Error(`Attempted to get members of a non-class: \"${clazz.getText()}\"`);\n    }\n\n    return this.getMembersOfSymbol(classSymbol);\n  }\n\n  /**\n   * Reflect over the constructor of a class and return metadata about its parameters.\n   *\n   * This method only looks at the constructor of a class directly and not at any inherited\n   * constructors.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns an array of `Parameter` metadata representing the parameters of the constructor, if\n   * a constructor exists. If the constructor exists and has 0 parameters, this array will be empty.\n   * If the class has no constructor, this method returns `null`.\n   *\n   * @throws if `declaration` does not resolve to a class declaration.\n   */\n  getConstructorParameters(clazz: ClassDeclaration): CtorParameter[]|null {\n    const classSymbol = this.getClassSymbol(clazz);\n    if (!classSymbol) {\n      throw new Error(\n          `Attempted to get constructor parameters of a non-class: \"${clazz.getText()}\"`);\n    }\n    const parameterNodes = this.getConstructorParameterDeclarations(classSymbol);\n    if (parameterNodes) {\n      return this.getConstructorParamInfo(classSymbol, parameterNodes);\n    }\n    return null;\n  }\n\n  getBaseClassExpression(clazz: ClassDeclaration): ts.Expression|null {\n    // First try getting the base class from an ES2015 class declaration\n    const superBaseClassIdentifier = super.getBaseClassExpression(clazz);\n    if (superBaseClassIdentifier) {\n      return superBaseClassIdentifier;\n    }\n\n    // That didn't work so now try getting it from the \"inner\" declaration.\n    const classSymbol = this.getClassSymbol(clazz);\n    if (classSymbol === undefined ||\n        !isNamedDeclaration(classSymbol.implementation.valueDeclaration)) {\n      return null;\n    }\n    return super.getBaseClassExpression(classSymbol.implementation.valueDeclaration);\n  }\n\n  getInternalNameOfClass(clazz: ClassDeclaration): ts.Identifier {\n    const classSymbol = this.getClassSymbol(clazz);\n    if (classSymbol === undefined) {\n      throw new Error(`getInternalNameOfClass() called on a non-class: expected ${\n          clazz.name.text} to be a class declaration.`);\n    }\n    return this.getNameFromClassSymbolDeclaration(\n        classSymbol, classSymbol.implementation.valueDeclaration);\n  }\n\n  getAdjacentNameOfClass(clazz: ClassDeclaration): ts.Identifier {\n    const classSymbol = this.getClassSymbol(clazz);\n    if (classSymbol === undefined) {\n      throw new Error(`getAdjacentNameOfClass() called on a non-class: expected ${\n          clazz.name.text} to be a class declaration.`);\n    }\n\n    return this.getAdjacentNameOfClassSymbol(classSymbol);\n  }\n\n  private getNameFromClassSymbolDeclaration(\n      classSymbol: NgccClassSymbol, declaration: ts.Declaration): ts.Identifier {\n    if (declaration === undefined) {\n      throw new Error(\n          `getInternalNameOfClass() called on a class with an undefined internal declaration. External class name: ${\n              classSymbol.name}; internal class name: ${classSymbol.implementation.name}.`);\n    }\n    if (!isNamedDeclaration(declaration)) {\n      throw new Error(\n          `getInternalNameOfClass() called on a class with an anonymous inner declaration: expected a name on:\\n${\n              declaration.getText()}`);\n    }\n    return declaration.name;\n  }\n\n  /**\n   * Check whether the given node actually represents a class.\n   */\n  isClass(node: ts.Node): node is ClassDeclaration {\n    return super.isClass(node) || this.getClassSymbol(node) !== undefined;\n  }\n\n  /**\n   * Trace an identifier to its declaration, if possible.\n   *\n   * This method attempts to resolve the declaration of the given identifier, tracing back through\n   * imports and re-exports until the original declaration statement is found. A `Declaration`\n   * object is returned if the original declaration is found, or `null` is returned otherwise.\n   *\n   * In ES2015, we need to account for identifiers that refer to aliased class declarations such as\n   * `MyClass_1`. Since such declarations are only available within the module itself, we need to\n   * find the original class declaration, e.g. `MyClass`, that is associated with the aliased one.\n   *\n   * @param id a TypeScript `ts.Identifier` to trace back to a declaration.\n   *\n   * @returns metadata about the `Declaration` if the original declaration is found, or `null`\n   * otherwise.\n   */\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null {\n    const superDeclaration = super.getDeclarationOfIdentifier(id);\n\n    // If no declaration was found, return.\n    if (superDeclaration === null) {\n      return superDeclaration;\n    }\n\n    // If the declaration already has traits assigned to it, return as is.\n    if (superDeclaration.known !== null ||\n        isConcreteDeclaration(superDeclaration) && superDeclaration.identity !== null) {\n      return superDeclaration;\n    }\n\n    let declarationNode: ts.Node = superDeclaration.node;\n    if (isNamedVariableDeclaration(superDeclaration.node) && !isTopLevel(superDeclaration.node)) {\n      const variableValue = this.getVariableValue(superDeclaration.node);\n      if (variableValue !== null && ts.isClassExpression(variableValue)) {\n        declarationNode = getContainingStatement(variableValue);\n      }\n    }\n\n    const outerNode = getOuterNodeFromInnerDeclaration(declarationNode);\n    const declaration = outerNode !== null && isNamedVariableDeclaration(outerNode) ?\n        this.getDeclarationOfIdentifier(outerNode.name) :\n        superDeclaration;\n    if (declaration === null || declaration.known !== null ||\n        isConcreteDeclaration(declaration) && declaration.identity !== null) {\n      return declaration;\n    }\n\n    // The identifier may have been of an additional class assignment such as `MyClass_1` that was\n    // present as alias for `MyClass`. If so, resolve such aliases to their original declaration.\n    const aliasedIdentifier = this.resolveAliasedClassIdentifier(declaration.node);\n    if (aliasedIdentifier !== null) {\n      return this.getDeclarationOfIdentifier(aliasedIdentifier);\n    }\n\n    // Variable declarations may represent an enum declaration, so attempt to resolve its members.\n    if (isConcreteDeclaration(declaration) && ts.isVariableDeclaration(declaration.node)) {\n      const enumMembers = this.resolveEnumMembers(declaration.node);\n      if (enumMembers !== null) {\n        declaration.identity = {kind: SpecialDeclarationKind.DownleveledEnum, enumMembers};\n      }\n    }\n\n    return declaration;\n  }\n\n  /**\n   * Gets all decorators of the given class symbol. Any decorator that have been synthetically\n   * injected by a migration will not be present in the returned collection.\n   */\n  getDecoratorsOfSymbol(symbol: NgccClassSymbol): Decorator[]|null {\n    const {classDecorators} = this.acquireDecoratorInfo(symbol);\n    if (classDecorators === null) {\n      return null;\n    }\n\n    // Return a clone of the array to prevent consumers from mutating the cache.\n    return Array.from(classDecorators);\n  }\n\n  /**\n   * Search the given module for variable declarations in which the initializer\n   * is an identifier marked with the `PRE_R3_MARKER`.\n   * @param module the module in which to search for switchable declarations.\n   * @returns an array of variable declarations that match.\n   */\n  getSwitchableDeclarations(module: ts.Node): SwitchableVariableDeclaration[] {\n    // Don't bother to walk the AST if the marker is not found in the text\n    return module.getText().indexOf(PRE_R3_MARKER) >= 0 ?\n        findAll(module, isSwitchableVariableDeclaration) :\n        [];\n  }\n\n  getVariableValue(declaration: ts.VariableDeclaration): ts.Expression|null {\n    const value = super.getVariableValue(declaration);\n    if (value) {\n      return value;\n    }\n\n    // We have a variable declaration that has no initializer. For example:\n    //\n    // ```\n    // var HttpClientXsrfModule_1;\n    // ```\n    //\n    // So look for the special scenario where the variable is being assigned in\n    // a nearby statement to the return value of a call to `__decorate`.\n    // Then find the 2nd argument of that call, the \"target\", which will be the\n    // actual class identifier. For example:\n    //\n    // ```\n    // HttpClientXsrfModule = HttpClientXsrfModule_1 = tslib_1.__decorate([\n    //   NgModule({\n    //     providers: [],\n    //   })\n    // ], HttpClientXsrfModule);\n    // ```\n    //\n    // And finally, find the declaration of the identifier in that argument.\n    // Note also that the assignment can occur within another assignment.\n    //\n    const block = declaration.parent.parent.parent;\n    const symbol = this.checker.getSymbolAtLocation(declaration.name);\n    if (symbol && (ts.isBlock(block) || ts.isSourceFile(block))) {\n      const decorateCall = this.findDecoratedVariableValue(block, symbol);\n      const target = decorateCall && decorateCall.arguments[1];\n      if (target && ts.isIdentifier(target)) {\n        const targetSymbol = this.checker.getSymbolAtLocation(target);\n        const targetDeclaration = targetSymbol && targetSymbol.valueDeclaration;\n        if (targetDeclaration) {\n          if (ts.isClassDeclaration(targetDeclaration) ||\n              ts.isFunctionDeclaration(targetDeclaration)) {\n            // The target is just a function or class declaration\n            // so return its identifier as the variable value.\n            return targetDeclaration.name || null;\n          } else if (ts.isVariableDeclaration(targetDeclaration)) {\n            // The target is a variable declaration, so find the far right expression,\n            // in the case of multiple assignments (e.g. `var1 = var2 = value`).\n            let targetValue = targetDeclaration.initializer;\n            while (targetValue && isAssignment(targetValue)) {\n              targetValue = targetValue.right;\n            }\n            if (targetValue) {\n              return targetValue;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Find all top-level class symbols in the given file.\n   * @param sourceFile The source file to search for classes.\n   * @returns An array of class symbols.\n   */\n  findClassSymbols(sourceFile: ts.SourceFile): NgccClassSymbol[] {\n    const classes = new Map<ts.Symbol, NgccClassSymbol>();\n    this.getModuleStatements(sourceFile)\n        .forEach(statement => this.addClassSymbolsFromStatement(classes, statement));\n    return Array.from(classes.values());\n  }\n\n  /**\n   * Get the number of generic type parameters of a given class.\n   *\n   * @param clazz a `ClassDeclaration` representing the class over which to reflect.\n   *\n   * @returns the number of type parameters of the class, if known, or `null` if the declaration\n   * is not a class or has an unknown number of type parameters.\n   */\n  getGenericArityOfClass(clazz: ClassDeclaration): number|null {\n    const dtsDeclaration = this.getDtsDeclaration(clazz);\n    if (dtsDeclaration && ts.isClassDeclaration(dtsDeclaration)) {\n      return dtsDeclaration.typeParameters ? dtsDeclaration.typeParameters.length : 0;\n    }\n    return null;\n  }\n\n  /**\n   * Take an exported declaration of a class (maybe down-leveled to a variable) and look up the\n   * declaration of its type in a separate .d.ts tree.\n   *\n   * This function is allowed to return `null` if the current compilation unit does not have a\n   * separate .d.ts tree. When compiling TypeScript code this is always the case, since .d.ts files\n   * are produced only during the emit of such a compilation. When compiling .js code, however,\n   * there is frequently a parallel .d.ts tree which this method exposes.\n   *\n   * Note that the `ts.ClassDeclaration` returned from this function may not be from the same\n   * `ts.Program` as the input declaration.\n   */\n  getDtsDeclaration(declaration: DeclarationNode): ts.Declaration|null {\n    if (this.dts === null) {\n      return null;\n    }\n    if (!isNamedDeclaration(declaration)) {\n      throw new Error(`Cannot get the dts file for a declaration that has no name: ${\n          declaration.getText()} in ${declaration.getSourceFile().fileName}`);\n    }\n\n    const decl = this.getDeclarationOfIdentifier(declaration.name);\n    if (decl === null) {\n      throw new Error(\n          `Cannot get the dts file for a node that cannot be associated with a declaration ${\n              declaration.getText()} in ${declaration.getSourceFile().fileName}`);\n    }\n\n    // Try to retrieve the dts declaration from the public map\n    if (this.publicDtsDeclarationMap === null) {\n      this.publicDtsDeclarationMap = this.computePublicDtsDeclarationMap(this.src, this.dts);\n    }\n    if (this.publicDtsDeclarationMap.has(decl.node)) {\n      return this.publicDtsDeclarationMap.get(decl.node)!;\n    }\n\n    // No public export, try the private map\n    if (this.privateDtsDeclarationMap === null) {\n      this.privateDtsDeclarationMap = this.computePrivateDtsDeclarationMap(this.src, this.dts);\n    }\n    if (this.privateDtsDeclarationMap.has(decl.node)) {\n      return this.privateDtsDeclarationMap.get(decl.node)!;\n    }\n\n    // No declaration found at all\n    return null;\n  }\n\n  getEndOfClass(classSymbol: NgccClassSymbol): ts.Node {\n    const implementation = classSymbol.implementation;\n    let last: ts.Node = implementation.valueDeclaration;\n    const implementationStatement = getContainingStatement(last);\n    if (implementationStatement === null) return last;\n\n    const container = implementationStatement.parent;\n    if (ts.isBlock(container)) {\n      // Assume that the implementation is inside an IIFE\n      const returnStatementIndex = container.statements.findIndex(ts.isReturnStatement);\n      if (returnStatementIndex === -1) {\n        throw new Error(\n            `Compiled class wrapper IIFE does not have a return statement: ${classSymbol.name} in ${\n                classSymbol.declaration.valueDeclaration.getSourceFile().fileName}`);\n      }\n\n      // Return the statement before the IIFE return statement\n      last = container.statements[returnStatementIndex - 1];\n    } else if (ts.isSourceFile(container)) {\n      // If there are static members on this class then find the last one\n      if (implementation.exports !== undefined) {\n        implementation.exports.forEach(exportSymbol => {\n          if (exportSymbol.valueDeclaration === undefined) {\n            return;\n          }\n          const exportStatement = getContainingStatement(exportSymbol.valueDeclaration);\n          if (exportStatement !== null && last.getEnd() < exportStatement.getEnd()) {\n            last = exportStatement;\n          }\n        });\n      }\n\n      // If there are helper calls for this class then find the last one\n      const helpers = this.getHelperCallsForClass(\n          classSymbol, ['__decorate', '__extends', '__param', '__metadata']);\n      helpers.forEach(helper => {\n        const helperStatement = getContainingStatement(helper);\n        if (helperStatement !== null && last.getEnd() < helperStatement.getEnd()) {\n          last = helperStatement;\n        }\n      });\n    }\n    return last;\n  }\n\n  /**\n   * Check whether a `Declaration` corresponds with a known declaration, such as `Object`, and set\n   * its `known` property to the appropriate `KnownDeclaration`.\n   *\n   * @param decl The `Declaration` to check.\n   * @return The passed in `Declaration` (potentially enhanced with a `KnownDeclaration`).\n   */\n  detectKnownDeclaration<T extends Declaration>(decl: T): T {\n    if (decl.known === null && this.isJavaScriptObjectDeclaration(decl)) {\n      // If the identifier resolves to the global JavaScript `Object`, update the declaration to\n      // denote it as the known `JsGlobalObject` declaration.\n      decl.known = KnownDeclaration.JsGlobalObject;\n    }\n    return decl;\n  }\n\n\n  ///////////// Protected Helpers /////////////\n\n  /**\n   * Extract all the \"classes\" from the `statement` and add them to the `classes` map.\n   */\n  protected addClassSymbolsFromStatement(\n      classes: Map<ts.Symbol, NgccClassSymbol>, statement: ts.Statement): void {\n    if (ts.isVariableStatement(statement)) {\n      statement.declarationList.declarations.forEach(declaration => {\n        const classSymbol = this.getClassSymbol(declaration);\n        if (classSymbol) {\n          classes.set(classSymbol.implementation, classSymbol);\n        }\n      });\n    } else if (ts.isClassDeclaration(statement)) {\n      const classSymbol = this.getClassSymbol(statement);\n      if (classSymbol) {\n        classes.set(classSymbol.implementation, classSymbol);\n      }\n    }\n  }\n\n  /**\n   * Compute the inner declaration node of a \"class\" from the given `declaration` node.\n   *\n   * @param declaration a node that is either an inner declaration or an alias of a class.\n   */\n  protected getInnerDeclarationFromAliasOrInner(declaration: ts.Node): ts.Node {\n    if (declaration.parent !== undefined && isNamedVariableDeclaration(declaration.parent)) {\n      const variableValue = this.getVariableValue(declaration.parent);\n      if (variableValue !== null) {\n        declaration = variableValue;\n      }\n    }\n    return declaration;\n  }\n\n  /**\n   * A class may be declared as a top level class declaration:\n   *\n   * ```\n   * class OuterClass { ... }\n   * ```\n   *\n   * or in a variable declaration to a class expression:\n   *\n   * ```\n   * var OuterClass = ClassAlias = class InnerClass {};\n   * ```\n   *\n   * or in a variable declaration to an IIFE containing a class declaration\n   *\n   * ```\n   * var OuterClass = ClassAlias = (() => {\n   *   class InnerClass {}\n   *   ...\n   *   return InnerClass;\n   * })()\n   * ```\n   *\n   * or in a variable declaration to an IIFE containing a function declaration\n   *\n   * ```\n   * var OuterClass = ClassAlias = (() => {\n   *   function InnerClass() {}\n   *   ...\n   *   return InnerClass;\n   * })()\n   * ```\n   *\n   * This method returns an `NgccClassSymbol` when provided with one of these cases.\n   *\n   * @param declaration the declaration whose symbol we are finding.\n   * @returns the symbol for the class or `undefined` if `declaration` does not represent an outer\n   *     declaration of a class.\n   */\n  protected getClassSymbolFromOuterDeclaration(declaration: ts.Node): NgccClassSymbol|undefined {\n    // Return a class symbol without an inner declaration if it is a regular \"top level\" class\n    if (isNamedClassDeclaration(declaration) && isTopLevel(declaration)) {\n      return this.createClassSymbol(declaration.name, null);\n    }\n\n    // Otherwise, an outer class declaration must be an initialized variable declaration:\n    if (!isInitializedVariableClassDeclaration(declaration)) {\n      return undefined;\n    }\n\n    const innerDeclaration = getInnerClassDeclaration(skipClassAliases(declaration));\n    if (innerDeclaration === null) {\n      return undefined;\n    }\n\n    return this.createClassSymbol(declaration.name, innerDeclaration);\n  }\n\n  /**\n   * In ES2015, a class may be declared using a variable declaration of the following structures:\n   *\n   * ```\n   * let MyClass = MyClass_1 = class MyClass {};\n   * ```\n   *\n   * or\n   *\n   * ```\n   * let MyClass = MyClass_1 = (() => { class MyClass {} ... return MyClass; })()\n   * ```\n   *\n   * or\n   *\n   * ```\n   * let MyClass = MyClass_1 = (() => { let MyClass = class MyClass {}; ... return MyClass; })()\n   * ```\n   *\n   * This method extracts the `NgccClassSymbol` for `MyClass` when provided with the\n   * `class MyClass {}` declaration node. When the `var MyClass` node or any other node is given,\n   * this method will return undefined instead.\n   *\n   * @param declaration the declaration whose symbol we are finding.\n   * @returns the symbol for the node or `undefined` if it does not represent an inner declaration\n   * of a class.\n   */\n  protected getClassSymbolFromInnerDeclaration(declaration: ts.Node): NgccClassSymbol|undefined {\n    let outerDeclaration: ts.ClassDeclaration|ts.VariableDeclaration|undefined = undefined;\n\n    if (ts.isClassExpression(declaration) && hasNameIdentifier(declaration)) {\n      // Handle `let MyClass = MyClass_1 = class MyClass {};`\n      outerDeclaration = getFarLeftHandSideOfAssignment(declaration);\n\n      // Handle this being in an IIFE\n      if (outerDeclaration !== undefined && !isTopLevel(outerDeclaration)) {\n        outerDeclaration = getContainingVariableDeclaration(outerDeclaration);\n      }\n    } else if (isNamedClassDeclaration(declaration)) {\n      // Handle `class MyClass {}` statement\n      if (isTopLevel(declaration)) {\n        // At the top level\n        outerDeclaration = declaration;\n      } else {\n        // Or inside an IIFE\n        outerDeclaration = getContainingVariableDeclaration(declaration);\n      }\n    }\n\n    if (outerDeclaration === undefined || !hasNameIdentifier(outerDeclaration)) {\n      return undefined;\n    }\n\n    return this.createClassSymbol(outerDeclaration.name, declaration);\n  }\n\n  /**\n   * Creates an `NgccClassSymbol` from an outer and inner declaration. If a class only has an outer\n   * declaration, the \"implementation\" symbol of the created `NgccClassSymbol` will be set equal to\n   * the \"declaration\" symbol.\n   *\n   * @param outerDeclaration The outer declaration node of the class.\n   * @param innerDeclaration The inner declaration node of the class, or undefined if no inner\n   * declaration is present.\n   * @returns the `NgccClassSymbol` representing the class, or undefined if a `ts.Symbol` for any of\n   * the declarations could not be resolved.\n   */\n  protected createClassSymbol(outerDeclaration: ts.Identifier, innerDeclaration: ts.Node|null):\n      NgccClassSymbol|undefined {\n    const declarationSymbol =\n        this.checker.getSymbolAtLocation(outerDeclaration) as ClassSymbol | undefined;\n    if (declarationSymbol === undefined) {\n      return undefined;\n    }\n\n    let implementationSymbol = declarationSymbol;\n    if (innerDeclaration !== null && isNamedDeclaration(innerDeclaration)) {\n      implementationSymbol = this.checker.getSymbolAtLocation(innerDeclaration.name) as ClassSymbol;\n    }\n\n    if (implementationSymbol === undefined) {\n      return undefined;\n    }\n\n    const classSymbol: NgccClassSymbol = {\n      name: declarationSymbol.name,\n      declaration: declarationSymbol,\n      implementation: implementationSymbol,\n      adjacent: this.getAdjacentSymbol(declarationSymbol, implementationSymbol),\n    };\n\n    return classSymbol;\n  }\n\n  private getAdjacentSymbol(declarationSymbol: ClassSymbol, implementationSymbol: ClassSymbol):\n      ClassSymbol|undefined {\n    if (declarationSymbol === implementationSymbol) {\n      return undefined;\n    }\n    const innerDeclaration = implementationSymbol.valueDeclaration;\n    if (!ts.isClassExpression(innerDeclaration) && !ts.isFunctionExpression(innerDeclaration)) {\n      return undefined;\n    }\n    // Deal with the inner class looking like this inside an IIFE:\n    // `let MyClass = class MyClass {};` or `var MyClass = function MyClass() {};`\n    const adjacentDeclaration = getFarLeftHandSideOfAssignment(innerDeclaration);\n    if (adjacentDeclaration === undefined || !isNamedVariableDeclaration(adjacentDeclaration)) {\n      return undefined;\n    }\n    const adjacentSymbol =\n        this.checker.getSymbolAtLocation(adjacentDeclaration.name) as ClassSymbol;\n    if (adjacentSymbol === declarationSymbol || adjacentSymbol === implementationSymbol) {\n      return undefined;\n    }\n    return adjacentSymbol;\n  }\n\n  /**\n   * Resolve a `ts.Symbol` to its declaration and detect whether it corresponds with a known\n   * declaration.\n   */\n  protected getDeclarationOfSymbol(symbol: ts.Symbol, originalId: ts.Identifier|null): Declaration\n      |null {\n    const declaration = super.getDeclarationOfSymbol(symbol, originalId);\n    if (declaration === null) {\n      return null;\n    }\n    return this.detectKnownDeclaration(declaration);\n  }\n\n  /**\n   * Finds the identifier of the actual class declaration for a potentially aliased declaration of a\n   * class.\n   *\n   * If the given declaration is for an alias of a class, this function will determine an identifier\n   * to the original declaration that represents this class.\n   *\n   * @param declaration The declaration to resolve.\n   * @returns The original identifier that the given class declaration resolves to, or `undefined`\n   * if the declaration does not represent an aliased class.\n   */\n  protected resolveAliasedClassIdentifier(declaration: DeclarationNode): ts.Identifier|null {\n    this.ensurePreprocessed(declaration.getSourceFile());\n    return this.aliasedClassDeclarations.has(declaration) ?\n        this.aliasedClassDeclarations.get(declaration)! :\n        null;\n  }\n\n  /**\n   * Ensures that the source file that `node` is part of has been preprocessed.\n   *\n   * During preprocessing, all statements in the source file will be visited such that certain\n   * processing steps can be done up-front and cached for subsequent usages.\n   *\n   * @param sourceFile The source file that needs to have gone through preprocessing.\n   */\n  protected ensurePreprocessed(sourceFile: ts.SourceFile): void {\n    if (!this.preprocessedSourceFiles.has(sourceFile)) {\n      this.preprocessedSourceFiles.add(sourceFile);\n\n      for (const statement of this.getModuleStatements(sourceFile)) {\n        this.preprocessStatement(statement);\n      }\n    }\n  }\n\n  /**\n   * Analyzes the given statement to see if it corresponds with a variable declaration like\n   * `let MyClass = MyClass_1 = class MyClass {};`. If so, the declaration of `MyClass_1`\n   * is associated with the `MyClass` identifier.\n   *\n   * @param statement The statement that needs to be preprocessed.\n   */\n  protected preprocessStatement(statement: ts.Statement): void {\n    if (!ts.isVariableStatement(statement)) {\n      return;\n    }\n\n    const declarations = statement.declarationList.declarations;\n    if (declarations.length !== 1) {\n      return;\n    }\n\n    const declaration = declarations[0];\n    const initializer = declaration.initializer;\n    if (!ts.isIdentifier(declaration.name) || !initializer || !isAssignment(initializer) ||\n        !ts.isIdentifier(initializer.left) || !this.isClass(declaration)) {\n      return;\n    }\n\n    const aliasedIdentifier = initializer.left;\n\n    const aliasedDeclaration = this.getDeclarationOfIdentifier(aliasedIdentifier);\n    if (aliasedDeclaration === null) {\n      throw new Error(\n          `Unable to locate declaration of ${aliasedIdentifier.text} in \"${statement.getText()}\"`);\n    }\n    this.aliasedClassDeclarations.set(aliasedDeclaration.node, declaration.name);\n  }\n\n  /**\n   * Get the top level statements for a module.\n   *\n   * In ES5 and ES2015 this is just the top level statements of the file.\n   * @param sourceFile The module whose statements we want.\n   * @returns An array of top level statements for the given module.\n   */\n  protected getModuleStatements(sourceFile: ts.SourceFile): ts.Statement[] {\n    return Array.from(sourceFile.statements);\n  }\n\n  /**\n   * Walk the AST looking for an assignment to the specified symbol.\n   * @param node The current node we are searching.\n   * @returns an expression that represents the value of the variable, or undefined if none can be\n   * found.\n   */\n  protected findDecoratedVariableValue(node: ts.Node|undefined, symbol: ts.Symbol):\n      ts.CallExpression|null {\n    if (!node) {\n      return null;\n    }\n    if (ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n      const left = node.left;\n      const right = node.right;\n      if (ts.isIdentifier(left) && this.checker.getSymbolAtLocation(left) === symbol) {\n        return (ts.isCallExpression(right) && getCalleeName(right) === '__decorate') ? right : null;\n      }\n      return this.findDecoratedVariableValue(right, symbol);\n    }\n    return node.forEachChild(node => this.findDecoratedVariableValue(node, symbol)) || null;\n  }\n\n  /**\n   * Try to retrieve the symbol of a static property on a class.\n   *\n   * In some cases, a static property can either be set on the inner (implementation or adjacent)\n   * declaration inside the class' IIFE, or it can be set on the outer variable declaration.\n   * Therefore, the host checks all places, first looking up the property on the inner symbols, and\n   * if the property is not found it will fall back to looking up the property on the outer symbol.\n   *\n   * @param symbol the class whose property we are interested in.\n   * @param propertyName the name of static property.\n   * @returns the symbol if it is found or `undefined` if not.\n   */\n  protected getStaticProperty(symbol: NgccClassSymbol, propertyName: ts.__String): ts.Symbol\n      |undefined {\n    return symbol.implementation.exports?.get(propertyName) ||\n        symbol.adjacent?.exports?.get(propertyName) ||\n        symbol.declaration.exports?.get(propertyName);\n  }\n\n  /**\n   * This is the main entry-point for obtaining information on the decorators of a given class. This\n   * information is computed either from static properties if present, or using `tslib.__decorate`\n   * helper calls otherwise. The computed result is cached per class.\n   *\n   * @param classSymbol the class for which decorators should be acquired.\n   * @returns all information of the decorators on the class.\n   */\n  protected acquireDecoratorInfo(classSymbol: NgccClassSymbol): DecoratorInfo {\n    const decl = classSymbol.declaration.valueDeclaration;\n    if (this.decoratorCache.has(decl)) {\n      return this.decoratorCache.get(decl)!;\n    }\n\n    // Extract decorators from static properties and `__decorate` helper calls, then merge them\n    // together where the information from the static properties is preferred.\n    const staticProps = this.computeDecoratorInfoFromStaticProperties(classSymbol);\n    const helperCalls = this.computeDecoratorInfoFromHelperCalls(classSymbol);\n\n    const decoratorInfo: DecoratorInfo = {\n      classDecorators: staticProps.classDecorators || helperCalls.classDecorators,\n      memberDecorators: staticProps.memberDecorators || helperCalls.memberDecorators,\n      constructorParamInfo: staticProps.constructorParamInfo || helperCalls.constructorParamInfo,\n    };\n\n    this.decoratorCache.set(decl, decoratorInfo);\n    return decoratorInfo;\n  }\n\n  /**\n   * Attempts to compute decorator information from static properties \"decorators\", \"propDecorators\"\n   * and \"ctorParameters\" on the class. If neither of these static properties is present the\n   * library is likely not compiled using tsickle for usage with Closure compiler, in which case\n   * `null` is returned.\n   *\n   * @param classSymbol The class symbol to compute the decorators information for.\n   * @returns All information on the decorators as extracted from static properties, or `null` if\n   * none of the static properties exist.\n   */\n  protected computeDecoratorInfoFromStaticProperties(classSymbol: NgccClassSymbol): {\n    classDecorators: Decorator[]|null; memberDecorators: Map<string, Decorator[]>| null;\n    constructorParamInfo: ParamInfo[] | null;\n  } {\n    let classDecorators: Decorator[]|null = null;\n    let memberDecorators: Map<string, Decorator[]>|null = null;\n    let constructorParamInfo: ParamInfo[]|null = null;\n\n    const decoratorsProperty = this.getStaticProperty(classSymbol, DECORATORS);\n    if (decoratorsProperty !== undefined) {\n      classDecorators = this.getClassDecoratorsFromStaticProperty(decoratorsProperty);\n    }\n\n    const propDecoratorsProperty = this.getStaticProperty(classSymbol, PROP_DECORATORS);\n    if (propDecoratorsProperty !== undefined) {\n      memberDecorators = this.getMemberDecoratorsFromStaticProperty(propDecoratorsProperty);\n    }\n\n    const constructorParamsProperty = this.getStaticProperty(classSymbol, CONSTRUCTOR_PARAMS);\n    if (constructorParamsProperty !== undefined) {\n      constructorParamInfo = this.getParamInfoFromStaticProperty(constructorParamsProperty);\n    }\n\n    return {classDecorators, memberDecorators, constructorParamInfo};\n  }\n\n  /**\n   * Get all class decorators for the given class, where the decorators are declared\n   * via a static property. For example:\n   *\n   * ```\n   * class SomeDirective {}\n   * SomeDirective.decorators = [\n   *   { type: Directive, args: [{ selector: '[someDirective]' },] }\n   * ];\n   * ```\n   *\n   * @param decoratorsSymbol the property containing the decorators we want to get.\n   * @returns an array of decorators or null if none where found.\n   */\n  protected getClassDecoratorsFromStaticProperty(decoratorsSymbol: ts.Symbol): Decorator[]|null {\n    const decoratorsIdentifier = decoratorsSymbol.valueDeclaration;\n    if (decoratorsIdentifier && decoratorsIdentifier.parent) {\n      if (ts.isBinaryExpression(decoratorsIdentifier.parent) &&\n          decoratorsIdentifier.parent.operatorToken.kind === ts.SyntaxKind.EqualsToken) {\n        // AST of the array of decorator values\n        const decoratorsArray = decoratorsIdentifier.parent.right;\n        return this.reflectDecorators(decoratorsArray)\n            .filter(decorator => this.isFromCore(decorator));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Examine a symbol which should be of a class, and return metadata about its members.\n   *\n   * @param symbol the `ClassSymbol` representing the class over which to reflect.\n   * @returns an array of `ClassMember` metadata representing the members of the class.\n   */\n  protected getMembersOfSymbol(symbol: NgccClassSymbol): ClassMember[] {\n    const members: ClassMember[] = [];\n\n    // The decorators map contains all the properties that are decorated\n    const {memberDecorators} = this.acquireDecoratorInfo(symbol);\n\n    // Make a copy of the decorators as successfully reflected members delete themselves from the\n    // map, so that any leftovers can be easily dealt with.\n    const decoratorsMap = new Map(memberDecorators);\n\n    // The member map contains all the method (instance and static); and any instance properties\n    // that are initialized in the class.\n    if (symbol.implementation.members) {\n      symbol.implementation.members.forEach((value, key) => {\n        const decorators = decoratorsMap.get(key as string);\n        const reflectedMembers = this.reflectMembers(value, decorators);\n        if (reflectedMembers) {\n          decoratorsMap.delete(key as string);\n          members.push(...reflectedMembers);\n        }\n      });\n    }\n\n    // The static property map contains all the static properties\n    if (symbol.implementation.exports) {\n      symbol.implementation.exports.forEach((value, key) => {\n        const decorators = decoratorsMap.get(key as string);\n        const reflectedMembers = this.reflectMembers(value, decorators, true);\n        if (reflectedMembers) {\n          decoratorsMap.delete(key as string);\n          members.push(...reflectedMembers);\n        }\n      });\n    }\n\n    // If this class was declared as a VariableDeclaration then it may have static properties\n    // attached to the variable rather than the class itself\n    // For example:\n    // ```\n    // let MyClass = class MyClass {\n    //   // no static properties here!\n    // }\n    // MyClass.staticProperty = ...;\n    // ```\n    if (ts.isVariableDeclaration(symbol.declaration.valueDeclaration)) {\n      if (symbol.declaration.exports) {\n        symbol.declaration.exports.forEach((value, key) => {\n          const decorators = decoratorsMap.get(key as string);\n          const reflectedMembers = this.reflectMembers(value, decorators, true);\n          if (reflectedMembers) {\n            decoratorsMap.delete(key as string);\n            members.push(...reflectedMembers);\n          }\n        });\n      }\n    }\n\n    // If this class was declared as a VariableDeclaration inside an IIFE, then it may have static\n    // properties attached to the variable rather than the class itself.\n    //\n    // For example:\n    // ```\n    // let OuterClass = (() => {\n    //   let AdjacentClass = class InternalClass {\n    //     // no static properties here!\n    //   }\n    //   AdjacentClass.staticProperty = ...;\n    // })();\n    // ```\n    if (symbol.adjacent !== undefined) {\n      if (ts.isVariableDeclaration(symbol.adjacent.valueDeclaration)) {\n        if (symbol.adjacent.exports !== undefined) {\n          symbol.adjacent.exports.forEach((value, key) => {\n            const decorators = decoratorsMap.get(key as string);\n            const reflectedMembers = this.reflectMembers(value, decorators, true);\n            if (reflectedMembers) {\n              decoratorsMap.delete(key as string);\n              members.push(...reflectedMembers);\n            }\n          });\n        }\n      }\n    }\n\n    // Deal with any decorated properties that were not initialized in the class\n    decoratorsMap.forEach((value, key) => {\n      members.push({\n        implementation: null,\n        decorators: value,\n        isStatic: false,\n        kind: ClassMemberKind.Property,\n        name: key,\n        nameNode: null,\n        node: null,\n        type: null,\n        value: null\n      });\n    });\n\n    return members;\n  }\n\n  /**\n   * Member decorators may be declared as static properties of the class:\n   *\n   * ```\n   * SomeDirective.propDecorators = {\n   *   \"ngForOf\": [{ type: Input },],\n   *   \"ngForTrackBy\": [{ type: Input },],\n   *   \"ngForTemplate\": [{ type: Input },],\n   * };\n   * ```\n   *\n   * @param decoratorsProperty the class whose member decorators we are interested in.\n   * @returns a map whose keys are the name of the members and whose values are collections of\n   * decorators for the given member.\n   */\n  protected getMemberDecoratorsFromStaticProperty(decoratorsProperty: ts.Symbol):\n      Map<string, Decorator[]> {\n    const memberDecorators = new Map<string, Decorator[]>();\n    // Symbol of the identifier for `SomeDirective.propDecorators`.\n    const propDecoratorsMap = getPropertyValueFromSymbol(decoratorsProperty);\n    if (propDecoratorsMap && ts.isObjectLiteralExpression(propDecoratorsMap)) {\n      const propertiesMap = reflectObjectLiteral(propDecoratorsMap);\n      propertiesMap.forEach((value, name) => {\n        const decorators =\n            this.reflectDecorators(value).filter(decorator => this.isFromCore(decorator));\n        if (decorators.length) {\n          memberDecorators.set(name, decorators);\n        }\n      });\n    }\n    return memberDecorators;\n  }\n\n  /**\n   * For a given class symbol, collects all decorator information from tslib helper methods, as\n   * generated by TypeScript into emitted JavaScript files.\n   *\n   * Class decorators are extracted from calls to `tslib.__decorate` that look as follows:\n   *\n   * ```\n   * let SomeDirective = class SomeDirective {}\n   * SomeDirective = __decorate([\n   *   Directive({ selector: '[someDirective]' }),\n   * ], SomeDirective);\n   * ```\n   *\n   * The extraction of member decorators is similar, with the distinction that its 2nd and 3rd\n   * argument correspond with a \"prototype\" target and the name of the member to which the\n   * decorators apply.\n   *\n   * ```\n   * __decorate([\n   *     Input(),\n   *     __metadata(\"design:type\", String)\n   * ], SomeDirective.prototype, \"input1\", void 0);\n   * ```\n   *\n   * @param classSymbol The class symbol for which decorators should be extracted.\n   * @returns All information on the decorators of the class.\n   */\n  protected computeDecoratorInfoFromHelperCalls(classSymbol: NgccClassSymbol): DecoratorInfo {\n    let classDecorators: Decorator[]|null = null;\n    const memberDecorators = new Map<string, Decorator[]>();\n    const constructorParamInfo: ParamInfo[] = [];\n\n    const getConstructorParamInfo = (index: number) => {\n      let param = constructorParamInfo[index];\n      if (param === undefined) {\n        param = constructorParamInfo[index] = {decorators: null, typeExpression: null};\n      }\n      return param;\n    };\n\n    // All relevant information can be extracted from calls to `__decorate`, obtain these first.\n    // Note that although the helper calls are retrieved using the class symbol, the result may\n    // contain helper calls corresponding with unrelated classes. Therefore, each helper call still\n    // has to be checked to actually correspond with the class symbol.\n    const helperCalls = this.getHelperCallsForClass(classSymbol, ['__decorate']);\n\n    const outerDeclaration = classSymbol.declaration.valueDeclaration;\n    const innerDeclaration = classSymbol.implementation.valueDeclaration;\n    const adjacentDeclaration = this.getAdjacentNameOfClassSymbol(classSymbol).parent;\n    const matchesClass = (identifier: ts.Identifier) => {\n      const decl = this.getDeclarationOfIdentifier(identifier);\n      return decl !== null &&\n          (decl.node === adjacentDeclaration || decl.node === outerDeclaration ||\n           decl.node === innerDeclaration);\n    };\n\n    for (const helperCall of helperCalls) {\n      if (isClassDecorateCall(helperCall, matchesClass)) {\n        // This `__decorate` call is targeting the class itself.\n        const helperArgs = helperCall.arguments[0];\n\n        for (const element of helperArgs.elements) {\n          const entry = this.reflectDecorateHelperEntry(element);\n          if (entry === null) {\n            continue;\n          }\n\n          if (entry.type === 'decorator') {\n            // The helper arg was reflected to represent an actual decorator\n            if (this.isFromCore(entry.decorator)) {\n              (classDecorators || (classDecorators = [])).push(entry.decorator);\n            }\n          } else if (entry.type === 'param:decorators') {\n            // The helper arg represents a decorator for a parameter. Since it's applied to the\n            // class, it corresponds with a constructor parameter of the class.\n            const param = getConstructorParamInfo(entry.index);\n            (param.decorators || (param.decorators = [])).push(entry.decorator);\n          } else if (entry.type === 'params') {\n            // The helper arg represents the types of the parameters. Since it's applied to the\n            // class, it corresponds with the constructor parameters of the class.\n            entry.types.forEach(\n                (type, index) => getConstructorParamInfo(index).typeExpression = type);\n          }\n        }\n      } else if (isMemberDecorateCall(helperCall, matchesClass)) {\n        // The `__decorate` call is targeting a member of the class\n        const helperArgs = helperCall.arguments[0];\n        const memberName = helperCall.arguments[2].text;\n\n        for (const element of helperArgs.elements) {\n          const entry = this.reflectDecorateHelperEntry(element);\n          if (entry === null) {\n            continue;\n          }\n\n          if (entry.type === 'decorator') {\n            // The helper arg was reflected to represent an actual decorator.\n            if (this.isFromCore(entry.decorator)) {\n              const decorators =\n                  memberDecorators.has(memberName) ? memberDecorators.get(memberName)! : [];\n              decorators.push(entry.decorator);\n              memberDecorators.set(memberName, decorators);\n            }\n          } else {\n            // Information on decorated parameters is not interesting for ngcc, so it's ignored.\n          }\n        }\n      }\n    }\n\n    return {classDecorators, memberDecorators, constructorParamInfo};\n  }\n\n  /**\n   * Extract the details of an entry within a `__decorate` helper call. For example, given the\n   * following code:\n   *\n   * ```\n   * __decorate([\n   *   Directive({ selector: '[someDirective]' }),\n   *   tslib_1.__param(2, Inject(INJECTED_TOKEN)),\n   *   tslib_1.__metadata(\"design:paramtypes\", [ViewContainerRef, TemplateRef, String])\n   * ], SomeDirective);\n   * ```\n   *\n   * it can be seen that there are calls to regular decorators (the `Directive`) and calls into\n   * `tslib` functions which have been inserted by TypeScript. Therefore, this function classifies\n   * a call to correspond with\n   *   1. a real decorator like `Directive` above, or\n   *   2. a decorated parameter, corresponding with `__param` calls from `tslib`, or\n   *   3. the type information of parameters, corresponding with `__metadata` call from `tslib`\n   *\n   * @param expression the expression that needs to be reflected into a `DecorateHelperEntry`\n   * @returns an object that indicates which of the three categories the call represents, together\n   * with the reflected information of the call, or null if the call is not a valid decorate call.\n   */\n  protected reflectDecorateHelperEntry(expression: ts.Expression): DecorateHelperEntry|null {\n    // We only care about those elements that are actual calls\n    if (!ts.isCallExpression(expression)) {\n      return null;\n    }\n    const call = expression;\n\n    const helperName = getCalleeName(call);\n    if (helperName === '__metadata') {\n      // This is a `tslib.__metadata` call, reflect to arguments into a `ParameterTypes` object\n      // if the metadata key is \"design:paramtypes\".\n      const key = call.arguments[0];\n      if (key === undefined || !ts.isStringLiteral(key) || key.text !== 'design:paramtypes') {\n        return null;\n      }\n\n      const value = call.arguments[1];\n      if (value === undefined || !ts.isArrayLiteralExpression(value)) {\n        return null;\n      }\n\n      return {\n        type: 'params',\n        types: Array.from(value.elements),\n      };\n    }\n\n    if (helperName === '__param') {\n      // This is a `tslib.__param` call that is reflected into a `ParameterDecorators` object.\n      const indexArg = call.arguments[0];\n      const index = indexArg && ts.isNumericLiteral(indexArg) ? parseInt(indexArg.text, 10) : NaN;\n      if (isNaN(index)) {\n        return null;\n      }\n\n      const decoratorCall = call.arguments[1];\n      if (decoratorCall === undefined || !ts.isCallExpression(decoratorCall)) {\n        return null;\n      }\n\n      const decorator = this.reflectDecoratorCall(decoratorCall);\n      if (decorator === null) {\n        return null;\n      }\n\n      return {\n        type: 'param:decorators',\n        index,\n        decorator,\n      };\n    }\n\n    // Otherwise attempt to reflect it as a regular decorator.\n    const decorator = this.reflectDecoratorCall(call);\n    if (decorator === null) {\n      return null;\n    }\n    return {\n      type: 'decorator',\n      decorator,\n    };\n  }\n\n  protected reflectDecoratorCall(call: ts.CallExpression): Decorator|null {\n    const decoratorExpression = call.expression;\n    if (!isDecoratorIdentifier(decoratorExpression)) {\n      return null;\n    }\n\n    // We found a decorator!\n    const decoratorIdentifier =\n        ts.isIdentifier(decoratorExpression) ? decoratorExpression : decoratorExpression.name;\n\n    return {\n      name: decoratorIdentifier.text,\n      identifier: decoratorExpression,\n      import: this.getImportOfIdentifier(decoratorIdentifier),\n      node: call,\n      args: Array.from(call.arguments),\n    };\n  }\n\n  /**\n   * Check the given statement to see if it is a call to any of the specified helper functions or\n   * null if not found.\n   *\n   * Matching statements will look like:  `tslib_1.__decorate(...);`.\n   * @param statement the statement that may contain the call.\n   * @param helperNames the names of the helper we are looking for.\n   * @returns the node that corresponds to the `__decorate(...)` call or null if the statement\n   * does not match.\n   */\n  protected getHelperCall(statement: ts.Statement, helperNames: string[]): ts.CallExpression|null {\n    if ((ts.isExpressionStatement(statement) || ts.isReturnStatement(statement)) &&\n        statement.expression) {\n      let expression = statement.expression;\n      while (isAssignment(expression)) {\n        expression = expression.right;\n      }\n      if (ts.isCallExpression(expression)) {\n        const calleeName = getCalleeName(expression);\n        if (calleeName !== null && helperNames.includes(calleeName)) {\n          return expression;\n        }\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Reflect over the given array node and extract decorator information from each element.\n   *\n   * This is used for decorators that are defined in static properties. For example:\n   *\n   * ```\n   * SomeDirective.decorators = [\n   *   { type: Directive, args: [{ selector: '[someDirective]' },] }\n   * ];\n   * ```\n   *\n   * @param decoratorsArray an expression that contains decorator information.\n   * @returns an array of decorator info that was reflected from the array node.\n   */\n  protected reflectDecorators(decoratorsArray: ts.Expression): Decorator[] {\n    const decorators: Decorator[] = [];\n\n    if (ts.isArrayLiteralExpression(decoratorsArray)) {\n      // Add each decorator that is imported from `@angular/core` into the `decorators` array\n      decoratorsArray.elements.forEach(node => {\n        // If the decorator is not an object literal expression then we are not interested\n        if (ts.isObjectLiteralExpression(node)) {\n          // We are only interested in objects of the form: `{ type: DecoratorType, args: [...] }`\n          const decorator = reflectObjectLiteral(node);\n\n          // Is the value of the `type` property an identifier?\n          if (decorator.has('type')) {\n            let decoratorType = decorator.get('type')!;\n            if (isDecoratorIdentifier(decoratorType)) {\n              const decoratorIdentifier =\n                  ts.isIdentifier(decoratorType) ? decoratorType : decoratorType.name;\n              decorators.push({\n                name: decoratorIdentifier.text,\n                identifier: decoratorType,\n                import: this.getImportOfIdentifier(decoratorIdentifier),\n                node,\n                args: getDecoratorArgs(node),\n              });\n            }\n          }\n        }\n      });\n    }\n    return decorators;\n  }\n\n  /**\n   * Reflect over a symbol and extract the member information, combining it with the\n   * provided decorator information, and whether it is a static member.\n   *\n   * A single symbol may represent multiple class members in the case of accessors;\n   * an equally named getter/setter accessor pair is combined into a single symbol.\n   * When the symbol is recognized as representing an accessor, its declarations are\n   * analyzed such that both the setter and getter accessor are returned as separate\n   * class members.\n   *\n   * One difference wrt the TypeScript host is that in ES2015, we cannot see which\n   * accessor originally had any decorators applied to them, as decorators are applied\n   * to the property descriptor in general, not a specific accessor. If an accessor\n   * has both a setter and getter, any decorators are only attached to the setter member.\n   *\n   * @param symbol the symbol for the member to reflect over.\n   * @param decorators an array of decorators associated with the member.\n   * @param isStatic true if this member is static, false if it is an instance property.\n   * @returns the reflected member information, or null if the symbol is not a member.\n   */\n  protected reflectMembers(symbol: ts.Symbol, decorators?: Decorator[], isStatic?: boolean):\n      ClassMember[]|null {\n    if (symbol.flags & ts.SymbolFlags.Accessor) {\n      const members: ClassMember[] = [];\n      const setter = symbol.declarations && symbol.declarations.find(ts.isSetAccessor);\n      const getter = symbol.declarations && symbol.declarations.find(ts.isGetAccessor);\n\n      const setterMember =\n          setter && this.reflectMember(setter, ClassMemberKind.Setter, decorators, isStatic);\n      if (setterMember) {\n        members.push(setterMember);\n\n        // Prevent attaching the decorators to a potential getter. In ES2015, we can't tell where\n        // the decorators were originally attached to, however we only want to attach them to a\n        // single `ClassMember` as otherwise ngtsc would handle the same decorators twice.\n        decorators = undefined;\n      }\n\n      const getterMember =\n          getter && this.reflectMember(getter, ClassMemberKind.Getter, decorators, isStatic);\n      if (getterMember) {\n        members.push(getterMember);\n      }\n\n      return members;\n    }\n\n    let kind: ClassMemberKind|null = null;\n    if (symbol.flags & ts.SymbolFlags.Method) {\n      kind = ClassMemberKind.Method;\n    } else if (symbol.flags & ts.SymbolFlags.Property) {\n      kind = ClassMemberKind.Property;\n    }\n\n    const node = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];\n    if (!node) {\n      // If the symbol has been imported from a TypeScript typings file then the compiler\n      // may pass the `prototype` symbol as an export of the class.\n      // But this has no declaration. In this case we just quietly ignore it.\n      return null;\n    }\n\n    const member = this.reflectMember(node, kind, decorators, isStatic);\n    if (!member) {\n      return null;\n    }\n\n    return [member];\n  }\n\n  /**\n   * Reflect over a symbol and extract the member information, combining it with the\n   * provided decorator information, and whether it is a static member.\n   * @param node the declaration node for the member to reflect over.\n   * @param kind the assumed kind of the member, may become more accurate during reflection.\n   * @param decorators an array of decorators associated with the member.\n   * @param isStatic true if this member is static, false if it is an instance property.\n   * @returns the reflected member information, or null if the symbol is not a member.\n   */\n  protected reflectMember(\n      node: ts.Declaration, kind: ClassMemberKind|null, decorators?: Decorator[],\n      isStatic?: boolean): ClassMember|null {\n    let value: ts.Expression|null = null;\n    let name: string|null = null;\n    let nameNode: ts.Identifier|null = null;\n\n    if (!isClassMemberType(node)) {\n      return null;\n    }\n\n    if (isStatic && isPropertyAccess(node)) {\n      name = node.name.text;\n      value = kind === ClassMemberKind.Property ? node.parent.right : null;\n    } else if (isThisAssignment(node)) {\n      kind = ClassMemberKind.Property;\n      name = node.left.name.text;\n      value = node.right;\n      isStatic = false;\n    } else if (ts.isConstructorDeclaration(node)) {\n      kind = ClassMemberKind.Constructor;\n      name = 'constructor';\n      isStatic = false;\n    }\n\n    if (kind === null) {\n      this.logger.warn(`Unknown member type: \"${node.getText()}`);\n      return null;\n    }\n\n    if (!name) {\n      if (isNamedDeclaration(node)) {\n        name = node.name.text;\n        nameNode = node.name;\n      } else {\n        return null;\n      }\n    }\n\n    // If we have still not determined if this is a static or instance member then\n    // look for the `static` keyword on the declaration\n    if (isStatic === undefined) {\n      isStatic = node.modifiers !== undefined &&\n          node.modifiers.some(mod => mod.kind === ts.SyntaxKind.StaticKeyword);\n    }\n\n    const type: ts.TypeNode = (node as any).type || null;\n    return {\n      node,\n      implementation: node,\n      kind,\n      type,\n      name,\n      nameNode,\n      value,\n      isStatic,\n      decorators: decorators || []\n    };\n  }\n\n  /**\n   * Find the declarations of the constructor parameters of a class identified by its symbol.\n   * @param classSymbol the class whose parameters we want to find.\n   * @returns an array of `ts.ParameterDeclaration` objects representing each of the parameters in\n   * the class's constructor or null if there is no constructor.\n   */\n  protected getConstructorParameterDeclarations(classSymbol: NgccClassSymbol):\n      ts.ParameterDeclaration[]|null {\n    const members = classSymbol.implementation.members;\n    if (members && members.has(CONSTRUCTOR)) {\n      const constructorSymbol = members.get(CONSTRUCTOR)!;\n      // For some reason the constructor does not have a `valueDeclaration` ?!?\n      const constructor = constructorSymbol.declarations &&\n          constructorSymbol.declarations[0] as ts.ConstructorDeclaration | undefined;\n      if (!constructor) {\n        return [];\n      }\n      if (constructor.parameters.length > 0) {\n        return Array.from(constructor.parameters);\n      }\n      if (isSynthesizedConstructor(constructor)) {\n        return null;\n      }\n      return [];\n    }\n    return null;\n  }\n\n  /**\n   * Get the parameter decorators of a class constructor.\n   *\n   * @param classSymbol the class whose parameter info we want to get.\n   * @param parameterNodes the array of TypeScript parameter nodes for this class's constructor.\n   * @returns an array of constructor parameter info objects.\n   */\n  protected getConstructorParamInfo(\n      classSymbol: NgccClassSymbol, parameterNodes: ts.ParameterDeclaration[]): CtorParameter[] {\n    const {constructorParamInfo} = this.acquireDecoratorInfo(classSymbol);\n\n    return parameterNodes.map((node, index) => {\n      const {decorators, typeExpression} = constructorParamInfo[index] ?\n          constructorParamInfo[index] :\n          {decorators: null, typeExpression: null};\n      const nameNode = node.name;\n      const typeValueReference = this.typeToValue(typeExpression);\n\n      return {\n        name: getNameText(nameNode),\n        nameNode,\n        typeValueReference,\n        typeNode: null,\n        decorators\n      };\n    });\n  }\n\n  /**\n   * Compute the `TypeValueReference` for the given `typeExpression`.\n   *\n   * Although `typeExpression` is a valid `ts.Expression` that could be emitted directly into the\n   * generated code, ngcc still needs to resolve the declaration and create an `IMPORTED` type\n   * value reference as the compiler has specialized handling for some symbols, for example\n   * `ChangeDetectorRef` from `@angular/core`. Such an `IMPORTED` type value reference will result\n   * in a newly generated namespace import, instead of emitting the original `typeExpression` as is.\n   */\n  private typeToValue(typeExpression: ts.Expression|null): TypeValueReference {\n    if (typeExpression === null) {\n      return {\n        kind: TypeValueReferenceKind.UNAVAILABLE,\n        reason: {kind: ValueUnavailableKind.MISSING_TYPE},\n      };\n    }\n\n    const imp = this.getImportOfExpression(typeExpression);\n    const decl = this.getDeclarationOfExpression(typeExpression);\n    if (imp === null || decl === null) {\n      return {\n        kind: TypeValueReferenceKind.LOCAL,\n        expression: typeExpression,\n        defaultImportStatement: null,\n      };\n    }\n\n    return {\n      kind: TypeValueReferenceKind.IMPORTED,\n      valueDeclaration: decl.node,\n      moduleName: imp.from,\n      importedName: imp.name,\n      nestedPath: null,\n    };\n  }\n\n  /**\n   * Determines where the `expression` is imported from.\n   *\n   * @param expression the expression to determine the import details for.\n   * @returns the `Import` for the expression, or `null` if the expression is not imported or the\n   * expression syntax is not supported.\n   */\n  private getImportOfExpression(expression: ts.Expression): Import|null {\n    if (ts.isIdentifier(expression)) {\n      return this.getImportOfIdentifier(expression);\n    } else if (ts.isPropertyAccessExpression(expression) && ts.isIdentifier(expression.name)) {\n      return this.getImportOfIdentifier(expression.name);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Get the parameter type and decorators for the constructor of a class,\n   * where the information is stored on a static property of the class.\n   *\n   * Note that in ESM2015, the property is defined an array, or by an arrow function that returns\n   * an array, of decorator and type information.\n   *\n   * For example,\n   *\n   * ```\n   * SomeDirective.ctorParameters = () => [\n   *   {type: ViewContainerRef},\n   *   {type: TemplateRef},\n   *   {type: undefined, decorators: [{ type: Inject, args: [INJECTED_TOKEN]}]},\n   * ];\n   * ```\n   *\n   * or\n   *\n   * ```\n   * SomeDirective.ctorParameters = [\n   *   {type: ViewContainerRef},\n   *   {type: TemplateRef},\n   *   {type: undefined, decorators: [{type: Inject, args: [INJECTED_TOKEN]}]},\n   * ];\n   * ```\n   *\n   * @param paramDecoratorsProperty the property that holds the parameter info we want to get.\n   * @returns an array of objects containing the type and decorators for each parameter.\n   */\n  protected getParamInfoFromStaticProperty(paramDecoratorsProperty: ts.Symbol): ParamInfo[]|null {\n    const paramDecorators = getPropertyValueFromSymbol(paramDecoratorsProperty);\n    if (paramDecorators) {\n      // The decorators array may be wrapped in an arrow function. If so unwrap it.\n      const container =\n          ts.isArrowFunction(paramDecorators) ? paramDecorators.body : paramDecorators;\n      if (ts.isArrayLiteralExpression(container)) {\n        const elements = container.elements;\n        return elements\n            .map(\n                element =>\n                    ts.isObjectLiteralExpression(element) ? reflectObjectLiteral(element) : null)\n            .map(paramInfo => {\n              const typeExpression =\n                  paramInfo && paramInfo.has('type') ? paramInfo.get('type')! : null;\n              const decoratorInfo =\n                  paramInfo && paramInfo.has('decorators') ? paramInfo.get('decorators')! : null;\n              const decorators = decoratorInfo &&\n                  this.reflectDecorators(decoratorInfo)\n                      .filter(decorator => this.isFromCore(decorator));\n              return {typeExpression, decorators};\n            });\n      } else if (paramDecorators !== undefined) {\n        this.logger.warn(\n            'Invalid constructor parameter decorator in ' +\n                paramDecorators.getSourceFile().fileName + ':\\n',\n            paramDecorators.getText());\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Search statements related to the given class for calls to the specified helper.\n   * @param classSymbol the class whose helper calls we are interested in.\n   * @param helperNames the names of the helpers (e.g. `__decorate`) whose calls we are interested\n   * in.\n   * @returns an array of CallExpression nodes for each matching helper call.\n   */\n  protected getHelperCallsForClass(classSymbol: NgccClassSymbol, helperNames: string[]):\n      ts.CallExpression[] {\n    return this.getStatementsForClass(classSymbol)\n        .map(statement => this.getHelperCall(statement, helperNames))\n        .filter(isDefined);\n  }\n\n  /**\n   * Find statements related to the given class that may contain calls to a helper.\n   *\n   * In ESM2015 code the helper calls are in the top level module, so we have to consider\n   * all the statements in the module.\n   *\n   * @param classSymbol the class whose helper calls we are interested in.\n   * @returns an array of statements that may contain helper calls.\n   */\n  protected getStatementsForClass(classSymbol: NgccClassSymbol): ts.Statement[] {\n    const classNode = classSymbol.implementation.valueDeclaration;\n    if (isTopLevel(classNode)) {\n      return this.getModuleStatements(classNode.getSourceFile());\n    }\n    const statement = getContainingStatement(classNode);\n    if (ts.isBlock(statement.parent)) {\n      return Array.from(statement.parent.statements);\n    }\n    // We should never arrive here\n    throw new Error(`Unable to find adjacent statements for ${classSymbol.name}`);\n  }\n\n  /**\n   * Test whether a decorator was imported from `@angular/core`.\n   *\n   * Is the decorator:\n   * * externally imported from `@angular/core`?\n   * * the current hosted program is actually `@angular/core` and\n   *   - relatively internally imported; or\n   *   - not imported, from the current file.\n   *\n   * @param decorator the decorator to test.\n   */\n  protected isFromCore(decorator: Decorator): boolean {\n    if (this.isCore) {\n      return !decorator.import || /^\\./.test(decorator.import.from);\n    } else {\n      return !!decorator.import && decorator.import.from === '@angular/core';\n    }\n  }\n\n  /**\n   * Create a mapping between the public exports in a src program and the public exports of a dts\n   * program.\n   *\n   * @param src the program bundle containing the source files.\n   * @param dts the program bundle containing the typings files.\n   * @returns a map of source declarations to typings declarations.\n   */\n  protected computePublicDtsDeclarationMap(src: BundleProgram, dts: BundleProgram):\n      Map<DeclarationNode, ts.Declaration> {\n    const declarationMap = new Map<DeclarationNode, ts.Declaration>();\n    const dtsDeclarationMap = new Map<string, ts.Declaration>();\n    const rootDts = getRootFileOrFail(dts);\n    this.collectDtsExportedDeclarations(dtsDeclarationMap, rootDts, dts.program.getTypeChecker());\n    const rootSrc = getRootFileOrFail(src);\n    this.collectSrcExportedDeclarations(declarationMap, dtsDeclarationMap, rootSrc);\n    return declarationMap;\n  }\n\n  /**\n   * Create a mapping between the \"private\" exports in a src program and the \"private\" exports of a\n   * dts program. These exports may be exported from individual files in the src or dts programs,\n   * but not exported from the root file (i.e publicly from the entry-point).\n   *\n   * This mapping is a \"best guess\" since we cannot guarantee that two declarations that happen to\n   * be exported from a file with the same name are actually equivalent. But this is a reasonable\n   * estimate for the purposes of ngcc.\n   *\n   * @param src the program bundle containing the source files.\n   * @param dts the program bundle containing the typings files.\n   * @returns a map of source declarations to typings declarations.\n   */\n  protected computePrivateDtsDeclarationMap(src: BundleProgram, dts: BundleProgram):\n      Map<DeclarationNode, ts.Declaration> {\n    const declarationMap = new Map<DeclarationNode, ts.Declaration>();\n    const dtsDeclarationMap = new Map<string, ts.Declaration>();\n    const typeChecker = dts.program.getTypeChecker();\n\n    const dtsFiles = getNonRootPackageFiles(dts);\n    for (const dtsFile of dtsFiles) {\n      this.collectDtsExportedDeclarations(dtsDeclarationMap, dtsFile, typeChecker);\n    }\n\n    const srcFiles = getNonRootPackageFiles(src);\n    for (const srcFile of srcFiles) {\n      this.collectSrcExportedDeclarations(declarationMap, dtsDeclarationMap, srcFile);\n    }\n    return declarationMap;\n  }\n\n  /**\n   * Collect mappings between names of exported declarations in a file and its actual declaration.\n   *\n   * Any new mappings are added to the `dtsDeclarationMap`.\n   */\n  protected collectDtsExportedDeclarations(\n      dtsDeclarationMap: Map<string, ts.Declaration>, srcFile: ts.SourceFile,\n      checker: ts.TypeChecker): void {\n    const srcModule = srcFile && checker.getSymbolAtLocation(srcFile);\n    const moduleExports = srcModule && checker.getExportsOfModule(srcModule);\n    if (moduleExports) {\n      moduleExports.forEach(exportedSymbol => {\n        const name = exportedSymbol.name;\n        if (exportedSymbol.flags & ts.SymbolFlags.Alias) {\n          exportedSymbol = checker.getAliasedSymbol(exportedSymbol);\n        }\n        const declaration = exportedSymbol.valueDeclaration;\n        if (declaration && !dtsDeclarationMap.has(name)) {\n          dtsDeclarationMap.set(name, declaration);\n        }\n      });\n    }\n  }\n\n\n  protected collectSrcExportedDeclarations(\n      declarationMap: Map<DeclarationNode, ts.Declaration>,\n      dtsDeclarationMap: Map<string, ts.Declaration>, srcFile: ts.SourceFile): void {\n    const fileExports = this.getExportsOfModule(srcFile);\n    if (fileExports !== null) {\n      for (const [exportName, {node: declarationNode}] of fileExports) {\n        if (dtsDeclarationMap.has(exportName)) {\n          declarationMap.set(declarationNode, dtsDeclarationMap.get(exportName)!);\n        }\n      }\n    }\n  }\n\n  protected getDeclarationOfExpression(expression: ts.Expression): Declaration|null {\n    if (ts.isIdentifier(expression)) {\n      return this.getDeclarationOfIdentifier(expression);\n    }\n\n    if (!ts.isPropertyAccessExpression(expression) || !ts.isIdentifier(expression.expression)) {\n      return null;\n    }\n\n    const namespaceDecl = this.getDeclarationOfIdentifier(expression.expression);\n    if (!namespaceDecl || !ts.isSourceFile(namespaceDecl.node)) {\n      return null;\n    }\n\n    const namespaceExports = this.getExportsOfModule(namespaceDecl.node);\n    if (namespaceExports === null) {\n      return null;\n    }\n\n    if (!namespaceExports.has(expression.name.text)) {\n      return null;\n    }\n\n    const exportDecl = namespaceExports.get(expression.name.text)!;\n    return {...exportDecl, viaModule: namespaceDecl.viaModule};\n  }\n\n  /** Checks if the specified declaration resolves to the known JavaScript global `Object`. */\n  protected isJavaScriptObjectDeclaration(decl: Declaration): boolean {\n    const node = decl.node;\n    // The default TypeScript library types the global `Object` variable through\n    // a variable declaration with a type reference resolving to `ObjectConstructor`.\n    if (!ts.isVariableDeclaration(node) || !ts.isIdentifier(node.name) ||\n        node.name.text !== 'Object' || node.type === undefined) {\n      return false;\n    }\n    const typeNode = node.type;\n    // If the variable declaration does not have a type resolving to `ObjectConstructor`,\n    // we cannot guarantee that the declaration resolves to the global `Object` variable.\n    if (!ts.isTypeReferenceNode(typeNode) || !ts.isIdentifier(typeNode.typeName) ||\n        typeNode.typeName.text !== 'ObjectConstructor') {\n      return false;\n    }\n    // Finally, check if the type definition for `Object` originates from a default library\n    // definition file. This requires default types to be enabled for the host program.\n    return this.src.program.isSourceFileDefaultLibrary(node.getSourceFile());\n  }\n\n  /**\n   * In JavaScript, enum declarations are emitted as a regular variable declaration followed by an\n   * IIFE in which the enum members are assigned.\n   *\n   *   export var Enum;\n   *   (function (Enum) {\n   *     Enum[\"a\"] = \"A\";\n   *     Enum[\"b\"] = \"B\";\n   *   })(Enum || (Enum = {}));\n   *\n   * @param declaration A variable declaration that may represent an enum\n   * @returns An array of enum members if the variable declaration is followed by an IIFE that\n   * declares the enum members, or null otherwise.\n   */\n  protected resolveEnumMembers(declaration: ts.VariableDeclaration): EnumMember[]|null {\n    // Initialized variables don't represent enum declarations.\n    if (declaration.initializer !== undefined) return null;\n\n    const variableStmt = declaration.parent.parent;\n    if (!ts.isVariableStatement(variableStmt)) return null;\n\n    const block = variableStmt.parent;\n    if (!ts.isBlock(block) && !ts.isSourceFile(block)) return null;\n\n    const declarationIndex = block.statements.findIndex(statement => statement === variableStmt);\n    if (declarationIndex === -1 || declarationIndex === block.statements.length - 1) return null;\n\n    const subsequentStmt = block.statements[declarationIndex + 1];\n    if (!ts.isExpressionStatement(subsequentStmt)) return null;\n\n    const iife = stripParentheses(subsequentStmt.expression);\n    if (!ts.isCallExpression(iife) || !isEnumDeclarationIife(iife)) return null;\n\n    const fn = stripParentheses(iife.expression);\n    if (!ts.isFunctionExpression(fn)) return null;\n\n    return this.reflectEnumMembers(fn);\n  }\n\n  /**\n   * Attempts to extract all `EnumMember`s from a function that is according to the JavaScript emit\n   * format for enums:\n   *\n   *   function (Enum) {\n   *     Enum[\"MemberA\"] = \"a\";\n   *     Enum[\"MemberB\"] = \"b\";\n   *   }\n   *\n   * @param fn The function expression that is assumed to contain enum members.\n   * @returns All enum members if the function is according to the correct syntax, null otherwise.\n   */\n  private reflectEnumMembers(fn: ts.FunctionExpression): EnumMember[]|null {\n    if (fn.parameters.length !== 1) return null;\n\n    const enumName = fn.parameters[0].name;\n    if (!ts.isIdentifier(enumName)) return null;\n\n    const enumMembers: EnumMember[] = [];\n    for (const statement of fn.body.statements) {\n      const enumMember = this.reflectEnumMember(enumName, statement);\n      if (enumMember === null) {\n        return null;\n      }\n      enumMembers.push(enumMember);\n    }\n    return enumMembers;\n  }\n\n  /**\n   * Attempts to extract a single `EnumMember` from a statement in the following syntax:\n   *\n   *   Enum[\"MemberA\"] = \"a\";\n   *\n   * or, for enum member with numeric values:\n   *\n   *   Enum[Enum[\"MemberA\"] = 0] = \"MemberA\";\n   *\n   * @param enumName The identifier of the enum that the members should be set on.\n   * @param statement The statement to inspect.\n   * @returns An `EnumMember` if the statement is according to the expected syntax, null otherwise.\n   */\n  protected reflectEnumMember(enumName: ts.Identifier, statement: ts.Statement): EnumMember|null {\n    if (!ts.isExpressionStatement(statement)) return null;\n\n    const expression = statement.expression;\n\n    // Check for the `Enum[X] = Y;` case.\n    if (!isEnumAssignment(enumName, expression)) {\n      return null;\n    }\n    const assignment = reflectEnumAssignment(expression);\n    if (assignment != null) {\n      return assignment;\n    }\n\n    // Check for the `Enum[Enum[X] = Y] = ...;` case.\n    const innerExpression = expression.left.argumentExpression;\n    if (!isEnumAssignment(enumName, innerExpression)) {\n      return null;\n    }\n    return reflectEnumAssignment(innerExpression);\n  }\n\n  private getAdjacentNameOfClassSymbol(classSymbol: NgccClassSymbol): ts.Identifier {\n    if (classSymbol.adjacent !== undefined) {\n      return this.getNameFromClassSymbolDeclaration(\n          classSymbol, classSymbol.adjacent.valueDeclaration);\n    } else {\n      return this.getNameFromClassSymbolDeclaration(\n          classSymbol, classSymbol.implementation.valueDeclaration);\n    }\n  }\n}\n\n///////////// Exported Helpers /////////////\n\n/**\n * Checks whether the iife has the following call signature:\n *\n *   (Enum || (Enum = {})\n *\n * Note that the `Enum` identifier is not checked, as it could also be something\n * like `exports.Enum`. Instead, only the structure of binary operators is checked.\n *\n * @param iife The call expression to check.\n * @returns true if the iife has a call signature that corresponds with a potential\n * enum declaration.\n */\nfunction isEnumDeclarationIife(iife: ts.CallExpression): boolean {\n  if (iife.arguments.length !== 1) return false;\n\n  const arg = iife.arguments[0];\n  if (!ts.isBinaryExpression(arg) || arg.operatorToken.kind !== ts.SyntaxKind.BarBarToken ||\n      !ts.isParenthesizedExpression(arg.right)) {\n    return false;\n  }\n\n  const right = arg.right.expression;\n  if (!ts.isBinaryExpression(right) || right.operatorToken.kind !== ts.SyntaxKind.EqualsToken) {\n    return false;\n  }\n\n  if (!ts.isObjectLiteralExpression(right.right) || right.right.properties.length !== 0) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * An enum member assignment that looks like `Enum[X] = Y;`.\n */\nexport type EnumMemberAssignment = ts.BinaryExpression&{left: ts.ElementAccessExpression};\n\n/**\n * Checks whether the expression looks like an enum member assignment targeting `Enum`:\n *\n *   Enum[X] = Y;\n *\n * Here, X and Y can be any expression.\n *\n * @param enumName The identifier of the enum that the members should be set on.\n * @param expression The expression that should be checked to conform to the above form.\n * @returns true if the expression is of the correct form, false otherwise.\n */\nfunction isEnumAssignment(\n    enumName: ts.Identifier, expression: ts.Expression): expression is EnumMemberAssignment {\n  if (!ts.isBinaryExpression(expression) ||\n      expression.operatorToken.kind !== ts.SyntaxKind.EqualsToken ||\n      !ts.isElementAccessExpression(expression.left)) {\n    return false;\n  }\n\n  // Verify that the outer assignment corresponds with the enum declaration.\n  const enumIdentifier = expression.left.expression;\n  return ts.isIdentifier(enumIdentifier) && enumIdentifier.text === enumName.text;\n}\n\n/**\n * Attempts to create an `EnumMember` from an expression that is believed to represent an enum\n * assignment.\n *\n * @param expression The expression that is believed to be an enum assignment.\n * @returns An `EnumMember` or null if the expression did not represent an enum member after all.\n */\nfunction reflectEnumAssignment(expression: EnumMemberAssignment): EnumMember|null {\n  const memberName = expression.left.argumentExpression;\n  if (!ts.isPropertyName(memberName)) return null;\n\n  return {name: memberName, initializer: expression.right};\n}\n\nexport type ParamInfo = {\n  decorators: Decorator[]|null,\n  typeExpression: ts.Expression|null\n};\n\n/**\n * Represents a call to `tslib.__metadata` as present in `tslib.__decorate` calls. This is a\n * synthetic decorator inserted by TypeScript that contains reflection information about the\n * target of the decorator, i.e. the class or property.\n */\nexport interface ParameterTypes {\n  type: 'params';\n  types: ts.Expression[];\n}\n\n/**\n * Represents a call to `tslib.__param` as present in `tslib.__decorate` calls. This contains\n * information on any decorators were applied to a certain parameter.\n */\nexport interface ParameterDecorators {\n  type: 'param:decorators';\n  index: number;\n  decorator: Decorator;\n}\n\n/**\n * Represents a call to a decorator as it was present in the original source code, as present in\n * `tslib.__decorate` calls.\n */\nexport interface DecoratorCall {\n  type: 'decorator';\n  decorator: Decorator;\n}\n\n/**\n * Represents the different kinds of decorate helpers that may be present as first argument to\n * `tslib.__decorate`, as follows:\n *\n * ```\n * __decorate([\n *   Directive({ selector: '[someDirective]' }),\n *   tslib_1.__param(2, Inject(INJECTED_TOKEN)),\n *   tslib_1.__metadata(\"design:paramtypes\", [ViewContainerRef, TemplateRef, String])\n * ], SomeDirective);\n * ```\n */\nexport type DecorateHelperEntry = ParameterTypes|ParameterDecorators|DecoratorCall;\n\n/**\n * The recorded decorator information of a single class. This information is cached in the host.\n */\ninterface DecoratorInfo {\n  /**\n   * All decorators that were present on the class. If no decorators were present, this is `null`\n   */\n  classDecorators: Decorator[]|null;\n\n  /**\n   * All decorators per member of the class they were present on.\n   */\n  memberDecorators: Map<string, Decorator[]>;\n\n  /**\n   * Represents the constructor parameter information, such as the type of a parameter and all\n   * decorators for a certain parameter. Indices in this array correspond with the parameter's\n   * index in the constructor. Note that this array may be sparse, i.e. certain constructor\n   * parameters may not have any info recorded.\n   */\n  constructorParamInfo: ParamInfo[];\n}\n\n/**\n * A statement node that represents an assignment.\n */\nexport type AssignmentStatement =\n    ts.ExpressionStatement&{expression: {left: ts.Identifier, right: ts.Expression}};\n\n/**\n * Test whether a statement node is an assignment statement.\n * @param statement the statement to test.\n */\nexport function isAssignmentStatement(statement: ts.Statement): statement is AssignmentStatement {\n  return ts.isExpressionStatement(statement) && isAssignment(statement.expression) &&\n      ts.isIdentifier(statement.expression.left);\n}\n\n/**\n * Parse the `expression` that is believed to be an IIFE and return the AST node that corresponds to\n * the body of the IIFE.\n *\n * The expression may be wrapped in parentheses, which are stripped off.\n *\n * If the IIFE is an arrow function then its body could be a `ts.Expression` rather than a\n * `ts.FunctionBody`.\n *\n * @param expression the expression to parse.\n * @returns the `ts.Expression` or `ts.FunctionBody` that holds the body of the IIFE or `undefined`\n *     if the `expression` did not have the correct shape.\n */\nexport function getIifeBody(expression: ts.Expression): ts.ConciseBody|undefined {\n  const call = stripParentheses(expression);\n  if (!ts.isCallExpression(call)) {\n    return undefined;\n  }\n\n  const fn = stripParentheses(call.expression);\n  if (!ts.isFunctionExpression(fn) && !ts.isArrowFunction(fn)) {\n    return undefined;\n  }\n\n  return fn.body;\n}\n\n/**\n * Returns true if the `node` is an assignment of the form `a = b`.\n *\n * @param node The AST node to check.\n */\nexport function isAssignment(node: ts.Node): node is ts.AssignmentExpression<ts.EqualsToken> {\n  return ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n}\n\n/**\n * Tests whether the provided call expression targets a class, by verifying its arguments are\n * according to the following form:\n *\n * ```\n * __decorate([], SomeDirective);\n * ```\n *\n * @param call the call expression that is tested to represent a class decorator call.\n * @param matches predicate function to test whether the call is associated with the desired class.\n */\nexport function isClassDecorateCall(\n    call: ts.CallExpression, matches: (identifier: ts.Identifier) => boolean):\n    call is ts.CallExpression&{arguments: [ts.ArrayLiteralExpression, ts.Expression]} {\n  const helperArgs = call.arguments[0];\n  if (helperArgs === undefined || !ts.isArrayLiteralExpression(helperArgs)) {\n    return false;\n  }\n\n  const target = call.arguments[1];\n  return target !== undefined && ts.isIdentifier(target) && matches(target);\n}\n\n/**\n * Tests whether the provided call expression targets a member of the class, by verifying its\n * arguments are according to the following form:\n *\n * ```\n * __decorate([], SomeDirective.prototype, \"member\", void 0);\n * ```\n *\n * @param call the call expression that is tested to represent a member decorator call.\n * @param matches predicate function to test whether the call is associated with the desired class.\n */\nexport function isMemberDecorateCall(\n    call: ts.CallExpression, matches: (identifier: ts.Identifier) => boolean):\n    call is ts.CallExpression&\n    {arguments: [ts.ArrayLiteralExpression, ts.StringLiteral, ts.StringLiteral]} {\n  const helperArgs = call.arguments[0];\n  if (helperArgs === undefined || !ts.isArrayLiteralExpression(helperArgs)) {\n    return false;\n  }\n\n  const target = call.arguments[1];\n  if (target === undefined || !ts.isPropertyAccessExpression(target) ||\n      !ts.isIdentifier(target.expression) || !matches(target.expression) ||\n      target.name.text !== 'prototype') {\n    return false;\n  }\n\n  const memberName = call.arguments[2];\n  return memberName !== undefined && ts.isStringLiteral(memberName);\n}\n\n/**\n * Helper method to extract the value of a property given the property's \"symbol\",\n * which is actually the symbol of the identifier of the property.\n */\nexport function getPropertyValueFromSymbol(propSymbol: ts.Symbol): ts.Expression|undefined {\n  const propIdentifier = propSymbol.valueDeclaration;\n  const parent = propIdentifier && propIdentifier.parent;\n  return parent && ts.isBinaryExpression(parent) ? parent.right : undefined;\n}\n\n/**\n * A callee could be one of: `__decorate(...)` or `tslib_1.__decorate`.\n */\nfunction getCalleeName(call: ts.CallExpression): string|null {\n  if (ts.isIdentifier(call.expression)) {\n    return stripDollarSuffix(call.expression.text);\n  }\n  if (ts.isPropertyAccessExpression(call.expression)) {\n    return stripDollarSuffix(call.expression.name.text);\n  }\n  return null;\n}\n\n///////////// Internal Helpers /////////////\n\ntype InitializedVariableClassDeclaration =\n    ClassDeclaration<ts.VariableDeclaration>&{initializer: ts.Expression};\n\nfunction isInitializedVariableClassDeclaration(node: ts.Node):\n    node is InitializedVariableClassDeclaration {\n  return isNamedVariableDeclaration(node) && node.initializer !== undefined;\n}\n\n/**\n * Handle a variable declaration of the form\n *\n * ```\n * var MyClass = alias1 = alias2 = <<declaration>>\n * ```\n *\n * @param node the LHS of a variable declaration.\n * @returns the original AST node or the RHS of a series of assignments in a variable\n *     declaration.\n */\nexport function skipClassAliases(node: InitializedVariableClassDeclaration): ts.Expression {\n  let expression = node.initializer;\n  while (isAssignment(expression)) {\n    expression = expression.right;\n  }\n  return expression;\n}\n\n/**\n * This expression could either be a class expression\n *\n * ```\n * class MyClass {};\n * ```\n *\n * or an IIFE wrapped class expression\n *\n * ```\n * (() => {\n *   class MyClass {}\n *   ...\n *   return MyClass;\n * })()\n * ```\n *\n * or an IIFE wrapped aliased class expression\n *\n * ```\n * (() => {\n *   let MyClass = class MyClass {}\n *   ...\n *   return MyClass;\n * })()\n * ```\n *\n * or an IFFE wrapped ES5 class function\n *\n * ```\n * (function () {\n *  function MyClass() {}\n *  ...\n *  return MyClass\n * })()\n * ```\n *\n * @param expression the node that represents the class whose declaration we are finding.\n * @returns the declaration of the class or `null` if it is not a \"class\".\n */\nexport function getInnerClassDeclaration(expression: ts.Expression):\n    ClassDeclaration<ts.ClassExpression|ts.ClassDeclaration|ts.FunctionDeclaration>|null {\n  if (ts.isClassExpression(expression) && hasNameIdentifier(expression)) {\n    return expression;\n  }\n\n  const iifeBody = getIifeBody(expression);\n  if (iifeBody === undefined) {\n    return null;\n  }\n\n  if (!ts.isBlock(iifeBody)) {\n    // Handle the fat arrow expression case: `() => ClassExpression`\n    return ts.isClassExpression(iifeBody) && isNamedDeclaration(iifeBody) ? iifeBody : null;\n  } else {\n    // Handle the case of a normal or fat-arrow function with a body.\n    // Return the first ClassDeclaration/VariableDeclaration inside the body\n    for (const statement of iifeBody.statements) {\n      if (isNamedClassDeclaration(statement) || isNamedFunctionDeclaration(statement)) {\n        return statement;\n      }\n      if (ts.isVariableStatement(statement)) {\n        for (const declaration of statement.declarationList.declarations) {\n          if (isInitializedVariableClassDeclaration(declaration)) {\n            const expression = skipClassAliases(declaration);\n            if (ts.isClassExpression(expression) && hasNameIdentifier(expression)) {\n              return expression;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\nfunction getDecoratorArgs(node: ts.ObjectLiteralExpression): ts.Expression[] {\n  // The arguments of a decorator are held in the `args` property of its declaration object.\n  const argsProperty = node.properties.filter(ts.isPropertyAssignment)\n                           .find(property => getNameText(property.name) === 'args');\n  const argsExpression = argsProperty && argsProperty.initializer;\n  return argsExpression && ts.isArrayLiteralExpression(argsExpression) ?\n      Array.from(argsExpression.elements) :\n      [];\n}\n\nfunction isPropertyAccess(node: ts.Node): node is ts.PropertyAccessExpression&\n    {parent: ts.BinaryExpression} {\n  return !!node.parent && ts.isBinaryExpression(node.parent) && ts.isPropertyAccessExpression(node);\n}\n\nfunction isThisAssignment(node: ts.Declaration): node is ts.BinaryExpression&\n    {left: ts.PropertyAccessExpression} {\n  return ts.isBinaryExpression(node) && ts.isPropertyAccessExpression(node.left) &&\n      node.left.expression.kind === ts.SyntaxKind.ThisKeyword;\n}\n\nfunction isNamedDeclaration(node: ts.Node): node is ts.NamedDeclaration&{name: ts.Identifier} {\n  const anyNode: any = node;\n  return !!anyNode.name && ts.isIdentifier(anyNode.name);\n}\n\n\nfunction isClassMemberType(node: ts.Declaration): node is ts.ClassElement|\n    ts.PropertyAccessExpression|ts.BinaryExpression {\n  return (ts.isClassElement(node) || isPropertyAccess(node) || ts.isBinaryExpression(node)) &&\n      // Additionally, ensure `node` is not an index signature, for example on an abstract class:\n      // `abstract class Foo { [key: string]: any; }`\n      !ts.isIndexSignatureDeclaration(node);\n}\n\n/**\n * Attempt to resolve the variable declaration that the given declaration is assigned to.\n * For example, for the following code:\n *\n * ```\n * var MyClass = MyClass_1 = class MyClass {};\n * ```\n *\n * or\n *\n * ```\n * var MyClass = MyClass_1 = (() => {\n *   class MyClass {}\n *   ...\n *   return MyClass;\n * })()\n  ```\n *\n * and the provided declaration being `class MyClass {}`, this will return the `var MyClass`\n * declaration.\n *\n * @param declaration The declaration for which any variable declaration should be obtained.\n * @returns the outer variable declaration if found, undefined otherwise.\n */\nfunction getFarLeftHandSideOfAssignment(declaration: ts.Declaration): ts.VariableDeclaration|\n    undefined {\n  let node = declaration.parent;\n\n  // Detect an intermediary variable assignment and skip over it.\n  if (isAssignment(node) && ts.isIdentifier(node.left)) {\n    node = node.parent;\n  }\n\n  return ts.isVariableDeclaration(node) ? node : undefined;\n}\n\nfunction getContainingVariableDeclaration(node: ts.Node): ClassDeclaration<ts.VariableDeclaration>|\n    undefined {\n  node = node.parent;\n  while (node !== undefined) {\n    if (isNamedVariableDeclaration(node)) {\n      return node;\n    }\n    node = node.parent;\n  }\n  return undefined;\n}\n\n/**\n * A constructor function may have been \"synthesized\" by TypeScript during JavaScript emit,\n * in the case no user-defined constructor exists and e.g. property initializers are used.\n * Those initializers need to be emitted into a constructor in JavaScript, so the TypeScript\n * compiler generates a synthetic constructor.\n *\n * We need to identify such constructors as ngcc needs to be able to tell if a class did\n * originally have a constructor in the TypeScript source. When a class has a superclass,\n * a synthesized constructor must not be considered as a user-defined constructor as that\n * prevents a base factory call from being created by ngtsc, resulting in a factory function\n * that does not inject the dependencies of the superclass. Hence, we identify a default\n * synthesized super call in the constructor body, according to the structure that TypeScript\n * emits during JavaScript emit:\n * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/ts.ts#L1068-L1082\n *\n * @param constructor a constructor function to test\n * @returns true if the constructor appears to have been synthesized\n */\nfunction isSynthesizedConstructor(constructor: ts.ConstructorDeclaration): boolean {\n  if (!constructor.body) return false;\n\n  const firstStatement = constructor.body.statements[0];\n  if (!firstStatement || !ts.isExpressionStatement(firstStatement)) return false;\n\n  return isSynthesizedSuperCall(firstStatement.expression);\n}\n\n/**\n * Tests whether the expression appears to have been synthesized by TypeScript, i.e. whether\n * it is of the following form:\n *\n * ```\n * super(...arguments);\n * ```\n *\n * @param expression the expression that is to be tested\n * @returns true if the expression appears to be a synthesized super call\n */\nfunction isSynthesizedSuperCall(expression: ts.Expression): boolean {\n  if (!ts.isCallExpression(expression)) return false;\n  if (expression.expression.kind !== ts.SyntaxKind.SuperKeyword) return false;\n  if (expression.arguments.length !== 1) return false;\n\n  const argument = expression.arguments[0];\n  return ts.isSpreadElement(argument) && ts.isIdentifier(argument.expression) &&\n      argument.expression.text === 'arguments';\n}\n\n/**\n * Find the statement that contains the given node\n * @param node a node whose containing statement we wish to find\n */\nexport function getContainingStatement(node: ts.Node): ts.Statement {\n  while (node.parent) {\n    if (ts.isBlock(node.parent) || ts.isSourceFile(node.parent)) {\n      break;\n    }\n    node = node.parent;\n  }\n  return node as ts.Statement;\n}\n\nfunction getRootFileOrFail(bundle: BundleProgram): ts.SourceFile {\n  const rootFile = bundle.program.getSourceFile(bundle.path);\n  if (rootFile === undefined) {\n    throw new Error(`The given rootPath ${rootFile} is not a file of the program.`);\n  }\n  return rootFile;\n}\n\nfunction getNonRootPackageFiles(bundle: BundleProgram): ts.SourceFile[] {\n  const rootFile = bundle.program.getSourceFile(bundle.path);\n  return bundle.program.getSourceFiles().filter(\n      f => (f !== rootFile) && isWithinPackage(bundle.package, absoluteFromSourceFile(f)));\n}\n\nfunction isTopLevel(node: ts.Node): boolean {\n  while (node = node.parent) {\n    if (ts.isBlock(node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Get a node that represents the actual (outer) declaration of a class from its implementation.\n *\n * Sometimes, the implementation of a class is an expression that is hidden inside an IIFE and\n * assigned to a variable outside the IIFE, which is what the rest of the program interacts with.\n * For example,\n *\n * ```\n * OuterNode = Alias = (function() { function InnerNode() {} return InnerNode; })();\n * ```\n *\n * @param node a node that could be the implementation inside an IIFE.\n * @returns a node that represents the outer declaration, or `null` if it is does not match the IIFE\n *     format shown above.\n */\nexport function getOuterNodeFromInnerDeclaration(node: ts.Node): ts.Node|null {\n  if (!ts.isFunctionDeclaration(node) && !ts.isClassDeclaration(node) &&\n      !ts.isVariableStatement(node)) {\n    return null;\n  }\n\n  // It might be the function expression inside the IIFE. We need to go 5 levels up...\n\n  // - IIFE body.\n  let outerNode = node.parent;\n  if (!outerNode || !ts.isBlock(outerNode)) return null;\n\n  // - IIFE function expression.\n  outerNode = outerNode.parent;\n  if (!outerNode || (!ts.isFunctionExpression(outerNode) && !ts.isArrowFunction(outerNode))) {\n    return null;\n  }\n  outerNode = outerNode.parent;\n\n  // - Parenthesis inside IIFE.\n  if (outerNode && ts.isParenthesizedExpression(outerNode)) outerNode = outerNode.parent;\n\n  // - IIFE call expression.\n  if (!outerNode || !ts.isCallExpression(outerNode)) return null;\n  outerNode = outerNode.parent;\n\n  // - Parenthesis around IIFE.\n  if (outerNode && ts.isParenthesizedExpression(outerNode)) outerNode = outerNode.parent;\n\n  // - Skip any aliases between the IIFE and the far left hand side of any assignments.\n  while (isAssignment(outerNode.parent)) {\n    outerNode = outerNode.parent;\n  }\n\n  return outerNode;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}