{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\"use strict\";\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * @typedef {Object} PathTreeNode\n * @property {Map<string, PathTreeNode>|null} children\n * @property {MappingValue} folder\n * @property {Map<string, MappingValue>} files\n */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar slashCode = \"/\".charCodeAt(0);\nvar dotCode = \".\".charCodeAt(0);\nvar hashCode = \"#\".charCodeAt(0);\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\n\nmodule.exports.processExportsField = function processExportsField(exportsField) {\n  return createFieldProcessor(buildExportsFieldPathTree(exportsField), assertExportsFieldRequest, assertExportTarget);\n};\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\n\n\nmodule.exports.processImportsField = function processImportsField(importsField) {\n  return createFieldProcessor(buildImportsFieldPathTree(importsField), assertImportsFieldRequest, assertImportTarget);\n};\n/**\n * @param {PathTreeNode} treeRoot root\n * @param {(s: string) => void} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\n\n\nfunction createFieldProcessor(treeRoot, assertRequest, assertTarget) {\n  return function fieldProcessor(request, conditionNames) {\n    assertRequest(request);\n    var match = findMatch(request, treeRoot);\n    if (match === null) return [];\n    /** @type {DirectMapping|null} */\n\n    var direct = null;\n\n    var _match = _slicedToArray(match, 2),\n        mapping = _match[0],\n        remainRequestIndex = _match[1];\n\n    if (isConditionalMapping(mapping)) {\n      direct = conditionalMapping(\n      /** @type {ConditionalMapping} */\n      mapping, conditionNames); // matching not found\n\n      if (direct === null) return [];\n    } else {\n      direct =\n      /** @type {DirectMapping} */\n      mapping;\n    }\n\n    var remainingRequest = remainRequestIndex !== request.length ? request.slice(remainRequestIndex) : undefined;\n    return directMapping(remainingRequest, direct, conditionNames, assertTarget);\n  };\n}\n/**\n * @param {string} request request\n */\n\n\nfunction assertExportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== dotCode) {\n    throw new Error('Request should be relative path and start with \".\"');\n  }\n\n  if (request.length === 1) return;\n\n  if (request.charCodeAt(1) !== slashCode) {\n    throw new Error('Request should be relative path and start with \"./\"');\n  }\n\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n}\n/**\n * @param {string} request request\n */\n\n\nfunction assertImportsFieldRequest(request) {\n  if (request.charCodeAt(0) !== hashCode) {\n    throw new Error('Request should start with \"#\"');\n  }\n\n  if (request.length === 1) {\n    throw new Error(\"Request should have at least 2 characters\");\n  }\n\n  if (request.charCodeAt(1) === slashCode) {\n    throw new Error('Request should not start with \"#/\"');\n  }\n\n  if (request.charCodeAt(request.length - 1) === slashCode) {\n    throw new Error(\"Only requesting file allowed\");\n  }\n}\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\n\n\nfunction assertExportTarget(exp, expectFolder) {\n  if (exp.charCodeAt(0) === slashCode || exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode) {\n    throw new Error(\"Export should be relative path and start with \\\"./\\\", got \".concat(JSON.stringify(exp), \".\"));\n  }\n\n  var isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? \"Expecting folder to folder mapping. \".concat(JSON.stringify(exp), \" should end with \\\"/\\\"\") : \"Expecting file to file mapping. \".concat(JSON.stringify(exp), \" should not end with \\\"/\\\"\"));\n  }\n}\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\n\n\nfunction assertImportTarget(imp, expectFolder) {\n  var isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n\n  if (isFolder !== expectFolder) {\n    throw new Error(expectFolder ? \"Expecting folder to folder mapping. \".concat(JSON.stringify(imp), \" should end with \\\"/\\\"\") : \"Expecting file to file mapping. \".concat(JSON.stringify(imp), \" should not end with \\\"/\\\"\"));\n  }\n}\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {PathTreeNode} treeRoot path tree root\n * @returns {[MappingValue, number]|null} match or null\n */\n\n\nfunction findMatch(request, treeRoot) {\n  if (request.length === 1) {\n    var _value = treeRoot.files.get(\"*root*\");\n\n    return _value ? [_value, 1] : null;\n  }\n\n  if (treeRoot.children === null && treeRoot.folder === null) {\n    var _value2 = treeRoot.files.get(request);\n\n    return _value2 ? [_value2, request.length] : null;\n  }\n\n  var node = treeRoot;\n  var lastNonSlashIndex = 0;\n  var slashIndex = request.indexOf(\"/\", 2);\n  /** @type {[MappingValue, number]|null} */\n\n  var lastFolderMatch = null;\n\n  while (slashIndex !== -1) {\n    var folder = request.slice(lastNonSlashIndex, slashIndex);\n    var _folderMapping = node.folder;\n\n    if (_folderMapping) {\n      if (lastFolderMatch) {\n        lastFolderMatch[0] = _folderMapping;\n        lastFolderMatch[1] = lastNonSlashIndex;\n      } else {\n        lastFolderMatch = [_folderMapping, lastNonSlashIndex || 2];\n      }\n    }\n\n    if (node.children === null) return lastFolderMatch;\n    var newNode = node.children.get(folder);\n\n    if (!newNode) {\n      var _value3 = node.folder;\n      return _value3 ? [_value3, lastNonSlashIndex] : null;\n    }\n\n    node = newNode;\n    lastNonSlashIndex = slashIndex + 1;\n    slashIndex = request.indexOf(\"/\", lastNonSlashIndex);\n  }\n\n  var value = node.files.get(lastNonSlashIndex > 0 ? request.slice(lastNonSlashIndex) : request);\n\n  if (value) {\n    return [value, request.length];\n  }\n\n  var folderMapping = node.folder;\n\n  if (folderMapping) {\n    return [folderMapping, lastNonSlashIndex || 2];\n  }\n\n  return lastFolderMatch;\n}\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\n\n\nfunction isConditionalMapping(mapping) {\n  return mapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping);\n}\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {DirectMapping|null} dirrectMapping_ direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\n\n\nfunction directMapping(remainingRequest, dirrectMapping_, conditionNames, assert) {\n  if (dirrectMapping_ === null) return [];\n  var expectFolder = remainingRequest !== undefined;\n\n  if (typeof dirrectMapping_ === \"string\") {\n    assert(dirrectMapping_, expectFolder);\n    return expectFolder ? [\"\".concat(dirrectMapping_).concat(remainingRequest)] : [dirrectMapping_];\n  }\n\n  var targets = [];\n\n  var _iterator = _createForOfIteratorHelper(dirrectMapping_),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var exp = _step.value;\n\n      if (typeof exp === \"string\") {\n        assert(exp, expectFolder);\n        targets.push(expectFolder ? \"\".concat(exp).concat(remainingRequest) : exp);\n        continue;\n      }\n\n      var mapping = conditionalMapping(exp, conditionNames);\n      if (!mapping) continue;\n      var innerExports = directMapping(remainingRequest, mapping, conditionNames, assert);\n\n      var _iterator2 = _createForOfIteratorHelper(innerExports),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var innerExport = _step2.value;\n          targets.push(innerExport);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return targets;\n}\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\n\n\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n  /** @type {[ConditionalMapping, string[], number][]} */\n  var lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n  loop: while (lookup.length > 0) {\n    var _lookup = _slicedToArray(lookup[lookup.length - 1], 3),\n        mapping = _lookup[0],\n        conditions = _lookup[1],\n        j = _lookup[2];\n\n    var last = conditions.length - 1;\n\n    for (var i = j; i < conditions.length; i++) {\n      var condition = conditions[i]; // assert default. Could be last only\n\n      if (i !== last) {\n        if (condition === \"default\") {\n          throw new Error(\"Default condition should be last one\");\n        }\n      } else if (condition === \"default\") {\n        var innerMapping = mapping[condition]; // is nested\n\n        if (isConditionalMapping(innerMapping)) {\n          var _conditionalMapping =\n          /** @type {ConditionalMapping} */\n          innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([_conditionalMapping, Object.keys(_conditionalMapping), 0]);\n          continue loop;\n        }\n\n        return (\n          /** @type {DirectMapping} */\n          innerMapping\n        );\n      }\n\n      if (conditionNames.has(condition)) {\n        var _innerMapping = mapping[condition]; // is nested\n\n        if (isConditionalMapping(_innerMapping)) {\n          var _conditionalMapping2 =\n          /** @type {ConditionalMapping} */\n          _innerMapping;\n          lookup[lookup.length - 1][2] = i + 1;\n          lookup.push([_conditionalMapping2, Object.keys(_conditionalMapping2), 0]);\n          continue loop;\n        }\n\n        return (\n          /** @type {DirectMapping} */\n          _innerMapping\n        );\n      }\n    }\n\n    lookup.pop();\n  }\n\n  return null;\n}\n/**\n * Internal helper to create path tree node\n * to ensure that each node gets the same hidden class\n * @returns {PathTreeNode} node\n */\n\n\nfunction createNode() {\n  return {\n    children: null,\n    folder: null,\n    files: new Map()\n  };\n}\n/**\n * Internal helper for building path tree\n * @param {PathTreeNode} root root\n * @param {string} path path\n * @param {MappingValue} target target\n */\n\n\nfunction walkPath(root, path, target) {\n  if (path.length === 2 && path === \"./\") {\n    root.folder = target;\n    return;\n  }\n\n  var node = root; // It is safe to store # and ./ as a part of file\n  // because mapping works like string concatenation\n  // so typical path tree can looks like\n  // root\n  // - files: [\"./a.js\", \"./b.js\"]\n  // - children:\n  //    node1:\n  //    - files: [\"a.js\", \"b.js\"]\n\n  var lastNonSlashIndex = 0; // This is safe for \"imports\" field\n  // since specifiers \"#\" and \"#/\" are disallowed and\n  // should be asserted before \"walking\"\n\n  var slashIndex = path.indexOf(\"/\", 2);\n\n  while (slashIndex !== -1) {\n    var folder = path.slice(lastNonSlashIndex, slashIndex);\n    var newNode = void 0;\n\n    if (node.children === null) {\n      newNode = createNode();\n      node.children = new Map();\n      node.children.set(folder, newNode);\n    } else {\n      newNode = node.children.get(folder);\n\n      if (!newNode) {\n        newNode = createNode();\n        node.children.set(folder, newNode);\n      }\n    }\n\n    node = newNode;\n    lastNonSlashIndex = slashIndex + 1;\n    slashIndex = path.indexOf(\"/\", lastNonSlashIndex);\n  }\n\n  if (lastNonSlashIndex < path.length) {\n    node.files.set(lastNonSlashIndex > 0 ? path.slice(lastNonSlashIndex) : path, target);\n  } else {\n    node.folder = target;\n  }\n}\n/**\n * @param {ExportsField} field exports field\n * @returns {PathTreeNode} tree root\n */\n\n\nfunction buildExportsFieldPathTree(field) {\n  var root = createNode(); // handle syntax sugar, if exports field is direct mapping for \".\"\n\n  if (typeof field === \"string\") {\n    root.files.set(\"*root*\", field);\n    return root;\n  } else if (Array.isArray(field)) {\n    root.files.set(\"*root*\", field.slice());\n    return root;\n  }\n\n  var keys = Object.keys(field);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key.charCodeAt(0) !== dotCode) {\n      // handle syntax sugar, if exports field is conditional mapping for \".\"\n      if (i === 0) {\n        while (i < keys.length) {\n          var charCode = keys[i].charCodeAt(0);\n\n          if (charCode === dotCode || charCode === slashCode) {\n            throw new Error(\"Exports field key should be relative path and start with \\\".\\\" (key: \".concat(JSON.stringify(key), \")\"));\n          }\n\n          i++;\n        }\n\n        root.files.set(\"*root*\", field);\n        return root;\n      }\n\n      throw new Error(\"Exports field key should be relative path and start with \\\".\\\" (key: \".concat(JSON.stringify(key), \")\"));\n    }\n\n    if (key.length === 1) {\n      root.files.set(\"*root*\", field[key]);\n      continue;\n    }\n\n    if (key.charCodeAt(1) !== slashCode) {\n      throw new Error(\"Exports field key should be relative path and start with \\\"./\\\" (key: \".concat(JSON.stringify(key), \")\"));\n    }\n\n    walkPath(root, key, field[key]);\n  }\n\n  return root;\n}\n/**\n * @param {ImportsField} field imports field\n * @returns {PathTreeNode} root\n */\n\n\nfunction buildImportsFieldPathTree(field) {\n  var root = createNode();\n  var keys = Object.keys(field);\n\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (key.charCodeAt(0) !== hashCode) {\n      throw new Error(\"Imports field key should start with \\\"#\\\" (key: \".concat(JSON.stringify(key), \")\"));\n    }\n\n    if (key.length === 1) {\n      throw new Error(\"Imports field key should have at least 2 characters (key: \".concat(JSON.stringify(key), \")\"));\n    }\n\n    if (key.charCodeAt(1) === slashCode) {\n      throw new Error(\"Imports field key should not start with \\\"#/\\\" (key: \".concat(JSON.stringify(key), \")\"));\n    }\n\n    walkPath(root, key, field[key]);\n  }\n\n  return root;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/enhanced-resolve/lib/util/entrypoints.js"],"names":["slashCode","charCodeAt","dotCode","hashCode","module","exports","processExportsField","exportsField","createFieldProcessor","buildExportsFieldPathTree","assertExportsFieldRequest","assertExportTarget","processImportsField","importsField","buildImportsFieldPathTree","assertImportsFieldRequest","assertImportTarget","treeRoot","assertRequest","assertTarget","fieldProcessor","request","conditionNames","match","findMatch","direct","mapping","remainRequestIndex","isConditionalMapping","conditionalMapping","remainingRequest","length","slice","undefined","directMapping","Error","exp","expectFolder","JSON","stringify","isFolder","imp","value","files","get","children","folder","node","lastNonSlashIndex","slashIndex","indexOf","lastFolderMatch","folderMapping","newNode","Array","isArray","dirrectMapping_","assert","targets","push","innerExports","innerExport","conditionalMapping_","lookup","Object","keys","loop","conditions","j","last","i","condition","innerMapping","has","pop","createNode","Map","walkPath","root","path","target","set","field","key","charCode"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AACA;;AACA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAEA,IAAMA,SAAS,GAAG,IAAIC,UAAJ,CAAe,CAAf,CAAlB;AACA,IAAMC,OAAO,GAAG,IAAID,UAAJ,CAAe,CAAf,CAAhB;AACA,IAAME,QAAQ,GAAG,IAAIF,UAAJ,CAAe,CAAf,CAAjB;AAEA;AACA;AACA;AACA;;AACAG,MAAM,CAACC,OAAP,CAAeC,mBAAf,GAAqC,SAASA,mBAAT,CACpCC,YADoC,EAEnC;AACD,SAAOC,oBAAoB,CAC1BC,yBAAyB,CAACF,YAAD,CADC,EAE1BG,yBAF0B,EAG1BC,kBAH0B,CAA3B;AAKA,CARD;AAUA;AACA;AACA;AACA;;;AACAP,MAAM,CAACC,OAAP,CAAeO,mBAAf,GAAqC,SAASA,mBAAT,CACpCC,YADoC,EAEnC;AACD,SAAOL,oBAAoB,CAC1BM,yBAAyB,CAACD,YAAD,CADC,EAE1BE,yBAF0B,EAG1BC,kBAH0B,CAA3B;AAKA,CARD;AAUA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASR,oBAAT,CAA8BS,QAA9B,EAAwCC,aAAxC,EAAuDC,YAAvD,EAAqE;AACpE,SAAO,SAASC,cAAT,CAAwBC,OAAxB,EAAiCC,cAAjC,EAAiD;AACvDJ,IAAAA,aAAa,CAACG,OAAD,CAAb;AAEA,QAAME,KAAK,GAAGC,SAAS,CAACH,OAAD,EAAUJ,QAAV,CAAvB;AAEA,QAAIM,KAAK,KAAK,IAAd,EAAoB,OAAO,EAAP;AAEpB;;AACA,QAAIE,MAAM,GAAG,IAAb;;AACA,gCAAsCF,KAAtC;AAAA,QAAOG,OAAP;AAAA,QAAgBC,kBAAhB;;AAEA,QAAIC,oBAAoB,CAACF,OAAD,CAAxB,EAAmC;AAClCD,MAAAA,MAAM,GAAGI,kBAAkB;AAC1B;AAAmCH,MAAAA,OADT,EAE1BJ,cAF0B,CAA3B,CADkC,CAMlC;;AACA,UAAIG,MAAM,KAAK,IAAf,EAAqB,OAAO,EAAP;AACrB,KARD,MAQO;AACNA,MAAAA,MAAM;AAAG;AAA8BC,MAAAA,OAAvC;AACA;;AAED,QAAMI,gBAAgB,GACrBH,kBAAkB,KAAKN,OAAO,CAACU,MAA/B,GACGV,OAAO,CAACW,KAAR,CAAcL,kBAAd,CADH,GAEGM,SAHJ;AAKA,WAAOC,aAAa,CACnBJ,gBADmB,EAEnBL,MAFmB,EAGnBH,cAHmB,EAInBH,YAJmB,CAApB;AAMA,GAlCD;AAmCA;AAED;AACA;AACA;;;AACA,SAAST,yBAAT,CAAmCW,OAAnC,EAA4C;AAC3C,MAAIA,OAAO,CAACpB,UAAR,CAAmB,CAAnB,MAA0BC,OAA9B,EAAuC;AACtC,UAAM,IAAIiC,KAAJ,CAAU,oDAAV,CAAN;AACA;;AACD,MAAId,OAAO,CAACU,MAAR,KAAmB,CAAvB,EAA0B;;AAC1B,MAAIV,OAAO,CAACpB,UAAR,CAAmB,CAAnB,MAA0BD,SAA9B,EAAyC;AACxC,UAAM,IAAImC,KAAJ,CAAU,qDAAV,CAAN;AACA;;AACD,MAAId,OAAO,CAACpB,UAAR,CAAmBoB,OAAO,CAACU,MAAR,GAAiB,CAApC,MAA2C/B,SAA/C,EAA0D;AACzD,UAAM,IAAImC,KAAJ,CAAU,8BAAV,CAAN;AACA;AACD;AAED;AACA;AACA;;;AACA,SAASpB,yBAAT,CAAmCM,OAAnC,EAA4C;AAC3C,MAAIA,OAAO,CAACpB,UAAR,CAAmB,CAAnB,MAA0BE,QAA9B,EAAwC;AACvC,UAAM,IAAIgC,KAAJ,CAAU,+BAAV,CAAN;AACA;;AACD,MAAId,OAAO,CAACU,MAAR,KAAmB,CAAvB,EAA0B;AACzB,UAAM,IAAII,KAAJ,CAAU,2CAAV,CAAN;AACA;;AACD,MAAId,OAAO,CAACpB,UAAR,CAAmB,CAAnB,MAA0BD,SAA9B,EAAyC;AACxC,UAAM,IAAImC,KAAJ,CAAU,oCAAV,CAAN;AACA;;AACD,MAAId,OAAO,CAACpB,UAAR,CAAmBoB,OAAO,CAACU,MAAR,GAAiB,CAApC,MAA2C/B,SAA/C,EAA0D;AACzD,UAAM,IAAImC,KAAJ,CAAU,8BAAV,CAAN;AACA;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASxB,kBAAT,CAA4ByB,GAA5B,EAAiCC,YAAjC,EAA+C;AAC9C,MACCD,GAAG,CAACnC,UAAJ,CAAe,CAAf,MAAsBD,SAAtB,IACCoC,GAAG,CAACnC,UAAJ,CAAe,CAAf,MAAsBC,OAAtB,IAAiCkC,GAAG,CAACnC,UAAJ,CAAe,CAAf,MAAsBD,SAFzD,EAGE;AACD,UAAM,IAAImC,KAAJ,qEACsDG,IAAI,CAACC,SAAL,CAC1DH,GAD0D,CADtD,OAAN;AAKA;;AAED,MAAMI,QAAQ,GAAGJ,GAAG,CAACnC,UAAJ,CAAemC,GAAG,CAACL,MAAJ,GAAa,CAA5B,MAAmC/B,SAApD;;AAEA,MAAIwC,QAAQ,KAAKH,YAAjB,EAA+B;AAC9B,UAAM,IAAIF,KAAJ,CACLE,YAAY,iDAC8BC,IAAI,CAACC,SAAL,CACvCH,GADuC,CAD9B,wEAI0BE,IAAI,CAACC,SAAL,CACnCH,GADmC,CAJ1B,+BADP,CAAN;AASA;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASpB,kBAAT,CAA4ByB,GAA5B,EAAiCJ,YAAjC,EAA+C;AAC9C,MAAMG,QAAQ,GAAGC,GAAG,CAACxC,UAAJ,CAAewC,GAAG,CAACV,MAAJ,GAAa,CAA5B,MAAmC/B,SAApD;;AAEA,MAAIwC,QAAQ,KAAKH,YAAjB,EAA+B;AAC9B,UAAM,IAAIF,KAAJ,CACLE,YAAY,iDAC8BC,IAAI,CAACC,SAAL,CACvCE,GADuC,CAD9B,wEAI0BH,IAAI,CAACC,SAAL,CACnCE,GADmC,CAJ1B,+BADP,CAAN;AASA;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASjB,SAAT,CAAmBH,OAAnB,EAA4BJ,QAA5B,EAAsC;AACrC,MAAII,OAAO,CAACU,MAAR,KAAmB,CAAvB,EAA0B;AACzB,QAAMW,MAAK,GAAGzB,QAAQ,CAAC0B,KAAT,CAAeC,GAAf,CAAmB,QAAnB,CAAd;;AAEA,WAAOF,MAAK,GAAG,CAACA,MAAD,EAAQ,CAAR,CAAH,GAAgB,IAA5B;AACA;;AAED,MAAIzB,QAAQ,CAAC4B,QAAT,KAAsB,IAAtB,IAA8B5B,QAAQ,CAAC6B,MAAT,KAAoB,IAAtD,EAA4D;AAC3D,QAAMJ,OAAK,GAAGzB,QAAQ,CAAC0B,KAAT,CAAeC,GAAf,CAAmBvB,OAAnB,CAAd;;AAEA,WAAOqB,OAAK,GAAG,CAACA,OAAD,EAAQrB,OAAO,CAACU,MAAhB,CAAH,GAA6B,IAAzC;AACA;;AAED,MAAIgB,IAAI,GAAG9B,QAAX;AACA,MAAI+B,iBAAiB,GAAG,CAAxB;AACA,MAAIC,UAAU,GAAG5B,OAAO,CAAC6B,OAAR,CAAgB,GAAhB,EAAqB,CAArB,CAAjB;AAEA;;AACA,MAAIC,eAAe,GAAG,IAAtB;;AAEA,SAAOF,UAAU,KAAK,CAAC,CAAvB,EAA0B;AACzB,QAAMH,MAAM,GAAGzB,OAAO,CAACW,KAAR,CAAcgB,iBAAd,EAAiCC,UAAjC,CAAf;AAEA,QAAMG,cAAa,GAAGL,IAAI,CAACD,MAA3B;;AACA,QAAIM,cAAJ,EAAmB;AAClB,UAAID,eAAJ,EAAqB;AACpBA,QAAAA,eAAe,CAAC,CAAD,CAAf,GAAqBC,cAArB;AACAD,QAAAA,eAAe,CAAC,CAAD,CAAf,GAAqBH,iBAArB;AACA,OAHD,MAGO;AACNG,QAAAA,eAAe,GAAG,CAACC,cAAD,EAAgBJ,iBAAiB,IAAI,CAArC,CAAlB;AACA;AACD;;AAED,QAAID,IAAI,CAACF,QAAL,KAAkB,IAAtB,EAA4B,OAAOM,eAAP;AAE5B,QAAME,OAAO,GAAGN,IAAI,CAACF,QAAL,CAAcD,GAAd,CAAkBE,MAAlB,CAAhB;;AAEA,QAAI,CAACO,OAAL,EAAc;AACb,UAAMX,OAAK,GAAGK,IAAI,CAACD,MAAnB;AAEA,aAAOJ,OAAK,GAAG,CAACA,OAAD,EAAQM,iBAAR,CAAH,GAAgC,IAA5C;AACA;;AAEDD,IAAAA,IAAI,GAAGM,OAAP;AACAL,IAAAA,iBAAiB,GAAGC,UAAU,GAAG,CAAjC;AACAA,IAAAA,UAAU,GAAG5B,OAAO,CAAC6B,OAAR,CAAgB,GAAhB,EAAqBF,iBAArB,CAAb;AACA;;AAED,MAAMN,KAAK,GAAGK,IAAI,CAACJ,KAAL,CAAWC,GAAX,CACbI,iBAAiB,GAAG,CAApB,GAAwB3B,OAAO,CAACW,KAAR,CAAcgB,iBAAd,CAAxB,GAA2D3B,OAD9C,CAAd;;AAIA,MAAIqB,KAAJ,EAAW;AACV,WAAO,CAACA,KAAD,EAAQrB,OAAO,CAACU,MAAhB,CAAP;AACA;;AAED,MAAMqB,aAAa,GAAGL,IAAI,CAACD,MAA3B;;AACA,MAAIM,aAAJ,EAAmB;AAClB,WAAO,CAACA,aAAD,EAAgBJ,iBAAiB,IAAI,CAArC,CAAP;AACA;;AAED,SAAOG,eAAP;AACA;AAED;AACA;AACA;AACA;;;AACA,SAASvB,oBAAT,CAA8BF,OAA9B,EAAuC;AACtC,SACCA,OAAO,KAAK,IAAZ,IAAoB,OAAOA,OAAP,KAAmB,QAAvC,IAAmD,CAAC4B,KAAK,CAACC,OAAN,CAAc7B,OAAd,CADrD;AAGA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,aAAT,CACCJ,gBADD,EAEC0B,eAFD,EAGClC,cAHD,EAICmC,MAJD,EAKE;AACD,MAAID,eAAe,KAAK,IAAxB,EAA8B,OAAO,EAAP;AAE9B,MAAMnB,YAAY,GAAGP,gBAAgB,KAAKG,SAA1C;;AAEA,MAAI,OAAOuB,eAAP,KAA2B,QAA/B,EAAyC;AACxCC,IAAAA,MAAM,CAACD,eAAD,EAAkBnB,YAAlB,CAAN;AAEA,WAAOA,YAAY,GAChB,WAAImB,eAAJ,SAAsB1B,gBAAtB,EADgB,GAEhB,CAAC0B,eAAD,CAFH;AAGA;;AAED,MAAME,OAAO,GAAG,EAAhB;;AAbC,6CAeiBF,eAfjB;AAAA;;AAAA;AAeD,wDAAmC;AAAA,UAAxBpB,GAAwB;;AAClC,UAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC5BqB,QAAAA,MAAM,CAACrB,GAAD,EAAMC,YAAN,CAAN;AACAqB,QAAAA,OAAO,CAACC,IAAR,CAAatB,YAAY,aAAMD,GAAN,SAAYN,gBAAZ,IAAiCM,GAA1D;AACA;AACA;;AAED,UAAMV,OAAO,GAAGG,kBAAkB,CAACO,GAAD,EAAMd,cAAN,CAAlC;AACA,UAAI,CAACI,OAAL,EAAc;AACd,UAAMkC,YAAY,GAAG1B,aAAa,CACjCJ,gBADiC,EAEjCJ,OAFiC,EAGjCJ,cAHiC,EAIjCmC,MAJiC,CAAlC;;AATkC,kDAeRG,YAfQ;AAAA;;AAAA;AAelC,+DAAwC;AAAA,cAA7BC,WAA6B;AACvCH,UAAAA,OAAO,CAACC,IAAR,CAAaE,WAAb;AACA;AAjBiC;AAAA;AAAA;AAAA;AAAA;AAkBlC;AAjCA;AAAA;AAAA;AAAA;AAAA;;AAmCD,SAAOH,OAAP;AACA;AAED;AACA;AACA;AACA;AACA;;;AACA,SAAS7B,kBAAT,CAA4BiC,mBAA5B,EAAiDxC,cAAjD,EAAiE;AAChE;AACA,MAAIyC,MAAM,GAAG,CAAC,CAACD,mBAAD,EAAsBE,MAAM,CAACC,IAAP,CAAYH,mBAAZ,CAAtB,EAAwD,CAAxD,CAAD,CAAb;;AAEAI,EAAAA,IAAI,EAAE,OAAOH,MAAM,CAAChC,MAAP,GAAgB,CAAvB,EAA0B;AAC/B,iCAAiCgC,MAAM,CAACA,MAAM,CAAChC,MAAP,GAAgB,CAAjB,CAAvC;AAAA,QAAOL,OAAP;AAAA,QAAgByC,UAAhB;AAAA,QAA4BC,CAA5B;;AACA,QAAMC,IAAI,GAAGF,UAAU,CAACpC,MAAX,GAAoB,CAAjC;;AAEA,SAAK,IAAIuC,CAAC,GAAGF,CAAb,EAAgBE,CAAC,GAAGH,UAAU,CAACpC,MAA/B,EAAuCuC,CAAC,EAAxC,EAA4C;AAC3C,UAAMC,SAAS,GAAGJ,UAAU,CAACG,CAAD,CAA5B,CAD2C,CAG3C;;AACA,UAAIA,CAAC,KAAKD,IAAV,EAAgB;AACf,YAAIE,SAAS,KAAK,SAAlB,EAA6B;AAC5B,gBAAM,IAAIpC,KAAJ,CAAU,sCAAV,CAAN;AACA;AACD,OAJD,MAIO,IAAIoC,SAAS,KAAK,SAAlB,EAA6B;AACnC,YAAMC,YAAY,GAAG9C,OAAO,CAAC6C,SAAD,CAA5B,CADmC,CAEnC;;AACA,YAAI3C,oBAAoB,CAAC4C,YAAD,CAAxB,EAAwC;AACvC,cAAM3C,mBAAkB;AAAG;AAAmC2C,UAAAA,YAA9D;AACAT,UAAAA,MAAM,CAACA,MAAM,CAAChC,MAAP,GAAgB,CAAjB,CAAN,CAA0B,CAA1B,IAA+BuC,CAAC,GAAG,CAAnC;AACAP,UAAAA,MAAM,CAACJ,IAAP,CAAY,CAAC9B,mBAAD,EAAqBmC,MAAM,CAACC,IAAP,CAAYpC,mBAAZ,CAArB,EAAsD,CAAtD,CAAZ;AACA,mBAASqC,IAAT;AACA;;AAED;AAAO;AAA8BM,UAAAA;AAArC;AACA;;AAED,UAAIlD,cAAc,CAACmD,GAAf,CAAmBF,SAAnB,CAAJ,EAAmC;AAClC,YAAMC,aAAY,GAAG9C,OAAO,CAAC6C,SAAD,CAA5B,CADkC,CAElC;;AACA,YAAI3C,oBAAoB,CAAC4C,aAAD,CAAxB,EAAwC;AACvC,cAAM3C,oBAAkB;AAAG;AAAmC2C,UAAAA,aAA9D;AACAT,UAAAA,MAAM,CAACA,MAAM,CAAChC,MAAP,GAAgB,CAAjB,CAAN,CAA0B,CAA1B,IAA+BuC,CAAC,GAAG,CAAnC;AACAP,UAAAA,MAAM,CAACJ,IAAP,CAAY,CAAC9B,oBAAD,EAAqBmC,MAAM,CAACC,IAAP,CAAYpC,oBAAZ,CAArB,EAAsD,CAAtD,CAAZ;AACA,mBAASqC,IAAT;AACA;;AAED;AAAO;AAA8BM,UAAAA;AAArC;AACA;AACD;;AAEDT,IAAAA,MAAM,CAACW,GAAP;AACA;;AAED,SAAO,IAAP;AACA;AAED;AACA;AACA;AACA;AACA;;;AACA,SAASC,UAAT,GAAsB;AACrB,SAAO;AACN9B,IAAAA,QAAQ,EAAE,IADJ;AAENC,IAAAA,MAAM,EAAE,IAFF;AAGNH,IAAAA,KAAK,EAAE,IAAIiC,GAAJ;AAHD,GAAP;AAKA;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,QAAT,CAAkBC,IAAlB,EAAwBC,IAAxB,EAA8BC,MAA9B,EAAsC;AACrC,MAAID,IAAI,CAAChD,MAAL,KAAgB,CAAhB,IAAqBgD,IAAI,KAAK,IAAlC,EAAwC;AACvCD,IAAAA,IAAI,CAAChC,MAAL,GAAckC,MAAd;AACA;AACA;;AAED,MAAIjC,IAAI,GAAG+B,IAAX,CANqC,CAOrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAI9B,iBAAiB,GAAG,CAAxB,CAfqC,CAgBrC;AACA;AACA;;AACA,MAAIC,UAAU,GAAG8B,IAAI,CAAC7B,OAAL,CAAa,GAAb,EAAkB,CAAlB,CAAjB;;AAEA,SAAOD,UAAU,KAAK,CAAC,CAAvB,EAA0B;AACzB,QAAMH,MAAM,GAAGiC,IAAI,CAAC/C,KAAL,CAAWgB,iBAAX,EAA8BC,UAA9B,CAAf;AACA,QAAII,OAAO,SAAX;;AAEA,QAAIN,IAAI,CAACF,QAAL,KAAkB,IAAtB,EAA4B;AAC3BQ,MAAAA,OAAO,GAAGsB,UAAU,EAApB;AACA5B,MAAAA,IAAI,CAACF,QAAL,GAAgB,IAAI+B,GAAJ,EAAhB;AACA7B,MAAAA,IAAI,CAACF,QAAL,CAAcoC,GAAd,CAAkBnC,MAAlB,EAA0BO,OAA1B;AACA,KAJD,MAIO;AACNA,MAAAA,OAAO,GAAGN,IAAI,CAACF,QAAL,CAAcD,GAAd,CAAkBE,MAAlB,CAAV;;AAEA,UAAI,CAACO,OAAL,EAAc;AACbA,QAAAA,OAAO,GAAGsB,UAAU,EAApB;AACA5B,QAAAA,IAAI,CAACF,QAAL,CAAcoC,GAAd,CAAkBnC,MAAlB,EAA0BO,OAA1B;AACA;AACD;;AAEDN,IAAAA,IAAI,GAAGM,OAAP;AACAL,IAAAA,iBAAiB,GAAGC,UAAU,GAAG,CAAjC;AACAA,IAAAA,UAAU,GAAG8B,IAAI,CAAC7B,OAAL,CAAa,GAAb,EAAkBF,iBAAlB,CAAb;AACA;;AAED,MAAIA,iBAAiB,GAAG+B,IAAI,CAAChD,MAA7B,EAAqC;AACpCgB,IAAAA,IAAI,CAACJ,KAAL,CAAWsC,GAAX,CACCjC,iBAAiB,GAAG,CAApB,GAAwB+B,IAAI,CAAC/C,KAAL,CAAWgB,iBAAX,CAAxB,GAAwD+B,IADzD,EAECC,MAFD;AAIA,GALD,MAKO;AACNjC,IAAAA,IAAI,CAACD,MAAL,GAAckC,MAAd;AACA;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASvE,yBAAT,CAAmCyE,KAAnC,EAA0C;AACzC,MAAMJ,IAAI,GAAGH,UAAU,EAAvB,CADyC,CAGzC;;AACA,MAAI,OAAOO,KAAP,KAAiB,QAArB,EAA+B;AAC9BJ,IAAAA,IAAI,CAACnC,KAAL,CAAWsC,GAAX,CAAe,QAAf,EAAyBC,KAAzB;AAEA,WAAOJ,IAAP;AACA,GAJD,MAIO,IAAIxB,KAAK,CAACC,OAAN,CAAc2B,KAAd,CAAJ,EAA0B;AAChCJ,IAAAA,IAAI,CAACnC,KAAL,CAAWsC,GAAX,CAAe,QAAf,EAAyBC,KAAK,CAAClD,KAAN,EAAzB;AAEA,WAAO8C,IAAP;AACA;;AAED,MAAMb,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYiB,KAAZ,CAAb;;AAEA,OAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAAI,CAAClC,MAAzB,EAAiCuC,CAAC,EAAlC,EAAsC;AACrC,QAAMa,GAAG,GAAGlB,IAAI,CAACK,CAAD,CAAhB;;AAEA,QAAIa,GAAG,CAAClF,UAAJ,CAAe,CAAf,MAAsBC,OAA1B,EAAmC;AAClC;AACA,UAAIoE,CAAC,KAAK,CAAV,EAAa;AACZ,eAAOA,CAAC,GAAGL,IAAI,CAAClC,MAAhB,EAAwB;AACvB,cAAMqD,QAAQ,GAAGnB,IAAI,CAACK,CAAD,CAAJ,CAAQrE,UAAR,CAAmB,CAAnB,CAAjB;;AACA,cAAImF,QAAQ,KAAKlF,OAAb,IAAwBkF,QAAQ,KAAKpF,SAAzC,EAAoD;AACnD,kBAAM,IAAImC,KAAJ,gFACiEG,IAAI,CAACC,SAAL,CACrE4C,GADqE,CADjE,OAAN;AAKA;;AACDb,UAAAA,CAAC;AACD;;AAEDQ,QAAAA,IAAI,CAACnC,KAAL,CAAWsC,GAAX,CAAe,QAAf,EAAyBC,KAAzB;AACA,eAAOJ,IAAP;AACA;;AAED,YAAM,IAAI3C,KAAJ,gFACiEG,IAAI,CAACC,SAAL,CACrE4C,GADqE,CADjE,OAAN;AAKA;;AAED,QAAIA,GAAG,CAACpD,MAAJ,KAAe,CAAnB,EAAsB;AACrB+C,MAAAA,IAAI,CAACnC,KAAL,CAAWsC,GAAX,CAAe,QAAf,EAAyBC,KAAK,CAACC,GAAD,CAA9B;AACA;AACA;;AAED,QAAIA,GAAG,CAAClF,UAAJ,CAAe,CAAf,MAAsBD,SAA1B,EAAqC;AACpC,YAAM,IAAImC,KAAJ,iFACkEG,IAAI,CAACC,SAAL,CACtE4C,GADsE,CADlE,OAAN;AAKA;;AAEDN,IAAAA,QAAQ,CAACC,IAAD,EAAOK,GAAP,EAAYD,KAAK,CAACC,GAAD,CAAjB,CAAR;AACA;;AAED,SAAOL,IAAP;AACA;AAED;AACA;AACA;AACA;;;AACA,SAAShE,yBAAT,CAAmCoE,KAAnC,EAA0C;AACzC,MAAMJ,IAAI,GAAGH,UAAU,EAAvB;AAEA,MAAMV,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAYiB,KAAZ,CAAb;;AAEA,OAAK,IAAIZ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,IAAI,CAAClC,MAAzB,EAAiCuC,CAAC,EAAlC,EAAsC;AACrC,QAAMa,GAAG,GAAGlB,IAAI,CAACK,CAAD,CAAhB;;AAEA,QAAIa,GAAG,CAAClF,UAAJ,CAAe,CAAf,MAAsBE,QAA1B,EAAoC;AACnC,YAAM,IAAIgC,KAAJ,2DAC4CG,IAAI,CAACC,SAAL,CAAe4C,GAAf,CAD5C,OAAN;AAGA;;AAED,QAAIA,GAAG,CAACpD,MAAJ,KAAe,CAAnB,EAAsB;AACrB,YAAM,IAAII,KAAJ,qEACwDG,IAAI,CAACC,SAAL,CAC5D4C,GAD4D,CADxD,OAAN;AAKA;;AAED,QAAIA,GAAG,CAAClF,UAAJ,CAAe,CAAf,MAAsBD,SAA1B,EAAqC;AACpC,YAAM,IAAImC,KAAJ,gEACiDG,IAAI,CAACC,SAAL,CACrD4C,GADqD,CADjD,OAAN;AAKA;;AAEDN,IAAAA,QAAQ,CAACC,IAAD,EAAOK,GAAP,EAAYD,KAAK,CAACC,GAAD,CAAjB,CAAR;AACA;;AAED,SAAOL,IAAP;AACA","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\n/** @typedef {string|(string|ConditionalMapping)[]} DirectMapping */\n/** @typedef {{[k: string]: MappingValue}} ConditionalMapping */\n/** @typedef {ConditionalMapping|DirectMapping|null} MappingValue */\n/** @typedef {Record<string, MappingValue>|ConditionalMapping|DirectMapping} ExportsField */\n/** @typedef {Record<string, MappingValue>} ImportsField */\n\n/**\n * @typedef {Object} PathTreeNode\n * @property {Map<string, PathTreeNode>|null} children\n * @property {MappingValue} folder\n * @property {Map<string, MappingValue>} files\n */\n\n/**\n * Processing exports/imports field\n * @callback FieldProcessor\n * @param {string} request request\n * @param {Set<string>} conditionNames condition names\n * @returns {string[]} resolved paths\n */\n\n/*\nExample exports field:\n{\n  \".\": \"./main.js\",\n  \"./feature\": {\n    \"browser\": \"./feature-browser.js\",\n    \"default\": \"./feature.js\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\".\" and \"./feature\") as exports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n----------\n\nExample imports field:\n{\n  \"#a\": \"./main.js\",\n  \"#moment\": {\n    \"browser\": \"./moment/index.js\",\n    \"default\": \"moment\"\n  },\n  \"#moment/\": {\n    \"browser\": \"./moment/\",\n    \"default\": \"moment/\"\n  }\n}\nTerminology:\n\nEnhanced-resolve name keys (\"#a\" and \"#moment/\", \"#moment\") as imports field keys.\n\nIf value is string or string[], mapping is called as a direct mapping\nand value called as a direct export.\n\nIf value is key-value object, mapping is called as a conditional mapping\nand value called as a conditional export.\n\nKey in conditional mapping is called condition name.\n\nConditional mapping nested in another conditional mapping is called nested mapping.\n\n*/\n\nconst slashCode = \"/\".charCodeAt(0);\nconst dotCode = \".\".charCodeAt(0);\nconst hashCode = \"#\".charCodeAt(0);\n\n/**\n * @param {ExportsField} exportsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processExportsField = function processExportsField(\n\texportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildExportsFieldPathTree(exportsField),\n\t\tassertExportsFieldRequest,\n\t\tassertExportTarget\n\t);\n};\n\n/**\n * @param {ImportsField} importsField the exports field\n * @returns {FieldProcessor} process callback\n */\nmodule.exports.processImportsField = function processImportsField(\n\timportsField\n) {\n\treturn createFieldProcessor(\n\t\tbuildImportsFieldPathTree(importsField),\n\t\tassertImportsFieldRequest,\n\t\tassertImportTarget\n\t);\n};\n\n/**\n * @param {PathTreeNode} treeRoot root\n * @param {(s: string) => void} assertRequest assertRequest\n * @param {(s: string, f: boolean) => void} assertTarget assertTarget\n * @returns {FieldProcessor} field processor\n */\nfunction createFieldProcessor(treeRoot, assertRequest, assertTarget) {\n\treturn function fieldProcessor(request, conditionNames) {\n\t\tassertRequest(request);\n\n\t\tconst match = findMatch(request, treeRoot);\n\n\t\tif (match === null) return [];\n\n\t\t/** @type {DirectMapping|null} */\n\t\tlet direct = null;\n\t\tconst [mapping, remainRequestIndex] = match;\n\n\t\tif (isConditionalMapping(mapping)) {\n\t\t\tdirect = conditionalMapping(\n\t\t\t\t/** @type {ConditionalMapping} */ (mapping),\n\t\t\t\tconditionNames\n\t\t\t);\n\n\t\t\t// matching not found\n\t\t\tif (direct === null) return [];\n\t\t} else {\n\t\t\tdirect = /** @type {DirectMapping} */ (mapping);\n\t\t}\n\n\t\tconst remainingRequest =\n\t\t\tremainRequestIndex !== request.length\n\t\t\t\t? request.slice(remainRequestIndex)\n\t\t\t\t: undefined;\n\n\t\treturn directMapping(\n\t\t\tremainingRequest,\n\t\t\tdirect,\n\t\t\tconditionNames,\n\t\t\tassertTarget\n\t\t);\n\t};\n}\n\n/**\n * @param {string} request request\n */\nfunction assertExportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== dotCode) {\n\t\tthrow new Error('Request should be relative path and start with \".\"');\n\t}\n\tif (request.length === 1) return;\n\tif (request.charCodeAt(1) !== slashCode) {\n\t\tthrow new Error('Request should be relative path and start with \"./\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n}\n\n/**\n * @param {string} request request\n */\nfunction assertImportsFieldRequest(request) {\n\tif (request.charCodeAt(0) !== hashCode) {\n\t\tthrow new Error('Request should start with \"#\"');\n\t}\n\tif (request.length === 1) {\n\t\tthrow new Error(\"Request should have at least 2 characters\");\n\t}\n\tif (request.charCodeAt(1) === slashCode) {\n\t\tthrow new Error('Request should not start with \"#/\"');\n\t}\n\tif (request.charCodeAt(request.length - 1) === slashCode) {\n\t\tthrow new Error(\"Only requesting file allowed\");\n\t}\n}\n\n/**\n * @param {string} exp export target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertExportTarget(exp, expectFolder) {\n\tif (\n\t\texp.charCodeAt(0) === slashCode ||\n\t\t(exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode)\n\t) {\n\t\tthrow new Error(\n\t\t\t`Export should be relative path and start with \"./\", got ${JSON.stringify(\n\t\t\t\texp\n\t\t\t)}.`\n\t\t);\n\t}\n\n\tconst isFolder = exp.charCodeAt(exp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\texp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * @param {string} imp import target\n * @param {boolean} expectFolder is folder expected\n */\nfunction assertImportTarget(imp, expectFolder) {\n\tconst isFolder = imp.charCodeAt(imp.length - 1) === slashCode;\n\n\tif (isFolder !== expectFolder) {\n\t\tthrow new Error(\n\t\t\texpectFolder\n\t\t\t\t? `Expecting folder to folder mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should end with \"/\"`\n\t\t\t\t: `Expecting file to file mapping. ${JSON.stringify(\n\t\t\t\t\t\timp\n\t\t\t\t  )} should not end with \"/\"`\n\t\t);\n\t}\n}\n\n/**\n * Trying to match request to field\n * @param {string} request request\n * @param {PathTreeNode} treeRoot path tree root\n * @returns {[MappingValue, number]|null} match or null\n */\nfunction findMatch(request, treeRoot) {\n\tif (request.length === 1) {\n\t\tconst value = treeRoot.files.get(\"*root*\");\n\n\t\treturn value ? [value, 1] : null;\n\t}\n\n\tif (treeRoot.children === null && treeRoot.folder === null) {\n\t\tconst value = treeRoot.files.get(request);\n\n\t\treturn value ? [value, request.length] : null;\n\t}\n\n\tlet node = treeRoot;\n\tlet lastNonSlashIndex = 0;\n\tlet slashIndex = request.indexOf(\"/\", 2);\n\n\t/** @type {[MappingValue, number]|null} */\n\tlet lastFolderMatch = null;\n\n\twhile (slashIndex !== -1) {\n\t\tconst folder = request.slice(lastNonSlashIndex, slashIndex);\n\n\t\tconst folderMapping = node.folder;\n\t\tif (folderMapping) {\n\t\t\tif (lastFolderMatch) {\n\t\t\t\tlastFolderMatch[0] = folderMapping;\n\t\t\t\tlastFolderMatch[1] = lastNonSlashIndex;\n\t\t\t} else {\n\t\t\t\tlastFolderMatch = [folderMapping, lastNonSlashIndex || 2];\n\t\t\t}\n\t\t}\n\n\t\tif (node.children === null) return lastFolderMatch;\n\n\t\tconst newNode = node.children.get(folder);\n\n\t\tif (!newNode) {\n\t\t\tconst value = node.folder;\n\n\t\t\treturn value ? [value, lastNonSlashIndex] : null;\n\t\t}\n\n\t\tnode = newNode;\n\t\tlastNonSlashIndex = slashIndex + 1;\n\t\tslashIndex = request.indexOf(\"/\", lastNonSlashIndex);\n\t}\n\n\tconst value = node.files.get(\n\t\tlastNonSlashIndex > 0 ? request.slice(lastNonSlashIndex) : request\n\t);\n\n\tif (value) {\n\t\treturn [value, request.length];\n\t}\n\n\tconst folderMapping = node.folder;\n\tif (folderMapping) {\n\t\treturn [folderMapping, lastNonSlashIndex || 2];\n\t}\n\n\treturn lastFolderMatch;\n}\n\n/**\n * @param {ConditionalMapping|DirectMapping|null} mapping mapping\n * @returns {boolean} is conditional mapping\n */\nfunction isConditionalMapping(mapping) {\n\treturn (\n\t\tmapping !== null && typeof mapping === \"object\" && !Array.isArray(mapping)\n\t);\n}\n\n/**\n * @param {string|undefined} remainingRequest remaining request when folder mapping, undefined for file mappings\n * @param {DirectMapping|null} dirrectMapping_ direct export\n * @param {Set<string>} conditionNames condition names\n * @param {(d: string, f: boolean) => void} assert asserting direct value\n * @returns {string[]} mapping result\n */\nfunction directMapping(\n\tremainingRequest,\n\tdirrectMapping_,\n\tconditionNames,\n\tassert\n) {\n\tif (dirrectMapping_ === null) return [];\n\n\tconst expectFolder = remainingRequest !== undefined;\n\n\tif (typeof dirrectMapping_ === \"string\") {\n\t\tassert(dirrectMapping_, expectFolder);\n\n\t\treturn expectFolder\n\t\t\t? [`${dirrectMapping_}${remainingRequest}`]\n\t\t\t: [dirrectMapping_];\n\t}\n\n\tconst targets = [];\n\n\tfor (const exp of dirrectMapping_) {\n\t\tif (typeof exp === \"string\") {\n\t\t\tassert(exp, expectFolder);\n\t\t\ttargets.push(expectFolder ? `${exp}${remainingRequest}` : exp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst mapping = conditionalMapping(exp, conditionNames);\n\t\tif (!mapping) continue;\n\t\tconst innerExports = directMapping(\n\t\t\tremainingRequest,\n\t\t\tmapping,\n\t\t\tconditionNames,\n\t\t\tassert\n\t\t);\n\t\tfor (const innerExport of innerExports) {\n\t\t\ttargets.push(innerExport);\n\t\t}\n\t}\n\n\treturn targets;\n}\n\n/**\n * @param {ConditionalMapping} conditionalMapping_ conditional mapping\n * @param {Set<string>} conditionNames condition names\n * @returns {DirectMapping|null} direct mapping if found\n */\nfunction conditionalMapping(conditionalMapping_, conditionNames) {\n\t/** @type {[ConditionalMapping, string[], number][]} */\n\tlet lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];\n\n\tloop: while (lookup.length > 0) {\n\t\tconst [mapping, conditions, j] = lookup[lookup.length - 1];\n\t\tconst last = conditions.length - 1;\n\n\t\tfor (let i = j; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\n\t\t\t// assert default. Could be last only\n\t\t\tif (i !== last) {\n\t\t\t\tif (condition === \"default\") {\n\t\t\t\t\tthrow new Error(\"Default condition should be last one\");\n\t\t\t\t}\n\t\t\t} else if (condition === \"default\") {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (innerMapping);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\n\t\t\tif (conditionNames.has(condition)) {\n\t\t\t\tconst innerMapping = mapping[condition];\n\t\t\t\t// is nested\n\t\t\t\tif (isConditionalMapping(innerMapping)) {\n\t\t\t\t\tconst conditionalMapping = /** @type {ConditionalMapping} */ (innerMapping);\n\t\t\t\t\tlookup[lookup.length - 1][2] = i + 1;\n\t\t\t\t\tlookup.push([conditionalMapping, Object.keys(conditionalMapping), 0]);\n\t\t\t\t\tcontinue loop;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {DirectMapping} */ (innerMapping);\n\t\t\t}\n\t\t}\n\n\t\tlookup.pop();\n\t}\n\n\treturn null;\n}\n\n/**\n * Internal helper to create path tree node\n * to ensure that each node gets the same hidden class\n * @returns {PathTreeNode} node\n */\nfunction createNode() {\n\treturn {\n\t\tchildren: null,\n\t\tfolder: null,\n\t\tfiles: new Map()\n\t};\n}\n\n/**\n * Internal helper for building path tree\n * @param {PathTreeNode} root root\n * @param {string} path path\n * @param {MappingValue} target target\n */\nfunction walkPath(root, path, target) {\n\tif (path.length === 2 && path === \"./\") {\n\t\troot.folder = target;\n\t\treturn;\n\t}\n\n\tlet node = root;\n\t// It is safe to store # and ./ as a part of file\n\t// because mapping works like string concatenation\n\t// so typical path tree can looks like\n\t// root\n\t// - files: [\"./a.js\", \"./b.js\"]\n\t// - children:\n\t//    node1:\n\t//    - files: [\"a.js\", \"b.js\"]\n\tlet lastNonSlashIndex = 0;\n\t// This is safe for \"imports\" field\n\t// since specifiers \"#\" and \"#/\" are disallowed and\n\t// should be asserted before \"walking\"\n\tlet slashIndex = path.indexOf(\"/\", 2);\n\n\twhile (slashIndex !== -1) {\n\t\tconst folder = path.slice(lastNonSlashIndex, slashIndex);\n\t\tlet newNode;\n\n\t\tif (node.children === null) {\n\t\t\tnewNode = createNode();\n\t\t\tnode.children = new Map();\n\t\t\tnode.children.set(folder, newNode);\n\t\t} else {\n\t\t\tnewNode = node.children.get(folder);\n\n\t\t\tif (!newNode) {\n\t\t\t\tnewNode = createNode();\n\t\t\t\tnode.children.set(folder, newNode);\n\t\t\t}\n\t\t}\n\n\t\tnode = newNode;\n\t\tlastNonSlashIndex = slashIndex + 1;\n\t\tslashIndex = path.indexOf(\"/\", lastNonSlashIndex);\n\t}\n\n\tif (lastNonSlashIndex < path.length) {\n\t\tnode.files.set(\n\t\t\tlastNonSlashIndex > 0 ? path.slice(lastNonSlashIndex) : path,\n\t\t\ttarget\n\t\t);\n\t} else {\n\t\tnode.folder = target;\n\t}\n}\n\n/**\n * @param {ExportsField} field exports field\n * @returns {PathTreeNode} tree root\n */\nfunction buildExportsFieldPathTree(field) {\n\tconst root = createNode();\n\n\t// handle syntax sugar, if exports field is direct mapping for \".\"\n\tif (typeof field === \"string\") {\n\t\troot.files.set(\"*root*\", field);\n\n\t\treturn root;\n\t} else if (Array.isArray(field)) {\n\t\troot.files.set(\"*root*\", field.slice());\n\n\t\treturn root;\n\t}\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== dotCode) {\n\t\t\t// handle syntax sugar, if exports field is conditional mapping for \".\"\n\t\t\tif (i === 0) {\n\t\t\t\twhile (i < keys.length) {\n\t\t\t\t\tconst charCode = keys[i].charCodeAt(0);\n\t\t\t\t\tif (charCode === dotCode || charCode === slashCode) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\ti++;\n\t\t\t\t}\n\n\t\t\t\troot.files.set(\"*root*\", field);\n\t\t\t\treturn root;\n\t\t\t}\n\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \".\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\troot.files.set(\"*root*\", field[key]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key.charCodeAt(1) !== slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Exports field key should be relative path and start with \"./\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\twalkPath(root, key, field[key]);\n\t}\n\n\treturn root;\n}\n\n/**\n * @param {ImportsField} field imports field\n * @returns {PathTreeNode} root\n */\nfunction buildImportsFieldPathTree(field) {\n\tconst root = createNode();\n\n\tconst keys = Object.keys(field);\n\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key = keys[i];\n\n\t\tif (key.charCodeAt(0) !== hashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should start with \"#\" (key: ${JSON.stringify(key)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should have at least 2 characters (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\tif (key.charCodeAt(1) === slashCode) {\n\t\t\tthrow new Error(\n\t\t\t\t`Imports field key should not start with \"#/\" (key: ${JSON.stringify(\n\t\t\t\t\tkey\n\t\t\t\t)})`\n\t\t\t);\n\t\t}\n\n\t\twalkPath(root, key, field[key]);\n\t}\n\n\treturn root;\n}\n"]},"metadata":{},"sourceType":"script"}