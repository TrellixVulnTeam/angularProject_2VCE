{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar SAXParser = require('parse5-sax-parser');\n\nvar _require = require('parse5/lib/serializer'),\n    escapeString = _require.escapeString;\n\nvar RewritingStream = /*#__PURE__*/function (_SAXParser) {\n  _inherits(RewritingStream, _SAXParser);\n\n  var _super = _createSuper(RewritingStream);\n\n  function RewritingStream() {\n    var _this;\n\n    _classCallCheck(this, RewritingStream);\n\n    _this = _super.call(this, {\n      sourceCodeLocationInfo: true\n    });\n    _this.posTracker = _this.locInfoMixin.posTracker;\n    return _this;\n  }\n\n  _createClass(RewritingStream, [{\n    key: \"_transformChunk\",\n    value: function _transformChunk(chunk) {\n      // NOTE: ignore upstream return value as we want to push to\n      // the Writable part of Transform stream ourselves.\n      _get(_getPrototypeOf(RewritingStream.prototype), \"_transformChunk\", this).call(this, chunk);\n    }\n  }, {\n    key: \"_getRawHtml\",\n    value: function _getRawHtml(location) {\n      var droppedBufferSize = this.posTracker.droppedBufferSize;\n      var start = location.startOffset - droppedBufferSize;\n      var end = location.endOffset - droppedBufferSize;\n      return this.tokenizer.preprocessor.html.slice(start, end);\n    } // Events\n\n  }, {\n    key: \"_handleToken\",\n    value: function _handleToken(token) {\n      if (!_get(_getPrototypeOf(RewritingStream.prototype), \"_handleToken\", this).call(this, token)) {\n        this.emitRaw(this._getRawHtml(token.location));\n      } // NOTE: don't skip new lines after <pre> and other tags,\n      // otherwise we'll have incorrect raw data.\n\n\n      this.parserFeedbackSimulator.skipNextNewLine = false;\n    } // Emitter API\n\n  }, {\n    key: \"_emitToken\",\n    value: function _emitToken(eventName, token) {\n      this.emit(eventName, token, this._getRawHtml(token.sourceCodeLocation));\n    }\n  }, {\n    key: \"emitDoctype\",\n    value: function emitDoctype(token) {\n      var res = \"<!DOCTYPE \".concat(token.name);\n\n      if (token.publicId !== null) {\n        res += \" PUBLIC \\\"\".concat(token.publicId, \"\\\"\");\n      } else if (token.systemId !== null) {\n        res += ' SYSTEM';\n      }\n\n      if (token.systemId !== null) {\n        res += \" \\\"\".concat(token.systemId, \"\\\"\");\n      }\n\n      res += '>';\n      this.push(res);\n    }\n  }, {\n    key: \"emitStartTag\",\n    value: function emitStartTag(token) {\n      var res = \"<\".concat(token.tagName);\n      var attrs = token.attrs;\n\n      for (var i = 0; i < attrs.length; i++) {\n        res += \" \".concat(attrs[i].name, \"=\\\"\").concat(escapeString(attrs[i].value, true), \"\\\"\");\n      }\n\n      res += token.selfClosing ? '/>' : '>';\n      this.push(res);\n    }\n  }, {\n    key: \"emitEndTag\",\n    value: function emitEndTag(token) {\n      this.push(\"</\".concat(token.tagName, \">\"));\n    }\n  }, {\n    key: \"emitText\",\n    value: function emitText(_ref) {\n      var text = _ref.text;\n      this.push(escapeString(text, false));\n    }\n  }, {\n    key: \"emitComment\",\n    value: function emitComment(token) {\n      this.push(\"<!--\".concat(token.text, \"-->\"));\n    }\n  }, {\n    key: \"emitRaw\",\n    value: function emitRaw(html) {\n      this.push(html);\n    }\n  }]);\n\n  return RewritingStream;\n}(SAXParser);\n\nmodule.exports = RewritingStream;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/parse5-html-rewriting-stream/lib/index.js"],"names":["SAXParser","require","escapeString","RewritingStream","sourceCodeLocationInfo","posTracker","locInfoMixin","chunk","location","droppedBufferSize","start","startOffset","end","endOffset","tokenizer","preprocessor","html","slice","token","emitRaw","_getRawHtml","parserFeedbackSimulator","skipNextNewLine","eventName","emit","sourceCodeLocation","res","name","publicId","systemId","push","tagName","attrs","i","length","value","selfClosing","text","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst SAXParser = require('parse5-sax-parser');\nconst { escapeString } = require('parse5/lib/serializer');\n\nclass RewritingStream extends SAXParser {\n    constructor() {\n        super({ sourceCodeLocationInfo: true });\n\n        this.posTracker = this.locInfoMixin.posTracker;\n    }\n\n    _transformChunk(chunk) {\n        // NOTE: ignore upstream return value as we want to push to\n        // the Writable part of Transform stream ourselves.\n        super._transformChunk(chunk);\n    }\n\n    _getRawHtml(location) {\n        const droppedBufferSize = this.posTracker.droppedBufferSize;\n        const start = location.startOffset - droppedBufferSize;\n        const end = location.endOffset - droppedBufferSize;\n\n        return this.tokenizer.preprocessor.html.slice(start, end);\n    }\n\n    // Events\n    _handleToken(token) {\n        if (!super._handleToken(token)) {\n            this.emitRaw(this._getRawHtml(token.location));\n        }\n\n        // NOTE: don't skip new lines after <pre> and other tags,\n        // otherwise we'll have incorrect raw data.\n        this.parserFeedbackSimulator.skipNextNewLine = false;\n    }\n\n    // Emitter API\n    _emitToken(eventName, token) {\n        this.emit(eventName, token, this._getRawHtml(token.sourceCodeLocation));\n    }\n\n    emitDoctype(token) {\n        let res = `<!DOCTYPE ${token.name}`;\n\n        if (token.publicId !== null) {\n            res += ` PUBLIC \"${token.publicId}\"`;\n        } else if (token.systemId !== null) {\n            res += ' SYSTEM';\n        }\n\n        if (token.systemId !== null) {\n            res += ` \"${token.systemId}\"`;\n        }\n\n        res += '>';\n\n        this.push(res);\n    }\n\n    emitStartTag(token) {\n        let res = `<${token.tagName}`;\n\n        const attrs = token.attrs;\n\n        for (let i = 0; i < attrs.length; i++) {\n            res += ` ${attrs[i].name}=\"${escapeString(attrs[i].value, true)}\"`;\n        }\n\n        res += token.selfClosing ? '/>' : '>';\n\n        this.push(res);\n    }\n\n    emitEndTag(token) {\n        this.push(`</${token.tagName}>`);\n    }\n\n    emitText({ text }) {\n        this.push(escapeString(text, false));\n    }\n\n    emitComment(token) {\n        this.push(`<!--${token.text}-->`);\n    }\n\n    emitRaw(html) {\n        this.push(html);\n    }\n}\n\nmodule.exports = RewritingStream;\n"]},"metadata":{},"sourceType":"script"}