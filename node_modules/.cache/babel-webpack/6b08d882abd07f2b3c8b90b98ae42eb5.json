{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/metadata/symbols\", [\"require\", \"exports\", \"tslib\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Symbols = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var Symbols =\n  /** @class */\n  function () {\n    function Symbols(sourceFile) {\n      this.sourceFile = sourceFile;\n      this.references = new Map();\n    }\n\n    Symbols.prototype.resolve = function (name, preferReference) {\n      return preferReference && this.references.get(name) || this.symbols.get(name);\n    };\n\n    Symbols.prototype.define = function (name, value) {\n      this.symbols.set(name, value);\n    };\n\n    Symbols.prototype.defineReference = function (name, value) {\n      this.references.set(name, value);\n    };\n\n    Symbols.prototype.has = function (name) {\n      return this.symbols.has(name);\n    };\n\n    Object.defineProperty(Symbols.prototype, \"symbols\", {\n      get: function get() {\n        var result = this._symbols;\n\n        if (!result) {\n          result = this._symbols = new Map();\n          populateBuiltins(result);\n          this.buildImports();\n        }\n\n        return result;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    Symbols.prototype.buildImports = function () {\n      var _this = this;\n\n      var symbols = this._symbols; // Collect the imported symbols into this.symbols\n\n      var stripQuotes = function stripQuotes(s) {\n        return s.replace(/^['\"]|['\"]$/g, '');\n      };\n\n      var visit = function visit(node) {\n        var e_1, _a;\n\n        switch (node.kind) {\n          case ts.SyntaxKind.ImportEqualsDeclaration:\n            var importEqualsDeclaration = node;\n\n            if (importEqualsDeclaration.moduleReference.kind === ts.SyntaxKind.ExternalModuleReference) {\n              var externalReference = importEqualsDeclaration.moduleReference;\n\n              if (externalReference.expression) {\n                // An `import <identifier> = require(<module-specifier>);\n                if (!externalReference.expression.parent) {\n                  // The `parent` field of a node is set by the TypeScript binder (run as\n                  // part of the type checker). Setting it here allows us to call `getText()`\n                  // even if the `SourceFile` was not type checked (which looks for `SourceFile`\n                  // in the parent chain). This doesn't damage the node as the binder unconditionally\n                  // sets the parent.\n                  externalReference.expression.parent = externalReference;\n                  externalReference.parent = _this.sourceFile;\n                }\n\n                var from_1 = stripQuotes(externalReference.expression.getText());\n                symbols.set(importEqualsDeclaration.name.text, {\n                  __symbolic: 'reference',\n                  module: from_1\n                });\n                break;\n              }\n            }\n\n            symbols.set(importEqualsDeclaration.name.text, {\n              __symbolic: 'error',\n              message: \"Unsupported import syntax\"\n            });\n            break;\n\n          case ts.SyntaxKind.ImportDeclaration:\n            var importDecl = node;\n\n            if (!importDecl.importClause) {\n              // An `import <module-specifier>` clause which does not bring symbols into scope.\n              break;\n            }\n\n            if (!importDecl.moduleSpecifier.parent) {\n              // See note above in the `ImportEqualDeclaration` case.\n              importDecl.moduleSpecifier.parent = importDecl;\n              importDecl.parent = _this.sourceFile;\n            }\n\n            var from = stripQuotes(importDecl.moduleSpecifier.getText());\n\n            if (importDecl.importClause.name) {\n              // An `import <identifier> form <module-specifier>` clause. Record the default symbol.\n              symbols.set(importDecl.importClause.name.text, {\n                __symbolic: 'reference',\n                module: from,\n                default: true\n              });\n            }\n\n            var bindings = importDecl.importClause.namedBindings;\n\n            if (bindings) {\n              switch (bindings.kind) {\n                case ts.SyntaxKind.NamedImports:\n                  try {\n                    // An `import { [<identifier> [, <identifier>] } from <module-specifier>` clause\n                    for (var _b = tslib_1.__values(bindings.elements), _c = _b.next(); !_c.done; _c = _b.next()) {\n                      var binding = _c.value;\n                      symbols.set(binding.name.text, {\n                        __symbolic: 'reference',\n                        module: from,\n                        name: binding.propertyName ? binding.propertyName.text : binding.name.text\n                      });\n                    }\n                  } catch (e_1_1) {\n                    e_1 = {\n                      error: e_1_1\n                    };\n                  } finally {\n                    try {\n                      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                    } finally {\n                      if (e_1) throw e_1.error;\n                    }\n                  }\n\n                  break;\n\n                case ts.SyntaxKind.NamespaceImport:\n                  // An `input * as <identifier> from <module-specifier>` clause.\n                  symbols.set(bindings.name.text, {\n                    __symbolic: 'reference',\n                    module: from\n                  });\n                  break;\n              }\n            }\n\n            break;\n        }\n\n        ts.forEachChild(node, visit);\n      };\n\n      if (this.sourceFile) {\n        ts.forEachChild(this.sourceFile, visit);\n      }\n    };\n\n    return Symbols;\n  }();\n\n  exports.Symbols = Symbols;\n\n  function populateBuiltins(symbols) {\n    // From lib.core.d.ts (all \"define const\")\n    ['Object', 'Function', 'String', 'Number', 'Array', 'Boolean', 'Map', 'NaN', 'Infinity', 'Math', 'Date', 'RegExp', 'Error', 'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError', 'TypeError', 'URIError', 'JSON', 'ArrayBuffer', 'DataView', 'Int8Array', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Int16Array', 'Int32Array', 'Uint32Array', 'Float32Array', 'Float64Array'].forEach(function (name) {\n      return symbols.set(name, {\n        __symbolic: 'reference',\n        name: name\n      });\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/metadata/symbols.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {MetadataSymbolicReferenceExpression, MetadataValue} from './schema';\n\nexport class Symbols {\n  // TODO(issue/24571): remove '!'.\n  private _symbols!: Map<string, MetadataValue>;\n  private references = new Map<string, MetadataSymbolicReferenceExpression>();\n\n  constructor(private sourceFile: ts.SourceFile) {}\n\n  resolve(name: string, preferReference?: boolean): MetadataValue|undefined {\n    return (preferReference && this.references.get(name)) || this.symbols.get(name);\n  }\n\n  define(name: string, value: MetadataValue) {\n    this.symbols.set(name, value);\n  }\n  defineReference(name: string, value: MetadataSymbolicReferenceExpression) {\n    this.references.set(name, value);\n  }\n\n  has(name: string): boolean {\n    return this.symbols.has(name);\n  }\n\n  private get symbols(): Map<string, MetadataValue> {\n    let result = this._symbols;\n    if (!result) {\n      result = this._symbols = new Map<string, MetadataValue>();\n      populateBuiltins(result);\n      this.buildImports();\n    }\n    return result;\n  }\n\n  private buildImports(): void {\n    const symbols = this._symbols;\n    // Collect the imported symbols into this.symbols\n    const stripQuotes = (s: string) => s.replace(/^['\"]|['\"]$/g, '');\n    const visit = (node: ts.Node) => {\n      switch (node.kind) {\n        case ts.SyntaxKind.ImportEqualsDeclaration:\n          const importEqualsDeclaration = <ts.ImportEqualsDeclaration>node;\n          if (importEqualsDeclaration.moduleReference.kind ===\n              ts.SyntaxKind.ExternalModuleReference) {\n            const externalReference =\n                <ts.ExternalModuleReference>importEqualsDeclaration.moduleReference;\n            if (externalReference.expression) {\n              // An `import <identifier> = require(<module-specifier>);\n              if (!externalReference.expression.parent) {\n                // The `parent` field of a node is set by the TypeScript binder (run as\n                // part of the type checker). Setting it here allows us to call `getText()`\n                // even if the `SourceFile` was not type checked (which looks for `SourceFile`\n                // in the parent chain). This doesn't damage the node as the binder unconditionally\n                // sets the parent.\n                (externalReference.expression.parent as ts.Node) = externalReference;\n                (externalReference.parent as ts.Node) = this.sourceFile;\n              }\n              const from = stripQuotes(externalReference.expression.getText());\n              symbols.set(\n                  importEqualsDeclaration.name.text, {__symbolic: 'reference', module: from});\n              break;\n            }\n          }\n          symbols.set(\n              importEqualsDeclaration.name.text,\n              {__symbolic: 'error', message: `Unsupported import syntax`});\n          break;\n        case ts.SyntaxKind.ImportDeclaration:\n          const importDecl = <ts.ImportDeclaration>node;\n          if (!importDecl.importClause) {\n            // An `import <module-specifier>` clause which does not bring symbols into scope.\n            break;\n          }\n          if (!importDecl.moduleSpecifier.parent) {\n            // See note above in the `ImportEqualDeclaration` case.\n            (importDecl.moduleSpecifier.parent as ts.Node) = importDecl;\n            (importDecl.parent as ts.Node) = this.sourceFile;\n          }\n          const from = stripQuotes(importDecl.moduleSpecifier.getText());\n          if (importDecl.importClause.name) {\n            // An `import <identifier> form <module-specifier>` clause. Record the default symbol.\n            symbols.set(\n                importDecl.importClause.name.text,\n                {__symbolic: 'reference', module: from, default: true});\n          }\n          const bindings = importDecl.importClause.namedBindings;\n          if (bindings) {\n            switch (bindings.kind) {\n              case ts.SyntaxKind.NamedImports:\n                // An `import { [<identifier> [, <identifier>] } from <module-specifier>` clause\n                for (const binding of (<ts.NamedImports>bindings).elements) {\n                  symbols.set(binding.name.text, {\n                    __symbolic: 'reference',\n                    module: from,\n                    name: binding.propertyName ? binding.propertyName.text : binding.name.text\n                  });\n                }\n                break;\n              case ts.SyntaxKind.NamespaceImport:\n                // An `input * as <identifier> from <module-specifier>` clause.\n                symbols.set(\n                    (<ts.NamespaceImport>bindings).name.text,\n                    {__symbolic: 'reference', module: from});\n                break;\n            }\n          }\n          break;\n      }\n      ts.forEachChild(node, visit);\n    };\n    if (this.sourceFile) {\n      ts.forEachChild(this.sourceFile, visit);\n    }\n  }\n}\n\nfunction populateBuiltins(symbols: Map<string, MetadataValue>) {\n  // From lib.core.d.ts (all \"define const\")\n  ['Object', 'Function', 'String', 'Number', 'Array', 'Boolean', 'Map', 'NaN', 'Infinity', 'Math',\n   'Date', 'RegExp', 'Error', 'Error', 'EvalError', 'RangeError', 'ReferenceError', 'SyntaxError',\n   'TypeError', 'URIError', 'JSON', 'ArrayBuffer', 'DataView', 'Int8Array', 'Uint8Array',\n   'Uint8ClampedArray', 'Uint16Array', 'Int16Array', 'Int32Array', 'Uint32Array', 'Float32Array',\n   'Float64Array']\n      .forEach(name => symbols.set(name, {__symbolic: 'reference', name}));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}