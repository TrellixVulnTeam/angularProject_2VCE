{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/routing/src/route\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.entryPointKeyFor = exports.RouterEntryPointManager = exports.RouterEntryPoint = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var RouterEntryPoint =\n  /** @class */\n  function () {\n    function RouterEntryPoint() {}\n\n    return RouterEntryPoint;\n  }();\n\n  exports.RouterEntryPoint = RouterEntryPoint;\n\n  var RouterEntryPointImpl =\n  /** @class */\n  function () {\n    function RouterEntryPointImpl(filePath, moduleName) {\n      this.filePath = filePath;\n      this.moduleName = moduleName;\n    }\n\n    Object.defineProperty(RouterEntryPointImpl.prototype, \"name\", {\n      get: function get() {\n        return this.moduleName;\n      },\n      enumerable: false,\n      configurable: true\n    }); // For debugging purposes.\n\n    RouterEntryPointImpl.prototype.toString = function () {\n      return \"RouterEntryPoint(name: \" + this.name + \", filePath: \" + this.filePath + \")\";\n    };\n\n    return RouterEntryPointImpl;\n  }();\n\n  var RouterEntryPointManager =\n  /** @class */\n  function () {\n    function RouterEntryPointManager(moduleResolver) {\n      this.moduleResolver = moduleResolver;\n      this.map = new Map();\n    }\n\n    RouterEntryPointManager.prototype.resolveLoadChildrenIdentifier = function (loadChildrenIdentifier, context) {\n      var _a = tslib_1.__read(loadChildrenIdentifier.split('#'), 2),\n          relativeFile = _a[0],\n          moduleName = _a[1];\n\n      if (moduleName === undefined) {\n        return null;\n      }\n\n      var resolvedSf = this.moduleResolver.resolveModule(relativeFile, context.fileName);\n\n      if (resolvedSf === null) {\n        return null;\n      }\n\n      return this.fromNgModule(resolvedSf, moduleName);\n    };\n\n    RouterEntryPointManager.prototype.fromNgModule = function (sf, moduleName) {\n      var key = entryPointKeyFor(sf.fileName, moduleName);\n\n      if (!this.map.has(key)) {\n        this.map.set(key, new RouterEntryPointImpl(sf.fileName, moduleName));\n      }\n\n      return this.map.get(key);\n    };\n\n    return RouterEntryPointManager;\n  }();\n\n  exports.RouterEntryPointManager = RouterEntryPointManager;\n\n  function entryPointKeyFor(filePath, moduleName) {\n    // Drop the extension to be compatible with how cli calls `listLazyRoutes(entryRoute)`.\n    return filePath.replace(/\\.tsx?$/i, '') + \"#\" + moduleName;\n  }\n\n  exports.entryPointKeyFor = entryPointKeyFor;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/routing/src/route.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAMH,MAAA,gBAAA;AAAA;AAAA,cAAA;AAAA,aAAA,gBAAA,GAAA,CAOC;;AAAD,WAAA,gBAAA;AAAC,GAPD,EAAA;;AAAsB,EAAA,OAAA,CAAA,gBAAA,GAAA,gBAAA;;AAStB,MAAA,oBAAA;AAAA;AAAA,cAAA;AACE,aAAA,oBAAA,CAAqB,QAArB,EAAgD,UAAhD,EAAkE;AAA7C,WAAA,QAAA,GAAA,QAAA;AAA2B,WAAA,UAAA,GAAA,UAAA;AAAsB;;AAEtE,IAAA,MAAA,CAAA,cAAA,CAAI,oBAAA,CAAA,SAAJ,EAAI,MAAJ,EAAQ;WAAR,eAAA;AACE,eAAO,KAAK,UAAZ;AACD,OAFO;uBAAA;;AAAA,KAAR,EAHF,CAOE;;AACA,IAAA,oBAAA,CAAA,SAAA,CAAA,QAAA,GAAA,YAAA;AACE,aAAO,4BAA0B,KAAK,IAA/B,GAAmC,cAAnC,GAAkD,KAAK,QAAvD,GAA+D,GAAtE;AACD,KAFD;;AAGF,WAAA,oBAAA;AAAC,GAXD,EAAA;;AAaA,MAAA,uBAAA;AAAA;AAAA,cAAA;AAGE,aAAA,uBAAA,CAAoB,cAApB,EAAkD;AAA9B,WAAA,cAAA,GAAA,cAAA;AAFZ,WAAA,GAAA,GAAM,IAAI,GAAJ,EAAN;AAE8C;;AAEtD,IAAA,uBAAA,CAAA,SAAA,CAAA,6BAAA,GAAA,UAA8B,sBAA9B,EAA8D,OAA9D,EAAoF;AAE5E,UAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAA6B,sBAAsB,CAAC,KAAvB,CAA6B,GAA7B,CAA7B,EAA8D,CAA9D,CAAA;AAAA,UAAC,YAAY,GAAA,EAAA,CAAA,CAAA,CAAb;AAAA,UAAe,UAAU,GAAA,EAAA,CAAA,CAAA,CAAzB;;AACN,UAAI,UAAU,KAAK,SAAnB,EAA8B;AAC5B,eAAO,IAAP;AACD;;AACD,UAAM,UAAU,GAAG,KAAK,cAAL,CAAoB,aAApB,CAAkC,YAAlC,EAAgD,OAAO,CAAC,QAAxD,CAAnB;;AACA,UAAI,UAAU,KAAK,IAAnB,EAAyB;AACvB,eAAO,IAAP;AACD;;AACD,aAAO,KAAK,YAAL,CAAkB,UAAlB,EAA8B,UAA9B,CAAP;AACD,KAXD;;AAaA,IAAA,uBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,EAAb,EAAgC,UAAhC,EAAkD;AAChD,UAAM,GAAG,GAAG,gBAAgB,CAAC,EAAE,CAAC,QAAJ,EAAc,UAAd,CAA5B;;AACA,UAAI,CAAC,KAAK,GAAL,CAAS,GAAT,CAAa,GAAb,CAAL,EAAwB;AACtB,aAAK,GAAL,CAAS,GAAT,CAAa,GAAb,EAAkB,IAAI,oBAAJ,CAAyB,EAAE,CAAC,QAA5B,EAAsC,UAAtC,CAAlB;AACD;;AACD,aAAO,KAAK,GAAL,CAAS,GAAT,CAAa,GAAb,CAAP;AACD,KAND;;AAOF,WAAA,uBAAA;AAAC,GAzBD,EAAA;;AAAa,EAAA,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AA2Bb,WAAgB,gBAAhB,CAAiC,QAAjC,EAAmD,UAAnD,EAAqE;AACnE;AACA,WAAU,QAAQ,CAAC,OAAT,CAAiB,UAAjB,EAA6B,EAA7B,IAAgC,GAAhC,GAAoC,UAA9C;AACD;;AAHD,EAAA,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ModuleResolver} from '../../imports';\n\nexport abstract class RouterEntryPoint {\n  abstract readonly filePath: string;\n\n  abstract readonly moduleName: string;\n\n  // Alias of moduleName for compatibility with what `ngtools_api` returned.\n  abstract readonly name: string;\n}\n\nclass RouterEntryPointImpl implements RouterEntryPoint {\n  constructor(readonly filePath: string, readonly moduleName: string) {}\n\n  get name(): string {\n    return this.moduleName;\n  }\n\n  // For debugging purposes.\n  toString(): string {\n    return `RouterEntryPoint(name: ${this.name}, filePath: ${this.filePath})`;\n  }\n}\n\nexport class RouterEntryPointManager {\n  private map = new Map<string, RouterEntryPoint>();\n\n  constructor(private moduleResolver: ModuleResolver) {}\n\n  resolveLoadChildrenIdentifier(loadChildrenIdentifier: string, context: ts.SourceFile):\n      RouterEntryPoint|null {\n    const [relativeFile, moduleName] = loadChildrenIdentifier.split('#');\n    if (moduleName === undefined) {\n      return null;\n    }\n    const resolvedSf = this.moduleResolver.resolveModule(relativeFile, context.fileName);\n    if (resolvedSf === null) {\n      return null;\n    }\n    return this.fromNgModule(resolvedSf, moduleName);\n  }\n\n  fromNgModule(sf: ts.SourceFile, moduleName: string): RouterEntryPoint {\n    const key = entryPointKeyFor(sf.fileName, moduleName);\n    if (!this.map.has(key)) {\n      this.map.set(key, new RouterEntryPointImpl(sf.fileName, moduleName));\n    }\n    return this.map.get(key)!;\n  }\n}\n\nexport function entryPointKeyFor(filePath: string, moduleName: string): string {\n  // Drop the extension to be compatible with how cli calls `listLazyRoutes(entryRoute)`.\n  return `${filePath.replace(/\\.tsx?$/i, '')}#${moduleName}`;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}