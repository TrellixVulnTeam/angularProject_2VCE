{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/routing/src/analyzer\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/routing/src/lazy\", \"@angular/compiler-cli/src/ngtsc/routing/src/route\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NgModuleRouteAnalyzer = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var lazy_1 = require(\"@angular/compiler-cli/src/ngtsc/routing/src/lazy\");\n\n  var route_1 = require(\"@angular/compiler-cli/src/ngtsc/routing/src/route\");\n\n  var NgModuleRouteAnalyzer =\n  /** @class */\n  function () {\n    function NgModuleRouteAnalyzer(moduleResolver, evaluator) {\n      this.evaluator = evaluator;\n      this.modules = new Map();\n      this.entryPointManager = new route_1.RouterEntryPointManager(moduleResolver);\n    }\n\n    NgModuleRouteAnalyzer.prototype.add = function (sourceFile, moduleName, imports, exports, providers) {\n      var key = route_1.entryPointKeyFor(sourceFile.fileName, moduleName);\n\n      if (this.modules.has(key)) {\n        throw new Error(\"Double route analyzing for '\" + key + \"'.\");\n      }\n\n      this.modules.set(key, {\n        sourceFile: sourceFile,\n        moduleName: moduleName,\n        imports: imports,\n        exports: exports,\n        providers: providers\n      });\n    };\n\n    NgModuleRouteAnalyzer.prototype.listLazyRoutes = function (entryModuleKey) {\n      var _this = this;\n\n      if (entryModuleKey !== undefined && !this.modules.has(entryModuleKey)) {\n        throw new Error(\"Failed to list lazy routes: Unknown module '\" + entryModuleKey + \"'.\");\n      }\n\n      var routes = [];\n      var scannedModuleKeys = new Set();\n      var pendingModuleKeys = entryModuleKey ? [entryModuleKey] : Array.from(this.modules.keys()); // When listing lazy routes for a specific entry module, we need to recursively extract\n      // \"transitive\" routes from imported/exported modules. This is not necessary when listing all\n      // lazy routes, because all analyzed modules will be scanned anyway.\n\n      var scanRecursively = entryModuleKey !== undefined;\n\n      while (pendingModuleKeys.length > 0) {\n        var key = pendingModuleKeys.pop();\n\n        if (scannedModuleKeys.has(key)) {\n          continue;\n        } else {\n          scannedModuleKeys.add(key);\n        }\n\n        var data = this.modules.get(key);\n        var entryPoints = lazy_1.scanForRouteEntryPoints(data.sourceFile, data.moduleName, data, this.entryPointManager, this.evaluator);\n        routes.push.apply(routes, tslib_1.__spread(entryPoints.map(function (entryPoint) {\n          return {\n            route: entryPoint.loadChildren,\n            module: entryPoint.from,\n            referencedModule: entryPoint.resolvedTo\n          };\n        })));\n\n        if (scanRecursively) {\n          pendingModuleKeys.push.apply(pendingModuleKeys, tslib_1.__spread(tslib_1.__spread(entryPoints.map(function (_a) {\n            var resolvedTo = _a.resolvedTo;\n            return route_1.entryPointKeyFor(resolvedTo.filePath, resolvedTo.moduleName);\n          }), lazy_1.scanForCandidateTransitiveModules(data.imports, this.evaluator), lazy_1.scanForCandidateTransitiveModules(data.exports, this.evaluator)).filter(function (key) {\n            return _this.modules.has(key);\n          })));\n        }\n      }\n\n      return routes;\n    };\n\n    return NgModuleRouteAnalyzer;\n  }();\n\n  exports.NgModuleRouteAnalyzer = NgModuleRouteAnalyzer;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/routing/src/analyzer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ModuleResolver} from '../../imports';\nimport {PartialEvaluator} from '../../partial_evaluator';\n\nimport {scanForCandidateTransitiveModules, scanForRouteEntryPoints} from './lazy';\nimport {entryPointKeyFor, RouterEntryPointManager} from './route';\n\nexport interface NgModuleRawRouteData {\n  sourceFile: ts.SourceFile;\n  moduleName: string;\n  imports: ts.Expression|null;\n  exports: ts.Expression|null;\n  providers: ts.Expression|null;\n}\n\nexport interface LazyRoute {\n  route: string;\n  module: {name: string, filePath: string};\n  referencedModule: {name: string, filePath: string};\n}\n\nexport class NgModuleRouteAnalyzer {\n  private modules = new Map<string, NgModuleRawRouteData>();\n  private entryPointManager: RouterEntryPointManager;\n\n  constructor(moduleResolver: ModuleResolver, private evaluator: PartialEvaluator) {\n    this.entryPointManager = new RouterEntryPointManager(moduleResolver);\n  }\n\n  add(sourceFile: ts.SourceFile, moduleName: string, imports: ts.Expression|null,\n      exports: ts.Expression|null, providers: ts.Expression|null): void {\n    const key = entryPointKeyFor(sourceFile.fileName, moduleName);\n    if (this.modules.has(key)) {\n      throw new Error(`Double route analyzing for '${key}'.`);\n    }\n    this.modules.set(key, {\n      sourceFile,\n      moduleName,\n      imports,\n      exports,\n      providers,\n    });\n  }\n\n  listLazyRoutes(entryModuleKey?: string|undefined): LazyRoute[] {\n    if ((entryModuleKey !== undefined) && !this.modules.has(entryModuleKey)) {\n      throw new Error(`Failed to list lazy routes: Unknown module '${entryModuleKey}'.`);\n    }\n\n    const routes: LazyRoute[] = [];\n    const scannedModuleKeys = new Set<string>();\n    const pendingModuleKeys = entryModuleKey ? [entryModuleKey] : Array.from(this.modules.keys());\n\n    // When listing lazy routes for a specific entry module, we need to recursively extract\n    // \"transitive\" routes from imported/exported modules. This is not necessary when listing all\n    // lazy routes, because all analyzed modules will be scanned anyway.\n    const scanRecursively = entryModuleKey !== undefined;\n\n    while (pendingModuleKeys.length > 0) {\n      const key = pendingModuleKeys.pop()!;\n\n      if (scannedModuleKeys.has(key)) {\n        continue;\n      } else {\n        scannedModuleKeys.add(key);\n      }\n\n      const data = this.modules.get(key)!;\n      const entryPoints = scanForRouteEntryPoints(\n          data.sourceFile, data.moduleName, data, this.entryPointManager, this.evaluator);\n\n      routes.push(...entryPoints.map(entryPoint => ({\n                                       route: entryPoint.loadChildren,\n                                       module: entryPoint.from,\n                                       referencedModule: entryPoint.resolvedTo,\n                                     })));\n\n      if (scanRecursively) {\n        pendingModuleKeys.push(\n            ...[\n                // Scan the retrieved lazy route entry points.\n                ...entryPoints.map(\n                    ({resolvedTo}) => entryPointKeyFor(resolvedTo.filePath, resolvedTo.moduleName)),\n                // Scan the current module's imported modules.\n                ...scanForCandidateTransitiveModules(data.imports, this.evaluator),\n                // Scan the current module's exported modules.\n                ...scanForCandidateTransitiveModules(data.exports, this.evaluator),\n        ].filter(key => this.modules.has(key)));\n      }\n    }\n\n    return routes;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}