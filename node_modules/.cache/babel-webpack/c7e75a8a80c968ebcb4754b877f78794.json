{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.toUnredirectedSourceFile = exports.isAssignment = exports.resolveModuleName = exports.nodeDebugInfo = exports.getRootDirs = exports.isExported = exports.isTypeDeclaration = exports.isValueDeclaration = exports.isDeclaration = exports.identifierOfNode = exports.getTokenAtPosition = exports.getSourceFileOrNull = exports.getSourceFile = exports.nodeNameForError = exports.isFromDtsFile = exports.isNonDeclarationTsPath = exports.isDtsPath = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var TS = /\\.tsx?$/i;\n  var D_TS = /\\.d\\.ts$/i;\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  function isDtsPath(filePath) {\n    return D_TS.test(filePath);\n  }\n\n  exports.isDtsPath = isDtsPath;\n\n  function isNonDeclarationTsPath(filePath) {\n    return TS.test(filePath) && !D_TS.test(filePath);\n  }\n\n  exports.isNonDeclarationTsPath = isNonDeclarationTsPath;\n\n  function isFromDtsFile(node) {\n    var sf = node.getSourceFile();\n\n    if (sf === undefined) {\n      sf = ts.getOriginalNode(node).getSourceFile();\n    }\n\n    return sf !== undefined && sf.isDeclarationFile;\n  }\n\n  exports.isFromDtsFile = isFromDtsFile;\n\n  function nodeNameForError(node) {\n    if (node.name !== undefined && ts.isIdentifier(node.name)) {\n      return node.name.text;\n    } else {\n      var kind = ts.SyntaxKind[node.kind];\n\n      var _a = ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart()),\n          line = _a.line,\n          character = _a.character;\n\n      return kind + \"@\" + line + \":\" + character;\n    }\n  }\n\n  exports.nodeNameForError = nodeNameForError;\n\n  function getSourceFile(node) {\n    // In certain transformation contexts, `ts.Node.getSourceFile()` can actually return `undefined`,\n    // despite the type signature not allowing it. In that event, get the `ts.SourceFile` via the\n    // original node instead (which works).\n    var directSf = node.getSourceFile();\n    return directSf !== undefined ? directSf : ts.getOriginalNode(node).getSourceFile();\n  }\n\n  exports.getSourceFile = getSourceFile;\n\n  function getSourceFileOrNull(program, fileName) {\n    return program.getSourceFile(fileName) || null;\n  }\n\n  exports.getSourceFileOrNull = getSourceFileOrNull;\n\n  function getTokenAtPosition(sf, pos) {\n    // getTokenAtPosition is part of TypeScript's private API.\n    return ts.getTokenAtPosition(sf, pos);\n  }\n\n  exports.getTokenAtPosition = getTokenAtPosition;\n\n  function identifierOfNode(decl) {\n    if (decl.name !== undefined && ts.isIdentifier(decl.name)) {\n      return decl.name;\n    } else {\n      return null;\n    }\n  }\n\n  exports.identifierOfNode = identifierOfNode;\n\n  function isDeclaration(node) {\n    return isValueDeclaration(node) || isTypeDeclaration(node);\n  }\n\n  exports.isDeclaration = isDeclaration;\n\n  function isValueDeclaration(node) {\n    return ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node) || ts.isVariableDeclaration(node);\n  }\n\n  exports.isValueDeclaration = isValueDeclaration;\n\n  function isTypeDeclaration(node) {\n    return ts.isEnumDeclaration(node) || ts.isTypeAliasDeclaration(node) || ts.isInterfaceDeclaration(node);\n  }\n\n  exports.isTypeDeclaration = isTypeDeclaration;\n\n  function isExported(node) {\n    var topLevel = node;\n\n    if (ts.isVariableDeclaration(node) && ts.isVariableDeclarationList(node.parent)) {\n      topLevel = node.parent.parent;\n    }\n\n    return topLevel.modifiers !== undefined && topLevel.modifiers.some(function (modifier) {\n      return modifier.kind === ts.SyntaxKind.ExportKeyword;\n    });\n  }\n\n  exports.isExported = isExported;\n\n  function getRootDirs(host, options) {\n    var rootDirs = [];\n\n    if (options.rootDirs !== undefined) {\n      rootDirs.push.apply(rootDirs, tslib_1.__spread(options.rootDirs));\n    } else if (options.rootDir !== undefined) {\n      rootDirs.push(options.rootDir);\n    } else {\n      rootDirs.push(host.getCurrentDirectory());\n    } // In Windows the above might not always return posix separated paths\n    // See:\n    // https://github.com/Microsoft/TypeScript/blob/3f7357d37f66c842d70d835bc925ec2a873ecfec/src/compiler/sys.ts#L650\n    // Also compiler options might be set via an API which doesn't normalize paths\n\n\n    return rootDirs.map(function (rootDir) {\n      return file_system_1.absoluteFrom(host.getCanonicalFileName(rootDir));\n    });\n  }\n\n  exports.getRootDirs = getRootDirs;\n\n  function nodeDebugInfo(node) {\n    var sf = getSourceFile(node);\n\n    var _a = ts.getLineAndCharacterOfPosition(sf, node.pos),\n        line = _a.line,\n        character = _a.character;\n\n    return \"[\" + sf.fileName + \": \" + ts.SyntaxKind[node.kind] + \" @ \" + line + \":\" + character + \"]\";\n  }\n\n  exports.nodeDebugInfo = nodeDebugInfo;\n  /**\n   * Resolve the specified `moduleName` using the given `compilerOptions` and `compilerHost`.\n   *\n   * This helper will attempt to use the `CompilerHost.resolveModuleNames()` method if available.\n   * Otherwise it will fallback on the `ts.ResolveModuleName()` function.\n   */\n\n  function resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache) {\n    if (compilerHost.resolveModuleNames) {\n      return compilerHost.resolveModuleNames([moduleName], containingFile, undefined, // reusedNames\n      undefined, // redirectedReference\n      compilerOptions)[0];\n    } else {\n      return ts.resolveModuleName(moduleName, containingFile, compilerOptions, compilerHost, moduleResolutionCache !== null ? moduleResolutionCache : undefined).resolvedModule;\n    }\n  }\n\n  exports.resolveModuleName = resolveModuleName;\n  /** Returns true if the node is an assignment expression. */\n\n  function isAssignment(node) {\n    return ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n  }\n\n  exports.isAssignment = isAssignment;\n  /**\n   * Obtains the non-redirected source file for `sf`.\n   */\n\n  function toUnredirectedSourceFile(sf) {\n    var redirectInfo = sf.redirectInfo;\n\n    if (redirectInfo === undefined) {\n      return sf;\n    }\n\n    return redirectInfo.unredirected;\n  }\n\n  exports.toUnredirectedSourceFile = toUnredirectedSourceFile;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/util/src/typescript.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst TS = /\\.tsx?$/i;\nconst D_TS = /\\.d\\.ts$/i;\n\nimport * as ts from 'typescript';\nimport {AbsoluteFsPath, absoluteFrom} from '../../file_system';\nimport {DeclarationNode} from '../../reflection';\n\nexport function isDtsPath(filePath: string): boolean {\n  return D_TS.test(filePath);\n}\n\nexport function isNonDeclarationTsPath(filePath: string): boolean {\n  return TS.test(filePath) && !D_TS.test(filePath);\n}\n\nexport function isFromDtsFile(node: ts.Node): boolean {\n  let sf: ts.SourceFile|undefined = node.getSourceFile();\n  if (sf === undefined) {\n    sf = ts.getOriginalNode(node).getSourceFile();\n  }\n  return sf !== undefined && sf.isDeclarationFile;\n}\n\nexport function nodeNameForError(node: ts.Node&{name?: ts.Node}): string {\n  if (node.name !== undefined && ts.isIdentifier(node.name)) {\n    return node.name.text;\n  } else {\n    const kind = ts.SyntaxKind[node.kind];\n    const {line, character} =\n        ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());\n    return `${kind}@${line}:${character}`;\n  }\n}\n\nexport function getSourceFile(node: ts.Node): ts.SourceFile {\n  // In certain transformation contexts, `ts.Node.getSourceFile()` can actually return `undefined`,\n  // despite the type signature not allowing it. In that event, get the `ts.SourceFile` via the\n  // original node instead (which works).\n  const directSf = node.getSourceFile() as ts.SourceFile | undefined;\n  return directSf !== undefined ? directSf : ts.getOriginalNode(node).getSourceFile();\n}\n\nexport function getSourceFileOrNull(program: ts.Program, fileName: AbsoluteFsPath): ts.SourceFile|\n    null {\n  return program.getSourceFile(fileName) || null;\n}\n\n\nexport function getTokenAtPosition(sf: ts.SourceFile, pos: number): ts.Node {\n  // getTokenAtPosition is part of TypeScript's private API.\n  return (ts as any).getTokenAtPosition(sf, pos);\n}\n\nexport function identifierOfNode(decl: ts.Node&{name?: ts.Node}): ts.Identifier|null {\n  if (decl.name !== undefined && ts.isIdentifier(decl.name)) {\n    return decl.name;\n  } else {\n    return null;\n  }\n}\n\nexport function isDeclaration(node: ts.Node): node is ts.Declaration {\n  return isValueDeclaration(node) || isTypeDeclaration(node);\n}\n\nexport function isValueDeclaration(node: ts.Node): node is ts.ClassDeclaration|\n    ts.FunctionDeclaration|ts.VariableDeclaration {\n  return ts.isClassDeclaration(node) || ts.isFunctionDeclaration(node) ||\n      ts.isVariableDeclaration(node);\n}\n\nexport function isTypeDeclaration(node: ts.Node): node is ts.EnumDeclaration|\n    ts.TypeAliasDeclaration|ts.InterfaceDeclaration {\n  return ts.isEnumDeclaration(node) || ts.isTypeAliasDeclaration(node) ||\n      ts.isInterfaceDeclaration(node);\n}\n\nexport function isExported(node: DeclarationNode): boolean {\n  let topLevel: ts.Node = node;\n  if (ts.isVariableDeclaration(node) && ts.isVariableDeclarationList(node.parent)) {\n    topLevel = node.parent.parent;\n  }\n  return topLevel.modifiers !== undefined &&\n      topLevel.modifiers.some(modifier => modifier.kind === ts.SyntaxKind.ExportKeyword);\n}\n\nexport function getRootDirs(\n    host: Pick<ts.CompilerHost, 'getCurrentDirectory'|'getCanonicalFileName'>,\n    options: ts.CompilerOptions): AbsoluteFsPath[] {\n  const rootDirs: string[] = [];\n  if (options.rootDirs !== undefined) {\n    rootDirs.push(...options.rootDirs);\n  } else if (options.rootDir !== undefined) {\n    rootDirs.push(options.rootDir);\n  } else {\n    rootDirs.push(host.getCurrentDirectory());\n  }\n\n  // In Windows the above might not always return posix separated paths\n  // See:\n  // https://github.com/Microsoft/TypeScript/blob/3f7357d37f66c842d70d835bc925ec2a873ecfec/src/compiler/sys.ts#L650\n  // Also compiler options might be set via an API which doesn't normalize paths\n  return rootDirs.map(rootDir => absoluteFrom(host.getCanonicalFileName(rootDir)));\n}\n\nexport function nodeDebugInfo(node: ts.Node): string {\n  const sf = getSourceFile(node);\n  const {line, character} = ts.getLineAndCharacterOfPosition(sf, node.pos);\n  return `[${sf.fileName}: ${ts.SyntaxKind[node.kind]} @ ${line}:${character}]`;\n}\n\n/**\n * Resolve the specified `moduleName` using the given `compilerOptions` and `compilerHost`.\n *\n * This helper will attempt to use the `CompilerHost.resolveModuleNames()` method if available.\n * Otherwise it will fallback on the `ts.ResolveModuleName()` function.\n */\nexport function resolveModuleName(\n    moduleName: string, containingFile: string, compilerOptions: ts.CompilerOptions,\n    compilerHost: ts.ModuleResolutionHost&Pick<ts.CompilerHost, 'resolveModuleNames'>,\n    moduleResolutionCache: ts.ModuleResolutionCache|null): ts.ResolvedModule|undefined {\n  if (compilerHost.resolveModuleNames) {\n    return compilerHost.resolveModuleNames(\n        [moduleName], containingFile,\n        undefined,  // reusedNames\n        undefined,  // redirectedReference\n        compilerOptions)[0];\n  } else {\n    return ts\n        .resolveModuleName(\n            moduleName, containingFile, compilerOptions, compilerHost,\n            moduleResolutionCache !== null ? moduleResolutionCache : undefined)\n        .resolvedModule;\n  }\n}\n\n/** Returns true if the node is an assignment expression. */\nexport function isAssignment(node: ts.Node): node is ts.BinaryExpression {\n  return ts.isBinaryExpression(node) && node.operatorToken.kind === ts.SyntaxKind.EqualsToken;\n}\n\n/**\n * Asserts that the keys `K` form a subset of the keys of `T`.\n */\nexport type SubsetOfKeys<T, K extends keyof T> = K;\n\n/**\n * Represents the type `T`, with a transformation applied that turns all methods (even optional\n * ones) into required fields (which may be `undefined`, if the method was optional).\n */\nexport type RequiredDelegations<T> = {\n  [M in keyof Required<T>]: T[M];\n};\n\n/**\n * Source files may become redirects to other source files when their package name and version are\n * identical. TypeScript creates a proxy source file for such source files which has an internal\n * `redirectInfo` property that refers to the original source file.\n */\ninterface RedirectedSourceFile extends ts.SourceFile {\n  redirectInfo?: {unredirected: ts.SourceFile;};\n}\n\n/**\n * Obtains the non-redirected source file for `sf`.\n */\nexport function toUnredirectedSourceFile(sf: ts.SourceFile): ts.SourceFile {\n  const redirectInfo = (sf as RedirectedSourceFile).redirectInfo;\n  if (redirectInfo === undefined) {\n    return sf;\n  }\n  return redirectInfo.unredirected;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}