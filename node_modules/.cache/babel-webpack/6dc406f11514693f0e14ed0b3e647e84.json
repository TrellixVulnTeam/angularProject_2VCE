{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/provider_analyzer\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/template_parser/template_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NgModuleProviderAnalyzer = exports.ProviderElementContext = exports.ProviderViewContext = exports.ProviderError = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var template_ast_1 = require(\"@angular/compiler/src/template_parser/template_ast\");\n\n  var ProviderError =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ProviderError, _super);\n\n    function ProviderError(message, span) {\n      return _super.call(this, span, message) || this;\n    }\n\n    return ProviderError;\n  }(parse_util_1.ParseError);\n\n  exports.ProviderError = ProviderError;\n\n  var ProviderViewContext =\n  /** @class */\n  function () {\n    function ProviderViewContext(reflector, component) {\n      var _this = this;\n\n      this.reflector = reflector;\n      this.component = component;\n      this.errors = [];\n      this.viewQueries = _getViewQueries(component);\n      this.viewProviders = new Map();\n      component.viewProviders.forEach(function (provider) {\n        if (_this.viewProviders.get(compile_metadata_1.tokenReference(provider.token)) == null) {\n          _this.viewProviders.set(compile_metadata_1.tokenReference(provider.token), true);\n        }\n      });\n    }\n\n    return ProviderViewContext;\n  }();\n\n  exports.ProviderViewContext = ProviderViewContext;\n\n  var ProviderElementContext =\n  /** @class */\n  function () {\n    function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n      var _this = this;\n\n      this.viewContext = viewContext;\n      this._parent = _parent;\n      this._isViewRoot = _isViewRoot;\n      this._directiveAsts = _directiveAsts;\n      this._sourceSpan = _sourceSpan;\n      this._transformedProviders = new Map();\n      this._seenProviders = new Map();\n      this._queriedTokens = new Map();\n      this.transformedHasViewContainer = false;\n      this._attrs = {};\n      attrs.forEach(function (attrAst) {\n        return _this._attrs[attrAst.name] = attrAst.value;\n      });\n\n      var directivesMeta = _directiveAsts.map(function (directiveAst) {\n        return directiveAst.directive;\n      });\n\n      this._allProviders = _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n      this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n      Array.from(this._allProviders.values()).forEach(function (provider) {\n        _this._addQueryReadsTo(provider.token, provider.token, _this._queriedTokens);\n      });\n\n      if (isTemplate) {\n        var templateRefId = identifiers_1.createTokenForExternalReference(this.viewContext.reflector, identifiers_1.Identifiers.TemplateRef);\n\n        this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n      }\n\n      refs.forEach(function (refAst) {\n        var defaultQueryValue = refAst.value || identifiers_1.createTokenForExternalReference(_this.viewContext.reflector, identifiers_1.Identifiers.ElementRef);\n\n        _this._addQueryReadsTo({\n          value: refAst.name\n        }, defaultQueryValue, _this._queriedTokens);\n      });\n\n      if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(identifiers_1.Identifiers.ViewContainerRef))) {\n        this.transformedHasViewContainer = true;\n      } // create the providers that we know are eager first\n\n\n      Array.from(this._allProviders.values()).forEach(function (provider) {\n        var eager = provider.eager || _this._queriedTokens.get(compile_metadata_1.tokenReference(provider.token));\n\n        if (eager) {\n          _this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n        }\n      });\n    }\n\n    ProviderElementContext.prototype.afterElement = function () {\n      var _this = this; // collect lazy providers\n\n\n      Array.from(this._allProviders.values()).forEach(function (provider) {\n        _this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n      });\n    };\n\n    Object.defineProperty(ProviderElementContext.prototype, \"transformProviders\", {\n      get: function get() {\n        // Note: Maps keep their insertion order.\n        var lazyProviders = [];\n        var eagerProviders = [];\n\n        this._transformedProviders.forEach(function (provider) {\n          if (provider.eager) {\n            eagerProviders.push(provider);\n          } else {\n            lazyProviders.push(provider);\n          }\n        });\n\n        return lazyProviders.concat(eagerProviders);\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"transformedDirectiveAsts\", {\n      get: function get() {\n        var sortedProviderTypes = this.transformProviders.map(function (provider) {\n          return provider.token.identifier;\n        });\n\n        var sortedDirectives = this._directiveAsts.slice();\n\n        sortedDirectives.sort(function (dir1, dir2) {\n          return sortedProviderTypes.indexOf(dir1.directive.type) - sortedProviderTypes.indexOf(dir2.directive.type);\n        });\n        return sortedDirectives;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(ProviderElementContext.prototype, \"queryMatches\", {\n      get: function get() {\n        var allMatches = [];\n\n        this._queriedTokens.forEach(function (matches) {\n          allMatches.push.apply(allMatches, tslib_1.__spread(matches));\n        });\n\n        return allMatches;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    ProviderElementContext.prototype._addQueryReadsTo = function (token, defaultValue, queryReadTokens) {\n      this._getQueriesFor(token).forEach(function (query) {\n        var queryValue = query.meta.read || defaultValue;\n        var tokenRef = compile_metadata_1.tokenReference(queryValue);\n        var queryMatches = queryReadTokens.get(tokenRef);\n\n        if (!queryMatches) {\n          queryMatches = [];\n          queryReadTokens.set(tokenRef, queryMatches);\n        }\n\n        queryMatches.push({\n          queryId: query.queryId,\n          value: queryValue\n        });\n      });\n    };\n\n    ProviderElementContext.prototype._getQueriesFor = function (token) {\n      var result = [];\n      var currentEl = this;\n      var distance = 0;\n      var queries;\n\n      while (currentEl !== null) {\n        queries = currentEl._contentQueries.get(compile_metadata_1.tokenReference(token));\n\n        if (queries) {\n          result.push.apply(result, tslib_1.__spread(queries.filter(function (query) {\n            return query.meta.descendants || distance <= 1;\n          })));\n        }\n\n        if (currentEl._directiveAsts.length > 0) {\n          distance++;\n        }\n\n        currentEl = currentEl._parent;\n      }\n\n      queries = this.viewContext.viewQueries.get(compile_metadata_1.tokenReference(token));\n\n      if (queries) {\n        result.push.apply(result, tslib_1.__spread(queries));\n      }\n\n      return result;\n    };\n\n    ProviderElementContext.prototype._getOrCreateLocalProvider = function (requestingProviderType, token, eager) {\n      var _this = this;\n\n      var resolvedProvider = this._allProviders.get(compile_metadata_1.tokenReference(token));\n\n      if (!resolvedProvider || (requestingProviderType === template_ast_1.ProviderAstType.Directive || requestingProviderType === template_ast_1.ProviderAstType.PublicService) && resolvedProvider.providerType === template_ast_1.ProviderAstType.PrivateService || (requestingProviderType === template_ast_1.ProviderAstType.PrivateService || requestingProviderType === template_ast_1.ProviderAstType.PublicService) && resolvedProvider.providerType === template_ast_1.ProviderAstType.Builtin) {\n        return null;\n      }\n\n      var transformedProviderAst = this._transformedProviders.get(compile_metadata_1.tokenReference(token));\n\n      if (transformedProviderAst) {\n        return transformedProviderAst;\n      }\n\n      if (this._seenProviders.get(compile_metadata_1.tokenReference(token)) != null) {\n        this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + compile_metadata_1.tokenName(token), this._sourceSpan));\n        return null;\n      }\n\n      this._seenProviders.set(compile_metadata_1.tokenReference(token), true);\n\n      var transformedProviders = resolvedProvider.providers.map(function (provider) {\n        var transformedUseValue = provider.useValue;\n        var transformedUseExisting = provider.useExisting;\n        var transformedDeps = undefined;\n\n        if (provider.useExisting != null) {\n          var existingDiDep = _this._getDependency(resolvedProvider.providerType, {\n            token: provider.useExisting\n          }, eager);\n\n          if (existingDiDep.token != null) {\n            transformedUseExisting = existingDiDep.token;\n          } else {\n            transformedUseExisting = null;\n            transformedUseValue = existingDiDep.value;\n          }\n        } else if (provider.useFactory) {\n          var deps = provider.deps || provider.useFactory.diDeps;\n          transformedDeps = deps.map(function (dep) {\n            return _this._getDependency(resolvedProvider.providerType, dep, eager);\n          });\n        } else if (provider.useClass) {\n          var deps = provider.deps || provider.useClass.diDeps;\n          transformedDeps = deps.map(function (dep) {\n            return _this._getDependency(resolvedProvider.providerType, dep, eager);\n          });\n        }\n\n        return _transformProvider(provider, {\n          useExisting: transformedUseExisting,\n          useValue: transformedUseValue,\n          deps: transformedDeps\n        });\n      });\n      transformedProviderAst = _transformProviderAst(resolvedProvider, {\n        eager: eager,\n        providers: transformedProviders\n      });\n\n      this._transformedProviders.set(compile_metadata_1.tokenReference(token), transformedProviderAst);\n\n      return transformedProviderAst;\n    };\n\n    ProviderElementContext.prototype._getLocalDependency = function (requestingProviderType, dep, eager) {\n      if (eager === void 0) {\n        eager = false;\n      }\n\n      if (dep.isAttribute) {\n        var attrValue = this._attrs[dep.token.value];\n        return {\n          isValue: true,\n          value: attrValue == null ? null : attrValue\n        };\n      }\n\n      if (dep.token != null) {\n        // access builtints\n        if (requestingProviderType === template_ast_1.ProviderAstType.Directive || requestingProviderType === template_ast_1.ProviderAstType.Component) {\n          if (compile_metadata_1.tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(identifiers_1.Identifiers.Renderer) || compile_metadata_1.tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(identifiers_1.Identifiers.ElementRef) || compile_metadata_1.tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(identifiers_1.Identifiers.ChangeDetectorRef) || compile_metadata_1.tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(identifiers_1.Identifiers.TemplateRef)) {\n            return dep;\n          }\n\n          if (compile_metadata_1.tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(identifiers_1.Identifiers.ViewContainerRef)) {\n            this.transformedHasViewContainer = true;\n          }\n        } // access the injector\n\n\n        if (compile_metadata_1.tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(identifiers_1.Identifiers.Injector)) {\n          return dep;\n        } // access providers\n\n\n        if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n          return dep;\n        }\n      }\n\n      return null;\n    };\n\n    ProviderElementContext.prototype._getDependency = function (requestingProviderType, dep, eager) {\n      if (eager === void 0) {\n        eager = false;\n      }\n\n      var currElement = this;\n      var currEager = eager;\n      var result = null;\n\n      if (!dep.isSkipSelf) {\n        result = this._getLocalDependency(requestingProviderType, dep, eager);\n      }\n\n      if (dep.isSelf) {\n        if (!result && dep.isOptional) {\n          result = {\n            isValue: true,\n            value: null\n          };\n        }\n      } else {\n        // check parent elements\n        while (!result && currElement._parent) {\n          var prevElement = currElement;\n          currElement = currElement._parent;\n\n          if (prevElement._isViewRoot) {\n            currEager = false;\n          }\n\n          result = currElement._getLocalDependency(template_ast_1.ProviderAstType.PublicService, dep, currEager);\n        } // check @Host restriction\n\n\n        if (!result) {\n          if (!dep.isHost || this.viewContext.component.isHost || this.viewContext.component.type.reference === compile_metadata_1.tokenReference(dep.token) || this.viewContext.viewProviders.get(compile_metadata_1.tokenReference(dep.token)) != null) {\n            result = dep;\n          } else {\n            result = dep.isOptional ? {\n              isValue: true,\n              value: null\n            } : null;\n          }\n        }\n      }\n\n      if (!result) {\n        this.viewContext.errors.push(new ProviderError(\"No provider for \" + compile_metadata_1.tokenName(dep.token), this._sourceSpan));\n      }\n\n      return result;\n    };\n\n    return ProviderElementContext;\n  }();\n\n  exports.ProviderElementContext = ProviderElementContext;\n\n  var NgModuleProviderAnalyzer =\n  /** @class */\n  function () {\n    function NgModuleProviderAnalyzer(reflector, ngModule, extraProviders, sourceSpan) {\n      var _this = this;\n\n      this.reflector = reflector;\n      this._transformedProviders = new Map();\n      this._seenProviders = new Map();\n      this._errors = [];\n      this._allProviders = new Map();\n      ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n        var ngModuleProvider = {\n          token: {\n            identifier: ngModuleType\n          },\n          useClass: ngModuleType\n        };\n\n        _resolveProviders([ngModuleProvider], template_ast_1.ProviderAstType.PublicService, true, sourceSpan, _this._errors, _this._allProviders,\n        /* isModule */\n        true);\n      });\n\n      _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) {\n        return entry.provider;\n      }).concat(extraProviders), template_ast_1.ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders,\n      /* isModule */\n      false);\n    }\n\n    NgModuleProviderAnalyzer.prototype.parse = function () {\n      var _this = this;\n\n      Array.from(this._allProviders.values()).forEach(function (provider) {\n        _this._getOrCreateLocalProvider(provider.token, provider.eager);\n      });\n\n      if (this._errors.length > 0) {\n        var errorString = this._errors.join('\\n');\n\n        throw new Error(\"Provider parse errors:\\n\" + errorString);\n      } // Note: Maps keep their insertion order.\n\n\n      var lazyProviders = [];\n      var eagerProviders = [];\n\n      this._transformedProviders.forEach(function (provider) {\n        if (provider.eager) {\n          eagerProviders.push(provider);\n        } else {\n          lazyProviders.push(provider);\n        }\n      });\n\n      return lazyProviders.concat(eagerProviders);\n    };\n\n    NgModuleProviderAnalyzer.prototype._getOrCreateLocalProvider = function (token, eager) {\n      var _this = this;\n\n      var resolvedProvider = this._allProviders.get(compile_metadata_1.tokenReference(token));\n\n      if (!resolvedProvider) {\n        return null;\n      }\n\n      var transformedProviderAst = this._transformedProviders.get(compile_metadata_1.tokenReference(token));\n\n      if (transformedProviderAst) {\n        return transformedProviderAst;\n      }\n\n      if (this._seenProviders.get(compile_metadata_1.tokenReference(token)) != null) {\n        this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \" + compile_metadata_1.tokenName(token), resolvedProvider.sourceSpan));\n\n        return null;\n      }\n\n      this._seenProviders.set(compile_metadata_1.tokenReference(token), true);\n\n      var transformedProviders = resolvedProvider.providers.map(function (provider) {\n        var transformedUseValue = provider.useValue;\n        var transformedUseExisting = provider.useExisting;\n        var transformedDeps = undefined;\n\n        if (provider.useExisting != null) {\n          var existingDiDep = _this._getDependency({\n            token: provider.useExisting\n          }, eager, resolvedProvider.sourceSpan);\n\n          if (existingDiDep.token != null) {\n            transformedUseExisting = existingDiDep.token;\n          } else {\n            transformedUseExisting = null;\n            transformedUseValue = existingDiDep.value;\n          }\n        } else if (provider.useFactory) {\n          var deps = provider.deps || provider.useFactory.diDeps;\n          transformedDeps = deps.map(function (dep) {\n            return _this._getDependency(dep, eager, resolvedProvider.sourceSpan);\n          });\n        } else if (provider.useClass) {\n          var deps = provider.deps || provider.useClass.diDeps;\n          transformedDeps = deps.map(function (dep) {\n            return _this._getDependency(dep, eager, resolvedProvider.sourceSpan);\n          });\n        }\n\n        return _transformProvider(provider, {\n          useExisting: transformedUseExisting,\n          useValue: transformedUseValue,\n          deps: transformedDeps\n        });\n      });\n      transformedProviderAst = _transformProviderAst(resolvedProvider, {\n        eager: eager,\n        providers: transformedProviders\n      });\n\n      this._transformedProviders.set(compile_metadata_1.tokenReference(token), transformedProviderAst);\n\n      return transformedProviderAst;\n    };\n\n    NgModuleProviderAnalyzer.prototype._getDependency = function (dep, eager, requestorSourceSpan) {\n      if (eager === void 0) {\n        eager = false;\n      }\n\n      var foundLocal = false;\n\n      if (!dep.isSkipSelf && dep.token != null) {\n        // access the injector\n        if (compile_metadata_1.tokenReference(dep.token) === this.reflector.resolveExternalReference(identifiers_1.Identifiers.Injector) || compile_metadata_1.tokenReference(dep.token) === this.reflector.resolveExternalReference(identifiers_1.Identifiers.ComponentFactoryResolver)) {\n          foundLocal = true; // access providers\n        } else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n          foundLocal = true;\n        }\n      }\n\n      return dep;\n    };\n\n    return NgModuleProviderAnalyzer;\n  }();\n\n  exports.NgModuleProviderAnalyzer = NgModuleProviderAnalyzer;\n\n  function _transformProvider(provider, _a) {\n    var useExisting = _a.useExisting,\n        useValue = _a.useValue,\n        deps = _a.deps;\n    return {\n      token: provider.token,\n      useClass: provider.useClass,\n      useExisting: useExisting,\n      useFactory: provider.useFactory,\n      useValue: useValue,\n      deps: deps,\n      multi: provider.multi\n    };\n  }\n\n  function _transformProviderAst(provider, _a) {\n    var eager = _a.eager,\n        providers = _a.providers;\n    return new template_ast_1.ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\n  }\n\n  function _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n    var providersByToken = new Map();\n    directives.forEach(function (directive) {\n      var dirProvider = {\n        token: {\n          identifier: directive.type\n        },\n        useClass: directive.type\n      };\n\n      _resolveProviders([dirProvider], directive.isComponent ? template_ast_1.ProviderAstType.Component : template_ast_1.ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken,\n      /* isModule */\n      false);\n    }); // Note: directives need to be able to overwrite providers of a component!\n\n    var directivesWithComponentFirst = directives.filter(function (dir) {\n      return dir.isComponent;\n    }).concat(directives.filter(function (dir) {\n      return !dir.isComponent;\n    }));\n    directivesWithComponentFirst.forEach(function (directive) {\n      _resolveProviders(directive.providers, template_ast_1.ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken,\n      /* isModule */\n      false);\n\n      _resolveProviders(directive.viewProviders, template_ast_1.ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken,\n      /* isModule */\n      false);\n    });\n    return providersByToken;\n  }\n\n  function _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {\n    providers.forEach(function (provider) {\n      var resolvedProvider = targetProvidersByToken.get(compile_metadata_1.tokenReference(provider.token));\n\n      if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n        targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \" + compile_metadata_1.tokenName(resolvedProvider.token), sourceSpan));\n      }\n\n      if (!resolvedProvider) {\n        var lifecycleHooks = provider.token.identifier && provider.token.identifier.lifecycleHooks ? provider.token.identifier.lifecycleHooks : [];\n        var isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n        resolvedProvider = new template_ast_1.ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);\n        targetProvidersByToken.set(compile_metadata_1.tokenReference(provider.token), resolvedProvider);\n      } else {\n        if (!provider.multi) {\n          resolvedProvider.providers.length = 0;\n        }\n\n        resolvedProvider.providers.push(provider);\n      }\n    });\n  }\n\n  function _getViewQueries(component) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    var viewQueryId = 1;\n    var viewQueries = new Map();\n\n    if (component.viewQueries) {\n      component.viewQueries.forEach(function (query) {\n        return _addQueryToTokenMap(viewQueries, {\n          meta: query,\n          queryId: viewQueryId++\n        });\n      });\n    }\n\n    return viewQueries;\n  }\n\n  function _getContentQueries(contentQueryStartId, directives) {\n    var contentQueryId = contentQueryStartId;\n    var contentQueries = new Map();\n    directives.forEach(function (directive, directiveIndex) {\n      if (directive.queries) {\n        directive.queries.forEach(function (query) {\n          return _addQueryToTokenMap(contentQueries, {\n            meta: query,\n            queryId: contentQueryId++\n          });\n        });\n      }\n    });\n    return contentQueries;\n  }\n\n  function _addQueryToTokenMap(map, query) {\n    query.meta.selectors.forEach(function (token) {\n      var entry = map.get(compile_metadata_1.tokenReference(token));\n\n      if (!entry) {\n        entry = [];\n        map.set(compile_metadata_1.tokenReference(token), entry);\n      }\n\n      entry.push(query);\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/provider_analyzer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompileDirectiveSummary, CompileNgModuleMetadata, CompileProviderMetadata, CompileQueryMetadata, CompileTokenMetadata, CompileTypeMetadata, tokenName, tokenReference} from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport {createTokenForExternalReference, Identifiers} from './identifiers';\nimport {ParseError, ParseSourceSpan} from './parse_util';\nimport {AttrAst, DirectiveAst, ProviderAst, ProviderAstType, QueryMatch, ReferenceAst} from './template_parser/template_ast';\n\nexport class ProviderError extends ParseError {\n  constructor(message: string, span: ParseSourceSpan) {\n    super(span, message);\n  }\n}\n\nexport interface QueryWithId {\n  meta: CompileQueryMetadata;\n  queryId: number;\n}\n\nexport class ProviderViewContext {\n  /**\n   * @internal\n   */\n  viewQueries: Map<any, QueryWithId[]>;\n  /**\n   * @internal\n   */\n  viewProviders: Map<any, boolean>;\n  errors: ProviderError[] = [];\n\n  constructor(public reflector: CompileReflector, public component: CompileDirectiveMetadata) {\n    this.viewQueries = _getViewQueries(component);\n    this.viewProviders = new Map<any, boolean>();\n    component.viewProviders.forEach((provider) => {\n      if (this.viewProviders.get(tokenReference(provider.token)) == null) {\n        this.viewProviders.set(tokenReference(provider.token), true);\n      }\n    });\n  }\n}\n\nexport class ProviderElementContext {\n  private _contentQueries: Map<any, QueryWithId[]>;\n\n  private _transformedProviders = new Map<any, ProviderAst>();\n  private _seenProviders = new Map<any, boolean>();\n  private _allProviders: Map<any, ProviderAst>;\n  private _attrs: {[key: string]: string};\n  private _queriedTokens = new Map<any, QueryMatch[]>();\n\n  public readonly transformedHasViewContainer: boolean = false;\n\n  constructor(\n      public viewContext: ProviderViewContext, private _parent: ProviderElementContext,\n      private _isViewRoot: boolean, private _directiveAsts: DirectiveAst[], attrs: AttrAst[],\n      refs: ReferenceAst[], isTemplate: boolean, contentQueryStartId: number,\n      private _sourceSpan: ParseSourceSpan) {\n    this._attrs = {};\n    attrs.forEach((attrAst) => this._attrs[attrAst.name] = attrAst.value);\n    const directivesMeta = _directiveAsts.map(directiveAst => directiveAst.directive);\n    this._allProviders =\n        _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n    this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n    Array.from(this._allProviders.values()).forEach((provider) => {\n      this._addQueryReadsTo(provider.token, provider.token, this._queriedTokens);\n    });\n    if (isTemplate) {\n      const templateRefId =\n          createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);\n      this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n    }\n    refs.forEach((refAst) => {\n      let defaultQueryValue = refAst.value ||\n          createTokenForExternalReference(this.viewContext.reflector, Identifiers.ElementRef);\n      this._addQueryReadsTo({value: refAst.name}, defaultQueryValue, this._queriedTokens);\n    });\n    if (this._queriedTokens.get(\n            this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {\n      this.transformedHasViewContainer = true;\n    }\n\n    // create the providers that we know are eager first\n    Array.from(this._allProviders.values()).forEach((provider) => {\n      const eager = provider.eager || this._queriedTokens.get(tokenReference(provider.token));\n      if (eager) {\n        this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n      }\n    });\n  }\n\n  afterElement() {\n    // collect lazy providers\n    Array.from(this._allProviders.values()).forEach((provider) => {\n      this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n    });\n  }\n\n  get transformProviders(): ProviderAst[] {\n    // Note: Maps keep their insertion order.\n    const lazyProviders: ProviderAst[] = [];\n    const eagerProviders: ProviderAst[] = [];\n    this._transformedProviders.forEach(provider => {\n      if (provider.eager) {\n        eagerProviders.push(provider);\n      } else {\n        lazyProviders.push(provider);\n      }\n    });\n    return lazyProviders.concat(eagerProviders);\n  }\n\n  get transformedDirectiveAsts(): DirectiveAst[] {\n    const sortedProviderTypes = this.transformProviders.map(provider => provider.token.identifier);\n    const sortedDirectives = this._directiveAsts.slice();\n    sortedDirectives.sort(\n        (dir1, dir2) => sortedProviderTypes.indexOf(dir1.directive.type) -\n            sortedProviderTypes.indexOf(dir2.directive.type));\n    return sortedDirectives;\n  }\n\n  get queryMatches(): QueryMatch[] {\n    const allMatches: QueryMatch[] = [];\n    this._queriedTokens.forEach((matches: QueryMatch[]) => {\n      allMatches.push(...matches);\n    });\n    return allMatches;\n  }\n\n  private _addQueryReadsTo(\n      token: CompileTokenMetadata, defaultValue: CompileTokenMetadata,\n      queryReadTokens: Map<any, QueryMatch[]>) {\n    this._getQueriesFor(token).forEach((query) => {\n      const queryValue = query.meta.read || defaultValue;\n      const tokenRef = tokenReference(queryValue);\n      let queryMatches = queryReadTokens.get(tokenRef);\n      if (!queryMatches) {\n        queryMatches = [];\n        queryReadTokens.set(tokenRef, queryMatches);\n      }\n      queryMatches.push({queryId: query.queryId, value: queryValue});\n    });\n  }\n\n  private _getQueriesFor(token: CompileTokenMetadata): QueryWithId[] {\n    const result: QueryWithId[] = [];\n    let currentEl: ProviderElementContext = this;\n    let distance = 0;\n    let queries: QueryWithId[]|undefined;\n    while (currentEl !== null) {\n      queries = currentEl._contentQueries.get(tokenReference(token));\n      if (queries) {\n        result.push(...queries.filter((query) => query.meta.descendants || distance <= 1));\n      }\n      if (currentEl._directiveAsts.length > 0) {\n        distance++;\n      }\n      currentEl = currentEl._parent;\n    }\n    queries = this.viewContext.viewQueries.get(tokenReference(token));\n    if (queries) {\n      result.push(...queries);\n    }\n    return result;\n  }\n\n\n  private _getOrCreateLocalProvider(\n      requestingProviderType: ProviderAstType, token: CompileTokenMetadata,\n      eager: boolean): ProviderAst|null {\n    const resolvedProvider = this._allProviders.get(tokenReference(token));\n    if (!resolvedProvider ||\n        ((requestingProviderType === ProviderAstType.Directive ||\n          requestingProviderType === ProviderAstType.PublicService) &&\n         resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n        ((requestingProviderType === ProviderAstType.PrivateService ||\n          requestingProviderType === ProviderAstType.PublicService) &&\n         resolvedProvider.providerType === ProviderAstType.Builtin)) {\n      return null;\n    }\n    let transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n    if (transformedProviderAst) {\n      return transformedProviderAst;\n    }\n    if (this._seenProviders.get(tokenReference(token)) != null) {\n      this.viewContext.errors.push(new ProviderError(\n          `Cannot instantiate cyclic dependency! ${tokenName(token)}`, this._sourceSpan));\n      return null;\n    }\n    this._seenProviders.set(tokenReference(token), true);\n    const transformedProviders = resolvedProvider.providers.map((provider) => {\n      let transformedUseValue = provider.useValue;\n      let transformedUseExisting = provider.useExisting!;\n      let transformedDeps: CompileDiDependencyMetadata[] = undefined!;\n      if (provider.useExisting != null) {\n        const existingDiDep = this._getDependency(\n            resolvedProvider.providerType, {token: provider.useExisting}, eager)!;\n        if (existingDiDep.token != null) {\n          transformedUseExisting = existingDiDep.token;\n        } else {\n          transformedUseExisting = null!;\n          transformedUseValue = existingDiDep.value;\n        }\n      } else if (provider.useFactory) {\n        const deps = provider.deps || provider.useFactory.diDeps;\n        transformedDeps =\n            deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager)!);\n      } else if (provider.useClass) {\n        const deps = provider.deps || provider.useClass.diDeps;\n        transformedDeps =\n            deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager)!);\n      }\n      return _transformProvider(provider, {\n        useExisting: transformedUseExisting,\n        useValue: transformedUseValue,\n        deps: transformedDeps\n      });\n    });\n    transformedProviderAst =\n        _transformProviderAst(resolvedProvider, {eager: eager, providers: transformedProviders});\n    this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n    return transformedProviderAst;\n  }\n\n  private _getLocalDependency(\n      requestingProviderType: ProviderAstType, dep: CompileDiDependencyMetadata,\n      eager: boolean = false): CompileDiDependencyMetadata|null {\n    if (dep.isAttribute) {\n      const attrValue = this._attrs[dep.token!.value];\n      return {isValue: true, value: attrValue == null ? null : attrValue};\n    }\n\n    if (dep.token != null) {\n      // access builtints\n      if ((requestingProviderType === ProviderAstType.Directive ||\n           requestingProviderType === ProviderAstType.Component)) {\n        if (tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) ||\n            tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) ||\n            tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(\n                    Identifiers.ChangeDetectorRef) ||\n            tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n          return dep;\n        }\n        if (tokenReference(dep.token) ===\n            this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n          (this as {transformedHasViewContainer: boolean}).transformedHasViewContainer = true;\n        }\n      }\n      // access the injector\n      if (tokenReference(dep.token) ===\n          this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {\n        return dep;\n      }\n      // access providers\n      if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n        return dep;\n      }\n    }\n    return null;\n  }\n\n  private _getDependency(\n      requestingProviderType: ProviderAstType, dep: CompileDiDependencyMetadata,\n      eager: boolean = false): CompileDiDependencyMetadata|null {\n    let currElement: ProviderElementContext = this;\n    let currEager: boolean = eager;\n    let result: CompileDiDependencyMetadata|null = null;\n    if (!dep.isSkipSelf) {\n      result = this._getLocalDependency(requestingProviderType, dep, eager);\n    }\n    if (dep.isSelf) {\n      if (!result && dep.isOptional) {\n        result = {isValue: true, value: null};\n      }\n    } else {\n      // check parent elements\n      while (!result && currElement._parent) {\n        const prevElement = currElement;\n        currElement = currElement._parent;\n        if (prevElement._isViewRoot) {\n          currEager = false;\n        }\n        result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n      }\n      // check @Host restriction\n      if (!result) {\n        if (!dep.isHost || this.viewContext.component.isHost ||\n            this.viewContext.component.type.reference === tokenReference(dep.token!) ||\n            this.viewContext.viewProviders.get(tokenReference(dep.token!)) != null) {\n          result = dep;\n        } else {\n          result = dep.isOptional ? {isValue: true, value: null} : null;\n        }\n      }\n    }\n    if (!result) {\n      this.viewContext.errors.push(\n          new ProviderError(`No provider for ${tokenName(dep.token!)}`, this._sourceSpan));\n    }\n    return result;\n  }\n}\n\n\nexport class NgModuleProviderAnalyzer {\n  private _transformedProviders = new Map<any, ProviderAst>();\n  private _seenProviders = new Map<any, boolean>();\n  private _allProviders: Map<any, ProviderAst>;\n  private _errors: ProviderError[] = [];\n\n  constructor(\n      private reflector: CompileReflector, ngModule: CompileNgModuleMetadata,\n      extraProviders: CompileProviderMetadata[], sourceSpan: ParseSourceSpan) {\n    this._allProviders = new Map<any, ProviderAst>();\n    ngModule.transitiveModule.modules.forEach((ngModuleType: CompileTypeMetadata) => {\n      const ngModuleProvider = {token: {identifier: ngModuleType}, useClass: ngModuleType};\n      _resolveProviders(\n          [ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, this._errors,\n          this._allProviders, /* isModule */ true);\n    });\n    _resolveProviders(\n        ngModule.transitiveModule.providers.map(entry => entry.provider).concat(extraProviders),\n        ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders,\n        /* isModule */ false);\n  }\n\n  parse(): ProviderAst[] {\n    Array.from(this._allProviders.values()).forEach((provider) => {\n      this._getOrCreateLocalProvider(provider.token, provider.eager);\n    });\n    if (this._errors.length > 0) {\n      const errorString = this._errors.join('\\n');\n      throw new Error(`Provider parse errors:\\n${errorString}`);\n    }\n    // Note: Maps keep their insertion order.\n    const lazyProviders: ProviderAst[] = [];\n    const eagerProviders: ProviderAst[] = [];\n    this._transformedProviders.forEach(provider => {\n      if (provider.eager) {\n        eagerProviders.push(provider);\n      } else {\n        lazyProviders.push(provider);\n      }\n    });\n    return lazyProviders.concat(eagerProviders);\n  }\n\n  private _getOrCreateLocalProvider(token: CompileTokenMetadata, eager: boolean): ProviderAst|null {\n    const resolvedProvider = this._allProviders.get(tokenReference(token));\n    if (!resolvedProvider) {\n      return null;\n    }\n    let transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n    if (transformedProviderAst) {\n      return transformedProviderAst;\n    }\n    if (this._seenProviders.get(tokenReference(token)) != null) {\n      this._errors.push(new ProviderError(\n          `Cannot instantiate cyclic dependency! ${tokenName(token)}`,\n          resolvedProvider.sourceSpan));\n      return null;\n    }\n    this._seenProviders.set(tokenReference(token), true);\n    const transformedProviders = resolvedProvider.providers.map((provider) => {\n      let transformedUseValue = provider.useValue;\n      let transformedUseExisting = provider.useExisting!;\n      let transformedDeps: CompileDiDependencyMetadata[] = undefined!;\n      if (provider.useExisting != null) {\n        const existingDiDep =\n            this._getDependency({token: provider.useExisting}, eager, resolvedProvider.sourceSpan);\n        if (existingDiDep.token != null) {\n          transformedUseExisting = existingDiDep.token;\n        } else {\n          transformedUseExisting = null!;\n          transformedUseValue = existingDiDep.value;\n        }\n      } else if (provider.useFactory) {\n        const deps = provider.deps || provider.useFactory.diDeps;\n        transformedDeps =\n            deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\n      } else if (provider.useClass) {\n        const deps = provider.deps || provider.useClass.diDeps;\n        transformedDeps =\n            deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\n      }\n      return _transformProvider(provider, {\n        useExisting: transformedUseExisting,\n        useValue: transformedUseValue,\n        deps: transformedDeps\n      });\n    });\n    transformedProviderAst =\n        _transformProviderAst(resolvedProvider, {eager: eager, providers: transformedProviders});\n    this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n    return transformedProviderAst;\n  }\n\n  private _getDependency(\n      dep: CompileDiDependencyMetadata, eager: boolean = false,\n      requestorSourceSpan: ParseSourceSpan): CompileDiDependencyMetadata {\n    let foundLocal = false;\n    if (!dep.isSkipSelf && dep.token != null) {\n      // access the injector\n      if (tokenReference(dep.token) ===\n              this.reflector.resolveExternalReference(Identifiers.Injector) ||\n          tokenReference(dep.token) ===\n              this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {\n        foundLocal = true;\n        // access providers\n      } else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n        foundLocal = true;\n      }\n    }\n    return dep;\n  }\n}\n\nfunction _transformProvider(\n    provider: CompileProviderMetadata,\n    {useExisting, useValue, deps}:\n        {useExisting: CompileTokenMetadata, useValue: any, deps: CompileDiDependencyMetadata[]}) {\n  return {\n    token: provider.token,\n    useClass: provider.useClass,\n    useExisting: useExisting,\n    useFactory: provider.useFactory,\n    useValue: useValue,\n    deps: deps,\n    multi: provider.multi\n  };\n}\n\nfunction _transformProviderAst(\n    provider: ProviderAst,\n    {eager, providers}: {eager: boolean, providers: CompileProviderMetadata[]}): ProviderAst {\n  return new ProviderAst(\n      provider.token, provider.multiProvider, provider.eager || eager, providers,\n      provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\n}\n\nfunction _resolveProvidersFromDirectives(\n    directives: CompileDirectiveSummary[], sourceSpan: ParseSourceSpan,\n    targetErrors: ParseError[]): Map<any, ProviderAst> {\n  const providersByToken = new Map<any, ProviderAst>();\n  directives.forEach((directive) => {\n    const dirProvider:\n        CompileProviderMetadata = {token: {identifier: directive.type}, useClass: directive.type};\n    _resolveProviders(\n        [dirProvider],\n        directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true,\n        sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n  });\n\n  // Note: directives need to be able to overwrite providers of a component!\n  const directivesWithComponentFirst =\n      directives.filter(dir => dir.isComponent).concat(directives.filter(dir => !dir.isComponent));\n  directivesWithComponentFirst.forEach((directive) => {\n    _resolveProviders(\n        directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors,\n        providersByToken, /* isModule */ false);\n    _resolveProviders(\n        directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors,\n        providersByToken, /* isModule */ false);\n  });\n  return providersByToken;\n}\n\nfunction _resolveProviders(\n    providers: CompileProviderMetadata[], providerType: ProviderAstType, eager: boolean,\n    sourceSpan: ParseSourceSpan, targetErrors: ParseError[],\n    targetProvidersByToken: Map<any, ProviderAst>, isModule: boolean) {\n  providers.forEach((provider) => {\n    let resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n    if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n      targetErrors.push(new ProviderError(\n          `Mixing multi and non multi provider is not possible for token ${\n              tokenName(resolvedProvider.token)}`,\n          sourceSpan));\n    }\n    if (!resolvedProvider) {\n      const lifecycleHooks = provider.token.identifier &&\n              (<CompileTypeMetadata>provider.token.identifier).lifecycleHooks ?\n          (<CompileTypeMetadata>provider.token.identifier).lifecycleHooks :\n          [];\n      const isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n      resolvedProvider = new ProviderAst(\n          provider.token, !!provider.multi, eager || isUseValue, [provider], providerType,\n          lifecycleHooks, sourceSpan, isModule);\n      targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n    } else {\n      if (!provider.multi) {\n        resolvedProvider.providers.length = 0;\n      }\n      resolvedProvider.providers.push(provider);\n    }\n  });\n}\n\n\nfunction _getViewQueries(component: CompileDirectiveMetadata): Map<any, QueryWithId[]> {\n  // Note: queries start with id 1 so we can use the number in a Bloom filter!\n  let viewQueryId = 1;\n  const viewQueries = new Map<any, QueryWithId[]>();\n  if (component.viewQueries) {\n    component.viewQueries.forEach(\n        (query) => _addQueryToTokenMap(viewQueries, {meta: query, queryId: viewQueryId++}));\n  }\n  return viewQueries;\n}\n\nfunction _getContentQueries(\n    contentQueryStartId: number, directives: CompileDirectiveSummary[]): Map<any, QueryWithId[]> {\n  let contentQueryId = contentQueryStartId;\n  const contentQueries = new Map<any, QueryWithId[]>();\n  directives.forEach((directive, directiveIndex) => {\n    if (directive.queries) {\n      directive.queries.forEach(\n          (query) => _addQueryToTokenMap(contentQueries, {meta: query, queryId: contentQueryId++}));\n    }\n  });\n  return contentQueries;\n}\n\nfunction _addQueryToTokenMap(map: Map<any, QueryWithId[]>, query: QueryWithId) {\n  query.meta.selectors.forEach((token: CompileTokenMetadata) => {\n    let entry = map.get(tokenReference(token));\n    if (!entry) {\n      entry = [];\n      map.set(tokenReference(token), entry);\n    }\n    entry.push(query);\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}