{"ast":null,"code":"var _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Minipass = require('minipass');\n\nvar EE = require('events');\n\nvar isStream = function isStream(s) {\n  return s && s instanceof EE && (typeof s.pipe === 'function' || // readable\n  typeof s.write === 'function' && typeof s.end === 'function' // writable\n  );\n};\n\nvar _head = Symbol('_head');\n\nvar _tail = Symbol('_tail');\n\nvar _linkStreams = Symbol('_linkStreams');\n\nvar _setHead = Symbol('_setHead');\n\nvar _setTail = Symbol('_setTail');\n\nvar _onError = Symbol('_onError');\n\nvar _onData = Symbol('_onData');\n\nvar _onEnd = Symbol('_onEnd');\n\nvar _onDrain = Symbol('_onDrain');\n\nvar _streams = Symbol('_streams');\n\nvar Pipeline = /*#__PURE__*/function (_Minipass) {\n  \"use strict\";\n\n  _inherits(Pipeline, _Minipass);\n\n  var _super = _createSuper(Pipeline);\n\n  function Pipeline(opts) {\n    var _this2;\n\n    var _this;\n\n    _classCallCheck(this, Pipeline);\n\n    for (var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      streams[_key - 1] = arguments[_key];\n    }\n\n    if (isStream(opts)) {\n      streams.unshift(opts);\n      opts = {};\n    }\n\n    _this = _super.call(this, opts);\n    _this[_streams] = [];\n    if (streams.length) (_this2 = _this).push.apply(_this2, streams);\n    return _this;\n  }\n\n  _createClass(Pipeline, [{\n    key: _linkStreams,\n    value: function value(streams) {\n      // reduce takes (left,right), and we return right to make it the\n      // new left value.\n      return streams.reduce(function (src, dest) {\n        src.on('error', function (er) {\n          return dest.emit('error', er);\n        });\n        src.pipe(dest);\n        return dest;\n      });\n    }\n  }, {\n    key: \"push\",\n    value: function push() {\n      var _this$_streams;\n\n      for (var _len2 = arguments.length, streams = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        streams[_key2] = arguments[_key2];\n      }\n\n      (_this$_streams = this[_streams]).push.apply(_this$_streams, streams);\n\n      if (this[_tail]) streams.unshift(this[_tail]);\n\n      var linkRet = this[_linkStreams](streams);\n\n      this[_setTail](linkRet);\n\n      if (!this[_head]) this[_setHead](streams[0]);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift() {\n      var _this$_streams2;\n\n      for (var _len3 = arguments.length, streams = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        streams[_key3] = arguments[_key3];\n      }\n\n      (_this$_streams2 = this[_streams]).unshift.apply(_this$_streams2, streams);\n\n      if (this[_head]) streams.push(this[_head]);\n\n      var linkRet = this[_linkStreams](streams);\n\n      this[_setHead](streams[0]);\n\n      if (!this[_tail]) this[_setTail](linkRet);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(er) {\n      // set fire to the whole thing.\n      this[_streams].forEach(function (s) {\n        return typeof s.destroy === 'function' && s.destroy();\n      });\n\n      return _get(_getPrototypeOf(Pipeline.prototype), \"destroy\", this).call(this, er);\n    } // readable interface -> tail\n\n  }, {\n    key: _setTail,\n    value: function value(stream) {\n      var _this3 = this;\n\n      this[_tail] = stream;\n      stream.on('error', function (er) {\n        return _this3[_onError](stream, er);\n      });\n      stream.on('data', function (chunk) {\n        return _this3[_onData](stream, chunk);\n      });\n      stream.on('end', function () {\n        return _this3[_onEnd](stream);\n      });\n      stream.on('finish', function () {\n        return _this3[_onEnd](stream);\n      });\n    } // errors proxied down the pipeline\n    // they're considered part of the \"read\" interface\n\n  }, {\n    key: _onError,\n    value: function value(stream, er) {\n      if (stream === this[_tail]) this.emit('error', er);\n    }\n  }, {\n    key: _onData,\n    value: function value(stream, chunk) {\n      if (stream === this[_tail]) _get(_getPrototypeOf(Pipeline.prototype), \"write\", this).call(this, chunk);\n    }\n  }, {\n    key: _onEnd,\n    value: function value(stream) {\n      if (stream === this[_tail]) _get(_getPrototypeOf(Pipeline.prototype), \"end\", this).call(this);\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      _get(_getPrototypeOf(Pipeline.prototype), \"pause\", this).call(this);\n\n      return this[_tail] && this[_tail].pause && this[_tail].pause();\n    } // NB: Minipass calls its internal private [RESUME] method during\n    // pipe drains, to avoid hazards where stream.resume() is overridden.\n    // Thus, we need to listen to the resume *event*, not override the\n    // resume() method, and proxy *that* to the tail.\n\n  }, {\n    key: \"emit\",\n    value: function emit(ev) {\n      var _get2;\n\n      if (ev === 'resume' && this[_tail] && this[_tail].resume) this[_tail].resume();\n\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n\n      return (_get2 = _get(_getPrototypeOf(Pipeline.prototype), \"emit\", this)).call.apply(_get2, [this, ev].concat(args));\n    } // writable interface -> head\n\n  }, {\n    key: _setHead,\n    value: function value(stream) {\n      var _this4 = this;\n\n      this[_head] = stream;\n      stream.on('drain', function () {\n        return _this4[_onDrain](stream);\n      });\n    }\n  }, {\n    key: _onDrain,\n    value: function value(stream) {\n      if (stream === this[_head]) this.emit('drain');\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, enc, cb) {\n      return this[_head].write(chunk, enc, cb) && (this.flowing || this.buffer.length === 0);\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, enc, cb) {\n      this[_head].end(chunk, enc, cb);\n\n      return this;\n    }\n  }]);\n\n  return Pipeline;\n}(Minipass);\n\nmodule.exports = Pipeline;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/minipass-pipeline/index.js"],"names":["Minipass","require","EE","isStream","s","pipe","write","end","_head","Symbol","_tail","_linkStreams","_setHead","_setTail","_onError","_onData","_onEnd","_onDrain","_streams","Pipeline","opts","streams","unshift","length","push","reduce","src","dest","on","er","emit","linkRet","forEach","destroy","stream","chunk","pause","ev","resume","args","enc","cb","flowing","buffer","module","exports"],"mappings":"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","sourcesContent":["const Minipass = require('minipass')\nconst EE = require('events')\nconst isStream = s => s && s instanceof EE && (\n  typeof s.pipe === 'function' || // readable\n  (typeof s.write === 'function' && typeof s.end === 'function') // writable\n)\n\nconst _head = Symbol('_head')\nconst _tail = Symbol('_tail')\nconst _linkStreams = Symbol('_linkStreams')\nconst _setHead = Symbol('_setHead')\nconst _setTail = Symbol('_setTail')\nconst _onError = Symbol('_onError')\nconst _onData = Symbol('_onData')\nconst _onEnd = Symbol('_onEnd')\nconst _onDrain = Symbol('_onDrain')\nconst _streams = Symbol('_streams')\nclass Pipeline extends Minipass {\n  constructor (opts, ...streams) {\n    if (isStream(opts)) {\n      streams.unshift(opts)\n      opts = {}\n    }\n\n    super(opts)\n    this[_streams] = []\n    if (streams.length)\n      this.push(...streams)\n  }\n\n  [_linkStreams] (streams) {\n    // reduce takes (left,right), and we return right to make it the\n    // new left value.\n    return streams.reduce((src, dest) => {\n      src.on('error', er => dest.emit('error', er))\n      src.pipe(dest)\n      return dest\n    })\n  }\n\n  push (...streams) {\n    this[_streams].push(...streams)\n    if (this[_tail])\n      streams.unshift(this[_tail])\n\n    const linkRet = this[_linkStreams](streams)\n\n    this[_setTail](linkRet)\n    if (!this[_head])\n      this[_setHead](streams[0])\n  }\n\n  unshift (...streams) {\n    this[_streams].unshift(...streams)\n    if (this[_head])\n      streams.push(this[_head])\n\n    const linkRet = this[_linkStreams](streams)\n    this[_setHead](streams[0])\n    if (!this[_tail])\n      this[_setTail](linkRet)\n  }\n\n  destroy (er) {\n    // set fire to the whole thing.\n    this[_streams].forEach(s =>\n      typeof s.destroy === 'function' && s.destroy())\n    return super.destroy(er)\n  }\n\n  // readable interface -> tail\n  [_setTail] (stream) {\n    this[_tail] = stream\n    stream.on('error', er => this[_onError](stream, er))\n    stream.on('data', chunk => this[_onData](stream, chunk))\n    stream.on('end', () => this[_onEnd](stream))\n    stream.on('finish', () => this[_onEnd](stream))\n  }\n\n  // errors proxied down the pipeline\n  // they're considered part of the \"read\" interface\n  [_onError] (stream, er) {\n    if (stream === this[_tail])\n      this.emit('error', er)\n  }\n  [_onData] (stream, chunk) {\n    if (stream === this[_tail])\n      super.write(chunk)\n  }\n  [_onEnd] (stream) {\n    if (stream === this[_tail])\n      super.end()\n  }\n  pause () {\n    super.pause()\n    return this[_tail] && this[_tail].pause && this[_tail].pause()\n  }\n\n  // NB: Minipass calls its internal private [RESUME] method during\n  // pipe drains, to avoid hazards where stream.resume() is overridden.\n  // Thus, we need to listen to the resume *event*, not override the\n  // resume() method, and proxy *that* to the tail.\n  emit (ev, ...args) {\n    if (ev === 'resume' && this[_tail] && this[_tail].resume)\n      this[_tail].resume()\n    return super.emit(ev, ...args)\n  }\n\n  // writable interface -> head\n  [_setHead] (stream) {\n    this[_head] = stream\n    stream.on('drain', () => this[_onDrain](stream))\n  }\n  [_onDrain] (stream) {\n    if (stream === this[_head])\n      this.emit('drain')\n  }\n  write (chunk, enc, cb) {\n    return this[_head].write(chunk, enc, cb) &&\n      (this.flowing || this.buffer.length === 0)\n  }\n  end (chunk, enc, cb) {\n    this[_head].end(chunk, enc, cb)\n    return this\n  }\n}\n\nmodule.exports = Pipeline\n"]},"metadata":{},"sourceType":"script"}