{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/cluster/utils\", [\"require\", \"exports\", \"cluster\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.sendMessageToWorker = exports.sendMessageToMaster = exports.Deferred = void 0; /// <reference types=\"node\" />\n\n  var cluster = require(\"cluster\");\n  /** Expose a `Promise` instance as well as APIs for resolving/rejecting it. */\n\n\n  var Deferred =\n  /** @class */\n  function () {\n    function Deferred() {\n      var _this = this;\n      /** The `Promise` instance associated with this deferred. */\n\n\n      this.promise = new Promise(function (resolve, reject) {\n        _this.resolve = resolve;\n        _this.reject = reject;\n      });\n    }\n\n    return Deferred;\n  }();\n\n  exports.Deferred = Deferred;\n  /**\n   * Send a message to the cluster master.\n   * (This function should be invoked from cluster workers only.)\n   *\n   * @param msg The message to send to the cluster master.\n   * @return A promise that is resolved once the message has been sent.\n   */\n\n  var sendMessageToMaster = function sendMessageToMaster(msg) {\n    if (cluster.isMaster) {\n      throw new Error('Unable to send message to the master process: Already on the master process.');\n    }\n\n    return new Promise(function (resolve, reject) {\n      if (process.send === undefined) {\n        // Theoretically, this should never happen on a worker process.\n        throw new Error('Unable to send message to the master process: Missing `process.send()`.');\n      }\n\n      process.send(msg, function (err) {\n        return err === null ? resolve() : reject(err);\n      });\n    });\n  };\n\n  exports.sendMessageToMaster = sendMessageToMaster;\n  /**\n   * Send a message to a cluster worker.\n   * (This function should be invoked from the cluster master only.)\n   *\n   * @param workerId The ID of the recipient worker.\n   * @param msg The message to send to the worker.\n   * @return A promise that is resolved once the message has been sent.\n   */\n\n  var sendMessageToWorker = function sendMessageToWorker(workerId, msg) {\n    if (!cluster.isMaster) {\n      throw new Error('Unable to send message to worker process: Sender is not the master process.');\n    }\n\n    var worker = cluster.workers[workerId];\n\n    if (worker === undefined || worker.isDead() || !worker.isConnected()) {\n      throw new Error('Unable to send message to worker process: Recipient does not exist or has disconnected.');\n    }\n\n    return new Promise(function (resolve, reject) {\n      worker.send(msg, function (err) {\n        return err === null ? resolve() : reject(err);\n      });\n    });\n  };\n\n  exports.sendMessageToWorker = sendMessageToWorker;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/ngcc/src/execution/cluster/utils.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;yFAEH;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAMA;;;AACA,MAAA,QAAA;AAAA;AAAA,cAAA;AAAA,aAAA,QAAA,GAAA;AAAA,UAAA,KAAA,GAAA,IAAA;AAiBE;;;AACA,WAAA,OAAA,GAAU,IAAI,OAAJ,CAAe,UAAC,OAAD,EAAU,MAAV,EAAgB;AACvC,QAAA,KAAI,CAAC,OAAL,GAAe,OAAf;AACA,QAAA,KAAI,CAAC,MAAL,GAAc,MAAd;AACD,OAHS,CAAV;AAID;;AAAD,WAAA,QAAA;AAAC,GAtBD,EAAA;;AAAa,EAAA,OAAA,CAAA,QAAA,GAAA,QAAA;AAwBb;;;;;;AAMG;;AACI,MAAM,mBAAmB,GAAG,SAAtB,mBAAsB,CAAC,GAAD,EAAuB;AACxD,QAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,YAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACD;;AAED,WAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AACjC,UAAI,OAAO,CAAC,IAAR,KAAiB,SAArB,EAAgC;AAC9B;AACA,cAAM,IAAI,KAAJ,CAAU,yEAAV,CAAN;AACD;;AAED,MAAA,OAAO,CAAC,IAAR,CAAa,GAAb,EAAkB,UAAC,GAAD,EAAgB;AAAK,eAAC,GAAG,KAAK,IAAT,GAAiB,OAAO,EAAxB,GAA6B,MAAM,CAAnC,GAAmC,CAAnC;AAAwC,OAA/E;AACD,KAPM,CAAP;AAQD,GAbM;;AAAM,EAAA,OAAA,CAAA,mBAAA,GAAmB,mBAAnB;AAeb;;;;;;;AAOG;;AACI,MAAM,mBAAmB,GAAG,SAAtB,mBAAsB,CAAC,QAAD,EAAmB,GAAnB,EAAuC;AACxE,QAAI,CAAC,OAAO,CAAC,QAAb,EAAuB;AACrB,YAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACD;;AAED,QAAM,MAAM,GAAG,OAAO,CAAC,OAAR,CAAgB,QAAhB,CAAf;;AAEA,QAAK,MAAM,KAAK,SAAZ,IAA0B,MAAM,CAAC,MAAP,EAA1B,IAA6C,CAAC,MAAM,CAAC,WAAP,EAAlD,EAAwE;AACtE,YAAM,IAAI,KAAJ,CACF,yFADE,CAAN;AAED;;AAED,WAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AACjC,MAAA,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,UAAC,GAAD,EAAgB;AAAK,eAAC,GAAG,KAAK,IAAT,GAAiB,OAAO,EAAxB,GAA6B,MAAM,CAAnC,GAAmC,CAAnC;AAAwC,OAA9E;AACD,KAFM,CAAP;AAGD,GAfM;;AAAM,EAAA,OAAA,CAAA,mBAAA,GAAmB,mBAAnB","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/// <reference types=\"node\" />\n\nimport * as cluster from 'cluster';\n\nimport {MessageFromWorker, MessageToWorker} from './api';\n\n\n\n/** Expose a `Promise` instance as well as APIs for resolving/rejecting it. */\nexport class Deferred<T> {\n  /**\n   * Resolve the associated promise with the specified value.\n   * If the value is a rejection (constructed with `Promise.reject()`), the promise will be rejected\n   * instead.\n   *\n   * @param value The value to resolve the promise with.\n   */\n  resolve!: (value: T) => void;\n\n  /**\n   * Rejects the associated promise with the specified reason.\n   *\n   * @param reason The rejection reason.\n   */\n  reject!: (reason: any) => void;\n\n  /** The `Promise` instance associated with this deferred. */\n  promise = new Promise<T>((resolve, reject) => {\n    this.resolve = resolve;\n    this.reject = reject;\n  });\n}\n\n/**\n * Send a message to the cluster master.\n * (This function should be invoked from cluster workers only.)\n *\n * @param msg The message to send to the cluster master.\n * @return A promise that is resolved once the message has been sent.\n */\nexport const sendMessageToMaster = (msg: MessageFromWorker): Promise<void> => {\n  if (cluster.isMaster) {\n    throw new Error('Unable to send message to the master process: Already on the master process.');\n  }\n\n  return new Promise((resolve, reject) => {\n    if (process.send === undefined) {\n      // Theoretically, this should never happen on a worker process.\n      throw new Error('Unable to send message to the master process: Missing `process.send()`.');\n    }\n\n    process.send(msg, (err: Error|null) => (err === null) ? resolve() : reject(err));\n  });\n};\n\n/**\n * Send a message to a cluster worker.\n * (This function should be invoked from the cluster master only.)\n *\n * @param workerId The ID of the recipient worker.\n * @param msg The message to send to the worker.\n * @return A promise that is resolved once the message has been sent.\n */\nexport const sendMessageToWorker = (workerId: number, msg: MessageToWorker): Promise<void> => {\n  if (!cluster.isMaster) {\n    throw new Error('Unable to send message to worker process: Sender is not the master process.');\n  }\n\n  const worker = cluster.workers[workerId];\n\n  if ((worker === undefined) || worker.isDead() || !worker.isConnected()) {\n    throw new Error(\n        'Unable to send message to worker process: Recipient does not exist or has disconnected.');\n  }\n\n  return new Promise((resolve, reject) => {\n    worker.send(msg, (err: Error|null) => (err === null) ? resolve() : reject(err));\n  });\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}