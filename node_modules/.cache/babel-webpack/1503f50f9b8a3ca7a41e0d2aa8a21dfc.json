{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/metadata/src/dts\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/metadata/src/property_mapping\", \"@angular/compiler-cli/src/ngtsc/metadata/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.DtsMetadataReader = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var property_mapping_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata/src/property_mapping\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata/src/util\");\n  /**\n   * A `MetadataReader` that can read metadata from `.d.ts` files, which have static Ivy properties\n   * from an upstream compilation already.\n   */\n\n\n  var DtsMetadataReader =\n  /** @class */\n  function () {\n    function DtsMetadataReader(checker, reflector) {\n      this.checker = checker;\n      this.reflector = reflector;\n    }\n    /**\n     * Read the metadata from a class that has already been compiled somehow (either it's in a .d.ts\n     * file, or in a .ts file with a handwritten definition).\n     *\n     * @param ref `Reference` to the class of interest, with the context of how it was obtained.\n     */\n\n\n    DtsMetadataReader.prototype.getNgModuleMetadata = function (ref) {\n      var clazz = ref.node;\n      var resolutionContext = clazz.getSourceFile().fileName; // This operation is explicitly not memoized, as it depends on `ref.ownedByModuleGuess`.\n      // TODO(alxhub): investigate caching of .d.ts module metadata.\n\n      var ngModuleDef = this.reflector.getMembersOfClass(clazz).find(function (member) {\n        return member.name === 'ɵmod' && member.isStatic;\n      });\n\n      if (ngModuleDef === undefined) {\n        return null;\n      } else if ( // Validate that the shape of the ngModuleDef type is correct.\n      ngModuleDef.type === null || !ts.isTypeReferenceNode(ngModuleDef.type) || ngModuleDef.type.typeArguments === undefined || ngModuleDef.type.typeArguments.length !== 4) {\n        return null;\n      } // Read the ModuleData out of the type arguments.\n\n\n      var _a = tslib_1.__read(ngModuleDef.type.typeArguments, 4),\n          _ = _a[0],\n          declarationMetadata = _a[1],\n          importMetadata = _a[2],\n          exportMetadata = _a[3];\n\n      return {\n        ref: ref,\n        declarations: util_1.extractReferencesFromType(this.checker, declarationMetadata, ref.ownedByModuleGuess, resolutionContext),\n        exports: util_1.extractReferencesFromType(this.checker, exportMetadata, ref.ownedByModuleGuess, resolutionContext),\n        imports: util_1.extractReferencesFromType(this.checker, importMetadata, ref.ownedByModuleGuess, resolutionContext),\n        schemas: [],\n        rawDeclarations: null\n      };\n    };\n    /**\n     * Read directive (or component) metadata from a referenced class in a .d.ts file.\n     */\n\n\n    DtsMetadataReader.prototype.getDirectiveMetadata = function (ref) {\n      var clazz = ref.node;\n      var def = this.reflector.getMembersOfClass(clazz).find(function (field) {\n        return field.isStatic && (field.name === 'ɵcmp' || field.name === 'ɵdir');\n      });\n\n      if (def === undefined) {\n        // No definition could be found.\n        return null;\n      } else if (def.type === null || !ts.isTypeReferenceNode(def.type) || def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {\n        // The type metadata was the wrong shape.\n        return null;\n      }\n\n      var isComponent = def.name === 'ɵcmp';\n      var ctorParams = this.reflector.getConstructorParameters(clazz); // A directive is considered to be structural if:\n      // 1) it's a directive, not a component, and\n      // 2) it injects `TemplateRef`\n\n      var isStructural = !isComponent && ctorParams !== null && ctorParams.some(function (param) {\n        return param.typeValueReference.kind === 1\n        /* IMPORTED */\n        && param.typeValueReference.moduleName === '@angular/core' && param.typeValueReference.importedName === 'TemplateRef';\n      });\n      var inputs = property_mapping_1.ClassPropertyMapping.fromMappedObject(util_1.readStringMapType(def.type.typeArguments[3]));\n      var outputs = property_mapping_1.ClassPropertyMapping.fromMappedObject(util_1.readStringMapType(def.type.typeArguments[4]));\n      return tslib_1.__assign(tslib_1.__assign({\n        ref: ref,\n        name: clazz.name.text,\n        isComponent: isComponent,\n        selector: util_1.readStringType(def.type.typeArguments[1]),\n        exportAs: util_1.readStringArrayType(def.type.typeArguments[2]),\n        inputs: inputs,\n        outputs: outputs,\n        queries: util_1.readStringArrayType(def.type.typeArguments[5])\n      }, util_1.extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector)), {\n        baseClass: readBaseClass(clazz, this.checker, this.reflector),\n        isPoisoned: false,\n        isStructural: isStructural\n      });\n    };\n    /**\n     * Read pipe metadata from a referenced class in a .d.ts file.\n     */\n\n\n    DtsMetadataReader.prototype.getPipeMetadata = function (ref) {\n      var def = this.reflector.getMembersOfClass(ref.node).find(function (field) {\n        return field.isStatic && field.name === 'ɵpipe';\n      });\n\n      if (def === undefined) {\n        // No definition could be found.\n        return null;\n      } else if (def.type === null || !ts.isTypeReferenceNode(def.type) || def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {\n        // The type metadata was the wrong shape.\n        return null;\n      }\n\n      var type = def.type.typeArguments[1];\n\n      if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {\n        // The type metadata was the wrong type.\n        return null;\n      }\n\n      var name = type.literal.text;\n      return {\n        ref: ref,\n        name: name\n      };\n    };\n\n    return DtsMetadataReader;\n  }();\n\n  exports.DtsMetadataReader = DtsMetadataReader;\n\n  function readBaseClass(clazz, checker, reflector) {\n    var e_1, _a;\n\n    if (!reflection_1.isNamedClassDeclaration(clazz)) {\n      // Technically this is an error in a .d.ts file, but for the purposes of finding the base class\n      // it's ignored.\n      return reflector.hasBaseClass(clazz) ? 'dynamic' : null;\n    }\n\n    if (clazz.heritageClauses !== undefined) {\n      try {\n        for (var _b = tslib_1.__values(clazz.heritageClauses), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var clause = _c.value;\n\n          if (clause.token === ts.SyntaxKind.ExtendsKeyword) {\n            var baseExpr = clause.types[0].expression;\n            var symbol = checker.getSymbolAtLocation(baseExpr);\n\n            if (symbol === undefined) {\n              return 'dynamic';\n            } else if (symbol.flags & ts.SymbolFlags.Alias) {\n              symbol = checker.getAliasedSymbol(symbol);\n            }\n\n            if (symbol.valueDeclaration !== undefined && reflection_1.isNamedClassDeclaration(symbol.valueDeclaration)) {\n              return new imports_1.Reference(symbol.valueDeclaration);\n            } else {\n              return 'dynamic';\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    return null;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/dts.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration, isNamedClassDeclaration, ReflectionHost, TypeValueReferenceKind} from '../../reflection';\n\nimport {DirectiveMeta, MetadataReader, NgModuleMeta, PipeMeta} from './api';\nimport {ClassPropertyMapping} from './property_mapping';\nimport {extractDirectiveTypeCheckMeta, extractReferencesFromType, readStringArrayType, readStringMapType, readStringType} from './util';\n\n/**\n * A `MetadataReader` that can read metadata from `.d.ts` files, which have static Ivy properties\n * from an upstream compilation already.\n */\nexport class DtsMetadataReader implements MetadataReader {\n  constructor(private checker: ts.TypeChecker, private reflector: ReflectionHost) {}\n\n  /**\n   * Read the metadata from a class that has already been compiled somehow (either it's in a .d.ts\n   * file, or in a .ts file with a handwritten definition).\n   *\n   * @param ref `Reference` to the class of interest, with the context of how it was obtained.\n   */\n  getNgModuleMetadata(ref: Reference<ClassDeclaration>): NgModuleMeta|null {\n    const clazz = ref.node;\n    const resolutionContext = clazz.getSourceFile().fileName;\n    // This operation is explicitly not memoized, as it depends on `ref.ownedByModuleGuess`.\n    // TODO(alxhub): investigate caching of .d.ts module metadata.\n    const ngModuleDef = this.reflector.getMembersOfClass(clazz).find(\n        member => member.name === 'ɵmod' && member.isStatic);\n    if (ngModuleDef === undefined) {\n      return null;\n    } else if (\n        // Validate that the shape of the ngModuleDef type is correct.\n        ngModuleDef.type === null || !ts.isTypeReferenceNode(ngModuleDef.type) ||\n        ngModuleDef.type.typeArguments === undefined ||\n        ngModuleDef.type.typeArguments.length !== 4) {\n      return null;\n    }\n\n    // Read the ModuleData out of the type arguments.\n    const [_, declarationMetadata, importMetadata, exportMetadata] = ngModuleDef.type.typeArguments;\n    return {\n      ref,\n      declarations: extractReferencesFromType(\n          this.checker, declarationMetadata, ref.ownedByModuleGuess, resolutionContext),\n      exports: extractReferencesFromType(\n          this.checker, exportMetadata, ref.ownedByModuleGuess, resolutionContext),\n      imports: extractReferencesFromType(\n          this.checker, importMetadata, ref.ownedByModuleGuess, resolutionContext),\n      schemas: [],\n      rawDeclarations: null,\n    };\n  }\n\n  /**\n   * Read directive (or component) metadata from a referenced class in a .d.ts file.\n   */\n  getDirectiveMetadata(ref: Reference<ClassDeclaration>): DirectiveMeta|null {\n    const clazz = ref.node;\n    const def = this.reflector.getMembersOfClass(clazz).find(\n        field => field.isStatic && (field.name === 'ɵcmp' || field.name === 'ɵdir'));\n    if (def === undefined) {\n      // No definition could be found.\n      return null;\n    } else if (\n        def.type === null || !ts.isTypeReferenceNode(def.type) ||\n        def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {\n      // The type metadata was the wrong shape.\n      return null;\n    }\n\n    const isComponent = def.name === 'ɵcmp';\n\n    const ctorParams = this.reflector.getConstructorParameters(clazz);\n\n    // A directive is considered to be structural if:\n    // 1) it's a directive, not a component, and\n    // 2) it injects `TemplateRef`\n    const isStructural = !isComponent && ctorParams !== null && ctorParams.some(param => {\n      return param.typeValueReference.kind === TypeValueReferenceKind.IMPORTED &&\n          param.typeValueReference.moduleName === '@angular/core' &&\n          param.typeValueReference.importedName === 'TemplateRef';\n    });\n\n    const inputs =\n        ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[3]));\n    const outputs =\n        ClassPropertyMapping.fromMappedObject(readStringMapType(def.type.typeArguments[4]));\n    return {\n      ref,\n      name: clazz.name.text,\n      isComponent,\n      selector: readStringType(def.type.typeArguments[1]),\n      exportAs: readStringArrayType(def.type.typeArguments[2]),\n      inputs,\n      outputs,\n      queries: readStringArrayType(def.type.typeArguments[5]),\n      ...extractDirectiveTypeCheckMeta(clazz, inputs, this.reflector),\n      baseClass: readBaseClass(clazz, this.checker, this.reflector),\n      isPoisoned: false,\n      isStructural,\n    };\n  }\n\n  /**\n   * Read pipe metadata from a referenced class in a .d.ts file.\n   */\n  getPipeMetadata(ref: Reference<ClassDeclaration>): PipeMeta|null {\n    const def = this.reflector.getMembersOfClass(ref.node).find(\n        field => field.isStatic && field.name === 'ɵpipe');\n    if (def === undefined) {\n      // No definition could be found.\n      return null;\n    } else if (\n        def.type === null || !ts.isTypeReferenceNode(def.type) ||\n        def.type.typeArguments === undefined || def.type.typeArguments.length < 2) {\n      // The type metadata was the wrong shape.\n      return null;\n    }\n    const type = def.type.typeArguments[1];\n    if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {\n      // The type metadata was the wrong type.\n      return null;\n    }\n    const name = type.literal.text;\n    return {ref, name};\n  }\n}\n\nfunction readBaseClass(clazz: ClassDeclaration, checker: ts.TypeChecker, reflector: ReflectionHost):\n    Reference<ClassDeclaration>|'dynamic'|null {\n  if (!isNamedClassDeclaration(clazz)) {\n    // Technically this is an error in a .d.ts file, but for the purposes of finding the base class\n    // it's ignored.\n    return reflector.hasBaseClass(clazz) ? 'dynamic' : null;\n  }\n\n  if (clazz.heritageClauses !== undefined) {\n    for (const clause of clazz.heritageClauses) {\n      if (clause.token === ts.SyntaxKind.ExtendsKeyword) {\n        const baseExpr = clause.types[0].expression;\n        let symbol = checker.getSymbolAtLocation(baseExpr);\n        if (symbol === undefined) {\n          return 'dynamic';\n        } else if (symbol.flags & ts.SymbolFlags.Alias) {\n          symbol = checker.getAliasedSymbol(symbol);\n        }\n        if (symbol.valueDeclaration !== undefined &&\n            isNamedClassDeclaration(symbol.valueDeclaration)) {\n          return new Reference(symbol.valueDeclaration);\n        } else {\n          return 'dynamic';\n        }\n      }\n    }\n  }\n  return null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}