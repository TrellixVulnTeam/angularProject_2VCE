{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n/** @typedef {import(\"../Module\")} Module */\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar DependencyReference = /*#__PURE__*/function () {\n  // TODO webpack 5: module must be dynamic, you must pass a function returning a module\n  // This is needed to remove the hack in ConcatenatedModule\n  // The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\n  /**\n   *\n   * @param {Module} module the referenced module\n   * @param {string[] | boolean} importedNames imported named from the module\n   * @param {boolean=} weak if this is a weak reference\n   * @param {number} order the order information or NaN if don't care\n   */\n  function DependencyReference(module, importedNames) {\n    var weak = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NaN;\n\n    _classCallCheck(this, DependencyReference);\n\n    // TODO webpack 5: make it a getter\n    this.module = module; // true: full object\n    // false: only sideeffects/no export\n    // array of strings: the exports with this names\n\n    this.importedNames = importedNames;\n    this.weak = !!weak;\n    this.order = order;\n  }\n  /**\n   * @param {DependencyReference[]} array an array (will be modified)\n   * @returns {DependencyReference[]} the array again\n   */\n\n\n  _createClass(DependencyReference, null, [{\n    key: \"sort\",\n    value: function sort(array) {\n      /** @type {WeakMap<DependencyReference, number>} */\n      var originalOrder = new WeakMap();\n      var i = 0;\n\n      var _iterator = _createForOfIteratorHelper(array),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ref = _step.value;\n          originalOrder.set(ref, i++);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return array.sort(function (a, b) {\n        var aOrder = a.order;\n        var bOrder = b.order;\n\n        if (isNaN(aOrder)) {\n          if (!isNaN(bOrder)) {\n            return 1;\n          }\n        } else {\n          if (isNaN(bOrder)) {\n            return -1;\n          }\n\n          if (aOrder !== bOrder) {\n            return aOrder - bOrder;\n          }\n        }\n\n        var aOrg = originalOrder.get(a);\n        var bOrg = originalOrder.get(b);\n        return aOrg - bOrg;\n      });\n    }\n  }]);\n\n  return DependencyReference;\n}();\n\nmodule.exports = DependencyReference;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/dependencies/DependencyReference.js"],"names":["DependencyReference","module","importedNames","weak","order","NaN","array","originalOrder","WeakMap","i","ref","set","sort","a","b","aOrder","bOrder","isNaN","aOrg","get","bOrg","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;IAEMA,mB;AACL;AACA;AACA;;AACA;AACD;AACA;AACA;AACA;AACA;AACA;AACC,+BAAYC,MAAZ,EAAoBC,aAApB,EAA8D;AAAA,QAA3BC,IAA2B,uEAApB,KAAoB;AAAA,QAAbC,KAAa,uEAALC,GAAK;;AAAA;;AAC7D;AACA,SAAKJ,MAAL,GAAcA,MAAd,CAF6D,CAG7D;AACA;AACA;;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,IAAL,GAAY,CAAC,CAACA,IAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA;AAED;AACD;AACA;AACA;;;;;WACC,cAAYE,KAAZ,EAAmB;AAClB;AACA,UAAMC,aAAa,GAAG,IAAIC,OAAJ,EAAtB;AACA,UAAIC,CAAC,GAAG,CAAR;;AAHkB,iDAIAH,KAJA;AAAA;;AAAA;AAIlB,4DAAyB;AAAA,cAAdI,GAAc;AACxBH,UAAAA,aAAa,CAACI,GAAd,CAAkBD,GAAlB,EAAuBD,CAAC,EAAxB;AACA;AANiB;AAAA;AAAA;AAAA;AAAA;;AAOlB,aAAOH,KAAK,CAACM,IAAN,CAAW,UAACC,CAAD,EAAIC,CAAJ,EAAU;AAC3B,YAAMC,MAAM,GAAGF,CAAC,CAACT,KAAjB;AACA,YAAMY,MAAM,GAAGF,CAAC,CAACV,KAAjB;;AACA,YAAIa,KAAK,CAACF,MAAD,CAAT,EAAmB;AAClB,cAAI,CAACE,KAAK,CAACD,MAAD,CAAV,EAAoB;AACnB,mBAAO,CAAP;AACA;AACD,SAJD,MAIO;AACN,cAAIC,KAAK,CAACD,MAAD,CAAT,EAAmB;AAClB,mBAAO,CAAC,CAAR;AACA;;AACD,cAAID,MAAM,KAAKC,MAAf,EAAuB;AACtB,mBAAOD,MAAM,GAAGC,MAAhB;AACA;AACD;;AACD,YAAME,IAAI,GAAGX,aAAa,CAACY,GAAd,CAAkBN,CAAlB,CAAb;AACA,YAAMO,IAAI,GAAGb,aAAa,CAACY,GAAd,CAAkBL,CAAlB,CAAb;AACA,eAAOI,IAAI,GAAGE,IAAd;AACA,OAlBM,CAAP;AAmBA;;;;;;AAGFnB,MAAM,CAACoB,OAAP,GAAiBrB,mBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Florent Cailhol @ooflorent\n*/\n\"use strict\";\n\n/** @typedef {import(\"../Module\")} Module */\n\nclass DependencyReference {\n\t// TODO webpack 5: module must be dynamic, you must pass a function returning a module\n\t// This is needed to remove the hack in ConcatenatedModule\n\t// The problem is that the `module` in Dependency could be replaced i. e. because of Scope Hoisting\n\t/**\n\t *\n\t * @param {Module} module the referenced module\n\t * @param {string[] | boolean} importedNames imported named from the module\n\t * @param {boolean=} weak if this is a weak reference\n\t * @param {number} order the order information or NaN if don't care\n\t */\n\tconstructor(module, importedNames, weak = false, order = NaN) {\n\t\t// TODO webpack 5: make it a getter\n\t\tthis.module = module;\n\t\t// true: full object\n\t\t// false: only sideeffects/no export\n\t\t// array of strings: the exports with this names\n\t\tthis.importedNames = importedNames;\n\t\tthis.weak = !!weak;\n\t\tthis.order = order;\n\t}\n\n\t/**\n\t * @param {DependencyReference[]} array an array (will be modified)\n\t * @returns {DependencyReference[]} the array again\n\t */\n\tstatic sort(array) {\n\t\t/** @type {WeakMap<DependencyReference, number>} */\n\t\tconst originalOrder = new WeakMap();\n\t\tlet i = 0;\n\t\tfor (const ref of array) {\n\t\t\toriginalOrder.set(ref, i++);\n\t\t}\n\t\treturn array.sort((a, b) => {\n\t\t\tconst aOrder = a.order;\n\t\t\tconst bOrder = b.order;\n\t\t\tif (isNaN(aOrder)) {\n\t\t\t\tif (!isNaN(bOrder)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (isNaN(bOrder)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (aOrder !== bOrder) {\n\t\t\t\t\treturn aOrder - bOrder;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst aOrg = originalOrder.get(a);\n\t\t\tconst bOrg = originalOrder.get(b);\n\t\t\treturn aOrg - bOrg;\n\t\t});\n\t}\n}\n\nmodule.exports = DependencyReference;\n"]},"metadata":{},"sourceType":"script"}