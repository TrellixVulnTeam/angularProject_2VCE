{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nvar _require = require('util'),\n    promisify = _require.promisify;\n\nvar pLocate = require('p-locate');\n\nvar fsStat = promisify(fs.stat);\nvar fsLStat = promisify(fs.lstat);\nvar typeMappings = {\n  directory: 'isDirectory',\n  file: 'isFile'\n};\n\nfunction checkType(_ref) {\n  var type = _ref.type;\n\n  if (type in typeMappings) {\n    return;\n  }\n\n  throw new Error(\"Invalid type specified: \".concat(type));\n}\n\nvar matchType = function matchType(type, stat) {\n  return type === undefined || stat[typeMappings[type]]();\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(paths, options) {\n    var statFn;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _objectSpread({\n              cwd: process.cwd(),\n              type: 'file',\n              allowSymlinks: true\n            }, options);\n            checkType(options);\n            statFn = options.allowSymlinks ? fsStat : fsLStat;\n            return _context2.abrupt(\"return\", pLocate(paths, /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path_) {\n                var stat;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return statFn(path.resolve(options.cwd, path_));\n\n                      case 3:\n                        stat = _context.sent;\n                        return _context.abrupt(\"return\", matchType(options.type, stat));\n\n                      case 7:\n                        _context.prev = 7;\n                        _context.t0 = _context[\"catch\"](0);\n                        return _context.abrupt(\"return\", false);\n\n                      case 10:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 7]]);\n              }));\n\n              return function (_x3) {\n                return _ref3.apply(this, arguments);\n              };\n            }(), options));\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmodule.exports.sync = function (paths, options) {\n  options = _objectSpread({\n    cwd: process.cwd(),\n    allowSymlinks: true,\n    type: 'file'\n  }, options);\n  checkType(options);\n  var statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;\n\n  var _iterator = _createForOfIteratorHelper(paths),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var path_ = _step.value;\n\n      try {\n        var stat = statFn(path.resolve(options.cwd, path_));\n\n        if (matchType(options.type, stat)) {\n          return path_;\n        }\n      } catch (_) {}\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/find-cache-dir/node_modules/locate-path/index.js"],"names":["path","require","fs","promisify","pLocate","fsStat","stat","fsLStat","lstat","typeMappings","directory","file","checkType","type","Error","matchType","undefined","module","exports","paths","options","cwd","process","allowSymlinks","statFn","path_","resolve","sync","statSync","lstatSync","_"],"mappings":"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","sourcesContent":["'use strict';\nconst path = require('path');\nconst fs = require('fs');\nconst {promisify} = require('util');\nconst pLocate = require('p-locate');\n\nconst fsStat = promisify(fs.stat);\nconst fsLStat = promisify(fs.lstat);\n\nconst typeMappings = {\n\tdirectory: 'isDirectory',\n\tfile: 'isFile'\n};\n\nfunction checkType({type}) {\n\tif (type in typeMappings) {\n\t\treturn;\n\t}\n\n\tthrow new Error(`Invalid type specified: ${type}`);\n}\n\nconst matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();\n\nmodule.exports = async (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\ttype: 'file',\n\t\tallowSymlinks: true,\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fsStat : fsLStat;\n\n\treturn pLocate(paths, async path_ => {\n\t\ttry {\n\t\t\tconst stat = await statFn(path.resolve(options.cwd, path_));\n\t\t\treturn matchType(options.type, stat);\n\t\t} catch (_) {\n\t\t\treturn false;\n\t\t}\n\t}, options);\n};\n\nmodule.exports.sync = (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\tallowSymlinks: true,\n\t\ttype: 'file',\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;\n\n\tfor (const path_ of paths) {\n\t\ttry {\n\t\t\tconst stat = statFn(path.resolve(options.cwd, path_));\n\n\t\t\tif (matchType(options.type, stat)) {\n\t\t\t\treturn path_;\n\t\t\t}\n\t\t} catch (_) {\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}