{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/file_system/src/helpers\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/file_system/src/invalid_file_system\", \"@angular/compiler-cli/src/ngtsc/file_system/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.toRelativeImport = exports.isLocalRelativePath = exports.basename = exports.relative = exports.isRooted = exports.isRoot = exports.resolve = exports.join = exports.dirname = exports.relativeFrom = exports.absoluteFromSourceFile = exports.absoluteFrom = exports.setFileSystem = exports.getFileSystem = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var invalid_file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system/src/invalid_file_system\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system/src/util\");\n\n  var fs = new invalid_file_system_1.InvalidFileSystem();\n\n  function getFileSystem() {\n    return fs;\n  }\n\n  exports.getFileSystem = getFileSystem;\n\n  function setFileSystem(fileSystem) {\n    fs = fileSystem;\n  }\n\n  exports.setFileSystem = setFileSystem;\n  /**\n   * Convert the path `path` to an `AbsoluteFsPath`, throwing an error if it's not an absolute path.\n   */\n\n  function absoluteFrom(path) {\n    if (!fs.isRooted(path)) {\n      throw new Error(\"Internal Error: absoluteFrom(\" + path + \"): path is not absolute\");\n    }\n\n    return fs.resolve(path);\n  }\n\n  exports.absoluteFrom = absoluteFrom;\n  /**\n   * Extract an `AbsoluteFsPath` from a `ts.SourceFile`.\n   */\n\n  function absoluteFromSourceFile(sf) {\n    return fs.resolve(sf.fileName);\n  }\n\n  exports.absoluteFromSourceFile = absoluteFromSourceFile;\n  /**\n   * Convert the path `path` to a `PathSegment`, throwing an error if it's not a relative path.\n   */\n\n  function relativeFrom(path) {\n    var normalized = util_1.normalizeSeparators(path);\n\n    if (fs.isRooted(normalized)) {\n      throw new Error(\"Internal Error: relativeFrom(\" + path + \"): path is not relative\");\n    }\n\n    return normalized;\n  }\n\n  exports.relativeFrom = relativeFrom;\n  /**\n   * Static access to `dirname`.\n   */\n\n  function dirname(file) {\n    return fs.dirname(file);\n  }\n\n  exports.dirname = dirname;\n  /**\n   * Static access to `join`.\n   */\n\n  function join(basePath) {\n    var paths = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      paths[_i - 1] = arguments[_i];\n    }\n\n    return fs.join.apply(fs, tslib_1.__spread([basePath], paths));\n  }\n\n  exports.join = join;\n  /**\n   * Static access to `resolve`s.\n   */\n\n  function resolve(basePath) {\n    var paths = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      paths[_i - 1] = arguments[_i];\n    }\n\n    return fs.resolve.apply(fs, tslib_1.__spread([basePath], paths));\n  }\n\n  exports.resolve = resolve;\n  /** Returns true when the path provided is the root path. */\n\n  function isRoot(path) {\n    return fs.isRoot(path);\n  }\n\n  exports.isRoot = isRoot;\n  /**\n   * Static access to `isRooted`.\n   */\n\n  function isRooted(path) {\n    return fs.isRooted(path);\n  }\n\n  exports.isRooted = isRooted;\n  /**\n   * Static access to `relative`.\n   */\n\n  function relative(from, to) {\n    return fs.relative(from, to);\n  }\n\n  exports.relative = relative;\n  /**\n   * Static access to `basename`.\n   */\n\n  function basename(filePath, extension) {\n    return fs.basename(filePath, extension);\n  }\n\n  exports.basename = basename;\n  /**\n   * Returns true if the given path is locally relative.\n   *\n   * This is used to work out if the given path is relative (i.e. not absolute) but also is not\n   * escaping the current directory.\n   */\n\n  function isLocalRelativePath(relativePath) {\n    return !isRooted(relativePath) && !relativePath.startsWith('..');\n  }\n\n  exports.isLocalRelativePath = isLocalRelativePath;\n  /**\n   * Converts a path to a form suitable for use as a relative module import specifier.\n   *\n   * In other words it adds the `./` to the path if it is locally relative.\n   */\n\n  function toRelativeImport(relativePath) {\n    return isLocalRelativePath(relativePath) ? \"./\" + relativePath : relativePath;\n  }\n\n  exports.toRelativeImport = toRelativeImport;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/file_system/src/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {InvalidFileSystem} from './invalid_file_system';\nimport {AbsoluteFsPath, FileSystem, PathSegment, PathString} from './types';\nimport {normalizeSeparators} from './util';\n\nlet fs: FileSystem = new InvalidFileSystem();\nexport function getFileSystem(): FileSystem {\n  return fs;\n}\nexport function setFileSystem(fileSystem: FileSystem) {\n  fs = fileSystem;\n}\n\n/**\n * Convert the path `path` to an `AbsoluteFsPath`, throwing an error if it's not an absolute path.\n */\nexport function absoluteFrom(path: string): AbsoluteFsPath {\n  if (!fs.isRooted(path)) {\n    throw new Error(`Internal Error: absoluteFrom(${path}): path is not absolute`);\n  }\n  return fs.resolve(path);\n}\n\n/**\n * Extract an `AbsoluteFsPath` from a `ts.SourceFile`.\n */\nexport function absoluteFromSourceFile(sf: ts.SourceFile): AbsoluteFsPath {\n  return fs.resolve(sf.fileName);\n}\n\n/**\n * Convert the path `path` to a `PathSegment`, throwing an error if it's not a relative path.\n */\nexport function relativeFrom(path: string): PathSegment {\n  const normalized = normalizeSeparators(path);\n  if (fs.isRooted(normalized)) {\n    throw new Error(`Internal Error: relativeFrom(${path}): path is not relative`);\n  }\n  return normalized as PathSegment;\n}\n\n/**\n * Static access to `dirname`.\n */\nexport function dirname<T extends PathString>(file: T): T {\n  return fs.dirname(file);\n}\n\n/**\n * Static access to `join`.\n */\nexport function join<T extends PathString>(basePath: T, ...paths: string[]): T {\n  return fs.join(basePath, ...paths);\n}\n\n/**\n * Static access to `resolve`s.\n */\nexport function resolve(basePath: string, ...paths: string[]): AbsoluteFsPath {\n  return fs.resolve(basePath, ...paths);\n}\n\n/** Returns true when the path provided is the root path. */\nexport function isRoot(path: AbsoluteFsPath): boolean {\n  return fs.isRoot(path);\n}\n\n/**\n * Static access to `isRooted`.\n */\nexport function isRooted(path: string): boolean {\n  return fs.isRooted(path);\n}\n\n/**\n * Static access to `relative`.\n */\nexport function relative<T extends PathString>(from: T, to: T): PathSegment|AbsoluteFsPath {\n  return fs.relative(from, to);\n}\n\n/**\n * Static access to `basename`.\n */\nexport function basename(filePath: PathString, extension?: string): PathSegment {\n  return fs.basename(filePath, extension) as PathSegment;\n}\n\n/**\n * Returns true if the given path is locally relative.\n *\n * This is used to work out if the given path is relative (i.e. not absolute) but also is not\n * escaping the current directory.\n */\nexport function isLocalRelativePath(relativePath: string): boolean {\n  return !isRooted(relativePath) && !relativePath.startsWith('..');\n}\n\n/**\n * Converts a path to a form suitable for use as a relative module import specifier.\n *\n * In other words it adds the `./` to the path if it is locally relative.\n */\nexport function toRelativeImport(relativePath: PathSegment|AbsoluteFsPath): PathSegment|\n    AbsoluteFsPath {\n  return isLocalRelativePath(relativePath) ? `./${relativePath}` as PathSegment : relativePath;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}