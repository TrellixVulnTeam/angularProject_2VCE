{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/file_system/src/logical\", [\"require\", \"exports\", \"@angular/compiler-cli/src/ngtsc/file_system/src/helpers\", \"@angular/compiler-cli/src/ngtsc/file_system/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.LogicalFileSystem = exports.LogicalProjectPath = void 0;\n\n  var helpers_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system/src/helpers\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system/src/util\");\n\n  exports.LogicalProjectPath = {\n    /**\n     * Get the relative path between two `LogicalProjectPath`s.\n     *\n     * This will return a `PathSegment` which would be a valid module specifier to use in `from` when\n     * importing from `to`.\n     */\n    relativePathBetween: function relativePathBetween(from, to) {\n      var relativePath = helpers_1.relative(helpers_1.dirname(helpers_1.resolve(from)), helpers_1.resolve(to));\n      return helpers_1.toRelativeImport(relativePath);\n    }\n  };\n  /**\n   * A utility class which can translate absolute paths to source files into logical paths in\n   * TypeScript's logical file system, based on the root directories of the project.\n   */\n\n  var LogicalFileSystem =\n  /** @class */\n  function () {\n    function LogicalFileSystem(rootDirs, compilerHost) {\n      var _this = this;\n\n      this.compilerHost = compilerHost;\n      /**\n       * A cache of file paths to project paths, because computation of these paths is slightly\n       * expensive.\n       */\n\n      this.cache = new Map(); // Make a copy and sort it by length in reverse order (longest first). This speeds up lookups,\n      // since there's no need to keep going through the array once a match is found.\n\n      this.rootDirs = rootDirs.concat([]).sort(function (a, b) {\n        return b.length - a.length;\n      });\n      this.canonicalRootDirs = this.rootDirs.map(function (dir) {\n        return _this.compilerHost.getCanonicalFileName(dir);\n      });\n    }\n    /**\n     * Get the logical path in the project of a `ts.SourceFile`.\n     *\n     * This method is provided as a convenient alternative to calling\n     * `logicalPathOfFile(absoluteFromSourceFile(sf))`.\n     */\n\n\n    LogicalFileSystem.prototype.logicalPathOfSf = function (sf) {\n      return this.logicalPathOfFile(helpers_1.absoluteFrom(sf.fileName));\n    };\n    /**\n     * Get the logical path in the project of a source file.\n     *\n     * @returns A `LogicalProjectPath` to the source file, or `null` if the source file is not in any\n     * of the TS project's root directories.\n     */\n\n\n    LogicalFileSystem.prototype.logicalPathOfFile = function (physicalFile) {\n      var canonicalFilePath = this.compilerHost.getCanonicalFileName(physicalFile);\n\n      if (!this.cache.has(canonicalFilePath)) {\n        var logicalFile = null;\n\n        for (var i = 0; i < this.rootDirs.length; i++) {\n          var rootDir = this.rootDirs[i];\n          var canonicalRootDir = this.canonicalRootDirs[i];\n\n          if (isWithinBasePath(canonicalRootDir, canonicalFilePath)) {\n            // Note that we match against canonical paths but then create the logical path from\n            // original paths.\n            logicalFile = this.createLogicalProjectPath(physicalFile, rootDir); // The logical project does not include any special \"node_modules\" nested directories.\n\n            if (logicalFile.indexOf('/node_modules/') !== -1) {\n              logicalFile = null;\n            } else {\n              break;\n            }\n          }\n        }\n\n        this.cache.set(canonicalFilePath, logicalFile);\n      }\n\n      return this.cache.get(canonicalFilePath);\n    };\n\n    LogicalFileSystem.prototype.createLogicalProjectPath = function (file, rootDir) {\n      var logicalPath = util_1.stripExtension(file.substr(rootDir.length));\n      return logicalPath.startsWith('/') ? logicalPath : '/' + logicalPath;\n    };\n\n    return LogicalFileSystem;\n  }();\n\n  exports.LogicalFileSystem = LogicalFileSystem;\n  /**\n   * Is the `path` a descendant of the `base`?\n   * E.g. `foo/bar/zee` is within `foo/bar` but not within `foo/car`.\n   */\n\n  function isWithinBasePath(base, path) {\n    return helpers_1.isLocalRelativePath(helpers_1.relative(base, path));\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/file_system/src/logical.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {absoluteFrom, dirname, isLocalRelativePath, relative, resolve, toRelativeImport} from './helpers';\nimport {AbsoluteFsPath, BrandedPath, PathSegment} from './types';\nimport {stripExtension} from './util';\n\n\n\n/**\n * A path that's relative to the logical root of a TypeScript project (one of the project's\n * rootDirs).\n *\n * Paths in the type system use POSIX format.\n */\nexport type LogicalProjectPath = BrandedPath<'LogicalProjectPath'>;\n\nexport const LogicalProjectPath = {\n  /**\n   * Get the relative path between two `LogicalProjectPath`s.\n   *\n   * This will return a `PathSegment` which would be a valid module specifier to use in `from` when\n   * importing from `to`.\n   */\n  relativePathBetween: function(from: LogicalProjectPath, to: LogicalProjectPath): PathSegment {\n    const relativePath = relative(dirname(resolve(from)), resolve(to));\n    return toRelativeImport(relativePath) as PathSegment;\n  },\n};\n\n/**\n * A utility class which can translate absolute paths to source files into logical paths in\n * TypeScript's logical file system, based on the root directories of the project.\n */\nexport class LogicalFileSystem {\n  /**\n   * The root directories of the project, sorted with the longest path first.\n   */\n  private rootDirs: AbsoluteFsPath[];\n\n  /**\n   * The same root directories as `rootDirs` but with each one converted to its\n   * canonical form for matching in case-insensitive file-systems.\n   */\n  private canonicalRootDirs: AbsoluteFsPath[];\n\n  /**\n   * A cache of file paths to project paths, because computation of these paths is slightly\n   * expensive.\n   */\n  private cache: Map<AbsoluteFsPath, LogicalProjectPath|null> = new Map();\n\n  constructor(\n      rootDirs: AbsoluteFsPath[],\n      private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>) {\n    // Make a copy and sort it by length in reverse order (longest first). This speeds up lookups,\n    // since there's no need to keep going through the array once a match is found.\n    this.rootDirs = rootDirs.concat([]).sort((a, b) => b.length - a.length);\n    this.canonicalRootDirs =\n        this.rootDirs.map(dir => this.compilerHost.getCanonicalFileName(dir) as AbsoluteFsPath);\n  }\n\n  /**\n   * Get the logical path in the project of a `ts.SourceFile`.\n   *\n   * This method is provided as a convenient alternative to calling\n   * `logicalPathOfFile(absoluteFromSourceFile(sf))`.\n   */\n  logicalPathOfSf(sf: ts.SourceFile): LogicalProjectPath|null {\n    return this.logicalPathOfFile(absoluteFrom(sf.fileName));\n  }\n\n  /**\n   * Get the logical path in the project of a source file.\n   *\n   * @returns A `LogicalProjectPath` to the source file, or `null` if the source file is not in any\n   * of the TS project's root directories.\n   */\n  logicalPathOfFile(physicalFile: AbsoluteFsPath): LogicalProjectPath|null {\n    const canonicalFilePath =\n        this.compilerHost.getCanonicalFileName(physicalFile) as AbsoluteFsPath;\n    if (!this.cache.has(canonicalFilePath)) {\n      let logicalFile: LogicalProjectPath|null = null;\n      for (let i = 0; i < this.rootDirs.length; i++) {\n        const rootDir = this.rootDirs[i];\n        const canonicalRootDir = this.canonicalRootDirs[i];\n        if (isWithinBasePath(canonicalRootDir, canonicalFilePath)) {\n          // Note that we match against canonical paths but then create the logical path from\n          // original paths.\n          logicalFile = this.createLogicalProjectPath(physicalFile, rootDir);\n          // The logical project does not include any special \"node_modules\" nested directories.\n          if (logicalFile.indexOf('/node_modules/') !== -1) {\n            logicalFile = null;\n          } else {\n            break;\n          }\n        }\n      }\n      this.cache.set(canonicalFilePath, logicalFile);\n    }\n    return this.cache.get(canonicalFilePath)!;\n  }\n\n  private createLogicalProjectPath(file: AbsoluteFsPath, rootDir: AbsoluteFsPath):\n      LogicalProjectPath {\n    const logicalPath = stripExtension(file.substr(rootDir.length));\n    return (logicalPath.startsWith('/') ? logicalPath : '/' + logicalPath) as LogicalProjectPath;\n  }\n}\n\n/**\n * Is the `path` a descendant of the `base`?\n * E.g. `foo/bar/zee` is within `foo/bar` but not within `foo/car`.\n */\nfunction isWithinBasePath(base: AbsoluteFsPath, path: AbsoluteFsPath): boolean {\n  return isLocalRelativePath(relative(base, path));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}