{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/entry_point\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/ngcc/src/host/umd_host\", \"@angular/compiler-cli/ngcc/src/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getEntryPointFormat = exports.isEntryPoint = exports.getEntryPointInfo = exports.INCOMPATIBLE_ENTRY_POINT = exports.IGNORED_ENTRY_POINT = exports.NO_ENTRY_POINT = exports.SUPPORTED_FORMAT_PROPERTIES = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var umd_host_1 = require(\"@angular/compiler-cli/ngcc/src/host/umd_host\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/utils\"); // We need to keep the elements of this const and the `EntryPointJsonProperty` type in sync.\n\n\n  exports.SUPPORTED_FORMAT_PROPERTIES = ['fesm2015', 'fesm5', 'es2015', 'esm2015', 'esm5', 'main', 'module', 'browser'];\n  /**\n   * The path does not represent an entry-point, i.e. there is no package.json at the path and there\n   * is no config to force an entry-point.\n   */\n\n  exports.NO_ENTRY_POINT = 'no-entry-point';\n  /**\n   * The path represents an entry-point that is `ignored` by an ngcc config.\n   */\n\n  exports.IGNORED_ENTRY_POINT = 'ignored-entry-point';\n  /**\n   * The path has a package.json, but it is not a valid entry-point for ngcc processing.\n   */\n\n  exports.INCOMPATIBLE_ENTRY_POINT = 'incompatible-entry-point';\n  /**\n   * Try to create an entry-point from the given paths and properties.\n   *\n   * @param packagePath the absolute path to the containing npm package\n   * @param entryPointPath the absolute path to the potential entry-point.\n   * @returns\n   * - An entry-point if it is valid and not ignored.\n   * - `NO_ENTRY_POINT` when there is no package.json at the path and there is no config to force an\n   *   entry-point,\n   * - `IGNORED_ENTRY_POINT` when the entry-point is ignored by an ngcc config.\n   * - `INCOMPATIBLE_ENTRY_POINT` when there is a package.json but it is not a valid Angular compiled\n   *   entry-point.\n   */\n\n  function getEntryPointInfo(fs, config, logger, packagePath, entryPointPath) {\n    var packagePackageJsonPath = fs.resolve(packagePath, 'package.json');\n    var entryPointPackageJsonPath = fs.resolve(entryPointPath, 'package.json');\n    var loadedPackagePackageJson = loadPackageJson(fs, packagePackageJsonPath);\n    var loadedEntryPointPackageJson = packagePackageJsonPath === entryPointPackageJsonPath ? loadedPackagePackageJson : loadPackageJson(fs, entryPointPackageJsonPath);\n\n    var _a = getPackageNameAndVersion(fs, packagePath, loadedPackagePackageJson, loadedEntryPointPackageJson),\n        packageName = _a.packageName,\n        packageVersion = _a.packageVersion;\n\n    var packageConfig = config.getPackageConfig(packageName, packagePath, packageVersion);\n    var entryPointConfig = packageConfig.entryPoints.get(entryPointPath);\n    var entryPointPackageJson;\n\n    if (entryPointConfig === undefined) {\n      if (!fs.exists(entryPointPackageJsonPath)) {\n        // No `package.json` and no config.\n        return exports.NO_ENTRY_POINT;\n      } else if (loadedEntryPointPackageJson === null) {\n        // `package.json` exists but could not be parsed and there is no redeeming config.\n        logger.warn(\"Failed to read entry point info from invalid 'package.json' file: \" + entryPointPackageJsonPath);\n        return exports.INCOMPATIBLE_ENTRY_POINT;\n      } else {\n        entryPointPackageJson = loadedEntryPointPackageJson;\n      }\n    } else if (entryPointConfig.ignore === true) {\n      // Explicitly ignored entry-point.\n      return exports.IGNORED_ENTRY_POINT;\n    } else {\n      entryPointPackageJson = mergeConfigAndPackageJson(fs, loadedEntryPointPackageJson, entryPointConfig, packagePath, entryPointPath);\n    }\n\n    var typings = entryPointPackageJson.typings || entryPointPackageJson.types || guessTypingsFromPackageJson(fs, entryPointPath, entryPointPackageJson);\n\n    if (typeof typings !== 'string') {\n      // Missing the required `typings` property\n      return exports.INCOMPATIBLE_ENTRY_POINT;\n    } // An entry-point is assumed to be compiled by Angular if there is either:\n    // * a `metadata.json` file next to the typings entry-point\n    // * a custom config for this entry-point\n\n\n    var metadataPath = fs.resolve(entryPointPath, typings.replace(/\\.d\\.ts$/, '') + '.metadata.json');\n    var compiledByAngular = entryPointConfig !== undefined || fs.exists(metadataPath);\n    var entryPointInfo = {\n      name: entryPointPackageJson.name,\n      path: entryPointPath,\n      packageName: packageName,\n      packagePath: packagePath,\n      packageJson: entryPointPackageJson,\n      typings: fs.resolve(entryPointPath, typings),\n      compiledByAngular: compiledByAngular,\n      ignoreMissingDependencies: entryPointConfig !== undefined ? !!entryPointConfig.ignoreMissingDependencies : false,\n      generateDeepReexports: entryPointConfig !== undefined ? !!entryPointConfig.generateDeepReexports : false\n    };\n    return entryPointInfo;\n  }\n\n  exports.getEntryPointInfo = getEntryPointInfo;\n\n  function isEntryPoint(result) {\n    return result !== exports.NO_ENTRY_POINT && result !== exports.INCOMPATIBLE_ENTRY_POINT && result !== exports.IGNORED_ENTRY_POINT;\n  }\n\n  exports.isEntryPoint = isEntryPoint;\n  /**\n   * Convert a package.json property into an entry-point format.\n   *\n   * @param property The property to convert to a format.\n   * @returns An entry-point format or `undefined` if none match the given property.\n   */\n\n  function getEntryPointFormat(fs, entryPoint, property) {\n    switch (property) {\n      case 'fesm2015':\n        return 'esm2015';\n\n      case 'fesm5':\n        return 'esm5';\n\n      case 'es2015':\n        return 'esm2015';\n\n      case 'esm2015':\n        return 'esm2015';\n\n      case 'esm5':\n        return 'esm5';\n\n      case 'browser':\n        var browserFile = entryPoint.packageJson['browser'];\n\n        if (typeof browserFile !== 'string') {\n          return undefined;\n        }\n\n        return sniffModuleFormat(fs, fs.join(entryPoint.path, browserFile));\n\n      case 'main':\n        var mainFile = entryPoint.packageJson['main'];\n\n        if (mainFile === undefined) {\n          return undefined;\n        }\n\n        return sniffModuleFormat(fs, fs.join(entryPoint.path, mainFile));\n\n      case 'module':\n        var moduleFilePath = entryPoint.packageJson['module']; // As of version 10, the `module` property in `package.json` should point to\n        // the ESM2015 format output as per Angular Package format specification. This\n        // means that the `module` property captures multiple formats, as old libraries\n        // built with the old APF can still be processed. We detect the format by checking\n        // the paths that should be used as per APF specification.\n\n        if (typeof moduleFilePath === 'string' && moduleFilePath.includes('esm2015')) {\n          return \"esm2015\";\n        }\n\n        return 'esm5';\n\n      default:\n        return undefined;\n    }\n  }\n\n  exports.getEntryPointFormat = getEntryPointFormat;\n  /**\n   * Parse the JSON from a `package.json` file.\n   * @param packageJsonPath the absolute path to the `package.json` file.\n   * @returns JSON from the `package.json` file if it is valid, `null` otherwise.\n   */\n\n  function loadPackageJson(fs, packageJsonPath) {\n    try {\n      return JSON.parse(fs.readFile(packageJsonPath));\n    } catch (_a) {\n      return null;\n    }\n  }\n\n  function sniffModuleFormat(fs, sourceFilePath) {\n    var resolvedPath = utils_1.resolveFileWithPostfixes(fs, sourceFilePath, ['', '.js', '/index.js']);\n\n    if (resolvedPath === null) {\n      return undefined;\n    }\n\n    var sourceFile = ts.createSourceFile(sourceFilePath, fs.readFile(resolvedPath), ts.ScriptTarget.ES5);\n\n    if (sourceFile.statements.length === 0) {\n      return undefined;\n    }\n\n    if (ts.isExternalModule(sourceFile)) {\n      return 'esm5';\n    } else if (umd_host_1.parseStatementForUmdModule(sourceFile.statements[0]) !== null) {\n      return 'umd';\n    } else {\n      return 'commonjs';\n    }\n  }\n\n  function mergeConfigAndPackageJson(fs, entryPointPackageJson, entryPointConfig, packagePath, entryPointPath) {\n    if (entryPointPackageJson !== null) {\n      return tslib_1.__assign(tslib_1.__assign({}, entryPointPackageJson), entryPointConfig.override);\n    } else {\n      var name = fs.basename(packagePath) + \"/\" + fs.relative(packagePath, entryPointPath);\n      return tslib_1.__assign({\n        name: name\n      }, entryPointConfig.override);\n    }\n  }\n\n  function guessTypingsFromPackageJson(fs, entryPointPath, entryPointPackageJson) {\n    var e_1, _a;\n\n    try {\n      for (var SUPPORTED_FORMAT_PROPERTIES_1 = tslib_1.__values(exports.SUPPORTED_FORMAT_PROPERTIES), SUPPORTED_FORMAT_PROPERTIES_1_1 = SUPPORTED_FORMAT_PROPERTIES_1.next(); !SUPPORTED_FORMAT_PROPERTIES_1_1.done; SUPPORTED_FORMAT_PROPERTIES_1_1 = SUPPORTED_FORMAT_PROPERTIES_1.next()) {\n        var prop = SUPPORTED_FORMAT_PROPERTIES_1_1.value;\n        var field = entryPointPackageJson[prop];\n\n        if (typeof field !== 'string') {\n          // Some crazy packages have things like arrays in these fields!\n          continue;\n        }\n\n        var relativeTypingsPath = field.replace(/\\.js$/, '.d.ts');\n        var typingsPath = fs.resolve(entryPointPath, relativeTypingsPath);\n\n        if (fs.exists(typingsPath)) {\n          return typingsPath;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (SUPPORTED_FORMAT_PROPERTIES_1_1 && !SUPPORTED_FORMAT_PROPERTIES_1_1.done && (_a = SUPPORTED_FORMAT_PROPERTIES_1.return)) _a.call(SUPPORTED_FORMAT_PROPERTIES_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Find or infer the name and version of a package.\n   *\n   * - The name is computed based on the `name` property of the package's or the entry-point's\n   *   `package.json` file (if available) or inferred from the package's path.\n   * - The version is read off of the `version` property of the package's `package.json` file (if\n   *   available).\n   *\n   * @param fs The file-system to use for processing `packagePath`.\n   * @param packagePath the absolute path to the package.\n   * @param packagePackageJson the parsed `package.json` of the package (if available).\n   * @param entryPointPackageJson the parsed `package.json` of an entry-point (if available).\n   * @returns the computed name and version of the package.\n   */\n\n\n  function getPackageNameAndVersion(fs, packagePath, packagePackageJson, entryPointPackageJson) {\n    var _a;\n\n    var packageName;\n\n    if (packagePackageJson !== null) {\n      // We have a valid `package.json` for the package: Get the package name from that.\n      packageName = packagePackageJson.name;\n    } else if (entryPointPackageJson !== null) {\n      // We have a valid `package.json` for the entry-point: Get the package name from that.\n      // This might be a secondary entry-point, so make sure we only keep the main package's name\n      // (e.g. only keep `@angular/common` from `@angular/common/http`).\n      packageName = /^(?:@[^/]+\\/)?[^/]*/.exec(entryPointPackageJson.name)[0];\n    } else {\n      // We don't have a valid `package.json`: Infer the package name from the package's path.\n      var lastSegment = fs.basename(packagePath);\n      var secondLastSegment = fs.basename(fs.dirname(packagePath));\n      packageName = secondLastSegment.startsWith('@') ? secondLastSegment + \"/\" + lastSegment : lastSegment;\n    }\n\n    return {\n      packageName: packageName,\n      packageVersion: (_a = packagePackageJson === null || packagePackageJson === void 0 ? void 0 : packagePackageJson.version) !== null && _a !== void 0 ? _a : null\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/entry_point.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath, PathManipulation, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {parseStatementForUmdModule} from '../host/umd_host';\nimport {resolveFileWithPostfixes} from '../utils';\n\nimport {NgccConfiguration, NgccEntryPointConfig} from './configuration';\n\n/**\n * The possible values for the format of an entry-point.\n */\nexport type EntryPointFormat = 'esm5'|'esm2015'|'umd'|'commonjs';\n\n/**\n * An object containing information about an entry-point, including paths\n * to each of the possible entry-point formats.\n */\nexport interface EntryPoint extends JsonObject {\n  /** The name of the entry-point (e.g. `@angular/core` or `@angular/common/http`). */\n  name: string;\n  /** The path to this entry point. */\n  path: AbsoluteFsPath;\n  /**\n   * The name of the package that contains this entry-point (e.g. `@angular/core` or\n   * `@angular/common`).\n   */\n  packageName: string;\n  /** The path to the package that contains this entry-point. */\n  packagePath: AbsoluteFsPath;\n  /** The parsed package.json file for this entry-point. */\n  packageJson: EntryPointPackageJson;\n  /** The path to a typings (.d.ts) file for this entry-point. */\n  typings: AbsoluteFsPath;\n  /** Is this EntryPoint compiled with the Angular View Engine compiler? */\n  compiledByAngular: boolean;\n  /** Should ngcc ignore missing dependencies and process this entrypoint anyway? */\n  ignoreMissingDependencies: boolean;\n  /** Should ngcc generate deep re-exports for this entrypoint? */\n  generateDeepReexports: boolean;\n}\n\nexport type JsonPrimitive = string|number|boolean|null;\nexport type JsonValue = JsonPrimitive|JsonArray|JsonObject|undefined;\nexport interface JsonArray extends Array<JsonValue> {}\nexport interface JsonObject {\n  [key: string]: JsonValue;\n}\n\nexport interface PackageJsonFormatPropertiesMap {\n  browser?: string;\n  fesm2015?: string;\n  fesm5?: string;\n  es2015?: string;  // if exists then it is actually FESM2015\n  esm2015?: string;\n  esm5?: string;\n  main?: string;     // UMD\n  module?: string;   // if exists then it is actually FESM5\n  types?: string;    // Synonymous to `typings` property - see https://bit.ly/2OgWp2H\n  typings?: string;  // TypeScript .d.ts files\n}\n\nexport type PackageJsonFormatProperties = keyof PackageJsonFormatPropertiesMap;\n\n/**\n * The properties that may be loaded from the `package.json` file.\n */\nexport interface EntryPointPackageJson extends JsonObject, PackageJsonFormatPropertiesMap {\n  name: string;\n  version?: string;\n  scripts?: Record<string, string>;\n  __processed_by_ivy_ngcc__?: Record<string, string>;\n}\n\nexport type EntryPointJsonProperty = Exclude<PackageJsonFormatProperties, 'types'|'typings'>;\n// We need to keep the elements of this const and the `EntryPointJsonProperty` type in sync.\nexport const SUPPORTED_FORMAT_PROPERTIES: EntryPointJsonProperty[] =\n    ['fesm2015', 'fesm5', 'es2015', 'esm2015', 'esm5', 'main', 'module', 'browser'];\n\n\n/**\n * The path does not represent an entry-point, i.e. there is no package.json at the path and there\n * is no config to force an entry-point.\n */\nexport const NO_ENTRY_POINT = 'no-entry-point';\n\n/**\n * The path represents an entry-point that is `ignored` by an ngcc config.\n */\nexport const IGNORED_ENTRY_POINT = 'ignored-entry-point';\n\n/**\n * The path has a package.json, but it is not a valid entry-point for ngcc processing.\n */\nexport const INCOMPATIBLE_ENTRY_POINT = 'incompatible-entry-point';\n\n/**\n * The result of calling `getEntryPointInfo()`.\n *\n * This will be an `EntryPoint` object if an Angular entry-point was identified;\n * Otherwise it will be a flag indicating one of:\n * * NO_ENTRY_POINT - the path is not an entry-point or ngcc is configured to ignore it\n * * INCOMPATIBLE_ENTRY_POINT - the path was a non-processable entry-point that should be searched\n * for sub-entry-points\n */\nexport type GetEntryPointResult =\n    EntryPoint|typeof IGNORED_ENTRY_POINT|typeof INCOMPATIBLE_ENTRY_POINT|typeof NO_ENTRY_POINT;\n\n\n/**\n * Try to create an entry-point from the given paths and properties.\n *\n * @param packagePath the absolute path to the containing npm package\n * @param entryPointPath the absolute path to the potential entry-point.\n * @returns\n * - An entry-point if it is valid and not ignored.\n * - `NO_ENTRY_POINT` when there is no package.json at the path and there is no config to force an\n *   entry-point,\n * - `IGNORED_ENTRY_POINT` when the entry-point is ignored by an ngcc config.\n * - `INCOMPATIBLE_ENTRY_POINT` when there is a package.json but it is not a valid Angular compiled\n *   entry-point.\n */\nexport function getEntryPointInfo(\n    fs: ReadonlyFileSystem, config: NgccConfiguration, logger: Logger, packagePath: AbsoluteFsPath,\n    entryPointPath: AbsoluteFsPath): GetEntryPointResult {\n  const packagePackageJsonPath = fs.resolve(packagePath, 'package.json');\n  const entryPointPackageJsonPath = fs.resolve(entryPointPath, 'package.json');\n  const loadedPackagePackageJson = loadPackageJson(fs, packagePackageJsonPath);\n  const loadedEntryPointPackageJson = (packagePackageJsonPath === entryPointPackageJsonPath) ?\n      loadedPackagePackageJson :\n      loadPackageJson(fs, entryPointPackageJsonPath);\n  const {packageName, packageVersion} = getPackageNameAndVersion(\n      fs, packagePath, loadedPackagePackageJson, loadedEntryPointPackageJson);\n\n  const packageConfig = config.getPackageConfig(packageName, packagePath, packageVersion);\n  const entryPointConfig = packageConfig.entryPoints.get(entryPointPath);\n  let entryPointPackageJson: EntryPointPackageJson;\n\n  if (entryPointConfig === undefined) {\n    if (!fs.exists(entryPointPackageJsonPath)) {\n      // No `package.json` and no config.\n      return NO_ENTRY_POINT;\n    } else if (loadedEntryPointPackageJson === null) {\n      // `package.json` exists but could not be parsed and there is no redeeming config.\n      logger.warn(`Failed to read entry point info from invalid 'package.json' file: ${\n          entryPointPackageJsonPath}`);\n\n      return INCOMPATIBLE_ENTRY_POINT;\n    } else {\n      entryPointPackageJson = loadedEntryPointPackageJson;\n    }\n  } else if (entryPointConfig.ignore === true) {\n    // Explicitly ignored entry-point.\n    return IGNORED_ENTRY_POINT;\n  } else {\n    entryPointPackageJson = mergeConfigAndPackageJson(\n        fs, loadedEntryPointPackageJson, entryPointConfig, packagePath, entryPointPath);\n  }\n\n  const typings = entryPointPackageJson.typings || entryPointPackageJson.types ||\n      guessTypingsFromPackageJson(fs, entryPointPath, entryPointPackageJson);\n  if (typeof typings !== 'string') {\n    // Missing the required `typings` property\n    return INCOMPATIBLE_ENTRY_POINT;\n  }\n\n  // An entry-point is assumed to be compiled by Angular if there is either:\n  // * a `metadata.json` file next to the typings entry-point\n  // * a custom config for this entry-point\n  const metadataPath =\n      fs.resolve(entryPointPath, typings.replace(/\\.d\\.ts$/, '') + '.metadata.json');\n  const compiledByAngular = entryPointConfig !== undefined || fs.exists(metadataPath);\n\n  const entryPointInfo: EntryPoint = {\n    name: entryPointPackageJson.name,\n    path: entryPointPath,\n    packageName,\n    packagePath,\n    packageJson: entryPointPackageJson,\n    typings: fs.resolve(entryPointPath, typings),\n    compiledByAngular,\n    ignoreMissingDependencies:\n        entryPointConfig !== undefined ? !!entryPointConfig.ignoreMissingDependencies : false,\n    generateDeepReexports:\n        entryPointConfig !== undefined ? !!entryPointConfig.generateDeepReexports : false,\n  };\n\n  return entryPointInfo;\n}\n\nexport function isEntryPoint(result: GetEntryPointResult): result is EntryPoint {\n  return result !== NO_ENTRY_POINT && result !== INCOMPATIBLE_ENTRY_POINT &&\n      result !== IGNORED_ENTRY_POINT;\n}\n\n/**\n * Convert a package.json property into an entry-point format.\n *\n * @param property The property to convert to a format.\n * @returns An entry-point format or `undefined` if none match the given property.\n */\nexport function getEntryPointFormat(\n    fs: ReadonlyFileSystem, entryPoint: EntryPoint,\n    property: EntryPointJsonProperty): EntryPointFormat|undefined {\n  switch (property) {\n    case 'fesm2015':\n      return 'esm2015';\n    case 'fesm5':\n      return 'esm5';\n    case 'es2015':\n      return 'esm2015';\n    case 'esm2015':\n      return 'esm2015';\n    case 'esm5':\n      return 'esm5';\n    case 'browser':\n      const browserFile = entryPoint.packageJson['browser'];\n      if (typeof browserFile !== 'string') {\n        return undefined;\n      }\n      return sniffModuleFormat(fs, fs.join(entryPoint.path, browserFile));\n    case 'main':\n      const mainFile = entryPoint.packageJson['main'];\n      if (mainFile === undefined) {\n        return undefined;\n      }\n      return sniffModuleFormat(fs, fs.join(entryPoint.path, mainFile));\n    case 'module':\n      const moduleFilePath = entryPoint.packageJson['module'];\n      // As of version 10, the `module` property in `package.json` should point to\n      // the ESM2015 format output as per Angular Package format specification. This\n      // means that the `module` property captures multiple formats, as old libraries\n      // built with the old APF can still be processed. We detect the format by checking\n      // the paths that should be used as per APF specification.\n      if (typeof moduleFilePath === 'string' && moduleFilePath.includes('esm2015')) {\n        return `esm2015`;\n      }\n      return 'esm5';\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Parse the JSON from a `package.json` file.\n * @param packageJsonPath the absolute path to the `package.json` file.\n * @returns JSON from the `package.json` file if it is valid, `null` otherwise.\n */\nfunction loadPackageJson(\n    fs: ReadonlyFileSystem, packageJsonPath: AbsoluteFsPath): EntryPointPackageJson|null {\n  try {\n    return JSON.parse(fs.readFile(packageJsonPath)) as EntryPointPackageJson;\n  } catch {\n    return null;\n  }\n}\n\nfunction sniffModuleFormat(\n    fs: ReadonlyFileSystem, sourceFilePath: AbsoluteFsPath): EntryPointFormat|undefined {\n  const resolvedPath = resolveFileWithPostfixes(fs, sourceFilePath, ['', '.js', '/index.js']);\n  if (resolvedPath === null) {\n    return undefined;\n  }\n\n  const sourceFile =\n      ts.createSourceFile(sourceFilePath, fs.readFile(resolvedPath), ts.ScriptTarget.ES5);\n  if (sourceFile.statements.length === 0) {\n    return undefined;\n  }\n  if (ts.isExternalModule(sourceFile)) {\n    return 'esm5';\n  } else if (parseStatementForUmdModule(sourceFile.statements[0]) !== null) {\n    return 'umd';\n  } else {\n    return 'commonjs';\n  }\n}\n\nfunction mergeConfigAndPackageJson(\n    fs: PathManipulation, entryPointPackageJson: EntryPointPackageJson|null,\n    entryPointConfig: NgccEntryPointConfig, packagePath: AbsoluteFsPath,\n    entryPointPath: AbsoluteFsPath): EntryPointPackageJson {\n  if (entryPointPackageJson !== null) {\n    return {...entryPointPackageJson, ...entryPointConfig.override};\n  } else {\n    const name = `${fs.basename(packagePath)}/${fs.relative(packagePath, entryPointPath)}`;\n    return {name, ...entryPointConfig.override};\n  }\n}\n\nfunction guessTypingsFromPackageJson(\n    fs: ReadonlyFileSystem, entryPointPath: AbsoluteFsPath,\n    entryPointPackageJson: EntryPointPackageJson): AbsoluteFsPath|null {\n  for (const prop of SUPPORTED_FORMAT_PROPERTIES) {\n    const field = entryPointPackageJson[prop];\n    if (typeof field !== 'string') {\n      // Some crazy packages have things like arrays in these fields!\n      continue;\n    }\n    const relativeTypingsPath = field.replace(/\\.js$/, '.d.ts');\n    const typingsPath = fs.resolve(entryPointPath, relativeTypingsPath);\n    if (fs.exists(typingsPath)) {\n      return typingsPath;\n    }\n  }\n  return null;\n}\n\n/**\n * Find or infer the name and version of a package.\n *\n * - The name is computed based on the `name` property of the package's or the entry-point's\n *   `package.json` file (if available) or inferred from the package's path.\n * - The version is read off of the `version` property of the package's `package.json` file (if\n *   available).\n *\n * @param fs The file-system to use for processing `packagePath`.\n * @param packagePath the absolute path to the package.\n * @param packagePackageJson the parsed `package.json` of the package (if available).\n * @param entryPointPackageJson the parsed `package.json` of an entry-point (if available).\n * @returns the computed name and version of the package.\n */\nfunction getPackageNameAndVersion(\n    fs: PathManipulation, packagePath: AbsoluteFsPath,\n    packagePackageJson: EntryPointPackageJson|null,\n    entryPointPackageJson: EntryPointPackageJson|\n    null): {packageName: string, packageVersion: string|null} {\n  let packageName: string;\n\n  if (packagePackageJson !== null) {\n    // We have a valid `package.json` for the package: Get the package name from that.\n    packageName = packagePackageJson.name;\n  } else if (entryPointPackageJson !== null) {\n    // We have a valid `package.json` for the entry-point: Get the package name from that.\n    // This might be a secondary entry-point, so make sure we only keep the main package's name\n    // (e.g. only keep `@angular/common` from `@angular/common/http`).\n    packageName = /^(?:@[^/]+\\/)?[^/]*/.exec(entryPointPackageJson.name)![0];\n  } else {\n    // We don't have a valid `package.json`: Infer the package name from the package's path.\n    const lastSegment = fs.basename(packagePath);\n    const secondLastSegment = fs.basename(fs.dirname(packagePath));\n\n    packageName =\n        secondLastSegment.startsWith('@') ? `${secondLastSegment}/${lastSegment}` : lastSegment;\n  }\n\n  return {\n    packageName,\n    packageVersion: packagePackageJson?.version ?? null,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}