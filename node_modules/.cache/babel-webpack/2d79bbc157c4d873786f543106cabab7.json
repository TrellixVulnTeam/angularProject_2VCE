{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/view_compiler/type_check_compiler\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/aot/static_symbol\", \"@angular/compiler/src/compiler_util/expression_converter\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/template_parser/template_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeCheckCompiler = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var static_symbol_1 = require(\"@angular/compiler/src/aot/static_symbol\");\n\n  var expression_converter_1 = require(\"@angular/compiler/src/compiler_util/expression_converter\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var template_ast_1 = require(\"@angular/compiler/src/template_parser/template_ast\");\n  /**\n   * Generates code that is used to type check templates.\n   */\n\n\n  var TypeCheckCompiler =\n  /** @class */\n  function () {\n    function TypeCheckCompiler(options, reflector) {\n      this.options = options;\n      this.reflector = reflector;\n    }\n    /**\n     * Important notes:\n     * - This must not produce new `import` statements, but only refer to types outside\n     *   of the file via the variables provided via externalReferenceVars.\n     *   This allows Typescript to reuse the old program's structure as no imports have changed.\n     * - This must not produce any exports, as this would pollute the .d.ts file\n     *   and also violate the point above.\n     */\n\n\n    TypeCheckCompiler.prototype.compileComponent = function (componentId, component, template, usedPipes, externalReferenceVars, ctx) {\n      var _this = this;\n\n      var pipes = new Map();\n      usedPipes.forEach(function (p) {\n        return pipes.set(p.name, p.type.reference);\n      });\n      var embeddedViewCount = 0;\n\n      var viewBuilderFactory = function viewBuilderFactory(parent, guards) {\n        var embeddedViewIndex = embeddedViewCount++;\n        return new ViewBuilder(_this.options, _this.reflector, externalReferenceVars, parent, component.type.reference, component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n      };\n\n      var visitor = viewBuilderFactory(null, []);\n      visitor.visitAll([], template);\n      return visitor.build(componentId);\n    };\n\n    return TypeCheckCompiler;\n  }();\n\n  exports.TypeCheckCompiler = TypeCheckCompiler;\n  var DYNAMIC_VAR_NAME = '_any';\n\n  var TypeCheckLocalResolver =\n  /** @class */\n  function () {\n    function TypeCheckLocalResolver() {}\n\n    TypeCheckLocalResolver.prototype.notifyImplicitReceiverUse = function () {};\n\n    TypeCheckLocalResolver.prototype.getLocal = function (name) {\n      if (name === expression_converter_1.EventHandlerVars.event.name) {\n        // References to the event should not be type-checked.\n        // TODO(chuckj): determine a better type for the event.\n        return o.variable(DYNAMIC_VAR_NAME);\n      }\n\n      return null;\n    };\n\n    return TypeCheckLocalResolver;\n  }();\n\n  var defaultResolver = new TypeCheckLocalResolver();\n\n  var ViewBuilder =\n  /** @class */\n  function () {\n    function ViewBuilder(options, reflector, externalReferenceVars, parent, component, isHostComponent, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory) {\n      this.options = options;\n      this.reflector = reflector;\n      this.externalReferenceVars = externalReferenceVars;\n      this.parent = parent;\n      this.component = component;\n      this.isHostComponent = isHostComponent;\n      this.embeddedViewIndex = embeddedViewIndex;\n      this.pipes = pipes;\n      this.guards = guards;\n      this.ctx = ctx;\n      this.viewBuilderFactory = viewBuilderFactory;\n      this.refOutputVars = new Map();\n      this.variables = [];\n      this.children = [];\n      this.updates = [];\n      this.actions = [];\n    }\n\n    ViewBuilder.prototype.getOutputVar = function (type) {\n      var varName;\n\n      if (type === this.component && this.isHostComponent) {\n        varName = DYNAMIC_VAR_NAME;\n      } else if (type instanceof static_symbol_1.StaticSymbol) {\n        varName = this.externalReferenceVars.get(type);\n      } else {\n        varName = DYNAMIC_VAR_NAME;\n      }\n\n      if (!varName) {\n        throw new Error(\"Illegal State: referring to a type without a variable \" + JSON.stringify(type));\n      }\n\n      return varName;\n    };\n\n    ViewBuilder.prototype.getTypeGuardExpressions = function (ast) {\n      var e_1, _a, e_2, _b;\n\n      var result = tslib_1.__spread(this.guards);\n\n      try {\n        for (var _c = tslib_1.__values(ast.directives), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var directive = _d.value;\n\n          try {\n            for (var _e = (e_2 = void 0, tslib_1.__values(directive.inputs)), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var input = _f.value;\n              var guard = directive.directive.guards[input.directiveName];\n\n              if (guard) {\n                var useIf = guard === 'UseIf';\n                result.push({\n                  guard: guard,\n                  useIf: useIf,\n                  expression: {\n                    context: this.component,\n                    value: input.value,\n                    sourceSpan: input.sourceSpan\n                  }\n                });\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return result;\n    };\n\n    ViewBuilder.prototype.visitAll = function (variables, astNodes) {\n      this.variables = variables;\n      template_ast_1.templateVisitAll(this, astNodes);\n    };\n\n    ViewBuilder.prototype.build = function (componentId, targetStatements) {\n      var e_3, _a;\n\n      var _this = this;\n\n      if (targetStatements === void 0) {\n        targetStatements = [];\n      }\n\n      this.children.forEach(function (child) {\n        return child.build(componentId, targetStatements);\n      });\n      var viewStmts = [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n      var bindingCount = 0;\n      this.updates.forEach(function (expression) {\n        var _a = _this.preprocessUpdateExpression(expression),\n            sourceSpan = _a.sourceSpan,\n            context = _a.context,\n            value = _a.value;\n\n        var bindingId = \"\" + bindingCount++;\n        var nameResolver = context === _this.component ? _this : defaultResolver;\n\n        var _b = expression_converter_1.convertPropertyBinding(nameResolver, o.variable(_this.getOutputVar(context)), value, bindingId, expression_converter_1.BindingForm.General),\n            stmts = _b.stmts,\n            currValExpr = _b.currValExpr;\n\n        stmts.push(new o.ExpressionStatement(currValExpr));\n        viewStmts.push.apply(viewStmts, tslib_1.__spread(stmts.map(function (stmt) {\n          return o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan);\n        })));\n      });\n      this.actions.forEach(function (_a) {\n        var sourceSpan = _a.sourceSpan,\n            context = _a.context,\n            value = _a.value;\n        var bindingId = \"\" + bindingCount++;\n        var nameResolver = context === _this.component ? _this : defaultResolver;\n        var stmts = expression_converter_1.convertActionBinding(nameResolver, o.variable(_this.getOutputVar(context)), value, bindingId).stmts;\n        viewStmts.push.apply(viewStmts, tslib_1.__spread(stmts.map(function (stmt) {\n          return o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan);\n        })));\n      });\n\n      if (this.guards.length) {\n        var guardExpression = undefined;\n\n        try {\n          for (var _b = tslib_1.__values(this.guards), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var guard = _c.value;\n\n            var _d = this.preprocessUpdateExpression(guard.expression),\n                context = _d.context,\n                value = _d.value;\n\n            var bindingId = \"\" + bindingCount++;\n            var nameResolver = context === this.component ? this : defaultResolver; // We only support support simple expressions and ignore others as they\n            // are unlikely to affect type narrowing.\n\n            var _e = expression_converter_1.convertPropertyBinding(nameResolver, o.variable(this.getOutputVar(context)), value, bindingId, expression_converter_1.BindingForm.TrySimple),\n                stmts = _e.stmts,\n                currValExpr = _e.currValExpr;\n\n            if (stmts.length == 0) {\n              var guardClause = guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n              guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n            }\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n\n        if (guardExpression) {\n          viewStmts = [new o.IfStmt(guardExpression, viewStmts)];\n        }\n      }\n\n      var viewName = \"_View_\" + componentId + \"_\" + this.embeddedViewIndex;\n      var viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n      targetStatements.push(viewFactory);\n      return targetStatements;\n    };\n\n    ViewBuilder.prototype.visitBoundText = function (ast, context) {\n      var _this = this;\n\n      var astWithSource = ast.value;\n      var inter = astWithSource.ast;\n      inter.expressions.forEach(function (expr) {\n        return _this.updates.push({\n          context: _this.component,\n          value: expr,\n          sourceSpan: ast.sourceSpan\n        });\n      });\n    };\n\n    ViewBuilder.prototype.visitEmbeddedTemplate = function (ast, context) {\n      this.visitElementOrTemplate(ast); // Note: The old view compiler used to use an `any` type\n      // for the context in any embedded view.\n      // We keep this behaivor behind a flag for now.\n\n      if (this.options.fullTemplateTypeCheck) {\n        // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n        // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n        // stamped out if ngIf is truthy so any bindings in the template can assume that,\n        // if a nullable type is used for ngIf, that expression is not null or undefined.\n        var guards = this.getTypeGuardExpressions(ast);\n        var childVisitor = this.viewBuilderFactory(this, guards);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n      }\n    };\n\n    ViewBuilder.prototype.visitElement = function (ast, context) {\n      var _this = this;\n\n      this.visitElementOrTemplate(ast);\n      var inputDefs = [];\n      var updateRendererExpressions = [];\n      var outputDefs = [];\n      ast.inputs.forEach(function (inputAst) {\n        _this.updates.push({\n          context: _this.component,\n          value: inputAst.value,\n          sourceSpan: inputAst.sourceSpan\n        });\n      });\n      template_ast_1.templateVisitAll(this, ast.children);\n    };\n\n    ViewBuilder.prototype.visitElementOrTemplate = function (ast) {\n      var _this = this;\n\n      ast.directives.forEach(function (dirAst) {\n        _this.visitDirective(dirAst);\n      });\n      ast.references.forEach(function (ref) {\n        var outputVarType = null; // Note: The old view compiler used to use an `any` type\n        // for directives exposed via `exportAs`.\n        // We keep this behaivor behind a flag for now.\n\n        if (ref.value && ref.value.identifier && _this.options.fullTemplateTypeCheck) {\n          outputVarType = ref.value.identifier.reference;\n        } else {\n          outputVarType = o.BuiltinTypeName.Dynamic;\n        }\n\n        _this.refOutputVars.set(ref.name, outputVarType);\n      });\n      ast.outputs.forEach(function (outputAst) {\n        _this.actions.push({\n          context: _this.component,\n          value: outputAst.handler,\n          sourceSpan: outputAst.sourceSpan\n        });\n      });\n    };\n\n    ViewBuilder.prototype.visitDirective = function (dirAst) {\n      var _this = this;\n\n      var dirType = dirAst.directive.type.reference;\n      dirAst.inputs.forEach(function (input) {\n        return _this.updates.push({\n          context: _this.component,\n          value: input.value,\n          sourceSpan: input.sourceSpan\n        });\n      }); // Note: The old view compiler used to use an `any` type\n      // for expressions in host properties / events.\n      // We keep this behaivor behind a flag for now.\n\n      if (this.options.fullTemplateTypeCheck) {\n        dirAst.hostProperties.forEach(function (inputAst) {\n          return _this.updates.push({\n            context: dirType,\n            value: inputAst.value,\n            sourceSpan: inputAst.sourceSpan\n          });\n        });\n        dirAst.hostEvents.forEach(function (hostEventAst) {\n          return _this.actions.push({\n            context: dirType,\n            value: hostEventAst.handler,\n            sourceSpan: hostEventAst.sourceSpan\n          });\n        });\n      }\n    };\n\n    ViewBuilder.prototype.notifyImplicitReceiverUse = function () {};\n\n    ViewBuilder.prototype.getLocal = function (name) {\n      if (name == expression_converter_1.EventHandlerVars.event.name) {\n        return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n      }\n\n      for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent) {\n        var outputVarType = void 0; // check references\n\n        outputVarType = currBuilder.refOutputVars.get(name);\n\n        if (outputVarType == null) {\n          // check variables\n          var varAst = currBuilder.variables.find(function (varAst) {\n            return varAst.name === name;\n          });\n\n          if (varAst) {\n            outputVarType = o.BuiltinTypeName.Dynamic;\n          }\n        }\n\n        if (outputVarType != null) {\n          return o.variable(this.getOutputVar(outputVarType));\n        }\n      }\n\n      return null;\n    };\n\n    ViewBuilder.prototype.pipeOutputVar = function (name) {\n      var pipe = this.pipes.get(name);\n\n      if (!pipe) {\n        throw new Error(\"Illegal State: Could not find pipe \" + name + \" in template of \" + this.component);\n      }\n\n      return this.getOutputVar(pipe);\n    };\n\n    ViewBuilder.prototype.preprocessUpdateExpression = function (expression) {\n      var _this = this;\n\n      return {\n        sourceSpan: expression.sourceSpan,\n        context: expression.context,\n        value: expression_converter_1.convertPropertyBindingBuiltins({\n          createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {\n            return function (args) {\n              var arr = o.literalArr(args); // Note: The old view compiler used to use an `any` type\n              // for arrays.\n\n              return _this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n            };\n          },\n          createLiteralMapConverter: function createLiteralMapConverter(keys) {\n            return function (values) {\n              var entries = keys.map(function (k, i) {\n                return {\n                  key: k.key,\n                  value: values[i],\n                  quoted: k.quoted\n                };\n              });\n              var map = o.literalMap(entries); // Note: The old view compiler used to use an `any` type\n              // for maps.\n\n              return _this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n            };\n          },\n          createPipeConverter: function createPipeConverter(name, argCount) {\n            return function (args) {\n              // Note: The old view compiler used to use an `any` type\n              // for pipes.\n              var pipeExpr = _this.options.fullTemplateTypeCheck ? o.variable(_this.pipeOutputVar(name)) : o.variable(_this.getOutputVar(o.BuiltinTypeName.Dynamic));\n              return pipeExpr.callMethod('transform', args);\n            };\n          }\n        }, expression.value)\n      };\n    };\n\n    ViewBuilder.prototype.visitNgContent = function (ast, context) {};\n\n    ViewBuilder.prototype.visitText = function (ast, context) {};\n\n    ViewBuilder.prototype.visitDirectiveProperty = function (ast, context) {};\n\n    ViewBuilder.prototype.visitReference = function (ast, context) {};\n\n    ViewBuilder.prototype.visitVariable = function (ast, context) {};\n\n    ViewBuilder.prototype.visitEvent = function (ast, context) {};\n\n    ViewBuilder.prototype.visitElementProperty = function (ast, context) {};\n\n    ViewBuilder.prototype.visitAttr = function (ast, context) {};\n\n    return ViewBuilder;\n  }();\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/view_compiler/type_check_compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AotCompilerOptions} from '../aot/compiler_options';\nimport {StaticReflector} from '../aot/static_reflector';\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileDirectiveMetadata, CompilePipeSummary} from '../compile_metadata';\nimport {BindingForm, convertActionBinding, convertPropertyBinding, convertPropertyBindingBuiltins, EventHandlerVars, LocalResolver} from '../compiler_util/expression_converter';\nimport {AST, ASTWithSource, Interpolation} from '../expression_parser/ast';\nimport * as o from '../output/output_ast';\nimport {ParseSourceSpan} from '../parse_util';\nimport {AttrAst, BoundDirectivePropertyAst, BoundElementPropertyAst, BoundEventAst, BoundTextAst, DirectiveAst, ElementAst, EmbeddedTemplateAst, NgContentAst, ReferenceAst, TemplateAst, TemplateAstVisitor, templateVisitAll, TextAst, VariableAst} from '../template_parser/template_ast';\nimport {OutputContext} from '../util';\n\n\n/**\n * Generates code that is used to type check templates.\n */\nexport class TypeCheckCompiler {\n  constructor(private options: AotCompilerOptions, private reflector: StaticReflector) {}\n\n  /**\n   * Important notes:\n   * - This must not produce new `import` statements, but only refer to types outside\n   *   of the file via the variables provided via externalReferenceVars.\n   *   This allows Typescript to reuse the old program's structure as no imports have changed.\n   * - This must not produce any exports, as this would pollute the .d.ts file\n   *   and also violate the point above.\n   */\n  compileComponent(\n      componentId: string, component: CompileDirectiveMetadata, template: TemplateAst[],\n      usedPipes: CompilePipeSummary[], externalReferenceVars: Map<StaticSymbol, string>,\n      ctx: OutputContext): o.Statement[] {\n    const pipes = new Map<string, StaticSymbol>();\n    usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\n    let embeddedViewCount = 0;\n    const viewBuilderFactory =\n        (parent: ViewBuilder|null, guards: GuardExpression[]): ViewBuilder => {\n          const embeddedViewIndex = embeddedViewCount++;\n          return new ViewBuilder(\n              this.options, this.reflector, externalReferenceVars, parent, component.type.reference,\n              component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n        };\n\n    const visitor = viewBuilderFactory(null, []);\n    visitor.visitAll([], template);\n\n    return visitor.build(componentId);\n  }\n}\n\ninterface GuardExpression {\n  guard: StaticSymbol;\n  useIf: boolean;\n  expression: Expression;\n}\n\ninterface ViewBuilderFactory {\n  (parent: ViewBuilder, guards: GuardExpression[]): ViewBuilder;\n}\n\n// Note: This is used as key in Map and should therefore be\n// unique per value.\ntype OutputVarType = o.BuiltinTypeName|StaticSymbol;\n\ninterface Expression {\n  context: OutputVarType;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\nconst DYNAMIC_VAR_NAME = '_any';\n\nclass TypeCheckLocalResolver implements LocalResolver {\n  notifyImplicitReceiverUse(): void {}\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      // References to the event should not be type-checked.\n      // TODO(chuckj): determine a better type for the event.\n      return o.variable(DYNAMIC_VAR_NAME);\n    }\n    return null;\n  }\n}\n\nconst defaultResolver = new TypeCheckLocalResolver();\n\nclass ViewBuilder implements TemplateAstVisitor, LocalResolver {\n  private refOutputVars = new Map<string, OutputVarType>();\n  private variables: VariableAst[] = [];\n  private children: ViewBuilder[] = [];\n  private updates: Expression[] = [];\n  private actions: Expression[] = [];\n\n  constructor(\n      private options: AotCompilerOptions, private reflector: StaticReflector,\n      private externalReferenceVars: Map<StaticSymbol, string>, private parent: ViewBuilder|null,\n      private component: StaticSymbol, private isHostComponent: boolean,\n      private embeddedViewIndex: number, private pipes: Map<string, StaticSymbol>,\n      private guards: GuardExpression[], private ctx: OutputContext,\n      private viewBuilderFactory: ViewBuilderFactory) {}\n\n  private getOutputVar(type: o.BuiltinTypeName|StaticSymbol): string {\n    let varName: string|undefined;\n    if (type === this.component && this.isHostComponent) {\n      varName = DYNAMIC_VAR_NAME;\n    } else if (type instanceof StaticSymbol) {\n      varName = this.externalReferenceVars.get(type);\n    } else {\n      varName = DYNAMIC_VAR_NAME;\n    }\n    if (!varName) {\n      throw new Error(\n          `Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\n    }\n    return varName;\n  }\n\n  private getTypeGuardExpressions(ast: EmbeddedTemplateAst): GuardExpression[] {\n    const result = [...this.guards];\n    for (let directive of ast.directives) {\n      for (let input of directive.inputs) {\n        const guard = directive.directive.guards[input.directiveName];\n        if (guard) {\n          const useIf = guard === 'UseIf';\n          result.push({\n            guard,\n            useIf,\n            expression: {\n              context: this.component,\n              value: input.value,\n              sourceSpan: input.sourceSpan,\n            },\n          });\n        }\n      }\n    }\n    return result;\n  }\n\n  visitAll(variables: VariableAst[], astNodes: TemplateAst[]) {\n    this.variables = variables;\n    templateVisitAll(this, astNodes);\n  }\n\n  build(componentId: string, targetStatements: o.Statement[] = []): o.Statement[] {\n    this.children.forEach((child) => child.build(componentId, targetStatements));\n    let viewStmts: o.Statement[] =\n        [o.variable(DYNAMIC_VAR_NAME).set(o.NULL_EXPR).toDeclStmt(o.DYNAMIC_TYPE)];\n    let bindingCount = 0;\n    this.updates.forEach((expression) => {\n      const {sourceSpan, context, value} = this.preprocessUpdateExpression(expression);\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts, currValExpr} = convertPropertyBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n          BindingForm.General);\n      stmts.push(new o.ExpressionStatement(currValExpr));\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    this.actions.forEach(({sourceSpan, context, value}) => {\n      const bindingId = `${bindingCount++}`;\n      const nameResolver = context === this.component ? this : defaultResolver;\n      const {stmts} = convertActionBinding(\n          nameResolver, o.variable(this.getOutputVar(context)), value, bindingId);\n      viewStmts.push(...stmts.map(\n          (stmt: o.Statement) => o.applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\n    });\n\n    if (this.guards.length) {\n      let guardExpression: o.Expression|undefined = undefined;\n      for (const guard of this.guards) {\n        const {context, value} = this.preprocessUpdateExpression(guard.expression);\n        const bindingId = `${bindingCount++}`;\n        const nameResolver = context === this.component ? this : defaultResolver;\n        // We only support support simple expressions and ignore others as they\n        // are unlikely to affect type narrowing.\n        const {stmts, currValExpr} = convertPropertyBinding(\n            nameResolver, o.variable(this.getOutputVar(context)), value, bindingId,\n            BindingForm.TrySimple);\n        if (stmts.length == 0) {\n          const guardClause =\n              guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n          guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n        }\n      }\n      if (guardExpression) {\n        viewStmts = [new o.IfStmt(guardExpression, viewStmts)];\n      }\n    }\n\n    const viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\n    const viewFactory = new o.DeclareFunctionStmt(viewName, [], viewStmts);\n    targetStatements.push(viewFactory);\n    return targetStatements;\n  }\n\n  visitBoundText(ast: BoundTextAst, context: any): any {\n    const astWithSource = <ASTWithSource>ast.value;\n    const inter = <Interpolation>astWithSource.ast;\n\n    inter.expressions.forEach(\n        (expr) =>\n            this.updates.push({context: this.component, value: expr, sourceSpan: ast.sourceSpan}));\n  }\n\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n    // Note: The old view compiler used to use an `any` type\n    // for the context in any embedded view.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n      // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n      // stamped out if ngIf is truthy so any bindings in the template can assume that,\n      // if a nullable type is used for ngIf, that expression is not null or undefined.\n      const guards = this.getTypeGuardExpressions(ast);\n      const childVisitor = this.viewBuilderFactory(this, guards);\n      this.children.push(childVisitor);\n      childVisitor.visitAll(ast.variables, ast.children);\n    }\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    this.visitElementOrTemplate(ast);\n\n    let inputDefs: o.Expression[] = [];\n    let updateRendererExpressions: Expression[] = [];\n    let outputDefs: o.Expression[] = [];\n    ast.inputs.forEach((inputAst) => {\n      this.updates.push(\n          {context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan});\n    });\n\n    templateVisitAll(this, ast.children);\n  }\n\n  private visitElementOrTemplate(ast: {\n    outputs: BoundEventAst[],\n    directives: DirectiveAst[],\n    references: ReferenceAst[],\n  }) {\n    ast.directives.forEach((dirAst) => {\n      this.visitDirective(dirAst);\n    });\n\n    ast.references.forEach((ref) => {\n      let outputVarType: OutputVarType = null!;\n      // Note: The old view compiler used to use an `any` type\n      // for directives exposed via `exportAs`.\n      // We keep this behaivor behind a flag for now.\n      if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\n        outputVarType = ref.value.identifier.reference;\n      } else {\n        outputVarType = o.BuiltinTypeName.Dynamic;\n      }\n      this.refOutputVars.set(ref.name, outputVarType);\n    });\n    ast.outputs.forEach((outputAst) => {\n      this.actions.push(\n          {context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan});\n    });\n  }\n\n  visitDirective(dirAst: DirectiveAst) {\n    const dirType = dirAst.directive.type.reference;\n    dirAst.inputs.forEach(\n        (input) => this.updates.push(\n            {context: this.component, value: input.value, sourceSpan: input.sourceSpan}));\n    // Note: The old view compiler used to use an `any` type\n    // for expressions in host properties / events.\n    // We keep this behaivor behind a flag for now.\n    if (this.options.fullTemplateTypeCheck) {\n      dirAst.hostProperties.forEach(\n          (inputAst) => this.updates.push(\n              {context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan}));\n      dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\n        context: dirType,\n        value: hostEventAst.handler,\n        sourceSpan: hostEventAst.sourceSpan\n      }));\n    }\n  }\n\n  notifyImplicitReceiverUse(): void {}\n  getLocal(name: string): o.Expression|null {\n    if (name == EventHandlerVars.event.name) {\n      return o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n    }\n    for (let currBuilder: ViewBuilder|null = this; currBuilder; currBuilder = currBuilder.parent) {\n      let outputVarType: OutputVarType|undefined;\n      // check references\n      outputVarType = currBuilder.refOutputVars.get(name);\n      if (outputVarType == null) {\n        // check variables\n        const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\n        if (varAst) {\n          outputVarType = o.BuiltinTypeName.Dynamic;\n        }\n      }\n      if (outputVarType != null) {\n        return o.variable(this.getOutputVar(outputVarType));\n      }\n    }\n    return null;\n  }\n\n  private pipeOutputVar(name: string): string {\n    const pipe = this.pipes.get(name);\n    if (!pipe) {\n      throw new Error(\n          `Illegal State: Could not find pipe ${name} in template of ${this.component}`);\n    }\n    return this.getOutputVar(pipe);\n  }\n\n  private preprocessUpdateExpression(expression: Expression): Expression {\n    return {\n      sourceSpan: expression.sourceSpan,\n      context: expression.context,\n      value: convertPropertyBindingBuiltins(\n          {\n            createLiteralArrayConverter: (argCount: number) => (args: o.Expression[]) => {\n              const arr = o.literalArr(args);\n              // Note: The old view compiler used to use an `any` type\n              // for arrays.\n              return this.options.fullTemplateTypeCheck ? arr : arr.cast(o.DYNAMIC_TYPE);\n            },\n            createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) =>\n                (values: o.Expression[]) => {\n                  const entries = keys.map((k, i) => ({\n                                             key: k.key,\n                                             value: values[i],\n                                             quoted: k.quoted,\n                                           }));\n                  const map = o.literalMap(entries);\n                  // Note: The old view compiler used to use an `any` type\n                  // for maps.\n                  return this.options.fullTemplateTypeCheck ? map : map.cast(o.DYNAMIC_TYPE);\n                },\n            createPipeConverter: (name: string, argCount: number) => (args: o.Expression[]) => {\n              // Note: The old view compiler used to use an `any` type\n              // for pipes.\n              const pipeExpr = this.options.fullTemplateTypeCheck ?\n                  o.variable(this.pipeOutputVar(name)) :\n                  o.variable(this.getOutputVar(o.BuiltinTypeName.Dynamic));\n              return pipeExpr.callMethod('transform', args);\n            },\n          },\n          expression.value)\n    };\n  }\n\n  visitNgContent(ast: NgContentAst, context: any): any {}\n  visitText(ast: TextAst, context: any): any {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any {}\n  visitReference(ast: ReferenceAst, context: any): any {}\n  visitVariable(ast: VariableAst, context: any): any {}\n  visitEvent(ast: BoundEventAst, context: any): any {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any {}\n  visitAttr(ast: AttrAst, context: any): any {}\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}