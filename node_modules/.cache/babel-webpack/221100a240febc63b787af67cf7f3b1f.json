{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _awaitAsyncGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleActionExecutor = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar jest_worker_1 = require(\"jest-worker\");\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n\nvar v8 = require(\"v8\");\n\nvar action_cache_1 = require(\"./action-cache\");\n\nvar workers_1 = require(\"./workers\");\n\nvar hasThreadSupport = function () {\n  try {\n    require('worker_threads');\n\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}(); // This is used to normalize serialization messaging across threads and processes\n// Threads use the structured clone algorithm which handles more types\n// Processes use JSON which is much more limited\n\n\nvar serialize = v8.serialize;\n\nvar workerFile = require.resolve('./process-bundle');\n\nworkerFile = path.extname(workerFile) === '.ts' ? require.resolve('./process-bundle-bootstrap') : workerFile;\n\nvar BundleActionExecutor = /*#__PURE__*/function () {\n  function BundleActionExecutor(workerOptions, integrityAlgorithm) {\n    var sizeThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32 * 1024;\n\n    _classCallCheck(this, BundleActionExecutor);\n\n    this.workerOptions = workerOptions;\n    this.sizeThreshold = sizeThreshold;\n\n    if (workerOptions.cachePath) {\n      this.cache = new action_cache_1.BundleActionCache(workerOptions.cachePath, integrityAlgorithm);\n    }\n  }\n\n  _createClass(BundleActionExecutor, [{\n    key: \"ensureLarge\",\n    value: function ensureLarge() {\n      if (this.largeWorker) {\n        return this.largeWorker;\n      } // larger files are processed in a separate process to limit memory usage in the main process\n\n\n      return this.largeWorker = new jest_worker_1.default(workerFile, {\n        exposedMethods: ['process', 'inlineLocales'],\n        setupArgs: [_toConsumableArray(serialize(this.workerOptions))],\n        numWorkers: workers_1.maxWorkers\n      });\n    }\n  }, {\n    key: \"ensureSmall\",\n    value: function ensureSmall() {\n      if (this.smallWorker) {\n        return this.smallWorker;\n      } // small files are processed in a limited number of threads to improve speed\n      // The limited number also prevents a large increase in memory usage for an otherwise short operation\n\n\n      return this.smallWorker = new jest_worker_1.default(workerFile, {\n        exposedMethods: ['process', 'inlineLocales'],\n        setupArgs: hasThreadSupport ? [this.workerOptions] : [_toConsumableArray(serialize(this.workerOptions))],\n        numWorkers: os.cpus().length < 2 ? 1 : 2,\n        enableWorkerThreads: hasThreadSupport\n      });\n    }\n  }, {\n    key: \"executeAction\",\n    value: function executeAction(method, action) {\n      // code.length is not an exact byte count but close enough for this\n      if (action.code.length > this.sizeThreshold) {\n        return BundleActionExecutor.executeMethod(this.ensureLarge(), method, action);\n      } else {\n        return BundleActionExecutor.executeMethod(this.ensureSmall(), method, action);\n      }\n    }\n  }, {\n    key: \"process\",\n    value: function () {\n      var _process = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(action) {\n        var cacheKeys, cachedResult;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.cache) {\n                  _context.next = 13;\n                  break;\n                }\n\n                cacheKeys = this.cache.generateCacheKeys(action);\n                action.cacheKeys = cacheKeys; // Try to get cached data, if it fails fallback to processing\n\n                _context.prev = 3;\n                _context.next = 6;\n                return this.cache.getCachedBundleResult(action);\n\n              case 6:\n                cachedResult = _context.sent;\n\n                if (!cachedResult) {\n                  _context.next = 9;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", cachedResult);\n\n              case 9:\n                _context.next = 13;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](3);\n\n              case 13:\n                return _context.abrupt(\"return\", this.executeAction('process', action));\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 11]]);\n      }));\n\n      function process(_x) {\n        return _process.apply(this, arguments);\n      }\n\n      return process;\n    }()\n  }, {\n    key: \"processAll\",\n    value: function processAll(actions) {\n      var _this = this;\n\n      return BundleActionExecutor.executeAll(actions, function (action) {\n        return _this.process(action);\n      });\n    }\n  }, {\n    key: \"inline\",\n    value: function () {\n      var _inline = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(action) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.executeAction('inlineLocales', action));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function inline(_x2) {\n        return _inline.apply(this, arguments);\n      }\n\n      return inline;\n    }()\n  }, {\n    key: \"inlineAll\",\n    value: function inlineAll(actions) {\n      var _this2 = this;\n\n      return BundleActionExecutor.executeAll(actions, function (action) {\n        return _this2.inline(action);\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // Floating promises are intentional here\n      // https://github.com/facebook/jest/tree/56079a5aceacf32333089cea50c64385885fee26/packages/jest-worker#end\n      if (this.largeWorker) {\n        // tslint:disable-next-line: no-floating-promises\n        this.largeWorker.end();\n      }\n\n      if (this.smallWorker) {\n        // tslint:disable-next-line: no-floating-promises\n        this.smallWorker.end();\n      }\n    }\n  }], [{\n    key: \"executeMethod\",\n    value: function executeMethod(worker, method, input) {\n      return worker[method](input);\n    }\n  }, {\n    key: \"executeAll\",\n    value: function executeAll(actions, executor) {\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var executions, _iterator, _step, _loop;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                executions = new Map();\n                _iterator = _createForOfIteratorHelper(actions);\n\n                try {\n                  _loop = function _loop() {\n                    var action = _step.value;\n                    var execution = executor(action);\n                    executions.set(execution, execution.then(function (result) {\n                      executions.delete(execution);\n                      return result;\n                    }));\n                  };\n\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    _loop();\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n              case 3:\n                if (!(executions.size > 0)) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                _context3.next = 6;\n                return Promise.race(executions.values());\n\n              case 6:\n                _context3.next = 3;\n                break;\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    }\n  }]);\n\n  return BundleActionExecutor;\n}();\n\nexports.BundleActionExecutor = BundleActionExecutor;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/src/utils/action-executor.js"],"names":["Object","defineProperty","exports","value","BundleActionExecutor","jest_worker_1","require","os","path","v8","action_cache_1","workers_1","hasThreadSupport","_a","serialize","workerFile","resolve","extname","workerOptions","integrityAlgorithm","sizeThreshold","cachePath","cache","BundleActionCache","largeWorker","default","exposedMethods","setupArgs","numWorkers","maxWorkers","smallWorker","cpus","length","enableWorkerThreads","method","action","code","executeMethod","ensureLarge","ensureSmall","cacheKeys","generateCacheKeys","getCachedBundleResult","cachedResult","executeAction","actions","executeAll","process","inline","end","worker","input","executor","executions","Map","execution","set","then","result","delete","size","Promise","race","values"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BundleActionExecutor = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst jest_worker_1 = require(\"jest-worker\");\nconst os = require(\"os\");\nconst path = require(\"path\");\nconst v8 = require(\"v8\");\nconst action_cache_1 = require(\"./action-cache\");\nconst workers_1 = require(\"./workers\");\nconst hasThreadSupport = (() => {\n    try {\n        require('worker_threads');\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n})();\n// This is used to normalize serialization messaging across threads and processes\n// Threads use the structured clone algorithm which handles more types\n// Processes use JSON which is much more limited\nconst serialize = v8.serialize;\nlet workerFile = require.resolve('./process-bundle');\nworkerFile =\n    path.extname(workerFile) === '.ts'\n        ? require.resolve('./process-bundle-bootstrap')\n        : workerFile;\nclass BundleActionExecutor {\n    constructor(workerOptions, integrityAlgorithm, sizeThreshold = 32 * 1024) {\n        this.workerOptions = workerOptions;\n        this.sizeThreshold = sizeThreshold;\n        if (workerOptions.cachePath) {\n            this.cache = new action_cache_1.BundleActionCache(workerOptions.cachePath, integrityAlgorithm);\n        }\n    }\n    static executeMethod(worker, method, input) {\n        return worker[method](input);\n    }\n    ensureLarge() {\n        if (this.largeWorker) {\n            return this.largeWorker;\n        }\n        // larger files are processed in a separate process to limit memory usage in the main process\n        return (this.largeWorker = new jest_worker_1.default(workerFile, {\n            exposedMethods: ['process', 'inlineLocales'],\n            setupArgs: [[...serialize(this.workerOptions)]],\n            numWorkers: workers_1.maxWorkers,\n        }));\n    }\n    ensureSmall() {\n        if (this.smallWorker) {\n            return this.smallWorker;\n        }\n        // small files are processed in a limited number of threads to improve speed\n        // The limited number also prevents a large increase in memory usage for an otherwise short operation\n        return (this.smallWorker = new jest_worker_1.default(workerFile, {\n            exposedMethods: ['process', 'inlineLocales'],\n            setupArgs: hasThreadSupport ? [this.workerOptions] : [[...serialize(this.workerOptions)]],\n            numWorkers: os.cpus().length < 2 ? 1 : 2,\n            enableWorkerThreads: hasThreadSupport,\n        }));\n    }\n    executeAction(method, action) {\n        // code.length is not an exact byte count but close enough for this\n        if (action.code.length > this.sizeThreshold) {\n            return BundleActionExecutor.executeMethod(this.ensureLarge(), method, action);\n        }\n        else {\n            return BundleActionExecutor.executeMethod(this.ensureSmall(), method, action);\n        }\n    }\n    async process(action) {\n        if (this.cache) {\n            const cacheKeys = this.cache.generateCacheKeys(action);\n            action.cacheKeys = cacheKeys;\n            // Try to get cached data, if it fails fallback to processing\n            try {\n                const cachedResult = await this.cache.getCachedBundleResult(action);\n                if (cachedResult) {\n                    return cachedResult;\n                }\n            }\n            catch (_a) { }\n        }\n        return this.executeAction('process', action);\n    }\n    processAll(actions) {\n        return BundleActionExecutor.executeAll(actions, action => this.process(action));\n    }\n    async inline(action) {\n        return this.executeAction('inlineLocales', action);\n    }\n    inlineAll(actions) {\n        return BundleActionExecutor.executeAll(actions, action => this.inline(action));\n    }\n    static async *executeAll(actions, executor) {\n        const executions = new Map();\n        for (const action of actions) {\n            const execution = executor(action);\n            executions.set(execution, execution.then(result => {\n                executions.delete(execution);\n                return result;\n            }));\n        }\n        while (executions.size > 0) {\n            yield Promise.race(executions.values());\n        }\n    }\n    stop() {\n        // Floating promises are intentional here\n        // https://github.com/facebook/jest/tree/56079a5aceacf32333089cea50c64385885fee26/packages/jest-worker#end\n        if (this.largeWorker) {\n            // tslint:disable-next-line: no-floating-promises\n            this.largeWorker.end();\n        }\n        if (this.smallWorker) {\n            // tslint:disable-next-line: no-floating-promises\n            this.smallWorker.end();\n        }\n    }\n}\nexports.BundleActionExecutor = BundleActionExecutor;\n"]},"metadata":{},"sourceType":"script"}