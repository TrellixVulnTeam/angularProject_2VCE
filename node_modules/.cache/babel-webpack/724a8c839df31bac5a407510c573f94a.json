{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CordHost = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar exception_1 = require(\"../../exception\");\n\nvar memory_1 = require(\"./memory\");\n/**\n * A Host that records changes to the underlying Host, while keeping a record of Create, Overwrite,\n * Rename and Delete of files.\n *\n * This is fully compatible with Host, but will keep a staging of every changes asked. That staging\n * follows the principle of the Tree (e.g. can create a file that already exists).\n *\n * Using `create()` and `overwrite()` will force those operations, but using `write` will add\n * the create/overwrite records IIF the files does/doesn't already exist.\n */\n\n\nvar CordHost = /*#__PURE__*/function (_memory_1$SimpleMemor) {\n  _inherits(CordHost, _memory_1$SimpleMemor);\n\n  var _super = _createSuper(CordHost);\n\n  function CordHost(_back) {\n    var _this;\n\n    _classCallCheck(this, CordHost);\n\n    _this = _super.call(this);\n    _this._back = _back;\n    _this._filesToCreate = new Set();\n    _this._filesToRename = new Map();\n    _this._filesToRenameRevert = new Map();\n    _this._filesToDelete = new Set();\n    _this._filesToOverwrite = new Set();\n    return _this;\n  }\n\n  _createClass(CordHost, [{\n    key: \"backend\",\n    get: function get() {\n      return this._back;\n    }\n  }, {\n    key: \"capabilities\",\n    get: function get() {\n      // Our own host is always Synchronous, but the backend might not be.\n      return {\n        synchronous: this._back.capabilities.synchronous\n      };\n    }\n    /**\n     * Create a copy of this host, including all actions made.\n     * @returns {CordHost} The carbon copy.\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var dolly = new CordHost(this._back);\n      dolly._cache = new Map(this._cache);\n      dolly._filesToCreate = new Set(this._filesToCreate);\n      dolly._filesToRename = new Map(this._filesToRename);\n      dolly._filesToRenameRevert = new Map(this._filesToRenameRevert);\n      dolly._filesToDelete = new Set(this._filesToDelete);\n      dolly._filesToOverwrite = new Set(this._filesToOverwrite);\n      return dolly;\n    }\n    /**\n     * Commit the changes recorded to a Host. It is assumed that the host does have the same structure\n     * as the host that was used for backend (could be the same host).\n     * @param host The host to create/delete/rename/overwrite files to.\n     * @param force Whether to skip existence checks when creating/overwriting. This is\n     *   faster but might lead to incorrect states. Because Hosts natively don't support creation\n     *   versus overwriting (it's only writing), we check for existence before completing a request.\n     * @returns An observable that completes when done, or error if an error occured.\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit(host) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      // Really commit everything to the actual host.\n      return rxjs_1.from(this.records()).pipe(operators_1.concatMap(function (record) {\n        switch (record.kind) {\n          case 'delete':\n            return host.delete(record.path);\n\n          case 'rename':\n            return host.rename(record.from, record.to);\n\n          case 'create':\n            return host.exists(record.path).pipe(operators_1.switchMap(function (exists) {\n              if (exists && !force) {\n                return rxjs_1.throwError(new exception_1.FileAlreadyExistException(record.path));\n              } else {\n                return host.write(record.path, record.content);\n              }\n            }));\n\n          case 'overwrite':\n            return host.exists(record.path).pipe(operators_1.switchMap(function (exists) {\n              if (!exists && !force) {\n                return rxjs_1.throwError(new exception_1.FileDoesNotExistException(record.path));\n              } else {\n                return host.write(record.path, record.content);\n              }\n            }));\n        }\n      }), operators_1.reduce(function () {}));\n    }\n  }, {\n    key: \"records\",\n    value: function records() {\n      var _this2 = this;\n\n      return [].concat(_toConsumableArray(_toConsumableArray(this._filesToDelete.values()).map(function (path) {\n        return {\n          kind: 'delete',\n          path: path\n        };\n      })), _toConsumableArray(_toConsumableArray(this._filesToRename.entries()).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            from = _ref2[0],\n            to = _ref2[1];\n\n        return {\n          kind: 'rename',\n          from: from,\n          to: to\n        };\n      })), _toConsumableArray(_toConsumableArray(this._filesToCreate.values()).map(function (path) {\n        return {\n          kind: 'create',\n          path: path,\n          content: _this2._read(path)\n        };\n      })), _toConsumableArray(_toConsumableArray(this._filesToOverwrite.values()).map(function (path) {\n        return {\n          kind: 'overwrite',\n          path: path,\n          content: _this2._read(path)\n        };\n      })));\n    }\n    /**\n     * Specialized version of {@link CordHost#write} which forces the creation of a file whether it\n     * exists or not.\n     * @param {} path\n     * @param {FileBuffer} content\n     * @returns {Observable<void>}\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(path, content) {\n      if (_get(_getPrototypeOf(CordHost.prototype), \"_exists\", this).call(this, path)) {\n        throw new exception_1.FileAlreadyExistException(path);\n      }\n\n      if (this._filesToDelete.has(path)) {\n        this._filesToDelete.delete(path);\n\n        this._filesToOverwrite.add(path);\n      } else {\n        this._filesToCreate.add(path);\n      }\n\n      return _get(_getPrototypeOf(CordHost.prototype), \"write\", this).call(this, path, content);\n    }\n  }, {\n    key: \"overwrite\",\n    value: function overwrite(path, content) {\n      var _this3 = this;\n\n      return this.isDirectory(path).pipe(operators_1.switchMap(function (isDir) {\n        if (isDir) {\n          return rxjs_1.throwError(new exception_1.PathIsDirectoryException(path));\n        }\n\n        return _this3.exists(path);\n      }), operators_1.switchMap(function (exists) {\n        if (!exists) {\n          return rxjs_1.throwError(new exception_1.FileDoesNotExistException(path));\n        }\n\n        if (!_this3._filesToCreate.has(path)) {\n          _this3._filesToOverwrite.add(path);\n        }\n\n        return _get(_getPrototypeOf(CordHost.prototype), \"write\", _this3).call(_this3, path, content);\n      }));\n    }\n  }, {\n    key: \"write\",\n    value: function write(path, content) {\n      var _this4 = this;\n\n      return this.exists(path).pipe(operators_1.switchMap(function (exists) {\n        if (exists) {\n          // It exists, but might be being renamed or deleted. In that case we want to create it.\n          if (_this4.willRename(path) || _this4.willDelete(path)) {\n            return _this4.create(path, content);\n          } else {\n            return _this4.overwrite(path, content);\n          }\n        } else {\n          return _this4.create(path, content);\n        }\n      }));\n    }\n  }, {\n    key: \"read\",\n    value: function read(path) {\n      if (this._exists(path)) {\n        return _get(_getPrototypeOf(CordHost.prototype), \"read\", this).call(this, path);\n      }\n\n      return this._back.read(path);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(path) {\n      var _this5 = this;\n\n      if (this._exists(path)) {\n        if (this._filesToCreate.has(path)) {\n          this._filesToCreate.delete(path);\n        } else if (this._filesToOverwrite.has(path)) {\n          this._filesToOverwrite.delete(path);\n\n          this._filesToDelete.add(path);\n        } else {\n          var maybeOrigin = this._filesToRenameRevert.get(path);\n\n          if (maybeOrigin) {\n            this._filesToRenameRevert.delete(path);\n\n            this._filesToRename.delete(maybeOrigin);\n\n            this._filesToDelete.add(maybeOrigin);\n          } else {\n            return rxjs_1.throwError(new exception_1.UnknownException(\"This should never happen. Path: \".concat(JSON.stringify(path), \".\")));\n          }\n        }\n\n        return _get(_getPrototypeOf(CordHost.prototype), \"delete\", this).call(this, path);\n      } else {\n        return this._back.exists(path).pipe(operators_1.switchMap(function (exists) {\n          if (exists) {\n            _this5._filesToDelete.add(path);\n\n            return rxjs_1.of();\n          } else {\n            return rxjs_1.throwError(new exception_1.FileDoesNotExistException(path));\n          }\n        }));\n      }\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(from, to) {\n      var _this6 = this;\n\n      return rxjs_1.concat(this.exists(to), this.exists(from)).pipe(operators_1.toArray(), operators_1.switchMap(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            existTo = _ref4[0],\n            existFrom = _ref4[1];\n\n        if (!existFrom) {\n          return rxjs_1.throwError(new exception_1.FileDoesNotExistException(from));\n        }\n\n        if (from === to) {\n          return rxjs_1.EMPTY;\n        }\n\n        if (existTo) {\n          return rxjs_1.throwError(new exception_1.FileAlreadyExistException(to));\n        } // If we're renaming a file that's been created, shortcircuit to creating the `to` path.\n\n\n        if (_this6._filesToCreate.has(from)) {\n          _this6._filesToCreate.delete(from);\n\n          _this6._filesToCreate.add(to);\n\n          return _get(_getPrototypeOf(CordHost.prototype), \"rename\", _this6).call(_this6, from, to);\n        }\n\n        if (_this6._filesToOverwrite.has(from)) {\n          _this6._filesToOverwrite.delete(from); // Recursively call this function. This is so we don't repeat the bottom logic. This\n          // if will be by-passed because we just deleted the `from` path from files to overwrite.\n\n\n          return rxjs_1.concat(_this6.rename(from, to), new rxjs_1.Observable(function (x) {\n            _this6._filesToOverwrite.add(to);\n\n            x.complete();\n          }));\n        }\n\n        if (_this6._filesToDelete.has(to)) {\n          _this6._filesToDelete.delete(to);\n\n          _this6._filesToDelete.add(from);\n\n          _this6._filesToOverwrite.add(to); // We need to delete the original and write the new one.\n\n\n          return _this6.read(from).pipe(operators_1.map(function (content) {\n            return _this6._write(to, content);\n          }));\n        }\n\n        var maybeTo1 = _this6._filesToRenameRevert.get(from);\n\n        if (maybeTo1) {\n          // We already renamed to this file (A => from), let's rename the former to the new\n          // path (A => to).\n          _this6._filesToRename.delete(maybeTo1);\n\n          _this6._filesToRenameRevert.delete(from);\n\n          from = maybeTo1;\n        }\n\n        _this6._filesToRename.set(from, to);\n\n        _this6._filesToRenameRevert.set(to, from); // If the file is part of our data, just rename it internally.\n\n\n        if (_this6._exists(from)) {\n          return _get(_getPrototypeOf(CordHost.prototype), \"rename\", _this6).call(_this6, from, to);\n        } else {\n          // Create a file with the same content.\n          return _this6._back.read(from).pipe(operators_1.switchMap(function (content) {\n            return _get(_getPrototypeOf(CordHost.prototype), \"write\", _this6).call(_this6, to, content);\n          }));\n        }\n      }));\n    }\n  }, {\n    key: \"list\",\n    value: function list(path) {\n      return rxjs_1.concat(_get(_getPrototypeOf(CordHost.prototype), \"list\", this).call(this, path), this._back.list(path)).pipe(operators_1.reduce(function (list, curr) {\n        curr.forEach(function (elem) {\n          return list.add(elem);\n        });\n        return list;\n      }, new Set()), operators_1.map(function (set) {\n        return _toConsumableArray(set);\n      }));\n    }\n  }, {\n    key: \"exists\",\n    value: function exists(path) {\n      return this._exists(path) ? rxjs_1.of(true) : this.willDelete(path) || this.willRename(path) ? rxjs_1.of(false) : this._back.exists(path);\n    }\n  }, {\n    key: \"isDirectory\",\n    value: function isDirectory(path) {\n      return this._exists(path) ? _get(_getPrototypeOf(CordHost.prototype), \"isDirectory\", this).call(this, path) : this._back.isDirectory(path);\n    }\n  }, {\n    key: \"isFile\",\n    value: function isFile(path) {\n      return this._exists(path) ? _get(_getPrototypeOf(CordHost.prototype), \"isFile\", this).call(this, path) : this.willDelete(path) || this.willRename(path) ? rxjs_1.of(false) : this._back.isFile(path);\n    }\n  }, {\n    key: \"stat\",\n    value: function stat(path) {\n      return this._exists(path) ? _get(_getPrototypeOf(CordHost.prototype), \"stat\", this).call(this, path) : this.willDelete(path) || this.willRename(path) ? rxjs_1.of(null) : this._back.stat(path);\n    }\n  }, {\n    key: \"watch\",\n    value: function watch(path, options) {\n      // Watching not supported.\n      return null;\n    }\n  }, {\n    key: \"willCreate\",\n    value: function willCreate(path) {\n      return this._filesToCreate.has(path);\n    }\n  }, {\n    key: \"willOverwrite\",\n    value: function willOverwrite(path) {\n      return this._filesToOverwrite.has(path);\n    }\n  }, {\n    key: \"willDelete\",\n    value: function willDelete(path) {\n      return this._filesToDelete.has(path);\n    }\n  }, {\n    key: \"willRename\",\n    value: function willRename(path) {\n      return this._filesToRename.has(path);\n    }\n  }, {\n    key: \"willRenameTo\",\n    value: function willRenameTo(path, to) {\n      return this._filesToRename.get(path) === to;\n    }\n  }]);\n\n  return CordHost;\n}(memory_1.SimpleMemoryHost);\n\nexports.CordHost = CordHost;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/virtual-fs/host/record.js"],"names":["Object","defineProperty","exports","value","CordHost","rxjs_1","require","operators_1","exception_1","memory_1","_back","_filesToCreate","Set","_filesToRename","Map","_filesToRenameRevert","_filesToDelete","_filesToOverwrite","synchronous","capabilities","dolly","_cache","host","force","from","records","pipe","concatMap","record","kind","delete","path","rename","to","exists","switchMap","throwError","FileAlreadyExistException","write","content","FileDoesNotExistException","reduce","values","map","entries","_read","has","add","isDirectory","isDir","PathIsDirectoryException","willRename","willDelete","create","overwrite","_exists","read","maybeOrigin","get","UnknownException","JSON","stringify","of","concat","toArray","existTo","existFrom","EMPTY","Observable","x","complete","_write","maybeTo1","set","list","curr","forEach","elem","isFile","stat","options","SimpleMemoryHost"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CordHost = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst exception_1 = require(\"../../exception\");\nconst memory_1 = require(\"./memory\");\n/**\n * A Host that records changes to the underlying Host, while keeping a record of Create, Overwrite,\n * Rename and Delete of files.\n *\n * This is fully compatible with Host, but will keep a staging of every changes asked. That staging\n * follows the principle of the Tree (e.g. can create a file that already exists).\n *\n * Using `create()` and `overwrite()` will force those operations, but using `write` will add\n * the create/overwrite records IIF the files does/doesn't already exist.\n */\nclass CordHost extends memory_1.SimpleMemoryHost {\n    constructor(_back) {\n        super();\n        this._back = _back;\n        this._filesToCreate = new Set();\n        this._filesToRename = new Map();\n        this._filesToRenameRevert = new Map();\n        this._filesToDelete = new Set();\n        this._filesToOverwrite = new Set();\n    }\n    get backend() { return this._back; }\n    get capabilities() {\n        // Our own host is always Synchronous, but the backend might not be.\n        return {\n            synchronous: this._back.capabilities.synchronous,\n        };\n    }\n    /**\n     * Create a copy of this host, including all actions made.\n     * @returns {CordHost} The carbon copy.\n     */\n    clone() {\n        const dolly = new CordHost(this._back);\n        dolly._cache = new Map(this._cache);\n        dolly._filesToCreate = new Set(this._filesToCreate);\n        dolly._filesToRename = new Map(this._filesToRename);\n        dolly._filesToRenameRevert = new Map(this._filesToRenameRevert);\n        dolly._filesToDelete = new Set(this._filesToDelete);\n        dolly._filesToOverwrite = new Set(this._filesToOverwrite);\n        return dolly;\n    }\n    /**\n     * Commit the changes recorded to a Host. It is assumed that the host does have the same structure\n     * as the host that was used for backend (could be the same host).\n     * @param host The host to create/delete/rename/overwrite files to.\n     * @param force Whether to skip existence checks when creating/overwriting. This is\n     *   faster but might lead to incorrect states. Because Hosts natively don't support creation\n     *   versus overwriting (it's only writing), we check for existence before completing a request.\n     * @returns An observable that completes when done, or error if an error occured.\n     */\n    commit(host, force = false) {\n        // Really commit everything to the actual host.\n        return rxjs_1.from(this.records()).pipe(operators_1.concatMap(record => {\n            switch (record.kind) {\n                case 'delete': return host.delete(record.path);\n                case 'rename': return host.rename(record.from, record.to);\n                case 'create':\n                    return host.exists(record.path).pipe(operators_1.switchMap(exists => {\n                        if (exists && !force) {\n                            return rxjs_1.throwError(new exception_1.FileAlreadyExistException(record.path));\n                        }\n                        else {\n                            return host.write(record.path, record.content);\n                        }\n                    }));\n                case 'overwrite':\n                    return host.exists(record.path).pipe(operators_1.switchMap(exists => {\n                        if (!exists && !force) {\n                            return rxjs_1.throwError(new exception_1.FileDoesNotExistException(record.path));\n                        }\n                        else {\n                            return host.write(record.path, record.content);\n                        }\n                    }));\n            }\n        }), operators_1.reduce(() => { }));\n    }\n    records() {\n        return [\n            ...[...this._filesToDelete.values()].map(path => ({\n                kind: 'delete', path,\n            })),\n            ...[...this._filesToRename.entries()].map(([from, to]) => ({\n                kind: 'rename', from, to,\n            })),\n            ...[...this._filesToCreate.values()].map(path => ({\n                kind: 'create', path, content: this._read(path),\n            })),\n            ...[...this._filesToOverwrite.values()].map(path => ({\n                kind: 'overwrite', path, content: this._read(path),\n            })),\n        ];\n    }\n    /**\n     * Specialized version of {@link CordHost#write} which forces the creation of a file whether it\n     * exists or not.\n     * @param {} path\n     * @param {FileBuffer} content\n     * @returns {Observable<void>}\n     */\n    create(path, content) {\n        if (super._exists(path)) {\n            throw new exception_1.FileAlreadyExistException(path);\n        }\n        if (this._filesToDelete.has(path)) {\n            this._filesToDelete.delete(path);\n            this._filesToOverwrite.add(path);\n        }\n        else {\n            this._filesToCreate.add(path);\n        }\n        return super.write(path, content);\n    }\n    overwrite(path, content) {\n        return this.isDirectory(path).pipe(operators_1.switchMap(isDir => {\n            if (isDir) {\n                return rxjs_1.throwError(new exception_1.PathIsDirectoryException(path));\n            }\n            return this.exists(path);\n        }), operators_1.switchMap(exists => {\n            if (!exists) {\n                return rxjs_1.throwError(new exception_1.FileDoesNotExistException(path));\n            }\n            if (!this._filesToCreate.has(path)) {\n                this._filesToOverwrite.add(path);\n            }\n            return super.write(path, content);\n        }));\n    }\n    write(path, content) {\n        return this.exists(path).pipe(operators_1.switchMap(exists => {\n            if (exists) {\n                // It exists, but might be being renamed or deleted. In that case we want to create it.\n                if (this.willRename(path) || this.willDelete(path)) {\n                    return this.create(path, content);\n                }\n                else {\n                    return this.overwrite(path, content);\n                }\n            }\n            else {\n                return this.create(path, content);\n            }\n        }));\n    }\n    read(path) {\n        if (this._exists(path)) {\n            return super.read(path);\n        }\n        return this._back.read(path);\n    }\n    delete(path) {\n        if (this._exists(path)) {\n            if (this._filesToCreate.has(path)) {\n                this._filesToCreate.delete(path);\n            }\n            else if (this._filesToOverwrite.has(path)) {\n                this._filesToOverwrite.delete(path);\n                this._filesToDelete.add(path);\n            }\n            else {\n                const maybeOrigin = this._filesToRenameRevert.get(path);\n                if (maybeOrigin) {\n                    this._filesToRenameRevert.delete(path);\n                    this._filesToRename.delete(maybeOrigin);\n                    this._filesToDelete.add(maybeOrigin);\n                }\n                else {\n                    return rxjs_1.throwError(new exception_1.UnknownException(`This should never happen. Path: ${JSON.stringify(path)}.`));\n                }\n            }\n            return super.delete(path);\n        }\n        else {\n            return this._back.exists(path).pipe(operators_1.switchMap(exists => {\n                if (exists) {\n                    this._filesToDelete.add(path);\n                    return rxjs_1.of();\n                }\n                else {\n                    return rxjs_1.throwError(new exception_1.FileDoesNotExistException(path));\n                }\n            }));\n        }\n    }\n    rename(from, to) {\n        return rxjs_1.concat(this.exists(to), this.exists(from)).pipe(operators_1.toArray(), operators_1.switchMap(([existTo, existFrom]) => {\n            if (!existFrom) {\n                return rxjs_1.throwError(new exception_1.FileDoesNotExistException(from));\n            }\n            if (from === to) {\n                return rxjs_1.EMPTY;\n            }\n            if (existTo) {\n                return rxjs_1.throwError(new exception_1.FileAlreadyExistException(to));\n            }\n            // If we're renaming a file that's been created, shortcircuit to creating the `to` path.\n            if (this._filesToCreate.has(from)) {\n                this._filesToCreate.delete(from);\n                this._filesToCreate.add(to);\n                return super.rename(from, to);\n            }\n            if (this._filesToOverwrite.has(from)) {\n                this._filesToOverwrite.delete(from);\n                // Recursively call this function. This is so we don't repeat the bottom logic. This\n                // if will be by-passed because we just deleted the `from` path from files to overwrite.\n                return rxjs_1.concat(this.rename(from, to), new rxjs_1.Observable(x => {\n                    this._filesToOverwrite.add(to);\n                    x.complete();\n                }));\n            }\n            if (this._filesToDelete.has(to)) {\n                this._filesToDelete.delete(to);\n                this._filesToDelete.add(from);\n                this._filesToOverwrite.add(to);\n                // We need to delete the original and write the new one.\n                return this.read(from).pipe(operators_1.map(content => this._write(to, content)));\n            }\n            const maybeTo1 = this._filesToRenameRevert.get(from);\n            if (maybeTo1) {\n                // We already renamed to this file (A => from), let's rename the former to the new\n                // path (A => to).\n                this._filesToRename.delete(maybeTo1);\n                this._filesToRenameRevert.delete(from);\n                from = maybeTo1;\n            }\n            this._filesToRename.set(from, to);\n            this._filesToRenameRevert.set(to, from);\n            // If the file is part of our data, just rename it internally.\n            if (this._exists(from)) {\n                return super.rename(from, to);\n            }\n            else {\n                // Create a file with the same content.\n                return this._back.read(from).pipe(operators_1.switchMap(content => super.write(to, content)));\n            }\n        }));\n    }\n    list(path) {\n        return rxjs_1.concat(super.list(path), this._back.list(path)).pipe(operators_1.reduce((list, curr) => {\n            curr.forEach(elem => list.add(elem));\n            return list;\n        }, new Set()), operators_1.map(set => [...set]));\n    }\n    exists(path) {\n        return this._exists(path)\n            ? rxjs_1.of(true)\n            : ((this.willDelete(path) || this.willRename(path)) ? rxjs_1.of(false) : this._back.exists(path));\n    }\n    isDirectory(path) {\n        return this._exists(path) ? super.isDirectory(path) : this._back.isDirectory(path);\n    }\n    isFile(path) {\n        return this._exists(path)\n            ? super.isFile(path)\n            : ((this.willDelete(path) || this.willRename(path)) ? rxjs_1.of(false) : this._back.isFile(path));\n    }\n    stat(path) {\n        return this._exists(path)\n            ? super.stat(path)\n            : ((this.willDelete(path) || this.willRename(path)) ? rxjs_1.of(null) : this._back.stat(path));\n    }\n    watch(path, options) {\n        // Watching not supported.\n        return null;\n    }\n    willCreate(path) {\n        return this._filesToCreate.has(path);\n    }\n    willOverwrite(path) {\n        return this._filesToOverwrite.has(path);\n    }\n    willDelete(path) {\n        return this._filesToDelete.has(path);\n    }\n    willRename(path) {\n        return this._filesToRename.has(path);\n    }\n    willRenameTo(path, to) {\n        return this._filesToRename.get(path) === to;\n    }\n}\nexports.CordHost = CordHost;\n"]},"metadata":{},"sourceType":"script"}