{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/styling_builder\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/expression_parser/ast\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/template_parser/template_parser\", \"@angular/compiler/src/render3/r3_identifiers\", \"@angular/compiler/src/render3/view/style_parser\", \"@angular/compiler/src/render3/view/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.parseProperty = exports.StylingBuilder = exports.MIN_STYLING_BINDING_SLOTS_REQUIRED = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ast_1 = require(\"@angular/compiler/src/expression_parser/ast\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var template_parser_1 = require(\"@angular/compiler/src/template_parser/template_parser\");\n\n  var r3_identifiers_1 = require(\"@angular/compiler/src/render3/r3_identifiers\");\n\n  var style_parser_1 = require(\"@angular/compiler/src/render3/view/style_parser\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/view/util\");\n\n  var IMPORTANT_FLAG = '!important';\n  /**\n   * Minimum amount of binding slots required in the runtime for style/class bindings.\n   *\n   * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n   * record binding data, property information and metadata.\n   *\n   * When a binding is registered it will place the following information in the `LView`:\n   *\n   * slot 1) binding value\n   * slot 2) cached value (all other values collected before it in string form)\n   *\n   * When a binding is registered it will place the following information in the `TData`:\n   *\n   * slot 1) prop name\n   * slot 2) binding index that points to the previous style/class binding (and some extra config\n   * values)\n   *\n   * Let's imagine we have a binding that looks like so:\n   *\n   * ```\n   * <div [style.width]=\"x\" [style.height]=\"y\">\n   * ```\n   *\n   * Our `LView` and `TData` data-structures look like so:\n   *\n   * ```typescript\n   * LView = [\n   *   // ...\n   *   x, // value of x\n   *   \"width: x\",\n   *\n   *   y, // value of y\n   *   \"width: x; height: y\",\n   *   // ...\n   * ];\n   *\n   * TData = [\n   *   // ...\n   *   \"width\", // binding slot 20\n   *   0,\n   *\n   *   \"height\",\n   *   20,\n   *   // ...\n   * ];\n   * ```\n   *\n   * */\n\n  exports.MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n  /**\n   * Produces creation/update instructions for all styling bindings (class and style)\n   *\n   * It also produces the creation instruction to register all initial styling values\n   * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n   * on an element within a template).\n   *\n   * The builder class below handles producing instructions for the following cases:\n   *\n   * - Static style/class attributes (style=\"...\" and class=\"...\")\n   * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n   * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n   *\n   * Due to the complex relationship of all of these cases, the instructions generated\n   * for these attributes/properties/bindings must be done so in the correct order. The\n   * order which these must be generated is as follows:\n   *\n   * if (createMode) {\n   *   styling(...)\n   * }\n   * if (updateMode) {\n   *   styleMap(...)\n   *   classMap(...)\n   *   styleProp(...)\n   *   classProp(...)\n   * }\n   *\n   * The creation/update methods within the builder class produce these instructions.\n   */\n\n  var StylingBuilder =\n  /** @class */\n  function () {\n    function StylingBuilder(_directiveExpr) {\n      this._directiveExpr = _directiveExpr;\n      /** Whether or not there are any static styling values present */\n\n      this._hasInitialValues = false;\n      /**\n       *  Whether or not there are any styling bindings present\n       *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n       */\n\n      this.hasBindings = false;\n      this.hasBindingsWithPipes = false;\n      /** the input for [class] (if it exists) */\n\n      this._classMapInput = null;\n      /** the input for [style] (if it exists) */\n\n      this._styleMapInput = null;\n      /** an array of each [style.prop] input */\n\n      this._singleStyleInputs = null;\n      /** an array of each [class.name] input */\n\n      this._singleClassInputs = null;\n      this._lastStylingInput = null;\n      this._firstStylingInput = null; // maps are used instead of hash maps because a Map will\n      // retain the ordering of the keys\n\n      /**\n       * Represents the location of each style binding in the template\n       * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n       * that `width=0` and `height=1`)\n       */\n\n      this._stylesIndex = new Map();\n      /**\n       * Represents the location of each class binding in the template\n       * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n       * that `big=0` and `hidden=1`)\n       */\n\n      this._classesIndex = new Map();\n      this._initialStyleValues = [];\n      this._initialClassValues = [];\n    }\n    /**\n     * Registers a given input to the styling builder to be later used when producing AOT code.\n     *\n     * The code below will only accept the input if it is somehow tied to styling (whether it be\n     * style/class bindings or static style/class attributes).\n     */\n\n\n    StylingBuilder.prototype.registerBoundInput = function (input) {\n      // [attr.style] or [attr.class] are skipped in the code below,\n      // they should not be treated as styling-based bindings since\n      // they are intended to be written directly to the attr and\n      // will therefore skip all style/class resolution that is present\n      // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n      // [class.prop]=\"\". [class]=\"\" assignments\n      var binding = null;\n      var name = input.name;\n\n      switch (input.type) {\n        case 0\n        /* Property */\n        :\n          binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n          break;\n\n        case 3\n        /* Style */\n        :\n          binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n          break;\n\n        case 2\n        /* Class */\n        :\n          binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n          break;\n      }\n\n      return binding ? true : false;\n    };\n\n    StylingBuilder.prototype.registerInputBasedOnName = function (name, expression, sourceSpan) {\n      var binding = null;\n      var prefix = name.substring(0, 6);\n      var isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n      var isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n\n      if (isStyle || isClass) {\n        var isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\n\n        var property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1\n\n        if (isStyle) {\n          binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n        } else {\n          binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n        }\n      }\n\n      return binding;\n    };\n\n    StylingBuilder.prototype.registerStyleInput = function (name, isMapBased, value, sourceSpan, suffix) {\n      if (template_parser_1.isEmptyExpression(value)) {\n        return null;\n      } // CSS custom properties are case-sensitive so we shouldn't normalize them.\n      // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n\n\n      if (!isCssCustomProperty(name)) {\n        name = style_parser_1.hyphenate(name);\n      }\n\n      var _a = parseProperty(name),\n          property = _a.property,\n          hasOverrideFlag = _a.hasOverrideFlag,\n          bindingSuffix = _a.suffix;\n\n      suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n      var entry = {\n        name: property,\n        suffix: suffix,\n        value: value,\n        sourceSpan: sourceSpan,\n        hasOverrideFlag: hasOverrideFlag\n      };\n\n      if (isMapBased) {\n        this._styleMapInput = entry;\n      } else {\n        (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n        registerIntoMap(this._stylesIndex, property);\n      }\n\n      this._lastStylingInput = entry;\n      this._firstStylingInput = this._firstStylingInput || entry;\n\n      this._checkForPipes(value);\n\n      this.hasBindings = true;\n      return entry;\n    };\n\n    StylingBuilder.prototype.registerClassInput = function (name, isMapBased, value, sourceSpan) {\n      if (template_parser_1.isEmptyExpression(value)) {\n        return null;\n      }\n\n      var _a = parseProperty(name),\n          property = _a.property,\n          hasOverrideFlag = _a.hasOverrideFlag;\n\n      var entry = {\n        name: property,\n        value: value,\n        sourceSpan: sourceSpan,\n        hasOverrideFlag: hasOverrideFlag,\n        suffix: null\n      };\n\n      if (isMapBased) {\n        this._classMapInput = entry;\n      } else {\n        (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n        registerIntoMap(this._classesIndex, property);\n      }\n\n      this._lastStylingInput = entry;\n      this._firstStylingInput = this._firstStylingInput || entry;\n\n      this._checkForPipes(value);\n\n      this.hasBindings = true;\n      return entry;\n    };\n\n    StylingBuilder.prototype._checkForPipes = function (value) {\n      if (value instanceof ast_1.ASTWithSource && value.ast instanceof ast_1.BindingPipe) {\n        this.hasBindingsWithPipes = true;\n      }\n    };\n    /**\n     * Registers the element's static style string value to the builder.\n     *\n     * @param value the style string (e.g. `width:100px; height:200px;`)\n     */\n\n\n    StylingBuilder.prototype.registerStyleAttr = function (value) {\n      this._initialStyleValues = style_parser_1.parse(value);\n      this._hasInitialValues = true;\n    };\n    /**\n     * Registers the element's static class string value to the builder.\n     *\n     * @param value the className string (e.g. `disabled gold zoom`)\n     */\n\n\n    StylingBuilder.prototype.registerClassAttr = function (value) {\n      this._initialClassValues = value.trim().split(/\\s+/g);\n      this._hasInitialValues = true;\n    };\n    /**\n     * Appends all styling-related expressions to the provided attrs array.\n     *\n     * @param attrs an existing array where each of the styling expressions\n     * will be inserted into.\n     */\n\n\n    StylingBuilder.prototype.populateInitialStylingAttrs = function (attrs) {\n      // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n      if (this._initialClassValues.length) {\n        attrs.push(o.literal(1\n        /* Classes */\n        ));\n\n        for (var i = 0; i < this._initialClassValues.length; i++) {\n          attrs.push(o.literal(this._initialClassValues[i]));\n        }\n      } // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n\n\n      if (this._initialStyleValues.length) {\n        attrs.push(o.literal(2\n        /* Styles */\n        ));\n\n        for (var i = 0; i < this._initialStyleValues.length; i += 2) {\n          attrs.push(o.literal(this._initialStyleValues[i]), o.literal(this._initialStyleValues[i + 1]));\n        }\n      }\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n     *\n     * The instruction generation code below is used for producing the AOT statement code which is\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\n     * as well as any of the provided attribute values, to the directive host element.\n     */\n\n\n    StylingBuilder.prototype.assignHostAttrs = function (attrs, definitionMap) {\n      if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n        this.populateInitialStylingAttrs(attrs);\n        definitionMap.set('hostAttrs', o.literalArr(attrs));\n      }\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `classMap`.\n     *\n     * The instruction data will contain all expressions for `classMap` to function\n     * which includes the `[class]` expression params.\n     */\n\n\n    StylingBuilder.prototype.buildClassMapInstruction = function (valueConverter) {\n      if (this._classMapInput) {\n        return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n      }\n\n      return null;\n    };\n    /**\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\n     *\n     * The instruction data will contain all expressions for `styleMap` to function\n     * which includes the `[style]` expression params.\n     */\n\n\n    StylingBuilder.prototype.buildStyleMapInstruction = function (valueConverter) {\n      if (this._styleMapInput) {\n        return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n      }\n\n      return null;\n    };\n\n    StylingBuilder.prototype._buildMapBasedInstruction = function (valueConverter, isClassBased, stylingInput) {\n      // each styling binding value is stored in the LView\n      // map-based bindings allocate two slots: one for the\n      // previous binding value and another for the previous\n      // className or style attribute value.\n      var totalBindingSlotsRequired = exports.MIN_STYLING_BINDING_SLOTS_REQUIRED; // these values must be outside of the update block so that they can\n      // be evaluated (the AST visit call) during creation time so that any\n      // pipes can be picked up in time before the template is built\n\n      var mapValue = stylingInput.value.visit(valueConverter);\n      var reference;\n\n      if (mapValue instanceof ast_1.Interpolation) {\n        totalBindingSlotsRequired += mapValue.expressions.length;\n        reference = isClassBased ? getClassMapInterpolationExpression(mapValue) : getStyleMapInterpolationExpression(mapValue);\n      } else {\n        reference = isClassBased ? r3_identifiers_1.Identifiers.classMap : r3_identifiers_1.Identifiers.styleMap;\n      }\n\n      return {\n        reference: reference,\n        calls: [{\n          supportsInterpolation: true,\n          sourceSpan: stylingInput.sourceSpan,\n          allocateBindingSlots: totalBindingSlotsRequired,\n          params: function params(convertFn) {\n            var convertResult = convertFn(mapValue);\n            var params = Array.isArray(convertResult) ? convertResult : [convertResult];\n            return params;\n          }\n        }]\n      };\n    };\n\n    StylingBuilder.prototype._buildSingleInputs = function (reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {\n      var instructions = [];\n      inputs.forEach(function (input) {\n        var previousInstruction = instructions[instructions.length - 1];\n        var value = input.value.visit(valueConverter);\n        var referenceForCall = reference; // each styling binding value is stored in the LView\n        // but there are two values stored for each binding:\n        //   1) the value itself\n        //   2) an intermediate value (concatenation of style up to this point).\n        //      We need to store the intermediate value so that we don't allocate\n        //      the strings on each CD.\n\n        var totalBindingSlotsRequired = exports.MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n        if (value instanceof ast_1.Interpolation) {\n          totalBindingSlotsRequired += value.expressions.length;\n\n          if (getInterpolationExpressionFn) {\n            referenceForCall = getInterpolationExpressionFn(value);\n          }\n        }\n\n        var call = {\n          sourceSpan: input.sourceSpan,\n          allocateBindingSlots: totalBindingSlotsRequired,\n          supportsInterpolation: !!getInterpolationExpressionFn,\n          params: function params(convertFn) {\n            // params => stylingProp(propName, value, suffix)\n            var params = [];\n            params.push(o.literal(input.name));\n            var convertResult = convertFn(value);\n\n            if (Array.isArray(convertResult)) {\n              params.push.apply(params, tslib_1.__spread(convertResult));\n            } else {\n              params.push(convertResult);\n            } // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n            // if that is detected then we need to pass that in as an optional param.\n\n\n            if (!isClassBased && input.suffix !== null) {\n              params.push(o.literal(input.suffix));\n            }\n\n            return params;\n          }\n        }; // If we ended up generating a call to the same instruction as the previous styling property\n        // we can chain the calls together safely to save some bytes, otherwise we have to generate\n        // a separate instruction call. This is primarily a concern with interpolation instructions\n        // where we may start off with one `reference`, but end up using another based on the\n        // number of interpolations.\n\n        if (previousInstruction && previousInstruction.reference === referenceForCall) {\n          previousInstruction.calls.push(call);\n        } else {\n          instructions.push({\n            reference: referenceForCall,\n            calls: [call]\n          });\n        }\n      });\n      return instructions;\n    };\n\n    StylingBuilder.prototype._buildClassInputs = function (valueConverter) {\n      if (this._singleClassInputs) {\n        return this._buildSingleInputs(r3_identifiers_1.Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);\n      }\n\n      return [];\n    };\n\n    StylingBuilder.prototype._buildStyleInputs = function (valueConverter) {\n      if (this._singleStyleInputs) {\n        return this._buildSingleInputs(r3_identifiers_1.Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);\n      }\n\n      return [];\n    };\n    /**\n     * Constructs all instructions which contain the expressions that will be placed\n     * into the update block of a template function or a directive hostBindings function.\n     */\n\n\n    StylingBuilder.prototype.buildUpdateLevelInstructions = function (valueConverter) {\n      var instructions = [];\n\n      if (this.hasBindings) {\n        var styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n\n        if (styleMapInstruction) {\n          instructions.push(styleMapInstruction);\n        }\n\n        var classMapInstruction = this.buildClassMapInstruction(valueConverter);\n\n        if (classMapInstruction) {\n          instructions.push(classMapInstruction);\n        }\n\n        instructions.push.apply(instructions, tslib_1.__spread(this._buildStyleInputs(valueConverter)));\n        instructions.push.apply(instructions, tslib_1.__spread(this._buildClassInputs(valueConverter)));\n      }\n\n      return instructions;\n    };\n\n    return StylingBuilder;\n  }();\n\n  exports.StylingBuilder = StylingBuilder;\n\n  function registerIntoMap(map, key) {\n    if (!map.has(key)) {\n      map.set(key, map.size);\n    }\n  }\n\n  function parseProperty(name) {\n    var hasOverrideFlag = false;\n    var overrideIndex = name.indexOf(IMPORTANT_FLAG);\n\n    if (overrideIndex !== -1) {\n      name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n      hasOverrideFlag = true;\n    }\n\n    var suffix = null;\n    var property = name;\n    var unitIndex = name.lastIndexOf('.');\n\n    if (unitIndex > 0) {\n      suffix = name.substr(unitIndex + 1);\n      property = name.substring(0, unitIndex);\n    }\n\n    return {\n      property: property,\n      suffix: suffix,\n      hasOverrideFlag: hasOverrideFlag\n    };\n  }\n\n  exports.parseProperty = parseProperty;\n  /**\n   * Gets the instruction to generate for an interpolated class map.\n   * @param interpolation An Interpolation AST\n   */\n\n  function getClassMapInterpolationExpression(interpolation) {\n    switch (util_1.getInterpolationArgsLength(interpolation)) {\n      case 1:\n        return r3_identifiers_1.Identifiers.classMap;\n\n      case 3:\n        return r3_identifiers_1.Identifiers.classMapInterpolate1;\n\n      case 5:\n        return r3_identifiers_1.Identifiers.classMapInterpolate2;\n\n      case 7:\n        return r3_identifiers_1.Identifiers.classMapInterpolate3;\n\n      case 9:\n        return r3_identifiers_1.Identifiers.classMapInterpolate4;\n\n      case 11:\n        return r3_identifiers_1.Identifiers.classMapInterpolate5;\n\n      case 13:\n        return r3_identifiers_1.Identifiers.classMapInterpolate6;\n\n      case 15:\n        return r3_identifiers_1.Identifiers.classMapInterpolate7;\n\n      case 17:\n        return r3_identifiers_1.Identifiers.classMapInterpolate8;\n\n      default:\n        return r3_identifiers_1.Identifiers.classMapInterpolateV;\n    }\n  }\n  /**\n   * Gets the instruction to generate for an interpolated style map.\n   * @param interpolation An Interpolation AST\n   */\n\n\n  function getStyleMapInterpolationExpression(interpolation) {\n    switch (util_1.getInterpolationArgsLength(interpolation)) {\n      case 1:\n        return r3_identifiers_1.Identifiers.styleMap;\n\n      case 3:\n        return r3_identifiers_1.Identifiers.styleMapInterpolate1;\n\n      case 5:\n        return r3_identifiers_1.Identifiers.styleMapInterpolate2;\n\n      case 7:\n        return r3_identifiers_1.Identifiers.styleMapInterpolate3;\n\n      case 9:\n        return r3_identifiers_1.Identifiers.styleMapInterpolate4;\n\n      case 11:\n        return r3_identifiers_1.Identifiers.styleMapInterpolate5;\n\n      case 13:\n        return r3_identifiers_1.Identifiers.styleMapInterpolate6;\n\n      case 15:\n        return r3_identifiers_1.Identifiers.styleMapInterpolate7;\n\n      case 17:\n        return r3_identifiers_1.Identifiers.styleMapInterpolate8;\n\n      default:\n        return r3_identifiers_1.Identifiers.styleMapInterpolateV;\n    }\n  }\n  /**\n   * Gets the instruction to generate for an interpolated style prop.\n   * @param interpolation An Interpolation AST\n   */\n\n\n  function getStylePropInterpolationExpression(interpolation) {\n    switch (util_1.getInterpolationArgsLength(interpolation)) {\n      case 1:\n        return r3_identifiers_1.Identifiers.styleProp;\n\n      case 3:\n        return r3_identifiers_1.Identifiers.stylePropInterpolate1;\n\n      case 5:\n        return r3_identifiers_1.Identifiers.stylePropInterpolate2;\n\n      case 7:\n        return r3_identifiers_1.Identifiers.stylePropInterpolate3;\n\n      case 9:\n        return r3_identifiers_1.Identifiers.stylePropInterpolate4;\n\n      case 11:\n        return r3_identifiers_1.Identifiers.stylePropInterpolate5;\n\n      case 13:\n        return r3_identifiers_1.Identifiers.stylePropInterpolate6;\n\n      case 15:\n        return r3_identifiers_1.Identifiers.stylePropInterpolate7;\n\n      case 17:\n        return r3_identifiers_1.Identifiers.stylePropInterpolate8;\n\n      default:\n        return r3_identifiers_1.Identifiers.stylePropInterpolateV;\n    }\n  }\n  /**\n   * Checks whether property name is a custom CSS property.\n   * See: https://www.w3.org/TR/css-variables-1\n   */\n\n\n  function isCssCustomProperty(name) {\n    return name.startsWith('--');\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/view/styling_builder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AttributeMarker} from '../../core';\nimport {AST, ASTWithSource, BindingPipe, BindingType, Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport {isEmptyExpression} from '../../template_parser/template_parser';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\n\nimport {hyphenate, parse as parseStyle} from './style_parser';\nimport {ValueConverter} from './template';\nimport {DefinitionMap, getInterpolationArgsLength} from './util';\n\nconst IMPORTANT_FLAG = '!important';\n\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\nexport const MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n\n/**\n * A styling expression summary that is to be processed by the compiler\n */\nexport interface StylingInstruction {\n  reference: o.ExternalReference;\n  /** Calls to individual styling instructions. Used when chaining calls to the same instruction. */\n  calls: StylingInstructionCall[];\n}\n\nexport interface StylingInstructionCall {\n  sourceSpan: ParseSourceSpan|null;\n  supportsInterpolation: boolean;\n  allocateBindingSlots: number;\n  params: ((convertFn: (value: any) => o.Expression | o.Expression[]) => o.Expression[]);\n}\n\n/**\n * An internal record of the input data for a styling binding\n */\ninterface BoundStylingEntry {\n  hasOverrideFlag: boolean;\n  name: string|null;\n  suffix: string|null;\n  sourceSpan: ParseSourceSpan;\n  value: AST;\n}\n\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\nexport class StylingBuilder {\n  /** Whether or not there are any static styling values present */\n  private _hasInitialValues = false;\n  /**\n   *  Whether or not there are any styling bindings present\n   *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n   */\n  public hasBindings = false;\n  public hasBindingsWithPipes = false;\n\n  /** the input for [class] (if it exists) */\n  private _classMapInput: BoundStylingEntry|null = null;\n  /** the input for [style] (if it exists) */\n  private _styleMapInput: BoundStylingEntry|null = null;\n  /** an array of each [style.prop] input */\n  private _singleStyleInputs: BoundStylingEntry[]|null = null;\n  /** an array of each [class.name] input */\n  private _singleClassInputs: BoundStylingEntry[]|null = null;\n  private _lastStylingInput: BoundStylingEntry|null = null;\n  private _firstStylingInput: BoundStylingEntry|null = null;\n\n  // maps are used instead of hash maps because a Map will\n  // retain the ordering of the keys\n\n  /**\n   * Represents the location of each style binding in the template\n   * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n   * that `width=0` and `height=1`)\n   */\n  private _stylesIndex = new Map<string, number>();\n\n  /**\n   * Represents the location of each class binding in the template\n   * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n   * that `big=0` and `hidden=1`)\n   */\n  private _classesIndex = new Map<string, number>();\n  private _initialStyleValues: string[] = [];\n  private _initialClassValues: string[] = [];\n\n  constructor(private _directiveExpr: o.Expression|null) {}\n\n  /**\n   * Registers a given input to the styling builder to be later used when producing AOT code.\n   *\n   * The code below will only accept the input if it is somehow tied to styling (whether it be\n   * style/class bindings or static style/class attributes).\n   */\n  registerBoundInput(input: t.BoundAttribute): boolean {\n    // [attr.style] or [attr.class] are skipped in the code below,\n    // they should not be treated as styling-based bindings since\n    // they are intended to be written directly to the attr and\n    // will therefore skip all style/class resolution that is present\n    // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n    // [class.prop]=\"\". [class]=\"\" assignments\n    let binding: BoundStylingEntry|null = null;\n    let name = input.name;\n    switch (input.type) {\n      case BindingType.Property:\n        binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n        break;\n      case BindingType.Style:\n        binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n        break;\n      case BindingType.Class:\n        binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n        break;\n    }\n    return binding ? true : false;\n  }\n\n  registerInputBasedOnName(name: string, expression: AST, sourceSpan: ParseSourceSpan) {\n    let binding: BoundStylingEntry|null = null;\n    const prefix = name.substring(0, 6);\n    const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n    const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n    if (isStyle || isClass) {\n      const isMapBased = name.charAt(5) !== '.';         // style.prop or class.prop makes this a no\n      const property = name.substr(isMapBased ? 5 : 6);  // the dot explains why there's a +1\n      if (isStyle) {\n        binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n      } else {\n        binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n      }\n    }\n    return binding;\n  }\n\n  registerStyleInput(\n      name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan,\n      suffix?: string|null): BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    // CSS custom properties are case-sensitive so we shouldn't normalize them.\n    // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n    if (!isCssCustomProperty(name)) {\n      name = hyphenate(name);\n    }\n    const {property, hasOverrideFlag, suffix: bindingSuffix} = parseProperty(name);\n    suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n    const entry:\n        BoundStylingEntry = {name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag};\n    if (isMapBased) {\n      this._styleMapInput = entry;\n    } else {\n      (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n      registerIntoMap(this._stylesIndex, property);\n    }\n    this._lastStylingInput = entry;\n    this._firstStylingInput = this._firstStylingInput || entry;\n    this._checkForPipes(value);\n    this.hasBindings = true;\n    return entry;\n  }\n\n  registerClassInput(name: string, isMapBased: boolean, value: AST, sourceSpan: ParseSourceSpan):\n      BoundStylingEntry|null {\n    if (isEmptyExpression(value)) {\n      return null;\n    }\n    const {property, hasOverrideFlag} = parseProperty(name);\n    const entry:\n        BoundStylingEntry = {name: property, value, sourceSpan, hasOverrideFlag, suffix: null};\n    if (isMapBased) {\n      this._classMapInput = entry;\n    } else {\n      (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n      registerIntoMap(this._classesIndex, property);\n    }\n    this._lastStylingInput = entry;\n    this._firstStylingInput = this._firstStylingInput || entry;\n    this._checkForPipes(value);\n    this.hasBindings = true;\n    return entry;\n  }\n\n  private _checkForPipes(value: AST) {\n    if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\n      this.hasBindingsWithPipes = true;\n    }\n  }\n\n  /**\n   * Registers the element's static style string value to the builder.\n   *\n   * @param value the style string (e.g. `width:100px; height:200px;`)\n   */\n  registerStyleAttr(value: string) {\n    this._initialStyleValues = parseStyle(value);\n    this._hasInitialValues = true;\n  }\n\n  /**\n   * Registers the element's static class string value to the builder.\n   *\n   * @param value the className string (e.g. `disabled gold zoom`)\n   */\n  registerClassAttr(value: string) {\n    this._initialClassValues = value.trim().split(/\\s+/g);\n    this._hasInitialValues = true;\n  }\n\n  /**\n   * Appends all styling-related expressions to the provided attrs array.\n   *\n   * @param attrs an existing array where each of the styling expressions\n   * will be inserted into.\n   */\n  populateInitialStylingAttrs(attrs: o.Expression[]): void {\n    // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n    if (this._initialClassValues.length) {\n      attrs.push(o.literal(AttributeMarker.Classes));\n      for (let i = 0; i < this._initialClassValues.length; i++) {\n        attrs.push(o.literal(this._initialClassValues[i]));\n      }\n    }\n\n    // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n    if (this._initialStyleValues.length) {\n      attrs.push(o.literal(AttributeMarker.Styles));\n      for (let i = 0; i < this._initialStyleValues.length; i += 2) {\n        attrs.push(\n            o.literal(this._initialStyleValues[i]), o.literal(this._initialStyleValues[i + 1]));\n      }\n    }\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n   *\n   * The instruction generation code below is used for producing the AOT statement code which is\n   * responsible for registering initial styles (within a directive hostBindings' creation block),\n   * as well as any of the provided attribute values, to the directive host element.\n   */\n  assignHostAttrs(attrs: o.Expression[], definitionMap: DefinitionMap): void {\n    if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n      this.populateInitialStylingAttrs(attrs);\n      definitionMap.set('hostAttrs', o.literalArr(attrs));\n    }\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `classMap`.\n   *\n   * The instruction data will contain all expressions for `classMap` to function\n   * which includes the `[class]` expression params.\n   */\n  buildClassMapInstruction(valueConverter: ValueConverter): StylingInstruction|null {\n    if (this._classMapInput) {\n      return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n    }\n    return null;\n  }\n\n  /**\n   * Builds an instruction with all the expressions and parameters for `styleMap`.\n   *\n   * The instruction data will contain all expressions for `styleMap` to function\n   * which includes the `[style]` expression params.\n   */\n  buildStyleMapInstruction(valueConverter: ValueConverter): StylingInstruction|null {\n    if (this._styleMapInput) {\n      return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n    }\n    return null;\n  }\n\n  private _buildMapBasedInstruction(\n      valueConverter: ValueConverter, isClassBased: boolean,\n      stylingInput: BoundStylingEntry): StylingInstruction {\n    // each styling binding value is stored in the LView\n    // map-based bindings allocate two slots: one for the\n    // previous binding value and another for the previous\n    // className or style attribute value.\n    let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n    // these values must be outside of the update block so that they can\n    // be evaluated (the AST visit call) during creation time so that any\n    // pipes can be picked up in time before the template is built\n    const mapValue = stylingInput.value.visit(valueConverter);\n    let reference: o.ExternalReference;\n    if (mapValue instanceof Interpolation) {\n      totalBindingSlotsRequired += mapValue.expressions.length;\n      reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\n                                 getStyleMapInterpolationExpression(mapValue);\n    } else {\n      reference = isClassBased ? R3.classMap : R3.styleMap;\n    }\n\n    return {\n      reference,\n      calls: [{\n        supportsInterpolation: true,\n        sourceSpan: stylingInput.sourceSpan,\n        allocateBindingSlots: totalBindingSlotsRequired,\n        params: (convertFn: (value: any) => o.Expression|o.Expression[]) => {\n          const convertResult = convertFn(mapValue);\n          const params = Array.isArray(convertResult) ? convertResult : [convertResult];\n          return params;\n        }\n      }]\n    };\n  }\n\n  private _buildSingleInputs(\n      reference: o.ExternalReference, inputs: BoundStylingEntry[], valueConverter: ValueConverter,\n      getInterpolationExpressionFn: ((value: Interpolation) => o.ExternalReference)|null,\n      isClassBased: boolean): StylingInstruction[] {\n    const instructions: StylingInstruction[] = [];\n\n    inputs.forEach(input => {\n      const previousInstruction: StylingInstruction|undefined =\n          instructions[instructions.length - 1];\n      const value = input.value.visit(valueConverter);\n      let referenceForCall = reference;\n\n      // each styling binding value is stored in the LView\n      // but there are two values stored for each binding:\n      //   1) the value itself\n      //   2) an intermediate value (concatenation of style up to this point).\n      //      We need to store the intermediate value so that we don't allocate\n      //      the strings on each CD.\n      let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n      if (value instanceof Interpolation) {\n        totalBindingSlotsRequired += value.expressions.length;\n\n        if (getInterpolationExpressionFn) {\n          referenceForCall = getInterpolationExpressionFn(value);\n        }\n      }\n\n      const call = {\n        sourceSpan: input.sourceSpan,\n        allocateBindingSlots: totalBindingSlotsRequired,\n        supportsInterpolation: !!getInterpolationExpressionFn,\n        params: (convertFn: (value: any) => o.Expression | o.Expression[]) => {\n          // params => stylingProp(propName, value, suffix)\n          const params: o.Expression[] = [];\n          params.push(o.literal(input.name));\n\n          const convertResult = convertFn(value);\n          if (Array.isArray(convertResult)) {\n            params.push(...convertResult);\n          } else {\n            params.push(convertResult);\n          }\n\n          // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n          // if that is detected then we need to pass that in as an optional param.\n          if (!isClassBased && input.suffix !== null) {\n            params.push(o.literal(input.suffix));\n          }\n\n          return params;\n        }\n      };\n\n      // If we ended up generating a call to the same instruction as the previous styling property\n      // we can chain the calls together safely to save some bytes, otherwise we have to generate\n      // a separate instruction call. This is primarily a concern with interpolation instructions\n      // where we may start off with one `reference`, but end up using another based on the\n      // number of interpolations.\n      if (previousInstruction && previousInstruction.reference === referenceForCall) {\n        previousInstruction.calls.push(call);\n      } else {\n        instructions.push({reference: referenceForCall, calls: [call]});\n      }\n    });\n\n    return instructions;\n  }\n\n  private _buildClassInputs(valueConverter: ValueConverter): StylingInstruction[] {\n    if (this._singleClassInputs) {\n      return this._buildSingleInputs(\n          R3.classProp, this._singleClassInputs, valueConverter, null, true);\n    }\n    return [];\n  }\n\n  private _buildStyleInputs(valueConverter: ValueConverter): StylingInstruction[] {\n    if (this._singleStyleInputs) {\n      return this._buildSingleInputs(\n          R3.styleProp, this._singleStyleInputs, valueConverter,\n          getStylePropInterpolationExpression, false);\n    }\n    return [];\n  }\n\n  /**\n   * Constructs all instructions which contain the expressions that will be placed\n   * into the update block of a template function or a directive hostBindings function.\n   */\n  buildUpdateLevelInstructions(valueConverter: ValueConverter) {\n    const instructions: StylingInstruction[] = [];\n    if (this.hasBindings) {\n      const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n      if (styleMapInstruction) {\n        instructions.push(styleMapInstruction);\n      }\n      const classMapInstruction = this.buildClassMapInstruction(valueConverter);\n      if (classMapInstruction) {\n        instructions.push(classMapInstruction);\n      }\n      instructions.push(...this._buildStyleInputs(valueConverter));\n      instructions.push(...this._buildClassInputs(valueConverter));\n    }\n    return instructions;\n  }\n}\n\nfunction registerIntoMap(map: Map<string, number>, key: string) {\n  if (!map.has(key)) {\n    map.set(key, map.size);\n  }\n}\n\nexport function parseProperty(name: string):\n    {property: string, suffix: string|null, hasOverrideFlag: boolean} {\n  let hasOverrideFlag = false;\n  const overrideIndex = name.indexOf(IMPORTANT_FLAG);\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n    hasOverrideFlag = true;\n  }\n\n  let suffix: string|null = null;\n  let property = name;\n  const unitIndex = name.lastIndexOf('.');\n  if (unitIndex > 0) {\n    suffix = name.substr(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n\n  return {property, suffix, hasOverrideFlag};\n}\n\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\nfunction getClassMapInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.classMap;\n    case 3:\n      return R3.classMapInterpolate1;\n    case 5:\n      return R3.classMapInterpolate2;\n    case 7:\n      return R3.classMapInterpolate3;\n    case 9:\n      return R3.classMapInterpolate4;\n    case 11:\n      return R3.classMapInterpolate5;\n    case 13:\n      return R3.classMapInterpolate6;\n    case 15:\n      return R3.classMapInterpolate7;\n    case 17:\n      return R3.classMapInterpolate8;\n    default:\n      return R3.classMapInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\nfunction getStyleMapInterpolationExpression(interpolation: Interpolation): o.ExternalReference {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.styleMap;\n    case 3:\n      return R3.styleMapInterpolate1;\n    case 5:\n      return R3.styleMapInterpolate2;\n    case 7:\n      return R3.styleMapInterpolate3;\n    case 9:\n      return R3.styleMapInterpolate4;\n    case 11:\n      return R3.styleMapInterpolate5;\n    case 13:\n      return R3.styleMapInterpolate6;\n    case 15:\n      return R3.styleMapInterpolate7;\n    case 17:\n      return R3.styleMapInterpolate8;\n    default:\n      return R3.styleMapInterpolateV;\n  }\n}\n\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\nfunction getStylePropInterpolationExpression(interpolation: Interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return R3.styleProp;\n    case 3:\n      return R3.stylePropInterpolate1;\n    case 5:\n      return R3.stylePropInterpolate2;\n    case 7:\n      return R3.stylePropInterpolate3;\n    case 9:\n      return R3.stylePropInterpolate4;\n    case 11:\n      return R3.stylePropInterpolate5;\n    case 13:\n      return R3.stylePropInterpolate6;\n    case 15:\n      return R3.stylePropInterpolate7;\n    case 17:\n      return R3.stylePropInterpolate8;\n    default:\n      return R3.stylePropInterpolateV;\n  }\n}\n\n/**\n * Checks whether property name is a custom CSS property.\n * See: https://www.w3.org/TR/css-variables-1\n */\nfunction isCssCustomProperty(name: string): boolean {\n  return name.startsWith('--');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}