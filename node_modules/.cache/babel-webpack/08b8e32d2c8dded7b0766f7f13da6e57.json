{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/analyze_entry_points\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/execution/tasks/queues/parallel_task_queue\", \"@angular/compiler-cli/ngcc/src/execution/tasks/queues/serial_task_queue\", \"@angular/compiler-cli/ngcc/src/execution/tasks/utils\", \"@angular/compiler-cli/ngcc/src/packages/build_marker\", \"@angular/compiler-cli/ngcc/src/packages/entry_point\", \"@angular/compiler-cli/ngcc/src/writing/cleaning/package_cleaner\", \"@angular/compiler-cli/ngcc/src/execution/tasks/api\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getAnalyzeEntryPointsFn = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var parallel_task_queue_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/queues/parallel_task_queue\");\n\n  var serial_task_queue_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/queues/serial_task_queue\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/utils\");\n\n  var build_marker_1 = require(\"@angular/compiler-cli/ngcc/src/packages/build_marker\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point\");\n\n  var package_cleaner_1 = require(\"@angular/compiler-cli/ngcc/src/writing/cleaning/package_cleaner\");\n\n  var api_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/api\");\n  /**\n   * Create the function for performing the analysis of the entry-points.\n   */\n\n\n  function getAnalyzeEntryPointsFn(logger, finder, fileSystem, supportedPropertiesToConsider, typingsOnly, compileAllFormats, propertiesToConsider, inParallel) {\n    return function () {\n      var e_1, _a, e_2, _b;\n\n      logger.debug('Analyzing entry-points...');\n      var startTime = Date.now();\n      var entryPointInfo = finder.findEntryPoints();\n      var cleaned = package_cleaner_1.cleanOutdatedPackages(fileSystem, entryPointInfo.entryPoints);\n\n      if (cleaned) {\n        // If we had to clean up one or more packages then we must read in the entry-points again.\n        entryPointInfo = finder.findEntryPoints();\n      }\n\n      var entryPoints = entryPointInfo.entryPoints,\n          invalidEntryPoints = entryPointInfo.invalidEntryPoints,\n          graph = entryPointInfo.graph;\n      logInvalidEntryPoints(logger, invalidEntryPoints);\n      var unprocessableEntryPointPaths = []; // The tasks are partially ordered by virtue of the entry-points being partially ordered too.\n\n      var tasks = [];\n\n      try {\n        for (var entryPoints_1 = tslib_1.__values(entryPoints), entryPoints_1_1 = entryPoints_1.next(); !entryPoints_1_1.done; entryPoints_1_1 = entryPoints_1.next()) {\n          var entryPoint = entryPoints_1_1.value;\n          var packageJson = entryPoint.packageJson;\n\n          var _c = getPropertiesToProcess(packageJson, supportedPropertiesToConsider, compileAllFormats, typingsOnly),\n              propertiesToProcess = _c.propertiesToProcess,\n              equivalentPropertiesMap = _c.equivalentPropertiesMap;\n\n          if (propertiesToProcess.length === 0) {\n            // This entry-point is unprocessable (i.e. there is no format property that is of interest\n            // and can be processed). This will result in an error, but continue looping over\n            // entry-points in order to collect all unprocessable ones and display a more informative\n            // error.\n            unprocessableEntryPointPaths.push(entryPoint.path);\n            continue;\n          }\n\n          var hasProcessedTypings = build_marker_1.hasBeenProcessed(packageJson, 'typings');\n\n          if (hasProcessedTypings && typingsOnly) {\n            // Typings for this entry-point have already been processed and we're in typings-only mode,\n            // so no task has to be created for this entry-point.\n            logger.debug(\"Skipping \" + entryPoint.name + \" : typings have already been processed.\");\n            continue;\n          }\n\n          var processDts = hasProcessedTypings ? api_1.DtsProcessing.No : typingsOnly ? api_1.DtsProcessing.Only : api_1.DtsProcessing.Yes;\n\n          try {\n            for (var propertiesToProcess_1 = (e_2 = void 0, tslib_1.__values(propertiesToProcess)), propertiesToProcess_1_1 = propertiesToProcess_1.next(); !propertiesToProcess_1_1.done; propertiesToProcess_1_1 = propertiesToProcess_1.next()) {\n              var formatProperty = propertiesToProcess_1_1.value;\n\n              if (build_marker_1.hasBeenProcessed(entryPoint.packageJson, formatProperty)) {\n                // The format-path which the property maps to is already processed - nothing to do.\n                logger.debug(\"Skipping \" + entryPoint.name + \" : \" + formatProperty + \" (already compiled).\");\n                continue;\n              }\n\n              var formatPropertiesToMarkAsProcessed = equivalentPropertiesMap.get(formatProperty);\n              tasks.push({\n                entryPoint: entryPoint,\n                formatProperty: formatProperty,\n                formatPropertiesToMarkAsProcessed: formatPropertiesToMarkAsProcessed,\n                processDts: processDts\n              }); // Only process typings for the first property (if not already processed).\n\n              processDts = api_1.DtsProcessing.No;\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (propertiesToProcess_1_1 && !propertiesToProcess_1_1.done && (_b = propertiesToProcess_1.return)) _b.call(propertiesToProcess_1);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (entryPoints_1_1 && !entryPoints_1_1.done && (_a = entryPoints_1.return)) _a.call(entryPoints_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Check for entry-points for which we could not process any format at all.\n\n\n      if (unprocessableEntryPointPaths.length > 0) {\n        throw new Error('Unable to process any formats for the following entry-points (tried ' + (propertiesToConsider.join(', ') + \"): \") + unprocessableEntryPointPaths.map(function (path) {\n          return \"\\n  - \" + path;\n        }).join(''));\n      }\n\n      var duration = Math.round((Date.now() - startTime) / 100) / 10;\n      logger.debug(\"Analyzed \" + entryPoints.length + \" entry-points in \" + duration + \"s. \" + (\"(Total tasks: \" + tasks.length + \")\"));\n      return getTaskQueue(logger, inParallel, tasks, graph);\n    };\n  }\n\n  exports.getAnalyzeEntryPointsFn = getAnalyzeEntryPointsFn;\n\n  function logInvalidEntryPoints(logger, invalidEntryPoints) {\n    invalidEntryPoints.forEach(function (invalidEntryPoint) {\n      logger.debug(\"Invalid entry-point \" + invalidEntryPoint.entryPoint.path + \".\", \"It is missing required dependencies:\\n\" + invalidEntryPoint.missingDependencies.map(function (dep) {\n        return \" - \" + dep;\n      }).join('\\n'));\n    });\n  }\n  /**\n   * This function computes and returns the following:\n   * - `propertiesToProcess`: An (ordered) list of properties that exist and need to be processed,\n   *   based on the provided `propertiesToConsider`, the properties in `package.json` and their\n   *   corresponding format-paths. NOTE: Only one property per format-path needs to be processed.\n   * - `equivalentPropertiesMap`: A mapping from each property in `propertiesToProcess` to the list of\n   *   other format properties in `package.json` that need to be marked as processed as soon as the\n   *   former has been processed.\n   */\n\n\n  function getPropertiesToProcess(packageJson, propertiesToConsider, compileAllFormats, typingsOnly) {\n    var e_3, _a, e_4, _b, e_5, _c;\n\n    var formatPathsToConsider = new Set();\n    var propertiesToProcess = [];\n\n    try {\n      for (var propertiesToConsider_1 = tslib_1.__values(propertiesToConsider), propertiesToConsider_1_1 = propertiesToConsider_1.next(); !propertiesToConsider_1_1.done; propertiesToConsider_1_1 = propertiesToConsider_1.next()) {\n        var prop = propertiesToConsider_1_1.value;\n        var formatPath = packageJson[prop]; // Ignore properties that are not defined in `package.json`.\n\n        if (typeof formatPath !== 'string') continue; // Ignore properties that map to the same format-path as a preceding property.\n\n        if (formatPathsToConsider.has(formatPath)) continue; // Process this property, because it is the first one to map to this format-path.\n\n        formatPathsToConsider.add(formatPath);\n        propertiesToProcess.push(prop); // If we only need one format processed, there is no need to process any more properties.\n\n        if (!compileAllFormats) break;\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (propertiesToConsider_1_1 && !propertiesToConsider_1_1.done && (_a = propertiesToConsider_1.return)) _a.call(propertiesToConsider_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n\n    var formatPathToProperties = {};\n\n    try {\n      for (var SUPPORTED_FORMAT_PROPERTIES_1 = tslib_1.__values(entry_point_1.SUPPORTED_FORMAT_PROPERTIES), SUPPORTED_FORMAT_PROPERTIES_1_1 = SUPPORTED_FORMAT_PROPERTIES_1.next(); !SUPPORTED_FORMAT_PROPERTIES_1_1.done; SUPPORTED_FORMAT_PROPERTIES_1_1 = SUPPORTED_FORMAT_PROPERTIES_1.next()) {\n        var prop = SUPPORTED_FORMAT_PROPERTIES_1_1.value;\n        var formatPath = packageJson[prop]; // Ignore properties that are not defined in `package.json`.\n\n        if (typeof formatPath !== 'string') continue; // Ignore properties that do not map to a format-path that will be considered.\n\n        if (!formatPathsToConsider.has(formatPath)) continue; // Add this property to the map.\n\n        var list = formatPathToProperties[formatPath] || (formatPathToProperties[formatPath] = []);\n        list.push(prop);\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (SUPPORTED_FORMAT_PROPERTIES_1_1 && !SUPPORTED_FORMAT_PROPERTIES_1_1.done && (_b = SUPPORTED_FORMAT_PROPERTIES_1.return)) _b.call(SUPPORTED_FORMAT_PROPERTIES_1);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n\n    var equivalentPropertiesMap = new Map();\n\n    try {\n      for (var propertiesToConsider_2 = tslib_1.__values(propertiesToConsider), propertiesToConsider_2_1 = propertiesToConsider_2.next(); !propertiesToConsider_2_1.done; propertiesToConsider_2_1 = propertiesToConsider_2.next()) {\n        var prop = propertiesToConsider_2_1.value;\n        var formatPath = packageJson[prop]; // If we are only processing typings then there should be no format properties to mark\n\n        var equivalentProperties = typingsOnly ? [] : formatPathToProperties[formatPath];\n        equivalentPropertiesMap.set(prop, equivalentProperties);\n      }\n    } catch (e_5_1) {\n      e_5 = {\n        error: e_5_1\n      };\n    } finally {\n      try {\n        if (propertiesToConsider_2_1 && !propertiesToConsider_2_1.done && (_c = propertiesToConsider_2.return)) _c.call(propertiesToConsider_2);\n      } finally {\n        if (e_5) throw e_5.error;\n      }\n    }\n\n    return {\n      propertiesToProcess: propertiesToProcess,\n      equivalentPropertiesMap: equivalentPropertiesMap\n    };\n  }\n\n  function getTaskQueue(logger, inParallel, tasks, graph) {\n    var dependencies = utils_1.computeTaskDependencies(tasks, graph);\n    return inParallel ? new parallel_task_queue_1.ParallelTaskQueue(logger, tasks, dependencies) : new serial_task_queue_1.SerialTaskQueue(logger, tasks, dependencies);\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/execution/analyze_entry_points.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {DepGraph} from 'dependency-graph';\n\nimport {FileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {InvalidEntryPoint} from '../dependencies/dependency_resolver';\nimport {EntryPointFinder} from '../entry_point_finder/interface';\nimport {ParallelTaskQueue} from '../execution/tasks/queues/parallel_task_queue';\nimport {SerialTaskQueue} from '../execution/tasks/queues/serial_task_queue';\nimport {computeTaskDependencies} from '../execution/tasks/utils';\nimport {hasBeenProcessed} from '../packages/build_marker';\nimport {EntryPoint, EntryPointJsonProperty, EntryPointPackageJson, SUPPORTED_FORMAT_PROPERTIES} from '../packages/entry_point';\nimport {cleanOutdatedPackages} from '../writing/cleaning/package_cleaner';\n\nimport {AnalyzeEntryPointsFn} from './api';\nimport {DtsProcessing, PartiallyOrderedTasks, TaskQueue} from './tasks/api';\n\n/**\n * Create the function for performing the analysis of the entry-points.\n */\nexport function getAnalyzeEntryPointsFn(\n    logger: Logger, finder: EntryPointFinder, fileSystem: FileSystem,\n    supportedPropertiesToConsider: EntryPointJsonProperty[], typingsOnly: boolean,\n    compileAllFormats: boolean, propertiesToConsider: string[],\n    inParallel: boolean): AnalyzeEntryPointsFn {\n  return () => {\n    logger.debug('Analyzing entry-points...');\n    const startTime = Date.now();\n\n    let entryPointInfo = finder.findEntryPoints();\n    const cleaned = cleanOutdatedPackages(fileSystem, entryPointInfo.entryPoints);\n    if (cleaned) {\n      // If we had to clean up one or more packages then we must read in the entry-points again.\n      entryPointInfo = finder.findEntryPoints();\n    }\n\n    const {entryPoints, invalidEntryPoints, graph} = entryPointInfo;\n    logInvalidEntryPoints(logger, invalidEntryPoints);\n\n    const unprocessableEntryPointPaths: string[] = [];\n    // The tasks are partially ordered by virtue of the entry-points being partially ordered too.\n    const tasks: PartiallyOrderedTasks = [] as any;\n\n    for (const entryPoint of entryPoints) {\n      const packageJson = entryPoint.packageJson;\n      const {propertiesToProcess, equivalentPropertiesMap} = getPropertiesToProcess(\n          packageJson, supportedPropertiesToConsider, compileAllFormats, typingsOnly);\n\n      if (propertiesToProcess.length === 0) {\n        // This entry-point is unprocessable (i.e. there is no format property that is of interest\n        // and can be processed). This will result in an error, but continue looping over\n        // entry-points in order to collect all unprocessable ones and display a more informative\n        // error.\n        unprocessableEntryPointPaths.push(entryPoint.path);\n        continue;\n      }\n\n      const hasProcessedTypings = hasBeenProcessed(packageJson, 'typings');\n      if (hasProcessedTypings && typingsOnly) {\n        // Typings for this entry-point have already been processed and we're in typings-only mode,\n        // so no task has to be created for this entry-point.\n        logger.debug(`Skipping ${entryPoint.name} : typings have already been processed.`);\n        continue;\n      }\n      let processDts = hasProcessedTypings ? DtsProcessing.No :\n                                             typingsOnly ? DtsProcessing.Only : DtsProcessing.Yes;\n\n      for (const formatProperty of propertiesToProcess) {\n        if (hasBeenProcessed(entryPoint.packageJson, formatProperty)) {\n          // The format-path which the property maps to is already processed - nothing to do.\n          logger.debug(`Skipping ${entryPoint.name} : ${formatProperty} (already compiled).`);\n          continue;\n        }\n\n        const formatPropertiesToMarkAsProcessed = equivalentPropertiesMap.get(formatProperty)!;\n        tasks.push({entryPoint, formatProperty, formatPropertiesToMarkAsProcessed, processDts});\n\n        // Only process typings for the first property (if not already processed).\n        processDts = DtsProcessing.No;\n      }\n    }\n\n    // Check for entry-points for which we could not process any format at all.\n    if (unprocessableEntryPointPaths.length > 0) {\n      throw new Error(\n          'Unable to process any formats for the following entry-points (tried ' +\n          `${propertiesToConsider.join(', ')}): ` +\n          unprocessableEntryPointPaths.map(path => `\\n  - ${path}`).join(''));\n    }\n\n    const duration = Math.round((Date.now() - startTime) / 100) / 10;\n    logger.debug(\n        `Analyzed ${entryPoints.length} entry-points in ${duration}s. ` +\n        `(Total tasks: ${tasks.length})`);\n\n    return getTaskQueue(logger, inParallel, tasks, graph);\n  };\n}\n\nfunction logInvalidEntryPoints(logger: Logger, invalidEntryPoints: InvalidEntryPoint[]): void {\n  invalidEntryPoints.forEach(invalidEntryPoint => {\n    logger.debug(\n        `Invalid entry-point ${invalidEntryPoint.entryPoint.path}.`,\n        `It is missing required dependencies:\\n` +\n            invalidEntryPoint.missingDependencies.map(dep => ` - ${dep}`).join('\\n'));\n  });\n}\n\n/**\n * This function computes and returns the following:\n * - `propertiesToProcess`: An (ordered) list of properties that exist and need to be processed,\n *   based on the provided `propertiesToConsider`, the properties in `package.json` and their\n *   corresponding format-paths. NOTE: Only one property per format-path needs to be processed.\n * - `equivalentPropertiesMap`: A mapping from each property in `propertiesToProcess` to the list of\n *   other format properties in `package.json` that need to be marked as processed as soon as the\n *   former has been processed.\n */\nfunction getPropertiesToProcess(\n    packageJson: EntryPointPackageJson, propertiesToConsider: EntryPointJsonProperty[],\n    compileAllFormats: boolean, typingsOnly: boolean): {\n  propertiesToProcess: EntryPointJsonProperty[];\n  equivalentPropertiesMap: Map<EntryPointJsonProperty, EntryPointJsonProperty[]>;\n} {\n  const formatPathsToConsider = new Set<string>();\n\n  const propertiesToProcess: EntryPointJsonProperty[] = [];\n  for (const prop of propertiesToConsider) {\n    const formatPath = packageJson[prop];\n\n    // Ignore properties that are not defined in `package.json`.\n    if (typeof formatPath !== 'string') continue;\n\n    // Ignore properties that map to the same format-path as a preceding property.\n    if (formatPathsToConsider.has(formatPath)) continue;\n\n    // Process this property, because it is the first one to map to this format-path.\n    formatPathsToConsider.add(formatPath);\n    propertiesToProcess.push(prop);\n\n    // If we only need one format processed, there is no need to process any more properties.\n    if (!compileAllFormats) break;\n  }\n\n  const formatPathToProperties: {[formatPath: string]: EntryPointJsonProperty[]} = {};\n  for (const prop of SUPPORTED_FORMAT_PROPERTIES) {\n    const formatPath = packageJson[prop];\n\n    // Ignore properties that are not defined in `package.json`.\n    if (typeof formatPath !== 'string') continue;\n\n    // Ignore properties that do not map to a format-path that will be considered.\n    if (!formatPathsToConsider.has(formatPath)) continue;\n\n    // Add this property to the map.\n    const list = formatPathToProperties[formatPath] || (formatPathToProperties[formatPath] = []);\n    list.push(prop);\n  }\n\n  const equivalentPropertiesMap = new Map<EntryPointJsonProperty, EntryPointJsonProperty[]>();\n  for (const prop of propertiesToConsider) {\n    const formatPath = packageJson[prop]!;\n    // If we are only processing typings then there should be no format properties to mark\n    const equivalentProperties = typingsOnly ? [] : formatPathToProperties[formatPath];\n    equivalentPropertiesMap.set(prop, equivalentProperties);\n  }\n\n  return {propertiesToProcess, equivalentPropertiesMap};\n}\n\nfunction getTaskQueue(\n    logger: Logger, inParallel: boolean, tasks: PartiallyOrderedTasks,\n    graph: DepGraph<EntryPoint>): TaskQueue {\n  const dependencies = computeTaskDependencies(tasks, graph);\n  return inParallel ? new ParallelTaskQueue(logger, tasks, dependencies) :\n                      new SerialTaskQueue(logger, tasks, dependencies);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}