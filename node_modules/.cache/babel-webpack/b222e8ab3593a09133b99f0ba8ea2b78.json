{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/ast_path\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.AstPath = void 0;\n  /**\n   * A path is an ordered set of elements. Typically a path is to  a\n   * particular offset in a source file. The head of the list is the top\n   * most node. The tail is the node that contains the offset directly.\n   *\n   * For example, the expression `a + b + c` might have an ast that looks\n   * like:\n   *     +\n   *    / \\\n   *   a   +\n   *      / \\\n   *     b   c\n   *\n   * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n   * 'c' at 9-10]` and the path the node at offset 1 would be\n   * `['+' at 1-10, 'a' at 1-2]`.\n   */\n\n  var AstPath =\n  /** @class */\n  function () {\n    function AstPath(path, position) {\n      if (position === void 0) {\n        position = -1;\n      }\n\n      this.path = path;\n      this.position = position;\n    }\n\n    Object.defineProperty(AstPath.prototype, \"empty\", {\n      get: function get() {\n        return !this.path || !this.path.length;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AstPath.prototype, \"head\", {\n      get: function get() {\n        return this.path[0];\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(AstPath.prototype, \"tail\", {\n      get: function get() {\n        return this.path[this.path.length - 1];\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    AstPath.prototype.parentOf = function (node) {\n      return node && this.path[this.path.indexOf(node) - 1];\n    };\n\n    AstPath.prototype.childOf = function (node) {\n      return this.path[this.path.indexOf(node) + 1];\n    };\n\n    AstPath.prototype.first = function (ctor) {\n      for (var i = this.path.length - 1; i >= 0; i--) {\n        var item = this.path[i];\n        if (item instanceof ctor) return item;\n      }\n    };\n\n    AstPath.prototype.push = function (node) {\n      this.path.push(node);\n    };\n\n    AstPath.prototype.pop = function () {\n      return this.path.pop();\n    };\n\n    return AstPath;\n  }();\n\n  exports.AstPath = AstPath;\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/ast_path.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;AAEH;;;;;;;;;;;;;;;;AAgBG;;AACH,MAAA,OAAA;AAAA;AAAA,cAAA;AACE,aAAA,OAAA,CAAoB,IAApB,EAAsC,QAAtC,EAA2D;AAArB,UAAA,QAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,QAAA,GAAA,CAAoB,CAApB;AAAqB;;AAAvC,WAAA,IAAA,GAAA,IAAA;AAAkB,WAAA,QAAA,GAAA,QAAA;AAAyB;;AAE/D,IAAA,MAAA,CAAA,cAAA,CAAI,OAAA,CAAA,SAAJ,EAAI,OAAJ,EAAS;WAAT,eAAA;AACE,eAAO,CAAC,KAAK,IAAN,IAAc,CAAC,KAAK,IAAL,CAAU,MAAhC;AACD,OAFQ;uBAAA;;AAAA,KAAT;AAGA,IAAA,MAAA,CAAA,cAAA,CAAI,OAAA,CAAA,SAAJ,EAAI,MAAJ,EAAQ;WAAR,eAAA;AACE,eAAO,KAAK,IAAL,CAAU,CAAV,CAAP;AACD,OAFO;uBAAA;;AAAA,KAAR;AAGA,IAAA,MAAA,CAAA,cAAA,CAAI,OAAA,CAAA,SAAJ,EAAI,MAAJ,EAAQ;WAAR,eAAA;AACE,eAAO,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,MAAV,GAAmB,CAA7B,CAAP;AACD,OAFO;uBAAA;;AAAA,KAAR;;AAIA,IAAA,OAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,IAAT,EAA0B;AACxB,aAAO,IAAI,IAAI,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,OAAV,CAAkB,IAAlB,IAA0B,CAApC,CAAf;AACD,KAFD;;AAGA,IAAA,OAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,IAAR,EAAe;AACb,aAAO,KAAK,IAAL,CAAU,KAAK,IAAL,CAAU,OAAV,CAAkB,IAAlB,IAA0B,CAApC,CAAP;AACD,KAFD;;AAIA,IAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAmB,IAAnB,EAAiD;AAC/C,WAAK,IAAI,CAAC,GAAG,KAAK,IAAL,CAAU,MAAV,GAAmB,CAAhC,EAAmC,CAAC,IAAI,CAAxC,EAA2C,CAAC,EAA5C,EAAgD;AAC9C,YAAI,IAAI,GAAG,KAAK,IAAL,CAAU,CAAV,CAAX;AACA,YAAI,IAAI,YAAY,IAApB,EAA0B,OAAU,IAAV;AAC3B;AACF,KALD;;AAOA,IAAA,OAAA,CAAA,SAAA,CAAA,IAAA,GAAA,UAAK,IAAL,EAAY;AACV,WAAK,IAAL,CAAU,IAAV,CAAe,IAAf;AACD,KAFD;;AAIA,IAAA,OAAA,CAAA,SAAA,CAAA,GAAA,GAAA,YAAA;AACE,aAAO,KAAK,IAAL,CAAU,GAAV,EAAP;AACD,KAFD;;AAGF,WAAA,OAAA;AAAC,GAlCD,EAAA;;AAAa,EAAA,OAAA,CAAA,OAAA,GAAA,OAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expression `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\nexport class AstPath<T> {\n  constructor(private path: T[], public position: number = -1) {}\n\n  get empty(): boolean {\n    return !this.path || !this.path.length;\n  }\n  get head(): T|undefined {\n    return this.path[0];\n  }\n  get tail(): T|undefined {\n    return this.path[this.path.length - 1];\n  }\n\n  parentOf(node: T|undefined): T|undefined {\n    return node && this.path[this.path.indexOf(node) - 1];\n  }\n  childOf(node: T): T|undefined {\n    return this.path[this.path.indexOf(node) + 1];\n  }\n\n  first<N extends T>(ctor: {new(...args: any[]): N}): N|undefined {\n    for (let i = this.path.length - 1; i >= 0; i--) {\n      let item = this.path[i];\n      if (item instanceof ctor) return <N>item;\n    }\n  }\n\n  push(node: T) {\n    this.path.push(node);\n  }\n\n  pop(): T {\n    return this.path.pop()!;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}