{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar percent = require('./percent');\n\nvar dataProperties = require('./data-properties');\n\nvar _require = require('./coverage-summary'),\n    CoverageSummary = _require.CoverageSummary; // returns a data object that represents empty coverage\n\n\nfunction emptyCoverage(filePath) {\n  return {\n    path: filePath,\n    statementMap: {},\n    fnMap: {},\n    branchMap: {},\n    s: {},\n    f: {},\n    b: {}\n  };\n} // asserts that a data object \"looks like\" a coverage object\n\n\nfunction assertValidObject(obj) {\n  var valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;\n\n  if (!valid) {\n    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\n\n\nvar FileCoverage = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n   * and empty coverage object with the specified file path or a data object that\n   * has all the required properties for a file coverage object.\n   */\n  function FileCoverage(pathOrObj) {\n    _classCallCheck(this, FileCoverage);\n\n    if (!pathOrObj) {\n      throw new Error('Coverage must be initialized with a path or an object');\n    }\n\n    if (typeof pathOrObj === 'string') {\n      this.data = emptyCoverage(pathOrObj);\n    } else if (pathOrObj instanceof FileCoverage) {\n      this.data = pathOrObj.data;\n    } else if (typeof pathOrObj === 'object') {\n      this.data = pathOrObj;\n    } else {\n      throw new Error('Invalid argument to coverage constructor');\n    }\n\n    assertValidObject(this.data);\n  }\n  /**\n   * returns computed line coverage from statement coverage.\n   * This is a map of hits keyed by line number in the source.\n   */\n\n\n  _createClass(FileCoverage, [{\n    key: \"getLineCoverage\",\n    value: function getLineCoverage() {\n      var statementMap = this.data.statementMap;\n      var statements = this.data.s;\n      var lineMap = Object.create(null);\n      Object.entries(statements).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            st = _ref2[0],\n            count = _ref2[1];\n\n        /* istanbul ignore if: is this even possible? */\n        if (!statementMap[st]) {\n          return;\n        }\n\n        var line = statementMap[st].start.line;\n        var prevVal = lineMap[line];\n\n        if (prevVal === undefined || prevVal < count) {\n          lineMap[line] = count;\n        }\n      });\n      return lineMap;\n    }\n    /**\n     * returns an array of uncovered line numbers.\n     * @returns {Array} an array of line numbers for which no hits have been\n     *  collected.\n     */\n\n  }, {\n    key: \"getUncoveredLines\",\n    value: function getUncoveredLines() {\n      var lc = this.getLineCoverage();\n      var ret = [];\n      Object.entries(lc).forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            l = _ref4[0],\n            hits = _ref4[1];\n\n        if (hits === 0) {\n          ret.push(l);\n        }\n      });\n      return ret;\n    }\n    /**\n     * returns a map of branch coverage by source line number.\n     * @returns {Object} an object keyed by line number. Each object\n     * has a `covered`, `total` and `coverage` (percentage) property.\n     */\n\n  }, {\n    key: \"getBranchCoverageByLine\",\n    value: function getBranchCoverageByLine() {\n      var branchMap = this.branchMap;\n      var branches = this.b;\n      var ret = {};\n      Object.entries(branchMap).forEach(function (_ref5) {\n        var _ret$line;\n\n        var _ref6 = _slicedToArray(_ref5, 2),\n            k = _ref6[0],\n            map = _ref6[1];\n\n        var line = map.line || map.loc.start.line;\n        var branchData = branches[k];\n        ret[line] = ret[line] || [];\n\n        (_ret$line = ret[line]).push.apply(_ret$line, _toConsumableArray(branchData));\n      });\n      Object.entries(ret).forEach(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            k = _ref8[0],\n            dataArray = _ref8[1];\n\n        var covered = dataArray.filter(function (item) {\n          return item > 0;\n        });\n        var coverage = covered.length / dataArray.length * 100;\n        ret[k] = {\n          covered: covered.length,\n          total: dataArray.length,\n          coverage: coverage\n        };\n      });\n      return ret;\n    }\n    /**\n     * return a JSON-serializable POJO for this file coverage object\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.data;\n    }\n    /**\n     * merges a second coverage object into this one, updating hit counts\n     * @param {FileCoverage} other - the coverage object to be merged into this one.\n     *  Note that the other object should have the same structure as this one (same file).\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      var _this = this;\n\n      if (other.all === true) {\n        return;\n      }\n\n      if (this.all === true) {\n        this.data = other.data;\n        return;\n      }\n\n      Object.entries(other.s).forEach(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            k = _ref10[0],\n            v = _ref10[1];\n\n        _this.data.s[k] += v;\n      });\n      Object.entries(other.f).forEach(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n            k = _ref12[0],\n            v = _ref12[1];\n\n        _this.data.f[k] += v;\n      });\n      Object.entries(other.b).forEach(function (_ref13) {\n        var _ref14 = _slicedToArray(_ref13, 2),\n            k = _ref14[0],\n            v = _ref14[1];\n\n        var i;\n        var retArray = _this.data.b[k];\n        /* istanbul ignore if: is this even possible? */\n\n        if (!retArray) {\n          _this.data.b[k] = v;\n          return;\n        }\n\n        for (i = 0; i < retArray.length; i += 1) {\n          retArray[i] += v[i];\n        }\n      });\n    }\n  }, {\n    key: \"computeSimpleTotals\",\n    value: function computeSimpleTotals(property) {\n      var stats = this[property];\n\n      if (typeof stats === 'function') {\n        stats = stats.call(this);\n      }\n\n      var ret = {\n        total: Object.keys(stats).length,\n        covered: Object.values(stats).filter(function (v) {\n          return !!v;\n        }).length,\n        skipped: 0\n      };\n      ret.pct = percent(ret.covered, ret.total);\n      return ret;\n    }\n  }, {\n    key: \"computeBranchTotals\",\n    value: function computeBranchTotals() {\n      var stats = this.b;\n      var ret = {\n        total: 0,\n        covered: 0,\n        skipped: 0\n      };\n      Object.values(stats).forEach(function (branches) {\n        ret.covered += branches.filter(function (hits) {\n          return hits > 0;\n        }).length;\n        ret.total += branches.length;\n      });\n      ret.pct = percent(ret.covered, ret.total);\n      return ret;\n    }\n    /**\n     * resets hit counts for all statements, functions and branches\n     * in this coverage object resulting in zero coverage.\n     */\n\n  }, {\n    key: \"resetHits\",\n    value: function resetHits() {\n      var statements = this.s;\n      var functions = this.f;\n      var branches = this.b;\n      Object.keys(statements).forEach(function (s) {\n        statements[s] = 0;\n      });\n      Object.keys(functions).forEach(function (f) {\n        functions[f] = 0;\n      });\n      Object.keys(branches).forEach(function (b) {\n        branches[b].fill(0);\n      });\n    }\n    /**\n     * returns a CoverageSummary for this file coverage object\n     * @returns {CoverageSummary}\n     */\n\n  }, {\n    key: \"toSummary\",\n    value: function toSummary() {\n      var ret = {};\n      ret.lines = this.computeSimpleTotals('getLineCoverage');\n      ret.functions = this.computeSimpleTotals('f', 'fnMap');\n      ret.statements = this.computeSimpleTotals('s', 'statementMap');\n      ret.branches = this.computeBranchTotals();\n      return new CoverageSummary(ret);\n    }\n  }]);\n\n  return FileCoverage;\n}(); // expose coverage data attributes\n\n\ndataProperties(FileCoverage, ['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b', 'all']);\nmodule.exports = {\n  FileCoverage: FileCoverage\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/istanbul-lib-coverage/lib/file-coverage.js"],"names":["percent","require","dataProperties","CoverageSummary","emptyCoverage","filePath","path","statementMap","fnMap","branchMap","s","f","b","assertValidObject","obj","valid","Error","Object","keys","join","FileCoverage","pathOrObj","data","statements","lineMap","create","entries","forEach","st","count","line","start","prevVal","undefined","lc","getLineCoverage","ret","l","hits","push","branches","k","map","loc","branchData","dataArray","covered","filter","item","coverage","length","total","other","all","v","i","retArray","property","stats","call","values","skipped","pct","functions","fill","lines","computeSimpleTotals","computeBranchTotals","module","exports"],"mappings":"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","sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst percent = require('./percent');\nconst dataProperties = require('./data-properties');\nconst { CoverageSummary } = require('./coverage-summary');\n\n// returns a data object that represents empty coverage\nfunction emptyCoverage(filePath) {\n    return {\n        path: filePath,\n        statementMap: {},\n        fnMap: {},\n        branchMap: {},\n        s: {},\n        f: {},\n        b: {}\n    };\n}\n\n// asserts that a data object \"looks like\" a coverage object\nfunction assertValidObject(obj) {\n    const valid =\n        obj &&\n        obj.path &&\n        obj.statementMap &&\n        obj.fnMap &&\n        obj.branchMap &&\n        obj.s &&\n        obj.f &&\n        obj.b;\n    if (!valid) {\n        throw new Error(\n            'Invalid file coverage object, missing keys, found:' +\n                Object.keys(obj).join(',')\n        );\n    }\n}\n\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\nclass FileCoverage {\n    /**\n     * @constructor\n     * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n     * and empty coverage object with the specified file path or a data object that\n     * has all the required properties for a file coverage object.\n     */\n    constructor(pathOrObj) {\n        if (!pathOrObj) {\n            throw new Error(\n                'Coverage must be initialized with a path or an object'\n            );\n        }\n        if (typeof pathOrObj === 'string') {\n            this.data = emptyCoverage(pathOrObj);\n        } else if (pathOrObj instanceof FileCoverage) {\n            this.data = pathOrObj.data;\n        } else if (typeof pathOrObj === 'object') {\n            this.data = pathOrObj;\n        } else {\n            throw new Error('Invalid argument to coverage constructor');\n        }\n        assertValidObject(this.data);\n    }\n\n    /**\n     * returns computed line coverage from statement coverage.\n     * This is a map of hits keyed by line number in the source.\n     */\n    getLineCoverage() {\n        const statementMap = this.data.statementMap;\n        const statements = this.data.s;\n        const lineMap = Object.create(null);\n\n        Object.entries(statements).forEach(([st, count]) => {\n            /* istanbul ignore if: is this even possible? */\n            if (!statementMap[st]) {\n                return;\n            }\n            const { line } = statementMap[st].start;\n            const prevVal = lineMap[line];\n            if (prevVal === undefined || prevVal < count) {\n                lineMap[line] = count;\n            }\n        });\n        return lineMap;\n    }\n\n    /**\n     * returns an array of uncovered line numbers.\n     * @returns {Array} an array of line numbers for which no hits have been\n     *  collected.\n     */\n    getUncoveredLines() {\n        const lc = this.getLineCoverage();\n        const ret = [];\n        Object.entries(lc).forEach(([l, hits]) => {\n            if (hits === 0) {\n                ret.push(l);\n            }\n        });\n        return ret;\n    }\n\n    /**\n     * returns a map of branch coverage by source line number.\n     * @returns {Object} an object keyed by line number. Each object\n     * has a `covered`, `total` and `coverage` (percentage) property.\n     */\n    getBranchCoverageByLine() {\n        const branchMap = this.branchMap;\n        const branches = this.b;\n        const ret = {};\n        Object.entries(branchMap).forEach(([k, map]) => {\n            const line = map.line || map.loc.start.line;\n            const branchData = branches[k];\n            ret[line] = ret[line] || [];\n            ret[line].push(...branchData);\n        });\n        Object.entries(ret).forEach(([k, dataArray]) => {\n            const covered = dataArray.filter(item => item > 0);\n            const coverage = (covered.length / dataArray.length) * 100;\n            ret[k] = {\n                covered: covered.length,\n                total: dataArray.length,\n                coverage\n            };\n        });\n        return ret;\n    }\n\n    /**\n     * return a JSON-serializable POJO for this file coverage object\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * merges a second coverage object into this one, updating hit counts\n     * @param {FileCoverage} other - the coverage object to be merged into this one.\n     *  Note that the other object should have the same structure as this one (same file).\n     */\n    merge(other) {\n        if (other.all === true) {\n            return;\n        }\n\n        if (this.all === true) {\n            this.data = other.data;\n            return;\n        }\n\n        Object.entries(other.s).forEach(([k, v]) => {\n            this.data.s[k] += v;\n        });\n        Object.entries(other.f).forEach(([k, v]) => {\n            this.data.f[k] += v;\n        });\n        Object.entries(other.b).forEach(([k, v]) => {\n            let i;\n            const retArray = this.data.b[k];\n            /* istanbul ignore if: is this even possible? */\n            if (!retArray) {\n                this.data.b[k] = v;\n                return;\n            }\n            for (i = 0; i < retArray.length; i += 1) {\n                retArray[i] += v[i];\n            }\n        });\n    }\n\n    computeSimpleTotals(property) {\n        let stats = this[property];\n\n        if (typeof stats === 'function') {\n            stats = stats.call(this);\n        }\n\n        const ret = {\n            total: Object.keys(stats).length,\n            covered: Object.values(stats).filter(v => !!v).length,\n            skipped: 0\n        };\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    computeBranchTotals() {\n        const stats = this.b;\n        const ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.values(stats).forEach(branches => {\n            ret.covered += branches.filter(hits => hits > 0).length;\n            ret.total += branches.length;\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    /**\n     * resets hit counts for all statements, functions and branches\n     * in this coverage object resulting in zero coverage.\n     */\n    resetHits() {\n        const statements = this.s;\n        const functions = this.f;\n        const branches = this.b;\n        Object.keys(statements).forEach(s => {\n            statements[s] = 0;\n        });\n        Object.keys(functions).forEach(f => {\n            functions[f] = 0;\n        });\n        Object.keys(branches).forEach(b => {\n            branches[b].fill(0);\n        });\n    }\n\n    /**\n     * returns a CoverageSummary for this file coverage object\n     * @returns {CoverageSummary}\n     */\n    toSummary() {\n        const ret = {};\n        ret.lines = this.computeSimpleTotals('getLineCoverage');\n        ret.functions = this.computeSimpleTotals('f', 'fnMap');\n        ret.statements = this.computeSimpleTotals('s', 'statementMap');\n        ret.branches = this.computeBranchTotals();\n        return new CoverageSummary(ret);\n    }\n}\n\n// expose coverage data attributes\ndataProperties(FileCoverage, [\n    'path',\n    'statementMap',\n    'fnMap',\n    'branchMap',\n    's',\n    'f',\n    'b',\n    'all'\n]);\n\nmodule.exports = {\n    FileCoverage\n};\n"]},"metadata":{},"sourceType":"script"}