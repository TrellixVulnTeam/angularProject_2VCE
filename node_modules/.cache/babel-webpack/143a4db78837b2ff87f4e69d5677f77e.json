{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/i18n/extractor_merger\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/ml_parser/ast\", \"@angular/compiler/src/ml_parser/parser\", \"@angular/compiler/src/i18n/i18n_ast\", \"@angular/compiler/src/i18n/i18n_parser\", \"@angular/compiler/src/i18n/parse_util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ExtractionResult = exports.mergeTranslations = exports.extractMessages = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var html = require(\"@angular/compiler/src/ml_parser/ast\");\n\n  var parser_1 = require(\"@angular/compiler/src/ml_parser/parser\");\n\n  var i18n = require(\"@angular/compiler/src/i18n/i18n_ast\");\n\n  var i18n_parser_1 = require(\"@angular/compiler/src/i18n/i18n_parser\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/i18n/parse_util\");\n\n  var _I18N_ATTR = 'i18n';\n  var _I18N_ATTR_PREFIX = 'i18n-';\n  var _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\n  var MEANING_SEPARATOR = '|';\n  var ID_SEPARATOR = '@@';\n  var i18nCommentsWarned = false;\n  /**\n   * Extract translatable messages from an html AST\n   */\n\n  function extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n    var visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.extract(nodes, interpolationConfig);\n  }\n\n  exports.extractMessages = extractMessages;\n\n  function mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n    var visitor = new _Visitor(implicitTags, implicitAttrs);\n    return visitor.merge(nodes, translations, interpolationConfig);\n  }\n\n  exports.mergeTranslations = mergeTranslations;\n\n  var ExtractionResult =\n  /** @class */\n  function () {\n    function ExtractionResult(messages, errors) {\n      this.messages = messages;\n      this.errors = errors;\n    }\n\n    return ExtractionResult;\n  }();\n\n  exports.ExtractionResult = ExtractionResult;\n\n  var _VisitorMode;\n\n  (function (_VisitorMode) {\n    _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n    _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n  })(_VisitorMode || (_VisitorMode = {}));\n  /**\n   * This Visitor is used:\n   * 1. to extract all the translatable strings from an html AST (see `extract()`),\n   * 2. to replace the translatable strings with the actual translations (see `merge()`)\n   *\n   * @internal\n   */\n\n\n  var _Visitor =\n  /** @class */\n  function () {\n    function _Visitor(_implicitTags, _implicitAttrs) {\n      this._implicitTags = _implicitTags;\n      this._implicitAttrs = _implicitAttrs;\n    }\n    /**\n     * Extracts the messages from the tree\n     */\n\n\n    _Visitor.prototype.extract = function (nodes, interpolationConfig) {\n      var _this = this;\n\n      this._init(_VisitorMode.Extract, interpolationConfig);\n\n      nodes.forEach(function (node) {\n        return node.visit(_this, null);\n      });\n\n      if (this._inI18nBlock) {\n        this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n      }\n\n      return new ExtractionResult(this._messages, this._errors);\n    };\n    /**\n     * Returns a tree where all translatable nodes are translated\n     */\n\n\n    _Visitor.prototype.merge = function (nodes, translations, interpolationConfig) {\n      this._init(_VisitorMode.Merge, interpolationConfig);\n\n      this._translations = translations; // Construct a single fake root element\n\n      var wrapper = new html.Element('wrapper', [], nodes, undefined, undefined, undefined);\n      var translatedNode = wrapper.visit(this, null);\n\n      if (this._inI18nBlock) {\n        this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n      }\n\n      return new parser_1.ParseTreeResult(translatedNode.children, this._errors);\n    };\n\n    _Visitor.prototype.visitExpansionCase = function (icuCase, context) {\n      // Parse cases for translatable html attributes\n      var expression = html.visitAll(this, icuCase.expression, context);\n\n      if (this._mode === _VisitorMode.Merge) {\n        return new html.ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n      }\n    };\n\n    _Visitor.prototype.visitExpansion = function (icu, context) {\n      this._mayBeAddBlockChildren(icu);\n\n      var wasInIcu = this._inIcu;\n\n      if (!this._inIcu) {\n        // nested ICU messages should not be extracted but top-level translated as a whole\n        if (this._isInTranslatableSection) {\n          this._addMessage([icu]);\n        }\n\n        this._inIcu = true;\n      }\n\n      var cases = html.visitAll(this, icu.cases, context);\n\n      if (this._mode === _VisitorMode.Merge) {\n        icu = new html.Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n      }\n\n      this._inIcu = wasInIcu;\n      return icu;\n    };\n\n    _Visitor.prototype.visitComment = function (comment, context) {\n      var isOpening = _isOpeningComment(comment);\n\n      if (isOpening && this._isInTranslatableSection) {\n        this._reportError(comment, 'Could not start a block inside a translatable section');\n\n        return;\n      }\n\n      var isClosing = _isClosingComment(comment);\n\n      if (isClosing && !this._inI18nBlock) {\n        this._reportError(comment, 'Trying to close an unopened block');\n\n        return;\n      }\n\n      if (!this._inI18nNode && !this._inIcu) {\n        if (!this._inI18nBlock) {\n          if (isOpening) {\n            // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n            if (!i18nCommentsWarned && console && console.warn) {\n              i18nCommentsWarned = true;\n              var details = comment.sourceSpan.details ? \", \" + comment.sourceSpan.details : ''; // TODO(ocombe): use a log service once there is a public one available\n\n              console.warn(\"I18n comments are deprecated, use an <ng-container> element instead (\" + comment.sourceSpan.start + details + \")\");\n            }\n\n            this._inI18nBlock = true;\n            this._blockStartDepth = this._depth;\n            this._blockChildren = [];\n            this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n\n            this._openTranslatableSection(comment);\n          }\n        } else {\n          if (isClosing) {\n            if (this._depth == this._blockStartDepth) {\n              this._closeTranslatableSection(comment, this._blockChildren);\n\n              this._inI18nBlock = false;\n\n              var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc); // merge attributes in sections\n\n\n              var nodes = this._translateMessage(comment, message);\n\n              return html.visitAll(this, nodes);\n            } else {\n              this._reportError(comment, 'I18N blocks should not cross element boundaries');\n\n              return;\n            }\n          }\n        }\n      }\n    };\n\n    _Visitor.prototype.visitText = function (text, context) {\n      if (this._isInTranslatableSection) {\n        this._mayBeAddBlockChildren(text);\n      }\n\n      return text;\n    };\n\n    _Visitor.prototype.visitElement = function (el, context) {\n      var _this = this;\n\n      this._mayBeAddBlockChildren(el);\n\n      this._depth++;\n      var wasInI18nNode = this._inI18nNode;\n      var wasInImplicitNode = this._inImplicitNode;\n      var childNodes = [];\n      var translatedChildNodes = undefined; // Extract:\n      // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n      // - ICU messages\n\n      var i18nAttr = _getI18nAttr(el);\n\n      var i18nMeta = i18nAttr ? i18nAttr.value : '';\n      var isImplicit = this._implicitTags.some(function (tag) {\n        return el.name === tag;\n      }) && !this._inIcu && !this._isInTranslatableSection;\n      var isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n      this._inImplicitNode = wasInImplicitNode || isImplicit;\n\n      if (!this._isInTranslatableSection && !this._inIcu) {\n        if (i18nAttr || isTopLevelImplicit) {\n          this._inI18nNode = true;\n\n          var message = this._addMessage(el.children, i18nMeta);\n\n          translatedChildNodes = this._translateMessage(el, message);\n        }\n\n        if (this._mode == _VisitorMode.Extract) {\n          var isTranslatable = i18nAttr || isTopLevelImplicit;\n          if (isTranslatable) this._openTranslatableSection(el);\n          html.visitAll(this, el.children);\n          if (isTranslatable) this._closeTranslatableSection(el, el.children);\n        }\n      } else {\n        if (i18nAttr || isTopLevelImplicit) {\n          this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n        }\n\n        if (this._mode == _VisitorMode.Extract) {\n          // Descend into child nodes for extraction\n          html.visitAll(this, el.children);\n        }\n      }\n\n      if (this._mode === _VisitorMode.Merge) {\n        var visitNodes = translatedChildNodes || el.children;\n        visitNodes.forEach(function (child) {\n          var visited = child.visit(_this, context);\n\n          if (visited && !_this._isInTranslatableSection) {\n            // Do not add the children from translatable sections (= i18n blocks here)\n            // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n            childNodes = childNodes.concat(visited);\n          }\n        });\n      }\n\n      this._visitAttributesOf(el);\n\n      this._depth--;\n      this._inI18nNode = wasInI18nNode;\n      this._inImplicitNode = wasInImplicitNode;\n\n      if (this._mode === _VisitorMode.Merge) {\n        var translatedAttrs = this._translateAttributes(el);\n\n        return new html.Element(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n      }\n\n      return null;\n    };\n\n    _Visitor.prototype.visitAttribute = function (attribute, context) {\n      throw new Error('unreachable code');\n    };\n\n    _Visitor.prototype._init = function (mode, interpolationConfig) {\n      this._mode = mode;\n      this._inI18nBlock = false;\n      this._inI18nNode = false;\n      this._depth = 0;\n      this._inIcu = false;\n      this._msgCountAtSectionStart = undefined;\n      this._errors = [];\n      this._messages = [];\n      this._inImplicitNode = false;\n      this._createI18nMessage = i18n_parser_1.createI18nMessageFactory(interpolationConfig);\n    }; // looks for translatable attributes\n\n\n    _Visitor.prototype._visitAttributesOf = function (el) {\n      var _this = this;\n\n      var explicitAttrNameToValue = {};\n      var implicitAttrNames = this._implicitAttrs[el.name] || [];\n      el.attrs.filter(function (attr) {\n        return attr.name.startsWith(_I18N_ATTR_PREFIX);\n      }).forEach(function (attr) {\n        return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;\n      });\n      el.attrs.forEach(function (attr) {\n        if (attr.name in explicitAttrNameToValue) {\n          _this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n        } else if (implicitAttrNames.some(function (name) {\n          return attr.name === name;\n        })) {\n          _this._addMessage([attr]);\n        }\n      });\n    }; // add a translatable message\n\n\n    _Visitor.prototype._addMessage = function (ast, msgMeta) {\n      if (ast.length == 0 || ast.length == 1 && ast[0] instanceof html.Attribute && !ast[0].value) {\n        // Do not create empty messages\n        return null;\n      }\n\n      var _a = _parseMessageMeta(msgMeta),\n          meaning = _a.meaning,\n          description = _a.description,\n          id = _a.id;\n\n      var message = this._createI18nMessage(ast, meaning, description, id);\n\n      this._messages.push(message);\n\n      return message;\n    }; // Translates the given message given the `TranslationBundle`\n    // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n    // no-op when called in extraction mode (returns [])\n\n\n    _Visitor.prototype._translateMessage = function (el, message) {\n      if (message && this._mode === _VisitorMode.Merge) {\n        var nodes = this._translations.get(message);\n\n        if (nodes) {\n          return nodes;\n        }\n\n        this._reportError(el, \"Translation unavailable for message id=\\\"\" + this._translations.digest(message) + \"\\\"\");\n      }\n\n      return [];\n    }; // translate the attributes of an element and remove i18n specific attributes\n\n\n    _Visitor.prototype._translateAttributes = function (el) {\n      var _this = this;\n\n      var attributes = el.attrs;\n      var i18nParsedMessageMeta = {};\n      attributes.forEach(function (attr) {\n        if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n          i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(attr.value);\n        }\n      });\n      var translatedAttributes = [];\n      attributes.forEach(function (attr) {\n        if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n          // strip i18n specific attributes\n          return;\n        }\n\n        if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n          var _a = i18nParsedMessageMeta[attr.name],\n              meaning = _a.meaning,\n              description = _a.description,\n              id = _a.id;\n\n          var message = _this._createI18nMessage([attr], meaning, description, id);\n\n          var nodes = _this._translations.get(message);\n\n          if (nodes) {\n            if (nodes.length == 0) {\n              translatedAttributes.push(new html.Attribute(attr.name, '', attr.sourceSpan, undefined\n              /* keySpan */\n              , undefined\n              /* valueSpan */\n              , undefined\n              /* i18n */\n              ));\n            } else if (nodes[0] instanceof html.Text) {\n              var value = nodes[0].value;\n              translatedAttributes.push(new html.Attribute(attr.name, value, attr.sourceSpan, undefined\n              /* keySpan */\n              , undefined\n              /* valueSpan */\n              , undefined\n              /* i18n */\n              ));\n            } else {\n              _this._reportError(el, \"Unexpected translation for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n            }\n          } else {\n            _this._reportError(el, \"Translation unavailable for attribute \\\"\" + attr.name + \"\\\" (id=\\\"\" + (id || _this._translations.digest(message)) + \"\\\")\");\n          }\n        } else {\n          translatedAttributes.push(attr);\n        }\n      });\n      return translatedAttributes;\n    };\n    /**\n     * Add the node as a child of the block when:\n     * - we are in a block,\n     * - we are not inside a ICU message (those are handled separately),\n     * - the node is a \"direct child\" of the block\n     */\n\n\n    _Visitor.prototype._mayBeAddBlockChildren = function (node) {\n      if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n        this._blockChildren.push(node);\n      }\n    };\n    /**\n     * Marks the start of a section, see `_closeTranslatableSection`\n     */\n\n\n    _Visitor.prototype._openTranslatableSection = function (node) {\n      if (this._isInTranslatableSection) {\n        this._reportError(node, 'Unexpected section start');\n      } else {\n        this._msgCountAtSectionStart = this._messages.length;\n      }\n    };\n\n    Object.defineProperty(_Visitor.prototype, \"_isInTranslatableSection\", {\n      /**\n       * A translatable section could be:\n       * - the content of translatable element,\n       * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n       */\n      get: function get() {\n        return this._msgCountAtSectionStart !== void 0;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    /**\n     * Terminates a section.\n     *\n     * If a section has only one significant children (comments not significant) then we should not\n     * keep the message from this children:\n     *\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n     * - one for the <p> content with meaning and description,\n     * - another one for the ICU message.\n     *\n     * In this case the last message is discarded as it contains less information (the AST is\n     * otherwise identical).\n     *\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\n     * ICU message here)\n     */\n\n    _Visitor.prototype._closeTranslatableSection = function (node, directChildren) {\n      if (!this._isInTranslatableSection) {\n        this._reportError(node, 'Unexpected section end');\n\n        return;\n      }\n\n      var startIndex = this._msgCountAtSectionStart;\n      var significantChildren = directChildren.reduce(function (count, node) {\n        return count + (node instanceof html.Comment ? 0 : 1);\n      }, 0);\n\n      if (significantChildren == 1) {\n        for (var i = this._messages.length - 1; i >= startIndex; i--) {\n          var ast = this._messages[i].nodes;\n\n          if (!(ast.length == 1 && ast[0] instanceof i18n.Text)) {\n            this._messages.splice(i, 1);\n\n            break;\n          }\n        }\n      }\n\n      this._msgCountAtSectionStart = undefined;\n    };\n\n    _Visitor.prototype._reportError = function (node, msg) {\n      this._errors.push(new parse_util_1.I18nError(node.sourceSpan, msg));\n    };\n\n    return _Visitor;\n  }();\n\n  function _isOpeningComment(n) {\n    return !!(n instanceof html.Comment && n.value && n.value.startsWith('i18n'));\n  }\n\n  function _isClosingComment(n) {\n    return !!(n instanceof html.Comment && n.value && n.value === '/i18n');\n  }\n\n  function _getI18nAttr(p) {\n    return p.attrs.find(function (attr) {\n      return attr.name === _I18N_ATTR;\n    }) || null;\n  }\n\n  function _parseMessageMeta(i18n) {\n    if (!i18n) return {\n      meaning: '',\n      description: '',\n      id: ''\n    };\n    var idIndex = i18n.indexOf(ID_SEPARATOR);\n    var descIndex = i18n.indexOf(MEANING_SEPARATOR);\n\n    var _a = tslib_1.__read(idIndex > -1 ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''], 2),\n        meaningAndDesc = _a[0],\n        id = _a[1];\n\n    var _b = tslib_1.__read(descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc], 2),\n        meaning = _b[0],\n        description = _b[1];\n\n    return {\n      meaning: meaning,\n      description: description,\n      id: id.trim()\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/i18n/extractor_merger.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {ParseTreeResult} from '../ml_parser/parser';\n\nimport * as i18n from './i18n_ast';\nimport {createI18nMessageFactory, I18nMessageFactory} from './i18n_parser';\nimport {I18nError} from './parse_util';\nimport {TranslationBundle} from './translation_bundle';\n\nconst _I18N_ATTR = 'i18n';\nconst _I18N_ATTR_PREFIX = 'i18n-';\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nlet i18nCommentsWarned = false;\n\n/**\n * Extract translatable messages from an html AST\n */\nexport function extractMessages(\n    nodes: html.Node[], interpolationConfig: InterpolationConfig, implicitTags: string[],\n    implicitAttrs: {[k: string]: string[]}): ExtractionResult {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.extract(nodes, interpolationConfig);\n}\n\nexport function mergeTranslations(\n    nodes: html.Node[], translations: TranslationBundle, interpolationConfig: InterpolationConfig,\n    implicitTags: string[], implicitAttrs: {[k: string]: string[]}): ParseTreeResult {\n  const visitor = new _Visitor(implicitTags, implicitAttrs);\n  return visitor.merge(nodes, translations, interpolationConfig);\n}\n\nexport class ExtractionResult {\n  constructor(public messages: i18n.Message[], public errors: I18nError[]) {}\n}\n\nenum _VisitorMode {\n  Extract,\n  Merge\n}\n\n/**\n * This Visitor is used:\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\n *\n * @internal\n */\nclass _Visitor implements html.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _depth!: number;\n\n  // <el i18n>...</el>\n  // TODO(issue/24571): remove '!'.\n  private _inI18nNode!: boolean;\n  // TODO(issue/24571): remove '!'.\n  private _inImplicitNode!: boolean;\n\n  // <!--i18n-->...<!--/i18n-->\n  // TODO(issue/24571): remove '!'.\n  private _inI18nBlock!: boolean;\n  // TODO(issue/24571): remove '!'.\n  private _blockMeaningAndDesc!: string;\n  // TODO(issue/24571): remove '!'.\n  private _blockChildren!: html.Node[];\n  // TODO(issue/24571): remove '!'.\n  private _blockStartDepth!: number;\n\n  // {<icu message>}\n  // TODO(issue/24571): remove '!'.\n  private _inIcu!: boolean;\n\n  // set to void 0 when not in a section\n  private _msgCountAtSectionStart: number|undefined;\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n  // TODO(issue/24571): remove '!'.\n  private _mode!: _VisitorMode;\n\n  // _VisitorMode.Extract only\n  // TODO(issue/24571): remove '!'.\n  private _messages!: i18n.Message[];\n\n  // _VisitorMode.Merge only\n  // TODO(issue/24571): remove '!'.\n  private _translations!: TranslationBundle;\n  // TODO(issue/24571): remove '!'.\n  private _createI18nMessage!: I18nMessageFactory;\n\n\n  constructor(private _implicitTags: string[], private _implicitAttrs: {[k: string]: string[]}) {}\n\n  /**\n   * Extracts the messages from the tree\n   */\n  extract(nodes: html.Node[], interpolationConfig: InterpolationConfig): ExtractionResult {\n    this._init(_VisitorMode.Extract, interpolationConfig);\n\n    nodes.forEach(node => node.visit(this, null));\n\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n\n    return new ExtractionResult(this._messages, this._errors);\n  }\n\n  /**\n   * Returns a tree where all translatable nodes are translated\n   */\n  merge(\n      nodes: html.Node[], translations: TranslationBundle,\n      interpolationConfig: InterpolationConfig): ParseTreeResult {\n    this._init(_VisitorMode.Merge, interpolationConfig);\n    this._translations = translations;\n\n    // Construct a single fake root element\n    const wrapper = new html.Element('wrapper', [], nodes, undefined!, undefined!, undefined);\n\n    const translatedNode = wrapper.visit(this, null);\n\n    if (this._inI18nBlock) {\n      this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n    }\n\n    return new ParseTreeResult(translatedNode.children, this._errors);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): any {\n    // Parse cases for translatable html attributes\n    const expression = html.visitAll(this, icuCase.expression, context);\n\n    if (this._mode === _VisitorMode.Merge) {\n      return new html.ExpansionCase(\n          icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan,\n          icuCase.expSourceSpan);\n    }\n  }\n\n  visitExpansion(icu: html.Expansion, context: any): html.Expansion {\n    this._mayBeAddBlockChildren(icu);\n\n    const wasInIcu = this._inIcu;\n\n    if (!this._inIcu) {\n      // nested ICU messages should not be extracted but top-level translated as a whole\n      if (this._isInTranslatableSection) {\n        this._addMessage([icu]);\n      }\n      this._inIcu = true;\n    }\n\n    const cases = html.visitAll(this, icu.cases, context);\n\n    if (this._mode === _VisitorMode.Merge) {\n      icu = new html.Expansion(\n          icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n    }\n\n    this._inIcu = wasInIcu;\n\n    return icu;\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    const isOpening = _isOpeningComment(comment);\n\n    if (isOpening && this._isInTranslatableSection) {\n      this._reportError(comment, 'Could not start a block inside a translatable section');\n      return;\n    }\n\n    const isClosing = _isClosingComment(comment);\n\n    if (isClosing && !this._inI18nBlock) {\n      this._reportError(comment, 'Trying to close an unopened block');\n      return;\n    }\n\n    if (!this._inI18nNode && !this._inIcu) {\n      if (!this._inI18nBlock) {\n        if (isOpening) {\n          // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n          if (!i18nCommentsWarned && <any>console && <any>console.warn) {\n            i18nCommentsWarned = true;\n            const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\n            // TODO(ocombe): use a log service once there is a public one available\n            console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${\n                comment.sourceSpan.start}${details})`);\n          }\n          this._inI18nBlock = true;\n          this._blockStartDepth = this._depth;\n          this._blockChildren = [];\n          this._blockMeaningAndDesc =\n              comment.value!.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n          this._openTranslatableSection(comment);\n        }\n      } else {\n        if (isClosing) {\n          if (this._depth == this._blockStartDepth) {\n            this._closeTranslatableSection(comment, this._blockChildren);\n            this._inI18nBlock = false;\n            const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc)!;\n            // merge attributes in sections\n            const nodes = this._translateMessage(comment, message);\n            return html.visitAll(this, nodes);\n          } else {\n            this._reportError(comment, 'I18N blocks should not cross element boundaries');\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  visitText(text: html.Text, context: any): html.Text {\n    if (this._isInTranslatableSection) {\n      this._mayBeAddBlockChildren(text);\n    }\n    return text;\n  }\n\n  visitElement(el: html.Element, context: any): html.Element|null {\n    this._mayBeAddBlockChildren(el);\n    this._depth++;\n    const wasInI18nNode = this._inI18nNode;\n    const wasInImplicitNode = this._inImplicitNode;\n    let childNodes: html.Node[] = [];\n    let translatedChildNodes: html.Node[] = undefined!;\n\n    // Extract:\n    // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n    // - ICU messages\n    const i18nAttr = _getI18nAttr(el);\n    const i18nMeta = i18nAttr ? i18nAttr.value : '';\n    const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&\n        !this._isInTranslatableSection;\n    const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n    this._inImplicitNode = wasInImplicitNode || isImplicit;\n\n    if (!this._isInTranslatableSection && !this._inIcu) {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._inI18nNode = true;\n        const message = this._addMessage(el.children, i18nMeta)!;\n        translatedChildNodes = this._translateMessage(el, message);\n      }\n\n      if (this._mode == _VisitorMode.Extract) {\n        const isTranslatable = i18nAttr || isTopLevelImplicit;\n        if (isTranslatable) this._openTranslatableSection(el);\n        html.visitAll(this, el.children);\n        if (isTranslatable) this._closeTranslatableSection(el, el.children);\n      }\n    } else {\n      if (i18nAttr || isTopLevelImplicit) {\n        this._reportError(\n            el, 'Could not mark an element as translatable inside a translatable section');\n      }\n\n      if (this._mode == _VisitorMode.Extract) {\n        // Descend into child nodes for extraction\n        html.visitAll(this, el.children);\n      }\n    }\n\n    if (this._mode === _VisitorMode.Merge) {\n      const visitNodes = translatedChildNodes || el.children;\n      visitNodes.forEach(child => {\n        const visited = child.visit(this, context);\n        if (visited && !this._isInTranslatableSection) {\n          // Do not add the children from translatable sections (= i18n blocks here)\n          // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n          childNodes = childNodes.concat(visited);\n        }\n      });\n    }\n\n    this._visitAttributesOf(el);\n\n    this._depth--;\n    this._inI18nNode = wasInI18nNode;\n    this._inImplicitNode = wasInImplicitNode;\n\n    if (this._mode === _VisitorMode.Merge) {\n      const translatedAttrs = this._translateAttributes(el);\n      return new html.Element(\n          el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan,\n          el.endSourceSpan);\n    }\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    throw new Error('unreachable code');\n  }\n\n  private _init(mode: _VisitorMode, interpolationConfig: InterpolationConfig): void {\n    this._mode = mode;\n    this._inI18nBlock = false;\n    this._inI18nNode = false;\n    this._depth = 0;\n    this._inIcu = false;\n    this._msgCountAtSectionStart = undefined;\n    this._errors = [];\n    this._messages = [];\n    this._inImplicitNode = false;\n    this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n  }\n\n  // looks for translatable attributes\n  private _visitAttributesOf(el: html.Element): void {\n    const explicitAttrNameToValue: {[k: string]: string} = {};\n    const implicitAttrNames: string[] = this._implicitAttrs[el.name] || [];\n\n    el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))\n        .forEach(\n            attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n                attr.value);\n\n    el.attrs.forEach(attr => {\n      if (attr.name in explicitAttrNameToValue) {\n        this._addMessage([attr], explicitAttrNameToValue[attr.name]);\n      } else if (implicitAttrNames.some(name => attr.name === name)) {\n        this._addMessage([attr]);\n      }\n    });\n  }\n\n  // add a translatable message\n  private _addMessage(ast: html.Node[], msgMeta?: string): i18n.Message|null {\n    if (ast.length == 0 ||\n        ast.length == 1 && ast[0] instanceof html.Attribute && !(<html.Attribute>ast[0]).value) {\n      // Do not create empty messages\n      return null;\n    }\n\n    const {meaning, description, id} = _parseMessageMeta(msgMeta);\n    const message = this._createI18nMessage(ast, meaning, description, id);\n    this._messages.push(message);\n    return message;\n  }\n\n  // Translates the given message given the `TranslationBundle`\n  // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n  // no-op when called in extraction mode (returns [])\n  private _translateMessage(el: html.Node, message: i18n.Message): html.Node[] {\n    if (message && this._mode === _VisitorMode.Merge) {\n      const nodes = this._translations.get(message);\n\n      if (nodes) {\n        return nodes;\n      }\n\n      this._reportError(\n          el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\n    }\n\n    return [];\n  }\n\n  // translate the attributes of an element and remove i18n specific attributes\n  private _translateAttributes(el: html.Element): html.Attribute[] {\n    const attributes = el.attrs;\n    const i18nParsedMessageMeta:\n        {[name: string]: {meaning: string, description: string, id: string}} = {};\n\n    attributes.forEach(attr => {\n      if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\n            _parseMessageMeta(attr.value);\n      }\n    });\n\n    const translatedAttributes: html.Attribute[] = [];\n\n    attributes.forEach((attr) => {\n      if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n        // strip i18n specific attributes\n        return;\n      }\n\n      if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n        const {meaning, description, id} = i18nParsedMessageMeta[attr.name];\n        const message: i18n.Message = this._createI18nMessage([attr], meaning, description, id);\n        const nodes = this._translations.get(message);\n        if (nodes) {\n          if (nodes.length == 0) {\n            translatedAttributes.push(new html.Attribute(\n                attr.name, '', attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */,\n                undefined /* i18n */));\n          } else if (nodes[0] instanceof html.Text) {\n            const value = (nodes[0] as html.Text).value;\n            translatedAttributes.push(new html.Attribute(\n                attr.name, value, attr.sourceSpan, undefined /* keySpan */,\n                undefined /* valueSpan */, undefined /* i18n */));\n          } else {\n            this._reportError(\n                el,\n                `Unexpected translation for attribute \"${attr.name}\" (id=\"${\n                    id || this._translations.digest(message)}\")`);\n          }\n        } else {\n          this._reportError(\n              el,\n              `Translation unavailable for attribute \"${attr.name}\" (id=\"${\n                  id || this._translations.digest(message)}\")`);\n        }\n      } else {\n        translatedAttributes.push(attr);\n      }\n    });\n\n    return translatedAttributes;\n  }\n\n\n  /**\n   * Add the node as a child of the block when:\n   * - we are in a block,\n   * - we are not inside a ICU message (those are handled separately),\n   * - the node is a \"direct child\" of the block\n   */\n  private _mayBeAddBlockChildren(node: html.Node): void {\n    if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n      this._blockChildren.push(node);\n    }\n  }\n\n  /**\n   * Marks the start of a section, see `_closeTranslatableSection`\n   */\n  private _openTranslatableSection(node: html.Node): void {\n    if (this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section start');\n    } else {\n      this._msgCountAtSectionStart = this._messages.length;\n    }\n  }\n\n  /**\n   * A translatable section could be:\n   * - the content of translatable element,\n   * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\n   */\n  private get _isInTranslatableSection(): boolean {\n    return this._msgCountAtSectionStart !== void 0;\n  }\n\n  /**\n   * Terminates a section.\n   *\n   * If a section has only one significant children (comments not significant) then we should not\n   * keep the message from this children:\n   *\n   * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\n   * - one for the <p> content with meaning and description,\n   * - another one for the ICU message.\n   *\n   * In this case the last message is discarded as it contains less information (the AST is\n   * otherwise identical).\n   *\n   * Note that we should still keep messages extracted from attributes inside the section (ie in the\n   * ICU message here)\n   */\n  private _closeTranslatableSection(node: html.Node, directChildren: html.Node[]): void {\n    if (!this._isInTranslatableSection) {\n      this._reportError(node, 'Unexpected section end');\n      return;\n    }\n\n    const startIndex = this._msgCountAtSectionStart;\n    const significantChildren: number = directChildren.reduce(\n        (count: number, node: html.Node): number => count + (node instanceof html.Comment ? 0 : 1),\n        0);\n\n    if (significantChildren == 1) {\n      for (let i = this._messages.length - 1; i >= startIndex!; i--) {\n        const ast = this._messages[i].nodes;\n        if (!(ast.length == 1 && ast[0] instanceof i18n.Text)) {\n          this._messages.splice(i, 1);\n          break;\n        }\n      }\n    }\n\n    this._msgCountAtSectionStart = undefined;\n  }\n\n  private _reportError(node: html.Node, msg: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, msg));\n  }\n}\n\nfunction _isOpeningComment(n: html.Node): boolean {\n  return !!(n instanceof html.Comment && n.value && n.value.startsWith('i18n'));\n}\n\nfunction _isClosingComment(n: html.Node): boolean {\n  return !!(n instanceof html.Comment && n.value && n.value === '/i18n');\n}\n\nfunction _getI18nAttr(p: html.Element): html.Attribute|null {\n  return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\n}\n\nfunction _parseMessageMeta(i18n?: string): {meaning: string, description: string, id: string} {\n  if (!i18n) return {meaning: '', description: '', id: ''};\n\n  const idIndex = i18n.indexOf(ID_SEPARATOR);\n  const descIndex = i18n.indexOf(MEANING_SEPARATOR);\n  const [meaningAndDesc, id] =\n      (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\n  const [meaning, description] = (descIndex > -1) ?\n      [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\n      ['', meaningAndDesc];\n\n  return {meaning, description, id: id.trim()};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}