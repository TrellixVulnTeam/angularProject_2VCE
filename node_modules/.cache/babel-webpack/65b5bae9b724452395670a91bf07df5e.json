{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/resource/src/loader\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.AdapterResourceLoader = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var CSS_PREPROCESSOR_EXT = /(\\.scss|\\.sass|\\.less|\\.styl)$/;\n  var RESOURCE_MARKER = '.$ngresource$';\n  var RESOURCE_MARKER_TS = RESOURCE_MARKER + '.ts';\n  /**\n   * `ResourceLoader` which delegates to an `NgCompilerAdapter`'s resource loading methods.\n   */\n\n  var AdapterResourceLoader =\n  /** @class */\n  function () {\n    function AdapterResourceLoader(adapter, options) {\n      this.adapter = adapter;\n      this.options = options;\n      this.cache = new Map();\n      this.fetching = new Map();\n      this.lookupResolutionHost = createLookupResolutionHost(this.adapter);\n      this.canPreload = !!this.adapter.readResource;\n    }\n    /**\n     * Resolve the url of a resource relative to the file that contains the reference to it.\n     * The return value of this method can be used in the `load()` and `preload()` methods.\n     *\n     * Uses the provided CompilerHost if it supports mapping resources to filenames.\n     * Otherwise, uses a fallback mechanism that searches the module resolution candidates.\n     *\n     * @param url The, possibly relative, url of the resource.\n     * @param fromFile The path to the file that contains the URL of the resource.\n     * @returns A resolved url of resource.\n     * @throws An error if the resource cannot be resolved.\n     */\n\n\n    AdapterResourceLoader.prototype.resolve = function (url, fromFile) {\n      var _this = this;\n\n      var resolvedUrl = null;\n\n      if (this.adapter.resourceNameToFileName) {\n        resolvedUrl = this.adapter.resourceNameToFileName(url, fromFile, function (url, fromFile) {\n          return _this.fallbackResolve(url, fromFile);\n        });\n      } else {\n        resolvedUrl = this.fallbackResolve(url, fromFile);\n      }\n\n      if (resolvedUrl === null) {\n        throw new Error(\"HostResourceResolver: could not resolve \" + url + \" in context of \" + fromFile + \")\");\n      }\n\n      return resolvedUrl;\n    };\n    /**\n     * Preload the specified resource, asynchronously.\n     *\n     * Once the resource is loaded, its value is cached so it can be accessed synchronously via the\n     * `load()` method.\n     *\n     * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to preload.\n     * @returns A Promise that is resolved once the resource has been loaded or `undefined` if the\n     * file has already been loaded.\n     * @throws An Error if pre-loading is not available.\n     */\n\n\n    AdapterResourceLoader.prototype.preload = function (resolvedUrl) {\n      var _this = this;\n\n      if (!this.adapter.readResource) {\n        throw new Error('HostResourceLoader: the CompilerHost provided does not support pre-loading resources.');\n      }\n\n      if (this.cache.has(resolvedUrl)) {\n        return undefined;\n      } else if (this.fetching.has(resolvedUrl)) {\n        return this.fetching.get(resolvedUrl);\n      }\n\n      var result = this.adapter.readResource(resolvedUrl);\n\n      if (typeof result === 'string') {\n        this.cache.set(resolvedUrl, result);\n        return undefined;\n      } else {\n        var fetchCompletion = result.then(function (str) {\n          _this.fetching.delete(resolvedUrl);\n\n          _this.cache.set(resolvedUrl, str);\n        });\n        this.fetching.set(resolvedUrl, fetchCompletion);\n        return fetchCompletion;\n      }\n    };\n    /**\n     * Load the resource at the given url, synchronously.\n     *\n     * The contents of the resource may have been cached by a previous call to `preload()`.\n     *\n     * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to load.\n     * @returns The contents of the resource.\n     */\n\n\n    AdapterResourceLoader.prototype.load = function (resolvedUrl) {\n      if (this.cache.has(resolvedUrl)) {\n        return this.cache.get(resolvedUrl);\n      }\n\n      var result = this.adapter.readResource ? this.adapter.readResource(resolvedUrl) : this.adapter.readFile(resolvedUrl);\n\n      if (typeof result !== 'string') {\n        throw new Error(\"HostResourceLoader: loader(\" + resolvedUrl + \") returned a Promise\");\n      }\n\n      this.cache.set(resolvedUrl, result);\n      return result;\n    };\n    /**\n     * Invalidate the entire resource cache.\n     */\n\n\n    AdapterResourceLoader.prototype.invalidate = function () {\n      this.cache.clear();\n    };\n    /**\n     * Attempt to resolve `url` in the context of `fromFile`, while respecting the rootDirs\n     * option from the tsconfig. First, normalize the file name.\n     */\n\n\n    AdapterResourceLoader.prototype.fallbackResolve = function (url, fromFile) {\n      var e_1, _a;\n\n      var candidateLocations;\n\n      if (url.startsWith('/')) {\n        // This path is not really an absolute path, but instead the leading '/' means that it's\n        // rooted in the project rootDirs. So look for it according to the rootDirs.\n        candidateLocations = this.getRootedCandidateLocations(url);\n      } else {\n        // This path is a \"relative\" path and can be resolved as such. To make this easier on the\n        // downstream resolver, the './' prefix is added if missing to distinguish these paths from\n        // absolute node_modules paths.\n        if (!url.startsWith('.')) {\n          url = \"./\" + url;\n        }\n\n        candidateLocations = this.getResolvedCandidateLocations(url, fromFile);\n      }\n\n      try {\n        for (var candidateLocations_1 = tslib_1.__values(candidateLocations), candidateLocations_1_1 = candidateLocations_1.next(); !candidateLocations_1_1.done; candidateLocations_1_1 = candidateLocations_1.next()) {\n          var candidate = candidateLocations_1_1.value;\n\n          if (this.adapter.fileExists(candidate)) {\n            return candidate;\n          } else if (CSS_PREPROCESSOR_EXT.test(candidate)) {\n            /**\n             * If the user specified styleUrl points to *.scss, but the Sass compiler was run before\n             * Angular, then the resource may have been generated as *.css. Simply try the resolution\n             * again.\n             */\n            var cssFallbackUrl = candidate.replace(CSS_PREPROCESSOR_EXT, '.css');\n\n            if (this.adapter.fileExists(cssFallbackUrl)) {\n              return cssFallbackUrl;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (candidateLocations_1_1 && !candidateLocations_1_1.done && (_a = candidateLocations_1.return)) _a.call(candidateLocations_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return null;\n    };\n\n    AdapterResourceLoader.prototype.getRootedCandidateLocations = function (url) {\n      // The path already starts with '/', so add a '.' to make it relative.\n      var segment = '.' + url;\n      return this.adapter.rootDirs.map(function (rootDir) {\n        return file_system_1.join(rootDir, segment);\n      });\n    };\n    /**\n     * TypeScript provides utilities to resolve module names, but not resource files (which aren't\n     * a part of the ts.Program). However, TypeScript's module resolution can be used creatively\n     * to locate where resource files should be expected to exist. Since module resolution returns\n     * a list of file names that were considered, the loader can enumerate the possible locations\n     * for the file by setting up a module resolution for it that will fail.\n     */\n\n\n    AdapterResourceLoader.prototype.getResolvedCandidateLocations = function (url, fromFile) {\n      // clang-format off\n      var failedLookup = ts.resolveModuleName(url + RESOURCE_MARKER, fromFile, this.options, this.lookupResolutionHost); // clang-format on\n\n      if (failedLookup.failedLookupLocations === undefined) {\n        throw new Error(\"Internal error: expected to find failedLookupLocations during resolution of resource '\" + url + \"' in context of \" + fromFile);\n      }\n\n      return failedLookup.failedLookupLocations.filter(function (candidate) {\n        return candidate.endsWith(RESOURCE_MARKER_TS);\n      }).map(function (candidate) {\n        return candidate.slice(0, -RESOURCE_MARKER_TS.length);\n      });\n    };\n\n    return AdapterResourceLoader;\n  }();\n\n  exports.AdapterResourceLoader = AdapterResourceLoader;\n  /**\n   * Derives a `ts.ModuleResolutionHost` from a compiler adapter that recognizes the special resource\n   * marker and does not go to the filesystem for these requests, as they are known not to exist.\n   */\n\n  function createLookupResolutionHost(adapter) {\n    var _a, _b, _c;\n\n    return {\n      directoryExists: function directoryExists(directoryName) {\n        if (directoryName.includes(RESOURCE_MARKER)) {\n          return false;\n        } else if (adapter.directoryExists !== undefined) {\n          return adapter.directoryExists(directoryName);\n        } else {\n          // TypeScript's module resolution logic assumes that the directory exists when no host\n          // implementation is available.\n          return true;\n        }\n      },\n      fileExists: function fileExists(fileName) {\n        if (fileName.includes(RESOURCE_MARKER)) {\n          return false;\n        } else {\n          return adapter.fileExists(fileName);\n        }\n      },\n      readFile: adapter.readFile.bind(adapter),\n      getCurrentDirectory: adapter.getCurrentDirectory.bind(adapter),\n      getDirectories: (_a = adapter.getDirectories) === null || _a === void 0 ? void 0 : _a.bind(adapter),\n      realpath: (_b = adapter.realpath) === null || _b === void 0 ? void 0 : _b.bind(adapter),\n      trace: (_c = adapter.trace) === null || _c === void 0 ? void 0 : _c.bind(adapter)\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/resource/src/loader.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ResourceLoader} from '../../annotations';\nimport {NgCompilerAdapter} from '../../core/api';\nimport {AbsoluteFsPath, join, PathSegment} from '../../file_system';\nimport {RequiredDelegations} from '../../util/src/typescript';\n\nconst CSS_PREPROCESSOR_EXT = /(\\.scss|\\.sass|\\.less|\\.styl)$/;\n\nconst RESOURCE_MARKER = '.$ngresource$';\nconst RESOURCE_MARKER_TS = RESOURCE_MARKER + '.ts';\n\n/**\n * `ResourceLoader` which delegates to an `NgCompilerAdapter`'s resource loading methods.\n */\nexport class AdapterResourceLoader implements ResourceLoader {\n  private cache = new Map<string, string>();\n  private fetching = new Map<string, Promise<void>>();\n  private lookupResolutionHost = createLookupResolutionHost(this.adapter);\n\n  canPreload = !!this.adapter.readResource;\n\n  constructor(private adapter: NgCompilerAdapter, private options: ts.CompilerOptions) {}\n\n  /**\n   * Resolve the url of a resource relative to the file that contains the reference to it.\n   * The return value of this method can be used in the `load()` and `preload()` methods.\n   *\n   * Uses the provided CompilerHost if it supports mapping resources to filenames.\n   * Otherwise, uses a fallback mechanism that searches the module resolution candidates.\n   *\n   * @param url The, possibly relative, url of the resource.\n   * @param fromFile The path to the file that contains the URL of the resource.\n   * @returns A resolved url of resource.\n   * @throws An error if the resource cannot be resolved.\n   */\n  resolve(url: string, fromFile: string): string {\n    let resolvedUrl: string|null = null;\n    if (this.adapter.resourceNameToFileName) {\n      resolvedUrl = this.adapter.resourceNameToFileName(\n          url, fromFile, (url: string, fromFile: string) => this.fallbackResolve(url, fromFile));\n    } else {\n      resolvedUrl = this.fallbackResolve(url, fromFile);\n    }\n    if (resolvedUrl === null) {\n      throw new Error(`HostResourceResolver: could not resolve ${url} in context of ${fromFile})`);\n    }\n    return resolvedUrl;\n  }\n\n  /**\n   * Preload the specified resource, asynchronously.\n   *\n   * Once the resource is loaded, its value is cached so it can be accessed synchronously via the\n   * `load()` method.\n   *\n   * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to preload.\n   * @returns A Promise that is resolved once the resource has been loaded or `undefined` if the\n   * file has already been loaded.\n   * @throws An Error if pre-loading is not available.\n   */\n  preload(resolvedUrl: string): Promise<void>|undefined {\n    if (!this.adapter.readResource) {\n      throw new Error(\n          'HostResourceLoader: the CompilerHost provided does not support pre-loading resources.');\n    }\n    if (this.cache.has(resolvedUrl)) {\n      return undefined;\n    } else if (this.fetching.has(resolvedUrl)) {\n      return this.fetching.get(resolvedUrl);\n    }\n\n    const result = this.adapter.readResource(resolvedUrl);\n    if (typeof result === 'string') {\n      this.cache.set(resolvedUrl, result);\n      return undefined;\n    } else {\n      const fetchCompletion = result.then(str => {\n        this.fetching.delete(resolvedUrl);\n        this.cache.set(resolvedUrl, str);\n      });\n      this.fetching.set(resolvedUrl, fetchCompletion);\n      return fetchCompletion;\n    }\n  }\n\n  /**\n   * Load the resource at the given url, synchronously.\n   *\n   * The contents of the resource may have been cached by a previous call to `preload()`.\n   *\n   * @param resolvedUrl The url (resolved by a call to `resolve()`) of the resource to load.\n   * @returns The contents of the resource.\n   */\n  load(resolvedUrl: string): string {\n    if (this.cache.has(resolvedUrl)) {\n      return this.cache.get(resolvedUrl)!;\n    }\n\n    const result = this.adapter.readResource ? this.adapter.readResource(resolvedUrl) :\n                                               this.adapter.readFile(resolvedUrl);\n    if (typeof result !== 'string') {\n      throw new Error(`HostResourceLoader: loader(${resolvedUrl}) returned a Promise`);\n    }\n    this.cache.set(resolvedUrl, result);\n    return result;\n  }\n\n  /**\n   * Invalidate the entire resource cache.\n   */\n  invalidate(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Attempt to resolve `url` in the context of `fromFile`, while respecting the rootDirs\n   * option from the tsconfig. First, normalize the file name.\n   */\n  private fallbackResolve(url: string, fromFile: string): string|null {\n    let candidateLocations: string[];\n    if (url.startsWith('/')) {\n      // This path is not really an absolute path, but instead the leading '/' means that it's\n      // rooted in the project rootDirs. So look for it according to the rootDirs.\n      candidateLocations = this.getRootedCandidateLocations(url);\n    } else {\n      // This path is a \"relative\" path and can be resolved as such. To make this easier on the\n      // downstream resolver, the './' prefix is added if missing to distinguish these paths from\n      // absolute node_modules paths.\n      if (!url.startsWith('.')) {\n        url = `./${url}`;\n      }\n      candidateLocations = this.getResolvedCandidateLocations(url, fromFile);\n    }\n\n    for (const candidate of candidateLocations) {\n      if (this.adapter.fileExists(candidate)) {\n        return candidate;\n      } else if (CSS_PREPROCESSOR_EXT.test(candidate)) {\n        /**\n         * If the user specified styleUrl points to *.scss, but the Sass compiler was run before\n         * Angular, then the resource may have been generated as *.css. Simply try the resolution\n         * again.\n         */\n        const cssFallbackUrl = candidate.replace(CSS_PREPROCESSOR_EXT, '.css');\n        if (this.adapter.fileExists(cssFallbackUrl)) {\n          return cssFallbackUrl;\n        }\n      }\n    }\n    return null;\n  }\n\n  private getRootedCandidateLocations(url: string): AbsoluteFsPath[] {\n    // The path already starts with '/', so add a '.' to make it relative.\n    const segment: PathSegment = ('.' + url) as PathSegment;\n    return this.adapter.rootDirs.map(rootDir => join(rootDir, segment));\n  }\n\n  /**\n   * TypeScript provides utilities to resolve module names, but not resource files (which aren't\n   * a part of the ts.Program). However, TypeScript's module resolution can be used creatively\n   * to locate where resource files should be expected to exist. Since module resolution returns\n   * a list of file names that were considered, the loader can enumerate the possible locations\n   * for the file by setting up a module resolution for it that will fail.\n   */\n  private getResolvedCandidateLocations(url: string, fromFile: string): string[] {\n    // `failedLookupLocations` is in the name of the type ts.ResolvedModuleWithFailedLookupLocations\n    // but is marked @internal in TypeScript. See\n    // https://github.com/Microsoft/TypeScript/issues/28770.\n    type ResolvedModuleWithFailedLookupLocations =\n        ts.ResolvedModuleWithFailedLookupLocations&{failedLookupLocations: ReadonlyArray<string>};\n\n    // clang-format off\n    const failedLookup = ts.resolveModuleName(url + RESOURCE_MARKER, fromFile, this.options, this.lookupResolutionHost) as ResolvedModuleWithFailedLookupLocations;\n    // clang-format on\n    if (failedLookup.failedLookupLocations === undefined) {\n      throw new Error(\n          `Internal error: expected to find failedLookupLocations during resolution of resource '${\n              url}' in context of ${fromFile}`);\n    }\n\n    return failedLookup.failedLookupLocations\n        .filter(candidate => candidate.endsWith(RESOURCE_MARKER_TS))\n        .map(candidate => candidate.slice(0, -RESOURCE_MARKER_TS.length));\n  }\n}\n\n/**\n * Derives a `ts.ModuleResolutionHost` from a compiler adapter that recognizes the special resource\n * marker and does not go to the filesystem for these requests, as they are known not to exist.\n */\nfunction createLookupResolutionHost(adapter: NgCompilerAdapter):\n    RequiredDelegations<ts.ModuleResolutionHost> {\n  return {\n    directoryExists(directoryName: string): boolean {\n      if (directoryName.includes(RESOURCE_MARKER)) {\n        return false;\n      } else if (adapter.directoryExists !== undefined) {\n        return adapter.directoryExists(directoryName);\n      } else {\n        // TypeScript's module resolution logic assumes that the directory exists when no host\n        // implementation is available.\n        return true;\n      }\n    },\n    fileExists(fileName: string): boolean {\n      if (fileName.includes(RESOURCE_MARKER)) {\n        return false;\n      } else {\n        return adapter.fileExists(fileName);\n      }\n    },\n    readFile: adapter.readFile.bind(adapter),\n    getCurrentDirectory: adapter.getCurrentDirectory.bind(adapter),\n    getDirectories: adapter.getDirectories?.bind(adapter),\n    realpath: adapter.realpath?.bind(adapter),\n    trace: adapter.trace?.bind(adapter),\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}