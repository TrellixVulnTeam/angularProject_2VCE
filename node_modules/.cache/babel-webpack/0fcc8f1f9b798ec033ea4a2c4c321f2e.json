{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/diagnostics/translate_diagnostics\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/transformers/api\", \"@angular/compiler-cli/src/transformers/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.translateDiagnostics = void 0;\n\n  var ts = require(\"typescript\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/transformers/api\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/transformers/util\");\n\n  function translateDiagnostics(host, untranslatedDiagnostics) {\n    var ts = [];\n    var ng = [];\n    untranslatedDiagnostics.forEach(function (diagnostic) {\n      if (diagnostic.file && diagnostic.start && util_1.GENERATED_FILES.test(diagnostic.file.fileName)) {\n        // We need to filter out diagnostics about unused functions as\n        // they are in fact referenced by nobody and only serve to surface\n        // type check errors.\n        if (diagnostic.code ===\n        /* ... is declared but never used */\n        6133) {\n          return;\n        }\n\n        var span = sourceSpanOf(host, diagnostic.file, diagnostic.start);\n\n        if (span) {\n          var fileName = span.start.file.url;\n          ng.push({\n            messageText: diagnosticMessageToString(diagnostic.messageText),\n            category: diagnostic.category,\n            span: span,\n            source: api_1.SOURCE,\n            code: api_1.DEFAULT_ERROR_CODE\n          });\n        }\n      } else {\n        ts.push(diagnostic);\n      }\n    });\n    return {\n      ts: ts,\n      ng: ng\n    };\n  }\n\n  exports.translateDiagnostics = translateDiagnostics;\n\n  function sourceSpanOf(host, source, start) {\n    var _a = ts.getLineAndCharacterOfPosition(source, start),\n        line = _a.line,\n        character = _a.character;\n\n    return host.parseSourceSpanOf(source.fileName, line, character);\n  }\n\n  function diagnosticMessageToString(message) {\n    return ts.flattenDiagnosticMessageText(message, '\\n');\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/diagnostics/translate_diagnostics.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAGH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,KAAA,GAAA,OAAA,CAAA,4CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AAMA,WAAgB,oBAAhB,CACI,IADJ,EACyB,uBADzB,EAC8E;AAE5E,QAAM,EAAE,GAAoB,EAA5B;AACA,QAAM,EAAE,GAAiB,EAAzB;AAEA,IAAA,uBAAuB,CAAC,OAAxB,CAAgC,UAAC,UAAD,EAAW;AACzC,UAAI,UAAU,CAAC,IAAX,IAAmB,UAAU,CAAC,KAA9B,IAAuC,MAAA,CAAA,eAAA,CAAgB,IAAhB,CAAqB,UAAU,CAAC,IAAX,CAAgB,QAArC,CAA3C,EAA2F;AACzF;AACA;AACA;AACA,YAAI,UAAU,CAAC,IAAX;AAAoB;AAAqC,YAA7D,EAAmE;AACjE;AACD;;AACD,YAAM,IAAI,GAAG,YAAY,CAAC,IAAD,EAAO,UAAU,CAAC,IAAlB,EAAwB,UAAU,CAAC,KAAnC,CAAzB;;AACA,YAAI,IAAJ,EAAU;AACR,cAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,GAAjC;AACA,UAAA,EAAE,CAAC,IAAH,CAAQ;AACN,YAAA,WAAW,EAAE,yBAAyB,CAAC,UAAU,CAAC,WAAZ,CADhC;AAEN,YAAA,QAAQ,EAAE,UAAU,CAAC,QAFf;AAGN,YAAA,IAAI,EAAA,IAHE;AAIN,YAAA,MAAM,EAAE,KAAA,CAAA,MAJF;AAKN,YAAA,IAAI,EAAE,KAAA,CAAA;AALA,WAAR;AAOD;AACF,OAlBD,MAkBO;AACL,QAAA,EAAE,CAAC,IAAH,CAAQ,UAAR;AACD;AACF,KAtBD;AAuBA,WAAO;AAAC,MAAA,EAAE,EAAA,EAAH;AAAK,MAAA,EAAE,EAAA;AAAP,KAAP;AACD;;AA9BD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA;;AAgCA,WAAS,YAAT,CAAsB,IAAtB,EAA2C,MAA3C,EAAkE,KAAlE,EAA+E;AAEvE,QAAA,EAAA,GAAoB,EAAE,CAAC,6BAAH,CAAiC,MAAjC,EAAyC,KAAzC,CAApB;AAAA,QAAC,IAAI,GAAA,EAAA,CAAA,IAAL;AAAA,QAAO,SAAS,GAAA,EAAA,CAAA,SAAhB;;AACN,WAAO,IAAI,CAAC,iBAAL,CAAuB,MAAM,CAAC,QAA9B,EAAwC,IAAxC,EAA8C,SAA9C,CAAP;AACD;;AAED,WAAS,yBAAT,CAAmC,OAAnC,EAA4E;AAC1E,WAAO,EAAE,CAAC,4BAAH,CAAgC,OAAhC,EAAyC,IAAzC,CAAP;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {DEFAULT_ERROR_CODE, Diagnostic, SOURCE} from '../transformers/api';\nimport {GENERATED_FILES} from '../transformers/util';\n\nexport interface TypeCheckHost {\n  parseSourceSpanOf(fileName: string, line: number, character: number): ParseSourceSpan|null;\n}\n\nexport function translateDiagnostics(\n    host: TypeCheckHost, untranslatedDiagnostics: ReadonlyArray<ts.Diagnostic>):\n    {ts: ts.Diagnostic[], ng: Diagnostic[]} {\n  const ts: ts.Diagnostic[] = [];\n  const ng: Diagnostic[] = [];\n\n  untranslatedDiagnostics.forEach((diagnostic) => {\n    if (diagnostic.file && diagnostic.start && GENERATED_FILES.test(diagnostic.file.fileName)) {\n      // We need to filter out diagnostics about unused functions as\n      // they are in fact referenced by nobody and only serve to surface\n      // type check errors.\n      if (diagnostic.code === /* ... is declared but never used */ 6133) {\n        return;\n      }\n      const span = sourceSpanOf(host, diagnostic.file, diagnostic.start);\n      if (span) {\n        const fileName = span.start.file.url;\n        ng.push({\n          messageText: diagnosticMessageToString(diagnostic.messageText),\n          category: diagnostic.category,\n          span,\n          source: SOURCE,\n          code: DEFAULT_ERROR_CODE\n        });\n      }\n    } else {\n      ts.push(diagnostic);\n    }\n  });\n  return {ts, ng};\n}\n\nfunction sourceSpanOf(host: TypeCheckHost, source: ts.SourceFile, start: number): ParseSourceSpan|\n    null {\n  const {line, character} = ts.getLineAndCharacterOfPosition(source, start);\n  return host.parseSourceSpanOf(source.fileName, line, character);\n}\n\nfunction diagnosticMessageToString(message: ts.DiagnosticMessageChain|string): string {\n  return ts.flattenDiagnosticMessageText(message, '\\n');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}