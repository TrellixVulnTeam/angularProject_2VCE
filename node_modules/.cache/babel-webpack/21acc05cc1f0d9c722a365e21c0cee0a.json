{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/host/esm5_host\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/ngcc/src/utils\", \"@angular/compiler-cli/ngcc/src/host/esm2015_host\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Esm5ReflectionHost = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/utils\");\n\n  var esm2015_host_1 = require(\"@angular/compiler-cli/ngcc/src/host/esm2015_host\");\n  /**\n   * ESM5 packages contain ECMAScript IIFE functions that act like classes. For example:\n   *\n   * ```\n   * var CommonModule = (function () {\n   *  function CommonModule() {\n   *  }\n   *  CommonModule.decorators = [ ... ];\n   *  return CommonModule;\n   * ```\n   *\n   * * \"Classes\" are decorated if they have a static property called `decorators`.\n   * * Members are decorated if there is a matching key on a static property\n   *   called `propDecorators`.\n   * * Constructor parameters decorators are found on an object returned from\n   *   a static method called `ctorParameters`.\n   *\n   */\n\n\n  var Esm5ReflectionHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Esm5ReflectionHost, _super);\n\n    function Esm5ReflectionHost() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    Esm5ReflectionHost.prototype.getBaseClassExpression = function (clazz) {\n      var superBaseClassExpression = _super.prototype.getBaseClassExpression.call(this, clazz);\n\n      if (superBaseClassExpression !== null) {\n        return superBaseClassExpression;\n      }\n\n      var iife = getIifeFn(this.getClassSymbol(clazz));\n      if (iife === null) return null;\n\n      if (iife.parameters.length !== 1 || !isSuperIdentifier(iife.parameters[0].name)) {\n        return null;\n      }\n\n      if (!ts.isCallExpression(iife.parent)) {\n        return null;\n      }\n\n      return iife.parent.arguments[0];\n    };\n    /**\n     * Trace an identifier to its declaration, if possible.\n     *\n     * This method attempts to resolve the declaration of the given identifier, tracing back through\n     * imports and re-exports until the original declaration statement is found. A `Declaration`\n     * object is returned if the original declaration is found, or `null` is returned otherwise.\n     *\n     * In ES5, the implementation of a class is a function expression that is hidden inside an IIFE.\n     * If we are looking for the declaration of the identifier of the inner function expression, we\n     * will get hold of the outer \"class\" variable declaration and return its identifier instead. See\n     * `getClassDeclarationFromInnerFunctionDeclaration()` for more info.\n     *\n     * @param id a TypeScript `ts.Identifier` to trace back to a declaration.\n     *\n     * @returns metadata about the `Declaration` if the original declaration is found, or `null`\n     * otherwise.\n     */\n\n\n    Esm5ReflectionHost.prototype.getDeclarationOfIdentifier = function (id) {\n      var declaration = _super.prototype.getDeclarationOfIdentifier.call(this, id);\n\n      if (declaration === null) {\n        var nonEmittedNorImportedTsHelperDeclaration = utils_1.getTsHelperFnFromIdentifier(id);\n\n        if (nonEmittedNorImportedTsHelperDeclaration !== null) {\n          // No declaration could be found for this identifier and its name matches a known TS helper\n          // function. This can happen if a package is compiled with `noEmitHelpers: true` and\n          // `importHelpers: false` (the default). This is, for example, the case with\n          // `@nativescript/angular@9.0.0-next-2019-11-12-155500-01`.\n          return {\n            kind: 1\n            /* Inline */\n            ,\n            node: id,\n            known: nonEmittedNorImportedTsHelperDeclaration,\n            viaModule: null\n          };\n        }\n      }\n\n      if (declaration === null || declaration.node === null || declaration.known !== null) {\n        return declaration;\n      }\n\n      if (!ts.isVariableDeclaration(declaration.node) || declaration.node.initializer !== undefined || // VariableDeclaration => VariableDeclarationList => VariableStatement => IIFE Block\n      !ts.isBlock(declaration.node.parent.parent.parent)) {\n        return declaration;\n      } // We might have an alias to another variable declaration.\n      // Search the containing iife body for it.\n\n\n      var block = declaration.node.parent.parent.parent;\n      var aliasSymbol = this.checker.getSymbolAtLocation(declaration.node.name);\n\n      for (var i = 0; i < block.statements.length; i++) {\n        var statement = block.statements[i]; // Looking for statement that looks like: `AliasedVariable = OriginalVariable;`\n\n        if (esm2015_host_1.isAssignmentStatement(statement) && ts.isIdentifier(statement.expression.left) && ts.isIdentifier(statement.expression.right) && this.checker.getSymbolAtLocation(statement.expression.left) === aliasSymbol) {\n          return this.getDeclarationOfIdentifier(statement.expression.right);\n        }\n      }\n\n      return declaration;\n    };\n    /**\n     * Parse a function declaration to find the relevant metadata about it.\n     *\n     * In ESM5 we need to do special work with optional arguments to the function, since they get\n     * their own initializer statement that needs to be parsed and then not included in the \"body\"\n     * statements of the function.\n     *\n     * @param node the function declaration to parse.\n     * @returns an object containing the node, statements and parameters of the function.\n     */\n\n\n    Esm5ReflectionHost.prototype.getDefinitionOfFunction = function (node) {\n      var definition = _super.prototype.getDefinitionOfFunction.call(this, node);\n\n      if (definition === null) {\n        return null;\n      } // Filter out and capture parameter initializers\n\n\n      if (definition.body !== null) {\n        var lookingForInitializers_1 = true;\n        var statements = definition.body.filter(function (s) {\n          lookingForInitializers_1 = lookingForInitializers_1 && captureParamInitializer(s, definition.parameters); // If we are no longer looking for parameter initializers then we include this statement\n\n          return !lookingForInitializers_1;\n        });\n        definition.body = statements;\n      }\n\n      return definition;\n    };\n    /**\n     * Check whether a `Declaration` corresponds with a known declaration, such as a TypeScript helper\n     * function, and set its `known` property to the appropriate `KnownDeclaration`.\n     *\n     * @param decl The `Declaration` to check.\n     * @return The passed in `Declaration` (potentially enhanced with a `KnownDeclaration`).\n     */\n\n\n    Esm5ReflectionHost.prototype.detectKnownDeclaration = function (decl) {\n      decl = _super.prototype.detectKnownDeclaration.call(this, decl); // Also check for TS helpers\n\n      if (decl.known === null && decl.node !== null) {\n        decl.known = utils_1.getTsHelperFnFromDeclaration(decl.node);\n      }\n\n      return decl;\n    }; ///////////// Protected Helpers /////////////\n\n    /**\n     * In ES5, the implementation of a class is a function expression that is hidden inside an IIFE,\n     * whose value is assigned to a variable (which represents the class to the rest of the program).\n     * So we might need to dig around to get hold of the \"class\" declaration.\n     *\n     * This method extracts a `NgccClassSymbol` if `declaration` is the function declaration inside\n     * the IIFE. Otherwise, undefined is returned.\n     *\n     * @param declaration the declaration whose symbol we are finding.\n     * @returns the symbol for the node or `undefined` if it is not a \"class\" or has no symbol.\n     */\n\n\n    Esm5ReflectionHost.prototype.getClassSymbolFromInnerDeclaration = function (declaration) {\n      var classSymbol = _super.prototype.getClassSymbolFromInnerDeclaration.call(this, declaration);\n\n      if (classSymbol !== undefined) {\n        return classSymbol;\n      }\n\n      if (!reflection_1.isNamedFunctionDeclaration(declaration)) {\n        return undefined;\n      }\n\n      var outerNode = esm2015_host_1.getOuterNodeFromInnerDeclaration(declaration);\n\n      if (outerNode === null || !utils_1.hasNameIdentifier(outerNode)) {\n        return undefined;\n      }\n\n      return this.createClassSymbol(outerNode.name, declaration);\n    };\n    /**\n     * Find the declarations of the constructor parameters of a class identified by its symbol.\n     *\n     * In ESM5, there is no \"class\" so the constructor that we want is actually the inner function\n     * declaration inside the IIFE, whose return value is assigned to the outer variable declaration\n     * (that represents the class to the rest of the program).\n     *\n     * @param classSymbol the symbol of the class (i.e. the outer variable declaration) whose\n     * parameters we want to find.\n     * @returns an array of `ts.ParameterDeclaration` objects representing each of the parameters in\n     * the class's constructor or `null` if there is no constructor.\n     */\n\n\n    Esm5ReflectionHost.prototype.getConstructorParameterDeclarations = function (classSymbol) {\n      var constructor = classSymbol.implementation.valueDeclaration;\n      if (!ts.isFunctionDeclaration(constructor)) return null;\n\n      if (constructor.parameters.length > 0) {\n        return Array.from(constructor.parameters);\n      }\n\n      if (this.isSynthesizedConstructor(constructor)) {\n        return null;\n      }\n\n      return [];\n    };\n    /**\n     * Get the parameter type and decorators for the constructor of a class,\n     * where the information is stored on a static method of the class.\n     *\n     * In this case the decorators are stored in the body of a method\n     * (`ctorParatemers`) attached to the constructor function.\n     *\n     * Note that unlike ESM2015 this is a function expression rather than an arrow\n     * function:\n     *\n     * ```\n     * SomeDirective.ctorParameters = function() { return [\n     *   { type: ViewContainerRef, },\n     *   { type: TemplateRef, },\n     *   { type: IterableDiffers, },\n     *   { type: undefined, decorators: [{ type: Inject, args: [INJECTED_TOKEN,] },] },\n     * ]; };\n     * ```\n     *\n     * @param paramDecoratorsProperty the property that holds the parameter info we want to get.\n     * @returns an array of objects containing the type and decorators for each parameter.\n     */\n\n\n    Esm5ReflectionHost.prototype.getParamInfoFromStaticProperty = function (paramDecoratorsProperty) {\n      var _this = this;\n\n      var paramDecorators = esm2015_host_1.getPropertyValueFromSymbol(paramDecoratorsProperty); // The decorators array may be wrapped in a function. If so unwrap it.\n\n      var returnStatement = getReturnStatement(paramDecorators);\n      var expression = returnStatement ? returnStatement.expression : paramDecorators;\n\n      if (expression && ts.isArrayLiteralExpression(expression)) {\n        var elements = expression.elements;\n        return elements.map(reflectArrayElement).map(function (paramInfo) {\n          var typeExpression = paramInfo && paramInfo.has('type') ? paramInfo.get('type') : null;\n          var decoratorInfo = paramInfo && paramInfo.has('decorators') ? paramInfo.get('decorators') : null;\n\n          var decorators = decoratorInfo && _this.reflectDecorators(decoratorInfo);\n\n          return {\n            typeExpression: typeExpression,\n            decorators: decorators\n          };\n        });\n      } else if (paramDecorators !== undefined) {\n        this.logger.warn('Invalid constructor parameter decorator in ' + paramDecorators.getSourceFile().fileName + ':\\n', paramDecorators.getText());\n      }\n\n      return null;\n    };\n    /**\n     * Reflect over a symbol and extract the member information, combining it with the\n     * provided decorator information, and whether it is a static member.\n     *\n     * If a class member uses accessors (e.g getters and/or setters) then it gets downleveled\n     * in ES5 to a single `Object.defineProperty()` call. In that case we must parse this\n     * call to extract the one or two ClassMember objects that represent the accessors.\n     *\n     * @param symbol the symbol for the member to reflect over.\n     * @param decorators an array of decorators associated with the member.\n     * @param isStatic true if this member is static, false if it is an instance property.\n     * @returns the reflected member information, or null if the symbol is not a member.\n     */\n\n\n    Esm5ReflectionHost.prototype.reflectMembers = function (symbol, decorators, isStatic) {\n      var node = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];\n      var propertyDefinition = node && getPropertyDefinition(node);\n\n      if (propertyDefinition) {\n        var members_1 = [];\n\n        if (propertyDefinition.setter) {\n          members_1.push({\n            node: node,\n            implementation: propertyDefinition.setter,\n            kind: reflection_1.ClassMemberKind.Setter,\n            type: null,\n            name: symbol.name,\n            nameNode: null,\n            value: null,\n            isStatic: isStatic || false,\n            decorators: decorators || []\n          }); // Prevent attaching the decorators to a potential getter. In ES5, we can't tell where the\n          // decorators were originally attached to, however we only want to attach them to a single\n          // `ClassMember` as otherwise ngtsc would handle the same decorators twice.\n\n          decorators = undefined;\n        }\n\n        if (propertyDefinition.getter) {\n          members_1.push({\n            node: node,\n            implementation: propertyDefinition.getter,\n            kind: reflection_1.ClassMemberKind.Getter,\n            type: null,\n            name: symbol.name,\n            nameNode: null,\n            value: null,\n            isStatic: isStatic || false,\n            decorators: decorators || []\n          });\n        }\n\n        return members_1;\n      }\n\n      var members = _super.prototype.reflectMembers.call(this, symbol, decorators, isStatic);\n\n      members && members.forEach(function (member) {\n        if (member && member.kind === reflection_1.ClassMemberKind.Method && member.isStatic && member.node && ts.isPropertyAccessExpression(member.node) && member.node.parent && ts.isBinaryExpression(member.node.parent) && ts.isFunctionExpression(member.node.parent.right)) {\n          // Recompute the implementation for this member:\n          // ES5 static methods are variable declarations so the declaration is actually the\n          // initializer of the variable assignment\n          member.implementation = member.node.parent.right;\n        }\n      });\n      return members;\n    };\n    /**\n     * Find statements related to the given class that may contain calls to a helper.\n     *\n     * In ESM5 code the helper calls are hidden inside the class's IIFE.\n     *\n     * @param classSymbol the class whose helper calls we are interested in. We expect this symbol\n     * to reference the inner identifier inside the IIFE.\n     * @returns an array of statements that may contain helper calls.\n     */\n\n\n    Esm5ReflectionHost.prototype.getStatementsForClass = function (classSymbol) {\n      var classDeclarationParent = classSymbol.implementation.valueDeclaration.parent;\n      return ts.isBlock(classDeclarationParent) ? Array.from(classDeclarationParent.statements) : [];\n    }; ///////////// Host Private Helpers /////////////\n\n    /**\n     * A constructor function may have been \"synthesized\" by TypeScript during JavaScript emit,\n     * in the case no user-defined constructor exists and e.g. property initializers are used.\n     * Those initializers need to be emitted into a constructor in JavaScript, so the TypeScript\n     * compiler generates a synthetic constructor.\n     *\n     * We need to identify such constructors as ngcc needs to be able to tell if a class did\n     * originally have a constructor in the TypeScript source. For ES5, we can not tell an\n     * empty constructor apart from a synthesized constructor, but fortunately that does not\n     * matter for the code generated by ngtsc.\n     *\n     * When a class has a superclass however, a synthesized constructor must not be considered\n     * as a user-defined constructor as that prevents a base factory call from being created by\n     * ngtsc, resulting in a factory function that does not inject the dependencies of the\n     * superclass. Hence, we identify a default synthesized super call in the constructor body,\n     * according to the structure that TypeScript's ES2015 to ES5 transformer generates in\n     * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1082-L1098\n     *\n     * Additionally, we handle synthetic delegate constructors that are emitted when TypeScript\n     * downlevel's ES2015 synthetically generated to ES5. These vary slightly from the default\n     * structure mentioned above because the ES2015 output uses a spread operator, for delegating\n     * to the parent constructor, that is preserved through a TypeScript helper in ES5. e.g.\n     *\n     * ```\n     * return _super.apply(this, tslib.__spread(arguments)) || this;\n     * ```\n     *\n     * Such constructs can be still considered as synthetic delegate constructors as they are\n     * the product of a common TypeScript to ES5 synthetic constructor, just being downleveled\n     * to ES5 using `tsc`. See: https://github.com/angular/angular/issues/38453.\n     *\n     *\n     * @param constructor a constructor function to test\n     * @returns true if the constructor appears to have been synthesized\n     */\n\n\n    Esm5ReflectionHost.prototype.isSynthesizedConstructor = function (constructor) {\n      if (!constructor.body) return false;\n      var firstStatement = constructor.body.statements[0];\n      if (!firstStatement) return false;\n      return this.isSynthesizedSuperThisAssignment(firstStatement) || this.isSynthesizedSuperReturnStatement(firstStatement);\n    };\n    /**\n     * Identifies synthesized super calls which pass-through function arguments directly and are\n     * being assigned to a common `_this` variable. The following patterns we intend to match:\n     *\n     * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n     *   ```\n     *   var _this = _super !== null && _super.apply(this, arguments) || this;\n     *   ```\n     *\n     * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n     *   ```\n     *   var _this = _super.apply(this, tslib.__spread(arguments)) || this;\n     *   ```\n     *\n     *\n     * @param statement a statement that may be a synthesized super call\n     * @returns true if the statement looks like a synthesized super call\n     */\n\n\n    Esm5ReflectionHost.prototype.isSynthesizedSuperThisAssignment = function (statement) {\n      if (!ts.isVariableStatement(statement)) return false;\n      var variableDeclarations = statement.declarationList.declarations;\n      if (variableDeclarations.length !== 1) return false;\n      var variableDeclaration = variableDeclarations[0];\n      if (!ts.isIdentifier(variableDeclaration.name) || !variableDeclaration.name.text.startsWith('_this')) return false;\n      var initializer = variableDeclaration.initializer;\n      if (!initializer) return false;\n      return this.isSynthesizedDefaultSuperCall(initializer);\n    };\n    /**\n     * Identifies synthesized super calls which pass-through function arguments directly and\n     * are being returned. The following patterns correspond to synthetic super return calls:\n     *\n     * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n     *   ```\n     *   return _super !== null && _super.apply(this, arguments) || this;\n     *   ```\n     *\n     * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n     *   ```\n     *   return _super.apply(this, tslib.__spread(arguments)) || this;\n     *   ```\n     *\n     * @param statement a statement that may be a synthesized super call\n     * @returns true if the statement looks like a synthesized super call\n     */\n\n\n    Esm5ReflectionHost.prototype.isSynthesizedSuperReturnStatement = function (statement) {\n      if (!ts.isReturnStatement(statement)) return false;\n      var expression = statement.expression;\n      if (!expression) return false;\n      return this.isSynthesizedDefaultSuperCall(expression);\n    };\n    /**\n     * Identifies synthesized super calls which pass-through function arguments directly. The\n     * synthetic delegate super call match the following patterns we intend to match:\n     *\n     * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n     *   ```\n     *   _super !== null && _super.apply(this, arguments) || this;\n     *   ```\n     *\n     * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n     *   ```\n     *   _super.apply(this, tslib.__spread(arguments)) || this;\n     *   ```\n     *\n     * @param expression an expression that may represent a default super call\n     * @returns true if the expression corresponds with the above form\n     */\n\n\n    Esm5ReflectionHost.prototype.isSynthesizedDefaultSuperCall = function (expression) {\n      if (!isBinaryExpr(expression, ts.SyntaxKind.BarBarToken)) return false;\n      if (expression.right.kind !== ts.SyntaxKind.ThisKeyword) return false;\n      var left = expression.left;\n\n      if (isBinaryExpr(left, ts.SyntaxKind.AmpersandAmpersandToken)) {\n        return isSuperNotNull(left.left) && this.isSuperApplyCall(left.right);\n      } else {\n        return this.isSuperApplyCall(left);\n      }\n    };\n    /**\n     * Tests whether the expression corresponds to a `super` call passing through\n     * function arguments without any modification. e.g.\n     *\n     * ```\n     * _super !== null && _super.apply(this, arguments) || this;\n     * ```\n     *\n     * This structure is generated by TypeScript when transforming ES2015 to ES5, see\n     * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1148-L1163\n     *\n     * Additionally, we also handle cases where `arguments` are wrapped by a TypeScript spread helper.\n     * This can happen if ES2015 class output contain auto-generated constructors due to class\n     * members. The ES2015 output will be using `super(...arguments)` to delegate to the superclass,\n     * but once downleveled to ES5, the spread operator will be persisted through a TypeScript spread\n     * helper. For example:\n     *\n     * ```\n     * _super.apply(this, __spread(arguments)) || this;\n     * ```\n     *\n     * More details can be found in: https://github.com/angular/angular/issues/38453.\n     *\n     * @param expression an expression that may represent a default super call\n     * @returns true if the expression corresponds with the above form\n     */\n\n\n    Esm5ReflectionHost.prototype.isSuperApplyCall = function (expression) {\n      if (!ts.isCallExpression(expression) || expression.arguments.length !== 2) return false;\n      var targetFn = expression.expression;\n      if (!ts.isPropertyAccessExpression(targetFn)) return false;\n      if (!isSuperIdentifier(targetFn.expression)) return false;\n      if (targetFn.name.text !== 'apply') return false;\n      var thisArgument = expression.arguments[0];\n      if (thisArgument.kind !== ts.SyntaxKind.ThisKeyword) return false;\n      var argumentsExpr = expression.arguments[1]; // If the super is directly invoked with `arguments`, return `true`. This represents the\n      // common TypeScript output where the delegate constructor super call matches the following\n      // pattern: `super.apply(this, arguments)`.\n\n      if (isArgumentsIdentifier(argumentsExpr)) {\n        return true;\n      } // The other scenario we intend to detect: The `arguments` variable might be wrapped with the\n      // TypeScript spread helper (either through tslib or inlined). This can happen if an explicit\n      // delegate constructor uses `super(...arguments)` in ES2015 and is downleveled to ES5 using\n      // `--downlevelIteration`. The output in such cases would not directly pass the function\n      // `arguments` to the `super` call, but wrap it in a TS spread helper. The output would match\n      // the following pattern: `super.apply(this, tslib.__spread(arguments))`. We check for such\n      // constructs below, but perform the detection of the call expression definition as last as\n      // that is the most expensive operation here.\n\n\n      if (!ts.isCallExpression(argumentsExpr) || argumentsExpr.arguments.length !== 1 || !isArgumentsIdentifier(argumentsExpr.arguments[0])) {\n        return false;\n      }\n\n      var argumentsCallExpr = argumentsExpr.expression;\n      var argumentsCallDeclaration = null; // The `__spread` helper could be globally available, or accessed through a namespaced\n      // import. Hence we support a property access here as long as it resolves to the actual\n      // known TypeScript spread helper.\n\n      if (ts.isIdentifier(argumentsCallExpr)) {\n        argumentsCallDeclaration = this.getDeclarationOfIdentifier(argumentsCallExpr);\n      } else if (ts.isPropertyAccessExpression(argumentsCallExpr) && ts.isIdentifier(argumentsCallExpr.name)) {\n        argumentsCallDeclaration = this.getDeclarationOfIdentifier(argumentsCallExpr.name);\n      }\n\n      return argumentsCallDeclaration !== null && argumentsCallDeclaration.known === reflection_1.KnownDeclaration.TsHelperSpread;\n    };\n\n    return Esm5ReflectionHost;\n  }(esm2015_host_1.Esm2015ReflectionHost);\n\n  exports.Esm5ReflectionHost = Esm5ReflectionHost;\n  /**\n   * In ES5, getters and setters have been downleveled into call expressions of\n   * `Object.defineProperty`, such as\n   *\n   * ```\n   * Object.defineProperty(Clazz.prototype, \"property\", {\n   *   get: function () {\n   *       return 'value';\n   *   },\n   *   set: function (value) {\n   *       this.value = value;\n   *   },\n   *   enumerable: true,\n   *   configurable: true\n   * });\n   * ```\n   *\n   * This function inspects the given node to determine if it corresponds with such a call, and if so\n   * extracts the `set` and `get` function expressions from the descriptor object, if they exist.\n   *\n   * @param node The node to obtain the property definition from.\n   * @returns The property definition if the node corresponds with accessor, null otherwise.\n   */\n\n  function getPropertyDefinition(node) {\n    if (!ts.isCallExpression(node)) return null;\n    var fn = node.expression;\n    if (!ts.isPropertyAccessExpression(fn) || !ts.isIdentifier(fn.expression) || fn.expression.text !== 'Object' || fn.name.text !== 'defineProperty') return null;\n    var descriptor = node.arguments[2];\n    if (!descriptor || !ts.isObjectLiteralExpression(descriptor)) return null;\n    return {\n      setter: readPropertyFunctionExpression(descriptor, 'set'),\n      getter: readPropertyFunctionExpression(descriptor, 'get')\n    };\n  }\n\n  function readPropertyFunctionExpression(object, name) {\n    var property = object.properties.find(function (p) {\n      return ts.isPropertyAssignment(p) && ts.isIdentifier(p.name) && p.name.text === name;\n    });\n    return property && ts.isFunctionExpression(property.initializer) && property.initializer || null;\n  }\n\n  function getReturnStatement(declaration) {\n    return declaration && ts.isFunctionExpression(declaration) ? declaration.body.statements.find(ts.isReturnStatement) : undefined;\n  }\n\n  function reflectArrayElement(element) {\n    return ts.isObjectLiteralExpression(element) ? reflection_1.reflectObjectLiteral(element) : null;\n  }\n\n  function isArgumentsIdentifier(expression) {\n    return ts.isIdentifier(expression) && expression.text === 'arguments';\n  }\n\n  function isSuperNotNull(expression) {\n    return isBinaryExpr(expression, ts.SyntaxKind.ExclamationEqualsEqualsToken) && isSuperIdentifier(expression.left);\n  }\n\n  function isBinaryExpr(expression, operator) {\n    return ts.isBinaryExpression(expression) && expression.operatorToken.kind === operator;\n  }\n\n  function isSuperIdentifier(node) {\n    // Verify that the identifier is prefixed with `_super`. We don't test for equivalence\n    // as TypeScript may have suffixed the name, e.g. `_super_1` to avoid name conflicts.\n    // Requiring only a prefix should be sufficiently accurate.\n    return ts.isIdentifier(node) && node.text.startsWith('_super');\n  }\n  /**\n   * Parse the statement to extract the ESM5 parameter initializer if there is one.\n   * If one is found, add it to the appropriate parameter in the `parameters` collection.\n   *\n   * The form we are looking for is:\n   *\n   * ```\n   * if (arg === void 0) { arg = initializer; }\n   * ```\n   *\n   * @param statement a statement that may be initializing an optional parameter\n   * @param parameters the collection of parameters that were found in the function definition\n   * @returns true if the statement was a parameter initializer\n   */\n\n\n  function captureParamInitializer(statement, parameters) {\n    if (ts.isIfStatement(statement) && isUndefinedComparison(statement.expression) && ts.isBlock(statement.thenStatement) && statement.thenStatement.statements.length === 1) {\n      var ifStatementComparison = statement.expression; // (arg === void 0)\n\n      var thenStatement = statement.thenStatement.statements[0]; // arg = initializer;\n\n      if (esm2015_host_1.isAssignmentStatement(thenStatement)) {\n        var comparisonName_1 = ifStatementComparison.left.text;\n        var assignmentName = thenStatement.expression.left.text;\n\n        if (comparisonName_1 === assignmentName) {\n          var parameter = parameters.find(function (p) {\n            return p.name === comparisonName_1;\n          });\n\n          if (parameter) {\n            parameter.initializer = thenStatement.expression.right;\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function isUndefinedComparison(expression) {\n    return ts.isBinaryExpression(expression) && expression.operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken && ts.isVoidExpression(expression.right) && ts.isIdentifier(expression.left);\n  }\n  /**\n   * Parse the declaration of the given `classSymbol` to find the IIFE wrapper function.\n   *\n   * This function may accept a `_super` argument if there is a base class.\n   *\n   * ```\n   * var TestClass = (function (_super) {\n   *   __extends(TestClass, _super);\n   *   function TestClass() {}\n   *   return TestClass;\n   * }(BaseClass));\n   * ```\n   *\n   * @param classSymbol the class whose iife wrapper function we want to get.\n   * @returns the IIFE function or null if it could not be parsed.\n   */\n\n\n  function getIifeFn(classSymbol) {\n    if (classSymbol === undefined) {\n      return null;\n    }\n\n    var innerDeclaration = classSymbol.implementation.valueDeclaration;\n    var iifeBody = innerDeclaration.parent;\n\n    if (!ts.isBlock(iifeBody)) {\n      return null;\n    }\n\n    var iifeWrapper = iifeBody.parent;\n    return iifeWrapper && ts.isFunctionExpression(iifeWrapper) ? iifeWrapper : null;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/host/esm5_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ClassDeclaration, ClassMember, ClassMemberKind, Declaration, DeclarationKind, Decorator, FunctionDefinition, isNamedFunctionDeclaration, KnownDeclaration, Parameter, reflectObjectLiteral} from '../../../src/ngtsc/reflection';\nimport {getTsHelperFnFromDeclaration, getTsHelperFnFromIdentifier, hasNameIdentifier} from '../utils';\n\nimport {Esm2015ReflectionHost, getOuterNodeFromInnerDeclaration, getPropertyValueFromSymbol, isAssignmentStatement, ParamInfo} from './esm2015_host';\nimport {NgccClassSymbol} from './ngcc_host';\n\n\n/**\n * ESM5 packages contain ECMAScript IIFE functions that act like classes. For example:\n *\n * ```\n * var CommonModule = (function () {\n *  function CommonModule() {\n *  }\n *  CommonModule.decorators = [ ... ];\n *  return CommonModule;\n * ```\n *\n * * \"Classes\" are decorated if they have a static property called `decorators`.\n * * Members are decorated if there is a matching key on a static property\n *   called `propDecorators`.\n * * Constructor parameters decorators are found on an object returned from\n *   a static method called `ctorParameters`.\n *\n */\nexport class Esm5ReflectionHost extends Esm2015ReflectionHost {\n  getBaseClassExpression(clazz: ClassDeclaration): ts.Expression|null {\n    const superBaseClassExpression = super.getBaseClassExpression(clazz);\n    if (superBaseClassExpression !== null) {\n      return superBaseClassExpression;\n    }\n\n    const iife = getIifeFn(this.getClassSymbol(clazz));\n    if (iife === null) return null;\n\n    if (iife.parameters.length !== 1 || !isSuperIdentifier(iife.parameters[0].name)) {\n      return null;\n    }\n\n    if (!ts.isCallExpression(iife.parent)) {\n      return null;\n    }\n\n    return iife.parent.arguments[0];\n  }\n\n  /**\n   * Trace an identifier to its declaration, if possible.\n   *\n   * This method attempts to resolve the declaration of the given identifier, tracing back through\n   * imports and re-exports until the original declaration statement is found. A `Declaration`\n   * object is returned if the original declaration is found, or `null` is returned otherwise.\n   *\n   * In ES5, the implementation of a class is a function expression that is hidden inside an IIFE.\n   * If we are looking for the declaration of the identifier of the inner function expression, we\n   * will get hold of the outer \"class\" variable declaration and return its identifier instead. See\n   * `getClassDeclarationFromInnerFunctionDeclaration()` for more info.\n   *\n   * @param id a TypeScript `ts.Identifier` to trace back to a declaration.\n   *\n   * @returns metadata about the `Declaration` if the original declaration is found, or `null`\n   * otherwise.\n   */\n  getDeclarationOfIdentifier(id: ts.Identifier): Declaration|null {\n    const declaration = super.getDeclarationOfIdentifier(id);\n\n    if (declaration === null) {\n      const nonEmittedNorImportedTsHelperDeclaration = getTsHelperFnFromIdentifier(id);\n      if (nonEmittedNorImportedTsHelperDeclaration !== null) {\n        // No declaration could be found for this identifier and its name matches a known TS helper\n        // function. This can happen if a package is compiled with `noEmitHelpers: true` and\n        // `importHelpers: false` (the default). This is, for example, the case with\n        // `@nativescript/angular@9.0.0-next-2019-11-12-155500-01`.\n        return {\n          kind: DeclarationKind.Inline,\n          node: id,\n          known: nonEmittedNorImportedTsHelperDeclaration,\n          viaModule: null,\n        };\n      }\n    }\n\n    if (declaration === null || declaration.node === null || declaration.known !== null) {\n      return declaration;\n    }\n\n    if (!ts.isVariableDeclaration(declaration.node) || declaration.node.initializer !== undefined ||\n        // VariableDeclaration => VariableDeclarationList => VariableStatement => IIFE Block\n        !ts.isBlock(declaration.node.parent.parent.parent)) {\n      return declaration;\n    }\n\n    // We might have an alias to another variable declaration.\n    // Search the containing iife body for it.\n    const block = declaration.node.parent.parent.parent;\n    const aliasSymbol = this.checker.getSymbolAtLocation(declaration.node.name);\n    for (let i = 0; i < block.statements.length; i++) {\n      const statement = block.statements[i];\n      // Looking for statement that looks like: `AliasedVariable = OriginalVariable;`\n      if (isAssignmentStatement(statement) && ts.isIdentifier(statement.expression.left) &&\n          ts.isIdentifier(statement.expression.right) &&\n          this.checker.getSymbolAtLocation(statement.expression.left) === aliasSymbol) {\n        return this.getDeclarationOfIdentifier(statement.expression.right);\n      }\n    }\n\n    return declaration;\n  }\n\n  /**\n   * Parse a function declaration to find the relevant metadata about it.\n   *\n   * In ESM5 we need to do special work with optional arguments to the function, since they get\n   * their own initializer statement that needs to be parsed and then not included in the \"body\"\n   * statements of the function.\n   *\n   * @param node the function declaration to parse.\n   * @returns an object containing the node, statements and parameters of the function.\n   */\n  getDefinitionOfFunction(node: ts.Node): FunctionDefinition|null {\n    const definition = super.getDefinitionOfFunction(node);\n    if (definition === null) {\n      return null;\n    }\n\n    // Filter out and capture parameter initializers\n    if (definition.body !== null) {\n      let lookingForInitializers = true;\n      const statements = definition.body.filter(s => {\n        lookingForInitializers =\n            lookingForInitializers && captureParamInitializer(s, definition.parameters);\n        // If we are no longer looking for parameter initializers then we include this statement\n        return !lookingForInitializers;\n      });\n      definition.body = statements;\n    }\n\n    return definition;\n  }\n\n  /**\n   * Check whether a `Declaration` corresponds with a known declaration, such as a TypeScript helper\n   * function, and set its `known` property to the appropriate `KnownDeclaration`.\n   *\n   * @param decl The `Declaration` to check.\n   * @return The passed in `Declaration` (potentially enhanced with a `KnownDeclaration`).\n   */\n  detectKnownDeclaration<T extends Declaration>(decl: T): T {\n    decl = super.detectKnownDeclaration(decl);\n\n    // Also check for TS helpers\n    if (decl.known === null && decl.node !== null) {\n      decl.known = getTsHelperFnFromDeclaration(decl.node);\n    }\n\n    return decl;\n  }\n\n\n  ///////////// Protected Helpers /////////////\n\n  /**\n   * In ES5, the implementation of a class is a function expression that is hidden inside an IIFE,\n   * whose value is assigned to a variable (which represents the class to the rest of the program).\n   * So we might need to dig around to get hold of the \"class\" declaration.\n   *\n   * This method extracts a `NgccClassSymbol` if `declaration` is the function declaration inside\n   * the IIFE. Otherwise, undefined is returned.\n   *\n   * @param declaration the declaration whose symbol we are finding.\n   * @returns the symbol for the node or `undefined` if it is not a \"class\" or has no symbol.\n   */\n  protected getClassSymbolFromInnerDeclaration(declaration: ts.Node): NgccClassSymbol|undefined {\n    const classSymbol = super.getClassSymbolFromInnerDeclaration(declaration);\n    if (classSymbol !== undefined) {\n      return classSymbol;\n    }\n\n    if (!isNamedFunctionDeclaration(declaration)) {\n      return undefined;\n    }\n\n    const outerNode = getOuterNodeFromInnerDeclaration(declaration);\n    if (outerNode === null || !hasNameIdentifier(outerNode)) {\n      return undefined;\n    }\n\n    return this.createClassSymbol(outerNode.name, declaration);\n  }\n\n  /**\n   * Find the declarations of the constructor parameters of a class identified by its symbol.\n   *\n   * In ESM5, there is no \"class\" so the constructor that we want is actually the inner function\n   * declaration inside the IIFE, whose return value is assigned to the outer variable declaration\n   * (that represents the class to the rest of the program).\n   *\n   * @param classSymbol the symbol of the class (i.e. the outer variable declaration) whose\n   * parameters we want to find.\n   * @returns an array of `ts.ParameterDeclaration` objects representing each of the parameters in\n   * the class's constructor or `null` if there is no constructor.\n   */\n  protected getConstructorParameterDeclarations(classSymbol: NgccClassSymbol):\n      ts.ParameterDeclaration[]|null {\n    const constructor = classSymbol.implementation.valueDeclaration;\n    if (!ts.isFunctionDeclaration(constructor)) return null;\n\n    if (constructor.parameters.length > 0) {\n      return Array.from(constructor.parameters);\n    }\n\n    if (this.isSynthesizedConstructor(constructor)) {\n      return null;\n    }\n\n    return [];\n  }\n\n  /**\n   * Get the parameter type and decorators for the constructor of a class,\n   * where the information is stored on a static method of the class.\n   *\n   * In this case the decorators are stored in the body of a method\n   * (`ctorParatemers`) attached to the constructor function.\n   *\n   * Note that unlike ESM2015 this is a function expression rather than an arrow\n   * function:\n   *\n   * ```\n   * SomeDirective.ctorParameters = function() { return [\n   *   { type: ViewContainerRef, },\n   *   { type: TemplateRef, },\n   *   { type: IterableDiffers, },\n   *   { type: undefined, decorators: [{ type: Inject, args: [INJECTED_TOKEN,] },] },\n   * ]; };\n   * ```\n   *\n   * @param paramDecoratorsProperty the property that holds the parameter info we want to get.\n   * @returns an array of objects containing the type and decorators for each parameter.\n   */\n  protected getParamInfoFromStaticProperty(paramDecoratorsProperty: ts.Symbol): ParamInfo[]|null {\n    const paramDecorators = getPropertyValueFromSymbol(paramDecoratorsProperty);\n    // The decorators array may be wrapped in a function. If so unwrap it.\n    const returnStatement = getReturnStatement(paramDecorators);\n    const expression = returnStatement ? returnStatement.expression : paramDecorators;\n    if (expression && ts.isArrayLiteralExpression(expression)) {\n      const elements = expression.elements;\n      return elements.map(reflectArrayElement).map(paramInfo => {\n        const typeExpression = paramInfo && paramInfo.has('type') ? paramInfo.get('type')! : null;\n        const decoratorInfo =\n            paramInfo && paramInfo.has('decorators') ? paramInfo.get('decorators')! : null;\n        const decorators = decoratorInfo && this.reflectDecorators(decoratorInfo);\n        return {typeExpression, decorators};\n      });\n    } else if (paramDecorators !== undefined) {\n      this.logger.warn(\n          'Invalid constructor parameter decorator in ' + paramDecorators.getSourceFile().fileName +\n              ':\\n',\n          paramDecorators.getText());\n    }\n    return null;\n  }\n\n  /**\n   * Reflect over a symbol and extract the member information, combining it with the\n   * provided decorator information, and whether it is a static member.\n   *\n   * If a class member uses accessors (e.g getters and/or setters) then it gets downleveled\n   * in ES5 to a single `Object.defineProperty()` call. In that case we must parse this\n   * call to extract the one or two ClassMember objects that represent the accessors.\n   *\n   * @param symbol the symbol for the member to reflect over.\n   * @param decorators an array of decorators associated with the member.\n   * @param isStatic true if this member is static, false if it is an instance property.\n   * @returns the reflected member information, or null if the symbol is not a member.\n   */\n  protected reflectMembers(symbol: ts.Symbol, decorators?: Decorator[], isStatic?: boolean):\n      ClassMember[]|null {\n    const node = symbol.valueDeclaration || symbol.declarations && symbol.declarations[0];\n    const propertyDefinition = node && getPropertyDefinition(node);\n    if (propertyDefinition) {\n      const members: ClassMember[] = [];\n      if (propertyDefinition.setter) {\n        members.push({\n          node,\n          implementation: propertyDefinition.setter,\n          kind: ClassMemberKind.Setter,\n          type: null,\n          name: symbol.name,\n          nameNode: null,\n          value: null,\n          isStatic: isStatic || false,\n          decorators: decorators || [],\n        });\n\n        // Prevent attaching the decorators to a potential getter. In ES5, we can't tell where the\n        // decorators were originally attached to, however we only want to attach them to a single\n        // `ClassMember` as otherwise ngtsc would handle the same decorators twice.\n        decorators = undefined;\n      }\n      if (propertyDefinition.getter) {\n        members.push({\n          node,\n          implementation: propertyDefinition.getter,\n          kind: ClassMemberKind.Getter,\n          type: null,\n          name: symbol.name,\n          nameNode: null,\n          value: null,\n          isStatic: isStatic || false,\n          decorators: decorators || [],\n        });\n      }\n      return members;\n    }\n\n    const members = super.reflectMembers(symbol, decorators, isStatic);\n    members && members.forEach(member => {\n      if (member && member.kind === ClassMemberKind.Method && member.isStatic && member.node &&\n          ts.isPropertyAccessExpression(member.node) && member.node.parent &&\n          ts.isBinaryExpression(member.node.parent) &&\n          ts.isFunctionExpression(member.node.parent.right)) {\n        // Recompute the implementation for this member:\n        // ES5 static methods are variable declarations so the declaration is actually the\n        // initializer of the variable assignment\n        member.implementation = member.node.parent.right;\n      }\n    });\n    return members;\n  }\n\n  /**\n   * Find statements related to the given class that may contain calls to a helper.\n   *\n   * In ESM5 code the helper calls are hidden inside the class's IIFE.\n   *\n   * @param classSymbol the class whose helper calls we are interested in. We expect this symbol\n   * to reference the inner identifier inside the IIFE.\n   * @returns an array of statements that may contain helper calls.\n   */\n  protected getStatementsForClass(classSymbol: NgccClassSymbol): ts.Statement[] {\n    const classDeclarationParent = classSymbol.implementation.valueDeclaration.parent;\n    return ts.isBlock(classDeclarationParent) ? Array.from(classDeclarationParent.statements) : [];\n  }\n\n  ///////////// Host Private Helpers /////////////\n\n  /**\n   * A constructor function may have been \"synthesized\" by TypeScript during JavaScript emit,\n   * in the case no user-defined constructor exists and e.g. property initializers are used.\n   * Those initializers need to be emitted into a constructor in JavaScript, so the TypeScript\n   * compiler generates a synthetic constructor.\n   *\n   * We need to identify such constructors as ngcc needs to be able to tell if a class did\n   * originally have a constructor in the TypeScript source. For ES5, we can not tell an\n   * empty constructor apart from a synthesized constructor, but fortunately that does not\n   * matter for the code generated by ngtsc.\n   *\n   * When a class has a superclass however, a synthesized constructor must not be considered\n   * as a user-defined constructor as that prevents a base factory call from being created by\n   * ngtsc, resulting in a factory function that does not inject the dependencies of the\n   * superclass. Hence, we identify a default synthesized super call in the constructor body,\n   * according to the structure that TypeScript's ES2015 to ES5 transformer generates in\n   * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1082-L1098\n   *\n   * Additionally, we handle synthetic delegate constructors that are emitted when TypeScript\n   * downlevel's ES2015 synthetically generated to ES5. These vary slightly from the default\n   * structure mentioned above because the ES2015 output uses a spread operator, for delegating\n   * to the parent constructor, that is preserved through a TypeScript helper in ES5. e.g.\n   *\n   * ```\n   * return _super.apply(this, tslib.__spread(arguments)) || this;\n   * ```\n   *\n   * Such constructs can be still considered as synthetic delegate constructors as they are\n   * the product of a common TypeScript to ES5 synthetic constructor, just being downleveled\n   * to ES5 using `tsc`. See: https://github.com/angular/angular/issues/38453.\n   *\n   *\n   * @param constructor a constructor function to test\n   * @returns true if the constructor appears to have been synthesized\n   */\n  private isSynthesizedConstructor(constructor: ts.FunctionDeclaration): boolean {\n    if (!constructor.body) return false;\n\n    const firstStatement = constructor.body.statements[0];\n    if (!firstStatement) return false;\n\n    return this.isSynthesizedSuperThisAssignment(firstStatement) ||\n        this.isSynthesizedSuperReturnStatement(firstStatement);\n  }\n\n  /**\n   * Identifies synthesized super calls which pass-through function arguments directly and are\n   * being assigned to a common `_this` variable. The following patterns we intend to match:\n   *\n   * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n   *   ```\n   *   var _this = _super !== null && _super.apply(this, arguments) || this;\n   *   ```\n   *\n   * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n   *   ```\n   *   var _this = _super.apply(this, tslib.__spread(arguments)) || this;\n   *   ```\n   *\n   *\n   * @param statement a statement that may be a synthesized super call\n   * @returns true if the statement looks like a synthesized super call\n   */\n  private isSynthesizedSuperThisAssignment(statement: ts.Statement): boolean {\n    if (!ts.isVariableStatement(statement)) return false;\n\n    const variableDeclarations = statement.declarationList.declarations;\n    if (variableDeclarations.length !== 1) return false;\n\n    const variableDeclaration = variableDeclarations[0];\n    if (!ts.isIdentifier(variableDeclaration.name) ||\n        !variableDeclaration.name.text.startsWith('_this'))\n      return false;\n\n    const initializer = variableDeclaration.initializer;\n    if (!initializer) return false;\n\n    return this.isSynthesizedDefaultSuperCall(initializer);\n  }\n  /**\n   * Identifies synthesized super calls which pass-through function arguments directly and\n   * are being returned. The following patterns correspond to synthetic super return calls:\n   *\n   * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n   *   ```\n   *   return _super !== null && _super.apply(this, arguments) || this;\n   *   ```\n   *\n   * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n   *   ```\n   *   return _super.apply(this, tslib.__spread(arguments)) || this;\n   *   ```\n   *\n   * @param statement a statement that may be a synthesized super call\n   * @returns true if the statement looks like a synthesized super call\n   */\n  private isSynthesizedSuperReturnStatement(statement: ts.Statement): boolean {\n    if (!ts.isReturnStatement(statement)) return false;\n\n    const expression = statement.expression;\n    if (!expression) return false;\n\n    return this.isSynthesizedDefaultSuperCall(expression);\n  }\n\n  /**\n   * Identifies synthesized super calls which pass-through function arguments directly. The\n   * synthetic delegate super call match the following patterns we intend to match:\n   *\n   * 1. Delegate call emitted by TypeScript when it emits ES5 directly.\n   *   ```\n   *   _super !== null && _super.apply(this, arguments) || this;\n   *   ```\n   *\n   * 2. Delegate call emitted by TypeScript when it downlevel's ES2015 to ES5.\n   *   ```\n   *   _super.apply(this, tslib.__spread(arguments)) || this;\n   *   ```\n   *\n   * @param expression an expression that may represent a default super call\n   * @returns true if the expression corresponds with the above form\n   */\n  private isSynthesizedDefaultSuperCall(expression: ts.Expression): boolean {\n    if (!isBinaryExpr(expression, ts.SyntaxKind.BarBarToken)) return false;\n    if (expression.right.kind !== ts.SyntaxKind.ThisKeyword) return false;\n\n    const left = expression.left;\n    if (isBinaryExpr(left, ts.SyntaxKind.AmpersandAmpersandToken)) {\n      return isSuperNotNull(left.left) && this.isSuperApplyCall(left.right);\n    } else {\n      return this.isSuperApplyCall(left);\n    }\n  }\n\n  /**\n   * Tests whether the expression corresponds to a `super` call passing through\n   * function arguments without any modification. e.g.\n   *\n   * ```\n   * _super !== null && _super.apply(this, arguments) || this;\n   * ```\n   *\n   * This structure is generated by TypeScript when transforming ES2015 to ES5, see\n   * https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/transformers/es2015.ts#L1148-L1163\n   *\n   * Additionally, we also handle cases where `arguments` are wrapped by a TypeScript spread helper.\n   * This can happen if ES2015 class output contain auto-generated constructors due to class\n   * members. The ES2015 output will be using `super(...arguments)` to delegate to the superclass,\n   * but once downleveled to ES5, the spread operator will be persisted through a TypeScript spread\n   * helper. For example:\n   *\n   * ```\n   * _super.apply(this, __spread(arguments)) || this;\n   * ```\n   *\n   * More details can be found in: https://github.com/angular/angular/issues/38453.\n   *\n   * @param expression an expression that may represent a default super call\n   * @returns true if the expression corresponds with the above form\n   */\n  private isSuperApplyCall(expression: ts.Expression): boolean {\n    if (!ts.isCallExpression(expression) || expression.arguments.length !== 2) return false;\n\n    const targetFn = expression.expression;\n    if (!ts.isPropertyAccessExpression(targetFn)) return false;\n    if (!isSuperIdentifier(targetFn.expression)) return false;\n    if (targetFn.name.text !== 'apply') return false;\n\n    const thisArgument = expression.arguments[0];\n    if (thisArgument.kind !== ts.SyntaxKind.ThisKeyword) return false;\n\n    const argumentsExpr = expression.arguments[1];\n\n    // If the super is directly invoked with `arguments`, return `true`. This represents the\n    // common TypeScript output where the delegate constructor super call matches the following\n    // pattern: `super.apply(this, arguments)`.\n    if (isArgumentsIdentifier(argumentsExpr)) {\n      return true;\n    }\n\n    // The other scenario we intend to detect: The `arguments` variable might be wrapped with the\n    // TypeScript spread helper (either through tslib or inlined). This can happen if an explicit\n    // delegate constructor uses `super(...arguments)` in ES2015 and is downleveled to ES5 using\n    // `--downlevelIteration`. The output in such cases would not directly pass the function\n    // `arguments` to the `super` call, but wrap it in a TS spread helper. The output would match\n    // the following pattern: `super.apply(this, tslib.__spread(arguments))`. We check for such\n    // constructs below, but perform the detection of the call expression definition as last as\n    // that is the most expensive operation here.\n    if (!ts.isCallExpression(argumentsExpr) || argumentsExpr.arguments.length !== 1 ||\n        !isArgumentsIdentifier(argumentsExpr.arguments[0])) {\n      return false;\n    }\n\n    const argumentsCallExpr = argumentsExpr.expression;\n    let argumentsCallDeclaration: Declaration|null = null;\n\n    // The `__spread` helper could be globally available, or accessed through a namespaced\n    // import. Hence we support a property access here as long as it resolves to the actual\n    // known TypeScript spread helper.\n    if (ts.isIdentifier(argumentsCallExpr)) {\n      argumentsCallDeclaration = this.getDeclarationOfIdentifier(argumentsCallExpr);\n    } else if (\n        ts.isPropertyAccessExpression(argumentsCallExpr) &&\n        ts.isIdentifier(argumentsCallExpr.name)) {\n      argumentsCallDeclaration = this.getDeclarationOfIdentifier(argumentsCallExpr.name);\n    }\n\n    return argumentsCallDeclaration !== null &&\n        argumentsCallDeclaration.known === KnownDeclaration.TsHelperSpread;\n  }\n}\n\n///////////// Internal Helpers /////////////\n\n/**\n * Represents the details about property definitions that were set using `Object.defineProperty`.\n */\ninterface PropertyDefinition {\n  setter: ts.FunctionExpression|null;\n  getter: ts.FunctionExpression|null;\n}\n\n/**\n * In ES5, getters and setters have been downleveled into call expressions of\n * `Object.defineProperty`, such as\n *\n * ```\n * Object.defineProperty(Clazz.prototype, \"property\", {\n *   get: function () {\n *       return 'value';\n *   },\n *   set: function (value) {\n *       this.value = value;\n *   },\n *   enumerable: true,\n *   configurable: true\n * });\n * ```\n *\n * This function inspects the given node to determine if it corresponds with such a call, and if so\n * extracts the `set` and `get` function expressions from the descriptor object, if they exist.\n *\n * @param node The node to obtain the property definition from.\n * @returns The property definition if the node corresponds with accessor, null otherwise.\n */\nfunction getPropertyDefinition(node: ts.Node): PropertyDefinition|null {\n  if (!ts.isCallExpression(node)) return null;\n\n  const fn = node.expression;\n  if (!ts.isPropertyAccessExpression(fn) || !ts.isIdentifier(fn.expression) ||\n      fn.expression.text !== 'Object' || fn.name.text !== 'defineProperty')\n    return null;\n\n  const descriptor = node.arguments[2];\n  if (!descriptor || !ts.isObjectLiteralExpression(descriptor)) return null;\n\n  return {\n    setter: readPropertyFunctionExpression(descriptor, 'set'),\n    getter: readPropertyFunctionExpression(descriptor, 'get'),\n  };\n}\n\nfunction readPropertyFunctionExpression(object: ts.ObjectLiteralExpression, name: string) {\n  const property = object.properties.find(\n      (p): p is ts.PropertyAssignment =>\n          ts.isPropertyAssignment(p) && ts.isIdentifier(p.name) && p.name.text === name);\n\n  return property && ts.isFunctionExpression(property.initializer) && property.initializer || null;\n}\n\nfunction getReturnStatement(declaration: ts.Expression|undefined): ts.ReturnStatement|undefined {\n  return declaration && ts.isFunctionExpression(declaration) ?\n      declaration.body.statements.find(ts.isReturnStatement) :\n      undefined;\n}\n\nfunction reflectArrayElement(element: ts.Expression) {\n  return ts.isObjectLiteralExpression(element) ? reflectObjectLiteral(element) : null;\n}\n\nfunction isArgumentsIdentifier(expression: ts.Expression): boolean {\n  return ts.isIdentifier(expression) && expression.text === 'arguments';\n}\n\nfunction isSuperNotNull(expression: ts.Expression): boolean {\n  return isBinaryExpr(expression, ts.SyntaxKind.ExclamationEqualsEqualsToken) &&\n      isSuperIdentifier(expression.left);\n}\n\nfunction isBinaryExpr(\n    expression: ts.Expression, operator: ts.BinaryOperator): expression is ts.BinaryExpression {\n  return ts.isBinaryExpression(expression) && expression.operatorToken.kind === operator;\n}\n\nfunction isSuperIdentifier(node: ts.Node): boolean {\n  // Verify that the identifier is prefixed with `_super`. We don't test for equivalence\n  // as TypeScript may have suffixed the name, e.g. `_super_1` to avoid name conflicts.\n  // Requiring only a prefix should be sufficiently accurate.\n  return ts.isIdentifier(node) && node.text.startsWith('_super');\n}\n\n/**\n * Parse the statement to extract the ESM5 parameter initializer if there is one.\n * If one is found, add it to the appropriate parameter in the `parameters` collection.\n *\n * The form we are looking for is:\n *\n * ```\n * if (arg === void 0) { arg = initializer; }\n * ```\n *\n * @param statement a statement that may be initializing an optional parameter\n * @param parameters the collection of parameters that were found in the function definition\n * @returns true if the statement was a parameter initializer\n */\nfunction captureParamInitializer(statement: ts.Statement, parameters: Parameter[]) {\n  if (ts.isIfStatement(statement) && isUndefinedComparison(statement.expression) &&\n      ts.isBlock(statement.thenStatement) && statement.thenStatement.statements.length === 1) {\n    const ifStatementComparison = statement.expression;           // (arg === void 0)\n    const thenStatement = statement.thenStatement.statements[0];  // arg = initializer;\n    if (isAssignmentStatement(thenStatement)) {\n      const comparisonName = ifStatementComparison.left.text;\n      const assignmentName = thenStatement.expression.left.text;\n      if (comparisonName === assignmentName) {\n        const parameter = parameters.find(p => p.name === comparisonName);\n        if (parameter) {\n          parameter.initializer = thenStatement.expression.right;\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfunction isUndefinedComparison(expression: ts.Expression): expression is ts.Expression&\n    {left: ts.Identifier, right: ts.Expression} {\n  return ts.isBinaryExpression(expression) &&\n      expression.operatorToken.kind === ts.SyntaxKind.EqualsEqualsEqualsToken &&\n      ts.isVoidExpression(expression.right) && ts.isIdentifier(expression.left);\n}\n\n/**\n * Parse the declaration of the given `classSymbol` to find the IIFE wrapper function.\n *\n * This function may accept a `_super` argument if there is a base class.\n *\n * ```\n * var TestClass = (function (_super) {\n *   __extends(TestClass, _super);\n *   function TestClass() {}\n *   return TestClass;\n * }(BaseClass));\n * ```\n *\n * @param classSymbol the class whose iife wrapper function we want to get.\n * @returns the IIFE function or null if it could not be parsed.\n */\nfunction getIifeFn(classSymbol: NgccClassSymbol|undefined): ts.FunctionExpression|null {\n  if (classSymbol === undefined) {\n    return null;\n  }\n\n  const innerDeclaration = classSymbol.implementation.valueDeclaration;\n  const iifeBody = innerDeclaration.parent;\n  if (!ts.isBlock(iifeBody)) {\n    return null;\n  }\n\n  const iifeWrapper = iifeBody.parent;\n  return iifeWrapper && ts.isFunctionExpression(iifeWrapper) ? iifeWrapper : null;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}