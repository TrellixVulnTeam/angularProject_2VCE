{"ast":null,"code":"/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar util = require(\"util\");\n\nvar SortableSet = require(\"./util/SortableSet\");\n\nvar intersect = require(\"./util/SetHelpers\").intersect;\n\nvar GraphHelpers = require(\"./GraphHelpers\");\n\nvar Entrypoint = require(\"./Entrypoint\");\n\nvar debugId = 1000;\nvar ERR_CHUNK_ENTRY = \"Chunk.entry was removed. Use hasRuntime()\";\nvar ERR_CHUNK_INITIAL = \"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\";\n/** @typedef {import(\"./Module\")} Module */\n\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n/**\n *  @typedef {Object} WithId an object who has an id property *\n *  @property {string | number} id the id of the object\n */\n\n/**\n * Compare two Modules based on their ids for sorting\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} sort value\n */\n// TODO use @callback\n\n/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */\n\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n\n/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */\n\nvar sortModuleById = function sortModuleById(a, b) {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n/**\n * Compare two ChunkGroups based on their ids for sorting\n * @param {ChunkGroup} a chunk group\n * @param {ChunkGroup} b chunk group\n * @returns {-1|0|1} sort value\n */\n\n\nvar sortChunkGroupById = function sortChunkGroupById(a, b) {\n  if (a.id < b.id) return -1;\n  if (b.id < a.id) return 1;\n  return 0;\n};\n/**\n * Compare two Identifiables , based on their ids for sorting\n * @param {Module} a first object with ident fn\n * @param {Module} b second object with ident fn\n * @returns {-1|0|1} The order number of the sort\n */\n\n\nvar sortByIdentifier = function sortByIdentifier(a, b) {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n/**\n * @returns {string} a concatenation of module identifiers sorted\n * @param {SortableSet} set to pull module identifiers from\n */\n\n\nvar _getModulesIdent = function getModulesIdent(set) {\n  set.sort();\n  var str = \"\";\n\n  var _iterator = _createForOfIteratorHelper(set),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var m = _step.value;\n      str += m.identifier() + \"#\";\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return str;\n};\n/**\n * @template T\n * @param {SortableSet<T>} set the sortable set to convert to array\n * @returns {Array<T>} the array returned from Array.from(set)\n */\n\n\nvar getArray = function getArray(set) {\n  return Array.from(set);\n};\n/**\n * @param {SortableSet<Module>} set the sortable Set to get the count/size of\n * @returns {number} the size of the modules\n */\n\n\nvar getModulesSize = function getModulesSize(set) {\n  var size = 0;\n\n  var _iterator2 = _createForOfIteratorHelper(set),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _module = _step2.value;\n      size += _module.size();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return size;\n};\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\n\n\nvar Chunk = /*#__PURE__*/function () {\n  /**\n   * @param {string=} name of chunk being created, is optional (for subclasses)\n   */\n  function Chunk(name) {\n    _classCallCheck(this, Chunk);\n\n    /** @type {number | null} */\n    this.id = null;\n    /** @type {number[] | null} */\n\n    this.ids = null;\n    /** @type {number} */\n\n    this.debugId = debugId++;\n    /** @type {string} */\n\n    this.name = name;\n    /** @type {boolean} */\n\n    this.preventIntegration = false;\n    /** @type {Module=} */\n\n    this.entryModule = undefined;\n    /** @private @type {SortableSet<Module>} */\n\n    this._modules = new SortableSet(undefined, sortByIdentifier);\n    /** @type {string?} */\n\n    this.filenameTemplate = undefined;\n    /** @private @type {SortableSet<ChunkGroup>} */\n\n    this._groups = new SortableSet(undefined, sortChunkGroupById);\n    /** @type {string[]} */\n\n    this.files = [];\n    /** @type {boolean} */\n\n    this.rendered = false;\n    /** @type {string=} */\n\n    this.hash = undefined;\n    /** @type {Object} */\n\n    this.contentHash = Object.create(null);\n    /** @type {string=} */\n\n    this.renderedHash = undefined;\n    /** @type {string=} */\n\n    this.chunkReason = undefined;\n    /** @type {boolean} */\n\n    this.extraAsync = false;\n    this.removedModules = undefined;\n  }\n  /**\n   * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead\n   * @returns {never} Throws an error trying to access this property\n   */\n\n\n  _createClass(Chunk, [{\n    key: \"entry\",\n    get: function get() {\n      throw new Error(ERR_CHUNK_ENTRY);\n    }\n    /**\n     * @deprecated .entry has been deprecated. Please use .hasRuntime() instead\n     * @param {never} data The data that was attempting to be set\n     * @returns {never} Throws an error trying to access this property\n     */\n    ,\n    set: function set(data) {\n      throw new Error(ERR_CHUNK_ENTRY);\n    }\n    /**\n     * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n     * @returns {never} Throws an error trying to access this property\n     */\n\n  }, {\n    key: \"initial\",\n    get: function get() {\n      throw new Error(ERR_CHUNK_INITIAL);\n    }\n    /**\n     * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n     * @param {never} data The data attempting to be set\n     * @returns {never} Throws an error trying to access this property\n     */\n    ,\n    set: function set(data) {\n      throw new Error(ERR_CHUNK_INITIAL);\n    }\n    /**\n     * @returns {boolean} whether or not the Chunk will have a runtime\n     */\n\n  }, {\n    key: \"hasRuntime\",\n    value: function hasRuntime() {\n      var _iterator3 = _createForOfIteratorHelper(this._groups),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var chunkGroup = _step3.value;\n\n          if (chunkGroup.isInitial() && chunkGroup instanceof Entrypoint && chunkGroup.getRuntimeChunk() === this) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return false;\n    }\n    /**\n     * @returns {boolean} whether or not this chunk can be an initial chunk\n     */\n\n  }, {\n    key: \"canBeInitial\",\n    value: function canBeInitial() {\n      var _iterator4 = _createForOfIteratorHelper(this._groups),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var chunkGroup = _step4.value;\n          if (chunkGroup.isInitial()) return true;\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      return false;\n    }\n    /**\n     * @returns {boolean} whether this chunk can only be an initial chunk\n     */\n\n  }, {\n    key: \"isOnlyInitial\",\n    value: function isOnlyInitial() {\n      if (this._groups.size <= 0) return false;\n\n      var _iterator5 = _createForOfIteratorHelper(this._groups),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var chunkGroup = _step5.value;\n          if (!chunkGroup.isInitial()) return false;\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      return true;\n    }\n    /**\n     * @returns {boolean} if this chunk contains the entry module\n     */\n\n  }, {\n    key: \"hasEntryModule\",\n    value: function hasEntryModule() {\n      return !!this.entryModule;\n    }\n    /**\n     * @param {Module} module the module that will be added to this chunk.\n     * @returns {boolean} returns true if the chunk doesn't have the module and it was added\n     */\n\n  }, {\n    key: \"addModule\",\n    value: function addModule(module) {\n      if (!this._modules.has(module)) {\n        this._modules.add(module);\n\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {Module} module the module that will be removed from this chunk\n     * @returns {boolean} returns true if chunk exists and is successfully deleted\n     */\n\n  }, {\n    key: \"removeModule\",\n    value: function removeModule(module) {\n      if (this._modules.delete(module)) {\n        module.removeChunk(this);\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * @param {Module[]} modules the new modules to be set\n     * @returns {void} set new modules to this chunk and return nothing\n     */\n\n  }, {\n    key: \"setModules\",\n    value: function setModules(modules) {\n      this._modules = new SortableSet(modules, sortByIdentifier);\n    }\n    /**\n     * @returns {number} the amount of modules in chunk\n     */\n\n  }, {\n    key: \"getNumberOfModules\",\n    value: function getNumberOfModules() {\n      return this._modules.size;\n    }\n    /**\n     * @returns {SortableSet} return the modules SortableSet for this chunk\n     */\n\n  }, {\n    key: \"modulesIterable\",\n    get: function get() {\n      return this._modules;\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n     * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully\n     */\n\n  }, {\n    key: \"addGroup\",\n    value: function addGroup(chunkGroup) {\n      if (this._groups.has(chunkGroup)) return false;\n\n      this._groups.add(chunkGroup);\n\n      return true;\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n     * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed\n     */\n\n  }, {\n    key: \"removeGroup\",\n    value: function removeGroup(chunkGroup) {\n      if (!this._groups.has(chunkGroup)) return false;\n\n      this._groups.delete(chunkGroup);\n\n      return true;\n    }\n    /**\n     * @param {ChunkGroup} chunkGroup the chunkGroup to check\n     * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n     */\n\n  }, {\n    key: \"isInGroup\",\n    value: function isInGroup(chunkGroup) {\n      return this._groups.has(chunkGroup);\n    }\n    /**\n     * @returns {number} the amount of groups said chunk is in\n     */\n\n  }, {\n    key: \"getNumberOfGroups\",\n    value: function getNumberOfGroups() {\n      return this._groups.size;\n    }\n    /**\n     * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in\n     */\n\n  }, {\n    key: \"groupsIterable\",\n    get: function get() {\n      return this._groups;\n    }\n    /**\n     * @param {Chunk} otherChunk the chunk to compare itself with\n     * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order\n     */\n\n  }, {\n    key: \"compareTo\",\n    value: function compareTo(otherChunk) {\n      if (this.name && !otherChunk.name) return -1;\n      if (!this.name && otherChunk.name) return 1;\n      if (this.name < otherChunk.name) return -1;\n      if (this.name > otherChunk.name) return 1;\n      if (this._modules.size > otherChunk._modules.size) return -1;\n      if (this._modules.size < otherChunk._modules.size) return 1;\n\n      this._modules.sort();\n\n      otherChunk._modules.sort();\n\n      var a = this._modules[Symbol.iterator]();\n\n      var b = otherChunk._modules[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n\n      while (true) {\n        var aItem = a.next();\n        if (aItem.done) return 0;\n        var bItem = b.next();\n        var aModuleIdentifier = aItem.value.identifier();\n        var bModuleIdentifier = bItem.value.identifier();\n        if (aModuleIdentifier < bModuleIdentifier) return -1;\n        if (aModuleIdentifier > bModuleIdentifier) return 1;\n      }\n    }\n    /**\n     * @param {Module} module Module to check\n     * @returns {boolean} returns true if module does exist in this chunk\n     */\n\n  }, {\n    key: \"containsModule\",\n    value: function containsModule(module) {\n      return this._modules.has(module);\n    }\n    /**\n     * @returns {Module[]} an array of modules (do not modify)\n     */\n\n  }, {\n    key: \"getModules\",\n    value: function getModules() {\n      return this._modules.getFromCache(getArray);\n    }\n  }, {\n    key: \"getModulesIdent\",\n    value: function getModulesIdent() {\n      return this._modules.getFromUnorderedCache(_getModulesIdent);\n    }\n    /**\n     * @param {string=} reason reason why chunk is removed\n     * @returns {void}\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(reason) {\n      // cleanup modules\n      // Array.from is used here to create a clone, because removeChunk modifies this._modules\n      for (var _i = 0, _Array$from = Array.from(this._modules); _i < _Array$from.length; _i++) {\n        var _module2 = _Array$from[_i];\n\n        _module2.removeChunk(this);\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(this._groups),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var chunkGroup = _step6.value;\n          chunkGroup.removeChunk(this);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n    /**\n     *\n     * @param {Module} module module to move\n     * @param {Chunk} otherChunk other chunk to move it to\n     * @returns {void}\n     */\n\n  }, {\n    key: \"moveModule\",\n    value: function moveModule(module, otherChunk) {\n      GraphHelpers.disconnectChunkAndModule(this, module);\n      GraphHelpers.connectChunkAndModule(otherChunk, module);\n      module.rewriteChunkInReasons(this, [otherChunk]);\n    }\n    /**\n     *\n     * @param {Chunk} otherChunk the chunk to integrate with\n     * @param {string} reason reason why the module is being integrated\n     * @returns {boolean} returns true or false if integration succeeds or fails\n     */\n\n  }, {\n    key: \"integrate\",\n    value: function integrate(otherChunk, reason) {\n      if (!this.canBeIntegrated(otherChunk)) {\n        return false;\n      } // Pick a new name for the integrated chunk\n\n\n      if (this.name && otherChunk.name) {\n        if (this.hasEntryModule() === otherChunk.hasEntryModule()) {\n          // When both chunks have entry modules or none have one, use\n          // shortest name\n          if (this.name.length !== otherChunk.name.length) {\n            this.name = this.name.length < otherChunk.name.length ? this.name : otherChunk.name;\n          } else {\n            this.name = this.name < otherChunk.name ? this.name : otherChunk.name;\n          }\n        } else if (otherChunk.hasEntryModule()) {\n          // Pick the name of the chunk with the entry module\n          this.name = otherChunk.name;\n        }\n      } else if (otherChunk.name) {\n        this.name = otherChunk.name;\n      } // Array.from is used here to create a clone, because moveModule modifies otherChunk._modules\n\n\n      for (var _i2 = 0, _Array$from2 = Array.from(otherChunk._modules); _i2 < _Array$from2.length; _i2++) {\n        var _module3 = _Array$from2[_i2];\n        otherChunk.moveModule(_module3, this);\n      }\n\n      otherChunk._modules.clear();\n\n      if (otherChunk.entryModule) {\n        this.entryModule = otherChunk.entryModule;\n      }\n\n      var _iterator7 = _createForOfIteratorHelper(otherChunk._groups),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var chunkGroup = _step7.value;\n          chunkGroup.replaceChunk(otherChunk, this);\n          this.addGroup(chunkGroup);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      otherChunk._groups.clear();\n\n      return true;\n    }\n    /**\n     * @param {Chunk} newChunk the new chunk that will be split out of the current chunk\n     * @returns {void}\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(newChunk) {\n      var _iterator8 = _createForOfIteratorHelper(this._groups),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var chunkGroup = _step8.value;\n          chunkGroup.insertChunk(newChunk, this);\n          newChunk.addGroup(chunkGroup);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this._modules.size === 0;\n    }\n  }, {\n    key: \"updateHash\",\n    value: function updateHash(hash) {\n      hash.update(\"\".concat(this.id, \" \"));\n      hash.update(this.ids ? this.ids.join(\",\") : \"\");\n      hash.update(\"\".concat(this.name || \"\", \" \"));\n\n      var _iterator9 = _createForOfIteratorHelper(this._modules),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var m = _step9.value;\n          hash.update(m.hash);\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n  }, {\n    key: \"canBeIntegrated\",\n    value: function canBeIntegrated(otherChunk) {\n      if (this.preventIntegration || otherChunk.preventIntegration) {\n        return false;\n      }\n      /**\n       * @param {Chunk} a chunk\n       * @param {Chunk} b chunk\n       * @returns {boolean} true, if a is always available when b is reached\n       */\n\n\n      var isAvailable = function isAvailable(a, b) {\n        var queue = new Set(b.groupsIterable);\n\n        var _iterator10 = _createForOfIteratorHelper(queue),\n            _step10;\n\n        try {\n          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n            var chunkGroup = _step10.value;\n            if (a.isInGroup(chunkGroup)) continue;\n            if (chunkGroup.isInitial()) return false;\n\n            var _iterator11 = _createForOfIteratorHelper(chunkGroup.parentsIterable),\n                _step11;\n\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var parent = _step11.value;\n                queue.add(parent);\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n          }\n        } catch (err) {\n          _iterator10.e(err);\n        } finally {\n          _iterator10.f();\n        }\n\n        return true;\n      };\n\n      var selfHasRuntime = this.hasRuntime();\n      var otherChunkHasRuntime = otherChunk.hasRuntime();\n\n      if (selfHasRuntime !== otherChunkHasRuntime) {\n        if (selfHasRuntime) {\n          return isAvailable(this, otherChunk);\n        } else if (otherChunkHasRuntime) {\n          return isAvailable(otherChunk, this);\n        } else {\n          return false;\n        }\n      }\n\n      if (this.hasEntryModule() || otherChunk.hasEntryModule()) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     *\n     * @param {number} size the size\n     * @param {Object} options the options passed in\n     * @returns {number} the multiplier returned\n     */\n\n  }, {\n    key: \"addMultiplierAndOverhead\",\n    value: function addMultiplierAndOverhead(size, options) {\n      var overhead = typeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n      var multiplicator = this.canBeInitial() ? options.entryChunkMultiplicator || 10 : 1;\n      return size * multiplicator + overhead;\n    }\n    /**\n     * @returns {number} the size of all modules\n     */\n\n  }, {\n    key: \"modulesSize\",\n    value: function modulesSize() {\n      return this._modules.getFromUnorderedCache(getModulesSize);\n    }\n    /**\n     * @param {Object} options the size display options\n     * @returns {number} the chunk size\n     */\n\n  }, {\n    key: \"size\",\n    value: function size() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.addMultiplierAndOverhead(this.modulesSize(), options);\n    }\n    /**\n     * @param {Chunk} otherChunk the other chunk\n     * @param {TODO} options the options for this function\n     * @returns {number | false} the size, or false if it can't be integrated\n     */\n\n  }, {\n    key: \"integratedSize\",\n    value: function integratedSize(otherChunk, options) {\n      // Chunk if it's possible to integrate this chunk\n      if (!this.canBeIntegrated(otherChunk)) {\n        return false;\n      }\n\n      var integratedModulesSize = this.modulesSize(); // only count modules that do not exist in this chunk!\n\n      var _iterator12 = _createForOfIteratorHelper(otherChunk._modules),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var otherModule = _step12.value;\n\n          if (!this._modules.has(otherModule)) {\n            integratedModulesSize += otherModule.size();\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return this.addMultiplierAndOverhead(integratedModulesSize, options);\n    }\n    /**\n     * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules\n     * @returns {void}\n     */\n\n  }, {\n    key: \"sortModules\",\n    value: function sortModules(sortByFn) {\n      this._modules.sortWith(sortByFn || sortModuleById);\n    }\n  }, {\n    key: \"sortItems\",\n    value: function sortItems() {\n      this.sortModules();\n    }\n    /**\n     * @returns {Set<Chunk>} a set of all the async chunks\n     */\n\n  }, {\n    key: \"getAllAsyncChunks\",\n    value: function getAllAsyncChunks() {\n      var queue = new Set();\n      var chunks = new Set();\n      var initialChunks = intersect(Array.from(this.groupsIterable, function (g) {\n        return new Set(g.chunks);\n      }));\n\n      var _iterator13 = _createForOfIteratorHelper(this.groupsIterable),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var chunkGroup = _step13.value;\n\n          var _iterator15 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n              _step15;\n\n          try {\n            for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n              var child = _step15.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator15.e(err);\n          } finally {\n            _iterator15.f();\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      var _iterator14 = _createForOfIteratorHelper(queue),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var _chunkGroup = _step14.value;\n\n          var _iterator16 = _createForOfIteratorHelper(_chunkGroup.chunks),\n              _step16;\n\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var chunk = _step16.value;\n\n              if (!initialChunks.has(chunk)) {\n                chunks.add(chunk);\n              }\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n\n          var _iterator17 = _createForOfIteratorHelper(_chunkGroup.childrenIterable),\n              _step17;\n\n          try {\n            for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n              var _child = _step17.value;\n              queue.add(_child);\n            }\n          } catch (err) {\n            _iterator17.e(err);\n          } finally {\n            _iterator17.f();\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      return chunks;\n    }\n    /**\n     * @typedef {Object} ChunkMaps\n     * @property {Record<string|number, string>} hash\n     * @property {Record<string|number, Record<string, string>>} contentHash\n     * @property {Record<string|number, string>} name\n     */\n\n    /**\n     * @param {boolean} realHash should the full hash or the rendered hash be used\n     * @returns {ChunkMaps} the chunk map information\n     */\n\n  }, {\n    key: \"getChunkMaps\",\n    value: function getChunkMaps(realHash) {\n      /** @type {Record<string|number, string>} */\n      var chunkHashMap = Object.create(null);\n      /** @type {Record<string|number, Record<string, string>>} */\n\n      var chunkContentHashMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n\n      var chunkNameMap = Object.create(null);\n\n      var _iterator18 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var chunk = _step18.value;\n          chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\n          for (var _i3 = 0, _Object$keys = Object.keys(chunk.contentHash); _i3 < _Object$keys.length; _i3++) {\n            var key = _Object$keys[_i3];\n\n            if (!chunkContentHashMap[key]) {\n              chunkContentHashMap[key] = Object.create(null);\n            }\n\n            chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n          }\n\n          if (chunk.name) {\n            chunkNameMap[chunk.id] = chunk.name;\n          }\n        }\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      return {\n        hash: chunkHashMap,\n        contentHash: chunkContentHashMap,\n        name: chunkNameMap\n      };\n    }\n    /**\n     * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)\n     */\n\n  }, {\n    key: \"getChildIdsByOrders\",\n    value: function getChildIdsByOrders() {\n      var lists = new Map();\n\n      var _iterator19 = _createForOfIteratorHelper(this.groupsIterable),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var group = _step19.value;\n\n          if (group.chunks[group.chunks.length - 1] === this) {\n            var _iterator21 = _createForOfIteratorHelper(group.childrenIterable),\n                _step21;\n\n            try {\n              for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                var childGroup = _step21.value;\n\n                // TODO webpack 5 remove this check for options\n                if (typeof childGroup.options === \"object\") {\n                  for (var _i4 = 0, _Object$keys2 = Object.keys(childGroup.options); _i4 < _Object$keys2.length; _i4++) {\n                    var key = _Object$keys2[_i4];\n\n                    if (key.endsWith(\"Order\")) {\n                      var name = key.substr(0, key.length - \"Order\".length);\n                      var list = lists.get(name);\n                      if (list === undefined) lists.set(name, list = []);\n                      list.push({\n                        order: childGroup.options[key],\n                        group: childGroup\n                      });\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator21.e(err);\n            } finally {\n              _iterator21.f();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n\n      var result = Object.create(null);\n\n      var _iterator20 = _createForOfIteratorHelper(lists),\n          _step20;\n\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var _step20$value = _slicedToArray(_step20.value, 2),\n              _name = _step20$value[0],\n              _list = _step20$value[1];\n\n          _list.sort(function (a, b) {\n            var cmp = b.order - a.order;\n            if (cmp !== 0) return cmp; // TODO webpack 5 remove this check of compareTo\n\n            if (a.group.compareTo) {\n              return a.group.compareTo(b.group);\n            }\n\n            return 0;\n          });\n\n          result[_name] = Array.from(_list.reduce(function (set, item) {\n            var _iterator22 = _createForOfIteratorHelper(item.group.chunks),\n                _step22;\n\n            try {\n              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                var chunk = _step22.value;\n                set.add(chunk.id);\n              }\n            } catch (err) {\n              _iterator22.e(err);\n            } finally {\n              _iterator22.f();\n            }\n\n            return set;\n          }, new Set()));\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getChildIdsByOrdersMap\",\n    value: function getChildIdsByOrdersMap(includeDirectChildren) {\n      var chunkMaps = Object.create(null);\n\n      var addChildIdsByOrdersToMap = function addChildIdsByOrdersToMap(chunk) {\n        var data = chunk.getChildIdsByOrders();\n\n        for (var _i5 = 0, _Object$keys3 = Object.keys(data); _i5 < _Object$keys3.length; _i5++) {\n          var key = _Object$keys3[_i5];\n          var chunkMap = chunkMaps[key];\n\n          if (chunkMap === undefined) {\n            chunkMaps[key] = chunkMap = Object.create(null);\n          }\n\n          chunkMap[chunk.id] = data[key];\n        }\n      };\n\n      if (includeDirectChildren) {\n        var chunks = new Set();\n\n        var _iterator23 = _createForOfIteratorHelper(this.groupsIterable),\n            _step23;\n\n        try {\n          for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n            var chunkGroup = _step23.value;\n\n            var _iterator25 = _createForOfIteratorHelper(chunkGroup.chunks),\n                _step25;\n\n            try {\n              for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                var chunk = _step25.value;\n                chunks.add(chunk);\n              }\n            } catch (err) {\n              _iterator25.e(err);\n            } finally {\n              _iterator25.f();\n            }\n          }\n        } catch (err) {\n          _iterator23.e(err);\n        } finally {\n          _iterator23.f();\n        }\n\n        var _iterator24 = _createForOfIteratorHelper(chunks),\n            _step24;\n\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var _chunk = _step24.value;\n            addChildIdsByOrdersToMap(_chunk);\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n      }\n\n      var _iterator26 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n          _step26;\n\n      try {\n        for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n          var _chunk2 = _step26.value;\n          addChildIdsByOrdersToMap(_chunk2);\n        }\n      } catch (err) {\n        _iterator26.e(err);\n      } finally {\n        _iterator26.f();\n      }\n\n      return chunkMaps;\n    }\n    /**\n     * @typedef {Object} ChunkModuleMaps\n     * @property {Record<string|number, (string|number)[]>} id\n     * @property {Record<string|number, string>} hash\n     */\n\n    /**\n     * @param {ModuleFilterPredicate} filterFn function used to filter modules\n     * @returns {ChunkModuleMaps} module map information\n     */\n\n  }, {\n    key: \"getChunkModuleMaps\",\n    value: function getChunkModuleMaps(filterFn) {\n      /** @type {Record<string|number, (string|number)[]>} */\n      var chunkModuleIdMap = Object.create(null);\n      /** @type {Record<string|number, string>} */\n\n      var chunkModuleHashMap = Object.create(null);\n\n      var _iterator27 = _createForOfIteratorHelper(this.getAllAsyncChunks()),\n          _step27;\n\n      try {\n        for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n          var chunk = _step27.value;\n\n          /** @type {(string|number)[]} */\n          var array = void 0;\n\n          var _iterator28 = _createForOfIteratorHelper(chunk.modulesIterable),\n              _step28;\n\n          try {\n            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n              var _module4 = _step28.value;\n\n              if (filterFn(_module4)) {\n                if (array === undefined) {\n                  array = [];\n                  chunkModuleIdMap[chunk.id] = array;\n                }\n\n                array.push(_module4.id);\n                chunkModuleHashMap[_module4.id] = _module4.renderedHash;\n              }\n            }\n          } catch (err) {\n            _iterator28.e(err);\n          } finally {\n            _iterator28.f();\n          }\n\n          if (array !== undefined) {\n            array.sort();\n          }\n        }\n      } catch (err) {\n        _iterator27.e(err);\n      } finally {\n        _iterator27.f();\n      }\n\n      return {\n        id: chunkModuleIdMap,\n        hash: chunkModuleHashMap\n      };\n    }\n    /**\n     *\n     * @param {function(Module): boolean} filterFn predicate function used to filter modules\n     * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks\n     * @returns {boolean} return true if module exists in graph\n     */\n\n  }, {\n    key: \"hasModuleInGraph\",\n    value: function hasModuleInGraph(filterFn, filterChunkFn) {\n      var queue = new Set(this.groupsIterable);\n      var chunksProcessed = new Set();\n\n      var _iterator29 = _createForOfIteratorHelper(queue),\n          _step29;\n\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var chunkGroup = _step29.value;\n\n          var _iterator30 = _createForOfIteratorHelper(chunkGroup.chunks),\n              _step30;\n\n          try {\n            for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n              var chunk = _step30.value;\n\n              if (!chunksProcessed.has(chunk)) {\n                chunksProcessed.add(chunk);\n\n                if (!filterChunkFn || filterChunkFn(chunk)) {\n                  var _iterator32 = _createForOfIteratorHelper(chunk.modulesIterable),\n                      _step32;\n\n                  try {\n                    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                      var _module5 = _step32.value;\n\n                      if (filterFn(_module5)) {\n                        return true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator32.e(err);\n                  } finally {\n                    _iterator32.f();\n                  }\n                }\n              }\n            }\n          } catch (err) {\n            _iterator30.e(err);\n          } finally {\n            _iterator30.f();\n          }\n\n          var _iterator31 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n              _step31;\n\n          try {\n            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n              var child = _step31.value;\n              queue.add(child);\n            }\n          } catch (err) {\n            _iterator31.e(err);\n          } finally {\n            _iterator31.f();\n          }\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n\n      return false;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"Chunk[\".concat(Array.from(this._modules).join(), \"]\");\n    }\n  }]);\n\n  return Chunk;\n}(); // TODO remove in webpack 5\n\n\nObject.defineProperty(Chunk.prototype, \"forEachModule\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback\n   * @param {ForEachModuleCallback} fn Callback function\n   * @returns {void}\n   */\n  function (fn) {\n    this._modules.forEach(fn);\n  }, \"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"mapModules\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Chunk}\n   * @typedef {function(any, number): any} MapModulesCallback\n   * @param {MapModulesCallback} fn Callback function\n   * @returns {TODO[]} result of mapped modules\n   */\n  function (fn) {\n    return Array.from(this._modules, fn);\n  }, \"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead\")\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"chunks\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.getChildren() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.chunks: Use ChunkGroup.add/removeChild() instead\");\n  }\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"parents\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.getParents() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.parents: Use ChunkGroup.add/removeParent() instead\");\n  }\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"blocks\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.getBlocks() instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.blocks: Use ChunkGroup.add/removeBlock() instead\");\n  }\n}); // TODO remove in webpack 5\n\nObject.defineProperty(Chunk.prototype, \"entrypoints\", {\n  configurable: false,\n  get: function get() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead\");\n  },\n  set: function set() {\n    throw new Error(\"Chunk.entrypoints: Use Chunks.addGroup instead\");\n  }\n});\nmodule.exports = Chunk;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/Chunk.js"],"names":["util","require","SortableSet","intersect","GraphHelpers","Entrypoint","debugId","ERR_CHUNK_ENTRY","ERR_CHUNK_INITIAL","sortModuleById","a","b","id","sortChunkGroupById","sortByIdentifier","identifier","getModulesIdent","set","sort","str","m","getArray","Array","from","getModulesSize","size","module","Chunk","name","ids","preventIntegration","entryModule","undefined","_modules","filenameTemplate","_groups","files","rendered","hash","contentHash","Object","create","renderedHash","chunkReason","extraAsync","removedModules","Error","data","chunkGroup","isInitial","getRuntimeChunk","has","add","delete","removeChunk","modules","otherChunk","Symbol","iterator","aItem","next","done","bItem","aModuleIdentifier","value","bModuleIdentifier","getFromCache","getFromUnorderedCache","reason","disconnectChunkAndModule","connectChunkAndModule","rewriteChunkInReasons","canBeIntegrated","hasEntryModule","length","moveModule","clear","replaceChunk","addGroup","newChunk","insertChunk","update","join","isAvailable","queue","Set","groupsIterable","isInGroup","parentsIterable","parent","selfHasRuntime","hasRuntime","otherChunkHasRuntime","options","overhead","chunkOverhead","multiplicator","canBeInitial","entryChunkMultiplicator","addMultiplierAndOverhead","modulesSize","integratedModulesSize","otherModule","sortByFn","sortWith","sortModules","chunks","initialChunks","g","childrenIterable","child","chunk","realHash","chunkHashMap","chunkContentHashMap","chunkNameMap","getAllAsyncChunks","keys","key","lists","Map","group","childGroup","endsWith","substr","list","get","push","order","result","cmp","compareTo","reduce","item","includeDirectChildren","chunkMaps","addChildIdsByOrdersToMap","getChildIdsByOrders","chunkMap","filterFn","chunkModuleIdMap","chunkModuleHashMap","array","modulesIterable","filterChunkFn","chunksProcessed","defineProperty","prototype","configurable","deprecate","fn","forEach","exports"],"mappings":"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","sourcesContent":["/*\nMIT License http://www.opensource.org/licenses/mit-license.php\nAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst intersect = require(\"./util/SetHelpers\").intersect;\nconst GraphHelpers = require(\"./GraphHelpers\");\nconst Entrypoint = require(\"./Entrypoint\");\nlet debugId = 1000;\nconst ERR_CHUNK_ENTRY = \"Chunk.entry was removed. Use hasRuntime()\";\nconst ERR_CHUNK_INITIAL =\n\t\"Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\";\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"./ModuleReason\")} ModuleReason */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n/**\n *  @typedef {Object} WithId an object who has an id property *\n *  @property {string | number} id the id of the object\n */\n\n/**\n * Compare two Modules based on their ids for sorting\n * @param {Module} a module\n * @param {Module} b module\n * @returns {-1|0|1} sort value\n */\n\n// TODO use @callback\n/** @typedef {(a: Module, b: Module) => -1|0|1} ModuleSortPredicate */\n/** @typedef {(m: Module) => boolean} ModuleFilterPredicate */\n/** @typedef {(c: Chunk) => boolean} ChunkFilterPredicate */\n\nconst sortModuleById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * Compare two ChunkGroups based on their ids for sorting\n * @param {ChunkGroup} a chunk group\n * @param {ChunkGroup} b chunk group\n * @returns {-1|0|1} sort value\n */\nconst sortChunkGroupById = (a, b) => {\n\tif (a.id < b.id) return -1;\n\tif (b.id < a.id) return 1;\n\treturn 0;\n};\n\n/**\n * Compare two Identifiables , based on their ids for sorting\n * @param {Module} a first object with ident fn\n * @param {Module} b second object with ident fn\n * @returns {-1|0|1} The order number of the sort\n */\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\n/**\n * @returns {string} a concatenation of module identifiers sorted\n * @param {SortableSet} set to pull module identifiers from\n */\nconst getModulesIdent = set => {\n\tset.sort();\n\tlet str = \"\";\n\tfor (const m of set) {\n\t\tstr += m.identifier() + \"#\";\n\t}\n\treturn str;\n};\n\n/**\n * @template T\n * @param {SortableSet<T>} set the sortable set to convert to array\n * @returns {Array<T>} the array returned from Array.from(set)\n */\nconst getArray = set => Array.from(set);\n\n/**\n * @param {SortableSet<Module>} set the sortable Set to get the count/size of\n * @returns {number} the size of the modules\n */\nconst getModulesSize = set => {\n\tlet size = 0;\n\tfor (const module of set) {\n\t\tsize += module.size();\n\t}\n\treturn size;\n};\n\n/**\n * A Chunk is a unit of encapsulation for Modules.\n * Chunks are \"rendered\" into bundles that get emitted when the build completes.\n */\nclass Chunk {\n\t/**\n\t * @param {string=} name of chunk being created, is optional (for subclasses)\n\t */\n\tconstructor(name) {\n\t\t/** @type {number | null} */\n\t\tthis.id = null;\n\t\t/** @type {number[] | null} */\n\t\tthis.ids = null;\n\t\t/** @type {number} */\n\t\tthis.debugId = debugId++;\n\t\t/** @type {string} */\n\t\tthis.name = name;\n\t\t/** @type {boolean} */\n\t\tthis.preventIntegration = false;\n\t\t/** @type {Module=} */\n\t\tthis.entryModule = undefined;\n\t\t/** @private @type {SortableSet<Module>} */\n\t\tthis._modules = new SortableSet(undefined, sortByIdentifier);\n\t\t/** @type {string?} */\n\t\tthis.filenameTemplate = undefined;\n\t\t/** @private @type {SortableSet<ChunkGroup>} */\n\t\tthis._groups = new SortableSet(undefined, sortChunkGroupById);\n\t\t/** @type {string[]} */\n\t\tthis.files = [];\n\t\t/** @type {boolean} */\n\t\tthis.rendered = false;\n\t\t/** @type {string=} */\n\t\tthis.hash = undefined;\n\t\t/** @type {Object} */\n\t\tthis.contentHash = Object.create(null);\n\t\t/** @type {string=} */\n\t\tthis.renderedHash = undefined;\n\t\t/** @type {string=} */\n\t\tthis.chunkReason = undefined;\n\t\t/** @type {boolean} */\n\t\tthis.extraAsync = false;\n\t\tthis.removedModules = undefined;\n\t}\n\n\t/**\n\t * @deprecated Chunk.entry has been deprecated. Please use .hasRuntime() instead\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tget entry() {\n\t\tthrow new Error(ERR_CHUNK_ENTRY);\n\t}\n\n\t/**\n\t * @deprecated .entry has been deprecated. Please use .hasRuntime() instead\n\t * @param {never} data The data that was attempting to be set\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tset entry(data) {\n\t\tthrow new Error(ERR_CHUNK_ENTRY);\n\t}\n\n\t/**\n\t * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tget initial() {\n\t\tthrow new Error(ERR_CHUNK_INITIAL);\n\t}\n\n\t/**\n\t * @deprecated Chunk.initial was removed. Use canBeInitial/isOnlyInitial()\n\t * @param {never} data The data attempting to be set\n\t * @returns {never} Throws an error trying to access this property\n\t */\n\tset initial(data) {\n\t\tthrow new Error(ERR_CHUNK_INITIAL);\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not the Chunk will have a runtime\n\t */\n\thasRuntime() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (\n\t\t\t\tchunkGroup.isInitial() &&\n\t\t\t\tchunkGroup instanceof Entrypoint &&\n\t\t\t\tchunkGroup.getRuntimeChunk() === this\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether or not this chunk can be an initial chunk\n\t */\n\tcanBeInitial() {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (chunkGroup.isInitial()) return true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @returns {boolean} whether this chunk can only be an initial chunk\n\t */\n\tisOnlyInitial() {\n\t\tif (this._groups.size <= 0) return false;\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tif (!chunkGroup.isInitial()) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @returns {boolean} if this chunk contains the entry module\n\t */\n\thasEntryModule() {\n\t\treturn !!this.entryModule;\n\t}\n\n\t/**\n\t * @param {Module} module the module that will be added to this chunk.\n\t * @returns {boolean} returns true if the chunk doesn't have the module and it was added\n\t */\n\taddModule(module) {\n\t\tif (!this._modules.has(module)) {\n\t\t\tthis._modules.add(module);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module} module the module that will be removed from this chunk\n\t * @returns {boolean} returns true if chunk exists and is successfully deleted\n\t */\n\tremoveModule(module) {\n\t\tif (this._modules.delete(module)) {\n\t\t\tmodule.removeChunk(this);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Module[]} modules the new modules to be set\n\t * @returns {void} set new modules to this chunk and return nothing\n\t */\n\tsetModules(modules) {\n\t\tthis._modules = new SortableSet(modules, sortByIdentifier);\n\t}\n\n\t/**\n\t * @returns {number} the amount of modules in chunk\n\t */\n\tgetNumberOfModules() {\n\t\treturn this._modules.size;\n\t}\n\n\t/**\n\t * @returns {SortableSet} return the modules SortableSet for this chunk\n\t */\n\tget modulesIterable() {\n\t\treturn this._modules;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being added\n\t * @returns {boolean} returns true if chunk is not apart of chunkGroup and is added successfully\n\t */\n\taddGroup(chunkGroup) {\n\t\tif (this._groups.has(chunkGroup)) return false;\n\t\tthis._groups.add(chunkGroup);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup the chunk is being removed from\n\t * @returns {boolean} returns true if chunk does exist in chunkGroup and is removed\n\t */\n\tremoveGroup(chunkGroup) {\n\t\tif (!this._groups.has(chunkGroup)) return false;\n\t\tthis._groups.delete(chunkGroup);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {ChunkGroup} chunkGroup the chunkGroup to check\n\t * @returns {boolean} returns true if chunk has chunkGroup reference and exists in chunkGroup\n\t */\n\tisInGroup(chunkGroup) {\n\t\treturn this._groups.has(chunkGroup);\n\t}\n\n\t/**\n\t * @returns {number} the amount of groups said chunk is in\n\t */\n\tgetNumberOfGroups() {\n\t\treturn this._groups.size;\n\t}\n\n\t/**\n\t * @returns {SortableSet<ChunkGroup>} the chunkGroups that said chunk is referenced in\n\t */\n\tget groupsIterable() {\n\t\treturn this._groups;\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the chunk to compare itself with\n\t * @returns {-1|0|1} this is a comparitor function like sort and returns -1, 0, or 1 based on sort order\n\t */\n\tcompareTo(otherChunk) {\n\t\tif (this.name && !otherChunk.name) return -1;\n\t\tif (!this.name && otherChunk.name) return 1;\n\t\tif (this.name < otherChunk.name) return -1;\n\t\tif (this.name > otherChunk.name) return 1;\n\t\tif (this._modules.size > otherChunk._modules.size) return -1;\n\t\tif (this._modules.size < otherChunk._modules.size) return 1;\n\t\tthis._modules.sort();\n\t\totherChunk._modules.sort();\n\t\tconst a = this._modules[Symbol.iterator]();\n\t\tconst b = otherChunk._modules[Symbol.iterator]();\n\t\t// eslint-disable-next-line no-constant-condition\n\t\twhile (true) {\n\t\t\tconst aItem = a.next();\n\t\t\tif (aItem.done) return 0;\n\t\t\tconst bItem = b.next();\n\t\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\t\tif (aModuleIdentifier < bModuleIdentifier) return -1;\n\t\t\tif (aModuleIdentifier > bModuleIdentifier) return 1;\n\t\t}\n\t}\n\n\t/**\n\t * @param {Module} module Module to check\n\t * @returns {boolean} returns true if module does exist in this chunk\n\t */\n\tcontainsModule(module) {\n\t\treturn this._modules.has(module);\n\t}\n\n\t/**\n\t * @returns {Module[]} an array of modules (do not modify)\n\t */\n\tgetModules() {\n\t\treturn this._modules.getFromCache(getArray);\n\t}\n\n\tgetModulesIdent() {\n\t\treturn this._modules.getFromUnorderedCache(getModulesIdent);\n\t}\n\n\t/**\n\t * @param {string=} reason reason why chunk is removed\n\t * @returns {void}\n\t */\n\tremove(reason) {\n\t\t// cleanup modules\n\t\t// Array.from is used here to create a clone, because removeChunk modifies this._modules\n\t\tfor (const module of Array.from(this._modules)) {\n\t\t\tmodule.removeChunk(this);\n\t\t}\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.removeChunk(this);\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {Module} module module to move\n\t * @param {Chunk} otherChunk other chunk to move it to\n\t * @returns {void}\n\t */\n\tmoveModule(module, otherChunk) {\n\t\tGraphHelpers.disconnectChunkAndModule(this, module);\n\t\tGraphHelpers.connectChunkAndModule(otherChunk, module);\n\t\tmodule.rewriteChunkInReasons(this, [otherChunk]);\n\t}\n\n\t/**\n\t *\n\t * @param {Chunk} otherChunk the chunk to integrate with\n\t * @param {string} reason reason why the module is being integrated\n\t * @returns {boolean} returns true or false if integration succeeds or fails\n\t */\n\tintegrate(otherChunk, reason) {\n\t\tif (!this.canBeIntegrated(otherChunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Pick a new name for the integrated chunk\n\t\tif (this.name && otherChunk.name) {\n\t\t\tif (this.hasEntryModule() === otherChunk.hasEntryModule()) {\n\t\t\t\t// When both chunks have entry modules or none have one, use\n\t\t\t\t// shortest name\n\t\t\t\tif (this.name.length !== otherChunk.name.length) {\n\t\t\t\t\tthis.name =\n\t\t\t\t\t\tthis.name.length < otherChunk.name.length\n\t\t\t\t\t\t\t? this.name\n\t\t\t\t\t\t\t: otherChunk.name;\n\t\t\t\t} else {\n\t\t\t\t\tthis.name = this.name < otherChunk.name ? this.name : otherChunk.name;\n\t\t\t\t}\n\t\t\t} else if (otherChunk.hasEntryModule()) {\n\t\t\t\t// Pick the name of the chunk with the entry module\n\t\t\t\tthis.name = otherChunk.name;\n\t\t\t}\n\t\t} else if (otherChunk.name) {\n\t\t\tthis.name = otherChunk.name;\n\t\t}\n\n\t\t// Array.from is used here to create a clone, because moveModule modifies otherChunk._modules\n\t\tfor (const module of Array.from(otherChunk._modules)) {\n\t\t\totherChunk.moveModule(module, this);\n\t\t}\n\t\totherChunk._modules.clear();\n\n\t\tif (otherChunk.entryModule) {\n\t\t\tthis.entryModule = otherChunk.entryModule;\n\t\t}\n\n\t\tfor (const chunkGroup of otherChunk._groups) {\n\t\t\tchunkGroup.replaceChunk(otherChunk, this);\n\t\t\tthis.addGroup(chunkGroup);\n\t\t}\n\t\totherChunk._groups.clear();\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {Chunk} newChunk the new chunk that will be split out of the current chunk\n\t * @returns {void}\n\t */\n\tsplit(newChunk) {\n\t\tfor (const chunkGroup of this._groups) {\n\t\t\tchunkGroup.insertChunk(newChunk, this);\n\t\t\tnewChunk.addGroup(chunkGroup);\n\t\t}\n\t}\n\n\tisEmpty() {\n\t\treturn this._modules.size === 0;\n\t}\n\n\tupdateHash(hash) {\n\t\thash.update(`${this.id} `);\n\t\thash.update(this.ids ? this.ids.join(\",\") : \"\");\n\t\thash.update(`${this.name || \"\"} `);\n\t\tfor (const m of this._modules) {\n\t\t\thash.update(m.hash);\n\t\t}\n\t}\n\n\tcanBeIntegrated(otherChunk) {\n\t\tif (this.preventIntegration || otherChunk.preventIntegration) {\n\t\t\treturn false;\n\t\t}\n\n\t\t/**\n\t\t * @param {Chunk} a chunk\n\t\t * @param {Chunk} b chunk\n\t\t * @returns {boolean} true, if a is always available when b is reached\n\t\t */\n\t\tconst isAvailable = (a, b) => {\n\t\t\tconst queue = new Set(b.groupsIterable);\n\t\t\tfor (const chunkGroup of queue) {\n\t\t\t\tif (a.isInGroup(chunkGroup)) continue;\n\t\t\t\tif (chunkGroup.isInitial()) return false;\n\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\tqueue.add(parent);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\tconst selfHasRuntime = this.hasRuntime();\n\t\tconst otherChunkHasRuntime = otherChunk.hasRuntime();\n\n\t\tif (selfHasRuntime !== otherChunkHasRuntime) {\n\t\t\tif (selfHasRuntime) {\n\t\t\t\treturn isAvailable(this, otherChunk);\n\t\t\t} else if (otherChunkHasRuntime) {\n\t\t\t\treturn isAvailable(otherChunk, this);\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (this.hasEntryModule() || otherChunk.hasEntryModule()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t *\n\t * @param {number} size the size\n\t * @param {Object} options the options passed in\n\t * @returns {number} the multiplier returned\n\t */\n\taddMultiplierAndOverhead(size, options) {\n\t\tconst overhead =\n\t\t\ttypeof options.chunkOverhead === \"number\" ? options.chunkOverhead : 10000;\n\t\tconst multiplicator = this.canBeInitial()\n\t\t\t? options.entryChunkMultiplicator || 10\n\t\t\t: 1;\n\n\t\treturn size * multiplicator + overhead;\n\t}\n\n\t/**\n\t * @returns {number} the size of all modules\n\t */\n\tmodulesSize() {\n\t\treturn this._modules.getFromUnorderedCache(getModulesSize);\n\t}\n\n\t/**\n\t * @param {Object} options the size display options\n\t * @returns {number} the chunk size\n\t */\n\tsize(options = {}) {\n\t\treturn this.addMultiplierAndOverhead(this.modulesSize(), options);\n\t}\n\n\t/**\n\t * @param {Chunk} otherChunk the other chunk\n\t * @param {TODO} options the options for this function\n\t * @returns {number | false} the size, or false if it can't be integrated\n\t */\n\tintegratedSize(otherChunk, options) {\n\t\t// Chunk if it's possible to integrate this chunk\n\t\tif (!this.canBeIntegrated(otherChunk)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet integratedModulesSize = this.modulesSize();\n\t\t// only count modules that do not exist in this chunk!\n\t\tfor (const otherModule of otherChunk._modules) {\n\t\t\tif (!this._modules.has(otherModule)) {\n\t\t\t\tintegratedModulesSize += otherModule.size();\n\t\t\t}\n\t\t}\n\n\t\treturn this.addMultiplierAndOverhead(integratedModulesSize, options);\n\t}\n\n\t/**\n\t * @param {function(Module, Module): -1|0|1=} sortByFn a predicate function used to sort modules\n\t * @returns {void}\n\t */\n\tsortModules(sortByFn) {\n\t\tthis._modules.sortWith(sortByFn || sortModuleById);\n\t}\n\n\tsortItems() {\n\t\tthis.sortModules();\n\t}\n\n\t/**\n\t * @returns {Set<Chunk>} a set of all the async chunks\n\t */\n\tgetAllAsyncChunks() {\n\t\tconst queue = new Set();\n\t\tconst chunks = new Set();\n\n\t\tconst initialChunks = intersect(\n\t\t\tArray.from(this.groupsIterable, g => new Set(g.chunks))\n\t\t);\n\n\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!initialChunks.has(chunk)) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n\n\t/**\n\t * @typedef {Object} ChunkMaps\n\t * @property {Record<string|number, string>} hash\n\t * @property {Record<string|number, Record<string, string>>} contentHash\n\t * @property {Record<string|number, string>} name\n\t */\n\n\t/**\n\t * @param {boolean} realHash should the full hash or the rendered hash be used\n\t * @returns {ChunkMaps} the chunk map information\n\t */\n\tgetChunkMaps(realHash) {\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, Record<string, string>>} */\n\t\tconst chunkContentHashMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkNameMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\tchunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;\n\t\t\tfor (const key of Object.keys(chunk.contentHash)) {\n\t\t\t\tif (!chunkContentHashMap[key]) {\n\t\t\t\t\tchunkContentHashMap[key] = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkContentHashMap[key][chunk.id] = chunk.contentHash[key];\n\t\t\t}\n\t\t\tif (chunk.name) {\n\t\t\t\tchunkNameMap[chunk.id] = chunk.name;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\thash: chunkHashMap,\n\t\t\tcontentHash: chunkContentHashMap,\n\t\t\tname: chunkNameMap\n\t\t};\n\t}\n\n\t/**\n\t * @returns {Record<string, Set<TODO>[]>} a record object of names to lists of child ids(?)\n\t */\n\tgetChildIdsByOrders() {\n\t\tconst lists = new Map();\n\t\tfor (const group of this.groupsIterable) {\n\t\t\tif (group.chunks[group.chunks.length - 1] === this) {\n\t\t\t\tfor (const childGroup of group.childrenIterable) {\n\t\t\t\t\t// TODO webpack 5 remove this check for options\n\t\t\t\t\tif (typeof childGroup.options === \"object\") {\n\t\t\t\t\t\tfor (const key of Object.keys(childGroup.options)) {\n\t\t\t\t\t\t\tif (key.endsWith(\"Order\")) {\n\t\t\t\t\t\t\t\tconst name = key.substr(0, key.length - \"Order\".length);\n\t\t\t\t\t\t\t\tlet list = lists.get(name);\n\t\t\t\t\t\t\t\tif (list === undefined) lists.set(name, (list = []));\n\t\t\t\t\t\t\t\tlist.push({\n\t\t\t\t\t\t\t\t\torder: childGroup.options[key],\n\t\t\t\t\t\t\t\t\tgroup: childGroup\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst result = Object.create(null);\n\t\tfor (const [name, list] of lists) {\n\t\t\tlist.sort((a, b) => {\n\t\t\t\tconst cmp = b.order - a.order;\n\t\t\t\tif (cmp !== 0) return cmp;\n\t\t\t\t// TODO webpack 5 remove this check of compareTo\n\t\t\t\tif (a.group.compareTo) {\n\t\t\t\t\treturn a.group.compareTo(b.group);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t});\n\t\t\tresult[name] = Array.from(\n\t\t\t\tlist.reduce((set, item) => {\n\t\t\t\t\tfor (const chunk of item.group.chunks) {\n\t\t\t\t\t\tset.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t\treturn set;\n\t\t\t\t}, new Set())\n\t\t\t);\n\t\t}\n\t\treturn result;\n\t}\n\n\tgetChildIdsByOrdersMap(includeDirectChildren) {\n\t\tconst chunkMaps = Object.create(null);\n\n\t\tconst addChildIdsByOrdersToMap = chunk => {\n\t\t\tconst data = chunk.getChildIdsByOrders();\n\t\t\tfor (const key of Object.keys(data)) {\n\t\t\t\tlet chunkMap = chunkMaps[key];\n\t\t\t\tif (chunkMap === undefined) {\n\t\t\t\t\tchunkMaps[key] = chunkMap = Object.create(null);\n\t\t\t\t}\n\t\t\t\tchunkMap[chunk.id] = data[key];\n\t\t\t}\n\t\t};\n\n\t\tif (includeDirectChildren) {\n\t\t\tconst chunks = new Set();\n\t\t\tfor (const chunkGroup of this.groupsIterable) {\n\t\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\t\tchunks.add(chunk);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const chunk of chunks) {\n\t\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t\t}\n\t\t}\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\taddChildIdsByOrdersToMap(chunk);\n\t\t}\n\n\t\treturn chunkMaps;\n\t}\n\n\t/**\n\t * @typedef {Object} ChunkModuleMaps\n\t * @property {Record<string|number, (string|number)[]>} id\n\t * @property {Record<string|number, string>} hash\n\t */\n\n\t/**\n\t * @param {ModuleFilterPredicate} filterFn function used to filter modules\n\t * @returns {ChunkModuleMaps} module map information\n\t */\n\tgetChunkModuleMaps(filterFn) {\n\t\t/** @type {Record<string|number, (string|number)[]>} */\n\t\tconst chunkModuleIdMap = Object.create(null);\n\t\t/** @type {Record<string|number, string>} */\n\t\tconst chunkModuleHashMap = Object.create(null);\n\n\t\tfor (const chunk of this.getAllAsyncChunks()) {\n\t\t\t/** @type {(string|number)[]} */\n\t\t\tlet array;\n\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\tchunkModuleIdMap[chunk.id] = array;\n\t\t\t\t\t}\n\t\t\t\t\tarray.push(module.id);\n\t\t\t\t\tchunkModuleHashMap[module.id] = module.renderedHash;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (array !== undefined) {\n\t\t\t\tarray.sort();\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: chunkModuleIdMap,\n\t\t\thash: chunkModuleHashMap\n\t\t};\n\t}\n\n\t/**\n\t *\n\t * @param {function(Module): boolean} filterFn predicate function used to filter modules\n\t * @param {function(Chunk): boolean} filterChunkFn predicate function used to filter chunks\n\t * @returns {boolean} return true if module exists in graph\n\t */\n\thasModuleInGraph(filterFn, filterChunkFn) {\n\t\tconst queue = new Set(this.groupsIterable);\n\t\tconst chunksProcessed = new Set();\n\n\t\tfor (const chunkGroup of queue) {\n\t\t\tfor (const chunk of chunkGroup.chunks) {\n\t\t\t\tif (!chunksProcessed.has(chunk)) {\n\t\t\t\t\tchunksProcessed.add(chunk);\n\t\t\t\t\tif (!filterChunkFn || filterChunkFn(chunk)) {\n\t\t\t\t\t\tfor (const module of chunk.modulesIterable) {\n\t\t\t\t\t\t\tif (filterFn(module)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\tqueue.add(child);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\ttoString() {\n\t\treturn `Chunk[${Array.from(this._modules).join()}]`;\n\t}\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"forEachModule\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @this {Chunk}\n\t\t * @typedef {function(any, any, Set<any>): void} ForEachModuleCallback\n\t\t * @param {ForEachModuleCallback} fn Callback function\n\t\t * @returns {void}\n\t\t */\n\t\tfunction(fn) {\n\t\t\tthis._modules.forEach(fn);\n\t\t},\n\t\t\"Chunk.forEachModule: Use for(const module of chunk.modulesIterable) instead\"\n\t)\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"mapModules\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @this {Chunk}\n\t\t * @typedef {function(any, number): any} MapModulesCallback\n\t\t * @param {MapModulesCallback} fn Callback function\n\t\t * @returns {TODO[]} result of mapped modules\n\t\t */\n\t\tfunction(fn) {\n\t\t\treturn Array.from(this._modules, fn);\n\t\t},\n\t\t\"Chunk.mapModules: Use Array.from(chunk.modulesIterable, fn) instead\"\n\t)\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"chunks\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.chunks: Use ChunkGroup.getChildren() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.chunks: Use ChunkGroup.add/removeChild() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"parents\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.parents: Use ChunkGroup.getParents() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.parents: Use ChunkGroup.add/removeParent() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"blocks\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\"Chunk.blocks: Use ChunkGroup.getBlocks() instead\");\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.blocks: Use ChunkGroup.add/removeBlock() instead\");\n\t}\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Chunk.prototype, \"entrypoints\", {\n\tconfigurable: false,\n\tget() {\n\t\tthrow new Error(\n\t\t\t\"Chunk.entrypoints: Use Chunks.groupsIterable and filter by instanceof Entrypoint instead\"\n\t\t);\n\t},\n\tset() {\n\t\tthrow new Error(\"Chunk.entrypoints: Use Chunks.addGroup instead\");\n\t}\n});\n\nmodule.exports = Chunk;\n"]},"metadata":{},"sourceType":"script"}