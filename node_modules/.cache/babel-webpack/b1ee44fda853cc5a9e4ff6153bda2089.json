{"ast":null,"code":"'use strict';\n\nvar mime = require('mime');\n\nvar createContext = require('./lib/context');\n\nvar middleware = require('./lib/middleware');\n\nvar reporter = require('./lib/reporter');\n\nvar _require = require('./lib/fs'),\n    setFs = _require.setFs,\n    toDisk = _require.toDisk;\n\nvar _require2 = require('./lib/util'),\n    getFilenameFromUrl = _require2.getFilenameFromUrl,\n    noop = _require2.noop,\n    ready = _require2.ready;\n\nvar defaults = {\n  logLevel: 'info',\n  logTime: false,\n  logger: null,\n  mimeTypes: null,\n  reporter: reporter,\n  stats: {\n    colors: true,\n    context: process.cwd()\n  },\n  watchOptions: {\n    aggregateTimeout: 200\n  },\n  writeToDisk: false\n};\n\nmodule.exports = function wdm(compiler, opts) {\n  var options = Object.assign({}, defaults, opts); // defining custom MIME type\n\n  if (options.mimeTypes) {\n    var typeMap = options.mimeTypes.typeMap || options.mimeTypes;\n    var force = !!options.mimeTypes.force;\n    mime.define(typeMap, force);\n  }\n\n  var context = createContext(compiler, options); // start watching\n\n  if (!options.lazy) {\n    context.watching = compiler.watch(options.watchOptions, function (err) {\n      if (err) {\n        context.log.error(err.stack || err);\n\n        if (err.details) {\n          context.log.error(err.details);\n        }\n      }\n    });\n  } else {\n    if (typeof options.filename === 'string') {\n      var filename = options.filename.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&') // eslint-disable-line no-useless-escape\n      .replace(/\\\\\\[[a-z]+\\\\\\]/gi, '.+');\n      options.filename = new RegExp(\"^[/]{0,1}\".concat(filename, \"$\"));\n    }\n\n    context.state = true;\n  }\n\n  if (options.writeToDisk) {\n    toDisk(context);\n  }\n\n  setFs(context, compiler);\n  return Object.assign(middleware(context), {\n    close: function close(callback) {\n      // eslint-disable-next-line no-param-reassign\n      callback = callback || noop;\n\n      if (context.watching) {\n        context.watching.close(callback);\n      } else {\n        callback();\n      }\n    },\n    context: context,\n    fileSystem: context.fs,\n    getFilenameFromUrl: getFilenameFromUrl.bind(this, context.options.publicPath, context.compiler),\n    invalidate: function invalidate(callback) {\n      // eslint-disable-next-line no-param-reassign\n      callback = callback || noop;\n\n      if (context.watching) {\n        ready(context, callback, {});\n        context.watching.invalidate();\n      } else {\n        callback();\n      }\n    },\n    waitUntilValid: function waitUntilValid(callback) {\n      // eslint-disable-next-line no-param-reassign\n      callback = callback || noop;\n      ready(context, callback, {});\n    }\n  });\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack-dev-server/node_modules/webpack-dev-middleware/index.js"],"names":["mime","require","createContext","middleware","reporter","setFs","toDisk","getFilenameFromUrl","noop","ready","defaults","logLevel","logTime","logger","mimeTypes","stats","colors","context","process","cwd","watchOptions","aggregateTimeout","writeToDisk","module","exports","wdm","compiler","opts","options","Object","assign","typeMap","force","define","lazy","watching","watch","err","log","error","stack","details","filename","replace","RegExp","state","close","callback","fileSystem","fs","bind","publicPath","invalidate","waitUntilValid"],"mappings":"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","sourcesContent":["'use strict';\n\nconst mime = require('mime');\n\nconst createContext = require('./lib/context');\nconst middleware = require('./lib/middleware');\nconst reporter = require('./lib/reporter');\nconst { setFs, toDisk } = require('./lib/fs');\nconst { getFilenameFromUrl, noop, ready } = require('./lib/util');\n\nconst defaults = {\n  logLevel: 'info',\n  logTime: false,\n  logger: null,\n  mimeTypes: null,\n  reporter,\n  stats: {\n    colors: true,\n    context: process.cwd(),\n  },\n  watchOptions: {\n    aggregateTimeout: 200,\n  },\n  writeToDisk: false,\n};\n\nmodule.exports = function wdm(compiler, opts) {\n  const options = Object.assign({}, defaults, opts);\n\n  // defining custom MIME type\n  if (options.mimeTypes) {\n    const typeMap = options.mimeTypes.typeMap || options.mimeTypes;\n    const force = !!options.mimeTypes.force;\n    mime.define(typeMap, force);\n  }\n\n  const context = createContext(compiler, options);\n\n  // start watching\n  if (!options.lazy) {\n    context.watching = compiler.watch(options.watchOptions, (err) => {\n      if (err) {\n        context.log.error(err.stack || err);\n        if (err.details) {\n          context.log.error(err.details);\n        }\n      }\n    });\n  } else {\n    if (typeof options.filename === 'string') {\n      const filename = options.filename\n        .replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&') // eslint-disable-line no-useless-escape\n        .replace(/\\\\\\[[a-z]+\\\\\\]/gi, '.+');\n\n      options.filename = new RegExp(`^[/]{0,1}${filename}$`);\n    }\n\n    context.state = true;\n  }\n\n  if (options.writeToDisk) {\n    toDisk(context);\n  }\n\n  setFs(context, compiler);\n\n  return Object.assign(middleware(context), {\n    close(callback) {\n      // eslint-disable-next-line no-param-reassign\n      callback = callback || noop;\n\n      if (context.watching) {\n        context.watching.close(callback);\n      } else {\n        callback();\n      }\n    },\n\n    context,\n\n    fileSystem: context.fs,\n\n    getFilenameFromUrl: getFilenameFromUrl.bind(\n      this,\n      context.options.publicPath,\n      context.compiler\n    ),\n\n    invalidate(callback) {\n      // eslint-disable-next-line no-param-reassign\n      callback = callback || noop;\n\n      if (context.watching) {\n        ready(context, callback, {});\n        context.watching.invalidate();\n      } else {\n        callback();\n      }\n    },\n\n    waitUntilValid(callback) {\n      // eslint-disable-next-line no-param-reassign\n      callback = callback || noop;\n\n      ready(context, callback, {});\n    },\n  });\n};\n"]},"metadata":{},"sourceType":"script"}