{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/metadata/src/api\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/api.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DirectiveMeta as T2DirectiveMeta, SchemaMetadata} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ClassPropertyMapping, ClassPropertyName} from './property_mapping';\n\n\n/**\n * Metadata collected for an `NgModule`.\n */\nexport interface NgModuleMeta {\n  ref: Reference<ClassDeclaration>;\n  declarations: Reference<ClassDeclaration>[];\n  imports: Reference<ClassDeclaration>[];\n  exports: Reference<ClassDeclaration>[];\n  schemas: SchemaMetadata[];\n\n  /**\n   * The raw `ts.Expression` which gave rise to `declarations`, if one exists.\n   *\n   * If this is `null`, then either no declarations exist, or no expression was available (likely\n   * because the module came from a .d.ts file).\n   */\n  rawDeclarations: ts.Expression|null;\n}\n\n/**\n * Typing metadata collected for a directive within an NgModule's scope.\n */\nexport interface DirectiveTypeCheckMeta {\n  /**\n   * List of static `ngTemplateGuard_xx` members found on the Directive's class.\n   * @see `TemplateGuardMeta`\n   */\n  ngTemplateGuards: TemplateGuardMeta[];\n\n  /**\n   * Whether the Directive's class has a static ngTemplateContextGuard function.\n   */\n  hasNgTemplateContextGuard: boolean;\n\n  /**\n   * The set of input fields which have a corresponding static `ngAcceptInputType_` on the\n   * Directive's class. This allows inputs to accept a wider range of types and coerce the input to\n   * a narrower type with a getter/setter. See https://angular.io/guide/template-typecheck.\n   */\n  coercedInputFields: Set<ClassPropertyName>;\n\n  /**\n   * The set of input fields which map to `readonly`, `private`, or `protected` members in the\n   * Directive's class.\n   */\n  restrictedInputFields: Set<ClassPropertyName>;\n\n  /**\n   * The set of input fields which are declared as string literal members in the Directive's class.\n   * We need to track these separately because these fields may not be valid JS identifiers so\n   * we cannot use them with property access expressions when assigning inputs.\n   */\n  stringLiteralInputFields: Set<ClassPropertyName>;\n\n  /**\n   * The set of input fields which do not have corresponding members in the Directive's class.\n   */\n  undeclaredInputFields: Set<ClassPropertyName>;\n\n  /**\n   * Whether the Directive's class is generic, i.e. `class MyDir<T> {...}`.\n   */\n  isGeneric: boolean;\n}\n\n/**\n * Metadata collected for a directive within an NgModule's scope.\n */\nexport interface DirectiveMeta extends T2DirectiveMeta, DirectiveTypeCheckMeta {\n  ref: Reference<ClassDeclaration>;\n  /**\n   * Unparsed selector of the directive, or null if the directive does not have a selector.\n   */\n  selector: string|null;\n  queries: string[];\n\n  /**\n   * A mapping of input field names to the property names.\n   */\n  inputs: ClassPropertyMapping;\n\n  /**\n   * A mapping of output field names to the property names.\n   */\n  outputs: ClassPropertyMapping;\n\n  /**\n   * A `Reference` to the base class for the directive, if one was detected.\n   *\n   * A value of `'dynamic'` indicates that while the analyzer detected that this directive extends\n   * another type, it could not statically determine the base class.\n   */\n  baseClass: Reference<ClassDeclaration>|'dynamic'|null;\n\n  /**\n   * Whether the directive had some issue with its declaration that means it might not have complete\n   * and reliable metadata.\n   */\n  isPoisoned: boolean;\n\n  /**\n   * Whether the directive is likely a structural directive (injects `TemplateRef`).\n   */\n  isStructural: boolean;\n}\n\n/**\n * Metadata that describes a template guard for one of the directive's inputs.\n */\nexport interface TemplateGuardMeta {\n  /**\n   * The input name that this guard should be applied to.\n   */\n  inputName: string;\n\n  /**\n   * Represents the type of the template guard.\n   *\n   * - 'invocation' means that a call to the template guard function is emitted so that its return\n   *   type can result in narrowing of the input type.\n   * - 'binding' means that the input binding expression itself is used as template guard.\n   */\n  type: 'invocation'|'binding';\n}\n\n/**\n * Metadata for a pipe within an NgModule's scope.\n */\nexport interface PipeMeta {\n  ref: Reference<ClassDeclaration>;\n  name: string;\n}\n\n/**\n * Reads metadata for directives, pipes, and modules from a particular source, such as .d.ts files\n * or a registry.\n */\nexport interface MetadataReader {\n  getDirectiveMetadata(node: Reference<ClassDeclaration>): DirectiveMeta|null;\n  getNgModuleMetadata(node: Reference<ClassDeclaration>): NgModuleMeta|null;\n  getPipeMetadata(node: Reference<ClassDeclaration>): PipeMeta|null;\n}\n\n/**\n * Registers new metadata for directives, pipes, and modules.\n */\nexport interface MetadataRegistry {\n  registerDirectiveMetadata(meta: DirectiveMeta): void;\n  registerNgModuleMetadata(meta: NgModuleMeta): void;\n  registerPipeMetadata(meta: PipeMeta): void;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}