{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/selector\", [\"require\", \"exports\", \"@angular/compiler/src/ml_parser/html_tags\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SelectorContext = exports.SelectorListContext = exports.SelectorMatcher = exports.CssSelector = void 0;\n\n  var html_tags_1 = require(\"@angular/compiler/src/ml_parser/html_tags\");\n\n  var _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + // 1: \":not(\"\n  '(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n  // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n  // 4: attribute; 5: attribute_string; 6: attribute_value\n  '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n  // \"[name=\"value\"]\",\n  // \"[name='value']\"\n  '(\\\\))|' + // 7: \")\"\n  '(\\\\s*,\\\\s*)', // 8: \",\"\n  'g');\n  /**\n   * A css selector contains an element name,\n   * css classes and attribute/value pairs with the purpose\n   * of selecting subsets out of them.\n   */\n\n\n  var CssSelector =\n  /** @class */\n  function () {\n    function CssSelector() {\n      this.element = null;\n      this.classNames = [];\n      /**\n       * The selectors are encoded in pairs where:\n       * - even locations are attribute names\n       * - odd locations are attribute values.\n       *\n       * Example:\n       * Selector: `[key1=value1][key2]` would parse to:\n       * ```\n       * ['key1', 'value1', 'key2', '']\n       * ```\n       */\n\n      this.attrs = [];\n      this.notSelectors = [];\n    }\n\n    CssSelector.parse = function (selector) {\n      var results = [];\n\n      var _addResult = function _addResult(res, cssSel) {\n        if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {\n          cssSel.element = '*';\n        }\n\n        res.push(cssSel);\n      };\n\n      var cssSelector = new CssSelector();\n      var match;\n      var current = cssSelector;\n      var inNot = false;\n      _SELECTOR_REGEXP.lastIndex = 0;\n\n      while (match = _SELECTOR_REGEXP.exec(selector)) {\n        if (match[1\n        /* NOT */\n        ]) {\n          if (inNot) {\n            throw new Error('Nesting :not in a selector is not allowed');\n          }\n\n          inNot = true;\n          current = new CssSelector();\n          cssSelector.notSelectors.push(current);\n        }\n\n        var tag = match[2\n        /* TAG */\n        ];\n\n        if (tag) {\n          var prefix = match[3\n          /* PREFIX */\n          ];\n\n          if (prefix === '#') {\n            // #hash\n            current.addAttribute('id', tag.substr(1));\n          } else if (prefix === '.') {\n            // Class\n            current.addClassName(tag.substr(1));\n          } else {\n            // Element\n            current.setElement(tag);\n          }\n        }\n\n        var attribute = match[4\n        /* ATTRIBUTE */\n        ];\n\n        if (attribute) {\n          current.addAttribute(attribute, match[6\n          /* ATTRIBUTE_VALUE */\n          ]);\n        }\n\n        if (match[7\n        /* NOT_END */\n        ]) {\n          inNot = false;\n          current = cssSelector;\n        }\n\n        if (match[8\n        /* SEPARATOR */\n        ]) {\n          if (inNot) {\n            throw new Error('Multiple selectors in :not are not supported');\n          }\n\n          _addResult(results, cssSelector);\n\n          cssSelector = current = new CssSelector();\n        }\n      }\n\n      _addResult(results, cssSelector);\n\n      return results;\n    };\n\n    CssSelector.prototype.isElementSelector = function () {\n      return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;\n    };\n\n    CssSelector.prototype.hasElementSelector = function () {\n      return !!this.element;\n    };\n\n    CssSelector.prototype.setElement = function (element) {\n      if (element === void 0) {\n        element = null;\n      }\n\n      this.element = element;\n    };\n    /** Gets a template string for an element that matches the selector. */\n\n\n    CssSelector.prototype.getMatchingElementTemplate = function () {\n      var tagName = this.element || 'div';\n      var classAttr = this.classNames.length > 0 ? \" class=\\\"\" + this.classNames.join(' ') + \"\\\"\" : '';\n      var attrs = '';\n\n      for (var i = 0; i < this.attrs.length; i += 2) {\n        var attrName = this.attrs[i];\n        var attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\" + this.attrs[i + 1] + \"\\\"\" : '';\n        attrs += \" \" + attrName + attrValue;\n      }\n\n      return html_tags_1.getHtmlTagDefinition(tagName).isVoid ? \"<\" + tagName + classAttr + attrs + \"/>\" : \"<\" + tagName + classAttr + attrs + \"></\" + tagName + \">\";\n    };\n\n    CssSelector.prototype.getAttrs = function () {\n      var result = [];\n\n      if (this.classNames.length > 0) {\n        result.push('class', this.classNames.join(' '));\n      }\n\n      return result.concat(this.attrs);\n    };\n\n    CssSelector.prototype.addAttribute = function (name, value) {\n      if (value === void 0) {\n        value = '';\n      }\n\n      this.attrs.push(name, value && value.toLowerCase() || '');\n    };\n\n    CssSelector.prototype.addClassName = function (name) {\n      this.classNames.push(name.toLowerCase());\n    };\n\n    CssSelector.prototype.toString = function () {\n      var res = this.element || '';\n\n      if (this.classNames) {\n        this.classNames.forEach(function (klass) {\n          return res += \".\" + klass;\n        });\n      }\n\n      if (this.attrs) {\n        for (var i = 0; i < this.attrs.length; i += 2) {\n          var name_1 = this.attrs[i];\n          var value = this.attrs[i + 1];\n          res += \"[\" + name_1 + (value ? '=' + value : '') + \"]\";\n        }\n      }\n\n      this.notSelectors.forEach(function (notSelector) {\n        return res += \":not(\" + notSelector + \")\";\n      });\n      return res;\n    };\n\n    return CssSelector;\n  }();\n\n  exports.CssSelector = CssSelector;\n  /**\n   * Reads a list of CssSelectors and allows to calculate which ones\n   * are contained in a given CssSelector.\n   */\n\n  var SelectorMatcher =\n  /** @class */\n  function () {\n    function SelectorMatcher() {\n      this._elementMap = new Map();\n      this._elementPartialMap = new Map();\n      this._classMap = new Map();\n      this._classPartialMap = new Map();\n      this._attrValueMap = new Map();\n      this._attrValuePartialMap = new Map();\n      this._listContexts = [];\n    }\n\n    SelectorMatcher.createNotMatcher = function (notSelectors) {\n      var notMatcher = new SelectorMatcher();\n      notMatcher.addSelectables(notSelectors, null);\n      return notMatcher;\n    };\n\n    SelectorMatcher.prototype.addSelectables = function (cssSelectors, callbackCtxt) {\n      var listContext = null;\n\n      if (cssSelectors.length > 1) {\n        listContext = new SelectorListContext(cssSelectors);\n\n        this._listContexts.push(listContext);\n      }\n\n      for (var i = 0; i < cssSelectors.length; i++) {\n        this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n      }\n    };\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param cssSelector A css selector\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n     */\n\n\n    SelectorMatcher.prototype._addSelectable = function (cssSelector, callbackCtxt, listContext) {\n      var matcher = this;\n      var element = cssSelector.element;\n      var classNames = cssSelector.classNames;\n      var attrs = cssSelector.attrs;\n      var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n      if (element) {\n        var isTerminal = attrs.length === 0 && classNames.length === 0;\n\n        if (isTerminal) {\n          this._addTerminal(matcher._elementMap, element, selectable);\n        } else {\n          matcher = this._addPartial(matcher._elementPartialMap, element);\n        }\n      }\n\n      if (classNames) {\n        for (var i = 0; i < classNames.length; i++) {\n          var isTerminal = attrs.length === 0 && i === classNames.length - 1;\n          var className = classNames[i];\n\n          if (isTerminal) {\n            this._addTerminal(matcher._classMap, className, selectable);\n          } else {\n            matcher = this._addPartial(matcher._classPartialMap, className);\n          }\n        }\n      }\n\n      if (attrs) {\n        for (var i = 0; i < attrs.length; i += 2) {\n          var isTerminal = i === attrs.length - 2;\n          var name_2 = attrs[i];\n          var value = attrs[i + 1];\n\n          if (isTerminal) {\n            var terminalMap = matcher._attrValueMap;\n            var terminalValuesMap = terminalMap.get(name_2);\n\n            if (!terminalValuesMap) {\n              terminalValuesMap = new Map();\n              terminalMap.set(name_2, terminalValuesMap);\n            }\n\n            this._addTerminal(terminalValuesMap, value, selectable);\n          } else {\n            var partialMap = matcher._attrValuePartialMap;\n            var partialValuesMap = partialMap.get(name_2);\n\n            if (!partialValuesMap) {\n              partialValuesMap = new Map();\n              partialMap.set(name_2, partialValuesMap);\n            }\n\n            matcher = this._addPartial(partialValuesMap, value);\n          }\n        }\n      }\n    };\n\n    SelectorMatcher.prototype._addTerminal = function (map, name, selectable) {\n      var terminalList = map.get(name);\n\n      if (!terminalList) {\n        terminalList = [];\n        map.set(name, terminalList);\n      }\n\n      terminalList.push(selectable);\n    };\n\n    SelectorMatcher.prototype._addPartial = function (map, name) {\n      var matcher = map.get(name);\n\n      if (!matcher) {\n        matcher = new SelectorMatcher();\n        map.set(name, matcher);\n      }\n\n      return matcher;\n    };\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param cssSelector A css selector\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return boolean true if a match was found\n     */\n\n\n    SelectorMatcher.prototype.match = function (cssSelector, matchedCallback) {\n      var result = false;\n      var element = cssSelector.element;\n      var classNames = cssSelector.classNames;\n      var attrs = cssSelector.attrs;\n\n      for (var i = 0; i < this._listContexts.length; i++) {\n        this._listContexts[i].alreadyMatched = false;\n      }\n\n      result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n      result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;\n\n      if (classNames) {\n        for (var i = 0; i < classNames.length; i++) {\n          var className = classNames[i];\n          result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n          result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;\n        }\n      }\n\n      if (attrs) {\n        for (var i = 0; i < attrs.length; i += 2) {\n          var name_3 = attrs[i];\n          var value = attrs[i + 1];\n\n          var terminalValuesMap = this._attrValueMap.get(name_3);\n\n          if (value) {\n            result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n          }\n\n          result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n          var partialValuesMap = this._attrValuePartialMap.get(name_3);\n\n          if (value) {\n            result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n          }\n\n          result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n        }\n      }\n\n      return result;\n    };\n    /** @internal */\n\n\n    SelectorMatcher.prototype._matchTerminal = function (map, name, cssSelector, matchedCallback) {\n      if (!map || typeof name !== 'string') {\n        return false;\n      }\n\n      var selectables = map.get(name) || [];\n      var starSelectables = map.get('*');\n\n      if (starSelectables) {\n        selectables = selectables.concat(starSelectables);\n      }\n\n      if (selectables.length === 0) {\n        return false;\n      }\n\n      var selectable;\n      var result = false;\n\n      for (var i = 0; i < selectables.length; i++) {\n        selectable = selectables[i];\n        result = selectable.finalize(cssSelector, matchedCallback) || result;\n      }\n\n      return result;\n    };\n    /** @internal */\n\n\n    SelectorMatcher.prototype._matchPartial = function (map, name, cssSelector, matchedCallback) {\n      if (!map || typeof name !== 'string') {\n        return false;\n      }\n\n      var nestedSelector = map.get(name);\n\n      if (!nestedSelector) {\n        return false;\n      } // TODO(perf): get rid of recursion and measure again\n      // TODO(perf): don't pass the whole selector into the recursion,\n      // but only the not processed parts\n\n\n      return nestedSelector.match(cssSelector, matchedCallback);\n    };\n\n    return SelectorMatcher;\n  }();\n\n  exports.SelectorMatcher = SelectorMatcher;\n\n  var SelectorListContext =\n  /** @class */\n  function () {\n    function SelectorListContext(selectors) {\n      this.selectors = selectors;\n      this.alreadyMatched = false;\n    }\n\n    return SelectorListContext;\n  }();\n\n  exports.SelectorListContext = SelectorListContext; // Store context to pass back selector and context when a selector is matched\n\n  var SelectorContext =\n  /** @class */\n  function () {\n    function SelectorContext(selector, cbContext, listContext) {\n      this.selector = selector;\n      this.cbContext = cbContext;\n      this.listContext = listContext;\n      this.notSelectors = selector.notSelectors;\n    }\n\n    SelectorContext.prototype.finalize = function (cssSelector, callback) {\n      var result = true;\n\n      if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n        var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n        result = !notMatcher.match(cssSelector, null);\n      }\n\n      if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n        if (this.listContext) {\n          this.listContext.alreadyMatched = true;\n        }\n\n        callback(this.selector, this.cbContext);\n      }\n\n      return result;\n    };\n\n    return SelectorContext;\n  }();\n\n  exports.SelectorContext = SelectorContext;\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/selector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getHtmlTagDefinition} from './ml_parser/html_tags';\n\nconst _SELECTOR_REGEXP = new RegExp(\n    '(\\\\:not\\\\()|' +               // 1: \":not(\"\n        '(([\\\\.\\\\#]?)[-\\\\w]+)|' +  // 2: \"tag\"; 3: \".\"/\"#\";\n        // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n        // 4: attribute; 5: attribute_string; 6: attribute_value\n        '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +  // \"[name]\", \"[name=value]\",\n                                                                   // \"[name=\"value\"]\",\n                                                                   // \"[name='value']\"\n        '(\\\\))|' +                                                 // 7: \")\"\n        '(\\\\s*,\\\\s*)',                                             // 8: \",\"\n    'g');\n\n/**\n * These offsets should match the match-groups in `_SELECTOR_REGEXP` offsets.\n */\nconst enum SelectorRegexp {\n  ALL = 0,  // The whole match\n  NOT = 1,\n  TAG = 2,\n  PREFIX = 3,\n  ATTRIBUTE = 4,\n  ATTRIBUTE_STRING = 5,\n  ATTRIBUTE_VALUE = 6,\n  NOT_END = 7,\n  SEPARATOR = 8,\n}\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string|null = null;\n  classNames: string[] = [];\n  /**\n   * The selectors are encoded in pairs where:\n   * - even locations are attribute names\n   * - odd locations are attribute values.\n   *\n   * Example:\n   * Selector: `[key1=value1][key2]` would parse to:\n   * ```\n   * ['key1', 'value1', 'key2', '']\n   * ```\n   */\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n\n  static parse(selector: string): CssSelector[] {\n    const results: CssSelector[] = [];\n    const _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n          cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match: string[]|null;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[SelectorRegexp.NOT]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[SelectorRegexp.TAG];\n      if (tag) {\n        const prefix = match[SelectorRegexp.PREFIX];\n        if (prefix === '#') {\n          // #hash\n          current.addAttribute('id', tag.substr(1));\n        } else if (prefix === '.') {\n          // Class\n          current.addClassName(tag.substr(1));\n        } else {\n          // Element\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[SelectorRegexp.ATTRIBUTE];\n      if (attribute) {\n        current.addAttribute(attribute, match[SelectorRegexp.ATTRIBUTE_VALUE]);\n      }\n      if (match[SelectorRegexp.NOT_END]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[SelectorRegexp.SEPARATOR]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n\n  isElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n        this.notSelectors.length === 0;\n  }\n\n  hasElementSelector(): boolean {\n    return !!this.element;\n  }\n\n  setElement(element: string|null = null) {\n    this.element = element;\n  }\n\n  /** Gets a template string for an element that matches the selector. */\n  getMatchingElementTemplate(): string {\n    const tagName = this.element || 'div';\n    const classAttr = this.classNames.length > 0 ? ` class=\"${this.classNames.join(' ')}\"` : '';\n\n    let attrs = '';\n    for (let i = 0; i < this.attrs.length; i += 2) {\n      const attrName = this.attrs[i];\n      const attrValue = this.attrs[i + 1] !== '' ? `=\"${this.attrs[i + 1]}\"` : '';\n      attrs += ` ${attrName}${attrValue}`;\n    }\n\n    return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :\n                                                  `<${tagName}${classAttr}${attrs}></${tagName}>`;\n  }\n\n  getAttrs(): string[] {\n    const result: string[] = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n\n  addAttribute(name: string, value: string = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n\n  addClassName(name: string) {\n    this.classNames.push(name.toLowerCase());\n  }\n\n  toString(): string {\n    let res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.attrs[i];\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher<T = any> {\n  static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher<null> {\n    const notMatcher = new SelectorMatcher<null>();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n\n  private _elementMap = new Map<string, SelectorContext<T>[]>();\n  private _elementPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _classMap = new Map<string, SelectorContext<T>[]>();\n  private _classPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _attrValueMap = new Map<string, Map<string, SelectorContext<T>[]>>();\n  private _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher<T>>>();\n  private _listContexts: SelectorListContext[] = [];\n\n  addSelectables(cssSelectors: CssSelector[], callbackCtxt?: T) {\n    let listContext: SelectorListContext = null!;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt as T, listContext);\n    }\n  }\n\n  /**\n   * Add an object that can be found later on by calling `match`.\n   * @param cssSelector A css selector\n   * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n   */\n  private _addSelectable(\n      cssSelector: CssSelector, callbackCtxt: T, listContext: SelectorListContext) {\n    let matcher: SelectorMatcher<T> = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext<T>[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher<T>>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n\n  private _addTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, selectable: SelectorContext<T>) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n\n  private _addPartial(map: Map<string, SelectorMatcher<T>>, name: string): SelectorMatcher<T> {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher<T>();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n\n  /**\n   * Find the objects that have been added via `addSelectable`\n   * whose css selector is contained in the given css selector.\n   * @param cssSelector A css selector\n   * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n   * @return boolean true if a match was found\n   */\n  match(cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = false;\n    const element = cssSelector.element!;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n        result;\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result =\n            this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n            this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n            result;\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n\n        const terminalValuesMap = this._attrValueMap.get(name)!;\n        if (value) {\n          result =\n              this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const partialValuesMap = this._attrValuePartialMap.get(name)!;\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let selectables: SelectorContext<T>[] = map.get(name) || [];\n    const starSelectables: SelectorContext<T>[] = map.get('*')!;\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable: SelectorContext<T>;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchPartial(\n      map: Map<string, SelectorMatcher<T>>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\n\nexport class SelectorListContext {\n  alreadyMatched: boolean = false;\n\n  constructor(public selectors: CssSelector[]) {}\n}\n\n// Store context to pass back selector and context when a selector is matched\nexport class SelectorContext<T = any> {\n  notSelectors: CssSelector[];\n\n  constructor(\n      public selector: CssSelector, public cbContext: T, public listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n\n  finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}