{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/graph\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SemanticDepGraphUpdater = exports.SemanticDepGraph = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/api\");\n  /**\n   * Represents a declaration for which no semantic symbol has been registered. For example,\n   * declarations from external dependencies have not been explicitly registered and are represented\n   * by this symbol. This allows the unresolved symbol to still be compared to a symbol from a prior\n   * compilation.\n   */\n\n\n  var OpaqueSymbol =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(OpaqueSymbol, _super);\n\n    function OpaqueSymbol() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    OpaqueSymbol.prototype.isPublicApiAffected = function () {\n      return false;\n    };\n\n    OpaqueSymbol.prototype.isTypeCheckApiAffected = function () {\n      return false;\n    };\n\n    return OpaqueSymbol;\n  }(api_1.SemanticSymbol);\n  /**\n   * The semantic dependency graph of a single compilation.\n   */\n\n\n  var SemanticDepGraph =\n  /** @class */\n  function () {\n    function SemanticDepGraph() {\n      this.files = new Map();\n      this.symbolByDecl = new Map();\n    }\n    /**\n     * Registers a symbol in the graph. The symbol is given a unique identifier if possible, such that\n     * its equivalent symbol can be obtained from a prior graph even if its declaration node has\n     * changed across rebuilds. Symbols without an identifier are only able to find themselves in a\n     * prior graph if their declaration node is identical.\n     */\n\n\n    SemanticDepGraph.prototype.registerSymbol = function (symbol) {\n      this.symbolByDecl.set(symbol.decl, symbol);\n\n      if (symbol.identifier !== null) {\n        // If the symbol has a unique identifier, record it in the file that declares it. This enables\n        // the symbol to be requested by its unique name.\n        if (!this.files.has(symbol.path)) {\n          this.files.set(symbol.path, new Map());\n        }\n\n        this.files.get(symbol.path).set(symbol.identifier, symbol);\n      }\n    };\n    /**\n     * Attempts to resolve a symbol in this graph that represents the given symbol from another graph.\n     * If no matching symbol could be found, null is returned.\n     *\n     * @param symbol The symbol from another graph for which its equivalent in this graph should be\n     * found.\n     */\n\n\n    SemanticDepGraph.prototype.getEquivalentSymbol = function (symbol) {\n      // First lookup the symbol by its declaration. It is typical for the declaration to not have\n      // changed across rebuilds, so this is likely to find the symbol. Using the declaration also\n      // allows to diff symbols for which no unique identifier could be determined.\n      var previousSymbol = this.getSymbolByDecl(symbol.decl);\n\n      if (previousSymbol === null && symbol.identifier !== null) {\n        // The declaration could not be resolved to a symbol in a prior compilation, which may\n        // happen because the file containing the declaration has changed. In that case we want to\n        // lookup the symbol based on its unique identifier, as that allows us to still compare the\n        // changed declaration to the prior compilation.\n        previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);\n      }\n\n      return previousSymbol;\n    };\n    /**\n     * Attempts to find the symbol by its identifier.\n     */\n\n\n    SemanticDepGraph.prototype.getSymbolByName = function (path, identifier) {\n      if (!this.files.has(path)) {\n        return null;\n      }\n\n      var file = this.files.get(path);\n\n      if (!file.has(identifier)) {\n        return null;\n      }\n\n      return file.get(identifier);\n    };\n    /**\n     * Attempts to resolve the declaration to its semantic symbol.\n     */\n\n\n    SemanticDepGraph.prototype.getSymbolByDecl = function (decl) {\n      if (!this.symbolByDecl.has(decl)) {\n        return null;\n      }\n\n      return this.symbolByDecl.get(decl);\n    };\n\n    return SemanticDepGraph;\n  }();\n\n  exports.SemanticDepGraph = SemanticDepGraph;\n  /**\n   * Implements the logic to go from a previous dependency graph to a new one, along with information\n   * on which files have been affected.\n   */\n\n  var SemanticDepGraphUpdater =\n  /** @class */\n  function () {\n    function SemanticDepGraphUpdater(\n    /**\n     * The semantic dependency graph of the most recently succeeded compilation, or null if this\n     * is the initial build.\n     */\n    priorGraph) {\n      this.priorGraph = priorGraph;\n      this.newGraph = new SemanticDepGraph();\n      /**\n       * Contains opaque symbols that were created for declarations for which there was no symbol\n       * registered, which happens for e.g. external declarations.\n       */\n\n      this.opaqueSymbols = new Map();\n    }\n    /**\n     * Registers the symbol in the new graph that is being created.\n     */\n\n\n    SemanticDepGraphUpdater.prototype.registerSymbol = function (symbol) {\n      this.newGraph.registerSymbol(symbol);\n    };\n    /**\n     * Takes all facts that have been gathered to create a new semantic dependency graph. In this\n     * process, the semantic impact of the changes is determined which results in a set of files that\n     * need to be emitted and/or type-checked.\n     */\n\n\n    SemanticDepGraphUpdater.prototype.finalize = function () {\n      if (this.priorGraph === null) {\n        // If no prior dependency graph is available then this was the initial build, in which case\n        // we don't need to determine the semantic impact as everything is already considered\n        // logically changed.\n        return {\n          needsEmit: new Set(),\n          needsTypeCheckEmit: new Set(),\n          newGraph: this.newGraph\n        };\n      }\n\n      var needsEmit = this.determineInvalidatedFiles(this.priorGraph);\n      var needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);\n      return {\n        needsEmit: needsEmit,\n        needsTypeCheckEmit: needsTypeCheckEmit,\n        newGraph: this.newGraph\n      };\n    };\n\n    SemanticDepGraphUpdater.prototype.determineInvalidatedFiles = function (priorGraph) {\n      var e_1, _a, e_2, _b;\n\n      var isPublicApiAffected = new Set();\n\n      try {\n        // The first phase is to collect all symbols which have their public API affected. Any symbols\n        // that cannot be matched up with a symbol from the prior graph are considered affected.\n        for (var _c = tslib_1.__values(this.newGraph.symbolByDecl.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var symbol = _d.value;\n          var previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n\n          if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {\n            isPublicApiAffected.add(symbol);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // The second phase is to find all symbols for which the emit result is affected, either because\n      // their used declarations have changed or any of those used declarations has had its public API\n      // affected as determined in the first phase.\n\n\n      var needsEmit = new Set();\n\n      try {\n        for (var _e = tslib_1.__values(this.newGraph.symbolByDecl.values()), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var symbol = _f.value;\n\n          if (symbol.isEmitAffected === undefined) {\n            continue;\n          }\n\n          var previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n\n          if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {\n            needsEmit.add(symbol.path);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return needsEmit;\n    };\n\n    SemanticDepGraphUpdater.prototype.determineInvalidatedTypeCheckFiles = function (priorGraph) {\n      var e_3, _a, e_4, _b;\n\n      var isTypeCheckApiAffected = new Set();\n\n      try {\n        // The first phase is to collect all symbols which have their public API affected. Any symbols\n        // that cannot be matched up with a symbol from the prior graph are considered affected.\n        for (var _c = tslib_1.__values(this.newGraph.symbolByDecl.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var symbol = _d.value;\n          var previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n\n          if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {\n            isTypeCheckApiAffected.add(symbol);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      } // The second phase is to find all symbols for which the emit result is affected, either because\n      // their used declarations have changed or any of those used declarations has had its public API\n      // affected as determined in the first phase.\n\n\n      var needsTypeCheckEmit = new Set();\n\n      try {\n        for (var _e = tslib_1.__values(this.newGraph.symbolByDecl.values()), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var symbol = _f.value;\n\n          if (symbol.isTypeCheckBlockAffected === undefined) {\n            continue;\n          }\n\n          var previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n\n          if (previousSymbol === null || symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {\n            needsTypeCheckEmit.add(symbol.path);\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      return needsTypeCheckEmit;\n    };\n    /**\n     * Creates a `SemanticReference` for the reference to `decl` using the expression `expr`. See\n     * the documentation of `SemanticReference` for details.\n     */\n\n\n    SemanticDepGraphUpdater.prototype.getSemanticReference = function (decl, expr) {\n      return {\n        symbol: this.getSymbol(decl),\n        importPath: getImportPath(expr)\n      };\n    };\n    /**\n     * Gets the `SemanticSymbol` that was registered for `decl` during the current compilation, or\n     * returns an opaque symbol that represents `decl`.\n     */\n\n\n    SemanticDepGraphUpdater.prototype.getSymbol = function (decl) {\n      var symbol = this.newGraph.getSymbolByDecl(decl);\n\n      if (symbol === null) {\n        // No symbol has been recorded for the provided declaration, which would be the case if the\n        // declaration is external. Return an opaque symbol in that case, to allow the external\n        // declaration to be compared to a prior compilation.\n        return this.getOpaqueSymbol(decl);\n      }\n\n      return symbol;\n    };\n    /**\n     * Gets or creates an `OpaqueSymbol` for the provided class declaration.\n     */\n\n\n    SemanticDepGraphUpdater.prototype.getOpaqueSymbol = function (decl) {\n      if (this.opaqueSymbols.has(decl)) {\n        return this.opaqueSymbols.get(decl);\n      }\n\n      var symbol = new OpaqueSymbol(decl);\n      this.opaqueSymbols.set(decl, symbol);\n      return symbol;\n    };\n\n    return SemanticDepGraphUpdater;\n  }();\n\n  exports.SemanticDepGraphUpdater = SemanticDepGraphUpdater;\n\n  function getImportPath(expr) {\n    if (expr instanceof compiler_1.ExternalExpr) {\n      return expr.value.moduleName + \"$\" + expr.value.name;\n    } else {\n      return null;\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/graph.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Expression, ExternalExpr} from '@angular/compiler';\nimport {AbsoluteFsPath} from '../../../file_system';\nimport {ClassDeclaration} from '../../../reflection';\nimport {SemanticReference, SemanticSymbol} from './api';\n\nexport interface SemanticDependencyResult {\n  /**\n   * The files that need to be re-emitted.\n   */\n  needsEmit: Set<AbsoluteFsPath>;\n\n  /**\n   * The files for which the type-check block should be regenerated.\n   */\n  needsTypeCheckEmit: Set<AbsoluteFsPath>;\n\n  /**\n   * The newly built graph that represents the current compilation.\n   */\n  newGraph: SemanticDepGraph;\n}\n\n/**\n * Represents a declaration for which no semantic symbol has been registered. For example,\n * declarations from external dependencies have not been explicitly registered and are represented\n * by this symbol. This allows the unresolved symbol to still be compared to a symbol from a prior\n * compilation.\n */\nclass OpaqueSymbol extends SemanticSymbol {\n  isPublicApiAffected(): false {\n    return false;\n  }\n\n  isTypeCheckApiAffected(): false {\n    return false;\n  }\n}\n\n/**\n * The semantic dependency graph of a single compilation.\n */\nexport class SemanticDepGraph {\n  readonly files = new Map<AbsoluteFsPath, Map<string, SemanticSymbol>>();\n  readonly symbolByDecl = new Map<ClassDeclaration, SemanticSymbol>();\n\n  /**\n   * Registers a symbol in the graph. The symbol is given a unique identifier if possible, such that\n   * its equivalent symbol can be obtained from a prior graph even if its declaration node has\n   * changed across rebuilds. Symbols without an identifier are only able to find themselves in a\n   * prior graph if their declaration node is identical.\n   */\n  registerSymbol(symbol: SemanticSymbol): void {\n    this.symbolByDecl.set(symbol.decl, symbol);\n\n    if (symbol.identifier !== null) {\n      // If the symbol has a unique identifier, record it in the file that declares it. This enables\n      // the symbol to be requested by its unique name.\n      if (!this.files.has(symbol.path)) {\n        this.files.set(symbol.path, new Map<string, SemanticSymbol>());\n      }\n      this.files.get(symbol.path)!.set(symbol.identifier, symbol);\n    }\n  }\n\n  /**\n   * Attempts to resolve a symbol in this graph that represents the given symbol from another graph.\n   * If no matching symbol could be found, null is returned.\n   *\n   * @param symbol The symbol from another graph for which its equivalent in this graph should be\n   * found.\n   */\n  getEquivalentSymbol(symbol: SemanticSymbol): SemanticSymbol|null {\n    // First lookup the symbol by its declaration. It is typical for the declaration to not have\n    // changed across rebuilds, so this is likely to find the symbol. Using the declaration also\n    // allows to diff symbols for which no unique identifier could be determined.\n    let previousSymbol = this.getSymbolByDecl(symbol.decl);\n    if (previousSymbol === null && symbol.identifier !== null) {\n      // The declaration could not be resolved to a symbol in a prior compilation, which may\n      // happen because the file containing the declaration has changed. In that case we want to\n      // lookup the symbol based on its unique identifier, as that allows us to still compare the\n      // changed declaration to the prior compilation.\n      previousSymbol = this.getSymbolByName(symbol.path, symbol.identifier);\n    }\n\n    return previousSymbol;\n  }\n\n  /**\n   * Attempts to find the symbol by its identifier.\n   */\n  private getSymbolByName(path: AbsoluteFsPath, identifier: string): SemanticSymbol|null {\n    if (!this.files.has(path)) {\n      return null;\n    }\n    const file = this.files.get(path)!;\n    if (!file.has(identifier)) {\n      return null;\n    }\n    return file.get(identifier)!;\n  }\n\n  /**\n   * Attempts to resolve the declaration to its semantic symbol.\n   */\n  getSymbolByDecl(decl: ClassDeclaration): SemanticSymbol|null {\n    if (!this.symbolByDecl.has(decl)) {\n      return null;\n    }\n    return this.symbolByDecl.get(decl)!;\n  }\n}\n\n/**\n * Implements the logic to go from a previous dependency graph to a new one, along with information\n * on which files have been affected.\n */\nexport class SemanticDepGraphUpdater {\n  private readonly newGraph = new SemanticDepGraph();\n\n  /**\n   * Contains opaque symbols that were created for declarations for which there was no symbol\n   * registered, which happens for e.g. external declarations.\n   */\n  private readonly opaqueSymbols = new Map<ClassDeclaration, OpaqueSymbol>();\n\n  constructor(\n      /**\n       * The semantic dependency graph of the most recently succeeded compilation, or null if this\n       * is the initial build.\n       */\n      private priorGraph: SemanticDepGraph|null) {}\n\n  /**\n   * Registers the symbol in the new graph that is being created.\n   */\n  registerSymbol(symbol: SemanticSymbol): void {\n    this.newGraph.registerSymbol(symbol);\n  }\n\n  /**\n   * Takes all facts that have been gathered to create a new semantic dependency graph. In this\n   * process, the semantic impact of the changes is determined which results in a set of files that\n   * need to be emitted and/or type-checked.\n   */\n  finalize(): SemanticDependencyResult {\n    if (this.priorGraph === null) {\n      // If no prior dependency graph is available then this was the initial build, in which case\n      // we don't need to determine the semantic impact as everything is already considered\n      // logically changed.\n      return {\n        needsEmit: new Set<AbsoluteFsPath>(),\n        needsTypeCheckEmit: new Set<AbsoluteFsPath>(),\n        newGraph: this.newGraph,\n      };\n    }\n\n    const needsEmit = this.determineInvalidatedFiles(this.priorGraph);\n    const needsTypeCheckEmit = this.determineInvalidatedTypeCheckFiles(this.priorGraph);\n    return {\n      needsEmit,\n      needsTypeCheckEmit,\n      newGraph: this.newGraph,\n    };\n  }\n\n  private determineInvalidatedFiles(priorGraph: SemanticDepGraph): Set<AbsoluteFsPath> {\n    const isPublicApiAffected = new Set<SemanticSymbol>();\n\n    // The first phase is to collect all symbols which have their public API affected. Any symbols\n    // that cannot be matched up with a symbol from the prior graph are considered affected.\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isPublicApiAffected(previousSymbol)) {\n        isPublicApiAffected.add(symbol);\n      }\n    }\n\n    // The second phase is to find all symbols for which the emit result is affected, either because\n    // their used declarations have changed or any of those used declarations has had its public API\n    // affected as determined in the first phase.\n    const needsEmit = new Set<AbsoluteFsPath>();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isEmitAffected === undefined) {\n        continue;\n      }\n\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isEmitAffected(previousSymbol, isPublicApiAffected)) {\n        needsEmit.add(symbol.path);\n      }\n    }\n\n    return needsEmit;\n  }\n\n  private determineInvalidatedTypeCheckFiles(priorGraph: SemanticDepGraph): Set<AbsoluteFsPath> {\n    const isTypeCheckApiAffected = new Set<SemanticSymbol>();\n\n    // The first phase is to collect all symbols which have their public API affected. Any symbols\n    // that cannot be matched up with a symbol from the prior graph are considered affected.\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null || symbol.isTypeCheckApiAffected(previousSymbol)) {\n        isTypeCheckApiAffected.add(symbol);\n      }\n    }\n\n    // The second phase is to find all symbols for which the emit result is affected, either because\n    // their used declarations have changed or any of those used declarations has had its public API\n    // affected as determined in the first phase.\n    const needsTypeCheckEmit = new Set<AbsoluteFsPath>();\n    for (const symbol of this.newGraph.symbolByDecl.values()) {\n      if (symbol.isTypeCheckBlockAffected === undefined) {\n        continue;\n      }\n\n      const previousSymbol = priorGraph.getEquivalentSymbol(symbol);\n      if (previousSymbol === null ||\n          symbol.isTypeCheckBlockAffected(previousSymbol, isTypeCheckApiAffected)) {\n        needsTypeCheckEmit.add(symbol.path);\n      }\n    }\n\n    return needsTypeCheckEmit;\n  }\n\n  /**\n   * Creates a `SemanticReference` for the reference to `decl` using the expression `expr`. See\n   * the documentation of `SemanticReference` for details.\n   */\n  getSemanticReference(decl: ClassDeclaration, expr: Expression): SemanticReference {\n    return {\n      symbol: this.getSymbol(decl),\n      importPath: getImportPath(expr),\n    };\n  }\n\n  /**\n   * Gets the `SemanticSymbol` that was registered for `decl` during the current compilation, or\n   * returns an opaque symbol that represents `decl`.\n   */\n  getSymbol(decl: ClassDeclaration): SemanticSymbol {\n    const symbol = this.newGraph.getSymbolByDecl(decl);\n    if (symbol === null) {\n      // No symbol has been recorded for the provided declaration, which would be the case if the\n      // declaration is external. Return an opaque symbol in that case, to allow the external\n      // declaration to be compared to a prior compilation.\n      return this.getOpaqueSymbol(decl);\n    }\n    return symbol;\n  }\n\n  /**\n   * Gets or creates an `OpaqueSymbol` for the provided class declaration.\n   */\n  private getOpaqueSymbol(decl: ClassDeclaration): OpaqueSymbol {\n    if (this.opaqueSymbols.has(decl)) {\n      return this.opaqueSymbols.get(decl)!;\n    }\n\n    const symbol = new OpaqueSymbol(decl);\n    this.opaqueSymbols.set(decl, symbol);\n    return symbol;\n  }\n}\n\nfunction getImportPath(expr: Expression): string|null {\n  if (expr instanceof ExternalExpr) {\n    return `${expr.value.moduleName}\\$${expr.value.name}`;\n  } else {\n    return null;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}