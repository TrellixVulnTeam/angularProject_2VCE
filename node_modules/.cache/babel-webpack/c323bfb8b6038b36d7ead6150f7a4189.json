{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/translator/src/translator\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ExpressionTranslatorVisitor = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var o = require(\"@angular/compiler\");\n\n  var UNARY_OPERATORS = new Map([[o.UnaryOperator.Minus, '-'], [o.UnaryOperator.Plus, '+']]);\n  var BINARY_OPERATORS = new Map([[o.BinaryOperator.And, '&&'], [o.BinaryOperator.Bigger, '>'], [o.BinaryOperator.BiggerEquals, '>='], [o.BinaryOperator.BitwiseAnd, '&'], [o.BinaryOperator.Divide, '/'], [o.BinaryOperator.Equals, '=='], [o.BinaryOperator.Identical, '==='], [o.BinaryOperator.Lower, '<'], [o.BinaryOperator.LowerEquals, '<='], [o.BinaryOperator.Minus, '-'], [o.BinaryOperator.Modulo, '%'], [o.BinaryOperator.Multiply, '*'], [o.BinaryOperator.NotEquals, '!='], [o.BinaryOperator.NotIdentical, '!=='], [o.BinaryOperator.Or, '||'], [o.BinaryOperator.Plus, '+']]);\n\n  var ExpressionTranslatorVisitor =\n  /** @class */\n  function () {\n    function ExpressionTranslatorVisitor(factory, imports, options) {\n      this.factory = factory;\n      this.imports = imports;\n      this.downlevelTaggedTemplates = options.downlevelTaggedTemplates === true;\n      this.downlevelVariableDeclarations = options.downlevelVariableDeclarations === true;\n\n      this.recordWrappedNode = options.recordWrappedNode || function () {};\n    }\n\n    ExpressionTranslatorVisitor.prototype.visitDeclareVarStmt = function (stmt, context) {\n      var _a;\n\n      var varType = this.downlevelVariableDeclarations ? 'var' : stmt.hasModifier(o.StmtModifier.Final) ? 'const' : 'let';\n      return this.attachComments(this.factory.createVariableDeclaration(stmt.name, (_a = stmt.value) === null || _a === void 0 ? void 0 : _a.visitExpression(this, context.withExpressionMode), varType), stmt.leadingComments);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitDeclareFunctionStmt = function (stmt, context) {\n      return this.attachComments(this.factory.createFunctionDeclaration(stmt.name, stmt.params.map(function (param) {\n        return param.name;\n      }), this.factory.createBlock(this.visitStatements(stmt.statements, context.withStatementMode))), stmt.leadingComments);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitExpressionStmt = function (stmt, context) {\n      return this.attachComments(this.factory.createExpressionStatement(stmt.expr.visitExpression(this, context.withStatementMode)), stmt.leadingComments);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitReturnStmt = function (stmt, context) {\n      return this.attachComments(this.factory.createReturnStatement(stmt.value.visitExpression(this, context.withExpressionMode)), stmt.leadingComments);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitDeclareClassStmt = function (_stmt, _context) {\n      throw new Error('Method not implemented.');\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitIfStmt = function (stmt, context) {\n      return this.attachComments(this.factory.createIfStatement(stmt.condition.visitExpression(this, context), this.factory.createBlock(this.visitStatements(stmt.trueCase, context.withStatementMode)), stmt.falseCase.length > 0 ? this.factory.createBlock(this.visitStatements(stmt.falseCase, context.withStatementMode)) : null), stmt.leadingComments);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitTryCatchStmt = function (_stmt, _context) {\n      throw new Error('Method not implemented.');\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitThrowStmt = function (stmt, context) {\n      return this.attachComments(this.factory.createThrowStatement(stmt.error.visitExpression(this, context.withExpressionMode)), stmt.leadingComments);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitReadVarExpr = function (ast, _context) {\n      var identifier = this.factory.createIdentifier(ast.name);\n      this.setSourceMapRange(identifier, ast.sourceSpan);\n      return identifier;\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitWriteVarExpr = function (expr, context) {\n      var assignment = this.factory.createAssignment(this.setSourceMapRange(this.factory.createIdentifier(expr.name), expr.sourceSpan), expr.value.visitExpression(this, context));\n      return context.isStatement ? assignment : this.factory.createParenthesizedExpression(assignment);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitWriteKeyExpr = function (expr, context) {\n      var exprContext = context.withExpressionMode;\n      var target = this.factory.createElementAccess(expr.receiver.visitExpression(this, exprContext), expr.index.visitExpression(this, exprContext));\n      var assignment = this.factory.createAssignment(target, expr.value.visitExpression(this, exprContext));\n      return context.isStatement ? assignment : this.factory.createParenthesizedExpression(assignment);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitWritePropExpr = function (expr, context) {\n      var target = this.factory.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name);\n      return this.factory.createAssignment(target, expr.value.visitExpression(this, context));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitInvokeMethodExpr = function (ast, context) {\n      var _this = this;\n\n      var target = ast.receiver.visitExpression(this, context);\n      return this.setSourceMapRange(this.factory.createCallExpression(ast.name !== null ? this.factory.createPropertyAccess(target, ast.name) : target, ast.args.map(function (arg) {\n        return arg.visitExpression(_this, context);\n      }),\n      /* pure */\n      false), ast.sourceSpan);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitInvokeFunctionExpr = function (ast, context) {\n      var _this = this;\n\n      return this.setSourceMapRange(this.factory.createCallExpression(ast.fn.visitExpression(this, context), ast.args.map(function (arg) {\n        return arg.visitExpression(_this, context);\n      }), ast.pure), ast.sourceSpan);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitTaggedTemplateExpr = function (ast, context) {\n      var _this = this;\n\n      return this.setSourceMapRange(this.createTaggedTemplateExpression(ast.tag.visitExpression(this, context), {\n        elements: ast.template.elements.map(function (e) {\n          var _a;\n\n          return createTemplateElement({\n            cooked: e.text,\n            raw: e.rawText,\n            range: (_a = e.sourceSpan) !== null && _a !== void 0 ? _a : ast.sourceSpan\n          });\n        }),\n        expressions: ast.template.expressions.map(function (e) {\n          return e.visitExpression(_this, context);\n        })\n      }), ast.sourceSpan);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitInstantiateExpr = function (ast, context) {\n      var _this = this;\n\n      return this.factory.createNewExpression(ast.classExpr.visitExpression(this, context), ast.args.map(function (arg) {\n        return arg.visitExpression(_this, context);\n      }));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitLiteralExpr = function (ast, _context) {\n      return this.setSourceMapRange(this.factory.createLiteral(ast.value), ast.sourceSpan);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitLocalizedString = function (ast, context) {\n      // A `$localize` message consists of `messageParts` and `expressions`, which get interleaved\n      // together. The interleaved pieces look like:\n      // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`\n      //\n      // Note that there is always a message part at the start and end, and so therefore\n      // `messageParts.length === expressions.length + 1`.\n      //\n      // Each message part may be prefixed with \"metadata\", which is wrapped in colons (:) delimiters.\n      // The metadata is attached to the first and subsequent message parts by calls to\n      // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.\n      //\n      // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts`\n      // array.\n      var elements = [createTemplateElement(ast.serializeI18nHead())];\n      var expressions = [];\n\n      for (var i = 0; i < ast.expressions.length; i++) {\n        var placeholder = this.setSourceMapRange(ast.expressions[i].visitExpression(this, context), ast.getPlaceholderSourceSpan(i));\n        expressions.push(placeholder);\n        elements.push(createTemplateElement(ast.serializeI18nTemplatePart(i + 1)));\n      }\n\n      var localizeTag = this.factory.createIdentifier('$localize');\n      return this.setSourceMapRange(this.createTaggedTemplateExpression(localizeTag, {\n        elements: elements,\n        expressions: expressions\n      }), ast.sourceSpan);\n    };\n\n    ExpressionTranslatorVisitor.prototype.createTaggedTemplateExpression = function (tag, template) {\n      return this.downlevelTaggedTemplates ? this.createES5TaggedTemplateFunctionCall(tag, template) : this.factory.createTaggedTemplate(tag, template);\n    };\n    /**\n     * Translate the tagged template literal into a call that is compatible with ES5, using the\n     * imported `__makeTemplateObject` helper for ES5 formatted output.\n     */\n\n\n    ExpressionTranslatorVisitor.prototype.createES5TaggedTemplateFunctionCall = function (tagHandler, _a) {\n      var e_1, _b;\n\n      var elements = _a.elements,\n          expressions = _a.expressions; // Ensure that the `__makeTemplateObject()` helper has been imported.\n\n      var _c = this.imports.generateNamedImport('tslib', '__makeTemplateObject'),\n          moduleImport = _c.moduleImport,\n          symbol = _c.symbol;\n\n      var __makeTemplateObjectHelper = moduleImport === null ? this.factory.createIdentifier(symbol) : this.factory.createPropertyAccess(moduleImport, symbol); // Collect up the cooked and raw strings into two separate arrays.\n\n\n      var cooked = [];\n      var raw = [];\n\n      try {\n        for (var elements_1 = tslib_1.__values(elements), elements_1_1 = elements_1.next(); !elements_1_1.done; elements_1_1 = elements_1.next()) {\n          var element = elements_1_1.value;\n          cooked.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.cooked), element.range));\n          raw.push(this.factory.setSourceMapRange(this.factory.createLiteral(element.raw), element.range));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (elements_1_1 && !elements_1_1.done && (_b = elements_1.return)) _b.call(elements_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Generate the helper call in the form: `__makeTemplateObject([cooked], [raw]);`\n\n\n      var templateHelperCall = this.factory.createCallExpression(__makeTemplateObjectHelper, [this.factory.createArrayLiteral(cooked), this.factory.createArrayLiteral(raw)],\n      /* pure */\n      false); // Finally create the tagged handler call in the form:\n      // `tag(__makeTemplateObject([cooked], [raw]), ...expressions);`\n\n      return this.factory.createCallExpression(tagHandler, tslib_1.__spread([templateHelperCall], expressions),\n      /* pure */\n      false);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitExternalExpr = function (ast, _context) {\n      if (ast.value.name === null) {\n        if (ast.value.moduleName === null) {\n          throw new Error('Invalid import without name nor moduleName');\n        }\n\n        return this.imports.generateNamespaceImport(ast.value.moduleName);\n      } // If a moduleName is specified, this is a normal import. If there's no module name, it's a\n      // reference to a global/ambient symbol.\n\n\n      if (ast.value.moduleName !== null) {\n        // This is a normal import. Find the imported module.\n        var _a = this.imports.generateNamedImport(ast.value.moduleName, ast.value.name),\n            moduleImport = _a.moduleImport,\n            symbol = _a.symbol;\n\n        if (moduleImport === null) {\n          // The symbol was ambient after all.\n          return this.factory.createIdentifier(symbol);\n        } else {\n          return this.factory.createPropertyAccess(moduleImport, symbol);\n        }\n      } else {\n        // The symbol is ambient, so just reference it.\n        return this.factory.createIdentifier(ast.value.name);\n      }\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitConditionalExpr = function (ast, context) {\n      var cond = ast.condition.visitExpression(this, context); // Ordinarily the ternary operator is right-associative. The following are equivalent:\n      //   `a ? b : c ? d : e` => `a ? b : (c ? d : e)`\n      //\n      // However, occasionally Angular needs to produce a left-associative conditional, such as in\n      // the case of a null-safe navigation production: `{{a?.b ? c : d}}`. This template produces\n      // a ternary of the form:\n      //   `a == null ? null : rest of expression`\n      // If the rest of the expression is also a ternary though, this would produce the form:\n      //   `a == null ? null : a.b ? c : d`\n      // which, if left as right-associative, would be incorrectly associated as:\n      //   `a == null ? null : (a.b ? c : d)`\n      //\n      // In such cases, the left-associativity needs to be enforced with parentheses:\n      //   `(a == null ? null : a.b) ? c : d`\n      //\n      // Such parentheses could always be included in the condition (guaranteeing correct behavior) in\n      // all cases, but this has a code size cost. Instead, parentheses are added only when a\n      // conditional expression is directly used as the condition of another.\n      //\n      // TODO(alxhub): investigate better logic for precendence of conditional operators\n\n      if (ast.condition instanceof o.ConditionalExpr) {\n        // The condition of this ternary needs to be wrapped in parentheses to maintain\n        // left-associativity.\n        cond = this.factory.createParenthesizedExpression(cond);\n      }\n\n      return this.factory.createConditional(cond, ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitNotExpr = function (ast, context) {\n      return this.factory.createUnaryExpression('!', ast.condition.visitExpression(this, context));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitAssertNotNullExpr = function (ast, context) {\n      return ast.condition.visitExpression(this, context);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitCastExpr = function (ast, context) {\n      return ast.value.visitExpression(this, context);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitFunctionExpr = function (ast, context) {\n      var _a;\n\n      return this.factory.createFunctionExpression((_a = ast.name) !== null && _a !== void 0 ? _a : null, ast.params.map(function (param) {\n        return param.name;\n      }), this.factory.createBlock(this.visitStatements(ast.statements, context)));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitBinaryOperatorExpr = function (ast, context) {\n      if (!BINARY_OPERATORS.has(ast.operator)) {\n        throw new Error(\"Unknown binary operator: \" + o.BinaryOperator[ast.operator]);\n      }\n\n      return this.factory.createBinaryExpression(ast.lhs.visitExpression(this, context), BINARY_OPERATORS.get(ast.operator), ast.rhs.visitExpression(this, context));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitReadPropExpr = function (ast, context) {\n      return this.factory.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitReadKeyExpr = function (ast, context) {\n      return this.factory.createElementAccess(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitLiteralArrayExpr = function (ast, context) {\n      var _this = this;\n\n      return this.factory.createArrayLiteral(ast.entries.map(function (expr) {\n        return _this.setSourceMapRange(expr.visitExpression(_this, context), ast.sourceSpan);\n      }));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitLiteralMapExpr = function (ast, context) {\n      var _this = this;\n\n      var properties = ast.entries.map(function (entry) {\n        return {\n          propertyName: entry.key,\n          quoted: entry.quoted,\n          value: entry.value.visitExpression(_this, context)\n        };\n      });\n      return this.setSourceMapRange(this.factory.createObjectLiteral(properties), ast.sourceSpan);\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitCommaExpr = function (ast, context) {\n      throw new Error('Method not implemented.');\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitWrappedNodeExpr = function (ast, _context) {\n      this.recordWrappedNode(ast);\n      return ast.node;\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitTypeofExpr = function (ast, context) {\n      return this.factory.createTypeOfExpression(ast.expr.visitExpression(this, context));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitUnaryOperatorExpr = function (ast, context) {\n      if (!UNARY_OPERATORS.has(ast.operator)) {\n        throw new Error(\"Unknown unary operator: \" + o.UnaryOperator[ast.operator]);\n      }\n\n      return this.factory.createUnaryExpression(UNARY_OPERATORS.get(ast.operator), ast.expr.visitExpression(this, context));\n    };\n\n    ExpressionTranslatorVisitor.prototype.visitStatements = function (statements, context) {\n      var _this = this;\n\n      return statements.map(function (stmt) {\n        return stmt.visitStatement(_this, context);\n      }).filter(function (stmt) {\n        return stmt !== undefined;\n      });\n    };\n\n    ExpressionTranslatorVisitor.prototype.setSourceMapRange = function (ast, span) {\n      return this.factory.setSourceMapRange(ast, createRange(span));\n    };\n\n    ExpressionTranslatorVisitor.prototype.attachComments = function (statement, leadingComments) {\n      if (leadingComments !== undefined) {\n        this.factory.attachComments(statement, leadingComments);\n      }\n\n      return statement;\n    };\n\n    return ExpressionTranslatorVisitor;\n  }();\n\n  exports.ExpressionTranslatorVisitor = ExpressionTranslatorVisitor;\n  /**\n   * Convert a cooked-raw string object into one that can be used by the AST factories.\n   */\n\n  function createTemplateElement(_a) {\n    var cooked = _a.cooked,\n        raw = _a.raw,\n        range = _a.range;\n    return {\n      cooked: cooked,\n      raw: raw,\n      range: createRange(range)\n    };\n  }\n  /**\n   * Convert an OutputAST source-span into a range that can be used by the AST factories.\n   */\n\n\n  function createRange(span) {\n    if (span === null) {\n      return null;\n    }\n\n    var start = span.start,\n        end = span.end;\n    var _a = start.file,\n        url = _a.url,\n        content = _a.content;\n\n    if (!url) {\n      return null;\n    }\n\n    return {\n      url: url,\n      content: content,\n      start: {\n        offset: start.offset,\n        line: start.line,\n        column: start.col\n      },\n      end: {\n        offset: end.offset,\n        line: end.line,\n        column: end.col\n      }\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/translator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '@angular/compiler';\nimport {createTaggedTemplate} from 'typescript';\n\nimport {AstFactory, BinaryOperator, ObjectLiteralProperty, SourceMapRange, TemplateElement, TemplateLiteral, UnaryOperator} from './api/ast_factory';\nimport {ImportGenerator} from './api/import_generator';\nimport {Context} from './context';\n\nconst UNARY_OPERATORS = new Map<o.UnaryOperator, UnaryOperator>([\n  [o.UnaryOperator.Minus, '-'],\n  [o.UnaryOperator.Plus, '+'],\n]);\n\nconst BINARY_OPERATORS = new Map<o.BinaryOperator, BinaryOperator>([\n  [o.BinaryOperator.And, '&&'],\n  [o.BinaryOperator.Bigger, '>'],\n  [o.BinaryOperator.BiggerEquals, '>='],\n  [o.BinaryOperator.BitwiseAnd, '&'],\n  [o.BinaryOperator.Divide, '/'],\n  [o.BinaryOperator.Equals, '=='],\n  [o.BinaryOperator.Identical, '==='],\n  [o.BinaryOperator.Lower, '<'],\n  [o.BinaryOperator.LowerEquals, '<='],\n  [o.BinaryOperator.Minus, '-'],\n  [o.BinaryOperator.Modulo, '%'],\n  [o.BinaryOperator.Multiply, '*'],\n  [o.BinaryOperator.NotEquals, '!='],\n  [o.BinaryOperator.NotIdentical, '!=='],\n  [o.BinaryOperator.Or, '||'],\n  [o.BinaryOperator.Plus, '+'],\n]);\n\nexport type RecordWrappedNodeFn<TExpression> = (node: o.WrappedNodeExpr<TExpression>) => void;\n\nexport interface TranslatorOptions<TExpression> {\n  downlevelTaggedTemplates?: boolean;\n  downlevelVariableDeclarations?: boolean;\n  recordWrappedNode?: RecordWrappedNodeFn<TExpression>;\n}\n\nexport class ExpressionTranslatorVisitor<TStatement, TExpression> implements o.ExpressionVisitor,\n                                                                             o.StatementVisitor {\n  private downlevelTaggedTemplates: boolean;\n  private downlevelVariableDeclarations: boolean;\n  private recordWrappedNode: RecordWrappedNodeFn<TExpression>;\n\n  constructor(\n      private factory: AstFactory<TStatement, TExpression>,\n      private imports: ImportGenerator<TExpression>, options: TranslatorOptions<TExpression>) {\n    this.downlevelTaggedTemplates = options.downlevelTaggedTemplates === true;\n    this.downlevelVariableDeclarations = options.downlevelVariableDeclarations === true;\n    this.recordWrappedNode = options.recordWrappedNode || (() => {});\n  }\n\n  visitDeclareVarStmt(stmt: o.DeclareVarStmt, context: Context): TStatement {\n    const varType = this.downlevelVariableDeclarations ?\n        'var' :\n        stmt.hasModifier(o.StmtModifier.Final) ? 'const' : 'let';\n    return this.attachComments(\n        this.factory.createVariableDeclaration(\n            stmt.name, stmt.value?.visitExpression(this, context.withExpressionMode), varType),\n        stmt.leadingComments);\n  }\n\n  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createFunctionDeclaration(\n            stmt.name, stmt.params.map(param => param.name),\n            this.factory.createBlock(\n                this.visitStatements(stmt.statements, context.withStatementMode))),\n        stmt.leadingComments);\n  }\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createExpressionStatement(\n            stmt.expr.visitExpression(this, context.withStatementMode)),\n        stmt.leadingComments);\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createReturnStatement(\n            stmt.value.visitExpression(this, context.withExpressionMode)),\n        stmt.leadingComments);\n  }\n\n  visitDeclareClassStmt(_stmt: o.ClassStmt, _context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitIfStmt(stmt: o.IfStmt, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createIfStatement(\n            stmt.condition.visitExpression(this, context),\n            this.factory.createBlock(\n                this.visitStatements(stmt.trueCase, context.withStatementMode)),\n            stmt.falseCase.length > 0 ? this.factory.createBlock(this.visitStatements(\n                                            stmt.falseCase, context.withStatementMode)) :\n                                        null),\n        stmt.leadingComments);\n  }\n\n  visitTryCatchStmt(_stmt: o.TryCatchStmt, _context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitThrowStmt(stmt: o.ThrowStmt, context: Context): TStatement {\n    return this.attachComments(\n        this.factory.createThrowStatement(\n            stmt.error.visitExpression(this, context.withExpressionMode)),\n        stmt.leadingComments);\n  }\n\n  visitReadVarExpr(ast: o.ReadVarExpr, _context: Context): TExpression {\n    const identifier = this.factory.createIdentifier(ast.name!);\n    this.setSourceMapRange(identifier, ast.sourceSpan);\n    return identifier;\n  }\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, context: Context): TExpression {\n    const assignment = this.factory.createAssignment(\n        this.setSourceMapRange(this.factory.createIdentifier(expr.name), expr.sourceSpan),\n        expr.value.visitExpression(this, context),\n    );\n    return context.isStatement ? assignment :\n                                 this.factory.createParenthesizedExpression(assignment);\n  }\n\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, context: Context): TExpression {\n    const exprContext = context.withExpressionMode;\n    const target = this.factory.createElementAccess(\n        expr.receiver.visitExpression(this, exprContext),\n        expr.index.visitExpression(this, exprContext),\n    );\n    const assignment =\n        this.factory.createAssignment(target, expr.value.visitExpression(this, exprContext));\n    return context.isStatement ? assignment :\n                                 this.factory.createParenthesizedExpression(assignment);\n  }\n\n  visitWritePropExpr(expr: o.WritePropExpr, context: Context): TExpression {\n    const target =\n        this.factory.createPropertyAccess(expr.receiver.visitExpression(this, context), expr.name);\n    return this.factory.createAssignment(target, expr.value.visitExpression(this, context));\n  }\n\n  visitInvokeMethodExpr(ast: o.InvokeMethodExpr, context: Context): TExpression {\n    const target = ast.receiver.visitExpression(this, context);\n    return this.setSourceMapRange(\n        this.factory.createCallExpression(\n            ast.name !== null ? this.factory.createPropertyAccess(target, ast.name) : target,\n            ast.args.map(arg => arg.visitExpression(this, context)),\n            /* pure */ false),\n        ast.sourceSpan);\n  }\n\n  visitInvokeFunctionExpr(ast: o.InvokeFunctionExpr, context: Context): TExpression {\n    return this.setSourceMapRange(\n        this.factory.createCallExpression(\n            ast.fn.visitExpression(this, context),\n            ast.args.map(arg => arg.visitExpression(this, context)), ast.pure),\n        ast.sourceSpan);\n  }\n\n  visitTaggedTemplateExpr(ast: o.TaggedTemplateExpr, context: Context): TExpression {\n    return this.setSourceMapRange(\n        this.createTaggedTemplateExpression(ast.tag.visitExpression(this, context), {\n          elements: ast.template.elements.map(e => createTemplateElement({\n                                                cooked: e.text,\n                                                raw: e.rawText,\n                                                range: e.sourceSpan ?? ast.sourceSpan,\n                                              })),\n          expressions: ast.template.expressions.map(e => e.visitExpression(this, context))\n        }),\n        ast.sourceSpan);\n  }\n\n  visitInstantiateExpr(ast: o.InstantiateExpr, context: Context): TExpression {\n    return this.factory.createNewExpression(\n        ast.classExpr.visitExpression(this, context),\n        ast.args.map(arg => arg.visitExpression(this, context)));\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, _context: Context): TExpression {\n    return this.setSourceMapRange(this.factory.createLiteral(ast.value), ast.sourceSpan);\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, context: Context): TExpression {\n    // A `$localize` message consists of `messageParts` and `expressions`, which get interleaved\n    // together. The interleaved pieces look like:\n    // `[messagePart0, expression0, messagePart1, expression1, messagePart2]`\n    //\n    // Note that there is always a message part at the start and end, and so therefore\n    // `messageParts.length === expressions.length + 1`.\n    //\n    // Each message part may be prefixed with \"metadata\", which is wrapped in colons (:) delimiters.\n    // The metadata is attached to the first and subsequent message parts by calls to\n    // `serializeI18nHead()` and `serializeI18nTemplatePart()` respectively.\n    //\n    // The first message part (i.e. `ast.messageParts[0]`) is used to initialize `messageParts`\n    // array.\n    const elements: TemplateElement[] = [createTemplateElement(ast.serializeI18nHead())];\n    const expressions: TExpression[] = [];\n    for (let i = 0; i < ast.expressions.length; i++) {\n      const placeholder = this.setSourceMapRange(\n          ast.expressions[i].visitExpression(this, context), ast.getPlaceholderSourceSpan(i));\n      expressions.push(placeholder);\n      elements.push(createTemplateElement(ast.serializeI18nTemplatePart(i + 1)));\n    }\n\n    const localizeTag = this.factory.createIdentifier('$localize');\n    return this.setSourceMapRange(\n        this.createTaggedTemplateExpression(localizeTag, {elements, expressions}), ast.sourceSpan);\n  }\n\n  private createTaggedTemplateExpression(tag: TExpression, template: TemplateLiteral<TExpression>):\n      TExpression {\n    return this.downlevelTaggedTemplates ? this.createES5TaggedTemplateFunctionCall(tag, template) :\n                                           this.factory.createTaggedTemplate(tag, template);\n  }\n\n  /**\n   * Translate the tagged template literal into a call that is compatible with ES5, using the\n   * imported `__makeTemplateObject` helper for ES5 formatted output.\n   */\n  private createES5TaggedTemplateFunctionCall(\n      tagHandler: TExpression, {elements, expressions}: TemplateLiteral<TExpression>): TExpression {\n    // Ensure that the `__makeTemplateObject()` helper has been imported.\n    const {moduleImport, symbol} =\n        this.imports.generateNamedImport('tslib', '__makeTemplateObject');\n    const __makeTemplateObjectHelper = (moduleImport === null) ?\n        this.factory.createIdentifier(symbol) :\n        this.factory.createPropertyAccess(moduleImport, symbol);\n\n    // Collect up the cooked and raw strings into two separate arrays.\n    const cooked: TExpression[] = [];\n    const raw: TExpression[] = [];\n    for (const element of elements) {\n      cooked.push(this.factory.setSourceMapRange(\n          this.factory.createLiteral(element.cooked), element.range));\n      raw.push(\n          this.factory.setSourceMapRange(this.factory.createLiteral(element.raw), element.range));\n    }\n\n    // Generate the helper call in the form: `__makeTemplateObject([cooked], [raw]);`\n    const templateHelperCall = this.factory.createCallExpression(\n        __makeTemplateObjectHelper,\n        [this.factory.createArrayLiteral(cooked), this.factory.createArrayLiteral(raw)],\n        /* pure */ false);\n\n    // Finally create the tagged handler call in the form:\n    // `tag(__makeTemplateObject([cooked], [raw]), ...expressions);`\n    return this.factory.createCallExpression(\n        tagHandler, [templateHelperCall, ...expressions],\n        /* pure */ false);\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr, _context: Context): TExpression {\n    if (ast.value.name === null) {\n      if (ast.value.moduleName === null) {\n        throw new Error('Invalid import without name nor moduleName');\n      }\n      return this.imports.generateNamespaceImport(ast.value.moduleName);\n    }\n    // If a moduleName is specified, this is a normal import. If there's no module name, it's a\n    // reference to a global/ambient symbol.\n    if (ast.value.moduleName !== null) {\n      // This is a normal import. Find the imported module.\n      const {moduleImport, symbol} =\n          this.imports.generateNamedImport(ast.value.moduleName, ast.value.name);\n      if (moduleImport === null) {\n        // The symbol was ambient after all.\n        return this.factory.createIdentifier(symbol);\n      } else {\n        return this.factory.createPropertyAccess(moduleImport, symbol);\n      }\n    } else {\n      // The symbol is ambient, so just reference it.\n      return this.factory.createIdentifier(ast.value.name);\n    }\n  }\n\n  visitConditionalExpr(ast: o.ConditionalExpr, context: Context): TExpression {\n    let cond: TExpression = ast.condition.visitExpression(this, context);\n\n    // Ordinarily the ternary operator is right-associative. The following are equivalent:\n    //   `a ? b : c ? d : e` => `a ? b : (c ? d : e)`\n    //\n    // However, occasionally Angular needs to produce a left-associative conditional, such as in\n    // the case of a null-safe navigation production: `{{a?.b ? c : d}}`. This template produces\n    // a ternary of the form:\n    //   `a == null ? null : rest of expression`\n    // If the rest of the expression is also a ternary though, this would produce the form:\n    //   `a == null ? null : a.b ? c : d`\n    // which, if left as right-associative, would be incorrectly associated as:\n    //   `a == null ? null : (a.b ? c : d)`\n    //\n    // In such cases, the left-associativity needs to be enforced with parentheses:\n    //   `(a == null ? null : a.b) ? c : d`\n    //\n    // Such parentheses could always be included in the condition (guaranteeing correct behavior) in\n    // all cases, but this has a code size cost. Instead, parentheses are added only when a\n    // conditional expression is directly used as the condition of another.\n    //\n    // TODO(alxhub): investigate better logic for precendence of conditional operators\n    if (ast.condition instanceof o.ConditionalExpr) {\n      // The condition of this ternary needs to be wrapped in parentheses to maintain\n      // left-associativity.\n      cond = this.factory.createParenthesizedExpression(cond);\n    }\n\n    return this.factory.createConditional(\n        cond, ast.trueCase.visitExpression(this, context),\n        ast.falseCase!.visitExpression(this, context));\n  }\n\n  visitNotExpr(ast: o.NotExpr, context: Context): TExpression {\n    return this.factory.createUnaryExpression('!', ast.condition.visitExpression(this, context));\n  }\n\n  visitAssertNotNullExpr(ast: o.AssertNotNull, context: Context): TExpression {\n    return ast.condition.visitExpression(this, context);\n  }\n\n  visitCastExpr(ast: o.CastExpr, context: Context): TExpression {\n    return ast.value.visitExpression(this, context);\n  }\n\n  visitFunctionExpr(ast: o.FunctionExpr, context: Context): TExpression {\n    return this.factory.createFunctionExpression(\n        ast.name ?? null, ast.params.map(param => param.name),\n        this.factory.createBlock(this.visitStatements(ast.statements, context)));\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, context: Context): TExpression {\n    if (!BINARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown binary operator: ${o.BinaryOperator[ast.operator]}`);\n    }\n    return this.factory.createBinaryExpression(\n        ast.lhs.visitExpression(this, context),\n        BINARY_OPERATORS.get(ast.operator)!,\n        ast.rhs.visitExpression(this, context),\n    );\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, context: Context): TExpression {\n    return this.factory.createPropertyAccess(ast.receiver.visitExpression(this, context), ast.name);\n  }\n\n  visitReadKeyExpr(ast: o.ReadKeyExpr, context: Context): TExpression {\n    return this.factory.createElementAccess(\n        ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context));\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: Context): TExpression {\n    return this.factory.createArrayLiteral(ast.entries.map(\n        expr => this.setSourceMapRange(expr.visitExpression(this, context), ast.sourceSpan)));\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: Context): TExpression {\n    const properties: ObjectLiteralProperty<TExpression>[] = ast.entries.map(entry => {\n      return {\n        propertyName: entry.key,\n        quoted: entry.quoted,\n        value: entry.value.visitExpression(this, context)\n      };\n    });\n    return this.setSourceMapRange(this.factory.createObjectLiteral(properties), ast.sourceSpan);\n  }\n\n  visitCommaExpr(ast: o.CommaExpr, context: Context): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, _context: Context): any {\n    this.recordWrappedNode(ast);\n    return ast.node;\n  }\n\n  visitTypeofExpr(ast: o.TypeofExpr, context: Context): TExpression {\n    return this.factory.createTypeOfExpression(ast.expr.visitExpression(this, context));\n  }\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, context: Context): TExpression {\n    if (!UNARY_OPERATORS.has(ast.operator)) {\n      throw new Error(`Unknown unary operator: ${o.UnaryOperator[ast.operator]}`);\n    }\n    return this.factory.createUnaryExpression(\n        UNARY_OPERATORS.get(ast.operator)!, ast.expr.visitExpression(this, context));\n  }\n\n  private visitStatements(statements: o.Statement[], context: Context): TStatement[] {\n    return statements.map(stmt => stmt.visitStatement(this, context))\n        .filter(stmt => stmt !== undefined);\n  }\n\n  private setSourceMapRange<T extends TExpression|TStatement>(ast: T, span: o.ParseSourceSpan|null):\n      T {\n    return this.factory.setSourceMapRange(ast, createRange(span));\n  }\n\n  private attachComments(statement: TStatement, leadingComments: o.LeadingComment[]|undefined):\n      TStatement {\n    if (leadingComments !== undefined) {\n      this.factory.attachComments(statement, leadingComments);\n    }\n    return statement;\n  }\n}\n\n/**\n * Convert a cooked-raw string object into one that can be used by the AST factories.\n */\nfunction createTemplateElement(\n    {cooked, raw, range}: {cooked: string, raw: string, range: o.ParseSourceSpan|null}):\n    TemplateElement {\n  return {cooked, raw, range: createRange(range)};\n}\n\n/**\n * Convert an OutputAST source-span into a range that can be used by the AST factories.\n */\nfunction createRange(span: o.ParseSourceSpan|null): SourceMapRange|null {\n  if (span === null) {\n    return null;\n  }\n  const {start, end} = span;\n  const {url, content} = start.file;\n  if (!url) {\n    return null;\n  }\n  return {\n    url,\n    content,\n    start: {offset: start.offset, line: start.line, column: start.col},\n    end: {offset: end.offset, line: end.line, column: end.col},\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}