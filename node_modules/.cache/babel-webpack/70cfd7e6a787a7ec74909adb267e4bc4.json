{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeIvyJitSupportCalls = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ts = require(\"typescript\");\n\nvar ast_helpers_1 = require(\"./ast_helpers\");\n\nvar interfaces_1 = require(\"./interfaces\");\n\nvar make_transform_1 = require(\"./make_transform\");\n\nfunction removeIvyJitSupportCalls(classMetadata, ngModuleScope, getTypeChecker) {\n  var standardTransform = function standardTransform(sourceFile) {\n    var ops = [];\n    ast_helpers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.ExpressionStatement).filter(function (statement) {\n      var innerStatement = getIifeStatement(statement);\n\n      if (!innerStatement) {\n        return false;\n      }\n\n      var shouldRemove = false;\n\n      if (ngModuleScope && ts.isBinaryExpression(innerStatement.expression)) {\n        shouldRemove = isIvyPrivateCallExpression(innerStatement.expression.right, 'ɵɵsetNgModuleScope');\n      }\n\n      if (classMetadata && !shouldRemove) {\n        if (ts.isBinaryExpression(innerStatement.expression)) {\n          shouldRemove = isIvyPrivateCallExpression(innerStatement.expression.right, 'ɵsetClassMetadata');\n        } else {\n          shouldRemove = isIvyPrivateCallExpression(innerStatement.expression, 'ɵsetClassMetadata');\n        }\n      }\n\n      return shouldRemove;\n    }).forEach(function (statement) {\n      return ops.push(new interfaces_1.RemoveNodeOperation(sourceFile, statement));\n    });\n    return ops;\n  };\n\n  return make_transform_1.makeTransform(standardTransform, getTypeChecker);\n}\n\nexports.removeIvyJitSupportCalls = removeIvyJitSupportCalls; // Each Ivy private call expression is inside an IIFE\n\nfunction getIifeStatement(exprStmt) {\n  var expression = exprStmt.expression;\n\n  if (!expression || !ts.isCallExpression(expression) || expression.arguments.length !== 0) {\n    return null;\n  }\n\n  var parenExpr = expression;\n\n  if (!ts.isParenthesizedExpression(parenExpr.expression)) {\n    return null;\n  }\n\n  var funExpr = parenExpr.expression.expression;\n\n  if (!ts.isFunctionExpression(funExpr)) {\n    return null;\n  }\n\n  var innerStmts = funExpr.body.statements;\n\n  if (innerStmts.length !== 1) {\n    return null;\n  }\n\n  var innerExprStmt = innerStmts[0];\n\n  if (!ts.isExpressionStatement(innerExprStmt)) {\n    return null;\n  }\n\n  return innerExprStmt;\n}\n\nfunction isIvyPrivateCallExpression(expression, name) {\n  // Now we're in the IIFE and have the inner expression statement. We can check if it matches\n  // a private Ivy call.\n  if (!ts.isCallExpression(expression)) {\n    return false;\n  }\n\n  var propAccExpr = expression.expression;\n\n  if (!ts.isPropertyAccessExpression(propAccExpr)) {\n    return false;\n  }\n\n  if (propAccExpr.name.text != name) {\n    return false;\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/transformers/remove-ivy-jit-support-calls.js"],"names":["Object","defineProperty","exports","value","removeIvyJitSupportCalls","ts","require","ast_helpers_1","interfaces_1","make_transform_1","classMetadata","ngModuleScope","getTypeChecker","standardTransform","sourceFile","ops","collectDeepNodes","SyntaxKind","ExpressionStatement","filter","statement","innerStatement","getIifeStatement","shouldRemove","isBinaryExpression","expression","isIvyPrivateCallExpression","right","forEach","push","RemoveNodeOperation","makeTransform","exprStmt","isCallExpression","arguments","length","parenExpr","isParenthesizedExpression","funExpr","isFunctionExpression","innerStmts","body","statements","innerExprStmt","isExpressionStatement","name","propAccExpr","isPropertyAccessExpression","text"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeIvyJitSupportCalls = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ts = require(\"typescript\");\nconst ast_helpers_1 = require(\"./ast_helpers\");\nconst interfaces_1 = require(\"./interfaces\");\nconst make_transform_1 = require(\"./make_transform\");\nfunction removeIvyJitSupportCalls(classMetadata, ngModuleScope, getTypeChecker) {\n    const standardTransform = function (sourceFile) {\n        const ops = [];\n        ast_helpers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.ExpressionStatement)\n            .filter(statement => {\n            const innerStatement = getIifeStatement(statement);\n            if (!innerStatement) {\n                return false;\n            }\n            let shouldRemove = false;\n            if (ngModuleScope && ts.isBinaryExpression(innerStatement.expression)) {\n                shouldRemove = isIvyPrivateCallExpression(innerStatement.expression.right, 'ɵɵsetNgModuleScope');\n            }\n            if (classMetadata && !shouldRemove) {\n                if (ts.isBinaryExpression(innerStatement.expression)) {\n                    shouldRemove = isIvyPrivateCallExpression(innerStatement.expression.right, 'ɵsetClassMetadata');\n                }\n                else {\n                    shouldRemove = isIvyPrivateCallExpression(innerStatement.expression, 'ɵsetClassMetadata');\n                }\n            }\n            return shouldRemove;\n        })\n            .forEach(statement => ops.push(new interfaces_1.RemoveNodeOperation(sourceFile, statement)));\n        return ops;\n    };\n    return make_transform_1.makeTransform(standardTransform, getTypeChecker);\n}\nexports.removeIvyJitSupportCalls = removeIvyJitSupportCalls;\n// Each Ivy private call expression is inside an IIFE\nfunction getIifeStatement(exprStmt) {\n    const expression = exprStmt.expression;\n    if (!expression || !ts.isCallExpression(expression) || expression.arguments.length !== 0) {\n        return null;\n    }\n    const parenExpr = expression;\n    if (!ts.isParenthesizedExpression(parenExpr.expression)) {\n        return null;\n    }\n    const funExpr = parenExpr.expression.expression;\n    if (!ts.isFunctionExpression(funExpr)) {\n        return null;\n    }\n    const innerStmts = funExpr.body.statements;\n    if (innerStmts.length !== 1) {\n        return null;\n    }\n    const innerExprStmt = innerStmts[0];\n    if (!ts.isExpressionStatement(innerExprStmt)) {\n        return null;\n    }\n    return innerExprStmt;\n}\nfunction isIvyPrivateCallExpression(expression, name) {\n    // Now we're in the IIFE and have the inner expression statement. We can check if it matches\n    // a private Ivy call.\n    if (!ts.isCallExpression(expression)) {\n        return false;\n    }\n    const propAccExpr = expression.expression;\n    if (!ts.isPropertyAccessExpression(propAccExpr)) {\n        return false;\n    }\n    if (propAccExpr.name.text != name) {\n        return false;\n    }\n    return true;\n}\n"]},"metadata":{},"sourceType":"script"}