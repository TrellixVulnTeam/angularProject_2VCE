{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/expression_parser/ast\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.BoundElementProperty = exports.ParsedVariable = exports.ParsedEvent = exports.ParsedPropertyType = exports.ParsedProperty = exports.AstMemoryEfficientTransformer = exports.AstTransformer = exports.RecursiveAstVisitor = exports.ExpressionBinding = exports.VariableBinding = exports.ASTWithSource = exports.AbsoluteSourceSpan = exports.FunctionCall = exports.SafeMethodCall = exports.MethodCall = exports.NonNullAssert = exports.PrefixNot = exports.Unary = exports.Binary = exports.Interpolation = exports.LiteralMap = exports.LiteralArray = exports.LiteralPrimitive = exports.BindingPipe = exports.KeyedWrite = exports.KeyedRead = exports.SafePropertyRead = exports.PropertyWrite = exports.PropertyRead = exports.Conditional = exports.Chain = exports.ThisReceiver = exports.ImplicitReceiver = exports.EmptyExpr = exports.Quote = exports.ASTWithName = exports.AST = exports.ParseSpan = exports.ParserError = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ParserError =\n  /** @class */\n  function () {\n    function ParserError(message, input, errLocation, ctxLocation) {\n      this.input = input;\n      this.errLocation = errLocation;\n      this.ctxLocation = ctxLocation;\n      this.message = \"Parser Error: \" + message + \" \" + errLocation + \" [\" + input + \"] in \" + ctxLocation;\n    }\n\n    return ParserError;\n  }();\n\n  exports.ParserError = ParserError;\n\n  var ParseSpan =\n  /** @class */\n  function () {\n    function ParseSpan(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n\n    ParseSpan.prototype.toAbsolute = function (absoluteOffset) {\n      return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n    };\n\n    return ParseSpan;\n  }();\n\n  exports.ParseSpan = ParseSpan;\n\n  var AST =\n  /** @class */\n  function () {\n    function AST(span,\n    /**\n     * Absolute location of the expression AST in a source code file.\n     */\n    sourceSpan) {\n      this.span = span;\n      this.sourceSpan = sourceSpan;\n    }\n\n    AST.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return null;\n    };\n\n    AST.prototype.toString = function () {\n      return 'AST';\n    };\n\n    return AST;\n  }();\n\n  exports.AST = AST;\n\n  var ASTWithName =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ASTWithName, _super);\n\n    function ASTWithName(span, sourceSpan, nameSpan) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.nameSpan = nameSpan;\n      return _this;\n    }\n\n    return ASTWithName;\n  }(AST);\n\n  exports.ASTWithName = ASTWithName;\n  /**\n   * Represents a quoted expression of the form:\n   *\n   * quote = prefix `:` uninterpretedExpression\n   * prefix = identifier\n   * uninterpretedExpression = arbitrary string\n   *\n   * A quoted expression is meant to be pre-processed by an AST transformer that\n   * converts it into another AST that no longer contains quoted expressions.\n   * It is meant to allow third-party developers to extend Angular template\n   * expression language. The `uninterpretedExpression` part of the quote is\n   * therefore not interpreted by the Angular's own expression parser.\n   */\n\n  var Quote =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Quote, _super);\n\n    function Quote(span, sourceSpan, prefix, uninterpretedExpression, location) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.prefix = prefix;\n      _this.uninterpretedExpression = uninterpretedExpression;\n      _this.location = location;\n      return _this;\n    }\n\n    Quote.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitQuote(this, context);\n    };\n\n    Quote.prototype.toString = function () {\n      return 'Quote';\n    };\n\n    return Quote;\n  }(AST);\n\n  exports.Quote = Quote;\n\n  var EmptyExpr =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(EmptyExpr, _super);\n\n    function EmptyExpr() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    EmptyExpr.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      } // do nothing\n\n    };\n\n    return EmptyExpr;\n  }(AST);\n\n  exports.EmptyExpr = EmptyExpr;\n\n  var ImplicitReceiver =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ImplicitReceiver, _super);\n\n    function ImplicitReceiver() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    ImplicitReceiver.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitImplicitReceiver(this, context);\n    };\n\n    return ImplicitReceiver;\n  }(AST);\n\n  exports.ImplicitReceiver = ImplicitReceiver;\n  /**\n   * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n   * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n   * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n   * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n   * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n   * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n   */\n\n  var ThisReceiver =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ThisReceiver, _super);\n\n    function ThisReceiver() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    ThisReceiver.prototype.visit = function (visitor, context) {\n      var _a;\n\n      if (context === void 0) {\n        context = null;\n      }\n\n      return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context);\n    };\n\n    return ThisReceiver;\n  }(ImplicitReceiver);\n\n  exports.ThisReceiver = ThisReceiver;\n  /**\n   * Multiple expressions separated by a semicolon.\n   */\n\n  var Chain =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Chain, _super);\n\n    function Chain(span, sourceSpan, expressions) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.expressions = expressions;\n      return _this;\n    }\n\n    Chain.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitChain(this, context);\n    };\n\n    return Chain;\n  }(AST);\n\n  exports.Chain = Chain;\n\n  var Conditional =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Conditional, _super);\n\n    function Conditional(span, sourceSpan, condition, trueExp, falseExp) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.condition = condition;\n      _this.trueExp = trueExp;\n      _this.falseExp = falseExp;\n      return _this;\n    }\n\n    Conditional.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitConditional(this, context);\n    };\n\n    return Conditional;\n  }(AST);\n\n  exports.Conditional = Conditional;\n\n  var PropertyRead =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(PropertyRead, _super);\n\n    function PropertyRead(span, sourceSpan, nameSpan, receiver, name) {\n      var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n\n      _this.receiver = receiver;\n      _this.name = name;\n      return _this;\n    }\n\n    PropertyRead.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitPropertyRead(this, context);\n    };\n\n    return PropertyRead;\n  }(ASTWithName);\n\n  exports.PropertyRead = PropertyRead;\n\n  var PropertyWrite =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(PropertyWrite, _super);\n\n    function PropertyWrite(span, sourceSpan, nameSpan, receiver, name, value) {\n      var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n\n      _this.receiver = receiver;\n      _this.name = name;\n      _this.value = value;\n      return _this;\n    }\n\n    PropertyWrite.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitPropertyWrite(this, context);\n    };\n\n    return PropertyWrite;\n  }(ASTWithName);\n\n  exports.PropertyWrite = PropertyWrite;\n\n  var SafePropertyRead =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(SafePropertyRead, _super);\n\n    function SafePropertyRead(span, sourceSpan, nameSpan, receiver, name) {\n      var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n\n      _this.receiver = receiver;\n      _this.name = name;\n      return _this;\n    }\n\n    SafePropertyRead.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitSafePropertyRead(this, context);\n    };\n\n    return SafePropertyRead;\n  }(ASTWithName);\n\n  exports.SafePropertyRead = SafePropertyRead;\n\n  var KeyedRead =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(KeyedRead, _super);\n\n    function KeyedRead(span, sourceSpan, obj, key) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.obj = obj;\n      _this.key = key;\n      return _this;\n    }\n\n    KeyedRead.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitKeyedRead(this, context);\n    };\n\n    return KeyedRead;\n  }(AST);\n\n  exports.KeyedRead = KeyedRead;\n\n  var KeyedWrite =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(KeyedWrite, _super);\n\n    function KeyedWrite(span, sourceSpan, obj, key, value) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.obj = obj;\n      _this.key = key;\n      _this.value = value;\n      return _this;\n    }\n\n    KeyedWrite.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitKeyedWrite(this, context);\n    };\n\n    return KeyedWrite;\n  }(AST);\n\n  exports.KeyedWrite = KeyedWrite;\n\n  var BindingPipe =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(BindingPipe, _super);\n\n    function BindingPipe(span, sourceSpan, exp, name, args, nameSpan) {\n      var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n\n      _this.exp = exp;\n      _this.name = name;\n      _this.args = args;\n      return _this;\n    }\n\n    BindingPipe.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitPipe(this, context);\n    };\n\n    return BindingPipe;\n  }(ASTWithName);\n\n  exports.BindingPipe = BindingPipe;\n\n  var LiteralPrimitive =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(LiteralPrimitive, _super);\n\n    function LiteralPrimitive(span, sourceSpan, value) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.value = value;\n      return _this;\n    }\n\n    LiteralPrimitive.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitLiteralPrimitive(this, context);\n    };\n\n    return LiteralPrimitive;\n  }(AST);\n\n  exports.LiteralPrimitive = LiteralPrimitive;\n\n  var LiteralArray =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(LiteralArray, _super);\n\n    function LiteralArray(span, sourceSpan, expressions) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.expressions = expressions;\n      return _this;\n    }\n\n    LiteralArray.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitLiteralArray(this, context);\n    };\n\n    return LiteralArray;\n  }(AST);\n\n  exports.LiteralArray = LiteralArray;\n\n  var LiteralMap =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(LiteralMap, _super);\n\n    function LiteralMap(span, sourceSpan, keys, values) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.keys = keys;\n      _this.values = values;\n      return _this;\n    }\n\n    LiteralMap.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitLiteralMap(this, context);\n    };\n\n    return LiteralMap;\n  }(AST);\n\n  exports.LiteralMap = LiteralMap;\n\n  var Interpolation =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Interpolation, _super);\n\n    function Interpolation(span, sourceSpan, strings, expressions) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.strings = strings;\n      _this.expressions = expressions;\n      return _this;\n    }\n\n    Interpolation.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitInterpolation(this, context);\n    };\n\n    return Interpolation;\n  }(AST);\n\n  exports.Interpolation = Interpolation;\n\n  var Binary =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Binary, _super);\n\n    function Binary(span, sourceSpan, operation, left, right) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.operation = operation;\n      _this.left = left;\n      _this.right = right;\n      return _this;\n    }\n\n    Binary.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitBinary(this, context);\n    };\n\n    return Binary;\n  }(AST);\n\n  exports.Binary = Binary;\n  /**\n   * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n   * node that was originally used. This inheritance relation can be deleted in some future major,\n   * after consumers have been given a chance to fully support Unary.\n   */\n\n  var Unary =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Unary, _super);\n    /**\n     * During the deprecation period this constructor is private, to avoid consumers from creating\n     * a `Unary` with the fallback properties for `Binary`.\n     */\n\n\n    function Unary(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\n      var _this = _super.call(this, span, sourceSpan, binaryOp, binaryLeft, binaryRight) || this;\n\n      _this.operator = operator;\n      _this.expr = expr;\n      return _this;\n    }\n    /**\n     * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n     */\n\n\n    Unary.createMinus = function (span, sourceSpan, expr) {\n      return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n    };\n    /**\n     * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n     */\n\n\n    Unary.createPlus = function (span, sourceSpan, expr) {\n      return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n    };\n\n    Unary.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      if (visitor.visitUnary !== undefined) {\n        return visitor.visitUnary(this, context);\n      }\n\n      return visitor.visitBinary(this, context);\n    };\n\n    return Unary;\n  }(Binary);\n\n  exports.Unary = Unary;\n\n  var PrefixNot =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(PrefixNot, _super);\n\n    function PrefixNot(span, sourceSpan, expression) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.expression = expression;\n      return _this;\n    }\n\n    PrefixNot.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitPrefixNot(this, context);\n    };\n\n    return PrefixNot;\n  }(AST);\n\n  exports.PrefixNot = PrefixNot;\n\n  var NonNullAssert =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(NonNullAssert, _super);\n\n    function NonNullAssert(span, sourceSpan, expression) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.expression = expression;\n      return _this;\n    }\n\n    NonNullAssert.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitNonNullAssert(this, context);\n    };\n\n    return NonNullAssert;\n  }(AST);\n\n  exports.NonNullAssert = NonNullAssert;\n\n  var MethodCall =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(MethodCall, _super);\n\n    function MethodCall(span, sourceSpan, nameSpan, receiver, name, args) {\n      var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n\n      _this.receiver = receiver;\n      _this.name = name;\n      _this.args = args;\n      return _this;\n    }\n\n    MethodCall.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitMethodCall(this, context);\n    };\n\n    return MethodCall;\n  }(ASTWithName);\n\n  exports.MethodCall = MethodCall;\n\n  var SafeMethodCall =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(SafeMethodCall, _super);\n\n    function SafeMethodCall(span, sourceSpan, nameSpan, receiver, name, args) {\n      var _this = _super.call(this, span, sourceSpan, nameSpan) || this;\n\n      _this.receiver = receiver;\n      _this.name = name;\n      _this.args = args;\n      return _this;\n    }\n\n    SafeMethodCall.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitSafeMethodCall(this, context);\n    };\n\n    return SafeMethodCall;\n  }(ASTWithName);\n\n  exports.SafeMethodCall = SafeMethodCall;\n\n  var FunctionCall =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(FunctionCall, _super);\n\n    function FunctionCall(span, sourceSpan, target, args) {\n      var _this = _super.call(this, span, sourceSpan) || this;\n\n      _this.target = target;\n      _this.args = args;\n      return _this;\n    }\n\n    FunctionCall.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      return visitor.visitFunctionCall(this, context);\n    };\n\n    return FunctionCall;\n  }(AST);\n\n  exports.FunctionCall = FunctionCall;\n  /**\n   * Records the absolute position of a text span in a source file, where `start` and `end` are the\n   * starting and ending byte offsets, respectively, of the text span in a source file.\n   */\n\n  var AbsoluteSourceSpan =\n  /** @class */\n  function () {\n    function AbsoluteSourceSpan(start, end) {\n      this.start = start;\n      this.end = end;\n    }\n\n    return AbsoluteSourceSpan;\n  }();\n\n  exports.AbsoluteSourceSpan = AbsoluteSourceSpan;\n\n  var ASTWithSource =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ASTWithSource, _super);\n\n    function ASTWithSource(ast, source, location, absoluteOffset, errors) {\n      var _this = _super.call(this, new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length)) || this;\n\n      _this.ast = ast;\n      _this.source = source;\n      _this.location = location;\n      _this.errors = errors;\n      return _this;\n    }\n\n    ASTWithSource.prototype.visit = function (visitor, context) {\n      if (context === void 0) {\n        context = null;\n      }\n\n      if (visitor.visitASTWithSource) {\n        return visitor.visitASTWithSource(this, context);\n      }\n\n      return this.ast.visit(visitor, context);\n    };\n\n    ASTWithSource.prototype.toString = function () {\n      return this.source + \" in \" + this.location;\n    };\n\n    return ASTWithSource;\n  }(AST);\n\n  exports.ASTWithSource = ASTWithSource;\n\n  var VariableBinding =\n  /** @class */\n  function () {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key name of the LHS along with its span.\n     * @param value optional value for the RHS along with its span.\n     */\n    function VariableBinding(sourceSpan, key, value) {\n      this.sourceSpan = sourceSpan;\n      this.key = key;\n      this.value = value;\n    }\n\n    return VariableBinding;\n  }();\n\n  exports.VariableBinding = VariableBinding;\n\n  var ExpressionBinding =\n  /** @class */\n  function () {\n    /**\n     * @param sourceSpan entire span of the binding.\n     * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n     * span. Note that the length of the span may not be the same as\n     * `key.source.length`. For example,\n     * 1. key.source = ngFor, key.span is for \"ngFor\"\n     * 2. key.source = ngForOf, key.span is for \"of\"\n     * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n     * @param value optional expression for the RHS.\n     */\n    function ExpressionBinding(sourceSpan, key, value) {\n      this.sourceSpan = sourceSpan;\n      this.key = key;\n      this.value = value;\n    }\n\n    return ExpressionBinding;\n  }();\n\n  exports.ExpressionBinding = ExpressionBinding;\n\n  var RecursiveAstVisitor =\n  /** @class */\n  function () {\n    function RecursiveAstVisitor() {}\n\n    RecursiveAstVisitor.prototype.visit = function (ast, context) {\n      // The default implementation just visits every node.\n      // Classes that extend RecursiveAstVisitor should override this function\n      // to selectively visit the specified node.\n      ast.visit(this, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitUnary = function (ast, context) {\n      this.visit(ast.expr, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitBinary = function (ast, context) {\n      this.visit(ast.left, context);\n      this.visit(ast.right, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitChain = function (ast, context) {\n      this.visitAll(ast.expressions, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitConditional = function (ast, context) {\n      this.visit(ast.condition, context);\n      this.visit(ast.trueExp, context);\n      this.visit(ast.falseExp, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitPipe = function (ast, context) {\n      this.visit(ast.exp, context);\n      this.visitAll(ast.args, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitFunctionCall = function (ast, context) {\n      if (ast.target) {\n        this.visit(ast.target, context);\n      }\n\n      this.visitAll(ast.args, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitImplicitReceiver = function (ast, context) {};\n\n    RecursiveAstVisitor.prototype.visitThisReceiver = function (ast, context) {};\n\n    RecursiveAstVisitor.prototype.visitInterpolation = function (ast, context) {\n      this.visitAll(ast.expressions, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitKeyedRead = function (ast, context) {\n      this.visit(ast.obj, context);\n      this.visit(ast.key, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitKeyedWrite = function (ast, context) {\n      this.visit(ast.obj, context);\n      this.visit(ast.key, context);\n      this.visit(ast.value, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitLiteralArray = function (ast, context) {\n      this.visitAll(ast.expressions, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitLiteralMap = function (ast, context) {\n      this.visitAll(ast.values, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitLiteralPrimitive = function (ast, context) {};\n\n    RecursiveAstVisitor.prototype.visitMethodCall = function (ast, context) {\n      this.visit(ast.receiver, context);\n      this.visitAll(ast.args, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitPrefixNot = function (ast, context) {\n      this.visit(ast.expression, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitNonNullAssert = function (ast, context) {\n      this.visit(ast.expression, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitPropertyRead = function (ast, context) {\n      this.visit(ast.receiver, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitPropertyWrite = function (ast, context) {\n      this.visit(ast.receiver, context);\n      this.visit(ast.value, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitSafePropertyRead = function (ast, context) {\n      this.visit(ast.receiver, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitSafeMethodCall = function (ast, context) {\n      this.visit(ast.receiver, context);\n      this.visitAll(ast.args, context);\n    };\n\n    RecursiveAstVisitor.prototype.visitQuote = function (ast, context) {}; // This is not part of the AstVisitor interface, just a helper method\n\n\n    RecursiveAstVisitor.prototype.visitAll = function (asts, context) {\n      var e_1, _a;\n\n      try {\n        for (var asts_1 = tslib_1.__values(asts), asts_1_1 = asts_1.next(); !asts_1_1.done; asts_1_1 = asts_1.next()) {\n          var ast = asts_1_1.value;\n          this.visit(ast, context);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (asts_1_1 && !asts_1_1.done && (_a = asts_1.return)) _a.call(asts_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    return RecursiveAstVisitor;\n  }();\n\n  exports.RecursiveAstVisitor = RecursiveAstVisitor;\n\n  var AstTransformer =\n  /** @class */\n  function () {\n    function AstTransformer() {}\n\n    AstTransformer.prototype.visitImplicitReceiver = function (ast, context) {\n      return ast;\n    };\n\n    AstTransformer.prototype.visitThisReceiver = function (ast, context) {\n      return ast;\n    };\n\n    AstTransformer.prototype.visitInterpolation = function (ast, context) {\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n    };\n\n    AstTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n      return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n    };\n\n    AstTransformer.prototype.visitPropertyRead = function (ast, context) {\n      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    };\n\n    AstTransformer.prototype.visitPropertyWrite = function (ast, context) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    };\n\n    AstTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    };\n\n    AstTransformer.prototype.visitMethodCall = function (ast, context) {\n      return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n\n    AstTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n      return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    };\n\n    AstTransformer.prototype.visitFunctionCall = function (ast, context) {\n      return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));\n    };\n\n    AstTransformer.prototype.visitLiteralArray = function (ast, context) {\n      return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    };\n\n    AstTransformer.prototype.visitLiteralMap = function (ast, context) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n    };\n\n    AstTransformer.prototype.visitUnary = function (ast, context) {\n      switch (ast.operator) {\n        case '+':\n          return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n\n        case '-':\n          return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n\n        default:\n          throw new Error(\"Unknown unary operator \" + ast.operator);\n      }\n    };\n\n    AstTransformer.prototype.visitBinary = function (ast, context) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    };\n\n    AstTransformer.prototype.visitPrefixNot = function (ast, context) {\n      return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    };\n\n    AstTransformer.prototype.visitNonNullAssert = function (ast, context) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    };\n\n    AstTransformer.prototype.visitConditional = function (ast, context) {\n      return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    };\n\n    AstTransformer.prototype.visitPipe = function (ast, context) {\n      return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);\n    };\n\n    AstTransformer.prototype.visitKeyedRead = function (ast, context) {\n      return new KeyedRead(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this));\n    };\n\n    AstTransformer.prototype.visitKeyedWrite = function (ast, context) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    };\n\n    AstTransformer.prototype.visitAll = function (asts) {\n      var res = [];\n\n      for (var i = 0; i < asts.length; ++i) {\n        res[i] = asts[i].visit(this);\n      }\n\n      return res;\n    };\n\n    AstTransformer.prototype.visitChain = function (ast, context) {\n      return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    };\n\n    AstTransformer.prototype.visitQuote = function (ast, context) {\n      return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\n    };\n\n    return AstTransformer;\n  }();\n\n  exports.AstTransformer = AstTransformer; // A transformer that only creates new nodes if the transformer makes a change or\n  // a change is made a child node.\n\n  var AstMemoryEfficientTransformer =\n  /** @class */\n  function () {\n    function AstMemoryEfficientTransformer() {}\n\n    AstMemoryEfficientTransformer.prototype.visitImplicitReceiver = function (ast, context) {\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitThisReceiver = function (ast, context) {\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitInterpolation = function (ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n      if (expressions !== ast.expressions) return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitLiteralPrimitive = function (ast, context) {\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitPropertyRead = function (ast, context) {\n      var receiver = ast.receiver.visit(this);\n\n      if (receiver !== ast.receiver) {\n        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitPropertyWrite = function (ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var value = ast.value.visit(this);\n\n      if (receiver !== ast.receiver || value !== ast.value) {\n        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitSafePropertyRead = function (ast, context) {\n      var receiver = ast.receiver.visit(this);\n\n      if (receiver !== ast.receiver) {\n        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitMethodCall = function (ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (receiver !== ast.receiver || args !== ast.args) {\n        return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitSafeMethodCall = function (ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (receiver !== ast.receiver || args !== ast.args) {\n        return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitFunctionCall = function (ast, context) {\n      var target = ast.target && ast.target.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (target !== ast.target || args !== ast.args) {\n        return new FunctionCall(ast.span, ast.sourceSpan, target, args);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitLiteralArray = function (ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n\n      if (expressions !== ast.expressions) {\n        return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitLiteralMap = function (ast, context) {\n      var values = this.visitAll(ast.values);\n\n      if (values !== ast.values) {\n        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitUnary = function (ast, context) {\n      var expr = ast.expr.visit(this);\n\n      if (expr !== ast.expr) {\n        switch (ast.operator) {\n          case '+':\n            return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n\n          case '-':\n            return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n\n          default:\n            throw new Error(\"Unknown unary operator \" + ast.operator);\n        }\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitBinary = function (ast, context) {\n      var left = ast.left.visit(this);\n      var right = ast.right.visit(this);\n\n      if (left !== ast.left || right !== ast.right) {\n        return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitPrefixNot = function (ast, context) {\n      var expression = ast.expression.visit(this);\n\n      if (expression !== ast.expression) {\n        return new PrefixNot(ast.span, ast.sourceSpan, expression);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitNonNullAssert = function (ast, context) {\n      var expression = ast.expression.visit(this);\n\n      if (expression !== ast.expression) {\n        return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitConditional = function (ast, context) {\n      var condition = ast.condition.visit(this);\n      var trueExp = ast.trueExp.visit(this);\n      var falseExp = ast.falseExp.visit(this);\n\n      if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n        return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitPipe = function (ast, context) {\n      var exp = ast.exp.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (exp !== ast.exp || args !== ast.args) {\n        return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitKeyedRead = function (ast, context) {\n      var obj = ast.obj.visit(this);\n      var key = ast.key.visit(this);\n\n      if (obj !== ast.obj || key !== ast.key) {\n        return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitKeyedWrite = function (ast, context) {\n      var obj = ast.obj.visit(this);\n      var key = ast.key.visit(this);\n      var value = ast.value.visit(this);\n\n      if (obj !== ast.obj || key !== ast.key || value !== ast.value) {\n        return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitAll = function (asts) {\n      var res = [];\n      var modified = false;\n\n      for (var i = 0; i < asts.length; ++i) {\n        var original = asts[i];\n        var value = original.visit(this);\n        res[i] = value;\n        modified = modified || value !== original;\n      }\n\n      return modified ? res : asts;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitChain = function (ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n\n      if (expressions !== ast.expressions) {\n        return new Chain(ast.span, ast.sourceSpan, expressions);\n      }\n\n      return ast;\n    };\n\n    AstMemoryEfficientTransformer.prototype.visitQuote = function (ast, context) {\n      return ast;\n    };\n\n    return AstMemoryEfficientTransformer;\n  }();\n\n  exports.AstMemoryEfficientTransformer = AstMemoryEfficientTransformer; // Bindings\n\n  var ParsedProperty =\n  /** @class */\n  function () {\n    function ParsedProperty(name, expression, type, // TODO(FW-2095): `keySpan` should really be required but allows `undefined` so VE does\n    // not need to be updated. Make `keySpan` required when VE is removed.\n    sourceSpan, keySpan, valueSpan) {\n      this.name = name;\n      this.expression = expression;\n      this.type = type;\n      this.sourceSpan = sourceSpan;\n      this.keySpan = keySpan;\n      this.valueSpan = valueSpan;\n      this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n      this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n    }\n\n    return ParsedProperty;\n  }();\n\n  exports.ParsedProperty = ParsedProperty;\n  var ParsedPropertyType;\n\n  (function (ParsedPropertyType) {\n    ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n    ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n  })(ParsedPropertyType = exports.ParsedPropertyType || (exports.ParsedPropertyType = {}));\n\n  var ParsedEvent =\n  /** @class */\n  function () {\n    // Regular events have a target\n    // Animation events have a phase\n    function ParsedEvent(name, targetOrPhase, type, handler, sourceSpan, // TODO(FW-2095): keySpan should be required but was made optional to avoid changing VE\n    handlerSpan, keySpan) {\n      this.name = name;\n      this.targetOrPhase = targetOrPhase;\n      this.type = type;\n      this.handler = handler;\n      this.sourceSpan = sourceSpan;\n      this.handlerSpan = handlerSpan;\n      this.keySpan = keySpan;\n    }\n\n    return ParsedEvent;\n  }();\n\n  exports.ParsedEvent = ParsedEvent;\n  /**\n   * ParsedVariable represents a variable declaration in a microsyntax expression.\n   */\n\n  var ParsedVariable =\n  /** @class */\n  function () {\n    function ParsedVariable(name, value, sourceSpan, keySpan, valueSpan) {\n      this.name = name;\n      this.value = value;\n      this.sourceSpan = sourceSpan;\n      this.keySpan = keySpan;\n      this.valueSpan = valueSpan;\n    }\n\n    return ParsedVariable;\n  }();\n\n  exports.ParsedVariable = ParsedVariable;\n\n  var BoundElementProperty =\n  /** @class */\n  function () {\n    function BoundElementProperty(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\n      this.name = name;\n      this.type = type;\n      this.securityContext = securityContext;\n      this.value = value;\n      this.unit = unit;\n      this.sourceSpan = sourceSpan;\n      this.keySpan = keySpan;\n      this.valueSpan = valueSpan;\n    }\n\n    return BoundElementProperty;\n  }();\n\n  exports.BoundElementProperty = BoundElementProperty;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/expression_parser/ast.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class ParserError {\n  public message: string;\n  constructor(\n      message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n  toAbsolute(absoluteOffset: number): AbsoluteSourceSpan {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\n\nexport class AST {\n  constructor(\n      public span: ParseSpan,\n      /**\n       * Absolute location of the expression AST in a source code file.\n       */\n      public sourceSpan: AbsoluteSourceSpan) {}\n  visit(visitor: AstVisitor, context: any = null): any {\n    return null;\n  }\n  toString(): string {\n    return 'AST';\n  }\n}\n\nexport abstract class ASTWithName extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public prefix: string,\n      public uninterpretedExpression: string, public location: any) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitQuote(this, context);\n  }\n  toString(): string {\n    return 'Quote';\n  }\n}\n\nexport class EmptyExpr extends AST {\n  visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nexport class ThisReceiver extends ImplicitReceiver {\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public condition: AST, public trueExp: AST,\n      public falseExp: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string, public value: AST) {\n    super(span, sourceSpan, nameSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public obj: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public obj: AST, public key: AST,\n      public value: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public exp: AST, public name: string,\n      public args: any[], nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan, nameSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public value: any) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport type LiteralMapKey = {\n  key: string; quoted: boolean;\n};\n\nexport class LiteralMap extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public keys: LiteralMapKey[],\n      public values: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public strings: any[],\n      public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operation: string, public left: AST,\n      public right: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nexport class Unary extends Binary {\n  // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n  // depend on these fields when operating on `Unary`.\n  left: never;\n  right: never;\n  operation: never;\n\n  /**\n   * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n   */\n  static createMinus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n  }\n\n  /**\n   * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n   */\n  static createPlus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n  }\n\n  /**\n   * During the deprecation period this constructor is private, to avoid consumers from creating\n   * a `Unary` with the fallback properties for `Binary`.\n   */\n  private constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operator: string, public expr: AST,\n      binaryOp: string, binaryLeft: AST, binaryRight: AST) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n  }\n\n  visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class MethodCall extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string, public args: any[]) {\n    super(span, sourceSpan, nameSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitMethodCall(this, context);\n  }\n}\n\nexport class SafeMethodCall extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string, public args: any[]) {\n    super(span, sourceSpan, nameSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeMethodCall(this, context);\n  }\n}\n\nexport class FunctionCall extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public target: AST|null,\n      public args: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitFunctionCall(this, context);\n  }\n}\n\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nexport class AbsoluteSourceSpan {\n  constructor(public readonly start: number, public readonly end: number) {}\n}\n\nexport class ASTWithSource extends AST {\n  constructor(\n      public ast: AST, public source: string|null, public location: string, absoluteOffset: number,\n      public errors: ParserError[]) {\n    super(\n        new ParseSpan(0, source === null ? 0 : source.length),\n        new AbsoluteSourceSpan(\n            absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\n/**\n * TemplateBinding refers to a particular key-value pair in a microsyntax\n * expression. A few examples are:\n *\n *   |---------------------|--------------|---------|--------------|\n *   |     expression      |     key      |  value  | binding type |\n *   |---------------------|--------------|---------|--------------|\n *   | 1. let item         |    item      |  null   |   variable   |\n *   | 2. of items         |   ngForOf    |  items  |  expression  |\n *   | 3. let x = y        |      x       |    y    |   variable   |\n *   | 4. index as i       |      i       |  index  |   variable   |\n *   | 5. trackBy: func    | ngForTrackBy |   func  |  expression  |\n *   | 6. *ngIf=\"cond\"     |     ngIf     |   cond  |  expression  |\n *   |---------------------|--------------|---------|--------------|\n *\n * (6) is a notable exception because it is a binding from the template key in\n * the LHS of a HTML attribute to the expression in the RHS. All other bindings\n * in the example above are derived solely from the RHS.\n */\nexport type TemplateBinding = VariableBinding|ExpressionBinding;\n\nexport class VariableBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key name of the LHS along with its span.\n   * @param value optional value for the RHS along with its span.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier,\n      public readonly value: TemplateBindingIdentifier|null) {}\n}\n\nexport class ExpressionBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n   * span. Note that the length of the span may not be the same as\n   * `key.source.length`. For example,\n   * 1. key.source = ngFor, key.span is for \"ngFor\"\n   * 2. key.source = ngForOf, key.span is for \"of\"\n   * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n   * @param value optional expression for the RHS.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier, public readonly value: ASTWithSource|null) {}\n}\n\nexport interface TemplateBindingIdentifier {\n  source: string;\n  span: AbsoluteSourceSpan;\n}\n\nexport interface AstVisitor {\n  /**\n   * The `visitUnary` method is declared as optional for backwards compatibility. In an upcoming\n   * major release, this method will be made required.\n   */\n  visitUnary?(ast: Unary, context: any): any;\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  visitFunctionCall(ast: FunctionCall, context: any): any;\n  /**\n   * The `visitThisReceiver` method is declared as optional for backwards compatibility.\n   * In an upcoming major release, this method will be made required.\n   */\n  visitThisReceiver?(ast: ThisReceiver, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitMethodCall(ast: MethodCall, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitQuote(ast: Quote, context: any): any;\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visitASTWithSource?(ast: ASTWithSource, context: any): any;\n  /**\n   * This function is optionally defined to allow classes that implement this\n   * interface to selectively decide if the specified `ast` should be visited.\n   * @param ast node to visit\n   * @param context context that gets passed to the node and all its children\n   */\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visit(ast: AST, context?: any): any {\n    // The default implementation just visits every node.\n    // Classes that extend RecursiveAstVisitor should override this function\n    // to selectively visit the specified node.\n    ast.visit(this, context);\n  }\n  visitUnary(ast: Unary, context: any): any {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast: Binary, context: any): any {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast: Chain, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitFunctionCall(ast: FunctionCall, context: any): any {\n    if (ast.target) {\n      this.visit(ast.target, context);\n    }\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast: ThisReceiver, context: any): any {}\n  visitThisReceiver(ast: ThisReceiver, context: any): any {}\n  visitInterpolation(ast: Interpolation, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    this.visit(ast.obj, context);\n    this.visit(ast.key, context);\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    this.visit(ast.obj, context);\n    this.visit(ast.key, context);\n    this.visit(ast.value, context);\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n  visitMethodCall(ast: MethodCall, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.value, context);\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitQuote(ast: Quote, context: any): any {}\n  // This is not part of the AstVisitor interface, just a helper method\n  visitAll(asts: AST[], context: any): any {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n        ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): AST {\n    return new MethodCall(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n        this.visitAll(ast.args));\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n    return new SafeMethodCall(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n        this.visitAll(ast.args));\n  }\n\n  visitFunctionCall(ast: FunctionCall, context: any): AST {\n    return new FunctionCall(\n        ast.span, ast.sourceSpan, ast.target!.visit(this), this.visitAll(ast.args));\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    switch (ast.operator) {\n      case '+':\n        return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      case '-':\n        return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      default:\n        throw new Error(`Unknown unary operator ${ast.operator}`);\n    }\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(\n        ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(\n        ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this),\n        ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(\n        ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args),\n        ast.nameSpan);\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(\n        ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitQuote(ast: Quote, context: any): AST {\n    return new Quote(\n        ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\n  }\n}\n\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nexport class AstMemoryEfficientTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): Interpolation {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions)\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n    return ast;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return ast;\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const value = ast.value.visit(this);\n    if (receiver !== ast.receiver || value !== ast.value) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n    }\n    return ast;\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);\n    }\n    return ast;\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);\n    }\n    return ast;\n  }\n\n  visitFunctionCall(ast: FunctionCall, context: any): AST {\n    const target = ast.target && ast.target.visit(this);\n    const args = this.visitAll(ast.args);\n    if (target !== ast.target || args !== ast.args) {\n      return new FunctionCall(ast.span, ast.sourceSpan, target, args);\n    }\n    return ast;\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    const values = this.visitAll(ast.values);\n    if (values !== ast.values) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n    }\n    return ast;\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    const expr = ast.expr.visit(this);\n    if (expr !== ast.expr) {\n      switch (ast.operator) {\n        case '+':\n          return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n        case '-':\n          return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n        default:\n          throw new Error(`Unknown unary operator ${ast.operator}`);\n      }\n    }\n    return ast;\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    const left = ast.left.visit(this);\n    const right = ast.right.visit(this);\n    if (left !== ast.left || right !== ast.right) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n    }\n    return ast;\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new PrefixNot(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    const condition = ast.condition.visit(this);\n    const trueExp = ast.trueExp.visit(this);\n    const falseExp = ast.falseExp.visit(this);\n    if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n      return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n    }\n    return ast;\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    const exp = ast.exp.visit(this);\n    const args = this.visitAll(ast.args);\n    if (exp !== ast.exp || args !== ast.args) {\n      return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n    }\n    return ast;\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    const obj = ast.obj.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.obj || key !== ast.key) {\n      return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    const obj = ast.obj.visit(this);\n    const key = ast.key.visit(this);\n    const value = ast.value.visit(this);\n    if (obj !== ast.obj || key !== ast.key || value !== ast.value) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n    }\n    return ast;\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    let modified = false;\n    for (let i = 0; i < asts.length; ++i) {\n      const original = asts[i];\n      const value = original.visit(this);\n      res[i] = value;\n      modified = modified || value !== original;\n    }\n    return modified ? res : asts;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new Chain(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n  visitQuote(ast: Quote, context: any): AST {\n    return ast;\n  }\n}\n\n// Bindings\n\nexport class ParsedProperty {\n  public readonly isLiteral: boolean;\n  public readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public expression: ASTWithSource, public type: ParsedPropertyType,\n      // TODO(FW-2095): `keySpan` should really be required but allows `undefined` so VE does\n      // not need to be updated. Make `keySpan` required when VE is removed.\n      public sourceSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan|undefined,\n      public valueSpan: ParseSourceSpan|undefined) {\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\n\nexport enum ParsedPropertyType {\n  DEFAULT,\n  LITERAL_ATTR,\n  ANIMATION\n}\n\nexport const enum ParsedEventType {\n  // DOM or Directive event\n  Regular,\n  // Animation specific event\n  Animation,\n}\n\nexport class ParsedEvent {\n  // Regular events have a target\n  // Animation events have a phase\n  constructor(\n      public name: string, public targetOrPhase: string, public type: ParsedEventType,\n      public handler: ASTWithSource, public sourceSpan: ParseSourceSpan,\n      // TODO(FW-2095): keySpan should be required but was made optional to avoid changing VE\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan|undefined) {}\n}\n\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nexport class ParsedVariable {\n  constructor(\n      public readonly name: string, public readonly value: string,\n      public readonly sourceSpan: ParseSourceSpan, public readonly keySpan: ParseSourceSpan,\n      public readonly valueSpan?: ParseSourceSpan) {}\n}\n\nexport const enum BindingType {\n  // A regular binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n  Animation,\n}\n\nexport class BoundElementProperty {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: ASTWithSource, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined) {}\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}