{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar operators_1 = require(\"rxjs/operators\");\n\nvar json_1 = require(\"../../json\");\n\nvar api_1 = require(\"./api\");\n\nvar exception_1 = require(\"./exception\");\n\nvar JobArgumentSchemaValidationError = /*#__PURE__*/function (_json_1$schema$Schema) {\n  _inherits(JobArgumentSchemaValidationError, _json_1$schema$Schema);\n\n  var _super = _createSuper(JobArgumentSchemaValidationError);\n\n  function JobArgumentSchemaValidationError(errors) {\n    _classCallCheck(this, JobArgumentSchemaValidationError);\n\n    return _super.call(this, errors, 'Job Argument failed to validate. Errors: ');\n  }\n\n  return JobArgumentSchemaValidationError;\n}(json_1.schema.SchemaValidationException);\n\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\n\nvar JobInboundMessageSchemaValidationError = /*#__PURE__*/function (_json_1$schema$Schema2) {\n  _inherits(JobInboundMessageSchemaValidationError, _json_1$schema$Schema2);\n\n  var _super2 = _createSuper(JobInboundMessageSchemaValidationError);\n\n  function JobInboundMessageSchemaValidationError(errors) {\n    _classCallCheck(this, JobInboundMessageSchemaValidationError);\n\n    return _super2.call(this, errors, 'Job Inbound Message failed to validate. Errors: ');\n  }\n\n  return JobInboundMessageSchemaValidationError;\n}(json_1.schema.SchemaValidationException);\n\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\n\nvar JobOutputSchemaValidationError = /*#__PURE__*/function (_json_1$schema$Schema3) {\n  _inherits(JobOutputSchemaValidationError, _json_1$schema$Schema3);\n\n  var _super3 = _createSuper(JobOutputSchemaValidationError);\n\n  function JobOutputSchemaValidationError(errors) {\n    _classCallCheck(this, JobOutputSchemaValidationError);\n\n    return _super3.call(this, errors, 'Job Output failed to validate. Errors: ');\n  }\n\n  return JobOutputSchemaValidationError;\n}(json_1.schema.SchemaValidationException);\n\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\n\nfunction _jobShare() {\n  // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n  // ReplaySubject.\n  return function (source) {\n    var refCount = 0;\n    var subject;\n    var hasError = false;\n    var isComplete = false;\n    var subscription;\n    return new rxjs_1.Observable(function (subscriber) {\n      var innerSub;\n      refCount++;\n\n      if (!subject) {\n        subject = new rxjs_1.Subject();\n        innerSub = subject.subscribe(subscriber);\n        subscription = source.subscribe({\n          next: function next(value) {\n            subject.next(value);\n          },\n          error: function error(err) {\n            hasError = true;\n            subject.error(err);\n          },\n          complete: function complete() {\n            isComplete = true;\n            subject.complete();\n          }\n        });\n      } else {\n        innerSub = subject.subscribe(subscriber);\n      }\n\n      return function () {\n        refCount--;\n        innerSub.unsubscribe();\n\n        if (subscription && refCount === 0 && (isComplete || hasError)) {\n          subscription.unsubscribe();\n        }\n      };\n    });\n  };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\n\n\nvar SimpleScheduler = /*#__PURE__*/function () {\n  function SimpleScheduler(_jobRegistry) {\n    var _schemaRegistry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new json_1.schema.CoreSchemaRegistry();\n\n    _classCallCheck(this, SimpleScheduler);\n\n    this._jobRegistry = _jobRegistry;\n    this._schemaRegistry = _schemaRegistry;\n    this._internalJobDescriptionMap = new Map();\n    this._queue = [];\n    this._pauseCounter = 0;\n  }\n\n  _createClass(SimpleScheduler, [{\n    key: \"_getInternalDescription\",\n    value: function _getInternalDescription(name) {\n      var _this = this;\n\n      var maybeHandler = this._internalJobDescriptionMap.get(name);\n\n      if (maybeHandler !== undefined) {\n        return rxjs_1.of(maybeHandler);\n      }\n\n      var handler = this._jobRegistry.get(name);\n\n      return handler.pipe(operators_1.switchMap(function (handler) {\n        if (handler === null) {\n          return rxjs_1.of(null);\n        }\n\n        var description = _objectSpread(_objectSpread({}, JSON.parse(JSON.stringify(handler.jobDescription))), {}, {\n          name: handler.jobDescription.name || name,\n          argument: handler.jobDescription.argument || true,\n          input: handler.jobDescription.input || true,\n          output: handler.jobDescription.output || true,\n          channels: handler.jobDescription.channels || {}\n        });\n\n        var handlerWithExtra = Object.assign(handler.bind(undefined), {\n          jobDescription: description,\n          argumentV: _this._schemaRegistry.compile(description.argument).pipe(operators_1.shareReplay(1)),\n          inputV: _this._schemaRegistry.compile(description.input).pipe(operators_1.shareReplay(1)),\n          outputV: _this._schemaRegistry.compile(description.output).pipe(operators_1.shareReplay(1))\n        });\n\n        _this._internalJobDescriptionMap.set(name, handlerWithExtra);\n\n        return rxjs_1.of(handlerWithExtra);\n      }));\n    }\n    /**\n     * Get a job description for a named job.\n     *\n     * @param name The name of the job.\n     * @returns A description, or null if the job is not registered.\n     */\n\n  }, {\n    key: \"getDescription\",\n    value: function getDescription(name) {\n      return rxjs_1.concat(this._getInternalDescription(name).pipe(operators_1.map(function (x) {\n        return x && x.jobDescription;\n      })), rxjs_1.of(null)).pipe(operators_1.first());\n    }\n    /**\n     * Returns true if the job name has been registered.\n     * @param name The name of the job.\n     * @returns True if the job exists, false otherwise.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(name) {\n      return this.getDescription(name).pipe(operators_1.map(function (x) {\n        return x !== null;\n      }));\n    }\n    /**\n     * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n     * used to resume execution. If multiple `pause()` were called, all their resume functions must\n     * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n     * function will have no effect.\n     *\n     * Jobs already running are NOT paused. This is pausing the scheduler only.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var _this2 = this;\n\n      var called = false;\n      this._pauseCounter++;\n      return function () {\n        if (!called) {\n          called = true;\n\n          if (--_this2._pauseCounter == 0) {\n            // Resume the queue.\n            var q = _this2._queue;\n            _this2._queue = [];\n            q.forEach(function (fn) {\n              return fn();\n            });\n          }\n        }\n      };\n    }\n    /**\n     * Schedule a job to be run, using its name.\n     * @param name The name of job to be run.\n     * @param argument The argument to send to the job when starting it.\n     * @param options Scheduling options.\n     * @returns The Job being run.\n     */\n\n  }, {\n    key: \"schedule\",\n    value: function schedule(name, argument, options) {\n      if (this._pauseCounter > 0) {\n        var waitable = new rxjs_1.Subject();\n\n        this._queue.push(function () {\n          return waitable.complete();\n        });\n\n        return this._scheduleJob(name, argument, options || {}, waitable);\n      }\n\n      return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n    }\n    /**\n     * Filter messages.\n     * @private\n     */\n\n  }, {\n    key: \"_filterJobOutboundMessages\",\n    value: function _filterJobOutboundMessages(message, state) {\n      switch (message.kind) {\n        case api_1.JobOutboundMessageKind.OnReady:\n          return state == api_1.JobState.Queued;\n\n        case api_1.JobOutboundMessageKind.Start:\n          return state == api_1.JobState.Ready;\n\n        case api_1.JobOutboundMessageKind.End:\n          return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n      }\n\n      return true;\n    }\n    /**\n     * Return a new state. This is just to simplify the reading of the _createJob method.\n     * @private\n     */\n\n  }, {\n    key: \"_updateState\",\n    value: function _updateState(message, state) {\n      switch (message.kind) {\n        case api_1.JobOutboundMessageKind.OnReady:\n          return api_1.JobState.Ready;\n\n        case api_1.JobOutboundMessageKind.Start:\n          return api_1.JobState.Started;\n\n        case api_1.JobOutboundMessageKind.End:\n          return api_1.JobState.Ended;\n      }\n\n      return state;\n    }\n    /**\n     * Create the job.\n     * @private\n     */\n\n  }, {\n    key: \"_createJob\",\n    value: function _createJob(name, argument, handler, inboundBus, outboundBus) {\n      var _this3 = this;\n\n      var schemaRegistry = this._schemaRegistry;\n      var channelsSubject = new Map();\n      var channels = new Map();\n      var state = api_1.JobState.Queued;\n      var pingId = 0; // Create the input channel by having a filter.\n\n      var input = new rxjs_1.Subject();\n      input.pipe(operators_1.switchMap(function (message) {\n        return handler.pipe(operators_1.switchMap(function (handler) {\n          if (handler === null) {\n            throw new exception_1.JobDoesNotExistException(name);\n          } else {\n            return handler.inputV.pipe(operators_1.switchMap(function (validate) {\n              return validate(message);\n            }));\n          }\n        }));\n      }), operators_1.filter(function (result) {\n        return result.success;\n      }), operators_1.map(function (result) {\n        return result.data;\n      })).subscribe(function (value) {\n        return inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Input,\n          value: value\n        });\n      });\n      outboundBus = rxjs_1.concat(outboundBus, // Add an End message at completion. This will be filtered out if the job actually send an\n      // End.\n      handler.pipe(operators_1.switchMap(function (handler) {\n        if (handler) {\n          return rxjs_1.of({\n            kind: api_1.JobOutboundMessageKind.End,\n            description: handler.jobDescription\n          });\n        } else {\n          return rxjs_1.EMPTY;\n        }\n      }))).pipe(operators_1.filter(function (message) {\n        return _this3._filterJobOutboundMessages(message, state);\n      }), // Update internal logic and Job<> members.\n      operators_1.tap(function (message) {\n        // Update the state.\n        state = _this3._updateState(message, state);\n\n        switch (message.kind) {\n          case api_1.JobOutboundMessageKind.ChannelCreate:\n            {\n              var maybeSubject = channelsSubject.get(message.name); // If it doesn't exist or it's closed on the other end.\n\n              if (!maybeSubject) {\n                var s = new rxjs_1.Subject();\n                channelsSubject.set(message.name, s);\n                channels.set(message.name, s.asObservable());\n              }\n\n              break;\n            }\n\n          case api_1.JobOutboundMessageKind.ChannelMessage:\n            {\n              var _maybeSubject = channelsSubject.get(message.name);\n\n              if (_maybeSubject) {\n                _maybeSubject.next(message.message);\n              }\n\n              break;\n            }\n\n          case api_1.JobOutboundMessageKind.ChannelComplete:\n            {\n              var _maybeSubject2 = channelsSubject.get(message.name);\n\n              if (_maybeSubject2) {\n                _maybeSubject2.complete();\n\n                channelsSubject.delete(message.name);\n              }\n\n              break;\n            }\n\n          case api_1.JobOutboundMessageKind.ChannelError:\n            {\n              var _maybeSubject3 = channelsSubject.get(message.name);\n\n              if (_maybeSubject3) {\n                _maybeSubject3.error(message.error);\n\n                channelsSubject.delete(message.name);\n              }\n\n              break;\n            }\n        }\n      }, function () {\n        state = api_1.JobState.Errored;\n      }), // Do output validation (might include default values so this might have side\n      // effects). We keep all messages in order.\n      operators_1.concatMap(function (message) {\n        if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n          return rxjs_1.of(message);\n        }\n\n        return handler.pipe(operators_1.switchMap(function (handler) {\n          if (handler === null) {\n            throw new exception_1.JobDoesNotExistException(name);\n          } else {\n            return handler.outputV.pipe(operators_1.switchMap(function (validate) {\n              return validate(message.value);\n            }), operators_1.switchMap(function (output) {\n              if (!output.success) {\n                throw new JobOutputSchemaValidationError(output.errors);\n              }\n\n              return rxjs_1.of(_objectSpread(_objectSpread({}, message), {}, {\n                output: output.data\n              }));\n            }));\n          }\n        }));\n      }), _jobShare());\n      var output = outboundBus.pipe(operators_1.filter(function (x) {\n        return x.kind == api_1.JobOutboundMessageKind.Output;\n      }), operators_1.map(function (x) {\n        return x.value;\n      }), operators_1.shareReplay(1)); // Return the Job.\n\n      return {\n        get state() {\n          return state;\n        },\n\n        argument: argument,\n        description: handler.pipe(operators_1.switchMap(function (handler) {\n          if (handler === null) {\n            throw new exception_1.JobDoesNotExistException(name);\n          } else {\n            return rxjs_1.of(handler.jobDescription);\n          }\n        })),\n        output: output,\n        getChannel: function getChannel(name) {\n          var schema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var maybeObservable = channels.get(name);\n\n          if (!maybeObservable) {\n            var s = new rxjs_1.Subject();\n            channelsSubject.set(name, s);\n            channels.set(name, s.asObservable());\n            maybeObservable = s.asObservable();\n          }\n\n          return maybeObservable.pipe( // Keep the order of messages.\n          operators_1.concatMap(function (message) {\n            return schemaRegistry.compile(schema).pipe(operators_1.switchMap(function (validate) {\n              return validate(message);\n            }), operators_1.filter(function (x) {\n              return x.success;\n            }), operators_1.map(function (x) {\n              return x.data;\n            }));\n          }));\n        },\n        ping: function ping() {\n          var id = pingId++;\n          inboundBus.next({\n            kind: api_1.JobInboundMessageKind.Ping,\n            id: id\n          });\n          return outboundBus.pipe(operators_1.filter(function (x) {\n            return x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id;\n          }), operators_1.first(), operators_1.ignoreElements());\n        },\n        stop: function stop() {\n          inboundBus.next({\n            kind: api_1.JobInboundMessageKind.Stop\n          });\n        },\n        input: input,\n        inboundBus: inboundBus,\n        outboundBus: outboundBus\n      };\n    }\n  }, {\n    key: \"_scheduleJob\",\n    value: function _scheduleJob(name, argument, options, waitable) {\n      var _this4 = this;\n\n      // Get handler first, since this can error out if there's no handler for the job name.\n      var handler = this._getInternalDescription(name);\n\n      var optionsDeps = options && options.dependencies || [];\n      var dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n      var inboundBus = new rxjs_1.Subject();\n      var outboundBus = rxjs_1.concat( // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n      // all dependencies at the same time so they run concurrently.\n      rxjs_1.merge.apply(rxjs_1, _toConsumableArray(dependencies.map(function (x) {\n        return x.outboundBus;\n      }))).pipe(operators_1.ignoreElements()), // Wait for pause() to clear (if necessary).\n      waitable, rxjs_1.from(handler).pipe(operators_1.switchMap(function (handler) {\n        return new rxjs_1.Observable(function (subscriber) {\n          if (!handler) {\n            throw new exception_1.JobDoesNotExistException(name);\n          } // Validate the argument.\n\n\n          return handler.argumentV.pipe(operators_1.switchMap(function (validate) {\n            return validate(argument);\n          }), operators_1.switchMap(function (output) {\n            if (!output.success) {\n              throw new JobArgumentSchemaValidationError(output.errors);\n            }\n\n            var argument = output.data;\n            var description = handler.jobDescription;\n            subscriber.next({\n              kind: api_1.JobOutboundMessageKind.OnReady,\n              description: description\n            });\n            var context = {\n              description: description,\n              dependencies: _toConsumableArray(dependencies),\n              inboundBus: inboundBus.asObservable(),\n              scheduler: _this4\n            };\n            return handler(argument, context);\n          })).subscribe(subscriber);\n        });\n      })));\n      return this._createJob(name, argument, handler, inboundBus, outboundBus);\n    }\n  }]);\n\n  return SimpleScheduler;\n}();\n\nexports.SimpleScheduler = SimpleScheduler;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/experimental/jobs/simple-scheduler.js"],"names":["Object","defineProperty","exports","value","SimpleScheduler","JobOutputSchemaValidationError","JobInboundMessageSchemaValidationError","JobArgumentSchemaValidationError","rxjs_1","require","operators_1","json_1","api_1","exception_1","errors","schema","SchemaValidationException","_jobShare","source","refCount","subject","hasError","isComplete","subscription","Observable","subscriber","innerSub","Subject","subscribe","next","error","err","complete","unsubscribe","_jobRegistry","_schemaRegistry","CoreSchemaRegistry","_internalJobDescriptionMap","Map","_queue","_pauseCounter","name","maybeHandler","get","undefined","of","handler","pipe","switchMap","description","JSON","parse","stringify","jobDescription","argument","input","output","channels","handlerWithExtra","assign","bind","argumentV","compile","shareReplay","inputV","outputV","set","concat","_getInternalDescription","map","x","first","getDescription","called","q","forEach","fn","options","waitable","push","_scheduleJob","EMPTY","message","state","kind","JobOutboundMessageKind","OnReady","JobState","Queued","Start","Ready","End","Started","Ended","inboundBus","outboundBus","schemaRegistry","channelsSubject","pingId","JobDoesNotExistException","validate","filter","result","success","data","JobInboundMessageKind","Input","_filterJobOutboundMessages","tap","_updateState","ChannelCreate","maybeSubject","s","asObservable","ChannelMessage","ChannelComplete","delete","ChannelError","Errored","concatMap","Output","getChannel","maybeObservable","ping","id","Ping","Pong","ignoreElements","stop","Stop","optionsDeps","dependencies","Array","isArray","merge","from","context","scheduler","_createJob"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst rxjs_1 = require(\"rxjs\");\nconst operators_1 = require(\"rxjs/operators\");\nconst json_1 = require(\"../../json\");\nconst api_1 = require(\"./api\");\nconst exception_1 = require(\"./exception\");\nclass JobArgumentSchemaValidationError extends json_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Argument failed to validate. Errors: ');\n    }\n}\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\nclass JobInboundMessageSchemaValidationError extends json_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Inbound Message failed to validate. Errors: ');\n    }\n}\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\nclass JobOutputSchemaValidationError extends json_1.schema.SchemaValidationException {\n    constructor(errors) {\n        super(errors, 'Job Output failed to validate. Errors: ');\n    }\n}\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\nfunction _jobShare() {\n    // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n    // ReplaySubject.\n    return (source) => {\n        let refCount = 0;\n        let subject;\n        let hasError = false;\n        let isComplete = false;\n        let subscription;\n        return new rxjs_1.Observable(subscriber => {\n            let innerSub;\n            refCount++;\n            if (!subject) {\n                subject = new rxjs_1.Subject();\n                innerSub = subject.subscribe(subscriber);\n                subscription = source.subscribe({\n                    next(value) { subject.next(value); },\n                    error(err) {\n                        hasError = true;\n                        subject.error(err);\n                    },\n                    complete() {\n                        isComplete = true;\n                        subject.complete();\n                    },\n                });\n            }\n            else {\n                innerSub = subject.subscribe(subscriber);\n            }\n            return () => {\n                refCount--;\n                innerSub.unsubscribe();\n                if (subscription && refCount === 0 && (isComplete || hasError)) {\n                    subscription.unsubscribe();\n                }\n            };\n        });\n    };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\nclass SimpleScheduler {\n    constructor(_jobRegistry, _schemaRegistry = new json_1.schema.CoreSchemaRegistry()) {\n        this._jobRegistry = _jobRegistry;\n        this._schemaRegistry = _schemaRegistry;\n        this._internalJobDescriptionMap = new Map();\n        this._queue = [];\n        this._pauseCounter = 0;\n    }\n    _getInternalDescription(name) {\n        const maybeHandler = this._internalJobDescriptionMap.get(name);\n        if (maybeHandler !== undefined) {\n            return rxjs_1.of(maybeHandler);\n        }\n        const handler = this._jobRegistry.get(name);\n        return handler.pipe(operators_1.switchMap(handler => {\n            if (handler === null) {\n                return rxjs_1.of(null);\n            }\n            const description = {\n                // Make a copy of it to be sure it's proper JSON.\n                ...JSON.parse(JSON.stringify(handler.jobDescription)),\n                name: handler.jobDescription.name || name,\n                argument: handler.jobDescription.argument || true,\n                input: handler.jobDescription.input || true,\n                output: handler.jobDescription.output || true,\n                channels: handler.jobDescription.channels || {},\n            };\n            const handlerWithExtra = Object.assign(handler.bind(undefined), {\n                jobDescription: description,\n                argumentV: this._schemaRegistry.compile(description.argument).pipe(operators_1.shareReplay(1)),\n                inputV: this._schemaRegistry.compile(description.input).pipe(operators_1.shareReplay(1)),\n                outputV: this._schemaRegistry.compile(description.output).pipe(operators_1.shareReplay(1)),\n            });\n            this._internalJobDescriptionMap.set(name, handlerWithExtra);\n            return rxjs_1.of(handlerWithExtra);\n        }));\n    }\n    /**\n     * Get a job description for a named job.\n     *\n     * @param name The name of the job.\n     * @returns A description, or null if the job is not registered.\n     */\n    getDescription(name) {\n        return rxjs_1.concat(this._getInternalDescription(name).pipe(operators_1.map(x => x && x.jobDescription)), rxjs_1.of(null)).pipe(operators_1.first());\n    }\n    /**\n     * Returns true if the job name has been registered.\n     * @param name The name of the job.\n     * @returns True if the job exists, false otherwise.\n     */\n    has(name) {\n        return this.getDescription(name).pipe(operators_1.map(x => x !== null));\n    }\n    /**\n     * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n     * used to resume execution. If multiple `pause()` were called, all their resume functions must\n     * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n     * function will have no effect.\n     *\n     * Jobs already running are NOT paused. This is pausing the scheduler only.\n     */\n    pause() {\n        let called = false;\n        this._pauseCounter++;\n        return () => {\n            if (!called) {\n                called = true;\n                if (--this._pauseCounter == 0) {\n                    // Resume the queue.\n                    const q = this._queue;\n                    this._queue = [];\n                    q.forEach(fn => fn());\n                }\n            }\n        };\n    }\n    /**\n     * Schedule a job to be run, using its name.\n     * @param name The name of job to be run.\n     * @param argument The argument to send to the job when starting it.\n     * @param options Scheduling options.\n     * @returns The Job being run.\n     */\n    schedule(name, argument, options) {\n        if (this._pauseCounter > 0) {\n            const waitable = new rxjs_1.Subject();\n            this._queue.push(() => waitable.complete());\n            return this._scheduleJob(name, argument, options || {}, waitable);\n        }\n        return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n    }\n    /**\n     * Filter messages.\n     * @private\n     */\n    _filterJobOutboundMessages(message, state) {\n        switch (message.kind) {\n            case api_1.JobOutboundMessageKind.OnReady:\n                return state == api_1.JobState.Queued;\n            case api_1.JobOutboundMessageKind.Start:\n                return state == api_1.JobState.Ready;\n            case api_1.JobOutboundMessageKind.End:\n                return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n        }\n        return true;\n    }\n    /**\n     * Return a new state. This is just to simplify the reading of the _createJob method.\n     * @private\n     */\n    _updateState(message, state) {\n        switch (message.kind) {\n            case api_1.JobOutboundMessageKind.OnReady:\n                return api_1.JobState.Ready;\n            case api_1.JobOutboundMessageKind.Start:\n                return api_1.JobState.Started;\n            case api_1.JobOutboundMessageKind.End:\n                return api_1.JobState.Ended;\n        }\n        return state;\n    }\n    /**\n     * Create the job.\n     * @private\n     */\n    _createJob(name, argument, handler, inboundBus, outboundBus) {\n        const schemaRegistry = this._schemaRegistry;\n        const channelsSubject = new Map();\n        const channels = new Map();\n        let state = api_1.JobState.Queued;\n        let pingId = 0;\n        // Create the input channel by having a filter.\n        const input = new rxjs_1.Subject();\n        input.pipe(operators_1.switchMap(message => handler.pipe(operators_1.switchMap(handler => {\n            if (handler === null) {\n                throw new exception_1.JobDoesNotExistException(name);\n            }\n            else {\n                return handler.inputV.pipe(operators_1.switchMap(validate => validate(message)));\n            }\n        }))), operators_1.filter(result => result.success), operators_1.map(result => result.data)).subscribe(value => inboundBus.next({ kind: api_1.JobInboundMessageKind.Input, value }));\n        outboundBus = rxjs_1.concat(outboundBus, \n        // Add an End message at completion. This will be filtered out if the job actually send an\n        // End.\n        handler.pipe(operators_1.switchMap(handler => {\n            if (handler) {\n                return rxjs_1.of({\n                    kind: api_1.JobOutboundMessageKind.End, description: handler.jobDescription,\n                });\n            }\n            else {\n                return rxjs_1.EMPTY;\n            }\n        }))).pipe(operators_1.filter(message => this._filterJobOutboundMessages(message, state)), \n        // Update internal logic and Job<> members.\n        operators_1.tap(message => {\n            // Update the state.\n            state = this._updateState(message, state);\n            switch (message.kind) {\n                case api_1.JobOutboundMessageKind.ChannelCreate: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    // If it doesn't exist or it's closed on the other end.\n                    if (!maybeSubject) {\n                        const s = new rxjs_1.Subject();\n                        channelsSubject.set(message.name, s);\n                        channels.set(message.name, s.asObservable());\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelMessage: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.next(message.message);\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelComplete: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.complete();\n                        channelsSubject.delete(message.name);\n                    }\n                    break;\n                }\n                case api_1.JobOutboundMessageKind.ChannelError: {\n                    const maybeSubject = channelsSubject.get(message.name);\n                    if (maybeSubject) {\n                        maybeSubject.error(message.error);\n                        channelsSubject.delete(message.name);\n                    }\n                    break;\n                }\n            }\n        }, () => {\n            state = api_1.JobState.Errored;\n        }), \n        // Do output validation (might include default values so this might have side\n        // effects). We keep all messages in order.\n        operators_1.concatMap(message => {\n            if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n                return rxjs_1.of(message);\n            }\n            return handler.pipe(operators_1.switchMap(handler => {\n                if (handler === null) {\n                    throw new exception_1.JobDoesNotExistException(name);\n                }\n                else {\n                    return handler.outputV.pipe(operators_1.switchMap(validate => validate(message.value)), operators_1.switchMap(output => {\n                        if (!output.success) {\n                            throw new JobOutputSchemaValidationError(output.errors);\n                        }\n                        return rxjs_1.of({\n                            ...message,\n                            output: output.data,\n                        });\n                    }));\n                }\n            }));\n        }), _jobShare());\n        const output = outboundBus.pipe(operators_1.filter(x => x.kind == api_1.JobOutboundMessageKind.Output), operators_1.map((x) => x.value), operators_1.shareReplay(1));\n        // Return the Job.\n        return {\n            get state() { return state; },\n            argument,\n            description: handler.pipe(operators_1.switchMap(handler => {\n                if (handler === null) {\n                    throw new exception_1.JobDoesNotExistException(name);\n                }\n                else {\n                    return rxjs_1.of(handler.jobDescription);\n                }\n            })),\n            output,\n            getChannel(name, schema = true) {\n                let maybeObservable = channels.get(name);\n                if (!maybeObservable) {\n                    const s = new rxjs_1.Subject();\n                    channelsSubject.set(name, s);\n                    channels.set(name, s.asObservable());\n                    maybeObservable = s.asObservable();\n                }\n                return maybeObservable.pipe(\n                // Keep the order of messages.\n                operators_1.concatMap(message => {\n                    return schemaRegistry.compile(schema).pipe(operators_1.switchMap(validate => validate(message)), operators_1.filter(x => x.success), operators_1.map(x => x.data));\n                }));\n            },\n            ping() {\n                const id = pingId++;\n                inboundBus.next({ kind: api_1.JobInboundMessageKind.Ping, id });\n                return outboundBus.pipe(operators_1.filter(x => x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id), operators_1.first(), operators_1.ignoreElements());\n            },\n            stop() {\n                inboundBus.next({ kind: api_1.JobInboundMessageKind.Stop });\n            },\n            input,\n            inboundBus,\n            outboundBus,\n        };\n    }\n    _scheduleJob(name, argument, options, waitable) {\n        // Get handler first, since this can error out if there's no handler for the job name.\n        const handler = this._getInternalDescription(name);\n        const optionsDeps = (options && options.dependencies) || [];\n        const dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n        const inboundBus = new rxjs_1.Subject();\n        const outboundBus = rxjs_1.concat(\n        // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n        // all dependencies at the same time so they run concurrently.\n        rxjs_1.merge(...dependencies.map(x => x.outboundBus)).pipe(operators_1.ignoreElements()), \n        // Wait for pause() to clear (if necessary).\n        waitable, rxjs_1.from(handler).pipe(operators_1.switchMap(handler => new rxjs_1.Observable((subscriber) => {\n            if (!handler) {\n                throw new exception_1.JobDoesNotExistException(name);\n            }\n            // Validate the argument.\n            return handler.argumentV.pipe(operators_1.switchMap(validate => validate(argument)), operators_1.switchMap(output => {\n                if (!output.success) {\n                    throw new JobArgumentSchemaValidationError(output.errors);\n                }\n                const argument = output.data;\n                const description = handler.jobDescription;\n                subscriber.next({ kind: api_1.JobOutboundMessageKind.OnReady, description });\n                const context = {\n                    description,\n                    dependencies: [...dependencies],\n                    inboundBus: inboundBus.asObservable(),\n                    scheduler: this,\n                };\n                return handler(argument, context);\n            })).subscribe(subscriber);\n        }))));\n        return this._createJob(name, argument, handler, inboundBus, outboundBus);\n    }\n}\nexports.SimpleScheduler = SimpleScheduler;\n"]},"metadata":{},"sourceType":"script"}