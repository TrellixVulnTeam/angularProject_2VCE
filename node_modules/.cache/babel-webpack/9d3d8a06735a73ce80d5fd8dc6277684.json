{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _TOKEN_EMISSION_HELPE2;\n\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nvar Tokenizer = require('parse5/lib/tokenizer');\n\nvar LocationInfoTokenizerMixin = require('parse5/lib/extensions/location-info/tokenizer-mixin');\n\nvar Mixin = require('parse5/lib/utils/mixin');\n\nvar mergeOptions = require('parse5/lib/utils/merge-options');\n\nvar DevNullStream = require('./dev-null-stream');\n\nvar ParserFeedbackSimulator = require('./parser-feedback-simulator');\n\nvar DEFAULT_OPTIONS = {\n  sourceCodeLocationInfo: false\n};\n\nvar SAXParser = /*#__PURE__*/function (_Transform) {\n  _inherits(SAXParser, _Transform);\n\n  var _super = _createSuper(SAXParser);\n\n  function SAXParser(options) {\n    var _this;\n\n    _classCallCheck(this, SAXParser);\n\n    _this = _super.call(this, {\n      encoding: 'utf8',\n      decodeStrings: false\n    });\n    _this.options = mergeOptions(DEFAULT_OPTIONS, options);\n    _this.tokenizer = new Tokenizer(options);\n    _this.locInfoMixin = null;\n\n    if (_this.options.sourceCodeLocationInfo) {\n      _this.locInfoMixin = Mixin.install(_this.tokenizer, LocationInfoTokenizerMixin);\n    }\n\n    _this.parserFeedbackSimulator = new ParserFeedbackSimulator(_this.tokenizer);\n    _this.pendingText = null;\n    _this.lastChunkWritten = false;\n    _this.stopped = false; // NOTE: always pipe stream to the /dev/null stream to avoid\n    // `highWaterMark` hit even if we don't have consumers.\n    // (see: https://github.com/inikulin/parse5/issues/97#issuecomment-171940774)\n\n    _this.pipe(new DevNullStream());\n\n    return _this;\n  } //TransformStream implementation\n\n\n  _createClass(SAXParser, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      if (typeof chunk !== 'string') {\n        throw new TypeError('Parser can work only with string streams.');\n      }\n\n      callback(null, this._transformChunk(chunk));\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(callback) {\n      this.lastChunkWritten = true;\n      callback(null, this._transformChunk(''));\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.stopped = true;\n    } //Internals\n\n  }, {\n    key: \"_transformChunk\",\n    value: function _transformChunk(chunk) {\n      if (!this.stopped) {\n        this.tokenizer.write(chunk, this.lastChunkWritten);\n\n        this._runParsingLoop();\n      }\n\n      return chunk;\n    }\n  }, {\n    key: \"_runParsingLoop\",\n    value: function _runParsingLoop() {\n      var token = null;\n\n      do {\n        token = this.parserFeedbackSimulator.getNextToken();\n\n        if (token.type === Tokenizer.HIBERNATION_TOKEN) {\n          break;\n        }\n\n        if (token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN) {\n          if (this.pendingText === null) {\n            token.type = Tokenizer.CHARACTER_TOKEN;\n            this.pendingText = token;\n          } else {\n            this.pendingText.chars += token.chars;\n\n            if (this.options.sourceCodeLocationInfo) {\n              var _token$location = token.location,\n                  endLine = _token$location.endLine,\n                  endCol = _token$location.endCol,\n                  endOffset = _token$location.endOffset;\n              Object.assign(this.pendingText.location, {\n                endLine: endLine,\n                endCol: endCol,\n                endOffset: endOffset\n              });\n            }\n          }\n        } else {\n          this._emitPendingText();\n\n          this._handleToken(token);\n        }\n      } while (!this.stopped && token.type !== Tokenizer.EOF_TOKEN);\n    }\n  }, {\n    key: \"_handleToken\",\n    value: function _handleToken(token) {\n      if (token.type === Tokenizer.EOF_TOKEN) {\n        return true;\n      }\n\n      var _TOKEN_EMISSION_HELPE = TOKEN_EMISSION_HELPERS[token.type],\n          eventName = _TOKEN_EMISSION_HELPE.eventName,\n          reshapeToken = _TOKEN_EMISSION_HELPE.reshapeToken;\n\n      if (this.listenerCount(eventName) === 0) {\n        return false;\n      }\n\n      this._emitToken(eventName, reshapeToken(token));\n\n      return true;\n    }\n  }, {\n    key: \"_emitToken\",\n    value: function _emitToken(eventName, token) {\n      this.emit(eventName, token);\n    }\n  }, {\n    key: \"_emitPendingText\",\n    value: function _emitPendingText() {\n      if (this.pendingText !== null) {\n        this._handleToken(this.pendingText);\n\n        this.pendingText = null;\n      }\n    }\n  }]);\n\n  return SAXParser;\n}(Transform);\n\nvar TOKEN_EMISSION_HELPERS = (_TOKEN_EMISSION_HELPE2 = {}, _defineProperty(_TOKEN_EMISSION_HELPE2, Tokenizer.START_TAG_TOKEN, {\n  eventName: 'startTag',\n  reshapeToken: function reshapeToken(origToken) {\n    return {\n      tagName: origToken.tagName,\n      attrs: origToken.attrs,\n      selfClosing: origToken.selfClosing,\n      sourceCodeLocation: origToken.location\n    };\n  }\n}), _defineProperty(_TOKEN_EMISSION_HELPE2, Tokenizer.END_TAG_TOKEN, {\n  eventName: 'endTag',\n  reshapeToken: function reshapeToken(origToken) {\n    return {\n      tagName: origToken.tagName,\n      sourceCodeLocation: origToken.location\n    };\n  }\n}), _defineProperty(_TOKEN_EMISSION_HELPE2, Tokenizer.COMMENT_TOKEN, {\n  eventName: 'comment',\n  reshapeToken: function reshapeToken(origToken) {\n    return {\n      text: origToken.data,\n      sourceCodeLocation: origToken.location\n    };\n  }\n}), _defineProperty(_TOKEN_EMISSION_HELPE2, Tokenizer.DOCTYPE_TOKEN, {\n  eventName: 'doctype',\n  reshapeToken: function reshapeToken(origToken) {\n    return {\n      name: origToken.name,\n      publicId: origToken.publicId,\n      systemId: origToken.systemId,\n      sourceCodeLocation: origToken.location\n    };\n  }\n}), _defineProperty(_TOKEN_EMISSION_HELPE2, Tokenizer.CHARACTER_TOKEN, {\n  eventName: 'text',\n  reshapeToken: function reshapeToken(origToken) {\n    return {\n      text: origToken.chars,\n      sourceCodeLocation: origToken.location\n    };\n  }\n}), _TOKEN_EMISSION_HELPE2);\nmodule.exports = SAXParser;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/parse5-sax-parser/lib/index.js"],"names":["require","Transform","Tokenizer","LocationInfoTokenizerMixin","Mixin","mergeOptions","DevNullStream","ParserFeedbackSimulator","DEFAULT_OPTIONS","sourceCodeLocationInfo","SAXParser","options","encoding","decodeStrings","tokenizer","locInfoMixin","install","parserFeedbackSimulator","pendingText","lastChunkWritten","stopped","pipe","chunk","callback","TypeError","_transformChunk","write","_runParsingLoop","token","getNextToken","type","HIBERNATION_TOKEN","CHARACTER_TOKEN","WHITESPACE_CHARACTER_TOKEN","NULL_CHARACTER_TOKEN","chars","location","endLine","endCol","endOffset","Object","assign","_emitPendingText","_handleToken","EOF_TOKEN","TOKEN_EMISSION_HELPERS","eventName","reshapeToken","listenerCount","_emitToken","emit","START_TAG_TOKEN","origToken","tagName","attrs","selfClosing","sourceCodeLocation","END_TAG_TOKEN","COMMENT_TOKEN","text","data","DOCTYPE_TOKEN","name","publicId","systemId","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst { Transform } = require('stream');\nconst Tokenizer = require('parse5/lib/tokenizer');\nconst LocationInfoTokenizerMixin = require('parse5/lib/extensions/location-info/tokenizer-mixin');\nconst Mixin = require('parse5/lib/utils/mixin');\nconst mergeOptions = require('parse5/lib/utils/merge-options');\nconst DevNullStream = require('./dev-null-stream');\nconst ParserFeedbackSimulator = require('./parser-feedback-simulator');\n\nconst DEFAULT_OPTIONS = {\n    sourceCodeLocationInfo: false\n};\n\nclass SAXParser extends Transform {\n    constructor(options) {\n        super({ encoding: 'utf8', decodeStrings: false });\n\n        this.options = mergeOptions(DEFAULT_OPTIONS, options);\n\n        this.tokenizer = new Tokenizer(options);\n        this.locInfoMixin = null;\n\n        if (this.options.sourceCodeLocationInfo) {\n            this.locInfoMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n        }\n\n        this.parserFeedbackSimulator = new ParserFeedbackSimulator(this.tokenizer);\n\n        this.pendingText = null;\n\n        this.lastChunkWritten = false;\n        this.stopped = false;\n\n        // NOTE: always pipe stream to the /dev/null stream to avoid\n        // `highWaterMark` hit even if we don't have consumers.\n        // (see: https://github.com/inikulin/parse5/issues/97#issuecomment-171940774)\n        this.pipe(new DevNullStream());\n    }\n\n    //TransformStream implementation\n    _transform(chunk, encoding, callback) {\n        if (typeof chunk !== 'string') {\n            throw new TypeError('Parser can work only with string streams.');\n        }\n\n        callback(null, this._transformChunk(chunk));\n    }\n\n    _final(callback) {\n        this.lastChunkWritten = true;\n        callback(null, this._transformChunk(''));\n    }\n\n    stop() {\n        this.stopped = true;\n    }\n\n    //Internals\n    _transformChunk(chunk) {\n        if (!this.stopped) {\n            this.tokenizer.write(chunk, this.lastChunkWritten);\n            this._runParsingLoop();\n        }\n        return chunk;\n    }\n\n    _runParsingLoop() {\n        let token = null;\n\n        do {\n            token = this.parserFeedbackSimulator.getNextToken();\n\n            if (token.type === Tokenizer.HIBERNATION_TOKEN) {\n                break;\n            }\n\n            if (\n                token.type === Tokenizer.CHARACTER_TOKEN ||\n                token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN ||\n                token.type === Tokenizer.NULL_CHARACTER_TOKEN\n            ) {\n                if (this.pendingText === null) {\n                    token.type = Tokenizer.CHARACTER_TOKEN;\n                    this.pendingText = token;\n                } else {\n                    this.pendingText.chars += token.chars;\n\n                    if (this.options.sourceCodeLocationInfo) {\n                        const { endLine, endCol, endOffset } = token.location;\n                        Object.assign(this.pendingText.location, {\n                            endLine,\n                            endCol,\n                            endOffset\n                        });\n                    }\n                }\n            } else {\n                this._emitPendingText();\n                this._handleToken(token);\n            }\n        } while (!this.stopped && token.type !== Tokenizer.EOF_TOKEN);\n    }\n\n    _handleToken(token) {\n        if (token.type === Tokenizer.EOF_TOKEN) {\n            return true;\n        }\n\n        const { eventName, reshapeToken } = TOKEN_EMISSION_HELPERS[token.type];\n\n        if (this.listenerCount(eventName) === 0) {\n            return false;\n        }\n\n        this._emitToken(eventName, reshapeToken(token));\n\n        return true;\n    }\n\n    _emitToken(eventName, token) {\n        this.emit(eventName, token);\n    }\n\n    _emitPendingText() {\n        if (this.pendingText !== null) {\n            this._handleToken(this.pendingText);\n            this.pendingText = null;\n        }\n    }\n}\n\nconst TOKEN_EMISSION_HELPERS = {\n    [Tokenizer.START_TAG_TOKEN]: {\n        eventName: 'startTag',\n        reshapeToken: origToken => ({\n            tagName: origToken.tagName,\n            attrs: origToken.attrs,\n            selfClosing: origToken.selfClosing,\n            sourceCodeLocation: origToken.location\n        })\n    },\n    [Tokenizer.END_TAG_TOKEN]: {\n        eventName: 'endTag',\n        reshapeToken: origToken => ({ tagName: origToken.tagName, sourceCodeLocation: origToken.location })\n    },\n    [Tokenizer.COMMENT_TOKEN]: {\n        eventName: 'comment',\n        reshapeToken: origToken => ({ text: origToken.data, sourceCodeLocation: origToken.location })\n    },\n    [Tokenizer.DOCTYPE_TOKEN]: {\n        eventName: 'doctype',\n        reshapeToken: origToken => ({\n            name: origToken.name,\n            publicId: origToken.publicId,\n            systemId: origToken.systemId,\n            sourceCodeLocation: origToken.location\n        })\n    },\n    [Tokenizer.CHARACTER_TOKEN]: {\n        eventName: 'text',\n        reshapeToken: origToken => ({ text: origToken.chars, sourceCodeLocation: origToken.location })\n    }\n};\n\nmodule.exports = SAXParser;\n"]},"metadata":{},"sourceType":"script"}