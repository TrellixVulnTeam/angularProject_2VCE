{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeAssetPatterns = exports.MissingAssetSourceRootException = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar core_1 = require(\"@angular-devkit/core\");\n\nvar MissingAssetSourceRootException = /*#__PURE__*/function (_core_1$BaseException) {\n  _inherits(MissingAssetSourceRootException, _core_1$BaseException);\n\n  var _super = _createSuper(MissingAssetSourceRootException);\n\n  function MissingAssetSourceRootException(path) {\n    _classCallCheck(this, MissingAssetSourceRootException);\n\n    return _super.call(this, \"The \".concat(path, \" asset path must start with the project source root.\"));\n  }\n\n  return MissingAssetSourceRootException;\n}(core_1.BaseException);\n\nexports.MissingAssetSourceRootException = MissingAssetSourceRootException;\n\nfunction normalizeAssetPatterns(assetPatterns, host, root, projectRoot, maybeSourceRoot) {\n  // When sourceRoot is not available, we default to ${projectRoot}/src.\n  var sourceRoot = maybeSourceRoot || core_1.join(projectRoot, 'src');\n  var resolvedSourceRoot = core_1.resolve(root, sourceRoot);\n\n  if (assetPatterns.length === 0) {\n    return [];\n  }\n\n  return assetPatterns.map(function (assetPattern) {\n    // Normalize string asset patterns to objects.\n    if (typeof assetPattern === 'string') {\n      var assetPath = core_1.normalize(assetPattern);\n      var resolvedAssetPath = core_1.resolve(root, assetPath); // Check if the string asset is within sourceRoot.\n\n      if (!resolvedAssetPath.startsWith(resolvedSourceRoot)) {\n        throw new MissingAssetSourceRootException(assetPattern);\n      }\n\n      var glob, input, output;\n      var isDirectory = false;\n\n      try {\n        isDirectory = host.isDirectory(resolvedAssetPath);\n      } catch (_a) {\n        isDirectory = true;\n      }\n\n      if (isDirectory) {\n        // Folders get a recursive star glob.\n        glob = '**/*'; // Input directory is their original path.\n\n        input = assetPath;\n      } else {\n        // Files are their own glob.\n        glob = core_1.basename(assetPath); // Input directory is their original dirname.\n\n        input = core_1.dirname(assetPath);\n      } // Output directory for both is the relative path from source root to input.\n\n\n      output = core_1.relative(resolvedSourceRoot, core_1.resolve(root, input)); // Return the asset pattern in object format.\n\n      return {\n        glob: glob,\n        input: input,\n        output: output\n      };\n    } else {\n      // It's already an AssetPatternObject, no need to convert.\n      return assetPattern;\n    }\n  });\n}\n\nexports.normalizeAssetPatterns = normalizeAssetPatterns;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/src/utils/normalize-asset-patterns.js"],"names":["Object","defineProperty","exports","value","normalizeAssetPatterns","MissingAssetSourceRootException","core_1","require","path","BaseException","assetPatterns","host","root","projectRoot","maybeSourceRoot","sourceRoot","join","resolvedSourceRoot","resolve","length","map","assetPattern","assetPath","normalize","resolvedAssetPath","startsWith","glob","input","output","isDirectory","_a","basename","dirname","relative"],"mappings":"AAAA;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,sBAAR,GAAiCF,OAAO,CAACG,+BAAR,GAA0C,KAAK,CAAhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,MAAM,GAAGC,OAAO,CAAC,sBAAD,CAAtB;;IACMF,+B;;;;;AACF,2CAAYG,IAAZ,EAAkB;AAAA;;AAAA,2CACDA,IADC;AAEjB;;;EAHyCF,MAAM,CAACG,a;;AAKrDP,OAAO,CAACG,+BAAR,GAA0CA,+BAA1C;;AACA,SAASD,sBAAT,CAAgCM,aAAhC,EAA+CC,IAA/C,EAAqDC,IAArD,EAA2DC,WAA3D,EAAwEC,eAAxE,EAAyF;AACrF;AACA,MAAMC,UAAU,GAAGD,eAAe,IAAIR,MAAM,CAACU,IAAP,CAAYH,WAAZ,EAAyB,KAAzB,CAAtC;AACA,MAAMI,kBAAkB,GAAGX,MAAM,CAACY,OAAP,CAAeN,IAAf,EAAqBG,UAArB,CAA3B;;AACA,MAAIL,aAAa,CAACS,MAAd,KAAyB,CAA7B,EAAgC;AAC5B,WAAO,EAAP;AACH;;AACD,SAAOT,aAAa,CACfU,GADE,CACE,UAAAC,YAAY,EAAI;AACrB;AACA,QAAI,OAAOA,YAAP,KAAwB,QAA5B,EAAsC;AAClC,UAAMC,SAAS,GAAGhB,MAAM,CAACiB,SAAP,CAAiBF,YAAjB,CAAlB;AACA,UAAMG,iBAAiB,GAAGlB,MAAM,CAACY,OAAP,CAAeN,IAAf,EAAqBU,SAArB,CAA1B,CAFkC,CAGlC;;AACA,UAAI,CAACE,iBAAiB,CAACC,UAAlB,CAA6BR,kBAA7B,CAAL,EAAuD;AACnD,cAAM,IAAIZ,+BAAJ,CAAoCgB,YAApC,CAAN;AACH;;AACD,UAAIK,IAAJ,EAAUC,KAAV,EAAiBC,MAAjB;AACA,UAAIC,WAAW,GAAG,KAAlB;;AACA,UAAI;AACAA,QAAAA,WAAW,GAAGlB,IAAI,CAACkB,WAAL,CAAiBL,iBAAjB,CAAd;AACH,OAFD,CAGA,OAAOM,EAAP,EAAW;AACPD,QAAAA,WAAW,GAAG,IAAd;AACH;;AACD,UAAIA,WAAJ,EAAiB;AACb;AACAH,QAAAA,IAAI,GAAG,MAAP,CAFa,CAGb;;AACAC,QAAAA,KAAK,GAAGL,SAAR;AACH,OALD,MAMK;AACD;AACAI,QAAAA,IAAI,GAAGpB,MAAM,CAACyB,QAAP,CAAgBT,SAAhB,CAAP,CAFC,CAGD;;AACAK,QAAAA,KAAK,GAAGrB,MAAM,CAAC0B,OAAP,CAAeV,SAAf,CAAR;AACH,OA1BiC,CA2BlC;;;AACAM,MAAAA,MAAM,GAAGtB,MAAM,CAAC2B,QAAP,CAAgBhB,kBAAhB,EAAoCX,MAAM,CAACY,OAAP,CAAeN,IAAf,EAAqBe,KAArB,CAApC,CAAT,CA5BkC,CA6BlC;;AACA,aAAO;AAAED,QAAAA,IAAI,EAAJA,IAAF;AAAQC,QAAAA,KAAK,EAALA,KAAR;AAAeC,QAAAA,MAAM,EAANA;AAAf,OAAP;AACH,KA/BD,MAgCK;AACD;AACA,aAAOP,YAAP;AACH;AACJ,GAvCM,CAAP;AAwCH;;AACDnB,OAAO,CAACE,sBAAR,GAAiCA,sBAAjC","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeAssetPatterns = exports.MissingAssetSourceRootException = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst core_1 = require(\"@angular-devkit/core\");\nclass MissingAssetSourceRootException extends core_1.BaseException {\n    constructor(path) {\n        super(`The ${path} asset path must start with the project source root.`);\n    }\n}\nexports.MissingAssetSourceRootException = MissingAssetSourceRootException;\nfunction normalizeAssetPatterns(assetPatterns, host, root, projectRoot, maybeSourceRoot) {\n    // When sourceRoot is not available, we default to ${projectRoot}/src.\n    const sourceRoot = maybeSourceRoot || core_1.join(projectRoot, 'src');\n    const resolvedSourceRoot = core_1.resolve(root, sourceRoot);\n    if (assetPatterns.length === 0) {\n        return [];\n    }\n    return assetPatterns\n        .map(assetPattern => {\n        // Normalize string asset patterns to objects.\n        if (typeof assetPattern === 'string') {\n            const assetPath = core_1.normalize(assetPattern);\n            const resolvedAssetPath = core_1.resolve(root, assetPath);\n            // Check if the string asset is within sourceRoot.\n            if (!resolvedAssetPath.startsWith(resolvedSourceRoot)) {\n                throw new MissingAssetSourceRootException(assetPattern);\n            }\n            let glob, input, output;\n            let isDirectory = false;\n            try {\n                isDirectory = host.isDirectory(resolvedAssetPath);\n            }\n            catch (_a) {\n                isDirectory = true;\n            }\n            if (isDirectory) {\n                // Folders get a recursive star glob.\n                glob = '**/*';\n                // Input directory is their original path.\n                input = assetPath;\n            }\n            else {\n                // Files are their own glob.\n                glob = core_1.basename(assetPath);\n                // Input directory is their original dirname.\n                input = core_1.dirname(assetPath);\n            }\n            // Output directory for both is the relative path from source root to input.\n            output = core_1.relative(resolvedSourceRoot, core_1.resolve(root, input));\n            // Return the asset pattern in object format.\n            return { glob, input, output };\n        }\n        else {\n            // It's already an AssetPatternObject, no need to convert.\n            return assetPattern;\n        }\n    });\n}\nexports.normalizeAssetPatterns = normalizeAssetPatterns;\n"]},"metadata":{},"sourceType":"script"}