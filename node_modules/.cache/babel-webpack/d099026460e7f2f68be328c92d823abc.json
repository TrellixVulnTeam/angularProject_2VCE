{"ast":null,"code":"'use strict';\n\nvar pMap = function pMap(iterable, mapper, options) {\n  return new Promise(function (resolve, reject) {\n    options = Object.assign({\n      concurrency: Infinity\n    }, options);\n\n    if (typeof mapper !== 'function') {\n      throw new TypeError('Mapper function is required');\n    }\n\n    var _options = options,\n        concurrency = _options.concurrency;\n\n    if (!(typeof concurrency === 'number' && concurrency >= 1)) {\n      throw new TypeError(\"Expected `concurrency` to be a number from 1 and up, got `\".concat(concurrency, \"` (\").concat(typeof concurrency, \")\"));\n    }\n\n    var ret = [];\n    var iterator = iterable[Symbol.iterator]();\n    var isRejected = false;\n    var isIterableDone = false;\n    var resolvingCount = 0;\n    var currentIndex = 0;\n\n    var next = function next() {\n      if (isRejected) {\n        return;\n      }\n\n      var nextItem = iterator.next();\n      var i = currentIndex;\n      currentIndex++;\n\n      if (nextItem.done) {\n        isIterableDone = true;\n\n        if (resolvingCount === 0) {\n          resolve(ret);\n        }\n\n        return;\n      }\n\n      resolvingCount++;\n      Promise.resolve(nextItem.value).then(function (element) {\n        return mapper(element, i);\n      }).then(function (value) {\n        ret[i] = value;\n        resolvingCount--;\n        next();\n      }, function (error) {\n        isRejected = true;\n        reject(error);\n      });\n    };\n\n    for (var i = 0; i < concurrency; i++) {\n      next();\n\n      if (isIterableDone) {\n        break;\n      }\n    }\n  });\n};\n\nmodule.exports = pMap; // TODO: Remove this for the next major release\n\nmodule.exports.default = pMap;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack-dev-server/node_modules/p-map/index.js"],"names":["pMap","iterable","mapper","options","Promise","resolve","reject","Object","assign","concurrency","Infinity","TypeError","ret","iterator","Symbol","isRejected","isIterableDone","resolvingCount","currentIndex","next","nextItem","i","done","value","then","element","error","module","exports","default"],"mappings":"AAAA;;AAEA,IAAMA,IAAI,GAAG,SAAPA,IAAO,CAACC,QAAD,EAAWC,MAAX,EAAmBC,OAAnB;AAAA,SAA+B,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC5EH,IAAAA,OAAO,GAAGI,MAAM,CAACC,MAAP,CAAc;AACvBC,MAAAA,WAAW,EAAEC;AADU,KAAd,EAEPP,OAFO,CAAV;;AAIA,QAAI,OAAOD,MAAP,KAAkB,UAAtB,EAAkC;AACjC,YAAM,IAAIS,SAAJ,CAAc,6BAAd,CAAN;AACA;;AAED,mBAAsBR,OAAtB;AAAA,QAAOM,WAAP,YAAOA,WAAP;;AAEA,QAAI,EAAE,OAAOA,WAAP,KAAuB,QAAvB,IAAmCA,WAAW,IAAI,CAApD,CAAJ,EAA4D;AAC3D,YAAM,IAAIE,SAAJ,qEAA8EF,WAA9E,gBAAgG,OAAOA,WAAvG,OAAN;AACA;;AAED,QAAMG,GAAG,GAAG,EAAZ;AACA,QAAMC,QAAQ,GAAGZ,QAAQ,CAACa,MAAM,CAACD,QAAR,CAAR,EAAjB;AACA,QAAIE,UAAU,GAAG,KAAjB;AACA,QAAIC,cAAc,GAAG,KAArB;AACA,QAAIC,cAAc,GAAG,CAArB;AACA,QAAIC,YAAY,GAAG,CAAnB;;AAEA,QAAMC,IAAI,GAAG,SAAPA,IAAO,GAAM;AAClB,UAAIJ,UAAJ,EAAgB;AACf;AACA;;AAED,UAAMK,QAAQ,GAAGP,QAAQ,CAACM,IAAT,EAAjB;AACA,UAAME,CAAC,GAAGH,YAAV;AACAA,MAAAA,YAAY;;AAEZ,UAAIE,QAAQ,CAACE,IAAb,EAAmB;AAClBN,QAAAA,cAAc,GAAG,IAAjB;;AAEA,YAAIC,cAAc,KAAK,CAAvB,EAA0B;AACzBZ,UAAAA,OAAO,CAACO,GAAD,CAAP;AACA;;AAED;AACA;;AAEDK,MAAAA,cAAc;AAEdb,MAAAA,OAAO,CAACC,OAAR,CAAgBe,QAAQ,CAACG,KAAzB,EACEC,IADF,CACO,UAAAC,OAAO;AAAA,eAAIvB,MAAM,CAACuB,OAAD,EAAUJ,CAAV,CAAV;AAAA,OADd,EAEEG,IAFF,CAGE,UAAAD,KAAK,EAAI;AACRX,QAAAA,GAAG,CAACS,CAAD,CAAH,GAASE,KAAT;AACAN,QAAAA,cAAc;AACdE,QAAAA,IAAI;AACJ,OAPH,EAQE,UAAAO,KAAK,EAAI;AACRX,QAAAA,UAAU,GAAG,IAAb;AACAT,QAAAA,MAAM,CAACoB,KAAD,CAAN;AACA,OAXH;AAaA,KAlCD;;AAoCA,SAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,WAApB,EAAiCY,CAAC,EAAlC,EAAsC;AACrCF,MAAAA,IAAI;;AAEJ,UAAIH,cAAJ,EAAoB;AACnB;AACA;AACD;AACD,GAjE2C,CAA/B;AAAA,CAAb;;AAmEAW,MAAM,CAACC,OAAP,GAAiB5B,IAAjB,C,CACA;;AACA2B,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyB7B,IAAzB","sourcesContent":["'use strict';\n\nconst pMap = (iterable, mapper, options) => new Promise((resolve, reject) => {\n\toptions = Object.assign({\n\t\tconcurrency: Infinity\n\t}, options);\n\n\tif (typeof mapper !== 'function') {\n\t\tthrow new TypeError('Mapper function is required');\n\t}\n\n\tconst {concurrency} = options;\n\n\tif (!(typeof concurrency === 'number' && concurrency >= 1)) {\n\t\tthrow new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t}\n\n\tconst ret = [];\n\tconst iterator = iterable[Symbol.iterator]();\n\tlet isRejected = false;\n\tlet isIterableDone = false;\n\tlet resolvingCount = 0;\n\tlet currentIndex = 0;\n\n\tconst next = () => {\n\t\tif (isRejected) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst nextItem = iterator.next();\n\t\tconst i = currentIndex;\n\t\tcurrentIndex++;\n\n\t\tif (nextItem.done) {\n\t\t\tisIterableDone = true;\n\n\t\t\tif (resolvingCount === 0) {\n\t\t\t\tresolve(ret);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tresolvingCount++;\n\n\t\tPromise.resolve(nextItem.value)\n\t\t\t.then(element => mapper(element, i))\n\t\t\t.then(\n\t\t\t\tvalue => {\n\t\t\t\t\tret[i] = value;\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tnext();\n\t\t\t\t},\n\t\t\t\terror => {\n\t\t\t\t\tisRejected = true;\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\t\t\t);\n\t};\n\n\tfor (let i = 0; i < concurrency; i++) {\n\t\tnext();\n\n\t\tif (isIterableDone) {\n\t\t\tbreak;\n\t\t}\n\t}\n});\n\nmodule.exports = pMap;\n// TODO: Remove this for the next major release\nmodule.exports.default = pMap;\n"]},"metadata":{},"sourceType":"script"}