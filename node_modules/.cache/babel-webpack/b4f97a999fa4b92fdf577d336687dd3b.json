{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar fsScandir = require(\"@nodelib/fs.scandir\");\n\nvar fastq = require(\"fastq\");\n\nvar common = require(\"./common\");\n\nvar reader_1 = require(\"./reader\");\n\nvar AsyncReader = /*#__PURE__*/function (_reader_1$default) {\n  _inherits(AsyncReader, _reader_1$default);\n\n  var _super = _createSuper(AsyncReader);\n\n  function AsyncReader(_root, _settings) {\n    var _this;\n\n    _classCallCheck(this, AsyncReader);\n\n    _this = _super.call(this, _root, _settings);\n    _this._settings = _settings;\n    _this._scandir = fsScandir.scandir;\n    _this._emitter = new events_1.EventEmitter();\n    _this._queue = fastq(_this._worker.bind(_assertThisInitialized(_this)), _this._settings.concurrency);\n    _this._isFatalError = false;\n    _this._isDestroyed = false;\n\n    _this._queue.drain = function () {\n      if (!_this._isFatalError) {\n        _this._emitter.emit('end');\n      }\n    };\n\n    return _this;\n  }\n\n  _createClass(AsyncReader, [{\n    key: \"read\",\n    value: function read() {\n      var _this2 = this;\n\n      this._isFatalError = false;\n      this._isDestroyed = false;\n      setImmediate(function () {\n        _this2._pushToQueue(_this2._root, _this2._settings.basePath);\n      });\n      return this._emitter;\n    }\n  }, {\n    key: \"isDestroyed\",\n    get: function get() {\n      return this._isDestroyed;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      if (this._isDestroyed) {\n        throw new Error('The reader is already destroyed');\n      }\n\n      this._isDestroyed = true;\n\n      this._queue.killAndDrain();\n    }\n  }, {\n    key: \"onEntry\",\n    value: function onEntry(callback) {\n      this._emitter.on('entry', callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this._emitter.once('error', callback);\n    }\n  }, {\n    key: \"onEnd\",\n    value: function onEnd(callback) {\n      this._emitter.once('end', callback);\n    }\n  }, {\n    key: \"_pushToQueue\",\n    value: function _pushToQueue(directory, base) {\n      var _this3 = this;\n\n      var queueItem = {\n        directory: directory,\n        base: base\n      };\n\n      this._queue.push(queueItem, function (error) {\n        if (error !== null) {\n          _this3._handleError(error);\n        }\n      });\n    }\n  }, {\n    key: \"_worker\",\n    value: function _worker(item, done) {\n      var _this4 = this;\n\n      this._scandir(item.directory, this._settings.fsScandirSettings, function (error, entries) {\n        if (error !== null) {\n          done(error, undefined);\n          return;\n        }\n\n        var _iterator = _createForOfIteratorHelper(entries),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var entry = _step.value;\n\n            _this4._handleEntry(entry, item.base);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        done(null, undefined);\n      });\n    }\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(error) {\n      if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n        return;\n      }\n\n      this._isFatalError = true;\n      this._isDestroyed = true;\n\n      this._emitter.emit('error', error);\n    }\n  }, {\n    key: \"_handleEntry\",\n    value: function _handleEntry(entry, base) {\n      if (this._isDestroyed || this._isFatalError) {\n        return;\n      }\n\n      var fullpath = entry.path;\n\n      if (base !== undefined) {\n        entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n      }\n\n      if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n        this._emitEntry(entry);\n      }\n\n      if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n        this._pushToQueue(fullpath, entry.path);\n      }\n    }\n  }, {\n    key: \"_emitEntry\",\n    value: function _emitEntry(entry) {\n      this._emitter.emit('entry', entry);\n    }\n  }]);\n\n  return AsyncReader;\n}(reader_1.default);\n\nexports.default = AsyncReader;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@nodelib/fs.walk/out/readers/async.js"],"names":["Object","defineProperty","exports","value","events_1","require","fsScandir","fastq","common","reader_1","AsyncReader","_root","_settings","_scandir","scandir","_emitter","EventEmitter","_queue","_worker","bind","concurrency","_isFatalError","_isDestroyed","drain","emit","setImmediate","_pushToQueue","basePath","Error","killAndDrain","callback","on","once","directory","base","queueItem","push","error","_handleError","item","done","fsScandirSettings","entries","undefined","entry","_handleEntry","isFatalError","fullpath","path","joinPathSegments","name","pathSegmentSeparator","isAppliedFilter","entryFilter","_emitEntry","dirent","isDirectory","deepFilter","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst events_1 = require(\"events\");\nconst fsScandir = require(\"@nodelib/fs.scandir\");\nconst fastq = require(\"fastq\");\nconst common = require(\"./common\");\nconst reader_1 = require(\"./reader\");\nclass AsyncReader extends reader_1.default {\n    constructor(_root, _settings) {\n        super(_root, _settings);\n        this._settings = _settings;\n        this._scandir = fsScandir.scandir;\n        this._emitter = new events_1.EventEmitter();\n        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        this._queue.drain = () => {\n            if (!this._isFatalError) {\n                this._emitter.emit('end');\n            }\n        };\n    }\n    read() {\n        this._isFatalError = false;\n        this._isDestroyed = false;\n        setImmediate(() => {\n            this._pushToQueue(this._root, this._settings.basePath);\n        });\n        return this._emitter;\n    }\n    get isDestroyed() {\n        return this._isDestroyed;\n    }\n    destroy() {\n        if (this._isDestroyed) {\n            throw new Error('The reader is already destroyed');\n        }\n        this._isDestroyed = true;\n        this._queue.killAndDrain();\n    }\n    onEntry(callback) {\n        this._emitter.on('entry', callback);\n    }\n    onError(callback) {\n        this._emitter.once('error', callback);\n    }\n    onEnd(callback) {\n        this._emitter.once('end', callback);\n    }\n    _pushToQueue(directory, base) {\n        const queueItem = { directory, base };\n        this._queue.push(queueItem, (error) => {\n            if (error !== null) {\n                this._handleError(error);\n            }\n        });\n    }\n    _worker(item, done) {\n        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {\n            if (error !== null) {\n                done(error, undefined);\n                return;\n            }\n            for (const entry of entries) {\n                this._handleEntry(entry, item.base);\n            }\n            done(null, undefined);\n        });\n    }\n    _handleError(error) {\n        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {\n            return;\n        }\n        this._isFatalError = true;\n        this._isDestroyed = true;\n        this._emitter.emit('error', error);\n    }\n    _handleEntry(entry, base) {\n        if (this._isDestroyed || this._isFatalError) {\n            return;\n        }\n        const fullpath = entry.path;\n        if (base !== undefined) {\n            entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);\n        }\n        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {\n            this._emitEntry(entry);\n        }\n        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {\n            this._pushToQueue(fullpath, entry.path);\n        }\n    }\n    _emitEntry(entry) {\n        this._emitter.emit('entry', entry);\n    }\n}\nexports.default = AsyncReader;\n"]},"metadata":{},"sourceType":"script"}