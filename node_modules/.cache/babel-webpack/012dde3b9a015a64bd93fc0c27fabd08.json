{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar crypto = require(\"crypto\");\n\nvar SortableSet = require(\"../util/SortableSet\");\n\nvar GraphHelpers = require(\"../GraphHelpers\");\n\nvar _require = require(\"../util/SetHelpers\"),\n    isSubset = _require.isSubset;\n\nvar deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nvar MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\nvar contextify = require(\"../util/identifier\").contextify;\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n\nvar deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\nvar hashFilename = function hashFilename(name) {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\n\nvar sortByIdentifier = function sortByIdentifier(a, b) {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\nvar getRequests = function getRequests(chunk) {\n  var requests = 0;\n\n  var _iterator = _createForOfIteratorHelper(chunk.groupsIterable),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunkGroup = _step.value;\n      requests = Math.max(requests, chunkGroup.chunks.length);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return requests;\n};\n\nvar getModulesSize = function getModulesSize(modules) {\n  var sum = 0;\n\n  var _iterator2 = _createForOfIteratorHelper(modules),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var m = _step2.value;\n      sum += m.size();\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return sum;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nvar isOverlap = function isOverlap(a, b) {\n  var _iterator3 = _createForOfIteratorHelper(a),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var item = _step3.value;\n      if (b.has(item)) return true;\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return false;\n};\n\nvar compareEntries = function compareEntries(a, b) {\n  // 1. by priority\n  var diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  var diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  var aSizeReduce = a.size * (a.chunks.size - 1);\n  var bSizeReduce = b.size * (b.chunks.size - 1);\n  var diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by cache group index\n\n  var indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;\n  if (indexDiff) return indexDiff; // 5. by number of modules (to be able to compare by identifier)\n\n  var modulesA = a.modules;\n  var modulesB = b.modules;\n  var diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 6. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  var aI = modulesA[Symbol.iterator]();\n  var bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    var aItem = aI.next();\n    var bItem = bI.next();\n    if (aItem.done) return 0;\n    var aModuleIdentifier = aItem.value.identifier();\n    var bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\n\nvar compareNumbers = function compareNumbers(a, b) {\n  return a - b;\n};\n\nvar INITIAL_CHUNK_FILTER = function INITIAL_CHUNK_FILTER(chunk) {\n  return chunk.canBeInitial();\n};\n\nvar ASYNC_CHUNK_FILTER = function ASYNC_CHUNK_FILTER(chunk) {\n  return !chunk.canBeInitial();\n};\n\nvar ALL_CHUNK_FILTER = function ALL_CHUNK_FILTER(chunk) {\n  return true;\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  function SplitChunksPlugin(options) {\n    _classCallCheck(this, SplitChunksPlugin);\n\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n\n  _createClass(SplitChunksPlugin, [{\n    key: \"apply\",\n    value:\n    /**\n     * @param {Compiler} compiler webpack compiler\n     * @returns {void}\n     */\n    function apply(compiler) {\n      var _this = this;\n\n      compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", function (compilation) {\n        var alreadyOptimized = false;\n        compilation.hooks.unseal.tap(\"SplitChunksPlugin\", function () {\n          alreadyOptimized = false;\n        });\n        compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", function (chunks) {\n          if (alreadyOptimized) return;\n          alreadyOptimized = true; // Give each selected chunk an index (to create strings from chunks)\n\n          var indexMap = new Map();\n          var index = 1;\n\n          var _iterator4 = _createForOfIteratorHelper(chunks),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var chunk = _step4.value;\n              indexMap.set(chunk, index++);\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          var getKey = function getKey(chunks) {\n            return Array.from(chunks, function (c) {\n              return indexMap.get(c);\n            }).sort(compareNumbers).join();\n          };\n          /** @type {Map<string, Set<Chunk>>} */\n\n\n          var chunkSetsInGraph = new Map();\n\n          var _iterator5 = _createForOfIteratorHelper(compilation.modules),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var _module = _step5.value;\n              var chunksKey = getKey(_module.chunksIterable);\n\n              if (!chunkSetsInGraph.has(chunksKey)) {\n                chunkSetsInGraph.set(chunksKey, new Set(_module.chunksIterable));\n              }\n            } // group these set of chunks by count\n            // to allow to check less sets via isSubset\n            // (only smaller sets can be subset)\n\n            /** @type {Map<number, Array<Set<Chunk>>>} */\n\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          var chunkSetsByCount = new Map();\n\n          var _iterator6 = _createForOfIteratorHelper(chunkSetsInGraph.values()),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var chunksSet = _step6.value;\n              var count = chunksSet.size;\n              var array = chunkSetsByCount.get(count);\n\n              if (array === undefined) {\n                array = [];\n                chunkSetsByCount.set(count, array);\n              }\n\n              array.push(chunksSet);\n            } // Create a list of possible combinations\n\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          var combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n          var getCombinations = function getCombinations(key) {\n            var chunksSet = chunkSetsInGraph.get(key);\n            var array = [chunksSet];\n\n            if (chunksSet.size > 1) {\n              var _iterator7 = _createForOfIteratorHelper(chunkSetsByCount),\n                  _step7;\n\n              try {\n                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                  var _step7$value = _slicedToArray(_step7.value, 2),\n                      count = _step7$value[0],\n                      setArray = _step7$value[1];\n\n                  // \"equal\" is not needed because they would have been merge in the first step\n                  if (count < chunksSet.size) {\n                    var _iterator8 = _createForOfIteratorHelper(setArray),\n                        _step8;\n\n                    try {\n                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                        var set = _step8.value;\n\n                        if (isSubset(chunksSet, set)) {\n                          array.push(set);\n                        }\n                      }\n                    } catch (err) {\n                      _iterator8.e(err);\n                    } finally {\n                      _iterator8.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator7.e(err);\n              } finally {\n                _iterator7.f();\n              }\n            }\n\n            return array;\n          };\n          /**\n           * @typedef {Object} SelectedChunksResult\n           * @property {Chunk[]} chunks the list of chunks\n           * @property {string} key a key of the list\n           */\n\n          /**\n           * @typedef {function(Chunk): boolean} ChunkFilterFunction\n           */\n\n          /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n          var selectedChunksCacheByChunksSet = new WeakMap();\n          /**\n           * get list and key by applying the filter function to the list\n           * It is cached for performance reasons\n           * @param {Set<Chunk>} chunks list of chunks\n           * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n           * @returns {SelectedChunksResult} list and key\n           */\n\n          var getSelectedChunks = function getSelectedChunks(chunks, chunkFilter) {\n            var entry = selectedChunksCacheByChunksSet.get(chunks);\n\n            if (entry === undefined) {\n              entry = new WeakMap();\n              selectedChunksCacheByChunksSet.set(chunks, entry);\n            }\n            /** @type {SelectedChunksResult} */\n\n\n            var entry2 = entry.get(chunkFilter);\n\n            if (entry2 === undefined) {\n              /** @type {Chunk[]} */\n              var selectedChunks = [];\n\n              var _iterator9 = _createForOfIteratorHelper(chunks),\n                  _step9;\n\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var chunk = _step9.value;\n                  if (chunkFilter(chunk)) selectedChunks.push(chunk);\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n\n              entry2 = {\n                chunks: selectedChunks,\n                key: getKey(selectedChunks)\n              };\n              entry.set(chunkFilter, entry2);\n            }\n\n            return entry2;\n          };\n          /**\n           * @typedef {Object} ChunksInfoItem\n           * @property {SortableSet} modules\n           * @property {TODO} cacheGroup\n           * @property {number} cacheGroupIndex\n           * @property {string} name\n           * @property {number} size\n           * @property {Set<Chunk>} chunks\n           * @property {Set<Chunk>} reuseableChunks\n           * @property {Set<string>} chunksKeys\n           */\n          // Map a list of chunks to a list of modules\n          // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n          /** @type {Map<string, ChunksInfoItem>} */\n\n\n          var chunksInfoMap = new Map();\n          /**\n           * @param {TODO} cacheGroup the current cache group\n           * @param {number} cacheGroupIndex the index of the cache group of ordering\n           * @param {Chunk[]} selectedChunks chunks selected for this module\n           * @param {string} selectedChunksKey a key of selectedChunks\n           * @param {Module} module the current module\n           * @returns {void}\n           */\n\n          var addModuleToChunksInfoMap = function addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, module) {\n            // Break if minimum number of chunks is not reached\n            if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n            var name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Create key for maps\n            // When it has a name we use the name as key\n            // Elsewise we create the key from chunks and cache group key\n            // This automatically merges equal names\n\n            var key = cacheGroup.key + (name ? \" name:\".concat(name) : \" chunks:\".concat(selectedChunksKey)); // Add module to maps\n\n            var info = chunksInfoMap.get(key);\n\n            if (info === undefined) {\n              chunksInfoMap.set(key, info = {\n                modules: new SortableSet(undefined, sortByIdentifier),\n                cacheGroup: cacheGroup,\n                cacheGroupIndex: cacheGroupIndex,\n                name: name,\n                size: 0,\n                chunks: new Set(),\n                reuseableChunks: new Set(),\n                chunksKeys: new Set()\n              });\n            }\n\n            info.modules.add(module);\n            info.size += module.size();\n\n            if (!info.chunksKeys.has(selectedChunksKey)) {\n              info.chunksKeys.add(selectedChunksKey);\n\n              var _iterator10 = _createForOfIteratorHelper(selectedChunks),\n                  _step10;\n\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var chunk = _step10.value;\n                  info.chunks.add(chunk);\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            }\n          }; // Walk through all modules\n\n\n          var _iterator11 = _createForOfIteratorHelper(compilation.modules),\n              _step11;\n\n          try {\n            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n              var _module2 = _step11.value;\n\n              // Get cache group\n              var cacheGroups = _this.options.getCacheGroups(_module2);\n\n              if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n                continue;\n              } // Prepare some values\n\n\n              var _chunksKey = getKey(_module2.chunksIterable);\n\n              var combs = combinationsCache.get(_chunksKey);\n\n              if (combs === undefined) {\n                combs = getCombinations(_chunksKey);\n                combinationsCache.set(_chunksKey, combs);\n              }\n\n              var cacheGroupIndex = 0;\n\n              var _iterator14 = _createForOfIteratorHelper(cacheGroups),\n                  _step14;\n\n              try {\n                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                  var cacheGroupSource = _step14.value;\n                  var minSize = cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : _this.options.minSize;\n                  var enforceSizeThreshold = cacheGroupSource.enforceSizeThreshold !== undefined ? cacheGroupSource.enforceSizeThreshold : cacheGroupSource.enforce ? 0 : _this.options.enforceSizeThreshold;\n                  var cacheGroup = {\n                    key: cacheGroupSource.key,\n                    priority: cacheGroupSource.priority || 0,\n                    chunksFilter: cacheGroupSource.chunksFilter || _this.options.chunksFilter,\n                    minSize: minSize,\n                    minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : _this.options.minSize,\n                    enforceSizeThreshold: enforceSizeThreshold,\n                    maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : _this.options.maxSize,\n                    minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : _this.options.minChunks,\n                    maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxAsyncRequests,\n                    maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : _this.options.maxInitialRequests,\n                    getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : _this.options.getName,\n                    filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : _this.options.filename,\n                    automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : _this.options.automaticNameDelimiter,\n                    reuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n                    _validateSize: minSize > 0,\n                    _conditionalEnforce: enforceSizeThreshold > 0\n                  }; // For all combination of chunk selection\n\n                  var _iterator15 = _createForOfIteratorHelper(combs),\n                      _step15;\n\n                  try {\n                    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                      var chunkCombination = _step15.value;\n                      // Break if minimum number of chunks is not reached\n                      if (chunkCombination.size < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n                      var _getSelectedChunks = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter),\n                          selectedChunks = _getSelectedChunks.chunks,\n                          selectedChunksKey = _getSelectedChunks.key;\n\n                      addModuleToChunksInfoMap(cacheGroup, cacheGroupIndex, selectedChunks, selectedChunksKey, _module2);\n                    }\n                  } catch (err) {\n                    _iterator15.e(err);\n                  } finally {\n                    _iterator15.f();\n                  }\n\n                  cacheGroupIndex++;\n                }\n              } catch (err) {\n                _iterator14.e(err);\n              } finally {\n                _iterator14.f();\n              }\n            } // Filter items were size < minSize\n\n          } catch (err) {\n            _iterator11.e(err);\n          } finally {\n            _iterator11.f();\n          }\n\n          var _iterator12 = _createForOfIteratorHelper(chunksInfoMap),\n              _step12;\n\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var pair = _step12.value;\n              var info = pair[1];\n\n              if (info.cacheGroup._validateSize && info.size < info.cacheGroup.minSize) {\n                chunksInfoMap.delete(pair[0]);\n              }\n            }\n            /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n\n          var maxSizeQueueMap = new Map();\n\n          var _loop = function _loop() {\n            // Find best matching entry\n            var bestEntryKey = void 0;\n            var bestEntry = void 0;\n\n            var _iterator16 = _createForOfIteratorHelper(chunksInfoMap),\n                _step16;\n\n            try {\n              for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n                var _pair = _step16.value;\n                var key = _pair[0];\n                var _info = _pair[1];\n\n                if (bestEntry === undefined) {\n                  bestEntry = _info;\n                  bestEntryKey = key;\n                } else if (compareEntries(bestEntry, _info) < 0) {\n                  bestEntry = _info;\n                  bestEntryKey = key;\n                }\n              }\n            } catch (err) {\n              _iterator16.e(err);\n            } finally {\n              _iterator16.f();\n            }\n\n            var item = bestEntry;\n            chunksInfoMap.delete(bestEntryKey);\n            var chunkName = item.name; // Variable for the new chunk (lazy created)\n\n            /** @type {Chunk} */\n\n            var newChunk = void 0; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n            var isReused = false;\n\n            if (item.cacheGroup.reuseExistingChunk) {\n              var _iterator17 = _createForOfIteratorHelper(item.chunks),\n                  _step17;\n\n              try {\n                outer: for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n                  var _chunk = _step17.value;\n                  if (_chunk.getNumberOfModules() !== item.modules.size) continue;\n                  if (_chunk.hasEntryModule()) continue;\n\n                  var _iterator18 = _createForOfIteratorHelper(item.modules),\n                      _step18;\n\n                  try {\n                    for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n                      var _module3 = _step18.value;\n                      if (!_chunk.containsModule(_module3)) continue outer;\n                    }\n                  } catch (err) {\n                    _iterator18.e(err);\n                  } finally {\n                    _iterator18.f();\n                  }\n\n                  if (!newChunk || !newChunk.name) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length < newChunk.name.length) {\n                    newChunk = _chunk;\n                  } else if (_chunk.name && _chunk.name.length === newChunk.name.length && _chunk.name < newChunk.name) {\n                    newChunk = _chunk;\n                  }\n\n                  chunkName = undefined;\n                  isReused = true;\n                }\n              } catch (err) {\n                _iterator17.e(err);\n              } finally {\n                _iterator17.f();\n              }\n            } // Check if maxRequests condition can be fulfilled\n\n\n            var selectedChunks = Array.from(item.chunks).filter(function (chunk) {\n              // skip if we address ourself\n              return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n            });\n            var enforced = item.cacheGroup._conditionalEnforce && item.size >= item.cacheGroup.enforceSizeThreshold; // Skip when no chunk selected\n\n            if (selectedChunks.length === 0) return \"continue\";\n            var usedChunks = new Set(selectedChunks); // Check if maxRequests condition can be fulfilled\n\n            if (!enforced && (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests))) {\n              var _iterator19 = _createForOfIteratorHelper(usedChunks),\n                  _step19;\n\n              try {\n                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n                  var _chunk2 = _step19.value;\n                  // respect max requests\n                  var maxRequests = _chunk2.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : _chunk2.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n\n                  if (isFinite(maxRequests) && getRequests(_chunk2) >= maxRequests) {\n                    usedChunks.delete(_chunk2);\n                  }\n                }\n              } catch (err) {\n                _iterator19.e(err);\n              } finally {\n                _iterator19.f();\n              }\n            }\n\n            var _iterator20 = _createForOfIteratorHelper(usedChunks),\n                _step20;\n\n            try {\n              outer: for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n                var _chunk5 = _step20.value;\n\n                var _iterator28 = _createForOfIteratorHelper(item.modules),\n                    _step28;\n\n                try {\n                  for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                    var _module7 = _step28.value;\n                    if (_chunk5.containsModule(_module7)) continue outer;\n                  }\n                } catch (err) {\n                  _iterator28.e(err);\n                } finally {\n                  _iterator28.f();\n                }\n\n                usedChunks.delete(_chunk5);\n              }\n            } catch (err) {\n              _iterator20.e(err);\n            } finally {\n              _iterator20.f();\n            } // Were some (invalid) chunks removed from usedChunks?\n            // => readd all modules to the queue, as things could have been changed\n\n\n            if (usedChunks.size < selectedChunks.length) {\n              if (usedChunks.size >= item.cacheGroup.minChunks) {\n                var chunksArr = Array.from(usedChunks);\n\n                var _iterator21 = _createForOfIteratorHelper(item.modules),\n                    _step21;\n\n                try {\n                  for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n                    var _module4 = _step21.value;\n                    addModuleToChunksInfoMap(item.cacheGroup, item.cacheGroupIndex, chunksArr, getKey(usedChunks), _module4);\n                  }\n                } catch (err) {\n                  _iterator21.e(err);\n                } finally {\n                  _iterator21.f();\n                }\n              }\n\n              return \"continue\";\n            } // Create the new chunk if not reusing one\n\n\n            if (!isReused) {\n              newChunk = compilation.addChunk(chunkName);\n            } // Walk through all chunks\n\n\n            var _iterator22 = _createForOfIteratorHelper(usedChunks),\n                _step22;\n\n            try {\n              for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n                var _chunk6 = _step22.value;\n\n                // Add graph connections for splitted chunk\n                _chunk6.split(newChunk);\n              } // Add a note to the chunk\n\n            } catch (err) {\n              _iterator22.e(err);\n            } finally {\n              _iterator22.f();\n            }\n\n            newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n\n            if (item.cacheGroup.key) {\n              newChunk.chunkReason += \" (cache group: \".concat(item.cacheGroup.key, \")\");\n            }\n\n            if (chunkName) {\n              newChunk.chunkReason += \" (name: \".concat(chunkName, \")\"); // If the chosen name is already an entry point we remove the entry point\n\n              var entrypoint = compilation.entrypoints.get(chunkName);\n\n              if (entrypoint) {\n                compilation.entrypoints.delete(chunkName);\n                entrypoint.remove();\n                newChunk.entryModule = undefined;\n              }\n            }\n\n            if (item.cacheGroup.filename) {\n              if (!newChunk.isOnlyInitial()) {\n                throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + \"(cache group: \".concat(item.cacheGroup.key, \")\"));\n              }\n\n              newChunk.filenameTemplate = item.cacheGroup.filename;\n            }\n\n            if (!isReused) {\n              // Add all modules to the new chunk\n              var _iterator23 = _createForOfIteratorHelper(item.modules),\n                  _step23;\n\n              try {\n                for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n                  var _module5 = _step23.value;\n\n                  if (typeof _module5.chunkCondition === \"function\") {\n                    if (!_module5.chunkCondition(newChunk)) continue;\n                  } // Add module to new chunk\n\n\n                  GraphHelpers.connectChunkAndModule(newChunk, _module5); // Remove module from used chunks\n\n                  var _iterator24 = _createForOfIteratorHelper(usedChunks),\n                      _step24;\n\n                  try {\n                    for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n                      var _chunk3 = _step24.value;\n\n                      _chunk3.removeModule(_module5);\n\n                      _module5.rewriteChunkInReasons(_chunk3, [newChunk]);\n                    }\n                  } catch (err) {\n                    _iterator24.e(err);\n                  } finally {\n                    _iterator24.f();\n                  }\n                }\n              } catch (err) {\n                _iterator23.e(err);\n              } finally {\n                _iterator23.f();\n              }\n            } else {\n              // Remove all modules from used chunks\n              var _iterator25 = _createForOfIteratorHelper(item.modules),\n                  _step25;\n\n              try {\n                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                  var _module6 = _step25.value;\n\n                  var _iterator26 = _createForOfIteratorHelper(usedChunks),\n                      _step26;\n\n                  try {\n                    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                      var _chunk4 = _step26.value;\n\n                      _chunk4.removeModule(_module6);\n\n                      _module6.rewriteChunkInReasons(_chunk4, [newChunk]);\n                    }\n                  } catch (err) {\n                    _iterator26.e(err);\n                  } finally {\n                    _iterator26.f();\n                  }\n                }\n              } catch (err) {\n                _iterator25.e(err);\n              } finally {\n                _iterator25.f();\n              }\n            }\n\n            if (item.cacheGroup.maxSize > 0) {\n              var oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n              maxSizeQueueMap.set(newChunk, {\n                minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),\n                maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n                automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n                keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n              });\n            } // remove all modules from other entries and update size\n\n\n            var _iterator27 = _createForOfIteratorHelper(chunksInfoMap),\n                _step27;\n\n            try {\n              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                var _step27$value = _slicedToArray(_step27.value, 2),\n                    _key = _step27$value[0],\n                    _info2 = _step27$value[1];\n\n                if (isOverlap(_info2.chunks, usedChunks)) {\n                  // update modules and total size\n                  // may remove it from the map when < minSize\n                  var oldSize = _info2.modules.size;\n\n                  var _iterator29 = _createForOfIteratorHelper(item.modules),\n                      _step29;\n\n                  try {\n                    for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                      var _module8 = _step29.value;\n\n                      _info2.modules.delete(_module8);\n                    }\n                  } catch (err) {\n                    _iterator29.e(err);\n                  } finally {\n                    _iterator29.f();\n                  }\n\n                  if (_info2.modules.size !== oldSize) {\n                    if (_info2.modules.size === 0) {\n                      chunksInfoMap.delete(_key);\n                      continue;\n                    }\n\n                    _info2.size = getModulesSize(_info2.modules);\n\n                    if (_info2.cacheGroup._validateSize && _info2.size < _info2.cacheGroup.minSize) {\n                      chunksInfoMap.delete(_key);\n                    }\n\n                    if (_info2.modules.size === 0) {\n                      chunksInfoMap.delete(_key);\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator27.e(err);\n            } finally {\n              _iterator27.f();\n            }\n          };\n\n          while (chunksInfoMap.size > 0) {\n            var _ret = _loop();\n\n            if (_ret === \"continue\") continue;\n          }\n\n          var incorrectMinMaxSizeSet = new Set(); // Make sure that maxSize is fulfilled\n\n          var _iterator13 = _createForOfIteratorHelper(compilation.chunks.slice()),\n              _step13;\n\n          try {\n            var _loop2 = function _loop2() {\n              var chunk = _step13.value;\n\n              var _ref = maxSizeQueueMap.get(chunk) || _this.options.fallbackCacheGroup,\n                  minSize = _ref.minSize,\n                  maxSize = _ref.maxSize,\n                  automaticNameDelimiter = _ref.automaticNameDelimiter,\n                  keys = _ref.keys;\n\n              if (!maxSize) return \"continue\";\n\n              if (minSize > maxSize) {\n                var warningKey = \"\".concat(keys && keys.join(), \" \").concat(minSize, \" \").concat(maxSize);\n\n                if (!incorrectMinMaxSizeSet.has(warningKey)) {\n                  incorrectMinMaxSizeSet.add(warningKey);\n                  compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));\n                }\n              }\n\n              var results = deterministicGroupingForModules({\n                maxSize: Math.max(minSize, maxSize),\n                minSize: minSize,\n                items: chunk.modulesIterable,\n                getKey: function getKey(module) {\n                  var ident = contextify(compilation.options.context, module.identifier());\n                  var name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n                  var fullKey = name + automaticNameDelimiter + hashFilename(ident);\n                  return fullKey.replace(/[\\\\/?]/g, \"_\");\n                },\n                getSize: function getSize(module) {\n                  return module.size();\n                }\n              });\n              results.sort(function (a, b) {\n                if (a.key < b.key) return -1;\n                if (a.key > b.key) return 1;\n                return 0;\n              });\n\n              for (var i = 0; i < results.length; i++) {\n                var group = results[i];\n                var key = _this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n                var name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n\n                if (name && name.length > 100) {\n                  name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n                }\n\n                var newPart = void 0;\n\n                if (i !== results.length - 1) {\n                  newPart = compilation.addChunk(name);\n                  chunk.split(newPart);\n                  newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n                  var _iterator30 = _createForOfIteratorHelper(group.items),\n                      _step30;\n\n                  try {\n                    for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                      var _module9 = _step30.value;\n\n                      if (typeof _module9.chunkCondition === \"function\") {\n                        if (!_module9.chunkCondition(newPart)) continue;\n                      } // Add module to new chunk\n\n\n                      GraphHelpers.connectChunkAndModule(newPart, _module9); // Remove module from used chunks\n\n                      chunk.removeModule(_module9);\n\n                      _module9.rewriteChunkInReasons(chunk, [newPart]);\n                    }\n                  } catch (err) {\n                    _iterator30.e(err);\n                  } finally {\n                    _iterator30.f();\n                  }\n                } else {\n                  // change the chunk to be a part\n                  newPart = chunk;\n                  chunk.name = name;\n                }\n              }\n            };\n\n            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n              var _ret2 = _loop2();\n\n              if (_ret2 === \"continue\") continue;\n            }\n          } catch (err) {\n            _iterator13.e(err);\n          } finally {\n            _iterator13.f();\n          }\n        });\n      });\n    }\n  }], [{\n    key: \"normalizeOptions\",\n    value: function normalizeOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n        minSize: options.minSize || 0,\n        enforceSizeThreshold: options.enforceSizeThreshold || 0,\n        maxSize: options.maxSize || 0,\n        minChunks: options.minChunks || 1,\n        maxAsyncRequests: options.maxAsyncRequests || 1,\n        maxInitialRequests: options.maxInitialRequests || 1,\n        hidePathInfo: options.hidePathInfo || false,\n        filename: options.filename || undefined,\n        getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n          cacheGroups: options.cacheGroups,\n          name: options.name,\n          automaticNameDelimiter: options.automaticNameDelimiter,\n          automaticNameMaxLength: options.automaticNameMaxLength\n        }),\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        automaticNameMaxLength: options.automaticNameMaxLength || 109,\n        fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n      };\n    }\n  }, {\n    key: \"normalizeName\",\n    value: function normalizeName(_ref2) {\n      var name = _ref2.name,\n          automaticNameDelimiter = _ref2.automaticNameDelimiter,\n          automaticNamePrefix = _ref2.automaticNamePrefix,\n          automaticNameMaxLength = _ref2.automaticNameMaxLength;\n\n      if (name === true) {\n        /** @type {WeakMap<Chunk[], Record<string, string>>} */\n        var cache = new WeakMap();\n\n        var fn = function fn(module, chunks, cacheGroup) {\n          var cacheEntry = cache.get(chunks);\n\n          if (cacheEntry === undefined) {\n            cacheEntry = {};\n            cache.set(chunks, cacheEntry);\n          } else if (cacheGroup in cacheEntry) {\n            return cacheEntry[cacheGroup];\n          }\n\n          var names = chunks.map(function (c) {\n            return c.name;\n          });\n\n          if (!names.every(Boolean)) {\n            cacheEntry[cacheGroup] = undefined;\n            return;\n          }\n\n          names.sort();\n          var prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n          var namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n          var name = namePrefix + names.join(automaticNameDelimiter); // Filenames and paths can't be too long otherwise an\n          // ENAMETOOLONG error is raised. If the generated name if too\n          // long, it is truncated and a hash is appended. The limit has\n          // been set to 109 to prevent `[name].[chunkhash].[ext]` from\n          // generating a 256+ character string.\n\n          if (name.length > automaticNameMaxLength) {\n            var hashedFilename = hashFilename(name);\n            var sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);\n            name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;\n          }\n\n          cacheEntry[cacheGroup] = name;\n          return name;\n        };\n\n        return fn;\n      }\n\n      if (typeof name === \"string\") {\n        var _fn = function _fn() {\n          return name;\n        };\n\n        return _fn;\n      }\n\n      if (typeof name === \"function\") return name;\n    }\n  }, {\n    key: \"normalizeChunksFilter\",\n    value: function normalizeChunksFilter(chunks) {\n      if (chunks === \"initial\") {\n        return INITIAL_CHUNK_FILTER;\n      }\n\n      if (chunks === \"async\") {\n        return ASYNC_CHUNK_FILTER;\n      }\n\n      if (chunks === \"all\") {\n        return ALL_CHUNK_FILTER;\n      }\n\n      if (typeof chunks === \"function\") return chunks;\n    }\n  }, {\n    key: \"normalizeFallbackCacheGroup\",\n    value: function normalizeFallbackCacheGroup(_ref3, _ref4) {\n      var _ref3$minSize = _ref3.minSize,\n          minSize = _ref3$minSize === void 0 ? undefined : _ref3$minSize,\n          _ref3$maxSize = _ref3.maxSize,\n          maxSize = _ref3$maxSize === void 0 ? undefined : _ref3$maxSize,\n          _ref3$automaticNameDe = _ref3.automaticNameDelimiter,\n          automaticNameDelimiter = _ref3$automaticNameDe === void 0 ? undefined : _ref3$automaticNameDe;\n      var _ref4$minSize = _ref4.minSize,\n          defaultMinSize = _ref4$minSize === void 0 ? undefined : _ref4$minSize,\n          _ref4$maxSize = _ref4.maxSize,\n          defaultMaxSize = _ref4$maxSize === void 0 ? undefined : _ref4$maxSize,\n          _ref4$automaticNameDe = _ref4.automaticNameDelimiter,\n          defaultAutomaticNameDelimiter = _ref4$automaticNameDe === void 0 ? undefined : _ref4$automaticNameDe;\n      return {\n        minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n        maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n        automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n      };\n    }\n  }, {\n    key: \"normalizeCacheGroups\",\n    value: function normalizeCacheGroups(_ref5) {\n      var cacheGroups = _ref5.cacheGroups,\n          name = _ref5.name,\n          automaticNameDelimiter = _ref5.automaticNameDelimiter,\n          automaticNameMaxLength = _ref5.automaticNameMaxLength;\n\n      if (typeof cacheGroups === \"function\") {\n        // TODO webpack 5 remove this\n        if (cacheGroups.length !== 1) {\n          return function (module) {\n            return cacheGroups(module, module.getChunks());\n          };\n        }\n\n        return cacheGroups;\n      }\n\n      if (cacheGroups && typeof cacheGroups === \"object\") {\n        var _fn2 = function _fn2(module) {\n          var results;\n\n          for (var _i = 0, _Object$keys = Object.keys(cacheGroups); _i < _Object$keys.length; _i++) {\n            var key = _Object$keys[_i];\n            var option = cacheGroups[key];\n            if (option === false) continue;\n\n            if (option instanceof RegExp || typeof option === \"string\") {\n              option = {\n                test: option\n              };\n            }\n\n            if (typeof option === \"function\") {\n              var result = option(module);\n\n              if (result) {\n                if (results === undefined) results = [];\n\n                var _iterator31 = _createForOfIteratorHelper(Array.isArray(result) ? result : [result]),\n                    _step31;\n\n                try {\n                  var _loop3 = function _loop3() {\n                    var r = _step31.value;\n                    var result = Object.assign({\n                      key: key\n                    }, r);\n                    if (result.name) result.getName = function () {\n                      return result.name;\n                    };\n\n                    if (result.chunks) {\n                      result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                    }\n\n                    results.push(result);\n                  };\n\n                  for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                    _loop3();\n                  }\n                } catch (err) {\n                  _iterator31.e(err);\n                } finally {\n                  _iterator31.f();\n                }\n              }\n            } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n              if (results === undefined) results = [];\n              results.push({\n                key: key,\n                priority: option.priority,\n                getName: SplitChunksPlugin.normalizeName({\n                  name: option.name || name,\n                  automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                  automaticNamePrefix: option.automaticNamePrefix,\n                  automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength\n                }) || function () {},\n                chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n                enforce: option.enforce,\n                minSize: option.minSize,\n                enforceSizeThreshold: option.enforceSizeThreshold,\n                maxSize: option.maxSize,\n                minChunks: option.minChunks,\n                maxAsyncRequests: option.maxAsyncRequests,\n                maxInitialRequests: option.maxInitialRequests,\n                filename: option.filename,\n                reuseExistingChunk: option.reuseExistingChunk\n              });\n            }\n          }\n\n          return results;\n        };\n\n        return _fn2;\n      }\n\n      var fn = function fn() {};\n\n      return fn;\n    }\n  }, {\n    key: \"checkTest\",\n    value: function checkTest(test, module) {\n      if (test === undefined) return true;\n\n      if (typeof test === \"function\") {\n        if (test.length !== 1) {\n          return test(module, module.getChunks());\n        }\n\n        return test(module);\n      }\n\n      if (typeof test === \"boolean\") return test;\n\n      if (typeof test === \"string\") {\n        if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n          return true;\n        }\n\n        var _iterator32 = _createForOfIteratorHelper(module.chunksIterable),\n            _step32;\n\n        try {\n          for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n            var chunk = _step32.value;\n\n            if (chunk.name && chunk.name.startsWith(test)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator32.e(err);\n        } finally {\n          _iterator32.f();\n        }\n\n        return false;\n      }\n\n      if (test instanceof RegExp) {\n        if (module.nameForCondition && test.test(module.nameForCondition())) {\n          return true;\n        }\n\n        var _iterator33 = _createForOfIteratorHelper(module.chunksIterable),\n            _step33;\n\n        try {\n          for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n            var _chunk7 = _step33.value;\n\n            if (_chunk7.name && test.test(_chunk7.name)) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _iterator33.e(err);\n        } finally {\n          _iterator33.f();\n        }\n\n        return false;\n      }\n\n      return false;\n    }\n  }]);\n\n  return SplitChunksPlugin;\n}();","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"names":["crypto","require","SortableSet","GraphHelpers","isSubset","deterministicGrouping","MinMaxSizeWarning","contextify","deterministicGroupingForModules","hashFilename","name","createHash","update","digest","slice","sortByIdentifier","a","b","identifier","getRequests","chunk","requests","groupsIterable","chunkGroup","Math","max","chunks","length","getModulesSize","modules","sum","m","size","isOverlap","item","has","compareEntries","diffPriority","cacheGroup","priority","diffCount","aSizeReduce","bSizeReduce","diffSizeReduce","indexDiff","cacheGroupIndex","modulesA","modulesB","diff","sort","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","compareNumbers","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","module","exports","options","SplitChunksPlugin","normalizeOptions","compiler","hooks","thisCompilation","tap","compilation","alreadyOptimized","unseal","optimizeChunksAdvanced","indexMap","Map","index","set","getKey","Array","from","c","get","join","chunkSetsInGraph","chunksKey","chunksIterable","Set","chunkSetsByCount","values","chunksSet","count","array","undefined","push","combinationsCache","getCombinations","key","setArray","selectedChunksCacheByChunksSet","WeakMap","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","minChunks","getName","info","reuseableChunks","chunksKeys","add","cacheGroups","getCacheGroups","isArray","combs","cacheGroupSource","minSize","enforce","enforceSizeThreshold","chunksFilter","minSizeForMaxSize","maxSize","maxAsyncRequests","Infinity","maxInitialRequests","filename","automaticNameDelimiter","reuseExistingChunk","_validateSize","_conditionalEnforce","chunkCombination","pair","delete","maxSizeQueueMap","bestEntryKey","bestEntry","chunkName","newChunk","isReused","outer","getNumberOfModules","hasEntryModule","containsModule","filter","enforced","usedChunks","Number","isFinite","maxRequests","isOnlyInitial","min","chunksArr","addChunk","split","chunkReason","entrypoint","entrypoints","remove","entryModule","Error","filenameTemplate","chunkCondition","connectChunkAndModule","removeModule","rewriteChunkInReasons","oldMaxSizeSettings","keys","concat","oldSize","incorrectMinMaxSizeSet","fallbackCacheGroup","warningKey","warnings","results","items","modulesIterable","ident","context","nameForCondition","replace","fullKey","getSize","i","group","hidePathInfo","newPart","normalizeChunksFilter","normalizeCacheGroups","automaticNameMaxLength","normalizeFallbackCacheGroup","automaticNamePrefix","cache","fn","cacheEntry","names","map","every","Boolean","prefix","namePrefix","hashedFilename","sliceLength","defaultMinSize","defaultMaxSize","defaultAutomaticNameDelimiter","getChunks","Object","option","RegExp","test","result","r","assign","checkTest","normalizeName","startsWith"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,WAAW,GAAGD,OAAO,CAAC,qBAAD,CAA3B;;AACA,IAAME,YAAY,GAAGF,OAAO,CAAC,iBAAD,CAA5B;;AACA,eAAqBA,OAAO,CAAC,oBAAD,CAA5B;AAAA,IAAQG,QAAR,YAAQA,QAAR;;AACA,IAAMC,qBAAqB,GAAGJ,OAAO,CAAC,+BAAD,CAArC;;AACA,IAAMK,iBAAiB,GAAGL,OAAO,CAAC,qBAAD,CAAjC;;AACA,IAAMM,UAAU,GAAGN,OAAO,CAAC,oBAAD,CAAP,CAA8BM,UAAjD;AAEA;;AACA;;AACA;;AACA;;AACA;;;AAEA,IAAMC,+BAA+B;AAAG;AAA8GH,qBAAtJ;;AAEA,IAAMI,YAAY,GAAG,SAAfA,YAAe,CAAAC,IAAI,EAAI;AAC5B,SAAOV,MAAM,CACXW,UADK,CACM,KADN,EAELC,MAFK,CAEEF,IAFF,EAGLG,MAHK,CAGE,KAHF,EAILC,KAJK,CAIC,CAJD,EAII,CAJJ,CAAP;AAKA,CAND;;AAQA,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,CAAD,EAAIC,CAAJ,EAAU;AAClC,MAAID,CAAC,CAACE,UAAF,KAAiBD,CAAC,CAACC,UAAF,EAArB,EAAqC,OAAO,CAAP;AACrC,MAAIF,CAAC,CAACE,UAAF,KAAiBD,CAAC,CAACC,UAAF,EAArB,EAAqC,OAAO,CAAC,CAAR;AACrC,SAAO,CAAP;AACA,CAJD;;AAMA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAAAC,KAAK,EAAI;AAC5B,MAAIC,QAAQ,GAAG,CAAf;;AAD4B,6CAEHD,KAAK,CAACE,cAFH;AAAA;;AAAA;AAE5B,wDAA+C;AAAA,UAApCC,UAAoC;AAC9CF,MAAAA,QAAQ,GAAGG,IAAI,CAACC,GAAL,CAASJ,QAAT,EAAmBE,UAAU,CAACG,MAAX,CAAkBC,MAArC,CAAX;AACA;AAJ2B;AAAA;AAAA;AAAA;AAAA;;AAK5B,SAAON,QAAP;AACA,CAND;;AAQA,IAAMO,cAAc,GAAG,SAAjBA,cAAiB,CAAAC,OAAO,EAAI;AACjC,MAAIC,GAAG,GAAG,CAAV;;AADiC,8CAEjBD,OAFiB;AAAA;;AAAA;AAEjC,2DAAyB;AAAA,UAAdE,CAAc;AACxBD,MAAAA,GAAG,IAAIC,CAAC,CAACC,IAAF,EAAP;AACA;AAJgC;AAAA;AAAA;AAAA;AAAA;;AAKjC,SAAOF,GAAP;AACA,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,SAAS,GAAG,SAAZA,SAAY,CAACjB,CAAD,EAAIC,CAAJ,EAAU;AAAA,8CACRD,CADQ;AAAA;;AAAA;AAC3B,2DAAsB;AAAA,UAAXkB,IAAW;AACrB,UAAIjB,CAAC,CAACkB,GAAF,CAAMD,IAAN,CAAJ,EAAiB,OAAO,IAAP;AACjB;AAH0B;AAAA;AAAA;AAAA;AAAA;;AAI3B,SAAO,KAAP;AACA,CALD;;AAOA,IAAME,cAAc,GAAG,SAAjBA,cAAiB,CAACpB,CAAD,EAAIC,CAAJ,EAAU;AAChC;AACA,MAAMoB,YAAY,GAAGrB,CAAC,CAACsB,UAAF,CAAaC,QAAb,GAAwBtB,CAAC,CAACqB,UAAF,CAAaC,QAA1D;AACA,MAAIF,YAAJ,EAAkB,OAAOA,YAAP,CAHc,CAIhC;;AACA,MAAMG,SAAS,GAAGxB,CAAC,CAACU,MAAF,CAASM,IAAT,GAAgBf,CAAC,CAACS,MAAF,CAASM,IAA3C;AACA,MAAIQ,SAAJ,EAAe,OAAOA,SAAP,CANiB,CAOhC;;AACA,MAAMC,WAAW,GAAGzB,CAAC,CAACgB,IAAF,IAAUhB,CAAC,CAACU,MAAF,CAASM,IAAT,GAAgB,CAA1B,CAApB;AACA,MAAMU,WAAW,GAAGzB,CAAC,CAACe,IAAF,IAAUf,CAAC,CAACS,MAAF,CAASM,IAAT,GAAgB,CAA1B,CAApB;AACA,MAAMW,cAAc,GAAGF,WAAW,GAAGC,WAArC;AACA,MAAIC,cAAJ,EAAoB,OAAOA,cAAP,CAXY,CAYhC;;AACA,MAAMC,SAAS,GAAG5B,CAAC,CAAC6B,eAAF,GAAoB5B,CAAC,CAAC4B,eAAxC;AACA,MAAID,SAAJ,EAAe,OAAOA,SAAP,CAdiB,CAehC;;AACA,MAAME,QAAQ,GAAG9B,CAAC,CAACa,OAAnB;AACA,MAAMkB,QAAQ,GAAG9B,CAAC,CAACY,OAAnB;AACA,MAAMmB,IAAI,GAAGF,QAAQ,CAACd,IAAT,GAAgBe,QAAQ,CAACf,IAAtC;AACA,MAAIgB,IAAJ,EAAU,OAAOA,IAAP,CAnBsB,CAoBhC;;AACAF,EAAAA,QAAQ,CAACG,IAAT;AACAF,EAAAA,QAAQ,CAACE,IAAT;AACA,MAAMC,EAAE,GAAGJ,QAAQ,CAACK,MAAM,CAACC,QAAR,CAAR,EAAX;AACA,MAAMC,EAAE,GAAGN,QAAQ,CAACI,MAAM,CAACC,QAAR,CAAR,EAAX,CAxBgC,CAyBhC;;AACA,SAAO,IAAP,EAAa;AACZ,QAAME,KAAK,GAAGJ,EAAE,CAACK,IAAH,EAAd;AACA,QAAMC,KAAK,GAAGH,EAAE,CAACE,IAAH,EAAd;AACA,QAAID,KAAK,CAACG,IAAV,EAAgB,OAAO,CAAP;AAChB,QAAMC,iBAAiB,GAAGJ,KAAK,CAACK,KAAN,CAAYzC,UAAZ,EAA1B;AACA,QAAM0C,iBAAiB,GAAGJ,KAAK,CAACG,KAAN,CAAYzC,UAAZ,EAA1B;AACA,QAAIwC,iBAAiB,GAAGE,iBAAxB,EAA2C,OAAO,CAAC,CAAR;AAC3C,QAAIF,iBAAiB,GAAGE,iBAAxB,EAA2C,OAAO,CAAP;AAC3C;AACD,CAnCD;;AAqCA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,CAAC7C,CAAD,EAAIC,CAAJ;AAAA,SAAUD,CAAC,GAAGC,CAAd;AAAA,CAAvB;;AAEA,IAAM6C,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAA1C,KAAK;AAAA,SAAIA,KAAK,CAAC2C,YAAN,EAAJ;AAAA,CAAlC;;AACA,IAAMC,kBAAkB,GAAG,SAArBA,kBAAqB,CAAA5C,KAAK;AAAA,SAAI,CAACA,KAAK,CAAC2C,YAAN,EAAL;AAAA,CAAhC;;AACA,IAAME,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAA7C,KAAK;AAAA,SAAI,IAAJ;AAAA,CAA9B;;AAEA8C,MAAM,CAACC,OAAP;AACC,6BAAYC,OAAZ,EAAqB;AAAA;;AACpB,SAAKA,OAAL,GAAeC,iBAAiB,CAACC,gBAAlB,CAAmCF,OAAnC,CAAf;AACA;;AAHF;AAAA;AAAA;AA+OC;AACD;AACA;AACA;AACC,mBAAMG,QAAN,EAAgB;AAAA;;AACfA,MAAAA,QAAQ,CAACC,KAAT,CAAeC,eAAf,CAA+BC,GAA/B,CAAmC,mBAAnC,EAAwD,UAAAC,WAAW,EAAI;AACtE,YAAIC,gBAAgB,GAAG,KAAvB;AACAD,QAAAA,WAAW,CAACH,KAAZ,CAAkBK,MAAlB,CAAyBH,GAAzB,CAA6B,mBAA7B,EAAkD,YAAM;AACvDE,UAAAA,gBAAgB,GAAG,KAAnB;AACA,SAFD;AAGAD,QAAAA,WAAW,CAACH,KAAZ,CAAkBM,sBAAlB,CAAyCJ,GAAzC,CACC,mBADD,EAEC,UAAAhD,MAAM,EAAI;AACT,cAAIkD,gBAAJ,EAAsB;AACtBA,UAAAA,gBAAgB,GAAG,IAAnB,CAFS,CAGT;;AACA,cAAMG,QAAQ,GAAG,IAAIC,GAAJ,EAAjB;AACA,cAAIC,KAAK,GAAG,CAAZ;;AALS,sDAMWvD,MANX;AAAA;;AAAA;AAMT,mEAA4B;AAAA,kBAAjBN,KAAiB;AAC3B2D,cAAAA,QAAQ,CAACG,GAAT,CAAa9D,KAAb,EAAoB6D,KAAK,EAAzB;AACA;AARQ;AAAA;AAAA;AAAA;AAAA;;AAST,cAAME,MAAM,GAAG,SAATA,MAAS,CAAAzD,MAAM,EAAI;AACxB,mBAAO0D,KAAK,CAACC,IAAN,CAAW3D,MAAX,EAAmB,UAAA4D,CAAC;AAAA,qBAAIP,QAAQ,CAACQ,GAAT,CAAaD,CAAb,CAAJ;AAAA,aAApB,EACLrC,IADK,CACAY,cADA,EAEL2B,IAFK,EAAP;AAGA,WAJD;AAKA;;;AACA,cAAMC,gBAAgB,GAAG,IAAIT,GAAJ,EAAzB;;AAfS,sDAgBYL,WAAW,CAAC9C,OAhBxB;AAAA;;AAAA;AAgBT,mEAA0C;AAAA,kBAA/BqC,OAA+B;AACzC,kBAAMwB,SAAS,GAAGP,MAAM,CAACjB,OAAM,CAACyB,cAAR,CAAxB;;AACA,kBAAI,CAACF,gBAAgB,CAACtD,GAAjB,CAAqBuD,SAArB,CAAL,EAAsC;AACrCD,gBAAAA,gBAAgB,CAACP,GAAjB,CAAqBQ,SAArB,EAAgC,IAAIE,GAAJ,CAAQ1B,OAAM,CAACyB,cAAf,CAAhC;AACA;AACD,aArBQ,CAuBT;AACA;AACA;;AACA;;AA1BS;AAAA;AAAA;AAAA;AAAA;;AA2BT,cAAME,gBAAgB,GAAG,IAAIb,GAAJ,EAAzB;;AA3BS,sDA4BeS,gBAAgB,CAACK,MAAjB,EA5Bf;AAAA;;AAAA;AA4BT,mEAAmD;AAAA,kBAAxCC,SAAwC;AAClD,kBAAMC,KAAK,GAAGD,SAAS,CAAC/D,IAAxB;AACA,kBAAIiE,KAAK,GAAGJ,gBAAgB,CAACN,GAAjB,CAAqBS,KAArB,CAAZ;;AACA,kBAAIC,KAAK,KAAKC,SAAd,EAAyB;AACxBD,gBAAAA,KAAK,GAAG,EAAR;AACAJ,gBAAAA,gBAAgB,CAACX,GAAjB,CAAqBc,KAArB,EAA4BC,KAA5B;AACA;;AACDA,cAAAA,KAAK,CAACE,IAAN,CAAWJ,SAAX;AACA,aApCQ,CAsCT;;AAtCS;AAAA;AAAA;AAAA;AAAA;;AAuCT,cAAMK,iBAAiB,GAAG,IAAIpB,GAAJ,EAA1B,CAvCS,CAuC4B;;AAErC,cAAMqB,eAAe,GAAG,SAAlBA,eAAkB,CAAAC,GAAG,EAAI;AAC9B,gBAAMP,SAAS,GAAGN,gBAAgB,CAACF,GAAjB,CAAqBe,GAArB,CAAlB;AACA,gBAAIL,KAAK,GAAG,CAACF,SAAD,CAAZ;;AACA,gBAAIA,SAAS,CAAC/D,IAAV,GAAiB,CAArB,EAAwB;AAAA,0DACS6D,gBADT;AAAA;;AAAA;AACvB,uEAAkD;AAAA;AAAA,sBAAtCG,KAAsC;AAAA,sBAA/BO,QAA+B;;AACjD;AACA,sBAAIP,KAAK,GAAGD,SAAS,CAAC/D,IAAtB,EAA4B;AAAA,gEACTuE,QADS;AAAA;;AAAA;AAC3B,6EAA4B;AAAA,4BAAjBrB,GAAiB;;AAC3B,4BAAI9E,QAAQ,CAAC2F,SAAD,EAAYb,GAAZ,CAAZ,EAA8B;AAC7Be,0BAAAA,KAAK,CAACE,IAAN,CAAWjB,GAAX;AACA;AACD;AAL0B;AAAA;AAAA;AAAA;AAAA;AAM3B;AACD;AAVsB;AAAA;AAAA;AAAA;AAAA;AAWvB;;AACD,mBAAOe,KAAP;AACA,WAhBD;AAkBA;AACL;AACA;AACA;AACA;;AAEK;AACL;AACA;;AAEK;;;AACA,cAAMO,8BAA8B,GAAG,IAAIC,OAAJ,EAAvC;AAEA;AACL;AACA;AACA;AACA;AACA;AACA;;AACK,cAAMC,iBAAiB,GAAG,SAApBA,iBAAoB,CAAChF,MAAD,EAASiF,WAAT,EAAyB;AAClD,gBAAIC,KAAK,GAAGJ,8BAA8B,CAACjB,GAA/B,CAAmC7D,MAAnC,CAAZ;;AACA,gBAAIkF,KAAK,KAAKV,SAAd,EAAyB;AACxBU,cAAAA,KAAK,GAAG,IAAIH,OAAJ,EAAR;AACAD,cAAAA,8BAA8B,CAACtB,GAA/B,CAAmCxD,MAAnC,EAA2CkF,KAA3C;AACA;AACD;;;AACA,gBAAIC,MAAM,GAAGD,KAAK,CAACrB,GAAN,CAAUoB,WAAV,CAAb;;AACA,gBAAIE,MAAM,KAAKX,SAAf,EAA0B;AACzB;AACA,kBAAMY,cAAc,GAAG,EAAvB;;AAFyB,0DAGLpF,MAHK;AAAA;;AAAA;AAGzB,uEAA4B;AAAA,sBAAjBN,KAAiB;AAC3B,sBAAIuF,WAAW,CAACvF,KAAD,CAAf,EAAwB0F,cAAc,CAACX,IAAf,CAAoB/E,KAApB;AACxB;AALwB;AAAA;AAAA;AAAA;AAAA;;AAMzByF,cAAAA,MAAM,GAAG;AACRnF,gBAAAA,MAAM,EAAEoF,cADA;AAERR,gBAAAA,GAAG,EAAEnB,MAAM,CAAC2B,cAAD;AAFH,eAAT;AAIAF,cAAAA,KAAK,CAAC1B,GAAN,CAAUyB,WAAV,EAAuBE,MAAvB;AACA;;AACD,mBAAOA,MAAP;AACA,WArBD;AAuBA;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEK;AACA;;AACA;;;AACA,cAAME,aAAa,GAAG,IAAI/B,GAAJ,EAAtB;AAEA;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AACK,cAAMgC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAChC1E,UADgC,EAEhCO,eAFgC,EAGhCiE,cAHgC,EAIhCG,iBAJgC,EAKhC/C,MALgC,EAM5B;AACJ;AACA,gBAAI4C,cAAc,CAACnF,MAAf,GAAwBW,UAAU,CAAC4E,SAAvC,EAAkD,OAF9C,CAGJ;;AACA,gBAAMxG,IAAI,GAAG4B,UAAU,CAAC6E,OAAX,CACZjD,MADY,EAEZ4C,cAFY,EAGZxE,UAAU,CAACgE,GAHC,CAAb,CAJI,CASJ;AACA;AACA;AACA;;AACA,gBAAMA,GAAG,GACRhE,UAAU,CAACgE,GAAX,IACC5F,IAAI,mBAAYA,IAAZ,sBAAgCuG,iBAAhC,CADL,CADD,CAbI,CAgBJ;;AACA,gBAAIG,IAAI,GAAGL,aAAa,CAACxB,GAAd,CAAkBe,GAAlB,CAAX;;AACA,gBAAIc,IAAI,KAAKlB,SAAb,EAAwB;AACvBa,cAAAA,aAAa,CAAC7B,GAAd,CACCoB,GADD,EAEEc,IAAI,GAAG;AACPvF,gBAAAA,OAAO,EAAE,IAAI3B,WAAJ,CAAgBgG,SAAhB,EAA2BnF,gBAA3B,CADF;AAEPuB,gBAAAA,UAAU,EAAVA,UAFO;AAGPO,gBAAAA,eAAe,EAAfA,eAHO;AAIPnC,gBAAAA,IAAI,EAAJA,IAJO;AAKPsB,gBAAAA,IAAI,EAAE,CALC;AAMPN,gBAAAA,MAAM,EAAE,IAAIkE,GAAJ,EAND;AAOPyB,gBAAAA,eAAe,EAAE,IAAIzB,GAAJ,EAPV;AAQP0B,gBAAAA,UAAU,EAAE,IAAI1B,GAAJ;AARL,eAFT;AAaA;;AACDwB,YAAAA,IAAI,CAACvF,OAAL,CAAa0F,GAAb,CAAiBrD,MAAjB;AACAkD,YAAAA,IAAI,CAACpF,IAAL,IAAakC,MAAM,CAAClC,IAAP,EAAb;;AACA,gBAAI,CAACoF,IAAI,CAACE,UAAL,CAAgBnF,GAAhB,CAAoB8E,iBAApB,CAAL,EAA6C;AAC5CG,cAAAA,IAAI,CAACE,UAAL,CAAgBC,GAAhB,CAAoBN,iBAApB;;AAD4C,2DAExBH,cAFwB;AAAA;;AAAA;AAE5C,0EAAoC;AAAA,sBAAzB1F,KAAyB;AACnCgG,kBAAAA,IAAI,CAAC1F,MAAL,CAAY6F,GAAZ,CAAgBnG,KAAhB;AACA;AAJ2C;AAAA;AAAA;AAAA;AAAA;AAK5C;AACD,WA/CD,CA/HS,CAgLT;;;AAhLS,uDAiLYuD,WAAW,CAAC9C,OAjLxB;AAAA;;AAAA;AAiLT,sEAA0C;AAAA,kBAA/BqC,QAA+B;;AACzC;AACA,kBAAIsD,WAAW,GAAG,KAAI,CAACpD,OAAL,CAAaqD,cAAb,CAA4BvD,QAA5B,CAAlB;;AACA,kBAAI,CAACkB,KAAK,CAACsC,OAAN,CAAcF,WAAd,CAAD,IAA+BA,WAAW,CAAC7F,MAAZ,KAAuB,CAA1D,EAA6D;AAC5D;AACA,eALwC,CAOzC;;;AACA,kBAAM+D,UAAS,GAAGP,MAAM,CAACjB,QAAM,CAACyB,cAAR,CAAxB;;AACA,kBAAIgC,KAAK,GAAGvB,iBAAiB,CAACb,GAAlB,CAAsBG,UAAtB,CAAZ;;AACA,kBAAIiC,KAAK,KAAKzB,SAAd,EAAyB;AACxByB,gBAAAA,KAAK,GAAGtB,eAAe,CAACX,UAAD,CAAvB;AACAU,gBAAAA,iBAAiB,CAAClB,GAAlB,CAAsBQ,UAAtB,EAAiCiC,KAAjC;AACA;;AAED,kBAAI9E,eAAe,GAAG,CAAtB;;AAfyC,2DAgBV2E,WAhBU;AAAA;;AAAA;AAgBzC,0EAA4C;AAAA,sBAAjCI,gBAAiC;AAC3C,sBAAMC,OAAO,GACZD,gBAAgB,CAACC,OAAjB,KAA6B3B,SAA7B,GACG0B,gBAAgB,CAACC,OADpB,GAEGD,gBAAgB,CAACE,OAAjB,GACA,CADA,GAEA,KAAI,CAAC1D,OAAL,CAAayD,OALjB;AAMA,sBAAME,oBAAoB,GACzBH,gBAAgB,CAACG,oBAAjB,KAA0C7B,SAA1C,GACG0B,gBAAgB,CAACG,oBADpB,GAEGH,gBAAgB,CAACE,OAAjB,GACA,CADA,GAEA,KAAI,CAAC1D,OAAL,CAAa2D,oBALjB;AAMA,sBAAMzF,UAAU,GAAG;AAClBgE,oBAAAA,GAAG,EAAEsB,gBAAgB,CAACtB,GADJ;AAElB/D,oBAAAA,QAAQ,EAAEqF,gBAAgB,CAACrF,QAAjB,IAA6B,CAFrB;AAGlByF,oBAAAA,YAAY,EACXJ,gBAAgB,CAACI,YAAjB,IAAiC,KAAI,CAAC5D,OAAL,CAAa4D,YAJ7B;AAKlBH,oBAAAA,OAAO,EAAPA,OALkB;AAMlBI,oBAAAA,iBAAiB,EAChBL,gBAAgB,CAACC,OAAjB,KAA6B3B,SAA7B,GACG0B,gBAAgB,CAACC,OADpB,GAEG,KAAI,CAACzD,OAAL,CAAayD,OATC;AAUlBE,oBAAAA,oBAAoB,EAApBA,oBAVkB;AAWlBG,oBAAAA,OAAO,EACNN,gBAAgB,CAACM,OAAjB,KAA6BhC,SAA7B,GACG0B,gBAAgB,CAACM,OADpB,GAEGN,gBAAgB,CAACE,OAAjB,GACA,CADA,GAEA,KAAI,CAAC1D,OAAL,CAAa8D,OAhBC;AAiBlBhB,oBAAAA,SAAS,EACRU,gBAAgB,CAACV,SAAjB,KAA+BhB,SAA/B,GACG0B,gBAAgB,CAACV,SADpB,GAEGU,gBAAgB,CAACE,OAAjB,GACA,CADA,GAEA,KAAI,CAAC1D,OAAL,CAAa8C,SAtBC;AAuBlBiB,oBAAAA,gBAAgB,EACfP,gBAAgB,CAACO,gBAAjB,KAAsCjC,SAAtC,GACG0B,gBAAgB,CAACO,gBADpB,GAEGP,gBAAgB,CAACE,OAAjB,GACAM,QADA,GAEA,KAAI,CAAChE,OAAL,CAAa+D,gBA5BC;AA6BlBE,oBAAAA,kBAAkB,EACjBT,gBAAgB,CAACS,kBAAjB,KAAwCnC,SAAxC,GACG0B,gBAAgB,CAACS,kBADpB,GAEGT,gBAAgB,CAACE,OAAjB,GACAM,QADA,GAEA,KAAI,CAAChE,OAAL,CAAaiE,kBAlCC;AAmClBlB,oBAAAA,OAAO,EACNS,gBAAgB,CAACT,OAAjB,KAA6BjB,SAA7B,GACG0B,gBAAgB,CAACT,OADpB,GAEG,KAAI,CAAC/C,OAAL,CAAa+C,OAtCC;AAuClBmB,oBAAAA,QAAQ,EACPV,gBAAgB,CAACU,QAAjB,KAA8BpC,SAA9B,GACG0B,gBAAgB,CAACU,QADpB,GAEG,KAAI,CAAClE,OAAL,CAAakE,QA1CC;AA2ClBC,oBAAAA,sBAAsB,EACrBX,gBAAgB,CAACW,sBAAjB,KAA4CrC,SAA5C,GACG0B,gBAAgB,CAACW,sBADpB,GAEG,KAAI,CAACnE,OAAL,CAAamE,sBA9CC;AA+ClBC,oBAAAA,kBAAkB,EAAEZ,gBAAgB,CAACY,kBA/CnB;AAgDlBC,oBAAAA,aAAa,EAAEZ,OAAO,GAAG,CAhDP;AAiDlBa,oBAAAA,mBAAmB,EAAEX,oBAAoB,GAAG;AAjD1B,mBAAnB,CAb2C,CAgE3C;;AAhE2C,+DAiEZJ,KAjEY;AAAA;;AAAA;AAiE3C,8EAAsC;AAAA,0BAA3BgB,gBAA2B;AACrC;AACA,0BAAIA,gBAAgB,CAAC3G,IAAjB,GAAwBM,UAAU,CAAC4E,SAAvC,EAAkD,SAFb,CAGrC;;AACA,+CAGIR,iBAAiB,CACpBiC,gBADoB,EAEpBrG,UAAU,CAAC0F,YAFS,CAHrB;AAAA,0BACSlB,cADT,sBACCpF,MADD;AAAA,0BAEMuF,iBAFN,sBAECX,GAFD;;AAQAU,sBAAAA,wBAAwB,CACvB1E,UADuB,EAEvBO,eAFuB,EAGvBiE,cAHuB,EAIvBG,iBAJuB,EAKvB/C,QALuB,CAAxB;AAOA;AApF0C;AAAA;AAAA;AAAA;AAAA;;AAqF3CrB,kBAAAA,eAAe;AACf;AAtGwC;AAAA;AAAA;AAAA;AAAA;AAuGzC,aAxRQ,CA0RT;;AA1RS;AAAA;AAAA;AAAA;AAAA;;AAAA,uDA2RUkE,aA3RV;AAAA;;AAAA;AA2RT,sEAAkC;AAAA,kBAAvB6B,IAAuB;AACjC,kBAAMxB,IAAI,GAAGwB,IAAI,CAAC,CAAD,CAAjB;;AACA,kBACCxB,IAAI,CAAC9E,UAAL,CAAgBmG,aAAhB,IACArB,IAAI,CAACpF,IAAL,GAAYoF,IAAI,CAAC9E,UAAL,CAAgBuF,OAF7B,EAGE;AACDd,gBAAAA,aAAa,CAAC8B,MAAd,CAAqBD,IAAI,CAAC,CAAD,CAAzB;AACA;AACD;AAED;;AArSS;AAAA;AAAA;AAAA;AAAA;;AAsST,cAAME,eAAe,GAAG,IAAI9D,GAAJ,EAAxB;;AAtSS;AAySR;AACA,gBAAI+D,YAAY,SAAhB;AACA,gBAAIC,SAAS,SAAb;;AA3SQ,yDA4SWjC,aA5SX;AAAA;;AAAA;AA4SR,wEAAkC;AAAA,oBAAvB6B,KAAuB;AACjC,oBAAMtC,GAAG,GAAGsC,KAAI,CAAC,CAAD,CAAhB;AACA,oBAAMxB,KAAI,GAAGwB,KAAI,CAAC,CAAD,CAAjB;;AACA,oBAAII,SAAS,KAAK9C,SAAlB,EAA6B;AAC5B8C,kBAAAA,SAAS,GAAG5B,KAAZ;AACA2B,kBAAAA,YAAY,GAAGzC,GAAf;AACA,iBAHD,MAGO,IAAIlE,cAAc,CAAC4G,SAAD,EAAY5B,KAAZ,CAAd,GAAkC,CAAtC,EAAyC;AAC/C4B,kBAAAA,SAAS,GAAG5B,KAAZ;AACA2B,kBAAAA,YAAY,GAAGzC,GAAf;AACA;AACD;AAtTO;AAAA;AAAA;AAAA;AAAA;;AAwTR,gBAAMpE,IAAI,GAAG8G,SAAb;AACAjC,YAAAA,aAAa,CAAC8B,MAAd,CAAqBE,YAArB;AAEA,gBAAIE,SAAS,GAAG/G,IAAI,CAACxB,IAArB,CA3TQ,CA4TR;;AACA;;AACA,gBAAIwI,QAAQ,SAAZ,CA9TQ,CA+TR;;AACA,gBAAIC,QAAQ,GAAG,KAAf;;AACA,gBAAIjH,IAAI,CAACI,UAAL,CAAgBkG,kBAApB,EAAwC;AAAA,2DACZtG,IAAI,CAACR,MADO;AAAA;;AAAA;AACvC0H,gBAAAA,KADuC,EAChC,0DAAiC;AAAA,sBAAtBhI,MAAsB;AACvC,sBAAIA,MAAK,CAACiI,kBAAN,OAA+BnH,IAAI,CAACL,OAAL,CAAaG,IAAhD,EAAsD;AACtD,sBAAIZ,MAAK,CAACkI,cAAN,EAAJ,EAA4B;;AAFW,+DAGlBpH,IAAI,CAACL,OAHa;AAAA;;AAAA;AAGvC,8EAAmC;AAAA,0BAAxBqC,QAAwB;AAClC,0BAAI,CAAC9C,MAAK,CAACmI,cAAN,CAAqBrF,QAArB,CAAL,EAAmC,SAASkF,KAAT;AACnC;AALsC;AAAA;AAAA;AAAA;AAAA;;AAMvC,sBAAI,CAACF,QAAD,IAAa,CAACA,QAAQ,CAACxI,IAA3B,EAAiC;AAChCwI,oBAAAA,QAAQ,GAAG9H,MAAX;AACA,mBAFD,MAEO,IACNA,MAAK,CAACV,IAAN,IACAU,MAAK,CAACV,IAAN,CAAWiB,MAAX,GAAoBuH,QAAQ,CAACxI,IAAT,CAAciB,MAF5B,EAGL;AACDuH,oBAAAA,QAAQ,GAAG9H,MAAX;AACA,mBALM,MAKA,IACNA,MAAK,CAACV,IAAN,IACAU,MAAK,CAACV,IAAN,CAAWiB,MAAX,KAAsBuH,QAAQ,CAACxI,IAAT,CAAciB,MADpC,IAEAP,MAAK,CAACV,IAAN,GAAawI,QAAQ,CAACxI,IAHhB,EAIL;AACDwI,oBAAAA,QAAQ,GAAG9H,MAAX;AACA;;AACD6H,kBAAAA,SAAS,GAAG/C,SAAZ;AACAiD,kBAAAA,QAAQ,GAAG,IAAX;AACA;AAvBsC;AAAA;AAAA;AAAA;AAAA;AAwBvC,aAzVO,CA0VR;;;AAEA,gBAAMrC,cAAc,GAAG1B,KAAK,CAACC,IAAN,CAAWnD,IAAI,CAACR,MAAhB,EAAwB8H,MAAxB,CAA+B,UAAApI,KAAK,EAAI;AAC9D;AACA,qBACC,CAAC,CAAC6H,SAAD,IAAc7H,KAAK,CAACV,IAAN,KAAeuI,SAA9B,KAA4C7H,KAAK,KAAK8H,QADvD;AAGA,aALsB,CAAvB;AAOA,gBAAMO,QAAQ,GACbvH,IAAI,CAACI,UAAL,CAAgBoG,mBAAhB,IACAxG,IAAI,CAACF,IAAL,IAAaE,IAAI,CAACI,UAAL,CAAgByF,oBAF9B,CAnWQ,CAuWR;;AACA,gBAAIjB,cAAc,CAACnF,MAAf,KAA0B,CAA9B,EAAiC;AAEjC,gBAAM+H,UAAU,GAAG,IAAI9D,GAAJ,CAAQkB,cAAR,CAAnB,CA1WQ,CA4WR;;AACA,gBACC,CAAC2C,QAAD,KACCE,MAAM,CAACC,QAAP,CAAgB1H,IAAI,CAACI,UAAL,CAAgB+F,kBAAhC,KACAsB,MAAM,CAACC,QAAP,CAAgB1H,IAAI,CAACI,UAAL,CAAgB6F,gBAAhC,CAFD,CADD,EAIE;AAAA,2DACmBuB,UADnB;AAAA;;AAAA;AACD,0EAAgC;AAAA,sBAArBtI,OAAqB;AAC/B;AACA,sBAAMyI,WAAW,GAAGzI,OAAK,CAAC0I,aAAN,KACjB5H,IAAI,CAACI,UAAL,CAAgB+F,kBADC,GAEjBjH,OAAK,CAAC2C,YAAN,KACAvC,IAAI,CAACuI,GAAL,CACA7H,IAAI,CAACI,UAAL,CAAgB+F,kBADhB,EAEAnG,IAAI,CAACI,UAAL,CAAgB6F,gBAFhB,CADA,GAKAjG,IAAI,CAACI,UAAL,CAAgB6F,gBAPnB;;AAQA,sBACCyB,QAAQ,CAACC,WAAD,CAAR,IACA1I,WAAW,CAACC,OAAD,CAAX,IAAsByI,WAFvB,EAGE;AACDH,oBAAAA,UAAU,CAACb,MAAX,CAAkBzH,OAAlB;AACA;AACD;AAjBA;AAAA;AAAA;AAAA;AAAA;AAkBD;;AAnYO,yDAqYmBsI,UArYnB;AAAA;;AAAA;AAqYRN,cAAAA,KArYQ,EAqYD,0DAAgC;AAAA,oBAArBhI,OAAqB;;AAAA,6DACjBc,IAAI,CAACL,OADY;AAAA;;AAAA;AACtC,4EAAmC;AAAA,wBAAxBqC,QAAwB;AAClC,wBAAI9C,OAAK,CAACmI,cAAN,CAAqBrF,QAArB,CAAJ,EAAkC,SAASkF,KAAT;AAClC;AAHqC;AAAA;AAAA;AAAA;AAAA;;AAItCM,gBAAAA,UAAU,CAACb,MAAX,CAAkBzH,OAAlB;AACA;AA1YO;AAAA;AAAA;AAAA;AAAA,cA4YR;AACA;;;AACA,gBAAIsI,UAAU,CAAC1H,IAAX,GAAkB8E,cAAc,CAACnF,MAArC,EAA6C;AAC5C,kBAAI+H,UAAU,CAAC1H,IAAX,IAAmBE,IAAI,CAACI,UAAL,CAAgB4E,SAAvC,EAAkD;AACjD,oBAAM8C,SAAS,GAAG5E,KAAK,CAACC,IAAN,CAAWqE,UAAX,CAAlB;;AADiD,6DAE5BxH,IAAI,CAACL,OAFuB;AAAA;;AAAA;AAEjD,4EAAmC;AAAA,wBAAxBqC,QAAwB;AAClC8C,oBAAAA,wBAAwB,CACvB9E,IAAI,CAACI,UADkB,EAEvBJ,IAAI,CAACW,eAFkB,EAGvBmH,SAHuB,EAIvB7E,MAAM,CAACuE,UAAD,CAJiB,EAKvBxF,QALuB,CAAxB;AAOA;AAVgD;AAAA;AAAA;AAAA;AAAA;AAWjD;;AACD;AACA,aA5ZO,CA8ZR;;;AACA,gBAAI,CAACiF,QAAL,EAAe;AACdD,cAAAA,QAAQ,GAAGvE,WAAW,CAACsF,QAAZ,CAAqBhB,SAArB,CAAX;AACA,aAjaO,CAkaR;;;AAlaQ,yDAmaYS,UAnaZ;AAAA;;AAAA;AAmaR,wEAAgC;AAAA,oBAArBtI,OAAqB;;AAC/B;AACAA,gBAAAA,OAAK,CAAC8I,KAAN,CAAYhB,QAAZ;AACA,eAtaO,CAwaR;;AAxaQ;AAAA;AAAA;AAAA;AAAA;;AAyaRA,YAAAA,QAAQ,CAACiB,WAAT,GAAuBhB,QAAQ,GAC5B,uBAD4B,GAE5B,aAFH;;AAGA,gBAAIjH,IAAI,CAACI,UAAL,CAAgBgE,GAApB,EAAyB;AACxB4C,cAAAA,QAAQ,CAACiB,WAAT,6BAA0CjI,IAAI,CAACI,UAAL,CAAgBgE,GAA1D;AACA;;AACD,gBAAI2C,SAAJ,EAAe;AACdC,cAAAA,QAAQ,CAACiB,WAAT,sBAAmClB,SAAnC,OADc,CAEd;;AACA,kBAAMmB,UAAU,GAAGzF,WAAW,CAAC0F,WAAZ,CAAwB9E,GAAxB,CAA4B0D,SAA5B,CAAnB;;AACA,kBAAImB,UAAJ,EAAgB;AACfzF,gBAAAA,WAAW,CAAC0F,WAAZ,CAAwBxB,MAAxB,CAA+BI,SAA/B;AACAmB,gBAAAA,UAAU,CAACE,MAAX;AACApB,gBAAAA,QAAQ,CAACqB,WAAT,GAAuBrE,SAAvB;AACA;AACD;;AACD,gBAAIhE,IAAI,CAACI,UAAL,CAAgBgG,QAApB,EAA8B;AAC7B,kBAAI,CAACY,QAAQ,CAACY,aAAT,EAAL,EAA+B;AAC9B,sBAAM,IAAIU,KAAJ,CACL,uGACC,sFADD,GAEC,iDAFD,2BAGkBtI,IAAI,CAACI,UAAL,CAAgBgE,GAHlC,MADK,CAAN;AAMA;;AACD4C,cAAAA,QAAQ,CAACuB,gBAAT,GAA4BvI,IAAI,CAACI,UAAL,CAAgBgG,QAA5C;AACA;;AACD,gBAAI,CAACa,QAAL,EAAe;AACd;AADc,2DAEOjH,IAAI,CAACL,OAFZ;AAAA;;AAAA;AAEd,0EAAmC;AAAA,sBAAxBqC,QAAwB;;AAClC,sBAAI,OAAOA,QAAM,CAACwG,cAAd,KAAiC,UAArC,EAAiD;AAChD,wBAAI,CAACxG,QAAM,CAACwG,cAAP,CAAsBxB,QAAtB,CAAL,EAAsC;AACtC,mBAHiC,CAIlC;;;AACA/I,kBAAAA,YAAY,CAACwK,qBAAb,CAAmCzB,QAAnC,EAA6ChF,QAA7C,EALkC,CAMlC;;AANkC,+DAOdwF,UAPc;AAAA;;AAAA;AAOlC,8EAAgC;AAAA,0BAArBtI,OAAqB;;AAC/BA,sBAAAA,OAAK,CAACwJ,YAAN,CAAmB1G,QAAnB;;AACAA,sBAAAA,QAAM,CAAC2G,qBAAP,CAA6BzJ,OAA7B,EAAoC,CAAC8H,QAAD,CAApC;AACA;AAViC;AAAA;AAAA;AAAA;AAAA;AAWlC;AAba;AAAA;AAAA;AAAA;AAAA;AAcd,aAdD,MAcO;AACN;AADM,2DAEehH,IAAI,CAACL,OAFpB;AAAA;;AAAA;AAEN,0EAAmC;AAAA,sBAAxBqC,QAAwB;;AAAA,+DACdwF,UADc;AAAA;;AAAA;AAClC,8EAAgC;AAAA,0BAArBtI,OAAqB;;AAC/BA,sBAAAA,OAAK,CAACwJ,YAAN,CAAmB1G,QAAnB;;AACAA,sBAAAA,QAAM,CAAC2G,qBAAP,CAA6BzJ,OAA7B,EAAoC,CAAC8H,QAAD,CAApC;AACA;AAJiC;AAAA;AAAA;AAAA;AAAA;AAKlC;AAPK;AAAA;AAAA;AAAA;AAAA;AAQN;;AAED,gBAAIhH,IAAI,CAACI,UAAL,CAAgB4F,OAAhB,GAA0B,CAA9B,EAAiC;AAChC,kBAAM4C,kBAAkB,GAAGhC,eAAe,CAACvD,GAAhB,CAAoB2D,QAApB,CAA3B;AACAJ,cAAAA,eAAe,CAAC5D,GAAhB,CAAoBgE,QAApB,EAA8B;AAC7BrB,gBAAAA,OAAO,EAAErG,IAAI,CAACC,GAAL,CACRqJ,kBAAkB,GAAGA,kBAAkB,CAACjD,OAAtB,GAAgC,CAD1C,EAER3F,IAAI,CAACI,UAAL,CAAgB2F,iBAFR,CADoB;AAK7BC,gBAAAA,OAAO,EAAE1G,IAAI,CAACuI,GAAL,CACRe,kBAAkB,GAAGA,kBAAkB,CAAC5C,OAAtB,GAAgCE,QAD1C,EAERlG,IAAI,CAACI,UAAL,CAAgB4F,OAFR,CALoB;AAS7BK,gBAAAA,sBAAsB,EAAErG,IAAI,CAACI,UAAL,CAAgBiG,sBATX;AAU7BwC,gBAAAA,IAAI,EAAED,kBAAkB,GACrBA,kBAAkB,CAACC,IAAnB,CAAwBC,MAAxB,CAA+B9I,IAAI,CAACI,UAAL,CAAgBgE,GAA/C,CADqB,GAErB,CAACpE,IAAI,CAACI,UAAL,CAAgBgE,GAAjB;AAZ0B,eAA9B;AAcA,aA5eO,CA8eR;;;AA9eQ,yDA+ekBS,aA/elB;AAAA;;AAAA;AA+eR,wEAAyC;AAAA;AAAA,oBAA7BT,IAA6B;AAAA,oBAAxBc,MAAwB;;AACxC,oBAAInF,SAAS,CAACmF,MAAI,CAAC1F,MAAN,EAAcgI,UAAd,CAAb,EAAwC;AACvC;AACA;AACA,sBAAMuB,OAAO,GAAG7D,MAAI,CAACvF,OAAL,CAAaG,IAA7B;;AAHuC,+DAIlBE,IAAI,CAACL,OAJa;AAAA;;AAAA;AAIvC,8EAAmC;AAAA,0BAAxBqC,QAAwB;;AAClCkD,sBAAAA,MAAI,CAACvF,OAAL,CAAagH,MAAb,CAAoB3E,QAApB;AACA;AANsC;AAAA;AAAA;AAAA;AAAA;;AAOvC,sBAAIkD,MAAI,CAACvF,OAAL,CAAaG,IAAb,KAAsBiJ,OAA1B,EAAmC;AAClC,wBAAI7D,MAAI,CAACvF,OAAL,CAAaG,IAAb,KAAsB,CAA1B,EAA6B;AAC5B+E,sBAAAA,aAAa,CAAC8B,MAAd,CAAqBvC,IAArB;AACA;AACA;;AACDc,oBAAAA,MAAI,CAACpF,IAAL,GAAYJ,cAAc,CAACwF,MAAI,CAACvF,OAAN,CAA1B;;AACA,wBACCuF,MAAI,CAAC9E,UAAL,CAAgBmG,aAAhB,IACArB,MAAI,CAACpF,IAAL,GAAYoF,MAAI,CAAC9E,UAAL,CAAgBuF,OAF7B,EAGE;AACDd,sBAAAA,aAAa,CAAC8B,MAAd,CAAqBvC,IAArB;AACA;;AACD,wBAAIc,MAAI,CAACvF,OAAL,CAAaG,IAAb,KAAsB,CAA1B,EAA6B;AAC5B+E,sBAAAA,aAAa,CAAC8B,MAAd,CAAqBvC,IAArB;AACA;AACD;AACD;AACD;AAxgBO;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwST,iBAAOS,aAAa,CAAC/E,IAAd,GAAqB,CAA5B,EAA+B;AAAA;;AAAA,qCAmH7B;AA8GD;;AAED,cAAMkJ,sBAAsB,GAAG,IAAItF,GAAJ,EAA/B,CA3gBS,CA6gBT;;AA7gBS,uDA8gBWjB,WAAW,CAACjD,MAAZ,CAAmBZ,KAAnB,EA9gBX;AAAA;;AAAA;AAAA;AAAA,kBA8gBEM,KA9gBF;;AA+gBR,yBACC0H,eAAe,CAACvD,GAAhB,CAAoBnE,KAApB,KAA8B,KAAI,CAACgD,OAAL,CAAa+G,kBAD5C;AAAA,kBAAQtD,OAAR,QAAQA,OAAR;AAAA,kBAAiBK,OAAjB,QAAiBA,OAAjB;AAAA,kBAA0BK,sBAA1B,QAA0BA,sBAA1B;AAAA,kBAAkDwC,IAAlD,QAAkDA,IAAlD;;AAEA,kBAAI,CAAC7C,OAAL,EAAc;;AACd,kBAAIL,OAAO,GAAGK,OAAd,EAAuB;AACtB,oBAAMkD,UAAU,aAAML,IAAI,IAAIA,IAAI,CAACvF,IAAL,EAAd,cAA6BqC,OAA7B,cAAwCK,OAAxC,CAAhB;;AACA,oBAAI,CAACgD,sBAAsB,CAAC/I,GAAvB,CAA2BiJ,UAA3B,CAAL,EAA6C;AAC5CF,kBAAAA,sBAAsB,CAAC3D,GAAvB,CAA2B6D,UAA3B;AACAzG,kBAAAA,WAAW,CAAC0G,QAAZ,CAAqBlF,IAArB,CACC,IAAI7F,iBAAJ,CAAsByK,IAAtB,EAA4BlD,OAA5B,EAAqCK,OAArC,CADD;AAGA;AACD;;AACD,kBAAMoD,OAAO,GAAG9K,+BAA+B,CAAC;AAC/C0H,gBAAAA,OAAO,EAAE1G,IAAI,CAACC,GAAL,CAASoG,OAAT,EAAkBK,OAAlB,CADsC;AAE/CL,gBAAAA,OAAO,EAAPA,OAF+C;AAG/C0D,gBAAAA,KAAK,EAAEnK,KAAK,CAACoK,eAHkC;AAI/CrG,gBAAAA,MAJ+C,kBAIxCjB,MAJwC,EAIhC;AACd,sBAAMuH,KAAK,GAAGlL,UAAU,CACvBoE,WAAW,CAACP,OAAZ,CAAoBsH,OADG,EAEvBxH,MAAM,CAAChD,UAAP,EAFuB,CAAxB;AAIA,sBAAMR,IAAI,GAAGwD,MAAM,CAACyH,gBAAP,GACVpL,UAAU,CACVoE,WAAW,CAACP,OAAZ,CAAoBsH,OADV,EAEVxH,MAAM,CAACyH,gBAAP,EAFU,CADA,GAKVF,KAAK,CAACG,OAAN,CAAc,iBAAd,EAAiC,EAAjC,CALH;AAMA,sBAAMC,OAAO,GACZnL,IAAI,GAAG6H,sBAAP,GAAgC9H,YAAY,CAACgL,KAAD,CAD7C;AAEA,yBAAOI,OAAO,CAACD,OAAR,CAAgB,SAAhB,EAA2B,GAA3B,CAAP;AACA,iBAlB8C;AAmB/CE,gBAAAA,OAnB+C,mBAmBvC5H,MAnBuC,EAmB/B;AACf,yBAAOA,MAAM,CAAClC,IAAP,EAAP;AACA;AArB8C,eAAD,CAA/C;AAuBAsJ,cAAAA,OAAO,CAACrI,IAAR,CAAa,UAACjC,CAAD,EAAIC,CAAJ,EAAU;AACtB,oBAAID,CAAC,CAACsF,GAAF,GAAQrF,CAAC,CAACqF,GAAd,EAAmB,OAAO,CAAC,CAAR;AACnB,oBAAItF,CAAC,CAACsF,GAAF,GAAQrF,CAAC,CAACqF,GAAd,EAAmB,OAAO,CAAP;AACnB,uBAAO,CAAP;AACA,eAJD;;AAKA,mBAAK,IAAIyF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,OAAO,CAAC3J,MAA5B,EAAoCoK,CAAC,EAArC,EAAyC;AACxC,oBAAMC,KAAK,GAAGV,OAAO,CAACS,CAAD,CAArB;AACA,oBAAMzF,GAAG,GAAG,KAAI,CAAClC,OAAL,CAAa6H,YAAb,GACTxL,YAAY,CAACuL,KAAK,CAAC1F,GAAP,CADH,GAET0F,KAAK,CAAC1F,GAFT;AAGA,oBAAI5F,IAAI,GAAGU,KAAK,CAACV,IAAN,GACRU,KAAK,CAACV,IAAN,GAAa6H,sBAAb,GAAsCjC,GAD9B,GAER,IAFH;;AAGA,oBAAI5F,IAAI,IAAIA,IAAI,CAACiB,MAAL,GAAc,GAA1B,EAA+B;AAC9BjB,kBAAAA,IAAI,GACHA,IAAI,CAACI,KAAL,CAAW,CAAX,EAAc,GAAd,IACAyH,sBADA,GAEA9H,YAAY,CAACC,IAAD,CAHb;AAIA;;AACD,oBAAIwL,OAAO,SAAX;;AACA,oBAAIH,CAAC,KAAKT,OAAO,CAAC3J,MAAR,GAAiB,CAA3B,EAA8B;AAC7BuK,kBAAAA,OAAO,GAAGvH,WAAW,CAACsF,QAAZ,CAAqBvJ,IAArB,CAAV;AACAU,kBAAAA,KAAK,CAAC8I,KAAN,CAAYgC,OAAZ;AACAA,kBAAAA,OAAO,CAAC/B,WAAR,GAAsB/I,KAAK,CAAC+I,WAA5B,CAH6B,CAI7B;;AAJ6B,+DAKR6B,KAAK,CAACT,KALE;AAAA;;AAAA;AAK7B,8EAAkC;AAAA,0BAAvBrH,QAAuB;;AACjC,0BAAI,OAAOA,QAAM,CAACwG,cAAd,KAAiC,UAArC,EAAiD;AAChD,4BAAI,CAACxG,QAAM,CAACwG,cAAP,CAAsBwB,OAAtB,CAAL,EAAqC;AACrC,uBAHgC,CAIjC;;;AACA/L,sBAAAA,YAAY,CAACwK,qBAAb,CAAmCuB,OAAnC,EAA4ChI,QAA5C,EALiC,CAMjC;;AACA9C,sBAAAA,KAAK,CAACwJ,YAAN,CAAmB1G,QAAnB;;AACAA,sBAAAA,QAAM,CAAC2G,qBAAP,CAA6BzJ,KAA7B,EAAoC,CAAC8K,OAAD,CAApC;AACA;AAd4B;AAAA;AAAA;AAAA;AAAA;AAe7B,iBAfD,MAeO;AACN;AACAA,kBAAAA,OAAO,GAAG9K,KAAV;AACAA,kBAAAA,KAAK,CAACV,IAAN,GAAaA,IAAb;AACA;AACD;AA1lBO;;AA8gBT,sEAAgD;AAAA;;AAAA,wCAGjC;AA0Ed;AA3lBQ;AAAA;AAAA;AAAA;AAAA;AA4lBT,SA9lBF;AAgmBA,OArmBD;AAsmBA;AA11BF;AAAA;AAAA,WAKC,4BAAsC;AAAA,UAAd0D,OAAc,uEAAJ,EAAI;AACrC,aAAO;AACN4D,QAAAA,YAAY,EAAE3D,iBAAiB,CAAC8H,qBAAlB,CACb/H,OAAO,CAAC1C,MAAR,IAAkB,KADL,CADR;AAINmG,QAAAA,OAAO,EAAEzD,OAAO,CAACyD,OAAR,IAAmB,CAJtB;AAKNE,QAAAA,oBAAoB,EAAE3D,OAAO,CAAC2D,oBAAR,IAAgC,CALhD;AAMNG,QAAAA,OAAO,EAAE9D,OAAO,CAAC8D,OAAR,IAAmB,CANtB;AAONhB,QAAAA,SAAS,EAAE9C,OAAO,CAAC8C,SAAR,IAAqB,CAP1B;AAQNiB,QAAAA,gBAAgB,EAAE/D,OAAO,CAAC+D,gBAAR,IAA4B,CARxC;AASNE,QAAAA,kBAAkB,EAAEjE,OAAO,CAACiE,kBAAR,IAA8B,CAT5C;AAUN4D,QAAAA,YAAY,EAAE7H,OAAO,CAAC6H,YAAR,IAAwB,KAVhC;AAWN3D,QAAAA,QAAQ,EAAElE,OAAO,CAACkE,QAAR,IAAoBpC,SAXxB;AAYNuB,QAAAA,cAAc,EAAEpD,iBAAiB,CAAC+H,oBAAlB,CAAuC;AACtD5E,UAAAA,WAAW,EAAEpD,OAAO,CAACoD,WADiC;AAEtD9G,UAAAA,IAAI,EAAE0D,OAAO,CAAC1D,IAFwC;AAGtD6H,UAAAA,sBAAsB,EAAEnE,OAAO,CAACmE,sBAHsB;AAItD8D,UAAAA,sBAAsB,EAAEjI,OAAO,CAACiI;AAJsB,SAAvC,CAZV;AAkBN9D,QAAAA,sBAAsB,EAAEnE,OAAO,CAACmE,sBAlB1B;AAmBN8D,QAAAA,sBAAsB,EAAEjI,OAAO,CAACiI,sBAAR,IAAkC,GAnBpD;AAoBNlB,QAAAA,kBAAkB,EAAE9G,iBAAiB,CAACiI,2BAAlB,CACnBlI,OAAO,CAAC+G,kBAAR,IAA8B,EADX,EAEnB/G,OAFmB;AApBd,OAAP;AAyBA;AA/BF;AAAA;AAAA,WAiCC,8BAKG;AAAA,UAJF1D,IAIE,SAJFA,IAIE;AAAA,UAHF6H,sBAGE,SAHFA,sBAGE;AAAA,UAFFgE,mBAEE,SAFFA,mBAEE;AAAA,UADFF,sBACE,SADFA,sBACE;;AACF,UAAI3L,IAAI,KAAK,IAAb,EAAmB;AAClB;AACA,YAAM8L,KAAK,GAAG,IAAI/F,OAAJ,EAAd;;AACA,YAAMgG,EAAE,GAAG,SAALA,EAAK,CAACvI,MAAD,EAASxC,MAAT,EAAiBY,UAAjB,EAAgC;AAC1C,cAAIoK,UAAU,GAAGF,KAAK,CAACjH,GAAN,CAAU7D,MAAV,CAAjB;;AACA,cAAIgL,UAAU,KAAKxG,SAAnB,EAA8B;AAC7BwG,YAAAA,UAAU,GAAG,EAAb;AACAF,YAAAA,KAAK,CAACtH,GAAN,CAAUxD,MAAV,EAAkBgL,UAAlB;AACA,WAHD,MAGO,IAAIpK,UAAU,IAAIoK,UAAlB,EAA8B;AACpC,mBAAOA,UAAU,CAACpK,UAAD,CAAjB;AACA;;AACD,cAAMqK,KAAK,GAAGjL,MAAM,CAACkL,GAAP,CAAW,UAAAtH,CAAC;AAAA,mBAAIA,CAAC,CAAC5E,IAAN;AAAA,WAAZ,CAAd;;AACA,cAAI,CAACiM,KAAK,CAACE,KAAN,CAAYC,OAAZ,CAAL,EAA2B;AAC1BJ,YAAAA,UAAU,CAACpK,UAAD,CAAV,GAAyB4D,SAAzB;AACA;AACA;;AACDyG,UAAAA,KAAK,CAAC1J,IAAN;AACA,cAAM8J,MAAM,GACX,OAAOR,mBAAP,KAA+B,QAA/B,GACGA,mBADH,GAEGjK,UAHJ;AAIA,cAAM0K,UAAU,GAAGD,MAAM,GAAGA,MAAM,GAAGxE,sBAAZ,GAAqC,EAA9D;AACA,cAAI7H,IAAI,GAAGsM,UAAU,GAAGL,KAAK,CAACnH,IAAN,CAAW+C,sBAAX,CAAxB,CAnB0C,CAoB1C;AACA;AACA;AACA;AACA;;AACA,cAAI7H,IAAI,CAACiB,MAAL,GAAc0K,sBAAlB,EAA0C;AACzC,gBAAMY,cAAc,GAAGxM,YAAY,CAACC,IAAD,CAAnC;AACA,gBAAMwM,WAAW,GAChBb,sBAAsB,IACrB9D,sBAAsB,CAAC5G,MAAvB,GAAgCsL,cAAc,CAACtL,MAD1B,CADvB;AAGAjB,YAAAA,IAAI,GACHA,IAAI,CAACI,KAAL,CAAW,CAAX,EAAcoM,WAAd,IACA3E,sBADA,GAEA0E,cAHD;AAIA;;AACDP,UAAAA,UAAU,CAACpK,UAAD,CAAV,GAAyB5B,IAAzB;AACA,iBAAOA,IAAP;AACA,SArCD;;AAsCA,eAAO+L,EAAP;AACA;;AACD,UAAI,OAAO/L,IAAP,KAAgB,QAApB,EAA8B;AAC7B,YAAM+L,GAAE,GAAG,SAALA,GAAK,GAAM;AAChB,iBAAO/L,IAAP;AACA,SAFD;;AAGA,eAAO+L,GAAP;AACA;;AACD,UAAI,OAAO/L,IAAP,KAAgB,UAApB,EAAgC,OAAOA,IAAP;AAChC;AAzFF;AAAA;AAAA,WA2FC,+BAA6BgB,MAA7B,EAAqC;AACpC,UAAIA,MAAM,KAAK,SAAf,EAA0B;AACzB,eAAOoC,oBAAP;AACA;;AACD,UAAIpC,MAAM,KAAK,OAAf,EAAwB;AACvB,eAAOsC,kBAAP;AACA;;AACD,UAAItC,MAAM,KAAK,KAAf,EAAsB;AACrB,eAAOuC,gBAAP;AACA;;AACD,UAAI,OAAOvC,MAAP,KAAkB,UAAtB,EAAkC,OAAOA,MAAP;AAClC;AAtGF;AAAA;AAAA,WAwGC,mDAWE;AAAA,gCATAmG,OASA;AAAA,UATAA,OASA,8BATU3B,SASV;AAAA,gCARAgC,OAQA;AAAA,UARAA,OAQA,8BARUhC,SAQV;AAAA,wCAPAqC,sBAOA;AAAA,UAPAA,sBAOA,sCAPyBrC,SAOzB;AAAA,gCAJA2B,OAIA;AAAA,UAJSsF,cAIT,8BAJ0BjH,SAI1B;AAAA,gCAHAgC,OAGA;AAAA,UAHSkF,cAGT,8BAH0BlH,SAG1B;AAAA,wCAFAqC,sBAEA;AAAA,UAFwB8E,6BAExB,sCAFwDnH,SAExD;AACD,aAAO;AACN2B,QAAAA,OAAO,EAAE,OAAOA,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwCsF,cAAc,IAAI,CAD7D;AAENjF,QAAAA,OAAO,EAAE,OAAOA,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwCkF,cAAc,IAAI,CAF7D;AAGN7E,QAAAA,sBAAsB,EACrBA,sBAAsB,IAAI8E,6BAA1B,IAA2D;AAJtD,OAAP;AAMA;AA1HF;AAAA;AAAA,WA4HC,qCAKG;AAAA,UAJF7F,WAIE,SAJFA,WAIE;AAAA,UAHF9G,IAGE,SAHFA,IAGE;AAAA,UAFF6H,sBAEE,SAFFA,sBAEE;AAAA,UADF8D,sBACE,SADFA,sBACE;;AACF,UAAI,OAAO7E,WAAP,KAAuB,UAA3B,EAAuC;AACtC;AACA,YAAIA,WAAW,CAAC7F,MAAZ,KAAuB,CAA3B,EAA8B;AAC7B,iBAAO,UAAAuC,MAAM;AAAA,mBAAIsD,WAAW,CAACtD,MAAD,EAASA,MAAM,CAACoJ,SAAP,EAAT,CAAf;AAAA,WAAb;AACA;;AACD,eAAO9F,WAAP;AACA;;AACD,UAAIA,WAAW,IAAI,OAAOA,WAAP,KAAuB,QAA1C,EAAoD;AACnD,YAAMiF,IAAE,GAAG,SAALA,IAAK,CAAAvI,MAAM,EAAI;AACpB,cAAIoH,OAAJ;;AACA,0CAAkBiC,MAAM,CAACxC,IAAP,CAAYvD,WAAZ,CAAlB,kCAA4C;AAAvC,gBAAMlB,GAAG,mBAAT;AACJ,gBAAIkH,MAAM,GAAGhG,WAAW,CAAClB,GAAD,CAAxB;AACA,gBAAIkH,MAAM,KAAK,KAAf,EAAsB;;AACtB,gBAAIA,MAAM,YAAYC,MAAlB,IAA4B,OAAOD,MAAP,KAAkB,QAAlD,EAA4D;AAC3DA,cAAAA,MAAM,GAAG;AACRE,gBAAAA,IAAI,EAAEF;AADE,eAAT;AAGA;;AACD,gBAAI,OAAOA,MAAP,KAAkB,UAAtB,EAAkC;AACjC,kBAAIG,MAAM,GAAGH,MAAM,CAACtJ,MAAD,CAAnB;;AACA,kBAAIyJ,MAAJ,EAAY;AACX,oBAAIrC,OAAO,KAAKpF,SAAhB,EAA2BoF,OAAO,GAAG,EAAV;;AADhB,6DAEKlG,KAAK,CAACsC,OAAN,CAAciG,MAAd,IAAwBA,MAAxB,GAAiC,CAACA,MAAD,CAFtC;AAAA;;AAAA;AAAA;AAAA,wBAEAC,CAFA;AAGV,wBAAMD,MAAM,GAAGJ,MAAM,CAACM,MAAP,CAAc;AAAEvH,sBAAAA,GAAG,EAAHA;AAAF,qBAAd,EAAuBsH,CAAvB,CAAf;AACA,wBAAID,MAAM,CAACjN,IAAX,EAAiBiN,MAAM,CAACxG,OAAP,GAAiB;AAAA,6BAAMwG,MAAM,CAACjN,IAAb;AAAA,qBAAjB;;AACjB,wBAAIiN,MAAM,CAACjM,MAAX,EAAmB;AAClBiM,sBAAAA,MAAM,CAAC3F,YAAP,GAAsB3D,iBAAiB,CAAC8H,qBAAlB,CACrBwB,MAAM,CAACjM,MADc,CAAtB;AAGA;;AACD4J,oBAAAA,OAAO,CAACnF,IAAR,CAAawH,MAAb;AAVU;;AAEX,4EAA2D;AAAA;AAS1D;AAXU;AAAA;AAAA;AAAA;AAAA;AAYX;AACD,aAfD,MAeO,IAAItJ,iBAAiB,CAACyJ,SAAlB,CAA4BN,MAAM,CAACE,IAAnC,EAAyCxJ,MAAzC,CAAJ,EAAsD;AAC5D,kBAAIoH,OAAO,KAAKpF,SAAhB,EAA2BoF,OAAO,GAAG,EAAV;AAC3BA,cAAAA,OAAO,CAACnF,IAAR,CAAa;AACZG,gBAAAA,GAAG,EAAEA,GADO;AAEZ/D,gBAAAA,QAAQ,EAAEiL,MAAM,CAACjL,QAFL;AAGZ4E,gBAAAA,OAAO,EACN9C,iBAAiB,CAAC0J,aAAlB,CAAgC;AAC/BrN,kBAAAA,IAAI,EAAE8M,MAAM,CAAC9M,IAAP,IAAeA,IADU;AAE/B6H,kBAAAA,sBAAsB,EACrB,OAAOiF,MAAM,CAACjF,sBAAd,KAAyC,QAAzC,GACGiF,MAAM,CAACjF,sBADV,GAEGA,sBAL2B;AAM/BgE,kBAAAA,mBAAmB,EAAEiB,MAAM,CAACjB,mBANG;AAO/BF,kBAAAA,sBAAsB,EACrBmB,MAAM,CAACnB,sBAAP,IAAiCA;AARH,iBAAhC,KASO,YAAM,CAAE,CAbJ;AAcZrE,gBAAAA,YAAY,EAAE3D,iBAAiB,CAAC8H,qBAAlB,CACbqB,MAAM,CAAC9L,MADM,CAdF;AAiBZoG,gBAAAA,OAAO,EAAE0F,MAAM,CAAC1F,OAjBJ;AAkBZD,gBAAAA,OAAO,EAAE2F,MAAM,CAAC3F,OAlBJ;AAmBZE,gBAAAA,oBAAoB,EAAEyF,MAAM,CAACzF,oBAnBjB;AAoBZG,gBAAAA,OAAO,EAAEsF,MAAM,CAACtF,OApBJ;AAqBZhB,gBAAAA,SAAS,EAAEsG,MAAM,CAACtG,SArBN;AAsBZiB,gBAAAA,gBAAgB,EAAEqF,MAAM,CAACrF,gBAtBb;AAuBZE,gBAAAA,kBAAkB,EAAEmF,MAAM,CAACnF,kBAvBf;AAwBZC,gBAAAA,QAAQ,EAAEkF,MAAM,CAAClF,QAxBL;AAyBZE,gBAAAA,kBAAkB,EAAEgF,MAAM,CAAChF;AAzBf,eAAb;AA2BA;AACD;;AACD,iBAAO8C,OAAP;AACA,SAzDD;;AA0DA,eAAOmB,IAAP;AACA;;AACD,UAAMA,EAAE,GAAG,SAALA,EAAK,GAAM,CAAE,CAAnB;;AACA,aAAOA,EAAP;AACA;AAxMF;AAAA;AAAA,WA0MC,mBAAiBiB,IAAjB,EAAuBxJ,MAAvB,EAA+B;AAC9B,UAAIwJ,IAAI,KAAKxH,SAAb,EAAwB,OAAO,IAAP;;AACxB,UAAI,OAAOwH,IAAP,KAAgB,UAApB,EAAgC;AAC/B,YAAIA,IAAI,CAAC/L,MAAL,KAAgB,CAApB,EAAuB;AACtB,iBAAO+L,IAAI,CAACxJ,MAAD,EAASA,MAAM,CAACoJ,SAAP,EAAT,CAAX;AACA;;AACD,eAAOI,IAAI,CAACxJ,MAAD,CAAX;AACA;;AACD,UAAI,OAAOwJ,IAAP,KAAgB,SAApB,EAA+B,OAAOA,IAAP;;AAC/B,UAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC7B,YACCxJ,MAAM,CAACyH,gBAAP,IACAzH,MAAM,CAACyH,gBAAP,GAA0BqC,UAA1B,CAAqCN,IAArC,CAFD,EAGE;AACD,iBAAO,IAAP;AACA;;AAN4B,qDAOTxJ,MAAM,CAACyB,cAPE;AAAA;;AAAA;AAO7B,oEAA2C;AAAA,gBAAhCvE,KAAgC;;AAC1C,gBAAIA,KAAK,CAACV,IAAN,IAAcU,KAAK,CAACV,IAAN,CAAWsN,UAAX,CAAsBN,IAAtB,CAAlB,EAA+C;AAC9C,qBAAO,IAAP;AACA;AACD;AAX4B;AAAA;AAAA;AAAA;AAAA;;AAY7B,eAAO,KAAP;AACA;;AACD,UAAIA,IAAI,YAAYD,MAApB,EAA4B;AAC3B,YAAIvJ,MAAM,CAACyH,gBAAP,IAA2B+B,IAAI,CAACA,IAAL,CAAUxJ,MAAM,CAACyH,gBAAP,EAAV,CAA/B,EAAqE;AACpE,iBAAO,IAAP;AACA;;AAH0B,qDAIPzH,MAAM,CAACyB,cAJA;AAAA;;AAAA;AAI3B,oEAA2C;AAAA,gBAAhCvE,OAAgC;;AAC1C,gBAAIA,OAAK,CAACV,IAAN,IAAcgN,IAAI,CAACA,IAAL,CAAUtM,OAAK,CAACV,IAAhB,CAAlB,EAAyC;AACxC,qBAAO,IAAP;AACA;AACD;AAR0B;AAAA;AAAA;AAAA;AAAA;;AAS3B,eAAO,KAAP;AACA;;AACD,aAAO,KAAP;AACA;AA7OF;;AAAA;AAAA","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst GraphHelpers = require(\"../GraphHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\nconst contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (deterministicGrouping);\n\nconst hashFilename = name => {\n\treturn crypto\n\t\t.createHash(\"md4\")\n\t\t.update(name)\n\t\t.digest(\"hex\")\n\t\t.slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst getModulesSize = modules => {\n\tlet sum = 0;\n\tfor (const m of modules) {\n\t\tsum += m.size();\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = a.size * (a.chunks.size - 1);\n\tconst bSizeReduce = b.size * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by cache group index\n\tconst indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;\n\tif (indexDiff) return indexDiff;\n\t// 5. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 6. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\tconst aI = modulesA[Symbol.iterator]();\n\tconst bI = modulesB[Symbol.iterator]();\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst aItem = aI.next();\n\t\tconst bItem = bI.next();\n\t\tif (aItem.done) return 0;\n\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t}\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n\tconstructor(options) {\n\t\tthis.options = SplitChunksPlugin.normalizeOptions(options);\n\t}\n\n\tstatic normalizeOptions(options = {}) {\n\t\treturn {\n\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\toptions.chunks || \"all\"\n\t\t\t),\n\t\t\tminSize: options.minSize || 0,\n\t\t\tenforceSizeThreshold: options.enforceSizeThreshold || 0,\n\t\t\tmaxSize: options.maxSize || 0,\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n\t\t\t\tcacheGroups: options.cacheGroups,\n\t\t\t\tname: options.name,\n\t\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength\n\t\t\t}),\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength || 109,\n\t\t\tfallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(\n\t\t\t\toptions.fallbackCacheGroup || {},\n\t\t\t\toptions\n\t\t\t)\n\t\t};\n\t}\n\n\tstatic normalizeName({\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNamePrefix,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (name === true) {\n\t\t\t/** @type {WeakMap<Chunk[], Record<string, string>>} */\n\t\t\tconst cache = new WeakMap();\n\t\t\tconst fn = (module, chunks, cacheGroup) => {\n\t\t\t\tlet cacheEntry = cache.get(chunks);\n\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\tcacheEntry = {};\n\t\t\t\t\tcache.set(chunks, cacheEntry);\n\t\t\t\t} else if (cacheGroup in cacheEntry) {\n\t\t\t\t\treturn cacheEntry[cacheGroup];\n\t\t\t\t}\n\t\t\t\tconst names = chunks.map(c => c.name);\n\t\t\t\tif (!names.every(Boolean)) {\n\t\t\t\t\tcacheEntry[cacheGroup] = undefined;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnames.sort();\n\t\t\t\tconst prefix =\n\t\t\t\t\ttypeof automaticNamePrefix === \"string\"\n\t\t\t\t\t\t? automaticNamePrefix\n\t\t\t\t\t\t: cacheGroup;\n\t\t\t\tconst namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n\t\t\t\tlet name = namePrefix + names.join(automaticNameDelimiter);\n\t\t\t\t// Filenames and paths can't be too long otherwise an\n\t\t\t\t// ENAMETOOLONG error is raised. If the generated name if too\n\t\t\t\t// long, it is truncated and a hash is appended. The limit has\n\t\t\t\t// been set to 109 to prevent `[name].[chunkhash].[ext]` from\n\t\t\t\t// generating a 256+ character string.\n\t\t\t\tif (name.length > automaticNameMaxLength) {\n\t\t\t\t\tconst hashedFilename = hashFilename(name);\n\t\t\t\t\tconst sliceLength =\n\t\t\t\t\t\tautomaticNameMaxLength -\n\t\t\t\t\t\t(automaticNameDelimiter.length + hashedFilename.length);\n\t\t\t\t\tname =\n\t\t\t\t\t\tname.slice(0, sliceLength) +\n\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\thashedFilename;\n\t\t\t\t}\n\t\t\t\tcacheEntry[cacheGroup] = name;\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"string\") {\n\t\t\tconst fn = () => {\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"function\") return name;\n\t}\n\n\tstatic normalizeChunksFilter(chunks) {\n\t\tif (chunks === \"initial\") {\n\t\t\treturn INITIAL_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"async\") {\n\t\t\treturn ASYNC_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"all\") {\n\t\t\treturn ALL_CHUNK_FILTER;\n\t\t}\n\t\tif (typeof chunks === \"function\") return chunks;\n\t}\n\n\tstatic normalizeFallbackCacheGroup(\n\t\t{\n\t\t\tminSize = undefined,\n\t\t\tmaxSize = undefined,\n\t\t\tautomaticNameDelimiter = undefined\n\t\t},\n\t\t{\n\t\t\tminSize: defaultMinSize = undefined,\n\t\t\tmaxSize: defaultMaxSize = undefined,\n\t\t\tautomaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n\t\t}\n\t) {\n\t\treturn {\n\t\t\tminSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n\t\t\tmaxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tautomaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n\t\t};\n\t}\n\n\tstatic normalizeCacheGroups({\n\t\tcacheGroups,\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (typeof cacheGroups === \"function\") {\n\t\t\t// TODO webpack 5 remove this\n\t\t\tif (cacheGroups.length !== 1) {\n\t\t\t\treturn module => cacheGroups(module, module.getChunks());\n\t\t\t}\n\t\t\treturn cacheGroups;\n\t\t}\n\t\tif (cacheGroups && typeof cacheGroups === \"object\") {\n\t\t\tconst fn = module => {\n\t\t\t\tlet results;\n\t\t\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\t\t\tlet option = cacheGroups[key];\n\t\t\t\t\tif (option === false) continue;\n\t\t\t\t\tif (option instanceof RegExp || typeof option === \"string\") {\n\t\t\t\t\t\toption = {\n\t\t\t\t\t\t\ttest: option\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof option === \"function\") {\n\t\t\t\t\t\tlet result = option(module);\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\t\tfor (const r of Array.isArray(result) ? result : [result]) {\n\t\t\t\t\t\t\t\tconst result = Object.assign({ key }, r);\n\t\t\t\t\t\t\t\tif (result.name) result.getName = () => result.name;\n\t\t\t\t\t\t\t\tif (result.chunks) {\n\t\t\t\t\t\t\t\t\tresult.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\t\t\tresult.chunks\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (SplitChunksPlugin.checkTest(option.test, module)) {\n\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tpriority: option.priority,\n\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\tSplitChunksPlugin.normalizeName({\n\t\t\t\t\t\t\t\t\tname: option.name || name,\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\t\ttypeof option.automaticNameDelimiter === \"string\"\n\t\t\t\t\t\t\t\t\t\t\t? option.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t\t: automaticNameDelimiter,\n\t\t\t\t\t\t\t\t\tautomaticNamePrefix: option.automaticNamePrefix,\n\t\t\t\t\t\t\t\t\tautomaticNameMaxLength:\n\t\t\t\t\t\t\t\t\t\toption.automaticNameMaxLength || automaticNameMaxLength\n\t\t\t\t\t\t\t\t}) || (() => {}),\n\t\t\t\t\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\toption.chunks\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tenforce: option.enforce,\n\t\t\t\t\t\t\tminSize: option.minSize,\n\t\t\t\t\t\t\tenforceSizeThreshold: option.enforceSizeThreshold,\n\t\t\t\t\t\t\tmaxSize: option.maxSize,\n\t\t\t\t\t\t\tminChunks: option.minChunks,\n\t\t\t\t\t\t\tmaxAsyncRequests: option.maxAsyncRequests,\n\t\t\t\t\t\t\tmaxInitialRequests: option.maxInitialRequests,\n\t\t\t\t\t\t\tfilename: option.filename,\n\t\t\t\t\t\t\treuseExistingChunk: option.reuseExistingChunk\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tconst fn = () => {};\n\t\treturn fn;\n\t}\n\n\tstatic checkTest(test, module) {\n\t\tif (test === undefined) return true;\n\t\tif (typeof test === \"function\") {\n\t\t\tif (test.length !== 1) {\n\t\t\t\treturn test(module, module.getChunks());\n\t\t\t}\n\t\t\treturn test(module);\n\t\t}\n\t\tif (typeof test === \"boolean\") return test;\n\t\tif (typeof test === \"string\") {\n\t\t\tif (\n\t\t\t\tmodule.nameForCondition &&\n\t\t\t\tmodule.nameForCondition().startsWith(test)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && chunk.name.startsWith(test)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (test instanceof RegExp) {\n\t\t\tif (module.nameForCondition && test.test(module.nameForCondition())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && test.test(chunk.name)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"SplitChunksPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\tconst indexMap = new Map();\n\t\t\t\t\tlet index = 1;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tindexMap.set(chunk, index++);\n\t\t\t\t\t}\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\treturn Array.from(chunks, c => indexMap.get(c))\n\t\t\t\t\t\t\t.sort(compareNumbers)\n\t\t\t\t\t\t\t.join();\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {Map<string, Set<Chunk>>} */\n\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\tfor (const chunksSet of chunkSetsInGraph.values()) {\n\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n\t\t\t\t\tconst getCombinations = key => {\n\t\t\t\t\t\tconst chunksSet = chunkSetsInGraph.get(key);\n\t\t\t\t\t\tvar array = [chunksSet];\n\t\t\t\t\t\tif (chunksSet.size > 1) {\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn array;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {string} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {function(Chunk): boolean} ChunkFilterFunction\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk>} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} ChunksInfoItem\n\t\t\t\t\t * @property {SortableSet} modules\n\t\t\t\t\t * @property {TODO} cacheGroup\n\t\t\t\t\t * @property {number} cacheGroupIndex\n\t\t\t\t\t * @property {string} name\n\t\t\t\t\t * @property {number} size\n\t\t\t\t\t * @property {Set<Chunk>} chunks\n\t\t\t\t\t * @property {Set<Chunk>} reuseableChunks\n\t\t\t\t\t * @property {Set<string>} chunksKeys\n\t\t\t\t\t */\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {TODO} cacheGroup the current cache group\n\t\t\t\t\t * @param {number} cacheGroupIndex the index of the cache group of ordering\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {string} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Elsewise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(undefined, sortByIdentifier),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tsize: 0,\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tinfo.size += module.size();\n\t\t\t\t\t\tif (!info.chunksKeys.has(selectedChunksKey)) {\n\t\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tlet combs = combinationsCache.get(chunksKey);\n\t\t\t\t\t\tif (combs === undefined) {\n\t\t\t\t\t\t\tcombs = getCombinations(chunksKey);\n\t\t\t\t\t\t\tcombinationsCache.set(chunksKey, combs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet cacheGroupIndex = 0;\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst minSize =\n\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t: this.options.minSize;\n\t\t\t\t\t\t\tconst enforceSizeThreshold =\n\t\t\t\t\t\t\t\tcacheGroupSource.enforceSizeThreshold !== undefined\n\t\t\t\t\t\t\t\t\t? cacheGroupSource.enforceSizeThreshold\n\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t: this.options.enforceSizeThreshold;\n\t\t\t\t\t\t\tconst cacheGroup = {\n\t\t\t\t\t\t\t\tkey: cacheGroupSource.key,\n\t\t\t\t\t\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\t\t\t\t\t\tchunksFilter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\t\tminSizeForMaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t\t: this.options.minSize,\n\t\t\t\t\t\t\t\tenforceSizeThreshold,\n\t\t\t\t\t\t\t\tmaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxSize\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t: this.options.maxSize,\n\t\t\t\t\t\t\t\tminChunks:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: this.options.minChunks,\n\t\t\t\t\t\t\t\tmaxAsyncRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\t\t\t\t\t\tmaxInitialRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t\t\t\t\t\t: this.options.getName,\n\t\t\t\t\t\t\t\tfilename:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t\t\t\t\t\t: this.options.filename,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\t\t\t\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk,\n\t\t\t\t\t\t\t\t_validateSize: minSize > 0,\n\t\t\t\t\t\t\t\t_conditionalEnforce: enforceSizeThreshold > 0\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tif (chunkCombination.size < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\t\tkey: selectedChunksKey\n\t\t\t\t\t\t\t\t} = getSelectedChunks(\n\t\t\t\t\t\t\t\t\tchunkCombination,\n\t\t\t\t\t\t\t\t\tcacheGroup.chunksFilter\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tcacheGroupIndex,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcacheGroupIndex++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinfo.cacheGroup._validateSize &&\n\t\t\t\t\t\t\tinfo.size < info.cacheGroup.minSize\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(pair[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (bestEntry === undefined) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t} else if (compareEntries(bestEntry, info) < 0) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isReused = false;\n\t\t\t\t\t\tif (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (chunk.getNumberOfModules() !== item.modules.size) continue;\n\t\t\t\t\t\t\t\tif (chunk.hasEntryModule()) continue;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisReused = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\n\t\t\t\t\t\tconst selectedChunks = Array.from(item.chunks).filter(chunk => {\n\t\t\t\t\t\t\t// skip if we address ourself\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t(!chunkName || chunk.name !== chunkName) && chunk !== newChunk\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tconst enforced =\n\t\t\t\t\t\t\titem.cacheGroup._conditionalEnforce &&\n\t\t\t\t\t\t\titem.size >= item.cacheGroup.enforceSizeThreshold;\n\n\t\t\t\t\t\t// Skip when no chunk selected\n\t\t\t\t\t\tif (selectedChunks.length === 0) continue;\n\n\t\t\t\t\t\tconst usedChunks = new Set(selectedChunks);\n\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!enforced &&\n\t\t\t\t\t\t\t(Number.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests))\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t// respect max requests\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tisFinite(maxRequests) &&\n\t\t\t\t\t\t\t\t\tgetRequests(chunk) >= maxRequests\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\touter: for (const chunk of usedChunks) {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tusedChunks.delete(chunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Were some (invalid) chunks removed from usedChunks?\n\t\t\t\t\t\t// => readd all modules to the queue, as things could have been changed\n\t\t\t\t\t\tif (usedChunks.size < selectedChunks.length) {\n\t\t\t\t\t\t\tif (usedChunks.size >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tconst chunksArr = Array.from(usedChunks);\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\titem.cacheGroupIndex,\n\t\t\t\t\t\t\t\t\t\tchunksArr,\n\t\t\t\t\t\t\t\t\t\tgetKey(usedChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason = isReused\n\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t: \"split chunk\";\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t\t// If the chosen name is already an entry point we remove the entry point\n\t\t\t\t\t\t\tconst entrypoint = compilation.entrypoints.get(chunkName);\n\t\t\t\t\t\t\tif (entrypoint) {\n\t\t\t\t\t\t\t\tcompilation.entrypoints.delete(chunkName);\n\t\t\t\t\t\t\t\tentrypoint.remove();\n\t\t\t\t\t\t\t\tnewChunk.entryModule = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tif (!newChunk.isOnlyInitial()) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" +\n\t\t\t\t\t\t\t\t\t\t\"The runtime can only handle loading of chunks which match the chunkFilename schema. \" +\n\t\t\t\t\t\t\t\t\t\t\"Using a custom filename would fail at runtime. \" +\n\t\t\t\t\t\t\t\t\t\t`(cache group: ${item.cacheGroup.key})`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (item.cacheGroup.maxSize > 0) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: Math.max(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.minSizeForMaxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tmaxSize: Math.min(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.maxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, usedChunks)) {\n\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinfo.size = getModulesSize(info.modules);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tinfo.cacheGroup._validateSize &&\n\t\t\t\t\t\t\t\t\t\tinfo.size < info.cacheGroup.minSize\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tfor (const chunk of compilation.chunks.slice()) {\n\t\t\t\t\t\tconst { minSize, maxSize, automaticNameDelimiter, keys } =\n\t\t\t\t\t\t\tmaxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n\t\t\t\t\t\tif (!maxSize) continue;\n\t\t\t\t\t\tif (minSize > maxSize) {\n\t\t\t\t\t\t\tconst warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSize, maxSize)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tmaxSize: Math.max(minSize, maxSize),\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\titems: chunk.modulesIterable,\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst ident = contextify(\n\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst name = module.nameForCondition\n\t\t\t\t\t\t\t\t\t? contextify(\n\t\t\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\t\t\tmodule.nameForCondition()\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname + automaticNameDelimiter + hashFilename(ident);\n\t\t\t\t\t\t\t\treturn fullKey.replace(/[\\\\/?]/g, \"_\");\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\treturn module.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresults.sort((a, b) => {\n\t\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet newPart;\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tnewPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart)) continue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newPart]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tnewPart = chunk;\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}