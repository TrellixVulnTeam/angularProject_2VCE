{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Partial<ResolveRequest>} requestOptions request options\n   * @param {string | ResolveStepHook} target target\n   */\n  function ParsePlugin(source, requestOptions, target) {\n    _classCallCheck(this, ParsePlugin);\n\n    this.source = source;\n    this.requestOptions = requestOptions;\n    this.target = target;\n  }\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n\n\n  _createClass(ParsePlugin, [{\n    key: \"apply\",\n    value: function apply(resolver) {\n      var _this = this;\n\n      var target = resolver.ensureHook(this.target);\n      resolver.getHook(this.source).tapAsync(\"ParsePlugin\", function (request, resolveContext, callback) {\n        var parsed = resolver.parse(\n        /** @type {string} */\n        request.request);\n\n        var obj = _objectSpread(_objectSpread(_objectSpread({}, request), parsed), _this.requestOptions);\n\n        if (request.query && !parsed.query) {\n          obj.query = request.query;\n        }\n\n        if (request.fragment && !parsed.fragment) {\n          obj.fragment = request.fragment;\n        }\n\n        if (parsed && resolveContext.log) {\n          if (parsed.module) resolveContext.log(\"Parsed request is a module\");\n          if (parsed.directory) resolveContext.log(\"Parsed request is a directory\");\n        } // There is an edge-case where a request with # can be a path or a fragment -> try both\n\n\n        if (obj.request && !obj.query && obj.fragment) {\n          var directory = obj.fragment.endsWith(\"/\");\n\n          var alternative = _objectSpread(_objectSpread({}, obj), {}, {\n            directory: directory,\n            request: obj.request + (obj.directory ? \"/\" : \"\") + (directory ? obj.fragment.slice(0, -1) : obj.fragment),\n            fragment: \"\"\n          });\n\n          resolver.doResolve(target, alternative, null, resolveContext, function (err, result) {\n            if (err) return callback(err);\n            if (result) return callback(null, result);\n            resolver.doResolve(target, obj, null, resolveContext, callback);\n          });\n          return;\n        }\n\n        resolver.doResolve(target, obj, null, resolveContext, callback);\n      });\n    }\n  }]);\n\n  return ParsePlugin;\n}();","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/enhanced-resolve/lib/ParsePlugin.js"],"names":["module","exports","source","requestOptions","target","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","parsed","parse","obj","query","fragment","log","directory","endsWith","alternative","slice","doResolve","err","result"],"mappings":"AAAA;AACA;AACA;AACA;AAEA;AAEA;;AACA;;AACA;;;;;;;;AAEAA,MAAM,CAACC,OAAP;AACC;AACD;AACA;AACA;AACA;AACC,uBAAYC,MAAZ,EAAoBC,cAApB,EAAoCC,MAApC,EAA4C;AAAA;;AAC3C,SAAKF,MAAL,GAAcA,MAAd;AACA,SAAKC,cAAL,GAAsBA,cAAtB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA;AAED;AACD;AACA;AACA;;;AAfA;AAAA;AAAA,WAgBC,eAAMC,QAAN,EAAgB;AAAA;;AACf,UAAMD,MAAM,GAAGC,QAAQ,CAACC,UAAT,CAAoB,KAAKF,MAAzB,CAAf;AACAC,MAAAA,QAAQ,CACNE,OADF,CACU,KAAKL,MADf,EAEEM,QAFF,CAEW,aAFX,EAE0B,UAACC,OAAD,EAAUC,cAAV,EAA0BC,QAA1B,EAAuC;AAC/D,YAAMC,MAAM,GAAGP,QAAQ,CAACQ,KAAT;AAAe;AAAuBJ,QAAAA,OAAO,CAACA,OAA9C,CAAf;;AACA,YAAMK,GAAG,iDAAQL,OAAR,GAAoBG,MAApB,GAA+B,KAAI,CAACT,cAApC,CAAT;;AACA,YAAIM,OAAO,CAACM,KAAR,IAAiB,CAACH,MAAM,CAACG,KAA7B,EAAoC;AACnCD,UAAAA,GAAG,CAACC,KAAJ,GAAYN,OAAO,CAACM,KAApB;AACA;;AACD,YAAIN,OAAO,CAACO,QAAR,IAAoB,CAACJ,MAAM,CAACI,QAAhC,EAA0C;AACzCF,UAAAA,GAAG,CAACE,QAAJ,GAAeP,OAAO,CAACO,QAAvB;AACA;;AACD,YAAIJ,MAAM,IAAIF,cAAc,CAACO,GAA7B,EAAkC;AACjC,cAAIL,MAAM,CAACZ,MAAX,EAAmBU,cAAc,CAACO,GAAf,CAAmB,4BAAnB;AACnB,cAAIL,MAAM,CAACM,SAAX,EACCR,cAAc,CAACO,GAAf,CAAmB,+BAAnB;AACD,SAb8D,CAc/D;;;AACA,YAAIH,GAAG,CAACL,OAAJ,IAAe,CAACK,GAAG,CAACC,KAApB,IAA6BD,GAAG,CAACE,QAArC,EAA+C;AAC9C,cAAME,SAAS,GAAGJ,GAAG,CAACE,QAAJ,CAAaG,QAAb,CAAsB,GAAtB,CAAlB;;AACA,cAAMC,WAAW,mCACbN,GADa;AAEhBI,YAAAA,SAAS,EAATA,SAFgB;AAGhBT,YAAAA,OAAO,EACNK,GAAG,CAACL,OAAJ,IACCK,GAAG,CAACI,SAAJ,GAAgB,GAAhB,GAAsB,EADvB,KAECA,SAAS,GAAGJ,GAAG,CAACE,QAAJ,CAAaK,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,CAAH,GAA+BP,GAAG,CAACE,QAF7C,CAJe;AAOhBA,YAAAA,QAAQ,EAAE;AAPM,YAAjB;;AASAX,UAAAA,QAAQ,CAACiB,SAAT,CACClB,MADD,EAECgB,WAFD,EAGC,IAHD,EAICV,cAJD,EAKC,UAACa,GAAD,EAAMC,MAAN,EAAiB;AAChB,gBAAID,GAAJ,EAAS,OAAOZ,QAAQ,CAACY,GAAD,CAAf;AACT,gBAAIC,MAAJ,EAAY,OAAOb,QAAQ,CAAC,IAAD,EAAOa,MAAP,CAAf;AACZnB,YAAAA,QAAQ,CAACiB,SAAT,CAAmBlB,MAAnB,EAA2BU,GAA3B,EAAgC,IAAhC,EAAsCJ,cAAtC,EAAsDC,QAAtD;AACA,WATF;AAWA;AACA;;AACDN,QAAAA,QAAQ,CAACiB,SAAT,CAAmBlB,MAAnB,EAA2BU,GAA3B,EAAgC,IAAhC,EAAsCJ,cAAtC,EAAsDC,QAAtD;AACA,OA1CF;AA2CA;AA7DF;;AAAA;AAAA","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\nmodule.exports = class ParsePlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Partial<ResolveRequest>} requestOptions request options\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, requestOptions, target) {\n\t\tthis.source = source;\n\t\tthis.requestOptions = requestOptions;\n\t\tthis.target = target;\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ParsePlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst parsed = resolver.parse(/** @type {string} */ (request.request));\n\t\t\t\tconst obj = { ...request, ...parsed, ...this.requestOptions };\n\t\t\t\tif (request.query && !parsed.query) {\n\t\t\t\t\tobj.query = request.query;\n\t\t\t\t}\n\t\t\t\tif (request.fragment && !parsed.fragment) {\n\t\t\t\t\tobj.fragment = request.fragment;\n\t\t\t\t}\n\t\t\t\tif (parsed && resolveContext.log) {\n\t\t\t\t\tif (parsed.module) resolveContext.log(\"Parsed request is a module\");\n\t\t\t\t\tif (parsed.directory)\n\t\t\t\t\t\tresolveContext.log(\"Parsed request is a directory\");\n\t\t\t\t}\n\t\t\t\t// There is an edge-case where a request with # can be a path or a fragment -> try both\n\t\t\t\tif (obj.request && !obj.query && obj.fragment) {\n\t\t\t\t\tconst directory = obj.fragment.endsWith(\"/\");\n\t\t\t\t\tconst alternative = {\n\t\t\t\t\t\t...obj,\n\t\t\t\t\t\tdirectory,\n\t\t\t\t\t\trequest:\n\t\t\t\t\t\t\tobj.request +\n\t\t\t\t\t\t\t(obj.directory ? \"/\" : \"\") +\n\t\t\t\t\t\t\t(directory ? obj.fragment.slice(0, -1) : obj.fragment),\n\t\t\t\t\t\tfragment: \"\"\n\t\t\t\t\t};\n\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\talternative,\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (result) return callback(null, result);\n\t\t\t\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolver.doResolve(target, obj, null, resolveContext, callback);\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}