{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/metadata/src/util\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.hasInjectableFields = exports.CompoundMetadataReader = exports.extractDirectiveTypeCheckMeta = exports.readStringArrayType = exports.readStringMapType = exports.readStringType = exports.extractReferencesFromType = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  function extractReferencesFromType(checker, def, ngModuleImportedFrom, resolutionContext) {\n    if (!ts.isTupleTypeNode(def)) {\n      return [];\n    }\n\n    return def.elements.map(function (element) {\n      if (!ts.isTypeQueryNode(element)) {\n        throw new Error(\"Expected TypeQueryNode: \" + typescript_1.nodeDebugInfo(element));\n      }\n\n      var type = element.exprName;\n\n      var _a = reflection_1.reflectTypeEntityToDeclaration(type, checker),\n          node = _a.node,\n          from = _a.from;\n\n      if (!reflection_1.isNamedClassDeclaration(node)) {\n        throw new Error(\"Expected named ClassDeclaration: \" + typescript_1.nodeDebugInfo(node));\n      }\n\n      var specifier = from !== null && !from.startsWith('.') ? from : ngModuleImportedFrom;\n\n      if (specifier !== null) {\n        return new imports_1.Reference(node, {\n          specifier: specifier,\n          resolutionContext: resolutionContext\n        });\n      } else {\n        return new imports_1.Reference(node);\n      }\n    });\n  }\n\n  exports.extractReferencesFromType = extractReferencesFromType;\n\n  function readStringType(type) {\n    if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {\n      return null;\n    }\n\n    return type.literal.text;\n  }\n\n  exports.readStringType = readStringType;\n\n  function readStringMapType(type) {\n    if (!ts.isTypeLiteralNode(type)) {\n      return {};\n    }\n\n    var obj = {};\n    type.members.forEach(function (member) {\n      if (!ts.isPropertySignature(member) || member.type === undefined || member.name === undefined || !ts.isStringLiteral(member.name)) {\n        return;\n      }\n\n      var value = readStringType(member.type);\n\n      if (value === null) {\n        return null;\n      }\n\n      obj[member.name.text] = value;\n    });\n    return obj;\n  }\n\n  exports.readStringMapType = readStringMapType;\n\n  function readStringArrayType(type) {\n    if (!ts.isTupleTypeNode(type)) {\n      return [];\n    }\n\n    var res = [];\n    type.elements.forEach(function (el) {\n      if (!ts.isLiteralTypeNode(el) || !ts.isStringLiteral(el.literal)) {\n        return;\n      }\n\n      res.push(el.literal.text);\n    });\n    return res;\n  }\n\n  exports.readStringArrayType = readStringArrayType;\n  /**\n   * Inspects the class' members and extracts the metadata that is used when type-checking templates\n   * that use the directive. This metadata does not contain information from a base class, if any,\n   * making this metadata invariant to changes of inherited classes.\n   */\n\n  function extractDirectiveTypeCheckMeta(node, inputs, reflector) {\n    var e_1, _a;\n\n    var members = reflector.getMembersOfClass(node);\n    var staticMembers = members.filter(function (member) {\n      return member.isStatic;\n    });\n    var ngTemplateGuards = staticMembers.map(extractTemplateGuard).filter(function (guard) {\n      return guard !== null;\n    });\n    var hasNgTemplateContextGuard = staticMembers.some(function (member) {\n      return member.kind === reflection_1.ClassMemberKind.Method && member.name === 'ngTemplateContextGuard';\n    });\n    var coercedInputFields = new Set(staticMembers.map(extractCoercedInput).filter(function (inputName) {\n      return inputName !== null;\n    }));\n    var restrictedInputFields = new Set();\n    var stringLiteralInputFields = new Set();\n    var undeclaredInputFields = new Set();\n\n    var _loop_1 = function _loop_1(classPropertyName) {\n      var field = members.find(function (member) {\n        return member.name === classPropertyName;\n      });\n\n      if (field === undefined || field.node === null) {\n        undeclaredInputFields.add(classPropertyName);\n        return \"continue\";\n      }\n\n      if (isRestricted(field.node)) {\n        restrictedInputFields.add(classPropertyName);\n      }\n\n      if (field.nameNode !== null && ts.isStringLiteral(field.nameNode)) {\n        stringLiteralInputFields.add(classPropertyName);\n      }\n    };\n\n    try {\n      for (var _b = tslib_1.__values(inputs.classPropertyNames), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var classPropertyName = _c.value;\n\n        _loop_1(classPropertyName);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    var arity = reflector.getGenericArityOfClass(node);\n    return {\n      hasNgTemplateContextGuard: hasNgTemplateContextGuard,\n      ngTemplateGuards: ngTemplateGuards,\n      coercedInputFields: coercedInputFields,\n      restrictedInputFields: restrictedInputFields,\n      stringLiteralInputFields: stringLiteralInputFields,\n      undeclaredInputFields: undeclaredInputFields,\n      isGeneric: arity !== null && arity > 0\n    };\n  }\n\n  exports.extractDirectiveTypeCheckMeta = extractDirectiveTypeCheckMeta;\n\n  function isRestricted(node) {\n    if (node.modifiers === undefined) {\n      return false;\n    }\n\n    return node.modifiers.some(function (modifier) {\n      return modifier.kind === ts.SyntaxKind.PrivateKeyword || modifier.kind === ts.SyntaxKind.ProtectedKeyword || modifier.kind === ts.SyntaxKind.ReadonlyKeyword;\n    });\n  }\n\n  function extractTemplateGuard(member) {\n    if (!member.name.startsWith('ngTemplateGuard_')) {\n      return null;\n    }\n\n    var inputName = afterUnderscore(member.name);\n\n    if (member.kind === reflection_1.ClassMemberKind.Property) {\n      var type = null;\n\n      if (member.type !== null && ts.isLiteralTypeNode(member.type) && ts.isStringLiteral(member.type.literal)) {\n        type = member.type.literal.text;\n      } // Only property members with string literal type 'binding' are considered as template guard.\n\n\n      if (type !== 'binding') {\n        return null;\n      }\n\n      return {\n        inputName: inputName,\n        type: type\n      };\n    } else if (member.kind === reflection_1.ClassMemberKind.Method) {\n      return {\n        inputName: inputName,\n        type: 'invocation'\n      };\n    } else {\n      return null;\n    }\n  }\n\n  function extractCoercedInput(member) {\n    if (member.kind !== reflection_1.ClassMemberKind.Property || !member.name.startsWith('ngAcceptInputType_')) {\n      return null;\n    }\n\n    return afterUnderscore(member.name);\n  }\n  /**\n   * A `MetadataReader` that reads from an ordered set of child readers until it obtains the requested\n   * metadata.\n   *\n   * This is used to combine `MetadataReader`s that read from different sources (e.g. from a registry\n   * and from .d.ts files).\n   */\n\n\n  var CompoundMetadataReader =\n  /** @class */\n  function () {\n    function CompoundMetadataReader(readers) {\n      this.readers = readers;\n    }\n\n    CompoundMetadataReader.prototype.getDirectiveMetadata = function (node) {\n      var e_2, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var reader = _c.value;\n          var meta = reader.getDirectiveMetadata(node);\n\n          if (meta !== null) {\n            return meta;\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return null;\n    };\n\n    CompoundMetadataReader.prototype.getNgModuleMetadata = function (node) {\n      var e_3, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var reader = _c.value;\n          var meta = reader.getNgModuleMetadata(node);\n\n          if (meta !== null) {\n            return meta;\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return null;\n    };\n\n    CompoundMetadataReader.prototype.getPipeMetadata = function (node) {\n      var e_4, _a;\n\n      try {\n        for (var _b = tslib_1.__values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var reader = _c.value;\n          var meta = reader.getPipeMetadata(node);\n\n          if (meta !== null) {\n            return meta;\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      return null;\n    };\n\n    return CompoundMetadataReader;\n  }();\n\n  exports.CompoundMetadataReader = CompoundMetadataReader;\n\n  function afterUnderscore(str) {\n    var pos = str.indexOf('_');\n\n    if (pos === -1) {\n      throw new Error(\"Expected '\" + str + \"' to contain '_'\");\n    }\n\n    return str.substr(pos + 1);\n  }\n  /** Returns whether a class declaration has the necessary class fields to make it injectable. */\n\n\n  function hasInjectableFields(clazz, host) {\n    var members = host.getMembersOfClass(clazz);\n    return members.some(function (_a) {\n      var isStatic = _a.isStatic,\n          name = _a.name;\n      return isStatic && (name === 'ɵprov' || name === 'ɵfac' || name === 'ɵinj');\n    });\n  }\n\n  exports.hasInjectableFields = hasInjectableFields;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {Reference} from '../../imports';\nimport {ClassDeclaration, ClassMember, ClassMemberKind, isNamedClassDeclaration, ReflectionHost, reflectTypeEntityToDeclaration} from '../../reflection';\nimport {nodeDebugInfo} from '../../util/src/typescript';\n\nimport {DirectiveMeta, DirectiveTypeCheckMeta, MetadataReader, NgModuleMeta, PipeMeta, TemplateGuardMeta} from './api';\nimport {ClassPropertyMapping, ClassPropertyName} from './property_mapping';\n\nexport function extractReferencesFromType(\n    checker: ts.TypeChecker, def: ts.TypeNode, ngModuleImportedFrom: string|null,\n    resolutionContext: string): Reference<ClassDeclaration>[] {\n  if (!ts.isTupleTypeNode(def)) {\n    return [];\n  }\n\n  return def.elements.map(element => {\n    if (!ts.isTypeQueryNode(element)) {\n      throw new Error(`Expected TypeQueryNode: ${nodeDebugInfo(element)}`);\n    }\n    const type = element.exprName;\n    const {node, from} = reflectTypeEntityToDeclaration(type, checker);\n    if (!isNamedClassDeclaration(node)) {\n      throw new Error(`Expected named ClassDeclaration: ${nodeDebugInfo(node)}`);\n    }\n    const specifier = (from !== null && !from.startsWith('.') ? from : ngModuleImportedFrom);\n    if (specifier !== null) {\n      return new Reference(node, {specifier, resolutionContext});\n    } else {\n      return new Reference(node);\n    }\n  });\n}\n\nexport function readStringType(type: ts.TypeNode): string|null {\n  if (!ts.isLiteralTypeNode(type) || !ts.isStringLiteral(type.literal)) {\n    return null;\n  }\n  return type.literal.text;\n}\n\nexport function readStringMapType(type: ts.TypeNode): {[key: string]: string} {\n  if (!ts.isTypeLiteralNode(type)) {\n    return {};\n  }\n  const obj: {[key: string]: string} = {};\n  type.members.forEach(member => {\n    if (!ts.isPropertySignature(member) || member.type === undefined || member.name === undefined ||\n        !ts.isStringLiteral(member.name)) {\n      return;\n    }\n    const value = readStringType(member.type);\n    if (value === null) {\n      return null;\n    }\n    obj[member.name.text] = value;\n  });\n  return obj;\n}\n\nexport function readStringArrayType(type: ts.TypeNode): string[] {\n  if (!ts.isTupleTypeNode(type)) {\n    return [];\n  }\n  const res: string[] = [];\n  type.elements.forEach(el => {\n    if (!ts.isLiteralTypeNode(el) || !ts.isStringLiteral(el.literal)) {\n      return;\n    }\n    res.push(el.literal.text);\n  });\n  return res;\n}\n\n/**\n * Inspects the class' members and extracts the metadata that is used when type-checking templates\n * that use the directive. This metadata does not contain information from a base class, if any,\n * making this metadata invariant to changes of inherited classes.\n */\nexport function extractDirectiveTypeCheckMeta(\n    node: ClassDeclaration, inputs: ClassPropertyMapping,\n    reflector: ReflectionHost): DirectiveTypeCheckMeta {\n  const members = reflector.getMembersOfClass(node);\n  const staticMembers = members.filter(member => member.isStatic);\n  const ngTemplateGuards = staticMembers.map(extractTemplateGuard)\n                               .filter((guard): guard is TemplateGuardMeta => guard !== null);\n  const hasNgTemplateContextGuard = staticMembers.some(\n      member => member.kind === ClassMemberKind.Method && member.name === 'ngTemplateContextGuard');\n\n  const coercedInputFields =\n      new Set(staticMembers.map(extractCoercedInput)\n                  .filter((inputName): inputName is ClassPropertyName => inputName !== null));\n\n  const restrictedInputFields = new Set<ClassPropertyName>();\n  const stringLiteralInputFields = new Set<ClassPropertyName>();\n  const undeclaredInputFields = new Set<ClassPropertyName>();\n\n  for (const classPropertyName of inputs.classPropertyNames) {\n    const field = members.find(member => member.name === classPropertyName);\n    if (field === undefined || field.node === null) {\n      undeclaredInputFields.add(classPropertyName);\n      continue;\n    }\n    if (isRestricted(field.node)) {\n      restrictedInputFields.add(classPropertyName);\n    }\n    if (field.nameNode !== null && ts.isStringLiteral(field.nameNode)) {\n      stringLiteralInputFields.add(classPropertyName);\n    }\n  }\n\n  const arity = reflector.getGenericArityOfClass(node);\n\n  return {\n    hasNgTemplateContextGuard,\n    ngTemplateGuards,\n    coercedInputFields,\n    restrictedInputFields,\n    stringLiteralInputFields,\n    undeclaredInputFields,\n    isGeneric: arity !== null && arity > 0,\n  };\n}\n\nfunction isRestricted(node: ts.Node): boolean {\n  if (node.modifiers === undefined) {\n    return false;\n  }\n\n  return node.modifiers.some(\n      modifier => modifier.kind === ts.SyntaxKind.PrivateKeyword ||\n          modifier.kind === ts.SyntaxKind.ProtectedKeyword ||\n          modifier.kind === ts.SyntaxKind.ReadonlyKeyword);\n}\n\nfunction extractTemplateGuard(member: ClassMember): TemplateGuardMeta|null {\n  if (!member.name.startsWith('ngTemplateGuard_')) {\n    return null;\n  }\n  const inputName = afterUnderscore(member.name);\n  if (member.kind === ClassMemberKind.Property) {\n    let type: string|null = null;\n    if (member.type !== null && ts.isLiteralTypeNode(member.type) &&\n        ts.isStringLiteral(member.type.literal)) {\n      type = member.type.literal.text;\n    }\n\n    // Only property members with string literal type 'binding' are considered as template guard.\n    if (type !== 'binding') {\n      return null;\n    }\n    return {inputName, type};\n  } else if (member.kind === ClassMemberKind.Method) {\n    return {inputName, type: 'invocation'};\n  } else {\n    return null;\n  }\n}\n\nfunction extractCoercedInput(member: ClassMember): string|null {\n  if (member.kind !== ClassMemberKind.Property || !member.name.startsWith('ngAcceptInputType_')) {\n    return null!;\n  }\n  return afterUnderscore(member.name);\n}\n\n/**\n * A `MetadataReader` that reads from an ordered set of child readers until it obtains the requested\n * metadata.\n *\n * This is used to combine `MetadataReader`s that read from different sources (e.g. from a registry\n * and from .d.ts files).\n */\nexport class CompoundMetadataReader implements MetadataReader {\n  constructor(private readers: MetadataReader[]) {}\n\n  getDirectiveMetadata(node: Reference<ClassDeclaration<ts.Declaration>>): DirectiveMeta|null {\n    for (const reader of this.readers) {\n      const meta = reader.getDirectiveMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n\n  getNgModuleMetadata(node: Reference<ClassDeclaration<ts.Declaration>>): NgModuleMeta|null {\n    for (const reader of this.readers) {\n      const meta = reader.getNgModuleMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n  getPipeMetadata(node: Reference<ClassDeclaration<ts.Declaration>>): PipeMeta|null {\n    for (const reader of this.readers) {\n      const meta = reader.getPipeMetadata(node);\n      if (meta !== null) {\n        return meta;\n      }\n    }\n    return null;\n  }\n}\n\nfunction afterUnderscore(str: string): string {\n  const pos = str.indexOf('_');\n  if (pos === -1) {\n    throw new Error(`Expected '${str}' to contain '_'`);\n  }\n  return str.substr(pos + 1);\n}\n\n/** Returns whether a class declaration has the necessary class fields to make it injectable. */\nexport function hasInjectableFields(clazz: ClassDeclaration, host: ReflectionHost): boolean {\n  const members = host.getMembersOfClass(clazz);\n  return members.some(\n      ({isStatic, name}) => isStatic && (name === 'ɵprov' || name === 'ɵfac' || name === 'ɵinj'));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}