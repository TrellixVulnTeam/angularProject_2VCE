{"ast":null,"code":"'use strict';\n/* global window: true */\n\n/* eslint-disable\n  no-shadow,\n  no-param-reassign,\n  space-before-function-paren\n*/\n\nvar LogLevel = require('./LogLevel');\n\nvar MethodFactory = require('./MethodFactory');\n\nvar PrefixFactory = require('./PrefixFactory');\n\nvar defaultLogger = new LogLevel({\n  name: 'default'\n});\nvar cache = {\n  default: defaultLogger\n}; // Grab the current global log variable in case of overwrite\n\nvar existing = typeof window !== 'undefined' ? window.log : null;\nvar loglevel = Object.assign(defaultLogger, {\n  get factories() {\n    return {\n      MethodFactory: MethodFactory,\n      PrefixFactory: PrefixFactory\n    };\n  },\n\n  get loggers() {\n    return cache;\n  },\n\n  getLogger: function getLogger(options) {\n    if (typeof options === 'string') {\n      options = {\n        name: options\n      };\n    }\n\n    if (!options.id) {\n      options.id = options.name;\n    }\n\n    var _options = options,\n        name = _options.name,\n        id = _options.id;\n    var defaults = {\n      level: defaultLogger.level\n    };\n\n    if (typeof name !== 'string' || !name || !name.length) {\n      throw new TypeError('You must supply a name when creating a logger');\n    }\n\n    var logger = cache[id];\n\n    if (!logger) {\n      logger = new LogLevel(Object.assign({}, defaults, options));\n      cache[id] = logger;\n    }\n\n    return logger;\n  },\n  noConflict: function noConflict() {\n    if (typeof window !== 'undefined' && window.log === defaultLogger) {\n      window.log = existing;\n    }\n\n    return defaultLogger;\n  }\n});\nmodule.exports = loglevel;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack-log/src/loglevel/index.js"],"names":["LogLevel","require","MethodFactory","PrefixFactory","defaultLogger","name","cache","default","existing","window","log","loglevel","Object","assign","factories","loggers","getLogger","options","id","defaults","level","length","TypeError","logger","noConflict","module","exports"],"mappings":"AAAA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,YAAD,CAAxB;;AACA,IAAMC,aAAa,GAAGD,OAAO,CAAC,iBAAD,CAA7B;;AACA,IAAME,aAAa,GAAGF,OAAO,CAAC,iBAAD,CAA7B;;AAEA,IAAMG,aAAa,GAAG,IAAIJ,QAAJ,CAAa;AAAEK,EAAAA,IAAI,EAAE;AAAR,CAAb,CAAtB;AACA,IAAMC,KAAK,GAAG;AAAEC,EAAAA,OAAO,EAAEH;AAAX,CAAd,C,CAEA;;AACA,IAAMI,QAAQ,GAAI,OAAOC,MAAP,KAAkB,WAAnB,GAAkCA,MAAM,CAACC,GAAzC,GAA+C,IAAhE;AAEA,IAAMC,QAAQ,GAAGC,MAAM,CAACC,MAAP,CAAcT,aAAd,EAA6B;AAC5C,MAAIU,SAAJ,GAAgB;AACd,WAAO;AACLZ,MAAAA,aAAa,EAAbA,aADK;AAELC,MAAAA,aAAa,EAAbA;AAFK,KAAP;AAID,GAN2C;;AAO5C,MAAIY,OAAJ,GAAc;AACZ,WAAOT,KAAP;AACD,GAT2C;;AAU5CU,EAAAA,SAV4C,qBAUlCC,OAVkC,EAUzB;AACjB,QAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,MAAAA,OAAO,GAAG;AAAEZ,QAAAA,IAAI,EAAEY;AAAR,OAAV;AACD;;AAED,QAAI,CAACA,OAAO,CAACC,EAAb,EAAiB;AACfD,MAAAA,OAAO,CAACC,EAAR,GAAaD,OAAO,CAACZ,IAArB;AACD;;AAED,mBAAqBY,OAArB;AAAA,QAAQZ,IAAR,YAAQA,IAAR;AAAA,QAAca,EAAd,YAAcA,EAAd;AACA,QAAMC,QAAQ,GAAG;AAAEC,MAAAA,KAAK,EAAEhB,aAAa,CAACgB;AAAvB,KAAjB;;AAEA,QAAI,OAAOf,IAAP,KAAgB,QAAhB,IAA4B,CAACA,IAA7B,IAAqC,CAACA,IAAI,CAACgB,MAA/C,EAAuD;AACrD,YAAM,IAAIC,SAAJ,CAAc,+CAAd,CAAN;AACD;;AAED,QAAIC,MAAM,GAAGjB,KAAK,CAACY,EAAD,CAAlB;;AAEA,QAAI,CAACK,MAAL,EAAa;AACXA,MAAAA,MAAM,GAAG,IAAIvB,QAAJ,CAAaY,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBM,QAAlB,EAA4BF,OAA5B,CAAb,CAAT;AAEAX,MAAAA,KAAK,CAACY,EAAD,CAAL,GAAYK,MAAZ;AACD;;AAED,WAAOA,MAAP;AACD,GAnC2C;AAoC5CC,EAAAA,UApC4C,wBAoC/B;AACX,QAAI,OAAOf,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,GAAP,KAAeN,aAApD,EAAmE;AACjEK,MAAAA,MAAM,CAACC,GAAP,GAAaF,QAAb;AACD;;AAED,WAAOJ,aAAP;AACD;AA1C2C,CAA7B,CAAjB;AA6CAqB,MAAM,CAACC,OAAP,GAAiBf,QAAjB","sourcesContent":["'use strict';\n\n/* global window: true */\n/* eslint-disable\n  no-shadow,\n  no-param-reassign,\n  space-before-function-paren\n*/\nconst LogLevel = require('./LogLevel');\nconst MethodFactory = require('./MethodFactory');\nconst PrefixFactory = require('./PrefixFactory');\n\nconst defaultLogger = new LogLevel({ name: 'default' });\nconst cache = { default: defaultLogger };\n\n// Grab the current global log variable in case of overwrite\nconst existing = (typeof window !== 'undefined') ? window.log : null;\n\nconst loglevel = Object.assign(defaultLogger, {\n  get factories() {\n    return {\n      MethodFactory,\n      PrefixFactory\n    };\n  },\n  get loggers() {\n    return cache;\n  },\n  getLogger(options) {\n    if (typeof options === 'string') {\n      options = { name: options };\n    }\n\n    if (!options.id) {\n      options.id = options.name;\n    }\n\n    const { name, id } = options;\n    const defaults = { level: defaultLogger.level };\n\n    if (typeof name !== 'string' || !name || !name.length) {\n      throw new TypeError('You must supply a name when creating a logger');\n    }\n\n    let logger = cache[id];\n\n    if (!logger) {\n      logger = new LogLevel(Object.assign({}, defaults, options));\n\n      cache[id] = logger;\n    }\n\n    return logger;\n  },\n  noConflict() {\n    if (typeof window !== 'undefined' && window.log === defaultLogger) {\n      window.log = existing;\n    }\n\n    return defaultLogger;\n  }\n});\n\nmodule.exports = loglevel;\n"]},"metadata":{},"sourceType":"script"}