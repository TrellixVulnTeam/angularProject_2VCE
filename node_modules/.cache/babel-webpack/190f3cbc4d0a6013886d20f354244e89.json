{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/partial/pipe\", [\"require\", \"exports\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/render3/r3_identifiers\", \"@angular/compiler/src/render3/r3_pipe_compiler\", \"@angular/compiler/src/render3/view/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.createPipeDefinitionMap = exports.compileDeclarePipeFromMetadata = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var r3_identifiers_1 = require(\"@angular/compiler/src/render3/r3_identifiers\");\n\n  var r3_pipe_compiler_1 = require(\"@angular/compiler/src/render3/r3_pipe_compiler\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/view/util\");\n  /**\n   * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n   */\n\n\n  function compileDeclarePipeFromMetadata(meta) {\n    var definitionMap = createPipeDefinitionMap(meta);\n    var expression = o.importExpr(r3_identifiers_1.Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);\n    var type = r3_pipe_compiler_1.createPipeType(meta);\n    return {\n      expression: expression,\n      type: type\n    };\n  }\n\n  exports.compileDeclarePipeFromMetadata = compileDeclarePipeFromMetadata;\n  /**\n   * Gathers the declaration fields for a Pipe into a `DefinitionMap`. This allows for reusing\n   * this logic for components, as they extend the Pipe metadata.\n   */\n\n  function createPipeDefinitionMap(meta) {\n    var definitionMap = new util_1.DefinitionMap();\n    definitionMap.set('version', o.literal('11.2.14'));\n    definitionMap.set('ngImport', o.importExpr(r3_identifiers_1.Identifiers.core)); // e.g. `type: MyPipe`\n\n    definitionMap.set('type', meta.internalType); // e.g. `name: \"myPipe\"`\n\n    definitionMap.set('name', o.literal(meta.pipeName));\n\n    if (meta.pure === false) {\n      // e.g. `pure: false`\n      definitionMap.set('pure', o.literal(meta.pure));\n    }\n\n    return definitionMap;\n  }\n\n  exports.createPipeDefinitionMap = createPipeDefinitionMap;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/partial/pipe.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;;;;;AAMG;;AACH,MAAA,CAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AACA,MAAA,gBAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AACA,MAAA,kBAAA,GAAA,OAAA,CAAA,gDAAA,CAAA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;AAIA;;AAEG;;;AACH,WAAgB,8BAAhB,CAA+C,IAA/C,EAAmE;AACjE,QAAM,aAAa,GAAG,uBAAuB,CAAC,IAAD,CAA7C;AAEA,QAAM,UAAU,GAAG,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,WAAhB,EAA6B,MAA7B,CAAoC,CAAC,aAAa,CAAC,YAAd,EAAD,CAApC,CAAnB;AACA,QAAM,IAAI,GAAG,kBAAA,CAAA,cAAA,CAAe,IAAf,CAAb;AAEA,WAAO;AAAC,MAAA,UAAU,EAAA,UAAX;AAAa,MAAA,IAAI,EAAA;AAAjB,KAAP;AACD;;AAPD,EAAA,OAAA,CAAA,8BAAA,GAAA,8BAAA;AASA;;;AAGG;;AACH,WAAgB,uBAAhB,CAAwC,IAAxC,EAA4D;AAE1D,QAAM,aAAa,GAAG,IAAI,MAAA,CAAA,aAAJ,EAAtB;AAEA,IAAA,aAAa,CAAC,GAAd,CAAkB,SAAlB,EAA6B,CAAC,CAAC,OAAF,CAAU,SAAV,CAA7B;AACA,IAAA,aAAa,CAAC,GAAd,CAAkB,UAAlB,EAA8B,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,IAAhB,CAA9B,EAL0D,CAO1D;;AACA,IAAA,aAAa,CAAC,GAAd,CAAkB,MAAlB,EAA0B,IAAI,CAAC,YAA/B,EAR0D,CAS1D;;AACA,IAAA,aAAa,CAAC,GAAd,CAAkB,MAAlB,EAA0B,CAAC,CAAC,OAAF,CAAU,IAAI,CAAC,QAAf,CAA1B;;AAEA,QAAI,IAAI,CAAC,IAAL,KAAc,KAAlB,EAAyB;AACvB;AACA,MAAA,aAAa,CAAC,GAAd,CAAkB,MAAlB,EAA0B,CAAC,CAAC,OAAF,CAAU,IAAI,CAAC,IAAf,CAA1B;AACD;;AAED,WAAO,aAAP;AACD;;AAlBD,EAAA,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../../output/output_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {createPipeType, R3PipeMetadata} from '../r3_pipe_compiler';\nimport {R3PipeDef} from '../view/api';\nimport {DefinitionMap} from '../view/util';\nimport {R3DeclarePipeMetadata} from './api';\n\n\n/**\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\n */\nexport function compileDeclarePipeFromMetadata(meta: R3PipeMetadata): R3PipeDef {\n  const definitionMap = createPipeDefinitionMap(meta);\n\n  const expression = o.importExpr(R3.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  const type = createPipeType(meta);\n\n  return {expression, type};\n}\n\n/**\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`. This allows for reusing\n * this logic for components, as they extend the Pipe metadata.\n */\nexport function createPipeDefinitionMap(meta: R3PipeMetadata):\n    DefinitionMap<R3DeclarePipeMetadata> {\n  const definitionMap = new DefinitionMap<R3DeclarePipeMetadata>();\n\n  definitionMap.set('version', o.literal('0.0.0-PLACEHOLDER'));\n  definitionMap.set('ngImport', o.importExpr(R3.core));\n\n  // e.g. `type: MyPipe`\n  definitionMap.set('type', meta.internalType);\n  // e.g. `name: \"myPipe\"`\n  definitionMap.set('name', o.literal(meta.pipeName));\n\n  if (meta.pure === false) {\n    // e.g. `pure: false`\n    definitionMap.set('pure', o.literal(meta.pure));\n  }\n\n  return definitionMap;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}