{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/expression\", [\"require\", \"exports\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/diagnostics\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.astToTypescript = exports.NULL_AS_ANY = void 0;\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/diagnostics\");\n\n  var ts_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\");\n\n  exports.NULL_AS_ANY = ts.createAsExpression(ts.createNull(), ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\n  var UNDEFINED = ts.createIdentifier('undefined');\n  var UNARY_OPS = new Map([['+', ts.SyntaxKind.PlusToken], ['-', ts.SyntaxKind.MinusToken]]);\n  var BINARY_OPS = new Map([['+', ts.SyntaxKind.PlusToken], ['-', ts.SyntaxKind.MinusToken], ['<', ts.SyntaxKind.LessThanToken], ['>', ts.SyntaxKind.GreaterThanToken], ['<=', ts.SyntaxKind.LessThanEqualsToken], ['>=', ts.SyntaxKind.GreaterThanEqualsToken], ['==', ts.SyntaxKind.EqualsEqualsToken], ['===', ts.SyntaxKind.EqualsEqualsEqualsToken], ['*', ts.SyntaxKind.AsteriskToken], ['/', ts.SyntaxKind.SlashToken], ['%', ts.SyntaxKind.PercentToken], ['!=', ts.SyntaxKind.ExclamationEqualsToken], ['!==', ts.SyntaxKind.ExclamationEqualsEqualsToken], ['||', ts.SyntaxKind.BarBarToken], ['&&', ts.SyntaxKind.AmpersandAmpersandToken], ['&', ts.SyntaxKind.AmpersandToken], ['|', ts.SyntaxKind.BarToken]]);\n  /**\n   * Convert an `AST` to TypeScript code directly, without going through an intermediate `Expression`\n   * AST.\n   */\n\n  function astToTypescript(ast, maybeResolve, config) {\n    var translator = new AstTranslator(maybeResolve, config);\n    return translator.translate(ast);\n  }\n\n  exports.astToTypescript = astToTypescript;\n\n  var AstTranslator =\n  /** @class */\n  function () {\n    function AstTranslator(maybeResolve, config) {\n      this.maybeResolve = maybeResolve;\n      this.config = config;\n    }\n\n    AstTranslator.prototype.translate = function (ast) {\n      // Skip over an `ASTWithSource` as its `visit` method calls directly into its ast's `visit`,\n      // which would prevent any custom resolution through `maybeResolve` for that node.\n      if (ast instanceof compiler_1.ASTWithSource) {\n        ast = ast.ast;\n      } // The `EmptyExpr` doesn't have a dedicated method on `AstVisitor`, so it's special cased here.\n\n\n      if (ast instanceof compiler_1.EmptyExpr) {\n        var res = ts.factory.createIdentifier('undefined');\n        diagnostics_1.addParseSpanInfo(res, ast.sourceSpan);\n        return res;\n      } // First attempt to let any custom resolution logic provide a translation for the given node.\n\n\n      var resolved = this.maybeResolve(ast);\n\n      if (resolved !== null) {\n        return resolved;\n      }\n\n      return ast.visit(this);\n    };\n\n    AstTranslator.prototype.visitUnary = function (ast) {\n      var expr = this.translate(ast.expr);\n      var op = UNARY_OPS.get(ast.operator);\n\n      if (op === undefined) {\n        throw new Error(\"Unsupported Unary.operator: \" + ast.operator);\n      }\n\n      var node = diagnostics_1.wrapForDiagnostics(ts.createPrefix(op, expr));\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitBinary = function (ast) {\n      var lhs = diagnostics_1.wrapForDiagnostics(this.translate(ast.left));\n      var rhs = diagnostics_1.wrapForDiagnostics(this.translate(ast.right));\n      var op = BINARY_OPS.get(ast.operation);\n\n      if (op === undefined) {\n        throw new Error(\"Unsupported Binary.operation: \" + ast.operation);\n      }\n\n      var node = ts.createBinary(lhs, op, rhs);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitChain = function (ast) {\n      var _this = this;\n\n      var elements = ast.expressions.map(function (expr) {\n        return _this.translate(expr);\n      });\n      var node = diagnostics_1.wrapForDiagnostics(ts.createCommaList(elements));\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitConditional = function (ast) {\n      var condExpr = this.translate(ast.condition);\n      var trueExpr = this.translate(ast.trueExp); // Wrap `falseExpr` in parens so that the trailing parse span info is not attributed to the\n      // whole conditional.\n      // In the following example, the last source span comment (5,6) could be seen as the\n      // trailing comment for _either_ the whole conditional expression _or_ just the `falseExpr` that\n      // is immediately before it:\n      // `conditional /*1,2*/ ? trueExpr /*3,4*/ : falseExpr /*5,6*/`\n      // This should be instead be `conditional /*1,2*/ ? trueExpr /*3,4*/ : (falseExpr /*5,6*/)`\n\n      var falseExpr = diagnostics_1.wrapForTypeChecker(this.translate(ast.falseExp));\n      var node = ts.createParen(ts.createConditional(condExpr, trueExpr, falseExpr));\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitFunctionCall = function (ast) {\n      var _this = this;\n\n      var receiver = diagnostics_1.wrapForDiagnostics(this.translate(ast.target));\n      var args = ast.args.map(function (expr) {\n        return _this.translate(expr);\n      });\n      var node = ts.createCall(receiver, undefined, args);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitImplicitReceiver = function (ast) {\n      throw new Error('Method not implemented.');\n    };\n\n    AstTranslator.prototype.visitThisReceiver = function (ast) {\n      throw new Error('Method not implemented.');\n    };\n\n    AstTranslator.prototype.visitInterpolation = function (ast) {\n      var _this = this; // Build up a chain of binary + operations to simulate the string concatenation of the\n      // interpolation's expressions. The chain is started using an actual string literal to ensure\n      // the type is inferred as 'string'.\n\n\n      return ast.expressions.reduce(function (lhs, ast) {\n        return ts.createBinary(lhs, ts.SyntaxKind.PlusToken, diagnostics_1.wrapForTypeChecker(_this.translate(ast)));\n      }, ts.createLiteral(''));\n    };\n\n    AstTranslator.prototype.visitKeyedRead = function (ast) {\n      var receiver = diagnostics_1.wrapForDiagnostics(this.translate(ast.obj));\n      var key = this.translate(ast.key);\n      var node = ts.createElementAccess(receiver, key);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitKeyedWrite = function (ast) {\n      var receiver = diagnostics_1.wrapForDiagnostics(this.translate(ast.obj));\n      var left = ts.createElementAccess(receiver, this.translate(ast.key)); // TODO(joost): annotate `left` with the span of the element access, which is not currently\n      //  available on `ast`.\n\n      var right = diagnostics_1.wrapForTypeChecker(this.translate(ast.value));\n      var node = diagnostics_1.wrapForDiagnostics(ts.createBinary(left, ts.SyntaxKind.EqualsToken, right));\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitLiteralArray = function (ast) {\n      var _this = this;\n\n      var elements = ast.expressions.map(function (expr) {\n        return _this.translate(expr);\n      });\n      var literal = ts.createArrayLiteral(elements); // If strictLiteralTypes is disabled, array literals are cast to `any`.\n\n      var node = this.config.strictLiteralTypes ? literal : ts_util_1.tsCastToAny(literal);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitLiteralMap = function (ast) {\n      var _this = this;\n\n      var properties = ast.keys.map(function (_a, idx) {\n        var key = _a.key;\n\n        var value = _this.translate(ast.values[idx]);\n\n        return ts.createPropertyAssignment(ts.createStringLiteral(key), value);\n      });\n      var literal = ts.createObjectLiteral(properties, true); // If strictLiteralTypes is disabled, object literals are cast to `any`.\n\n      var node = this.config.strictLiteralTypes ? literal : ts_util_1.tsCastToAny(literal);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitLiteralPrimitive = function (ast) {\n      var node;\n\n      if (ast.value === undefined) {\n        node = ts.createIdentifier('undefined');\n      } else if (ast.value === null) {\n        node = ts.createNull();\n      } else {\n        node = ts.createLiteral(ast.value);\n      }\n\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitMethodCall = function (ast) {\n      var _this = this;\n\n      var receiver = diagnostics_1.wrapForDiagnostics(this.translate(ast.receiver));\n      var method = ts.createPropertyAccess(receiver, ast.name);\n      diagnostics_1.addParseSpanInfo(method, ast.nameSpan);\n      var args = ast.args.map(function (expr) {\n        return _this.translate(expr);\n      });\n      var node = ts.createCall(method, undefined, args);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitNonNullAssert = function (ast) {\n      var expr = diagnostics_1.wrapForDiagnostics(this.translate(ast.expression));\n      var node = ts.createNonNullExpression(expr);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitPipe = function (ast) {\n      throw new Error('Method not implemented.');\n    };\n\n    AstTranslator.prototype.visitPrefixNot = function (ast) {\n      var expression = diagnostics_1.wrapForDiagnostics(this.translate(ast.expression));\n      var node = ts.createLogicalNot(expression);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitPropertyRead = function (ast) {\n      // This is a normal property read - convert the receiver to an expression and emit the correct\n      // TypeScript expression to read the property.\n      var receiver = diagnostics_1.wrapForDiagnostics(this.translate(ast.receiver));\n      var name = ts.createPropertyAccess(receiver, ast.name);\n      diagnostics_1.addParseSpanInfo(name, ast.nameSpan);\n      var node = diagnostics_1.wrapForDiagnostics(name);\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitPropertyWrite = function (ast) {\n      var receiver = diagnostics_1.wrapForDiagnostics(this.translate(ast.receiver));\n      var left = ts.createPropertyAccess(receiver, ast.name);\n      diagnostics_1.addParseSpanInfo(left, ast.nameSpan); // TypeScript reports assignment errors on the entire lvalue expression. Annotate the lvalue of\n      // the assignment with the sourceSpan, which includes receivers, rather than nameSpan for\n      // consistency of the diagnostic location.\n      // a.b.c = 1\n      // ^^^^^^^^^ sourceSpan\n      //     ^     nameSpan\n\n      var leftWithPath = diagnostics_1.wrapForDiagnostics(left);\n      diagnostics_1.addParseSpanInfo(leftWithPath, ast.sourceSpan); // The right needs to be wrapped in parens as well or we cannot accurately match its\n      // span to just the RHS. For example, the span in `e = $event /*0,10*/` is ambiguous.\n      // It could refer to either the whole binary expression or just the RHS.\n      // We should instead generate `e = ($event /*0,10*/)` so we know the span 0,10 matches RHS.\n\n      var right = diagnostics_1.wrapForTypeChecker(this.translate(ast.value));\n      var node = diagnostics_1.wrapForDiagnostics(ts.createBinary(leftWithPath, ts.SyntaxKind.EqualsToken, right));\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitQuote = function (ast) {\n      return exports.NULL_AS_ANY;\n    };\n\n    AstTranslator.prototype.visitSafeMethodCall = function (ast) {\n      var _this = this; // See the comments in SafePropertyRead above for an explanation of the cases here.\n\n\n      var node;\n      var receiver = diagnostics_1.wrapForDiagnostics(this.translate(ast.receiver));\n      var args = ast.args.map(function (expr) {\n        return _this.translate(expr);\n      });\n\n      if (this.config.strictSafeNavigationTypes) {\n        // \"a?.method(...)\" becomes (null as any ? a!.method(...) : undefined)\n        var method = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n        diagnostics_1.addParseSpanInfo(method, ast.nameSpan);\n        var call = ts.createCall(method, undefined, args);\n        node = ts.createParen(ts.createConditional(exports.NULL_AS_ANY, call, UNDEFINED));\n      } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n        // \"a?.method(...)\" becomes (a as any).method(...)\n        var method = ts.createPropertyAccess(ts_util_1.tsCastToAny(receiver), ast.name);\n        diagnostics_1.addParseSpanInfo(method, ast.nameSpan);\n        node = ts.createCall(method, undefined, args);\n      } else {\n        // \"a?.method(...)\" becomes (a!.method(...) as any)\n        var method = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n        diagnostics_1.addParseSpanInfo(method, ast.nameSpan);\n        node = ts_util_1.tsCastToAny(ts.createCall(method, undefined, args));\n      }\n\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    AstTranslator.prototype.visitSafePropertyRead = function (ast) {\n      var node;\n      var receiver = diagnostics_1.wrapForDiagnostics(this.translate(ast.receiver)); // The form of safe property reads depends on whether strictness is in use.\n\n      if (this.config.strictSafeNavigationTypes) {\n        // Basically, the return here is either the type of the complete expression with a null-safe\n        // property read, or `undefined`. So a ternary is used to create an \"or\" type:\n        // \"a?.b\" becomes (null as any ? a!.b : undefined)\n        // The type of this expression is (typeof a!.b) | undefined, which is exactly as desired.\n        var expr = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n        diagnostics_1.addParseSpanInfo(expr, ast.nameSpan);\n        node = ts.createParen(ts.createConditional(exports.NULL_AS_ANY, expr, UNDEFINED));\n      } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n        // Emulate a View Engine bug where 'any' is inferred for the left-hand side of the safe\n        // navigation operation. With this bug, the type of the left-hand side is regarded as any.\n        // Therefore, the left-hand side only needs repeating in the output (to validate it), and then\n        // 'any' is used for the rest of the expression. This is done using a comma operator:\n        // \"a?.b\" becomes (a as any).b, which will of course have type 'any'.\n        node = ts.createPropertyAccess(ts_util_1.tsCastToAny(receiver), ast.name);\n      } else {\n        // The View Engine bug isn't active, so check the entire type of the expression, but the final\n        // result is still inferred as `any`.\n        // \"a?.b\" becomes (a!.b as any)\n        var expr = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n        diagnostics_1.addParseSpanInfo(expr, ast.nameSpan);\n        node = ts_util_1.tsCastToAny(expr);\n      }\n\n      diagnostics_1.addParseSpanInfo(node, ast.sourceSpan);\n      return node;\n    };\n\n    return AstTranslator;\n  }();\n  /**\n   * Checks whether View Engine will infer a type of 'any' for the left-hand side of a safe navigation\n   * operation.\n   *\n   * In View Engine's template type-checker, certain receivers of safe navigation operations will\n   * cause a temporary variable to be allocated as part of the checking expression, to save the value\n   * of the receiver and use it more than once in the expression. This temporary variable has type\n   * 'any'. In practice, this means certain receivers cause View Engine to not check the full\n   * expression, and other receivers will receive more complete checking.\n   *\n   * For compatibility, this logic is adapted from View Engine's expression_converter.ts so that the\n   * Ivy checker can emulate this bug when needed.\n   */\n\n\n  var VeSafeLhsInferenceBugDetector =\n  /** @class */\n  function () {\n    function VeSafeLhsInferenceBugDetector() {}\n\n    VeSafeLhsInferenceBugDetector.veWillInferAnyFor = function (ast) {\n      return ast.receiver.visit(VeSafeLhsInferenceBugDetector.SINGLETON);\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitUnary = function (ast) {\n      return ast.expr.visit(this);\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitBinary = function (ast) {\n      return ast.left.visit(this) || ast.right.visit(this);\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitChain = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitConditional = function (ast) {\n      return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitFunctionCall = function (ast) {\n      return true;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitImplicitReceiver = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitThisReceiver = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitInterpolation = function (ast) {\n      var _this = this;\n\n      return ast.expressions.some(function (exp) {\n        return exp.visit(_this);\n      });\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitKeyedRead = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitKeyedWrite = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitLiteralArray = function (ast) {\n      return true;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitLiteralMap = function (ast) {\n      return true;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitLiteralPrimitive = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitMethodCall = function (ast) {\n      return true;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitPipe = function (ast) {\n      return true;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitPrefixNot = function (ast) {\n      return ast.expression.visit(this);\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitNonNullAssert = function (ast) {\n      return ast.expression.visit(this);\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitPropertyRead = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitPropertyWrite = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitQuote = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitSafeMethodCall = function (ast) {\n      return true;\n    };\n\n    VeSafeLhsInferenceBugDetector.prototype.visitSafePropertyRead = function (ast) {\n      return false;\n    };\n\n    VeSafeLhsInferenceBugDetector.SINGLETON = new VeSafeLhsInferenceBugDetector();\n    return VeSafeLhsInferenceBugDetector;\n  }();\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/expression.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST, AstVisitor, ASTWithSource, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralPrimitive, MethodCall, NonNullAssert, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, ThisReceiver, Unary} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {TypeCheckingConfig} from '../api';\n\nimport {addParseSpanInfo, wrapForDiagnostics, wrapForTypeChecker} from './diagnostics';\nimport {tsCastToAny} from './ts_util';\n\nexport const NULL_AS_ANY =\n    ts.createAsExpression(ts.createNull(), ts.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));\nconst UNDEFINED = ts.createIdentifier('undefined');\n\nconst UNARY_OPS = new Map<string, ts.PrefixUnaryOperator>([\n  ['+', ts.SyntaxKind.PlusToken],\n  ['-', ts.SyntaxKind.MinusToken],\n]);\n\nconst BINARY_OPS = new Map<string, ts.BinaryOperator>([\n  ['+', ts.SyntaxKind.PlusToken],\n  ['-', ts.SyntaxKind.MinusToken],\n  ['<', ts.SyntaxKind.LessThanToken],\n  ['>', ts.SyntaxKind.GreaterThanToken],\n  ['<=', ts.SyntaxKind.LessThanEqualsToken],\n  ['>=', ts.SyntaxKind.GreaterThanEqualsToken],\n  ['==', ts.SyntaxKind.EqualsEqualsToken],\n  ['===', ts.SyntaxKind.EqualsEqualsEqualsToken],\n  ['*', ts.SyntaxKind.AsteriskToken],\n  ['/', ts.SyntaxKind.SlashToken],\n  ['%', ts.SyntaxKind.PercentToken],\n  ['!=', ts.SyntaxKind.ExclamationEqualsToken],\n  ['!==', ts.SyntaxKind.ExclamationEqualsEqualsToken],\n  ['||', ts.SyntaxKind.BarBarToken],\n  ['&&', ts.SyntaxKind.AmpersandAmpersandToken],\n  ['&', ts.SyntaxKind.AmpersandToken],\n  ['|', ts.SyntaxKind.BarToken],\n]);\n\n/**\n * Convert an `AST` to TypeScript code directly, without going through an intermediate `Expression`\n * AST.\n */\nexport function astToTypescript(\n    ast: AST, maybeResolve: (ast: AST) => (ts.Expression | null),\n    config: TypeCheckingConfig): ts.Expression {\n  const translator = new AstTranslator(maybeResolve, config);\n  return translator.translate(ast);\n}\n\nclass AstTranslator implements AstVisitor {\n  constructor(\n      private maybeResolve: (ast: AST) => (ts.Expression | null),\n      private config: TypeCheckingConfig) {}\n\n  translate(ast: AST): ts.Expression {\n    // Skip over an `ASTWithSource` as its `visit` method calls directly into its ast's `visit`,\n    // which would prevent any custom resolution through `maybeResolve` for that node.\n    if (ast instanceof ASTWithSource) {\n      ast = ast.ast;\n    }\n\n    // The `EmptyExpr` doesn't have a dedicated method on `AstVisitor`, so it's special cased here.\n    if (ast instanceof EmptyExpr) {\n      const res = ts.factory.createIdentifier('undefined');\n      addParseSpanInfo(res, ast.sourceSpan);\n      return res;\n    }\n\n    // First attempt to let any custom resolution logic provide a translation for the given node.\n    const resolved = this.maybeResolve(ast);\n    if (resolved !== null) {\n      return resolved;\n    }\n\n    return ast.visit(this);\n  }\n\n  visitUnary(ast: Unary): ts.Expression {\n    const expr = this.translate(ast.expr);\n    const op = UNARY_OPS.get(ast.operator);\n    if (op === undefined) {\n      throw new Error(`Unsupported Unary.operator: ${ast.operator}`);\n    }\n    const node = wrapForDiagnostics(ts.createPrefix(op, expr));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitBinary(ast: Binary): ts.Expression {\n    const lhs = wrapForDiagnostics(this.translate(ast.left));\n    const rhs = wrapForDiagnostics(this.translate(ast.right));\n    const op = BINARY_OPS.get(ast.operation);\n    if (op === undefined) {\n      throw new Error(`Unsupported Binary.operation: ${ast.operation}`);\n    }\n    const node = ts.createBinary(lhs, op, rhs);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitChain(ast: Chain): ts.Expression {\n    const elements = ast.expressions.map(expr => this.translate(expr));\n    const node = wrapForDiagnostics(ts.createCommaList(elements));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitConditional(ast: Conditional): ts.Expression {\n    const condExpr = this.translate(ast.condition);\n    const trueExpr = this.translate(ast.trueExp);\n    // Wrap `falseExpr` in parens so that the trailing parse span info is not attributed to the\n    // whole conditional.\n    // In the following example, the last source span comment (5,6) could be seen as the\n    // trailing comment for _either_ the whole conditional expression _or_ just the `falseExpr` that\n    // is immediately before it:\n    // `conditional /*1,2*/ ? trueExpr /*3,4*/ : falseExpr /*5,6*/`\n    // This should be instead be `conditional /*1,2*/ ? trueExpr /*3,4*/ : (falseExpr /*5,6*/)`\n    const falseExpr = wrapForTypeChecker(this.translate(ast.falseExp));\n    const node = ts.createParen(ts.createConditional(condExpr, trueExpr, falseExpr));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitFunctionCall(ast: FunctionCall): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.target!));\n    const args = ast.args.map(expr => this.translate(expr));\n    const node = ts.createCall(receiver, undefined, args);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitImplicitReceiver(ast: ImplicitReceiver): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitThisReceiver(ast: ThisReceiver): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitInterpolation(ast: Interpolation): ts.Expression {\n    // Build up a chain of binary + operations to simulate the string concatenation of the\n    // interpolation's expressions. The chain is started using an actual string literal to ensure\n    // the type is inferred as 'string'.\n    return ast.expressions.reduce(\n        (lhs, ast) =>\n            ts.createBinary(lhs, ts.SyntaxKind.PlusToken, wrapForTypeChecker(this.translate(ast))),\n        ts.createLiteral(''));\n  }\n\n  visitKeyedRead(ast: KeyedRead): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.obj));\n    const key = this.translate(ast.key);\n    const node = ts.createElementAccess(receiver, key);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.obj));\n    const left = ts.createElementAccess(receiver, this.translate(ast.key));\n    // TODO(joost): annotate `left` with the span of the element access, which is not currently\n    //  available on `ast`.\n    const right = wrapForTypeChecker(this.translate(ast.value));\n    const node = wrapForDiagnostics(ts.createBinary(left, ts.SyntaxKind.EqualsToken, right));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitLiteralArray(ast: LiteralArray): ts.Expression {\n    const elements = ast.expressions.map(expr => this.translate(expr));\n    const literal = ts.createArrayLiteral(elements);\n    // If strictLiteralTypes is disabled, array literals are cast to `any`.\n    const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitLiteralMap(ast: LiteralMap): ts.Expression {\n    const properties = ast.keys.map(({key}, idx) => {\n      const value = this.translate(ast.values[idx]);\n      return ts.createPropertyAssignment(ts.createStringLiteral(key), value);\n    });\n    const literal = ts.createObjectLiteral(properties, true);\n    // If strictLiteralTypes is disabled, object literals are cast to `any`.\n    const node = this.config.strictLiteralTypes ? literal : tsCastToAny(literal);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive): ts.Expression {\n    let node: ts.Expression;\n    if (ast.value === undefined) {\n      node = ts.createIdentifier('undefined');\n    } else if (ast.value === null) {\n      node = ts.createNull();\n    } else {\n      node = ts.createLiteral(ast.value);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitMethodCall(ast: MethodCall): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const method = ts.createPropertyAccess(receiver, ast.name);\n    addParseSpanInfo(method, ast.nameSpan);\n    const args = ast.args.map(expr => this.translate(expr));\n    const node = ts.createCall(method, undefined, args);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitNonNullAssert(ast: NonNullAssert): ts.Expression {\n    const expr = wrapForDiagnostics(this.translate(ast.expression));\n    const node = ts.createNonNullExpression(expr);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitPipe(ast: BindingPipe): never {\n    throw new Error('Method not implemented.');\n  }\n\n  visitPrefixNot(ast: PrefixNot): ts.Expression {\n    const expression = wrapForDiagnostics(this.translate(ast.expression));\n    const node = ts.createLogicalNot(expression);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitPropertyRead(ast: PropertyRead): ts.Expression {\n    // This is a normal property read - convert the receiver to an expression and emit the correct\n    // TypeScript expression to read the property.\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const name = ts.createPropertyAccess(receiver, ast.name);\n    addParseSpanInfo(name, ast.nameSpan);\n    const node = wrapForDiagnostics(name);\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitPropertyWrite(ast: PropertyWrite): ts.Expression {\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const left = ts.createPropertyAccess(receiver, ast.name);\n    addParseSpanInfo(left, ast.nameSpan);\n    // TypeScript reports assignment errors on the entire lvalue expression. Annotate the lvalue of\n    // the assignment with the sourceSpan, which includes receivers, rather than nameSpan for\n    // consistency of the diagnostic location.\n    // a.b.c = 1\n    // ^^^^^^^^^ sourceSpan\n    //     ^     nameSpan\n    const leftWithPath = wrapForDiagnostics(left);\n    addParseSpanInfo(leftWithPath, ast.sourceSpan);\n    // The right needs to be wrapped in parens as well or we cannot accurately match its\n    // span to just the RHS. For example, the span in `e = $event /*0,10*/` is ambiguous.\n    // It could refer to either the whole binary expression or just the RHS.\n    // We should instead generate `e = ($event /*0,10*/)` so we know the span 0,10 matches RHS.\n    const right = wrapForTypeChecker(this.translate(ast.value));\n    const node =\n        wrapForDiagnostics(ts.createBinary(leftWithPath, ts.SyntaxKind.EqualsToken, right));\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitQuote(ast: Quote): ts.Expression {\n    return NULL_AS_ANY;\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall): ts.Expression {\n    // See the comments in SafePropertyRead above for an explanation of the cases here.\n    let node: ts.Expression;\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    const args = ast.args.map(expr => this.translate(expr));\n    if (this.config.strictSafeNavigationTypes) {\n      // \"a?.method(...)\" becomes (null as any ? a!.method(...) : undefined)\n      const method = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(method, ast.nameSpan);\n      const call = ts.createCall(method, undefined, args);\n      node = ts.createParen(ts.createConditional(NULL_AS_ANY, call, UNDEFINED));\n    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      // \"a?.method(...)\" becomes (a as any).method(...)\n      const method = ts.createPropertyAccess(tsCastToAny(receiver), ast.name);\n      addParseSpanInfo(method, ast.nameSpan);\n      node = ts.createCall(method, undefined, args);\n    } else {\n      // \"a?.method(...)\" becomes (a!.method(...) as any)\n      const method = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(method, ast.nameSpan);\n      node = tsCastToAny(ts.createCall(method, undefined, args));\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead): ts.Expression {\n    let node: ts.Expression;\n    const receiver = wrapForDiagnostics(this.translate(ast.receiver));\n    // The form of safe property reads depends on whether strictness is in use.\n    if (this.config.strictSafeNavigationTypes) {\n      // Basically, the return here is either the type of the complete expression with a null-safe\n      // property read, or `undefined`. So a ternary is used to create an \"or\" type:\n      // \"a?.b\" becomes (null as any ? a!.b : undefined)\n      // The type of this expression is (typeof a!.b) | undefined, which is exactly as desired.\n      const expr = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(expr, ast.nameSpan);\n      node = ts.createParen(ts.createConditional(NULL_AS_ANY, expr, UNDEFINED));\n    } else if (VeSafeLhsInferenceBugDetector.veWillInferAnyFor(ast)) {\n      // Emulate a View Engine bug where 'any' is inferred for the left-hand side of the safe\n      // navigation operation. With this bug, the type of the left-hand side is regarded as any.\n      // Therefore, the left-hand side only needs repeating in the output (to validate it), and then\n      // 'any' is used for the rest of the expression. This is done using a comma operator:\n      // \"a?.b\" becomes (a as any).b, which will of course have type 'any'.\n      node = ts.createPropertyAccess(tsCastToAny(receiver), ast.name);\n    } else {\n      // The View Engine bug isn't active, so check the entire type of the expression, but the final\n      // result is still inferred as `any`.\n      // \"a?.b\" becomes (a!.b as any)\n      const expr = ts.createPropertyAccess(ts.createNonNullExpression(receiver), ast.name);\n      addParseSpanInfo(expr, ast.nameSpan);\n      node = tsCastToAny(expr);\n    }\n    addParseSpanInfo(node, ast.sourceSpan);\n    return node;\n  }\n}\n\n/**\n * Checks whether View Engine will infer a type of 'any' for the left-hand side of a safe navigation\n * operation.\n *\n * In View Engine's template type-checker, certain receivers of safe navigation operations will\n * cause a temporary variable to be allocated as part of the checking expression, to save the value\n * of the receiver and use it more than once in the expression. This temporary variable has type\n * 'any'. In practice, this means certain receivers cause View Engine to not check the full\n * expression, and other receivers will receive more complete checking.\n *\n * For compatibility, this logic is adapted from View Engine's expression_converter.ts so that the\n * Ivy checker can emulate this bug when needed.\n */\nclass VeSafeLhsInferenceBugDetector implements AstVisitor {\n  private static SINGLETON = new VeSafeLhsInferenceBugDetector();\n\n  static veWillInferAnyFor(ast: SafeMethodCall|SafePropertyRead) {\n    return ast.receiver.visit(VeSafeLhsInferenceBugDetector.SINGLETON);\n  }\n\n  visitUnary(ast: Unary): boolean {\n    return ast.expr.visit(this);\n  }\n  visitBinary(ast: Binary): boolean {\n    return ast.left.visit(this) || ast.right.visit(this);\n  }\n  visitChain(ast: Chain): boolean {\n    return false;\n  }\n  visitConditional(ast: Conditional): boolean {\n    return ast.condition.visit(this) || ast.trueExp.visit(this) || ast.falseExp.visit(this);\n  }\n  visitFunctionCall(ast: FunctionCall): boolean {\n    return true;\n  }\n  visitImplicitReceiver(ast: ImplicitReceiver): boolean {\n    return false;\n  }\n  visitThisReceiver(ast: ThisReceiver): boolean {\n    return false;\n  }\n  visitInterpolation(ast: Interpolation): boolean {\n    return ast.expressions.some(exp => exp.visit(this));\n  }\n  visitKeyedRead(ast: KeyedRead): boolean {\n    return false;\n  }\n  visitKeyedWrite(ast: KeyedWrite): boolean {\n    return false;\n  }\n  visitLiteralArray(ast: LiteralArray): boolean {\n    return true;\n  }\n  visitLiteralMap(ast: LiteralMap): boolean {\n    return true;\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive): boolean {\n    return false;\n  }\n  visitMethodCall(ast: MethodCall): boolean {\n    return true;\n  }\n  visitPipe(ast: BindingPipe): boolean {\n    return true;\n  }\n  visitPrefixNot(ast: PrefixNot): boolean {\n    return ast.expression.visit(this);\n  }\n  visitNonNullAssert(ast: PrefixNot): boolean {\n    return ast.expression.visit(this);\n  }\n  visitPropertyRead(ast: PropertyRead): boolean {\n    return false;\n  }\n  visitPropertyWrite(ast: PropertyWrite): boolean {\n    return false;\n  }\n  visitQuote(ast: Quote): boolean {\n    return false;\n  }\n  visitSafeMethodCall(ast: SafeMethodCall): boolean {\n    return true;\n  }\n  visitSafePropertyRead(ast: SafePropertyRead): boolean {\n    return false;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}