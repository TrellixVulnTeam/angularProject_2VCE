{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/style_parser\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.hyphenate = exports.stripUnnecessaryQuotes = exports.parse = void 0;\n  /**\n   * Parses string representation of a style and converts it into object literal.\n   *\n   * @param value string representation of style as used in the `style` attribute in HTML.\n   *   Example: `color: red; height: auto`.\n   * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n   * 'auto']`\n   */\n\n  function parse(value) {\n    // we use a string array here instead of a string map\n    // because a string-map is not guaranteed to retain the\n    // order of the entries whereas a string array can be\n    // constructed in a [key, value, key, value] format.\n    var styles = [];\n    var i = 0;\n    var parenDepth = 0;\n    var quote = 0\n    /* QuoteNone */\n    ;\n    var valueStart = 0;\n    var propStart = 0;\n    var currentProp = null;\n    var valueHasQuotes = false;\n\n    while (i < value.length) {\n      var token = value.charCodeAt(i++);\n\n      switch (token) {\n        case 40\n        /* OpenParen */\n        :\n          parenDepth++;\n          break;\n\n        case 41\n        /* CloseParen */\n        :\n          parenDepth--;\n          break;\n\n        case 39\n        /* QuoteSingle */\n        :\n          // valueStart needs to be there since prop values don't\n          // have quotes in CSS\n          valueHasQuotes = valueHasQuotes || valueStart > 0;\n\n          if (quote === 0\n          /* QuoteNone */\n          ) {\n              quote = 39\n              /* QuoteSingle */\n              ;\n            } else if (quote === 39\n          /* QuoteSingle */\n          && value.charCodeAt(i - 1) !== 92\n          /* BackSlash */\n          ) {\n              quote = 0\n              /* QuoteNone */\n              ;\n            }\n\n          break;\n\n        case 34\n        /* QuoteDouble */\n        :\n          // same logic as above\n          valueHasQuotes = valueHasQuotes || valueStart > 0;\n\n          if (quote === 0\n          /* QuoteNone */\n          ) {\n              quote = 34\n              /* QuoteDouble */\n              ;\n            } else if (quote === 34\n          /* QuoteDouble */\n          && value.charCodeAt(i - 1) !== 92\n          /* BackSlash */\n          ) {\n              quote = 0\n              /* QuoteNone */\n              ;\n            }\n\n          break;\n\n        case 58\n        /* Colon */\n        :\n          if (!currentProp && parenDepth === 0 && quote === 0\n          /* QuoteNone */\n          ) {\n              currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n              valueStart = i;\n            }\n\n          break;\n\n        case 59\n        /* Semicolon */\n        :\n          if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0\n          /* QuoteNone */\n          ) {\n              var styleVal = value.substring(valueStart, i - 1).trim();\n              styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n              propStart = i;\n              valueStart = 0;\n              currentProp = null;\n              valueHasQuotes = false;\n            }\n\n          break;\n      }\n    }\n\n    if (currentProp && valueStart) {\n      var styleVal = value.substr(valueStart).trim();\n      styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n    }\n\n    return styles;\n  }\n\n  exports.parse = parse;\n\n  function stripUnnecessaryQuotes(value) {\n    var qS = value.charCodeAt(0);\n    var qE = value.charCodeAt(value.length - 1);\n\n    if (qS == qE && (qS == 39\n    /* QuoteSingle */\n    || qS == 34\n    /* QuoteDouble */\n    )) {\n      var tempValue = value.substring(1, value.length - 1); // special case to avoid using a multi-quoted string that was just chomped\n      // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n\n      if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n        value = tempValue;\n      }\n    }\n\n    return value;\n  }\n\n  exports.stripUnnecessaryQuotes = stripUnnecessaryQuotes;\n\n  function hyphenate(value) {\n    return value.replace(/[a-z][A-Z]/g, function (v) {\n      return v.charAt(0) + '-' + v.charAt(1);\n    }).toLowerCase();\n  }\n\n  exports.hyphenate = hyphenate;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/view/style_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst enum Char {\n  OpenParen = 40,\n  CloseParen = 41,\n  Colon = 58,\n  Semicolon = 59,\n  BackSlash = 92,\n  QuoteNone = 0,  // indicating we are not inside a quote\n  QuoteDouble = 34,\n  QuoteSingle = 39,\n}\n\n\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nexport function parse(value: string): string[] {\n  // we use a string array here instead of a string map\n  // because a string-map is not guaranteed to retain the\n  // order of the entries whereas a string array can be\n  // constructed in a [key, value, key, value] format.\n  const styles: string[] = [];\n\n  let i = 0;\n  let parenDepth = 0;\n  let quote: Char = Char.QuoteNone;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp: string|null = null;\n  let valueHasQuotes = false;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++) as Char;\n    switch (token) {\n      case Char.OpenParen:\n        parenDepth++;\n        break;\n      case Char.CloseParen:\n        parenDepth--;\n        break;\n      case Char.QuoteSingle:\n        // valueStart needs to be there since prop values don't\n        // have quotes in CSS\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteSingle;\n        } else if (quote === Char.QuoteSingle && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.QuoteDouble:\n        // same logic as above\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteDouble;\n        } else if (quote === Char.QuoteDouble && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.Colon:\n        if (!currentProp && parenDepth === 0 && quote === Char.QuoteNone) {\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case Char.Semicolon:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === Char.QuoteNone) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n          valueHasQuotes = false;\n        }\n        break;\n    }\n  }\n\n  if (currentProp && valueStart) {\n    const styleVal = value.substr(valueStart).trim();\n    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n  }\n\n  return styles;\n}\n\nexport function stripUnnecessaryQuotes(value: string): string {\n  const qS = value.charCodeAt(0);\n  const qE = value.charCodeAt(value.length - 1);\n  if (qS == qE && (qS == Char.QuoteSingle || qS == Char.QuoteDouble)) {\n    const tempValue = value.substring(1, value.length - 1);\n    // special case to avoid using a multi-quoted string that was just chomped\n    // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n    if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n      value = tempValue;\n    }\n  }\n  return value;\n}\n\nexport function hyphenate(value: string): string {\n  return value\n      .replace(\n          /[a-z][A-Z]/g,\n          v => {\n            return v.charAt(0) + '-' + v.charAt(1);\n          })\n      .toLowerCase();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}