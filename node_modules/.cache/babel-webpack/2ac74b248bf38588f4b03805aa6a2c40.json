{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar Queue = require(\"../util/Queue\");\n\nvar _require = require(\"../util/SetHelpers\"),\n    intersect = _require.intersect;\n\nvar getParentChunksWithModule = function getParentChunksWithModule(currentChunk, module) {\n  var chunks = [];\n  var stack = new Set(currentChunk.parentsIterable);\n\n  var _iterator = _createForOfIteratorHelper(stack),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var chunk = _step.value;\n\n      if (chunk.containsModule(module)) {\n        chunks.push(chunk);\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(chunk.parentsIterable),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var parent = _step2.value;\n            stack.add(parent);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return chunks;\n};\n\nvar RemoveParentModulesPlugin = /*#__PURE__*/function () {\n  function RemoveParentModulesPlugin() {\n    _classCallCheck(this, RemoveParentModulesPlugin);\n  }\n\n  _createClass(RemoveParentModulesPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      compiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", function (compilation) {\n        var handler = function handler(chunks, chunkGroups) {\n          var queue = new Queue();\n          var availableModulesMap = new WeakMap();\n\n          var _iterator3 = _createForOfIteratorHelper(compilation.entrypoints.values()),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _chunkGroup = _step3.value;\n              // initialize available modules for chunks without parents\n              availableModulesMap.set(_chunkGroup, new Set());\n\n              var _iterator10 = _createForOfIteratorHelper(_chunkGroup.childrenIterable),\n                  _step10;\n\n              try {\n                for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                  var _child = _step10.value;\n                  queue.enqueue(_child);\n                }\n              } catch (err) {\n                _iterator10.e(err);\n              } finally {\n                _iterator10.f();\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          while (queue.length > 0) {\n            var chunkGroup = queue.dequeue();\n            var availableModules = availableModulesMap.get(chunkGroup);\n            var changed = false;\n\n            var _iterator4 = _createForOfIteratorHelper(chunkGroup.parentsIterable),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var parent = _step4.value;\n                var availableModulesInParent = availableModulesMap.get(parent);\n\n                if (availableModulesInParent !== undefined) {\n                  // If we know the available modules in parent: process these\n                  if (availableModules === undefined) {\n                    // if we have not own info yet: create new entry\n                    availableModules = new Set(availableModulesInParent);\n\n                    var _iterator6 = _createForOfIteratorHelper(parent.chunks),\n                        _step6;\n\n                    try {\n                      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                        var chunk = _step6.value;\n\n                        var _iterator7 = _createForOfIteratorHelper(chunk.modulesIterable),\n                            _step7;\n\n                        try {\n                          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                            var m = _step7.value;\n                            availableModules.add(m);\n                          }\n                        } catch (err) {\n                          _iterator7.e(err);\n                        } finally {\n                          _iterator7.f();\n                        }\n                      }\n                    } catch (err) {\n                      _iterator6.e(err);\n                    } finally {\n                      _iterator6.f();\n                    }\n\n                    availableModulesMap.set(chunkGroup, availableModules);\n                    changed = true;\n                  } else {\n                    var _iterator8 = _createForOfIteratorHelper(availableModules),\n                        _step8;\n\n                    try {\n                      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                        var _m = _step8.value;\n\n                        if (!parent.containsModule(_m) && !availableModulesInParent.has(_m)) {\n                          availableModules.delete(_m);\n                          changed = true;\n                        }\n                      }\n                    } catch (err) {\n                      _iterator8.e(err);\n                    } finally {\n                      _iterator8.f();\n                    }\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n\n            if (changed) {\n              // if something changed: enqueue our children\n              var _iterator5 = _createForOfIteratorHelper(chunkGroup.childrenIterable),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var child = _step5.value;\n                  queue.enqueue(child);\n                }\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n            }\n          } // now we have available modules for every chunk\n\n\n          var _iterator9 = _createForOfIteratorHelper(chunks),\n              _step9;\n\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var _chunk = _step9.value;\n              var availableModulesSets = Array.from(_chunk.groupsIterable, function (chunkGroup) {\n                return availableModulesMap.get(chunkGroup);\n              });\n              if (availableModulesSets.some(function (s) {\n                return s === undefined;\n              })) continue; // No info about this chunk group\n\n              var _availableModules = availableModulesSets.length === 1 ? availableModulesSets[0] : intersect(availableModulesSets);\n\n              var numberOfModules = _chunk.getNumberOfModules();\n\n              var toRemove = new Set();\n\n              if (numberOfModules < _availableModules.size) {\n                var _iterator11 = _createForOfIteratorHelper(_chunk.modulesIterable),\n                    _step11;\n\n                try {\n                  for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                    var _m2 = _step11.value;\n\n                    if (_availableModules.has(_m2)) {\n                      toRemove.add(_m2);\n                    }\n                  }\n                } catch (err) {\n                  _iterator11.e(err);\n                } finally {\n                  _iterator11.f();\n                }\n              } else {\n                var _iterator12 = _createForOfIteratorHelper(_availableModules),\n                    _step12;\n\n                try {\n                  for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                    var _m3 = _step12.value;\n\n                    if (_chunk.containsModule(_m3)) {\n                      toRemove.add(_m3);\n                    }\n                  }\n                } catch (err) {\n                  _iterator12.e(err);\n                } finally {\n                  _iterator12.f();\n                }\n              }\n\n              var _iterator13 = _createForOfIteratorHelper(toRemove),\n                  _step13;\n\n              try {\n                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                  var _module = _step13.value;\n\n                  _module.rewriteChunkInReasons(_chunk, getParentChunksWithModule(_chunk, _module));\n\n                  _chunk.removeModule(_module);\n                }\n              } catch (err) {\n                _iterator13.e(err);\n              } finally {\n                _iterator13.f();\n              }\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        };\n\n        compilation.hooks.optimizeChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n        compilation.hooks.optimizeExtractedChunksBasic.tap(\"RemoveParentModulesPlugin\", handler);\n      });\n    }\n  }]);\n\n  return RemoveParentModulesPlugin;\n}();\n\nmodule.exports = RemoveParentModulesPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/optimize/RemoveParentModulesPlugin.js"],"names":["Queue","require","intersect","getParentChunksWithModule","currentChunk","module","chunks","stack","Set","parentsIterable","chunk","containsModule","push","parent","add","RemoveParentModulesPlugin","compiler","hooks","compilation","tap","handler","chunkGroups","queue","availableModulesMap","WeakMap","entrypoints","values","chunkGroup","set","childrenIterable","child","enqueue","length","dequeue","availableModules","get","changed","availableModulesInParent","undefined","modulesIterable","m","has","delete","availableModulesSets","Array","from","groupsIterable","some","s","numberOfModules","getNumberOfModules","toRemove","size","rewriteChunkInReasons","removeModule","optimizeChunksBasic","optimizeExtractedChunksBasic","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Queue = require(\"../util/Queue\");\nconst { intersect } = require(\"../util/SetHelpers\");\n\nconst getParentChunksWithModule = (currentChunk, module) => {\n\tconst chunks = [];\n\tconst stack = new Set(currentChunk.parentsIterable);\n\n\tfor (const chunk of stack) {\n\t\tif (chunk.containsModule(module)) {\n\t\t\tchunks.push(chunk);\n\t\t} else {\n\t\t\tfor (const parent of chunk.parentsIterable) {\n\t\t\t\tstack.add(parent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn chunks;\n};\n\nclass RemoveParentModulesPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\"RemoveParentModulesPlugin\", compilation => {\n\t\t\tconst handler = (chunks, chunkGroups) => {\n\t\t\t\tconst queue = new Queue();\n\t\t\t\tconst availableModulesMap = new WeakMap();\n\n\t\t\t\tfor (const chunkGroup of compilation.entrypoints.values()) {\n\t\t\t\t\t// initialize available modules for chunks without parents\n\t\t\t\t\tavailableModulesMap.set(chunkGroup, new Set());\n\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twhile (queue.length > 0) {\n\t\t\t\t\tconst chunkGroup = queue.dequeue();\n\t\t\t\t\tlet availableModules = availableModulesMap.get(chunkGroup);\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\tfor (const parent of chunkGroup.parentsIterable) {\n\t\t\t\t\t\tconst availableModulesInParent = availableModulesMap.get(parent);\n\t\t\t\t\t\tif (availableModulesInParent !== undefined) {\n\t\t\t\t\t\t\t// If we know the available modules in parent: process these\n\t\t\t\t\t\t\tif (availableModules === undefined) {\n\t\t\t\t\t\t\t\t// if we have not own info yet: create new entry\n\t\t\t\t\t\t\t\tavailableModules = new Set(availableModulesInParent);\n\t\t\t\t\t\t\t\tfor (const chunk of parent.chunks) {\n\t\t\t\t\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.add(m);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tavailableModulesMap.set(chunkGroup, availableModules);\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!parent.containsModule(m) &&\n\t\t\t\t\t\t\t\t\t\t!availableModulesInParent.has(m)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tavailableModules.delete(m);\n\t\t\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) {\n\t\t\t\t\t\t// if something changed: enqueue our children\n\t\t\t\t\t\tfor (const child of chunkGroup.childrenIterable) {\n\t\t\t\t\t\t\tqueue.enqueue(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// now we have available modules for every chunk\n\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\tconst availableModulesSets = Array.from(\n\t\t\t\t\t\tchunk.groupsIterable,\n\t\t\t\t\t\tchunkGroup => availableModulesMap.get(chunkGroup)\n\t\t\t\t\t);\n\t\t\t\t\tif (availableModulesSets.some(s => s === undefined)) continue; // No info about this chunk group\n\t\t\t\t\tconst availableModules =\n\t\t\t\t\t\tavailableModulesSets.length === 1\n\t\t\t\t\t\t\t? availableModulesSets[0]\n\t\t\t\t\t\t\t: intersect(availableModulesSets);\n\t\t\t\t\tconst numberOfModules = chunk.getNumberOfModules();\n\t\t\t\t\tconst toRemove = new Set();\n\t\t\t\t\tif (numberOfModules < availableModules.size) {\n\t\t\t\t\t\tfor (const m of chunk.modulesIterable) {\n\t\t\t\t\t\t\tif (availableModules.has(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const m of availableModules) {\n\t\t\t\t\t\t\tif (chunk.containsModule(m)) {\n\t\t\t\t\t\t\t\ttoRemove.add(m);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const module of toRemove) {\n\t\t\t\t\t\tmodule.rewriteChunkInReasons(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tgetParentChunksWithModule(chunk, module)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tcompilation.hooks.optimizeChunksBasic.tap(\n\t\t\t\t\"RemoveParentModulesPlugin\",\n\t\t\t\thandler\n\t\t\t);\n\t\t\tcompilation.hooks.optimizeExtractedChunksBasic.tap(\n\t\t\t\t\"RemoveParentModulesPlugin\",\n\t\t\t\thandler\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RemoveParentModulesPlugin;\n"]},"metadata":{},"sourceType":"script"}