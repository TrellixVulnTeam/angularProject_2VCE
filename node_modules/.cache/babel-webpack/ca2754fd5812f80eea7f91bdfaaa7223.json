{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/i18n/serializers/xtb\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/ml_parser/ast\", \"@angular/compiler/src/ml_parser/xml_parser\", \"@angular/compiler/src/i18n/i18n_ast\", \"@angular/compiler/src/i18n/parse_util\", \"@angular/compiler/src/i18n/serializers/serializer\", \"@angular/compiler/src/i18n/serializers/xmb\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Xtb = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ml = require(\"@angular/compiler/src/ml_parser/ast\");\n\n  var xml_parser_1 = require(\"@angular/compiler/src/ml_parser/xml_parser\");\n\n  var i18n = require(\"@angular/compiler/src/i18n/i18n_ast\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/i18n/parse_util\");\n\n  var serializer_1 = require(\"@angular/compiler/src/i18n/serializers/serializer\");\n\n  var xmb_1 = require(\"@angular/compiler/src/i18n/serializers/xmb\");\n\n  var _TRANSLATIONS_TAG = 'translationbundle';\n  var _TRANSLATION_TAG = 'translation';\n  var _PLACEHOLDER_TAG = 'ph';\n\n  var Xtb =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(Xtb, _super);\n\n    function Xtb() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    Xtb.prototype.write = function (messages, locale) {\n      throw new Error('Unsupported');\n    };\n\n    Xtb.prototype.load = function (content, url) {\n      // xtb to xml nodes\n      var xtbParser = new XtbParser();\n\n      var _a = xtbParser.parse(content, url),\n          locale = _a.locale,\n          msgIdToHtml = _a.msgIdToHtml,\n          errors = _a.errors; // xml nodes to i18n nodes\n\n\n      var i18nNodesByMsgId = {};\n      var converter = new XmlToI18n(); // Because we should be able to load xtb files that rely on features not supported by angular,\n      // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n      // converted\n\n      Object.keys(msgIdToHtml).forEach(function (msgId) {\n        var valueFn = function valueFn() {\n          var _a = converter.convert(msgIdToHtml[msgId], url),\n              i18nNodes = _a.i18nNodes,\n              errors = _a.errors;\n\n          if (errors.length) {\n            throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n          }\n\n          return i18nNodes;\n        };\n\n        createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n      });\n\n      if (errors.length) {\n        throw new Error(\"xtb parse errors:\\n\" + errors.join('\\n'));\n      }\n\n      return {\n        locale: locale,\n        i18nNodesByMsgId: i18nNodesByMsgId\n      };\n    };\n\n    Xtb.prototype.digest = function (message) {\n      return xmb_1.digest(message);\n    };\n\n    Xtb.prototype.createNameMapper = function (message) {\n      return new serializer_1.SimplePlaceholderMapper(message, xmb_1.toPublicName);\n    };\n\n    return Xtb;\n  }(serializer_1.Serializer);\n\n  exports.Xtb = Xtb;\n\n  function createLazyProperty(messages, id, valueFn) {\n    Object.defineProperty(messages, id, {\n      configurable: true,\n      enumerable: true,\n      get: function get() {\n        var value = valueFn();\n        Object.defineProperty(messages, id, {\n          enumerable: true,\n          value: value\n        });\n        return value;\n      },\n      set: function set(_) {\n        throw new Error('Could not overwrite an XTB translation');\n      }\n    });\n  } // Extract messages as xml nodes from the xtb file\n\n\n  var XtbParser =\n  /** @class */\n  function () {\n    function XtbParser() {\n      this._locale = null;\n    }\n\n    XtbParser.prototype.parse = function (xtb, url) {\n      this._bundleDepth = 0;\n      this._msgIdToHtml = {}; // We can not parse the ICU messages at this point as some messages might not originate\n      // from Angular that could not be lex'd.\n\n      var xml = new xml_parser_1.XmlParser().parse(xtb, url);\n      this._errors = xml.errors;\n      ml.visitAll(this, xml.rootNodes);\n      return {\n        msgIdToHtml: this._msgIdToHtml,\n        errors: this._errors,\n        locale: this._locale\n      };\n    };\n\n    XtbParser.prototype.visitElement = function (element, context) {\n      switch (element.name) {\n        case _TRANSLATIONS_TAG:\n          this._bundleDepth++;\n\n          if (this._bundleDepth > 1) {\n            this._addError(element, \"<\" + _TRANSLATIONS_TAG + \"> elements can not be nested\");\n          }\n\n          var langAttr = element.attrs.find(function (attr) {\n            return attr.name === 'lang';\n          });\n\n          if (langAttr) {\n            this._locale = langAttr.value;\n          }\n\n          ml.visitAll(this, element.children, null);\n          this._bundleDepth--;\n          break;\n\n        case _TRANSLATION_TAG:\n          var idAttr = element.attrs.find(function (attr) {\n            return attr.name === 'id';\n          });\n\n          if (!idAttr) {\n            this._addError(element, \"<\" + _TRANSLATION_TAG + \"> misses the \\\"id\\\" attribute\");\n          } else {\n            var id = idAttr.value;\n\n            if (this._msgIdToHtml.hasOwnProperty(id)) {\n              this._addError(element, \"Duplicated translations for msg \" + id);\n            } else {\n              var innerTextStart = element.startSourceSpan.end.offset;\n              var innerTextEnd = element.endSourceSpan.start.offset;\n              var content = element.startSourceSpan.start.file.content;\n              var innerText = content.slice(innerTextStart, innerTextEnd);\n              this._msgIdToHtml[id] = innerText;\n            }\n          }\n\n          break;\n\n        default:\n          this._addError(element, 'Unexpected tag');\n\n      }\n    };\n\n    XtbParser.prototype.visitAttribute = function (attribute, context) {};\n\n    XtbParser.prototype.visitText = function (text, context) {};\n\n    XtbParser.prototype.visitComment = function (comment, context) {};\n\n    XtbParser.prototype.visitExpansion = function (expansion, context) {};\n\n    XtbParser.prototype.visitExpansionCase = function (expansionCase, context) {};\n\n    XtbParser.prototype._addError = function (node, message) {\n      this._errors.push(new parse_util_1.I18nError(node.sourceSpan, message));\n    };\n\n    return XtbParser;\n  }(); // Convert ml nodes (xtb syntax) to i18n nodes\n\n\n  var XmlToI18n =\n  /** @class */\n  function () {\n    function XmlToI18n() {}\n\n    XmlToI18n.prototype.convert = function (message, url) {\n      var xmlIcu = new xml_parser_1.XmlParser().parse(message, url, {\n        tokenizeExpansionForms: true\n      });\n      this._errors = xmlIcu.errors;\n      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : ml.visitAll(this, xmlIcu.rootNodes);\n      return {\n        i18nNodes: i18nNodes,\n        errors: this._errors\n      };\n    };\n\n    XmlToI18n.prototype.visitText = function (text, context) {\n      return new i18n.Text(text.value, text.sourceSpan);\n    };\n\n    XmlToI18n.prototype.visitExpansion = function (icu, context) {\n      var caseMap = {};\n      ml.visitAll(this, icu.cases).forEach(function (c) {\n        caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n      });\n      return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    };\n\n    XmlToI18n.prototype.visitExpansionCase = function (icuCase, context) {\n      return {\n        value: icuCase.value,\n        nodes: ml.visitAll(this, icuCase.expression)\n      };\n    };\n\n    XmlToI18n.prototype.visitElement = function (el, context) {\n      if (el.name === _PLACEHOLDER_TAG) {\n        var nameAttr = el.attrs.find(function (attr) {\n          return attr.name === 'name';\n        });\n\n        if (nameAttr) {\n          return new i18n.Placeholder('', nameAttr.value, el.sourceSpan);\n        }\n\n        this._addError(el, \"<\" + _PLACEHOLDER_TAG + \"> misses the \\\"name\\\" attribute\");\n      } else {\n        this._addError(el, \"Unexpected tag\");\n      }\n\n      return null;\n    };\n\n    XmlToI18n.prototype.visitComment = function (comment, context) {};\n\n    XmlToI18n.prototype.visitAttribute = function (attribute, context) {};\n\n    XmlToI18n.prototype._addError = function (node, message) {\n      this._errors.push(new parse_util_1.I18nError(node.sourceSpan, message));\n    };\n\n    return XmlToI18n;\n  }();\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/i18n/serializers/xtb.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ml from '../../ml_parser/ast';\nimport {XmlParser} from '../../ml_parser/xml_parser';\nimport * as i18n from '../i18n_ast';\nimport {I18nError} from '../parse_util';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport {digest, toPublicName} from './xmb';\n\nconst _TRANSLATIONS_TAG = 'translationbundle';\nconst _TRANSLATION_TAG = 'translation';\nconst _PLACEHOLDER_TAG = 'ph';\n\nexport class Xtb extends Serializer {\n  write(messages: i18n.Message[], locale: string|null): string {\n    throw new Error('Unsupported');\n  }\n\n  load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    // xtb to xml nodes\n    const xtbParser = new XtbParser();\n    const {locale, msgIdToHtml, errors} = xtbParser.parse(content, url);\n\n    // xml nodes to i18n nodes\n    const i18nNodesByMsgId: {[msgId: string]: i18n.Node[]} = {};\n    const converter = new XmlToI18n();\n\n    // Because we should be able to load xtb files that rely on features not supported by angular,\n    // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n    // converted\n    Object.keys(msgIdToHtml).forEach(msgId => {\n      const valueFn = function() {\n        const {i18nNodes, errors} = converter.convert(msgIdToHtml[msgId], url);\n        if (errors.length) {\n          throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n        }\n        return i18nNodes;\n      };\n      createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n    });\n\n    if (errors.length) {\n      throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\n    }\n\n    return {locale: locale!, i18nNodesByMsgId};\n  }\n\n  digest(message: i18n.Message): string {\n    return digest(message);\n  }\n\n  createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nfunction createLazyProperty(messages: any, id: string, valueFn: () => any) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: function() {\n      const value = valueFn();\n      Object.defineProperty(messages, id, {enumerable: true, value});\n      return value;\n    },\n    set: _ => {\n      throw new Error('Could not overwrite an XTB translation');\n    },\n  });\n}\n\n// Extract messages as xml nodes from the xtb file\nclass XtbParser implements ml.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _bundleDepth!: number;\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n  // TODO(issue/24571): remove '!'.\n  private _msgIdToHtml!: {[msgId: string]: string};\n  private _locale: string|null = null;\n\n  parse(xtb: string, url: string) {\n    this._bundleDepth = 0;\n    this._msgIdToHtml = {};\n\n    // We can not parse the ICU messages at this point as some messages might not originate\n    // from Angular that could not be lex'd.\n    const xml = new XmlParser().parse(xtb, url);\n\n    this._errors = xml.errors;\n    ml.visitAll(this, xml.rootNodes);\n\n    return {\n      msgIdToHtml: this._msgIdToHtml,\n      errors: this._errors,\n      locale: this._locale,\n    };\n  }\n\n  visitElement(element: ml.Element, context: any): any {\n    switch (element.name) {\n      case _TRANSLATIONS_TAG:\n        this._bundleDepth++;\n        if (this._bundleDepth > 1) {\n          this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\n        }\n        const langAttr = element.attrs.find((attr) => attr.name === 'lang');\n        if (langAttr) {\n          this._locale = langAttr.value;\n        }\n        ml.visitAll(this, element.children, null);\n        this._bundleDepth--;\n        break;\n\n      case _TRANSLATION_TAG:\n        const idAttr = element.attrs.find((attr) => attr.name === 'id');\n        if (!idAttr) {\n          this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\n        } else {\n          const id = idAttr.value;\n          if (this._msgIdToHtml.hasOwnProperty(id)) {\n            this._addError(element, `Duplicated translations for msg ${id}`);\n          } else {\n            const innerTextStart = element.startSourceSpan.end.offset;\n            const innerTextEnd = element.endSourceSpan!.start.offset;\n            const content = element.startSourceSpan.start.file.content;\n            const innerText = content.slice(innerTextStart!, innerTextEnd!);\n            this._msgIdToHtml[id] = innerText;\n          }\n        }\n        break;\n\n      default:\n        this._addError(element, 'Unexpected tag');\n    }\n  }\n\n  visitAttribute(attribute: ml.Attribute, context: any): any {}\n\n  visitText(text: ml.Text, context: any): any {}\n\n  visitComment(comment: ml.Comment, context: any): any {}\n\n  visitExpansion(expansion: ml.Expansion, context: any): any {}\n\n  visitExpansionCase(expansionCase: ml.ExpansionCase, context: any): any {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n\n// Convert ml nodes (xtb syntax) to i18n nodes\nclass XmlToI18n implements ml.Visitor {\n  // TODO(issue/24571): remove '!'.\n  private _errors!: I18nError[];\n\n  convert(message: string, url: string) {\n    const xmlIcu = new XmlParser().parse(message, url, {tokenizeExpansionForms: true});\n    this._errors = xmlIcu.errors;\n\n    const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\n        [] :\n        ml.visitAll(this, xmlIcu.rootNodes);\n\n    return {\n      i18nNodes,\n      errors: this._errors,\n    };\n  }\n\n  visitText(text: ml.Text, context: any) {\n    return new i18n.Text(text.value, text.sourceSpan);\n  }\n\n  visitExpansion(icu: ml.Expansion, context: any) {\n    const caseMap: {[value: string]: i18n.Node} = {};\n\n    ml.visitAll(this, icu.cases).forEach(c => {\n      caseMap[c.value] = new i18n.Container(c.nodes, icu.sourceSpan);\n    });\n\n    return new i18n.Icu(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n  }\n\n  visitExpansionCase(icuCase: ml.ExpansionCase, context: any): any {\n    return {\n      value: icuCase.value,\n      nodes: ml.visitAll(this, icuCase.expression),\n    };\n  }\n\n  visitElement(el: ml.Element, context: any): i18n.Placeholder|null {\n    if (el.name === _PLACEHOLDER_TAG) {\n      const nameAttr = el.attrs.find((attr) => attr.name === 'name');\n      if (nameAttr) {\n        return new i18n.Placeholder('', nameAttr.value, el.sourceSpan);\n      }\n\n      this._addError(el, `<${_PLACEHOLDER_TAG}> misses the \"name\" attribute`);\n    } else {\n      this._addError(el, `Unexpected tag`);\n    }\n    return null;\n  }\n\n  visitComment(comment: ml.Comment, context: any) {}\n\n  visitAttribute(attribute: ml.Attribute, context: any) {}\n\n  private _addError(node: ml.Node, message: string): void {\n    this._errors.push(new I18nError(node.sourceSpan, message));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}