{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Gajus Kuizinas @gajus\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar Ajv = require(\"ajv\");\n\nvar ajv = new Ajv({\n  errorDataPath: \"configuration\",\n  allErrors: true,\n  verbose: true\n});\n\nrequire(\"ajv-keywords\")(ajv, [\"instanceof\"]);\n\nrequire(\"../schemas/ajv.absolutePath\")(ajv);\n\nvar validateSchema = function validateSchema(schema, options) {\n  if (Array.isArray(options)) {\n    var errors = options.map(function (options) {\n      return validateObject(schema, options);\n    });\n    errors.forEach(function (list, idx) {\n      var applyPrefix = function applyPrefix(err) {\n        err.dataPath = \"[\".concat(idx, \"]\").concat(err.dataPath);\n\n        if (err.children) {\n          err.children.forEach(applyPrefix);\n        }\n      };\n\n      list.forEach(applyPrefix);\n    });\n    return errors.reduce(function (arr, items) {\n      return arr.concat(items);\n    }, []);\n  } else {\n    return validateObject(schema, options);\n  }\n};\n\nvar validateObject = function validateObject(schema, options) {\n  var validate = ajv.compile(schema);\n  var valid = validate(options);\n  return valid ? [] : filterErrors(validate.errors);\n};\n\nvar filterErrors = function filterErrors(errors) {\n  var newErrors = [];\n\n  var _iterator = _createForOfIteratorHelper(errors),\n      _step;\n\n  try {\n    var _loop = function _loop() {\n      var err = _step.value;\n      var dataPath = err.dataPath;\n      var children = [];\n      newErrors = newErrors.filter(function (oldError) {\n        if (oldError.dataPath.includes(dataPath)) {\n          if (oldError.children) {\n            children = children.concat(oldError.children.slice(0));\n          }\n\n          oldError.children = undefined;\n          children.push(oldError);\n          return false;\n        }\n\n        return true;\n      });\n\n      if (children.length) {\n        err.children = children;\n      }\n\n      newErrors.push(err);\n    };\n\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return newErrors;\n};\n\nmodule.exports = validateSchema;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/validateSchema.js"],"names":["Ajv","require","ajv","errorDataPath","allErrors","verbose","validateSchema","schema","options","Array","isArray","errors","map","validateObject","forEach","list","idx","applyPrefix","err","dataPath","children","reduce","arr","items","concat","validate","compile","valid","filterErrors","newErrors","filter","oldError","includes","slice","undefined","push","length","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Gajus Kuizinas @gajus\n*/\n\"use strict\";\n\nconst Ajv = require(\"ajv\");\nconst ajv = new Ajv({\n\terrorDataPath: \"configuration\",\n\tallErrors: true,\n\tverbose: true\n});\nrequire(\"ajv-keywords\")(ajv, [\"instanceof\"]);\nrequire(\"../schemas/ajv.absolutePath\")(ajv);\n\nconst validateSchema = (schema, options) => {\n\tif (Array.isArray(options)) {\n\t\tconst errors = options.map(options => validateObject(schema, options));\n\t\terrors.forEach((list, idx) => {\n\t\t\tconst applyPrefix = err => {\n\t\t\t\terr.dataPath = `[${idx}]${err.dataPath}`;\n\t\t\t\tif (err.children) {\n\t\t\t\t\terr.children.forEach(applyPrefix);\n\t\t\t\t}\n\t\t\t};\n\t\t\tlist.forEach(applyPrefix);\n\t\t});\n\t\treturn errors.reduce((arr, items) => {\n\t\t\treturn arr.concat(items);\n\t\t}, []);\n\t} else {\n\t\treturn validateObject(schema, options);\n\t}\n};\n\nconst validateObject = (schema, options) => {\n\tconst validate = ajv.compile(schema);\n\tconst valid = validate(options);\n\treturn valid ? [] : filterErrors(validate.errors);\n};\n\nconst filterErrors = errors => {\n\tlet newErrors = [];\n\tfor (const err of errors) {\n\t\tconst dataPath = err.dataPath;\n\t\tlet children = [];\n\t\tnewErrors = newErrors.filter(oldError => {\n\t\t\tif (oldError.dataPath.includes(dataPath)) {\n\t\t\t\tif (oldError.children) {\n\t\t\t\t\tchildren = children.concat(oldError.children.slice(0));\n\t\t\t\t}\n\t\t\t\toldError.children = undefined;\n\t\t\t\tchildren.push(oldError);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\tif (children.length) {\n\t\t\terr.children = children;\n\t\t}\n\t\tnewErrors.push(err);\n\t}\n\n\treturn newErrors;\n};\n\nmodule.exports = validateSchema;\n"]},"metadata":{},"sourceType":"script"}