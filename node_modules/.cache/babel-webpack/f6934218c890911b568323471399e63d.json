{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/api/api\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.UpdateMode = void 0;\n  var UpdateMode;\n\n  (function (UpdateMode) {\n    /**\n     * A complete update creates a completely new overlay of type-checking code on top of the user's\n     * original program, which doesn't include type-checking code from previous calls to\n     * `updateFiles`.\n     */\n    UpdateMode[UpdateMode[\"Complete\"] = 0] = \"Complete\";\n    /**\n     * An incremental update changes the contents of some files in the type-checking program without\n     * reverting any prior changes.\n     */\n\n    UpdateMode[UpdateMode[\"Incremental\"] = 1] = \"Incremental\";\n  })(UpdateMode = exports.UpdateMode || (exports.UpdateMode = {}));\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/api/api.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;AA0YH,MAAY,UAAZ;;AAAA,GAAA,UAAY,UAAZ,EAAsB;AACpB;;;;AAIG;AACH,IAAA,UAAA,CAAA,UAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AAEA;;;AAGG;;AACH,IAAA,UAAA,CAAA,UAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AACD,GAbD,EAAY,UAAU,GAAV,OAAA,CAAA,UAAA,KAAA,OAAA,CAAA,UAAA,GAAU,EAAV,CAAZ","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteSourceSpan, BoundTarget, DirectiveMeta, ParseSourceSpan, SchemaMetadata} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {Reference} from '../../imports';\nimport {ClassPropertyMapping, DirectiveTypeCheckMeta} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\n\n\n/**\n * Extension of `DirectiveMeta` that includes additional information required to type-check the\n * usage of a particular directive.\n */\nexport interface TypeCheckableDirectiveMeta extends DirectiveMeta, DirectiveTypeCheckMeta {\n  ref: Reference<ClassDeclaration>;\n  queries: string[];\n  inputs: ClassPropertyMapping;\n  outputs: ClassPropertyMapping;\n}\n\nexport type TemplateId = string&{__brand: 'TemplateId'};\n\n/**\n * Metadata required in addition to a component class in order to generate a type check block (TCB)\n * for that component.\n */\nexport interface TypeCheckBlockMetadata {\n  /**\n   * A unique identifier for the class which gave rise to this TCB.\n   *\n   * This can be used to map errors back to the `ts.ClassDeclaration` for the component.\n   */\n  id: TemplateId;\n\n  /**\n   * Semantic information about the template of the component.\n   */\n  boundTarget: BoundTarget<TypeCheckableDirectiveMeta>;\n\n  /*\n   * Pipes used in the template of the component.\n   */\n  pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>;\n\n  /**\n   * Schemas that apply to this template.\n   */\n  schemas: SchemaMetadata[];\n}\n\nexport interface TypeCtorMetadata {\n  /**\n   * The name of the requested type constructor function.\n   */\n  fnName: string;\n\n  /**\n   * Whether to generate a body for the function or not.\n   */\n  body: boolean;\n\n  /**\n   * Input, output, and query field names in the type which should be included as constructor input.\n   */\n  fields: {inputs: string[]; outputs: string[]; queries: string[];};\n\n  /**\n   * `Set` of field names which have type coercion enabled.\n   */\n  coercedInputFields: Set<string>;\n}\n\nexport interface TypeCheckingConfig {\n  /**\n   * Whether to check the left-hand side type of binding operations.\n   *\n   * For example, if this is `false` then the expression `[input]=\"expr\"` will have `expr` type-\n   * checked, but not the assignment of the resulting type to the `input` property of whichever\n   * directive or component is receiving the binding. If set to `true`, both sides of the assignment\n   * are checked.\n   *\n   * This flag only affects bindings to components/directives. Bindings to the DOM are checked if\n   * `checkTypeOfDomBindings` is set.\n   */\n  checkTypeOfInputBindings: boolean;\n\n  /**\n   * Whether to honor the access modifiers on input bindings for the component/directive.\n   *\n   * If a template binding attempts to assign to an input that is private/protected/readonly,\n   * this will produce errors when enabled but will not when disabled.\n   */\n  honorAccessModifiersForInputBindings: boolean;\n\n  /**\n   * Whether to use strict null types for input bindings for directives.\n   *\n   * If this is `true`, applications that are compiled with TypeScript's `strictNullChecks` enabled\n   * will produce type errors for bindings which can evaluate to `undefined` or `null` where the\n   * inputs's type does not include `undefined` or `null` in its type. If set to `false`, all\n   * binding expressions are wrapped in a non-null assertion operator to effectively disable strict\n   * null checks. This may be particularly useful when the directive is from a library that is not\n   * compiled with `strictNullChecks` enabled.\n   *\n   * If `checkTypeOfInputBindings` is set to `false`, this flag has no effect.\n   */\n  strictNullInputBindings: boolean;\n\n  /**\n   * Whether to check text attributes that happen to be consumed by a directive or component.\n   *\n   * For example, in a template containing `<input matInput disabled>` the `disabled` attribute ends\n   * up being consumed as an input with type `boolean` by the `matInput` directive. At runtime, the\n   * input will be set to the attribute's string value, which is an empty string for attributes\n   * without a value, so with this flag set to `true`, an error would be reported. If set to\n   * `false`, text attributes will never report an error.\n   *\n   * Note that if `checkTypeOfInputBindings` is set to `false`, this flag has no effect.\n   */\n  checkTypeOfAttributes: boolean;\n\n  /**\n   * Whether to check the left-hand side type of binding operations to DOM properties.\n   *\n   * As `checkTypeOfBindings`, but only applies to bindings to DOM properties.\n   *\n   * This does not affect the use of the `DomSchemaChecker` to validate the template against the DOM\n   * schema. Rather, this flag is an experimental, not yet complete feature which uses the\n   * lib.dom.d.ts DOM typings in TypeScript to validate that DOM bindings are of the correct type\n   * for assignability to the underlying DOM element properties.\n   */\n  checkTypeOfDomBindings: boolean;\n\n  /**\n   * Whether to infer the type of the `$event` variable in event bindings for directive outputs or\n   * animation events.\n   *\n   * If this is `true`, the type of `$event` will be inferred based on the generic type of\n   * `EventEmitter`/`Subject` of the output. If set to `false`, the `$event` variable will be of\n   * type `any`.\n   */\n  checkTypeOfOutputEvents: boolean;\n\n  /**\n   * Whether to infer the type of the `$event` variable in event bindings for animations.\n   *\n   * If this is `true`, the type of `$event` will be `AnimationEvent` from `@angular/animations`.\n   * If set to `false`, the `$event` variable will be of type `any`.\n   */\n  checkTypeOfAnimationEvents: boolean;\n\n  /**\n   * Whether to infer the type of the `$event` variable in event bindings to DOM events.\n   *\n   * If this is `true`, the type of `$event` will be inferred based on TypeScript's\n   * `HTMLElementEventMap`, with a fallback to the native `Event` type. If set to `false`, the\n   * `$event` variable will be of type `any`.\n   */\n  checkTypeOfDomEvents: boolean;\n\n  /**\n   * Whether to infer the type of local references to DOM elements.\n   *\n   * If this is `true`, the type of a `#ref` variable on a DOM node in the template will be\n   * determined by the type of `document.createElement` for the given DOM node type. If set to\n   * `false`, the type of `ref` for DOM nodes will be `any`.\n   */\n  checkTypeOfDomReferences: boolean;\n\n\n  /**\n   * Whether to infer the type of local references.\n   *\n   * If this is `true`, the type of a `#ref` variable that points to a directive or `TemplateRef` in\n   * the template will be inferred correctly. If set to `false`, the type of `ref` for will be\n   * `any`.\n   */\n  checkTypeOfNonDomReferences: boolean;\n\n  /**\n   * Whether to adjust the output of the TCB to ensure compatibility with the `TemplateTypeChecker`.\n   *\n   * The statements generated in the TCB are optimized for performance and producing diagnostics.\n   * These optimizations can result in generating a TCB that does not have all the information\n   * needed by the `TemplateTypeChecker` for retrieving `Symbol`s. For example, as an optimization,\n   * the TCB will not generate variable declaration statements for directives that have no\n   * references, inputs, or outputs. However, the `TemplateTypeChecker` always needs these\n   * statements to be present in order to provide `ts.Symbol`s and `ts.Type`s for the directives.\n   *\n   * When set to `false`, enables TCB optimizations for template diagnostics.\n   * When set to `true`, ensures all information required by `TemplateTypeChecker` to\n   * retrieve symbols for template nodes is available in the TCB.\n   */\n  enableTemplateTypeChecker: boolean;\n\n  /**\n   * Whether to include type information from pipes in the type-checking operation.\n   *\n   * If this is `true`, then the pipe's type signature for `transform()` will be used to check the\n   * usage of the pipe. If this is `false`, then the result of applying a pipe will be `any`, and\n   * the types of the pipe's value and arguments will not be matched against the `transform()`\n   * method.\n   */\n  checkTypeOfPipes: boolean;\n\n  /**\n   * Whether to narrow the types of template contexts.\n   */\n  applyTemplateContextGuards: boolean;\n\n  /**\n   * Whether to use a strict type for null-safe navigation operations.\n   *\n   * If this is `false`, then the return type of `a?.b` or `a?()` will be `any`. If set to `true`,\n   * then the return type of `a?.b` for example will be the same as the type of the ternary\n   * expression `a != null ? a.b : a`.\n   */\n  strictSafeNavigationTypes: boolean;\n\n  /**\n   * Whether to descend into template bodies and check any bindings there.\n   */\n  checkTemplateBodies: boolean;\n\n  /**\n   * Whether to always apply DOM schema checks in template bodies, independently of the\n   * `checkTemplateBodies` setting.\n   */\n  alwaysCheckSchemaInTemplateBodies: boolean;\n\n  /**\n   * Whether to check resolvable queries.\n   *\n   * This is currently an unsupported feature.\n   */\n  checkQueries: false;\n\n  /**\n   * Whether to use any generic types of the context component.\n   *\n   * If this is `true`, then if the context component has generic types, those will be mirrored in\n   * the template type-checking context. If `false`, any generic type parameters of the context\n   * component will be set to `any` during type-checking.\n   */\n  useContextGenericType: boolean;\n\n  /**\n   * Whether or not to infer types for object and array literals in the template.\n   *\n   * If this is `true`, then the type of an object or an array literal in the template will be the\n   * same type that TypeScript would infer if the literal appeared in code. If `false`, then such\n   * literals are cast to `any` when declared.\n   */\n  strictLiteralTypes: boolean;\n\n  /**\n   * Whether to use inline type constructors.\n   *\n   * If this is `true`, create inline type constructors when required. For example, if a type\n   * constructor's parameters has private types, it cannot be created normally, so we inline it in\n   * the directives definition file.\n   *\n   * If false, do not create inline type constructors. Fall back to using `any` type for\n   * constructors that normally require inlining.\n   *\n   * This option requires the environment to support inlining. If the environment does not support\n   * inlining, this must be set to `false`.\n   */\n  useInlineTypeConstructors: boolean;\n\n  /**\n   * Whether or not to produce diagnostic suggestions in cases where the compiler could have\n   * inferred a better type for a construct, but was prevented from doing so by the current type\n   * checking configuration.\n   *\n   * For example, if the compiler could have used a template context guard to infer a better type\n   * for a structural directive's context and `let-` variables, but the user is in\n   * `fullTemplateTypeCheck` mode and such guards are therefore disabled.\n   *\n   * This mode is useful for clients like the Language Service which want to inform users of\n   * opportunities to improve their own developer experience.\n   */\n  suggestionsForSuboptimalTypeInference: boolean;\n}\n\n\nexport type TemplateSourceMapping =\n    DirectTemplateSourceMapping|IndirectTemplateSourceMapping|ExternalTemplateSourceMapping;\n\n/**\n * A mapping to an inline template in a TS file.\n *\n * `ParseSourceSpan`s for this template should be accurate for direct reporting in a TS error\n * message.\n */\nexport interface DirectTemplateSourceMapping {\n  type: 'direct';\n  node: ts.StringLiteral|ts.NoSubstitutionTemplateLiteral;\n}\n\n/**\n * A mapping to a template which is still in a TS file, but where the node positions in any\n * `ParseSourceSpan`s are not accurate for one reason or another.\n *\n * This can occur if the template expression was interpolated in a way where the compiler could not\n * construct a contiguous mapping for the template string. The `node` refers to the `template`\n * expression.\n */\nexport interface IndirectTemplateSourceMapping {\n  type: 'indirect';\n  componentClass: ClassDeclaration;\n  node: ts.Expression;\n  template: string;\n}\n\n/**\n * A mapping to a template declared in an external HTML file, where node positions in\n * `ParseSourceSpan`s represent accurate offsets into the external file.\n *\n * In this case, the given `node` refers to the `templateUrl` expression.\n */\nexport interface ExternalTemplateSourceMapping {\n  type: 'external';\n  componentClass: ClassDeclaration;\n  node: ts.Expression;\n  template: string;\n  templateUrl: string;\n}\n\n/**\n * A mapping of a TCB template id to a span in the corresponding template source.\n */\nexport interface SourceLocation {\n  id: TemplateId;\n  span: AbsoluteSourceSpan;\n}\n\n/**\n * A representation of all a node's template mapping information we know. Useful for producing\n * diagnostics based on a TCB node or generally mapping from a TCB node back to a template location.\n */\nexport interface FullTemplateMapping {\n  sourceLocation: SourceLocation;\n  templateSourceMapping: TemplateSourceMapping;\n  span: ParseSourceSpan;\n}\n\n/**\n * Abstracts the operation of determining which shim file will host a particular component's\n * template type-checking code.\n *\n * Different consumers of the type checking infrastructure may choose different approaches to\n * optimize for their specific use case (for example, the command-line compiler optimizes for\n * efficient `ts.Program` reuse in watch mode).\n */\nexport interface ComponentToShimMappingStrategy {\n  /**\n   * Given a component, determine a path to the shim file into which that component's type checking\n   * code will be generated.\n   *\n   * A major constraint is that components in different input files must not share the same shim\n   * file. The behavior of the template type-checking system is undefined if this is violated.\n   */\n  shimPathForComponent(node: ts.ClassDeclaration): AbsoluteFsPath;\n}\n\n/**\n * Strategy used to manage a `ts.Program` which contains template type-checking code and update it\n * over time.\n *\n * This abstraction allows both the Angular compiler itself as well as the language service to\n * implement efficient template type-checking using common infrastructure.\n */\nexport interface TypeCheckingProgramStrategy extends ComponentToShimMappingStrategy {\n  /**\n   * Whether this strategy supports modifying user files (inline modifications) in addition to\n   * modifying type-checking shims.\n   */\n  readonly supportsInlineOperations: boolean;\n\n  /**\n   * Retrieve the latest version of the program, containing all the updates made thus far.\n   */\n  getProgram(): ts.Program;\n\n  /**\n   * Incorporate a set of changes to either augment or completely replace the type-checking code\n   * included in the type-checking program.\n   */\n  updateFiles(contents: Map<AbsoluteFsPath, string>, updateMode: UpdateMode): void;\n}\n\nexport enum UpdateMode {\n  /**\n   * A complete update creates a completely new overlay of type-checking code on top of the user's\n   * original program, which doesn't include type-checking code from previous calls to\n   * `updateFiles`.\n   */\n  Complete,\n\n  /**\n   * An incremental update changes the contents of some files in the type-checking program without\n   * reverting any prior changes.\n   */\n  Incremental,\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}