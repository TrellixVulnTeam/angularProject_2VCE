{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar postcss = require('postcss');\n\nvar ICSSUtils = require('icss-utils');\n\nvar matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nvar matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nvar matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\nvar options = {};\nvar importIndex = 0;\n\nvar createImportedName = options && options.createImportedName || function (importName\n/*, path*/\n) {\n  return \"i__const_\".concat(importName.replace(/\\W/g, '_'), \"_\").concat(importIndex++);\n};\n\nmodule.exports = postcss.plugin('postcss-modules-values', function () {\n  return function (css, result) {\n    var importAliases = [];\n    var definitions = {};\n\n    var addDefinition = function addDefinition(atRule) {\n      var matches;\n\n      while (matches = matchValueDefinition.exec(atRule.params)) {\n        var _matches = matches,\n            _matches2 = _slicedToArray(_matches, 3),\n\n        /*match*/\n        key = _matches2[1],\n            value = _matches2[2]; // Add to the definitions, knowing that values can refer to each other\n\n\n        definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);\n        atRule.remove();\n      }\n    };\n\n    var addImport = function addImport(atRule) {\n      var matches = matchImports.exec(atRule.params);\n\n      if (matches) {\n        var _matches3 = _slicedToArray(matches, 3),\n\n        /*match*/\n        aliases = _matches3[1],\n            path = _matches3[2]; // We can use constants for path names\n\n\n        if (definitions[path]) {\n          path = definitions[path];\n        }\n\n        var imports = aliases.replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1').split(/\\s*,\\s*/).map(function (alias) {\n          var tokens = matchImport.exec(alias);\n\n          if (tokens) {\n            var _tokens = _slicedToArray(tokens, 3),\n\n            /*match*/\n            theirName = _tokens[1],\n                _tokens$ = _tokens[2],\n                myName = _tokens$ === void 0 ? theirName : _tokens$;\n\n            var importedName = createImportedName(myName);\n            definitions[myName] = importedName;\n            return {\n              theirName: theirName,\n              importedName: importedName\n            };\n          } else {\n            throw new Error(\"@import statement \\\"\".concat(alias, \"\\\" is invalid!\"));\n          }\n        });\n        importAliases.push({\n          path: path,\n          imports: imports\n        });\n        atRule.remove();\n      }\n    };\n    /* Look at all the @value statements and treat them as locals or as imports */\n\n\n    css.walkAtRules('value', function (atRule) {\n      if (matchImports.exec(atRule.params)) {\n        addImport(atRule);\n      } else {\n        if (atRule.params.indexOf('@value') !== -1) {\n          result.warn('Invalid value definition: ' + atRule.params);\n        }\n\n        addDefinition(atRule);\n      }\n    });\n    /* We want to export anything defined by now, but don't add it to the CSS yet or\n    it well get picked up by the replacement stuff */\n\n    var exportDeclarations = Object.keys(definitions).map(function (key) {\n      return postcss.decl({\n        value: definitions[key],\n        prop: key,\n        raws: {\n          before: '\\n  '\n        }\n      });\n    });\n    /* If we have no definitions, don't continue */\n\n    if (!Object.keys(definitions).length) {\n      return;\n    }\n    /* Perform replacements */\n\n\n    ICSSUtils.replaceSymbols(css, definitions);\n    /* Add export rules if any */\n\n    if (exportDeclarations.length > 0) {\n      var exportRule = postcss.rule({\n        selector: ':export',\n        raws: {\n          after: '\\n'\n        }\n      });\n      exportRule.append(exportDeclarations);\n      css.prepend(exportRule);\n    }\n    /* Add import rules */\n\n\n    importAliases.reverse().forEach(function (_ref) {\n      var path = _ref.path,\n          imports = _ref.imports;\n      var importRule = postcss.rule({\n        selector: \":import(\".concat(path, \")\"),\n        raws: {\n          after: '\\n'\n        }\n      });\n      imports.forEach(function (_ref2) {\n        var theirName = _ref2.theirName,\n            importedName = _ref2.importedName;\n        importRule.append({\n          value: theirName,\n          prop: importedName,\n          raws: {\n            before: '\\n  '\n          }\n        });\n      });\n      css.prepend(importRule);\n    });\n  };\n});","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/postcss-modules-values/src/index.js"],"names":["postcss","require","ICSSUtils","matchImports","matchValueDefinition","matchImport","options","importIndex","createImportedName","importName","replace","module","exports","plugin","css","result","importAliases","definitions","addDefinition","atRule","matches","exec","params","key","value","replaceValueSymbols","remove","addImport","aliases","path","imports","split","map","alias","tokens","theirName","myName","importedName","Error","push","walkAtRules","indexOf","warn","exportDeclarations","Object","keys","decl","prop","raws","before","length","replaceSymbols","exportRule","rule","selector","after","append","prepend","reverse","forEach","importRule"],"mappings":"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","sourcesContent":["'use strict';\n\nconst postcss = require('postcss');\nconst ICSSUtils = require('icss-utils');\n\nconst matchImports = /^(.+?|\\([\\s\\S]+?\\))\\s+from\\s+(\"[^\"]*\"|'[^']*'|[\\w-]+)$/;\nconst matchValueDefinition = /(?:\\s+|^)([\\w-]+):?\\s+(.+?)\\s*$/g;\nconst matchImport = /^([\\w-]+)(?:\\s+as\\s+([\\w-]+))?/;\n\nlet options = {};\nlet importIndex = 0;\nlet createImportedName =\n  (options && options.createImportedName) ||\n  ((importName /*, path*/) =>\n    `i__const_${importName.replace(/\\W/g, '_')}_${importIndex++}`);\n\nmodule.exports = postcss.plugin(\n  'postcss-modules-values',\n  () => (css, result) => {\n    const importAliases = [];\n    const definitions = {};\n\n    const addDefinition = atRule => {\n      let matches;\n      while ((matches = matchValueDefinition.exec(atRule.params))) {\n        let [, /*match*/ key, value] = matches;\n        // Add to the definitions, knowing that values can refer to each other\n        definitions[key] = ICSSUtils.replaceValueSymbols(value, definitions);\n        atRule.remove();\n      }\n    };\n\n    const addImport = atRule => {\n      const matches = matchImports.exec(atRule.params);\n      if (matches) {\n        let [, /*match*/ aliases, path] = matches;\n        // We can use constants for path names\n        if (definitions[path]) {\n          path = definitions[path];\n        }\n        const imports = aliases\n          .replace(/^\\(\\s*([\\s\\S]+)\\s*\\)$/, '$1')\n          .split(/\\s*,\\s*/)\n          .map(alias => {\n            const tokens = matchImport.exec(alias);\n            if (tokens) {\n              const [, /*match*/ theirName, myName = theirName] = tokens;\n              const importedName = createImportedName(myName);\n              definitions[myName] = importedName;\n              return { theirName, importedName };\n            } else {\n              throw new Error(`@import statement \"${alias}\" is invalid!`);\n            }\n          });\n        importAliases.push({ path, imports });\n        atRule.remove();\n      }\n    };\n\n    /* Look at all the @value statements and treat them as locals or as imports */\n    css.walkAtRules('value', atRule => {\n      if (matchImports.exec(atRule.params)) {\n        addImport(atRule);\n      } else {\n        if (atRule.params.indexOf('@value') !== -1) {\n          result.warn('Invalid value definition: ' + atRule.params);\n        }\n\n        addDefinition(atRule);\n      }\n    });\n\n    /* We want to export anything defined by now, but don't add it to the CSS yet or\n   it well get picked up by the replacement stuff */\n    const exportDeclarations = Object.keys(definitions).map(key =>\n      postcss.decl({\n        value: definitions[key],\n        prop: key,\n        raws: { before: '\\n  ' }\n      })\n    );\n\n    /* If we have no definitions, don't continue */\n    if (!Object.keys(definitions).length) {\n      return;\n    }\n\n    /* Perform replacements */\n    ICSSUtils.replaceSymbols(css, definitions);\n\n    /* Add export rules if any */\n    if (exportDeclarations.length > 0) {\n      const exportRule = postcss.rule({\n        selector: ':export',\n        raws: { after: '\\n' }\n      });\n      exportRule.append(exportDeclarations);\n      css.prepend(exportRule);\n    }\n\n    /* Add import rules */\n    importAliases.reverse().forEach(({ path, imports }) => {\n      const importRule = postcss.rule({\n        selector: `:import(${path})`,\n        raws: { after: '\\n' }\n      });\n      imports.forEach(({ theirName, importedName }) => {\n        importRule.append({\n          value: theirName,\n          prop: importedName,\n          raws: { before: '\\n  ' }\n        });\n      });\n\n      css.prepend(importRule);\n    });\n  }\n);\n"]},"metadata":{},"sourceType":"script"}