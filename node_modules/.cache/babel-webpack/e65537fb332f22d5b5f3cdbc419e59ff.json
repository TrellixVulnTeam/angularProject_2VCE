{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _taggedTemplateLiteral = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/taggedTemplateLiteral\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _templateObject;\n\nvar BB = require('bluebird');\n\nvar contentPath = require('./content/path');\n\nvar crypto = require('crypto');\n\nvar figgyPudding = require('figgy-pudding');\n\nvar fixOwner = require('./util/fix-owner');\n\nvar fs = require('graceful-fs');\n\nvar hashToSegments = require('./util/hash-to-segments');\n\nvar ms = require('mississippi');\n\nvar path = require('path');\n\nvar ssri = require('ssri');\n\nvar Y = require('./util/y.js');\n\nvar indexV = require('../package.json')['cache-version'].index;\n\nvar appendFileAsync = BB.promisify(fs.appendFile);\nvar readFileAsync = BB.promisify(fs.readFile);\nvar readdirAsync = BB.promisify(fs.readdir);\nvar concat = ms.concat;\nvar from = ms.from;\n\nmodule.exports.NotFoundError = /*#__PURE__*/function (_Error) {\n  _inherits(NotFoundError, _Error);\n\n  var _super = _createSuper(NotFoundError);\n\n  function NotFoundError(cache, key) {\n    var _this;\n\n    _classCallCheck(this, NotFoundError);\n\n    _this = _super.call(this, Y(_templateObject || (_templateObject = _taggedTemplateLiteral([\"No cache entry for `\", \"` found in `\", \"`\"], [\"No cache entry for \\\\`\", \"\\\\` found in \\\\`\", \"\\\\`\"])), key, cache));\n    _this.code = 'ENOENT';\n    _this.cache = cache;\n    _this.key = key;\n    return _this;\n  }\n\n  return NotFoundError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar IndexOpts = figgyPudding({\n  metadata: {},\n  size: {}\n});\nmodule.exports.insert = insert;\n\nfunction insert(cache, key, integrity, opts) {\n  opts = IndexOpts(opts);\n  var bucket = bucketPath(cache, key);\n  var entry = {\n    key: key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  };\n  return fixOwner.mkdirfix(cache, path.dirname(bucket)).then(function () {\n    var stringified = JSON.stringify(entry); // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n\n    return appendFileAsync(bucket, \"\\n\".concat(hashEntry(stringified), \"\\t\").concat(stringified));\n  }).then(function () {\n    return fixOwner.chownr(cache, bucket);\n  }).catch({\n    code: 'ENOENT'\n  }, function () {// There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(function () {\n    return formatEntry(cache, entry);\n  });\n}\n\nmodule.exports.insert.sync = insertSync;\n\nfunction insertSync(cache, key, integrity, opts) {\n  opts = IndexOpts(opts);\n  var bucket = bucketPath(cache, key);\n  var entry = {\n    key: key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  };\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));\n  var stringified = JSON.stringify(entry);\n  fs.appendFileSync(bucket, \"\\n\".concat(hashEntry(stringified), \"\\t\").concat(stringified));\n\n  try {\n    fixOwner.chownr.sync(cache, bucket);\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n  }\n\n  return formatEntry(cache, entry);\n}\n\nmodule.exports.find = find;\n\nfunction find(cache, key) {\n  var bucket = bucketPath(cache, key);\n  return bucketEntries(bucket).then(function (entries) {\n    return entries.reduce(function (latest, next) {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  }).catch(function (err) {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  });\n}\n\nmodule.exports.find.sync = findSync;\n\nfunction findSync(cache, key) {\n  var bucket = bucketPath(cache, key);\n\n  try {\n    return bucketEntriesSync(bucket).reduce(function (latest, next) {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}\n\nmodule.exports.delete = del;\n\nfunction del(cache, key, opts) {\n  return insert(cache, key, null, opts);\n}\n\nmodule.exports.delete.sync = delSync;\n\nfunction delSync(cache, key, opts) {\n  return insertSync(cache, key, null, opts);\n}\n\nmodule.exports.lsStream = lsStream;\n\nfunction lsStream(cache) {\n  var indexDir = bucketDir(cache);\n  var stream = from.obj(); // \"/cachename/*\"\n\n  readdirOrEmpty(indexDir).map(function (bucket) {\n    var bucketPath = path.join(indexDir, bucket); // \"/cachename/<bucket 0xFF>/*\"\n\n    return readdirOrEmpty(bucketPath).map(function (subbucket) {\n      var subbucketPath = path.join(bucketPath, subbucket); // \"/cachename/<bucket 0xFF>/<bucket 0xFF>/*\"\n\n      return readdirOrEmpty(subbucketPath).map(function (entry) {\n        var getKeyToEntry = bucketEntries(path.join(subbucketPath, entry)).reduce(function (acc, entry) {\n          acc.set(entry.key, entry);\n          return acc;\n        }, new Map());\n        return getKeyToEntry.then(function (reduced) {\n          var _iterator = _createForOfIteratorHelper(reduced.values()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _entry = _step.value;\n              var formatted = formatEntry(cache, _entry);\n              formatted && stream.push(formatted);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }).catch({\n          code: 'ENOENT'\n        }, nop);\n      });\n    });\n  }).then(function () {\n    stream.push(null);\n  }, function (err) {\n    stream.emit('error', err);\n  });\n  return stream;\n}\n\nmodule.exports.ls = ls;\n\nfunction ls(cache) {\n  return BB.fromNode(function (cb) {\n    lsStream(cache).on('error', cb).pipe(concat(function (entries) {\n      cb(null, entries.reduce(function (acc, xs) {\n        acc[xs.key] = xs;\n        return acc;\n      }, {}));\n    }));\n  });\n}\n\nfunction bucketEntries(bucket, filter) {\n  return readFileAsync(bucket, 'utf8').then(function (data) {\n    return _bucketEntries(data, filter);\n  });\n}\n\nfunction bucketEntriesSync(bucket, filter) {\n  var data = fs.readFileSync(bucket, 'utf8');\n  return _bucketEntries(data, filter);\n}\n\nfunction _bucketEntries(data, filter) {\n  var entries = [];\n  data.split('\\n').forEach(function (entry) {\n    if (!entry) {\n      return;\n    }\n\n    var pieces = entry.split('\\t');\n\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return;\n    }\n\n    var obj;\n\n    try {\n      obj = JSON.parse(pieces[1]);\n    } catch (e) {\n      // Entry is corrupted!\n      return;\n    }\n\n    if (obj) {\n      entries.push(obj);\n    }\n  });\n  return entries;\n}\n\nmodule.exports._bucketDir = bucketDir;\n\nfunction bucketDir(cache) {\n  return path.join(cache, \"index-v\".concat(indexV));\n}\n\nmodule.exports._bucketPath = bucketPath;\n\nfunction bucketPath(cache, key) {\n  var hashed = hashKey(key);\n  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));\n}\n\nmodule.exports._hashKey = hashKey;\n\nfunction hashKey(key) {\n  return hash(key, 'sha256');\n}\n\nmodule.exports._hashEntry = hashEntry;\n\nfunction hashEntry(str) {\n  return hash(str, 'sha1');\n}\n\nfunction hash(str, digest) {\n  return crypto.createHash(digest).update(str).digest('hex');\n}\n\nfunction formatEntry(cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) {\n    return null;\n  }\n\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  };\n}\n\nfunction readdirOrEmpty(dir) {\n  return readdirAsync(dir).catch({\n    code: 'ENOENT'\n  }, function () {\n    return [];\n  }).catch({\n    code: 'ENOTDIR'\n  }, function () {\n    return [];\n  });\n}\n\nfunction nop() {}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/node_modules/cacache/lib/entry-index.js"],"names":["BB","require","contentPath","crypto","figgyPudding","fixOwner","fs","hashToSegments","ms","path","ssri","Y","indexV","index","appendFileAsync","promisify","appendFile","readFileAsync","readFile","readdirAsync","readdir","concat","from","module","exports","NotFoundError","cache","key","code","Error","IndexOpts","metadata","size","insert","integrity","opts","bucket","bucketPath","entry","stringify","time","Date","now","mkdirfix","dirname","then","stringified","JSON","hashEntry","chownr","catch","formatEntry","sync","insertSync","appendFileSync","err","find","bucketEntries","entries","reduce","latest","next","findSync","bucketEntriesSync","delete","del","delSync","lsStream","indexDir","bucketDir","stream","obj","readdirOrEmpty","map","join","subbucket","subbucketPath","getKeyToEntry","acc","set","Map","reduced","values","formatted","push","nop","emit","ls","fromNode","cb","on","pipe","xs","filter","data","_bucketEntries","readFileSync","split","forEach","pieces","parse","e","_bucketDir","_bucketPath","hashed","hashKey","apply","_hashKey","hash","_hashEntry","str","digest","createHash","update","dir"],"mappings":"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","sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst contentPath = require('./content/path')\nconst crypto = require('crypto')\nconst figgyPudding = require('figgy-pudding')\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('graceful-fs')\nconst hashToSegments = require('./util/hash-to-segments')\nconst ms = require('mississippi')\nconst path = require('path')\nconst ssri = require('ssri')\nconst Y = require('./util/y.js')\n\nconst indexV = require('../package.json')['cache-version'].index\n\nconst appendFileAsync = BB.promisify(fs.appendFile)\nconst readFileAsync = BB.promisify(fs.readFile)\nconst readdirAsync = BB.promisify(fs.readdir)\nconst concat = ms.concat\nconst from = ms.from\n\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor (cache, key) {\n    super(Y`No cache entry for \\`${key}\\` found in \\`${cache}\\``)\n    this.code = 'ENOENT'\n    this.cache = cache\n    this.key = key\n  }\n}\n\nconst IndexOpts = figgyPudding({\n  metadata: {},\n  size: {}\n})\n\nmodule.exports.insert = insert\nfunction insert (cache, key, integrity, opts) {\n  opts = IndexOpts(opts)\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  }\n  return fixOwner.mkdirfix(\n    cache, path.dirname(bucket)\n  ).then(() => {\n    const stringified = JSON.stringify(entry)\n    // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with this.\n    return appendFileAsync(\n      bucket, `\\n${hashEntry(stringified)}\\t${stringified}`\n    )\n  }).then(\n    () => fixOwner.chownr(cache, bucket)\n  ).catch({ code: 'ENOENT' }, () => {\n    // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }).then(() => {\n    return formatEntry(cache, entry)\n  })\n}\n\nmodule.exports.insert.sync = insertSync\nfunction insertSync (cache, key, integrity, opts) {\n  opts = IndexOpts(opts)\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size: opts.size,\n    metadata: opts.metadata\n  }\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket))\n  const stringified = JSON.stringify(entry)\n  fs.appendFileSync(\n    bucket, `\\n${hashEntry(stringified)}\\t${stringified}`\n  )\n  try {\n    fixOwner.chownr.sync(cache, bucket)\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err\n    }\n  }\n  return formatEntry(cache, entry)\n}\n\nmodule.exports.find = find\nfunction find (cache, key) {\n  const bucket = bucketPath(cache, key)\n  return bucketEntries(bucket).then(entries => {\n    return entries.reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  }).catch(err => {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  })\n}\n\nmodule.exports.find.sync = findSync\nfunction findSync (cache, key) {\n  const bucket = bucketPath(cache, key)\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports.delete = del\nfunction del (cache, key, opts) {\n  return insert(cache, key, null, opts)\n}\n\nmodule.exports.delete.sync = delSync\nfunction delSync (cache, key, opts) {\n  return insertSync(cache, key, null, opts)\n}\n\nmodule.exports.lsStream = lsStream\nfunction lsStream (cache) {\n  const indexDir = bucketDir(cache)\n  const stream = from.obj()\n\n  // \"/cachename/*\"\n  readdirOrEmpty(indexDir).map(bucket => {\n    const bucketPath = path.join(indexDir, bucket)\n\n    // \"/cachename/<bucket 0xFF>/*\"\n    return readdirOrEmpty(bucketPath).map(subbucket => {\n      const subbucketPath = path.join(bucketPath, subbucket)\n\n      // \"/cachename/<bucket 0xFF>/<bucket 0xFF>/*\"\n      return readdirOrEmpty(subbucketPath).map(entry => {\n        const getKeyToEntry = bucketEntries(\n          path.join(subbucketPath, entry)\n        ).reduce((acc, entry) => {\n          acc.set(entry.key, entry)\n          return acc\n        }, new Map())\n\n        return getKeyToEntry.then(reduced => {\n          for (let entry of reduced.values()) {\n            const formatted = formatEntry(cache, entry)\n            formatted && stream.push(formatted)\n          }\n        }).catch({ code: 'ENOENT' }, nop)\n      })\n    })\n  }).then(() => {\n    stream.push(null)\n  }, err => {\n    stream.emit('error', err)\n  })\n\n  return stream\n}\n\nmodule.exports.ls = ls\nfunction ls (cache) {\n  return BB.fromNode(cb => {\n    lsStream(cache).on('error', cb).pipe(concat(entries => {\n      cb(null, entries.reduce((acc, xs) => {\n        acc[xs.key] = xs\n        return acc\n      }, {}))\n    }))\n  })\n}\n\nfunction bucketEntries (bucket, filter) {\n  return readFileAsync(\n    bucket, 'utf8'\n  ).then(data => _bucketEntries(data, filter))\n}\n\nfunction bucketEntriesSync (bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8')\n  return _bucketEntries(data, filter)\n}\n\nfunction _bucketEntries (data, filter) {\n  let entries = []\n  data.split('\\n').forEach(entry => {\n    if (!entry) { return }\n    const pieces = entry.split('\\t')\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return\n    }\n    let obj\n    try {\n      obj = JSON.parse(pieces[1])\n    } catch (e) {\n      // Entry is corrupted!\n      return\n    }\n    if (obj) {\n      entries.push(obj)\n    }\n  })\n  return entries\n}\n\nmodule.exports._bucketDir = bucketDir\nfunction bucketDir (cache) {\n  return path.join(cache, `index-v${indexV}`)\n}\n\nmodule.exports._bucketPath = bucketPath\nfunction bucketPath (cache, key) {\n  const hashed = hashKey(key)\n  return path.join.apply(path, [bucketDir(cache)].concat(\n    hashToSegments(hashed)\n  ))\n}\n\nmodule.exports._hashKey = hashKey\nfunction hashKey (key) {\n  return hash(key, 'sha256')\n}\n\nmodule.exports._hashEntry = hashEntry\nfunction hashEntry (str) {\n  return hash(str, 'sha1')\n}\n\nfunction hash (str, digest) {\n  return crypto\n    .createHash(digest)\n    .update(str)\n    .digest('hex')\n}\n\nfunction formatEntry (cache, entry) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity) { return null }\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: contentPath(cache, entry.integrity),\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  }\n}\n\nfunction readdirOrEmpty (dir) {\n  return readdirAsync(dir)\n    .catch({ code: 'ENOENT' }, () => [])\n    .catch({ code: 'ENOTDIR' }, () => [])\n}\n\nfunction nop () {\n}\n"]},"metadata":{},"sourceType":"script"}