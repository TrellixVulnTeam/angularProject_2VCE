{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_emitter\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeEmitter = exports.canEmitType = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n  /**\n   * Determines whether the provided type can be emitted, which means that it can be safely emitted\n   * into a different location.\n   *\n   * If this function returns true, a `TypeEmitter` should be able to succeed. Vice versa, if this\n   * function returns false, then using the `TypeEmitter` should not be attempted as it is known to\n   * fail.\n   */\n\n\n  function canEmitType(type, resolver) {\n    return canEmitTypeWorker(type);\n\n    function canEmitTypeWorker(type) {\n      return visitTypeNode(type, {\n        visitTypeReferenceNode: function visitTypeReferenceNode(type) {\n          return canEmitTypeReference(type);\n        },\n        visitArrayTypeNode: function visitArrayTypeNode(type) {\n          return canEmitTypeWorker(type.elementType);\n        },\n        visitKeywordType: function visitKeywordType() {\n          return true;\n        },\n        visitLiteralType: function visitLiteralType() {\n          return true;\n        },\n        visitOtherType: function visitOtherType() {\n          return false;\n        }\n      });\n    }\n\n    function canEmitTypeReference(type) {\n      var reference = resolver(type); // If the type could not be resolved, it can not be emitted.\n\n      if (reference === null) {\n        return false;\n      } // If the type is a reference without a owning module, consider the type not to be eligible for\n      // emitting.\n\n\n      if (reference instanceof imports_1.Reference && !reference.hasOwningModuleGuess) {\n        return false;\n      } // The type can be emitted if either it does not have any type arguments, or all of them can be\n      // emitted.\n\n\n      return type.typeArguments === undefined || type.typeArguments.every(canEmitTypeWorker);\n    }\n  }\n\n  exports.canEmitType = canEmitType;\n  /**\n   * Given a `ts.TypeNode`, this class derives an equivalent `ts.TypeNode` that has been emitted into\n   * a different context.\n   *\n   * For example, consider the following code:\n   *\n   * ```\n   * import {NgIterable} from '@angular/core';\n   *\n   * class NgForOf<T, U extends NgIterable<T>> {}\n   * ```\n   *\n   * Here, the generic type parameters `T` and `U` can be emitted into a different context, as the\n   * type reference to `NgIterable` originates from an absolute module import so that it can be\n   * emitted anywhere, using that same module import. The process of emitting translates the\n   * `NgIterable` type reference to a type reference that is valid in the context in which it is\n   * emitted, for example:\n   *\n   * ```\n   * import * as i0 from '@angular/core';\n   * import * as i1 from '@angular/common';\n   *\n   * const _ctor1: <T, U extends i0.NgIterable<T>>(o: Pick<i1.NgForOf<T, U>, 'ngForOf'>):\n   * i1.NgForOf<T, U>;\n   * ```\n   *\n   * Notice how the type reference for `NgIterable` has been translated into a qualified name,\n   * referring to the namespace import that was created.\n   */\n\n  var TypeEmitter =\n  /** @class */\n  function () {\n    function TypeEmitter(resolver, emitReference) {\n      this.resolver = resolver;\n      this.emitReference = emitReference;\n    }\n\n    TypeEmitter.prototype.emitType = function (type) {\n      var _this = this;\n\n      return visitTypeNode(type, {\n        visitTypeReferenceNode: function visitTypeReferenceNode(type) {\n          return _this.emitTypeReference(type);\n        },\n        visitArrayTypeNode: function visitArrayTypeNode(type) {\n          return ts.updateArrayTypeNode(type, _this.emitType(type.elementType));\n        },\n        visitKeywordType: function visitKeywordType(type) {\n          return type;\n        },\n        visitLiteralType: function visitLiteralType(type) {\n          return type;\n        },\n        visitOtherType: function visitOtherType() {\n          throw new Error('Unable to emit a complex type');\n        }\n      });\n    };\n\n    TypeEmitter.prototype.emitTypeReference = function (type) {\n      var _this = this; // Determine the reference that the type corresponds with.\n\n\n      var reference = this.resolver(type);\n\n      if (reference === null) {\n        throw new Error('Unable to emit an unresolved reference');\n      } // Emit the type arguments, if any.\n\n\n      var typeArguments = undefined;\n\n      if (type.typeArguments !== undefined) {\n        typeArguments = ts.createNodeArray(type.typeArguments.map(function (typeArg) {\n          return _this.emitType(typeArg);\n        }));\n      } // Emit the type name.\n\n\n      var typeName = type.typeName;\n\n      if (reference instanceof imports_1.Reference) {\n        if (!reference.hasOwningModuleGuess) {\n          throw new Error('A type reference to emit must be imported from an absolute module');\n        }\n\n        var emittedType = this.emitReference(reference);\n\n        if (!ts.isTypeReferenceNode(emittedType)) {\n          throw new Error(\"Expected TypeReferenceNode for emitted reference, got \" + ts.SyntaxKind[emittedType.kind]);\n        }\n\n        typeName = emittedType.typeName;\n      }\n\n      return ts.updateTypeReferenceNode(type, typeName, typeArguments);\n    };\n\n    return TypeEmitter;\n  }();\n\n  exports.TypeEmitter = TypeEmitter;\n\n  function visitTypeNode(type, visitor) {\n    if (ts.isTypeReferenceNode(type)) {\n      return visitor.visitTypeReferenceNode(type);\n    } else if (ts.isArrayTypeNode(type)) {\n      return visitor.visitArrayTypeNode(type);\n    } else if (ts.isLiteralTypeNode(type)) {\n      return visitor.visitLiteralType(type);\n    }\n\n    switch (type.kind) {\n      case ts.SyntaxKind.AnyKeyword:\n      case ts.SyntaxKind.UnknownKeyword:\n      case ts.SyntaxKind.NumberKeyword:\n      case ts.SyntaxKind.ObjectKeyword:\n      case ts.SyntaxKind.BooleanKeyword:\n      case ts.SyntaxKind.StringKeyword:\n      case ts.SyntaxKind.UndefinedKeyword:\n      case ts.SyntaxKind.NullKeyword:\n        return visitor.visitKeywordType(type);\n\n      default:\n        return visitor.visitOtherType(type);\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/type_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport {Reference} from '../../imports';\n\n/**\n * A resolved type reference can either be a `Reference`, the original `ts.TypeReferenceNode` itself\n * or null to indicate the no reference could be resolved.\n */\nexport type ResolvedTypeReference = Reference|ts.TypeReferenceNode|null;\n\n/**\n * A type reference resolver function is responsible for finding the declaration of the type\n * reference and verifying whether it can be emitted.\n */\nexport type TypeReferenceResolver = (type: ts.TypeReferenceNode) => ResolvedTypeReference;\n\n/**\n * Determines whether the provided type can be emitted, which means that it can be safely emitted\n * into a different location.\n *\n * If this function returns true, a `TypeEmitter` should be able to succeed. Vice versa, if this\n * function returns false, then using the `TypeEmitter` should not be attempted as it is known to\n * fail.\n */\nexport function canEmitType(type: ts.TypeNode, resolver: TypeReferenceResolver): boolean {\n  return canEmitTypeWorker(type);\n\n  function canEmitTypeWorker(type: ts.TypeNode): boolean {\n    return visitTypeNode(type, {\n      visitTypeReferenceNode: type => canEmitTypeReference(type),\n      visitArrayTypeNode: type => canEmitTypeWorker(type.elementType),\n      visitKeywordType: () => true,\n      visitLiteralType: () => true,\n      visitOtherType: () => false,\n    });\n  }\n\n  function canEmitTypeReference(type: ts.TypeReferenceNode): boolean {\n    const reference = resolver(type);\n\n    // If the type could not be resolved, it can not be emitted.\n    if (reference === null) {\n      return false;\n    }\n\n    // If the type is a reference without a owning module, consider the type not to be eligible for\n    // emitting.\n    if (reference instanceof Reference && !reference.hasOwningModuleGuess) {\n      return false;\n    }\n\n    // The type can be emitted if either it does not have any type arguments, or all of them can be\n    // emitted.\n    return type.typeArguments === undefined || type.typeArguments.every(canEmitTypeWorker);\n  }\n}\n\n/**\n * Given a `ts.TypeNode`, this class derives an equivalent `ts.TypeNode` that has been emitted into\n * a different context.\n *\n * For example, consider the following code:\n *\n * ```\n * import {NgIterable} from '@angular/core';\n *\n * class NgForOf<T, U extends NgIterable<T>> {}\n * ```\n *\n * Here, the generic type parameters `T` and `U` can be emitted into a different context, as the\n * type reference to `NgIterable` originates from an absolute module import so that it can be\n * emitted anywhere, using that same module import. The process of emitting translates the\n * `NgIterable` type reference to a type reference that is valid in the context in which it is\n * emitted, for example:\n *\n * ```\n * import * as i0 from '@angular/core';\n * import * as i1 from '@angular/common';\n *\n * const _ctor1: <T, U extends i0.NgIterable<T>>(o: Pick<i1.NgForOf<T, U>, 'ngForOf'>):\n * i1.NgForOf<T, U>;\n * ```\n *\n * Notice how the type reference for `NgIterable` has been translated into a qualified name,\n * referring to the namespace import that was created.\n */\nexport class TypeEmitter {\n  /**\n   * Resolver function that computes a `Reference` corresponding with a `ts.TypeReferenceNode`.\n   */\n  private resolver: TypeReferenceResolver;\n\n  /**\n   * Given a `Reference`, this function is responsible for the actual emitting work. It should\n   * produce a `ts.TypeNode` that is valid within the desired context.\n   */\n  private emitReference: (ref: Reference) => ts.TypeNode;\n\n  constructor(resolver: TypeReferenceResolver, emitReference: (ref: Reference) => ts.TypeNode) {\n    this.resolver = resolver;\n    this.emitReference = emitReference;\n  }\n\n  emitType(type: ts.TypeNode): ts.TypeNode {\n    return visitTypeNode(type, {\n      visitTypeReferenceNode: type => this.emitTypeReference(type),\n      visitArrayTypeNode: type => ts.updateArrayTypeNode(type, this.emitType(type.elementType)),\n      visitKeywordType: type => type,\n      visitLiteralType: type => type,\n      visitOtherType: () => {\n        throw new Error('Unable to emit a complex type');\n      },\n    });\n  }\n\n  private emitTypeReference(type: ts.TypeReferenceNode): ts.TypeNode {\n    // Determine the reference that the type corresponds with.\n    const reference = this.resolver(type);\n    if (reference === null) {\n      throw new Error('Unable to emit an unresolved reference');\n    }\n\n    // Emit the type arguments, if any.\n    let typeArguments: ts.NodeArray<ts.TypeNode>|undefined = undefined;\n    if (type.typeArguments !== undefined) {\n      typeArguments = ts.createNodeArray(type.typeArguments.map(typeArg => this.emitType(typeArg)));\n    }\n\n    // Emit the type name.\n    let typeName = type.typeName;\n    if (reference instanceof Reference) {\n      if (!reference.hasOwningModuleGuess) {\n        throw new Error('A type reference to emit must be imported from an absolute module');\n      }\n\n      const emittedType = this.emitReference(reference);\n      if (!ts.isTypeReferenceNode(emittedType)) {\n        throw new Error(`Expected TypeReferenceNode for emitted reference, got ${\n            ts.SyntaxKind[emittedType.kind]}`);\n      }\n\n      typeName = emittedType.typeName;\n    }\n\n    return ts.updateTypeReferenceNode(type, typeName, typeArguments);\n  }\n}\n\n/**\n * Visitor interface that allows for unified recognition of the different types of `ts.TypeNode`s,\n * so that `visitTypeNode` is a centralized piece of recognition logic to be used in both\n * `canEmitType` and `TypeEmitter`.\n */\ninterface TypeEmitterVisitor<R> {\n  visitTypeReferenceNode(type: ts.TypeReferenceNode): R;\n  visitArrayTypeNode(type: ts.ArrayTypeNode): R;\n  visitKeywordType(type: ts.KeywordTypeNode): R;\n  visitLiteralType(type: ts.LiteralTypeNode): R;\n  visitOtherType(type: ts.TypeNode): R;\n}\n\nfunction visitTypeNode<R>(type: ts.TypeNode, visitor: TypeEmitterVisitor<R>): R {\n  if (ts.isTypeReferenceNode(type)) {\n    return visitor.visitTypeReferenceNode(type);\n  } else if (ts.isArrayTypeNode(type)) {\n    return visitor.visitArrayTypeNode(type);\n  } else if (ts.isLiteralTypeNode(type)) {\n    return visitor.visitLiteralType(type);\n  }\n\n  switch (type.kind) {\n    case ts.SyntaxKind.AnyKeyword:\n    case ts.SyntaxKind.UnknownKeyword:\n    case ts.SyntaxKind.NumberKeyword:\n    case ts.SyntaxKind.ObjectKeyword:\n    case ts.SyntaxKind.BooleanKeyword:\n    case ts.SyntaxKind.StringKeyword:\n    case ts.SyntaxKind.UndefinedKeyword:\n    case ts.SyntaxKind.NullKeyword:\n      return visitor.visitKeywordType(type as ts.KeywordTypeNode);\n    default:\n      return visitor.visitOtherType(type);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}