{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/output/output_interpreter\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/output/ts_emitter\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.interpretStatements = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var ts_emitter_1 = require(\"@angular/compiler/src/output/ts_emitter\");\n\n  function interpretStatements(statements, reflector) {\n    var ctx = new _ExecutionContext(null, null, null, new Map());\n    var visitor = new StatementInterpreter(reflector);\n    visitor.visitAllStatements(statements, ctx);\n    var result = {};\n    ctx.exports.forEach(function (exportName) {\n      result[exportName] = ctx.vars.get(exportName);\n    });\n    return result;\n  }\n\n  exports.interpretStatements = interpretStatements;\n\n  function _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n    var childCtx = ctx.createChildWihtLocalVars();\n\n    for (var i = 0; i < varNames.length; i++) {\n      childCtx.vars.set(varNames[i], varValues[i]);\n    }\n\n    var result = visitor.visitAllStatements(statements, childCtx);\n    return result ? result.value : null;\n  }\n\n  var _ExecutionContext =\n  /** @class */\n  function () {\n    function _ExecutionContext(parent, instance, className, vars) {\n      this.parent = parent;\n      this.instance = instance;\n      this.className = className;\n      this.vars = vars;\n      this.exports = [];\n    }\n\n    _ExecutionContext.prototype.createChildWihtLocalVars = function () {\n      return new _ExecutionContext(this, this.instance, this.className, new Map());\n    };\n\n    return _ExecutionContext;\n  }();\n\n  var ReturnValue =\n  /** @class */\n  function () {\n    function ReturnValue(value) {\n      this.value = value;\n    }\n\n    return ReturnValue;\n  }();\n\n  function createDynamicClass(_classStmt, _ctx, _visitor) {\n    var propertyDescriptors = {};\n\n    _classStmt.getters.forEach(function (getter) {\n      // Note: use `function` instead of arrow function to capture `this`\n      propertyDescriptors[getter.name] = {\n        configurable: false,\n        get: function get() {\n          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n          return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n        }\n      };\n    });\n\n    _classStmt.methods.forEach(function (method) {\n      var paramNames = method.params.map(function (param) {\n        return param.name;\n      }); // Note: use `function` instead of arrow function to capture `this`\n\n      propertyDescriptors[method.name] = {\n        writable: false,\n        configurable: false,\n        value: function value() {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n          return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n        }\n      };\n    });\n\n    var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) {\n      return param.name;\n    }); // Note: use `function` instead of arrow function to capture `this`\n\n\n    var ctor = function ctor() {\n      var _this = this;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n\n      _classStmt.fields.forEach(function (field) {\n        _this[field.name] = undefined;\n      });\n\n      _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n    };\n\n    var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n    return ctor;\n  }\n\n  var StatementInterpreter =\n  /** @class */\n  function () {\n    function StatementInterpreter(reflector) {\n      this.reflector = reflector;\n    }\n\n    StatementInterpreter.prototype.debugAst = function (ast) {\n      return ts_emitter_1.debugOutputAstAsTypeScript(ast);\n    };\n\n    StatementInterpreter.prototype.visitDeclareVarStmt = function (stmt, ctx) {\n      var initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;\n      ctx.vars.set(stmt.name, initialValue);\n\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        ctx.exports.push(stmt.name);\n      }\n\n      return null;\n    };\n\n    StatementInterpreter.prototype.visitWriteVarExpr = function (expr, ctx) {\n      var value = expr.value.visitExpression(this, ctx);\n      var currCtx = ctx;\n\n      while (currCtx != null) {\n        if (currCtx.vars.has(expr.name)) {\n          currCtx.vars.set(expr.name, value);\n          return value;\n        }\n\n        currCtx = currCtx.parent;\n      }\n\n      throw new Error(\"Not declared variable \" + expr.name);\n    };\n\n    StatementInterpreter.prototype.visitWrappedNodeExpr = function (ast, ctx) {\n      throw new Error('Cannot interpret a WrappedNodeExpr.');\n    };\n\n    StatementInterpreter.prototype.visitTypeofExpr = function (ast, ctx) {\n      throw new Error('Cannot interpret a TypeofExpr');\n    };\n\n    StatementInterpreter.prototype.visitReadVarExpr = function (ast, ctx) {\n      var varName = ast.name;\n\n      if (ast.builtin != null) {\n        switch (ast.builtin) {\n          case o.BuiltinVar.Super:\n            return Object.getPrototypeOf(ctx.instance);\n\n          case o.BuiltinVar.This:\n            return ctx.instance;\n\n          case o.BuiltinVar.CatchError:\n            varName = CATCH_ERROR_VAR;\n            break;\n\n          case o.BuiltinVar.CatchStack:\n            varName = CATCH_STACK_VAR;\n            break;\n\n          default:\n            throw new Error(\"Unknown builtin variable \" + ast.builtin);\n        }\n      }\n\n      var currCtx = ctx;\n\n      while (currCtx != null) {\n        if (currCtx.vars.has(varName)) {\n          return currCtx.vars.get(varName);\n        }\n\n        currCtx = currCtx.parent;\n      }\n\n      throw new Error(\"Not declared variable \" + varName);\n    };\n\n    StatementInterpreter.prototype.visitWriteKeyExpr = function (expr, ctx) {\n      var receiver = expr.receiver.visitExpression(this, ctx);\n      var index = expr.index.visitExpression(this, ctx);\n      var value = expr.value.visitExpression(this, ctx);\n      receiver[index] = value;\n      return value;\n    };\n\n    StatementInterpreter.prototype.visitWritePropExpr = function (expr, ctx) {\n      var receiver = expr.receiver.visitExpression(this, ctx);\n      var value = expr.value.visitExpression(this, ctx);\n      receiver[expr.name] = value;\n      return value;\n    };\n\n    StatementInterpreter.prototype.visitInvokeMethodExpr = function (expr, ctx) {\n      var receiver = expr.receiver.visitExpression(this, ctx);\n      var args = this.visitAllExpressions(expr.args, ctx);\n      var result;\n\n      if (expr.builtin != null) {\n        switch (expr.builtin) {\n          case o.BuiltinMethod.ConcatArray:\n            result = receiver.concat.apply(receiver, tslib_1.__spread(args));\n            break;\n\n          case o.BuiltinMethod.SubscribeObservable:\n            result = receiver.subscribe({\n              next: args[0]\n            });\n            break;\n\n          case o.BuiltinMethod.Bind:\n            result = receiver.bind.apply(receiver, tslib_1.__spread(args));\n            break;\n\n          default:\n            throw new Error(\"Unknown builtin method \" + expr.builtin);\n        }\n      } else {\n        result = receiver[expr.name].apply(receiver, args);\n      }\n\n      return result;\n    };\n\n    StatementInterpreter.prototype.visitInvokeFunctionExpr = function (stmt, ctx) {\n      var args = this.visitAllExpressions(stmt.args, ctx);\n      var fnExpr = stmt.fn;\n\n      if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {\n        ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n        return null;\n      } else {\n        var fn = stmt.fn.visitExpression(this, ctx);\n        return fn.apply(null, args);\n      }\n    };\n\n    StatementInterpreter.prototype.visitTaggedTemplateExpr = function (expr, ctx) {\n      var templateElements = expr.template.elements.map(function (e) {\n        return e.text;\n      });\n      Object.defineProperty(templateElements, 'raw', {\n        value: expr.template.elements.map(function (e) {\n          return e.rawText;\n        })\n      });\n      var args = this.visitAllExpressions(expr.template.expressions, ctx);\n      args.unshift(templateElements);\n      var tag = expr.tag.visitExpression(this, ctx);\n      return tag.apply(null, args);\n    };\n\n    StatementInterpreter.prototype.visitReturnStmt = function (stmt, ctx) {\n      return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    };\n\n    StatementInterpreter.prototype.visitDeclareClassStmt = function (stmt, ctx) {\n      var clazz = createDynamicClass(stmt, ctx, this);\n      ctx.vars.set(stmt.name, clazz);\n\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        ctx.exports.push(stmt.name);\n      }\n\n      return null;\n    };\n\n    StatementInterpreter.prototype.visitExpressionStmt = function (stmt, ctx) {\n      return stmt.expr.visitExpression(this, ctx);\n    };\n\n    StatementInterpreter.prototype.visitIfStmt = function (stmt, ctx) {\n      var condition = stmt.condition.visitExpression(this, ctx);\n\n      if (condition) {\n        return this.visitAllStatements(stmt.trueCase, ctx);\n      } else if (stmt.falseCase != null) {\n        return this.visitAllStatements(stmt.falseCase, ctx);\n      }\n\n      return null;\n    };\n\n    StatementInterpreter.prototype.visitTryCatchStmt = function (stmt, ctx) {\n      try {\n        return this.visitAllStatements(stmt.bodyStmts, ctx);\n      } catch (e) {\n        var childCtx = ctx.createChildWihtLocalVars();\n        childCtx.vars.set(CATCH_ERROR_VAR, e);\n        childCtx.vars.set(CATCH_STACK_VAR, e.stack);\n        return this.visitAllStatements(stmt.catchStmts, childCtx);\n      }\n    };\n\n    StatementInterpreter.prototype.visitThrowStmt = function (stmt, ctx) {\n      throw stmt.error.visitExpression(this, ctx);\n    };\n\n    StatementInterpreter.prototype.visitInstantiateExpr = function (ast, ctx) {\n      var args = this.visitAllExpressions(ast.args, ctx);\n      var clazz = ast.classExpr.visitExpression(this, ctx);\n      return new (clazz.bind.apply(clazz, tslib_1.__spread([void 0], args)))();\n    };\n\n    StatementInterpreter.prototype.visitLiteralExpr = function (ast, ctx) {\n      return ast.value;\n    };\n\n    StatementInterpreter.prototype.visitLocalizedString = function (ast, context) {\n      return null;\n    };\n\n    StatementInterpreter.prototype.visitExternalExpr = function (ast, ctx) {\n      return this.reflector.resolveExternalReference(ast.value);\n    };\n\n    StatementInterpreter.prototype.visitConditionalExpr = function (ast, ctx) {\n      if (ast.condition.visitExpression(this, ctx)) {\n        return ast.trueCase.visitExpression(this, ctx);\n      } else if (ast.falseCase != null) {\n        return ast.falseCase.visitExpression(this, ctx);\n      }\n\n      return null;\n    };\n\n    StatementInterpreter.prototype.visitNotExpr = function (ast, ctx) {\n      return !ast.condition.visitExpression(this, ctx);\n    };\n\n    StatementInterpreter.prototype.visitAssertNotNullExpr = function (ast, ctx) {\n      return ast.condition.visitExpression(this, ctx);\n    };\n\n    StatementInterpreter.prototype.visitCastExpr = function (ast, ctx) {\n      return ast.value.visitExpression(this, ctx);\n    };\n\n    StatementInterpreter.prototype.visitFunctionExpr = function (ast, ctx) {\n      var paramNames = ast.params.map(function (param) {\n        return param.name;\n      });\n      return _declareFn(paramNames, ast.statements, ctx, this);\n    };\n\n    StatementInterpreter.prototype.visitDeclareFunctionStmt = function (stmt, ctx) {\n      var paramNames = stmt.params.map(function (param) {\n        return param.name;\n      });\n      ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n\n      if (stmt.hasModifier(o.StmtModifier.Exported)) {\n        ctx.exports.push(stmt.name);\n      }\n\n      return null;\n    };\n\n    StatementInterpreter.prototype.visitUnaryOperatorExpr = function (ast, ctx) {\n      var _this = this;\n\n      var rhs = function rhs() {\n        return ast.expr.visitExpression(_this, ctx);\n      };\n\n      switch (ast.operator) {\n        case o.UnaryOperator.Plus:\n          return +rhs();\n\n        case o.UnaryOperator.Minus:\n          return -rhs();\n\n        default:\n          throw new Error(\"Unknown operator \" + ast.operator);\n      }\n    };\n\n    StatementInterpreter.prototype.visitBinaryOperatorExpr = function (ast, ctx) {\n      var _this = this;\n\n      var lhs = function lhs() {\n        return ast.lhs.visitExpression(_this, ctx);\n      };\n\n      var rhs = function rhs() {\n        return ast.rhs.visitExpression(_this, ctx);\n      };\n\n      switch (ast.operator) {\n        case o.BinaryOperator.Equals:\n          return lhs() == rhs();\n\n        case o.BinaryOperator.Identical:\n          return lhs() === rhs();\n\n        case o.BinaryOperator.NotEquals:\n          return lhs() != rhs();\n\n        case o.BinaryOperator.NotIdentical:\n          return lhs() !== rhs();\n\n        case o.BinaryOperator.And:\n          return lhs() && rhs();\n\n        case o.BinaryOperator.Or:\n          return lhs() || rhs();\n\n        case o.BinaryOperator.Plus:\n          return lhs() + rhs();\n\n        case o.BinaryOperator.Minus:\n          return lhs() - rhs();\n\n        case o.BinaryOperator.Divide:\n          return lhs() / rhs();\n\n        case o.BinaryOperator.Multiply:\n          return lhs() * rhs();\n\n        case o.BinaryOperator.Modulo:\n          return lhs() % rhs();\n\n        case o.BinaryOperator.Lower:\n          return lhs() < rhs();\n\n        case o.BinaryOperator.LowerEquals:\n          return lhs() <= rhs();\n\n        case o.BinaryOperator.Bigger:\n          return lhs() > rhs();\n\n        case o.BinaryOperator.BiggerEquals:\n          return lhs() >= rhs();\n\n        default:\n          throw new Error(\"Unknown operator \" + ast.operator);\n      }\n    };\n\n    StatementInterpreter.prototype.visitReadPropExpr = function (ast, ctx) {\n      var result;\n      var receiver = ast.receiver.visitExpression(this, ctx);\n      result = receiver[ast.name];\n      return result;\n    };\n\n    StatementInterpreter.prototype.visitReadKeyExpr = function (ast, ctx) {\n      var receiver = ast.receiver.visitExpression(this, ctx);\n      var prop = ast.index.visitExpression(this, ctx);\n      return receiver[prop];\n    };\n\n    StatementInterpreter.prototype.visitLiteralArrayExpr = function (ast, ctx) {\n      return this.visitAllExpressions(ast.entries, ctx);\n    };\n\n    StatementInterpreter.prototype.visitLiteralMapExpr = function (ast, ctx) {\n      var _this = this;\n\n      var result = {};\n      ast.entries.forEach(function (entry) {\n        return result[entry.key] = entry.value.visitExpression(_this, ctx);\n      });\n      return result;\n    };\n\n    StatementInterpreter.prototype.visitCommaExpr = function (ast, context) {\n      var values = this.visitAllExpressions(ast.parts, context);\n      return values[values.length - 1];\n    };\n\n    StatementInterpreter.prototype.visitAllExpressions = function (expressions, ctx) {\n      var _this = this;\n\n      return expressions.map(function (expr) {\n        return expr.visitExpression(_this, ctx);\n      });\n    };\n\n    StatementInterpreter.prototype.visitAllStatements = function (statements, ctx) {\n      for (var i = 0; i < statements.length; i++) {\n        var stmt = statements[i];\n        var val = stmt.visitStatement(this, ctx);\n\n        if (val instanceof ReturnValue) {\n          return val;\n        }\n      }\n\n      return null;\n    };\n\n    return StatementInterpreter;\n  }();\n\n  function _declareFn(varNames, statements, ctx, visitor) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n    };\n  }\n\n  var CATCH_ERROR_VAR = 'error';\n  var CATCH_STACK_VAR = 'stack';\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/output/output_interpreter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {CompileReflector} from '../compile_reflector';\nimport * as o from './output_ast';\nimport {debugOutputAstAsTypeScript} from './ts_emitter';\n\nexport function interpretStatements(\n    statements: o.Statement[], reflector: CompileReflector): {[key: string]: any} {\n  const ctx = new _ExecutionContext(null, null, null, new Map<string, any>());\n  const visitor = new StatementInterpreter(reflector);\n  visitor.visitAllStatements(statements, ctx);\n  const result: {[key: string]: any} = {};\n  ctx.exports.forEach((exportName) => {\n    result[exportName] = ctx.vars.get(exportName);\n  });\n  return result;\n}\n\nfunction _executeFunctionStatements(\n    varNames: string[], varValues: any[], statements: o.Statement[], ctx: _ExecutionContext,\n    visitor: StatementInterpreter): any {\n  const childCtx = ctx.createChildWihtLocalVars();\n  for (let i = 0; i < varNames.length; i++) {\n    childCtx.vars.set(varNames[i], varValues[i]);\n  }\n  const result = visitor.visitAllStatements(statements, childCtx);\n  return result ? result.value : null;\n}\n\nclass _ExecutionContext {\n  exports: string[] = [];\n\n  constructor(\n      public parent: _ExecutionContext|null, public instance: Object|null,\n      public className: string|null, public vars: Map<string, any>) {}\n\n  createChildWihtLocalVars(): _ExecutionContext {\n    return new _ExecutionContext(this, this.instance, this.className, new Map<string, any>());\n  }\n}\n\nclass ReturnValue {\n  constructor(public value: any) {}\n}\n\nfunction createDynamicClass(\n    _classStmt: o.ClassStmt, _ctx: _ExecutionContext, _visitor: StatementInterpreter): Function {\n  const propertyDescriptors: {[key: string]: any} = {};\n\n  _classStmt.getters.forEach((getter: o.ClassGetter) => {\n    // Note: use `function` instead of arrow function to capture `this`\n    propertyDescriptors[getter.name] = {\n      configurable: false,\n      get: function() {\n        const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n      }\n    };\n  });\n  _classStmt.methods.forEach(function(method: o.ClassMethod) {\n    const paramNames = method.params.map(param => param.name);\n    // Note: use `function` instead of arrow function to capture `this`\n    propertyDescriptors[method.name!] = {\n      writable: false,\n      configurable: false,\n      value: function(...args: any[]) {\n        const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n      }\n    };\n  });\n\n  const ctorParamNames = _classStmt.constructorMethod.params.map(param => param.name);\n  // Note: use `function` instead of arrow function to capture `this`\n  const ctor = function(this: Object, ...args: any[]) {\n    const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n    _classStmt.fields.forEach((field) => {\n      (this as any)[field.name] = undefined;\n    });\n    _executeFunctionStatements(\n        ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n  };\n  const superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n  ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n  return ctor;\n}\n\nclass StatementInterpreter implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private reflector: CompileReflector) {}\n  debugAst(ast: o.Expression|o.Statement|o.Type): string {\n    return debugOutputAstAsTypeScript(ast);\n  }\n\n  visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: _ExecutionContext): any {\n    const initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;\n    ctx.vars.set(stmt.name, initialValue);\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      ctx.exports.push(stmt.name);\n    }\n    return null;\n  }\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: _ExecutionContext): any {\n    const value = expr.value.visitExpression(this, ctx);\n    let currCtx = ctx;\n    while (currCtx != null) {\n      if (currCtx.vars.has(expr.name)) {\n        currCtx.vars.set(expr.name, value);\n        return value;\n      }\n      currCtx = currCtx.parent!;\n    }\n    throw new Error(`Not declared variable ${expr.name}`);\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: _ExecutionContext): never {\n    throw new Error('Cannot interpret a WrappedNodeExpr.');\n  }\n  visitTypeofExpr(ast: o.TypeofExpr, ctx: _ExecutionContext): never {\n    throw new Error('Cannot interpret a TypeofExpr');\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: _ExecutionContext): any {\n    let varName = ast.name!;\n    if (ast.builtin != null) {\n      switch (ast.builtin) {\n        case o.BuiltinVar.Super:\n          return Object.getPrototypeOf(ctx.instance);\n        case o.BuiltinVar.This:\n          return ctx.instance;\n        case o.BuiltinVar.CatchError:\n          varName = CATCH_ERROR_VAR;\n          break;\n        case o.BuiltinVar.CatchStack:\n          varName = CATCH_STACK_VAR;\n          break;\n        default:\n          throw new Error(`Unknown builtin variable ${ast.builtin}`);\n      }\n    }\n    let currCtx = ctx;\n    while (currCtx != null) {\n      if (currCtx.vars.has(varName)) {\n        return currCtx.vars.get(varName);\n      }\n      currCtx = currCtx.parent!;\n    }\n    throw new Error(`Not declared variable ${varName}`);\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: _ExecutionContext): any {\n    const receiver = expr.receiver.visitExpression(this, ctx);\n    const index = expr.index.visitExpression(this, ctx);\n    const value = expr.value.visitExpression(this, ctx);\n    receiver[index] = value;\n    return value;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: _ExecutionContext): any {\n    const receiver = expr.receiver.visitExpression(this, ctx);\n    const value = expr.value.visitExpression(this, ctx);\n    receiver[expr.name] = value;\n    return value;\n  }\n\n  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: _ExecutionContext): any {\n    const receiver = expr.receiver.visitExpression(this, ctx);\n    const args = this.visitAllExpressions(expr.args, ctx);\n    let result: any;\n    if (expr.builtin != null) {\n      switch (expr.builtin) {\n        case o.BuiltinMethod.ConcatArray:\n          result = receiver.concat(...args);\n          break;\n        case o.BuiltinMethod.SubscribeObservable:\n          result = receiver.subscribe({next: args[0]});\n          break;\n        case o.BuiltinMethod.Bind:\n          result = receiver.bind(...args);\n          break;\n        default:\n          throw new Error(`Unknown builtin method ${expr.builtin}`);\n      }\n    } else {\n      result = receiver[expr.name!].apply(receiver, args);\n    }\n    return result;\n  }\n  visitInvokeFunctionExpr(stmt: o.InvokeFunctionExpr, ctx: _ExecutionContext): any {\n    const args = this.visitAllExpressions(stmt.args, ctx);\n    const fnExpr = stmt.fn;\n    if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {\n      ctx.instance!.constructor.prototype.constructor.apply(ctx.instance, args);\n      return null;\n    } else {\n      const fn = stmt.fn.visitExpression(this, ctx);\n      return fn.apply(null, args);\n    }\n  }\n  visitTaggedTemplateExpr(expr: o.TaggedTemplateExpr, ctx: _ExecutionContext): any {\n    const templateElements = expr.template.elements.map((e) => e.text);\n    Object.defineProperty(\n        templateElements, 'raw', {value: expr.template.elements.map((e) => e.rawText)});\n    const args = this.visitAllExpressions(expr.template.expressions, ctx);\n    args.unshift(templateElements);\n    const tag = expr.tag.visitExpression(this, ctx);\n    return tag.apply(null, args);\n  }\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: _ExecutionContext): any {\n    return new ReturnValue(stmt.value.visitExpression(this, ctx));\n  }\n  visitDeclareClassStmt(stmt: o.ClassStmt, ctx: _ExecutionContext): any {\n    const clazz = createDynamicClass(stmt, ctx, this);\n    ctx.vars.set(stmt.name, clazz);\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      ctx.exports.push(stmt.name);\n    }\n    return null;\n  }\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: _ExecutionContext): any {\n    return stmt.expr.visitExpression(this, ctx);\n  }\n  visitIfStmt(stmt: o.IfStmt, ctx: _ExecutionContext): any {\n    const condition = stmt.condition.visitExpression(this, ctx);\n    if (condition) {\n      return this.visitAllStatements(stmt.trueCase, ctx);\n    } else if (stmt.falseCase != null) {\n      return this.visitAllStatements(stmt.falseCase, ctx);\n    }\n    return null;\n  }\n  visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: _ExecutionContext): any {\n    try {\n      return this.visitAllStatements(stmt.bodyStmts, ctx);\n    } catch (e) {\n      const childCtx = ctx.createChildWihtLocalVars();\n      childCtx.vars.set(CATCH_ERROR_VAR, e);\n      childCtx.vars.set(CATCH_STACK_VAR, e.stack);\n      return this.visitAllStatements(stmt.catchStmts, childCtx);\n    }\n  }\n  visitThrowStmt(stmt: o.ThrowStmt, ctx: _ExecutionContext): any {\n    throw stmt.error.visitExpression(this, ctx);\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: _ExecutionContext): any {\n    const args = this.visitAllExpressions(ast.args, ctx);\n    const clazz = ast.classExpr.visitExpression(this, ctx);\n    return new clazz(...args);\n  }\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: _ExecutionContext): any {\n    return ast.value;\n  }\n  visitLocalizedString(ast: o.LocalizedString, context: any): any {\n    return null;\n  }\n  visitExternalExpr(ast: o.ExternalExpr, ctx: _ExecutionContext): any {\n    return this.reflector.resolveExternalReference(ast.value);\n  }\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: _ExecutionContext): any {\n    if (ast.condition.visitExpression(this, ctx)) {\n      return ast.trueCase.visitExpression(this, ctx);\n    } else if (ast.falseCase != null) {\n      return ast.falseCase.visitExpression(this, ctx);\n    }\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: _ExecutionContext): any {\n    return !ast.condition.visitExpression(this, ctx);\n  }\n  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: _ExecutionContext): any {\n    return ast.condition.visitExpression(this, ctx);\n  }\n  visitCastExpr(ast: o.CastExpr, ctx: _ExecutionContext): any {\n    return ast.value.visitExpression(this, ctx);\n  }\n  visitFunctionExpr(ast: o.FunctionExpr, ctx: _ExecutionContext): any {\n    const paramNames = ast.params.map((param) => param.name);\n    return _declareFn(paramNames, ast.statements, ctx, this);\n  }\n  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: _ExecutionContext): any {\n    const paramNames = stmt.params.map((param) => param.name);\n    ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      ctx.exports.push(stmt.name);\n    }\n    return null;\n  }\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, ctx: _ExecutionContext): any {\n    const rhs = () => ast.expr.visitExpression(this, ctx);\n\n    switch (ast.operator) {\n      case o.UnaryOperator.Plus:\n        return +rhs();\n      case o.UnaryOperator.Minus:\n        return -rhs();\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n  }\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: _ExecutionContext): any {\n    const lhs = () => ast.lhs.visitExpression(this, ctx);\n    const rhs = () => ast.rhs.visitExpression(this, ctx);\n\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        return lhs() == rhs();\n      case o.BinaryOperator.Identical:\n        return lhs() === rhs();\n      case o.BinaryOperator.NotEquals:\n        return lhs() != rhs();\n      case o.BinaryOperator.NotIdentical:\n        return lhs() !== rhs();\n      case o.BinaryOperator.And:\n        return lhs() && rhs();\n      case o.BinaryOperator.Or:\n        return lhs() || rhs();\n      case o.BinaryOperator.Plus:\n        return lhs() + rhs();\n      case o.BinaryOperator.Minus:\n        return lhs() - rhs();\n      case o.BinaryOperator.Divide:\n        return lhs() / rhs();\n      case o.BinaryOperator.Multiply:\n        return lhs() * rhs();\n      case o.BinaryOperator.Modulo:\n        return lhs() % rhs();\n      case o.BinaryOperator.Lower:\n        return lhs() < rhs();\n      case o.BinaryOperator.LowerEquals:\n        return lhs() <= rhs();\n      case o.BinaryOperator.Bigger:\n        return lhs() > rhs();\n      case o.BinaryOperator.BiggerEquals:\n        return lhs() >= rhs();\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n  }\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: _ExecutionContext): any {\n    let result: any;\n    const receiver = ast.receiver.visitExpression(this, ctx);\n    result = receiver[ast.name];\n    return result;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: _ExecutionContext): any {\n    const receiver = ast.receiver.visitExpression(this, ctx);\n    const prop = ast.index.visitExpression(this, ctx);\n    return receiver[prop];\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: _ExecutionContext): any {\n    return this.visitAllExpressions(ast.entries, ctx);\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: _ExecutionContext): any {\n    const result: {[k: string]: any} = {};\n    ast.entries.forEach(entry => result[entry.key] = entry.value.visitExpression(this, ctx));\n    return result;\n  }\n  visitCommaExpr(ast: o.CommaExpr, context: any): any {\n    const values = this.visitAllExpressions(ast.parts, context);\n    return values[values.length - 1];\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: _ExecutionContext): any {\n    return expressions.map((expr) => expr.visitExpression(this, ctx));\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: _ExecutionContext): ReturnValue|null {\n    for (let i = 0; i < statements.length; i++) {\n      const stmt = statements[i];\n      const val = stmt.visitStatement(this, ctx);\n      if (val instanceof ReturnValue) {\n        return val;\n      }\n    }\n    return null;\n  }\n}\n\nfunction _declareFn(\n    varNames: string[], statements: o.Statement[], ctx: _ExecutionContext,\n    visitor: StatementInterpreter): Function {\n  return (...args: any[]) => _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n}\n\nconst CATCH_ERROR_VAR = 'error';\nconst CATCH_STACK_VAR = 'stack';\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}