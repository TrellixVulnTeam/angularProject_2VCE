{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar ContextDependencyHelpers = exports;\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\n\nvar quotemeta = function quotemeta(str) {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nvar splitContextFromPrefix = function splitContextFromPrefix(prefix) {\n  var idx = prefix.lastIndexOf(\"/\");\n  var context = \".\";\n\n  if (idx >= 0) {\n    context = prefix.substr(0, idx);\n    prefix = \".\".concat(prefix.substr(idx));\n  }\n\n  return {\n    context: context,\n    prefix: prefix\n  };\n};\n\nvar splitQueryFromPostfix = function splitQueryFromPostfix(postfix) {\n  var idx = postfix.indexOf(\"?\");\n  var query = \"\";\n\n  if (idx >= 0) {\n    query = postfix.substr(idx);\n    postfix = postfix.substr(0, idx);\n  }\n\n  return {\n    postfix: postfix,\n    query: query\n  };\n};\n\nContextDependencyHelpers.create = function (Dep, range, param, expr, options, contextOptions) {\n  var parser = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n\n  if (param.isTemplateString()) {\n    var prefixRaw = param.quasis[0].string;\n    var postfixRaw = param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : \"\";\n    var valueRange = param.range;\n\n    var _splitContextFromPref = splitContextFromPrefix(prefixRaw),\n        context = _splitContextFromPref.context,\n        prefix = _splitContextFromPref.prefix;\n\n    var _splitQueryFromPostfi = splitQueryFromPostfix(postfixRaw),\n        postfix = _splitQueryFromPostfi.postfix,\n        query = _splitQueryFromPostfi.query; // When there are more than two quasis, the generated RegExp can be more precise\n    // We join the quasis with the expression regexp\n\n\n    var innerQuasis = param.quasis.slice(1, param.quasis.length - 1);\n    var innerRegExp = options.wrappedContextRegExp.source + innerQuasis.map(function (q) {\n      return quotemeta(q.string) + options.wrappedContextRegExp.source;\n    }).join(\"\"); // Example: `./context/pre${e}inner${e}inner2${e}post?query`\n    // context: \"./context\"\n    // prefix: \"./pre\"\n    // innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n    // (BEE = BasicEvaluatedExpression)\n    // postfix: \"post\"\n    // query: \"?query\"\n    // regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n\n    var regExp = new RegExp(\"^\".concat(quotemeta(prefix)).concat(innerRegExp).concat(quotemeta(postfix), \"$\"));\n    var dep = new Dep(Object.assign({\n      request: context + query,\n      recursive: options.wrappedContextRecursive,\n      regExp: regExp,\n      mode: \"sync\"\n    }, contextOptions), range, valueRange);\n    dep.loc = expr.loc;\n    var replaces = [];\n    param.parts.forEach(function (part, i) {\n      if (i % 2 === 0) {\n        // Quasis or merged quasi\n        var _range = part.range;\n        var value = part.string;\n\n        if (param.templateStringKind === \"cooked\") {\n          value = JSON.stringify(value);\n          value = value.slice(1, value.length - 1);\n        }\n\n        if (i === 0) {\n          // prefix\n          value = prefix;\n          _range = [param.range[0], part.range[1]];\n          value = (param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") + value;\n        } else if (i === param.parts.length - 1) {\n          // postfix\n          value = postfix;\n          _range = [part.range[0], param.range[1]];\n          value = value + \"`\";\n        } else if (part.expression && part.expression.type === \"TemplateElement\" && part.expression.value.raw === value) {\n          // Shortcut when it's a single quasi and doesn't need to be replaced\n          return;\n        }\n\n        replaces.push({\n          range: _range,\n          value: value\n        });\n      } else {\n        // Expression\n        if (parser) {\n          parser.walkExpression(part.expression);\n        }\n      }\n    });\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    return dep;\n  } else if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {\n    var _prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n\n    var _postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n\n    var prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;\n    var postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null;\n    var _valueRange = param.range;\n\n    var _splitContextFromPref2 = splitContextFromPrefix(_prefixRaw),\n        _context = _splitContextFromPref2.context,\n        _prefix = _splitContextFromPref2.prefix;\n\n    var _splitQueryFromPostfi2 = splitQueryFromPostfix(_postfixRaw),\n        _postfix = _splitQueryFromPostfi2.postfix,\n        _query = _splitQueryFromPostfi2.query;\n\n    var _regExp = new RegExp(\"^\".concat(quotemeta(_prefix)).concat(options.wrappedContextRegExp.source).concat(quotemeta(_postfix), \"$\"));\n\n    var _dep = new Dep(Object.assign({\n      request: _context + _query,\n      recursive: options.wrappedContextRecursive,\n      regExp: _regExp,\n      mode: \"sync\"\n    }, contextOptions), range, _valueRange);\n\n    _dep.loc = expr.loc;\n    var _replaces = [];\n\n    if (prefixRange) {\n      _replaces.push({\n        range: prefixRange,\n        value: JSON.stringify(_prefix)\n      });\n    }\n\n    if (postfixRange) {\n      _replaces.push({\n        range: postfixRange,\n        value: JSON.stringify(_postfix)\n      });\n    }\n\n    _dep.replaces = _replaces;\n    _dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n\n    if (parser && param.wrappedInnerExpressions) {\n      var _iterator = _createForOfIteratorHelper(param.wrappedInnerExpressions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var part = _step.value;\n          if (part.expression) parser.walkExpression(part.expression);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return _dep;\n  } else {\n    var _dep2 = new Dep(Object.assign({\n      request: options.exprContextRequest,\n      recursive: options.exprContextRecursive,\n      regExp: options.exprContextRegExp,\n      mode: \"sync\"\n    }, contextOptions), range, param.range);\n\n    _dep2.loc = expr.loc;\n    _dep2.critical = options.exprContextCritical && \"the request of a dependency is an expression\";\n\n    if (parser) {\n      parser.walkExpression(param.expression);\n    }\n\n    return _dep2;\n  }\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/dependencies/ContextDependencyHelpers.js"],"names":["ContextDependencyHelpers","exports","quotemeta","str","replace","splitContextFromPrefix","prefix","idx","lastIndexOf","context","substr","splitQueryFromPostfix","postfix","indexOf","query","create","Dep","range","param","expr","options","contextOptions","parser","isTemplateString","prefixRaw","quasis","string","postfixRaw","length","valueRange","innerQuasis","slice","innerRegExp","wrappedContextRegExp","source","map","q","join","regExp","RegExp","dep","Object","assign","request","recursive","wrappedContextRecursive","mode","loc","replaces","parts","forEach","part","i","value","templateStringKind","JSON","stringify","expression","type","raw","push","walkExpression","critical","wrappedContextCritical","isWrapped","isString","prefixRange","postfixRange","wrappedInnerExpressions","exprContextRequest","exprContextRecursive","exprContextRegExp","exprContextCritical"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;AAEA,IAAMA,wBAAwB,GAAGC,OAAjC;AAEA;AACA;AACA;AACA;AACA;;AACA,IAAMC,SAAS,GAAG,SAAZA,SAAY,CAAAC,GAAG,EAAI;AACxB,SAAOA,GAAG,CAACC,OAAJ,CAAY,uBAAZ,EAAqC,MAArC,CAAP;AACA,CAFD;;AAIA,IAAMC,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAAC,MAAM,EAAI;AACxC,MAAMC,GAAG,GAAGD,MAAM,CAACE,WAAP,CAAmB,GAAnB,CAAZ;AACA,MAAIC,OAAO,GAAG,GAAd;;AACA,MAAIF,GAAG,IAAI,CAAX,EAAc;AACbE,IAAAA,OAAO,GAAGH,MAAM,CAACI,MAAP,CAAc,CAAd,EAAiBH,GAAjB,CAAV;AACAD,IAAAA,MAAM,cAAOA,MAAM,CAACI,MAAP,CAAcH,GAAd,CAAP,CAAN;AACA;;AACD,SAAO;AACNE,IAAAA,OAAO,EAAPA,OADM;AAENH,IAAAA,MAAM,EAANA;AAFM,GAAP;AAIA,CAXD;;AAaA,IAAMK,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAAC,OAAO,EAAI;AACxC,MAAML,GAAG,GAAGK,OAAO,CAACC,OAAR,CAAgB,GAAhB,CAAZ;AACA,MAAIC,KAAK,GAAG,EAAZ;;AACA,MAAIP,GAAG,IAAI,CAAX,EAAc;AACbO,IAAAA,KAAK,GAAGF,OAAO,CAACF,MAAR,CAAeH,GAAf,CAAR;AACAK,IAAAA,OAAO,GAAGA,OAAO,CAACF,MAAR,CAAe,CAAf,EAAkBH,GAAlB,CAAV;AACA;;AACD,SAAO;AACNK,IAAAA,OAAO,EAAPA,OADM;AAENE,IAAAA,KAAK,EAALA;AAFM,GAAP;AAIA,CAXD;;AAaAd,wBAAwB,CAACe,MAAzB,GAAkC,UACjCC,GADiC,EAEjCC,KAFiC,EAGjCC,KAHiC,EAIjCC,IAJiC,EAKjCC,OALiC,EAMjCC,cANiC,EAS7B;AAAA,MADJC,MACI,uEADK,IACL;;AACJ,MAAIJ,KAAK,CAACK,gBAAN,EAAJ,EAA8B;AAC7B,QAAIC,SAAS,GAAGN,KAAK,CAACO,MAAN,CAAa,CAAb,EAAgBC,MAAhC;AACA,QAAIC,UAAU,GACbT,KAAK,CAACO,MAAN,CAAaG,MAAb,GAAsB,CAAtB,GACGV,KAAK,CAACO,MAAN,CAAaP,KAAK,CAACO,MAAN,CAAaG,MAAb,GAAsB,CAAnC,EAAsCF,MADzC,GAEG,EAHJ;AAKA,QAAMG,UAAU,GAAGX,KAAK,CAACD,KAAzB;;AACA,gCAA4BZ,sBAAsB,CAACmB,SAAD,CAAlD;AAAA,QAAQf,OAAR,yBAAQA,OAAR;AAAA,QAAiBH,MAAjB,yBAAiBA,MAAjB;;AACA,gCAA2BK,qBAAqB,CAACgB,UAAD,CAAhD;AAAA,QAAQf,OAAR,yBAAQA,OAAR;AAAA,QAAiBE,KAAjB,yBAAiBA,KAAjB,CAT6B,CAW7B;AACA;;;AACA,QAAMgB,WAAW,GAAGZ,KAAK,CAACO,MAAN,CAAaM,KAAb,CAAmB,CAAnB,EAAsBb,KAAK,CAACO,MAAN,CAAaG,MAAb,GAAsB,CAA5C,CAApB;AACA,QAAMI,WAAW,GAChBZ,OAAO,CAACa,oBAAR,CAA6BC,MAA7B,GACAJ,WAAW,CACTK,GADF,CACM,UAAAC,CAAC;AAAA,aAAIlC,SAAS,CAACkC,CAAC,CAACV,MAAH,CAAT,GAAsBN,OAAO,CAACa,oBAAR,CAA6BC,MAAvD;AAAA,KADP,EAEEG,IAFF,CAEO,EAFP,CAFD,CAd6B,CAoB7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMC,MAAM,GAAG,IAAIC,MAAJ,YACVrC,SAAS,CAACI,MAAD,CADC,SACU0B,WADV,SACwB9B,SAAS,CAACU,OAAD,CADjC,OAAf;AAGA,QAAM4B,GAAG,GAAG,IAAIxB,GAAJ,CACXyB,MAAM,CAACC,MAAP,CACC;AACCC,MAAAA,OAAO,EAAElC,OAAO,GAAGK,KADpB;AAEC8B,MAAAA,SAAS,EAAExB,OAAO,CAACyB,uBAFpB;AAGCP,MAAAA,MAAM,EAANA,MAHD;AAICQ,MAAAA,IAAI,EAAE;AAJP,KADD,EAOCzB,cAPD,CADW,EAUXJ,KAVW,EAWXY,UAXW,CAAZ;AAaAW,IAAAA,GAAG,CAACO,GAAJ,GAAU5B,IAAI,CAAC4B,GAAf;AACA,QAAMC,QAAQ,GAAG,EAAjB;AAEA9B,IAAAA,KAAK,CAAC+B,KAAN,CAAYC,OAAZ,CAAoB,UAACC,IAAD,EAAOC,CAAP,EAAa;AAChC,UAAIA,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB;AAChB;AACA,YAAInC,MAAK,GAAGkC,IAAI,CAAClC,KAAjB;AACA,YAAIoC,KAAK,GAAGF,IAAI,CAACzB,MAAjB;;AACA,YAAIR,KAAK,CAACoC,kBAAN,KAA6B,QAAjC,EAA2C;AAC1CD,UAAAA,KAAK,GAAGE,IAAI,CAACC,SAAL,CAAeH,KAAf,CAAR;AACAA,UAAAA,KAAK,GAAGA,KAAK,CAACtB,KAAN,CAAY,CAAZ,EAAesB,KAAK,CAACzB,MAAN,GAAe,CAA9B,CAAR;AACA;;AACD,YAAIwB,CAAC,KAAK,CAAV,EAAa;AACZ;AACAC,UAAAA,KAAK,GAAG/C,MAAR;AACAW,UAAAA,MAAK,GAAG,CAACC,KAAK,CAACD,KAAN,CAAY,CAAZ,CAAD,EAAiBkC,IAAI,CAAClC,KAAL,CAAW,CAAX,CAAjB,CAAR;AACAoC,UAAAA,KAAK,GACJ,CAACnC,KAAK,CAACoC,kBAAN,KAA6B,QAA7B,GAAwC,GAAxC,GAA8C,aAA/C,IACAD,KAFD;AAGA,SAPD,MAOO,IAAID,CAAC,KAAKlC,KAAK,CAAC+B,KAAN,CAAYrB,MAAZ,GAAqB,CAA/B,EAAkC;AACxC;AACAyB,UAAAA,KAAK,GAAGzC,OAAR;AACAK,UAAAA,MAAK,GAAG,CAACkC,IAAI,CAAClC,KAAL,CAAW,CAAX,CAAD,EAAgBC,KAAK,CAACD,KAAN,CAAY,CAAZ,CAAhB,CAAR;AACAoC,UAAAA,KAAK,GAAGA,KAAK,GAAG,GAAhB;AACA,SALM,MAKA,IACNF,IAAI,CAACM,UAAL,IACAN,IAAI,CAACM,UAAL,CAAgBC,IAAhB,KAAyB,iBADzB,IAEAP,IAAI,CAACM,UAAL,CAAgBJ,KAAhB,CAAsBM,GAAtB,KAA8BN,KAHxB,EAIL;AACD;AACA;AACA;;AACDL,QAAAA,QAAQ,CAACY,IAAT,CAAc;AACb3C,UAAAA,KAAK,EAALA,MADa;AAEboC,UAAAA,KAAK,EAALA;AAFa,SAAd;AAIA,OAhCD,MAgCO;AACN;AACA,YAAI/B,MAAJ,EAAY;AACXA,UAAAA,MAAM,CAACuC,cAAP,CAAsBV,IAAI,CAACM,UAA3B;AACA;AACD;AACD,KAvCD;AAyCAjB,IAAAA,GAAG,CAACQ,QAAJ,GAAeA,QAAf;AACAR,IAAAA,GAAG,CAACsB,QAAJ,GACC1C,OAAO,CAAC2C,sBAAR,IACA,wDAFD;AAGA,WAAOvB,GAAP;AACA,GA7FD,MA6FO,IACNtB,KAAK,CAAC8C,SAAN,OACE9C,KAAK,CAACZ,MAAN,IAAgBY,KAAK,CAACZ,MAAN,CAAa2D,QAAb,EAAjB,IACC/C,KAAK,CAACN,OAAN,IAAiBM,KAAK,CAACN,OAAN,CAAcqD,QAAd,EAFnB,CADM,EAIL;AACD,QAAIzC,UAAS,GACZN,KAAK,CAACZ,MAAN,IAAgBY,KAAK,CAACZ,MAAN,CAAa2D,QAAb,EAAhB,GAA0C/C,KAAK,CAACZ,MAAN,CAAaoB,MAAvD,GAAgE,EADjE;;AAEA,QAAIC,WAAU,GACbT,KAAK,CAACN,OAAN,IAAiBM,KAAK,CAACN,OAAN,CAAcqD,QAAd,EAAjB,GAA4C/C,KAAK,CAACN,OAAN,CAAcc,MAA1D,GAAmE,EADpE;;AAEA,QAAMwC,WAAW,GAChBhD,KAAK,CAACZ,MAAN,IAAgBY,KAAK,CAACZ,MAAN,CAAa2D,QAAb,EAAhB,GAA0C/C,KAAK,CAACZ,MAAN,CAAaW,KAAvD,GAA+D,IADhE;AAEA,QAAMkD,YAAY,GACjBjD,KAAK,CAACN,OAAN,IAAiBM,KAAK,CAACN,OAAN,CAAcqD,QAAd,EAAjB,GAA4C/C,KAAK,CAACN,OAAN,CAAcK,KAA1D,GAAkE,IADnE;AAEA,QAAMY,WAAU,GAAGX,KAAK,CAACD,KAAzB;;AACA,iCAA4BZ,sBAAsB,CAACmB,UAAD,CAAlD;AAAA,QAAQf,QAAR,0BAAQA,OAAR;AAAA,QAAiBH,OAAjB,0BAAiBA,MAAjB;;AACA,iCAA2BK,qBAAqB,CAACgB,WAAD,CAAhD;AAAA,QAAQf,QAAR,0BAAQA,OAAR;AAAA,QAAiBE,MAAjB,0BAAiBA,KAAjB;;AACA,QAAMwB,OAAM,GAAG,IAAIC,MAAJ,YACVrC,SAAS,CAACI,OAAD,CADC,SACUc,OAAO,CAACa,oBAAR,CAA6BC,MADvC,SACgDhC,SAAS,CACtEU,QADsE,CADzD,OAAf;;AAKA,QAAM4B,IAAG,GAAG,IAAIxB,GAAJ,CACXyB,MAAM,CAACC,MAAP,CACC;AACCC,MAAAA,OAAO,EAAElC,QAAO,GAAGK,MADpB;AAEC8B,MAAAA,SAAS,EAAExB,OAAO,CAACyB,uBAFpB;AAGCP,MAAAA,MAAM,EAANA,OAHD;AAICQ,MAAAA,IAAI,EAAE;AAJP,KADD,EAOCzB,cAPD,CADW,EAUXJ,KAVW,EAWXY,WAXW,CAAZ;;AAaAW,IAAAA,IAAG,CAACO,GAAJ,GAAU5B,IAAI,CAAC4B,GAAf;AACA,QAAMC,SAAQ,GAAG,EAAjB;;AACA,QAAIkB,WAAJ,EAAiB;AAChBlB,MAAAA,SAAQ,CAACY,IAAT,CAAc;AACb3C,QAAAA,KAAK,EAAEiD,WADM;AAEbb,QAAAA,KAAK,EAAEE,IAAI,CAACC,SAAL,CAAelD,OAAf;AAFM,OAAd;AAIA;;AACD,QAAI6D,YAAJ,EAAkB;AACjBnB,MAAAA,SAAQ,CAACY,IAAT,CAAc;AACb3C,QAAAA,KAAK,EAAEkD,YADM;AAEbd,QAAAA,KAAK,EAAEE,IAAI,CAACC,SAAL,CAAe5C,QAAf;AAFM,OAAd;AAIA;;AACD4B,IAAAA,IAAG,CAACQ,QAAJ,GAAeA,SAAf;AACAR,IAAAA,IAAG,CAACsB,QAAJ,GACC1C,OAAO,CAAC2C,sBAAR,IACA,wDAFD;;AAIA,QAAIzC,MAAM,IAAIJ,KAAK,CAACkD,uBAApB,EAA6C;AAAA,iDACzBlD,KAAK,CAACkD,uBADmB;AAAA;;AAAA;AAC5C,4DAAkD;AAAA,cAAvCjB,IAAuC;AACjD,cAAIA,IAAI,CAACM,UAAT,EAAqBnC,MAAM,CAACuC,cAAP,CAAsBV,IAAI,CAACM,UAA3B;AACrB;AAH2C;AAAA;AAAA;AAAA;AAAA;AAI5C;;AAED,WAAOjB,IAAP;AACA,GA5DM,MA4DA;AACN,QAAMA,KAAG,GAAG,IAAIxB,GAAJ,CACXyB,MAAM,CAACC,MAAP,CACC;AACCC,MAAAA,OAAO,EAAEvB,OAAO,CAACiD,kBADlB;AAECzB,MAAAA,SAAS,EAAExB,OAAO,CAACkD,oBAFpB;AAGChC,MAAAA,MAAM,EAAElB,OAAO,CAACmD,iBAHjB;AAICzB,MAAAA,IAAI,EAAE;AAJP,KADD,EAOCzB,cAPD,CADW,EAUXJ,KAVW,EAWXC,KAAK,CAACD,KAXK,CAAZ;;AAaAuB,IAAAA,KAAG,CAACO,GAAJ,GAAU5B,IAAI,CAAC4B,GAAf;AACAP,IAAAA,KAAG,CAACsB,QAAJ,GACC1C,OAAO,CAACoD,mBAAR,IACA,8CAFD;;AAIA,QAAIlD,MAAJ,EAAY;AACXA,MAAAA,MAAM,CAACuC,cAAP,CAAsB3C,KAAK,CAACuC,UAA5B;AACA;;AAED,WAAOjB,KAAP;AACA;AACD,CA5LD","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ContextDependencyHelpers = exports;\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quotemeta = str => {\n\treturn str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\n\nconst splitContextFromPrefix = prefix => {\n\tconst idx = prefix.lastIndexOf(\"/\");\n\tlet context = \".\";\n\tif (idx >= 0) {\n\t\tcontext = prefix.substr(0, idx);\n\t\tprefix = `.${prefix.substr(idx)}`;\n\t}\n\treturn {\n\t\tcontext,\n\t\tprefix\n\t};\n};\n\nconst splitQueryFromPostfix = postfix => {\n\tconst idx = postfix.indexOf(\"?\");\n\tlet query = \"\";\n\tif (idx >= 0) {\n\t\tquery = postfix.substr(idx);\n\t\tpostfix = postfix.substr(0, idx);\n\t}\n\treturn {\n\t\tpostfix,\n\t\tquery\n\t};\n};\n\nContextDependencyHelpers.create = (\n\tDep,\n\trange,\n\tparam,\n\texpr,\n\toptions,\n\tcontextOptions,\n\t// when parser is not passed in, expressions won't be walked\n\tparser = null\n) => {\n\tif (param.isTemplateString()) {\n\t\tlet prefixRaw = param.quasis[0].string;\n\t\tlet postfixRaw =\n\t\t\tparam.quasis.length > 1\n\t\t\t\t? param.quasis[param.quasis.length - 1].string\n\t\t\t\t: \"\";\n\n\t\tconst valueRange = param.range;\n\t\tconst { context, prefix } = splitContextFromPrefix(prefixRaw);\n\t\tconst { postfix, query } = splitQueryFromPostfix(postfixRaw);\n\n\t\t// When there are more than two quasis, the generated RegExp can be more precise\n\t\t// We join the quasis with the expression regexp\n\t\tconst innerQuasis = param.quasis.slice(1, param.quasis.length - 1);\n\t\tconst innerRegExp =\n\t\t\toptions.wrappedContextRegExp.source +\n\t\t\tinnerQuasis\n\t\t\t\t.map(q => quotemeta(q.string) + options.wrappedContextRegExp.source)\n\t\t\t\t.join(\"\");\n\n\t\t// Example: `./context/pre${e}inner${e}inner2${e}post?query`\n\t\t// context: \"./context\"\n\t\t// prefix: \"./pre\"\n\t\t// innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n\t\t// (BEE = BasicEvaluatedExpression)\n\t\t// postfix: \"post\"\n\t\t// query: \"?query\"\n\t\t// regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n\t\tconst regExp = new RegExp(\n\t\t\t`^${quotemeta(prefix)}${innerRegExp}${quotemeta(postfix)}$`\n\t\t);\n\t\tconst dep = new Dep(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\trequest: context + query,\n\t\t\t\t\trecursive: options.wrappedContextRecursive,\n\t\t\t\t\tregExp,\n\t\t\t\t\tmode: \"sync\"\n\t\t\t\t},\n\t\t\t\tcontextOptions\n\t\t\t),\n\t\t\trange,\n\t\t\tvalueRange\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tconst replaces = [];\n\n\t\tparam.parts.forEach((part, i) => {\n\t\t\tif (i % 2 === 0) {\n\t\t\t\t// Quasis or merged quasi\n\t\t\t\tlet range = part.range;\n\t\t\t\tlet value = part.string;\n\t\t\t\tif (param.templateStringKind === \"cooked\") {\n\t\t\t\t\tvalue = JSON.stringify(value);\n\t\t\t\t\tvalue = value.slice(1, value.length - 1);\n\t\t\t\t}\n\t\t\t\tif (i === 0) {\n\t\t\t\t\t// prefix\n\t\t\t\t\tvalue = prefix;\n\t\t\t\t\trange = [param.range[0], part.range[1]];\n\t\t\t\t\tvalue =\n\t\t\t\t\t\t(param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") +\n\t\t\t\t\t\tvalue;\n\t\t\t\t} else if (i === param.parts.length - 1) {\n\t\t\t\t\t// postfix\n\t\t\t\t\tvalue = postfix;\n\t\t\t\t\trange = [part.range[0], param.range[1]];\n\t\t\t\t\tvalue = value + \"`\";\n\t\t\t\t} else if (\n\t\t\t\t\tpart.expression &&\n\t\t\t\t\tpart.expression.type === \"TemplateElement\" &&\n\t\t\t\t\tpart.expression.value.raw === value\n\t\t\t\t) {\n\t\t\t\t\t// Shortcut when it's a single quasi and doesn't need to be replaced\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treplaces.push({\n\t\t\t\t\trange,\n\t\t\t\t\tvalue\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Expression\n\t\t\t\tif (parser) {\n\t\t\t\t\tparser.walkExpression(part.expression);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tdep.replaces = replaces;\n\t\tdep.critical =\n\t\t\toptions.wrappedContextCritical &&\n\t\t\t\"a part of the request of a dependency is an expression\";\n\t\treturn dep;\n\t} else if (\n\t\tparam.isWrapped() &&\n\t\t((param.prefix && param.prefix.isString()) ||\n\t\t\t(param.postfix && param.postfix.isString()))\n\t) {\n\t\tlet prefixRaw =\n\t\t\tparam.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n\t\tlet postfixRaw =\n\t\t\tparam.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n\t\tconst prefixRange =\n\t\t\tparam.prefix && param.prefix.isString() ? param.prefix.range : null;\n\t\tconst postfixRange =\n\t\t\tparam.postfix && param.postfix.isString() ? param.postfix.range : null;\n\t\tconst valueRange = param.range;\n\t\tconst { context, prefix } = splitContextFromPrefix(prefixRaw);\n\t\tconst { postfix, query } = splitQueryFromPostfix(postfixRaw);\n\t\tconst regExp = new RegExp(\n\t\t\t`^${quotemeta(prefix)}${options.wrappedContextRegExp.source}${quotemeta(\n\t\t\t\tpostfix\n\t\t\t)}$`\n\t\t);\n\t\tconst dep = new Dep(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\trequest: context + query,\n\t\t\t\t\trecursive: options.wrappedContextRecursive,\n\t\t\t\t\tregExp,\n\t\t\t\t\tmode: \"sync\"\n\t\t\t\t},\n\t\t\t\tcontextOptions\n\t\t\t),\n\t\t\trange,\n\t\t\tvalueRange\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tconst replaces = [];\n\t\tif (prefixRange) {\n\t\t\treplaces.push({\n\t\t\t\trange: prefixRange,\n\t\t\t\tvalue: JSON.stringify(prefix)\n\t\t\t});\n\t\t}\n\t\tif (postfixRange) {\n\t\t\treplaces.push({\n\t\t\t\trange: postfixRange,\n\t\t\t\tvalue: JSON.stringify(postfix)\n\t\t\t});\n\t\t}\n\t\tdep.replaces = replaces;\n\t\tdep.critical =\n\t\t\toptions.wrappedContextCritical &&\n\t\t\t\"a part of the request of a dependency is an expression\";\n\n\t\tif (parser && param.wrappedInnerExpressions) {\n\t\t\tfor (const part of param.wrappedInnerExpressions) {\n\t\t\t\tif (part.expression) parser.walkExpression(part.expression);\n\t\t\t}\n\t\t}\n\n\t\treturn dep;\n\t} else {\n\t\tconst dep = new Dep(\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\trequest: options.exprContextRequest,\n\t\t\t\t\trecursive: options.exprContextRecursive,\n\t\t\t\t\tregExp: options.exprContextRegExp,\n\t\t\t\t\tmode: \"sync\"\n\t\t\t\t},\n\t\t\t\tcontextOptions\n\t\t\t),\n\t\t\trange,\n\t\t\tparam.range\n\t\t);\n\t\tdep.loc = expr.loc;\n\t\tdep.critical =\n\t\t\toptions.exprContextCritical &&\n\t\t\t\"the request of a dependency is an expression\";\n\n\t\tif (parser) {\n\t\t\tparser.walkExpression(param.expression);\n\t\t}\n\n\t\treturn dep;\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}