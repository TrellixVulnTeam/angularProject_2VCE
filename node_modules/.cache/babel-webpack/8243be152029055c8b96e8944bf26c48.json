{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/template_parser/template_ast\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  var _a;\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.templateVisitAll = exports.RecursiveTemplateAstVisitor = exports.NullTemplateVisitor = exports.NgContentAst = exports.ProviderAstType = exports.ProviderAst = exports.DirectiveAst = exports.BoundDirectivePropertyAst = exports.EmbeddedTemplateAst = exports.ElementAst = exports.VariableAst = exports.ReferenceAst = exports.BoundEventAst = exports.BoundElementPropertyAst = exports.AttrAst = exports.BoundTextAst = exports.TextAst = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * A segment of text within the template.\n   */\n\n\n  var TextAst =\n  /** @class */\n  function () {\n    function TextAst(value, ngContentIndex, sourceSpan) {\n      this.value = value;\n      this.ngContentIndex = ngContentIndex;\n      this.sourceSpan = sourceSpan;\n    }\n\n    TextAst.prototype.visit = function (visitor, context) {\n      return visitor.visitText(this, context);\n    };\n\n    return TextAst;\n  }();\n\n  exports.TextAst = TextAst;\n  /**\n   * A bound expression within the text of a template.\n   */\n\n  var BoundTextAst =\n  /** @class */\n  function () {\n    function BoundTextAst(value, ngContentIndex, sourceSpan) {\n      this.value = value;\n      this.ngContentIndex = ngContentIndex;\n      this.sourceSpan = sourceSpan;\n    }\n\n    BoundTextAst.prototype.visit = function (visitor, context) {\n      return visitor.visitBoundText(this, context);\n    };\n\n    return BoundTextAst;\n  }();\n\n  exports.BoundTextAst = BoundTextAst;\n  /**\n   * A plain attribute on an element.\n   */\n\n  var AttrAst =\n  /** @class */\n  function () {\n    function AttrAst(name, value, sourceSpan) {\n      this.name = name;\n      this.value = value;\n      this.sourceSpan = sourceSpan;\n    }\n\n    AttrAst.prototype.visit = function (visitor, context) {\n      return visitor.visitAttr(this, context);\n    };\n\n    return AttrAst;\n  }();\n\n  exports.AttrAst = AttrAst;\n  var BoundPropertyMapping = (_a = {}, _a[4\n  /* Animation */\n  ] = 4\n  /* Animation */\n  , _a[1\n  /* Attribute */\n  ] = 1\n  /* Attribute */\n  , _a[2\n  /* Class */\n  ] = 2\n  /* Class */\n  , _a[0\n  /* Property */\n  ] = 0\n  /* Property */\n  , _a[3\n  /* Style */\n  ] = 3\n  /* Style */\n  , _a);\n  /**\n   * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n   * `[@trigger]=\"stateExp\"`)\n   */\n\n  var BoundElementPropertyAst =\n  /** @class */\n  function () {\n    function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n      this.name = name;\n      this.type = type;\n      this.securityContext = securityContext;\n      this.value = value;\n      this.unit = unit;\n      this.sourceSpan = sourceSpan;\n      this.isAnimation = this.type === 4\n      /* Animation */\n      ;\n    }\n\n    BoundElementPropertyAst.fromBoundProperty = function (prop) {\n      var type = BoundPropertyMapping[prop.type];\n      return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\n    };\n\n    BoundElementPropertyAst.prototype.visit = function (visitor, context) {\n      return visitor.visitElementProperty(this, context);\n    };\n\n    return BoundElementPropertyAst;\n  }();\n\n  exports.BoundElementPropertyAst = BoundElementPropertyAst;\n  /**\n   * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n   * `(@trigger.phase)=\"callback($event)\"`).\n   */\n\n  var BoundEventAst =\n  /** @class */\n  function () {\n    function BoundEventAst(name, target, phase, handler, sourceSpan, handlerSpan) {\n      this.name = name;\n      this.target = target;\n      this.phase = phase;\n      this.handler = handler;\n      this.sourceSpan = sourceSpan;\n      this.handlerSpan = handlerSpan;\n      this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n      this.isAnimation = !!this.phase;\n    }\n\n    BoundEventAst.calcFullName = function (name, target, phase) {\n      if (target) {\n        return target + \":\" + name;\n      }\n\n      if (phase) {\n        return \"@\" + name + \".\" + phase;\n      }\n\n      return name;\n    };\n\n    BoundEventAst.fromParsedEvent = function (event) {\n      var target = event.type === 0\n      /* Regular */\n      ? event.targetOrPhase : null;\n      var phase = event.type === 1\n      /* Animation */\n      ? event.targetOrPhase : null;\n      return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\n    };\n\n    BoundEventAst.prototype.visit = function (visitor, context) {\n      return visitor.visitEvent(this, context);\n    };\n\n    return BoundEventAst;\n  }();\n\n  exports.BoundEventAst = BoundEventAst;\n  /**\n   * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n   */\n\n  var ReferenceAst =\n  /** @class */\n  function () {\n    function ReferenceAst(name, value, originalValue, sourceSpan) {\n      this.name = name;\n      this.value = value;\n      this.originalValue = originalValue;\n      this.sourceSpan = sourceSpan;\n    }\n\n    ReferenceAst.prototype.visit = function (visitor, context) {\n      return visitor.visitReference(this, context);\n    };\n\n    return ReferenceAst;\n  }();\n\n  exports.ReferenceAst = ReferenceAst;\n  /**\n   * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n   */\n\n  var VariableAst =\n  /** @class */\n  function () {\n    function VariableAst(name, value, sourceSpan, valueSpan) {\n      this.name = name;\n      this.value = value;\n      this.sourceSpan = sourceSpan;\n      this.valueSpan = valueSpan;\n    }\n\n    VariableAst.fromParsedVariable = function (v) {\n      return new VariableAst(v.name, v.value, v.sourceSpan, v.valueSpan);\n    };\n\n    VariableAst.prototype.visit = function (visitor, context) {\n      return visitor.visitVariable(this, context);\n    };\n\n    return VariableAst;\n  }();\n\n  exports.VariableAst = VariableAst;\n  /**\n   * An element declaration in a template.\n   */\n\n  var ElementAst =\n  /** @class */\n  function () {\n    function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n      this.name = name;\n      this.attrs = attrs;\n      this.inputs = inputs;\n      this.outputs = outputs;\n      this.references = references;\n      this.directives = directives;\n      this.providers = providers;\n      this.hasViewContainer = hasViewContainer;\n      this.queryMatches = queryMatches;\n      this.children = children;\n      this.ngContentIndex = ngContentIndex;\n      this.sourceSpan = sourceSpan;\n      this.endSourceSpan = endSourceSpan;\n    }\n\n    ElementAst.prototype.visit = function (visitor, context) {\n      return visitor.visitElement(this, context);\n    };\n\n    return ElementAst;\n  }();\n\n  exports.ElementAst = ElementAst;\n  /**\n   * A `<ng-template>` element included in an Angular template.\n   */\n\n  var EmbeddedTemplateAst =\n  /** @class */\n  function () {\n    function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n      this.attrs = attrs;\n      this.outputs = outputs;\n      this.references = references;\n      this.variables = variables;\n      this.directives = directives;\n      this.providers = providers;\n      this.hasViewContainer = hasViewContainer;\n      this.queryMatches = queryMatches;\n      this.children = children;\n      this.ngContentIndex = ngContentIndex;\n      this.sourceSpan = sourceSpan;\n    }\n\n    EmbeddedTemplateAst.prototype.visit = function (visitor, context) {\n      return visitor.visitEmbeddedTemplate(this, context);\n    };\n\n    return EmbeddedTemplateAst;\n  }();\n\n  exports.EmbeddedTemplateAst = EmbeddedTemplateAst;\n  /**\n   * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n   */\n\n  var BoundDirectivePropertyAst =\n  /** @class */\n  function () {\n    function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n      this.directiveName = directiveName;\n      this.templateName = templateName;\n      this.value = value;\n      this.sourceSpan = sourceSpan;\n    }\n\n    BoundDirectivePropertyAst.prototype.visit = function (visitor, context) {\n      return visitor.visitDirectiveProperty(this, context);\n    };\n\n    return BoundDirectivePropertyAst;\n  }();\n\n  exports.BoundDirectivePropertyAst = BoundDirectivePropertyAst;\n  /**\n   * A directive declared on an element.\n   */\n\n  var DirectiveAst =\n  /** @class */\n  function () {\n    function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n      this.directive = directive;\n      this.inputs = inputs;\n      this.hostProperties = hostProperties;\n      this.hostEvents = hostEvents;\n      this.contentQueryStartId = contentQueryStartId;\n      this.sourceSpan = sourceSpan;\n    }\n\n    DirectiveAst.prototype.visit = function (visitor, context) {\n      return visitor.visitDirective(this, context);\n    };\n\n    return DirectiveAst;\n  }();\n\n  exports.DirectiveAst = DirectiveAst;\n  /**\n   * A provider declared on an element\n   */\n\n  var ProviderAst =\n  /** @class */\n  function () {\n    function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {\n      this.token = token;\n      this.multiProvider = multiProvider;\n      this.eager = eager;\n      this.providers = providers;\n      this.providerType = providerType;\n      this.lifecycleHooks = lifecycleHooks;\n      this.sourceSpan = sourceSpan;\n      this.isModule = isModule;\n    }\n\n    ProviderAst.prototype.visit = function (visitor, context) {\n      // No visit method in the visitor for now...\n      return null;\n    };\n\n    return ProviderAst;\n  }();\n\n  exports.ProviderAst = ProviderAst;\n  var ProviderAstType;\n\n  (function (ProviderAstType) {\n    ProviderAstType[ProviderAstType[\"PublicService\"] = 0] = \"PublicService\";\n    ProviderAstType[ProviderAstType[\"PrivateService\"] = 1] = \"PrivateService\";\n    ProviderAstType[ProviderAstType[\"Component\"] = 2] = \"Component\";\n    ProviderAstType[ProviderAstType[\"Directive\"] = 3] = \"Directive\";\n    ProviderAstType[ProviderAstType[\"Builtin\"] = 4] = \"Builtin\";\n  })(ProviderAstType = exports.ProviderAstType || (exports.ProviderAstType = {}));\n  /**\n   * Position where content is to be projected (instance of `<ng-content>` in a template).\n   */\n\n\n  var NgContentAst =\n  /** @class */\n  function () {\n    function NgContentAst(index, ngContentIndex, sourceSpan) {\n      this.index = index;\n      this.ngContentIndex = ngContentIndex;\n      this.sourceSpan = sourceSpan;\n    }\n\n    NgContentAst.prototype.visit = function (visitor, context) {\n      return visitor.visitNgContent(this, context);\n    };\n\n    return NgContentAst;\n  }();\n\n  exports.NgContentAst = NgContentAst;\n  /**\n   * A visitor that accepts each node but doesn't do anything. It is intended to be used\n   * as the base class for a visitor that is only interested in a subset of the node types.\n   */\n\n  var NullTemplateVisitor =\n  /** @class */\n  function () {\n    function NullTemplateVisitor() {}\n\n    NullTemplateVisitor.prototype.visitNgContent = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitElement = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitReference = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitVariable = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitEvent = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitElementProperty = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitAttr = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitBoundText = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitText = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitDirective = function (ast, context) {};\n\n    NullTemplateVisitor.prototype.visitDirectiveProperty = function (ast, context) {};\n\n    return NullTemplateVisitor;\n  }();\n\n  exports.NullTemplateVisitor = NullTemplateVisitor;\n  /**\n   * Base class that can be used to build a visitor that visits each node\n   * in an template ast recursively.\n   */\n\n  var RecursiveTemplateAstVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(RecursiveTemplateAstVisitor, _super);\n\n    function RecursiveTemplateAstVisitor() {\n      return _super.call(this) || this;\n    } // Nodes with children\n\n\n    RecursiveTemplateAstVisitor.prototype.visitEmbeddedTemplate = function (ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.references);\n        visit(ast.variables);\n        visit(ast.directives);\n        visit(ast.providers);\n        visit(ast.children);\n      });\n    };\n\n    RecursiveTemplateAstVisitor.prototype.visitElement = function (ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.inputs);\n        visit(ast.outputs);\n        visit(ast.references);\n        visit(ast.directives);\n        visit(ast.providers);\n        visit(ast.children);\n      });\n    };\n\n    RecursiveTemplateAstVisitor.prototype.visitDirective = function (ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.inputs);\n        visit(ast.hostProperties);\n        visit(ast.hostEvents);\n      });\n    };\n\n    RecursiveTemplateAstVisitor.prototype.visitChildren = function (context, cb) {\n      var results = [];\n      var t = this;\n\n      function visit(children) {\n        if (children && children.length) results.push(templateVisitAll(t, children, context));\n      }\n\n      cb(visit);\n      return Array.prototype.concat.apply([], results);\n    };\n\n    return RecursiveTemplateAstVisitor;\n  }(NullTemplateVisitor);\n\n  exports.RecursiveTemplateAstVisitor = RecursiveTemplateAstVisitor;\n  /**\n   * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\n   */\n\n  function templateVisitAll(visitor, asts, context) {\n    if (context === void 0) {\n      context = null;\n    }\n\n    var result = [];\n    var visit = visitor.visit ? function (ast) {\n      return visitor.visit(ast, context) || ast.visit(visitor, context);\n    } : function (ast) {\n      return ast.visit(visitor, context);\n    };\n    asts.forEach(function (ast) {\n      var astResult = visit(ast);\n\n      if (astResult) {\n        result.push(astResult);\n      }\n    });\n    return result;\n  }\n\n  exports.templateVisitAll = templateVisitAll;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/template_parser/template_ast.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;;AA0BH;;AAEG;;;AACH,MAAA,OAAA;AAAA;AAAA,cAAA;AACE,aAAA,OAAA,CACW,KADX,EACiC,cADjC,EACgE,UADhE,EAC2F;AAAhF,WAAA,KAAA,GAAA,KAAA;AAAsB,WAAA,cAAA,GAAA,cAAA;AAA+B,WAAA,UAAA,GAAA,UAAA;AAA+B;;AAC/F,IAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,SAAR,CAAkB,IAAlB,EAAwB,OAAxB,CAAP;AACD,KAFD;;AAGF,WAAA,OAAA;AAAC,GAND,EAAA;;AAAa,EAAA,OAAA,CAAA,OAAA,GAAA,OAAA;AAQb;;AAEG;;AACH,MAAA,YAAA;AAAA;AAAA,cAAA;AACE,aAAA,YAAA,CACW,KADX,EACwC,cADxC,EAEW,UAFX,EAEsC;AAD3B,WAAA,KAAA,GAAA,KAAA;AAA6B,WAAA,cAAA,GAAA,cAAA;AAC7B,WAAA,UAAA,GAAA,UAAA;AAA+B;;AAC1C,IAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,cAAR,CAAuB,IAAvB,EAA6B,OAA7B,CAAP;AACD,KAFD;;AAGF,WAAA,YAAA;AAAC,GAPD,EAAA;;AAAa,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA;AASb;;AAEG;;AACH,MAAA,OAAA;AAAA;AAAA,cAAA;AACE,aAAA,OAAA,CAAmB,IAAnB,EAAwC,KAAxC,EAA8D,UAA9D,EAAyF;AAAtE,WAAA,IAAA,GAAA,IAAA;AAAqB,WAAA,KAAA,GAAA,KAAA;AAAsB,WAAA,UAAA,GAAA,UAAA;AAA+B;;AAC7F,IAAA,OAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,SAAR,CAAkB,IAAlB,EAAwB,OAAxB,CAAP;AACD,KAFD;;AAGF,WAAA,OAAA;AAAC,GALD,EAAA;;AAAa,EAAA,OAAA,CAAA,OAAA,GAAA,OAAA;AAoBb,MAAM,oBAAoB,IAAA,EAAA,GAAA,EAAA,EACxB,EAAA,CAAA;AAAA;AAAA,GAAA,GAAA;AAAA;AADwB,IAExB,EAAA,CAAA;AAAA;AAAA,GAAA,GAAA;AAAA;AAFwB,IAGxB,EAAA,CAAA;AAAA;AAAA,GAAA,GAAA;AAAA;AAHwB,IAIxB,EAAA,CAAA;AAAA;AAAA,GAAA,GAAA;AAAA;AAJwB,IAKxB,EAAA,CAAA;AAAA;AAAA,GAAA,GAAA;AAAA;AALwB,IAMzB,EANyB,CAA1B;AAQA;;;AAGG;;AACH,MAAA,uBAAA;AAAA;AAAA,cAAA;AAGE,aAAA,uBAAA,CACW,IADX,EACgC,IADhC,EAEW,eAFX,EAEoD,KAFpD,EAGW,IAHX,EAGqC,UAHrC,EAGgE;AAFrD,WAAA,IAAA,GAAA,IAAA;AAAqB,WAAA,IAAA,GAAA,IAAA;AACrB,WAAA,eAAA,GAAA,eAAA;AAAyC,WAAA,KAAA,GAAA,KAAA;AACzC,WAAA,IAAA,GAAA,IAAA;AAA0B,WAAA,UAAA,GAAA,UAAA;AACnC,WAAK,WAAL,GAAmB,KAAK,IAAL,KAAS;AAAA;AAA5B;AACD;;AAEM,IAAA,uBAAA,CAAA,iBAAA,GAAP,UAAyB,IAAzB,EAAmD;AACjD,UAAM,IAAI,GAAG,oBAAoB,CAAC,IAAI,CAAC,IAAN,CAAjC;AACA,aAAO,IAAI,uBAAJ,CACH,IAAI,CAAC,IADF,EACQ,IADR,EACc,IAAI,CAAC,eADnB,EACoC,IAAI,CAAC,KADzC,EACgD,IAAI,CAAC,IADrD,EAC2D,IAAI,CAAC,UADhE,CAAP;AAED,KAJM;;AAMP,IAAA,uBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,oBAAR,CAA6B,IAA7B,EAAmC,OAAnC,CAAP;AACD,KAFD;;AAGF,WAAA,uBAAA;AAAC,GAnBD,EAAA;;AAAa,EAAA,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAqBb;;;AAGG;;AACH,MAAA,aAAA;AAAA;AAAA,cAAA;AAIE,aAAA,aAAA,CACW,IADX,EACgC,MADhC,EAC4D,KAD5D,EAEW,OAFX,EAE0C,UAF1C,EAGW,WAHX,EAGuC;AAF5B,WAAA,IAAA,GAAA,IAAA;AAAqB,WAAA,MAAA,GAAA,MAAA;AAA4B,WAAA,KAAA,GAAA,KAAA;AACjD,WAAA,OAAA,GAAA,OAAA;AAA+B,WAAA,UAAA,GAAA,UAAA;AAC/B,WAAA,WAAA,GAAA,WAAA;AACT,WAAK,QAAL,GAAgB,aAAa,CAAC,YAAd,CAA2B,KAAK,IAAhC,EAAsC,KAAK,MAA3C,EAAmD,KAAK,KAAxD,CAAhB;AACA,WAAK,WAAL,GAAmB,CAAC,CAAC,KAAK,KAA1B;AACD;;AAEM,IAAA,aAAA,CAAA,YAAA,GAAP,UAAoB,IAApB,EAAkC,MAAlC,EAAuD,KAAvD,EAAyE;AACvE,UAAI,MAAJ,EAAY;AACV,eAAU,MAAM,GAAA,GAAN,GAAU,IAApB;AACD;;AACD,UAAI,KAAJ,EAAW;AACT,eAAO,MAAI,IAAJ,GAAQ,GAAR,GAAY,KAAnB;AACD;;AAED,aAAO,IAAP;AACD,KATM;;AAWA,IAAA,aAAA,CAAA,eAAA,GAAP,UAAuB,KAAvB,EAAyC;AACvC,UAAM,MAAM,GAAgB,KAAK,CAAC,IAAN,KAAU;AAAA;AAAV,QAAyC,KAAK,CAAC,aAA/C,GAA+D,IAA3F;AACA,UAAM,KAAK,GACP,KAAK,CAAC,IAAN,KAAU;AAAA;AAAV,QAA2C,KAAK,CAAC,aAAjD,GAAiE,IADrE;AAEA,aAAO,IAAI,aAAJ,CACH,KAAK,CAAC,IADH,EACS,MADT,EACiB,KADjB,EACwB,KAAK,CAAC,OAD9B,EACuC,KAAK,CAAC,UAD7C,EACyD,KAAK,CAAC,WAD/D,CAAP;AAED,KANM;;AAQP,IAAA,aAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,UAAR,CAAmB,IAAnB,EAAyB,OAAzB,CAAP;AACD,KAFD;;AAGF,WAAA,aAAA;AAAC,GAlCD,EAAA;;AAAa,EAAA,OAAA,CAAA,aAAA,GAAA,aAAA;AAoCb;;AAEG;;AACH,MAAA,YAAA;AAAA;AAAA,cAAA;AACE,aAAA,YAAA,CACW,IADX,EACgC,KADhC,EACoE,aADpE,EAEW,UAFX,EAEsC;AAD3B,WAAA,IAAA,GAAA,IAAA;AAAqB,WAAA,KAAA,GAAA,KAAA;AAAoC,WAAA,aAAA,GAAA,aAAA;AACzD,WAAA,UAAA,GAAA,UAAA;AAA+B;;AAC1C,IAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,cAAR,CAAuB,IAAvB,EAA6B,OAA7B,CAAP;AACD,KAFD;;AAGF,WAAA,YAAA;AAAC,GAPD,EAAA;;AAAa,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA;AASb;;AAEG;;AACH,MAAA,WAAA;AAAA;AAAA,cAAA;AACE,aAAA,WAAA,CACoB,IADpB,EACkD,KADlD,EAEoB,UAFpB,EAEiE,SAFjE,EAE4F;AADxE,WAAA,IAAA,GAAA,IAAA;AAA8B,WAAA,KAAA,GAAA,KAAA;AAC9B,WAAA,UAAA,GAAA,UAAA;AAA6C,WAAA,SAAA,GAAA,SAAA;AAA+B;;AAEzF,IAAA,WAAA,CAAA,kBAAA,GAAP,UAA0B,CAA1B,EAA2C;AACzC,aAAO,IAAI,WAAJ,CAAgB,CAAC,CAAC,IAAlB,EAAwB,CAAC,CAAC,KAA1B,EAAiC,CAAC,CAAC,UAAnC,EAA+C,CAAC,CAAC,SAAjD,CAAP;AACD,KAFM;;AAIP,IAAA,WAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,aAAR,CAAsB,IAAtB,EAA4B,OAA5B,CAAP;AACD,KAFD;;AAGF,WAAA,WAAA;AAAC,GAZD,EAAA;;AAAa,EAAA,OAAA,CAAA,WAAA,GAAA,WAAA;AAcb;;AAEG;;AACH,MAAA,UAAA;AAAA;AAAA,cAAA;AACE,aAAA,UAAA,CACW,IADX,EACgC,KADhC,EACyD,MADzD,EAEW,OAFX,EAE4C,UAF5C,EAGW,UAHX,EAG8C,SAH9C,EAIW,gBAJX,EAI6C,YAJ7C,EAKW,QALX,EAK2C,cAL3C,EAMW,UANX,EAM+C,aAN/C,EAMkF;AALvE,WAAA,IAAA,GAAA,IAAA;AAAqB,WAAA,KAAA,GAAA,KAAA;AAAyB,WAAA,MAAA,GAAA,MAAA;AAC9C,WAAA,OAAA,GAAA,OAAA;AAAiC,WAAA,UAAA,GAAA,UAAA;AACjC,WAAA,UAAA,GAAA,UAAA;AAAmC,WAAA,SAAA,GAAA,SAAA;AACnC,WAAA,gBAAA,GAAA,gBAAA;AAAkC,WAAA,YAAA,GAAA,YAAA;AAClC,WAAA,QAAA,GAAA,QAAA;AAAgC,WAAA,cAAA,GAAA,cAAA;AAChC,WAAA,UAAA,GAAA,UAAA;AAAoC,WAAA,aAAA,GAAA,aAAA;AAAuC;;AAEtF,IAAA,UAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,YAAR,CAAqB,IAArB,EAA2B,OAA3B,CAAP;AACD,KAFD;;AAGF,WAAA,UAAA;AAAC,GAZD,EAAA;;AAAa,EAAA,OAAA,CAAA,UAAA,GAAA,UAAA;AAcb;;AAEG;;AACH,MAAA,mBAAA;AAAA;AAAA,cAAA;AACE,aAAA,mBAAA,CACW,KADX,EACoC,OADpC,EACqE,UADrE,EAEW,SAFX,EAE4C,UAF5C,EAGW,SAHX,EAG4C,gBAH5C,EAIW,YAJX,EAI8C,QAJ9C,EAKW,cALX,EAK0C,UAL1C,EAKqE;AAJ1D,WAAA,KAAA,GAAA,KAAA;AAAyB,WAAA,OAAA,GAAA,OAAA;AAAiC,WAAA,UAAA,GAAA,UAAA;AAC1D,WAAA,SAAA,GAAA,SAAA;AAAiC,WAAA,UAAA,GAAA,UAAA;AACjC,WAAA,SAAA,GAAA,SAAA;AAAiC,WAAA,gBAAA,GAAA,gBAAA;AACjC,WAAA,YAAA,GAAA,YAAA;AAAmC,WAAA,QAAA,GAAA,QAAA;AACnC,WAAA,cAAA,GAAA,cAAA;AAA+B,WAAA,UAAA,GAAA,UAAA;AAA+B;;AAEzE,IAAA,mBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,qBAAR,CAA8B,IAA9B,EAAoC,OAApC,CAAP;AACD,KAFD;;AAGF,WAAA,mBAAA;AAAC,GAXD,EAAA;;AAAa,EAAA,OAAA,CAAA,mBAAA,GAAA,mBAAA;AAab;;AAEG;;AACH,MAAA,yBAAA;AAAA;AAAA,cAAA;AACE,aAAA,yBAAA,CACW,aADX,EACyC,YADzC,EACsE,KADtE,EAEW,UAFX,EAEsC;AAD3B,WAAA,aAAA,GAAA,aAAA;AAA8B,WAAA,YAAA,GAAA,YAAA;AAA6B,WAAA,KAAA,GAAA,KAAA;AAC3D,WAAA,UAAA,GAAA,UAAA;AAA+B;;AAC1C,IAAA,yBAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,sBAAR,CAA+B,IAA/B,EAAqC,OAArC,CAAP;AACD,KAFD;;AAGF,WAAA,yBAAA;AAAC,GAPD,EAAA;;AAAa,EAAA,OAAA,CAAA,yBAAA,GAAA,yBAAA;AASb;;AAEG;;AACH,MAAA,YAAA;AAAA;AAAA,cAAA;AACE,aAAA,YAAA,CACW,SADX,EACsD,MADtD,EAEW,cAFX,EAE6D,UAF7D,EAGW,mBAHX,EAG+C,UAH/C,EAG0E;AAF/D,WAAA,SAAA,GAAA,SAAA;AAA2C,WAAA,MAAA,GAAA,MAAA;AAC3C,WAAA,cAAA,GAAA,cAAA;AAAkD,WAAA,UAAA,GAAA,UAAA;AAClD,WAAA,mBAAA,GAAA,mBAAA;AAAoC,WAAA,UAAA,GAAA,UAAA;AAA+B;;AAC9E,IAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,cAAR,CAAuB,IAAvB,EAA6B,OAA7B,CAAP;AACD,KAFD;;AAGF,WAAA,YAAA;AAAC,GARD,EAAA;;AAAa,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA;AAUb;;AAEG;;AACH,MAAA,WAAA;AAAA;AAAA,cAAA;AACE,aAAA,WAAA,CACW,KADX,EAC+C,aAD/C,EAC8E,KAD9E,EAEW,SAFX,EAEwD,YAFxD,EAGW,cAHX,EAGoD,UAHpD,EAIa,QAJb,EAI8B;AAHnB,WAAA,KAAA,GAAA,KAAA;AAAoC,WAAA,aAAA,GAAA,aAAA;AAA+B,WAAA,KAAA,GAAA,KAAA;AACnE,WAAA,SAAA,GAAA,SAAA;AAA6C,WAAA,YAAA,GAAA,YAAA;AAC7C,WAAA,cAAA,GAAA,cAAA;AAAyC,WAAA,UAAA,GAAA,UAAA;AACvC,WAAA,QAAA,GAAA,QAAA;AAAqB;;AAElC,IAAA,WAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C;AACA,aAAO,IAAP;AACD,KAHD;;AAIF,WAAA,WAAA;AAAC,GAXD,EAAA;;AAAa,EAAA,OAAA,CAAA,WAAA,GAAA,WAAA;AAab,MAAY,eAAZ;;AAAA,GAAA,UAAY,eAAZ,EAA2B;AACzB,IAAA,eAAA,CAAA,eAAA,CAAA,eAAA,CAAA,GAAA,CAAA,CAAA,GAAA,eAAA;AACA,IAAA,eAAA,CAAA,eAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,gBAAA;AACA,IAAA,eAAA,CAAA,eAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,IAAA,eAAA,CAAA,eAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,IAAA,eAAA,CAAA,eAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACD,GAND,EAAY,eAAe,GAAf,OAAA,CAAA,eAAA,KAAA,OAAA,CAAA,eAAA,GAAe,EAAf,CAAZ;AAQA;;AAEG;;;AACH,MAAA,YAAA;AAAA;AAAA,cAAA;AACE,aAAA,YAAA,CACW,KADX,EACiC,cADjC,EACgE,UADhE,EAC2F;AAAhF,WAAA,KAAA,GAAA,KAAA;AAAsB,WAAA,cAAA,GAAA,cAAA;AAA+B,WAAA,UAAA,GAAA,UAAA;AAA+B;;AAC/F,IAAA,YAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,OAAN,EAAmC,OAAnC,EAA+C;AAC7C,aAAO,OAAO,CAAC,cAAR,CAAuB,IAAvB,EAA6B,OAA7B,CAAP;AACD,KAFD;;AAGF,WAAA,YAAA;AAAC,GAND,EAAA;;AAAa,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA;AAoCb;;;AAGG;;AACH,MAAA,mBAAA;AAAA;AAAA,cAAA;AAAA,aAAA,mBAAA,GAAA,CAaC;;AAZC,IAAA,mBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAAkC,OAAlC,EAA8C,CAAU,CAAxD;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,GAAtB,EAAgD,OAAhD,EAA4D,CAAU,CAAtE;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,GAAb,EAA8B,OAA9B,EAA0C,CAAU,CAApD;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAAkC,OAAlC,EAA8C,CAAU,CAAxD;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,GAAd,EAAgC,OAAhC,EAA4C,CAAU,CAAtD;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,GAAX,EAA+B,OAA/B,EAA2C,CAAU,CAArD;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,GAArB,EAAmD,OAAnD,EAA+D,CAAU,CAAzE;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,GAAV,EAAwB,OAAxB,EAAoC,CAAU,CAA9C;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAAkC,OAAlC,EAA8C,CAAU,CAAxD;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,SAAA,GAAA,UAAU,GAAV,EAAwB,OAAxB,EAAoC,CAAU,CAA9C;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAAkC,OAAlC,EAA8C,CAAU,CAAxD;;AACA,IAAA,mBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,GAAvB,EAAuD,OAAvD,EAAmE,CAAU,CAA7E;;AACF,WAAA,mBAAA;AAAC,GAbD,EAAA;;AAAa,EAAA,OAAA,CAAA,mBAAA,GAAA,mBAAA;AAeb;;;AAGG;;AACH,MAAA,2BAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAiD,IAAA,OAAA,CAAA,SAAA,CAAA,2BAAA,EAAA,MAAA;;AAC/C,aAAA,2BAAA,GAAA;aACE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,I;AACR,KAHH,CAKE;;;AACA,IAAA,2BAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,GAAtB,EAAgD,OAAhD,EAA4D;AAC1D,aAAO,KAAK,aAAL,CAAmB,OAAnB,EAA4B,UAAA,KAAA,EAAK;AACtC,QAAA,KAAK,CAAC,GAAG,CAAC,KAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,UAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,SAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,UAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,SAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,QAAL,CAAL;AACD,OAPM,CAAP;AAQD,KATD;;AAWA,IAAA,2BAAA,CAAA,SAAA,CAAA,YAAA,GAAA,UAAa,GAAb,EAA8B,OAA9B,EAA0C;AACxC,aAAO,KAAK,aAAL,CAAmB,OAAnB,EAA4B,UAAA,KAAA,EAAK;AACtC,QAAA,KAAK,CAAC,GAAG,CAAC,KAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,MAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,OAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,UAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,UAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,SAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,QAAL,CAAL;AACD,OARM,CAAP;AASD,KAVD;;AAYA,IAAA,2BAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAAkC,OAAlC,EAA8C;AAC5C,aAAO,KAAK,aAAL,CAAmB,OAAnB,EAA4B,UAAA,KAAA,EAAK;AACtC,QAAA,KAAK,CAAC,GAAG,CAAC,MAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,cAAL,CAAL;AACA,QAAA,KAAK,CAAC,GAAG,CAAC,UAAL,CAAL;AACD,OAJM,CAAP;AAKD,KAND;;AAQU,IAAA,2BAAA,CAAA,SAAA,CAAA,aAAA,GAAV,UACI,OADJ,EAEI,EAFJ,EAEmF;AACjF,UAAI,OAAO,GAAY,EAAvB;AACA,UAAI,CAAC,GAAG,IAAR;;AACA,eAAS,KAAT,CAAsC,QAAtC,EAA6D;AAC3D,YAAI,QAAQ,IAAI,QAAQ,CAAC,MAAzB,EAAiC,OAAO,CAAC,IAAR,CAAa,gBAAgB,CAAC,CAAD,EAAI,QAAJ,EAAc,OAAd,CAA7B;AAClC;;AACD,MAAA,EAAE,CAAC,KAAD,CAAF;AACA,aAAO,KAAK,CAAC,SAAN,CAAgB,MAAhB,CAAuB,KAAvB,CAA6B,EAA7B,EAAiC,OAAjC,CAAP;AACD,KAVS;;AAWZ,WAAA,2BAAA;AAAC,GAhDD,CAAiD,mBAAjD,CAAA;;AAAa,EAAA,OAAA,CAAA,2BAAA,GAAA,2BAAA;AAkDb;;AAEG;;AACH,WAAgB,gBAAhB,CACI,OADJ,EACiC,IADjC,EACsD,OADtD,EACyE;AAAnB,QAAA,OAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,OAAA,GAAA,IAAA;AAAmB;;AACvE,QAAM,MAAM,GAAU,EAAtB;AACA,QAAM,KAAK,GAAG,OAAO,CAAC,KAAR,GACV,UAAC,GAAD,EAAiB;AAAK,aAAA,OAAO,CAAC,KAAR,CAAe,GAAf,EAAoB,OAApB,KAAgC,GAAG,CAAC,KAAJ,CAAU,OAAV,EAAhC,OAAgC,CAAhC;AAA2D,KADvE,GAEV,UAAC,GAAD,EAAiB;AAAK,aAAA,GAAG,CAAC,KAAJ,CAAU,OAAV,EAAA,OAAA,CAAA;AAA2B,KAFrD;AAGA,IAAA,IAAI,CAAC,OAAL,CAAa,UAAA,GAAA,EAAG;AACd,UAAM,SAAS,GAAG,KAAK,CAAC,GAAD,CAAvB;;AACA,UAAI,SAAJ,EAAe;AACb,QAAA,MAAM,CAAC,IAAP,CAAY,SAAZ;AACD;AACF,KALD;AAMA,WAAO,MAAP;AACD;;AAbD,EAAA,OAAA,CAAA,gBAAA,GAAA,gBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AstPath} from '../ast_path';\nimport {CompileDirectiveSummary, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\nimport {SecurityContext} from '../core';\nimport {ASTWithSource, BindingType, BoundElementProperty, ParsedEvent, ParsedEventType, ParsedVariable} from '../expression_parser/ast';\nimport {LifecycleHooks} from '../lifecycle_reflector';\nimport {ParseSourceSpan} from '../parse_util';\n\n\n\n/**\n * An Abstract Syntax Tree node representing part of a parsed Angular template.\n */\nexport interface TemplateAst {\n  /**\n   * The source span from which this node was parsed.\n   */\n  sourceSpan: ParseSourceSpan;\n\n  /**\n   * Visit this node and possibly transform it.\n   */\n  visit(visitor: TemplateAstVisitor, context: any): any;\n}\n\n/**\n * A segment of text within the template.\n */\nexport class TextAst implements TemplateAst {\n  constructor(\n      public value: string, public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n/**\n * A bound expression within the text of a template.\n */\nexport class BoundTextAst implements TemplateAst {\n  constructor(\n      public value: ASTWithSource, public ngContentIndex: number,\n      public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitBoundText(this, context);\n  }\n}\n\n/**\n * A plain attribute on an element.\n */\nexport class AttrAst implements TemplateAst {\n  constructor(public name: string, public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitAttr(this, context);\n  }\n}\n\nexport const enum PropertyBindingType {\n  // A normal binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n  Animation,\n}\n\nconst BoundPropertyMapping = {\n  [BindingType.Animation]: PropertyBindingType.Animation,\n  [BindingType.Attribute]: PropertyBindingType.Attribute,\n  [BindingType.Class]: PropertyBindingType.Class,\n  [BindingType.Property]: PropertyBindingType.Property,\n  [BindingType.Style]: PropertyBindingType.Style,\n};\n\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[@trigger]=\"stateExp\"`)\n */\nexport class BoundElementPropertyAst implements TemplateAst {\n  readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public type: PropertyBindingType,\n      public securityContext: SecurityContext, public value: ASTWithSource,\n      public unit: string|null, public sourceSpan: ParseSourceSpan) {\n    this.isAnimation = this.type === PropertyBindingType.Animation;\n  }\n\n  static fromBoundProperty(prop: BoundElementProperty) {\n    const type = BoundPropertyMapping[prop.type];\n    return new BoundElementPropertyAst(\n        prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\n  }\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitElementProperty(this, context);\n  }\n}\n\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(@trigger.phase)=\"callback($event)\"`).\n */\nexport class BoundEventAst implements TemplateAst {\n  readonly fullName: string;\n  readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public target: string|null, public phase: string|null,\n      public handler: ASTWithSource, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan) {\n    this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n    this.isAnimation = !!this.phase;\n  }\n\n  static calcFullName(name: string, target: string|null, phase: string|null): string {\n    if (target) {\n      return `${target}:${name}`;\n    }\n    if (phase) {\n      return `@${name}.${phase}`;\n    }\n\n    return name;\n  }\n\n  static fromParsedEvent(event: ParsedEvent) {\n    const target: string|null = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase: string|null =\n        event.type === ParsedEventType.Animation ? event.targetOrPhase : null;\n    return new BoundEventAst(\n        event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\n  }\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitEvent(this, context);\n  }\n}\n\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nexport class ReferenceAst implements TemplateAst {\n  constructor(\n      public name: string, public value: CompileTokenMetadata, public originalValue: string,\n      public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitReference(this, context);\n  }\n}\n\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nexport class VariableAst implements TemplateAst {\n  constructor(\n      public readonly name: string, public readonly value: string,\n      public readonly sourceSpan: ParseSourceSpan, public readonly valueSpan?: ParseSourceSpan) {}\n\n  static fromParsedVariable(v: ParsedVariable) {\n    return new VariableAst(v.name, v.value, v.sourceSpan, v.valueSpan);\n  }\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitVariable(this, context);\n  }\n}\n\n/**\n * An element declaration in a template.\n */\nexport class ElementAst implements TemplateAst {\n  constructor(\n      public name: string, public attrs: AttrAst[], public inputs: BoundElementPropertyAst[],\n      public outputs: BoundEventAst[], public references: ReferenceAst[],\n      public directives: DirectiveAst[], public providers: ProviderAst[],\n      public hasViewContainer: boolean, public queryMatches: QueryMatch[],\n      public children: TemplateAst[], public ngContentIndex: number|null,\n      public sourceSpan: ParseSourceSpan, public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nexport class EmbeddedTemplateAst implements TemplateAst {\n  constructor(\n      public attrs: AttrAst[], public outputs: BoundEventAst[], public references: ReferenceAst[],\n      public variables: VariableAst[], public directives: DirectiveAst[],\n      public providers: ProviderAst[], public hasViewContainer: boolean,\n      public queryMatches: QueryMatch[], public children: TemplateAst[],\n      public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitEmbeddedTemplate(this, context);\n  }\n}\n\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nexport class BoundDirectivePropertyAst implements TemplateAst {\n  constructor(\n      public directiveName: string, public templateName: string, public value: ASTWithSource,\n      public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitDirectiveProperty(this, context);\n  }\n}\n\n/**\n * A directive declared on an element.\n */\nexport class DirectiveAst implements TemplateAst {\n  constructor(\n      public directive: CompileDirectiveSummary, public inputs: BoundDirectivePropertyAst[],\n      public hostProperties: BoundElementPropertyAst[], public hostEvents: BoundEventAst[],\n      public contentQueryStartId: number, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitDirective(this, context);\n  }\n}\n\n/**\n * A provider declared on an element\n */\nexport class ProviderAst implements TemplateAst {\n  constructor(\n      public token: CompileTokenMetadata, public multiProvider: boolean, public eager: boolean,\n      public providers: CompileProviderMetadata[], public providerType: ProviderAstType,\n      public lifecycleHooks: LifecycleHooks[], public sourceSpan: ParseSourceSpan,\n      readonly isModule: boolean) {}\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    // No visit method in the visitor for now...\n    return null;\n  }\n}\n\nexport enum ProviderAstType {\n  PublicService,\n  PrivateService,\n  Component,\n  Directive,\n  Builtin\n}\n\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nexport class NgContentAst implements TemplateAst {\n  constructor(\n      public index: number, public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitNgContent(this, context);\n  }\n}\n\nexport interface QueryMatch {\n  queryId: number;\n  value: CompileTokenMetadata;\n}\n\n/**\n * A visitor for {@link TemplateAst} trees that will process each node.\n */\nexport interface TemplateAstVisitor {\n  // Returning a truthy value from `visit()` will prevent `templateVisitAll()` from the call to\n  // the typed method and result returned will become the result included in `visitAll()`s\n  // result array.\n  visit?(ast: TemplateAst, context: any): any;\n\n  visitNgContent(ast: NgContentAst, context: any): any;\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any;\n  visitElement(ast: ElementAst, context: any): any;\n  visitReference(ast: ReferenceAst, context: any): any;\n  visitVariable(ast: VariableAst, context: any): any;\n  visitEvent(ast: BoundEventAst, context: any): any;\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any;\n  visitAttr(ast: AttrAst, context: any): any;\n  visitBoundText(ast: BoundTextAst, context: any): any;\n  visitText(ast: TextAst, context: any): any;\n  visitDirective(ast: DirectiveAst, context: any): any;\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any;\n}\n\n/**\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\n * as the base class for a visitor that is only interested in a subset of the node types.\n */\nexport class NullTemplateVisitor implements TemplateAstVisitor {\n  visitNgContent(ast: NgContentAst, context: any): void {}\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): void {}\n  visitElement(ast: ElementAst, context: any): void {}\n  visitReference(ast: ReferenceAst, context: any): void {}\n  visitVariable(ast: VariableAst, context: any): void {}\n  visitEvent(ast: BoundEventAst, context: any): void {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): void {}\n  visitAttr(ast: AttrAst, context: any): void {}\n  visitBoundText(ast: BoundTextAst, context: any): void {}\n  visitText(ast: TextAst, context: any): void {}\n  visitDirective(ast: DirectiveAst, context: any): void {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): void {}\n}\n\n/**\n * Base class that can be used to build a visitor that visits each node\n * in an template ast recursively.\n */\nexport class RecursiveTemplateAstVisitor extends NullTemplateVisitor implements TemplateAstVisitor {\n  constructor() {\n    super();\n  }\n\n  // Nodes with children\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.references);\n      visit(ast.variables);\n      visit(ast.directives);\n      visit(ast.providers);\n      visit(ast.children);\n    });\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.inputs);\n      visit(ast.outputs);\n      visit(ast.references);\n      visit(ast.directives);\n      visit(ast.providers);\n      visit(ast.children);\n    });\n  }\n\n  visitDirective(ast: DirectiveAst, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.inputs);\n      visit(ast.hostProperties);\n      visit(ast.hostEvents);\n    });\n  }\n\n  protected visitChildren(\n      context: any,\n      cb: (visit: (<V extends TemplateAst>(children: V[]|undefined) => void)) => void) {\n    let results: any[][] = [];\n    let t = this;\n    function visit<T extends TemplateAst>(children: T[]|undefined) {\n      if (children && children.length) results.push(templateVisitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n\n/**\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\n */\nexport function templateVisitAll(\n    visitor: TemplateAstVisitor, asts: TemplateAst[], context: any = null): any[] {\n  const result: any[] = [];\n  const visit = visitor.visit ?\n      (ast: TemplateAst) => visitor.visit!(ast, context) || ast.visit(visitor, context) :\n      (ast: TemplateAst) => ast.visit(visitor, context);\n  asts.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nexport type TemplateAstPath = AstPath<TemplateAst>;\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}