{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/metadata/bundler\", [\"require\", \"exports\", \"tslib\", \"path\", \"typescript\", \"@angular/compiler-cli/src/metadata/collector\", \"@angular/compiler-cli/src/metadata/schema\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.CompilerHostAdapter = exports.MetadataBundler = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var path = require(\"path\");\n\n  var ts = require(\"typescript\");\n\n  var collector_1 = require(\"@angular/compiler-cli/src/metadata/collector\");\n\n  var schema_1 = require(\"@angular/compiler-cli/src/metadata/schema\"); // The character set used to produce private names.\n\n\n  var PRIVATE_NAME_CHARS = 'abcdefghijklmnopqrstuvwxyz';\n\n  var MetadataBundler =\n  /** @class */\n  function () {\n    function MetadataBundler(root, importAs, host, privateSymbolPrefix) {\n      this.root = root;\n      this.importAs = importAs;\n      this.host = host;\n      this.symbolMap = new Map();\n      this.metadataCache = new Map();\n      this.exports = new Map();\n      this.rootModule = \"./\" + path.basename(root);\n      this.privateSymbolPrefix = (privateSymbolPrefix || '').replace(/\\W/g, '_');\n    }\n\n    MetadataBundler.prototype.getMetadataBundle = function () {\n      // Export the root module. This also collects the transitive closure of all values referenced by\n      // the exports.\n      var exportedSymbols = this.exportAll(this.rootModule);\n      this.canonicalizeSymbols(exportedSymbols); // TODO: exports? e.g. a module re-exports a symbol from another bundle\n\n      var metadata = this.getEntries(exportedSymbols);\n      var privates = Array.from(this.symbolMap.values()).filter(function (s) {\n        return s.referenced && s.isPrivate;\n      }).map(function (s) {\n        return {\n          privateName: s.privateName,\n          name: s.declaration.name,\n          module: s.declaration.module\n        };\n      });\n      var origins = Array.from(this.symbolMap.values()).filter(function (s) {\n        return s.referenced && !s.reexport;\n      }).reduce(function (p, s) {\n        p[s.isPrivate ? s.privateName : s.name] = s.declaration.module;\n        return p;\n      }, {});\n      var exports = this.getReExports(exportedSymbols);\n      return {\n        metadata: {\n          __symbolic: 'module',\n          version: schema_1.METADATA_VERSION,\n          exports: exports.length ? exports : undefined,\n          metadata: metadata,\n          origins: origins,\n          importAs: this.importAs\n        },\n        privates: privates\n      };\n    };\n\n    MetadataBundler.resolveModule = function (importName, from) {\n      return resolveModule(importName, from);\n    };\n\n    MetadataBundler.prototype.getMetadata = function (moduleName) {\n      var result = this.metadataCache.get(moduleName);\n\n      if (!result) {\n        if (moduleName.startsWith('.')) {\n          var fullModuleName = resolveModule(moduleName, this.root);\n          result = this.host.getMetadataFor(fullModuleName, this.root);\n        }\n\n        this.metadataCache.set(moduleName, result);\n      }\n\n      return result;\n    };\n\n    MetadataBundler.prototype.exportAll = function (moduleName) {\n      var e_1, _a, e_2, _b, e_3, _c;\n\n      var _this = this;\n\n      var module = this.getMetadata(moduleName);\n      var result = this.exports.get(moduleName);\n\n      if (result) {\n        return result;\n      }\n\n      result = [];\n\n      var exportSymbol = function exportSymbol(exportedSymbol, exportAs) {\n        var symbol = _this.symbolOf(moduleName, exportAs);\n\n        result.push(symbol);\n        exportedSymbol.reexportedAs = symbol;\n        symbol.exports = exportedSymbol;\n      }; // Export all the symbols defined in this module.\n\n\n      if (module && module.metadata) {\n        for (var key in module.metadata) {\n          var data = module.metadata[key];\n\n          if (schema_1.isMetadataImportedSymbolReferenceExpression(data)) {\n            // This is a re-export of an imported symbol. Record this as a re-export.\n            var exportFrom = resolveModule(data.module, moduleName);\n            this.exportAll(exportFrom);\n            var symbol = this.symbolOf(exportFrom, data.name);\n            exportSymbol(symbol, key);\n          } else {\n            // Record that this symbol is exported by this module.\n            result.push(this.symbolOf(moduleName, key));\n          }\n        }\n      } // Export all the re-exports from this module\n\n\n      if (module && module.exports) {\n        var unnamedModuleExportsIdx = 0;\n\n        try {\n          for (var _d = tslib_1.__values(module.exports), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var exportDeclaration = _e.value;\n            var exportFrom = resolveModule(exportDeclaration.from, moduleName); // Record all the exports from the module even if we don't use it directly.\n\n            var exportedSymbols = this.exportAll(exportFrom);\n\n            if (exportDeclaration.export) {\n              try {\n                // Re-export all the named exports from a module.\n                for (var _f = (e_2 = void 0, tslib_1.__values(exportDeclaration.export)), _g = _f.next(); !_g.done; _g = _f.next()) {\n                  var exportItem = _g.value;\n                  var name = typeof exportItem == 'string' ? exportItem : exportItem.name;\n                  var exportAs = typeof exportItem == 'string' ? exportItem : exportItem.as;\n                  var symbol = this.symbolOf(exportFrom, name);\n\n                  if (exportedSymbols && exportedSymbols.length == 1 && exportedSymbols[0].reexport && exportedSymbols[0].name == '*') {\n                    // This is a named export from a module we have no metadata about. Record the named\n                    // export as a re-export.\n                    symbol.reexport = true;\n                  }\n\n                  exportSymbol(this.symbolOf(exportFrom, name), exportAs);\n                }\n              } catch (e_2_1) {\n                e_2 = {\n                  error: e_2_1\n                };\n              } finally {\n                try {\n                  if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n                } finally {\n                  if (e_2) throw e_2.error;\n                }\n              }\n            } else {\n              // Re-export all the symbols from the module\n              var exportedSymbols_2 = this.exportAll(exportFrom);\n\n              try {\n                for (var exportedSymbols_1 = (e_3 = void 0, tslib_1.__values(exportedSymbols_2)), exportedSymbols_1_1 = exportedSymbols_1.next(); !exportedSymbols_1_1.done; exportedSymbols_1_1 = exportedSymbols_1.next()) {\n                  var exportedSymbol = exportedSymbols_1_1.value; // In case the exported symbol does not have a name, we need to give it an unique\n                  // name for the current module. This is necessary because there can be multiple\n                  // unnamed re-exports in a given module.\n\n                  var name = exportedSymbol.name === '*' ? \"unnamed_reexport_\" + unnamedModuleExportsIdx++ : exportedSymbol.name;\n                  exportSymbol(exportedSymbol, name);\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (exportedSymbols_1_1 && !exportedSymbols_1_1.done && (_c = exportedSymbols_1.return)) _c.call(exportedSymbols_1);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n\n      if (!module) {\n        // If no metadata is found for this import then it is considered external to the\n        // library and should be recorded as a re-export in the final metadata if it is\n        // eventually re-exported.\n        var symbol = this.symbolOf(moduleName, '*');\n        symbol.reexport = true;\n        result.push(symbol);\n      }\n\n      this.exports.set(moduleName, result);\n      return result;\n    };\n    /**\n     * Fill in the canonicalSymbol which is the symbol that should be imported by factories.\n     * The canonical symbol is the one exported by the index file for the bundle or definition\n     * symbol for private symbols that are not exported by bundle index.\n     */\n\n\n    MetadataBundler.prototype.canonicalizeSymbols = function (exportedSymbols) {\n      var symbols = Array.from(this.symbolMap.values());\n      this.exported = new Set(exportedSymbols);\n      symbols.forEach(this.canonicalizeSymbol, this);\n    };\n\n    MetadataBundler.prototype.canonicalizeSymbol = function (symbol) {\n      var rootExport = getRootExport(symbol);\n      var declaration = getSymbolDeclaration(symbol);\n      var isPrivate = !this.exported.has(rootExport);\n      var canonicalSymbol = isPrivate ? declaration : rootExport;\n      symbol.isPrivate = isPrivate;\n      symbol.declaration = declaration;\n      symbol.canonicalSymbol = canonicalSymbol;\n      symbol.reexport = declaration.reexport;\n    };\n\n    MetadataBundler.prototype.getEntries = function (exportedSymbols) {\n      var _this = this;\n\n      var result = {};\n      var exportedNames = new Set(exportedSymbols.map(function (s) {\n        return s.name;\n      }));\n      var privateName = 0;\n\n      function newPrivateName(prefix) {\n        while (true) {\n          var digits = [];\n          var index = privateName++;\n          var base = PRIVATE_NAME_CHARS;\n\n          while (!digits.length || index > 0) {\n            digits.unshift(base[index % base.length]);\n            index = Math.floor(index / base.length);\n          }\n\n          var result_1 = \"\\u0275\" + prefix + digits.join('');\n          if (!exportedNames.has(result_1)) return result_1;\n        }\n      }\n\n      exportedSymbols.forEach(function (symbol) {\n        return _this.convertSymbol(symbol);\n      });\n      var symbolsMap = new Map();\n      Array.from(this.symbolMap.values()).forEach(function (symbol) {\n        if (symbol.referenced && !symbol.reexport) {\n          var name = symbol.name;\n          var identifier = symbol.declaration.module + \":\" + symbol.declaration.name;\n\n          if (symbol.isPrivate && !symbol.privateName) {\n            name = newPrivateName(_this.privateSymbolPrefix);\n            symbol.privateName = name;\n          }\n\n          if (symbolsMap.has(identifier)) {\n            var names = symbolsMap.get(identifier);\n            names.push(name);\n          } else {\n            symbolsMap.set(identifier, [name]);\n          }\n\n          result[name] = symbol.value;\n        }\n      }); // check for duplicated entries\n\n      symbolsMap.forEach(function (names, identifier) {\n        if (names.length > 1) {\n          var _a = tslib_1.__read(identifier.split(':'), 2),\n              module_1 = _a[0],\n              declaredName = _a[1]; // prefer the export that uses the declared name (if any)\n\n\n          var reference_1 = names.indexOf(declaredName);\n\n          if (reference_1 === -1) {\n            reference_1 = 0;\n          } // keep one entry and replace the others by references\n\n\n          names.forEach(function (name, i) {\n            if (i !== reference_1) {\n              result[name] = {\n                __symbolic: 'reference',\n                name: names[reference_1]\n              };\n            }\n          });\n        }\n      });\n      return result;\n    };\n\n    MetadataBundler.prototype.getReExports = function (exportedSymbols) {\n      var e_4, _a;\n\n      var modules = new Map();\n      var exportAlls = new Set();\n\n      try {\n        for (var exportedSymbols_3 = tslib_1.__values(exportedSymbols), exportedSymbols_3_1 = exportedSymbols_3.next(); !exportedSymbols_3_1.done; exportedSymbols_3_1 = exportedSymbols_3.next()) {\n          var symbol = exportedSymbols_3_1.value;\n\n          if (symbol.reexport) {\n            // symbol.declaration is guaranteed to be defined during the phase this method is called.\n            var declaration = symbol.declaration;\n            var module_2 = declaration.module;\n\n            if (declaration.name == '*') {\n              // Reexport all the symbols.\n              exportAlls.add(declaration.module);\n            } else {\n              // Re-export the symbol as the exported name.\n              var entry = modules.get(module_2);\n\n              if (!entry) {\n                entry = [];\n                modules.set(module_2, entry);\n              }\n\n              var as = symbol.name;\n              var name = declaration.name;\n              entry.push({\n                name: name,\n                as: as\n              });\n            }\n          }\n        }\n      } catch (e_4_1) {\n        e_4 = {\n          error: e_4_1\n        };\n      } finally {\n        try {\n          if (exportedSymbols_3_1 && !exportedSymbols_3_1.done && (_a = exportedSymbols_3.return)) _a.call(exportedSymbols_3);\n        } finally {\n          if (e_4) throw e_4.error;\n        }\n      }\n\n      return tslib_1.__spread(Array.from(exportAlls.values()).map(function (from) {\n        return {\n          from: from\n        };\n      }), Array.from(modules.entries()).map(function (_a) {\n        var _b = tslib_1.__read(_a, 2),\n            from = _b[0],\n            exports = _b[1];\n\n        return {\n          export: exports,\n          from: from\n        };\n      }));\n    };\n\n    MetadataBundler.prototype.convertSymbol = function (symbol) {\n      // canonicalSymbol is ensured to be defined before this is called.\n      var canonicalSymbol = symbol.canonicalSymbol;\n\n      if (!canonicalSymbol.referenced) {\n        canonicalSymbol.referenced = true; // declaration is ensured to be definded before this method is called.\n\n        var declaration = canonicalSymbol.declaration;\n        var module_3 = this.getMetadata(declaration.module);\n\n        if (module_3) {\n          var value = module_3.metadata[declaration.name];\n\n          if (value && !declaration.name.startsWith('___')) {\n            canonicalSymbol.value = this.convertEntry(declaration.module, value);\n          }\n        }\n      }\n    };\n\n    MetadataBundler.prototype.convertEntry = function (moduleName, value) {\n      if (schema_1.isClassMetadata(value)) {\n        return this.convertClass(moduleName, value);\n      }\n\n      if (schema_1.isFunctionMetadata(value)) {\n        return this.convertFunction(moduleName, value);\n      }\n\n      if (schema_1.isInterfaceMetadata(value)) {\n        return value;\n      }\n\n      return this.convertValue(moduleName, value);\n    };\n\n    MetadataBundler.prototype.convertClass = function (moduleName, value) {\n      var _this = this;\n\n      return {\n        __symbolic: 'class',\n        arity: value.arity,\n        extends: this.convertExpression(moduleName, value.extends),\n        decorators: value.decorators && value.decorators.map(function (d) {\n          return _this.convertExpression(moduleName, d);\n        }),\n        members: this.convertMembers(moduleName, value.members),\n        statics: value.statics && this.convertStatics(moduleName, value.statics)\n      };\n    };\n\n    MetadataBundler.prototype.convertMembers = function (moduleName, members) {\n      var _this = this;\n\n      var result = {};\n\n      for (var name in members) {\n        var value = members[name];\n        result[name] = value.map(function (v) {\n          return _this.convertMember(moduleName, v);\n        });\n      }\n\n      return result;\n    };\n\n    MetadataBundler.prototype.convertMember = function (moduleName, member) {\n      var _this = this;\n\n      var result = {\n        __symbolic: member.__symbolic\n      };\n      result.decorators = member.decorators && member.decorators.map(function (d) {\n        return _this.convertExpression(moduleName, d);\n      });\n\n      if (schema_1.isMethodMetadata(member)) {\n        result.parameterDecorators = member.parameterDecorators && member.parameterDecorators.map(function (d) {\n          return d && d.map(function (p) {\n            return _this.convertExpression(moduleName, p);\n          });\n        });\n\n        if (schema_1.isConstructorMetadata(member)) {\n          if (member.parameters) {\n            result.parameters = member.parameters.map(function (p) {\n              return _this.convertExpression(moduleName, p);\n            });\n          }\n        }\n      }\n\n      return result;\n    };\n\n    MetadataBundler.prototype.convertStatics = function (moduleName, statics) {\n      var result = {};\n\n      for (var key in statics) {\n        var value = statics[key];\n\n        if (schema_1.isFunctionMetadata(value)) {\n          result[key] = this.convertFunction(moduleName, value);\n        } else if (schema_1.isMetadataSymbolicCallExpression(value)) {\n          // Class members can also contain static members that call a function with module\n          // references. e.g. \"static ɵprov = ɵɵdefineInjectable(..)\". We also need to\n          // convert these module references because otherwise these resolve to non-existent files.\n          result[key] = this.convertValue(moduleName, value);\n        } else {\n          result[key] = value;\n        }\n      }\n\n      return result;\n    };\n\n    MetadataBundler.prototype.convertFunction = function (moduleName, value) {\n      var _this = this;\n\n      return {\n        __symbolic: 'function',\n        parameters: value.parameters,\n        defaults: value.defaults && value.defaults.map(function (v) {\n          return _this.convertValue(moduleName, v);\n        }),\n        value: this.convertValue(moduleName, value.value)\n      };\n    };\n\n    MetadataBundler.prototype.convertValue = function (moduleName, value) {\n      var _this = this;\n\n      if (isPrimitive(value)) {\n        return value;\n      }\n\n      if (schema_1.isMetadataError(value)) {\n        return this.convertError(moduleName, value);\n      }\n\n      if (schema_1.isMetadataSymbolicExpression(value)) {\n        return this.convertExpression(moduleName, value);\n      }\n\n      if (Array.isArray(value)) {\n        return value.map(function (v) {\n          return _this.convertValue(moduleName, v);\n        });\n      } // Otherwise it is a metadata object.\n\n\n      var object = value;\n      var result = {};\n\n      for (var key in object) {\n        result[key] = this.convertValue(moduleName, object[key]);\n      }\n\n      return result;\n    };\n\n    MetadataBundler.prototype.convertExpression = function (moduleName, value) {\n      if (value) {\n        switch (value.__symbolic) {\n          case 'error':\n            return this.convertError(moduleName, value);\n\n          case 'reference':\n            return this.convertReference(moduleName, value);\n\n          default:\n            return this.convertExpressionNode(moduleName, value);\n        }\n      }\n\n      return value;\n    };\n\n    MetadataBundler.prototype.convertError = function (module, value) {\n      return {\n        __symbolic: 'error',\n        message: value.message,\n        line: value.line,\n        character: value.character,\n        context: value.context,\n        module: module\n      };\n    };\n\n    MetadataBundler.prototype.convertReference = function (moduleName, value) {\n      var _this = this;\n\n      var createReference = function createReference(symbol) {\n        var declaration = symbol.declaration;\n\n        if (declaration.module.startsWith('.')) {\n          // Reference to a symbol defined in the module. Ensure it is converted then return a\n          // references to the final symbol.\n          _this.convertSymbol(symbol);\n\n          return {\n            __symbolic: 'reference',\n\n            get name() {\n              // Resolved lazily because private names are assigned late.\n              var canonicalSymbol = symbol.canonicalSymbol;\n\n              if (canonicalSymbol.isPrivate == null) {\n                throw Error('Invalid state: isPrivate was not initialized');\n              }\n\n              return canonicalSymbol.isPrivate ? canonicalSymbol.privateName : canonicalSymbol.name;\n            }\n\n          };\n        } else {\n          // The symbol was a re-exported symbol from another module. Return a reference to the\n          // original imported symbol.\n          return {\n            __symbolic: 'reference',\n            name: declaration.name,\n            module: declaration.module\n          };\n        }\n      };\n\n      if (schema_1.isMetadataGlobalReferenceExpression(value)) {\n        var metadata = this.getMetadata(moduleName);\n\n        if (metadata && metadata.metadata && metadata.metadata[value.name]) {\n          // Reference to a symbol defined in the module\n          return createReference(this.canonicalSymbolOf(moduleName, value.name));\n        } // If a reference has arguments, the arguments need to be converted.\n\n\n        if (value.arguments) {\n          return {\n            __symbolic: 'reference',\n            name: value.name,\n            arguments: value.arguments.map(function (a) {\n              return _this.convertValue(moduleName, a);\n            })\n          };\n        } // Global references without arguments (such as to Math or JSON) are unmodified.\n\n\n        return value;\n      }\n\n      if (schema_1.isMetadataImportedSymbolReferenceExpression(value)) {\n        // References to imported symbols are separated into two, references to bundled modules and\n        // references to modules external to the bundle. If the module reference is relative it is\n        // assumed to be in the bundle. If it is Global it is assumed to be outside the bundle.\n        // References to symbols outside the bundle are left unmodified. References to symbol inside\n        // the bundle need to be converted to a bundle import reference reachable from the bundle\n        // index.\n        if (value.module.startsWith('.')) {\n          // Reference is to a symbol defined inside the module. Convert the reference to a reference\n          // to the canonical symbol.\n          var referencedModule = resolveModule(value.module, moduleName);\n          var referencedName = value.name;\n          return createReference(this.canonicalSymbolOf(referencedModule, referencedName));\n        } // Value is a reference to a symbol defined outside the module.\n\n\n        if (value.arguments) {\n          // If a reference has arguments the arguments need to be converted.\n          return {\n            __symbolic: 'reference',\n            name: value.name,\n            module: value.module,\n            arguments: value.arguments.map(function (a) {\n              return _this.convertValue(moduleName, a);\n            })\n          };\n        }\n\n        return value;\n      }\n\n      if (schema_1.isMetadataModuleReferenceExpression(value)) {\n        // Cannot support references to bundled modules as the internal modules of a bundle are erased\n        // by the bundler.\n        if (value.module.startsWith('.')) {\n          return {\n            __symbolic: 'error',\n            message: 'Unsupported bundled module reference',\n            context: {\n              module: value.module\n            }\n          };\n        } // References to unbundled modules are unmodified.\n\n\n        return value;\n      }\n    };\n\n    MetadataBundler.prototype.convertExpressionNode = function (moduleName, value) {\n      var result = {\n        __symbolic: value.__symbolic\n      };\n\n      for (var key in value) {\n        result[key] = this.convertValue(moduleName, value[key]);\n      }\n\n      return result;\n    };\n\n    MetadataBundler.prototype.symbolOf = function (module, name) {\n      var symbolKey = module + \":\" + name;\n      var symbol = this.symbolMap.get(symbolKey);\n\n      if (!symbol) {\n        symbol = {\n          module: module,\n          name: name\n        };\n        this.symbolMap.set(symbolKey, symbol);\n      }\n\n      return symbol;\n    };\n\n    MetadataBundler.prototype.canonicalSymbolOf = function (module, name) {\n      // Ensure the module has been seen.\n      this.exportAll(module);\n      var symbol = this.symbolOf(module, name);\n\n      if (!symbol.canonicalSymbol) {\n        this.canonicalizeSymbol(symbol);\n      }\n\n      return symbol;\n    };\n\n    return MetadataBundler;\n  }();\n\n  exports.MetadataBundler = MetadataBundler;\n\n  var CompilerHostAdapter =\n  /** @class */\n  function () {\n    function CompilerHostAdapter(host, cache, options) {\n      this.host = host;\n      this.cache = cache;\n      this.options = options;\n      this.collector = new collector_1.MetadataCollector();\n    }\n\n    CompilerHostAdapter.prototype.getMetadataFor = function (fileName, containingFile) {\n      var resolvedModule = ts.resolveModuleName(fileName, containingFile, this.options, this.host).resolvedModule;\n      var sourceFile;\n\n      if (resolvedModule) {\n        var resolvedFileName = resolvedModule.resolvedFileName;\n\n        if (resolvedModule.extension !== '.ts') {\n          resolvedFileName = resolvedFileName.replace(/(\\.d\\.ts|\\.js)$/, '.ts');\n        }\n\n        sourceFile = this.host.getSourceFile(resolvedFileName, ts.ScriptTarget.Latest);\n      } else {\n        // If typescript is unable to resolve the file, fallback on old behavior\n        if (!this.host.fileExists(fileName + '.ts')) return undefined;\n        sourceFile = this.host.getSourceFile(fileName + '.ts', ts.ScriptTarget.Latest);\n      } // If there is a metadata cache, use it to get the metadata for this source file. Otherwise,\n      // fall back on the locally created MetadataCollector.\n\n\n      if (!sourceFile) {\n        return undefined;\n      } else if (this.cache) {\n        return this.cache.getMetadata(sourceFile);\n      } else {\n        return this.collector.getMetadata(sourceFile);\n      }\n    };\n\n    return CompilerHostAdapter;\n  }();\n\n  exports.CompilerHostAdapter = CompilerHostAdapter;\n\n  function resolveModule(importName, from) {\n    if (importName.startsWith('.') && from) {\n      var normalPath = path.normalize(path.join(path.dirname(from), importName));\n\n      if (!normalPath.startsWith('.') && from.startsWith('.')) {\n        // path.normalize() preserves leading '../' but not './'. This adds it back.\n        normalPath = \".\" + path.sep + normalPath;\n      } // Replace windows path delimiters with forward-slashes. Otherwise the paths are not\n      // TypeScript compatible when building the bundle.\n\n\n      return normalPath.replace(/\\\\/g, '/');\n    }\n\n    return importName;\n  }\n\n  function isPrimitive(o) {\n    return o === null || typeof o !== 'function' && typeof o !== 'object';\n  }\n\n  function getRootExport(symbol) {\n    return symbol.reexportedAs ? getRootExport(symbol.reexportedAs) : symbol;\n  }\n\n  function getSymbolDeclaration(symbol) {\n    return symbol.exports ? getSymbolDeclaration(symbol.exports) : symbol;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/metadata/bundler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {MetadataCache} from '../transformers/metadata_cache';\n\nimport {MetadataCollector} from './collector';\nimport {ClassMetadata, ConstructorMetadata, FunctionMetadata, isClassMetadata, isConstructorMetadata, isFunctionMetadata, isInterfaceMetadata, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportedSymbolReferenceExpression, isMetadataModuleReferenceExpression, isMetadataSymbolicCallExpression, isMetadataSymbolicExpression, isMethodMetadata, MemberMetadata, METADATA_VERSION, MetadataEntry, MetadataError, MetadataMap, MetadataObject, MetadataSymbolicExpression, MetadataSymbolicReferenceExpression, MetadataValue, MethodMetadata, ModuleExportMetadata, ModuleMetadata} from './schema';\n\n\n\n// The character set used to produce private names.\nconst PRIVATE_NAME_CHARS = 'abcdefghijklmnopqrstuvwxyz';\n\ninterface Symbol {\n  module: string;\n  name: string;\n\n  // Produced by indirectly by exportAll() for symbols re-export another symbol.\n  exports?: Symbol;\n\n  // Produced by indirectly by exportAll() for symbols are re-exported by another symbol.\n  reexportedAs?: Symbol;\n\n  // Produced by canonicalizeSymbols() for all symbols. A symbol is private if it is not\n  // exported by the index.\n  isPrivate?: boolean;\n\n  // Produced by canonicalizeSymbols() for all symbols. This is the one symbol that\n  // respresents all other symbols and is the only symbol that, among all the re-exported\n  // aliases, whose fields can be trusted to contain the correct information.\n  // For private symbols this is the declaration symbol. For public symbols this is the\n  // symbol that is exported.\n  canonicalSymbol?: Symbol;\n\n  // Produced by canonicalizeSymbols() for all symbols. This the symbol that originally\n  // declared the value and should be used to fetch the value.\n  declaration?: Symbol;\n\n  // A symbol is referenced if it is exported from index or referenced by the value of\n  // a referenced symbol's value.\n  referenced?: boolean;\n\n  // A symbol is marked as a re-export the symbol was rexported from a module that is\n  // not part of the flat module bundle.\n  reexport?: boolean;\n\n  // Only valid for referenced canonical symbols. Produces by convertSymbols().\n  value?: MetadataEntry;\n\n  // Only valid for referenced private symbols. It is the name to use to import the symbol from\n  // the bundle index. Produce by assignPrivateNames();\n  privateName?: string;\n}\n\nexport interface BundleEntries {\n  [name: string]: MetadataEntry;\n}\n\nexport interface BundlePrivateEntry {\n  privateName: string;\n  name: string;\n  module: string;\n}\n\nexport interface BundledModule {\n  metadata: ModuleMetadata;\n  privates: BundlePrivateEntry[];\n}\n\nexport interface MetadataBundlerHost {\n  getMetadataFor(moduleName: string, containingFile: string): ModuleMetadata|undefined;\n}\n\ntype StaticsMetadata = {\n  [name: string]: MetadataValue|FunctionMetadata;\n};\n\nexport class MetadataBundler {\n  private symbolMap = new Map<string, Symbol>();\n  private metadataCache = new Map<string, ModuleMetadata|undefined>();\n  private exports = new Map<string, Symbol[]>();\n  private rootModule: string;\n  private privateSymbolPrefix: string;\n  // TODO(issue/24571): remove '!'.\n  private exported!: Set<Symbol>;\n\n  constructor(\n      private root: string, private importAs: string|undefined, private host: MetadataBundlerHost,\n      privateSymbolPrefix?: string) {\n    this.rootModule = `./${path.basename(root)}`;\n    this.privateSymbolPrefix = (privateSymbolPrefix || '').replace(/\\W/g, '_');\n  }\n\n  getMetadataBundle(): BundledModule {\n    // Export the root module. This also collects the transitive closure of all values referenced by\n    // the exports.\n    const exportedSymbols = this.exportAll(this.rootModule);\n    this.canonicalizeSymbols(exportedSymbols);\n    // TODO: exports? e.g. a module re-exports a symbol from another bundle\n    const metadata = this.getEntries(exportedSymbols);\n    const privates = Array.from(this.symbolMap.values())\n                         .filter(s => s.referenced && s.isPrivate)\n                         .map(s => ({\n                                privateName: s.privateName!,\n                                name: s.declaration!.name,\n                                module: s.declaration!.module\n                              }));\n    const origins = Array.from(this.symbolMap.values())\n                        .filter(s => s.referenced && !s.reexport)\n                        .reduce<{[name: string]: string}>((p, s) => {\n                          p[s.isPrivate ? s.privateName! : s.name] = s.declaration!.module;\n                          return p;\n                        }, {});\n    const exports = this.getReExports(exportedSymbols);\n    return {\n      metadata: {\n        __symbolic: 'module',\n        version: METADATA_VERSION,\n        exports: exports.length ? exports : undefined,\n        metadata,\n        origins,\n        importAs: this.importAs!\n      },\n      privates\n    };\n  }\n\n  static resolveModule(importName: string, from: string): string {\n    return resolveModule(importName, from);\n  }\n\n  private getMetadata(moduleName: string): ModuleMetadata|undefined {\n    let result = this.metadataCache.get(moduleName);\n    if (!result) {\n      if (moduleName.startsWith('.')) {\n        const fullModuleName = resolveModule(moduleName, this.root);\n        result = this.host.getMetadataFor(fullModuleName, this.root);\n      }\n      this.metadataCache.set(moduleName, result);\n    }\n    return result;\n  }\n\n  private exportAll(moduleName: string): Symbol[] {\n    const module = this.getMetadata(moduleName);\n    let result = this.exports.get(moduleName);\n\n    if (result) {\n      return result;\n    }\n\n    result = [];\n\n    const exportSymbol = (exportedSymbol: Symbol, exportAs: string) => {\n      const symbol = this.symbolOf(moduleName, exportAs);\n      result!.push(symbol);\n      exportedSymbol.reexportedAs = symbol;\n      symbol.exports = exportedSymbol;\n    };\n\n    // Export all the symbols defined in this module.\n    if (module && module.metadata) {\n      for (let key in module.metadata) {\n        const data = module.metadata[key];\n        if (isMetadataImportedSymbolReferenceExpression(data)) {\n          // This is a re-export of an imported symbol. Record this as a re-export.\n          const exportFrom = resolveModule(data.module, moduleName);\n          this.exportAll(exportFrom);\n          const symbol = this.symbolOf(exportFrom, data.name);\n          exportSymbol(symbol, key);\n        } else {\n          // Record that this symbol is exported by this module.\n          result.push(this.symbolOf(moduleName, key));\n        }\n      }\n    }\n\n    // Export all the re-exports from this module\n    if (module && module.exports) {\n      let unnamedModuleExportsIdx = 0;\n      for (const exportDeclaration of module.exports) {\n        const exportFrom = resolveModule(exportDeclaration.from, moduleName);\n        // Record all the exports from the module even if we don't use it directly.\n        const exportedSymbols = this.exportAll(exportFrom);\n        if (exportDeclaration.export) {\n          // Re-export all the named exports from a module.\n          for (const exportItem of exportDeclaration.export) {\n            const name = typeof exportItem == 'string' ? exportItem : exportItem.name;\n            const exportAs = typeof exportItem == 'string' ? exportItem : exportItem.as;\n            const symbol = this.symbolOf(exportFrom, name);\n            if (exportedSymbols && exportedSymbols.length == 1 && exportedSymbols[0].reexport &&\n                exportedSymbols[0].name == '*') {\n              // This is a named export from a module we have no metadata about. Record the named\n              // export as a re-export.\n              symbol.reexport = true;\n            }\n            exportSymbol(this.symbolOf(exportFrom, name), exportAs);\n          }\n        } else {\n          // Re-export all the symbols from the module\n          const exportedSymbols = this.exportAll(exportFrom);\n          for (const exportedSymbol of exportedSymbols) {\n            // In case the exported symbol does not have a name, we need to give it an unique\n            // name for the current module. This is necessary because there can be multiple\n            // unnamed re-exports in a given module.\n            const name = exportedSymbol.name === '*' ?\n                `unnamed_reexport_${unnamedModuleExportsIdx++}` :\n                exportedSymbol.name;\n            exportSymbol(exportedSymbol, name);\n          }\n        }\n      }\n    }\n\n    if (!module) {\n      // If no metadata is found for this import then it is considered external to the\n      // library and should be recorded as a re-export in the final metadata if it is\n      // eventually re-exported.\n      const symbol = this.symbolOf(moduleName, '*');\n      symbol.reexport = true;\n      result.push(symbol);\n    }\n    this.exports.set(moduleName, result);\n\n    return result;\n  }\n\n  /**\n   * Fill in the canonicalSymbol which is the symbol that should be imported by factories.\n   * The canonical symbol is the one exported by the index file for the bundle or definition\n   * symbol for private symbols that are not exported by bundle index.\n   */\n  private canonicalizeSymbols(exportedSymbols: Symbol[]) {\n    const symbols = Array.from(this.symbolMap.values());\n    this.exported = new Set(exportedSymbols);\n    symbols.forEach(this.canonicalizeSymbol, this);\n  }\n\n  private canonicalizeSymbol(symbol: Symbol) {\n    const rootExport = getRootExport(symbol);\n    const declaration = getSymbolDeclaration(symbol);\n    const isPrivate = !this.exported.has(rootExport);\n    const canonicalSymbol = isPrivate ? declaration : rootExport;\n    symbol.isPrivate = isPrivate;\n    symbol.declaration = declaration;\n    symbol.canonicalSymbol = canonicalSymbol;\n    symbol.reexport = declaration.reexport;\n  }\n\n  private getEntries(exportedSymbols: Symbol[]): BundleEntries {\n    const result: BundleEntries = {};\n\n    const exportedNames = new Set(exportedSymbols.map(s => s.name));\n    let privateName = 0;\n\n    function newPrivateName(prefix: string): string {\n      while (true) {\n        let digits: string[] = [];\n        let index = privateName++;\n        let base = PRIVATE_NAME_CHARS;\n        while (!digits.length || index > 0) {\n          digits.unshift(base[index % base.length]);\n          index = Math.floor(index / base.length);\n        }\n        const result = `\\u0275${prefix}${digits.join('')}`;\n        if (!exportedNames.has(result)) return result;\n      }\n    }\n\n    exportedSymbols.forEach(symbol => this.convertSymbol(symbol));\n\n    const symbolsMap = new Map<string, string[]>();\n    Array.from(this.symbolMap.values()).forEach(symbol => {\n      if (symbol.referenced && !symbol.reexport) {\n        let name = symbol.name;\n        const identifier = `${symbol.declaration!.module}:${symbol.declaration!.name}`;\n        if (symbol.isPrivate && !symbol.privateName) {\n          name = newPrivateName(this.privateSymbolPrefix);\n          symbol.privateName = name;\n        }\n        if (symbolsMap.has(identifier)) {\n          const names = symbolsMap.get(identifier);\n          names!.push(name);\n        } else {\n          symbolsMap.set(identifier, [name]);\n        }\n        result[name] = symbol.value!;\n      }\n    });\n\n    // check for duplicated entries\n    symbolsMap.forEach((names: string[], identifier: string) => {\n      if (names.length > 1) {\n        const [module, declaredName] = identifier.split(':');\n        // prefer the export that uses the declared name (if any)\n        let reference = names.indexOf(declaredName);\n        if (reference === -1) {\n          reference = 0;\n        }\n\n        // keep one entry and replace the others by references\n        names.forEach((name: string, i: number) => {\n          if (i !== reference) {\n            result[name] = {__symbolic: 'reference', name: names[reference]};\n          }\n        });\n      }\n    });\n\n    return result;\n  }\n\n  private getReExports(exportedSymbols: Symbol[]): ModuleExportMetadata[] {\n    type ExportClause = {name: string, as: string}[];\n    const modules = new Map<string, ExportClause>();\n    const exportAlls = new Set<string>();\n    for (const symbol of exportedSymbols) {\n      if (symbol.reexport) {\n        // symbol.declaration is guaranteed to be defined during the phase this method is called.\n        const declaration = symbol.declaration!;\n        const module = declaration.module;\n        if (declaration!.name == '*') {\n          // Reexport all the symbols.\n          exportAlls.add(declaration.module);\n        } else {\n          // Re-export the symbol as the exported name.\n          let entry = modules.get(module);\n          if (!entry) {\n            entry = [];\n            modules.set(module, entry);\n          }\n          const as = symbol.name;\n          const name = declaration.name;\n          entry.push({name, as});\n        }\n      }\n    }\n    return [\n      ...Array.from(exportAlls.values()).map(from => ({from})),\n      ...Array.from(modules.entries()).map(([from, exports]) => ({export: exports, from}))\n    ];\n  }\n\n  private convertSymbol(symbol: Symbol) {\n    // canonicalSymbol is ensured to be defined before this is called.\n    const canonicalSymbol = symbol.canonicalSymbol!;\n\n    if (!canonicalSymbol.referenced) {\n      canonicalSymbol.referenced = true;\n      // declaration is ensured to be definded before this method is called.\n      const declaration = canonicalSymbol.declaration!;\n      const module = this.getMetadata(declaration.module);\n      if (module) {\n        const value = module.metadata[declaration.name];\n        if (value && !declaration.name.startsWith('___')) {\n          canonicalSymbol.value = this.convertEntry(declaration.module, value);\n        }\n      }\n    }\n  }\n\n  private convertEntry(moduleName: string, value: MetadataEntry): MetadataEntry {\n    if (isClassMetadata(value)) {\n      return this.convertClass(moduleName, value);\n    }\n    if (isFunctionMetadata(value)) {\n      return this.convertFunction(moduleName, value);\n    }\n    if (isInterfaceMetadata(value)) {\n      return value;\n    }\n    return this.convertValue(moduleName, value);\n  }\n\n  private convertClass(moduleName: string, value: ClassMetadata): ClassMetadata {\n    return {\n      __symbolic: 'class',\n      arity: value.arity,\n      extends: this.convertExpression(moduleName, value.extends) !,\n      decorators:\n          value.decorators && value.decorators.map(d => this.convertExpression(moduleName, d) !),\n      members: this.convertMembers(moduleName, value.members !),\n      statics: value.statics && this.convertStatics(moduleName, value.statics)\n    };\n  }\n\n  private convertMembers(moduleName: string, members: MetadataMap): MetadataMap {\n    const result: MetadataMap = {};\n    for (const name in members) {\n      const value = members[name];\n      result[name] = value.map(v => this.convertMember(moduleName, v));\n    }\n    return result;\n  }\n\n  private convertMember(moduleName: string, member: MemberMetadata) {\n    const result: MemberMetadata = {__symbolic: member.__symbolic};\n    result.decorators =\n        member.decorators && member.decorators.map(d => this.convertExpression(moduleName, d)!);\n    if (isMethodMetadata(member)) {\n      (result as MethodMetadata).parameterDecorators = member.parameterDecorators &&\n          member.parameterDecorators.map(\n              d => d && d.map(p => this.convertExpression(moduleName, p)!));\n      if (isConstructorMetadata(member)) {\n        if (member.parameters) {\n          (result as ConstructorMetadata).parameters =\n              member.parameters.map(p => this.convertExpression(moduleName, p));\n        }\n      }\n    }\n    return result;\n  }\n\n  private convertStatics(moduleName: string, statics: StaticsMetadata): StaticsMetadata {\n    let result: StaticsMetadata = {};\n    for (const key in statics) {\n      const value = statics[key];\n\n      if (isFunctionMetadata(value)) {\n        result[key] = this.convertFunction(moduleName, value);\n      } else if (isMetadataSymbolicCallExpression(value)) {\n        // Class members can also contain static members that call a function with module\n        // references. e.g. \"static ɵprov = ɵɵdefineInjectable(..)\". We also need to\n        // convert these module references because otherwise these resolve to non-existent files.\n        result[key] = this.convertValue(moduleName, value);\n      } else {\n        result[key] = value;\n      }\n    }\n    return result;\n  }\n\n  private convertFunction(moduleName: string, value: FunctionMetadata): FunctionMetadata {\n    return {\n      __symbolic: 'function',\n      parameters: value.parameters,\n      defaults: value.defaults && value.defaults.map(v => this.convertValue(moduleName, v)),\n      value: this.convertValue(moduleName, value.value)\n    };\n  }\n\n  private convertValue(moduleName: string, value: MetadataValue): MetadataValue {\n    if (isPrimitive(value)) {\n      return value;\n    }\n    if (isMetadataError(value)) {\n      return this.convertError(moduleName, value);\n    }\n    if (isMetadataSymbolicExpression(value)) {\n      return this.convertExpression(moduleName, value)!;\n    }\n    if (Array.isArray(value)) {\n      return value.map(v => this.convertValue(moduleName, v));\n    }\n\n    // Otherwise it is a metadata object.\n    const object = value as MetadataObject;\n    const result: MetadataObject = {};\n    for (const key in object) {\n      result[key] = this.convertValue(moduleName, object[key]);\n    }\n    return result;\n  }\n\n  private convertExpression(\n      moduleName: string, value: MetadataSymbolicExpression|MetadataError|null|undefined):\n      MetadataSymbolicExpression|MetadataError|undefined|null {\n    if (value) {\n      switch (value.__symbolic) {\n        case 'error':\n          return this.convertError(moduleName, value as MetadataError);\n        case 'reference':\n          return this.convertReference(moduleName, value as MetadataSymbolicReferenceExpression);\n        default:\n          return this.convertExpressionNode(moduleName, value);\n      }\n    }\n    return value;\n  }\n\n  private convertError(module: string, value: MetadataError): MetadataError {\n    return {\n      __symbolic: 'error',\n      message: value.message,\n      line: value.line,\n      character: value.character,\n      context: value.context,\n      module\n    };\n  }\n\n  private convertReference(moduleName: string, value: MetadataSymbolicReferenceExpression):\n      MetadataSymbolicReferenceExpression|MetadataError|undefined {\n    const createReference = (symbol: Symbol): MetadataSymbolicReferenceExpression => {\n      const declaration = symbol.declaration!;\n      if (declaration.module.startsWith('.')) {\n        // Reference to a symbol defined in the module. Ensure it is converted then return a\n        // references to the final symbol.\n        this.convertSymbol(symbol);\n        return {\n          __symbolic: 'reference',\n          get name() {\n            // Resolved lazily because private names are assigned late.\n            const canonicalSymbol = symbol.canonicalSymbol!;\n            if (canonicalSymbol.isPrivate == null) {\n              throw Error('Invalid state: isPrivate was not initialized');\n            }\n            return canonicalSymbol.isPrivate ? canonicalSymbol.privateName! : canonicalSymbol.name;\n          }\n        };\n      } else {\n        // The symbol was a re-exported symbol from another module. Return a reference to the\n        // original imported symbol.\n        return {__symbolic: 'reference', name: declaration.name, module: declaration.module};\n      }\n    };\n\n    if (isMetadataGlobalReferenceExpression(value)) {\n      const metadata = this.getMetadata(moduleName);\n      if (metadata && metadata.metadata && metadata.metadata[value.name]) {\n        // Reference to a symbol defined in the module\n        return createReference(this.canonicalSymbolOf(moduleName, value.name));\n      }\n\n      // If a reference has arguments, the arguments need to be converted.\n      if (value.arguments) {\n        return {\n          __symbolic: 'reference',\n          name: value.name,\n          arguments: value.arguments.map(a => this.convertValue(moduleName, a))\n        };\n      }\n\n      // Global references without arguments (such as to Math or JSON) are unmodified.\n      return value;\n    }\n\n    if (isMetadataImportedSymbolReferenceExpression(value)) {\n      // References to imported symbols are separated into two, references to bundled modules and\n      // references to modules external to the bundle. If the module reference is relative it is\n      // assumed to be in the bundle. If it is Global it is assumed to be outside the bundle.\n      // References to symbols outside the bundle are left unmodified. References to symbol inside\n      // the bundle need to be converted to a bundle import reference reachable from the bundle\n      // index.\n\n      if (value.module.startsWith('.')) {\n        // Reference is to a symbol defined inside the module. Convert the reference to a reference\n        // to the canonical symbol.\n        const referencedModule = resolveModule(value.module, moduleName);\n        const referencedName = value.name;\n        return createReference(this.canonicalSymbolOf(referencedModule, referencedName));\n      }\n\n      // Value is a reference to a symbol defined outside the module.\n      if (value.arguments) {\n        // If a reference has arguments the arguments need to be converted.\n        return {\n          __symbolic: 'reference',\n          name: value.name,\n          module: value.module,\n          arguments: value.arguments.map(a => this.convertValue(moduleName, a))\n        };\n      }\n      return value;\n    }\n\n    if (isMetadataModuleReferenceExpression(value)) {\n      // Cannot support references to bundled modules as the internal modules of a bundle are erased\n      // by the bundler.\n      if (value.module.startsWith('.')) {\n        return {\n          __symbolic: 'error',\n          message: 'Unsupported bundled module reference',\n          context: {module: value.module}\n        };\n      }\n\n      // References to unbundled modules are unmodified.\n      return value;\n    }\n  }\n\n  private convertExpressionNode(moduleName: string, value: MetadataSymbolicExpression):\n      MetadataSymbolicExpression {\n    const result: MetadataSymbolicExpression = {__symbolic: value.__symbolic} as any;\n    for (const key in value) {\n      (result as any)[key] = this.convertValue(moduleName, (value as any)[key]);\n    }\n    return result;\n  }\n\n  private symbolOf(module: string, name: string): Symbol {\n    const symbolKey = `${module}:${name}`;\n    let symbol = this.symbolMap.get(symbolKey);\n    if (!symbol) {\n      symbol = {module, name};\n      this.symbolMap.set(symbolKey, symbol);\n    }\n    return symbol;\n  }\n\n  private canonicalSymbolOf(module: string, name: string): Symbol {\n    // Ensure the module has been seen.\n    this.exportAll(module);\n    const symbol = this.symbolOf(module, name);\n    if (!symbol.canonicalSymbol) {\n      this.canonicalizeSymbol(symbol);\n    }\n    return symbol;\n  }\n}\n\nexport class CompilerHostAdapter implements MetadataBundlerHost {\n  private collector = new MetadataCollector();\n\n  constructor(\n      private host: ts.CompilerHost, private cache: MetadataCache|null,\n      private options: ts.CompilerOptions) {}\n\n  getMetadataFor(fileName: string, containingFile: string): ModuleMetadata|undefined {\n    const {resolvedModule} =\n        ts.resolveModuleName(fileName, containingFile, this.options, this.host);\n\n    let sourceFile: ts.SourceFile|undefined;\n    if (resolvedModule) {\n      let {resolvedFileName} = resolvedModule;\n      if (resolvedModule.extension !== '.ts') {\n        resolvedFileName = resolvedFileName.replace(/(\\.d\\.ts|\\.js)$/, '.ts');\n      }\n      sourceFile = this.host.getSourceFile(resolvedFileName, ts.ScriptTarget.Latest);\n    } else {\n      // If typescript is unable to resolve the file, fallback on old behavior\n      if (!this.host.fileExists(fileName + '.ts')) return undefined;\n      sourceFile = this.host.getSourceFile(fileName + '.ts', ts.ScriptTarget.Latest);\n    }\n\n    // If there is a metadata cache, use it to get the metadata for this source file. Otherwise,\n    // fall back on the locally created MetadataCollector.\n    if (!sourceFile) {\n      return undefined;\n    } else if (this.cache) {\n      return this.cache.getMetadata(sourceFile);\n    } else {\n      return this.collector.getMetadata(sourceFile);\n    }\n  }\n}\n\nfunction resolveModule(importName: string, from: string): string {\n  if (importName.startsWith('.') && from) {\n    let normalPath = path.normalize(path.join(path.dirname(from), importName));\n    if (!normalPath.startsWith('.') && from.startsWith('.')) {\n      // path.normalize() preserves leading '../' but not './'. This adds it back.\n      normalPath = `.${path.sep}${normalPath}`;\n    }\n    // Replace windows path delimiters with forward-slashes. Otherwise the paths are not\n    // TypeScript compatible when building the bundle.\n    return normalPath.replace(/\\\\/g, '/');\n  }\n  return importName;\n}\n\nfunction isPrimitive(o: any): o is boolean|string|number {\n  return o === null || (typeof o !== 'function' && typeof o !== 'object');\n}\n\nfunction getRootExport(symbol: Symbol): Symbol {\n  return symbol.reexportedAs ? getRootExport(symbol.reexportedAs) : symbol;\n}\n\nfunction getSymbolDeclaration(symbol: Symbol): Symbol {\n  return symbol.exports ? getSymbolDeclaration(symbol.exports) : symbol;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}