{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\"; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar acorn = require(\"acorn\");\n\nvar _require = require(\"tapable\"),\n    Tapable = _require.Tapable,\n    SyncBailHook = _require.SyncBailHook,\n    HookMap = _require.HookMap;\n\nvar util = require(\"util\");\n\nvar vm = require(\"vm\");\n\nvar BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nvar StackedSetMap = require(\"./util/StackedSetMap\");\n\nvar acornParser = acorn.Parser;\n\nvar joinRanges = function joinRanges(startRange, endRange) {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n\nvar defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 11,\n  sourceType: \"module\",\n  onComment: null\n}; // regexp to match at least one \"magic comment\"\n\nvar webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nvar EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\n\nvar Parser = /*#__PURE__*/function (_Tapable) {\n  _inherits(Parser, _Tapable);\n\n  var _super = _createSuper(Parser);\n\n  function Parser(options) {\n    var _this;\n\n    var sourceType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"auto\";\n\n    _classCallCheck(this, Parser);\n\n    _this = _super.call(this);\n    _this.hooks = {\n      evaluateTypeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluate: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateDefinedIdentifier: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      evaluateCallExpressionMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\", \"param\"]);\n      }),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(function () {\n        return new SyncBailHook([\"statement\"]);\n      }),\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      export: new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationLet: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationConst: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      varDeclarationVar: new HookMap(function () {\n        return new SyncBailHook([\"declaration\"]);\n      }),\n      canRename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      rename: new HookMap(function () {\n        return new SyncBailHook([\"initExpression\"]);\n      }),\n      assigned: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      assign: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      typeof: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      callAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      new: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expression: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionAnyMember: new HookMap(function () {\n        return new SyncBailHook([\"expression\"]);\n      }),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    var HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      typeof: /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      new: /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n\n    _this._pluginCompat.tap(\"Parser\", function (options) {\n      for (var _i = 0, _Object$keys = Object.keys(HOOK_MAP_COMPAT_CONFIG); _i < _Object$keys.length; _i++) {\n        var name = _Object$keys[_i];\n        var regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        var match = regexp.exec(options.name);\n\n        if (match) {\n          if (match[1]) {\n            _this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_this)));\n          } else {\n            _this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(_assertThisInitialized(_this)));\n          }\n\n          return true;\n        }\n      }\n    });\n\n    _this.options = options;\n    _this.sourceType = sourceType;\n    _this.scope = undefined;\n    _this.state = undefined;\n    _this.comments = undefined;\n\n    _this.initializeEvaluating();\n\n    return _this;\n  }\n\n  _createClass(Parser, [{\n    key: \"initializeEvaluating\",\n    value: function initializeEvaluating() {\n      var _this2 = this;\n\n      this.hooks.evaluate.for(\"Literal\").tap(\"Parser\", function (expr) {\n        switch (typeof expr.value) {\n          case \"number\":\n            return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n\n          case \"string\":\n            return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n\n          case \"boolean\":\n            return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n        }\n\n        if (expr.value === null) {\n          return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n        }\n\n        if (expr.value instanceof RegExp) {\n          return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var leftAsBool;\n        var right;\n\n        if (expr.operator === \"&&\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === false) return left.setRange(expr.range);\n          if (leftAsBool !== true) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        } else if (expr.operator === \"||\") {\n          left = _this2.evaluateExpression(expr.left);\n          leftAsBool = left && left.asBool();\n          if (leftAsBool === true) return left.setRange(expr.range);\n          if (leftAsBool !== false) return;\n          right = _this2.evaluateExpression(expr.right);\n          return right.setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", function (expr) {\n        var left;\n        var right;\n        var res;\n\n        if (expr.operator === \"+\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n\n          if (left.isString()) {\n            if (right.isString()) {\n              res.setString(left.string + right.string);\n            } else if (right.isNumber()) {\n              res.setString(left.string + right.number);\n            } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n              // \"left\" + (\"prefix\" + inner + \"postfix\")\n              // => (\"leftprefix\" + inner + \"postfix\")\n              res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // \"left\" + ([null] + inner + \"postfix\")\n              // => (\"left\" + inner + \"postfix\")\n              res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n            } else {\n              // \"left\" + expr\n              // => (\"left\" + expr + \"\")\n              res.setWrapped(left, null, [right]);\n            }\n          } else if (left.isNumber()) {\n            if (right.isString()) {\n              res.setString(left.number + right.string);\n            } else if (right.isNumber()) {\n              res.setNumber(left.number + right.number);\n            } else {\n              return;\n            }\n          } else if (left.isWrapped()) {\n            if (left.postfix && left.postfix.isString() && right.isString()) {\n              // (\"prefix\" + inner + \"postfix\") + \"right\"\n              // => (\"prefix\" + inner + \"postfixright\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n              // (\"prefix\" + inner + \"postfix\") + 123\n              // => (\"prefix\" + inner + \"postfix123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n            } else if (right.isString()) {\n              // (\"prefix\" + inner + [null]) + \"right\"\n              // => (\"prefix\" + inner + \"right\")\n              res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n            } else if (right.isNumber()) {\n              // (\"prefix\" + inner + [null]) + 123\n              // => (\"prefix\" + inner + \"123\")\n              res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n            } else if (right.isWrapped()) {\n              // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n              // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n              res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n            } else {\n              // (\"prefix\" + inner + postfix) + expr\n              // => (\"prefix\" + inner + postfix + expr + [null])\n              res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n            }\n          } else {\n            if (right.isString()) {\n              // left + \"right\"\n              // => ([null] + left + \"right\")\n              res.setWrapped(null, right, [left]);\n            } else if (right.isWrapped()) {\n              // left + (prefix + inner + \"postfix\")\n              // => ([null] + left + prefix + inner + \"postfix\")\n              res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n            } else {\n              return;\n            }\n          }\n\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"-\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number - right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"*\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number * right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"/\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number / right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"**\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(Math.pow(left.number, right.number));\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string === right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number === right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool === right.bool);\n          }\n        } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          res = new BasicEvaluatedExpression();\n          res.setRange(expr.range);\n\n          if (left.isString() && right.isString()) {\n            return res.setBoolean(left.string !== right.string);\n          } else if (left.isNumber() && right.isNumber()) {\n            return res.setBoolean(left.number !== right.number);\n          } else if (left.isBoolean() && right.isBoolean()) {\n            return res.setBoolean(left.bool !== right.bool);\n          }\n        } else if (expr.operator === \"&\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number & right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"|\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number | right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"^\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number ^ right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >>> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \">>\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number >> right.number);\n          res.setRange(expr.range);\n          return res;\n        } else if (expr.operator === \"<<\") {\n          left = _this2.evaluateExpression(expr.left);\n          right = _this2.evaluateExpression(expr.right);\n          if (!left || !right) return;\n          if (!left.isNumber() || !right.isNumber()) return;\n          res = new BasicEvaluatedExpression();\n          res.setNumber(left.number << right.number);\n          res.setRange(expr.range);\n          return res;\n        }\n      });\n      this.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", function (expr) {\n        if (expr.operator === \"typeof\") {\n          var res;\n          var name;\n\n          if (expr.argument.type === \"Identifier\") {\n            name = _this2.scope.renames.get(expr.argument.name) || expr.argument.name;\n\n            if (!_this2.scope.definitions.has(name)) {\n              var hook = _this2.hooks.evaluateTypeof.get(name);\n\n              if (hook !== undefined) {\n                res = hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n\n          if (expr.argument.type === \"MemberExpression\") {\n            var exprName = _this2.getNameForExpression(expr.argument);\n\n            if (exprName && exprName.free) {\n              var _hook = _this2.hooks.evaluateTypeof.get(exprName.name);\n\n              if (_hook !== undefined) {\n                res = _hook.call(expr);\n                if (res !== undefined) return res;\n              }\n            }\n          }\n\n          if (expr.argument.type === \"FunctionExpression\") {\n            return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n          }\n\n          var arg = _this2.evaluateExpression(expr.argument);\n\n          if (arg.isString() || arg.isWrapped()) {\n            return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n          }\n\n          if (arg.isNumber()) {\n            return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n          }\n\n          if (arg.isBoolean()) {\n            return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n          }\n\n          if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n            return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n          }\n        } else if (expr.operator === \"!\") {\n          var argument = _this2.evaluateExpression(expr.argument);\n\n          if (!argument) return;\n\n          if (argument.isBoolean()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n          }\n\n          if (argument.isTruthy()) {\n            return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n          }\n\n          if (argument.isFalsy()) {\n            return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n          }\n\n          if (argument.isString()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n          }\n\n          if (argument.isNumber()) {\n            return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n          }\n        } else if (expr.operator === \"~\") {\n          var _argument = _this2.evaluateExpression(expr.argument);\n\n          if (!_argument) return;\n          if (!_argument.isNumber()) return;\n\n          var _res = new BasicEvaluatedExpression();\n\n          _res.setNumber(~_argument.number);\n\n          _res.setRange(expr.range);\n\n          return _res;\n        }\n      });\n      this.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", function (expr) {\n        return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(expr.name) || expr.name;\n\n        if (!_this2.scope.definitions.has(expr.name)) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        } else {\n          var _hook2 = _this2.hooks.evaluateDefinedIdentifier.get(name);\n\n          if (_hook2 !== undefined) {\n            return _hook2.call(expr);\n          }\n        }\n      });\n      this.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", function (expr) {\n        var name = _this2.scope.renames.get(\"this\");\n\n        if (name) {\n          var hook = _this2.hooks.evaluateIdentifier.get(name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expr);\n            if (result) return result;\n          }\n\n          return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", function (expression) {\n        var exprName = _this2.getNameForExpression(expression);\n\n        if (exprName) {\n          if (exprName.free) {\n            var hook = _this2.hooks.evaluateIdentifier.get(exprName.name);\n\n            if (hook !== undefined) {\n              var result = hook.call(expression);\n              if (result) return result;\n            }\n\n            return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n          } else {\n            var _hook3 = _this2.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\n            if (_hook3 !== undefined) {\n              return _hook3.call(expression);\n            }\n          }\n        }\n      });\n      this.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", function (expr) {\n        if (expr.callee.type !== \"MemberExpression\") return;\n        if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n\n        var param = _this2.evaluateExpression(expr.callee.object);\n\n        if (!param) return;\n        var property = expr.callee.property.name || expr.callee.property.value;\n\n        var hook = _this2.hooks.evaluateCallExpressionMember.get(property);\n\n        if (hook !== undefined) {\n          return hook.call(expr, param);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 2) return;\n\n        var arg1 = _this2.evaluateExpression(expr.arguments[0]);\n\n        var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n\n        if (!arg1.isString() && !arg1.isRegExp()) return;\n        arg1 = arg1.regExp || arg1.string;\n        if (!arg2.isString()) return;\n        arg2 = arg2.string;\n        return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n      });\n      [\"substr\", \"substring\"].forEach(function (fn) {\n        _this2.hooks.evaluateCallExpressionMember.for(fn).tap(\"Parser\", function (expr, param) {\n          if (!param.isString()) return;\n          var arg1;\n          var result,\n              str = param.string;\n\n          switch (expr.arguments.length) {\n            case 1:\n              arg1 = _this2.evaluateExpression(expr.arguments[0]);\n              if (!arg1.isNumber()) return;\n              result = str[fn](arg1.number);\n              break;\n\n            case 2:\n              {\n                arg1 = _this2.evaluateExpression(expr.arguments[0]);\n\n                var arg2 = _this2.evaluateExpression(expr.arguments[1]);\n\n                if (!arg1.isNumber()) return;\n                if (!arg2.isNumber()) return;\n                result = str[fn](arg1.number, arg2.number);\n                break;\n              }\n\n            default:\n              return;\n          }\n\n          return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n        });\n      });\n      /**\n       * @param {string} kind \"cooked\" | \"raw\"\n       * @param {TODO} templateLiteralExpr TemplateLiteral expr\n       * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n       */\n\n      var getSimplifiedTemplateResult = function getSimplifiedTemplateResult(kind, templateLiteralExpr) {\n        var quasis = [];\n        var parts = [];\n\n        for (var i = 0; i < templateLiteralExpr.quasis.length; i++) {\n          var quasiExpr = templateLiteralExpr.quasis[i];\n          var quasi = quasiExpr.value[kind];\n\n          if (i > 0) {\n            var prevExpr = parts[parts.length - 1];\n\n            var expr = _this2.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n\n            var exprAsString = expr.asString();\n\n            if (typeof exprAsString === \"string\") {\n              // We can merge quasi + expr + quasi when expr\n              // is a const string\n              prevExpr.setString(prevExpr.string + exprAsString + quasi);\n              prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression\n\n              prevExpr.setExpression(undefined);\n              continue;\n            }\n\n            parts.push(expr);\n          }\n\n          var part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n          quasis.push(part);\n          parts.push(part);\n        }\n\n        return {\n          quasis: quasis,\n          parts: parts\n        };\n      };\n\n      this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", function (node) {\n        var _getSimplifiedTemplat = getSimplifiedTemplateResult(\"cooked\", node),\n            quasis = _getSimplifiedTemplat.quasis,\n            parts = _getSimplifiedTemplat.parts;\n\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n      });\n      this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", function (node) {\n        if (_this2.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n\n        var _getSimplifiedTemplat2 = getSimplifiedTemplateResult(\"raw\", node.quasi),\n            quasis = _getSimplifiedTemplat2.quasis,\n            parts = _getSimplifiedTemplat2.parts;\n\n        if (parts.length === 1) {\n          return parts[0].setRange(node.range);\n        }\n\n        return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString() && !param.isWrapped()) return;\n        var stringSuffix = null;\n        var hasUnknownParams = false;\n\n        for (var i = expr.arguments.length - 1; i >= 0; i--) {\n          var argExpr = _this2.evaluateExpression(expr.arguments[i]);\n\n          if (!argExpr.isString() && !argExpr.isNumber()) {\n            hasUnknownParams = true;\n            break;\n          }\n\n          var value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n          var newString = value + (stringSuffix ? stringSuffix.string : \"\");\n          var newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n          stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n        }\n\n        if (hasUnknownParams) {\n          var prefix = param.isString() ? param : param.prefix;\n          return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n        } else if (param.isWrapped()) {\n          var postfix = stringSuffix || param.postfix;\n          return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n        } else {\n          var _newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n\n          return new BasicEvaluatedExpression().setString(_newString).setRange(expr.range);\n        }\n      });\n      this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"Parser\", function (expr, param) {\n        if (!param.isString()) return;\n        if (expr.arguments.length !== 1) return;\n        var result;\n\n        var arg = _this2.evaluateExpression(expr.arguments[0]);\n\n        if (arg.isString()) {\n          result = param.string.split(arg.string);\n        } else if (arg.isRegExp()) {\n          result = param.string.split(arg.regExp);\n        } else {\n          return;\n        }\n\n        return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n      });\n      this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", function (expr) {\n        var condition = _this2.evaluateExpression(expr.test);\n\n        var conditionValue = condition.asBool();\n        var res;\n\n        if (conditionValue === undefined) {\n          var consequent = _this2.evaluateExpression(expr.consequent);\n\n          var alternate = _this2.evaluateExpression(expr.alternate);\n\n          if (!consequent || !alternate) return;\n          res = new BasicEvaluatedExpression();\n\n          if (consequent.isConditional()) {\n            res.setOptions(consequent.options);\n          } else {\n            res.setOptions([consequent]);\n          }\n\n          if (alternate.isConditional()) {\n            res.addOptions(alternate.options);\n          } else {\n            res.addOptions([alternate]);\n          }\n        } else {\n          res = _this2.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n        }\n\n        res.setRange(expr.range);\n        return res;\n      });\n      this.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", function (expr) {\n        var items = expr.elements.map(function (element) {\n          return element !== null && _this2.evaluateExpression(element);\n        });\n        if (!items.every(Boolean)) return;\n        return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n      });\n    }\n  }, {\n    key: \"getRenameIdentifier\",\n    value: function getRenameIdentifier(expr) {\n      var result = this.evaluateExpression(expr);\n\n      if (result && result.isIdentifier()) {\n        return result.identifier;\n      }\n    }\n  }, {\n    key: \"walkClass\",\n    value: function walkClass(classy) {\n      if (classy.superClass) this.walkExpression(classy.superClass);\n\n      if (classy.body && classy.body.type === \"ClassBody\") {\n        var wasTopLevel = this.scope.topLevelScope;\n        this.scope.topLevelScope = false;\n\n        var _iterator = _createForOfIteratorHelper(classy.body.body),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var methodDefinition = _step.value;\n\n            if (methodDefinition.type === \"MethodDefinition\") {\n              this.walkMethodDefinition(methodDefinition);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.scope.topLevelScope = wasTopLevel;\n      }\n    }\n  }, {\n    key: \"walkMethodDefinition\",\n    value: function walkMethodDefinition(methodDefinition) {\n      if (methodDefinition.computed && methodDefinition.key) {\n        this.walkExpression(methodDefinition.key);\n      }\n\n      if (methodDefinition.value) {\n        this.walkExpression(methodDefinition.value);\n      }\n    } // Prewalking iterates the scope for variable declarations\n\n  }, {\n    key: \"prewalkStatements\",\n    value: function prewalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.prewalkStatement(statement);\n      }\n    } // Block-Prewalking iterates the scope for block variable declarations\n\n  }, {\n    key: \"blockPrewalkStatements\",\n    value: function blockPrewalkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.blockPrewalkStatement(statement);\n      }\n    } // Walking iterates the statements and expressions and processes them\n\n  }, {\n    key: \"walkStatements\",\n    value: function walkStatements(statements) {\n      for (var index = 0, len = statements.length; index < len; index++) {\n        var statement = statements[index];\n        this.walkStatement(statement);\n      }\n    }\n  }, {\n    key: \"prewalkStatement\",\n    value: function prewalkStatement(statement) {\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.prewalkBlockStatement(statement);\n          break;\n\n        case \"DoWhileStatement\":\n          this.prewalkDoWhileStatement(statement);\n          break;\n\n        case \"ExportAllDeclaration\":\n          this.prewalkExportAllDeclaration(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.prewalkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.prewalkExportNamedDeclaration(statement);\n          break;\n\n        case \"ForInStatement\":\n          this.prewalkForInStatement(statement);\n          break;\n\n        case \"ForOfStatement\":\n          this.prewalkForOfStatement(statement);\n          break;\n\n        case \"ForStatement\":\n          this.prewalkForStatement(statement);\n          break;\n\n        case \"FunctionDeclaration\":\n          this.prewalkFunctionDeclaration(statement);\n          break;\n\n        case \"IfStatement\":\n          this.prewalkIfStatement(statement);\n          break;\n\n        case \"ImportDeclaration\":\n          this.prewalkImportDeclaration(statement);\n          break;\n\n        case \"LabeledStatement\":\n          this.prewalkLabeledStatement(statement);\n          break;\n\n        case \"SwitchStatement\":\n          this.prewalkSwitchStatement(statement);\n          break;\n\n        case \"TryStatement\":\n          this.prewalkTryStatement(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.prewalkVariableDeclaration(statement);\n          break;\n\n        case \"WhileStatement\":\n          this.prewalkWhileStatement(statement);\n          break;\n\n        case \"WithStatement\":\n          this.prewalkWithStatement(statement);\n          break;\n      }\n    }\n  }, {\n    key: \"blockPrewalkStatement\",\n    value: function blockPrewalkStatement(statement) {\n      switch (statement.type) {\n        case \"VariableDeclaration\":\n          this.blockPrewalkVariableDeclaration(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.blockPrewalkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.blockPrewalkExportNamedDeclaration(statement);\n          break;\n\n        case \"ClassDeclaration\":\n          this.blockPrewalkClassDeclaration(statement);\n          break;\n      }\n    }\n  }, {\n    key: \"walkStatement\",\n    value: function walkStatement(statement) {\n      if (this.hooks.statement.call(statement) !== undefined) return;\n\n      switch (statement.type) {\n        case \"BlockStatement\":\n          this.walkBlockStatement(statement);\n          break;\n\n        case \"ClassDeclaration\":\n          this.walkClassDeclaration(statement);\n          break;\n\n        case \"DoWhileStatement\":\n          this.walkDoWhileStatement(statement);\n          break;\n\n        case \"ExportDefaultDeclaration\":\n          this.walkExportDefaultDeclaration(statement);\n          break;\n\n        case \"ExportNamedDeclaration\":\n          this.walkExportNamedDeclaration(statement);\n          break;\n\n        case \"ExpressionStatement\":\n          this.walkExpressionStatement(statement);\n          break;\n\n        case \"ForInStatement\":\n          this.walkForInStatement(statement);\n          break;\n\n        case \"ForOfStatement\":\n          this.walkForOfStatement(statement);\n          break;\n\n        case \"ForStatement\":\n          this.walkForStatement(statement);\n          break;\n\n        case \"FunctionDeclaration\":\n          this.walkFunctionDeclaration(statement);\n          break;\n\n        case \"IfStatement\":\n          this.walkIfStatement(statement);\n          break;\n\n        case \"LabeledStatement\":\n          this.walkLabeledStatement(statement);\n          break;\n\n        case \"ReturnStatement\":\n          this.walkReturnStatement(statement);\n          break;\n\n        case \"SwitchStatement\":\n          this.walkSwitchStatement(statement);\n          break;\n\n        case \"ThrowStatement\":\n          this.walkThrowStatement(statement);\n          break;\n\n        case \"TryStatement\":\n          this.walkTryStatement(statement);\n          break;\n\n        case \"VariableDeclaration\":\n          this.walkVariableDeclaration(statement);\n          break;\n\n        case \"WhileStatement\":\n          this.walkWhileStatement(statement);\n          break;\n\n        case \"WithStatement\":\n          this.walkWithStatement(statement);\n          break;\n      }\n    } // Real Statements\n\n  }, {\n    key: \"prewalkBlockStatement\",\n    value: function prewalkBlockStatement(statement) {\n      this.prewalkStatements(statement.body);\n    }\n  }, {\n    key: \"walkBlockStatement\",\n    value: function walkBlockStatement(statement) {\n      var _this3 = this;\n\n      this.inBlockScope(function () {\n        var body = statement.body;\n\n        _this3.blockPrewalkStatements(body);\n\n        _this3.walkStatements(body);\n      });\n    }\n  }, {\n    key: \"walkExpressionStatement\",\n    value: function walkExpressionStatement(statement) {\n      this.walkExpression(statement.expression);\n    }\n  }, {\n    key: \"prewalkIfStatement\",\n    value: function prewalkIfStatement(statement) {\n      this.prewalkStatement(statement.consequent);\n\n      if (statement.alternate) {\n        this.prewalkStatement(statement.alternate);\n      }\n    }\n  }, {\n    key: \"walkIfStatement\",\n    value: function walkIfStatement(statement) {\n      var result = this.hooks.statementIf.call(statement);\n\n      if (result === undefined) {\n        this.walkExpression(statement.test);\n        this.walkStatement(statement.consequent);\n\n        if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkStatement(statement.consequent);\n        } else if (statement.alternate) {\n          this.walkStatement(statement.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"prewalkLabeledStatement\",\n    value: function prewalkLabeledStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkLabeledStatement\",\n    value: function walkLabeledStatement(statement) {\n      var hook = this.hooks.label.get(statement.label.name);\n\n      if (hook !== undefined) {\n        var result = hook.call(statement);\n        if (result === true) return;\n      }\n\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkWithStatement\",\n    value: function prewalkWithStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWithStatement\",\n    value: function walkWithStatement(statement) {\n      this.walkExpression(statement.object);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkSwitchStatement\",\n    value: function prewalkSwitchStatement(statement) {\n      this.prewalkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkSwitchStatement\",\n    value: function walkSwitchStatement(statement) {\n      this.walkExpression(statement.discriminant);\n      this.walkSwitchCases(statement.cases);\n    }\n  }, {\n    key: \"walkTerminatingStatement\",\n    value: function walkTerminatingStatement(statement) {\n      if (statement.argument) this.walkExpression(statement.argument);\n    }\n  }, {\n    key: \"walkReturnStatement\",\n    value: function walkReturnStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"walkThrowStatement\",\n    value: function walkThrowStatement(statement) {\n      this.walkTerminatingStatement(statement);\n    }\n  }, {\n    key: \"prewalkTryStatement\",\n    value: function prewalkTryStatement(statement) {\n      this.prewalkStatement(statement.block);\n    }\n  }, {\n    key: \"walkTryStatement\",\n    value: function walkTryStatement(statement) {\n      if (this.scope.inTry) {\n        this.walkStatement(statement.block);\n      } else {\n        this.scope.inTry = true;\n        this.walkStatement(statement.block);\n        this.scope.inTry = false;\n      }\n\n      if (statement.handler) this.walkCatchClause(statement.handler);\n      if (statement.finalizer) this.walkStatement(statement.finalizer);\n    }\n  }, {\n    key: \"prewalkWhileStatement\",\n    value: function prewalkWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkWhileStatement\",\n    value: function walkWhileStatement(statement) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.body);\n    }\n  }, {\n    key: \"prewalkDoWhileStatement\",\n    value: function prewalkDoWhileStatement(statement) {\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkDoWhileStatement\",\n    value: function walkDoWhileStatement(statement) {\n      this.walkStatement(statement.body);\n      this.walkExpression(statement.test);\n    }\n  }, {\n    key: \"prewalkForStatement\",\n    value: function prewalkForStatement(statement) {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.prewalkStatement(statement.init);\n        }\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForStatement\",\n    value: function walkForStatement(statement) {\n      var _this4 = this;\n\n      this.inBlockScope(function () {\n        if (statement.init) {\n          if (statement.init.type === \"VariableDeclaration\") {\n            _this4.blockPrewalkVariableDeclaration(statement.init);\n\n            _this4.walkStatement(statement.init);\n          } else {\n            _this4.walkExpression(statement.init);\n          }\n        }\n\n        if (statement.test) {\n          _this4.walkExpression(statement.test);\n        }\n\n        if (statement.update) {\n          _this4.walkExpression(statement.update);\n        }\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this4.blockPrewalkStatements(body.body);\n\n          _this4.walkStatements(body.body);\n        } else {\n          _this4.walkStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"prewalkForInStatement\",\n    value: function prewalkForInStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForInStatement\",\n    value: function walkForInStatement(statement) {\n      var _this5 = this;\n\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this5.blockPrewalkVariableDeclaration(statement.left);\n\n          _this5.walkVariableDeclaration(statement.left);\n        } else {\n          _this5.walkPattern(statement.left);\n        }\n\n        _this5.walkExpression(statement.right);\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this5.blockPrewalkStatements(body.body);\n\n          _this5.walkStatements(body.body);\n        } else {\n          _this5.walkStatement(body);\n        }\n      });\n    }\n  }, {\n    key: \"prewalkForOfStatement\",\n    value: function prewalkForOfStatement(statement) {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.prewalkVariableDeclaration(statement.left);\n      }\n\n      this.prewalkStatement(statement.body);\n    }\n  }, {\n    key: \"walkForOfStatement\",\n    value: function walkForOfStatement(statement) {\n      var _this6 = this;\n\n      this.inBlockScope(function () {\n        if (statement.left.type === \"VariableDeclaration\") {\n          _this6.blockPrewalkVariableDeclaration(statement.left);\n\n          _this6.walkVariableDeclaration(statement.left);\n        } else {\n          _this6.walkPattern(statement.left);\n        }\n\n        _this6.walkExpression(statement.right);\n\n        var body = statement.body;\n\n        if (body.type === \"BlockStatement\") {\n          // no need to add additional scope\n          _this6.blockPrewalkStatements(body.body);\n\n          _this6.walkStatements(body.body);\n        } else {\n          _this6.walkStatement(body);\n        }\n      });\n    } // Declarations\n\n  }, {\n    key: \"prewalkFunctionDeclaration\",\n    value: function prewalkFunctionDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkFunctionDeclaration\",\n    value: function walkFunctionDeclaration(statement) {\n      var _this7 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      this.inFunctionScope(true, statement.params, function () {\n        var _iterator2 = _createForOfIteratorHelper(statement.params),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var param = _step2.value;\n\n            _this7.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        if (statement.body.type === \"BlockStatement\") {\n          _this7.detectMode(statement.body.body);\n\n          _this7.prewalkStatement(statement.body);\n\n          _this7.walkStatement(statement.body);\n        } else {\n          _this7.walkExpression(statement.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"prewalkImportDeclaration\",\n    value: function prewalkImportDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.import.call(statement, source);\n\n      var _iterator3 = _createForOfIteratorHelper(statement.specifiers),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var specifier = _step3.value;\n          var name = specifier.local.name;\n          this.scope.renames.set(name, null);\n          this.scope.definitions.add(name);\n\n          switch (specifier.type) {\n            case \"ImportDefaultSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, \"default\", name);\n              break;\n\n            case \"ImportSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n              break;\n\n            case \"ImportNamespaceSpecifier\":\n              this.hooks.importSpecifier.call(statement, source, null, name);\n              break;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"enterDeclaration\",\n    value: function enterDeclaration(declaration, onIdent) {\n      switch (declaration.type) {\n        case \"VariableDeclaration\":\n          var _iterator4 = _createForOfIteratorHelper(declaration.declarations),\n              _step4;\n\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var declarator = _step4.value;\n\n              switch (declarator.type) {\n                case \"VariableDeclarator\":\n                  {\n                    this.enterPattern(declarator.id, onIdent);\n                    break;\n                  }\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n\n          break;\n\n        case \"FunctionDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n\n        case \"ClassDeclaration\":\n          this.enterPattern(declaration.id, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"blockPrewalkExportNamedDeclaration\",\n    value: function blockPrewalkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.blockPrewalkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"prewalkExportNamedDeclaration\",\n    value: function prewalkExportNamedDeclaration(statement) {\n      var _this8 = this;\n\n      var source;\n\n      if (statement.source) {\n        source = statement.source.value;\n        this.hooks.exportImport.call(statement, source);\n      } else {\n        this.hooks.export.call(statement);\n      }\n\n      if (statement.declaration) {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.prewalkStatement(statement.declaration);\n          var index = 0;\n          this.enterDeclaration(statement.declaration, function (def) {\n            _this8.hooks.exportSpecifier.call(statement, def, def, index++);\n          });\n        }\n      }\n\n      if (statement.specifiers) {\n        for (var specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n          var specifier = statement.specifiers[specifierIndex];\n\n          switch (specifier.type) {\n            case \"ExportSpecifier\":\n              {\n                var name = specifier.exported.name;\n\n                if (source) {\n                  this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n                } else {\n                  this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n                }\n\n                break;\n              }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"walkExportNamedDeclaration\",\n    value: function walkExportNamedDeclaration(statement) {\n      if (statement.declaration) {\n        this.walkStatement(statement.declaration);\n      }\n    }\n  }, {\n    key: \"blockPrewalkExportDefaultDeclaration\",\n    value: function blockPrewalkExportDefaultDeclaration(statement) {\n      if (statement.declaration.type === \"ClassDeclaration\") {\n        this.blockPrewalkClassDeclaration(statement.declaration);\n      }\n    }\n  }, {\n    key: \"prewalkExportDefaultDeclaration\",\n    value: function prewalkExportDefaultDeclaration(statement) {\n      this.prewalkStatement(statement.declaration);\n\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\");\n      }\n    }\n  }, {\n    key: \"walkExportDefaultDeclaration\",\n    value: function walkExportDefaultDeclaration(statement) {\n      this.hooks.export.call(statement);\n\n      if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n        if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n          this.walkStatement(statement.declaration);\n        }\n      } else {\n        // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n        // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n        // These nodes must be treated as expressions.\n        if (statement.declaration.type === \"FunctionDeclaration\") {\n          this.walkFunctionDeclaration(statement.declaration);\n        } else if (statement.declaration.type === \"ClassDeclaration\") {\n          this.walkClassDeclaration(statement.declaration);\n        } else {\n          this.walkExpression(statement.declaration);\n        }\n\n        if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n          this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n        }\n      }\n    }\n  }, {\n    key: \"prewalkExportAllDeclaration\",\n    value: function prewalkExportAllDeclaration(statement) {\n      var source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n      this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n    }\n  }, {\n    key: \"prewalkVariableDeclaration\",\n    value: function prewalkVariableDeclaration(statement) {\n      if (statement.kind !== \"var\") return;\n\n      this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n    }\n  }, {\n    key: \"blockPrewalkVariableDeclaration\",\n    value: function blockPrewalkVariableDeclaration(statement) {\n      if (statement.kind === \"var\") return;\n      var hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n\n      this._prewalkVariableDeclaration(statement, hookMap);\n    }\n  }, {\n    key: \"_prewalkVariableDeclaration\",\n    value: function _prewalkVariableDeclaration(statement, hookMap) {\n      var _this9 = this;\n\n      var _iterator5 = _createForOfIteratorHelper(statement.declarations),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var declarator = _step5.value;\n\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, function (name, decl) {\n                  var hook = hookMap.get(name);\n\n                  if (hook === undefined || !hook.call(decl)) {\n                    hook = _this9.hooks.varDeclaration.get(name);\n\n                    if (hook === undefined || !hook.call(decl)) {\n                      _this9.scope.renames.set(name, null);\n\n                      _this9.scope.definitions.add(name);\n                    }\n                  }\n                });\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  }, {\n    key: \"walkVariableDeclaration\",\n    value: function walkVariableDeclaration(statement) {\n      var _iterator6 = _createForOfIteratorHelper(statement.declarations),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var declarator = _step6.value;\n\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                var renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n\n                if (renameIdentifier && declarator.id.type === \"Identifier\") {\n                  var hook = this.hooks.canRename.get(renameIdentifier);\n\n                  if (hook !== undefined && hook.call(declarator.init)) {\n                    // renaming with \"var a = b;\"\n                    var _hook4 = this.hooks.rename.get(renameIdentifier);\n\n                    if (_hook4 === undefined || !_hook4.call(declarator.init)) {\n                      this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                      this.scope.definitions.delete(declarator.id.name);\n                    }\n\n                    break;\n                  }\n                }\n\n                this.walkPattern(declarator.id);\n                if (declarator.init) this.walkExpression(declarator.init);\n                break;\n              }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"blockPrewalkClassDeclaration\",\n    value: function blockPrewalkClassDeclaration(statement) {\n      if (statement.id) {\n        this.scope.renames.set(statement.id.name, null);\n        this.scope.definitions.add(statement.id.name);\n      }\n    }\n  }, {\n    key: \"walkClassDeclaration\",\n    value: function walkClassDeclaration(statement) {\n      this.walkClass(statement);\n    }\n  }, {\n    key: \"prewalkSwitchCases\",\n    value: function prewalkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n        this.prewalkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkSwitchCases\",\n    value: function walkSwitchCases(switchCases) {\n      for (var index = 0, len = switchCases.length; index < len; index++) {\n        var switchCase = switchCases[index];\n\n        if (switchCase.test) {\n          this.walkExpression(switchCase.test);\n        }\n\n        this.walkStatements(switchCase.consequent);\n      }\n    }\n  }, {\n    key: \"walkCatchClause\",\n    value: function walkCatchClause(catchClause) {\n      var _this10 = this;\n\n      this.inBlockScope(function () {\n        // Error binding is optional in catch clause since ECMAScript 2019\n        if (catchClause.param !== null) {\n          _this10.enterPattern(catchClause.param, function (ident) {\n            _this10.scope.renames.set(ident, null);\n\n            _this10.scope.definitions.add(ident);\n          });\n\n          _this10.walkPattern(catchClause.param);\n        }\n\n        _this10.prewalkStatement(catchClause.body);\n\n        _this10.walkStatement(catchClause.body);\n      });\n    }\n  }, {\n    key: \"walkPattern\",\n    value: function walkPattern(pattern) {\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.walkArrayPattern(pattern);\n          break;\n\n        case \"AssignmentPattern\":\n          this.walkAssignmentPattern(pattern);\n          break;\n\n        case \"MemberExpression\":\n          this.walkMemberExpression(pattern);\n          break;\n\n        case \"ObjectPattern\":\n          this.walkObjectPattern(pattern);\n          break;\n\n        case \"RestElement\":\n          this.walkRestElement(pattern);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAssignmentPattern\",\n    value: function walkAssignmentPattern(pattern) {\n      this.walkExpression(pattern.right);\n      this.walkPattern(pattern.left);\n    }\n  }, {\n    key: \"walkObjectPattern\",\n    value: function walkObjectPattern(pattern) {\n      for (var i = 0, len = pattern.properties.length; i < len; i++) {\n        var prop = pattern.properties[i];\n\n        if (prop) {\n          if (prop.computed) this.walkExpression(prop.key);\n          if (prop.value) this.walkPattern(prop.value);\n        }\n      }\n    }\n  }, {\n    key: \"walkArrayPattern\",\n    value: function walkArrayPattern(pattern) {\n      for (var i = 0, len = pattern.elements.length; i < len; i++) {\n        var element = pattern.elements[i];\n        if (element) this.walkPattern(element);\n      }\n    }\n  }, {\n    key: \"walkRestElement\",\n    value: function walkRestElement(pattern) {\n      this.walkPattern(pattern.argument);\n    }\n  }, {\n    key: \"walkExpressions\",\n    value: function walkExpressions(expressions) {\n      var _iterator7 = _createForOfIteratorHelper(expressions),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var expression = _step7.value;\n\n          if (expression) {\n            this.walkExpression(expression);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }, {\n    key: \"walkExpression\",\n    value: function walkExpression(expression) {\n      switch (expression.type) {\n        case \"ArrayExpression\":\n          this.walkArrayExpression(expression);\n          break;\n\n        case \"ArrowFunctionExpression\":\n          this.walkArrowFunctionExpression(expression);\n          break;\n\n        case \"AssignmentExpression\":\n          this.walkAssignmentExpression(expression);\n          break;\n\n        case \"AwaitExpression\":\n          this.walkAwaitExpression(expression);\n          break;\n\n        case \"BinaryExpression\":\n          this.walkBinaryExpression(expression);\n          break;\n\n        case \"CallExpression\":\n          this.walkCallExpression(expression);\n          break;\n\n        case \"ClassExpression\":\n          this.walkClassExpression(expression);\n          break;\n\n        case \"ConditionalExpression\":\n          this.walkConditionalExpression(expression);\n          break;\n\n        case \"FunctionExpression\":\n          this.walkFunctionExpression(expression);\n          break;\n\n        case \"Identifier\":\n          this.walkIdentifier(expression);\n          break;\n\n        case \"LogicalExpression\":\n          this.walkLogicalExpression(expression);\n          break;\n\n        case \"MemberExpression\":\n          this.walkMemberExpression(expression);\n          break;\n\n        case \"NewExpression\":\n          this.walkNewExpression(expression);\n          break;\n\n        case \"ObjectExpression\":\n          this.walkObjectExpression(expression);\n          break;\n\n        case \"SequenceExpression\":\n          this.walkSequenceExpression(expression);\n          break;\n\n        case \"SpreadElement\":\n          this.walkSpreadElement(expression);\n          break;\n\n        case \"TaggedTemplateExpression\":\n          this.walkTaggedTemplateExpression(expression);\n          break;\n\n        case \"TemplateLiteral\":\n          this.walkTemplateLiteral(expression);\n          break;\n\n        case \"ThisExpression\":\n          this.walkThisExpression(expression);\n          break;\n\n        case \"UnaryExpression\":\n          this.walkUnaryExpression(expression);\n          break;\n\n        case \"UpdateExpression\":\n          this.walkUpdateExpression(expression);\n          break;\n\n        case \"YieldExpression\":\n          this.walkYieldExpression(expression);\n          break;\n      }\n    }\n  }, {\n    key: \"walkAwaitExpression\",\n    value: function walkAwaitExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkArrayExpression\",\n    value: function walkArrayExpression(expression) {\n      if (expression.elements) {\n        this.walkExpressions(expression.elements);\n      }\n    }\n  }, {\n    key: \"walkSpreadElement\",\n    value: function walkSpreadElement(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkObjectExpression\",\n    value: function walkObjectExpression(expression) {\n      for (var propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n        var prop = expression.properties[propIndex];\n\n        if (prop.type === \"SpreadElement\") {\n          this.walkExpression(prop.argument);\n          continue;\n        }\n\n        if (prop.computed) {\n          this.walkExpression(prop.key);\n        }\n\n        if (prop.shorthand) {\n          this.scope.inShorthand = true;\n        }\n\n        this.walkExpression(prop.value);\n\n        if (prop.shorthand) {\n          this.scope.inShorthand = false;\n        }\n      }\n    }\n  }, {\n    key: \"walkFunctionExpression\",\n    value: function walkFunctionExpression(expression) {\n      var _this11 = this;\n\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      var scopeParams = expression.params; // Add function name in scope for recursive calls\n\n      if (expression.id) {\n        scopeParams.push(expression.id.name);\n      }\n\n      this.inFunctionScope(true, scopeParams, function () {\n        var _iterator8 = _createForOfIteratorHelper(expression.params),\n            _step8;\n\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var param = _step8.value;\n\n            _this11.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n\n        if (expression.body.type === \"BlockStatement\") {\n          _this11.detectMode(expression.body.body);\n\n          _this11.prewalkStatement(expression.body);\n\n          _this11.walkStatement(expression.body);\n        } else {\n          _this11.walkExpression(expression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkArrowFunctionExpression\",\n    value: function walkArrowFunctionExpression(expression) {\n      var _this12 = this;\n\n      this.inFunctionScope(false, expression.params, function () {\n        var _iterator9 = _createForOfIteratorHelper(expression.params),\n            _step9;\n\n        try {\n          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n            var param = _step9.value;\n\n            _this12.walkPattern(param);\n          }\n        } catch (err) {\n          _iterator9.e(err);\n        } finally {\n          _iterator9.f();\n        }\n\n        if (expression.body.type === \"BlockStatement\") {\n          _this12.detectMode(expression.body.body);\n\n          _this12.prewalkStatement(expression.body);\n\n          _this12.walkStatement(expression.body);\n        } else {\n          _this12.walkExpression(expression.body);\n        }\n      });\n    }\n  }, {\n    key: \"walkSequenceExpression\",\n    value: function walkSequenceExpression(expression) {\n      if (expression.expressions) this.walkExpressions(expression.expressions);\n    }\n  }, {\n    key: \"walkUpdateExpression\",\n    value: function walkUpdateExpression(expression) {\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkUnaryExpression\",\n    value: function walkUnaryExpression(expression) {\n      if (expression.operator === \"typeof\") {\n        var exprName = this.getNameForExpression(expression.argument);\n\n        if (exprName && exprName.free) {\n          var hook = this.hooks.typeof.get(exprName.name);\n\n          if (hook !== undefined) {\n            var result = hook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n\n      this.walkExpression(expression.argument);\n    }\n  }, {\n    key: \"walkLeftRightExpression\",\n    value: function walkLeftRightExpression(expression) {\n      this.walkExpression(expression.left);\n      this.walkExpression(expression.right);\n    }\n  }, {\n    key: \"walkBinaryExpression\",\n    value: function walkBinaryExpression(expression) {\n      this.walkLeftRightExpression(expression);\n    }\n  }, {\n    key: \"walkLogicalExpression\",\n    value: function walkLogicalExpression(expression) {\n      var result = this.hooks.expressionLogicalOperator.call(expression);\n\n      if (result === undefined) {\n        this.walkLeftRightExpression(expression);\n      } else {\n        if (result) {\n          this.walkExpression(expression.right);\n        }\n      }\n    }\n  }, {\n    key: \"walkAssignmentExpression\",\n    value: function walkAssignmentExpression(expression) {\n      var _this13 = this;\n\n      var renameIdentifier = this.getRenameIdentifier(expression.right);\n\n      if (expression.left.type === \"Identifier\" && renameIdentifier) {\n        var hook = this.hooks.canRename.get(renameIdentifier);\n\n        if (hook !== undefined && hook.call(expression.right)) {\n          // renaming \"a = b;\"\n          var _hook5 = this.hooks.rename.get(renameIdentifier);\n\n          if (_hook5 === undefined || !_hook5.call(expression.right)) {\n            this.scope.renames.set(expression.left.name, renameIdentifier);\n            this.scope.definitions.delete(expression.left.name);\n          }\n\n          return;\n        }\n      }\n\n      if (expression.left.type === \"Identifier\") {\n        var assignedHook = this.hooks.assigned.get(expression.left.name);\n\n        if (assignedHook === undefined || !assignedHook.call(expression)) {\n          this.walkExpression(expression.right);\n        }\n\n        this.scope.renames.set(expression.left.name, null);\n        var assignHook = this.hooks.assign.get(expression.left.name);\n\n        if (assignHook === undefined || !assignHook.call(expression)) {\n          this.walkExpression(expression.left);\n        }\n\n        return;\n      }\n\n      this.walkExpression(expression.right);\n      this.walkPattern(expression.left);\n      this.enterPattern(expression.left, function (name, decl) {\n        _this13.scope.renames.set(name, null);\n      });\n    }\n  }, {\n    key: \"walkConditionalExpression\",\n    value: function walkConditionalExpression(expression) {\n      var result = this.hooks.expressionConditionalOperator.call(expression);\n\n      if (result === undefined) {\n        this.walkExpression(expression.test);\n        this.walkExpression(expression.consequent);\n\n        if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      } else {\n        if (result) {\n          this.walkExpression(expression.consequent);\n        } else if (expression.alternate) {\n          this.walkExpression(expression.alternate);\n        }\n      }\n    }\n  }, {\n    key: \"walkNewExpression\",\n    value: function walkNewExpression(expression) {\n      var callee = this.evaluateExpression(expression.callee);\n\n      if (callee.isIdentifier()) {\n        var hook = this.hooks.new.get(callee.identifier);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n\n          if (result === true) {\n            return;\n          }\n        }\n      }\n\n      this.walkExpression(expression.callee);\n\n      if (expression.arguments) {\n        this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkYieldExpression\",\n    value: function walkYieldExpression(expression) {\n      if (expression.argument) {\n        this.walkExpression(expression.argument);\n      }\n    }\n  }, {\n    key: \"walkTemplateLiteral\",\n    value: function walkTemplateLiteral(expression) {\n      if (expression.expressions) {\n        this.walkExpressions(expression.expressions);\n      }\n    }\n  }, {\n    key: \"walkTaggedTemplateExpression\",\n    value: function walkTaggedTemplateExpression(expression) {\n      if (expression.tag) {\n        this.walkExpression(expression.tag);\n      }\n\n      if (expression.quasi && expression.quasi.expressions) {\n        this.walkExpressions(expression.quasi.expressions);\n      }\n    }\n  }, {\n    key: \"walkClassExpression\",\n    value: function walkClassExpression(expression) {\n      this.walkClass(expression);\n    }\n  }, {\n    key: \"_walkIIFE\",\n    value: function _walkIIFE(functionExpression, options, currentThis) {\n      var _this14 = this;\n\n      var renameArgOrThis = function renameArgOrThis(argOrThis) {\n        var renameIdentifier = _this14.getRenameIdentifier(argOrThis);\n\n        if (renameIdentifier) {\n          var hook = _this14.hooks.canRename.get(renameIdentifier);\n\n          if (hook !== undefined && hook.call(argOrThis)) {\n            var _hook6 = _this14.hooks.rename.get(renameIdentifier);\n\n            if (_hook6 === undefined || !_hook6.call(argOrThis)) {\n              return renameIdentifier;\n            }\n          }\n        }\n\n        _this14.walkExpression(argOrThis);\n      };\n\n      var params = functionExpression.params;\n      var renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n      var args = options.map(renameArgOrThis);\n      var wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      var scopeParams = params.filter(function (identifier, idx) {\n        return !args[idx];\n      }); // Add function name in scope for recursive calls\n\n      if (functionExpression.id) {\n        scopeParams.push(functionExpression.id.name);\n      }\n\n      this.inFunctionScope(true, scopeParams, function () {\n        if (renameThis) {\n          _this14.scope.renames.set(\"this\", renameThis);\n        }\n\n        for (var i = 0; i < args.length; i++) {\n          var param = args[i];\n          if (!param) continue;\n          if (!params[i] || params[i].type !== \"Identifier\") continue;\n\n          _this14.scope.renames.set(params[i].name, param);\n        }\n\n        if (functionExpression.body.type === \"BlockStatement\") {\n          _this14.detectMode(functionExpression.body.body);\n\n          _this14.prewalkStatement(functionExpression.body);\n\n          _this14.walkStatement(functionExpression.body);\n        } else {\n          _this14.walkExpression(functionExpression.body);\n        }\n      });\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }, {\n    key: \"walkCallExpression\",\n    value: function walkCallExpression(expression) {\n      if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n        // (function(…) { }.call/bind(?, …))\n        this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n      } else if (expression.callee.type === \"FunctionExpression\") {\n        // (function(…) { }(…))\n        this._walkIIFE(expression.callee, expression.arguments, null);\n      } else if (expression.callee.type === \"Import\") {\n        var result = this.hooks.importCall.call(expression);\n        if (result === true) return;\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      } else {\n        var callee = this.evaluateExpression(expression.callee);\n\n        if (callee.isIdentifier()) {\n          var callHook = this.hooks.call.get(callee.identifier);\n\n          if (callHook !== undefined) {\n            var _result = callHook.call(expression);\n\n            if (_result === true) return;\n          }\n\n          var identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\n          if (identifier !== callee.identifier) {\n            var callAnyHook = this.hooks.callAnyMember.get(identifier);\n\n            if (callAnyHook !== undefined) {\n              var _result2 = callAnyHook.call(expression);\n\n              if (_result2 === true) return;\n            }\n          }\n        }\n\n        if (expression.callee) this.walkExpression(expression.callee);\n        if (expression.arguments) this.walkExpressions(expression.arguments);\n      }\n    }\n  }, {\n    key: \"walkMemberExpression\",\n    value: function walkMemberExpression(expression) {\n      var exprName = this.getNameForExpression(expression);\n\n      if (exprName && exprName.free) {\n        var expressionHook = this.hooks.expression.get(exprName.name);\n\n        if (expressionHook !== undefined) {\n          var result = expressionHook.call(expression);\n          if (result === true) return;\n        }\n\n        var expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n\n        if (expressionAnyMemberHook !== undefined) {\n          var _result3 = expressionAnyMemberHook.call(expression);\n\n          if (_result3 === true) return;\n        }\n      }\n\n      this.walkExpression(expression.object);\n      if (expression.computed === true) this.walkExpression(expression.property);\n    }\n  }, {\n    key: \"walkThisExpression\",\n    value: function walkThisExpression(expression) {\n      var expressionHook = this.hooks.expression.get(\"this\");\n\n      if (expressionHook !== undefined) {\n        expressionHook.call(expression);\n      }\n    }\n  }, {\n    key: \"walkIdentifier\",\n    value: function walkIdentifier(expression) {\n      if (!this.scope.definitions.has(expression.name)) {\n        var hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n    /**\n     * @deprecated\n     * @param {any} params scope params\n     * @param {function(): void} fn inner function\n     * @returns {void}\n     */\n\n  }, {\n    key: \"inScope\",\n    value: function inScope(params, fn) {\n      var _this15 = this;\n\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      this.scope.renames.set(\"this\", null);\n      this.enterPatterns(params, function (ident) {\n        _this15.scope.renames.set(ident, null);\n\n        _this15.scope.definitions.add(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inFunctionScope\",\n    value: function inFunctionScope(hasThis, params, fn) {\n      var _this16 = this;\n\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: false,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n\n      if (hasThis) {\n        this.scope.renames.set(\"this\", null);\n      }\n\n      this.enterPatterns(params, function (ident) {\n        _this16.scope.renames.set(ident, null);\n\n        _this16.scope.definitions.add(ident);\n      });\n      fn();\n      this.scope = oldScope;\n    }\n  }, {\n    key: \"inBlockScope\",\n    value: function inBlockScope(fn) {\n      var oldScope = this.scope;\n      this.scope = {\n        topLevelScope: oldScope.topLevelScope,\n        inTry: oldScope.inTry,\n        inShorthand: false,\n        isStrict: oldScope.isStrict,\n        isAsmJs: oldScope.isAsmJs,\n        definitions: oldScope.definitions.createChild(),\n        renames: oldScope.renames.createChild()\n      };\n      fn();\n      this.scope = oldScope;\n    } // TODO webpack 5: remove this methods\n    // only for backward-compat\n\n  }, {\n    key: \"detectStrictMode\",\n    value: function detectStrictMode(statements) {\n      this.detectMode(statements);\n    }\n  }, {\n    key: \"detectMode\",\n    value: function detectMode(statements) {\n      var isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n\n      if (isLiteral && statements[0].expression.value === \"use strict\") {\n        this.scope.isStrict = true;\n      }\n\n      if (isLiteral && statements[0].expression.value === \"use asm\") {\n        this.scope.isAsmJs = true;\n      }\n    }\n  }, {\n    key: \"enterPatterns\",\n    value: function enterPatterns(patterns, onIdent) {\n      var _iterator10 = _createForOfIteratorHelper(patterns),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var pattern = _step10.value;\n\n          if (typeof pattern !== \"string\") {\n            this.enterPattern(pattern, onIdent);\n          } else if (pattern) {\n            onIdent(pattern);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    }\n  }, {\n    key: \"enterPattern\",\n    value: function enterPattern(pattern, onIdent) {\n      if (!pattern) return;\n\n      switch (pattern.type) {\n        case \"ArrayPattern\":\n          this.enterArrayPattern(pattern, onIdent);\n          break;\n\n        case \"AssignmentPattern\":\n          this.enterAssignmentPattern(pattern, onIdent);\n          break;\n\n        case \"Identifier\":\n          this.enterIdentifier(pattern, onIdent);\n          break;\n\n        case \"ObjectPattern\":\n          this.enterObjectPattern(pattern, onIdent);\n          break;\n\n        case \"RestElement\":\n          this.enterRestElement(pattern, onIdent);\n          break;\n\n        case \"Property\":\n          this.enterPattern(pattern.value, onIdent);\n          break;\n      }\n    }\n  }, {\n    key: \"enterIdentifier\",\n    value: function enterIdentifier(pattern, onIdent) {\n      onIdent(pattern.name, pattern);\n    }\n  }, {\n    key: \"enterObjectPattern\",\n    value: function enterObjectPattern(pattern, onIdent) {\n      for (var propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n        var prop = pattern.properties[propIndex];\n        this.enterPattern(prop, onIdent);\n      }\n    }\n  }, {\n    key: \"enterArrayPattern\",\n    value: function enterArrayPattern(pattern, onIdent) {\n      for (var elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n        var element = pattern.elements[elementIndex];\n        this.enterPattern(element, onIdent);\n      }\n    }\n  }, {\n    key: \"enterRestElement\",\n    value: function enterRestElement(pattern, onIdent) {\n      this.enterPattern(pattern.argument, onIdent);\n    }\n  }, {\n    key: \"enterAssignmentPattern\",\n    value: function enterAssignmentPattern(pattern, onIdent) {\n      this.enterPattern(pattern.left, onIdent);\n    }\n  }, {\n    key: \"evaluateExpression\",\n    value: function evaluateExpression(expression) {\n      try {\n        var hook = this.hooks.evaluate.get(expression.type);\n\n        if (hook !== undefined) {\n          var result = hook.call(expression);\n\n          if (result !== undefined) {\n            if (result) {\n              result.setExpression(expression);\n            }\n\n            return result;\n          }\n        }\n      } catch (e) {\n        console.warn(e); // ignore error\n      }\n\n      return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n    }\n  }, {\n    key: \"parseString\",\n    value: function parseString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            return this.parseString(expression.left) + this.parseString(expression.right);\n          }\n\n          break;\n\n        case \"Literal\":\n          return expression.value + \"\";\n      }\n\n      throw new Error(expression.type + \" is not supported as parameter for require\");\n    }\n  }, {\n    key: \"parseCalculatedString\",\n    value: function parseCalculatedString(expression) {\n      switch (expression.type) {\n        case \"BinaryExpression\":\n          if (expression.operator === \"+\") {\n            var left = this.parseCalculatedString(expression.left);\n            var right = this.parseCalculatedString(expression.right);\n\n            if (left.code) {\n              return {\n                range: left.range,\n                value: left.value,\n                code: true,\n                conditional: false\n              };\n            } else if (right.code) {\n              return {\n                range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n                value: left.value + right.value,\n                code: true,\n                conditional: false\n              };\n            } else {\n              return {\n                range: [left.range[0], right.range[1]],\n                value: left.value + right.value,\n                code: false,\n                conditional: false\n              };\n            }\n          }\n\n          break;\n\n        case \"ConditionalExpression\":\n          {\n            var consequent = this.parseCalculatedString(expression.consequent);\n            var alternate = this.parseCalculatedString(expression.alternate);\n            var items = [];\n\n            if (consequent.conditional) {\n              items.push.apply(items, _toConsumableArray(consequent.conditional));\n            } else if (!consequent.code) {\n              items.push(consequent);\n            } else {\n              break;\n            }\n\n            if (alternate.conditional) {\n              items.push.apply(items, _toConsumableArray(alternate.conditional));\n            } else if (!alternate.code) {\n              items.push(alternate);\n            } else {\n              break;\n            }\n\n            return {\n              range: undefined,\n              value: \"\",\n              code: true,\n              conditional: items\n            };\n          }\n\n        case \"Literal\":\n          return {\n            range: expression.range,\n            value: expression.value + \"\",\n            code: false,\n            conditional: false\n          };\n      }\n\n      return {\n        range: undefined,\n        value: \"\",\n        code: true,\n        conditional: false\n      };\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(source, initialState) {\n      var ast;\n      var comments;\n\n      if (typeof source === \"object\" && source !== null) {\n        ast = source;\n        comments = source.comments;\n      } else {\n        comments = [];\n        ast = Parser.parse(source, {\n          sourceType: this.sourceType,\n          onComment: comments\n        });\n      }\n\n      var oldScope = this.scope;\n      var oldState = this.state;\n      var oldComments = this.comments;\n      this.scope = {\n        topLevelScope: true,\n        inTry: false,\n        inShorthand: false,\n        isStrict: false,\n        isAsmJs: false,\n        definitions: new StackedSetMap(),\n        renames: new StackedSetMap()\n      };\n      var state = this.state = initialState || {};\n      this.comments = comments;\n\n      if (this.hooks.program.call(ast, comments) === undefined) {\n        this.detectMode(ast.body);\n        this.prewalkStatements(ast.body);\n        this.blockPrewalkStatements(ast.body);\n        this.walkStatements(ast.body);\n      }\n\n      this.scope = oldScope;\n      this.state = oldState;\n      this.comments = oldComments;\n      return state;\n    }\n  }, {\n    key: \"evaluate\",\n    value: function evaluate(source) {\n      var ast = Parser.parse(\"(\" + source + \")\", {\n        sourceType: this.sourceType,\n        locations: false\n      }); // TODO(https://github.com/acornjs/acorn/issues/741)\n      // @ts-ignore\n\n      if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n        throw new Error(\"evaluate: Source is not a expression\");\n      } // TODO(https://github.com/acornjs/acorn/issues/741)\n      // @ts-ignore\n\n\n      return this.evaluateExpression(ast.body[0].expression);\n    }\n  }, {\n    key: \"getComments\",\n    value: function getComments(range) {\n      return this.comments.filter(function (comment) {\n        return comment.range[0] >= range[0] && comment.range[1] <= range[1];\n      });\n    }\n  }, {\n    key: \"parseCommentOptions\",\n    value: function parseCommentOptions(range) {\n      var comments = this.getComments(range);\n\n      if (comments.length === 0) {\n        return EMPTY_COMMENT_OPTIONS;\n      }\n\n      var options = {};\n      var errors = [];\n\n      var _iterator11 = _createForOfIteratorHelper(comments),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var comment = _step11.value;\n          var value = comment.value;\n\n          if (value && webpackCommentRegExp.test(value)) {\n            // try compile only if webpack options comment is present\n            try {\n              var val = vm.runInNewContext(\"(function(){return {\".concat(value, \"};})()\"));\n              Object.assign(options, val);\n            } catch (e) {\n              e.comment = comment;\n              errors.push(e);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      return {\n        options: options,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"getNameForExpression\",\n    value: function getNameForExpression(expression) {\n      var expr = expression;\n      var exprName = [];\n\n      while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n        exprName.push(expr.computed ? expr.property.value : expr.property.name);\n        expr = expr.object;\n      }\n\n      var free;\n\n      if (expr.type === \"Identifier\") {\n        free = !this.scope.definitions.has(expr.name);\n        exprName.push(this.scope.renames.get(expr.name) || expr.name);\n      } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n        free = true;\n        exprName.push(this.scope.renames.get(\"this\"));\n      } else if (expr.type === \"ThisExpression\") {\n        free = this.scope.topLevelScope;\n        exprName.push(\"this\");\n      } else {\n        return null;\n      }\n\n      var prefix = \"\";\n\n      for (var i = exprName.length - 1; i >= 2; i--) {\n        prefix += exprName[i] + \".\";\n      }\n\n      if (exprName.length > 1) {\n        prefix += exprName[1];\n      }\n\n      var name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n      var nameGeneral = prefix;\n      return {\n        name: name,\n        nameGeneral: nameGeneral,\n        free: free\n      };\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(code, options) {\n      var type = options ? options.sourceType : \"module\";\n      var parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n\n      if (type === \"auto\") {\n        parserOptions.sourceType = \"module\";\n      } else if (parserOptions.sourceType === \"script\") {\n        parserOptions.allowReturnOutsideFunction = true;\n      }\n\n      var ast;\n      var error;\n      var threw = false;\n\n      try {\n        ast = acornParser.parse(code, parserOptions);\n      } catch (e) {\n        error = e;\n        threw = true;\n      }\n\n      if (threw && type === \"auto\") {\n        parserOptions.sourceType = \"script\";\n        parserOptions.allowReturnOutsideFunction = true;\n\n        if (Array.isArray(parserOptions.onComment)) {\n          parserOptions.onComment.length = 0;\n        }\n\n        try {\n          ast = acornParser.parse(code, parserOptions);\n          threw = false;\n        } catch (e) {\n          threw = true;\n        }\n      }\n\n      if (threw) {\n        throw error;\n      }\n\n      return ast;\n    }\n  }]);\n\n  return Parser;\n}(Tapable); // TODO remove in webpack 5\n\n\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/Parser.js"],"names":["acorn","require","Tapable","SyncBailHook","HookMap","util","vm","BasicEvaluatedExpression","StackedSetMap","acornParser","Parser","joinRanges","startRange","endRange","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","hooks","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateCallExpressionMember","statement","statementIf","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","canRename","rename","assigned","assign","typeof","importCall","call","callAnyMember","new","expression","expressionAnyMember","expressionConditionalOperator","expressionLogicalOperator","program","HOOK_MAP_COMPAT_CONFIG","_pluginCompat","tap","Object","keys","name","regexp","match","exec","fn","bind","scope","undefined","state","comments","initializeEvaluating","for","expr","value","setNumber","setRange","range","setString","setBoolean","setNull","setRegExp","left","leftAsBool","right","operator","evaluateExpression","asBool","res","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","concat","Math","pow","isBoolean","bool","argument","type","renames","get","definitions","has","hook","exprName","getNameForExpression","free","arg","isArray","isConstArray","isRegExp","isTruthy","isFalsy","result","setIdentifier","callee","property","computed","param","object","arguments","length","arg1","arg2","regExp","replace","forEach","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","parts","i","quasiExpr","quasi","prevExpr","expressions","exprAsString","asString","setExpression","push","part","node","setTemplateString","tag","identifier","stringSuffix","hasUnknownParams","argExpr","newString","newRange","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","isIdentifier","classy","superClass","walkExpression","body","wasTopLevel","topLevelScope","methodDefinition","walkMethodDefinition","key","statements","index","len","prewalkStatement","blockPrewalkStatement","walkStatement","prewalkBlockStatement","prewalkDoWhileStatement","prewalkExportAllDeclaration","prewalkExportDefaultDeclaration","prewalkExportNamedDeclaration","prewalkForInStatement","prewalkForOfStatement","prewalkForStatement","prewalkFunctionDeclaration","prewalkIfStatement","prewalkImportDeclaration","prewalkLabeledStatement","prewalkSwitchStatement","prewalkTryStatement","prewalkVariableDeclaration","prewalkWhileStatement","prewalkWithStatement","blockPrewalkVariableDeclaration","blockPrewalkExportDefaultDeclaration","blockPrewalkExportNamedDeclaration","blockPrewalkClassDeclaration","walkBlockStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","prewalkStatements","inBlockScope","blockPrewalkStatements","walkStatements","prewalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","inTry","handler","walkCatchClause","finalizer","init","update","walkPattern","id","set","add","inFunctionScope","params","detectMode","source","specifiers","specifier","local","imported","declaration","onIdent","declarations","declarator","enterPattern","enterDeclaration","def","specifierIndex","exported","_prewalkVariableDeclaration","hookMap","decl","renameIdentifier","getRenameIdentifier","delete","walkClass","switchCases","switchCase","catchClause","ident","pattern","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","properties","prop","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkLogicalExpression","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","walkExpressions","propIndex","shorthand","inShorthand","scopeParams","walkLeftRightExpression","assignedHook","assignHook","functionExpression","currentThis","renameArgOrThis","argOrThis","renameThis","args","filter","idx","_walkIIFE","slice","callHook","callAnyHook","expressionHook","expressionAnyMemberHook","nameGeneral","oldScope","isStrict","isAsmJs","createChild","enterPatterns","hasThis","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","initialState","ast","parse","oldState","oldComments","comment","getComments","val","runInNewContext","parserOptions","create","allowReturnOutsideFunction","error","threw","Array","defineProperty","prototype","configurable","deprecate","parseCommentOptions","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst acorn = require(\"acorn\");\nconst { Tapable, SyncBailHook, HookMap } = require(\"tapable\");\nconst util = require(\"util\");\nconst vm = require(\"vm\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst StackedSetMap = require(\"./util/StackedSetMap\");\n\nconst acornParser = acorn.Parser;\n\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: 11,\n\tsourceType: \"module\",\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass Parser extends Tapable {\n\tconstructor(options, sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\tassigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tcallAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"])\n\t\t};\n\t\tconst HOOK_MAP_COMPAT_CONFIG = {\n\t\t\tevaluateTypeof: /^evaluate typeof (.+)$/,\n\t\t\tevaluateIdentifier: /^evaluate Identifier (.+)$/,\n\t\t\tevaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n\t\t\tevaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n\t\t\tevaluate: /^evaluate (.+)$/,\n\t\t\tlabel: /^label (.+)$/,\n\t\t\tvarDeclarationLet: /^var-let (.+)$/,\n\t\t\tvarDeclarationConst: /^var-const (.+)$/,\n\t\t\tvarDeclarationVar: /^var-var (.+)$/,\n\t\t\tvarDeclaration: /^var (.+)$/,\n\t\t\tcanRename: /^can-rename (.+)$/,\n\t\t\trename: /^rename (.+)$/,\n\t\t\ttypeof: /^typeof (.+)$/,\n\t\t\tassigned: /^assigned (.+)$/,\n\t\t\tassign: /^assign (.+)$/,\n\t\t\tcallAnyMember: /^call (.+)\\.\\*$/,\n\t\t\tcall: /^call (.+)$/,\n\t\t\tnew: /^new (.+)$/,\n\t\t\texpressionConditionalOperator: /^expression \\?:$/,\n\t\t\texpressionAnyMember: /^expression (.+)\\.\\*$/,\n\t\t\texpression: /^expression (.+)$/\n\t\t};\n\t\tthis._pluginCompat.tap(\"Parser\", options => {\n\t\t\tfor (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n\t\t\t\tconst regexp = HOOK_MAP_COMPAT_CONFIG[name];\n\t\t\t\tconst match = regexp.exec(options.name);\n\t\t\t\tif (match) {\n\t\t\t\t\tif (match[1]) {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.options = options;\n\t\tthis.sourceType = sourceType;\n\t\tthis.scope = undefined;\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.initializeEvaluating();\n\t}\n\n\tinitializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression().setNull().setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet leftAsBool;\n\t\t\tlet right;\n\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== true) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== false) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet right;\n\t\t\tlet res;\n\t\t\tif (expr.operator === \"+\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (left.isString()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"leftprefix\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixright\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number - right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number * right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number / right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(Math.pow(left.number, right.number));\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"==\" || expr.operator === \"===\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string === right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number === right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool === right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string !== right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number !== right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool !== right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number & right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number | right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number ^ right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >>> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number << right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\tlet res;\n\t\t\t\tlet name;\n\t\t\t\tif (expr.argument.type === \"Identifier\") {\n\t\t\t\t\tname =\n\t\t\t\t\t\tthis.scope.renames.get(expr.argument.name) || expr.argument.name;\n\t\t\t\t\tif (!this.scope.definitions.has(name)) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"MemberExpression\") {\n\t\t\t\t\tconst exprName = this.getNameForExpression(expr.argument);\n\t\t\t\t\tif (exprName && exprName.free) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(exprName.name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"FunctionExpression\") {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\tif (arg.isString() || arg.isWrapped()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (argument.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.bool)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isTruthy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(false)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isFalsy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(true)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isString()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.string)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.number)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (!argument.isNumber()) return;\n\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(~argument.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(expr.name) || expr.name;\n\t\t\tif (!this.scope.definitions.has(expr.name)) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t} else {\n\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(\"this\");\n\t\t\tif (name) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n\t\t\tlet exprName = this.getNameForExpression(expression);\n\t\t\tif (exprName) {\n\t\t\t\tif (exprName.free) {\n\t\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setIdentifier(exprName.name)\n\t\t\t\t\t\t.setRange(expression.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.callee.type !== \"MemberExpression\") return;\n\t\t\tif (\n\t\t\t\texpr.callee.property.type !==\n\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t)\n\t\t\t\treturn;\n\t\t\tconst param = this.evaluateExpression(expr.callee.object);\n\t\t\tif (!param) return;\n\t\t\tconst property = expr.callee.property.name || expr.callee.property.value;\n\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\tif (hook !== undefined) {\n\t\t\t\treturn hook.call(expr, param);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\targ1 = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\targ2 = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1, arg2))\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {string} kind \"cooked\" | \"raw\"\n\t\t * @param {TODO} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\tconst quasis = [];\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (typeof exprAsString === \"string\") {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(quasiExpr.range)\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n\t\t\tif (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst argExpr = this.evaluateExpression(expr.arguments[i]);\n\t\t\t\t\tif (!argExpr.isString() && !argExpr.isNumber()) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = [\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t];\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\tconst conditionValue = condition.asBool();\n\t\t\tlet res;\n\t\t\tif (conditionValue === undefined) {\n\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\tif (!consequent || !alternate) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\tres.setOptions(consequent.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t}\n\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\tres.addOptions(alternate.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t);\n\t\t\t}\n\t\t\tres.setRange(expr.range);\n\t\t\treturn res;\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\treturn element !== null && this.evaluateExpression(element);\n\t\t\t});\n\t\t\tif (!items.every(Boolean)) return;\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setItems(items)\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t}\n\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result && result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\twalkClass(classy) {\n\t\tif (classy.superClass) this.walkExpression(classy.superClass);\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\tthis.scope.topLevelScope = false;\n\t\t\tfor (const methodDefinition of classy.body.body) {\n\t\t\t\tif (methodDefinition.type === \"MethodDefinition\") {\n\t\t\t\t\tthis.walkMethodDefinition(methodDefinition);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t}\n\t}\n\n\twalkMethodDefinition(methodDefinition) {\n\t\tif (methodDefinition.computed && methodDefinition.key) {\n\t\t\tthis.walkExpression(methodDefinition.key);\n\t\t}\n\t\tif (methodDefinition.value) {\n\t\t\tthis.walkExpression(methodDefinition.value);\n\t\t}\n\t}\n\n\t// Prewalking iterates the scope for variable declarations\n\tprewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.prewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Block-Prewalking iterates the scope for block variable declarations\n\tblockPrewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPrewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Walking iterates the statements and expressions and processes them\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\tprewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.prewalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.prewalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.prewalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.prewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.prewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.prewalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.prewalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.prewalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.prewalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.prewalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.prewalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.prewalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.prewalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.prewalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.prewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.prewalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.prewalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPrewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPrewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPrewalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkStatement(statement) {\n\t\tif (this.hooks.statement.call(statement) !== undefined) return;\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Real Statements\n\tprewalkBlockStatement(statement) {\n\t\tthis.prewalkStatements(statement.body);\n\t}\n\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tthis.blockPrewalkStatements(body);\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\tprewalkIfStatement(statement) {\n\t\tthis.prewalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.prewalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkLabeledStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkWithStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkSwitchStatement(statement) {\n\t\tthis.prewalkSwitchCases(statement.cases);\n\t}\n\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\tprewalkTryStatement(statement) {\n\t\tthis.prewalkStatement(statement.block);\n\t}\n\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\tprewalkWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkDoWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\tprewalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.prewalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForOfStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Declarations\n\tprewalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tthis.prewalkStatement(statement.body);\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\tprewalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tthis.scope.renames.set(name, null);\n\t\t\tthis.scope.definitions.add(name);\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, \"default\", name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(\n\t\t\t\t\t\tstatement,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tspecifier.imported.name,\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, null, name);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.blockPrewalkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.prewalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPrewalkExportDefaultDeclaration(statement) {\n\t\tif (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\tthis.blockPrewalkClassDeclaration(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportDefaultDeclaration(statement) {\n\t\tthis.prewalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\"\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (statement.declaration.type === \"FunctionDeclaration\") {\n\t\t\t\tthis.walkFunctionDeclaration(statement.declaration);\n\t\t\t} else if (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\t\tthis.walkClassDeclaration(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n\t}\n\n\tprewalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\tblockPrewalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._prewalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t_prewalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(name, null);\n\t\t\t\t\t\t\t\tthis.scope.definitions.add(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(\n\t\t\t\t\t\t\t\t\tdeclarator.id.name,\n\t\t\t\t\t\t\t\t\tthis.scope.renames.get(renameIdentifier) || renameIdentifier\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.scope.definitions.delete(declarator.id.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPrewalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\tprewalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.prewalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\n\t\t\tif (switchCase.test) {\n\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t}\n\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.scope.renames.set(ident, null);\n\t\t\t\t\tthis.scope.definitions.add(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tthis.prewalkStatement(catchClause.body);\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAwaitExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tif (prop.type === \"SpreadElement\") {\n\t\t\t\tthis.walkExpression(prop.argument);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (prop.computed) {\n\t\t\t\tthis.walkExpression(prop.key);\n\t\t\t}\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = true;\n\t\t\t}\n\t\t\tthis.walkExpression(prop.value);\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t}\n\t\t}\n\t}\n\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = expression.params;\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkArrowFunctionExpression(expression) {\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t}\n\n\twalkSequenceExpression(expression) {\n\t\tif (expression.expressions) this.walkExpressions(expression.expressions);\n\t}\n\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst exprName = this.getNameForExpression(expression.argument);\n\t\t\tif (exprName && exprName.free) {\n\t\t\t\tconst hook = this.hooks.typeof.get(exprName.name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\twalkBinaryExpression(expression) {\n\t\tthis.walkLeftRightExpression(expression);\n\t}\n\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkAssignmentExpression(expression) {\n\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\tif (expression.left.type === \"Identifier\" && renameIdentifier) {\n\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\tif (hook !== undefined && hook.call(expression.right)) {\n\t\t\t\t// renaming \"a = b;\"\n\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\tif (hook === undefined || !hook.call(expression.right)) {\n\t\t\t\t\tthis.scope.renames.set(expression.left.name, renameIdentifier);\n\t\t\t\t\tthis.scope.definitions.delete(expression.left.name);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst assignedHook = this.hooks.assigned.get(expression.left.name);\n\t\t\tif (assignedHook === undefined || !assignedHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t\tthis.scope.renames.set(expression.left.name, null);\n\t\t\tconst assignHook = this.hooks.assign.get(expression.left.name);\n\t\t\tif (assignHook === undefined || !assignHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.walkExpression(expression.right);\n\t\tthis.walkPattern(expression.left);\n\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\tthis.scope.renames.set(name, null);\n\t\t});\n\t}\n\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkNewExpression(expression) {\n\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\tif (callee.isIdentifier()) {\n\t\t\tconst hook = this.hooks.new.get(callee.identifier);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.walkExpression(expression.tag);\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst renameArgOrThis = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\tif (hook !== undefined && hook.call(argOrThis)) {\n\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\tif (hook === undefined || !hook.call(argOrThis)) {\n\t\t\t\t\t\treturn renameIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst params = functionExpression.params;\n\t\tconst renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n\t\tconst args = options.map(renameArgOrThis);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = params.filter((identifier, idx) => !args[idx]);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis) {\n\t\t\t\tthis.scope.renames.set(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tconst param = args[i];\n\t\t\t\tif (!param) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.scope.renames.set(params[i].name, param);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tthis.prewalkStatement(functionExpression.body);\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkCallExpression(expression) {\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type === \"FunctionExpression\" &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0\n\t\t) {\n\t\t\t// (function(…) { }.call/bind(?, …))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (expression.callee.type === \"FunctionExpression\") {\n\t\t\t// (function(…) { }(…))\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else if (expression.callee.type === \"Import\") {\n\t\t\tlet result = this.hooks.importCall.call(expression);\n\t\t\tif (result === true) return;\n\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t} else {\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst callHook = this.hooks.call.get(callee.identifier);\n\t\t\t\tif (callHook !== undefined) {\n\t\t\t\t\tlet result = callHook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t\tlet identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\t\t\t\tif (identifier !== callee.identifier) {\n\t\t\t\t\tconst callAnyHook = this.hooks.callAnyMember.get(identifier);\n\t\t\t\t\tif (callAnyHook !== undefined) {\n\t\t\t\t\t\tlet result = callAnyHook.call(expression);\n\t\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expression.callee) this.walkExpression(expression.callee);\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkMemberExpression(expression) {\n\t\tconst exprName = this.getNameForExpression(expression);\n\t\tif (exprName && exprName.free) {\n\t\t\tconst expressionHook = this.hooks.expression.get(exprName.name);\n\t\t\tif (expressionHook !== undefined) {\n\t\t\t\tconst result = expressionHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t\tconst expressionAnyMemberHook = this.hooks.expressionAnyMember.get(\n\t\t\t\texprName.nameGeneral\n\t\t\t);\n\t\t\tif (expressionAnyMemberHook !== undefined) {\n\t\t\t\tconst result = expressionAnyMemberHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkThisExpression(expression) {\n\t\tconst expressionHook = this.hooks.expression.get(\"this\");\n\t\tif (expressionHook !== undefined) {\n\t\t\texpressionHook.call(expression);\n\t\t}\n\t}\n\n\twalkIdentifier(expression) {\n\t\tif (!this.scope.definitions.has(expression.name)) {\n\t\t\tconst hook = this.hooks.expression.get(\n\t\t\t\tthis.scope.renames.get(expression.name) || expression.name\n\t\t\t);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tthis.scope.renames.set(\"this\", null);\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.scope.renames.set(\"this\", null);\n\t\t}\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t// TODO webpack 5: remove this methods\n\t// only for backward-compat\n\tdetectStrictMode(statements) {\n\t\tthis.detectMode(statements);\n\t}\n\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (isLiteral && statements[0].expression.value === \"use strict\") {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (isLiteral && statements[0].expression.value === \"use asm\") {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tenterIdentifier(pattern, onIdent) {\n\t\tonIdent(pattern.name, pattern);\n\t}\n\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(expression.range)\n\t\t\t.setExpression(expression);\n\t}\n\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\tparse(source, initialState) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tif (typeof source === \"object\" && source !== null) {\n\t\t\tast = source;\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = Parser.parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedSetMap(),\n\t\t\trenames: new StackedSetMap()\n\t\t};\n\t\tconst state = (this.state = initialState || {});\n\t\tthis.comments = comments;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.prewalkStatements(ast.body);\n\t\t\tthis.blockPrewalkStatements(ast.body);\n\t\t\tthis.walkStatements(ast.body);\n\t\t}\n\t\tthis.scope = oldScope;\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\treturn state;\n\t}\n\n\tevaluate(source) {\n\t\tconst ast = Parser.parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\tgetComments(range) {\n\t\treturn this.comments.filter(\n\t\t\tcomment => comment.range[0] >= range[0] && comment.range[1] <= range[1]\n\t\t);\n\t}\n\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tconst val = vm.runInNewContext(`(function(){return {${value}};})()`);\n\t\t\t\t\tObject.assign(options, val);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.comment = comment;\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\tgetNameForExpression(expression) {\n\t\tlet expr = expression;\n\t\tconst exprName = [];\n\t\twhile (\n\t\t\texpr.type === \"MemberExpression\" &&\n\t\t\texpr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")\n\t\t) {\n\t\t\texprName.push(expr.computed ? expr.property.value : expr.property.name);\n\t\t\texpr = expr.object;\n\t\t}\n\t\tlet free;\n\t\tif (expr.type === \"Identifier\") {\n\t\t\tfree = !this.scope.definitions.has(expr.name);\n\t\t\texprName.push(this.scope.renames.get(expr.name) || expr.name);\n\t\t} else if (\n\t\t\texpr.type === \"ThisExpression\" &&\n\t\t\tthis.scope.renames.get(\"this\")\n\t\t) {\n\t\t\tfree = true;\n\t\t\texprName.push(this.scope.renames.get(\"this\"));\n\t\t} else if (expr.type === \"ThisExpression\") {\n\t\t\tfree = this.scope.topLevelScope;\n\t\t\texprName.push(\"this\");\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\tlet prefix = \"\";\n\t\tfor (let i = exprName.length - 1; i >= 2; i--) {\n\t\t\tprefix += exprName[i] + \".\";\n\t\t}\n\t\tif (exprName.length > 1) {\n\t\t\tprefix += exprName[1];\n\t\t}\n\t\tconst name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n\t\tconst nameGeneral = prefix;\n\t\treturn {\n\t\t\tname,\n\t\t\tnameGeneral,\n\t\t\tfree\n\t\t};\n\t}\n\n\tstatic parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\tconst parserOptions = Object.assign(\n\t\t\tObject.create(null),\n\t\t\tdefaultParserOptions,\n\t\t\toptions\n\t\t);\n\n\t\tif (type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"module\";\n\t\t} else if (parserOptions.sourceType === \"script\") {\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t}\n\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\tthrew = true;\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn ast;\n\t}\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @param {TODO} range Range\n\t\t * @returns {void}\n\t\t * @this {Parser}\n\t\t */\n\t\tfunction(range) {\n\t\t\treturn this.parseCommentOptions(range).options;\n\t\t},\n\t\t\"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\"\n\t)\n});\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}