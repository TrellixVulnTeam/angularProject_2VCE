{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/environment\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/translator\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_constructor\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Environment = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var translator_1 = require(\"@angular/compiler-cli/src/ngtsc/translator\");\n\n  var ts_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/ts_util\");\n\n  var type_constructor_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_constructor\");\n\n  var type_parameter_emitter_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_parameter_emitter\");\n  /**\n   * A context which hosts one or more Type Check Blocks (TCBs).\n   *\n   * An `Environment` supports the generation of TCBs by tracking necessary imports, declarations of\n   * type constructors, and other statements beyond the type-checking code within the TCB itself.\n   * Through method calls on `Environment`, the TCB generator can request `ts.Expression`s which\n   * reference declarations in the `Environment` for these artifacts`.\n   *\n   * `Environment` can be used in a standalone fashion, or can be extended to support more specialized\n   * usage.\n   */\n\n\n  var Environment =\n  /** @class */\n  function () {\n    function Environment(config, importManager, refEmitter, reflector, contextFile) {\n      this.config = config;\n      this.importManager = importManager;\n      this.refEmitter = refEmitter;\n      this.reflector = reflector;\n      this.contextFile = contextFile;\n      this.nextIds = {\n        pipeInst: 1,\n        typeCtor: 1\n      };\n      this.typeCtors = new Map();\n      this.typeCtorStatements = [];\n      this.pipeInsts = new Map();\n      this.pipeInstStatements = [];\n    }\n    /**\n     * Get an expression referring to a type constructor for the given directive.\n     *\n     * Depending on the shape of the directive itself, this could be either a reference to a declared\n     * type constructor, or to an inline type constructor.\n     */\n\n\n    Environment.prototype.typeCtorFor = function (dir) {\n      var dirRef = dir.ref;\n      var node = dirRef.node;\n\n      if (this.typeCtors.has(node)) {\n        return this.typeCtors.get(node);\n      }\n\n      if (type_constructor_1.requiresInlineTypeCtor(node, this.reflector)) {\n        // The constructor has already been created inline, we just need to construct a reference to\n        // it.\n        var ref = this.reference(dirRef);\n        var typeCtorExpr = ts.createPropertyAccess(ref, 'ngTypeCtor');\n        this.typeCtors.set(node, typeCtorExpr);\n        return typeCtorExpr;\n      } else {\n        var fnName = \"_ctor\" + this.nextIds.typeCtor++;\n        var nodeTypeRef = this.referenceType(dirRef);\n\n        if (!ts.isTypeReferenceNode(nodeTypeRef)) {\n          throw new Error(\"Expected TypeReferenceNode from reference to \" + dirRef.debugName);\n        }\n\n        var meta = {\n          fnName: fnName,\n          body: true,\n          fields: {\n            inputs: dir.inputs.classPropertyNames,\n            outputs: dir.outputs.classPropertyNames,\n            // TODO: support queries\n            queries: dir.queries\n          },\n          coercedInputFields: dir.coercedInputFields\n        };\n        var typeParams = this.emitTypeParameters(node);\n        var typeCtor = type_constructor_1.generateTypeCtorDeclarationFn(node, meta, nodeTypeRef.typeName, typeParams, this.reflector);\n        this.typeCtorStatements.push(typeCtor);\n        var fnId = ts.createIdentifier(fnName);\n        this.typeCtors.set(node, fnId);\n        return fnId;\n      }\n    };\n    /*\n     * Get an expression referring to an instance of the given pipe.\n     */\n\n\n    Environment.prototype.pipeInst = function (ref) {\n      if (this.pipeInsts.has(ref.node)) {\n        return this.pipeInsts.get(ref.node);\n      }\n\n      var pipeType = this.referenceType(ref);\n      var pipeInstId = ts.createIdentifier(\"_pipe\" + this.nextIds.pipeInst++);\n      this.pipeInstStatements.push(ts_util_1.tsDeclareVariable(pipeInstId, pipeType));\n      this.pipeInsts.set(ref.node, pipeInstId);\n      return pipeInstId;\n    };\n    /**\n     * Generate a `ts.Expression` that references the given node.\n     *\n     * This may involve importing the node into the file if it's not declared there already.\n     */\n\n\n    Environment.prototype.reference = function (ref) {\n      // Disable aliasing for imports generated in a template type-checking context, as there is no\n      // guarantee that any alias re-exports exist in the .d.ts files. It's safe to use direct imports\n      // in these cases as there is no strict dependency checking during the template type-checking\n      // pass.\n      var ngExpr = this.refEmitter.emit(ref, this.contextFile, imports_1.ImportFlags.NoAliasing); // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.\n\n      return translator_1.translateExpression(ngExpr.expression, this.importManager);\n    };\n    /**\n     * Generate a `ts.TypeNode` that references the given node as a type.\n     *\n     * This may involve importing the node into the file if it's not declared there already.\n     */\n\n\n    Environment.prototype.referenceType = function (ref) {\n      var ngExpr = this.refEmitter.emit(ref, this.contextFile, imports_1.ImportFlags.NoAliasing | imports_1.ImportFlags.AllowTypeImports); // Create an `ExpressionType` from the `Expression` and translate it via `translateType`.\n      // TODO(alxhub): support references to types with generic arguments in a clean way.\n\n      return translator_1.translateType(new compiler_1.ExpressionType(ngExpr.expression), this.importManager);\n    };\n\n    Environment.prototype.emitTypeParameters = function (declaration) {\n      var _this = this;\n\n      var emitter = new type_parameter_emitter_1.TypeParameterEmitter(declaration.typeParameters, this.reflector);\n      return emitter.emit(function (ref) {\n        return _this.referenceType(ref);\n      });\n    };\n    /**\n     * Generate a `ts.TypeNode` that references a given type from the provided module.\n     *\n     * This will involve importing the type into the file, and will also add type parameters if\n     * provided.\n     */\n\n\n    Environment.prototype.referenceExternalType = function (moduleName, name, typeParams) {\n      var external = new compiler_1.ExternalExpr({\n        moduleName: moduleName,\n        name: name\n      });\n      return translator_1.translateType(new compiler_1.ExpressionType(external, [\n        /* modifiers */\n      ], typeParams), this.importManager);\n    };\n\n    Environment.prototype.getPreludeStatements = function () {\n      return tslib_1.__spread(this.pipeInstStatements, this.typeCtorStatements);\n    };\n\n    return Environment;\n  }();\n\n  exports.Environment = Environment;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/environment.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ExpressionType, ExternalExpr, Type, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ImportFlags, Reference, ReferenceEmitter} from '../../imports';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ImportManager, translateExpression, translateType} from '../../translator';\nimport {TypeCheckableDirectiveMeta, TypeCheckingConfig, TypeCtorMetadata} from '../api';\n\nimport {tsDeclareVariable} from './ts_util';\nimport {generateTypeCtorDeclarationFn, requiresInlineTypeCtor} from './type_constructor';\nimport {TypeParameterEmitter} from './type_parameter_emitter';\n\n/**\n * A context which hosts one or more Type Check Blocks (TCBs).\n *\n * An `Environment` supports the generation of TCBs by tracking necessary imports, declarations of\n * type constructors, and other statements beyond the type-checking code within the TCB itself.\n * Through method calls on `Environment`, the TCB generator can request `ts.Expression`s which\n * reference declarations in the `Environment` for these artifacts`.\n *\n * `Environment` can be used in a standalone fashion, or can be extended to support more specialized\n * usage.\n */\nexport class Environment {\n  private nextIds = {\n    pipeInst: 1,\n    typeCtor: 1,\n  };\n\n  private typeCtors = new Map<ClassDeclaration, ts.Expression>();\n  protected typeCtorStatements: ts.Statement[] = [];\n\n  private pipeInsts = new Map<ClassDeclaration, ts.Expression>();\n  protected pipeInstStatements: ts.Statement[] = [];\n\n  constructor(\n      readonly config: TypeCheckingConfig, protected importManager: ImportManager,\n      private refEmitter: ReferenceEmitter, readonly reflector: ReflectionHost,\n      protected contextFile: ts.SourceFile) {}\n\n  /**\n   * Get an expression referring to a type constructor for the given directive.\n   *\n   * Depending on the shape of the directive itself, this could be either a reference to a declared\n   * type constructor, or to an inline type constructor.\n   */\n  typeCtorFor(dir: TypeCheckableDirectiveMeta): ts.Expression {\n    const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n    const node = dirRef.node;\n    if (this.typeCtors.has(node)) {\n      return this.typeCtors.get(node)!;\n    }\n\n    if (requiresInlineTypeCtor(node, this.reflector)) {\n      // The constructor has already been created inline, we just need to construct a reference to\n      // it.\n      const ref = this.reference(dirRef);\n      const typeCtorExpr = ts.createPropertyAccess(ref, 'ngTypeCtor');\n      this.typeCtors.set(node, typeCtorExpr);\n      return typeCtorExpr;\n    } else {\n      const fnName = `_ctor${this.nextIds.typeCtor++}`;\n      const nodeTypeRef = this.referenceType(dirRef);\n      if (!ts.isTypeReferenceNode(nodeTypeRef)) {\n        throw new Error(`Expected TypeReferenceNode from reference to ${dirRef.debugName}`);\n      }\n      const meta: TypeCtorMetadata = {\n        fnName,\n        body: true,\n        fields: {\n          inputs: dir.inputs.classPropertyNames,\n          outputs: dir.outputs.classPropertyNames,\n          // TODO: support queries\n          queries: dir.queries,\n        },\n        coercedInputFields: dir.coercedInputFields,\n      };\n      const typeParams = this.emitTypeParameters(node);\n      const typeCtor = generateTypeCtorDeclarationFn(\n          node, meta, nodeTypeRef.typeName, typeParams, this.reflector);\n      this.typeCtorStatements.push(typeCtor);\n      const fnId = ts.createIdentifier(fnName);\n      this.typeCtors.set(node, fnId);\n      return fnId;\n    }\n  }\n\n  /*\n   * Get an expression referring to an instance of the given pipe.\n   */\n  pipeInst(ref: Reference<ClassDeclaration<ts.ClassDeclaration>>): ts.Expression {\n    if (this.pipeInsts.has(ref.node)) {\n      return this.pipeInsts.get(ref.node)!;\n    }\n\n    const pipeType = this.referenceType(ref);\n    const pipeInstId = ts.createIdentifier(`_pipe${this.nextIds.pipeInst++}`);\n\n    this.pipeInstStatements.push(tsDeclareVariable(pipeInstId, pipeType));\n    this.pipeInsts.set(ref.node, pipeInstId);\n\n    return pipeInstId;\n  }\n\n  /**\n   * Generate a `ts.Expression` that references the given node.\n   *\n   * This may involve importing the node into the file if it's not declared there already.\n   */\n  reference(ref: Reference<ClassDeclaration<ts.ClassDeclaration>>): ts.Expression {\n    // Disable aliasing for imports generated in a template type-checking context, as there is no\n    // guarantee that any alias re-exports exist in the .d.ts files. It's safe to use direct imports\n    // in these cases as there is no strict dependency checking during the template type-checking\n    // pass.\n    const ngExpr = this.refEmitter.emit(ref, this.contextFile, ImportFlags.NoAliasing);\n\n    // Use `translateExpression` to convert the `Expression` into a `ts.Expression`.\n    return translateExpression(ngExpr.expression, this.importManager);\n  }\n\n  /**\n   * Generate a `ts.TypeNode` that references the given node as a type.\n   *\n   * This may involve importing the node into the file if it's not declared there already.\n   */\n  referenceType(ref: Reference): ts.TypeNode {\n    const ngExpr = this.refEmitter.emit(\n        ref, this.contextFile, ImportFlags.NoAliasing | ImportFlags.AllowTypeImports);\n\n    // Create an `ExpressionType` from the `Expression` and translate it via `translateType`.\n    // TODO(alxhub): support references to types with generic arguments in a clean way.\n    return translateType(new ExpressionType(ngExpr.expression), this.importManager);\n  }\n\n  private emitTypeParameters(declaration: ClassDeclaration<ts.ClassDeclaration>):\n      ts.TypeParameterDeclaration[]|undefined {\n    const emitter = new TypeParameterEmitter(declaration.typeParameters, this.reflector);\n    return emitter.emit(ref => this.referenceType(ref));\n  }\n\n  /**\n   * Generate a `ts.TypeNode` that references a given type from the provided module.\n   *\n   * This will involve importing the type into the file, and will also add type parameters if\n   * provided.\n   */\n  referenceExternalType(moduleName: string, name: string, typeParams?: Type[]): ts.TypeNode {\n    const external = new ExternalExpr({moduleName, name});\n    return translateType(\n        new ExpressionType(external, [/* modifiers */], typeParams), this.importManager);\n  }\n\n  getPreludeStatements(): ts.Statement[] {\n    return [\n      ...this.pipeInstStatements,\n      ...this.typeCtorStatements,\n    ];\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}