{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/writing/package_json_updater\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/file_system\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.applyChange = exports.DirectPackageJsonUpdater = exports.PackageJsonUpdate = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n  /**\n   * A utility class providing a fluent API for recording multiple changes to a `package.json` file\n   * (and optionally its in-memory parsed representation).\n   *\n   * NOTE: This class should generally not be instantiated directly; instances are implicitly created\n   *       via `PackageJsonUpdater#createUpdate()`.\n   */\n\n\n  var PackageJsonUpdate =\n  /** @class */\n  function () {\n    function PackageJsonUpdate(writeChangesImpl) {\n      this.writeChangesImpl = writeChangesImpl;\n      this.changes = [];\n      this.applied = false;\n    }\n    /**\n     * Record a change to a `package.json` property.\n     *\n     * If the ancestor objects do not yet exist in the `package.json` file, they will be created. The\n     * positioning of the property can also be specified. (If the property already exists, it will be\n     * moved accordingly.)\n     *\n     * NOTE: Property positioning is only guaranteed to be respected in the serialized `package.json`\n     *       file. Positioning will not be taken into account when updating in-memory representations.\n     *\n     * NOTE 2: Property positioning only affects the last property in `propertyPath`. Ancestor\n     *         objects' positioning will not be affected.\n     *\n     * @param propertyPath The path of a (possibly nested) property to add/update.\n     * @param value The new value to set the property to.\n     * @param position The desired position for the added/updated property.\n     */\n\n\n    PackageJsonUpdate.prototype.addChange = function (propertyPath, value, positioning) {\n      if (positioning === void 0) {\n        positioning = 'unimportant';\n      }\n\n      this.ensureNotApplied();\n      this.changes.push([propertyPath, value, positioning]);\n      return this;\n    };\n    /**\n     * Write the recorded changes to the associated `package.json` file (and optionally a\n     * pre-existing, in-memory representation of it).\n     *\n     * @param packageJsonPath The path to the `package.json` file that needs to be updated.\n     * @param parsedJson A pre-existing, in-memory representation of the `package.json` file that\n     *                   needs to be updated as well.\n     */\n\n\n    PackageJsonUpdate.prototype.writeChanges = function (packageJsonPath, parsedJson) {\n      this.ensureNotApplied();\n      this.writeChangesImpl(this.changes, packageJsonPath, parsedJson);\n      this.applied = true;\n    };\n\n    PackageJsonUpdate.prototype.ensureNotApplied = function () {\n      if (this.applied) {\n        throw new Error('Trying to apply a `PackageJsonUpdate` that has already been applied.');\n      }\n    };\n\n    return PackageJsonUpdate;\n  }();\n\n  exports.PackageJsonUpdate = PackageJsonUpdate;\n  /** A `PackageJsonUpdater` that writes directly to the file-system. */\n\n  var DirectPackageJsonUpdater =\n  /** @class */\n  function () {\n    function DirectPackageJsonUpdater(fs) {\n      this.fs = fs;\n    }\n\n    DirectPackageJsonUpdater.prototype.createUpdate = function () {\n      var _this = this;\n\n      return new PackageJsonUpdate(function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        return _this.writeChanges.apply(_this, tslib_1.__spread(args));\n      });\n    };\n\n    DirectPackageJsonUpdater.prototype.writeChanges = function (changes, packageJsonPath, preExistingParsedJson) {\n      var e_1, _a;\n\n      if (changes.length === 0) {\n        throw new Error(\"No changes to write to '\" + packageJsonPath + \"'.\");\n      } // Read and parse the `package.json` content.\n      // NOTE: We are not using `preExistingParsedJson` (even if specified) to avoid corrupting the\n      //       content on disk in case `preExistingParsedJson` is outdated.\n\n\n      var parsedJson = this.fs.exists(packageJsonPath) ? JSON.parse(this.fs.readFile(packageJsonPath)) : {};\n\n      try {\n        // Apply all changes to both the canonical representation (read from disk) and any pre-existing,\n        // in-memory representation.\n        for (var changes_1 = tslib_1.__values(changes), changes_1_1 = changes_1.next(); !changes_1_1.done; changes_1_1 = changes_1.next()) {\n          var _b = tslib_1.__read(changes_1_1.value, 3),\n              propPath = _b[0],\n              value = _b[1],\n              positioning = _b[2];\n\n          if (propPath.length === 0) {\n            throw new Error(\"Missing property path for writing value to '\" + packageJsonPath + \"'.\");\n          }\n\n          applyChange(parsedJson, propPath, value, positioning);\n\n          if (preExistingParsedJson) {\n            // No need to take property positioning into account for in-memory representations.\n            applyChange(preExistingParsedJson, propPath, value, 'unimportant');\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (changes_1_1 && !changes_1_1.done && (_a = changes_1.return)) _a.call(changes_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Ensure the containing directory exists (in case this is a synthesized `package.json` due to a\n      // custom configuration) and write the updated content to disk.\n\n\n      this.fs.ensureDir(file_system_1.dirname(packageJsonPath));\n      this.fs.writeFile(packageJsonPath, JSON.stringify(parsedJson, null, 2) + \"\\n\");\n    };\n\n    return DirectPackageJsonUpdater;\n  }();\n\n  exports.DirectPackageJsonUpdater = DirectPackageJsonUpdater; // Helpers\n\n  function applyChange(ctx, propPath, value, positioning) {\n    var lastPropIdx = propPath.length - 1;\n    var lastProp = propPath[lastPropIdx];\n\n    for (var i = 0; i < lastPropIdx; i++) {\n      var key = propPath[i];\n      var newCtx = ctx.hasOwnProperty(key) ? ctx[key] : ctx[key] = {};\n\n      if (typeof newCtx !== 'object' || newCtx === null || Array.isArray(newCtx)) {\n        throw new Error(\"Property path '\" + propPath.join('.') + \"' does not point to an object.\");\n      }\n\n      ctx = newCtx;\n    }\n\n    ctx[lastProp] = value;\n    positionProperty(ctx, lastProp, positioning);\n  }\n\n  exports.applyChange = applyChange;\n\n  function movePropBefore(ctx, prop, isNextProp) {\n    var allProps = Object.keys(ctx);\n    var otherProps = allProps.filter(function (p) {\n      return p !== prop;\n    });\n    var nextPropIdx = otherProps.findIndex(isNextProp);\n    var propsToShift = nextPropIdx === -1 ? [] : otherProps.slice(nextPropIdx);\n    movePropToEnd(ctx, prop);\n    propsToShift.forEach(function (p) {\n      return movePropToEnd(ctx, p);\n    });\n  }\n\n  function movePropToEnd(ctx, prop) {\n    var value = ctx[prop];\n    delete ctx[prop];\n    ctx[prop] = value;\n  }\n\n  function positionProperty(ctx, prop, positioning) {\n    switch (positioning) {\n      case 'alphabetic':\n        movePropBefore(ctx, prop, function (p) {\n          return p > prop;\n        });\n        break;\n\n      case 'unimportant':\n        // Leave the property order unchanged; i.e. newly added properties will be last and existing\n        // ones will remain in their old position.\n        break;\n\n      default:\n        if (typeof positioning !== 'object' || positioning.before === undefined) {\n          throw new Error(\"Unknown positioning (\" + JSON.stringify(positioning) + \") for property '\" + prop + \"'.\");\n        }\n\n        movePropBefore(ctx, prop, function (p) {\n          return p === positioning.before;\n        });\n        break;\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/writing/package_json_updater.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteFsPath, dirname, FileSystem} from '../../../src/ngtsc/file_system';\nimport {JsonObject, JsonValue} from '../packages/entry_point';\n\n\nexport type PackageJsonChange = [string[], JsonValue, PackageJsonPropertyPositioning];\nexport type PackageJsonPropertyPositioning = 'unimportant'|'alphabetic'|{before: string};\nexport type WritePackageJsonChangesFn =\n    (changes: PackageJsonChange[], packageJsonPath: AbsoluteFsPath, parsedJson?: JsonObject) =>\n        void;\n\n/**\n * A utility object that can be used to safely update values in a `package.json` file.\n *\n * Example usage:\n * ```ts\n * const updatePackageJson = packageJsonUpdater\n *     .createUpdate()\n *     .addChange(['name'], 'package-foo')\n *     .addChange(['scripts', 'foo'], 'echo FOOOO...', 'unimportant')\n *     .addChange(['dependencies', 'baz'], '1.0.0', 'alphabetic')\n *     .addChange(['dependencies', 'bar'], '2.0.0', {before: 'baz'})\n *     .writeChanges('/foo/package.json');\n *     // or\n *     // .writeChanges('/foo/package.json', inMemoryParsedJson);\n * ```\n */\nexport interface PackageJsonUpdater {\n  /**\n   * Create a `PackageJsonUpdate` object, which provides a fluent API for batching updates to a\n   * `package.json` file. (Batching the updates is useful, because it avoids unnecessary I/O\n   * operations.)\n   */\n  createUpdate(): PackageJsonUpdate;\n\n  /**\n   * Write a set of changes to the specified `package.json` file (and optionally a pre-existing,\n   * in-memory representation of it).\n   *\n   * @param changes The set of changes to apply.\n   * @param packageJsonPath The path to the `package.json` file that needs to be updated.\n   * @param parsedJson A pre-existing, in-memory representation of the `package.json` file that\n   *                   needs to be updated as well.\n   */\n  writeChanges(\n      changes: PackageJsonChange[], packageJsonPath: AbsoluteFsPath, parsedJson?: JsonObject): void;\n}\n\n/**\n * A utility class providing a fluent API for recording multiple changes to a `package.json` file\n * (and optionally its in-memory parsed representation).\n *\n * NOTE: This class should generally not be instantiated directly; instances are implicitly created\n *       via `PackageJsonUpdater#createUpdate()`.\n */\nexport class PackageJsonUpdate {\n  private changes: PackageJsonChange[] = [];\n  private applied = false;\n\n  constructor(private writeChangesImpl: WritePackageJsonChangesFn) {}\n\n  /**\n   * Record a change to a `package.json` property.\n   *\n   * If the ancestor objects do not yet exist in the `package.json` file, they will be created. The\n   * positioning of the property can also be specified. (If the property already exists, it will be\n   * moved accordingly.)\n   *\n   * NOTE: Property positioning is only guaranteed to be respected in the serialized `package.json`\n   *       file. Positioning will not be taken into account when updating in-memory representations.\n   *\n   * NOTE 2: Property positioning only affects the last property in `propertyPath`. Ancestor\n   *         objects' positioning will not be affected.\n   *\n   * @param propertyPath The path of a (possibly nested) property to add/update.\n   * @param value The new value to set the property to.\n   * @param position The desired position for the added/updated property.\n   */\n  addChange(\n      propertyPath: string[], value: JsonValue,\n      positioning: PackageJsonPropertyPositioning = 'unimportant'): this {\n    this.ensureNotApplied();\n    this.changes.push([propertyPath, value, positioning]);\n    return this;\n  }\n\n  /**\n   * Write the recorded changes to the associated `package.json` file (and optionally a\n   * pre-existing, in-memory representation of it).\n   *\n   * @param packageJsonPath The path to the `package.json` file that needs to be updated.\n   * @param parsedJson A pre-existing, in-memory representation of the `package.json` file that\n   *                   needs to be updated as well.\n   */\n  writeChanges(packageJsonPath: AbsoluteFsPath, parsedJson?: JsonObject): void {\n    this.ensureNotApplied();\n    this.writeChangesImpl(this.changes, packageJsonPath, parsedJson);\n    this.applied = true;\n  }\n\n  private ensureNotApplied() {\n    if (this.applied) {\n      throw new Error('Trying to apply a `PackageJsonUpdate` that has already been applied.');\n    }\n  }\n}\n\n/** A `PackageJsonUpdater` that writes directly to the file-system. */\nexport class DirectPackageJsonUpdater implements PackageJsonUpdater {\n  constructor(private fs: FileSystem) {}\n\n  createUpdate(): PackageJsonUpdate {\n    return new PackageJsonUpdate((...args) => this.writeChanges(...args));\n  }\n\n  writeChanges(\n      changes: PackageJsonChange[], packageJsonPath: AbsoluteFsPath,\n      preExistingParsedJson?: JsonObject): void {\n    if (changes.length === 0) {\n      throw new Error(`No changes to write to '${packageJsonPath}'.`);\n    }\n\n    // Read and parse the `package.json` content.\n    // NOTE: We are not using `preExistingParsedJson` (even if specified) to avoid corrupting the\n    //       content on disk in case `preExistingParsedJson` is outdated.\n    const parsedJson = this.fs.exists(packageJsonPath) ?\n        JSON.parse(this.fs.readFile(packageJsonPath)) as JsonObject :\n        {};\n\n    // Apply all changes to both the canonical representation (read from disk) and any pre-existing,\n    // in-memory representation.\n    for (const [propPath, value, positioning] of changes) {\n      if (propPath.length === 0) {\n        throw new Error(`Missing property path for writing value to '${packageJsonPath}'.`);\n      }\n\n      applyChange(parsedJson, propPath, value, positioning);\n\n      if (preExistingParsedJson) {\n        // No need to take property positioning into account for in-memory representations.\n        applyChange(preExistingParsedJson, propPath, value, 'unimportant');\n      }\n    }\n\n    // Ensure the containing directory exists (in case this is a synthesized `package.json` due to a\n    // custom configuration) and write the updated content to disk.\n    this.fs.ensureDir(dirname(packageJsonPath));\n    this.fs.writeFile(packageJsonPath, `${JSON.stringify(parsedJson, null, 2)}\\n`);\n  }\n}\n\n// Helpers\nexport function applyChange(\n    ctx: JsonObject, propPath: string[], value: JsonValue,\n    positioning: PackageJsonPropertyPositioning): void {\n  const lastPropIdx = propPath.length - 1;\n  const lastProp = propPath[lastPropIdx];\n\n  for (let i = 0; i < lastPropIdx; i++) {\n    const key = propPath[i];\n    const newCtx = ctx.hasOwnProperty(key) ? ctx[key] : (ctx[key] = {});\n\n    if ((typeof newCtx !== 'object') || (newCtx === null) || Array.isArray(newCtx)) {\n      throw new Error(`Property path '${propPath.join('.')}' does not point to an object.`);\n    }\n\n    ctx = newCtx;\n  }\n\n  ctx[lastProp] = value;\n  positionProperty(ctx, lastProp, positioning);\n}\n\nfunction movePropBefore(ctx: JsonObject, prop: string, isNextProp: (p: string) => boolean): void {\n  const allProps = Object.keys(ctx);\n  const otherProps = allProps.filter(p => p !== prop);\n  const nextPropIdx = otherProps.findIndex(isNextProp);\n  const propsToShift = (nextPropIdx === -1) ? [] : otherProps.slice(nextPropIdx);\n\n  movePropToEnd(ctx, prop);\n  propsToShift.forEach(p => movePropToEnd(ctx, p));\n}\n\nfunction movePropToEnd(ctx: JsonObject, prop: string): void {\n  const value = ctx[prop];\n  delete ctx[prop];\n  ctx[prop] = value;\n}\n\nfunction positionProperty(\n    ctx: JsonObject, prop: string, positioning: PackageJsonPropertyPositioning): void {\n  switch (positioning) {\n    case 'alphabetic':\n      movePropBefore(ctx, prop, p => p > prop);\n      break;\n    case 'unimportant':\n      // Leave the property order unchanged; i.e. newly added properties will be last and existing\n      // ones will remain in their old position.\n      break;\n    default:\n      if ((typeof positioning !== 'object') || (positioning.before === undefined)) {\n        throw new Error(\n            `Unknown positioning (${JSON.stringify(positioning)}) for property '${prop}'.`);\n      }\n\n      movePropBefore(ctx, prop, p => p === positioning.before);\n      break;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}