{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/context\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/translator\", \"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/dom\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/environment\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/oob\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_check_block\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_check_file\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/type_constructor\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeCheckContextImpl = exports.InliningMode = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var translator_1 = require(\"@angular/compiler-cli/src/ngtsc/translator\");\n\n  var diagnostics_2 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/diagnostics\");\n\n  var dom_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/dom\");\n\n  var environment_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/environment\");\n\n  var oob_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/oob\");\n\n  var tcb_util_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/tcb_util\");\n\n  var type_check_block_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_check_block\");\n\n  var type_check_file_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_check_file\");\n\n  var type_constructor_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/type_constructor\");\n  /**\n   * How a type-checking context should handle operations which would require inlining.\n   */\n\n\n  var InliningMode;\n\n  (function (InliningMode) {\n    /**\n     * Use inlining operations when required.\n     */\n    InliningMode[InliningMode[\"InlineOps\"] = 0] = \"InlineOps\";\n    /**\n     * Produce diagnostics if an operation would require inlining.\n     */\n\n    InliningMode[InliningMode[\"Error\"] = 1] = \"Error\";\n  })(InliningMode = exports.InliningMode || (exports.InliningMode = {}));\n  /**\n   * A template type checking context for a program.\n   *\n   * The `TypeCheckContext` allows registration of components and their templates which need to be\n   * type checked.\n   */\n\n\n  var TypeCheckContextImpl =\n  /** @class */\n  function () {\n    function TypeCheckContextImpl(config, compilerHost, componentMappingStrategy, refEmitter, reflector, host, inlining, perf) {\n      this.config = config;\n      this.compilerHost = compilerHost;\n      this.componentMappingStrategy = componentMappingStrategy;\n      this.refEmitter = refEmitter;\n      this.reflector = reflector;\n      this.host = host;\n      this.inlining = inlining;\n      this.perf = perf;\n      this.fileMap = new Map();\n      /**\n       * A `Map` of `ts.SourceFile`s that the context has seen to the operations (additions of methods\n       * or type-check blocks) that need to be eventually performed on that file.\n       */\n\n      this.opMap = new Map();\n      /**\n       * Tracks when an a particular class has a pending type constructor patching operation already\n       * queued.\n       */\n\n      this.typeCtorPending = new Set();\n\n      if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {\n        // We cannot use inlining for type checking since this environment does not support it.\n        throw new Error(\"AssertionError: invalid inlining configuration.\");\n      }\n    }\n    /**\n     * Register a template to potentially be type-checked.\n     *\n     * Implements `TypeCheckContext.addTemplate`.\n     */\n\n\n    TypeCheckContextImpl.prototype.addTemplate = function (ref, binder, template, pipes, schemas, sourceMapping, file, parseErrors) {\n      var e_1, _a;\n\n      if (!this.host.shouldCheckComponent(ref.node)) {\n        return;\n      }\n\n      var fileData = this.dataForFile(ref.node.getSourceFile());\n      var shimData = this.pendingShimForComponent(ref.node);\n      var templateId = fileData.sourceManager.getTemplateId(ref.node);\n      var templateDiagnostics = [];\n\n      if (parseErrors !== null) {\n        templateDiagnostics.push.apply(templateDiagnostics, tslib_1.__spread(this.getTemplateDiagnostics(parseErrors, templateId, sourceMapping)));\n      }\n\n      var boundTarget = binder.bind({\n        template: template\n      });\n\n      if (this.inlining === InliningMode.InlineOps) {\n        try {\n          // Get all of the directives used in the template and record inline type constructors when\n          // required.\n          for (var _b = tslib_1.__values(boundTarget.getUsedDirectives()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var dir = _c.value;\n            var dirRef = dir.ref;\n            var dirNode = dirRef.node;\n\n            if (!dir.isGeneric || !type_constructor_1.requiresInlineTypeCtor(dirNode, this.reflector)) {\n              // inlining not required\n              continue;\n            } // Add an inline type constructor operation for the directive.\n\n\n            this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {\n              fnName: 'ngTypeCtor',\n              // The constructor should have a body if the directive comes from a .ts file, but not if\n              // it comes from a .d.ts file. .d.ts declarations don't have bodies.\n              body: !dirNode.getSourceFile().isDeclarationFile,\n              fields: {\n                inputs: dir.inputs.classPropertyNames,\n                outputs: dir.outputs.classPropertyNames,\n                // TODO(alxhub): support queries\n                queries: dir.queries\n              },\n              coercedInputFields: dir.coercedInputFields\n            });\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n\n      shimData.templates.set(templateId, {\n        template: template,\n        boundTarget: boundTarget,\n        templateDiagnostics: templateDiagnostics\n      });\n      var inliningRequirement = tcb_util_1.requiresInlineTypeCheckBlock(ref.node, pipes, this.reflector); // If inlining is not supported, but is required for either the TCB or one of its directive\n      // dependencies, then exit here with an error.\n\n      if (this.inlining === InliningMode.Error && inliningRequirement === tcb_util_1.TcbInliningRequirement.MustInline) {\n        // This template cannot be supported because the underlying strategy does not support inlining\n        // and inlining would be required.\n        // Record diagnostics to indicate the issues with this template.\n        shimData.oobRecorder.requiresInlineTcb(templateId, ref.node); // Checking this template would be unsupported, so don't try.\n\n        this.perf.eventCount(perf_1.PerfEvent.SkipGenerateTcbNoInline);\n        return;\n      }\n\n      var meta = {\n        id: fileData.sourceManager.captureSource(ref.node, sourceMapping, file),\n        boundTarget: boundTarget,\n        pipes: pipes,\n        schemas: schemas\n      };\n      this.perf.eventCount(perf_1.PerfEvent.GenerateTcb);\n\n      if (inliningRequirement !== tcb_util_1.TcbInliningRequirement.None && this.inlining === InliningMode.InlineOps) {\n        // This class didn't meet the requirements for external type checking, so generate an inline\n        // TCB for the class.\n        this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);\n      } else if (inliningRequirement === tcb_util_1.TcbInliningRequirement.ShouldInlineForGenericBounds && this.inlining === InliningMode.Error) {\n        // It's suggested that this TCB should be generated inline due to the component's generic\n        // bounds, but inlining is not supported by the current environment. Use a non-inline type\n        // check block, but fall back to `any` generic parameters since the generic bounds can't be\n        // referenced in that context. This will infer a less useful type for the component, but allow\n        // for type-checking it in an environment where that would not be possible otherwise.\n        shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, type_check_block_1.TcbGenericContextBehavior.FallbackToAny);\n      } else {\n        shimData.file.addTypeCheckBlock(ref, meta, shimData.domSchemaChecker, shimData.oobRecorder, type_check_block_1.TcbGenericContextBehavior.UseEmitter);\n      }\n    };\n    /**\n     * Record a type constructor for the given `node` with the given `ctorMetadata`.\n     */\n\n\n    TypeCheckContextImpl.prototype.addInlineTypeCtor = function (fileData, sf, ref, ctorMeta) {\n      if (this.typeCtorPending.has(ref.node)) {\n        return;\n      }\n\n      this.typeCtorPending.add(ref.node); // Lazily construct the operation map.\n\n      if (!this.opMap.has(sf)) {\n        this.opMap.set(sf, []);\n      }\n\n      var ops = this.opMap.get(sf); // Push a `TypeCtorOp` into the operation queue for the source file.\n\n      ops.push(new TypeCtorOp(ref, ctorMeta));\n      fileData.hasInlines = true;\n    };\n    /**\n     * Transform a `ts.SourceFile` into a version that includes type checking code.\n     *\n     * If this particular `ts.SourceFile` requires changes, the text representing its new contents\n     * will be returned. Otherwise, a `null` return indicates no changes were necessary.\n     */\n\n\n    TypeCheckContextImpl.prototype.transform = function (sf) {\n      var _this = this; // If there are no operations pending for this particular file, return `null` to indicate no\n      // changes.\n\n\n      if (!this.opMap.has(sf)) {\n        return null;\n      } // Imports may need to be added to the file to support type-checking of directives used in the\n      // template within it.\n\n\n      var importManager = new translator_1.ImportManager(new imports_1.NoopImportRewriter(), '_i'); // Each Op has a splitPoint index into the text where it needs to be inserted. Split the\n      // original source text into chunks at these split points, where code will be inserted between\n      // the chunks.\n\n      var ops = this.opMap.get(sf).sort(orderOps);\n      var textParts = splitStringAtPoints(sf.text, ops.map(function (op) {\n        return op.splitPoint;\n      })); // Use a `ts.Printer` to generate source code.\n\n      var printer = ts.createPrinter({\n        omitTrailingSemicolon: true\n      }); // Begin with the intial section of the code text.\n\n      var code = textParts[0]; // Process each operation and use the printer to generate source code for it, inserting it into\n      // the source code in between the original chunks.\n\n      ops.forEach(function (op, idx) {\n        var text = op.execute(importManager, sf, _this.refEmitter, printer);\n        code += '\\n\\n' + text + textParts[idx + 1];\n      }); // Write out the imports that need to be added to the beginning of the file.\n\n      var imports = importManager.getAllImports(sf.fileName).map(function (i) {\n        return \"import * as \" + i.qualifier.text + \" from '\" + i.specifier + \"';\";\n      }).join('\\n');\n      code = imports + '\\n' + code;\n      return code;\n    };\n\n    TypeCheckContextImpl.prototype.finalize = function () {\n      var e_2, _a, e_3, _b, e_4, _c; // First, build the map of updates to source files.\n\n\n      var updates = new Map();\n\n      try {\n        for (var _d = tslib_1.__values(this.opMap.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var originalSf = _e.value;\n          var newText = this.transform(originalSf);\n\n          if (newText !== null) {\n            updates.set(file_system_1.absoluteFromSourceFile(originalSf), newText);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      try {\n        // Then go through each input file that has pending code generation operations.\n        for (var _f = tslib_1.__values(this.fileMap), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var _h = tslib_1.__read(_g.value, 2),\n              sfPath = _h[0],\n              pendingFileData = _h[1];\n\n          try {\n            // For each input file, consider generation operations for each of its shims.\n            for (var _j = (e_4 = void 0, tslib_1.__values(pendingFileData.shimData.values())), _k = _j.next(); !_k.done; _k = _j.next()) {\n              var pendingShimData = _k.value;\n              this.host.recordShimData(sfPath, {\n                genesisDiagnostics: tslib_1.__spread(pendingShimData.domSchemaChecker.diagnostics, pendingShimData.oobRecorder.diagnostics),\n                hasInlines: pendingFileData.hasInlines,\n                path: pendingShimData.file.fileName,\n                templates: pendingShimData.templates\n              });\n              updates.set(pendingShimData.file.fileName, pendingShimData.file.render(false\n              /* removeComments */\n              ));\n            }\n          } catch (e_4_1) {\n            e_4 = {\n              error: e_4_1\n            };\n          } finally {\n            try {\n              if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n            } finally {\n              if (e_4) throw e_4.error;\n            }\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return updates;\n    };\n\n    TypeCheckContextImpl.prototype.addInlineTypeCheckBlock = function (fileData, shimData, ref, tcbMeta) {\n      var sf = ref.node.getSourceFile();\n\n      if (!this.opMap.has(sf)) {\n        this.opMap.set(sf, []);\n      }\n\n      var ops = this.opMap.get(sf);\n      ops.push(new InlineTcbOp(ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker, shimData.oobRecorder));\n      fileData.hasInlines = true;\n    };\n\n    TypeCheckContextImpl.prototype.pendingShimForComponent = function (node) {\n      var fileData = this.dataForFile(node.getSourceFile());\n      var shimPath = this.componentMappingStrategy.shimPathForComponent(node);\n\n      if (!fileData.shimData.has(shimPath)) {\n        fileData.shimData.set(shimPath, {\n          domSchemaChecker: new dom_1.RegistryDomSchemaChecker(fileData.sourceManager),\n          oobRecorder: new oob_1.OutOfBandDiagnosticRecorderImpl(fileData.sourceManager),\n          file: new type_check_file_1.TypeCheckFile(shimPath, this.config, this.refEmitter, this.reflector, this.compilerHost),\n          templates: new Map()\n        });\n      }\n\n      return fileData.shimData.get(shimPath);\n    };\n\n    TypeCheckContextImpl.prototype.dataForFile = function (sf) {\n      var sfPath = file_system_1.absoluteFromSourceFile(sf);\n\n      if (!this.fileMap.has(sfPath)) {\n        var data = {\n          hasInlines: false,\n          sourceManager: this.host.getSourceManager(sfPath),\n          shimData: new Map()\n        };\n        this.fileMap.set(sfPath, data);\n      }\n\n      return this.fileMap.get(sfPath);\n    };\n\n    TypeCheckContextImpl.prototype.getTemplateDiagnostics = function (parseErrors, templateId, sourceMapping) {\n      return parseErrors.map(function (error) {\n        var span = error.span;\n\n        if (span.start.offset === span.end.offset) {\n          // Template errors can contain zero-length spans, if the error occurs at a single point.\n          // However, TypeScript does not handle displaying a zero-length diagnostic very well, so\n          // increase the ending offset by 1 for such errors, to ensure the position is shown in the\n          // diagnostic.\n          span.end.offset++;\n        }\n\n        return diagnostics_2.makeTemplateDiagnostic(templateId, sourceMapping, span, ts.DiagnosticCategory.Error, diagnostics_1.ngErrorCode(diagnostics_1.ErrorCode.TEMPLATE_PARSE_ERROR), error.msg);\n      });\n    };\n\n    return TypeCheckContextImpl;\n  }();\n\n  exports.TypeCheckContextImpl = TypeCheckContextImpl;\n  /**\n   * A type check block operation which produces inline type check code for a particular component.\n   */\n\n  var InlineTcbOp =\n  /** @class */\n  function () {\n    function InlineTcbOp(ref, meta, config, reflector, domSchemaChecker, oobRecorder) {\n      this.ref = ref;\n      this.meta = meta;\n      this.config = config;\n      this.reflector = reflector;\n      this.domSchemaChecker = domSchemaChecker;\n      this.oobRecorder = oobRecorder;\n    }\n\n    Object.defineProperty(InlineTcbOp.prototype, \"splitPoint\", {\n      /**\n       * Type check blocks are inserted immediately after the end of the component class.\n       */\n      get: function get() {\n        return this.ref.node.end + 1;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    InlineTcbOp.prototype.execute = function (im, sf, refEmitter, printer) {\n      var env = new environment_1.Environment(this.config, im, refEmitter, this.reflector, sf);\n      var fnName = ts.createIdentifier(\"_tcb_\" + this.ref.node.pos); // Inline TCBs should copy any generic type parameter nodes directly, as the TCB code is inlined\n      // into the class in a context where that will always be legal.\n\n      var fn = type_check_block_1.generateTypeCheckBlock(env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder, type_check_block_1.TcbGenericContextBehavior.CopyClassNodes);\n      return printer.printNode(ts.EmitHint.Unspecified, fn, sf);\n    };\n\n    return InlineTcbOp;\n  }();\n  /**\n   * A type constructor operation which produces type constructor code for a particular directive.\n   */\n\n\n  var TypeCtorOp =\n  /** @class */\n  function () {\n    function TypeCtorOp(ref, meta) {\n      this.ref = ref;\n      this.meta = meta;\n    }\n\n    Object.defineProperty(TypeCtorOp.prototype, \"splitPoint\", {\n      /**\n       * Type constructor operations are inserted immediately before the end of the directive class.\n       */\n      get: function get() {\n        return this.ref.node.end - 1;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TypeCtorOp.prototype.execute = function (im, sf, refEmitter, printer) {\n      var tcb = type_constructor_1.generateInlineTypeCtor(this.ref.node, this.meta);\n      return printer.printNode(ts.EmitHint.Unspecified, tcb, sf);\n    };\n\n    return TypeCtorOp;\n  }();\n  /**\n   * Compare two operations and return their split point ordering.\n   */\n\n\n  function orderOps(op1, op2) {\n    return op1.splitPoint - op2.splitPoint;\n  }\n  /**\n   * Split a string into chunks at any number of split points.\n   */\n\n\n  function splitStringAtPoints(str, points) {\n    var splits = [];\n    var start = 0;\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      splits.push(str.substring(start, point));\n      start = point;\n    }\n\n    splits.push(str.substring(start));\n    return splits;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/context.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {BoundTarget, ParseError, ParseSourceFile, R3TargetBinder, SchemaMetadata, TemplateParseError, TmplAstNode} from '@angular/compiler';\nimport {ErrorCode, ngErrorCode} from '@angular/compiler-cli/src/ngtsc/diagnostics';\nimport * as ts from 'typescript';\n\nimport {absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\nimport {NoopImportRewriter, Reference, ReferenceEmitter} from '../../imports';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, ReflectionHost} from '../../reflection';\nimport {ImportManager} from '../../translator';\nimport {ComponentToShimMappingStrategy, TemplateId, TemplateSourceMapping, TypeCheckableDirectiveMeta, TypeCheckBlockMetadata, TypeCheckContext, TypeCheckingConfig, TypeCtorMetadata} from '../api';\nimport {makeTemplateDiagnostic, TemplateDiagnostic} from '../diagnostics';\n\nimport {DomSchemaChecker, RegistryDomSchemaChecker} from './dom';\nimport {Environment} from './environment';\nimport {OutOfBandDiagnosticRecorder, OutOfBandDiagnosticRecorderImpl} from './oob';\nimport {TemplateSourceManager} from './source';\nimport {requiresInlineTypeCheckBlock, TcbInliningRequirement} from './tcb_util';\nimport {generateTypeCheckBlock, TcbGenericContextBehavior} from './type_check_block';\nimport {TypeCheckFile} from './type_check_file';\nimport {generateInlineTypeCtor, requiresInlineTypeCtor} from './type_constructor';\n\nexport interface ShimTypeCheckingData {\n  /**\n   * Path to the shim file.\n   */\n  path: AbsoluteFsPath;\n\n  /**\n   * Any `ts.Diagnostic`s which were produced during the generation of this shim.\n   *\n   * Some diagnostics are produced during creation time and are tracked here.\n   */\n  genesisDiagnostics: TemplateDiagnostic[];\n\n  /**\n   * Whether any inline operations for the input file were required to generate this shim.\n   */\n  hasInlines: boolean;\n\n  /**\n   * Map of `TemplateId` to information collected about the template during the template\n   * type-checking process.\n   */\n  templates: Map<TemplateId, TemplateData>;\n}\n\n/**\n * Data tracked for each template processed by the template type-checking system.\n */\nexport interface TemplateData {\n  /**\n   * Template nodes for which the TCB was generated.\n   */\n  template: TmplAstNode[];\n\n  /**\n   * `BoundTarget` which was used to generate the TCB, and contains bindings for the associated\n   * template nodes.\n   */\n  boundTarget: BoundTarget<TypeCheckableDirectiveMeta>;\n\n  /**\n   * Errors found while parsing them template, which have been converted to diagnostics.\n   */\n  templateDiagnostics: TemplateDiagnostic[];\n}\n\n/**\n * Data for an input file which is still in the process of template type-checking code generation.\n */\nexport interface PendingFileTypeCheckingData {\n  /**\n   * Whether any inline code has been required by the shim yet.\n   */\n  hasInlines: boolean;\n\n  /**\n   * Source mapping information for mapping diagnostics from inlined type check blocks back to the\n   * original template.\n   */\n  sourceManager: TemplateSourceManager;\n\n  /**\n   * Map of in-progress shim data for shims generated from this input file.\n   */\n  shimData: Map<AbsoluteFsPath, PendingShimData>;\n}\n\nexport interface PendingShimData {\n  /**\n   * Recorder for out-of-band diagnostics which are raised during generation.\n   */\n  oobRecorder: OutOfBandDiagnosticRecorder;\n\n  /**\n   * The `DomSchemaChecker` in use for this template, which records any schema-related diagnostics.\n   */\n  domSchemaChecker: DomSchemaChecker;\n\n  /**\n   * Shim file in the process of being generated.\n   */\n  file: TypeCheckFile;\n\n\n  /**\n   * Map of `TemplateId` to information collected about the template as it's ingested.\n   */\n  templates: Map<TemplateId, TemplateData>;\n}\n\n/**\n * Adapts the `TypeCheckContextImpl` to the larger template type-checking system.\n *\n * Through this interface, a single `TypeCheckContextImpl` (which represents one \"pass\" of template\n * type-checking) requests information about the larger state of type-checking, as well as reports\n * back its results once finalized.\n */\nexport interface TypeCheckingHost {\n  /**\n   * Retrieve the `TemplateSourceManager` responsible for components in the given input file path.\n   */\n  getSourceManager(sfPath: AbsoluteFsPath): TemplateSourceManager;\n\n  /**\n   * Whether a particular component class should be included in the current type-checking pass.\n   *\n   * Not all components offered to the `TypeCheckContext` for checking may require processing. For\n   * example, the component may have results already available from a prior pass or from a previous\n   * program.\n   */\n  shouldCheckComponent(node: ts.ClassDeclaration): boolean;\n\n  /**\n   * Report data from a shim generated from the given input file path.\n   */\n  recordShimData(sfPath: AbsoluteFsPath, data: ShimTypeCheckingData): void;\n\n  /**\n   * Record that all of the components within the given input file path had code generated - that\n   * is, coverage for the file can be considered complete.\n   */\n  recordComplete(sfPath: AbsoluteFsPath): void;\n}\n\n/**\n * How a type-checking context should handle operations which would require inlining.\n */\nexport enum InliningMode {\n  /**\n   * Use inlining operations when required.\n   */\n  InlineOps,\n\n  /**\n   * Produce diagnostics if an operation would require inlining.\n   */\n  Error,\n}\n\n/**\n * A template type checking context for a program.\n *\n * The `TypeCheckContext` allows registration of components and their templates which need to be\n * type checked.\n */\nexport class TypeCheckContextImpl implements TypeCheckContext {\n  private fileMap = new Map<AbsoluteFsPath, PendingFileTypeCheckingData>();\n\n  constructor(\n      private config: TypeCheckingConfig,\n      private compilerHost: Pick<ts.CompilerHost, 'getCanonicalFileName'>,\n      private componentMappingStrategy: ComponentToShimMappingStrategy,\n      private refEmitter: ReferenceEmitter, private reflector: ReflectionHost,\n      private host: TypeCheckingHost, private inlining: InliningMode, private perf: PerfRecorder) {\n    if (inlining === InliningMode.Error && config.useInlineTypeConstructors) {\n      // We cannot use inlining for type checking since this environment does not support it.\n      throw new Error(`AssertionError: invalid inlining configuration.`);\n    }\n  }\n\n  /**\n   * A `Map` of `ts.SourceFile`s that the context has seen to the operations (additions of methods\n   * or type-check blocks) that need to be eventually performed on that file.\n   */\n  private opMap = new Map<ts.SourceFile, Op[]>();\n\n  /**\n   * Tracks when an a particular class has a pending type constructor patching operation already\n   * queued.\n   */\n  private typeCtorPending = new Set<ts.ClassDeclaration>();\n\n  /**\n   * Register a template to potentially be type-checked.\n   *\n   * Implements `TypeCheckContext.addTemplate`.\n   */\n  addTemplate(\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      binder: R3TargetBinder<TypeCheckableDirectiveMeta>, template: TmplAstNode[],\n      pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,\n      schemas: SchemaMetadata[], sourceMapping: TemplateSourceMapping, file: ParseSourceFile,\n      parseErrors: ParseError[]|null): void {\n    if (!this.host.shouldCheckComponent(ref.node)) {\n      return;\n    }\n\n    const fileData = this.dataForFile(ref.node.getSourceFile());\n    const shimData = this.pendingShimForComponent(ref.node);\n    const templateId = fileData.sourceManager.getTemplateId(ref.node);\n\n    const templateDiagnostics: TemplateDiagnostic[] = [];\n\n    if (parseErrors !== null) {\n      templateDiagnostics.push(\n          ...this.getTemplateDiagnostics(parseErrors, templateId, sourceMapping));\n    }\n\n    const boundTarget = binder.bind({template});\n\n    if (this.inlining === InliningMode.InlineOps) {\n      // Get all of the directives used in the template and record inline type constructors when\n      // required.\n      for (const dir of boundTarget.getUsedDirectives()) {\n        const dirRef = dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;\n        const dirNode = dirRef.node;\n\n        if (!dir.isGeneric || !requiresInlineTypeCtor(dirNode, this.reflector)) {\n          // inlining not required\n          continue;\n        }\n\n        // Add an inline type constructor operation for the directive.\n        this.addInlineTypeCtor(fileData, dirNode.getSourceFile(), dirRef, {\n          fnName: 'ngTypeCtor',\n          // The constructor should have a body if the directive comes from a .ts file, but not if\n          // it comes from a .d.ts file. .d.ts declarations don't have bodies.\n          body: !dirNode.getSourceFile().isDeclarationFile,\n          fields: {\n            inputs: dir.inputs.classPropertyNames,\n            outputs: dir.outputs.classPropertyNames,\n            // TODO(alxhub): support queries\n            queries: dir.queries,\n          },\n          coercedInputFields: dir.coercedInputFields,\n        });\n      }\n    }\n\n    shimData.templates.set(templateId, {\n      template,\n      boundTarget,\n      templateDiagnostics,\n    });\n\n    const inliningRequirement = requiresInlineTypeCheckBlock(ref.node, pipes, this.reflector);\n\n    // If inlining is not supported, but is required for either the TCB or one of its directive\n    // dependencies, then exit here with an error.\n    if (this.inlining === InliningMode.Error &&\n        inliningRequirement === TcbInliningRequirement.MustInline) {\n      // This template cannot be supported because the underlying strategy does not support inlining\n      // and inlining would be required.\n\n      // Record diagnostics to indicate the issues with this template.\n      shimData.oobRecorder.requiresInlineTcb(templateId, ref.node);\n\n      // Checking this template would be unsupported, so don't try.\n      this.perf.eventCount(PerfEvent.SkipGenerateTcbNoInline);\n      return;\n    }\n\n    const meta = {\n      id: fileData.sourceManager.captureSource(ref.node, sourceMapping, file),\n      boundTarget,\n      pipes,\n      schemas,\n    };\n    this.perf.eventCount(PerfEvent.GenerateTcb);\n    if (inliningRequirement !== TcbInliningRequirement.None &&\n        this.inlining === InliningMode.InlineOps) {\n      // This class didn't meet the requirements for external type checking, so generate an inline\n      // TCB for the class.\n      this.addInlineTypeCheckBlock(fileData, shimData, ref, meta);\n    } else if (\n        inliningRequirement === TcbInliningRequirement.ShouldInlineForGenericBounds &&\n        this.inlining === InliningMode.Error) {\n      // It's suggested that this TCB should be generated inline due to the component's generic\n      // bounds, but inlining is not supported by the current environment. Use a non-inline type\n      // check block, but fall back to `any` generic parameters since the generic bounds can't be\n      // referenced in that context. This will infer a less useful type for the component, but allow\n      // for type-checking it in an environment where that would not be possible otherwise.\n      shimData.file.addTypeCheckBlock(\n          ref, meta, shimData.domSchemaChecker, shimData.oobRecorder,\n          TcbGenericContextBehavior.FallbackToAny);\n    } else {\n      shimData.file.addTypeCheckBlock(\n          ref, meta, shimData.domSchemaChecker, shimData.oobRecorder,\n          TcbGenericContextBehavior.UseEmitter);\n    }\n  }\n\n  /**\n   * Record a type constructor for the given `node` with the given `ctorMetadata`.\n   */\n  addInlineTypeCtor(\n      fileData: PendingFileTypeCheckingData, sf: ts.SourceFile,\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, ctorMeta: TypeCtorMetadata): void {\n    if (this.typeCtorPending.has(ref.node)) {\n      return;\n    }\n    this.typeCtorPending.add(ref.node);\n\n    // Lazily construct the operation map.\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf)!;\n\n    // Push a `TypeCtorOp` into the operation queue for the source file.\n    ops.push(new TypeCtorOp(ref, ctorMeta));\n    fileData.hasInlines = true;\n  }\n\n  /**\n   * Transform a `ts.SourceFile` into a version that includes type checking code.\n   *\n   * If this particular `ts.SourceFile` requires changes, the text representing its new contents\n   * will be returned. Otherwise, a `null` return indicates no changes were necessary.\n   */\n  transform(sf: ts.SourceFile): string|null {\n    // If there are no operations pending for this particular file, return `null` to indicate no\n    // changes.\n    if (!this.opMap.has(sf)) {\n      return null;\n    }\n\n    // Imports may need to be added to the file to support type-checking of directives used in the\n    // template within it.\n    const importManager = new ImportManager(new NoopImportRewriter(), '_i');\n\n    // Each Op has a splitPoint index into the text where it needs to be inserted. Split the\n    // original source text into chunks at these split points, where code will be inserted between\n    // the chunks.\n    const ops = this.opMap.get(sf)!.sort(orderOps);\n    const textParts = splitStringAtPoints(sf.text, ops.map(op => op.splitPoint));\n\n    // Use a `ts.Printer` to generate source code.\n    const printer = ts.createPrinter({omitTrailingSemicolon: true});\n\n    // Begin with the intial section of the code text.\n    let code = textParts[0];\n\n    // Process each operation and use the printer to generate source code for it, inserting it into\n    // the source code in between the original chunks.\n    ops.forEach((op, idx) => {\n      const text = op.execute(importManager, sf, this.refEmitter, printer);\n      code += '\\n\\n' + text + textParts[idx + 1];\n    });\n\n    // Write out the imports that need to be added to the beginning of the file.\n    let imports = importManager.getAllImports(sf.fileName)\n                      .map(i => `import * as ${i.qualifier.text} from '${i.specifier}';`)\n                      .join('\\n');\n    code = imports + '\\n' + code;\n\n    return code;\n  }\n\n  finalize(): Map<AbsoluteFsPath, string> {\n    // First, build the map of updates to source files.\n    const updates = new Map<AbsoluteFsPath, string>();\n    for (const originalSf of this.opMap.keys()) {\n      const newText = this.transform(originalSf);\n      if (newText !== null) {\n        updates.set(absoluteFromSourceFile(originalSf), newText);\n      }\n    }\n\n    // Then go through each input file that has pending code generation operations.\n    for (const [sfPath, pendingFileData] of this.fileMap) {\n      // For each input file, consider generation operations for each of its shims.\n      for (const pendingShimData of pendingFileData.shimData.values()) {\n        this.host.recordShimData(sfPath, {\n          genesisDiagnostics: [\n            ...pendingShimData.domSchemaChecker.diagnostics,\n            ...pendingShimData.oobRecorder.diagnostics,\n          ],\n          hasInlines: pendingFileData.hasInlines,\n          path: pendingShimData.file.fileName,\n          templates: pendingShimData.templates,\n        });\n        updates.set(\n            pendingShimData.file.fileName, pendingShimData.file.render(false /* removeComments */));\n      }\n    }\n\n    return updates;\n  }\n\n  private addInlineTypeCheckBlock(\n      fileData: PendingFileTypeCheckingData, shimData: PendingShimData,\n      ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      tcbMeta: TypeCheckBlockMetadata): void {\n    const sf = ref.node.getSourceFile();\n    if (!this.opMap.has(sf)) {\n      this.opMap.set(sf, []);\n    }\n    const ops = this.opMap.get(sf)!;\n    ops.push(new InlineTcbOp(\n        ref, tcbMeta, this.config, this.reflector, shimData.domSchemaChecker,\n        shimData.oobRecorder));\n    fileData.hasInlines = true;\n  }\n\n  private pendingShimForComponent(node: ts.ClassDeclaration): PendingShimData {\n    const fileData = this.dataForFile(node.getSourceFile());\n    const shimPath = this.componentMappingStrategy.shimPathForComponent(node);\n    if (!fileData.shimData.has(shimPath)) {\n      fileData.shimData.set(shimPath, {\n        domSchemaChecker: new RegistryDomSchemaChecker(fileData.sourceManager),\n        oobRecorder: new OutOfBandDiagnosticRecorderImpl(fileData.sourceManager),\n        file: new TypeCheckFile(\n            shimPath, this.config, this.refEmitter, this.reflector, this.compilerHost),\n        templates: new Map<TemplateId, TemplateData>(),\n      });\n    }\n    return fileData.shimData.get(shimPath)!;\n  }\n\n  private dataForFile(sf: ts.SourceFile): PendingFileTypeCheckingData {\n    const sfPath = absoluteFromSourceFile(sf);\n\n    if (!this.fileMap.has(sfPath)) {\n      const data: PendingFileTypeCheckingData = {\n        hasInlines: false,\n        sourceManager: this.host.getSourceManager(sfPath),\n        shimData: new Map(),\n      };\n      this.fileMap.set(sfPath, data);\n    }\n\n    return this.fileMap.get(sfPath)!;\n  }\n\n  private getTemplateDiagnostics(\n      parseErrors: ParseError[], templateId: TemplateId,\n      sourceMapping: TemplateSourceMapping): TemplateDiagnostic[] {\n    return parseErrors.map(error => {\n      const span = error.span;\n\n      if (span.start.offset === span.end.offset) {\n        // Template errors can contain zero-length spans, if the error occurs at a single point.\n        // However, TypeScript does not handle displaying a zero-length diagnostic very well, so\n        // increase the ending offset by 1 for such errors, to ensure the position is shown in the\n        // diagnostic.\n        span.end.offset++;\n      }\n\n      return makeTemplateDiagnostic(\n          templateId, sourceMapping, span, ts.DiagnosticCategory.Error,\n          ngErrorCode(ErrorCode.TEMPLATE_PARSE_ERROR), error.msg);\n    });\n  }\n}\n\n/**\n * A code generation operation that needs to happen within a given source file.\n */\ninterface Op {\n  /**\n   * The node in the file which will have code generated for it.\n   */\n  readonly ref: Reference<ClassDeclaration<ts.ClassDeclaration>>;\n\n  /**\n   * Index into the source text where the code generated by the operation should be inserted.\n   */\n  readonly splitPoint: number;\n\n  /**\n   * Execute the operation and return the generated code as text.\n   */\n  execute(im: ImportManager, sf: ts.SourceFile, refEmitter: ReferenceEmitter, printer: ts.Printer):\n      string;\n}\n\n/**\n * A type check block operation which produces inline type check code for a particular component.\n */\nclass InlineTcbOp implements Op {\n  constructor(\n      readonly ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      readonly meta: TypeCheckBlockMetadata, readonly config: TypeCheckingConfig,\n      readonly reflector: ReflectionHost, readonly domSchemaChecker: DomSchemaChecker,\n      readonly oobRecorder: OutOfBandDiagnosticRecorder) {}\n\n  /**\n   * Type check blocks are inserted immediately after the end of the component class.\n   */\n  get splitPoint(): number {\n    return this.ref.node.end + 1;\n  }\n\n  execute(im: ImportManager, sf: ts.SourceFile, refEmitter: ReferenceEmitter, printer: ts.Printer):\n      string {\n    const env = new Environment(this.config, im, refEmitter, this.reflector, sf);\n    const fnName = ts.createIdentifier(`_tcb_${this.ref.node.pos}`);\n\n    // Inline TCBs should copy any generic type parameter nodes directly, as the TCB code is inlined\n    // into the class in a context where that will always be legal.\n    const fn = generateTypeCheckBlock(\n        env, this.ref, fnName, this.meta, this.domSchemaChecker, this.oobRecorder,\n        TcbGenericContextBehavior.CopyClassNodes);\n    return printer.printNode(ts.EmitHint.Unspecified, fn, sf);\n  }\n}\n\n/**\n * A type constructor operation which produces type constructor code for a particular directive.\n */\nclass TypeCtorOp implements Op {\n  constructor(\n      readonly ref: Reference<ClassDeclaration<ts.ClassDeclaration>>,\n      readonly meta: TypeCtorMetadata) {}\n\n  /**\n   * Type constructor operations are inserted immediately before the end of the directive class.\n   */\n  get splitPoint(): number {\n    return this.ref.node.end - 1;\n  }\n\n  execute(im: ImportManager, sf: ts.SourceFile, refEmitter: ReferenceEmitter, printer: ts.Printer):\n      string {\n    const tcb = generateInlineTypeCtor(this.ref.node, this.meta);\n    return printer.printNode(ts.EmitHint.Unspecified, tcb, sf);\n  }\n}\n\n/**\n * Compare two operations and return their split point ordering.\n */\nfunction orderOps(op1: Op, op2: Op): number {\n  return op1.splitPoint - op2.splitPoint;\n}\n\n/**\n * Split a string into chunks at any number of split points.\n */\nfunction splitStringAtPoints(str: string, points: number[]): string[] {\n  const splits: string[] = [];\n  let start = 0;\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    splits.push(str.substring(start, point));\n    start = point;\n  }\n  splits.push(str.substring(start));\n  return splits;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}