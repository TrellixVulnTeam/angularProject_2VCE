{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/ngcc/src/writing/in_place_file_writer\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NewEntryPointFileWriter = exports.NGCC_PROPERTY_EXTENSION = exports.NGCC_DIRECTORY = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var in_place_file_writer_1 = require(\"@angular/compiler-cli/ngcc/src/writing/in_place_file_writer\");\n\n  exports.NGCC_DIRECTORY = '__ivy_ngcc__';\n  exports.NGCC_PROPERTY_EXTENSION = '_ivy_ngcc';\n  /**\n   * This FileWriter creates a copy of the original entry-point, then writes the transformed\n   * files onto the files in this copy, and finally updates the package.json with a new\n   * entry-point format property that points to this new entry-point.\n   *\n   * If there are transformed typings files in this bundle, they are updated in-place (see the\n   * `InPlaceFileWriter`).\n   */\n\n  var NewEntryPointFileWriter =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(NewEntryPointFileWriter, _super);\n\n    function NewEntryPointFileWriter(fs, logger, errorOnFailedEntryPoint, pkgJsonUpdater) {\n      var _this = _super.call(this, fs, logger, errorOnFailedEntryPoint) || this;\n\n      _this.pkgJsonUpdater = pkgJsonUpdater;\n      return _this;\n    }\n\n    NewEntryPointFileWriter.prototype.writeBundle = function (bundle, transformedFiles, formatProperties) {\n      var _this = this; // The new folder is at the root of the overall package\n\n\n      var entryPoint = bundle.entryPoint;\n      var ngccFolder = this.fs.join(entryPoint.packagePath, exports.NGCC_DIRECTORY);\n      this.copyBundle(bundle, entryPoint.packagePath, ngccFolder, transformedFiles);\n      transformedFiles.forEach(function (file) {\n        return _this.writeFile(file, entryPoint.packagePath, ngccFolder);\n      });\n      this.updatePackageJson(entryPoint, formatProperties, ngccFolder);\n    };\n\n    NewEntryPointFileWriter.prototype.revertBundle = function (entryPoint, transformedFilePaths, formatProperties) {\n      // IMPLEMENTATION NOTE:\n      //\n      // The changes made by `copyBundle()` are not reverted here. The non-transformed copied files\n      // are identical to the original ones and they will be overwritten when re-processing the\n      // entry-point anyway.\n      //\n      // This way, we avoid the overhead of having to inform the master process about all source files\n      // being copied in `copyBundle()`.\n      var e_1, _a;\n\n      try {\n        // Revert the transformed files.\n        for (var transformedFilePaths_1 = tslib_1.__values(transformedFilePaths), transformedFilePaths_1_1 = transformedFilePaths_1.next(); !transformedFilePaths_1_1.done; transformedFilePaths_1_1 = transformedFilePaths_1.next()) {\n          var filePath = transformedFilePaths_1_1.value;\n          this.revertFile(filePath, entryPoint.packagePath);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (transformedFilePaths_1_1 && !transformedFilePaths_1_1.done && (_a = transformedFilePaths_1.return)) _a.call(transformedFilePaths_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Revert any changes to `package.json`.\n\n\n      this.revertPackageJson(entryPoint, formatProperties);\n    };\n\n    NewEntryPointFileWriter.prototype.copyBundle = function (bundle, packagePath, ngccFolder, transformedFiles) {\n      var _this = this;\n\n      var doNotCopy = new Set(transformedFiles.map(function (f) {\n        return f.path;\n      }));\n      bundle.src.program.getSourceFiles().forEach(function (sourceFile) {\n        var originalPath = file_system_1.absoluteFromSourceFile(sourceFile);\n\n        if (doNotCopy.has(originalPath)) {\n          return;\n        }\n\n        var relativePath = _this.fs.relative(packagePath, originalPath);\n\n        var isInsidePackage = file_system_1.isLocalRelativePath(relativePath);\n\n        if (!sourceFile.isDeclarationFile && isInsidePackage) {\n          var newPath = _this.fs.resolve(ngccFolder, relativePath);\n\n          _this.fs.ensureDir(_this.fs.dirname(newPath));\n\n          _this.fs.copyFile(originalPath, newPath);\n\n          _this.copyAndUpdateSourceMap(originalPath, newPath);\n        }\n      });\n    };\n    /**\n     * If a source file has an associated source-map, then copy this, while updating its sourceRoot\n     * accordingly.\n     *\n     * For now don't try to parse the source for inline source-maps or external source-map links,\n     * since that is more complex and will slow ngcc down.\n     * Instead just check for a source-map file residing next to the source file, which is by far\n     * the most common case.\n     *\n     * @param originalSrcPath absolute path to the original source file being copied.\n     * @param newSrcPath absolute path to where the source will be written.\n     */\n\n\n    NewEntryPointFileWriter.prototype.copyAndUpdateSourceMap = function (originalSrcPath, newSrcPath) {\n      var _a;\n\n      var sourceMapPath = originalSrcPath + '.map';\n\n      if (this.fs.exists(sourceMapPath)) {\n        try {\n          var sourceMap = JSON.parse(this.fs.readFile(sourceMapPath));\n          var newSourceMapPath = newSrcPath + '.map';\n          var relativePath = this.fs.relative(this.fs.dirname(newSourceMapPath), this.fs.dirname(sourceMapPath));\n          sourceMap.sourceRoot = this.fs.join(relativePath, sourceMap.sourceRoot || '.');\n          this.fs.ensureDir(this.fs.dirname(newSourceMapPath));\n          this.fs.writeFile(newSourceMapPath, JSON.stringify(sourceMap));\n        } catch (e) {\n          this.logger.warn(\"Failed to process source-map at \" + sourceMapPath);\n          this.logger.warn((_a = e.message) !== null && _a !== void 0 ? _a : e);\n        }\n      }\n    };\n\n    NewEntryPointFileWriter.prototype.writeFile = function (file, packagePath, ngccFolder) {\n      if (typescript_1.isDtsPath(file.path.replace(/\\.map$/, ''))) {\n        // This is either `.d.ts` or `.d.ts.map` file\n        _super.prototype.writeFileAndBackup.call(this, file);\n      } else {\n        var relativePath = this.fs.relative(packagePath, file.path);\n        var newFilePath = this.fs.resolve(ngccFolder, relativePath);\n        this.fs.ensureDir(this.fs.dirname(newFilePath));\n        this.fs.writeFile(newFilePath, file.contents);\n      }\n    };\n\n    NewEntryPointFileWriter.prototype.revertFile = function (filePath, packagePath) {\n      if (typescript_1.isDtsPath(filePath.replace(/\\.map$/, ''))) {\n        // This is either `.d.ts` or `.d.ts.map` file\n        _super.prototype.revertFileAndBackup.call(this, filePath);\n      } else if (this.fs.exists(filePath)) {\n        var relativePath = this.fs.relative(packagePath, filePath);\n        var newFilePath = this.fs.resolve(packagePath, exports.NGCC_DIRECTORY, relativePath);\n        this.fs.removeFile(newFilePath);\n      }\n    };\n\n    NewEntryPointFileWriter.prototype.updatePackageJson = function (entryPoint, formatProperties, ngccFolder) {\n      var e_2, _a;\n\n      if (formatProperties.length === 0) {\n        // No format properties need updating.\n        return;\n      }\n\n      var packageJson = entryPoint.packageJson;\n      var packageJsonPath = this.fs.join(entryPoint.path, 'package.json'); // All format properties point to the same format-path.\n\n      var oldFormatProp = formatProperties[0];\n      var oldFormatPath = packageJson[oldFormatProp];\n      var oldAbsFormatPath = this.fs.resolve(entryPoint.path, oldFormatPath);\n      var newAbsFormatPath = this.fs.resolve(ngccFolder, this.fs.relative(entryPoint.packagePath, oldAbsFormatPath));\n      var newFormatPath = this.fs.relative(entryPoint.path, newAbsFormatPath); // Update all properties in `package.json` (both in memory and on disk).\n\n      var update = this.pkgJsonUpdater.createUpdate();\n\n      try {\n        for (var formatProperties_1 = tslib_1.__values(formatProperties), formatProperties_1_1 = formatProperties_1.next(); !formatProperties_1_1.done; formatProperties_1_1 = formatProperties_1.next()) {\n          var formatProperty = formatProperties_1_1.value;\n\n          if (packageJson[formatProperty] !== oldFormatPath) {\n            throw new Error(\"Unable to update '\" + packageJsonPath + \"': Format properties \" + (\"(\" + formatProperties.join(', ') + \") map to more than one format-path.\"));\n          }\n\n          update.addChange([\"\" + formatProperty + exports.NGCC_PROPERTY_EXTENSION], newFormatPath, {\n            before: formatProperty\n          });\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (formatProperties_1_1 && !formatProperties_1_1.done && (_a = formatProperties_1.return)) _a.call(formatProperties_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      update.writeChanges(packageJsonPath, packageJson);\n    };\n\n    NewEntryPointFileWriter.prototype.revertPackageJson = function (entryPoint, formatProperties) {\n      var e_3, _a;\n\n      if (formatProperties.length === 0) {\n        // No format properties need reverting.\n        return;\n      }\n\n      var packageJson = entryPoint.packageJson;\n      var packageJsonPath = this.fs.join(entryPoint.path, 'package.json'); // Revert all properties in `package.json` (both in memory and on disk).\n      // Since `updatePackageJson()` only adds properties, it is safe to just remove them (if they\n      // exist).\n\n      var update = this.pkgJsonUpdater.createUpdate();\n\n      try {\n        for (var formatProperties_2 = tslib_1.__values(formatProperties), formatProperties_2_1 = formatProperties_2.next(); !formatProperties_2_1.done; formatProperties_2_1 = formatProperties_2.next()) {\n          var formatProperty = formatProperties_2_1.value;\n          update.addChange([\"\" + formatProperty + exports.NGCC_PROPERTY_EXTENSION], undefined);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (formatProperties_2_1 && !formatProperties_2_1.done && (_a = formatProperties_2.return)) _a.call(formatProperties_2);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      update.writeChanges(packageJsonPath, packageJson);\n    };\n\n    return NewEntryPointFileWriter;\n  }(in_place_file_writer_1.InPlaceFileWriter);\n\n  exports.NewEntryPointFileWriter = NewEntryPointFileWriter;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/writing/new_entry_point_file_writer.ts"],"names":[],"mappings":"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","sourcesContent":["\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {absoluteFromSourceFile, AbsoluteFsPath, FileSystem, isLocalRelativePath} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {isDtsPath} from '../../../src/ngtsc/util/src/typescript';\nimport {EntryPoint, EntryPointJsonProperty} from '../packages/entry_point';\nimport {EntryPointBundle} from '../packages/entry_point_bundle';\nimport {FileToWrite} from '../rendering/utils';\n\nimport {InPlaceFileWriter} from './in_place_file_writer';\nimport {PackageJsonUpdater} from './package_json_updater';\n\nexport const NGCC_DIRECTORY = '__ivy_ngcc__';\nexport const NGCC_PROPERTY_EXTENSION = '_ivy_ngcc';\n\n/**\n * This FileWriter creates a copy of the original entry-point, then writes the transformed\n * files onto the files in this copy, and finally updates the package.json with a new\n * entry-point format property that points to this new entry-point.\n *\n * If there are transformed typings files in this bundle, they are updated in-place (see the\n * `InPlaceFileWriter`).\n */\nexport class NewEntryPointFileWriter extends InPlaceFileWriter {\n  constructor(\n      fs: FileSystem, logger: Logger, errorOnFailedEntryPoint: boolean,\n      private pkgJsonUpdater: PackageJsonUpdater) {\n    super(fs, logger, errorOnFailedEntryPoint);\n  }\n\n  writeBundle(\n      bundle: EntryPointBundle, transformedFiles: FileToWrite[],\n      formatProperties: EntryPointJsonProperty[]) {\n    // The new folder is at the root of the overall package\n    const entryPoint = bundle.entryPoint;\n    const ngccFolder = this.fs.join(entryPoint.packagePath, NGCC_DIRECTORY);\n    this.copyBundle(bundle, entryPoint.packagePath, ngccFolder, transformedFiles);\n    transformedFiles.forEach(file => this.writeFile(file, entryPoint.packagePath, ngccFolder));\n    this.updatePackageJson(entryPoint, formatProperties, ngccFolder);\n  }\n\n  revertBundle(\n      entryPoint: EntryPoint, transformedFilePaths: AbsoluteFsPath[],\n      formatProperties: EntryPointJsonProperty[]): void {\n    // IMPLEMENTATION NOTE:\n    //\n    // The changes made by `copyBundle()` are not reverted here. The non-transformed copied files\n    // are identical to the original ones and they will be overwritten when re-processing the\n    // entry-point anyway.\n    //\n    // This way, we avoid the overhead of having to inform the master process about all source files\n    // being copied in `copyBundle()`.\n\n    // Revert the transformed files.\n    for (const filePath of transformedFilePaths) {\n      this.revertFile(filePath, entryPoint.packagePath);\n    }\n\n    // Revert any changes to `package.json`.\n    this.revertPackageJson(entryPoint, formatProperties);\n  }\n\n  protected copyBundle(\n      bundle: EntryPointBundle, packagePath: AbsoluteFsPath, ngccFolder: AbsoluteFsPath,\n      transformedFiles: FileToWrite[]) {\n    const doNotCopy = new Set(transformedFiles.map(f => f.path));\n    bundle.src.program.getSourceFiles().forEach(sourceFile => {\n      const originalPath = absoluteFromSourceFile(sourceFile);\n      if (doNotCopy.has(originalPath)) {\n        return;\n      }\n      const relativePath = this.fs.relative(packagePath, originalPath);\n      const isInsidePackage = isLocalRelativePath(relativePath);\n      if (!sourceFile.isDeclarationFile && isInsidePackage) {\n        const newPath = this.fs.resolve(ngccFolder, relativePath);\n        this.fs.ensureDir(this.fs.dirname(newPath));\n        this.fs.copyFile(originalPath, newPath);\n        this.copyAndUpdateSourceMap(originalPath, newPath);\n      }\n    });\n  }\n\n  /**\n   * If a source file has an associated source-map, then copy this, while updating its sourceRoot\n   * accordingly.\n   *\n   * For now don't try to parse the source for inline source-maps or external source-map links,\n   * since that is more complex and will slow ngcc down.\n   * Instead just check for a source-map file residing next to the source file, which is by far\n   * the most common case.\n   *\n   * @param originalSrcPath absolute path to the original source file being copied.\n   * @param newSrcPath absolute path to where the source will be written.\n   */\n  protected copyAndUpdateSourceMap(originalSrcPath: AbsoluteFsPath, newSrcPath: AbsoluteFsPath):\n      void {\n    const sourceMapPath = (originalSrcPath + '.map') as AbsoluteFsPath;\n    if (this.fs.exists(sourceMapPath)) {\n      try {\n        const sourceMap =\n            JSON.parse(this.fs.readFile(sourceMapPath)) as {sourceRoot: string, [key: string]: any};\n        const newSourceMapPath = (newSrcPath + '.map') as AbsoluteFsPath;\n        const relativePath =\n            this.fs.relative(this.fs.dirname(newSourceMapPath), this.fs.dirname(sourceMapPath));\n        sourceMap.sourceRoot = this.fs.join(relativePath, sourceMap.sourceRoot || '.');\n        this.fs.ensureDir(this.fs.dirname(newSourceMapPath));\n        this.fs.writeFile(newSourceMapPath, JSON.stringify(sourceMap));\n      } catch (e) {\n        this.logger.warn(`Failed to process source-map at ${sourceMapPath}`);\n        this.logger.warn(e.message ?? e);\n      }\n    }\n  }\n\n  protected writeFile(file: FileToWrite, packagePath: AbsoluteFsPath, ngccFolder: AbsoluteFsPath):\n      void {\n    if (isDtsPath(file.path.replace(/\\.map$/, ''))) {\n      // This is either `.d.ts` or `.d.ts.map` file\n      super.writeFileAndBackup(file);\n    } else {\n      const relativePath = this.fs.relative(packagePath, file.path);\n      const newFilePath = this.fs.resolve(ngccFolder, relativePath);\n      this.fs.ensureDir(this.fs.dirname(newFilePath));\n      this.fs.writeFile(newFilePath, file.contents);\n    }\n  }\n\n  protected revertFile(filePath: AbsoluteFsPath, packagePath: AbsoluteFsPath): void {\n    if (isDtsPath(filePath.replace(/\\.map$/, ''))) {\n      // This is either `.d.ts` or `.d.ts.map` file\n      super.revertFileAndBackup(filePath);\n    } else if (this.fs.exists(filePath)) {\n      const relativePath = this.fs.relative(packagePath, filePath);\n      const newFilePath = this.fs.resolve(packagePath, NGCC_DIRECTORY, relativePath);\n      this.fs.removeFile(newFilePath);\n    }\n  }\n\n  protected updatePackageJson(\n      entryPoint: EntryPoint, formatProperties: EntryPointJsonProperty[],\n      ngccFolder: AbsoluteFsPath) {\n    if (formatProperties.length === 0) {\n      // No format properties need updating.\n      return;\n    }\n\n    const packageJson = entryPoint.packageJson;\n    const packageJsonPath = this.fs.join(entryPoint.path, 'package.json');\n\n    // All format properties point to the same format-path.\n    const oldFormatProp = formatProperties[0]!;\n    const oldFormatPath = packageJson[oldFormatProp]!;\n    const oldAbsFormatPath = this.fs.resolve(entryPoint.path, oldFormatPath);\n    const newAbsFormatPath =\n        this.fs.resolve(ngccFolder, this.fs.relative(entryPoint.packagePath, oldAbsFormatPath));\n    const newFormatPath = this.fs.relative(entryPoint.path, newAbsFormatPath);\n\n    // Update all properties in `package.json` (both in memory and on disk).\n    const update = this.pkgJsonUpdater.createUpdate();\n\n    for (const formatProperty of formatProperties) {\n      if (packageJson[formatProperty] !== oldFormatPath) {\n        throw new Error(\n            `Unable to update '${packageJsonPath}': Format properties ` +\n            `(${formatProperties.join(', ')}) map to more than one format-path.`);\n      }\n\n      update.addChange(\n          [`${formatProperty}${NGCC_PROPERTY_EXTENSION}`], newFormatPath, {before: formatProperty});\n    }\n\n    update.writeChanges(packageJsonPath, packageJson);\n  }\n\n  protected revertPackageJson(entryPoint: EntryPoint, formatProperties: EntryPointJsonProperty[]) {\n    if (formatProperties.length === 0) {\n      // No format properties need reverting.\n      return;\n    }\n\n    const packageJson = entryPoint.packageJson;\n    const packageJsonPath = this.fs.join(entryPoint.path, 'package.json');\n\n    // Revert all properties in `package.json` (both in memory and on disk).\n    // Since `updatePackageJson()` only adds properties, it is safe to just remove them (if they\n    // exist).\n    const update = this.pkgJsonUpdater.createUpdate();\n\n    for (const formatProperty of formatProperties) {\n      update.addChange([`${formatProperty}${NGCC_PROPERTY_EXTENSION}`], undefined);\n    }\n\n    update.writeChanges(packageJsonPath, packageJson);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}