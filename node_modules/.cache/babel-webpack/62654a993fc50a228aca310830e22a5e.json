{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <reference types=\"node\" />\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/perf/src/recorder\", [\"require\", \"exports\", \"@angular/compiler-cli/src/ngtsc/perf/src/api\", \"@angular/compiler-cli/src/ngtsc/perf/src/clock\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.DelegatingPerfRecorder = exports.ActivePerfRecorder = void 0;\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/perf/src/api\");\n\n  var clock_1 = require(\"@angular/compiler-cli/src/ngtsc/perf/src/clock\");\n  /**\n   * A `PerfRecorder` that actively tracks performance statistics.\n   */\n\n\n  var ActivePerfRecorder =\n  /** @class */\n  function () {\n    function ActivePerfRecorder(zeroTime) {\n      this.zeroTime = zeroTime;\n      this.currentPhase = api_1.PerfPhase.Unaccounted;\n      this.currentPhaseEntered = this.zeroTime;\n      this.counters = Array(api_1.PerfEvent.LAST).fill(0);\n      this.phaseTime = Array(api_1.PerfPhase.LAST).fill(0);\n      this.bytes = Array(api_1.PerfCheckpoint.LAST).fill(0); // Take an initial memory snapshot before any other compilation work begins.\n\n      this.memory(api_1.PerfCheckpoint.Initial);\n    }\n    /**\n     * Creates an `ActivePerfRecoder` with its zero point set to the current time.\n     */\n\n\n    ActivePerfRecorder.zeroedToNow = function () {\n      return new ActivePerfRecorder(clock_1.mark());\n    };\n\n    ActivePerfRecorder.prototype.reset = function () {\n      this.counters = Array(api_1.PerfEvent.LAST).fill(0);\n      this.phaseTime = Array(api_1.PerfPhase.LAST).fill(0);\n      this.bytes = Array(api_1.PerfCheckpoint.LAST).fill(0);\n      this.zeroTime = clock_1.mark();\n      this.currentPhase = api_1.PerfPhase.Unaccounted;\n      this.currentPhaseEntered = this.zeroTime;\n    };\n\n    ActivePerfRecorder.prototype.memory = function (after) {\n      this.bytes[after] = process.memoryUsage().heapUsed;\n    };\n\n    ActivePerfRecorder.prototype.phase = function (phase) {\n      var previous = this.currentPhase;\n      this.phaseTime[this.currentPhase] += clock_1.timeSinceInMicros(this.currentPhaseEntered);\n      this.currentPhase = phase;\n      this.currentPhaseEntered = clock_1.mark();\n      return previous;\n    };\n\n    ActivePerfRecorder.prototype.inPhase = function (phase, fn) {\n      var previousPhase = this.phase(phase);\n\n      try {\n        return fn();\n      } finally {\n        this.phase(previousPhase);\n      }\n    };\n\n    ActivePerfRecorder.prototype.eventCount = function (counter, incrementBy) {\n      if (incrementBy === void 0) {\n        incrementBy = 1;\n      }\n\n      this.counters[counter] += incrementBy;\n    };\n    /**\n     * Return the current performance metrics as a serializable object.\n     */\n\n\n    ActivePerfRecorder.prototype.finalize = function () {\n      // Track the last segment of time spent in `this.currentPhase` in the time array.\n      this.phase(api_1.PerfPhase.Unaccounted);\n      var results = {\n        events: {},\n        phases: {},\n        memory: {}\n      };\n\n      for (var i = 0; i < this.phaseTime.length; i++) {\n        if (this.phaseTime[i] > 0) {\n          results.phases[api_1.PerfPhase[i]] = this.phaseTime[i];\n        }\n      }\n\n      for (var i = 0; i < this.phaseTime.length; i++) {\n        if (this.counters[i] > 0) {\n          results.events[api_1.PerfEvent[i]] = this.counters[i];\n        }\n      }\n\n      for (var i = 0; i < this.bytes.length; i++) {\n        if (this.bytes[i] > 0) {\n          results.memory[api_1.PerfCheckpoint[i]] = this.bytes[i];\n        }\n      }\n\n      return results;\n    };\n\n    return ActivePerfRecorder;\n  }();\n\n  exports.ActivePerfRecorder = ActivePerfRecorder;\n  /**\n   * A `PerfRecorder` that delegates to a target `PerfRecorder` which can be updated later.\n   *\n   * `DelegatingPerfRecorder` is useful when a compiler class that needs a `PerfRecorder` can outlive\n   * the current compilation. This is true for most compiler classes as resource-only changes reuse\n   * the same `NgCompiler` for a new compilation.\n   */\n\n  var DelegatingPerfRecorder =\n  /** @class */\n  function () {\n    function DelegatingPerfRecorder(target) {\n      this.target = target;\n    }\n\n    DelegatingPerfRecorder.prototype.eventCount = function (counter, incrementBy) {\n      this.target.eventCount(counter, incrementBy);\n    };\n\n    DelegatingPerfRecorder.prototype.phase = function (phase) {\n      return this.target.phase(phase);\n    };\n\n    DelegatingPerfRecorder.prototype.inPhase = function (phase, fn) {\n      // Note: this doesn't delegate to `this.target.inPhase` but instead is implemented manually here\n      // to avoid adding an additional frame of noise to the stack when debugging.\n      var previousPhase = this.target.phase(phase);\n\n      try {\n        return fn();\n      } finally {\n        this.target.phase(previousPhase);\n      }\n    };\n\n    DelegatingPerfRecorder.prototype.memory = function (after) {\n      this.target.memory(after);\n    };\n\n    DelegatingPerfRecorder.prototype.reset = function () {\n      this.target.reset();\n    };\n\n    return DelegatingPerfRecorder;\n  }();\n\n  exports.DelegatingPerfRecorder = DelegatingPerfRecorder;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/perf/src/recorder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/// <reference types=\"node\" />\n\nimport {PerfCheckpoint, PerfEvent, PerfPhase, PerfRecorder} from './api';\nimport {HrTime, mark, timeSinceInMicros} from './clock';\n\n/**\n * Serializable performance data for the compilation, using string names.\n */\nexport interface PerfResults {\n  events: Record<string, number>;\n  phases: Record<string, number>;\n  memory: Record<string, number>;\n}\n\n/**\n * A `PerfRecorder` that actively tracks performance statistics.\n */\nexport class ActivePerfRecorder implements PerfRecorder {\n  private counters: number[];\n  private phaseTime: number[];\n  private bytes: number[];\n\n  private currentPhase = PerfPhase.Unaccounted;\n  private currentPhaseEntered = this.zeroTime;\n\n  /**\n   * Creates an `ActivePerfRecoder` with its zero point set to the current time.\n   */\n  static zeroedToNow(): ActivePerfRecorder {\n    return new ActivePerfRecorder(mark());\n  }\n\n  private constructor(private zeroTime: HrTime) {\n    this.counters = Array(PerfEvent.LAST).fill(0);\n    this.phaseTime = Array(PerfPhase.LAST).fill(0);\n    this.bytes = Array(PerfCheckpoint.LAST).fill(0);\n\n    // Take an initial memory snapshot before any other compilation work begins.\n    this.memory(PerfCheckpoint.Initial);\n  }\n\n  reset(): void {\n    this.counters = Array(PerfEvent.LAST).fill(0);\n    this.phaseTime = Array(PerfPhase.LAST).fill(0);\n    this.bytes = Array(PerfCheckpoint.LAST).fill(0);\n    this.zeroTime = mark();\n    this.currentPhase = PerfPhase.Unaccounted;\n    this.currentPhaseEntered = this.zeroTime;\n  }\n\n  memory(after: PerfCheckpoint): void {\n    this.bytes[after] = process.memoryUsage().heapUsed;\n  }\n\n  phase(phase: PerfPhase): PerfPhase {\n    const previous = this.currentPhase;\n    this.phaseTime[this.currentPhase] += timeSinceInMicros(this.currentPhaseEntered);\n    this.currentPhase = phase;\n    this.currentPhaseEntered = mark();\n    return previous;\n  }\n\n  inPhase<T>(phase: PerfPhase, fn: () => T): T {\n    const previousPhase = this.phase(phase);\n    try {\n      return fn();\n    } finally {\n      this.phase(previousPhase);\n    }\n  }\n\n  eventCount(counter: PerfEvent, incrementBy: number = 1): void {\n    this.counters[counter] += incrementBy;\n  }\n\n  /**\n   * Return the current performance metrics as a serializable object.\n   */\n  finalize(): PerfResults {\n    // Track the last segment of time spent in `this.currentPhase` in the time array.\n    this.phase(PerfPhase.Unaccounted);\n\n    const results: PerfResults = {\n      events: {},\n      phases: {},\n      memory: {},\n    };\n\n    for (let i = 0; i < this.phaseTime.length; i++) {\n      if (this.phaseTime[i] > 0) {\n        results.phases[PerfPhase[i]] = this.phaseTime[i];\n      }\n    }\n\n    for (let i = 0; i < this.phaseTime.length; i++) {\n      if (this.counters[i] > 0) {\n        results.events[PerfEvent[i]] = this.counters[i];\n      }\n    }\n\n    for (let i = 0; i < this.bytes.length; i++) {\n      if (this.bytes[i] > 0) {\n        results.memory[PerfCheckpoint[i]] = this.bytes[i];\n      }\n    }\n\n    return results;\n  }\n}\n\n/**\n * A `PerfRecorder` that delegates to a target `PerfRecorder` which can be updated later.\n *\n * `DelegatingPerfRecorder` is useful when a compiler class that needs a `PerfRecorder` can outlive\n * the current compilation. This is true for most compiler classes as resource-only changes reuse\n * the same `NgCompiler` for a new compilation.\n */\nexport class DelegatingPerfRecorder implements PerfRecorder {\n  constructor(public target: PerfRecorder) {}\n\n  eventCount(counter: PerfEvent, incrementBy?: number): void {\n    this.target.eventCount(counter, incrementBy);\n  }\n\n  phase(phase: PerfPhase): PerfPhase {\n    return this.target.phase(phase);\n  }\n\n  inPhase<T>(phase: PerfPhase, fn: () => T): T {\n    // Note: this doesn't delegate to `this.target.inPhase` but instead is implemented manually here\n    // to avoid adding an additional frame of noise to the stack when debugging.\n    const previousPhase = this.target.phase(phase);\n    try {\n      return fn();\n    } finally {\n      this.target.phase(previousPhase);\n    }\n  }\n\n  memory(after: PerfCheckpoint): void {\n    this.target.memory(after);\n  }\n\n  reset(): void {\n    this.target.reset();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}