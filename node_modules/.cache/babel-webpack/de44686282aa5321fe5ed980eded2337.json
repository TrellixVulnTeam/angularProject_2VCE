{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/metadata/src/resource_registry\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ResourceRegistry = exports.isExternalResource = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  function isExternalResource(resource) {\n    return resource.path !== null;\n  }\n\n  exports.isExternalResource = isExternalResource;\n  /**\n   * Tracks the mapping between external template/style files and the component(s) which use them.\n   *\n   * This information is produced during analysis of the program and is used mainly to support\n   * external tooling, for which such a mapping is challenging to determine without compiler\n   * assistance.\n   */\n\n  var ResourceRegistry =\n  /** @class */\n  function () {\n    function ResourceRegistry() {\n      this.externalTemplateToComponentsMap = new Map();\n      this.componentToTemplateMap = new Map();\n      this.componentToStylesMap = new Map();\n      this.externalStyleToComponentsMap = new Map();\n    }\n\n    ResourceRegistry.prototype.getComponentsWithTemplate = function (template) {\n      if (!this.externalTemplateToComponentsMap.has(template)) {\n        return new Set();\n      }\n\n      return this.externalTemplateToComponentsMap.get(template);\n    };\n\n    ResourceRegistry.prototype.registerResources = function (resources, component) {\n      var e_1, _a;\n\n      if (resources.template !== null) {\n        this.registerTemplate(resources.template, component);\n      }\n\n      try {\n        for (var _b = tslib_1.__values(resources.styles), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var style = _c.value;\n          this.registerStyle(style, component);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    };\n\n    ResourceRegistry.prototype.registerTemplate = function (templateResource, component) {\n      var path = templateResource.path;\n\n      if (path !== null) {\n        if (!this.externalTemplateToComponentsMap.has(path)) {\n          this.externalTemplateToComponentsMap.set(path, new Set());\n        }\n\n        this.externalTemplateToComponentsMap.get(path).add(component);\n      }\n\n      this.componentToTemplateMap.set(component, templateResource);\n    };\n\n    ResourceRegistry.prototype.getTemplate = function (component) {\n      if (!this.componentToTemplateMap.has(component)) {\n        return null;\n      }\n\n      return this.componentToTemplateMap.get(component);\n    };\n\n    ResourceRegistry.prototype.registerStyle = function (styleResource, component) {\n      var path = styleResource.path;\n\n      if (!this.componentToStylesMap.has(component)) {\n        this.componentToStylesMap.set(component, new Set());\n      }\n\n      if (path !== null) {\n        if (!this.externalStyleToComponentsMap.has(path)) {\n          this.externalStyleToComponentsMap.set(path, new Set());\n        }\n\n        this.externalStyleToComponentsMap.get(path).add(component);\n      }\n\n      this.componentToStylesMap.get(component).add(styleResource);\n    };\n\n    ResourceRegistry.prototype.getStyles = function (component) {\n      if (!this.componentToStylesMap.has(component)) {\n        return new Set();\n      }\n\n      return this.componentToStylesMap.get(component);\n    };\n\n    ResourceRegistry.prototype.getComponentsWithStyle = function (styleUrl) {\n      if (!this.externalStyleToComponentsMap.has(styleUrl)) {\n        return new Set();\n      }\n\n      return this.externalStyleToComponentsMap.get(styleUrl);\n    };\n\n    return ResourceRegistry;\n  }();\n\n  exports.ResourceRegistry = ResourceRegistry;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/metadata/src/resource_registry.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {ClassDeclaration} from '../../reflection';\n\n/**\n * Represents an resource for a component and contains the `AbsoluteFsPath`\n * to the file which was resolved by evaluating the `ts.Expression` (generally, a relative or\n * absolute string path to the resource).\n *\n * If the resource is inline, the `path` will be `null`.\n */\nexport interface Resource {\n  path: AbsoluteFsPath|null;\n  expression: ts.Expression;\n}\n\nexport interface ExternalResource extends Resource {\n  path: AbsoluteFsPath;\n}\n\nexport function isExternalResource(resource: Resource): resource is ExternalResource {\n  return resource.path !== null;\n}\n\n/**\n * Represents the either inline or external resources of a component.\n *\n * A resource with a `path` of `null` is considered inline.\n */\nexport interface ComponentResources {\n  template: Resource;\n  styles: ReadonlySet<Resource>;\n}\n\n/**\n * Tracks the mapping between external template/style files and the component(s) which use them.\n *\n * This information is produced during analysis of the program and is used mainly to support\n * external tooling, for which such a mapping is challenging to determine without compiler\n * assistance.\n */\nexport class ResourceRegistry {\n  private externalTemplateToComponentsMap = new Map<AbsoluteFsPath, Set<ClassDeclaration>>();\n  private componentToTemplateMap = new Map<ClassDeclaration, Resource>();\n  private componentToStylesMap = new Map<ClassDeclaration, Set<Resource>>();\n  private externalStyleToComponentsMap = new Map<AbsoluteFsPath, Set<ClassDeclaration>>();\n\n  getComponentsWithTemplate(template: AbsoluteFsPath): ReadonlySet<ClassDeclaration> {\n    if (!this.externalTemplateToComponentsMap.has(template)) {\n      return new Set();\n    }\n\n    return this.externalTemplateToComponentsMap.get(template)!;\n  }\n\n  registerResources(resources: ComponentResources, component: ClassDeclaration) {\n    if (resources.template !== null) {\n      this.registerTemplate(resources.template, component);\n    }\n    for (const style of resources.styles) {\n      this.registerStyle(style, component);\n    }\n  }\n\n  registerTemplate(templateResource: Resource, component: ClassDeclaration): void {\n    const {path} = templateResource;\n    if (path !== null) {\n      if (!this.externalTemplateToComponentsMap.has(path)) {\n        this.externalTemplateToComponentsMap.set(path, new Set());\n      }\n      this.externalTemplateToComponentsMap.get(path)!.add(component);\n    }\n    this.componentToTemplateMap.set(component, templateResource);\n  }\n\n  getTemplate(component: ClassDeclaration): Resource|null {\n    if (!this.componentToTemplateMap.has(component)) {\n      return null;\n    }\n    return this.componentToTemplateMap.get(component)!;\n  }\n\n  registerStyle(styleResource: Resource, component: ClassDeclaration): void {\n    const {path} = styleResource;\n    if (!this.componentToStylesMap.has(component)) {\n      this.componentToStylesMap.set(component, new Set());\n    }\n    if (path !== null) {\n      if (!this.externalStyleToComponentsMap.has(path)) {\n        this.externalStyleToComponentsMap.set(path, new Set());\n      }\n      this.externalStyleToComponentsMap.get(path)!.add(component);\n    }\n    this.componentToStylesMap.get(component)!.add(styleResource);\n  }\n\n  getStyles(component: ClassDeclaration): Set<Resource> {\n    if (!this.componentToStylesMap.has(component)) {\n      return new Set();\n    }\n    return this.componentToStylesMap.get(component)!;\n  }\n\n  getComponentsWithStyle(styleUrl: AbsoluteFsPath): ReadonlySet<ClassDeclaration> {\n    if (!this.externalStyleToComponentsMap.has(styleUrl)) {\n      return new Set();\n    }\n\n    return this.externalStyleToComponentsMap.get(styleUrl)!;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}