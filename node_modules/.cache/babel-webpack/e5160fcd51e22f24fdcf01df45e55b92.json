{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/node_emitter\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/translator\", \"@angular/compiler-cli/src/transformers/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NodeEmitterVisitor = exports.updateSourceFile = exports.TypeScriptNodeEmitter = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var translator_1 = require(\"@angular/compiler-cli/src/ngtsc/translator\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/transformers/util\");\n\n  var METHOD_THIS_NAME = 'this';\n  var CATCH_ERROR_NAME = 'error';\n  var CATCH_STACK_NAME = 'stack';\n  var _VALID_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\n\n  var TypeScriptNodeEmitter =\n  /** @class */\n  function () {\n    function TypeScriptNodeEmitter(annotateForClosureCompiler) {\n      this.annotateForClosureCompiler = annotateForClosureCompiler;\n    }\n\n    TypeScriptNodeEmitter.prototype.updateSourceFile = function (sourceFile, stmts, preamble) {\n      var converter = new NodeEmitterVisitor(this.annotateForClosureCompiler); // [].concat flattens the result so that each `visit...` method can also return an array of\n      // stmts.\n\n      var statements = [].concat.apply([], tslib_1.__spread(stmts.map(function (stmt) {\n        return stmt.visitStatement(converter, null);\n      }).filter(function (stmt) {\n        return stmt != null;\n      })));\n\n      var sourceStatements = tslib_1.__spread(converter.getReexports(), converter.getImports(), statements);\n\n      if (preamble) {\n        // We always attach the preamble comment to a `NotEmittedStatement` node, because tsickle uses\n        // this node type as a marker of the preamble to ensure that it adds its own new nodes after\n        // the preamble.\n        var preambleCommentHolder = ts.createNotEmittedStatement(sourceFile); // Preamble comments are passed through as-is, which means that they must already contain a\n        // leading `*` if they should be a JSDOC comment.\n\n        ts.addSyntheticLeadingComment(preambleCommentHolder, ts.SyntaxKind.MultiLineCommentTrivia, preamble,\n        /* hasTrailingNewline */\n        true);\n        sourceStatements.unshift(preambleCommentHolder);\n      }\n\n      converter.updateSourceMap(sourceStatements);\n      var newSourceFile = ts.updateSourceFileNode(sourceFile, sourceStatements);\n      return [newSourceFile, converter.getNodeMap()];\n    };\n\n    return TypeScriptNodeEmitter;\n  }();\n\n  exports.TypeScriptNodeEmitter = TypeScriptNodeEmitter;\n  /**\n   * Update the given source file to include the changes specified in module.\n   *\n   * The module parameter is treated as a partial module meaning that the statements are added to\n   * the module instead of replacing the module. Also, any classes are treated as partial classes\n   * and the included members are added to the class with the same name instead of a new class\n   * being created.\n   */\n\n  function updateSourceFile(sourceFile, module, annotateForClosureCompiler) {\n    var converter = new NodeEmitterVisitor(annotateForClosureCompiler);\n    converter.loadExportedVariableIdentifiers(sourceFile);\n    var prefixStatements = module.statements.filter(function (statement) {\n      return !(statement instanceof compiler_1.ClassStmt);\n    });\n    var classes = module.statements.filter(function (statement) {\n      return statement instanceof compiler_1.ClassStmt;\n    });\n    var classMap = new Map(classes.map(function (classStatement) {\n      return [classStatement.name, classStatement];\n    }));\n    var classNames = new Set(classes.map(function (classStatement) {\n      return classStatement.name;\n    }));\n    var prefix = prefixStatements.map(function (statement) {\n      return statement.visitStatement(converter, sourceFile);\n    }); // Add static methods to all the classes referenced in module.\n\n    var newStatements = sourceFile.statements.map(function (node) {\n      if (node.kind == ts.SyntaxKind.ClassDeclaration) {\n        var classDeclaration = node;\n        var name = classDeclaration.name;\n\n        if (name) {\n          var classStatement = classMap.get(name.text);\n\n          if (classStatement) {\n            classNames.delete(name.text);\n            var classMemberHolder = converter.visitDeclareClassStmt(classStatement);\n            var newMethods = classMemberHolder.members.filter(function (member) {\n              return member.kind !== ts.SyntaxKind.Constructor;\n            });\n\n            var newMembers = tslib_1.__spread(classDeclaration.members, newMethods);\n\n            return ts.updateClassDeclaration(classDeclaration,\n            /* decorators */\n            classDeclaration.decorators,\n            /* modifiers */\n            classDeclaration.modifiers,\n            /* name */\n            classDeclaration.name,\n            /* typeParameters */\n            classDeclaration.typeParameters,\n            /* heritageClauses */\n            classDeclaration.heritageClauses || [],\n            /* members */\n            newMembers);\n          }\n        }\n      }\n\n      return node;\n    }); // Validate that all the classes have been generated\n\n    classNames.size == 0 || util_1.error((classNames.size == 1 ? 'Class' : 'Classes') + \" \\\"\" + Array.from(classNames.keys()).join(', ') + \"\\\" not generated\"); // Add imports to the module required by the new methods\n\n    var imports = converter.getImports();\n\n    if (imports && imports.length) {\n      // Find where the new imports should go\n      var index = firstAfter(newStatements, function (statement) {\n        return statement.kind === ts.SyntaxKind.ImportDeclaration || statement.kind === ts.SyntaxKind.ImportEqualsDeclaration;\n      });\n      newStatements = tslib_1.__spread(newStatements.slice(0, index), imports, prefix, newStatements.slice(index));\n    } else {\n      newStatements = tslib_1.__spread(prefix, newStatements);\n    }\n\n    converter.updateSourceMap(newStatements);\n    var newSourceFile = ts.updateSourceFileNode(sourceFile, newStatements);\n    return [newSourceFile, converter.getNodeMap()];\n  }\n\n  exports.updateSourceFile = updateSourceFile; // Return the index after the first value in `a` that doesn't match the predicate after a value that\n  // does or 0 if no values match.\n\n  function firstAfter(a, predicate) {\n    var index = 0;\n    var len = a.length;\n\n    for (; index < len; index++) {\n      var value = a[index];\n      if (predicate(value)) break;\n    }\n\n    if (index >= len) return 0;\n\n    for (; index < len; index++) {\n      var value = a[index];\n      if (!predicate(value)) break;\n    }\n\n    return index;\n  }\n\n  function escapeLiteral(value) {\n    return value.replace(/(\\\"|\\\\)/g, '\\\\$1').replace(/(\\n)|(\\r)/g, function (v, n, r) {\n      return n ? '\\\\n' : '\\\\r';\n    });\n  }\n\n  function createLiteral(value) {\n    if (value === null) {\n      return ts.createNull();\n    } else if (value === undefined) {\n      return ts.createIdentifier('undefined');\n    } else {\n      var result = ts.createLiteral(value);\n\n      if (ts.isStringLiteral(result) && result.text.indexOf('\\\\') >= 0) {\n        // Hack to avoid problems cause indirectly by:\n        //    https://github.com/Microsoft/TypeScript/issues/20192\n        // This avoids the string escaping normally performed for a string relying on that\n        // TypeScript just emits the text raw for a numeric literal.\n        result.kind = ts.SyntaxKind.NumericLiteral;\n        result.text = \"\\\"\" + escapeLiteral(result.text) + \"\\\"\";\n      }\n\n      return result;\n    }\n  }\n\n  function isExportTypeStatement(statement) {\n    return !!statement.modifiers && statement.modifiers.some(function (mod) {\n      return mod.kind === ts.SyntaxKind.ExportKeyword;\n    });\n  }\n  /**\n   * Visits an output ast and produces the corresponding TypeScript synthetic nodes.\n   */\n\n\n  var NodeEmitterVisitor =\n  /** @class */\n  function () {\n    function NodeEmitterVisitor(annotateForClosureCompiler) {\n      this.annotateForClosureCompiler = annotateForClosureCompiler;\n      this._nodeMap = new Map();\n      this._importsWithPrefixes = new Map();\n      this._reexports = new Map();\n      this._templateSources = new Map();\n      this._exportedVariableIdentifiers = new Map();\n    }\n    /**\n     * Process the source file and collect exported identifiers that refer to variables.\n     *\n     * Only variables are collected because exported classes still exist in the module scope in\n     * CommonJS, whereas variables have their declarations moved onto the `exports` object, and all\n     * references are updated accordingly.\n     */\n\n\n    NodeEmitterVisitor.prototype.loadExportedVariableIdentifiers = function (sourceFile) {\n      var _this = this;\n\n      sourceFile.statements.forEach(function (statement) {\n        if (ts.isVariableStatement(statement) && isExportTypeStatement(statement)) {\n          statement.declarationList.declarations.forEach(function (declaration) {\n            if (ts.isIdentifier(declaration.name)) {\n              _this._exportedVariableIdentifiers.set(declaration.name.text, declaration.name);\n            }\n          });\n        }\n      });\n    };\n\n    NodeEmitterVisitor.prototype.getReexports = function () {\n      return Array.from(this._reexports.entries()).map(function (_a) {\n        var _b = tslib_1.__read(_a, 2),\n            exportedFilePath = _b[0],\n            reexports = _b[1];\n\n        return ts.createExportDeclaration(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        undefined, ts.createNamedExports(reexports.map(function (_a) {\n          var name = _a.name,\n              as = _a.as;\n          return ts.createExportSpecifier(name, as);\n        })),\n        /* moduleSpecifier */\n        createLiteral(exportedFilePath));\n      });\n    };\n\n    NodeEmitterVisitor.prototype.getImports = function () {\n      return Array.from(this._importsWithPrefixes.entries()).map(function (_a) {\n        var _b = tslib_1.__read(_a, 2),\n            namespace = _b[0],\n            prefix = _b[1];\n\n        return ts.createImportDeclaration(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        undefined,\n        /* importClause */\n        ts.createImportClause(\n        /* name */\n        undefined, ts.createNamespaceImport(ts.createIdentifier(prefix))),\n        /* moduleSpecifier */\n        createLiteral(namespace));\n      });\n    };\n\n    NodeEmitterVisitor.prototype.getNodeMap = function () {\n      return this._nodeMap;\n    };\n\n    NodeEmitterVisitor.prototype.updateSourceMap = function (statements) {\n      var _this = this;\n\n      var lastRangeStartNode = undefined;\n      var lastRangeEndNode = undefined;\n      var lastRange = undefined;\n\n      var recordLastSourceRange = function recordLastSourceRange() {\n        if (lastRange && lastRangeStartNode && lastRangeEndNode) {\n          if (lastRangeStartNode == lastRangeEndNode) {\n            ts.setSourceMapRange(lastRangeEndNode, lastRange);\n          } else {\n            ts.setSourceMapRange(lastRangeStartNode, lastRange); // Only emit the pos for the first node emitted in the range.\n\n            ts.setEmitFlags(lastRangeStartNode, ts.EmitFlags.NoTrailingSourceMap);\n            ts.setSourceMapRange(lastRangeEndNode, lastRange); // Only emit emit end for the last node emitted in the range.\n\n            ts.setEmitFlags(lastRangeEndNode, ts.EmitFlags.NoLeadingSourceMap);\n          }\n        }\n      };\n\n      var visitNode = function visitNode(tsNode) {\n        var ngNode = _this._nodeMap.get(tsNode);\n\n        if (ngNode) {\n          var range = _this.sourceRangeOf(ngNode);\n\n          if (range) {\n            if (!lastRange || range.source != lastRange.source || range.pos != lastRange.pos || range.end != lastRange.end) {\n              recordLastSourceRange();\n              lastRangeStartNode = tsNode;\n              lastRange = range;\n            }\n\n            lastRangeEndNode = tsNode;\n          }\n        }\n\n        ts.forEachChild(tsNode, visitNode);\n      };\n\n      statements.forEach(visitNode);\n      recordLastSourceRange();\n    };\n\n    NodeEmitterVisitor.prototype.postProcess = function (ngNode, tsNode) {\n      if (tsNode && !this._nodeMap.has(tsNode)) {\n        this._nodeMap.set(tsNode, ngNode);\n      }\n\n      if (tsNode !== null && ngNode instanceof compiler_1.Statement && ngNode.leadingComments !== undefined) {\n        translator_1.attachComments(tsNode, ngNode.leadingComments);\n      }\n\n      return tsNode;\n    };\n\n    NodeEmitterVisitor.prototype.sourceRangeOf = function (node) {\n      if (node.sourceSpan) {\n        var span = node.sourceSpan;\n\n        if (span.start.file == span.end.file) {\n          var file = span.start.file;\n\n          if (file.url) {\n            var source = this._templateSources.get(file);\n\n            if (!source) {\n              source = ts.createSourceMapSource(file.url, file.content, function (pos) {\n                return pos;\n              });\n\n              this._templateSources.set(file, source);\n            }\n\n            return {\n              pos: span.start.offset,\n              end: span.end.offset,\n              source: source\n            };\n          }\n        }\n      }\n\n      return null;\n    };\n\n    NodeEmitterVisitor.prototype.getModifiers = function (stmt) {\n      var modifiers = [];\n\n      if (stmt.hasModifier(compiler_1.StmtModifier.Exported)) {\n        modifiers.push(ts.createToken(ts.SyntaxKind.ExportKeyword));\n      }\n\n      return modifiers;\n    }; // StatementVisitor\n\n\n    NodeEmitterVisitor.prototype.visitDeclareVarStmt = function (stmt) {\n      if (stmt.hasModifier(compiler_1.StmtModifier.Exported) && stmt.value instanceof compiler_1.ExternalExpr && !stmt.type) {\n        // check for a reexport\n        var _a = stmt.value.value,\n            name = _a.name,\n            moduleName = _a.moduleName;\n\n        if (moduleName) {\n          var reexports = this._reexports.get(moduleName);\n\n          if (!reexports) {\n            reexports = [];\n\n            this._reexports.set(moduleName, reexports);\n          }\n\n          reexports.push({\n            name: name,\n            as: stmt.name\n          });\n          return null;\n        }\n      }\n\n      var varDeclList = ts.createVariableDeclarationList([ts.createVariableDeclaration(ts.createIdentifier(stmt.name),\n      /* type */\n      undefined, stmt.value && stmt.value.visitExpression(this, null) || undefined)]);\n\n      if (stmt.hasModifier(compiler_1.StmtModifier.Exported)) {\n        // Note: We need to add an explicit variable and export declaration so that\n        // the variable can be referred in the same file as well.\n        var tsVarStmt = this.postProcess(stmt, ts.createVariableStatement(\n        /* modifiers */\n        [], varDeclList));\n        var exportStmt = this.postProcess(stmt, ts.createExportDeclaration(\n        /*decorators*/\n        undefined,\n        /*modifiers*/\n        undefined, ts.createNamedExports([ts.createExportSpecifier(stmt.name, stmt.name)])));\n        return [tsVarStmt, exportStmt];\n      }\n\n      return this.postProcess(stmt, ts.createVariableStatement(this.getModifiers(stmt), varDeclList));\n    };\n\n    NodeEmitterVisitor.prototype.visitDeclareFunctionStmt = function (stmt) {\n      return this.postProcess(stmt, ts.createFunctionDeclaration(\n      /* decorators */\n      undefined, this.getModifiers(stmt),\n      /* asteriskToken */\n      undefined, stmt.name,\n      /* typeParameters */\n      undefined, stmt.params.map(function (p) {\n        return ts.createParameter(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        undefined,\n        /* dotDotDotToken */\n        undefined, p.name);\n      }),\n      /* type */\n      undefined, this._visitStatements(stmt.statements)));\n    };\n\n    NodeEmitterVisitor.prototype.visitExpressionStmt = function (stmt) {\n      return this.postProcess(stmt, ts.createStatement(stmt.expr.visitExpression(this, null)));\n    };\n\n    NodeEmitterVisitor.prototype.visitReturnStmt = function (stmt) {\n      return this.postProcess(stmt, ts.createReturn(stmt.value ? stmt.value.visitExpression(this, null) : undefined));\n    };\n\n    NodeEmitterVisitor.prototype.visitDeclareClassStmt = function (stmt) {\n      var _this = this;\n\n      var modifiers = this.getModifiers(stmt);\n      var fields = stmt.fields.map(function (field) {\n        var property = ts.createProperty(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        translateModifiers(field.modifiers), field.name,\n        /* questionToken */\n        undefined,\n        /* type */\n        undefined, field.initializer == null ? ts.createNull() : field.initializer.visitExpression(_this, null));\n\n        if (_this.annotateForClosureCompiler) {\n          // Closure compiler transforms the form `Service.ɵprov = X` into `Service$ɵprov = X`. To\n          // prevent this transformation, such assignments need to be annotated with @nocollapse.\n          // Note that tsickle is typically responsible for adding such annotations, however it\n          // doesn't yet handle synthetic fields added during other transformations.\n          ts.addSyntheticLeadingComment(property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ',\n          /* hasTrailingNewLine */\n          false);\n        }\n\n        return property;\n      });\n      var getters = stmt.getters.map(function (getter) {\n        return ts.createGetAccessor(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        undefined, getter.name,\n        /* parameters */\n        [],\n        /* type */\n        undefined, _this._visitStatements(getter.body));\n      });\n      var constructor = stmt.constructorMethod && [ts.createConstructor(\n      /* decorators */\n      undefined,\n      /* modifiers */\n      undefined,\n      /* parameters */\n      stmt.constructorMethod.params.map(function (p) {\n        return ts.createParameter(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        undefined,\n        /* dotDotDotToken */\n        undefined, p.name);\n      }), this._visitStatements(stmt.constructorMethod.body))] || []; // TODO {chuckj}: Determine what should be done for a method with a null name.\n\n      var methods = stmt.methods.filter(function (method) {\n        return method.name;\n      }).map(function (method) {\n        return ts.createMethod(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        translateModifiers(method.modifiers),\n        /* astriskToken */\n        undefined, method.name\n        /* guarded by filter */\n        ,\n        /* questionToken */\n        undefined,\n        /* typeParameters */\n        undefined, method.params.map(function (p) {\n          return ts.createParameter(\n          /* decorators */\n          undefined,\n          /* modifiers */\n          undefined,\n          /* dotDotDotToken */\n          undefined, p.name);\n        }),\n        /* type */\n        undefined, _this._visitStatements(method.body));\n      });\n      return this.postProcess(stmt, ts.createClassDeclaration(\n      /* decorators */\n      undefined, modifiers, stmt.name,\n      /* typeParameters*/\n      undefined, stmt.parent && [ts.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [stmt.parent.visitExpression(this, null)])] || [], tslib_1.__spread(fields, getters, constructor, methods)));\n    };\n\n    NodeEmitterVisitor.prototype.visitIfStmt = function (stmt) {\n      return this.postProcess(stmt, ts.createIf(stmt.condition.visitExpression(this, null), this._visitStatements(stmt.trueCase), stmt.falseCase && stmt.falseCase.length && this._visitStatements(stmt.falseCase) || undefined));\n    };\n\n    NodeEmitterVisitor.prototype.visitTryCatchStmt = function (stmt) {\n      return this.postProcess(stmt, ts.createTry(this._visitStatements(stmt.bodyStmts), ts.createCatchClause(CATCH_ERROR_NAME, this._visitStatementsPrefix([ts.createVariableStatement(\n      /* modifiers */\n      undefined, [ts.createVariableDeclaration(CATCH_STACK_NAME,\n      /* type */\n      undefined, ts.createPropertyAccess(ts.createIdentifier(CATCH_ERROR_NAME), ts.createIdentifier(CATCH_STACK_NAME)))])], stmt.catchStmts)),\n      /* finallyBlock */\n      undefined));\n    };\n\n    NodeEmitterVisitor.prototype.visitThrowStmt = function (stmt) {\n      return this.postProcess(stmt, ts.createThrow(stmt.error.visitExpression(this, null)));\n    }; // ExpressionVisitor\n\n\n    NodeEmitterVisitor.prototype.visitWrappedNodeExpr = function (expr) {\n      return this.postProcess(expr, expr.node);\n    };\n\n    NodeEmitterVisitor.prototype.visitTypeofExpr = function (expr) {\n      var typeOf = ts.createTypeOf(expr.expr.visitExpression(this, null));\n      return this.postProcess(expr, typeOf);\n    }; // ExpressionVisitor\n\n\n    NodeEmitterVisitor.prototype.visitReadVarExpr = function (expr) {\n      switch (expr.builtin) {\n        case compiler_1.BuiltinVar.This:\n          return this.postProcess(expr, ts.createIdentifier(METHOD_THIS_NAME));\n\n        case compiler_1.BuiltinVar.CatchError:\n          return this.postProcess(expr, ts.createIdentifier(CATCH_ERROR_NAME));\n\n        case compiler_1.BuiltinVar.CatchStack:\n          return this.postProcess(expr, ts.createIdentifier(CATCH_STACK_NAME));\n\n        case compiler_1.BuiltinVar.Super:\n          return this.postProcess(expr, ts.createSuper());\n      }\n\n      if (expr.name) {\n        return this.postProcess(expr, ts.createIdentifier(expr.name));\n      }\n\n      throw Error(\"Unexpected ReadVarExpr form\");\n    };\n\n    NodeEmitterVisitor.prototype.visitWriteVarExpr = function (expr) {\n      return this.postProcess(expr, ts.createAssignment(ts.createIdentifier(expr.name), expr.value.visitExpression(this, null)));\n    };\n\n    NodeEmitterVisitor.prototype.visitWriteKeyExpr = function (expr) {\n      return this.postProcess(expr, ts.createAssignment(ts.createElementAccess(expr.receiver.visitExpression(this, null), expr.index.visitExpression(this, null)), expr.value.visitExpression(this, null)));\n    };\n\n    NodeEmitterVisitor.prototype.visitWritePropExpr = function (expr) {\n      return this.postProcess(expr, ts.createAssignment(ts.createPropertyAccess(expr.receiver.visitExpression(this, null), expr.name), expr.value.visitExpression(this, null)));\n    };\n\n    NodeEmitterVisitor.prototype.visitInvokeMethodExpr = function (expr) {\n      var _this = this;\n\n      var methodName = getMethodName(expr);\n      return this.postProcess(expr, ts.createCall(ts.createPropertyAccess(expr.receiver.visitExpression(this, null), methodName),\n      /* typeArguments */\n      undefined, expr.args.map(function (arg) {\n        return arg.visitExpression(_this, null);\n      })));\n    };\n\n    NodeEmitterVisitor.prototype.visitInvokeFunctionExpr = function (expr) {\n      var _this = this;\n\n      return this.postProcess(expr, ts.createCall(expr.fn.visitExpression(this, null),\n      /* typeArguments */\n      undefined, expr.args.map(function (arg) {\n        return arg.visitExpression(_this, null);\n      })));\n    };\n\n    NodeEmitterVisitor.prototype.visitTaggedTemplateExpr = function (expr) {\n      throw new Error('tagged templates are not supported in pre-ivy mode.');\n    };\n\n    NodeEmitterVisitor.prototype.visitInstantiateExpr = function (expr) {\n      var _this = this;\n\n      return this.postProcess(expr, ts.createNew(expr.classExpr.visitExpression(this, null),\n      /* typeArguments */\n      undefined, expr.args.map(function (arg) {\n        return arg.visitExpression(_this, null);\n      })));\n    };\n\n    NodeEmitterVisitor.prototype.visitLiteralExpr = function (expr) {\n      return this.postProcess(expr, createLiteral(expr.value));\n    };\n\n    NodeEmitterVisitor.prototype.visitLocalizedString = function (expr, context) {\n      throw new Error('localized strings are not supported in pre-ivy mode.');\n    };\n\n    NodeEmitterVisitor.prototype.visitExternalExpr = function (expr) {\n      return this.postProcess(expr, this._visitIdentifier(expr.value));\n    };\n\n    NodeEmitterVisitor.prototype.visitConditionalExpr = function (expr) {\n      // TODO {chuckj}: Review use of ! on falseCase. Should it be non-nullable?\n      return this.postProcess(expr, ts.createParen(ts.createConditional(expr.condition.visitExpression(this, null), expr.trueCase.visitExpression(this, null), expr.falseCase.visitExpression(this, null))));\n    };\n\n    NodeEmitterVisitor.prototype.visitNotExpr = function (expr) {\n      return this.postProcess(expr, ts.createPrefix(ts.SyntaxKind.ExclamationToken, expr.condition.visitExpression(this, null)));\n    };\n\n    NodeEmitterVisitor.prototype.visitAssertNotNullExpr = function (expr) {\n      return expr.condition.visitExpression(this, null);\n    };\n\n    NodeEmitterVisitor.prototype.visitCastExpr = function (expr) {\n      return expr.value.visitExpression(this, null);\n    };\n\n    NodeEmitterVisitor.prototype.visitFunctionExpr = function (expr) {\n      return this.postProcess(expr, ts.createFunctionExpression(\n      /* modifiers */\n      undefined,\n      /* astriskToken */\n      undefined,\n      /* name */\n      expr.name || undefined,\n      /* typeParameters */\n      undefined, expr.params.map(function (p) {\n        return ts.createParameter(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        undefined,\n        /* dotDotDotToken */\n        undefined, p.name);\n      }),\n      /* type */\n      undefined, this._visitStatements(expr.statements)));\n    };\n\n    NodeEmitterVisitor.prototype.visitUnaryOperatorExpr = function (expr) {\n      var unaryOperator;\n\n      switch (expr.operator) {\n        case compiler_1.UnaryOperator.Minus:\n          unaryOperator = ts.SyntaxKind.MinusToken;\n          break;\n\n        case compiler_1.UnaryOperator.Plus:\n          unaryOperator = ts.SyntaxKind.PlusToken;\n          break;\n\n        default:\n          throw new Error(\"Unknown operator: \" + expr.operator);\n      }\n\n      var binary = ts.createPrefix(unaryOperator, expr.expr.visitExpression(this, null));\n      return this.postProcess(expr, expr.parens ? ts.createParen(binary) : binary);\n    };\n\n    NodeEmitterVisitor.prototype.visitBinaryOperatorExpr = function (expr) {\n      var binaryOperator;\n\n      switch (expr.operator) {\n        case compiler_1.BinaryOperator.And:\n          binaryOperator = ts.SyntaxKind.AmpersandAmpersandToken;\n          break;\n\n        case compiler_1.BinaryOperator.BitwiseAnd:\n          binaryOperator = ts.SyntaxKind.AmpersandToken;\n          break;\n\n        case compiler_1.BinaryOperator.Bigger:\n          binaryOperator = ts.SyntaxKind.GreaterThanToken;\n          break;\n\n        case compiler_1.BinaryOperator.BiggerEquals:\n          binaryOperator = ts.SyntaxKind.GreaterThanEqualsToken;\n          break;\n\n        case compiler_1.BinaryOperator.Divide:\n          binaryOperator = ts.SyntaxKind.SlashToken;\n          break;\n\n        case compiler_1.BinaryOperator.Equals:\n          binaryOperator = ts.SyntaxKind.EqualsEqualsToken;\n          break;\n\n        case compiler_1.BinaryOperator.Identical:\n          binaryOperator = ts.SyntaxKind.EqualsEqualsEqualsToken;\n          break;\n\n        case compiler_1.BinaryOperator.Lower:\n          binaryOperator = ts.SyntaxKind.LessThanToken;\n          break;\n\n        case compiler_1.BinaryOperator.LowerEquals:\n          binaryOperator = ts.SyntaxKind.LessThanEqualsToken;\n          break;\n\n        case compiler_1.BinaryOperator.Minus:\n          binaryOperator = ts.SyntaxKind.MinusToken;\n          break;\n\n        case compiler_1.BinaryOperator.Modulo:\n          binaryOperator = ts.SyntaxKind.PercentToken;\n          break;\n\n        case compiler_1.BinaryOperator.Multiply:\n          binaryOperator = ts.SyntaxKind.AsteriskToken;\n          break;\n\n        case compiler_1.BinaryOperator.NotEquals:\n          binaryOperator = ts.SyntaxKind.ExclamationEqualsToken;\n          break;\n\n        case compiler_1.BinaryOperator.NotIdentical:\n          binaryOperator = ts.SyntaxKind.ExclamationEqualsEqualsToken;\n          break;\n\n        case compiler_1.BinaryOperator.Or:\n          binaryOperator = ts.SyntaxKind.BarBarToken;\n          break;\n\n        case compiler_1.BinaryOperator.Plus:\n          binaryOperator = ts.SyntaxKind.PlusToken;\n          break;\n\n        default:\n          throw new Error(\"Unknown operator: \" + expr.operator);\n      }\n\n      var binary = ts.createBinary(expr.lhs.visitExpression(this, null), binaryOperator, expr.rhs.visitExpression(this, null));\n      return this.postProcess(expr, expr.parens ? ts.createParen(binary) : binary);\n    };\n\n    NodeEmitterVisitor.prototype.visitReadPropExpr = function (expr) {\n      return this.postProcess(expr, ts.createPropertyAccess(expr.receiver.visitExpression(this, null), expr.name));\n    };\n\n    NodeEmitterVisitor.prototype.visitReadKeyExpr = function (expr) {\n      return this.postProcess(expr, ts.createElementAccess(expr.receiver.visitExpression(this, null), expr.index.visitExpression(this, null)));\n    };\n\n    NodeEmitterVisitor.prototype.visitLiteralArrayExpr = function (expr) {\n      var _this = this;\n\n      return this.postProcess(expr, ts.createArrayLiteral(expr.entries.map(function (entry) {\n        return entry.visitExpression(_this, null);\n      })));\n    };\n\n    NodeEmitterVisitor.prototype.visitLiteralMapExpr = function (expr) {\n      var _this = this;\n\n      return this.postProcess(expr, ts.createObjectLiteral(expr.entries.map(function (entry) {\n        return ts.createPropertyAssignment(entry.quoted || !_VALID_IDENTIFIER_RE.test(entry.key) ? ts.createLiteral(entry.key) : entry.key, entry.value.visitExpression(_this, null));\n      })));\n    };\n\n    NodeEmitterVisitor.prototype.visitCommaExpr = function (expr) {\n      var _this = this;\n\n      return this.postProcess(expr, expr.parts.map(function (e) {\n        return e.visitExpression(_this, null);\n      }).reduce(function (left, right) {\n        return left ? ts.createBinary(left, ts.SyntaxKind.CommaToken, right) : right;\n      }, null));\n    };\n\n    NodeEmitterVisitor.prototype._visitStatements = function (statements) {\n      return this._visitStatementsPrefix([], statements);\n    };\n\n    NodeEmitterVisitor.prototype._visitStatementsPrefix = function (prefix, statements) {\n      var _this = this;\n\n      return ts.createBlock(tslib_1.__spread(prefix, statements.map(function (stmt) {\n        return stmt.visitStatement(_this, null);\n      }).filter(function (f) {\n        return f != null;\n      })));\n    };\n\n    NodeEmitterVisitor.prototype._visitIdentifier = function (value) {\n      // name can only be null during JIT which never executes this code.\n      var moduleName = value.moduleName,\n          name = value.name;\n      var prefixIdent = null;\n\n      if (moduleName) {\n        var prefix = this._importsWithPrefixes.get(moduleName);\n\n        if (prefix == null) {\n          prefix = \"i\" + this._importsWithPrefixes.size;\n\n          this._importsWithPrefixes.set(moduleName, prefix);\n        }\n\n        prefixIdent = ts.createIdentifier(prefix);\n      }\n\n      if (prefixIdent) {\n        return ts.createPropertyAccess(prefixIdent, name);\n      } else {\n        var id = ts.createIdentifier(name);\n\n        if (this._exportedVariableIdentifiers.has(name)) {\n          // In order for this new identifier node to be properly rewritten in CommonJS output,\n          // it must have its original node set to a parsed instance of the same identifier.\n          ts.setOriginalNode(id, this._exportedVariableIdentifiers.get(name));\n        }\n\n        return id;\n      }\n    };\n\n    return NodeEmitterVisitor;\n  }();\n\n  exports.NodeEmitterVisitor = NodeEmitterVisitor;\n\n  function getMethodName(methodRef) {\n    if (methodRef.name) {\n      return methodRef.name;\n    } else {\n      switch (methodRef.builtin) {\n        case compiler_1.BuiltinMethod.Bind:\n          return 'bind';\n\n        case compiler_1.BuiltinMethod.ConcatArray:\n          return 'concat';\n\n        case compiler_1.BuiltinMethod.SubscribeObservable:\n          return 'subscribe';\n      }\n    }\n\n    throw new Error('Unexpected method reference form');\n  }\n\n  function modifierFromModifier(modifier) {\n    switch (modifier) {\n      case compiler_1.StmtModifier.Exported:\n        return ts.createToken(ts.SyntaxKind.ExportKeyword);\n\n      case compiler_1.StmtModifier.Final:\n        return ts.createToken(ts.SyntaxKind.ConstKeyword);\n\n      case compiler_1.StmtModifier.Private:\n        return ts.createToken(ts.SyntaxKind.PrivateKeyword);\n\n      case compiler_1.StmtModifier.Static:\n        return ts.createToken(ts.SyntaxKind.StaticKeyword);\n    }\n  }\n\n  function translateModifiers(modifiers) {\n    return modifiers == null ? undefined : modifiers.map(modifierFromModifier);\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/node_emitter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AssertNotNull, BinaryOperator, BinaryOperatorExpr, BuiltinMethod, BuiltinVar, CastExpr, ClassStmt, CommaExpr, ConditionalExpr, DeclareFunctionStmt, DeclareVarStmt, ExpressionStatement, ExpressionVisitor, ExternalExpr, ExternalReference, FunctionExpr, IfStmt, InstantiateExpr, InvokeFunctionExpr, InvokeMethodExpr, LeadingComment, leadingComment, LiteralArrayExpr, LiteralExpr, LiteralMapExpr, LocalizedString, NotExpr, ParseSourceFile, ParseSourceSpan, PartialModule, ReadKeyExpr, ReadPropExpr, ReadVarExpr, ReturnStatement, Statement, StatementVisitor, StmtModifier, TaggedTemplateExpr, ThrowStmt, TryCatchStmt, TypeofExpr, UnaryOperator, UnaryOperatorExpr, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {attachComments} from '../ngtsc/translator';\nimport {error} from './util';\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan|null;\n}\n\nconst METHOD_THIS_NAME = 'this';\nconst CATCH_ERROR_NAME = 'error';\nconst CATCH_STACK_NAME = 'stack';\nconst _VALID_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\n\nexport class TypeScriptNodeEmitter {\n  constructor(private annotateForClosureCompiler: boolean) {}\n\n  updateSourceFile(sourceFile: ts.SourceFile, stmts: Statement[], preamble?: string):\n      [ts.SourceFile, Map<ts.Node, Node>] {\n    const converter = new NodeEmitterVisitor(this.annotateForClosureCompiler);\n    // [].concat flattens the result so that each `visit...` method can also return an array of\n    // stmts.\n    const statements: any[] = [].concat(\n        ...stmts.map(stmt => stmt.visitStatement(converter, null)).filter(stmt => stmt != null));\n    const sourceStatements =\n        [...converter.getReexports(), ...converter.getImports(), ...statements];\n    if (preamble) {\n      // We always attach the preamble comment to a `NotEmittedStatement` node, because tsickle uses\n      // this node type as a marker of the preamble to ensure that it adds its own new nodes after\n      // the preamble.\n      const preambleCommentHolder = ts.createNotEmittedStatement(sourceFile);\n      // Preamble comments are passed through as-is, which means that they must already contain a\n      // leading `*` if they should be a JSDOC comment.\n      ts.addSyntheticLeadingComment(\n          preambleCommentHolder, ts.SyntaxKind.MultiLineCommentTrivia, preamble,\n          /* hasTrailingNewline */ true);\n      sourceStatements.unshift(preambleCommentHolder);\n    }\n\n    converter.updateSourceMap(sourceStatements);\n    const newSourceFile = ts.updateSourceFileNode(sourceFile, sourceStatements);\n    return [newSourceFile, converter.getNodeMap()];\n  }\n}\n\n/**\n * Update the given source file to include the changes specified in module.\n *\n * The module parameter is treated as a partial module meaning that the statements are added to\n * the module instead of replacing the module. Also, any classes are treated as partial classes\n * and the included members are added to the class with the same name instead of a new class\n * being created.\n */\nexport function updateSourceFile(\n    sourceFile: ts.SourceFile, module: PartialModule,\n    annotateForClosureCompiler: boolean): [ts.SourceFile, Map<ts.Node, Node>] {\n  const converter = new NodeEmitterVisitor(annotateForClosureCompiler);\n  converter.loadExportedVariableIdentifiers(sourceFile);\n\n  const prefixStatements = module.statements.filter(statement => !(statement instanceof ClassStmt));\n  const classes =\n      module.statements.filter(statement => statement instanceof ClassStmt) as ClassStmt[];\n  const classMap = new Map(\n      classes.map<[string, ClassStmt]>(classStatement => [classStatement.name, classStatement]));\n  const classNames = new Set(classes.map(classStatement => classStatement.name));\n\n  const prefix: ts.Statement[] =\n      prefixStatements.map(statement => statement.visitStatement(converter, sourceFile));\n\n  // Add static methods to all the classes referenced in module.\n  let newStatements = sourceFile.statements.map(node => {\n    if (node.kind == ts.SyntaxKind.ClassDeclaration) {\n      const classDeclaration = node as ts.ClassDeclaration;\n      const name = classDeclaration.name;\n      if (name) {\n        const classStatement = classMap.get(name.text);\n        if (classStatement) {\n          classNames.delete(name.text);\n          const classMemberHolder =\n              converter.visitDeclareClassStmt(classStatement) as ts.ClassDeclaration;\n          const newMethods =\n              classMemberHolder.members.filter(member => member.kind !== ts.SyntaxKind.Constructor);\n          const newMembers = [...classDeclaration.members, ...newMethods];\n\n          return ts.updateClassDeclaration(\n              classDeclaration,\n              /* decorators */ classDeclaration.decorators,\n              /* modifiers */ classDeclaration.modifiers,\n              /* name */ classDeclaration.name,\n              /* typeParameters */ classDeclaration.typeParameters,\n              /* heritageClauses */ classDeclaration.heritageClauses || [],\n              /* members */ newMembers);\n        }\n      }\n    }\n    return node;\n  });\n\n  // Validate that all the classes have been generated\n  classNames.size == 0 ||\n      error(`${classNames.size == 1 ? 'Class' : 'Classes'} \"${\n          Array.from(classNames.keys()).join(', ')}\" not generated`);\n\n  // Add imports to the module required by the new methods\n  const imports = converter.getImports();\n  if (imports && imports.length) {\n    // Find where the new imports should go\n    const index = firstAfter(\n        newStatements,\n        statement => statement.kind === ts.SyntaxKind.ImportDeclaration ||\n            statement.kind === ts.SyntaxKind.ImportEqualsDeclaration);\n    newStatements =\n        [...newStatements.slice(0, index), ...imports, ...prefix, ...newStatements.slice(index)];\n  } else {\n    newStatements = [...prefix, ...newStatements];\n  }\n\n  converter.updateSourceMap(newStatements);\n  const newSourceFile = ts.updateSourceFileNode(sourceFile, newStatements);\n\n  return [newSourceFile, converter.getNodeMap()];\n}\n\n// Return the index after the first value in `a` that doesn't match the predicate after a value that\n// does or 0 if no values match.\nfunction firstAfter<T>(a: T[], predicate: (value: T) => boolean) {\n  let index = 0;\n  const len = a.length;\n  for (; index < len; index++) {\n    const value = a[index];\n    if (predicate(value)) break;\n  }\n  if (index >= len) return 0;\n  for (; index < len; index++) {\n    const value = a[index];\n    if (!predicate(value)) break;\n  }\n  return index;\n}\n\n// A recorded node is a subtype of the node that is marked as being recorded. This is used\n// to ensure that NodeEmitterVisitor.record has been called on all nodes returned by the\n// NodeEmitterVisitor\nexport type RecordedNode<T extends ts.Node = ts.Node> = (T&{\n  __recorded: any;\n})|null;\n\nfunction escapeLiteral(value: string): string {\n  return value.replace(/(\\\"|\\\\)/g, '\\\\$1').replace(/(\\n)|(\\r)/g, function(v, n, r) {\n    return n ? '\\\\n' : '\\\\r';\n  });\n}\n\nfunction createLiteral(value: any) {\n  if (value === null) {\n    return ts.createNull();\n  } else if (value === undefined) {\n    return ts.createIdentifier('undefined');\n  } else {\n    const result = ts.createLiteral(value);\n    if (ts.isStringLiteral(result) && result.text.indexOf('\\\\') >= 0) {\n      // Hack to avoid problems cause indirectly by:\n      //    https://github.com/Microsoft/TypeScript/issues/20192\n      // This avoids the string escaping normally performed for a string relying on that\n      // TypeScript just emits the text raw for a numeric literal.\n      (result as any).kind = ts.SyntaxKind.NumericLiteral;\n      result.text = `\"${escapeLiteral(result.text)}\"`;\n    }\n    return result;\n  }\n}\n\nfunction isExportTypeStatement(statement: ts.Statement): boolean {\n  return !!statement.modifiers &&\n      statement.modifiers.some(mod => mod.kind === ts.SyntaxKind.ExportKeyword);\n}\n\n/**\n * Visits an output ast and produces the corresponding TypeScript synthetic nodes.\n */\nexport class NodeEmitterVisitor implements StatementVisitor, ExpressionVisitor {\n  private _nodeMap = new Map<ts.Node, Node>();\n  private _importsWithPrefixes = new Map<string, string>();\n  private _reexports = new Map<string, {name: string, as: string}[]>();\n  private _templateSources = new Map<ParseSourceFile, ts.SourceMapSource>();\n  private _exportedVariableIdentifiers = new Map<string, ts.Identifier>();\n\n  constructor(private annotateForClosureCompiler: boolean) {}\n\n  /**\n   * Process the source file and collect exported identifiers that refer to variables.\n   *\n   * Only variables are collected because exported classes still exist in the module scope in\n   * CommonJS, whereas variables have their declarations moved onto the `exports` object, and all\n   * references are updated accordingly.\n   */\n  loadExportedVariableIdentifiers(sourceFile: ts.SourceFile): void {\n    sourceFile.statements.forEach(statement => {\n      if (ts.isVariableStatement(statement) && isExportTypeStatement(statement)) {\n        statement.declarationList.declarations.forEach(declaration => {\n          if (ts.isIdentifier(declaration.name)) {\n            this._exportedVariableIdentifiers.set(declaration.name.text, declaration.name);\n          }\n        });\n      }\n    });\n  }\n\n  getReexports(): ts.Statement[] {\n    return Array.from(this._reexports.entries())\n        .map(\n            ([exportedFilePath, reexports]) => ts.createExportDeclaration(\n                /* decorators */ undefined,\n                /* modifiers */ undefined,\n                ts.createNamedExports(\n                    reexports.map(({name, as}) => ts.createExportSpecifier(name, as))),\n                /* moduleSpecifier */ createLiteral(exportedFilePath)));\n  }\n\n  getImports(): ts.Statement[] {\n    return Array.from(this._importsWithPrefixes.entries())\n        .map(\n            ([namespace, prefix]) => ts.createImportDeclaration(\n                /* decorators */ undefined,\n                /* modifiers */ undefined,\n                /* importClause */\n                ts.createImportClause(\n                    /* name */<ts.Identifier>(undefined as any),\n                    ts.createNamespaceImport(ts.createIdentifier(prefix))),\n                /* moduleSpecifier */ createLiteral(namespace)));\n  }\n\n  getNodeMap() {\n    return this._nodeMap;\n  }\n\n  updateSourceMap(statements: ts.Statement[]) {\n    let lastRangeStartNode: ts.Node|undefined = undefined;\n    let lastRangeEndNode: ts.Node|undefined = undefined;\n    let lastRange: ts.SourceMapRange|undefined = undefined;\n\n    const recordLastSourceRange = () => {\n      if (lastRange && lastRangeStartNode && lastRangeEndNode) {\n        if (lastRangeStartNode == lastRangeEndNode) {\n          ts.setSourceMapRange(lastRangeEndNode, lastRange);\n        } else {\n          ts.setSourceMapRange(lastRangeStartNode, lastRange);\n          // Only emit the pos for the first node emitted in the range.\n          ts.setEmitFlags(lastRangeStartNode, ts.EmitFlags.NoTrailingSourceMap);\n          ts.setSourceMapRange(lastRangeEndNode, lastRange);\n          // Only emit emit end for the last node emitted in the range.\n          ts.setEmitFlags(lastRangeEndNode, ts.EmitFlags.NoLeadingSourceMap);\n        }\n      }\n    };\n\n    const visitNode = (tsNode: ts.Node) => {\n      const ngNode = this._nodeMap.get(tsNode);\n      if (ngNode) {\n        const range = this.sourceRangeOf(ngNode);\n        if (range) {\n          if (!lastRange || range.source != lastRange.source || range.pos != lastRange.pos ||\n              range.end != lastRange.end) {\n            recordLastSourceRange();\n            lastRangeStartNode = tsNode;\n            lastRange = range;\n          }\n          lastRangeEndNode = tsNode;\n        }\n      }\n      ts.forEachChild(tsNode, visitNode);\n    };\n    statements.forEach(visitNode);\n    recordLastSourceRange();\n  }\n\n  private postProcess<T extends ts.Node>(ngNode: Node, tsNode: T|null): RecordedNode<T> {\n    if (tsNode && !this._nodeMap.has(tsNode)) {\n      this._nodeMap.set(tsNode, ngNode);\n    }\n    if (tsNode !== null && ngNode instanceof Statement && ngNode.leadingComments !== undefined) {\n      attachComments(tsNode as unknown as ts.Statement, ngNode.leadingComments);\n    }\n    return tsNode as RecordedNode<T>;\n  }\n\n  private sourceRangeOf(node: Node): ts.SourceMapRange|null {\n    if (node.sourceSpan) {\n      const span = node.sourceSpan;\n      if (span.start.file == span.end.file) {\n        const file = span.start.file;\n        if (file.url) {\n          let source = this._templateSources.get(file);\n          if (!source) {\n            source = ts.createSourceMapSource(file.url, file.content, pos => pos);\n            this._templateSources.set(file, source);\n          }\n          return {pos: span.start.offset, end: span.end.offset, source};\n        }\n      }\n    }\n    return null;\n  }\n\n  private getModifiers(stmt: Statement) {\n    let modifiers: ts.Modifier[] = [];\n    if (stmt.hasModifier(StmtModifier.Exported)) {\n      modifiers.push(ts.createToken(ts.SyntaxKind.ExportKeyword));\n    }\n    return modifiers;\n  }\n\n  // StatementVisitor\n  visitDeclareVarStmt(stmt: DeclareVarStmt) {\n    if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr &&\n        !stmt.type) {\n      // check for a reexport\n      const {name, moduleName} = stmt.value.value;\n      if (moduleName) {\n        let reexports = this._reexports.get(moduleName);\n        if (!reexports) {\n          reexports = [];\n          this._reexports.set(moduleName, reexports);\n        }\n        reexports.push({name: name!, as: stmt.name});\n        return null;\n      }\n    }\n\n    const varDeclList = ts.createVariableDeclarationList([ts.createVariableDeclaration(\n        ts.createIdentifier(stmt.name),\n        /* type */ undefined,\n        (stmt.value && stmt.value.visitExpression(this, null)) || undefined)]);\n\n    if (stmt.hasModifier(StmtModifier.Exported)) {\n      // Note: We need to add an explicit variable and export declaration so that\n      // the variable can be referred in the same file as well.\n      const tsVarStmt =\n          this.postProcess(stmt, ts.createVariableStatement(/* modifiers */[], varDeclList));\n      const exportStmt = this.postProcess(\n          stmt,\n          ts.createExportDeclaration(\n              /*decorators*/ undefined, /*modifiers*/ undefined,\n              ts.createNamedExports([ts.createExportSpecifier(stmt.name, stmt.name)])));\n      return [tsVarStmt, exportStmt];\n    }\n    return this.postProcess(stmt, ts.createVariableStatement(this.getModifiers(stmt), varDeclList));\n  }\n\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt) {\n    return this.postProcess(\n        stmt,\n        ts.createFunctionDeclaration(\n            /* decorators */ undefined, this.getModifiers(stmt),\n            /* asteriskToken */ undefined, stmt.name, /* typeParameters */ undefined,\n            stmt.params.map(\n                p => ts.createParameter(\n                    /* decorators */ undefined, /* modifiers */ undefined,\n                    /* dotDotDotToken */ undefined, p.name)),\n            /* type */ undefined, this._visitStatements(stmt.statements)));\n  }\n\n  visitExpressionStmt(stmt: ExpressionStatement) {\n    return this.postProcess(stmt, ts.createStatement(stmt.expr.visitExpression(this, null)));\n  }\n\n  visitReturnStmt(stmt: ReturnStatement) {\n    return this.postProcess(\n        stmt, ts.createReturn(stmt.value ? stmt.value.visitExpression(this, null) : undefined));\n  }\n\n  visitDeclareClassStmt(stmt: ClassStmt) {\n    const modifiers = this.getModifiers(stmt);\n    const fields = stmt.fields.map(field => {\n      const property = ts.createProperty(\n          /* decorators */ undefined, /* modifiers */ translateModifiers(field.modifiers),\n          field.name,\n          /* questionToken */ undefined,\n          /* type */ undefined,\n          field.initializer == null ? ts.createNull() :\n                                      field.initializer.visitExpression(this, null));\n\n      if (this.annotateForClosureCompiler) {\n        // Closure compiler transforms the form `Service.ɵprov = X` into `Service$ɵprov = X`. To\n        // prevent this transformation, such assignments need to be annotated with @nocollapse.\n        // Note that tsickle is typically responsible for adding such annotations, however it\n        // doesn't yet handle synthetic fields added during other transformations.\n        ts.addSyntheticLeadingComment(\n            property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ',\n            /* hasTrailingNewLine */ false);\n      }\n\n      return property;\n    });\n    const getters = stmt.getters.map(\n        getter => ts.createGetAccessor(\n            /* decorators */ undefined, /* modifiers */ undefined, getter.name, /* parameters */[],\n            /* type */ undefined, this._visitStatements(getter.body)));\n\n    const constructor =\n        (stmt.constructorMethod && [ts.createConstructor(\n                                       /* decorators */ undefined,\n                                       /* modifiers */ undefined,\n                                       /* parameters */\n                                       stmt.constructorMethod.params.map(\n                                           p => ts.createParameter(\n                                               /* decorators */ undefined,\n                                               /* modifiers */ undefined,\n                                               /* dotDotDotToken */ undefined, p.name)),\n                                       this._visitStatements(stmt.constructorMethod.body))]) ||\n        [];\n\n    // TODO {chuckj}: Determine what should be done for a method with a null name.\n    const methods = stmt.methods.filter(method => method.name)\n                        .map(\n                            method => ts.createMethod(\n                                /* decorators */ undefined,\n                                /* modifiers */ translateModifiers(method.modifiers),\n                                /* astriskToken */ undefined, method.name!/* guarded by filter */,\n                                /* questionToken */ undefined, /* typeParameters */ undefined,\n                                method.params.map(\n                                    p => ts.createParameter(\n                                        /* decorators */ undefined, /* modifiers */ undefined,\n                                        /* dotDotDotToken */ undefined, p.name)),\n                                /* type */ undefined, this._visitStatements(method.body)));\n    return this.postProcess(\n        stmt,\n        ts.createClassDeclaration(\n            /* decorators */ undefined, modifiers, stmt.name, /* typeParameters*/ undefined,\n            stmt.parent &&\n                    [ts.createHeritageClause(\n                        ts.SyntaxKind.ExtendsKeyword, [stmt.parent.visitExpression(this, null)])] ||\n                [],\n            [...fields, ...getters, ...constructor, ...methods]));\n  }\n\n  visitIfStmt(stmt: IfStmt) {\n    return this.postProcess(\n        stmt,\n        ts.createIf(\n            stmt.condition.visitExpression(this, null), this._visitStatements(stmt.trueCase),\n            stmt.falseCase && stmt.falseCase.length && this._visitStatements(stmt.falseCase) ||\n                undefined));\n  }\n\n  visitTryCatchStmt(stmt: TryCatchStmt): RecordedNode<ts.TryStatement> {\n    return this.postProcess(\n        stmt,\n        ts.createTry(\n            this._visitStatements(stmt.bodyStmts),\n            ts.createCatchClause(\n                CATCH_ERROR_NAME,\n                this._visitStatementsPrefix(\n                    [ts.createVariableStatement(\n                        /* modifiers */ undefined,\n                        [ts.createVariableDeclaration(\n                            CATCH_STACK_NAME, /* type */ undefined,\n                            ts.createPropertyAccess(\n                                ts.createIdentifier(CATCH_ERROR_NAME),\n                                ts.createIdentifier(CATCH_STACK_NAME)))])],\n                    stmt.catchStmts)),\n            /* finallyBlock */ undefined));\n  }\n\n  visitThrowStmt(stmt: ThrowStmt) {\n    return this.postProcess(stmt, ts.createThrow(stmt.error.visitExpression(this, null)));\n  }\n\n  // ExpressionVisitor\n  visitWrappedNodeExpr(expr: WrappedNodeExpr<any>) {\n    return this.postProcess(expr, expr.node);\n  }\n\n  visitTypeofExpr(expr: TypeofExpr) {\n    const typeOf = ts.createTypeOf(expr.expr.visitExpression(this, null));\n    return this.postProcess(expr, typeOf);\n  }\n\n  // ExpressionVisitor\n  visitReadVarExpr(expr: ReadVarExpr) {\n    switch (expr.builtin) {\n      case BuiltinVar.This:\n        return this.postProcess(expr, ts.createIdentifier(METHOD_THIS_NAME));\n      case BuiltinVar.CatchError:\n        return this.postProcess(expr, ts.createIdentifier(CATCH_ERROR_NAME));\n      case BuiltinVar.CatchStack:\n        return this.postProcess(expr, ts.createIdentifier(CATCH_STACK_NAME));\n      case BuiltinVar.Super:\n        return this.postProcess(expr, ts.createSuper());\n    }\n    if (expr.name) {\n      return this.postProcess(expr, ts.createIdentifier(expr.name));\n    }\n    throw Error(`Unexpected ReadVarExpr form`);\n  }\n\n  visitWriteVarExpr(expr: WriteVarExpr): RecordedNode<ts.BinaryExpression> {\n    return this.postProcess(\n        expr,\n        ts.createAssignment(\n            ts.createIdentifier(expr.name), expr.value.visitExpression(this, null)));\n  }\n\n  visitWriteKeyExpr(expr: WriteKeyExpr): RecordedNode<ts.BinaryExpression> {\n    return this.postProcess(\n        expr,\n        ts.createAssignment(\n            ts.createElementAccess(\n                expr.receiver.visitExpression(this, null), expr.index.visitExpression(this, null)),\n            expr.value.visitExpression(this, null)));\n  }\n\n  visitWritePropExpr(expr: WritePropExpr): RecordedNode<ts.BinaryExpression> {\n    return this.postProcess(\n        expr,\n        ts.createAssignment(\n            ts.createPropertyAccess(expr.receiver.visitExpression(this, null), expr.name),\n            expr.value.visitExpression(this, null)));\n  }\n\n  visitInvokeMethodExpr(expr: InvokeMethodExpr): RecordedNode<ts.CallExpression> {\n    const methodName = getMethodName(expr);\n    return this.postProcess(\n        expr,\n        ts.createCall(\n            ts.createPropertyAccess(expr.receiver.visitExpression(this, null), methodName),\n            /* typeArguments */ undefined, expr.args.map(arg => arg.visitExpression(this, null))));\n  }\n\n  visitInvokeFunctionExpr(expr: InvokeFunctionExpr): RecordedNode<ts.CallExpression> {\n    return this.postProcess(\n        expr,\n        ts.createCall(\n            expr.fn.visitExpression(this, null), /* typeArguments */ undefined,\n            expr.args.map(arg => arg.visitExpression(this, null))));\n  }\n\n  visitTaggedTemplateExpr(expr: TaggedTemplateExpr): RecordedNode<ts.TaggedTemplateExpression> {\n    throw new Error('tagged templates are not supported in pre-ivy mode.');\n  }\n\n  visitInstantiateExpr(expr: InstantiateExpr): RecordedNode<ts.NewExpression> {\n    return this.postProcess(\n        expr,\n        ts.createNew(\n            expr.classExpr.visitExpression(this, null), /* typeArguments */ undefined,\n            expr.args.map(arg => arg.visitExpression(this, null))));\n  }\n\n  visitLiteralExpr(expr: LiteralExpr) {\n    return this.postProcess(expr, createLiteral(expr.value));\n  }\n\n  visitLocalizedString(expr: LocalizedString, context: any) {\n    throw new Error('localized strings are not supported in pre-ivy mode.');\n  }\n\n  visitExternalExpr(expr: ExternalExpr) {\n    return this.postProcess(expr, this._visitIdentifier(expr.value));\n  }\n\n  visitConditionalExpr(expr: ConditionalExpr): RecordedNode<ts.ParenthesizedExpression> {\n    // TODO {chuckj}: Review use of ! on falseCase. Should it be non-nullable?\n    return this.postProcess(\n        expr,\n        ts.createParen(ts.createConditional(\n            expr.condition.visitExpression(this, null), expr.trueCase.visitExpression(this, null),\n            expr.falseCase!.visitExpression(this, null))));\n  }\n\n  visitNotExpr(expr: NotExpr): RecordedNode<ts.PrefixUnaryExpression> {\n    return this.postProcess(\n        expr,\n        ts.createPrefix(\n            ts.SyntaxKind.ExclamationToken, expr.condition.visitExpression(this, null)));\n  }\n\n  visitAssertNotNullExpr(expr: AssertNotNull): RecordedNode<ts.Expression> {\n    return expr.condition.visitExpression(this, null);\n  }\n\n  visitCastExpr(expr: CastExpr): RecordedNode<ts.Expression> {\n    return expr.value.visitExpression(this, null);\n  }\n\n  visitFunctionExpr(expr: FunctionExpr) {\n    return this.postProcess(\n        expr,\n        ts.createFunctionExpression(\n            /* modifiers */ undefined, /* astriskToken */ undefined,\n            /* name */ expr.name || undefined,\n            /* typeParameters */ undefined,\n            expr.params.map(\n                p => ts.createParameter(\n                    /* decorators */ undefined, /* modifiers */ undefined,\n                    /* dotDotDotToken */ undefined, p.name)),\n            /* type */ undefined, this._visitStatements(expr.statements)));\n  }\n\n  visitUnaryOperatorExpr(expr: UnaryOperatorExpr):\n      RecordedNode<ts.UnaryExpression|ts.ParenthesizedExpression> {\n    let unaryOperator: ts.BinaryOperator;\n    switch (expr.operator) {\n      case UnaryOperator.Minus:\n        unaryOperator = ts.SyntaxKind.MinusToken;\n        break;\n      case UnaryOperator.Plus:\n        unaryOperator = ts.SyntaxKind.PlusToken;\n        break;\n      default:\n        throw new Error(`Unknown operator: ${expr.operator}`);\n    }\n    const binary = ts.createPrefix(unaryOperator, expr.expr.visitExpression(this, null));\n    return this.postProcess(expr, expr.parens ? ts.createParen(binary) : binary);\n  }\n\n  visitBinaryOperatorExpr(expr: BinaryOperatorExpr):\n      RecordedNode<ts.BinaryExpression|ts.ParenthesizedExpression> {\n    let binaryOperator: ts.BinaryOperator;\n    switch (expr.operator) {\n      case BinaryOperator.And:\n        binaryOperator = ts.SyntaxKind.AmpersandAmpersandToken;\n        break;\n      case BinaryOperator.BitwiseAnd:\n        binaryOperator = ts.SyntaxKind.AmpersandToken;\n        break;\n      case BinaryOperator.Bigger:\n        binaryOperator = ts.SyntaxKind.GreaterThanToken;\n        break;\n      case BinaryOperator.BiggerEquals:\n        binaryOperator = ts.SyntaxKind.GreaterThanEqualsToken;\n        break;\n      case BinaryOperator.Divide:\n        binaryOperator = ts.SyntaxKind.SlashToken;\n        break;\n      case BinaryOperator.Equals:\n        binaryOperator = ts.SyntaxKind.EqualsEqualsToken;\n        break;\n      case BinaryOperator.Identical:\n        binaryOperator = ts.SyntaxKind.EqualsEqualsEqualsToken;\n        break;\n      case BinaryOperator.Lower:\n        binaryOperator = ts.SyntaxKind.LessThanToken;\n        break;\n      case BinaryOperator.LowerEquals:\n        binaryOperator = ts.SyntaxKind.LessThanEqualsToken;\n        break;\n      case BinaryOperator.Minus:\n        binaryOperator = ts.SyntaxKind.MinusToken;\n        break;\n      case BinaryOperator.Modulo:\n        binaryOperator = ts.SyntaxKind.PercentToken;\n        break;\n      case BinaryOperator.Multiply:\n        binaryOperator = ts.SyntaxKind.AsteriskToken;\n        break;\n      case BinaryOperator.NotEquals:\n        binaryOperator = ts.SyntaxKind.ExclamationEqualsToken;\n        break;\n      case BinaryOperator.NotIdentical:\n        binaryOperator = ts.SyntaxKind.ExclamationEqualsEqualsToken;\n        break;\n      case BinaryOperator.Or:\n        binaryOperator = ts.SyntaxKind.BarBarToken;\n        break;\n      case BinaryOperator.Plus:\n        binaryOperator = ts.SyntaxKind.PlusToken;\n        break;\n      default:\n        throw new Error(`Unknown operator: ${expr.operator}`);\n    }\n    const binary = ts.createBinary(\n        expr.lhs.visitExpression(this, null), binaryOperator, expr.rhs.visitExpression(this, null));\n    return this.postProcess(expr, expr.parens ? ts.createParen(binary) : binary);\n  }\n\n  visitReadPropExpr(expr: ReadPropExpr): RecordedNode<ts.PropertyAccessExpression> {\n    return this.postProcess(\n        expr, ts.createPropertyAccess(expr.receiver.visitExpression(this, null), expr.name));\n  }\n\n  visitReadKeyExpr(expr: ReadKeyExpr): RecordedNode<ts.ElementAccessExpression> {\n    return this.postProcess(\n        expr,\n        ts.createElementAccess(\n            expr.receiver.visitExpression(this, null), expr.index.visitExpression(this, null)));\n  }\n\n  visitLiteralArrayExpr(expr: LiteralArrayExpr): RecordedNode<ts.ArrayLiteralExpression> {\n    return this.postProcess(\n        expr, ts.createArrayLiteral(expr.entries.map(entry => entry.visitExpression(this, null))));\n  }\n\n  visitLiteralMapExpr(expr: LiteralMapExpr): RecordedNode<ts.ObjectLiteralExpression> {\n    return this.postProcess(\n        expr,\n        ts.createObjectLiteral(expr.entries.map(\n            entry => ts.createPropertyAssignment(\n                entry.quoted || !_VALID_IDENTIFIER_RE.test(entry.key) ?\n                    ts.createLiteral(entry.key) :\n                    entry.key,\n                entry.value.visitExpression(this, null)))));\n  }\n\n  visitCommaExpr(expr: CommaExpr): RecordedNode<ts.Expression> {\n    return this.postProcess(\n        expr,\n        expr.parts.map(e => e.visitExpression(this, null))\n            .reduce<ts.Expression|null>(\n                (left, right) =>\n                    left ? ts.createBinary(left, ts.SyntaxKind.CommaToken, right) : right,\n                null));\n  }\n\n  private _visitStatements(statements: Statement[]): ts.Block {\n    return this._visitStatementsPrefix([], statements);\n  }\n\n  private _visitStatementsPrefix(prefix: ts.Statement[], statements: Statement[]) {\n    return ts.createBlock([\n      ...prefix, ...statements.map(stmt => stmt.visitStatement(this, null)).filter(f => f != null)\n    ]);\n  }\n\n  private _visitIdentifier(value: ExternalReference): ts.Expression {\n    // name can only be null during JIT which never executes this code.\n    const moduleName = value.moduleName, name = value.name!;\n    let prefixIdent: ts.Identifier|null = null;\n    if (moduleName) {\n      let prefix = this._importsWithPrefixes.get(moduleName);\n      if (prefix == null) {\n        prefix = `i${this._importsWithPrefixes.size}`;\n        this._importsWithPrefixes.set(moduleName, prefix);\n      }\n      prefixIdent = ts.createIdentifier(prefix);\n    }\n    if (prefixIdent) {\n      return ts.createPropertyAccess(prefixIdent, name);\n    } else {\n      const id = ts.createIdentifier(name);\n      if (this._exportedVariableIdentifiers.has(name)) {\n        // In order for this new identifier node to be properly rewritten in CommonJS output,\n        // it must have its original node set to a parsed instance of the same identifier.\n        ts.setOriginalNode(id, this._exportedVariableIdentifiers.get(name));\n      }\n      return id;\n    }\n  }\n}\n\nfunction getMethodName(methodRef: {name: string|null; builtin: BuiltinMethod | null}): string {\n  if (methodRef.name) {\n    return methodRef.name;\n  } else {\n    switch (methodRef.builtin) {\n      case BuiltinMethod.Bind:\n        return 'bind';\n      case BuiltinMethod.ConcatArray:\n        return 'concat';\n      case BuiltinMethod.SubscribeObservable:\n        return 'subscribe';\n    }\n  }\n  throw new Error('Unexpected method reference form');\n}\n\nfunction modifierFromModifier(modifier: StmtModifier): ts.Modifier {\n  switch (modifier) {\n    case StmtModifier.Exported:\n      return ts.createToken(ts.SyntaxKind.ExportKeyword);\n    case StmtModifier.Final:\n      return ts.createToken(ts.SyntaxKind.ConstKeyword);\n    case StmtModifier.Private:\n      return ts.createToken(ts.SyntaxKind.PrivateKeyword);\n    case StmtModifier.Static:\n      return ts.createToken(ts.SyntaxKind.StaticKeyword);\n  }\n}\n\nfunction translateModifiers(modifiers: StmtModifier[]|null): ts.Modifier[]|undefined {\n  return modifiers == null ? undefined : modifiers!.map(modifierFromModifier);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}