{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/host/ngcc_host\", [\"require\", \"exports\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isSwitchableVariableDeclaration = exports.POST_R3_MARKER = exports.PRE_R3_MARKER = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ts = require(\"typescript\");\n\n  exports.PRE_R3_MARKER = '__PRE_R3__';\n  exports.POST_R3_MARKER = '__POST_R3__';\n\n  function isSwitchableVariableDeclaration(node) {\n    return ts.isVariableDeclaration(node) && !!node.initializer && ts.isIdentifier(node.initializer) && node.initializer.text.endsWith(exports.PRE_R3_MARKER);\n  }\n\n  exports.isSwitchableVariableDeclaration = isSwitchableVariableDeclaration;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/host/ngcc_host.ts"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;;;;;;AAMG;;AACH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAIa,EAAA,OAAA,CAAA,aAAA,GAAgB,YAAhB;AACA,EAAA,OAAA,CAAA,cAAA,GAAiB,aAAjB;;AAGb,WAAgB,+BAAhB,CAAgD,IAAhD,EAA6D;AAE3D,WAAO,EAAE,CAAC,qBAAH,CAAyB,IAAzB,KAAkC,CAAC,CAAC,IAAI,CAAC,WAAzC,IACH,EAAE,CAAC,YAAH,CAAgB,IAAI,CAAC,WAArB,CADG,IACkC,IAAI,CAAC,WAAL,CAAiB,IAAjB,CAAsB,QAAtB,CAA+B,OAAA,CAAA,aAA/B,CADzC;AAED;;AAJD,EAAA,OAAA,CAAA,+BAAA,GAAA,+BAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {ClassDeclaration, Declaration, Decorator, ReflectionHost} from '../../../src/ngtsc/reflection';\n\nexport const PRE_R3_MARKER = '__PRE_R3__';\nexport const POST_R3_MARKER = '__POST_R3__';\n\nexport type SwitchableVariableDeclaration = ts.VariableDeclaration&{initializer: ts.Identifier};\nexport function isSwitchableVariableDeclaration(node: ts.Node):\n    node is SwitchableVariableDeclaration {\n  return ts.isVariableDeclaration(node) && !!node.initializer &&\n      ts.isIdentifier(node.initializer) && node.initializer.text.endsWith(PRE_R3_MARKER);\n}\n\n/**\n * The symbol corresponding to a \"class\" declaration. I.e. a `ts.Symbol` whose `valueDeclaration` is\n * a `ClassDeclaration`.\n */\nexport type ClassSymbol = ts.Symbol&{valueDeclaration: ClassDeclaration};\n\n/**\n * A representation of a class that accounts for the potential existence of two `ClassSymbol`s for a\n * given class, as the compiled JavaScript bundles that ngcc reflects on can have two declarations.\n */\nexport interface NgccClassSymbol {\n  /**\n   * The name of the class.\n   */\n  name: string;\n\n  /**\n   * Represents the symbol corresponding with the outer declaration of the class. This should be\n   * considered the public class symbol, i.e. its declaration is visible to the rest of the program.\n   */\n  declaration: ClassSymbol;\n\n  /**\n   * Represents the symbol corresponding with the inner declaration of the class, referred to as its\n   * \"implementation\". This is not necessarily a `ClassSymbol` but rather just a `ts.Symbol`, as the\n   * inner declaration does not need to satisfy the requirements imposed on a publicly visible class\n   * declaration.\n   */\n  implementation: ts.Symbol;\n\n  /**\n   * Represents the symbol corresponding to a variable within a class IIFE that may be used to\n   * attach static properties or decorated.\n   */\n  adjacent?: ts.Symbol;\n}\n\n/**\n * A reflection host that has extra methods for looking at non-Typescript package formats\n */\nexport interface NgccReflectionHost extends ReflectionHost {\n  /**\n   * Find a symbol for a declaration that we think is a class.\n   * @param declaration The declaration whose symbol we are finding\n   * @returns the symbol for the declaration or `undefined` if it is not\n   * a \"class\" or has no symbol.\n   */\n  getClassSymbol(declaration: ts.Node): NgccClassSymbol|undefined;\n\n  /**\n   * Search the given module for variable declarations in which the initializer\n   * is an identifier marked with the `PRE_R3_MARKER`.\n   * @param module The module in which to search for switchable declarations.\n   * @returns An array of variable declarations that match.\n   */\n  getSwitchableDeclarations(module: ts.Node): SwitchableVariableDeclaration[];\n\n  /**\n   * Retrieves all decorators of a given class symbol.\n   * @param symbol Class symbol that can refer to a declaration which can hold decorators.\n   * @returns An array of decorators or null if none are declared.\n   */\n  getDecoratorsOfSymbol(symbol: NgccClassSymbol): Decorator[]|null;\n\n  /**\n   * Retrieves all class symbols of a given source file.\n   * @param sourceFile The source file to search for classes.\n   * @returns An array of found class symbols.\n   */\n  findClassSymbols(sourceFile: ts.SourceFile): NgccClassSymbol[];\n\n  /**\n   * Find the last node that is relevant to the specified class.\n   *\n   * As well as the main declaration, classes can have additional statements such as static\n   * properties (`SomeClass.staticProp = ...;`) and decorators (`__decorate(SomeClass, ...);`).\n   * It is useful to know exactly where the class \"ends\" so that we can inject additional\n   * statements after that point.\n   *\n   * @param classSymbol The class whose statements we want.\n   */\n  getEndOfClass(classSymbol: NgccClassSymbol): ts.Node;\n\n  /**\n   * Check whether a `Declaration` corresponds with a known declaration and set its `known` property\n   * to the appropriate `KnownDeclaration`.\n   *\n   * @param decl The `Declaration` to check.\n   * @return The passed in `Declaration` (potentially enhanced with a `KnownDeclaration`).\n   */\n  detectKnownDeclaration<T extends Declaration>(decl: T): T;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}