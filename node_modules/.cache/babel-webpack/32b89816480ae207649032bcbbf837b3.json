{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addUndefinedDefaults = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar interface_1 = require(\"../interface\");\n\nvar utility_1 = require(\"./utility\");\n\nfunction addUndefinedDefaults(value, _pointer, schema) {\n  if (typeof schema === 'boolean' || schema === undefined) {\n    return value;\n  }\n\n  var types = utility_1.getTypesOfSchema(schema);\n\n  if (types.size === 0) {\n    return value;\n  }\n\n  var type;\n\n  if (types.size === 1) {\n    // only one potential type\n    type = Array.from(types)[0];\n  } else if (types.size === 2 && types.has('array') && types.has('object')) {\n    // need to create one of them and array is simpler\n    type = 'array';\n  } else if (schema.properties && types.has('object')) {\n    // assume object\n    type = 'object';\n  } else if (schema.items && types.has('array')) {\n    // assume array\n    type = 'array';\n  } else {\n    // anything else needs to be checked by the consumer anyway\n    return value;\n  }\n\n  if (type === 'array') {\n    return value == undefined ? [] : value;\n  }\n\n  if (type === 'object') {\n    var newValue;\n\n    if (value == undefined) {\n      newValue = {};\n    } else if (interface_1.isJsonObject(value)) {\n      newValue = value;\n    } else {\n      return value;\n    }\n\n    if (!interface_1.isJsonObject(schema.properties)) {\n      return newValue;\n    }\n\n    for (var _i = 0, _Object$entries = Object.entries(schema.properties); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          propName = _Object$entries$_i[0],\n          schemaObject = _Object$entries$_i[1];\n\n      if (propName === '$schema' || !interface_1.isJsonObject(schemaObject)) {\n        continue;\n      }\n\n      var _value = newValue[propName];\n\n      if (_value === undefined) {\n        newValue[propName] = schemaObject.default;\n      } else if (interface_1.isJsonObject(_value)) {\n        (function () {\n          // Basic support for oneOf and anyOf.\n          var propertySchemas = schemaObject.oneOf || schemaObject.anyOf;\n          var allProperties = Object.keys(_value); // Locate a schema which declares all the properties that the object contains.\n\n          var adjustedSchema = interface_1.isJsonArray(propertySchemas) && propertySchemas.find(function (s) {\n            if (!interface_1.isJsonObject(s)) {\n              return false;\n            }\n\n            var schemaType = utility_1.getTypesOfSchema(s);\n\n            if (schemaType.size === 1 && schemaType.has('object') && interface_1.isJsonObject(s.properties)) {\n              var properties = Object.keys(s.properties);\n              return allProperties.every(function (key) {\n                return properties.includes(key);\n              });\n            }\n\n            return false;\n          });\n\n          if (adjustedSchema && interface_1.isJsonObject(adjustedSchema)) {\n            newValue[propName] = addUndefinedDefaults(_value, _pointer, adjustedSchema);\n          }\n        })();\n      }\n    }\n\n    return newValue;\n  }\n\n  return value;\n}\n\nexports.addUndefinedDefaults = addUndefinedDefaults;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/json/schema/transforms.js"],"names":["Object","defineProperty","exports","value","addUndefinedDefaults","interface_1","require","utility_1","_pointer","schema","undefined","types","getTypesOfSchema","size","type","Array","from","has","properties","items","newValue","isJsonObject","entries","propName","schemaObject","default","propertySchemas","oneOf","anyOf","allProperties","keys","adjustedSchema","isJsonArray","find","s","schemaType","every","key","includes"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addUndefinedDefaults = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst interface_1 = require(\"../interface\");\nconst utility_1 = require(\"./utility\");\nfunction addUndefinedDefaults(value, _pointer, schema) {\n    if (typeof schema === 'boolean' || schema === undefined) {\n        return value;\n    }\n    const types = utility_1.getTypesOfSchema(schema);\n    if (types.size === 0) {\n        return value;\n    }\n    let type;\n    if (types.size === 1) {\n        // only one potential type\n        type = Array.from(types)[0];\n    }\n    else if (types.size === 2 && types.has('array') && types.has('object')) {\n        // need to create one of them and array is simpler\n        type = 'array';\n    }\n    else if (schema.properties && types.has('object')) {\n        // assume object\n        type = 'object';\n    }\n    else if (schema.items && types.has('array')) {\n        // assume array\n        type = 'array';\n    }\n    else {\n        // anything else needs to be checked by the consumer anyway\n        return value;\n    }\n    if (type === 'array') {\n        return value == undefined ? [] : value;\n    }\n    if (type === 'object') {\n        let newValue;\n        if (value == undefined) {\n            newValue = {};\n        }\n        else if (interface_1.isJsonObject(value)) {\n            newValue = value;\n        }\n        else {\n            return value;\n        }\n        if (!interface_1.isJsonObject(schema.properties)) {\n            return newValue;\n        }\n        for (const [propName, schemaObject] of Object.entries(schema.properties)) {\n            if (propName === '$schema' || !interface_1.isJsonObject(schemaObject)) {\n                continue;\n            }\n            const value = newValue[propName];\n            if (value === undefined) {\n                newValue[propName] = schemaObject.default;\n            }\n            else if (interface_1.isJsonObject(value)) {\n                // Basic support for oneOf and anyOf.\n                const propertySchemas = schemaObject.oneOf || schemaObject.anyOf;\n                const allProperties = Object.keys(value);\n                // Locate a schema which declares all the properties that the object contains.\n                const adjustedSchema = interface_1.isJsonArray(propertySchemas) && propertySchemas.find(s => {\n                    if (!interface_1.isJsonObject(s)) {\n                        return false;\n                    }\n                    const schemaType = utility_1.getTypesOfSchema(s);\n                    if (schemaType.size === 1 && schemaType.has('object') && interface_1.isJsonObject(s.properties)) {\n                        const properties = Object.keys(s.properties);\n                        return allProperties.every(key => properties.includes(key));\n                    }\n                    return false;\n                });\n                if (adjustedSchema && interface_1.isJsonObject(adjustedSchema)) {\n                    newValue[propName] = addUndefinedDefaults(value, _pointer, adjustedSchema);\n                }\n            }\n        }\n        return newValue;\n    }\n    return value;\n}\nexports.addUndefinedDefaults = addUndefinedDefaults;\n"]},"metadata":{},"sourceType":"script"}