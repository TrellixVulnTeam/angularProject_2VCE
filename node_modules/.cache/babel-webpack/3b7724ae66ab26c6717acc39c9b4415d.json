{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/r3_module_compiler\", [\"require\", \"exports\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/render3/r3_identifiers\", \"@angular/compiler/src/render3/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.compileInjector = exports.compileNgModule = void 0;\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var r3_identifiers_1 = require(\"@angular/compiler/src/render3/r3_identifiers\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/util\");\n  /**\n   * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n   */\n\n\n  function compileNgModule(meta) {\n    var internalType = meta.internalType,\n        moduleType = meta.type,\n        bootstrap = meta.bootstrap,\n        declarations = meta.declarations,\n        imports = meta.imports,\n        exports = meta.exports,\n        schemas = meta.schemas,\n        containsForwardDecls = meta.containsForwardDecls,\n        emitInline = meta.emitInline,\n        id = meta.id;\n    var additionalStatements = [];\n    var definitionMap = {\n      type: internalType\n    }; // Only generate the keys in the metadata if the arrays have values.\n\n    if (bootstrap.length) {\n      definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);\n    } // If requested to emit scope information inline, pass the declarations, imports and exports to\n    // the `ɵɵdefineNgModule` call. The JIT compilation uses this.\n\n\n    if (emitInline) {\n      if (declarations.length) {\n        definitionMap.declarations = refsToArray(declarations, containsForwardDecls);\n      }\n\n      if (imports.length) {\n        definitionMap.imports = refsToArray(imports, containsForwardDecls);\n      }\n\n      if (exports.length) {\n        definitionMap.exports = refsToArray(exports, containsForwardDecls);\n      }\n    } // If not emitting inline, the scope information is not passed into `ɵɵdefineNgModule` as it would\n    // prevent tree-shaking of the declarations, imports and exports references.\n    else {\n        var setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n\n        if (setNgModuleScopeCall !== null) {\n          additionalStatements.push(setNgModuleScopeCall);\n        }\n      }\n\n    if (schemas && schemas.length) {\n      definitionMap.schemas = o.literalArr(schemas.map(function (ref) {\n        return ref.value;\n      }));\n    }\n\n    if (id) {\n      definitionMap.id = id;\n    }\n\n    var expression = o.importExpr(r3_identifiers_1.Identifiers.defineNgModule).callFn([util_1.mapToMapExpression(definitionMap)]);\n    var type = new o.ExpressionType(o.importExpr(r3_identifiers_1.Identifiers.NgModuleDefWithMeta, [new o.ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports), tupleTypeOf(exports)]));\n    return {\n      expression: expression,\n      type: type,\n      additionalStatements: additionalStatements\n    };\n  }\n\n  exports.compileNgModule = compileNgModule;\n  /**\n   * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n   * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n   * such that the references to declarations, imports and exports may be elided causing these\n   * symbols to become tree-shakeable.\n   */\n\n  function generateSetNgModuleScopeCall(meta) {\n    var moduleType = meta.adjacentType,\n        declarations = meta.declarations,\n        imports = meta.imports,\n        exports = meta.exports,\n        containsForwardDecls = meta.containsForwardDecls;\n    var scopeMap = {};\n\n    if (declarations.length) {\n      scopeMap.declarations = refsToArray(declarations, containsForwardDecls);\n    }\n\n    if (imports.length) {\n      scopeMap.imports = refsToArray(imports, containsForwardDecls);\n    }\n\n    if (exports.length) {\n      scopeMap.exports = refsToArray(exports, containsForwardDecls);\n    }\n\n    if (Object.keys(scopeMap).length === 0) {\n      return null;\n    } // setNgModuleScope(...)\n\n\n    var fnCall = new o.InvokeFunctionExpr(\n    /* fn */\n    o.importExpr(r3_identifiers_1.Identifiers.setNgModuleScope),\n    /* args */\n    [moduleType, util_1.mapToMapExpression(scopeMap)]); // (ngJitMode guard) && setNgModuleScope(...)\n\n    var guardedCall = util_1.jitOnlyGuardedExpression(fnCall); // function() { (ngJitMode guard) && setNgModuleScope(...); }\n\n    var iife = new o.FunctionExpr(\n    /* params */\n    [],\n    /* statements */\n    [guardedCall.toStmt()]); // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n\n    var iifeCall = new o.InvokeFunctionExpr(\n    /* fn */\n    iife,\n    /* args */\n    []);\n    return iifeCall.toStmt();\n  }\n\n  function compileInjector(meta) {\n    var definitionMap = {};\n\n    if (meta.providers !== null) {\n      definitionMap.providers = meta.providers;\n    }\n\n    if (meta.imports.length > 0) {\n      definitionMap.imports = o.literalArr(meta.imports);\n    }\n\n    var expression = o.importExpr(r3_identifiers_1.Identifiers.defineInjector).callFn([util_1.mapToMapExpression(definitionMap)]);\n    var type = new o.ExpressionType(o.importExpr(r3_identifiers_1.Identifiers.InjectorDef, [new o.ExpressionType(meta.type.type)]));\n    return {\n      expression: expression,\n      type: type\n    };\n  }\n\n  exports.compileInjector = compileInjector;\n\n  function tupleTypeOf(exp) {\n    var types = exp.map(function (ref) {\n      return o.typeofExpr(ref.type);\n    });\n    return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n  }\n\n  function refsToArray(refs, shouldForwardDeclare) {\n    var values = o.literalArr(refs.map(function (ref) {\n      return ref.value;\n    }));\n    return shouldForwardDeclare ? o.fn([], [new o.ReturnStatement(values)]) : values;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/render3/r3_module_compiler.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAEH,MAAA,CAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AAGA,MAAA,gBAAA,GAAA,OAAA,CAAA,8CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,oCAAA,CAAA;AA4EA;;AAEG;;;AACH,WAAgB,eAAhB,CAAgC,IAAhC,EAAwD;AAEpD,QAAA,YAAY,GAUV,IAAI,CAVM,YAAZ;AAAA,QACM,UAAU,GASd,IAAI,CATU,IADhB;AAAA,QAEA,SAAS,GAQP,IAAI,CARG,SAFT;AAAA,QAGA,YAAY,GAOV,IAAI,CAPM,YAHZ;AAAA,QAIA,OAAO,GAML,IAAI,CANC,OAJP;AAAA,QAKA,OAAO,GAKL,IAAI,CALC,OALP;AAAA,QAMA,OAAO,GAIL,IAAI,CAJC,OANP;AAAA,QAOA,oBAAoB,GAGlB,IAAI,CAHc,oBAPpB;AAAA,QAQA,UAAU,GAER,IAAI,CAFI,UARV;AAAA,QASA,EAAE,GACA,IAAI,CADJ,EATF;AAYF,QAAM,oBAAoB,GAAkB,EAA5C;AACA,QAAM,aAAa,GAAG;AAAC,MAAA,IAAI,EAAE;AAAP,KAAtB,CAfsD,CAyBtD;;AACA,QAAI,SAAS,CAAC,MAAd,EAAsB;AACpB,MAAA,aAAa,CAAC,SAAd,GAA0B,WAAW,CAAC,SAAD,EAAY,oBAAZ,CAArC;AACD,KA5BqD,CA8BtD;AACA;;;AACA,QAAI,UAAJ,EAAgB;AACd,UAAI,YAAY,CAAC,MAAjB,EAAyB;AACvB,QAAA,aAAa,CAAC,YAAd,GAA6B,WAAW,CAAC,YAAD,EAAe,oBAAf,CAAxC;AACD;;AAED,UAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,QAAA,aAAa,CAAC,OAAd,GAAwB,WAAW,CAAC,OAAD,EAAU,oBAAV,CAAnC;AACD;;AAED,UAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,QAAA,aAAa,CAAC,OAAd,GAAwB,WAAW,CAAC,OAAD,EAAU,oBAAV,CAAnC;AACD;AACF,KAZD,CAcA;AACA;AAfA,SAgBK;AACH,YAAM,oBAAoB,GAAG,4BAA4B,CAAC,IAAD,CAAzD;;AACA,YAAI,oBAAoB,KAAK,IAA7B,EAAmC;AACjC,UAAA,oBAAoB,CAAC,IAArB,CAA0B,oBAA1B;AACD;AACF;;AAED,QAAI,OAAO,IAAI,OAAO,CAAC,MAAvB,EAA+B;AAC7B,MAAA,aAAa,CAAC,OAAd,GAAwB,CAAC,CAAC,UAAF,CAAa,OAAO,CAAC,GAAR,CAAY,UAAA,GAAA,EAAG;AAAI,eAAA,GAAG,CAAH,KAAA;AAAS,OAA5B,CAAb,CAAxB;AACD;;AAED,QAAI,EAAJ,EAAQ;AACN,MAAA,aAAa,CAAC,EAAd,GAAmB,EAAnB;AACD;;AAED,QAAM,UAAU,GAAG,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,cAAhB,EAAgC,MAAhC,CAAuC,CAAC,MAAA,CAAA,kBAAA,CAAmB,aAAnB,CAAD,CAAvC,CAAnB;AACA,QAAM,IAAI,GAAG,IAAI,CAAC,CAAC,cAAN,CAAqB,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,mBAAhB,EAAqC,CACrE,IAAI,CAAC,CAAC,cAAN,CAAqB,UAAU,CAAC,IAAhC,CADqE,EAC9B,WAAW,CAAC,YAAD,CADmB,EACH,WAAW,CAAC,OAAD,CADR,EAErE,WAAW,CAAC,OAAD,CAF0D,CAArC,CAArB,CAAb;AAMA,WAAO;AAAC,MAAA,UAAU,EAAA,UAAX;AAAa,MAAA,IAAI,EAAA,IAAjB;AAAmB,MAAA,oBAAoB,EAAA;AAAvC,KAAP;AACD;;AAvED,EAAA,OAAA,CAAA,eAAA,GAAA,eAAA;AAyEA;;;;;AAKG;;AACH,WAAS,4BAAT,CAAsC,IAAtC,EAA8D;AACrD,QAAc,UAAU,GAA0D,IAAI,CAA9D,YAAxB;AAAA,QAA0B,YAAY,GAA4C,IAAI,CAAhD,YAAtC;AAAA,QAAwC,OAAO,GAAmC,IAAI,CAAvC,OAA/C;AAAA,QAAiD,OAAO,GAA0B,IAAI,CAA9B,OAAxD;AAAA,QAA0D,oBAAoB,GAAI,IAAI,CAAR,oBAA9E;AAEP,QAAM,QAAQ,GAAG,EAAjB;;AAMA,QAAI,YAAY,CAAC,MAAjB,EAAyB;AACvB,MAAA,QAAQ,CAAC,YAAT,GAAwB,WAAW,CAAC,YAAD,EAAe,oBAAf,CAAnC;AACD;;AAED,QAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,MAAA,QAAQ,CAAC,OAAT,GAAmB,WAAW,CAAC,OAAD,EAAU,oBAAV,CAA9B;AACD;;AAED,QAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,MAAA,QAAQ,CAAC,OAAT,GAAmB,WAAW,CAAC,OAAD,EAAU,oBAAV,CAA9B;AACD;;AAED,QAAI,MAAM,CAAC,IAAP,CAAY,QAAZ,EAAsB,MAAtB,KAAiC,CAArC,EAAwC;AACtC,aAAO,IAAP;AACD,KAvB2D,CAyB5D;;;AACA,QAAM,MAAM,GAAG,IAAI,CAAC,CAAC,kBAAN;AACX;AAAS,IAAA,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,gBAAhB,CADE;AAEX;AAAU,KAAC,UAAD,EAAa,MAAA,CAAA,kBAAA,CAAmB,QAAnB,CAAb,CAFC,CAAf,CA1B4D,CA8B5D;;AACA,QAAM,WAAW,GAAG,MAAA,CAAA,wBAAA,CAAyB,MAAzB,CAApB,CA/B4D,CAiC5D;;AACA,QAAM,IAAI,GAAG,IAAI,CAAC,CAAC,YAAN;AACT;AAAY,MADH;AAET;AAAgB,KAAC,WAAW,CAAC,MAAZ,EAAD,CAFP,CAAb,CAlC4D,CAsC5D;;AACA,QAAM,QAAQ,GAAG,IAAI,CAAC,CAAC,kBAAN;AACb;AAAS,IAAA,IADI;AAEb;AAAU,MAFG,CAAjB;AAIA,WAAO,QAAQ,CAAC,MAAT,EAAP;AACD;;AAeD,WAAgB,eAAhB,CAAgC,IAAhC,EAAwD;AACtD,QAAM,aAAa,GAAiC,EAApD;;AAEA,QAAI,IAAI,CAAC,SAAL,KAAmB,IAAvB,EAA6B;AAC3B,MAAA,aAAa,CAAC,SAAd,GAA0B,IAAI,CAAC,SAA/B;AACD;;AAED,QAAI,IAAI,CAAC,OAAL,CAAa,MAAb,GAAsB,CAA1B,EAA6B;AAC3B,MAAA,aAAa,CAAC,OAAd,GAAwB,CAAC,CAAC,UAAF,CAAa,IAAI,CAAC,OAAlB,CAAxB;AACD;;AAED,QAAM,UAAU,GAAG,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,cAAhB,EAAgC,MAAhC,CAAuC,CAAC,MAAA,CAAA,kBAAA,CAAmB,aAAnB,CAAD,CAAvC,CAAnB;AACA,QAAM,IAAI,GACN,IAAI,CAAC,CAAC,cAAN,CAAqB,CAAC,CAAC,UAAF,CAAa,gBAAA,CAAA,WAAA,CAAG,WAAhB,EAA6B,CAAC,IAAI,CAAC,CAAC,cAAN,CAAqB,IAAI,CAAC,IAAL,CAAU,IAA/B,CAAD,CAA7B,CAArB,CADJ;AAEA,WAAO;AAAC,MAAA,UAAU,EAAA,UAAX;AAAa,MAAA,IAAI,EAAA;AAAjB,KAAP;AACD;;AAfD,EAAA,OAAA,CAAA,eAAA,GAAA,eAAA;;AAiBA,WAAS,WAAT,CAAqB,GAArB,EAAuC;AACrC,QAAM,KAAK,GAAG,GAAG,CAAC,GAAJ,CAAQ,UAAA,GAAA,EAAG;AAAI,aAAA,CAAC,CAAC,UAAF,CAAa,GAAG,CAAhB,IAAA,CAAA;AAAsB,KAArC,CAAd;AACA,WAAO,GAAG,CAAC,MAAJ,GAAa,CAAb,GAAiB,CAAC,CAAC,cAAF,CAAiB,CAAC,CAAC,UAAF,CAAa,KAAb,CAAjB,CAAjB,GAAyD,CAAC,CAAC,SAAlE;AACD;;AAED,WAAS,WAAT,CAAqB,IAArB,EAA0C,oBAA1C,EAAuE;AACrE,QAAM,MAAM,GAAG,CAAC,CAAC,UAAF,CAAa,IAAI,CAAC,GAAL,CAAS,UAAA,GAAA,EAAG;AAAI,aAAA,GAAG,CAAH,KAAA;AAAS,KAAzB,CAAb,CAAf;AACA,WAAO,oBAAoB,GAAG,CAAC,CAAC,EAAF,CAAK,EAAL,EAAS,CAAC,IAAI,CAAC,CAAC,eAAN,CAAsB,MAAtB,CAAD,CAAT,CAAH,GAA+C,MAA1E;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\n\nimport {R3DependencyMetadata, R3FactoryFn} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {jitOnlyGuardedExpression, mapToMapExpression, R3Reference} from './util';\n\nexport interface R3NgModuleDef {\n  expression: o.Expression;\n  type: o.Type;\n  additionalStatements: o.Statement[];\n}\n\n/**\n * Metadata required by the module compiler to generate a module def (`ɵmod`) for a type.\n */\nexport interface R3NgModuleMetadata {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the module type being compiled, intended for use within a class\n   * definition itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * An expression intended for use by statements that are adjacent (i.e. tightly coupled) to but\n   * not internal to a class definition.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  adjacentType: o.Expression;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * Whether to emit the selector scope values (declarations, imports, exports) inline into the\n   * module definition, or to generate additional statements which patch them on. Inline emission\n   * does not allow components to be tree-shaken, but is useful for JIT mode.\n   */\n  emitInline: boolean;\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[]|null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression|null;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef {\n  const {\n    internalType,\n    type: moduleType,\n    bootstrap,\n    declarations,\n    imports,\n    exports,\n    schemas,\n    containsForwardDecls,\n    emitInline,\n    id\n  } = meta;\n\n  const additionalStatements: o.Statement[] = [];\n  const definitionMap = {type: internalType} as {\n    type: o.Expression,\n    bootstrap: o.Expression,\n    declarations: o.Expression,\n    imports: o.Expression,\n    exports: o.Expression,\n    schemas: o.LiteralArrayExpr,\n    id: o.Expression\n  };\n\n  // Only generate the keys in the metadata if the arrays have values.\n  if (bootstrap.length) {\n    definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);\n  }\n\n  // If requested to emit scope information inline, pass the declarations, imports and exports to\n  // the `ɵɵdefineNgModule` call. The JIT compilation uses this.\n  if (emitInline) {\n    if (declarations.length) {\n      definitionMap.declarations = refsToArray(declarations, containsForwardDecls);\n    }\n\n    if (imports.length) {\n      definitionMap.imports = refsToArray(imports, containsForwardDecls);\n    }\n\n    if (exports.length) {\n      definitionMap.exports = refsToArray(exports, containsForwardDecls);\n    }\n  }\n\n  // If not emitting inline, the scope information is not passed into `ɵɵdefineNgModule` as it would\n  // prevent tree-shaking of the declarations, imports and exports references.\n  else {\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      additionalStatements.push(setNgModuleScopeCall);\n    }\n  }\n\n  if (schemas && schemas.length) {\n    definitionMap.schemas = o.literalArr(schemas.map(ref => ref.value));\n  }\n\n  if (id) {\n    definitionMap.id = id;\n  }\n\n  const expression = o.importExpr(R3.defineNgModule).callFn([mapToMapExpression(definitionMap)]);\n  const type = new o.ExpressionType(o.importExpr(R3.NgModuleDefWithMeta, [\n    new o.ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),\n    tupleTypeOf(exports)\n  ]));\n\n\n  return {expression, type, additionalStatements};\n}\n\n/**\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement|null {\n  const {adjacentType: moduleType, declarations, imports, exports, containsForwardDecls} = meta;\n\n  const scopeMap = {} as {\n    declarations: o.Expression,\n    imports: o.Expression,\n    exports: o.Expression,\n  };\n\n  if (declarations.length) {\n    scopeMap.declarations = refsToArray(declarations, containsForwardDecls);\n  }\n\n  if (imports.length) {\n    scopeMap.imports = refsToArray(imports, containsForwardDecls);\n  }\n\n  if (exports.length) {\n    scopeMap.exports = refsToArray(exports, containsForwardDecls);\n  }\n\n  if (Object.keys(scopeMap).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n      /* fn */ o.importExpr(R3.setNgModuleScope),\n      /* args */[moduleType, mapToMapExpression(scopeMap)]);\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(\n      /* params */[],\n      /* statements */[guardedCall.toStmt()]);\n\n  // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n  const iifeCall = new o.InvokeFunctionExpr(\n      /* fn */ iife,\n      /* args */[]);\n\n  return iifeCall.toStmt();\n}\n\nexport interface R3InjectorDef {\n  expression: o.Expression;\n  type: o.Type;\n}\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: R3Reference;\n  internalType: o.Expression;\n  providers: o.Expression|null;\n  imports: o.Expression[];\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3InjectorDef {\n  const definitionMap: Record<string, o.Expression> = {};\n\n  if (meta.providers !== null) {\n    definitionMap.providers = meta.providers;\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.imports = o.literalArr(meta.imports);\n  }\n\n  const expression = o.importExpr(R3.defineInjector).callFn([mapToMapExpression(definitionMap)]);\n  const type =\n      new o.ExpressionType(o.importExpr(R3.InjectorDef, [new o.ExpressionType(meta.type.type)]));\n  return {expression, type};\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map(ref => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n\nfunction refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression {\n  const values = o.literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? o.fn([], [new o.ReturnStatement(values)]) : values;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}