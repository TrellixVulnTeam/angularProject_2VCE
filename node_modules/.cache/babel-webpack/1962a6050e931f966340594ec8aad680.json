{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar Generator = require(\"../Generator\");\n\nvar Template = require(\"../Template\");\n\nvar WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\nvar _require = require(\"webpack-sources\"),\n    RawSource = _require.RawSource;\n\nvar _require2 = require(\"@webassemblyjs/wasm-edit\"),\n    editWithAST = _require2.editWithAST,\n    addWithAST = _require2.addWithAST;\n\nvar _require3 = require(\"@webassemblyjs/wasm-parser\"),\n    decode = _require3.decode;\n\nvar t = require(\"@webassemblyjs/ast\");\n\nvar _require4 = require(\"@webassemblyjs/helper-module-context\"),\n    moduleContextFromModuleAST = _require4.moduleContextFromModuleAST;\n\nvar WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\n\n\nvar compose = function compose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return fns.reduce(function (prevFn, nextFn) {\n    return function (value) {\n      return nextFn(prevFn(value));\n    };\n  }, function (value) {\n    return value;\n  });\n}; // TODO replace with @callback\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar removeStartFunc = function removeStartFunc(state) {\n  return function (bin) {\n    return editWithAST(state.ast, bin, {\n      Start: function Start(path) {\n        path.remove();\n      }\n    });\n  };\n};\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\n\n\nvar getImportedGlobals = function getImportedGlobals(ast) {\n  var importedGlobals = [];\n  t.traverse(ast, {\n    ModuleImport: function ModuleImport(_ref) {\n      var node = _ref.node;\n\n      if (t.isGlobalType(node.descr)) {\n        importedGlobals.push(node);\n      }\n    }\n  });\n  return importedGlobals;\n};\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\n\n\nvar getCountImportedFunc = function getCountImportedFunc(ast) {\n  var count = 0;\n  t.traverse(ast, {\n    ModuleImport: function ModuleImport(_ref2) {\n      var node = _ref2.node;\n\n      if (t.isFuncImportDescr(node.descr)) {\n        count++;\n      }\n    }\n  });\n  return count;\n};\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\n\n\nvar getNextTypeIndex = function getNextTypeIndex(ast) {\n  var typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n\n  if (typeSectionMetadata === undefined) {\n    return t.indexLiteral(0);\n  }\n\n  return t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\n\n\nvar getNextFuncIndex = function getNextFuncIndex(ast, countImportedFunc) {\n  var funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n\n  if (funcSectionMetadata === undefined) {\n    return t.indexLiteral(0 + countImportedFunc);\n  }\n\n  var vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n  return t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\n\n\nvar createDefaultInitForGlobal = function createDefaultInitForGlobal(globalType) {\n  if (globalType.valtype[0] === \"i\") {\n    // create NumberLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.numberLiteralFromRaw(66)]);\n  } else if (globalType.valtype[0] === \"f\") {\n    // create FloatLiteral global initializer\n    return t.objectInstruction(\"const\", globalType.valtype, [t.floatLiteral(66, false, false, \"66\")]);\n  } else {\n    throw new Error(\"unknown type: \" + globalType.valtype);\n  }\n};\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar rewriteImportedGlobals = function rewriteImportedGlobals(state) {\n  return function (bin) {\n    var additionalInitCode = state.additionalInitCode;\n    var newGlobals = [];\n    bin = editWithAST(state.ast, bin, {\n      ModuleImport: function ModuleImport(path) {\n        if (t.isGlobalType(path.node.descr)) {\n          var globalType = path.node.descr;\n          globalType.mutability = \"var\";\n          var init = [createDefaultInitForGlobal(globalType), t.instruction(\"end\")];\n          newGlobals.push(t.global(globalType, init));\n          path.remove();\n        }\n      },\n      // in order to preserve non-imported global's order we need to re-inject\n      // those as well\n      Global: function Global(path) {\n        var node = path.node;\n\n        var _node$init = _slicedToArray(node.init, 1),\n            init = _node$init[0];\n\n        if (init.id === \"get_global\") {\n          node.globalType.mutability = \"var\";\n          var initialGlobalidx = init.args[0];\n          node.init = [createDefaultInitForGlobal(node.globalType), t.instruction(\"end\")];\n          additionalInitCode.push(\n          /**\n           * get_global in global initializer only works for imported globals.\n           * They have the same indices as the init params, so use the\n           * same index.\n           */\n          t.instruction(\"get_local\", [initialGlobalidx]), t.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)]));\n        }\n\n        newGlobals.push(node);\n        path.remove();\n      }\n    }); // Add global declaration instructions\n\n    return addWithAST(state.ast, bin, newGlobals);\n  };\n};\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {Set<string>} state.externalExports Module\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar rewriteExportNames = function rewriteExportNames(_ref3) {\n  var ast = _ref3.ast,\n      module = _ref3.module,\n      externalExports = _ref3.externalExports;\n  return function (bin) {\n    return editWithAST(ast, bin, {\n      ModuleExport: function ModuleExport(path) {\n        var isExternal = externalExports.has(path.node.name);\n\n        if (isExternal) {\n          path.remove();\n          return;\n        }\n\n        var usedName = module.isUsed(path.node.name);\n\n        if (!usedName) {\n          path.remove();\n          return;\n        }\n\n        path.node.name = usedName;\n      }\n    });\n  };\n};\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar rewriteImports = function rewriteImports(_ref4) {\n  var ast = _ref4.ast,\n      usedDependencyMap = _ref4.usedDependencyMap;\n  return function (bin) {\n    return editWithAST(ast, bin, {\n      ModuleImport: function ModuleImport(path) {\n        var result = usedDependencyMap.get(path.node.module + \":\" + path.node.name);\n\n        if (result !== undefined) {\n          path.node.module = result.module;\n          path.node.name = result.name;\n        }\n      }\n    });\n  };\n};\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\n\n\nvar addInitFunction = function addInitFunction(_ref5) {\n  var ast = _ref5.ast,\n      initFuncId = _ref5.initFuncId,\n      startAtFuncOffset = _ref5.startAtFuncOffset,\n      importedGlobals = _ref5.importedGlobals,\n      additionalInitCode = _ref5.additionalInitCode,\n      nextFuncIndex = _ref5.nextFuncIndex,\n      nextTypeIndex = _ref5.nextTypeIndex;\n  return function (bin) {\n    var funcParams = importedGlobals.map(function (importedGlobal) {\n      // used for debugging\n      var id = t.identifier(\"\".concat(importedGlobal.module, \".\").concat(importedGlobal.name));\n      return t.funcParam(importedGlobal.descr.valtype, id);\n    });\n    var funcBody = importedGlobals.reduce(function (acc, importedGlobal, index) {\n      var args = [t.indexLiteral(index)];\n      var body = [t.instruction(\"get_local\", args), t.instruction(\"set_global\", args)];\n      return [].concat(_toConsumableArray(acc), body);\n    }, []);\n\n    if (typeof startAtFuncOffset === \"number\") {\n      funcBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n    }\n\n    var _iterator = _createForOfIteratorHelper(additionalInitCode),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var instr = _step.value;\n        funcBody.push(instr);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    funcBody.push(t.instruction(\"end\"));\n    var funcResults = []; // Code section\n\n    var funcSignature = t.signature(funcParams, funcResults);\n    var func = t.func(initFuncId, funcSignature, funcBody); // Type section\n\n    var functype = t.typeInstruction(undefined, funcSignature); // Func section\n\n    var funcindex = t.indexInFuncSection(nextTypeIndex); // Export section\n\n    var moduleExport = t.moduleExport(initFuncId.value, t.moduleExportDescr(\"Func\", nextFuncIndex));\n    return addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n  };\n};\n/**\n * Extract mangle mappings from module\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\n\n\nvar getUsedDependencyMap = function getUsedDependencyMap(module, mangle) {\n  /** @type {Map<string, UsedWasmDependency>} */\n  var map = new Map();\n\n  var _iterator2 = _createForOfIteratorHelper(WebAssemblyUtils.getUsedDependencies(module, mangle)),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var usedDep = _step2.value;\n      var dep = usedDep.dependency;\n      var request = dep.request;\n      var exportName = dep.name;\n      map.set(request + \":\" + exportName, usedDep);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return map;\n};\n\nvar WebAssemblyGenerator = /*#__PURE__*/function (_Generator) {\n  _inherits(WebAssemblyGenerator, _Generator);\n\n  var _super = _createSuper(WebAssemblyGenerator);\n\n  function WebAssemblyGenerator(options) {\n    var _this;\n\n    _classCallCheck(this, WebAssemblyGenerator);\n\n    _this = _super.call(this);\n    _this.options = options;\n    return _this;\n  }\n  /**\n   * @param {NormalModule} module module for which the code should be generated\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n   * @param {RuntimeTemplate} runtimeTemplate the runtime template\n   * @param {string} type which kind of code should be generated\n   * @returns {Source} generated code\n   */\n\n\n  _createClass(WebAssemblyGenerator, [{\n    key: \"generate\",\n    value: function generate(module, dependencyTemplates, runtimeTemplate, type) {\n      var bin = module.originalSource().source();\n      var initFuncId = t.identifier(Array.isArray(module.usedExports) ? Template.numberToIdentifer(module.usedExports.length) : \"__webpack_init__\"); // parse it\n\n      var ast = decode(bin, {\n        ignoreDataSection: true,\n        ignoreCodeSection: true,\n        ignoreCustomNameSection: true\n      });\n      var moduleContext = moduleContextFromModuleAST(ast.body[0]);\n      var importedGlobals = getImportedGlobals(ast);\n      var countImportedFunc = getCountImportedFunc(ast);\n      var startAtFuncOffset = moduleContext.getStart();\n      var nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n      var nextTypeIndex = getNextTypeIndex(ast);\n      var usedDependencyMap = getUsedDependencyMap(module, this.options.mangleImports);\n      var externalExports = new Set(module.dependencies.filter(function (d) {\n        return d instanceof WebAssemblyExportImportedDependency;\n      }).map(function (d) {\n        var wasmDep =\n        /** @type {WebAssemblyExportImportedDependency} */\n        d;\n        return wasmDep.exportName;\n      }));\n      /** @type {t.Instruction[]} */\n\n      var additionalInitCode = [];\n      var transform = compose(rewriteExportNames({\n        ast: ast,\n        module: module,\n        externalExports: externalExports\n      }), removeStartFunc({\n        ast: ast\n      }), rewriteImportedGlobals({\n        ast: ast,\n        additionalInitCode: additionalInitCode\n      }), rewriteImports({\n        ast: ast,\n        usedDependencyMap: usedDependencyMap\n      }), addInitFunction({\n        ast: ast,\n        initFuncId: initFuncId,\n        importedGlobals: importedGlobals,\n        additionalInitCode: additionalInitCode,\n        startAtFuncOffset: startAtFuncOffset,\n        nextFuncIndex: nextFuncIndex,\n        nextTypeIndex: nextTypeIndex\n      }));\n      var newBin = transform(bin);\n      return new RawSource(newBin);\n    }\n  }]);\n\n  return WebAssemblyGenerator;\n}(Generator);\n\nmodule.exports = WebAssemblyGenerator;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/wasm/WebAssemblyGenerator.js"],"names":["Generator","require","Template","WebAssemblyUtils","RawSource","editWithAST","addWithAST","decode","t","moduleContextFromModuleAST","WebAssemblyExportImportedDependency","compose","fns","reduce","prevFn","nextFn","value","removeStartFunc","state","bin","ast","Start","path","remove","getImportedGlobals","importedGlobals","traverse","ModuleImport","node","isGlobalType","descr","push","getCountImportedFunc","count","isFuncImportDescr","getNextTypeIndex","typeSectionMetadata","getSectionMetadata","undefined","indexLiteral","vectorOfSize","getNextFuncIndex","countImportedFunc","funcSectionMetadata","createDefaultInitForGlobal","globalType","valtype","objectInstruction","numberLiteralFromRaw","floatLiteral","Error","rewriteImportedGlobals","additionalInitCode","newGlobals","mutability","init","instruction","global","Global","id","initialGlobalidx","args","length","rewriteExportNames","module","externalExports","ModuleExport","isExternal","has","name","usedName","isUsed","rewriteImports","usedDependencyMap","result","get","addInitFunction","initFuncId","startAtFuncOffset","nextFuncIndex","nextTypeIndex","funcParams","map","importedGlobal","identifier","funcParam","funcBody","acc","index","body","callInstruction","instr","funcResults","funcSignature","signature","func","functype","typeInstruction","funcindex","indexInFuncSection","moduleExport","moduleExportDescr","getUsedDependencyMap","mangle","Map","getUsedDependencies","usedDep","dep","dependency","request","exportName","set","WebAssemblyGenerator","options","dependencyTemplates","runtimeTemplate","type","originalSource","source","Array","isArray","usedExports","numberToIdentifer","ignoreDataSection","ignoreCodeSection","ignoreCustomNameSection","moduleContext","getStart","mangleImports","Set","dependencies","filter","d","wasmDep","transform","newBin","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Generator = require(\"../Generator\");\nconst Template = require(\"../Template\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\nconst { RawSource } = require(\"webpack-sources\");\n\nconst { editWithAST, addWithAST } = require(\"@webassemblyjs/wasm-edit\");\nconst { decode } = require(\"@webassemblyjs/wasm-parser\");\nconst t = require(\"@webassemblyjs/ast\");\nconst {\n\tmoduleContextFromModuleAST\n} = require(\"@webassemblyjs/helper-module-context\");\n\nconst WebAssemblyExportImportedDependency = require(\"../dependencies/WebAssemblyExportImportedDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"./WebAssemblyUtils\").UsedWasmDependency} UsedWasmDependency */\n/** @typedef {import(\"../NormalModule\")} NormalModule */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../Dependency\").DependencyTemplate} DependencyTemplate */\n\n/**\n * @typedef {(ArrayBuffer) => ArrayBuffer} ArrayBufferTransform\n */\n\n/**\n * @template T\n * @param {Function[]} fns transforms\n * @returns {Function} composed transform\n */\nconst compose = (...fns) => {\n\treturn fns.reduce(\n\t\t(prevFn, nextFn) => {\n\t\t\treturn value => nextFn(prevFn(value));\n\t\t},\n\t\tvalue => value\n\t);\n};\n\n// TODO replace with @callback\n\n/**\n * Removes the start instruction\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst removeStartFunc = state => bin => {\n\treturn editWithAST(state.ast, bin, {\n\t\tStart(path) {\n\t\t\tpath.remove();\n\t\t}\n\t});\n};\n\n/**\n * Get imported globals\n *\n * @param {Object} ast Module's AST\n * @returns {Array<t.ModuleImport>} - nodes\n */\nconst getImportedGlobals = ast => {\n\tconst importedGlobals = [];\n\n\tt.traverse(ast, {\n\t\tModuleImport({ node }) {\n\t\t\tif (t.isGlobalType(node.descr)) {\n\t\t\t\timportedGlobals.push(node);\n\t\t\t}\n\t\t}\n\t});\n\n\treturn importedGlobals;\n};\n\n/**\n * Get the count for imported func\n *\n * @param {Object} ast Module's AST\n * @returns {Number} - count\n */\nconst getCountImportedFunc = ast => {\n\tlet count = 0;\n\n\tt.traverse(ast, {\n\t\tModuleImport({ node }) {\n\t\t\tif (t.isFuncImportDescr(node.descr)) {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn count;\n};\n\n/**\n * Get next type index\n *\n * @param {Object} ast Module's AST\n * @returns {t.Index} - index\n */\nconst getNextTypeIndex = ast => {\n\tconst typeSectionMetadata = t.getSectionMetadata(ast, \"type\");\n\n\tif (typeSectionMetadata === undefined) {\n\t\treturn t.indexLiteral(0);\n\t}\n\n\treturn t.indexLiteral(typeSectionMetadata.vectorOfSize.value);\n};\n\n/**\n * Get next func index\n *\n * The Func section metadata provide informations for implemented funcs\n * in order to have the correct index we shift the index by number of external\n * functions.\n *\n * @param {Object} ast Module's AST\n * @param {Number} countImportedFunc number of imported funcs\n * @returns {t.Index} - index\n */\nconst getNextFuncIndex = (ast, countImportedFunc) => {\n\tconst funcSectionMetadata = t.getSectionMetadata(ast, \"func\");\n\n\tif (funcSectionMetadata === undefined) {\n\t\treturn t.indexLiteral(0 + countImportedFunc);\n\t}\n\n\tconst vectorOfSize = funcSectionMetadata.vectorOfSize.value;\n\n\treturn t.indexLiteral(vectorOfSize + countImportedFunc);\n};\n\n/**\n * Creates an init instruction for a global type\n * @param {t.GlobalType} globalType the global type\n * @returns {t.Instruction} init expression\n */\nconst createDefaultInitForGlobal = globalType => {\n\tif (globalType.valtype[0] === \"i\") {\n\t\t// create NumberLiteral global initializer\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\n\t\t\tt.numberLiteralFromRaw(66)\n\t\t]);\n\t} else if (globalType.valtype[0] === \"f\") {\n\t\t// create FloatLiteral global initializer\n\t\treturn t.objectInstruction(\"const\", globalType.valtype, [\n\t\t\tt.floatLiteral(66, false, false, \"66\")\n\t\t]);\n\t} else {\n\t\tthrow new Error(\"unknown type: \" + globalType.valtype);\n\t}\n};\n\n/**\n * Rewrite the import globals:\n * - removes the ModuleImport instruction\n * - injects at the same offset a mutable global of the same type\n *\n * Since the imported globals are before the other global declarations, our\n * indices will be preserved.\n *\n * Note that globals will become mutable.\n *\n * @param {Object} state unused state\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImportedGlobals = state => bin => {\n\tconst additionalInitCode = state.additionalInitCode;\n\tconst newGlobals = [];\n\n\tbin = editWithAST(state.ast, bin, {\n\t\tModuleImport(path) {\n\t\t\tif (t.isGlobalType(path.node.descr)) {\n\t\t\t\tconst globalType = path.node.descr;\n\n\t\t\t\tglobalType.mutability = \"var\";\n\n\t\t\t\tconst init = [\n\t\t\t\t\tcreateDefaultInitForGlobal(globalType),\n\t\t\t\t\tt.instruction(\"end\")\n\t\t\t\t];\n\n\t\t\t\tnewGlobals.push(t.global(globalType, init));\n\n\t\t\t\tpath.remove();\n\t\t\t}\n\t\t},\n\n\t\t// in order to preserve non-imported global's order we need to re-inject\n\t\t// those as well\n\t\tGlobal(path) {\n\t\t\tconst { node } = path;\n\t\t\tconst [init] = node.init;\n\n\t\t\tif (init.id === \"get_global\") {\n\t\t\t\tnode.globalType.mutability = \"var\";\n\n\t\t\t\tconst initialGlobalidx = init.args[0];\n\n\t\t\t\tnode.init = [\n\t\t\t\t\tcreateDefaultInitForGlobal(node.globalType),\n\t\t\t\t\tt.instruction(\"end\")\n\t\t\t\t];\n\n\t\t\t\tadditionalInitCode.push(\n\t\t\t\t\t/**\n\t\t\t\t\t * get_global in global initializer only works for imported globals.\n\t\t\t\t\t * They have the same indices as the init params, so use the\n\t\t\t\t\t * same index.\n\t\t\t\t\t */\n\t\t\t\t\tt.instruction(\"get_local\", [initialGlobalidx]),\n\t\t\t\t\tt.instruction(\"set_global\", [t.indexLiteral(newGlobals.length)])\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tnewGlobals.push(node);\n\n\t\t\tpath.remove();\n\t\t}\n\t});\n\n\t// Add global declaration instructions\n\treturn addWithAST(state.ast, bin, newGlobals);\n};\n\n/**\n * Rewrite the export names\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Module} state.module Module\n * @param {Set<string>} state.externalExports Module\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteExportNames = ({ ast, module, externalExports }) => bin => {\n\treturn editWithAST(ast, bin, {\n\t\tModuleExport(path) {\n\t\t\tconst isExternal = externalExports.has(path.node.name);\n\t\t\tif (isExternal) {\n\t\t\t\tpath.remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst usedName = module.isUsed(path.node.name);\n\t\t\tif (!usedName) {\n\t\t\t\tpath.remove();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpath.node.name = usedName;\n\t\t}\n\t});\n};\n\n/**\n * Mangle import names and modules\n * @param {Object} state state\n * @param {Object} state.ast Module's ast\n * @param {Map<string, UsedWasmDependency>} state.usedDependencyMap mappings to mangle names\n * @returns {ArrayBufferTransform} transform\n */\nconst rewriteImports = ({ ast, usedDependencyMap }) => bin => {\n\treturn editWithAST(ast, bin, {\n\t\tModuleImport(path) {\n\t\t\tconst result = usedDependencyMap.get(\n\t\t\t\tpath.node.module + \":\" + path.node.name\n\t\t\t);\n\n\t\t\tif (result !== undefined) {\n\t\t\t\tpath.node.module = result.module;\n\t\t\t\tpath.node.name = result.name;\n\t\t\t}\n\t\t}\n\t});\n};\n\n/**\n * Add an init function.\n *\n * The init function fills the globals given input arguments.\n *\n * @param {Object} state transformation state\n * @param {Object} state.ast Module's ast\n * @param {t.Identifier} state.initFuncId identifier of the init function\n * @param {t.Index} state.startAtFuncOffset index of the start function\n * @param {t.ModuleImport[]} state.importedGlobals list of imported globals\n * @param {t.Instruction[]} state.additionalInitCode list of addition instructions for the init function\n * @param {t.Index} state.nextFuncIndex index of the next function\n * @param {t.Index} state.nextTypeIndex index of the next type\n * @returns {ArrayBufferTransform} transform\n */\nconst addInitFunction = ({\n\tast,\n\tinitFuncId,\n\tstartAtFuncOffset,\n\timportedGlobals,\n\tadditionalInitCode,\n\tnextFuncIndex,\n\tnextTypeIndex\n}) => bin => {\n\tconst funcParams = importedGlobals.map(importedGlobal => {\n\t\t// used for debugging\n\t\tconst id = t.identifier(`${importedGlobal.module}.${importedGlobal.name}`);\n\n\t\treturn t.funcParam(importedGlobal.descr.valtype, id);\n\t});\n\n\tconst funcBody = importedGlobals.reduce((acc, importedGlobal, index) => {\n\t\tconst args = [t.indexLiteral(index)];\n\t\tconst body = [\n\t\t\tt.instruction(\"get_local\", args),\n\t\t\tt.instruction(\"set_global\", args)\n\t\t];\n\n\t\treturn [...acc, ...body];\n\t}, []);\n\n\tif (typeof startAtFuncOffset === \"number\") {\n\t\tfuncBody.push(t.callInstruction(t.numberLiteralFromRaw(startAtFuncOffset)));\n\t}\n\n\tfor (const instr of additionalInitCode) {\n\t\tfuncBody.push(instr);\n\t}\n\n\tfuncBody.push(t.instruction(\"end\"));\n\n\tconst funcResults = [];\n\n\t// Code section\n\tconst funcSignature = t.signature(funcParams, funcResults);\n\tconst func = t.func(initFuncId, funcSignature, funcBody);\n\n\t// Type section\n\tconst functype = t.typeInstruction(undefined, funcSignature);\n\n\t// Func section\n\tconst funcindex = t.indexInFuncSection(nextTypeIndex);\n\n\t// Export section\n\tconst moduleExport = t.moduleExport(\n\t\tinitFuncId.value,\n\t\tt.moduleExportDescr(\"Func\", nextFuncIndex)\n\t);\n\n\treturn addWithAST(ast, bin, [func, moduleExport, funcindex, functype]);\n};\n\n/**\n * Extract mangle mappings from module\n * @param {Module} module current module\n * @param {boolean} mangle mangle imports\n * @returns {Map<string, UsedWasmDependency>} mappings to mangled names\n */\nconst getUsedDependencyMap = (module, mangle) => {\n\t/** @type {Map<string, UsedWasmDependency>} */\n\tconst map = new Map();\n\tfor (const usedDep of WebAssemblyUtils.getUsedDependencies(module, mangle)) {\n\t\tconst dep = usedDep.dependency;\n\t\tconst request = dep.request;\n\t\tconst exportName = dep.name;\n\t\tmap.set(request + \":\" + exportName, usedDep);\n\t}\n\treturn map;\n};\n\nclass WebAssemblyGenerator extends Generator {\n\tconstructor(options) {\n\t\tsuper();\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {NormalModule} module module for which the code should be generated\n\t * @param {Map<Function, DependencyTemplate>} dependencyTemplates mapping from dependencies to templates\n\t * @param {RuntimeTemplate} runtimeTemplate the runtime template\n\t * @param {string} type which kind of code should be generated\n\t * @returns {Source} generated code\n\t */\n\tgenerate(module, dependencyTemplates, runtimeTemplate, type) {\n\t\tlet bin = module.originalSource().source();\n\n\t\tconst initFuncId = t.identifier(\n\t\t\tArray.isArray(module.usedExports)\n\t\t\t\t? Template.numberToIdentifer(module.usedExports.length)\n\t\t\t\t: \"__webpack_init__\"\n\t\t);\n\n\t\t// parse it\n\t\tconst ast = decode(bin, {\n\t\t\tignoreDataSection: true,\n\t\t\tignoreCodeSection: true,\n\t\t\tignoreCustomNameSection: true\n\t\t});\n\n\t\tconst moduleContext = moduleContextFromModuleAST(ast.body[0]);\n\n\t\tconst importedGlobals = getImportedGlobals(ast);\n\t\tconst countImportedFunc = getCountImportedFunc(ast);\n\t\tconst startAtFuncOffset = moduleContext.getStart();\n\t\tconst nextFuncIndex = getNextFuncIndex(ast, countImportedFunc);\n\t\tconst nextTypeIndex = getNextTypeIndex(ast);\n\n\t\tconst usedDependencyMap = getUsedDependencyMap(\n\t\t\tmodule,\n\t\t\tthis.options.mangleImports\n\t\t);\n\t\tconst externalExports = new Set(\n\t\t\tmodule.dependencies\n\t\t\t\t.filter(d => d instanceof WebAssemblyExportImportedDependency)\n\t\t\t\t.map(d => {\n\t\t\t\t\tconst wasmDep = /** @type {WebAssemblyExportImportedDependency} */ (d);\n\t\t\t\t\treturn wasmDep.exportName;\n\t\t\t\t})\n\t\t);\n\n\t\t/** @type {t.Instruction[]} */\n\t\tconst additionalInitCode = [];\n\n\t\tconst transform = compose(\n\t\t\trewriteExportNames({\n\t\t\t\tast,\n\t\t\t\tmodule,\n\t\t\t\texternalExports\n\t\t\t}),\n\n\t\t\tremoveStartFunc({ ast }),\n\n\t\t\trewriteImportedGlobals({ ast, additionalInitCode }),\n\n\t\t\trewriteImports({\n\t\t\t\tast,\n\t\t\t\tusedDependencyMap\n\t\t\t}),\n\n\t\t\taddInitFunction({\n\t\t\t\tast,\n\t\t\t\tinitFuncId,\n\t\t\t\timportedGlobals,\n\t\t\t\tadditionalInitCode,\n\t\t\t\tstartAtFuncOffset,\n\t\t\t\tnextFuncIndex,\n\t\t\t\tnextTypeIndex\n\t\t\t})\n\t\t);\n\n\t\tconst newBin = transform(bin);\n\n\t\treturn new RawSource(newBin);\n\t}\n}\n\nmodule.exports = WebAssemblyGenerator;\n"]},"metadata":{},"sourceType":"script"}