{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isSetEqual = exports.isArrayEqual = exports.referenceEquality = exports.isReferenceEqual = exports.isSymbolEqual = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * Determines whether the provided symbols represent the same declaration.\n   */\n\n\n  function isSymbolEqual(a, b) {\n    if (a.decl === b.decl) {\n      // If the declaration is identical then it must represent the same symbol.\n      return true;\n    }\n\n    if (a.identifier === null || b.identifier === null) {\n      // Unidentifiable symbols are assumed to be different.\n      return false;\n    }\n\n    return a.path === b.path && a.identifier === b.identifier;\n  }\n\n  exports.isSymbolEqual = isSymbolEqual;\n  /**\n   * Determines whether the provided references to a semantic symbol are still equal, i.e. represent\n   * the same symbol and are imported by the same path.\n   */\n\n  function isReferenceEqual(a, b) {\n    if (!isSymbolEqual(a.symbol, b.symbol)) {\n      // If the reference's target symbols are different, the reference itself is different.\n      return false;\n    } // The reference still corresponds with the same symbol, now check that the path by which it is\n    // imported has not changed.\n\n\n    return a.importPath === b.importPath;\n  }\n\n  exports.isReferenceEqual = isReferenceEqual;\n\n  function referenceEquality(a, b) {\n    return a === b;\n  }\n\n  exports.referenceEquality = referenceEquality;\n  /**\n   * Determines if the provided arrays are equal to each other, using the provided equality tester\n   * that is called for all entries in the array.\n   */\n\n  function isArrayEqual(a, b, equalityTester) {\n    if (equalityTester === void 0) {\n      equalityTester = referenceEquality;\n    }\n\n    if (a === null || b === null) {\n      return a === b;\n    }\n\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return !a.some(function (item, index) {\n      return !equalityTester(item, b[index]);\n    });\n  }\n\n  exports.isArrayEqual = isArrayEqual;\n  /**\n   * Determines if the provided sets are equal to each other, using the provided equality tester.\n   * Sets that only differ in ordering are considered equal.\n   */\n\n  function isSetEqual(a, b, equalityTester) {\n    var e_1, _a, e_2, _b;\n\n    if (equalityTester === void 0) {\n      equalityTester = referenceEquality;\n    }\n\n    if (a === null || b === null) {\n      return a === b;\n    }\n\n    if (a.size !== b.size) {\n      return false;\n    }\n\n    try {\n      for (var a_1 = tslib_1.__values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {\n        var itemA = a_1_1.value;\n        var found = false;\n\n        try {\n          for (var b_1 = (e_2 = void 0, tslib_1.__values(b)), b_1_1 = b_1.next(); !b_1_1.done; b_1_1 = b_1.next()) {\n            var itemB = b_1_1.value;\n\n            if (equalityTester(itemA, itemB)) {\n              found = true;\n              break;\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (b_1_1 && !b_1_1.done && (_b = b_1.return)) _b.call(b_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        if (!found) {\n          return false;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return true;\n  }\n\n  exports.isSetEqual = isSetEqual;\n});","map":{"version":3,"sources":["../../../../../../../../../../packages/compiler-cli/src/ngtsc/incremental/semantic_graph/src/util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {SemanticReference, SemanticSymbol} from './api';\n\n/**\n * Determines whether the provided symbols represent the same declaration.\n */\nexport function isSymbolEqual(a: SemanticSymbol, b: SemanticSymbol): boolean {\n  if (a.decl === b.decl) {\n    // If the declaration is identical then it must represent the same symbol.\n    return true;\n  }\n\n  if (a.identifier === null || b.identifier === null) {\n    // Unidentifiable symbols are assumed to be different.\n    return false;\n  }\n\n  return a.path === b.path && a.identifier === b.identifier;\n}\n\n/**\n * Determines whether the provided references to a semantic symbol are still equal, i.e. represent\n * the same symbol and are imported by the same path.\n */\nexport function isReferenceEqual(a: SemanticReference, b: SemanticReference): boolean {\n  if (!isSymbolEqual(a.symbol, b.symbol)) {\n    // If the reference's target symbols are different, the reference itself is different.\n    return false;\n  }\n\n  // The reference still corresponds with the same symbol, now check that the path by which it is\n  // imported has not changed.\n  return a.importPath === b.importPath;\n}\n\nexport function referenceEquality<T>(a: T, b: T): boolean {\n  return a === b;\n}\n\n/**\n * Determines if the provided arrays are equal to each other, using the provided equality tester\n * that is called for all entries in the array.\n */\nexport function isArrayEqual<T>(\n    a: readonly T[]|null, b: readonly T[]|null,\n    equalityTester: (a: T, b: T) => boolean = referenceEquality): boolean {\n  if (a === null || b === null) {\n    return a === b;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return !a.some((item, index) => !equalityTester(item, b[index]));\n}\n\n/**\n * Determines if the provided sets are equal to each other, using the provided equality tester.\n * Sets that only differ in ordering are considered equal.\n */\nexport function isSetEqual<T>(\n    a: ReadonlySet<T>|null, b: ReadonlySet<T>|null,\n    equalityTester: (a: T, b: T) => boolean = referenceEquality): boolean {\n  if (a === null || b === null) {\n    return a === b;\n  }\n\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const itemA of a) {\n    let found = false;\n    for (const itemB of b) {\n      if (equalityTester(itemA, itemB)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}