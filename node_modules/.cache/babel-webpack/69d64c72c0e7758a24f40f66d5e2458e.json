{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/entry_point_finder/entry_point_collector\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/packages/entry_point\", \"@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.EntryPointCollector = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point\");\n\n  var new_entry_point_file_writer_1 = require(\"@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer\");\n  /**\n   * A class that traverses a file-tree, starting at a given path, looking for all entry-points,\n   * also capturing the dependencies of each entry-point that is found.\n   */\n\n\n  var EntryPointCollector =\n  /** @class */\n  function () {\n    function EntryPointCollector(fs, config, logger, resolver) {\n      this.fs = fs;\n      this.config = config;\n      this.logger = logger;\n      this.resolver = resolver;\n    }\n    /**\n     * Look for Angular packages that need to be compiled, starting at the source directory.\n     * The function will recurse into directories that start with `@...`, e.g. `@angular/...`.\n     *\n     * @param sourceDirectory An absolute path to the root directory where searching begins.\n     * @returns an array of `EntryPoint`s that were found within `sourceDirectory`.\n     */\n\n\n    EntryPointCollector.prototype.walkDirectoryForPackages = function (sourceDirectory) {\n      var e_1, _a; // Try to get a primary entry point from this directory\n\n\n      var primaryEntryPoint = entry_point_1.getEntryPointInfo(this.fs, this.config, this.logger, sourceDirectory, sourceDirectory); // If there is an entry-point but it is not compatible with ngcc (it has a bad package.json or\n      // invalid typings) then exit. It is unlikely that such an entry point has a dependency on an\n      // Angular library.\n\n      if (primaryEntryPoint === entry_point_1.INCOMPATIBLE_ENTRY_POINT) {\n        return [];\n      }\n\n      var entryPoints = [];\n\n      if (primaryEntryPoint !== entry_point_1.NO_ENTRY_POINT) {\n        if (primaryEntryPoint !== entry_point_1.IGNORED_ENTRY_POINT) {\n          entryPoints.push(this.resolver.getEntryPointWithDependencies(primaryEntryPoint));\n        }\n\n        this.collectSecondaryEntryPoints(entryPoints, sourceDirectory, sourceDirectory, this.fs.readdir(sourceDirectory)); // Also check for any nested node_modules in this package but only if at least one of the\n        // entry-points was compiled by Angular.\n\n        if (entryPoints.some(function (e) {\n          return e.entryPoint.compiledByAngular;\n        })) {\n          var nestedNodeModulesPath = this.fs.join(sourceDirectory, 'node_modules');\n\n          if (this.fs.exists(nestedNodeModulesPath)) {\n            entryPoints.push.apply(entryPoints, tslib_1.__spread(this.walkDirectoryForPackages(nestedNodeModulesPath)));\n          }\n        }\n\n        return entryPoints;\n      }\n\n      try {\n        // The `sourceDirectory` was not a package (i.e. there was no package.json)\n        // So search its sub-directories for Angular packages and entry-points\n        for (var _b = tslib_1.__values(this.fs.readdir(sourceDirectory)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var path = _c.value;\n\n          if (isIgnorablePath(path)) {\n            // Ignore hidden files, node_modules and ngcc directory\n            continue;\n          }\n\n          var absolutePath = this.fs.resolve(sourceDirectory, path);\n          var stat = this.fs.lstat(absolutePath);\n\n          if (stat.isSymbolicLink() || !stat.isDirectory()) {\n            // Ignore symbolic links and non-directories\n            continue;\n          }\n\n          entryPoints.push.apply(entryPoints, tslib_1.__spread(this.walkDirectoryForPackages(this.fs.join(sourceDirectory, path))));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return entryPoints;\n    };\n    /**\n     * Search the `directory` looking for any secondary entry-points for a package, adding any that\n     * are found to the `entryPoints` array.\n     *\n     * @param entryPoints An array where we will add any entry-points found in this directory.\n     * @param packagePath The absolute path to the package that may contain entry-points.\n     * @param directory The current directory being searched.\n     * @param paths The paths contained in the current `directory`.\n     */\n\n\n    EntryPointCollector.prototype.collectSecondaryEntryPoints = function (entryPoints, packagePath, directory, paths) {\n      var e_2, _a;\n\n      var _this = this;\n\n      var _loop_1 = function _loop_1(path) {\n        if (isIgnorablePath(path)) {\n          return \"continue\";\n        }\n\n        var absolutePath = this_1.fs.resolve(directory, path);\n        var stat = this_1.fs.lstat(absolutePath);\n\n        if (stat.isSymbolicLink()) {\n          return \"continue\";\n        }\n\n        var isDirectory = stat.isDirectory();\n\n        if (!path.endsWith('.js') && !isDirectory) {\n          return \"continue\";\n        } // If the path is a JS file then strip its extension and see if we can match an\n        // entry-point (even if it is an ignored one).\n\n\n        var possibleEntryPointPath = isDirectory ? absolutePath : stripJsExtension(absolutePath);\n        var subEntryPoint = entry_point_1.getEntryPointInfo(this_1.fs, this_1.config, this_1.logger, packagePath, possibleEntryPointPath);\n\n        if (entry_point_1.isEntryPoint(subEntryPoint)) {\n          entryPoints.push(this_1.resolver.getEntryPointWithDependencies(subEntryPoint));\n        }\n\n        if (!isDirectory) {\n          return \"continue\";\n        } // If not an entry-point itself, this directory may contain entry-points of its own.\n\n\n        var canContainEntryPoints = subEntryPoint === entry_point_1.NO_ENTRY_POINT || subEntryPoint === entry_point_1.INCOMPATIBLE_ENTRY_POINT;\n        var childPaths = this_1.fs.readdir(absolutePath);\n\n        if (canContainEntryPoints && childPaths.some(function (childPath) {\n          return childPath.endsWith('.js') && _this.fs.stat(_this.fs.resolve(absolutePath, childPath)).isFile();\n        })) {\n          return \"continue\";\n        }\n\n        this_1.collectSecondaryEntryPoints(entryPoints, packagePath, absolutePath, childPaths);\n      };\n\n      var this_1 = this;\n\n      try {\n        for (var paths_1 = tslib_1.__values(paths), paths_1_1 = paths_1.next(); !paths_1_1.done; paths_1_1 = paths_1.next()) {\n          var path = paths_1_1.value;\n\n          _loop_1(path);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (paths_1_1 && !paths_1_1.done && (_a = paths_1.return)) _a.call(paths_1);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    };\n\n    return EntryPointCollector;\n  }();\n\n  exports.EntryPointCollector = EntryPointCollector;\n\n  function stripJsExtension(filePath) {\n    return filePath.replace(/\\.js$/, '');\n  }\n\n  function isIgnorablePath(path) {\n    return path.startsWith('.') || path === 'node_modules' || path === new_entry_point_file_writer_1.NGCC_DIRECTORY;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/entry_point_finder/entry_point_collector.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, PathSegment, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {EntryPointWithDependencies} from '../dependencies/dependency_host';\nimport {DependencyResolver} from '../dependencies/dependency_resolver';\nimport {NgccConfiguration} from '../packages/configuration';\nimport {getEntryPointInfo, IGNORED_ENTRY_POINT, INCOMPATIBLE_ENTRY_POINT, isEntryPoint, NO_ENTRY_POINT} from '../packages/entry_point';\nimport {NGCC_DIRECTORY} from '../writing/new_entry_point_file_writer';\n\n/**\n * A class that traverses a file-tree, starting at a given path, looking for all entry-points,\n * also capturing the dependencies of each entry-point that is found.\n */\nexport class EntryPointCollector {\n  constructor(\n      private fs: ReadonlyFileSystem, private config: NgccConfiguration, private logger: Logger,\n      private resolver: DependencyResolver) {}\n\n  /**\n   * Look for Angular packages that need to be compiled, starting at the source directory.\n   * The function will recurse into directories that start with `@...`, e.g. `@angular/...`.\n   *\n   * @param sourceDirectory An absolute path to the root directory where searching begins.\n   * @returns an array of `EntryPoint`s that were found within `sourceDirectory`.\n   */\n  walkDirectoryForPackages(sourceDirectory: AbsoluteFsPath): EntryPointWithDependencies[] {\n    // Try to get a primary entry point from this directory\n    const primaryEntryPoint =\n        getEntryPointInfo(this.fs, this.config, this.logger, sourceDirectory, sourceDirectory);\n\n    // If there is an entry-point but it is not compatible with ngcc (it has a bad package.json or\n    // invalid typings) then exit. It is unlikely that such an entry point has a dependency on an\n    // Angular library.\n    if (primaryEntryPoint === INCOMPATIBLE_ENTRY_POINT) {\n      return [];\n    }\n\n    const entryPoints: EntryPointWithDependencies[] = [];\n    if (primaryEntryPoint !== NO_ENTRY_POINT) {\n      if (primaryEntryPoint !== IGNORED_ENTRY_POINT) {\n        entryPoints.push(this.resolver.getEntryPointWithDependencies(primaryEntryPoint));\n      }\n      this.collectSecondaryEntryPoints(\n          entryPoints, sourceDirectory, sourceDirectory, this.fs.readdir(sourceDirectory));\n\n      // Also check for any nested node_modules in this package but only if at least one of the\n      // entry-points was compiled by Angular.\n      if (entryPoints.some(e => e.entryPoint.compiledByAngular)) {\n        const nestedNodeModulesPath = this.fs.join(sourceDirectory, 'node_modules');\n        if (this.fs.exists(nestedNodeModulesPath)) {\n          entryPoints.push(...this.walkDirectoryForPackages(nestedNodeModulesPath));\n        }\n      }\n\n      return entryPoints;\n    }\n\n    // The `sourceDirectory` was not a package (i.e. there was no package.json)\n    // So search its sub-directories for Angular packages and entry-points\n    for (const path of this.fs.readdir(sourceDirectory)) {\n      if (isIgnorablePath(path)) {\n        // Ignore hidden files, node_modules and ngcc directory\n        continue;\n      }\n\n      const absolutePath = this.fs.resolve(sourceDirectory, path);\n      const stat = this.fs.lstat(absolutePath);\n      if (stat.isSymbolicLink() || !stat.isDirectory()) {\n        // Ignore symbolic links and non-directories\n        continue;\n      }\n\n      entryPoints.push(...this.walkDirectoryForPackages(this.fs.join(sourceDirectory, path)));\n    }\n\n    return entryPoints;\n  }\n\n  /**\n   * Search the `directory` looking for any secondary entry-points for a package, adding any that\n   * are found to the `entryPoints` array.\n   *\n   * @param entryPoints An array where we will add any entry-points found in this directory.\n   * @param packagePath The absolute path to the package that may contain entry-points.\n   * @param directory The current directory being searched.\n   * @param paths The paths contained in the current `directory`.\n   */\n  private collectSecondaryEntryPoints(\n      entryPoints: EntryPointWithDependencies[], packagePath: AbsoluteFsPath,\n      directory: AbsoluteFsPath, paths: PathSegment[]): void {\n    for (const path of paths) {\n      if (isIgnorablePath(path)) {\n        // Ignore hidden files, node_modules and ngcc directory\n        continue;\n      }\n\n      const absolutePath = this.fs.resolve(directory, path);\n      const stat = this.fs.lstat(absolutePath);\n      if (stat.isSymbolicLink()) {\n        // Ignore symbolic links\n        continue;\n      }\n\n      const isDirectory = stat.isDirectory();\n      if (!path.endsWith('.js') && !isDirectory) {\n        // Ignore files that do not end in `.js`\n        continue;\n      }\n\n      // If the path is a JS file then strip its extension and see if we can match an\n      // entry-point (even if it is an ignored one).\n      const possibleEntryPointPath = isDirectory ? absolutePath : stripJsExtension(absolutePath);\n      const subEntryPoint =\n          getEntryPointInfo(this.fs, this.config, this.logger, packagePath, possibleEntryPointPath);\n      if (isEntryPoint(subEntryPoint)) {\n        entryPoints.push(this.resolver.getEntryPointWithDependencies(subEntryPoint));\n      }\n\n      if (!isDirectory) {\n        // This path is not a directory so we are done.\n        continue;\n      }\n\n      // If not an entry-point itself, this directory may contain entry-points of its own.\n      const canContainEntryPoints =\n          subEntryPoint === NO_ENTRY_POINT || subEntryPoint === INCOMPATIBLE_ENTRY_POINT;\n      const childPaths = this.fs.readdir(absolutePath);\n      if (canContainEntryPoints &&\n          childPaths.some(\n              childPath => childPath.endsWith('.js') &&\n                  this.fs.stat(this.fs.resolve(absolutePath, childPath)).isFile())) {\n        // We do not consider non-entry-point directories that contain JS files as they are very\n        // unlikely to be containers for sub-entry-points.\n        continue;\n      }\n      this.collectSecondaryEntryPoints(entryPoints, packagePath, absolutePath, childPaths);\n    }\n  }\n}\n\nfunction stripJsExtension<T extends string>(filePath: T): T {\n  return filePath.replace(/\\.js$/, '') as T;\n}\n\nfunction isIgnorablePath(path: PathSegment): boolean {\n  return path.startsWith('.') || path === 'node_modules' || path === NGCC_DIRECTORY;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}