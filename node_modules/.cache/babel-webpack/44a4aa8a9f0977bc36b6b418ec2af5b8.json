{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/entry_point/src/reference_graph\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ReferenceGraph = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ReferenceGraph =\n  /** @class */\n  function () {\n    function ReferenceGraph() {\n      this.references = new Map();\n    }\n\n    ReferenceGraph.prototype.add = function (from, to) {\n      if (!this.references.has(from)) {\n        this.references.set(from, new Set());\n      }\n\n      this.references.get(from).add(to);\n    };\n\n    ReferenceGraph.prototype.transitiveReferencesOf = function (target) {\n      var set = new Set();\n      this.collectTransitiveReferences(set, target);\n      return set;\n    };\n\n    ReferenceGraph.prototype.pathFrom = function (source, target) {\n      return this.collectPathFrom(source, target, new Set());\n    };\n\n    ReferenceGraph.prototype.collectPathFrom = function (source, target, seen) {\n      var _this = this;\n\n      if (source === target) {\n        // Looking for a path from the target to itself - that path is just the target. This is the\n        // \"base case\" of the search.\n        return [target];\n      } else if (seen.has(source)) {\n        // The search has already looked through this source before.\n        return null;\n      } // Consider outgoing edges from `source`.\n\n\n      seen.add(source);\n\n      if (!this.references.has(source)) {\n        // There are no outgoing edges from `source`.\n        return null;\n      } else {\n        // Look through the outgoing edges of `source`.\n        // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n        var candidatePath_1 = null;\n        this.references.get(source).forEach(function (edge) {\n          // Early exit if a path has already been found.\n          if (candidatePath_1 !== null) {\n            return;\n          } // Look for a path from this outgoing edge to `target`.\n\n\n          var partialPath = _this.collectPathFrom(edge, target, seen);\n\n          if (partialPath !== null) {\n            // A path exists from `edge` to `target`. Insert `source` at the beginning.\n            candidatePath_1 = tslib_1.__spread([source], partialPath);\n          }\n        });\n        return candidatePath_1;\n      }\n    };\n\n    ReferenceGraph.prototype.collectTransitiveReferences = function (set, decl) {\n      var _this = this;\n\n      if (this.references.has(decl)) {\n        // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n        this.references.get(decl).forEach(function (ref) {\n          if (!set.has(ref)) {\n            set.add(ref);\n\n            _this.collectTransitiveReferences(set, ref);\n          }\n        });\n      }\n    };\n\n    return ReferenceGraph;\n  }();\n\n  exports.ReferenceGraph = ReferenceGraph;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/entry_point/src/reference_graph.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAIH,MAAA,cAAA;AAAA;AAAA,cAAA;AAAA,aAAA,cAAA,GAAA;AACU,WAAA,UAAA,GAAa,IAAI,GAAJ,EAAb;AAkET;;AAhEC,IAAA,cAAA,CAAA,SAAA,CAAA,GAAA,GAAA,UAAI,IAAJ,EAAa,EAAb,EAAkB;AAChB,UAAI,CAAC,KAAK,UAAL,CAAgB,GAAhB,CAAoB,IAApB,CAAL,EAAgC;AAC9B,aAAK,UAAL,CAAgB,GAAhB,CAAoB,IAApB,EAA0B,IAAI,GAAJ,EAA1B;AACD;;AACD,WAAK,UAAL,CAAgB,GAAhB,CAAoB,IAApB,EAA2B,GAA3B,CAA+B,EAA/B;AACD,KALD;;AAOA,IAAA,cAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UAAuB,MAAvB,EAAgC;AAC9B,UAAM,GAAG,GAAG,IAAI,GAAJ,EAAZ;AACA,WAAK,2BAAL,CAAiC,GAAjC,EAAsC,MAAtC;AACA,aAAO,GAAP;AACD,KAJD;;AAMA,IAAA,cAAA,CAAA,SAAA,CAAA,QAAA,GAAA,UAAS,MAAT,EAAoB,MAApB,EAA6B;AAC3B,aAAO,KAAK,eAAL,CAAqB,MAArB,EAA6B,MAA7B,EAAqC,IAAI,GAAJ,EAArC,CAAP;AACD,KAFD;;AAIQ,IAAA,cAAA,CAAA,SAAA,CAAA,eAAA,GAAR,UAAwB,MAAxB,EAAmC,MAAnC,EAA8C,IAA9C,EAA0D;AAA1D,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,MAAM,KAAK,MAAf,EAAuB;AACrB;AACA;AACA,eAAO,CAAC,MAAD,CAAP;AACD,OAJD,MAIO,IAAI,IAAI,CAAC,GAAL,CAAS,MAAT,CAAJ,EAAsB;AAC3B;AACA,eAAO,IAAP;AACD,OARuD,CASxD;;;AACA,MAAA,IAAI,CAAC,GAAL,CAAS,MAAT;;AAEA,UAAI,CAAC,KAAK,UAAL,CAAgB,GAAhB,CAAoB,MAApB,CAAL,EAAkC;AAChC;AACA,eAAO,IAAP;AACD,OAHD,MAGO;AACL;AACA;AACA,YAAI,eAAa,GAAa,IAA9B;AACA,aAAK,UAAL,CAAgB,GAAhB,CAAoB,MAApB,EAA6B,OAA7B,CAAqC,UAAA,IAAA,EAAI;AACvC;AACA,cAAI,eAAa,KAAK,IAAtB,EAA4B;AAC1B;AACD,WAJsC,CAKvC;;;AACA,cAAM,WAAW,GAAG,KAAI,CAAC,eAAL,CAAqB,IAArB,EAA2B,MAA3B,EAAmC,IAAnC,CAApB;;AACA,cAAI,WAAW,KAAK,IAApB,EAA0B;AACxB;AACA,YAAA,eAAa,GAAA,OAAA,CAAA,QAAA,CAAA,CAAI,MAAJ,CAAA,EAAe,WAAf,CAAb;AACD;AACF,SAXD;AAaA,eAAO,eAAP;AACD;AACF,KAlCO;;AAoCA,IAAA,cAAA,CAAA,SAAA,CAAA,2BAAA,GAAR,UAAoC,GAApC,EAAiD,IAAjD,EAAwD;AAAxD,UAAA,KAAA,GAAA,IAAA;;AACE,UAAI,KAAK,UAAL,CAAgB,GAAhB,CAAoB,IAApB,CAAJ,EAA+B;AAC7B;AACA,aAAK,UAAL,CAAgB,GAAhB,CAAoB,IAApB,EAA2B,OAA3B,CAAmC,UAAA,GAAA,EAAG;AACpC,cAAI,CAAC,GAAG,CAAC,GAAJ,CAAQ,GAAR,CAAL,EAAmB;AACjB,YAAA,GAAG,CAAC,GAAJ,CAAQ,GAAR;;AACA,YAAA,KAAI,CAAC,2BAAL,CAAiC,GAAjC,EAAsC,GAAtC;AACD;AACF,SALD;AAMD;AACF,KAVO;;AAWV,WAAA,cAAA;AAAC,GAnED,EAAA;;AAAa,EAAA,OAAA,CAAA,cAAA,GAAA,cAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DeclarationNode} from '../../reflection';\n\nexport class ReferenceGraph<T = DeclarationNode> {\n  private references = new Map<T, Set<T>>();\n\n  add(from: T, to: T): void {\n    if (!this.references.has(from)) {\n      this.references.set(from, new Set());\n    }\n    this.references.get(from)!.add(to);\n  }\n\n  transitiveReferencesOf(target: T): Set<T> {\n    const set = new Set<T>();\n    this.collectTransitiveReferences(set, target);\n    return set;\n  }\n\n  pathFrom(source: T, target: T): T[]|null {\n    return this.collectPathFrom(source, target, new Set());\n  }\n\n  private collectPathFrom(source: T, target: T, seen: Set<T>): T[]|null {\n    if (source === target) {\n      // Looking for a path from the target to itself - that path is just the target. This is the\n      // \"base case\" of the search.\n      return [target];\n    } else if (seen.has(source)) {\n      // The search has already looked through this source before.\n      return null;\n    }\n    // Consider outgoing edges from `source`.\n    seen.add(source);\n\n    if (!this.references.has(source)) {\n      // There are no outgoing edges from `source`.\n      return null;\n    } else {\n      // Look through the outgoing edges of `source`.\n      // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n      let candidatePath: T[]|null = null;\n      this.references.get(source)!.forEach(edge => {\n        // Early exit if a path has already been found.\n        if (candidatePath !== null) {\n          return;\n        }\n        // Look for a path from this outgoing edge to `target`.\n        const partialPath = this.collectPathFrom(edge, target, seen);\n        if (partialPath !== null) {\n          // A path exists from `edge` to `target`. Insert `source` at the beginning.\n          candidatePath = [source, ...partialPath];\n        }\n      });\n\n      return candidatePath;\n    }\n  }\n\n  private collectTransitiveReferences(set: Set<T>, decl: T): void {\n    if (this.references.has(decl)) {\n      // TODO(alxhub): use proper iteration when the legacy build is removed. (#27762)\n      this.references.get(decl)!.forEach(ref => {\n        if (!set.has(ref)) {\n          set.add(ref);\n          this.collectTransitiveReferences(set, ref);\n        }\n      });\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}