{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nfunction startsWith(string, searchString) {\n  var stringLength = string.length;\n  var searchLength = searchString.length; // early out if the search length is greater than the search string\n\n  if (searchLength > stringLength) {\n    return false;\n  }\n\n  var index = -1;\n\n  while (++index < searchLength) {\n    if (string.charCodeAt(index) !== searchString.charCodeAt(index)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nmodule.exports = /*#__PURE__*/function () {\n  function AliasPlugin(source, options, target) {\n    _classCallCheck(this, AliasPlugin);\n\n    this.source = source;\n    this.options = Array.isArray(options) ? options : [options];\n    this.target = target;\n  }\n\n  _createClass(AliasPlugin, [{\n    key: \"apply\",\n    value: function apply(resolver) {\n      var _this = this;\n\n      var target = resolver.ensureHook(this.target);\n      resolver.getHook(this.source).tapAsync(\"AliasPlugin\", function (request, resolveContext, callback) {\n        var innerRequest = request.request || request.path;\n        if (!innerRequest) return callback();\n\n        var _iterator = _createForOfIteratorHelper(_this.options),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var item = _step.value;\n\n            if (innerRequest === item.name || !item.onlyModule && startsWith(innerRequest, item.name + \"/\")) {\n              if (innerRequest !== item.alias && !startsWith(innerRequest, item.alias + \"/\")) {\n                var newRequestStr = item.alias + innerRequest.substr(item.name.length);\n                var obj = Object.assign({}, request, {\n                  request: newRequestStr\n                });\n                return resolver.doResolve(target, obj, \"aliased with mapping '\" + item.name + \"': '\" + item.alias + \"' to '\" + newRequestStr + \"'\", resolveContext, function (err, result) {\n                  if (err) return callback(err); // Don't allow other aliasing or raw request\n\n                  if (result === undefined) return callback(null, null);\n                  callback(null, result);\n                });\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return callback();\n      });\n    }\n  }]);\n\n  return AliasPlugin;\n}();","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/node_modules/enhanced-resolve/lib/AliasPlugin.js"],"names":["startsWith","string","searchString","stringLength","length","searchLength","index","charCodeAt","module","exports","source","options","target","Array","isArray","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","innerRequest","path","item","name","onlyModule","alias","newRequestStr","substr","obj","Object","assign","doResolve","err","result","undefined"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction startsWith(string, searchString) {\n\tconst stringLength = string.length;\n\tconst searchLength = searchString.length;\n\n\t// early out if the search length is greater than the search string\n\tif (searchLength > stringLength) {\n\t\treturn false;\n\t}\n\tlet index = -1;\n\twhile (++index < searchLength) {\n\t\tif (string.charCodeAt(index) !== searchString.charCodeAt(index)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nmodule.exports = class AliasPlugin {\n\tconstructor(source, options, target) {\n\t\tthis.source = source;\n\t\tthis.options = Array.isArray(options) ? options : [options];\n\t\tthis.target = target;\n\t}\n\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"AliasPlugin\", (request, resolveContext, callback) => {\n\t\t\t\tconst innerRequest = request.request || request.path;\n\t\t\t\tif (!innerRequest) return callback();\n\t\t\t\tfor (const item of this.options) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tinnerRequest === item.name ||\n\t\t\t\t\t\t(!item.onlyModule && startsWith(innerRequest, item.name + \"/\"))\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tinnerRequest !== item.alias &&\n\t\t\t\t\t\t\t!startsWith(innerRequest, item.alias + \"/\")\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst newRequestStr =\n\t\t\t\t\t\t\t\titem.alias + innerRequest.substr(item.name.length);\n\t\t\t\t\t\t\tconst obj = Object.assign({}, request, {\n\t\t\t\t\t\t\t\trequest: newRequestStr\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn resolver.doResolve(\n\t\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\t\"aliased with mapping '\" +\n\t\t\t\t\t\t\t\t\titem.name +\n\t\t\t\t\t\t\t\t\t\"': '\" +\n\t\t\t\t\t\t\t\t\titem.alias +\n\t\t\t\t\t\t\t\t\t\"' to '\" +\n\t\t\t\t\t\t\t\t\tnewRequestStr +\n\t\t\t\t\t\t\t\t\t\"'\",\n\t\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\t// Don't allow other aliasing or raw request\n\t\t\t\t\t\t\t\t\tif (result === undefined) return callback(null, null);\n\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn callback();\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}