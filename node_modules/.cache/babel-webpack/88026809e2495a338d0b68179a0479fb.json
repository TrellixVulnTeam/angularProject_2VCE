{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findTopLevelFunctions = exports.getPrefixFunctionsTransformer = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ts = require(\"typescript\");\n\nvar ast_utils_1 = require(\"../helpers/ast-utils\");\n\nfunction getPrefixFunctionsTransformer() {\n  return function (context) {\n    var transformer = function transformer(sf) {\n      var topLevelFunctions = findTopLevelFunctions(sf);\n\n      var visitor = function visitor(node) {\n        // Add pure function comment to top level functions.\n        if (topLevelFunctions.has(node)) {\n          var newNode = ast_utils_1.addPureComment(node); // Replace node with modified one.\n\n          return ts.visitEachChild(newNode, visitor, context);\n        } // Otherwise return node as is.\n\n\n        return ts.visitEachChild(node, visitor, context);\n      };\n\n      return ts.visitNode(sf, visitor);\n    };\n\n    return transformer;\n  };\n}\n\nexports.getPrefixFunctionsTransformer = getPrefixFunctionsTransformer;\n\nfunction findTopLevelFunctions(parentNode) {\n  var topLevelFunctions = new Set();\n\n  function cb(node) {\n    // Stop recursing into this branch if it's a definition construct.\n    // These are function expression, function declaration, class, or arrow function (lambda).\n    // The body of these constructs will not execute when loading the module, so we don't\n    // need to mark function calls inside them as pure.\n    // Class static initializers in ES2015 are an exception we don't cover. They would need similar\n    // processing as enums to prevent property setting from causing the class to be retained.\n    if (ts.isFunctionLike(node) || ts.isClassLike(node) || ts.isArrowFunction(node) || ts.isMethodDeclaration(node)) {\n      return;\n    }\n\n    var noPureComment = !ast_utils_1.hasPureComment(node);\n    var innerNode = node;\n\n    while (innerNode && ts.isParenthesizedExpression(innerNode)) {\n      innerNode = innerNode.expression;\n      noPureComment = noPureComment && !ast_utils_1.hasPureComment(innerNode);\n    }\n\n    if (!innerNode) {\n      return;\n    }\n\n    if ((ts.isFunctionExpression(innerNode) || ts.isArrowFunction(innerNode)) && ts.isParenthesizedExpression(node)) {\n      // pure functions can be wrapped in parentizes\n      // we should not add pure comments to this sort of syntax.\n      // example var foo = (() => x)\n      return;\n    }\n\n    if (noPureComment) {\n      if (ts.isNewExpression(innerNode)) {\n        topLevelFunctions.add(node);\n      } else if (ts.isCallExpression(innerNode)) {\n        var expression = innerNode.expression;\n\n        if (ts.isIdentifier(expression) && ast_utils_1.getCleanHelperName(expression.text)) {\n          return;\n        }\n\n        while (expression && ts.isParenthesizedExpression(expression)) {\n          expression = expression.expression;\n        }\n\n        if (expression) {\n          if (ts.isFunctionExpression(expression)) {\n            // Skip IIFE's with arguments\n            // This could be improved to check if there are any references to variables\n            if (innerNode.arguments.length === 0) {\n              topLevelFunctions.add(node);\n            }\n          } else {\n            topLevelFunctions.add(node);\n          }\n        }\n      }\n    }\n\n    ts.forEachChild(innerNode, cb);\n  }\n\n  ts.forEachChild(parentNode, cb);\n  return topLevelFunctions;\n}\n\nexports.findTopLevelFunctions = findTopLevelFunctions;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-optimizer/src/transforms/prefix-functions.js"],"names":["Object","defineProperty","exports","value","findTopLevelFunctions","getPrefixFunctionsTransformer","ts","require","ast_utils_1","context","transformer","sf","topLevelFunctions","visitor","node","has","newNode","addPureComment","visitEachChild","visitNode","parentNode","Set","cb","isFunctionLike","isClassLike","isArrowFunction","isMethodDeclaration","noPureComment","hasPureComment","innerNode","isParenthesizedExpression","expression","isFunctionExpression","isNewExpression","add","isCallExpression","isIdentifier","getCleanHelperName","text","arguments","length","forEachChild"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findTopLevelFunctions = exports.getPrefixFunctionsTransformer = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ts = require(\"typescript\");\nconst ast_utils_1 = require(\"../helpers/ast-utils\");\nfunction getPrefixFunctionsTransformer() {\n    return (context) => {\n        const transformer = (sf) => {\n            const topLevelFunctions = findTopLevelFunctions(sf);\n            const visitor = (node) => {\n                // Add pure function comment to top level functions.\n                if (topLevelFunctions.has(node)) {\n                    const newNode = ast_utils_1.addPureComment(node);\n                    // Replace node with modified one.\n                    return ts.visitEachChild(newNode, visitor, context);\n                }\n                // Otherwise return node as is.\n                return ts.visitEachChild(node, visitor, context);\n            };\n            return ts.visitNode(sf, visitor);\n        };\n        return transformer;\n    };\n}\nexports.getPrefixFunctionsTransformer = getPrefixFunctionsTransformer;\nfunction findTopLevelFunctions(parentNode) {\n    const topLevelFunctions = new Set();\n    function cb(node) {\n        // Stop recursing into this branch if it's a definition construct.\n        // These are function expression, function declaration, class, or arrow function (lambda).\n        // The body of these constructs will not execute when loading the module, so we don't\n        // need to mark function calls inside them as pure.\n        // Class static initializers in ES2015 are an exception we don't cover. They would need similar\n        // processing as enums to prevent property setting from causing the class to be retained.\n        if (ts.isFunctionLike(node)\n            || ts.isClassLike(node)\n            || ts.isArrowFunction(node)\n            || ts.isMethodDeclaration(node)) {\n            return;\n        }\n        let noPureComment = !ast_utils_1.hasPureComment(node);\n        let innerNode = node;\n        while (innerNode && ts.isParenthesizedExpression(innerNode)) {\n            innerNode = innerNode.expression;\n            noPureComment = noPureComment && !ast_utils_1.hasPureComment(innerNode);\n        }\n        if (!innerNode) {\n            return;\n        }\n        if ((ts.isFunctionExpression(innerNode) || ts.isArrowFunction(innerNode))\n            && ts.isParenthesizedExpression(node)) {\n            // pure functions can be wrapped in parentizes\n            // we should not add pure comments to this sort of syntax.\n            // example var foo = (() => x)\n            return;\n        }\n        if (noPureComment) {\n            if (ts.isNewExpression(innerNode)) {\n                topLevelFunctions.add(node);\n            }\n            else if (ts.isCallExpression(innerNode)) {\n                let expression = innerNode.expression;\n                if (ts.isIdentifier(expression) && ast_utils_1.getCleanHelperName(expression.text)) {\n                    return;\n                }\n                while (expression && ts.isParenthesizedExpression(expression)) {\n                    expression = expression.expression;\n                }\n                if (expression) {\n                    if (ts.isFunctionExpression(expression)) {\n                        // Skip IIFE's with arguments\n                        // This could be improved to check if there are any references to variables\n                        if (innerNode.arguments.length === 0) {\n                            topLevelFunctions.add(node);\n                        }\n                    }\n                    else {\n                        topLevelFunctions.add(node);\n                    }\n                }\n            }\n        }\n        ts.forEachChild(innerNode, cb);\n    }\n    ts.forEachChild(parentNode, cb);\n    return topLevelFunctions;\n}\nexports.findTopLevelFunctions = findTopLevelFunctions;\n"]},"metadata":{},"sourceType":"script"}