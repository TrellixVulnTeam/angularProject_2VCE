{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/build_marker\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.markAsProcessed = exports.hasBeenProcessed = exports.cleanPackageJson = exports.needsCleaning = exports.NGCC_VERSION = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var new_entry_point_file_writer_1 = require(\"@angular/compiler-cli/ngcc/src/writing/new_entry_point_file_writer\");\n\n  exports.NGCC_VERSION = '11.2.14';\n  /**\n   * Returns true if there is a format in this entry-point that was compiled with an outdated version\n   * of ngcc.\n   *\n   * @param packageJson The parsed contents of the package.json for the entry-point\n   */\n\n  function needsCleaning(packageJson) {\n    return Object.values(packageJson.__processed_by_ivy_ngcc__ || {}).some(function (value) {\n      return value !== exports.NGCC_VERSION;\n    });\n  }\n\n  exports.needsCleaning = needsCleaning;\n  /**\n   * Clean any build marker artifacts from the given `packageJson` object.\n   * @param packageJson The parsed contents of the package.json to modify\n   * @returns true if the package was modified during cleaning\n   */\n\n  function cleanPackageJson(packageJson) {\n    var e_1, _a;\n\n    if (packageJson.__processed_by_ivy_ngcc__ !== undefined) {\n      // Remove the actual marker\n      delete packageJson.__processed_by_ivy_ngcc__;\n\n      try {\n        // Remove new format properties that have been added by ngcc\n        for (var _b = tslib_1.__values(Object.keys(packageJson)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var prop = _c.value;\n\n          if (prop.endsWith(new_entry_point_file_writer_1.NGCC_PROPERTY_EXTENSION)) {\n            delete packageJson[prop];\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Also remove the prebulish script if we modified it\n\n\n      var scripts = packageJson.scripts;\n\n      if (scripts !== undefined && scripts.prepublishOnly) {\n        delete scripts.prepublishOnly;\n\n        if (scripts.prepublishOnly__ivy_ngcc_bak !== undefined) {\n          scripts.prepublishOnly = scripts.prepublishOnly__ivy_ngcc_bak;\n          delete scripts.prepublishOnly__ivy_ngcc_bak;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  exports.cleanPackageJson = cleanPackageJson;\n  /**\n   * Check whether ngcc has already processed a given entry-point format.\n   *\n   * @param packageJson The parsed contents of the package.json file for the entry-point.\n   * @param format The entry-point format property in the package.json to check.\n   * @returns true if the `format` in the entry-point has already been processed by this ngcc version,\n   * false otherwise.\n   */\n\n  function hasBeenProcessed(packageJson, format) {\n    return packageJson.__processed_by_ivy_ngcc__ !== undefined && packageJson.__processed_by_ivy_ngcc__[format] === exports.NGCC_VERSION;\n  }\n\n  exports.hasBeenProcessed = hasBeenProcessed;\n  /**\n   * Write a build marker for the given entry-point and format properties, to indicate that they have\n   * been compiled by this version of ngcc.\n   *\n   * @param pkgJsonUpdater The writer to use for updating `package.json`.\n   * @param packageJson The parsed contents of the `package.json` file for the entry-point.\n   * @param packageJsonPath The absolute path to the `package.json` file.\n   * @param properties The properties in the `package.json` of the formats for which we are writing\n   *                   the marker.\n   */\n\n  function markAsProcessed(pkgJsonUpdater, packageJson, packageJsonPath, formatProperties) {\n    var e_2, _a;\n\n    var update = pkgJsonUpdater.createUpdate();\n\n    try {\n      // Update the format properties to mark them as processed.\n      for (var formatProperties_1 = tslib_1.__values(formatProperties), formatProperties_1_1 = formatProperties_1.next(); !formatProperties_1_1.done; formatProperties_1_1 = formatProperties_1.next()) {\n        var prop = formatProperties_1_1.value;\n        update.addChange(['__processed_by_ivy_ngcc__', prop], exports.NGCC_VERSION, 'alphabetic');\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (formatProperties_1_1 && !formatProperties_1_1.done && (_a = formatProperties_1.return)) _a.call(formatProperties_1);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    } // Update the `prepublishOnly` script (keeping a backup, if necessary) to prevent `ngcc`'d\n    // packages from getting accidentally published.\n\n\n    var oldPrepublishOnly = packageJson.scripts && packageJson.scripts.prepublishOnly;\n    var newPrepublishOnly = 'node --eval \\\"console.error(\\'' + 'ERROR: Trying to publish a package that has been compiled by NGCC. This is not allowed.\\\\n' + 'Please delete and rebuild the package, without compiling with NGCC, before attempting to publish.\\\\n' + 'Note that NGCC may have been run by importing this package into another project that is being built with Ivy enabled.\\\\n' + '\\')\\\" ' + '&& exit 1';\n\n    if (oldPrepublishOnly && oldPrepublishOnly !== newPrepublishOnly) {\n      update.addChange(['scripts', 'prepublishOnly__ivy_ngcc_bak'], oldPrepublishOnly);\n    }\n\n    update.addChange(['scripts', 'prepublishOnly'], newPrepublishOnly);\n    update.writeChanges(packageJsonPath, packageJson);\n  }\n\n  exports.markAsProcessed = markAsProcessed;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/build_marker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath} from '../../../src/ngtsc/file_system';\nimport {NGCC_PROPERTY_EXTENSION} from '../writing/new_entry_point_file_writer';\nimport {PackageJsonUpdater} from '../writing/package_json_updater';\nimport {EntryPointPackageJson, PackageJsonFormatProperties} from './entry_point';\n\nexport const NGCC_VERSION = '0.0.0-PLACEHOLDER';\n\n/**\n * Returns true if there is a format in this entry-point that was compiled with an outdated version\n * of ngcc.\n *\n * @param packageJson The parsed contents of the package.json for the entry-point\n */\nexport function needsCleaning(packageJson: EntryPointPackageJson): boolean {\n  return Object.values(packageJson.__processed_by_ivy_ngcc__ || {})\n      .some(value => value !== NGCC_VERSION);\n}\n\n/**\n * Clean any build marker artifacts from the given `packageJson` object.\n * @param packageJson The parsed contents of the package.json to modify\n * @returns true if the package was modified during cleaning\n */\nexport function cleanPackageJson(packageJson: EntryPointPackageJson): boolean {\n  if (packageJson.__processed_by_ivy_ngcc__ !== undefined) {\n    // Remove the actual marker\n    delete packageJson.__processed_by_ivy_ngcc__;\n    // Remove new format properties that have been added by ngcc\n    for (const prop of Object.keys(packageJson)) {\n      if (prop.endsWith(NGCC_PROPERTY_EXTENSION)) {\n        delete packageJson[prop];\n      }\n    }\n\n    // Also remove the prebulish script if we modified it\n    const scripts = packageJson.scripts;\n    if (scripts !== undefined && scripts.prepublishOnly) {\n      delete scripts.prepublishOnly;\n      if (scripts.prepublishOnly__ivy_ngcc_bak !== undefined) {\n        scripts.prepublishOnly = scripts.prepublishOnly__ivy_ngcc_bak;\n        delete scripts.prepublishOnly__ivy_ngcc_bak;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\n/**\n * Check whether ngcc has already processed a given entry-point format.\n *\n * @param packageJson The parsed contents of the package.json file for the entry-point.\n * @param format The entry-point format property in the package.json to check.\n * @returns true if the `format` in the entry-point has already been processed by this ngcc version,\n * false otherwise.\n */\nexport function hasBeenProcessed(\n    packageJson: EntryPointPackageJson, format: PackageJsonFormatProperties): boolean {\n  return packageJson.__processed_by_ivy_ngcc__ !== undefined &&\n      packageJson.__processed_by_ivy_ngcc__[format] === NGCC_VERSION;\n}\n\n/**\n * Write a build marker for the given entry-point and format properties, to indicate that they have\n * been compiled by this version of ngcc.\n *\n * @param pkgJsonUpdater The writer to use for updating `package.json`.\n * @param packageJson The parsed contents of the `package.json` file for the entry-point.\n * @param packageJsonPath The absolute path to the `package.json` file.\n * @param properties The properties in the `package.json` of the formats for which we are writing\n *                   the marker.\n */\nexport function markAsProcessed(\n    pkgJsonUpdater: PackageJsonUpdater, packageJson: EntryPointPackageJson,\n    packageJsonPath: AbsoluteFsPath, formatProperties: PackageJsonFormatProperties[]): void {\n  const update = pkgJsonUpdater.createUpdate();\n\n  // Update the format properties to mark them as processed.\n  for (const prop of formatProperties) {\n    update.addChange(['__processed_by_ivy_ngcc__', prop], NGCC_VERSION, 'alphabetic');\n  }\n\n  // Update the `prepublishOnly` script (keeping a backup, if necessary) to prevent `ngcc`'d\n  // packages from getting accidentally published.\n  const oldPrepublishOnly = packageJson.scripts && packageJson.scripts.prepublishOnly;\n  const newPrepublishOnly = 'node --eval \\\"console.error(\\'' +\n      'ERROR: Trying to publish a package that has been compiled by NGCC. This is not allowed.\\\\n' +\n      'Please delete and rebuild the package, without compiling with NGCC, before attempting to publish.\\\\n' +\n      'Note that NGCC may have been run by importing this package into another project that is being built with Ivy enabled.\\\\n' +\n      '\\')\\\" ' +\n      '&& exit 1';\n\n  if (oldPrepublishOnly && (oldPrepublishOnly !== newPrepublishOnly)) {\n    update.addChange(['scripts', 'prepublishOnly__ivy_ngcc_bak'], oldPrepublishOnly);\n  }\n\n  update.addChange(['scripts', 'prepublishOnly'], newPrepublishOnly);\n\n  update.writeChanges(packageJsonPath, packageJson);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}