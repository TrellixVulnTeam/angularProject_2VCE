{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\"use strict\";\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar path = require(\"path\");\n\nvar DescriptionFileUtils = require(\"./DescriptionFileUtils\");\n\nvar forEachBail = require(\"./forEachBail\");\n\nvar _require = require(\"./util/entrypoints\"),\n    processExportsField = _require.processExportsField;\n\nvar _require2 = require(\"./util/identifier\"),\n    parseIdentifier = _require2.parseIdentifier;\n\nvar _require3 = require(\"./util/path\"),\n    checkExportsFieldTarget = _require3.checkExportsFieldTarget;\n/** @typedef {import(\"./Resolver\")} Resolver */\n\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\n\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * @param {string | ResolveStepHook} source source\n   * @param {Set<string>} conditionNames condition names\n   * @param {string | string[]} fieldNamePath name path\n   * @param {string | ResolveStepHook} target target\n   */\n  function ExportsFieldPlugin(source, conditionNames, fieldNamePath, target) {\n    _classCallCheck(this, ExportsFieldPlugin);\n\n    this.source = source;\n    this.target = target;\n    this.conditionNames = conditionNames;\n    this.fieldName = fieldNamePath;\n    /** @type {WeakMap<any, FieldProcessor>} */\n\n    this.fieldProcessorCache = new WeakMap();\n  }\n  /**\n   * @param {Resolver} resolver the resolver\n   * @returns {void}\n   */\n\n\n  _createClass(ExportsFieldPlugin, [{\n    key: \"apply\",\n    value: function apply(resolver) {\n      var _this = this;\n\n      var target = resolver.ensureHook(this.target);\n      resolver.getHook(this.source).tapAsync(\"ExportsFieldPlugin\", function (request, resolveContext, callback) {\n        // When there is no description file, abort\n        if (!request.descriptionFilePath) return callback();\n        if ( // When the description file is inherited from parent, abort\n        // (There is no description file inside of this package)\n        request.relativePath !== \".\" || request.request === undefined) return callback();\n        var remainingRequest = request.query || request.fragment ? (request.request === \".\" ? \"./\" : request.request) + request.query + request.fragment : request.request;\n        /** @type {ExportsField|null} */\n\n        var exportsField = DescriptionFileUtils.getField(request.descriptionFileData, _this.fieldName);\n        if (!exportsField) return callback();\n\n        if (request.directory) {\n          return callback(new Error(\"Resolving to directories is not possible with the exports field (request was \".concat(remainingRequest, \"/)\")));\n        }\n\n        var paths;\n\n        try {\n          // We attach the cache to the description file instead of the exportsField value\n          // because we use a WeakMap and the exportsField could be a string too.\n          // Description file is always an object when exports field can be accessed.\n          var fieldProcessor = _this.fieldProcessorCache.get(request.descriptionFileData);\n\n          if (fieldProcessor === undefined) {\n            fieldProcessor = processExportsField(exportsField);\n\n            _this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);\n          }\n\n          paths = fieldProcessor(remainingRequest, _this.conditionNames);\n        } catch (err) {\n          if (resolveContext.log) {\n            resolveContext.log(\"Exports field in \".concat(request.descriptionFilePath, \" can't be processed: \").concat(err));\n          }\n\n          return callback(err);\n        }\n\n        if (paths.length === 0) {\n          return callback(new Error(\"Package path \".concat(remainingRequest, \" is not exported from package \").concat(request.descriptionFileRoot, \" (see exports field in \").concat(request.descriptionFilePath, \")\")));\n        }\n\n        forEachBail(paths, function (p, callback) {\n          var parsedIdentifier = parseIdentifier(p);\n          if (!parsedIdentifier) return callback();\n\n          var _parsedIdentifier = _slicedToArray(parsedIdentifier, 3),\n              relativePath = _parsedIdentifier[0],\n              query = _parsedIdentifier[1],\n              fragment = _parsedIdentifier[2];\n\n          var error = checkExportsFieldTarget(relativePath);\n\n          if (error) {\n            return callback(error);\n          }\n\n          var obj = _objectSpread(_objectSpread({}, request), {}, {\n            request: undefined,\n            path: path.join(\n            /** @type {string} */\n            request.descriptionFileRoot, relativePath),\n            relativePath: relativePath,\n            query: query,\n            fragment: fragment\n          });\n\n          resolver.doResolve(target, obj, \"using exports field: \" + p, resolveContext, callback);\n        }, function (err, result) {\n          return callback(err, result || null);\n        });\n      });\n    }\n  }]);\n\n  return ExportsFieldPlugin;\n}();","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js"],"names":["path","require","DescriptionFileUtils","forEachBail","processExportsField","parseIdentifier","checkExportsFieldTarget","module","exports","source","conditionNames","fieldNamePath","target","fieldName","fieldProcessorCache","WeakMap","resolver","ensureHook","getHook","tapAsync","request","resolveContext","callback","descriptionFilePath","relativePath","undefined","remainingRequest","query","fragment","exportsField","getField","descriptionFileData","directory","Error","paths","fieldProcessor","get","set","err","log","length","descriptionFileRoot","p","parsedIdentifier","error","obj","join","doResolve","result"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Ivan Kopeykin @vankop\n*/\n\n\"use strict\";\n\nconst path = require(\"path\");\nconst DescriptionFileUtils = require(\"./DescriptionFileUtils\");\nconst forEachBail = require(\"./forEachBail\");\nconst { processExportsField } = require(\"./util/entrypoints\");\nconst { parseIdentifier } = require(\"./util/identifier\");\nconst { checkExportsFieldTarget } = require(\"./util/path\");\n\n/** @typedef {import(\"./Resolver\")} Resolver */\n/** @typedef {import(\"./Resolver\").ResolveStepHook} ResolveStepHook */\n/** @typedef {import(\"./util/entrypoints\").ExportsField} ExportsField */\n/** @typedef {import(\"./util/entrypoints\").FieldProcessor} FieldProcessor */\n\nmodule.exports = class ExportsFieldPlugin {\n\t/**\n\t * @param {string | ResolveStepHook} source source\n\t * @param {Set<string>} conditionNames condition names\n\t * @param {string | string[]} fieldNamePath name path\n\t * @param {string | ResolveStepHook} target target\n\t */\n\tconstructor(source, conditionNames, fieldNamePath, target) {\n\t\tthis.source = source;\n\t\tthis.target = target;\n\t\tthis.conditionNames = conditionNames;\n\t\tthis.fieldName = fieldNamePath;\n\t\t/** @type {WeakMap<any, FieldProcessor>} */\n\t\tthis.fieldProcessorCache = new WeakMap();\n\t}\n\n\t/**\n\t * @param {Resolver} resolver the resolver\n\t * @returns {void}\n\t */\n\tapply(resolver) {\n\t\tconst target = resolver.ensureHook(this.target);\n\t\tresolver\n\t\t\t.getHook(this.source)\n\t\t\t.tapAsync(\"ExportsFieldPlugin\", (request, resolveContext, callback) => {\n\t\t\t\t// When there is no description file, abort\n\t\t\t\tif (!request.descriptionFilePath) return callback();\n\t\t\t\tif (\n\t\t\t\t\t// When the description file is inherited from parent, abort\n\t\t\t\t\t// (There is no description file inside of this package)\n\t\t\t\t\trequest.relativePath !== \".\" ||\n\t\t\t\t\trequest.request === undefined\n\t\t\t\t)\n\t\t\t\t\treturn callback();\n\n\t\t\t\tconst remainingRequest =\n\t\t\t\t\trequest.query || request.fragment\n\t\t\t\t\t\t? (request.request === \".\" ? \"./\" : request.request) +\n\t\t\t\t\t\t  request.query +\n\t\t\t\t\t\t  request.fragment\n\t\t\t\t\t\t: request.request;\n\t\t\t\t/** @type {ExportsField|null} */\n\t\t\t\tconst exportsField = DescriptionFileUtils.getField(\n\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\tthis.fieldName\n\t\t\t\t);\n\t\t\t\tif (!exportsField) return callback();\n\n\t\t\t\tif (request.directory) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet paths;\n\n\t\t\t\ttry {\n\t\t\t\t\t// We attach the cache to the description file instead of the exportsField value\n\t\t\t\t\t// because we use a WeakMap and the exportsField could be a string too.\n\t\t\t\t\t// Description file is always an object when exports field can be accessed.\n\t\t\t\t\tlet fieldProcessor = this.fieldProcessorCache.get(\n\t\t\t\t\t\trequest.descriptionFileData\n\t\t\t\t\t);\n\t\t\t\t\tif (fieldProcessor === undefined) {\n\t\t\t\t\t\tfieldProcessor = processExportsField(exportsField);\n\t\t\t\t\t\tthis.fieldProcessorCache.set(\n\t\t\t\t\t\t\trequest.descriptionFileData,\n\t\t\t\t\t\t\tfieldProcessor\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpaths = fieldProcessor(remainingRequest, this.conditionNames);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (resolveContext.log) {\n\t\t\t\t\t\tresolveContext.log(\n\t\t\t\t\t\t\t`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\n\t\t\t\tif (paths.length === 0) {\n\t\t\t\t\treturn callback(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tforEachBail(\n\t\t\t\t\tpaths,\n\t\t\t\t\t(p, callback) => {\n\t\t\t\t\t\tconst parsedIdentifier = parseIdentifier(p);\n\n\t\t\t\t\t\tif (!parsedIdentifier) return callback();\n\n\t\t\t\t\t\tconst [relativePath, query, fragment] = parsedIdentifier;\n\n\t\t\t\t\t\tconst error = checkExportsFieldTarget(relativePath);\n\n\t\t\t\t\t\tif (error) {\n\t\t\t\t\t\t\treturn callback(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t...request,\n\t\t\t\t\t\t\trequest: undefined,\n\t\t\t\t\t\t\tpath: path.join(\n\t\t\t\t\t\t\t\t/** @type {string} */ (request.descriptionFileRoot),\n\t\t\t\t\t\t\t\trelativePath\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\trelativePath,\n\t\t\t\t\t\t\tquery,\n\t\t\t\t\t\t\tfragment\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tresolver.doResolve(\n\t\t\t\t\t\t\ttarget,\n\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\"using exports field: \" + p,\n\t\t\t\t\t\t\tresolveContext,\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => callback(err, result || null)\n\t\t\t\t);\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}