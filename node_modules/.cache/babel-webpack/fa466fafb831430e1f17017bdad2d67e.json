{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/completion\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"@angular/compiler/src/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/typecheck/api\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.CompletionEngine = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var compiler_2 = require(\"@angular/compiler/src/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/api\");\n\n  var comments_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\");\n  /**\n   * Powers autocompletion for a specific component.\n   *\n   * Internally caches autocompletion results, and must be discarded if the component template or\n   * surrounding TS program have changed.\n   */\n\n\n  var CompletionEngine =\n  /** @class */\n  function () {\n    function CompletionEngine(tcb, data, shimPath) {\n      this.tcb = tcb;\n      this.data = data;\n      this.shimPath = shimPath;\n      /**\n       * Cache of completions for various levels of the template, including the root template (`null`).\n       * Memoizes `getTemplateContextCompletions`.\n       */\n\n      this.templateContextCache = new Map();\n      this.expressionCompletionCache = new Map(); // Find the component completion expression within the TCB. This looks like: `ctx. /* ... */;`\n\n      var globalRead = comments_1.findFirstMatchingNode(this.tcb, {\n        filter: ts.isPropertyAccessExpression,\n        withExpressionIdentifier: comments_1.ExpressionIdentifier.COMPONENT_COMPLETION\n      });\n\n      if (globalRead !== null) {\n        this.componentContext = {\n          shimPath: this.shimPath,\n          // `globalRead.name` is an empty `ts.Identifier`, so its start position immediately follows\n          // the `.` in `ctx.`. TS autocompletion APIs can then be used to access completion results\n          // for the component context.\n          positionInShimFile: globalRead.name.getStart()\n        };\n      } else {\n        this.componentContext = null;\n      }\n    }\n    /**\n     * Get global completions within the given template context and AST node.\n     *\n     * @param context the given template context - either a `TmplAstTemplate` embedded view, or `null`\n     *     for the root\n     * template context.\n     * @param node the given AST node\n     */\n\n\n    CompletionEngine.prototype.getGlobalCompletions = function (context, node) {\n      if (this.componentContext === null) {\n        return null;\n      }\n\n      var templateContext = this.getTemplateContextCompletions(context);\n\n      if (templateContext === null) {\n        return null;\n      }\n\n      var nodeContext = null;\n\n      if (node instanceof compiler_2.EmptyExpr) {\n        var nodeLocation = comments_1.findFirstMatchingNode(this.tcb, {\n          filter: ts.isIdentifier,\n          withSpan: node.sourceSpan\n        });\n\n        if (nodeLocation !== null) {\n          nodeContext = {\n            shimPath: this.shimPath,\n            positionInShimFile: nodeLocation.getStart()\n          };\n        }\n      }\n\n      return {\n        componentContext: this.componentContext,\n        templateContext: templateContext,\n        nodeContext: nodeContext\n      };\n    };\n\n    CompletionEngine.prototype.getExpressionCompletionLocation = function (expr) {\n      if (this.expressionCompletionCache.has(expr)) {\n        return this.expressionCompletionCache.get(expr);\n      } // Completion works inside property reads and method calls.\n\n\n      var tsExpr = null;\n\n      if (expr instanceof compiler_2.PropertyRead || expr instanceof compiler_2.MethodCall || expr instanceof compiler_2.PropertyWrite) {\n        // Non-safe navigation operations are trivial: `foo.bar` or `foo.bar()`\n        tsExpr = comments_1.findFirstMatchingNode(this.tcb, {\n          filter: ts.isPropertyAccessExpression,\n          withSpan: expr.nameSpan\n        });\n      } else if (expr instanceof compiler_2.SafePropertyRead || expr instanceof compiler_2.SafeMethodCall) {\n        // Safe navigation operations are a little more complex, and involve a ternary. Completion\n        // happens in the \"true\" case of the ternary.\n        var ternaryExpr = comments_1.findFirstMatchingNode(this.tcb, {\n          filter: ts.isParenthesizedExpression,\n          withSpan: expr.sourceSpan\n        });\n\n        if (ternaryExpr === null || !ts.isConditionalExpression(ternaryExpr.expression)) {\n          return null;\n        }\n\n        var whenTrue = ternaryExpr.expression.whenTrue;\n\n        if (expr instanceof compiler_2.SafePropertyRead && ts.isPropertyAccessExpression(whenTrue)) {\n          tsExpr = whenTrue;\n        } else if (expr instanceof compiler_2.SafeMethodCall && ts.isCallExpression(whenTrue) && ts.isPropertyAccessExpression(whenTrue.expression)) {\n          tsExpr = whenTrue.expression;\n        }\n      }\n\n      if (tsExpr === null) {\n        return null;\n      }\n\n      var res = {\n        shimPath: this.shimPath,\n        positionInShimFile: tsExpr.name.getEnd()\n      };\n      this.expressionCompletionCache.set(expr, res);\n      return res;\n    };\n    /**\n     * Get global completions within the given template context - either a `TmplAstTemplate` embedded\n     * view, or `null` for the root context.\n     */\n\n\n    CompletionEngine.prototype.getTemplateContextCompletions = function (context) {\n      var e_1, _a;\n\n      if (this.templateContextCache.has(context)) {\n        return this.templateContextCache.get(context);\n      }\n\n      var templateContext = new Map();\n\n      try {\n        // The bound template already has details about the references and variables in scope in the\n        // `context` template - they just need to be converted to `Completion`s.\n        for (var _b = tslib_1.__values(this.data.boundTarget.getEntitiesInTemplateScope(context)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var node = _c.value;\n\n          if (node instanceof compiler_1.TmplAstReference) {\n            templateContext.set(node.name, {\n              kind: api_1.CompletionKind.Reference,\n              node: node\n            });\n          } else {\n            templateContext.set(node.name, {\n              kind: api_1.CompletionKind.Variable,\n              node: node\n            });\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      this.templateContextCache.set(context, templateContext);\n      return templateContext;\n    };\n\n    return CompletionEngine;\n  }();\n\n  exports.CompletionEngine = CompletionEngine;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/completion.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TmplAstReference, TmplAstTemplate} from '@angular/compiler';\nimport {AST, EmptyExpr, MethodCall, PropertyRead, PropertyWrite, SafeMethodCall, SafePropertyRead, TmplAstNode} from '@angular/compiler/src/compiler';\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {CompletionKind, GlobalCompletion, ReferenceCompletion, ShimLocation, VariableCompletion} from '../api';\n\nimport {ExpressionIdentifier, findFirstMatchingNode} from './comments';\nimport {TemplateData} from './context';\n\n/**\n * Powers autocompletion for a specific component.\n *\n * Internally caches autocompletion results, and must be discarded if the component template or\n * surrounding TS program have changed.\n */\nexport class CompletionEngine {\n  private componentContext: ShimLocation|null;\n\n  /**\n   * Cache of completions for various levels of the template, including the root template (`null`).\n   * Memoizes `getTemplateContextCompletions`.\n   */\n  private templateContextCache =\n      new Map<TmplAstTemplate|null, Map<string, ReferenceCompletion|VariableCompletion>>();\n\n  private expressionCompletionCache =\n      new Map<PropertyRead|SafePropertyRead|MethodCall|SafeMethodCall, ShimLocation>();\n\n\n  constructor(private tcb: ts.Node, private data: TemplateData, private shimPath: AbsoluteFsPath) {\n    // Find the component completion expression within the TCB. This looks like: `ctx. /* ... */;`\n    const globalRead = findFirstMatchingNode(this.tcb, {\n      filter: ts.isPropertyAccessExpression,\n      withExpressionIdentifier: ExpressionIdentifier.COMPONENT_COMPLETION\n    });\n\n    if (globalRead !== null) {\n      this.componentContext = {\n        shimPath: this.shimPath,\n        // `globalRead.name` is an empty `ts.Identifier`, so its start position immediately follows\n        // the `.` in `ctx.`. TS autocompletion APIs can then be used to access completion results\n        // for the component context.\n        positionInShimFile: globalRead.name.getStart(),\n      };\n    } else {\n      this.componentContext = null;\n    }\n  }\n\n  /**\n   * Get global completions within the given template context and AST node.\n   *\n   * @param context the given template context - either a `TmplAstTemplate` embedded view, or `null`\n   *     for the root\n   * template context.\n   * @param node the given AST node\n   */\n  getGlobalCompletions(context: TmplAstTemplate|null, node: AST|TmplAstNode): GlobalCompletion\n      |null {\n    if (this.componentContext === null) {\n      return null;\n    }\n\n    const templateContext = this.getTemplateContextCompletions(context);\n    if (templateContext === null) {\n      return null;\n    }\n\n    let nodeContext: ShimLocation|null = null;\n    if (node instanceof EmptyExpr) {\n      const nodeLocation = findFirstMatchingNode(this.tcb, {\n        filter: ts.isIdentifier,\n        withSpan: node.sourceSpan,\n      });\n      if (nodeLocation !== null) {\n        nodeContext = {\n          shimPath: this.shimPath,\n          positionInShimFile: nodeLocation.getStart(),\n        };\n      }\n    }\n\n    return {\n      componentContext: this.componentContext,\n      templateContext,\n      nodeContext,\n    };\n  }\n\n  getExpressionCompletionLocation(expr: PropertyRead|PropertyWrite|MethodCall|\n                                  SafeMethodCall): ShimLocation|null {\n    if (this.expressionCompletionCache.has(expr)) {\n      return this.expressionCompletionCache.get(expr)!;\n    }\n\n    // Completion works inside property reads and method calls.\n    let tsExpr: ts.PropertyAccessExpression|null = null;\n    if (expr instanceof PropertyRead || expr instanceof MethodCall ||\n        expr instanceof PropertyWrite) {\n      // Non-safe navigation operations are trivial: `foo.bar` or `foo.bar()`\n      tsExpr = findFirstMatchingNode(this.tcb, {\n        filter: ts.isPropertyAccessExpression,\n        withSpan: expr.nameSpan,\n      });\n    } else if (expr instanceof SafePropertyRead || expr instanceof SafeMethodCall) {\n      // Safe navigation operations are a little more complex, and involve a ternary. Completion\n      // happens in the \"true\" case of the ternary.\n      const ternaryExpr = findFirstMatchingNode(this.tcb, {\n        filter: ts.isParenthesizedExpression,\n        withSpan: expr.sourceSpan,\n      });\n      if (ternaryExpr === null || !ts.isConditionalExpression(ternaryExpr.expression)) {\n        return null;\n      }\n      const whenTrue = ternaryExpr.expression.whenTrue;\n\n      if (expr instanceof SafePropertyRead && ts.isPropertyAccessExpression(whenTrue)) {\n        tsExpr = whenTrue;\n      } else if (\n          expr instanceof SafeMethodCall && ts.isCallExpression(whenTrue) &&\n          ts.isPropertyAccessExpression(whenTrue.expression)) {\n        tsExpr = whenTrue.expression;\n      }\n    }\n\n    if (tsExpr === null) {\n      return null;\n    }\n\n    const res: ShimLocation = {\n      shimPath: this.shimPath,\n      positionInShimFile: tsExpr.name.getEnd(),\n    };\n    this.expressionCompletionCache.set(expr, res);\n    return res;\n  }\n\n  /**\n   * Get global completions within the given template context - either a `TmplAstTemplate` embedded\n   * view, or `null` for the root context.\n   */\n  private getTemplateContextCompletions(context: TmplAstTemplate|null):\n      Map<string, ReferenceCompletion|VariableCompletion>|null {\n    if (this.templateContextCache.has(context)) {\n      return this.templateContextCache.get(context)!;\n    }\n\n    const templateContext = new Map<string, ReferenceCompletion|VariableCompletion>();\n\n    // The bound template already has details about the references and variables in scope in the\n    // `context` template - they just need to be converted to `Completion`s.\n    for (const node of this.data.boundTarget.getEntitiesInTemplateScope(context)) {\n      if (node instanceof TmplAstReference) {\n        templateContext.set(node.name, {\n          kind: CompletionKind.Reference,\n          node,\n        });\n      } else {\n        templateContext.set(node.name, {\n          kind: CompletionKind.Variable,\n          node,\n        });\n      }\n    }\n\n    this.templateContextCache.set(context, templateContext);\n    return templateContext;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}