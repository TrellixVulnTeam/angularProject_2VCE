{"ast":null,"code":"var _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug')('log4js:fileSync');\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nvar os = require('os');\n\nvar eol = os.EOL || '\\n';\n\nfunction touchFile(file, options) {\n  // if the file exists, nothing to do\n  if (fs.existsSync(file)) {\n    return;\n  } // touch the file to apply flags (like w to truncate the file)\n\n\n  var id = fs.openSync(file, options.flags, options.mode);\n  fs.closeSync(id);\n}\n\nvar RollingFileSync = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function RollingFileSync(filename, size, backups, options) {\n    _classCallCheck(this, RollingFileSync);\n\n    debug('In RollingFileStream');\n\n    function throwErrorIfArgumentsAreNotValid() {\n      if (!filename || !size || size <= 0) {\n        throw new Error('You must specify a filename and file size');\n      }\n    }\n\n    throwErrorIfArgumentsAreNotValid();\n    this.filename = filename;\n    this.size = size;\n    this.backups = backups || 1;\n    this.options = options;\n    this.currentSize = 0;\n\n    function currentFileSize(file) {\n      var fileSize = 0;\n\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n\n      return fileSize;\n    }\n\n    this.currentSize = currentFileSize(this.filename);\n  }\n\n  _createClass(RollingFileSync, [{\n    key: \"shouldRoll\",\n    value: function shouldRoll() {\n      debug('should roll with current size %d, and max size %d', this.currentSize, this.size);\n      return this.currentSize >= this.size;\n    }\n  }, {\n    key: \"roll\",\n    value: function roll(filename) {\n      var that = this;\n      var nameMatcher = new RegExp(\"^\".concat(path.basename(filename)));\n\n      function justTheseFiles(item) {\n        return nameMatcher.test(item);\n      }\n\n      function index(filename_) {\n        return parseInt(filename_.substring(\"\".concat(path.basename(filename), \".\").length), 10) || 0;\n      }\n\n      function byIndex(a, b) {\n        if (index(a) > index(b)) {\n          return 1;\n        }\n\n        if (index(a) < index(b)) {\n          return -1;\n        }\n\n        return 0;\n      }\n\n      function increaseFileIndex(fileToRename) {\n        var idx = index(fileToRename);\n        debug(\"Index of \".concat(fileToRename, \" is \").concat(idx));\n\n        if (idx < that.backups) {\n          // on windows, you can get a EEXIST error if you rename a file to an existing file\n          // so, we'll try to delete the file we're renaming to first\n          try {\n            fs.unlinkSync(\"\".concat(filename, \".\").concat(idx + 1));\n          } catch (e) {// ignore err: if we could not delete, it's most likely that it doesn't exist\n          }\n\n          debug(\"Renaming \".concat(fileToRename, \" -> \").concat(filename, \".\").concat(idx + 1));\n          fs.renameSync(path.join(path.dirname(filename), fileToRename), \"\".concat(filename, \".\").concat(idx + 1));\n        }\n      }\n\n      function renameTheFiles() {\n        // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n        debug('Renaming the old files');\n        var files = fs.readdirSync(path.dirname(filename));\n        files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);\n      }\n\n      debug('Rolling, rolling, rolling');\n      renameTheFiles();\n    }\n    /* eslint no-unused-vars:0 */\n\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding) {\n      var that = this;\n\n      function writeTheChunk() {\n        debug('writing the chunk to the file');\n        that.currentSize += chunk.length;\n        fs.appendFileSync(that.filename, chunk);\n      }\n\n      debug('in write');\n\n      if (this.shouldRoll()) {\n        this.currentSize = 0;\n        this.roll(this.filename);\n      }\n\n      writeTheChunk();\n    }\n  }]);\n\n  return RollingFileSync;\n}();\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param timezoneOffset - optional timezone offset in minutes\n *   (default system local)\n * @param options - passed as is to fs options\n */\n\n\nfunction fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {\n  debug('fileSync appender created');\n  file = path.normalize(file);\n  numBackups = numBackups === undefined ? 5 : numBackups; // there has to be at least one backup if logSize has been specified\n\n  numBackups = numBackups === 0 ? 1 : numBackups;\n\n  function openTheStream(filePath, fileSize, numFiles) {\n    var stream;\n\n    if (fileSize) {\n      stream = new RollingFileSync(filePath, fileSize, numFiles, options);\n    } else {\n      stream = function (f) {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n        return {\n          write: function write(data) {\n            fs.appendFileSync(f, data);\n          }\n        };\n      }(filePath);\n    }\n\n    return stream;\n  }\n\n  var logFile = openTheStream(file, logSize, numBackups);\n  return function (loggingEvent) {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\n\nfunction configure(config, layouts) {\n  var layout = layouts.basicLayout;\n\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  var options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 420\n  };\n  return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config.timezoneOffset, options);\n}\n\nmodule.exports.configure = configure;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/log4js/lib/appenders/fileSync.js"],"names":["debug","require","path","fs","os","eol","EOL","touchFile","file","options","existsSync","id","openSync","flags","mode","closeSync","RollingFileSync","filename","size","backups","throwErrorIfArgumentsAreNotValid","Error","currentSize","currentFileSize","fileSize","statSync","e","that","nameMatcher","RegExp","basename","justTheseFiles","item","test","index","filename_","parseInt","substring","length","byIndex","a","b","increaseFileIndex","fileToRename","idx","unlinkSync","renameSync","join","dirname","renameTheFiles","files","readdirSync","filter","sort","reverse","forEach","chunk","encoding","writeTheChunk","appendFileSync","shouldRoll","roll","fileAppender","layout","logSize","numBackups","timezoneOffset","normalize","undefined","openTheStream","filePath","numFiles","stream","f","write","data","logFile","loggingEvent","configure","config","layouts","basicLayout","type","maxLogSize","module","exports"],"mappings":";;;;AAAA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAP,CAAiB,iBAAjB,CAAd;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,IAAME,EAAE,GAAGF,OAAO,CAAC,IAAD,CAAlB;;AACA,IAAMG,EAAE,GAAGH,OAAO,CAAC,IAAD,CAAlB;;AAEA,IAAMI,GAAG,GAAGD,EAAE,CAACE,GAAH,IAAU,IAAtB;;AAEA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBC,OAAzB,EAAkC;AAChC;AACA,MAAIN,EAAE,CAACO,UAAH,CAAcF,IAAd,CAAJ,EAAyB;AACvB;AACD,GAJ+B,CAMhC;;;AACA,MAAMG,EAAE,GAAGR,EAAE,CAACS,QAAH,CAAYJ,IAAZ,EAAkBC,OAAO,CAACI,KAA1B,EAAiCJ,OAAO,CAACK,IAAzC,CAAX;AACAX,EAAAA,EAAE,CAACY,SAAH,CAAaJ,EAAb;AACD;;IAEKK,e;;;AACJ,2BAAYC,QAAZ,EAAsBC,IAAtB,EAA4BC,OAA5B,EAAqCV,OAArC,EAA8C;AAAA;;AAC5CT,IAAAA,KAAK,CAAC,sBAAD,CAAL;;AAEA,aAASoB,gCAAT,GAA4C;AAC1C,UAAI,CAACH,QAAD,IAAa,CAACC,IAAd,IAAsBA,IAAI,IAAI,CAAlC,EAAqC;AACnC,cAAM,IAAIG,KAAJ,CAAU,2CAAV,CAAN;AACD;AACF;;AAEDD,IAAAA,gCAAgC;AAEhC,SAAKH,QAAL,GAAgBA,QAAhB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,OAAL,GAAeA,OAAO,IAAI,CAA1B;AACA,SAAKV,OAAL,GAAeA,OAAf;AACA,SAAKa,WAAL,GAAmB,CAAnB;;AAEA,aAASC,eAAT,CAAyBf,IAAzB,EAA+B;AAC7B,UAAIgB,QAAQ,GAAG,CAAf;;AAEA,UAAI;AACFA,QAAAA,QAAQ,GAAGrB,EAAE,CAACsB,QAAH,CAAYjB,IAAZ,EAAkBU,IAA7B;AACD,OAFD,CAEE,OAAOQ,CAAP,EAAU;AACV;AACAnB,QAAAA,SAAS,CAACC,IAAD,EAAOC,OAAP,CAAT;AACD;;AACD,aAAOe,QAAP;AACD;;AAED,SAAKF,WAAL,GAAmBC,eAAe,CAAC,KAAKN,QAAN,CAAlC;AACD;;;;WAED,sBAAa;AACXjB,MAAAA,KAAK,CAAC,mDAAD,EAAsD,KAAKsB,WAA3D,EAAwE,KAAKJ,IAA7E,CAAL;AACA,aAAO,KAAKI,WAAL,IAAoB,KAAKJ,IAAhC;AACD;;;WAED,cAAKD,QAAL,EAAe;AACb,UAAMU,IAAI,GAAG,IAAb;AACA,UAAMC,WAAW,GAAG,IAAIC,MAAJ,YAAe3B,IAAI,CAAC4B,QAAL,CAAcb,QAAd,CAAf,EAApB;;AAEA,eAASc,cAAT,CAAwBC,IAAxB,EAA8B;AAC5B,eAAOJ,WAAW,CAACK,IAAZ,CAAiBD,IAAjB,CAAP;AACD;;AAED,eAASE,KAAT,CAAeC,SAAf,EAA0B;AACxB,eAAOC,QAAQ,CAACD,SAAS,CAACE,SAAV,CAAoB,UAAInC,IAAI,CAAC4B,QAAL,CAAcb,QAAd,CAAJ,OAAgCqB,MAApD,CAAD,EAA8D,EAA9D,CAAR,IAA6E,CAApF;AACD;;AAED,eAASC,OAAT,CAAiBC,CAAjB,EAAoBC,CAApB,EAAuB;AACrB,YAAIP,KAAK,CAACM,CAAD,CAAL,GAAWN,KAAK,CAACO,CAAD,CAApB,EAAyB;AACvB,iBAAO,CAAP;AACD;;AACD,YAAIP,KAAK,CAACM,CAAD,CAAL,GAAWN,KAAK,CAACO,CAAD,CAApB,EAAyB;AACvB,iBAAO,CAAC,CAAR;AACD;;AAED,eAAO,CAAP;AACD;;AAED,eAASC,iBAAT,CAA2BC,YAA3B,EAAyC;AACvC,YAAMC,GAAG,GAAGV,KAAK,CAACS,YAAD,CAAjB;AACA3C,QAAAA,KAAK,oBAAa2C,YAAb,iBAAgCC,GAAhC,EAAL;;AACA,YAAIA,GAAG,GAAGjB,IAAI,CAACR,OAAf,EAAwB;AACtB;AACA;AACA,cAAI;AACFhB,YAAAA,EAAE,CAAC0C,UAAH,WAAiB5B,QAAjB,cAA6B2B,GAAG,GAAG,CAAnC;AACD,WAFD,CAEE,OAAOlB,CAAP,EAAU,CACV;AACD;;AAED1B,UAAAA,KAAK,oBAAa2C,YAAb,iBAAgC1B,QAAhC,cAA4C2B,GAAG,GAAG,CAAlD,EAAL;AACAzC,UAAAA,EAAE,CAAC2C,UAAH,CAAc5C,IAAI,CAAC6C,IAAL,CAAU7C,IAAI,CAAC8C,OAAL,CAAa/B,QAAb,CAAV,EAAkC0B,YAAlC,CAAd,YAAkE1B,QAAlE,cAA8E2B,GAAG,GAAG,CAApF;AACD;AACF;;AAED,eAASK,cAAT,GAA0B;AACxB;AACAjD,QAAAA,KAAK,CAAC,wBAAD,CAAL;AAEA,YAAMkD,KAAK,GAAG/C,EAAE,CAACgD,WAAH,CAAejD,IAAI,CAAC8C,OAAL,CAAa/B,QAAb,CAAf,CAAd;AACAiC,QAAAA,KAAK,CAACE,MAAN,CAAarB,cAAb,EAA6BsB,IAA7B,CAAkCd,OAAlC,EAA2Ce,OAA3C,GAAqDC,OAArD,CAA6Db,iBAA7D;AACD;;AAED1C,MAAAA,KAAK,CAAC,2BAAD,CAAL;AACAiD,MAAAA,cAAc;AACf;AAED;;;;WACA,eAAMO,KAAN,EAAaC,QAAb,EAAuB;AACrB,UAAM9B,IAAI,GAAG,IAAb;;AAGA,eAAS+B,aAAT,GAAyB;AACvB1D,QAAAA,KAAK,CAAC,+BAAD,CAAL;AACA2B,QAAAA,IAAI,CAACL,WAAL,IAAoBkC,KAAK,CAAClB,MAA1B;AACAnC,QAAAA,EAAE,CAACwD,cAAH,CAAkBhC,IAAI,CAACV,QAAvB,EAAiCuC,KAAjC;AACD;;AAEDxD,MAAAA,KAAK,CAAC,UAAD,CAAL;;AAGA,UAAI,KAAK4D,UAAL,EAAJ,EAAuB;AACrB,aAAKtC,WAAL,GAAmB,CAAnB;AACA,aAAKuC,IAAL,CAAU,KAAK5C,QAAf;AACD;;AAEDyC,MAAAA,aAAa;AACd;;;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASI,YAAT,CAAsBtD,IAAtB,EAA4BuD,MAA5B,EAAoCC,OAApC,EAA6CC,UAA7C,EAAyDC,cAAzD,EAAyEzD,OAAzE,EAAkF;AAChFT,EAAAA,KAAK,CAAC,2BAAD,CAAL;AACAQ,EAAAA,IAAI,GAAGN,IAAI,CAACiE,SAAL,CAAe3D,IAAf,CAAP;AACAyD,EAAAA,UAAU,GAAGA,UAAU,KAAKG,SAAf,GAA2B,CAA3B,GAA+BH,UAA5C,CAHgF,CAIhF;;AACAA,EAAAA,UAAU,GAAGA,UAAU,KAAK,CAAf,GAAmB,CAAnB,GAAuBA,UAApC;;AAEA,WAASI,aAAT,CAAuBC,QAAvB,EAAiC9C,QAAjC,EAA2C+C,QAA3C,EAAqD;AACnD,QAAIC,MAAJ;;AAEA,QAAIhD,QAAJ,EAAc;AACZgD,MAAAA,MAAM,GAAG,IAAIxD,eAAJ,CACPsD,QADO,EAEP9C,QAFO,EAGP+C,QAHO,EAIP9D,OAJO,CAAT;AAMD,KAPD,MAOO;AACL+D,MAAAA,MAAM,GAAK,UAACC,CAAD,EAAO;AAChB;AACAlE,QAAAA,SAAS,CAACkE,CAAD,EAAIhE,OAAJ,CAAT;AAEA,eAAO;AACLiE,UAAAA,KADK,iBACCC,IADD,EACO;AACVxE,YAAAA,EAAE,CAACwD,cAAH,CAAkBc,CAAlB,EAAqBE,IAArB;AACD;AAHI,SAAP;AAKD,OATQ,CASLL,QATK,CAAT;AAUD;;AAED,WAAOE,MAAP;AACD;;AAED,MAAMI,OAAO,GAAGP,aAAa,CAAC7D,IAAD,EAAOwD,OAAP,EAAgBC,UAAhB,CAA7B;AAEA,SAAO,UAACY,YAAD,EAAkB;AACvBD,IAAAA,OAAO,CAACF,KAAR,CAAcX,MAAM,CAACc,YAAD,EAAeX,cAAf,CAAN,GAAuC7D,GAArD;AACD,GAFD;AAGD;;AAED,SAASyE,SAAT,CAAmBC,MAAnB,EAA2BC,OAA3B,EAAoC;AAClC,MAAIjB,MAAM,GAAGiB,OAAO,CAACC,WAArB;;AACA,MAAIF,MAAM,CAAChB,MAAX,EAAmB;AACjBA,IAAAA,MAAM,GAAGiB,OAAO,CAACjB,MAAR,CAAegB,MAAM,CAAChB,MAAP,CAAcmB,IAA7B,EAAmCH,MAAM,CAAChB,MAA1C,CAAT;AACD;;AAED,MAAMtD,OAAO,GAAG;AACdI,IAAAA,KAAK,EAAEkE,MAAM,CAAClE,KAAP,IAAgB,GADT;AAEd4C,IAAAA,QAAQ,EAAEsB,MAAM,CAACtB,QAAP,IAAmB,MAFf;AAGd3C,IAAAA,IAAI,EAAEiE,MAAM,CAACjE,IAAP,IAAe;AAHP,GAAhB;AAMA,SAAOgD,YAAY,CACjBiB,MAAM,CAAC9D,QADU,EAEjB8C,MAFiB,EAGjBgB,MAAM,CAACI,UAHU,EAIjBJ,MAAM,CAAC5D,OAJU,EAKjB4D,MAAM,CAACb,cALU,EAMjBzD,OANiB,CAAnB;AAQD;;AAED2E,MAAM,CAACC,OAAP,CAAeP,SAAf,GAA2BA,SAA3B","sourcesContent":["const debug = require('debug')('log4js:fileSync');\nconst path = require('path');\nconst fs = require('fs');\nconst os = require('os');\n\nconst eol = os.EOL || '\\n';\n\nfunction touchFile(file, options) {\n  // if the file exists, nothing to do\n  if (fs.existsSync(file)) {\n    return;\n  }\n\n  // touch the file to apply flags (like w to truncate the file)\n  const id = fs.openSync(file, options.flags, options.mode);\n  fs.closeSync(id);\n}\n\nclass RollingFileSync {\n  constructor(filename, size, backups, options) {\n    debug('In RollingFileStream');\n\n    function throwErrorIfArgumentsAreNotValid() {\n      if (!filename || !size || size <= 0) {\n        throw new Error('You must specify a filename and file size');\n      }\n    }\n\n    throwErrorIfArgumentsAreNotValid();\n\n    this.filename = filename;\n    this.size = size;\n    this.backups = backups || 1;\n    this.options = options;\n    this.currentSize = 0;\n\n    function currentFileSize(file) {\n      let fileSize = 0;\n\n      try {\n        fileSize = fs.statSync(file).size;\n      } catch (e) {\n        // file does not exist\n        touchFile(file, options);\n      }\n      return fileSize;\n    }\n\n    this.currentSize = currentFileSize(this.filename);\n  }\n\n  shouldRoll() {\n    debug('should roll with current size %d, and max size %d', this.currentSize, this.size);\n    return this.currentSize >= this.size;\n  }\n\n  roll(filename) {\n    const that = this;\n    const nameMatcher = new RegExp(`^${path.basename(filename)}`);\n\n    function justTheseFiles(item) {\n      return nameMatcher.test(item);\n    }\n\n    function index(filename_) {\n      return parseInt(filename_.substring((`${path.basename(filename)}.`).length), 10) || 0;\n    }\n\n    function byIndex(a, b) {\n      if (index(a) > index(b)) {\n        return 1;\n      }\n      if (index(a) < index(b)) {\n        return -1;\n      }\n\n      return 0;\n    }\n\n    function increaseFileIndex(fileToRename) {\n      const idx = index(fileToRename);\n      debug(`Index of ${fileToRename} is ${idx}`);\n      if (idx < that.backups) {\n        // on windows, you can get a EEXIST error if you rename a file to an existing file\n        // so, we'll try to delete the file we're renaming to first\n        try {\n          fs.unlinkSync(`${filename}.${idx + 1}`);\n        } catch (e) {\n          // ignore err: if we could not delete, it's most likely that it doesn't exist\n        }\n\n        debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);\n        fs.renameSync(path.join(path.dirname(filename), fileToRename), `${filename}.${idx + 1}`);\n      }\n    }\n\n    function renameTheFiles() {\n      // roll the backups (rename file.n to file.n+1, where n <= numBackups)\n      debug('Renaming the old files');\n\n      const files = fs.readdirSync(path.dirname(filename));\n      files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);\n    }\n\n    debug('Rolling, rolling, rolling');\n    renameTheFiles();\n  }\n\n  /* eslint no-unused-vars:0 */\n  write(chunk, encoding) {\n    const that = this;\n\n\n    function writeTheChunk() {\n      debug('writing the chunk to the file');\n      that.currentSize += chunk.length;\n      fs.appendFileSync(that.filename, chunk);\n    }\n\n    debug('in write');\n\n\n    if (this.shouldRoll()) {\n      this.currentSize = 0;\n      this.roll(this.filename);\n    }\n\n    writeTheChunk();\n  }\n}\n\n/**\n * File Appender writing the logs to a text file. Supports rolling of logs by size.\n *\n * @param file file log messages will be written to\n * @param layout a function that takes a logevent and returns a string\n *   (defaults to basicLayout).\n * @param logSize - the maximum size (in bytes) for a log file,\n *   if not provided then logs won't be rotated.\n * @param numBackups - the number of log files to keep after logSize\n *   has been reached (default 5)\n * @param timezoneOffset - optional timezone offset in minutes\n *   (default system local)\n * @param options - passed as is to fs options\n */\nfunction fileAppender(file, layout, logSize, numBackups, timezoneOffset, options) {\n  debug('fileSync appender created');\n  file = path.normalize(file);\n  numBackups = numBackups === undefined ? 5 : numBackups;\n  // there has to be at least one backup if logSize has been specified\n  numBackups = numBackups === 0 ? 1 : numBackups;\n\n  function openTheStream(filePath, fileSize, numFiles) {\n    let stream;\n\n    if (fileSize) {\n      stream = new RollingFileSync(\n        filePath,\n        fileSize,\n        numFiles,\n        options\n      );\n    } else {\n      stream = (((f) => {\n        // touch the file to apply flags (like w to truncate the file)\n        touchFile(f, options);\n\n        return {\n          write(data) {\n            fs.appendFileSync(f, data);\n          }\n        };\n      }))(filePath);\n    }\n\n    return stream;\n  }\n\n  const logFile = openTheStream(file, logSize, numBackups);\n\n  return (loggingEvent) => {\n    logFile.write(layout(loggingEvent, timezoneOffset) + eol);\n  };\n}\n\nfunction configure(config, layouts) {\n  let layout = layouts.basicLayout;\n  if (config.layout) {\n    layout = layouts.layout(config.layout.type, config.layout);\n  }\n\n  const options = {\n    flags: config.flags || 'a',\n    encoding: config.encoding || 'utf8',\n    mode: config.mode || 0o644\n  };\n\n  return fileAppender(\n    config.filename,\n    layout,\n    config.maxLogSize,\n    config.backups,\n    config.timezoneOffset,\n    options\n  );\n}\n\nmodule.exports.configure = configure;\n"]},"metadata":{},"sourceType":"script"}