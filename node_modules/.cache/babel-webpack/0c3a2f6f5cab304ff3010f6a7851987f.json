{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar crypto = require('crypto');\n\nvar MiniPass = require('minipass');\n\nvar SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']; // TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\n\nvar BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\nvar SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/;\nvar STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/;\nvar VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\nvar defaultOpts = {\n  algorithms: ['sha512'],\n  error: false,\n  options: [],\n  pickAlgorithm: getPrioritizedHash,\n  sep: ' ',\n  single: false,\n  strict: false\n};\n\nvar ssriOpts = function ssriOpts() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return _objectSpread(_objectSpread({}, defaultOpts), opts);\n};\n\nvar getOptString = function getOptString(options) {\n  return !options || !options.length ? '' : \"?\".concat(options.join('?'));\n};\n\nvar _onEnd = Symbol('_onEnd');\n\nvar _getOptions = Symbol('_getOptions');\n\nvar IntegrityStream = /*#__PURE__*/function (_MiniPass) {\n  _inherits(IntegrityStream, _MiniPass);\n\n  var _super = _createSuper(IntegrityStream);\n\n  function IntegrityStream(opts) {\n    var _this;\n\n    _classCallCheck(this, IntegrityStream);\n\n    _this = _super.call(this);\n    _this.size = 0;\n    _this.opts = opts; // may be overridden later, but set now for class consistency\n\n    _this[_getOptions](); // options used for calculating stream.  can't be changed.\n\n\n    var _opts$algorithms = opts.algorithms,\n        algorithms = _opts$algorithms === void 0 ? defaultOpts.algorithms : _opts$algorithms;\n    _this.algorithms = Array.from(new Set(algorithms.concat(_this.algorithm ? [_this.algorithm] : [])));\n    _this.hashes = _this.algorithms.map(crypto.createHash);\n    return _this;\n  }\n\n  _createClass(IntegrityStream, [{\n    key: _getOptions,\n    value: function value() {\n      var _defaultOpts$this$opt = _objectSpread(_objectSpread({}, defaultOpts), this.opts),\n          integrity = _defaultOpts$this$opt.integrity,\n          size = _defaultOpts$this$opt.size,\n          options = _defaultOpts$this$opt.options; // For verification\n\n\n      this.sri = integrity ? parse(integrity, this.opts) : null;\n      this.expectedSize = size;\n      this.goodSri = this.sri ? !!Object.keys(this.sri).length : false;\n      this.algorithm = this.goodSri ? this.sri.pickAlgorithm(this.opts) : null;\n      this.digests = this.goodSri ? this.sri[this.algorithm] : null;\n      this.optString = getOptString(options);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      if (ev === 'end') this[_onEnd]();\n      return _get(_getPrototypeOf(IntegrityStream.prototype), \"emit\", this).call(this, ev, data);\n    }\n  }, {\n    key: \"write\",\n    value: function write(data) {\n      this.size += data.length;\n      this.hashes.forEach(function (h) {\n        return h.update(data);\n      });\n      return _get(_getPrototypeOf(IntegrityStream.prototype), \"write\", this).call(this, data);\n    }\n  }, {\n    key: _onEnd,\n    value: function value() {\n      var _this2 = this;\n\n      if (!this.goodSri) {\n        this[_getOptions]();\n      }\n\n      var newSri = parse(this.hashes.map(function (h, i) {\n        return \"\".concat(_this2.algorithms[i], \"-\").concat(h.digest('base64')).concat(_this2.optString);\n      }).join(' '), this.opts); // Integrity verification mode\n\n      var match = this.goodSri && newSri.match(this.sri, this.opts);\n\n      if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n        var err = new Error(\"stream size mismatch when checking \".concat(this.sri, \".\\n  Wanted: \").concat(this.expectedSize, \"\\n  Found: \").concat(this.size));\n        err.code = 'EBADSIZE';\n        err.found = this.size;\n        err.expected = this.expectedSize;\n        err.sri = this.sri;\n        this.emit('error', err);\n      } else if (this.sri && !match) {\n        var _err = new Error(\"\".concat(this.sri, \" integrity checksum failed when using \").concat(this.algorithm, \": wanted \").concat(this.digests, \" but got \").concat(newSri, \". (\").concat(this.size, \" bytes)\"));\n\n        _err.code = 'EINTEGRITY';\n        _err.found = newSri;\n        _err.expected = this.digests;\n        _err.algorithm = this.algorithm;\n        _err.sri = this.sri;\n        this.emit('error', _err);\n      } else {\n        this.emit('size', this.size);\n        this.emit('integrity', newSri);\n        match && this.emit('verified', match);\n      }\n    }\n  }]);\n\n  return IntegrityStream;\n}(MiniPass);\n\nvar Hash = /*#__PURE__*/function () {\n  function Hash(hash, opts) {\n    _classCallCheck(this, Hash);\n\n    opts = ssriOpts(opts);\n    var strict = !!opts.strict;\n    this.source = hash.trim(); // set default values so that we make V8 happy to\n    // always see a familiar object template.\n\n    this.digest = '';\n    this.algorithm = '';\n    this.options = []; // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n\n    var match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n\n    if (!match) {\n      return;\n    }\n\n    if (strict && !SPEC_ALGORITHMS.some(function (a) {\n      return a === match[1];\n    })) {\n      return;\n    }\n\n    this.algorithm = match[1];\n    this.digest = match[2];\n    var rawOpts = match[3];\n\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?');\n    }\n  }\n\n  _createClass(Hash, [{\n    key: \"isHash\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"hexDigest\",\n    value: function hexDigest() {\n      return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(opts) {\n      var _this3 = this;\n\n      opts = ssriOpts(opts);\n\n      if (opts.strict) {\n        // Strict mode enforces the standard as close to the foot of the\n        // letter as it can.\n        if (!( // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(function (x) {\n          return x === _this3.algorithm;\n        }) && // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        this.options.every(function (opt) {\n          return opt.match(VCHAR_REGEX);\n        }))) {\n          return '';\n        }\n      }\n\n      var options = this.options && this.options.length ? \"?\".concat(this.options.join('?')) : '';\n      return \"\".concat(this.algorithm, \"-\").concat(this.digest).concat(options);\n    }\n  }]);\n\n  return Hash;\n}();\n\nvar Integrity = /*#__PURE__*/function () {\n  function Integrity() {\n    _classCallCheck(this, Integrity);\n  }\n\n  _createClass(Integrity, [{\n    key: \"isIntegrity\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString();\n    }\n  }, {\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return Object.keys(this).length === 0;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(opts) {\n      var _this4 = this;\n\n      opts = ssriOpts(opts);\n      var sep = opts.sep || ' ';\n\n      if (opts.strict) {\n        // Entries must be separated by whitespace, according to spec.\n        sep = sep.replace(/\\S+/g, ' ');\n      }\n\n      return Object.keys(this).map(function (k) {\n        return _this4[k].map(function (hash) {\n          return Hash.prototype.toString.call(hash, opts);\n        }).filter(function (x) {\n          return x.length;\n        }).join(sep);\n      }).filter(function (x) {\n        return x.length;\n      }).join(sep);\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(integrity, opts) {\n      opts = ssriOpts(opts);\n      var other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n      return parse(\"\".concat(this.toString(opts), \" \").concat(other), opts);\n    }\n  }, {\n    key: \"hexDigest\",\n    value: function hexDigest() {\n      return parse(this, {\n        single: true\n      }).hexDigest();\n    } // add additional hashes to an integrity value, but prevent\n    // *changing* an existing integrity hash.\n\n  }, {\n    key: \"merge\",\n    value: function merge(integrity, opts) {\n      var _this5 = this;\n\n      opts = ssriOpts(opts);\n      var other = parse(integrity, opts);\n\n      var _loop = function _loop(algo) {\n        if (_this5[algo]) {\n          if (!_this5[algo].find(function (hash) {\n            return other[algo].find(function (otherhash) {\n              return hash.digest === otherhash.digest;\n            });\n          })) {\n            throw new Error('hashes do not match, cannot update integrity');\n          }\n        } else {\n          _this5[algo] = other[algo];\n        }\n      };\n\n      for (var algo in other) {\n        _loop(algo);\n      }\n    }\n  }, {\n    key: \"match\",\n    value: function match(integrity, opts) {\n      opts = ssriOpts(opts);\n      var other = parse(integrity, opts);\n      var algo = other.pickAlgorithm(opts);\n      return this[algo] && other[algo] && this[algo].find(function (hash) {\n        return other[algo].find(function (otherhash) {\n          return hash.digest === otherhash.digest;\n        });\n      }) || false;\n    }\n  }, {\n    key: \"pickAlgorithm\",\n    value: function pickAlgorithm(opts) {\n      opts = ssriOpts(opts);\n      var pickAlgorithm = opts.pickAlgorithm;\n      var keys = Object.keys(this);\n      return keys.reduce(function (acc, algo) {\n        return pickAlgorithm(acc, algo) || acc;\n      });\n    }\n  }]);\n\n  return Integrity;\n}();\n\nmodule.exports.parse = parse;\n\nfunction parse(sri, opts) {\n  if (!sri) return null;\n  opts = ssriOpts(opts);\n\n  if (typeof sri === 'string') {\n    return _parse(sri, opts);\n  } else if (sri.algorithm && sri.digest) {\n    var fullSri = new Integrity();\n    fullSri[sri.algorithm] = [sri];\n    return _parse(stringify(fullSri, opts), opts);\n  } else {\n    return _parse(stringify(sri, opts), opts);\n  }\n}\n\nfunction _parse(integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts);\n  }\n\n  var hashes = integrity.trim().split(/\\s+/).reduce(function (acc, string) {\n    var hash = new Hash(string, opts);\n\n    if (hash.algorithm && hash.digest) {\n      var algo = hash.algorithm;\n\n      if (!acc[algo]) {\n        acc[algo] = [];\n      }\n\n      acc[algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n  return hashes.isEmpty() ? null : hashes;\n}\n\nmodule.exports.stringify = stringify;\n\nfunction stringify(obj, opts) {\n  opts = ssriOpts(opts);\n\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts);\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts);\n  } else {\n    return Integrity.prototype.toString.call(obj, opts);\n  }\n}\n\nmodule.exports.fromHex = fromHex;\n\nfunction fromHex(hexDigest, algorithm, opts) {\n  opts = ssriOpts(opts);\n  var optString = getOptString(opts.options);\n  return parse(\"\".concat(algorithm, \"-\").concat(Buffer.from(hexDigest, 'hex').toString('base64')).concat(optString), opts);\n}\n\nmodule.exports.fromData = fromData;\n\nfunction fromData(data, opts) {\n  opts = ssriOpts(opts);\n  var algorithms = opts.algorithms;\n  var optString = getOptString(opts.options);\n  return algorithms.reduce(function (acc, algo) {\n    var digest = crypto.createHash(algo).update(data).digest('base64');\n    var hash = new Hash(\"\".concat(algo, \"-\").concat(digest).concat(optString), opts);\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n\n    if (hash.algorithm && hash.digest) {\n      var _algo = hash.algorithm;\n\n      if (!acc[_algo]) {\n        acc[_algo] = [];\n      }\n\n      acc[_algo].push(hash);\n    }\n\n    return acc;\n  }, new Integrity());\n}\n\nmodule.exports.fromStream = fromStream;\n\nfunction fromStream(stream, opts) {\n  opts = ssriOpts(opts);\n  var istream = integrityStream(opts);\n  return new Promise(function (resolve, reject) {\n    stream.pipe(istream);\n    stream.on('error', reject);\n    istream.on('error', reject);\n    var sri;\n    istream.on('integrity', function (s) {\n      sri = s;\n    });\n    istream.on('end', function () {\n      return resolve(sri);\n    });\n    istream.on('data', function () {});\n  });\n}\n\nmodule.exports.checkData = checkData;\n\nfunction checkData(data, sri, opts) {\n  opts = ssriOpts(opts);\n  sri = parse(sri, opts);\n\n  if (!sri || !Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      });\n    } else {\n      return false;\n    }\n  }\n\n  var algorithm = sri.pickAlgorithm(opts);\n  var digest = crypto.createHash(algorithm).update(data).digest('base64');\n  var newSri = parse({\n    algorithm: algorithm,\n    digest: digest\n  });\n  var match = newSri.match(sri, opts);\n\n  if (match || !opts.error) {\n    return match;\n  } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n    var err = new Error(\"data size mismatch when checking \".concat(sri, \".\\n  Wanted: \").concat(opts.size, \"\\n  Found: \").concat(data.length));\n    err.code = 'EBADSIZE';\n    err.found = data.length;\n    err.expected = opts.size;\n    err.sri = sri;\n    throw err;\n  } else {\n    var _err2 = new Error(\"Integrity checksum failed when using \".concat(algorithm, \": Wanted \").concat(sri, \", but got \").concat(newSri, \". (\").concat(data.length, \" bytes)\"));\n\n    _err2.code = 'EINTEGRITY';\n    _err2.found = newSri;\n    _err2.expected = sri;\n    _err2.algorithm = algorithm;\n    _err2.sri = sri;\n    throw _err2;\n  }\n}\n\nmodule.exports.checkStream = checkStream;\n\nfunction checkStream(stream, sri, opts) {\n  opts = ssriOpts(opts);\n  opts.integrity = sri;\n  sri = parse(sri, opts);\n\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(new Error('No valid integrity hashes to check against'), {\n      code: 'EINTEGRITY'\n    }));\n  }\n\n  var checker = integrityStream(opts);\n  return new Promise(function (resolve, reject) {\n    stream.pipe(checker);\n    stream.on('error', reject);\n    checker.on('error', reject);\n    var sri;\n    checker.on('verified', function (s) {\n      sri = s;\n    });\n    checker.on('end', function () {\n      return resolve(sri);\n    });\n    checker.on('data', function () {});\n  });\n}\n\nmodule.exports.integrityStream = integrityStream;\n\nfunction integrityStream() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new IntegrityStream(opts);\n}\n\nmodule.exports.create = createIntegrity;\n\nfunction createIntegrity(opts) {\n  opts = ssriOpts(opts);\n  var algorithms = opts.algorithms;\n  var optString = getOptString(opts.options);\n  var hashes = algorithms.map(crypto.createHash);\n  return {\n    update: function update(chunk, enc) {\n      hashes.forEach(function (h) {\n        return h.update(chunk, enc);\n      });\n      return this;\n    },\n    digest: function digest(enc) {\n      var integrity = algorithms.reduce(function (acc, algo) {\n        var digest = hashes.shift().digest('base64');\n        var hash = new Hash(\"\".concat(algo, \"-\").concat(digest).concat(optString), opts);\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n\n        if (hash.algorithm && hash.digest) {\n          var _algo2 = hash.algorithm;\n\n          if (!acc[_algo2]) {\n            acc[_algo2] = [];\n          }\n\n          acc[_algo2].push(hash);\n        }\n\n        return acc;\n      }, new Integrity());\n      return integrity;\n    }\n  };\n}\n\nvar NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos\n\nvar DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name\n//        for the algorithm, so we guesswork it based on the OpenSSL names.\n'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(function (algo) {\n  return NODE_HASHES.has(algo);\n});\n\nfunction getPrioritizedHash(algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/ssri/index.js"],"names":["crypto","require","MiniPass","SPEC_ALGORITHMS","BASE64_REGEX","SRI_REGEX","STRICT_SRI_REGEX","VCHAR_REGEX","defaultOpts","algorithms","error","options","pickAlgorithm","getPrioritizedHash","sep","single","strict","ssriOpts","opts","getOptString","length","join","_onEnd","Symbol","_getOptions","IntegrityStream","size","Array","from","Set","concat","algorithm","hashes","map","createHash","integrity","sri","parse","expectedSize","goodSri","Object","keys","digests","optString","ev","data","forEach","h","update","newSri","i","digest","match","err","Error","code","found","expected","emit","Hash","hash","source","trim","some","a","rawOpts","slice","split","Buffer","toString","x","every","opt","Integrity","replace","k","prototype","call","filter","other","stringify","hexDigest","algo","find","otherhash","reduce","acc","module","exports","_parse","fullSri","string","push","isEmpty","obj","fromHex","fromData","fromStream","stream","istream","integrityStream","Promise","resolve","reject","pipe","on","s","checkData","assign","checkStream","checker","create","createIntegrity","chunk","enc","shift","NODE_HASHES","getHashes","DEFAULT_PRIORITY","has","algo1","algo2","indexOf","toLowerCase"],"mappings":"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","sourcesContent":["'use strict'\n\nconst crypto = require('crypto')\nconst MiniPass = require('minipass')\n\nconst SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512']\n\n// TODO: this should really be a hardcoded list of algorithms we support,\n// rather than [a-z0-9].\nconst BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i\nconst SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\\S*]*)$/\nconst STRICT_SRI_REGEX = /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)?$/\nconst VCHAR_REGEX = /^[\\x21-\\x7E]+$/\n\nconst defaultOpts = {\n  algorithms: ['sha512'],\n  error: false,\n  options: [],\n  pickAlgorithm: getPrioritizedHash,\n  sep: ' ',\n  single: false,\n  strict: false\n}\n\nconst ssriOpts = (opts = {}) => ({ ...defaultOpts, ...opts })\n\nconst getOptString = options => !options || !options.length\n  ? ''\n  : `?${options.join('?')}`\n\nconst _onEnd = Symbol('_onEnd')\nconst _getOptions = Symbol('_getOptions')\nclass IntegrityStream extends MiniPass {\n  constructor (opts) {\n    super()\n    this.size = 0\n    this.opts = opts\n\n    // may be overridden later, but set now for class consistency\n    this[_getOptions]()\n\n    // options used for calculating stream.  can't be changed.\n    const { algorithms = defaultOpts.algorithms } = opts\n    this.algorithms = Array.from(\n      new Set(algorithms.concat(this.algorithm ? [this.algorithm] : []))\n    )\n    this.hashes = this.algorithms.map(crypto.createHash)\n  }\n\n  [_getOptions] () {\n    const {\n      integrity,\n      size,\n      options\n    } = { ...defaultOpts, ...this.opts }\n\n    // For verification\n    this.sri = integrity ? parse(integrity, this.opts) : null\n    this.expectedSize = size\n    this.goodSri = this.sri ? !!Object.keys(this.sri).length : false\n    this.algorithm = this.goodSri ? this.sri.pickAlgorithm(this.opts) : null\n    this.digests = this.goodSri ? this.sri[this.algorithm] : null\n    this.optString = getOptString(options)\n  }\n\n  emit (ev, data) {\n    if (ev === 'end') this[_onEnd]()\n    return super.emit(ev, data)\n  }\n\n  write (data) {\n    this.size += data.length\n    this.hashes.forEach(h => h.update(data))\n    return super.write(data)\n  }\n\n  [_onEnd] () {\n    if (!this.goodSri) {\n      this[_getOptions]()\n    }\n    const newSri = parse(this.hashes.map((h, i) => {\n      return `${this.algorithms[i]}-${h.digest('base64')}${this.optString}`\n    }).join(' '), this.opts)\n    // Integrity verification mode\n    const match = this.goodSri && newSri.match(this.sri, this.opts)\n    if (typeof this.expectedSize === 'number' && this.size !== this.expectedSize) {\n      const err = new Error(`stream size mismatch when checking ${this.sri}.\\n  Wanted: ${this.expectedSize}\\n  Found: ${this.size}`)\n      err.code = 'EBADSIZE'\n      err.found = this.size\n      err.expected = this.expectedSize\n      err.sri = this.sri\n      this.emit('error', err)\n    } else if (this.sri && !match) {\n      const err = new Error(`${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`)\n      err.code = 'EINTEGRITY'\n      err.found = newSri\n      err.expected = this.digests\n      err.algorithm = this.algorithm\n      err.sri = this.sri\n      this.emit('error', err)\n    } else {\n      this.emit('size', this.size)\n      this.emit('integrity', newSri)\n      match && this.emit('verified', match)\n    }\n  }\n}\n\nclass Hash {\n  get isHash () { return true }\n  constructor (hash, opts) {\n    opts = ssriOpts(opts)\n    const strict = !!opts.strict\n    this.source = hash.trim()\n\n    // set default values so that we make V8 happy to\n    // always see a familiar object template.\n    this.digest = ''\n    this.algorithm = ''\n    this.options = []\n\n    // 3.1. Integrity metadata (called \"Hash\" by ssri)\n    // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n    const match = this.source.match(\n      strict\n        ? STRICT_SRI_REGEX\n        : SRI_REGEX\n    )\n    if (!match) { return }\n    if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) { return }\n    this.algorithm = match[1]\n    this.digest = match[2]\n\n    const rawOpts = match[3]\n    if (rawOpts) {\n      this.options = rawOpts.slice(1).split('?')\n    }\n  }\n\n  hexDigest () {\n    return this.digest && Buffer.from(this.digest, 'base64').toString('hex')\n  }\n\n  toJSON () {\n    return this.toString()\n  }\n\n  toString (opts) {\n    opts = ssriOpts(opts)\n    if (opts.strict) {\n      // Strict mode enforces the standard as close to the foot of the\n      // letter as it can.\n      if (!(\n        // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) &&\n        // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) &&\n        // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        this.options.every(opt => opt.match(VCHAR_REGEX))\n      )) {\n        return ''\n      }\n    }\n    const options = this.options && this.options.length\n      ? `?${this.options.join('?')}`\n      : ''\n    return `${this.algorithm}-${this.digest}${options}`\n  }\n}\n\nclass Integrity {\n  get isIntegrity () { return true }\n  toJSON () {\n    return this.toString()\n  }\n\n  isEmpty () {\n    return Object.keys(this).length === 0\n  }\n\n  toString (opts) {\n    opts = ssriOpts(opts)\n    let sep = opts.sep || ' '\n    if (opts.strict) {\n      // Entries must be separated by whitespace, according to spec.\n      sep = sep.replace(/\\S+/g, ' ')\n    }\n    return Object.keys(this).map(k => {\n      return this[k].map(hash => {\n        return Hash.prototype.toString.call(hash, opts)\n      }).filter(x => x.length).join(sep)\n    }).filter(x => x.length).join(sep)\n  }\n\n  concat (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = typeof integrity === 'string'\n      ? integrity\n      : stringify(integrity, opts)\n    return parse(`${this.toString(opts)} ${other}`, opts)\n  }\n\n  hexDigest () {\n    return parse(this, { single: true }).hexDigest()\n  }\n\n  // add additional hashes to an integrity value, but prevent\n  // *changing* an existing integrity hash.\n  merge (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = parse(integrity, opts)\n    for (const algo in other) {\n      if (this[algo]) {\n        if (!this[algo].find(hash =>\n          other[algo].find(otherhash =>\n            hash.digest === otherhash.digest))) {\n          throw new Error('hashes do not match, cannot update integrity')\n        }\n      } else {\n        this[algo] = other[algo]\n      }\n    }\n  }\n\n  match (integrity, opts) {\n    opts = ssriOpts(opts)\n    const other = parse(integrity, opts)\n    const algo = other.pickAlgorithm(opts)\n    return (\n      this[algo] &&\n      other[algo] &&\n      this[algo].find(hash =>\n        other[algo].find(otherhash =>\n          hash.digest === otherhash.digest\n        )\n      )\n    ) || false\n  }\n\n  pickAlgorithm (opts) {\n    opts = ssriOpts(opts)\n    const pickAlgorithm = opts.pickAlgorithm\n    const keys = Object.keys(this)\n    return keys.reduce((acc, algo) => {\n      return pickAlgorithm(acc, algo) || acc\n    })\n  }\n}\n\nmodule.exports.parse = parse\nfunction parse (sri, opts) {\n  if (!sri) return null\n  opts = ssriOpts(opts)\n  if (typeof sri === 'string') {\n    return _parse(sri, opts)\n  } else if (sri.algorithm && sri.digest) {\n    const fullSri = new Integrity()\n    fullSri[sri.algorithm] = [sri]\n    return _parse(stringify(fullSri, opts), opts)\n  } else {\n    return _parse(stringify(sri, opts), opts)\n  }\n}\n\nfunction _parse (integrity, opts) {\n  // 3.4.3. Parse metadata\n  // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n  if (opts.single) {\n    return new Hash(integrity, opts)\n  }\n  const hashes = integrity.trim().split(/\\s+/).reduce((acc, string) => {\n    const hash = new Hash(string, opts)\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n  return hashes.isEmpty() ? null : hashes\n}\n\nmodule.exports.stringify = stringify\nfunction stringify (obj, opts) {\n  opts = ssriOpts(opts)\n  if (obj.algorithm && obj.digest) {\n    return Hash.prototype.toString.call(obj, opts)\n  } else if (typeof obj === 'string') {\n    return stringify(parse(obj, opts), opts)\n  } else {\n    return Integrity.prototype.toString.call(obj, opts)\n  }\n}\n\nmodule.exports.fromHex = fromHex\nfunction fromHex (hexDigest, algorithm, opts) {\n  opts = ssriOpts(opts)\n  const optString = getOptString(opts.options)\n  return parse(\n    `${algorithm}-${\n      Buffer.from(hexDigest, 'hex').toString('base64')\n    }${optString}`, opts\n  )\n}\n\nmodule.exports.fromData = fromData\nfunction fromData (data, opts) {\n  opts = ssriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = getOptString(opts.options)\n  return algorithms.reduce((acc, algo) => {\n    const digest = crypto.createHash(algo).update(data).digest('base64')\n    const hash = new Hash(\n      `${algo}-${digest}${optString}`,\n      opts\n    )\n    /* istanbul ignore else - it would be VERY strange if the string we\n     * just calculated with an algo did not have an algo or digest.\n     */\n    if (hash.algorithm && hash.digest) {\n      const algo = hash.algorithm\n      if (!acc[algo]) { acc[algo] = [] }\n      acc[algo].push(hash)\n    }\n    return acc\n  }, new Integrity())\n}\n\nmodule.exports.fromStream = fromStream\nfunction fromStream (stream, opts) {\n  opts = ssriOpts(opts)\n  const istream = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(istream)\n    stream.on('error', reject)\n    istream.on('error', reject)\n    let sri\n    istream.on('integrity', s => { sri = s })\n    istream.on('end', () => resolve(sri))\n    istream.on('data', () => {})\n  })\n}\n\nmodule.exports.checkData = checkData\nfunction checkData (data, sri, opts) {\n  opts = ssriOpts(opts)\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    if (opts.error) {\n      throw Object.assign(\n        new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        }\n      )\n    } else {\n      return false\n    }\n  }\n  const algorithm = sri.pickAlgorithm(opts)\n  const digest = crypto.createHash(algorithm).update(data).digest('base64')\n  const newSri = parse({ algorithm, digest })\n  const match = newSri.match(sri, opts)\n  if (match || !opts.error) {\n    return match\n  } else if (typeof opts.size === 'number' && (data.length !== opts.size)) {\n    const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`)\n    err.code = 'EBADSIZE'\n    err.found = data.length\n    err.expected = opts.size\n    err.sri = sri\n    throw err\n  } else {\n    const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`)\n    err.code = 'EINTEGRITY'\n    err.found = newSri\n    err.expected = sri\n    err.algorithm = algorithm\n    err.sri = sri\n    throw err\n  }\n}\n\nmodule.exports.checkStream = checkStream\nfunction checkStream (stream, sri, opts) {\n  opts = ssriOpts(opts)\n  opts.integrity = sri\n  sri = parse(sri, opts)\n  if (!sri || !Object.keys(sri).length) {\n    return Promise.reject(Object.assign(\n      new Error('No valid integrity hashes to check against'), {\n        code: 'EINTEGRITY'\n      }\n    ))\n  }\n  const checker = integrityStream(opts)\n  return new Promise((resolve, reject) => {\n    stream.pipe(checker)\n    stream.on('error', reject)\n    checker.on('error', reject)\n    let sri\n    checker.on('verified', s => { sri = s })\n    checker.on('end', () => resolve(sri))\n    checker.on('data', () => {})\n  })\n}\n\nmodule.exports.integrityStream = integrityStream\nfunction integrityStream (opts = {}) {\n  return new IntegrityStream(opts)\n}\n\nmodule.exports.create = createIntegrity\nfunction createIntegrity (opts) {\n  opts = ssriOpts(opts)\n  const algorithms = opts.algorithms\n  const optString = getOptString(opts.options)\n\n  const hashes = algorithms.map(crypto.createHash)\n\n  return {\n    update: function (chunk, enc) {\n      hashes.forEach(h => h.update(chunk, enc))\n      return this\n    },\n    digest: function (enc) {\n      const integrity = algorithms.reduce((acc, algo) => {\n        const digest = hashes.shift().digest('base64')\n        const hash = new Hash(\n          `${algo}-${digest}${optString}`,\n          opts\n        )\n        /* istanbul ignore else - it would be VERY strange if the hash we\n         * just calculated with an algo did not have an algo or digest.\n         */\n        if (hash.algorithm && hash.digest) {\n          const algo = hash.algorithm\n          if (!acc[algo]) { acc[algo] = [] }\n          acc[algo].push(hash)\n        }\n        return acc\n      }, new Integrity())\n\n      return integrity\n    }\n  }\n}\n\nconst NODE_HASHES = new Set(crypto.getHashes())\n\n// This is a Best Effort™ at a reasonable priority for hash algos\nconst DEFAULT_PRIORITY = [\n  'md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512',\n  // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3',\n  'sha3-256', 'sha3-384', 'sha3-512',\n  'sha3_256', 'sha3_384', 'sha3_512'\n].filter(algo => NODE_HASHES.has(algo))\n\nfunction getPrioritizedHash (algo1, algo2) {\n  return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())\n    ? algo1\n    : algo2\n}\n"]},"metadata":{},"sourceType":"script"}