{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceCoverage = void 0;\n\nvar _istanbulLibCoverage = require(\"istanbul-lib-coverage\");\n\nfunction cloneLocation(loc) {\n  return {\n    start: {\n      line: loc && loc.start.line,\n      column: loc && loc.start.column\n    },\n    end: {\n      line: loc && loc.end.line,\n      column: loc && loc.end.column\n    }\n  };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\n\n\nvar SourceCoverage = /*#__PURE__*/function (_istanbulLibCoverage$) {\n  _inherits(SourceCoverage, _istanbulLibCoverage$);\n\n  var _super = _createSuper(SourceCoverage);\n\n  function SourceCoverage(pathOrObj) {\n    var _this;\n\n    _classCallCheck(this, SourceCoverage);\n\n    _this = _super.call(this, pathOrObj);\n    _this.meta = {\n      last: {\n        s: 0,\n        f: 0,\n        b: 0\n      }\n    };\n    return _this;\n  }\n\n  _createClass(SourceCoverage, [{\n    key: \"newStatement\",\n    value: function newStatement(loc) {\n      var s = this.meta.last.s;\n      this.data.statementMap[s] = cloneLocation(loc);\n      this.data.s[s] = 0;\n      this.meta.last.s += 1;\n      return s;\n    }\n  }, {\n    key: \"newFunction\",\n    value: function newFunction(name, decl, loc) {\n      var f = this.meta.last.f;\n      name = name || '(anonymous_' + f + ')';\n      this.data.fnMap[f] = {\n        name: name,\n        decl: cloneLocation(decl),\n        loc: cloneLocation(loc),\n        // DEPRECATED: some legacy reports require this info.\n        line: loc && loc.start.line\n      };\n      this.data.f[f] = 0;\n      this.meta.last.f += 1;\n      return f;\n    }\n  }, {\n    key: \"newBranch\",\n    value: function newBranch(type, loc) {\n      var b = this.meta.last.b;\n      this.data.b[b] = [];\n      this.data.branchMap[b] = {\n        loc: cloneLocation(loc),\n        type: type,\n        locations: [],\n        // DEPRECATED: some legacy reports require this info.\n        line: loc && loc.start.line\n      };\n      this.meta.last.b += 1;\n      return b;\n    }\n  }, {\n    key: \"addBranchPath\",\n    value: function addBranchPath(name, location) {\n      var bMeta = this.data.branchMap[name];\n      var counts = this.data.b[name];\n      /* istanbul ignore if: paranoid check */\n\n      if (!bMeta) {\n        throw new Error('Invalid branch ' + name);\n      }\n\n      bMeta.locations.push(cloneLocation(location));\n      counts.push(0);\n      return counts.length - 1;\n    }\n    /**\n     * Assigns an input source map to the coverage that can be used\n     * to remap the coverage output to the original source\n     * @param sourceMap {object} the source map\n     */\n\n  }, {\n    key: \"inputSourceMap\",\n    value: function inputSourceMap(sourceMap) {\n      this.data.inputSourceMap = sourceMap;\n    }\n  }, {\n    key: \"freeze\",\n    value: function freeze() {\n      // prune empty branches\n      var map = this.data.branchMap;\n      var branches = this.data.b;\n      Object.keys(map).forEach(function (b) {\n        if (map[b].locations.length === 0) {\n          delete map[b];\n          delete branches[b];\n        }\n      });\n    }\n  }]);\n\n  return SourceCoverage;\n}(_istanbulLibCoverage.classes.FileCoverage);\n\nexports.SourceCoverage = SourceCoverage;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/istanbul-lib-instrument/dist/source-coverage.js"],"names":["Object","defineProperty","exports","value","SourceCoverage","_istanbulLibCoverage","require","cloneLocation","loc","start","line","column","end","pathOrObj","meta","last","s","f","b","data","statementMap","name","decl","fnMap","type","branchMap","locations","location","bMeta","counts","Error","push","length","sourceMap","inputSourceMap","map","branches","keys","forEach","classes","FileCoverage"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SourceCoverage = void 0;\n\nvar _istanbulLibCoverage = require(\"istanbul-lib-coverage\");\n\nfunction cloneLocation(loc) {\n  return {\n    start: {\n      line: loc && loc.start.line,\n      column: loc && loc.start.column\n    },\n    end: {\n      line: loc && loc.end.line,\n      column: loc && loc.end.column\n    }\n  };\n}\n/**\n * SourceCoverage provides mutation methods to manipulate the structure of\n * a file coverage object. Used by the instrumenter to create a full coverage\n * object for a file incrementally.\n *\n * @private\n * @param pathOrObj {String|Object} - see the argument for {@link FileCoverage}\n * @extends FileCoverage\n * @constructor\n */\n\n\nclass SourceCoverage extends _istanbulLibCoverage.classes.FileCoverage {\n  constructor(pathOrObj) {\n    super(pathOrObj);\n    this.meta = {\n      last: {\n        s: 0,\n        f: 0,\n        b: 0\n      }\n    };\n  }\n\n  newStatement(loc) {\n    const s = this.meta.last.s;\n    this.data.statementMap[s] = cloneLocation(loc);\n    this.data.s[s] = 0;\n    this.meta.last.s += 1;\n    return s;\n  }\n\n  newFunction(name, decl, loc) {\n    const f = this.meta.last.f;\n    name = name || '(anonymous_' + f + ')';\n    this.data.fnMap[f] = {\n      name,\n      decl: cloneLocation(decl),\n      loc: cloneLocation(loc),\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.data.f[f] = 0;\n    this.meta.last.f += 1;\n    return f;\n  }\n\n  newBranch(type, loc) {\n    const b = this.meta.last.b;\n    this.data.b[b] = [];\n    this.data.branchMap[b] = {\n      loc: cloneLocation(loc),\n      type,\n      locations: [],\n      // DEPRECATED: some legacy reports require this info.\n      line: loc && loc.start.line\n    };\n    this.meta.last.b += 1;\n    return b;\n  }\n\n  addBranchPath(name, location) {\n    const bMeta = this.data.branchMap[name];\n    const counts = this.data.b[name];\n    /* istanbul ignore if: paranoid check */\n\n    if (!bMeta) {\n      throw new Error('Invalid branch ' + name);\n    }\n\n    bMeta.locations.push(cloneLocation(location));\n    counts.push(0);\n    return counts.length - 1;\n  }\n  /**\n   * Assigns an input source map to the coverage that can be used\n   * to remap the coverage output to the original source\n   * @param sourceMap {object} the source map\n   */\n\n\n  inputSourceMap(sourceMap) {\n    this.data.inputSourceMap = sourceMap;\n  }\n\n  freeze() {\n    // prune empty branches\n    const map = this.data.branchMap;\n    const branches = this.data.b;\n    Object.keys(map).forEach(b => {\n      if (map[b].locations.length === 0) {\n        delete map[b];\n        delete branches[b];\n      }\n    });\n  }\n\n}\n\nexports.SourceCoverage = SourceCoverage;"]},"metadata":{},"sourceType":"script"}