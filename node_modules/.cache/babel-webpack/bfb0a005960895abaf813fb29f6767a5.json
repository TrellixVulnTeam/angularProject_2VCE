{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/reflection/src/type_to_value\", [\"require\", \"exports\", \"tslib\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.typeNodeToValueExpr = exports.typeToValue = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n  /**\n   * Potentially convert a `ts.TypeNode` to a `TypeValueReference`, which indicates how to use the\n   * type given in the `ts.TypeNode` in a value position.\n   *\n   * This can return `null` if the `typeNode` is `null`, if it does not refer to a symbol with a value\n   * declaration, or if it is not possible to statically understand.\n   */\n\n\n  function typeToValue(typeNode, checker) {\n    // It's not possible to get a value expression if the parameter doesn't even have a type.\n    if (typeNode === null) {\n      return missingType();\n    }\n\n    if (!ts.isTypeReferenceNode(typeNode)) {\n      return unsupportedType(typeNode);\n    }\n\n    var symbols = resolveTypeSymbols(typeNode, checker);\n\n    if (symbols === null) {\n      return unknownReference(typeNode);\n    }\n\n    var local = symbols.local,\n        decl = symbols.decl; // It's only valid to convert a type reference to a value reference if the type actually\n    // has a value declaration associated with it. Note that const enums are an exception,\n    // because while they do have a value declaration, they don't exist at runtime.\n\n    if (decl.valueDeclaration === undefined || decl.flags & ts.SymbolFlags.ConstEnum) {\n      var typeOnlyDecl = null;\n\n      if (decl.declarations !== undefined && decl.declarations.length > 0) {\n        typeOnlyDecl = decl.declarations[0];\n      }\n\n      return noValueDeclaration(typeNode, typeOnlyDecl);\n    } // The type points to a valid value declaration. Rewrite the TypeReference into an\n    // Expression which references the value pointed to by the TypeReference, if possible.\n    // Look at the local `ts.Symbol`'s declarations and see if it comes from an import\n    // statement. If so, extract the module specifier and the name of the imported type.\n\n\n    var firstDecl = local.declarations && local.declarations[0];\n\n    if (firstDecl !== undefined) {\n      if (ts.isImportClause(firstDecl) && firstDecl.name !== undefined) {\n        // This is a default import.\n        //   import Foo from 'foo';\n        if (firstDecl.isTypeOnly) {\n          // Type-only imports cannot be represented as value.\n          return typeOnlyImport(typeNode, firstDecl);\n        }\n\n        return {\n          kind: 0\n          /* LOCAL */\n          ,\n          expression: firstDecl.name,\n          defaultImportStatement: firstDecl.parent\n        };\n      } else if (ts.isImportSpecifier(firstDecl)) {\n        // The symbol was imported by name\n        //   import {Foo} from 'foo';\n        // or\n        //   import {Foo as Bar} from 'foo';\n        if (firstDecl.parent.parent.isTypeOnly) {\n          // Type-only imports cannot be represented as value.\n          return typeOnlyImport(typeNode, firstDecl.parent.parent);\n        } // Determine the name to import (`Foo`) from the import specifier, as the symbol names of\n        // the imported type could refer to a local alias (like `Bar` in the example above).\n\n\n        var importedName = (firstDecl.propertyName || firstDecl.name).text; // The first symbol name refers to the local name, which is replaced by `importedName` above.\n        // Any remaining symbol names make up the complete path to the value.\n\n        var _a = tslib_1.__read(symbols.symbolNames),\n            _localName = _a[0],\n            nestedPath = _a.slice(1);\n\n        var moduleName = extractModuleName(firstDecl.parent.parent.parent);\n        return {\n          kind: 1\n          /* IMPORTED */\n          ,\n          valueDeclaration: decl.valueDeclaration,\n          moduleName: moduleName,\n          importedName: importedName,\n          nestedPath: nestedPath\n        };\n      } else if (ts.isNamespaceImport(firstDecl)) {\n        // The import is a namespace import\n        //   import * as Foo from 'foo';\n        if (firstDecl.parent.isTypeOnly) {\n          // Type-only imports cannot be represented as value.\n          return typeOnlyImport(typeNode, firstDecl.parent);\n        }\n\n        if (symbols.symbolNames.length === 1) {\n          // The type refers to the namespace itself, which cannot be represented as a value.\n          return namespaceImport(typeNode, firstDecl.parent);\n        } // The first symbol name refers to the local name of the namespace, which is is discarded\n        // as a new namespace import will be generated. This is followed by the symbol name that needs\n        // to be imported and any remaining names that constitute the complete path to the value.\n\n\n        var _b = tslib_1.__read(symbols.symbolNames),\n            _ns = _b[0],\n            importedName = _b[1],\n            nestedPath = _b.slice(2);\n\n        var moduleName = extractModuleName(firstDecl.parent.parent);\n        return {\n          kind: 1\n          /* IMPORTED */\n          ,\n          valueDeclaration: decl.valueDeclaration,\n          moduleName: moduleName,\n          importedName: importedName,\n          nestedPath: nestedPath\n        };\n      }\n    } // If the type is not imported, the type reference can be converted into an expression as is.\n\n\n    var expression = typeNodeToValueExpr(typeNode);\n\n    if (expression !== null) {\n      return {\n        kind: 0\n        /* LOCAL */\n        ,\n        expression: expression,\n        defaultImportStatement: null\n      };\n    } else {\n      return unsupportedType(typeNode);\n    }\n  }\n\n  exports.typeToValue = typeToValue;\n\n  function unsupportedType(typeNode) {\n    return {\n      kind: 2\n      /* UNAVAILABLE */\n      ,\n      reason: {\n        kind: 5\n        /* UNSUPPORTED */\n        ,\n        typeNode: typeNode\n      }\n    };\n  }\n\n  function noValueDeclaration(typeNode, decl) {\n    return {\n      kind: 2\n      /* UNAVAILABLE */\n      ,\n      reason: {\n        kind: 1\n        /* NO_VALUE_DECLARATION */\n        ,\n        typeNode: typeNode,\n        decl: decl\n      }\n    };\n  }\n\n  function typeOnlyImport(typeNode, importClause) {\n    return {\n      kind: 2\n      /* UNAVAILABLE */\n      ,\n      reason: {\n        kind: 2\n        /* TYPE_ONLY_IMPORT */\n        ,\n        typeNode: typeNode,\n        importClause: importClause\n      }\n    };\n  }\n\n  function unknownReference(typeNode) {\n    return {\n      kind: 2\n      /* UNAVAILABLE */\n      ,\n      reason: {\n        kind: 3\n        /* UNKNOWN_REFERENCE */\n        ,\n        typeNode: typeNode\n      }\n    };\n  }\n\n  function namespaceImport(typeNode, importClause) {\n    return {\n      kind: 2\n      /* UNAVAILABLE */\n      ,\n      reason: {\n        kind: 4\n        /* NAMESPACE */\n        ,\n        typeNode: typeNode,\n        importClause: importClause\n      }\n    };\n  }\n\n  function missingType() {\n    return {\n      kind: 2\n      /* UNAVAILABLE */\n      ,\n      reason: {\n        kind: 0\n        /* MISSING_TYPE */\n\n      }\n    };\n  }\n  /**\n   * Attempt to extract a `ts.Expression` that's equivalent to a `ts.TypeNode`, as the two have\n   * different AST shapes but can reference the same symbols.\n   *\n   * This will return `null` if an equivalent expression cannot be constructed.\n   */\n\n\n  function typeNodeToValueExpr(node) {\n    if (ts.isTypeReferenceNode(node)) {\n      return entityNameToValue(node.typeName);\n    } else {\n      return null;\n    }\n  }\n\n  exports.typeNodeToValueExpr = typeNodeToValueExpr;\n  /**\n   * Resolve a `TypeReference` node to the `ts.Symbol`s for both its declaration and its local source.\n   *\n   * In the event that the `TypeReference` refers to a locally declared symbol, these will be the\n   * same. If the `TypeReference` refers to an imported symbol, then `decl` will be the fully resolved\n   * `ts.Symbol` of the referenced symbol. `local` will be the `ts.Symbol` of the `ts.Identifier`\n   * which points to the import statement by which the symbol was imported.\n   *\n   * All symbol names that make up the type reference are returned left-to-right into the\n   * `symbolNames` array, which is guaranteed to include at least one entry.\n   */\n\n  function resolveTypeSymbols(typeRef, checker) {\n    var typeName = typeRef.typeName; // typeRefSymbol is the ts.Symbol of the entire type reference.\n\n    var typeRefSymbol = checker.getSymbolAtLocation(typeName);\n\n    if (typeRefSymbol === undefined) {\n      return null;\n    } // `local` is the `ts.Symbol` for the local `ts.Identifier` for the type.\n    // If the type is actually locally declared or is imported by name, for example:\n    //   import {Foo} from './foo';\n    // then it'll be the same as `typeRefSymbol`.\n    //\n    // If the type is imported via a namespace import, for example:\n    //   import * as foo from './foo';\n    // and then referenced as:\n    //   constructor(f: foo.Foo)\n    // then `local` will be the `ts.Symbol` of `foo`, whereas `typeRefSymbol` will be the `ts.Symbol`\n    // of `foo.Foo`. This allows tracking of the import behind whatever type reference exists.\n\n\n    var local = typeRefSymbol; // Destructure a name like `foo.X.Y.Z` as follows:\n    // - in `leftMost`, the `ts.Identifier` of the left-most name (`foo`) in the qualified name.\n    //   This identifier is used to resolve the `ts.Symbol` for `local`.\n    // - in `symbolNames`, all names involved in the qualified path, or a single symbol name if the\n    //   type is not qualified.\n\n    var leftMost = typeName;\n    var symbolNames = [];\n\n    while (ts.isQualifiedName(leftMost)) {\n      symbolNames.unshift(leftMost.right.text);\n      leftMost = leftMost.left;\n    }\n\n    symbolNames.unshift(leftMost.text);\n\n    if (leftMost !== typeName) {\n      var localTmp = checker.getSymbolAtLocation(leftMost);\n\n      if (localTmp !== undefined) {\n        local = localTmp;\n      }\n    } // De-alias the top-level type reference symbol to get the symbol of the actual declaration.\n\n\n    var decl = typeRefSymbol;\n\n    if (typeRefSymbol.flags & ts.SymbolFlags.Alias) {\n      decl = checker.getAliasedSymbol(typeRefSymbol);\n    }\n\n    return {\n      local: local,\n      decl: decl,\n      symbolNames: symbolNames\n    };\n  }\n\n  function entityNameToValue(node) {\n    if (ts.isQualifiedName(node)) {\n      var left = entityNameToValue(node.left);\n      return left !== null ? ts.createPropertyAccess(left, node.right) : null;\n    } else if (ts.isIdentifier(node)) {\n      return ts.getMutableClone(node);\n    } else {\n      return null;\n    }\n  }\n\n  function extractModuleName(node) {\n    if (!ts.isStringLiteral(node.moduleSpecifier)) {\n      throw new Error('not a module specifier');\n    }\n\n    return node.moduleSpecifier.text;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/reflection/src/type_to_value.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {TypeValueReference, TypeValueReferenceKind, UnavailableTypeValueReference, ValueUnavailableKind} from './host';\n\n/**\n * Potentially convert a `ts.TypeNode` to a `TypeValueReference`, which indicates how to use the\n * type given in the `ts.TypeNode` in a value position.\n *\n * This can return `null` if the `typeNode` is `null`, if it does not refer to a symbol with a value\n * declaration, or if it is not possible to statically understand.\n */\nexport function typeToValue(\n    typeNode: ts.TypeNode|null, checker: ts.TypeChecker): TypeValueReference {\n  // It's not possible to get a value expression if the parameter doesn't even have a type.\n  if (typeNode === null) {\n    return missingType();\n  }\n\n  if (!ts.isTypeReferenceNode(typeNode)) {\n    return unsupportedType(typeNode);\n  }\n\n  const symbols = resolveTypeSymbols(typeNode, checker);\n  if (symbols === null) {\n    return unknownReference(typeNode);\n  }\n\n  const {local, decl} = symbols;\n  // It's only valid to convert a type reference to a value reference if the type actually\n  // has a value declaration associated with it. Note that const enums are an exception,\n  // because while they do have a value declaration, they don't exist at runtime.\n  if (decl.valueDeclaration === undefined || decl.flags & ts.SymbolFlags.ConstEnum) {\n    let typeOnlyDecl: ts.Declaration|null = null;\n    if (decl.declarations !== undefined && decl.declarations.length > 0) {\n      typeOnlyDecl = decl.declarations[0];\n    }\n    return noValueDeclaration(typeNode, typeOnlyDecl);\n  }\n\n  // The type points to a valid value declaration. Rewrite the TypeReference into an\n  // Expression which references the value pointed to by the TypeReference, if possible.\n\n  // Look at the local `ts.Symbol`'s declarations and see if it comes from an import\n  // statement. If so, extract the module specifier and the name of the imported type.\n  const firstDecl = local.declarations && local.declarations[0];\n  if (firstDecl !== undefined) {\n    if (ts.isImportClause(firstDecl) && firstDecl.name !== undefined) {\n      // This is a default import.\n      //   import Foo from 'foo';\n\n      if (firstDecl.isTypeOnly) {\n        // Type-only imports cannot be represented as value.\n        return typeOnlyImport(typeNode, firstDecl);\n      }\n\n      return {\n        kind: TypeValueReferenceKind.LOCAL,\n        expression: firstDecl.name,\n        defaultImportStatement: firstDecl.parent,\n      };\n    } else if (ts.isImportSpecifier(firstDecl)) {\n      // The symbol was imported by name\n      //   import {Foo} from 'foo';\n      // or\n      //   import {Foo as Bar} from 'foo';\n\n      if (firstDecl.parent.parent.isTypeOnly) {\n        // Type-only imports cannot be represented as value.\n        return typeOnlyImport(typeNode, firstDecl.parent.parent);\n      }\n\n      // Determine the name to import (`Foo`) from the import specifier, as the symbol names of\n      // the imported type could refer to a local alias (like `Bar` in the example above).\n      const importedName = (firstDecl.propertyName || firstDecl.name).text;\n\n      // The first symbol name refers to the local name, which is replaced by `importedName` above.\n      // Any remaining symbol names make up the complete path to the value.\n      const [_localName, ...nestedPath] = symbols.symbolNames;\n\n      const moduleName = extractModuleName(firstDecl.parent.parent.parent);\n      return {\n        kind: TypeValueReferenceKind.IMPORTED,\n        valueDeclaration: decl.valueDeclaration,\n        moduleName,\n        importedName,\n        nestedPath\n      };\n    } else if (ts.isNamespaceImport(firstDecl)) {\n      // The import is a namespace import\n      //   import * as Foo from 'foo';\n\n      if (firstDecl.parent.isTypeOnly) {\n        // Type-only imports cannot be represented as value.\n        return typeOnlyImport(typeNode, firstDecl.parent);\n      }\n\n      if (symbols.symbolNames.length === 1) {\n        // The type refers to the namespace itself, which cannot be represented as a value.\n        return namespaceImport(typeNode, firstDecl.parent);\n      }\n\n      // The first symbol name refers to the local name of the namespace, which is is discarded\n      // as a new namespace import will be generated. This is followed by the symbol name that needs\n      // to be imported and any remaining names that constitute the complete path to the value.\n      const [_ns, importedName, ...nestedPath] = symbols.symbolNames;\n\n      const moduleName = extractModuleName(firstDecl.parent.parent);\n      return {\n        kind: TypeValueReferenceKind.IMPORTED,\n        valueDeclaration: decl.valueDeclaration,\n        moduleName,\n        importedName,\n        nestedPath\n      };\n    }\n  }\n\n  // If the type is not imported, the type reference can be converted into an expression as is.\n  const expression = typeNodeToValueExpr(typeNode);\n  if (expression !== null) {\n    return {\n      kind: TypeValueReferenceKind.LOCAL,\n      expression,\n      defaultImportStatement: null,\n    };\n  } else {\n    return unsupportedType(typeNode);\n  }\n}\n\nfunction unsupportedType(typeNode: ts.TypeNode): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.UNSUPPORTED, typeNode},\n  };\n}\n\nfunction noValueDeclaration(\n    typeNode: ts.TypeNode, decl: ts.Declaration|null): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.NO_VALUE_DECLARATION, typeNode, decl},\n  };\n}\n\nfunction typeOnlyImport(\n    typeNode: ts.TypeNode, importClause: ts.ImportClause): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.TYPE_ONLY_IMPORT, typeNode, importClause},\n  };\n}\n\nfunction unknownReference(typeNode: ts.TypeNode): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.UNKNOWN_REFERENCE, typeNode},\n  };\n}\n\nfunction namespaceImport(\n    typeNode: ts.TypeNode, importClause: ts.ImportClause): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.NAMESPACE, typeNode, importClause},\n  };\n}\n\nfunction missingType(): UnavailableTypeValueReference {\n  return {\n    kind: TypeValueReferenceKind.UNAVAILABLE,\n    reason: {kind: ValueUnavailableKind.MISSING_TYPE},\n  };\n}\n\n/**\n * Attempt to extract a `ts.Expression` that's equivalent to a `ts.TypeNode`, as the two have\n * different AST shapes but can reference the same symbols.\n *\n * This will return `null` if an equivalent expression cannot be constructed.\n */\nexport function typeNodeToValueExpr(node: ts.TypeNode): ts.Expression|null {\n  if (ts.isTypeReferenceNode(node)) {\n    return entityNameToValue(node.typeName);\n  } else {\n    return null;\n  }\n}\n\n/**\n * Resolve a `TypeReference` node to the `ts.Symbol`s for both its declaration and its local source.\n *\n * In the event that the `TypeReference` refers to a locally declared symbol, these will be the\n * same. If the `TypeReference` refers to an imported symbol, then `decl` will be the fully resolved\n * `ts.Symbol` of the referenced symbol. `local` will be the `ts.Symbol` of the `ts.Identifier`\n * which points to the import statement by which the symbol was imported.\n *\n * All symbol names that make up the type reference are returned left-to-right into the\n * `symbolNames` array, which is guaranteed to include at least one entry.\n */\nfunction resolveTypeSymbols(typeRef: ts.TypeReferenceNode, checker: ts.TypeChecker):\n    {local: ts.Symbol, decl: ts.Symbol, symbolNames: string[]}|null {\n  const typeName = typeRef.typeName;\n  // typeRefSymbol is the ts.Symbol of the entire type reference.\n  const typeRefSymbol: ts.Symbol|undefined = checker.getSymbolAtLocation(typeName);\n  if (typeRefSymbol === undefined) {\n    return null;\n  }\n\n  // `local` is the `ts.Symbol` for the local `ts.Identifier` for the type.\n  // If the type is actually locally declared or is imported by name, for example:\n  //   import {Foo} from './foo';\n  // then it'll be the same as `typeRefSymbol`.\n  //\n  // If the type is imported via a namespace import, for example:\n  //   import * as foo from './foo';\n  // and then referenced as:\n  //   constructor(f: foo.Foo)\n  // then `local` will be the `ts.Symbol` of `foo`, whereas `typeRefSymbol` will be the `ts.Symbol`\n  // of `foo.Foo`. This allows tracking of the import behind whatever type reference exists.\n  let local = typeRefSymbol;\n\n  // Destructure a name like `foo.X.Y.Z` as follows:\n  // - in `leftMost`, the `ts.Identifier` of the left-most name (`foo`) in the qualified name.\n  //   This identifier is used to resolve the `ts.Symbol` for `local`.\n  // - in `symbolNames`, all names involved in the qualified path, or a single symbol name if the\n  //   type is not qualified.\n  let leftMost = typeName;\n  const symbolNames: string[] = [];\n  while (ts.isQualifiedName(leftMost)) {\n    symbolNames.unshift(leftMost.right.text);\n    leftMost = leftMost.left;\n  }\n  symbolNames.unshift(leftMost.text);\n\n  if (leftMost !== typeName) {\n    const localTmp = checker.getSymbolAtLocation(leftMost);\n    if (localTmp !== undefined) {\n      local = localTmp;\n    }\n  }\n\n  // De-alias the top-level type reference symbol to get the symbol of the actual declaration.\n  let decl = typeRefSymbol;\n  if (typeRefSymbol.flags & ts.SymbolFlags.Alias) {\n    decl = checker.getAliasedSymbol(typeRefSymbol);\n  }\n  return {local, decl, symbolNames};\n}\n\nfunction entityNameToValue(node: ts.EntityName): ts.Expression|null {\n  if (ts.isQualifiedName(node)) {\n    const left = entityNameToValue(node.left);\n    return left !== null ? ts.createPropertyAccess(left, node.right) : null;\n  } else if (ts.isIdentifier(node)) {\n    return ts.getMutableClone(node);\n  } else {\n    return null;\n  }\n}\n\nfunction extractModuleName(node: ts.ImportDeclaration): string {\n  if (!ts.isStringLiteral(node.moduleSpecifier)) {\n    throw new Error('not a module specifier');\n  }\n  return node.moduleSpecifier.text;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}