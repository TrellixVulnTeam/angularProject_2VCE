{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar RequireEnsureDependenciesBlock = require(\"./RequireEnsureDependenciesBlock\");\n\nvar RequireEnsureItemDependency = require(\"./RequireEnsureItemDependency\");\n\nvar getFunctionExpression = require(\"./getFunctionExpression\");\n\nmodule.exports = /*#__PURE__*/function () {\n  function RequireEnsureDependenciesBlockParserPlugin() {\n    _classCallCheck(this, RequireEnsureDependenciesBlockParserPlugin);\n  }\n\n  _createClass(RequireEnsureDependenciesBlockParserPlugin, [{\n    key: \"apply\",\n    value: function apply(parser) {\n      parser.hooks.call.for(\"require.ensure\").tap(\"RequireEnsureDependenciesBlockParserPlugin\", function (expr) {\n        var chunkName = null;\n        var chunkNameRange = null;\n        var errorExpressionArg = null;\n        var errorExpression = null;\n\n        switch (expr.arguments.length) {\n          case 4:\n            {\n              var chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);\n              if (!chunkNameExpr.isString()) return;\n              chunkNameRange = chunkNameExpr.range;\n              chunkName = chunkNameExpr.string;\n            }\n          // falls through\n\n          case 3:\n            {\n              errorExpressionArg = expr.arguments[2];\n              errorExpression = getFunctionExpression(errorExpressionArg);\n\n              if (!errorExpression && !chunkName) {\n                var _chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);\n\n                if (!_chunkNameExpr.isString()) return;\n                chunkNameRange = _chunkNameExpr.range;\n                chunkName = _chunkNameExpr.string;\n              }\n            }\n          // falls through\n\n          case 2:\n            {\n              var dependenciesExpr = parser.evaluateExpression(expr.arguments[0]);\n              var dependenciesItems = dependenciesExpr.isArray() ? dependenciesExpr.items : [dependenciesExpr];\n              var successExpressionArg = expr.arguments[1];\n              var successExpression = getFunctionExpression(successExpressionArg);\n\n              if (successExpression) {\n                parser.walkExpressions(successExpression.expressions);\n              }\n\n              if (errorExpression) {\n                parser.walkExpressions(errorExpression.expressions);\n              }\n\n              var dep = new RequireEnsureDependenciesBlock(expr, successExpression ? successExpression.fn : successExpressionArg, errorExpression ? errorExpression.fn : errorExpressionArg, chunkName, chunkNameRange, parser.state.module, expr.loc);\n              var old = parser.state.current;\n              parser.state.current = dep;\n\n              try {\n                var failed = false;\n                parser.inScope([], function () {\n                  var _iterator = _createForOfIteratorHelper(dependenciesItems),\n                      _step;\n\n                  try {\n                    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                      var ee = _step.value;\n\n                      if (ee.isString()) {\n                        var edep = new RequireEnsureItemDependency(ee.string);\n                        edep.loc = dep.loc;\n                        dep.addDependency(edep);\n                      } else {\n                        failed = true;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator.e(err);\n                  } finally {\n                    _iterator.f();\n                  }\n                });\n\n                if (failed) {\n                  return;\n                }\n\n                if (successExpression) {\n                  if (successExpression.fn.body.type === \"BlockStatement\") {\n                    parser.walkStatement(successExpression.fn.body);\n                  } else {\n                    parser.walkExpression(successExpression.fn.body);\n                  }\n                }\n\n                old.addBlock(dep);\n              } finally {\n                parser.state.current = old;\n              }\n\n              if (!successExpression) {\n                parser.walkExpression(successExpressionArg);\n              }\n\n              if (errorExpression) {\n                if (errorExpression.fn.body.type === \"BlockStatement\") {\n                  parser.walkStatement(errorExpression.fn.body);\n                } else {\n                  parser.walkExpression(errorExpression.fn.body);\n                }\n              } else if (errorExpressionArg) {\n                parser.walkExpression(errorExpressionArg);\n              }\n\n              return true;\n            }\n        }\n      });\n    }\n  }]);\n\n  return RequireEnsureDependenciesBlockParserPlugin;\n}();","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/dependencies/RequireEnsureDependenciesBlockParserPlugin.js"],"names":["RequireEnsureDependenciesBlock","require","RequireEnsureItemDependency","getFunctionExpression","module","exports","parser","hooks","call","for","tap","expr","chunkName","chunkNameRange","errorExpressionArg","errorExpression","arguments","length","chunkNameExpr","evaluateExpression","isString","range","string","dependenciesExpr","dependenciesItems","isArray","items","successExpressionArg","successExpression","walkExpressions","expressions","dep","fn","state","loc","old","current","failed","inScope","ee","edep","addDependency","body","type","walkStatement","walkExpression","addBlock"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst RequireEnsureDependenciesBlock = require(\"./RequireEnsureDependenciesBlock\");\nconst RequireEnsureItemDependency = require(\"./RequireEnsureItemDependency\");\nconst getFunctionExpression = require(\"./getFunctionExpression\");\n\nmodule.exports = class RequireEnsureDependenciesBlockParserPlugin {\n\tapply(parser) {\n\t\tparser.hooks.call\n\t\t\t.for(\"require.ensure\")\n\t\t\t.tap(\"RequireEnsureDependenciesBlockParserPlugin\", expr => {\n\t\t\t\tlet chunkName = null;\n\t\t\t\tlet chunkNameRange = null;\n\t\t\t\tlet errorExpressionArg = null;\n\t\t\t\tlet errorExpression = null;\n\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\tcase 4: {\n\t\t\t\t\t\tconst chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);\n\t\t\t\t\t\tif (!chunkNameExpr.isString()) return;\n\t\t\t\t\t\tchunkNameRange = chunkNameExpr.range;\n\t\t\t\t\t\tchunkName = chunkNameExpr.string;\n\t\t\t\t\t}\n\t\t\t\t\t// falls through\n\t\t\t\t\tcase 3: {\n\t\t\t\t\t\terrorExpressionArg = expr.arguments[2];\n\t\t\t\t\t\terrorExpression = getFunctionExpression(errorExpressionArg);\n\n\t\t\t\t\t\tif (!errorExpression && !chunkName) {\n\t\t\t\t\t\t\tconst chunkNameExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\t\texpr.arguments[2]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (!chunkNameExpr.isString()) return;\n\t\t\t\t\t\t\tchunkNameRange = chunkNameExpr.range;\n\t\t\t\t\t\t\tchunkName = chunkNameExpr.string;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// falls through\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tconst dependenciesExpr = parser.evaluateExpression(\n\t\t\t\t\t\t\texpr.arguments[0]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst dependenciesItems = dependenciesExpr.isArray()\n\t\t\t\t\t\t\t? dependenciesExpr.items\n\t\t\t\t\t\t\t: [dependenciesExpr];\n\t\t\t\t\t\tconst successExpressionArg = expr.arguments[1];\n\t\t\t\t\t\tconst successExpression = getFunctionExpression(\n\t\t\t\t\t\t\tsuccessExpressionArg\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (successExpression) {\n\t\t\t\t\t\t\tparser.walkExpressions(successExpression.expressions);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (errorExpression) {\n\t\t\t\t\t\t\tparser.walkExpressions(errorExpression.expressions);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst dep = new RequireEnsureDependenciesBlock(\n\t\t\t\t\t\t\texpr,\n\t\t\t\t\t\t\tsuccessExpression ? successExpression.fn : successExpressionArg,\n\t\t\t\t\t\t\terrorExpression ? errorExpression.fn : errorExpressionArg,\n\t\t\t\t\t\t\tchunkName,\n\t\t\t\t\t\t\tchunkNameRange,\n\t\t\t\t\t\t\tparser.state.module,\n\t\t\t\t\t\t\texpr.loc\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst old = parser.state.current;\n\t\t\t\t\t\tparser.state.current = dep;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tlet failed = false;\n\t\t\t\t\t\t\tparser.inScope([], () => {\n\t\t\t\t\t\t\t\tfor (const ee of dependenciesItems) {\n\t\t\t\t\t\t\t\t\tif (ee.isString()) {\n\t\t\t\t\t\t\t\t\t\tconst edep = new RequireEnsureItemDependency(ee.string);\n\t\t\t\t\t\t\t\t\t\tedep.loc = dep.loc;\n\t\t\t\t\t\t\t\t\t\tdep.addDependency(edep);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tfailed = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif (failed) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (successExpression) {\n\t\t\t\t\t\t\t\tif (successExpression.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\t\t\t\tparser.walkStatement(successExpression.fn.body);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tparser.walkExpression(successExpression.fn.body);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\told.addBlock(dep);\n\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\tparser.state.current = old;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!successExpression) {\n\t\t\t\t\t\t\tparser.walkExpression(successExpressionArg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (errorExpression) {\n\t\t\t\t\t\t\tif (errorExpression.fn.body.type === \"BlockStatement\") {\n\t\t\t\t\t\t\t\tparser.walkStatement(errorExpression.fn.body);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.walkExpression(errorExpression.fn.body);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (errorExpressionArg) {\n\t\t\t\t\t\t\tparser.walkExpression(errorExpressionArg);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}