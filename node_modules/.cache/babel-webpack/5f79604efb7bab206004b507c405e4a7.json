{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.template = exports.templateParser = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar source_map_1 = require(\"source-map\"); // Matches <%= expr %>. This does not support structural JavaScript (for/if/...).\n\n\nvar kInterpolateRe = /<%=([\\s\\S]+?)%>/g; // Matches <%# text %>. It's a comment and will be entirely ignored.\n\nvar kCommentRe = /<%#([\\s\\S]+?)%>/g; // Used to match template delimiters.\n// <%- expr %>: HTML escape the value.\n// <% ... %>: Structural template code.\n\nvar kEscapeRe = /<%-([\\s\\S]+?)%>/g;\nvar kEvaluateRe = /<%([\\s\\S]+?)%>/g;\n/** Used to map characters to HTML entities. */\n\nvar kHtmlEscapes = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '`': '&#96;'\n}; // Used to match HTML entities and HTML characters.\n\nvar reUnescapedHtml = new RegExp(\"[\".concat(Object.keys(kHtmlEscapes).join(''), \"]\"), 'g');\n\nfunction _positionFor(content, offset) {\n  var line = 1;\n  var column = 0;\n\n  for (var i = 0; i < offset - 1; i++) {\n    if (content[i] == '\\n') {\n      line++;\n      column = 0;\n    } else {\n      column++;\n    }\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n/**\n * Given a source text (and a fileName), returns a TemplateAst.\n */\n\n\nfunction templateParser(sourceText, fileName) {\n  var children = []; // Compile the regexp to match each delimiter.\n\n  var reExpressions = [kEscapeRe, kCommentRe, kInterpolateRe, kEvaluateRe];\n  var reDelimiters = RegExp(reExpressions.map(function (x) {\n    return x.source;\n  }).join('|') + '|$', 'g');\n  var parsed = sourceText.split(reDelimiters);\n  var offset = 0; // Optimization that uses the fact that the end of a node is always the beginning of the next\n  // node, so we keep the positioning of the nodes in memory.\n\n  var start = _positionFor(sourceText, offset);\n\n  var end;\n  var increment = reExpressions.length + 1;\n\n  for (var i = 0; i < parsed.length; i += increment) {\n    var _parsed$slice = parsed.slice(i, i + increment),\n        _parsed$slice2 = _slicedToArray(_parsed$slice, 5),\n        content = _parsed$slice2[0],\n        _escape = _parsed$slice2[1],\n        comment = _parsed$slice2[2],\n        interpolate = _parsed$slice2[3],\n        evaluate = _parsed$slice2[4];\n\n    if (content) {\n      end = _positionFor(sourceText, offset + content.length);\n      offset += content.length;\n      children.push({\n        kind: 'content',\n        content: content,\n        start: start,\n        end: end\n      });\n      start = end;\n    }\n\n    if (_escape) {\n      end = _positionFor(sourceText, offset + _escape.length + 5);\n      offset += _escape.length + 5;\n      children.push({\n        kind: 'escape',\n        expression: _escape,\n        start: start,\n        end: end\n      });\n      start = end;\n    }\n\n    if (comment) {\n      end = _positionFor(sourceText, offset + comment.length + 5);\n      offset += comment.length + 5;\n      children.push({\n        kind: 'comment',\n        text: comment,\n        start: start,\n        end: end\n      });\n      start = end;\n    }\n\n    if (interpolate) {\n      end = _positionFor(sourceText, offset + interpolate.length + 5);\n      offset += interpolate.length + 5;\n      children.push({\n        kind: 'interpolate',\n        expression: interpolate,\n        start: start,\n        end: end\n      });\n      start = end;\n    }\n\n    if (evaluate) {\n      end = _positionFor(sourceText, offset + evaluate.length + 5);\n      offset += evaluate.length + 5;\n      children.push({\n        kind: 'evaluate',\n        expression: evaluate,\n        start: start,\n        end: end\n      });\n      start = end;\n    }\n  }\n\n  return {\n    fileName: fileName,\n    content: sourceText,\n    children: children\n  };\n}\n\nexports.templateParser = templateParser;\n/**\n * Fastest implementation of the templating algorithm. It only add strings and does not bother\n * with source maps.\n */\n\nfunction templateFast(ast, options) {\n  var module = options && options.module ? 'module.exports.default =' : '';\n  var reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, '\\\\\\\\\\\\\\'');\n  return \"\\n    return \".concat(module, \" function(obj) {\\n      obj || (obj = {});\\n      let __t;\\n      let __p = '';\\n      const __escapes = \").concat(JSON.stringify(kHtmlEscapes), \";\\n      const __escapesre = new RegExp('\").concat(reHtmlEscape, \"', 'g');\\n\\n      const __e = function(s) {\\n        return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';\\n      };\\n      with (obj) {\\n        \").concat(ast.children.map(function (node) {\n    switch (node.kind) {\n      case 'content':\n        return \"__p += \".concat(JSON.stringify(node.content), \";\");\n\n      case 'interpolate':\n        return \"__p += ((__t = (\".concat(node.expression, \")) == null) ? '' : __t;\");\n\n      case 'escape':\n        return \"__p += __e(\".concat(node.expression, \");\");\n\n      case 'evaluate':\n        return node.expression;\n    }\n  }).join('\\n'), \"\\n      }\\n\\n      return __p;\\n    };\\n  \");\n}\n/**\n * Templating algorithm with source map support. The map is outputted as //# sourceMapUrl=...\n */\n\n\nfunction templateWithSourceMap(ast, options) {\n  var sourceUrl = ast.fileName;\n  var module = options && options.module ? 'module.exports.default =' : '';\n  var reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, '\\\\\\\\\\\\\\'');\n  var preamble = new source_map_1.SourceNode(1, 0, sourceUrl, '').add(new source_map_1.SourceNode(1, 0, sourceUrl, [\"return \".concat(module, \" function(obj) {\\n\"), '  obj || (obj = {});\\n', '  let __t;\\n', '  let __p = \"\";\\n', \"  const __escapes = \".concat(JSON.stringify(kHtmlEscapes), \";\\n\"), \"  const __escapesre = new RegExp('\".concat(reHtmlEscape, \"', 'g');\\n\"), \"\\n\", \"  const __e = function(s) { \", \"    return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';\", \"  };\\n\", \"  with (obj) {\\n\"]));\n  var end = ast.children.length ? ast.children[ast.children.length - 1].end : {\n    line: 0,\n    column: 0\n  };\n  var nodes = ast.children.reduce(function (chunk, node) {\n    var code = '';\n\n    switch (node.kind) {\n      case 'content':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p = __p')].concat(_toConsumableArray(node.content.split('\\n').map(function (line, i, arr) {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, '\\n    + ' + JSON.stringify(line + (i == arr.length - 1 ? '' : '\\n')));\n        })), [new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ';\\n')]);\n        break;\n\n      case 'interpolate':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += ((__t = ')].concat(_toConsumableArray(node.expression.split('\\n').map(function (line, i, arr) {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        })), [new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ') == null ? \"\" : __t);\\n')]);\n        break;\n\n      case 'escape':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += __e(')].concat(_toConsumableArray(node.expression.split('\\n').map(function (line, i, arr) {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        })), [new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ');\\n')]);\n        break;\n\n      case 'evaluate':\n        code = [].concat(_toConsumableArray(node.expression.split('\\n').map(function (line, i, arr) {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        })), [new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, '\\n')]);\n        break;\n    }\n\n    return chunk.add(new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, code));\n  }, preamble).add(new source_map_1.SourceNode(end.line, end.column, sourceUrl, ['  };\\n', '\\n', '  return __p;\\n', '}\\n']));\n  var code = nodes.toStringWithSourceMap({\n    file: sourceUrl,\n    sourceRoot: options && options.sourceRoot || '.'\n  }); // Set the source content in the source map, otherwise the sourceUrl is not enough\n  // to find the content.\n\n  code.map.setSourceContent(sourceUrl, ast.content);\n  return code.code + '\\n//# sourceMappingURL=data:application/json;base64,' + Buffer.from(code.map.toString()).toString('base64');\n}\n/**\n * An equivalent of EJS templates, which is based on John Resig's `tmpl` implementation\n * (http://ejohn.org/blog/javascript-micro-templating/) and Laura Doktorova's doT.js\n * (https://github.com/olado/doT).\n *\n * This version differs from lodash by removing support from ES6 quasi-literals, and making the\n * code slightly simpler to follow. It also does not depend on any third party, which is nice.\n *\n * Finally, it supports SourceMap, if you ever need to debug, which is super nice.\n *\n * @param content The template content.\n * @param options Optional Options. See TemplateOptions for more description.\n * @return {(input: T) => string} A function that accept an input object and returns the content\n *         of the template with the input applied.\n */\n\n\nfunction template(content, options) {\n  var sourceUrl = options && options.sourceURL || 'ejs';\n  var ast = templateParser(content, sourceUrl);\n  var source; // If there's no need for source map support, we revert back to the fast implementation.\n\n  if (options && options.sourceMap) {\n    source = templateWithSourceMap(ast, options);\n  } else {\n    source = templateFast(ast, options);\n  } // We pass a dummy module in case the module option is passed. If `module: true` is passed, we\n  // need to only use the source, not the function itself. Otherwise expect a module object to be\n  // passed, and we use that one.\n\n\n  var fn = Function('module', source);\n  var module = options && options.module ? options.module === true ? {\n    exports: {}\n  } : options.module : null;\n  var result = fn(module); // Provide the compiled function's source by its `toString` method or\n  // the `source` property as a convenience for inlining compiled templates.\n\n  result.source = source;\n  return result;\n}\n\nexports.template = template;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/utils/template.js"],"names":["Object","defineProperty","exports","value","template","templateParser","source_map_1","require","kInterpolateRe","kCommentRe","kEscapeRe","kEvaluateRe","kHtmlEscapes","reUnescapedHtml","RegExp","keys","join","_positionFor","content","offset","line","column","i","sourceText","fileName","children","reExpressions","reDelimiters","map","x","source","parsed","split","start","end","increment","length","slice","escape","comment","interpolate","evaluate","push","kind","expression","text","templateFast","ast","options","module","reHtmlEscape","replace","JSON","stringify","node","templateWithSourceMap","sourceUrl","preamble","SourceNode","add","nodes","reduce","chunk","code","arr","toStringWithSourceMap","file","sourceRoot","setSourceContent","Buffer","from","toString","sourceURL","sourceMap","fn","Function","result"],"mappings":"AAAA;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,QAAR,GAAmBF,OAAO,CAACG,cAAR,GAAyB,KAAK,CAAjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,YAAY,GAAGC,OAAO,CAAC,YAAD,CAA5B,C,CACA;;;AACA,IAAMC,cAAc,GAAG,kBAAvB,C,CACA;;AACA,IAAMC,UAAU,GAAG,kBAAnB,C,CACA;AACA;AACA;;AACA,IAAMC,SAAS,GAAG,kBAAlB;AACA,IAAMC,WAAW,GAAG,iBAApB;AACA;;AACA,IAAMC,YAAY,GAAG;AACjB,OAAK,OADY;AAEjB,OAAK,MAFY;AAGjB,OAAK,MAHY;AAIjB,OAAK,QAJY;AAKjB,OAAK,OALY;AAMjB,OAAK;AANY,CAArB,C,CAQA;;AACA,IAAMC,eAAe,GAAG,IAAIC,MAAJ,YAAed,MAAM,CAACe,IAAP,CAAYH,YAAZ,EAA0BI,IAA1B,CAA+B,EAA/B,CAAf,QAAsD,GAAtD,CAAxB;;AACA,SAASC,YAAT,CAAsBC,OAAtB,EAA+BC,MAA/B,EAAuC;AACnC,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,GAAG,CAA7B,EAAgCG,CAAC,EAAjC,EAAqC;AACjC,QAAIJ,OAAO,CAACI,CAAD,CAAP,IAAc,IAAlB,EAAwB;AACpBF,MAAAA,IAAI;AACJC,MAAAA,MAAM,GAAG,CAAT;AACH,KAHD,MAIK;AACDA,MAAAA,MAAM;AACT;AACJ;;AACD,SAAO;AACHD,IAAAA,IAAI,EAAJA,IADG;AAEHC,IAAAA,MAAM,EAANA;AAFG,GAAP;AAIH;AACD;AACA;AACA;;;AACA,SAAShB,cAAT,CAAwBkB,UAAxB,EAAoCC,QAApC,EAA8C;AAC1C,MAAMC,QAAQ,GAAG,EAAjB,CAD0C,CAE1C;;AACA,MAAMC,aAAa,GAAG,CAAChB,SAAD,EAAYD,UAAZ,EAAwBD,cAAxB,EAAwCG,WAAxC,CAAtB;AACA,MAAMgB,YAAY,GAAGb,MAAM,CAACY,aAAa,CAACE,GAAd,CAAkB,UAAAC,CAAC;AAAA,WAAIA,CAAC,CAACC,MAAN;AAAA,GAAnB,EAAiCd,IAAjC,CAAsC,GAAtC,IAA6C,IAA9C,EAAoD,GAApD,CAA3B;AACA,MAAMe,MAAM,GAAGR,UAAU,CAACS,KAAX,CAAiBL,YAAjB,CAAf;AACA,MAAIR,MAAM,GAAG,CAAb,CAN0C,CAO1C;AACA;;AACA,MAAIc,KAAK,GAAGhB,YAAY,CAACM,UAAD,EAAaJ,MAAb,CAAxB;;AACA,MAAIe,GAAJ;AACA,MAAMC,SAAS,GAAGT,aAAa,CAACU,MAAd,GAAuB,CAAzC;;AACA,OAAK,IAAId,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,MAAM,CAACK,MAA3B,EAAmCd,CAAC,IAAIa,SAAxC,EAAmD;AAC/C,wBAA0DJ,MAAM,CAACM,KAAP,CAAaf,CAAb,EAAgBA,CAAC,GAAGa,SAApB,CAA1D;AAAA;AAAA,QAAOjB,OAAP;AAAA,QAAgBoB,OAAhB;AAAA,QAAwBC,OAAxB;AAAA,QAAiCC,WAAjC;AAAA,QAA8CC,QAA9C;;AACA,QAAIvB,OAAJ,EAAa;AACTgB,MAAAA,GAAG,GAAGjB,YAAY,CAACM,UAAD,EAAaJ,MAAM,GAAGD,OAAO,CAACkB,MAA9B,CAAlB;AACAjB,MAAAA,MAAM,IAAID,OAAO,CAACkB,MAAlB;AACAX,MAAAA,QAAQ,CAACiB,IAAT,CAAc;AAAEC,QAAAA,IAAI,EAAE,SAAR;AAAmBzB,QAAAA,OAAO,EAAPA,OAAnB;AAA4Be,QAAAA,KAAK,EAALA,KAA5B;AAAmCC,QAAAA,GAAG,EAAHA;AAAnC,OAAd;AACAD,MAAAA,KAAK,GAAGC,GAAR;AACH;;AACD,QAAII,OAAJ,EAAY;AACRJ,MAAAA,GAAG,GAAGjB,YAAY,CAACM,UAAD,EAAaJ,MAAM,GAAGmB,OAAM,CAACF,MAAhB,GAAyB,CAAtC,CAAlB;AACAjB,MAAAA,MAAM,IAAImB,OAAM,CAACF,MAAP,GAAgB,CAA1B;AACAX,MAAAA,QAAQ,CAACiB,IAAT,CAAc;AAAEC,QAAAA,IAAI,EAAE,QAAR;AAAkBC,QAAAA,UAAU,EAAEN,OAA9B;AAAsCL,QAAAA,KAAK,EAALA,KAAtC;AAA6CC,QAAAA,GAAG,EAAHA;AAA7C,OAAd;AACAD,MAAAA,KAAK,GAAGC,GAAR;AACH;;AACD,QAAIK,OAAJ,EAAa;AACTL,MAAAA,GAAG,GAAGjB,YAAY,CAACM,UAAD,EAAaJ,MAAM,GAAGoB,OAAO,CAACH,MAAjB,GAA0B,CAAvC,CAAlB;AACAjB,MAAAA,MAAM,IAAIoB,OAAO,CAACH,MAAR,GAAiB,CAA3B;AACAX,MAAAA,QAAQ,CAACiB,IAAT,CAAc;AAAEC,QAAAA,IAAI,EAAE,SAAR;AAAmBE,QAAAA,IAAI,EAAEN,OAAzB;AAAkCN,QAAAA,KAAK,EAALA,KAAlC;AAAyCC,QAAAA,GAAG,EAAHA;AAAzC,OAAd;AACAD,MAAAA,KAAK,GAAGC,GAAR;AACH;;AACD,QAAIM,WAAJ,EAAiB;AACbN,MAAAA,GAAG,GAAGjB,YAAY,CAACM,UAAD,EAAaJ,MAAM,GAAGqB,WAAW,CAACJ,MAArB,GAA8B,CAA3C,CAAlB;AACAjB,MAAAA,MAAM,IAAIqB,WAAW,CAACJ,MAAZ,GAAqB,CAA/B;AACAX,MAAAA,QAAQ,CAACiB,IAAT,CAAc;AACVC,QAAAA,IAAI,EAAE,aADI;AAEVC,QAAAA,UAAU,EAAEJ,WAFF;AAGVP,QAAAA,KAAK,EAALA,KAHU;AAIVC,QAAAA,GAAG,EAAHA;AAJU,OAAd;AAMAD,MAAAA,KAAK,GAAGC,GAAR;AACH;;AACD,QAAIO,QAAJ,EAAc;AACVP,MAAAA,GAAG,GAAGjB,YAAY,CAACM,UAAD,EAAaJ,MAAM,GAAGsB,QAAQ,CAACL,MAAlB,GAA2B,CAAxC,CAAlB;AACAjB,MAAAA,MAAM,IAAIsB,QAAQ,CAACL,MAAT,GAAkB,CAA5B;AACAX,MAAAA,QAAQ,CAACiB,IAAT,CAAc;AAAEC,QAAAA,IAAI,EAAE,UAAR;AAAoBC,QAAAA,UAAU,EAAEH,QAAhC;AAA0CR,QAAAA,KAAK,EAALA,KAA1C;AAAiDC,QAAAA,GAAG,EAAHA;AAAjD,OAAd;AACAD,MAAAA,KAAK,GAAGC,GAAR;AACH;AACJ;;AACD,SAAO;AACHV,IAAAA,QAAQ,EAARA,QADG;AAEHN,IAAAA,OAAO,EAAEK,UAFN;AAGHE,IAAAA,QAAQ,EAARA;AAHG,GAAP;AAKH;;AACDvB,OAAO,CAACG,cAAR,GAAyBA,cAAzB;AACA;AACA;AACA;AACA;;AACA,SAASyC,YAAT,CAAsBC,GAAtB,EAA2BC,OAA3B,EAAoC;AAChC,MAAMC,MAAM,GAAGD,OAAO,IAAIA,OAAO,CAACC,MAAnB,GAA4B,0BAA5B,GAAyD,EAAxE;AACA,MAAMC,YAAY,GAAGrC,eAAe,CAACiB,MAAhB,CAAuBqB,OAAvB,CAA+B,MAA/B,EAAuC,UAAvC,CAArB;AACA,gCACSF,MADT,sHAKsBG,IAAI,CAACC,SAAL,CAAezC,YAAf,CALtB,sDAMoCsC,YANpC,2LAYMH,GAAG,CAACtB,QAAJ,CAAaG,GAAb,CAAiB,UAAA0B,IAAI,EAAI;AAC3B,YAAQA,IAAI,CAACX,IAAb;AACI,WAAK,SAAL;AACI,gCAAiBS,IAAI,CAACC,SAAL,CAAeC,IAAI,CAACpC,OAApB,CAAjB;;AACJ,WAAK,aAAL;AACI,yCAA0BoC,IAAI,CAACV,UAA/B;;AACJ,WAAK,QAAL;AACI,oCAAqBU,IAAI,CAACV,UAA1B;;AACJ,WAAK,UAAL;AACI,eAAOU,IAAI,CAACV,UAAZ;AARR;AAUH,GAXK,EAWH5B,IAXG,CAWE,IAXF,CAZN;AA6BH;AACD;AACA;AACA;;;AACA,SAASuC,qBAAT,CAA+BR,GAA/B,EAAoCC,OAApC,EAA6C;AACzC,MAAMQ,SAAS,GAAGT,GAAG,CAACvB,QAAtB;AACA,MAAMyB,MAAM,GAAGD,OAAO,IAAIA,OAAO,CAACC,MAAnB,GAA4B,0BAA5B,GAAyD,EAAxE;AACA,MAAMC,YAAY,GAAGrC,eAAe,CAACiB,MAAhB,CAAuBqB,OAAvB,CAA+B,MAA/B,EAAuC,UAAvC,CAArB;AACA,MAAMM,QAAQ,GAAI,IAAInD,YAAY,CAACoD,UAAjB,CAA4B,CAA5B,EAA+B,CAA/B,EAAkCF,SAAlC,EAA6C,EAA7C,CAAD,CACZG,GADY,CACR,IAAIrD,YAAY,CAACoD,UAAjB,CAA4B,CAA5B,EAA+B,CAA/B,EAAkCF,SAAlC,EAA6C,kBACxCP,MADwC,yBAElD,wBAFkD,EAGlD,cAHkD,EAIlD,mBAJkD,gCAK3BG,IAAI,CAACC,SAAL,CAAezC,YAAf,CAL2B,sDAMbsC,YANa,6KAA7C,CADQ,CAAjB;AAcA,MAAMhB,GAAG,GAAGa,GAAG,CAACtB,QAAJ,CAAaW,MAAb,GACNW,GAAG,CAACtB,QAAJ,CAAasB,GAAG,CAACtB,QAAJ,CAAaW,MAAb,GAAsB,CAAnC,EAAsCF,GADhC,GAEN;AAAEd,IAAAA,IAAI,EAAE,CAAR;AAAWC,IAAAA,MAAM,EAAE;AAAnB,GAFN;AAGA,MAAMuC,KAAK,GAAGb,GAAG,CAACtB,QAAJ,CAAaoC,MAAb,CAAoB,UAACC,KAAD,EAAQR,IAAR,EAAiB;AAC/C,QAAIS,IAAI,GAAG,EAAX;;AACA,YAAQT,IAAI,CAACX,IAAb;AACI,WAAK,SAAL;AACIoB,QAAAA,IAAI,IACA,IAAIzD,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACrB,KAAL,CAAWb,IAAvC,EAA6CkC,IAAI,CAACrB,KAAL,CAAWZ,MAAxD,EAAgEmC,SAAhE,EAA2E,WAA3E,CADA,4BAEGF,IAAI,CAACpC,OAAL,CAAac,KAAb,CAAmB,IAAnB,EAAyBJ,GAAzB,CAA6B,UAACR,IAAD,EAAOE,CAAP,EAAU0C,GAAV,EAAkB;AAC9C,iBAAO,IAAI1D,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACrB,KAAL,CAAWb,IAAX,GAAkBE,CAA9C,EAAiDA,CAAC,IAAI,CAAL,GAASgC,IAAI,CAACrB,KAAL,CAAWZ,MAApB,GAA6B,CAA9E,EAAiFmC,SAAjF,EAA4F,aAC7FJ,IAAI,CAACC,SAAL,CAAejC,IAAI,IAAIE,CAAC,IAAI0C,GAAG,CAAC5B,MAAJ,GAAa,CAAlB,GAAsB,EAAtB,GAA2B,IAA/B,CAAnB,CADC,CAAP;AAEH,SAHE,CAFH,IAMA,IAAI9B,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACpB,GAAL,CAASd,IAArC,EAA2CkC,IAAI,CAACpB,GAAL,CAASb,MAApD,EAA4DmC,SAA5D,EAAuE,KAAvE,CANA,EAAJ;AAQA;;AACJ,WAAK,aAAL;AACIO,QAAAA,IAAI,IACA,IAAIzD,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACrB,KAAL,CAAWb,IAAvC,EAA6CkC,IAAI,CAACrB,KAAL,CAAWZ,MAAxD,EAAgEmC,SAAhE,EAA2E,iBAA3E,CADA,4BAEGF,IAAI,CAACV,UAAL,CAAgBZ,KAAhB,CAAsB,IAAtB,EAA4BJ,GAA5B,CAAgC,UAACR,IAAD,EAAOE,CAAP,EAAU0C,GAAV,EAAkB;AACjD,iBAAO,IAAI1D,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACrB,KAAL,CAAWb,IAAX,GAAkBE,CAA9C,EAAiDA,CAAC,IAAI,CAAL,GAASgC,IAAI,CAACrB,KAAL,CAAWZ,MAApB,GAA6B,CAA9E,EAAiFmC,SAAjF,EAA4FpC,IAAI,IAAKE,CAAC,IAAI0C,GAAG,CAAC5B,MAAJ,GAAa,CAAnB,GAAwB,EAAxB,GAA6B,IAAjC,CAAhG,CAAP;AACH,SAFE,CAFH,IAKA,IAAI9B,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACpB,GAAL,CAASd,IAArC,EAA2CkC,IAAI,CAACpB,GAAL,CAASb,MAApD,EAA4DmC,SAA5D,EAAuE,0BAAvE,CALA,EAAJ;AAOA;;AACJ,WAAK,QAAL;AACIO,QAAAA,IAAI,IACA,IAAIzD,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACrB,KAAL,CAAWb,IAAvC,EAA6CkC,IAAI,CAACrB,KAAL,CAAWZ,MAAxD,EAAgEmC,SAAhE,EAA2E,aAA3E,CADA,4BAEGF,IAAI,CAACV,UAAL,CAAgBZ,KAAhB,CAAsB,IAAtB,EAA4BJ,GAA5B,CAAgC,UAACR,IAAD,EAAOE,CAAP,EAAU0C,GAAV,EAAkB;AACjD,iBAAO,IAAI1D,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACrB,KAAL,CAAWb,IAAX,GAAkBE,CAA9C,EAAiDA,CAAC,IAAI,CAAL,GAASgC,IAAI,CAACrB,KAAL,CAAWZ,MAApB,GAA6B,CAA9E,EAAiFmC,SAAjF,EAA4FpC,IAAI,IAAKE,CAAC,IAAI0C,GAAG,CAAC5B,MAAJ,GAAa,CAAnB,GAAwB,EAAxB,GAA6B,IAAjC,CAAhG,CAAP;AACH,SAFE,CAFH,IAKA,IAAI9B,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACpB,GAAL,CAASd,IAArC,EAA2CkC,IAAI,CAACpB,GAAL,CAASb,MAApD,EAA4DmC,SAA5D,EAAuE,MAAvE,CALA,EAAJ;AAOA;;AACJ,WAAK,UAAL;AACIO,QAAAA,IAAI,gCACGT,IAAI,CAACV,UAAL,CAAgBZ,KAAhB,CAAsB,IAAtB,EAA4BJ,GAA5B,CAAgC,UAACR,IAAD,EAAOE,CAAP,EAAU0C,GAAV,EAAkB;AACjD,iBAAO,IAAI1D,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACrB,KAAL,CAAWb,IAAX,GAAkBE,CAA9C,EAAiDA,CAAC,IAAI,CAAL,GAASgC,IAAI,CAACrB,KAAL,CAAWZ,MAApB,GAA6B,CAA9E,EAAiFmC,SAAjF,EAA4FpC,IAAI,IAAKE,CAAC,IAAI0C,GAAG,CAAC5B,MAAJ,GAAa,CAAnB,GAAwB,EAAxB,GAA6B,IAAjC,CAAhG,CAAP;AACH,SAFE,CADH,IAIA,IAAI9B,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACpB,GAAL,CAASd,IAArC,EAA2CkC,IAAI,CAACpB,GAAL,CAASb,MAApD,EAA4DmC,SAA5D,EAAuE,IAAvE,CAJA,EAAJ;AAMA;AApCR;;AAsCA,WAAOM,KAAK,CAACH,GAAN,CAAU,IAAIrD,YAAY,CAACoD,UAAjB,CAA4BJ,IAAI,CAACrB,KAAL,CAAWb,IAAvC,EAA6CkC,IAAI,CAACrB,KAAL,CAAWZ,MAAxD,EAAgEmC,SAAhE,EAA2EO,IAA3E,CAAV,CAAP;AACH,GAzCa,EAyCXN,QAzCW,EA0CTE,GA1CS,CA0CL,IAAIrD,YAAY,CAACoD,UAAjB,CAA4BxB,GAAG,CAACd,IAAhC,EAAsCc,GAAG,CAACb,MAA1C,EAAkDmC,SAAlD,EAA6D,CAClE,QADkE,EAElE,IAFkE,EAGlE,iBAHkE,EAIlE,KAJkE,CAA7D,CA1CK,CAAd;AAgDA,MAAMO,IAAI,GAAGH,KAAK,CAACK,qBAAN,CAA4B;AACrCC,IAAAA,IAAI,EAAEV,SAD+B;AAErCW,IAAAA,UAAU,EAAEnB,OAAO,IAAIA,OAAO,CAACmB,UAAnB,IAAiC;AAFR,GAA5B,CAAb,CArEyC,CAyEzC;AACA;;AACAJ,EAAAA,IAAI,CAACnC,GAAL,CAASwC,gBAAT,CAA0BZ,SAA1B,EAAqCT,GAAG,CAAC7B,OAAzC;AACA,SAAO6C,IAAI,CAACA,IAAL,GACD,sDADC,GAEDM,MAAM,CAACC,IAAP,CAAYP,IAAI,CAACnC,GAAL,CAAS2C,QAAT,EAAZ,EAAiCA,QAAjC,CAA0C,QAA1C,CAFN;AAGH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASnE,QAAT,CAAkBc,OAAlB,EAA2B8B,OAA3B,EAAoC;AAChC,MAAMQ,SAAS,GAAGR,OAAO,IAAIA,OAAO,CAACwB,SAAnB,IAAgC,KAAlD;AACA,MAAMzB,GAAG,GAAG1C,cAAc,CAACa,OAAD,EAAUsC,SAAV,CAA1B;AACA,MAAI1B,MAAJ,CAHgC,CAIhC;;AACA,MAAIkB,OAAO,IAAIA,OAAO,CAACyB,SAAvB,EAAkC;AAC9B3C,IAAAA,MAAM,GAAGyB,qBAAqB,CAACR,GAAD,EAAMC,OAAN,CAA9B;AACH,GAFD,MAGK;AACDlB,IAAAA,MAAM,GAAGgB,YAAY,CAACC,GAAD,EAAMC,OAAN,CAArB;AACH,GAV+B,CAWhC;AACA;AACA;;;AACA,MAAM0B,EAAE,GAAGC,QAAQ,CAAC,QAAD,EAAW7C,MAAX,CAAnB;AACA,MAAMmB,MAAM,GAAGD,OAAO,IAAIA,OAAO,CAACC,MAAnB,GACRD,OAAO,CAACC,MAAR,KAAmB,IAAnB,GAA0B;AAAE/C,IAAAA,OAAO,EAAE;AAAX,GAA1B,GAA4C8C,OAAO,CAACC,MAD5C,GAET,IAFN;AAGA,MAAM2B,MAAM,GAAGF,EAAE,CAACzB,MAAD,CAAjB,CAlBgC,CAmBhC;AACA;;AACA2B,EAAAA,MAAM,CAAC9C,MAAP,GAAgBA,MAAhB;AACA,SAAO8C,MAAP;AACH;;AACD1E,OAAO,CAACE,QAAR,GAAmBA,QAAnB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.template = exports.templateParser = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst source_map_1 = require(\"source-map\");\n// Matches <%= expr %>. This does not support structural JavaScript (for/if/...).\nconst kInterpolateRe = /<%=([\\s\\S]+?)%>/g;\n// Matches <%# text %>. It's a comment and will be entirely ignored.\nconst kCommentRe = /<%#([\\s\\S]+?)%>/g;\n// Used to match template delimiters.\n// <%- expr %>: HTML escape the value.\n// <% ... %>: Structural template code.\nconst kEscapeRe = /<%-([\\s\\S]+?)%>/g;\nconst kEvaluateRe = /<%([\\s\\S]+?)%>/g;\n/** Used to map characters to HTML entities. */\nconst kHtmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '`': '&#96;',\n};\n// Used to match HTML entities and HTML characters.\nconst reUnescapedHtml = new RegExp(`[${Object.keys(kHtmlEscapes).join('')}]`, 'g');\nfunction _positionFor(content, offset) {\n    let line = 1;\n    let column = 0;\n    for (let i = 0; i < offset - 1; i++) {\n        if (content[i] == '\\n') {\n            line++;\n            column = 0;\n        }\n        else {\n            column++;\n        }\n    }\n    return {\n        line,\n        column,\n    };\n}\n/**\n * Given a source text (and a fileName), returns a TemplateAst.\n */\nfunction templateParser(sourceText, fileName) {\n    const children = [];\n    // Compile the regexp to match each delimiter.\n    const reExpressions = [kEscapeRe, kCommentRe, kInterpolateRe, kEvaluateRe];\n    const reDelimiters = RegExp(reExpressions.map(x => x.source).join('|') + '|$', 'g');\n    const parsed = sourceText.split(reDelimiters);\n    let offset = 0;\n    // Optimization that uses the fact that the end of a node is always the beginning of the next\n    // node, so we keep the positioning of the nodes in memory.\n    let start = _positionFor(sourceText, offset);\n    let end;\n    const increment = reExpressions.length + 1;\n    for (let i = 0; i < parsed.length; i += increment) {\n        const [content, escape, comment, interpolate, evaluate] = parsed.slice(i, i + increment);\n        if (content) {\n            end = _positionFor(sourceText, offset + content.length);\n            offset += content.length;\n            children.push({ kind: 'content', content, start, end });\n            start = end;\n        }\n        if (escape) {\n            end = _positionFor(sourceText, offset + escape.length + 5);\n            offset += escape.length + 5;\n            children.push({ kind: 'escape', expression: escape, start, end });\n            start = end;\n        }\n        if (comment) {\n            end = _positionFor(sourceText, offset + comment.length + 5);\n            offset += comment.length + 5;\n            children.push({ kind: 'comment', text: comment, start, end });\n            start = end;\n        }\n        if (interpolate) {\n            end = _positionFor(sourceText, offset + interpolate.length + 5);\n            offset += interpolate.length + 5;\n            children.push({\n                kind: 'interpolate',\n                expression: interpolate,\n                start,\n                end,\n            });\n            start = end;\n        }\n        if (evaluate) {\n            end = _positionFor(sourceText, offset + evaluate.length + 5);\n            offset += evaluate.length + 5;\n            children.push({ kind: 'evaluate', expression: evaluate, start, end });\n            start = end;\n        }\n    }\n    return {\n        fileName,\n        content: sourceText,\n        children,\n    };\n}\nexports.templateParser = templateParser;\n/**\n * Fastest implementation of the templating algorithm. It only add strings and does not bother\n * with source maps.\n */\nfunction templateFast(ast, options) {\n    const module = options && options.module ? 'module.exports.default =' : '';\n    const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, '\\\\\\\\\\\\\\'');\n    return `\n    return ${module} function(obj) {\n      obj || (obj = {});\n      let __t;\n      let __p = '';\n      const __escapes = ${JSON.stringify(kHtmlEscapes)};\n      const __escapesre = new RegExp('${reHtmlEscape}', 'g');\n\n      const __e = function(s) {\n        return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';\n      };\n      with (obj) {\n        ${ast.children.map(node => {\n        switch (node.kind) {\n            case 'content':\n                return `__p += ${JSON.stringify(node.content)};`;\n            case 'interpolate':\n                return `__p += ((__t = (${node.expression})) == null) ? '' : __t;`;\n            case 'escape':\n                return `__p += __e(${node.expression});`;\n            case 'evaluate':\n                return node.expression;\n        }\n    }).join('\\n')}\n      }\n\n      return __p;\n    };\n  `;\n}\n/**\n * Templating algorithm with source map support. The map is outputted as //# sourceMapUrl=...\n */\nfunction templateWithSourceMap(ast, options) {\n    const sourceUrl = ast.fileName;\n    const module = options && options.module ? 'module.exports.default =' : '';\n    const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, '\\\\\\\\\\\\\\'');\n    const preamble = (new source_map_1.SourceNode(1, 0, sourceUrl, ''))\n        .add(new source_map_1.SourceNode(1, 0, sourceUrl, [\n        `return ${module} function(obj) {\\n`,\n        '  obj || (obj = {});\\n',\n        '  let __t;\\n',\n        '  let __p = \"\";\\n',\n        `  const __escapes = ${JSON.stringify(kHtmlEscapes)};\\n`,\n        `  const __escapesre = new RegExp('${reHtmlEscape}', 'g');\\n`,\n        `\\n`,\n        `  const __e = function(s) { `,\n        `    return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';`,\n        `  };\\n`,\n        `  with (obj) {\\n`,\n    ]));\n    const end = ast.children.length\n        ? ast.children[ast.children.length - 1].end\n        : { line: 0, column: 0 };\n    const nodes = ast.children.reduce((chunk, node) => {\n        let code = '';\n        switch (node.kind) {\n            case 'content':\n                code = [\n                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p = __p'),\n                    ...node.content.split('\\n').map((line, i, arr) => {\n                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, '\\n    + '\n                            + JSON.stringify(line + (i == arr.length - 1 ? '' : '\\n')));\n                    }),\n                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ';\\n'),\n                ];\n                break;\n            case 'interpolate':\n                code = [\n                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += ((__t = '),\n                    ...node.expression.split('\\n').map((line, i, arr) => {\n                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + ((i == arr.length - 1) ? '' : '\\n'));\n                    }),\n                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ') == null ? \"\" : __t);\\n'),\n                ];\n                break;\n            case 'escape':\n                code = [\n                    new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += __e('),\n                    ...node.expression.split('\\n').map((line, i, arr) => {\n                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + ((i == arr.length - 1) ? '' : '\\n'));\n                    }),\n                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ');\\n'),\n                ];\n                break;\n            case 'evaluate':\n                code = [\n                    ...node.expression.split('\\n').map((line, i, arr) => {\n                        return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + ((i == arr.length - 1) ? '' : '\\n'));\n                    }),\n                    new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, '\\n'),\n                ];\n                break;\n        }\n        return chunk.add(new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, code));\n    }, preamble)\n        .add(new source_map_1.SourceNode(end.line, end.column, sourceUrl, [\n        '  };\\n',\n        '\\n',\n        '  return __p;\\n',\n        '}\\n',\n    ]));\n    const code = nodes.toStringWithSourceMap({\n        file: sourceUrl,\n        sourceRoot: options && options.sourceRoot || '.',\n    });\n    // Set the source content in the source map, otherwise the sourceUrl is not enough\n    // to find the content.\n    code.map.setSourceContent(sourceUrl, ast.content);\n    return code.code\n        + '\\n//# sourceMappingURL=data:application/json;base64,'\n        + Buffer.from(code.map.toString()).toString('base64');\n}\n/**\n * An equivalent of EJS templates, which is based on John Resig's `tmpl` implementation\n * (http://ejohn.org/blog/javascript-micro-templating/) and Laura Doktorova's doT.js\n * (https://github.com/olado/doT).\n *\n * This version differs from lodash by removing support from ES6 quasi-literals, and making the\n * code slightly simpler to follow. It also does not depend on any third party, which is nice.\n *\n * Finally, it supports SourceMap, if you ever need to debug, which is super nice.\n *\n * @param content The template content.\n * @param options Optional Options. See TemplateOptions for more description.\n * @return {(input: T) => string} A function that accept an input object and returns the content\n *         of the template with the input applied.\n */\nfunction template(content, options) {\n    const sourceUrl = options && options.sourceURL || 'ejs';\n    const ast = templateParser(content, sourceUrl);\n    let source;\n    // If there's no need for source map support, we revert back to the fast implementation.\n    if (options && options.sourceMap) {\n        source = templateWithSourceMap(ast, options);\n    }\n    else {\n        source = templateFast(ast, options);\n    }\n    // We pass a dummy module in case the module option is passed. If `module: true` is passed, we\n    // need to only use the source, not the function itself. Otherwise expect a module object to be\n    // passed, and we use that one.\n    const fn = Function('module', source);\n    const module = options && options.module\n        ? (options.module === true ? { exports: {} } : options.module)\n        : null;\n    const result = fn(module);\n    // Provide the compiled function's source by its `toString` method or\n    // the `source` property as a convenience for inlining compiled templates.\n    result.source = source;\n    return result;\n}\nexports.template = template;\n"]},"metadata":{},"sourceType":"script"}