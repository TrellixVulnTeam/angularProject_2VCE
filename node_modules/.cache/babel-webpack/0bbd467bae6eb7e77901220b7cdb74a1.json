{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/tasks/queues/base_task_queue\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/execution/tasks/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.BaseTaskQueue = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/utils\");\n  /**\n   * A base `TaskQueue` implementation to be used as base for concrete implementations.\n   */\n\n\n  var BaseTaskQueue =\n  /** @class */\n  function () {\n    function BaseTaskQueue(logger, tasks, dependencies) {\n      this.logger = logger;\n      this.tasks = tasks;\n      this.dependencies = dependencies;\n      this.inProgressTasks = new Set();\n      /**\n       * A map of tasks that should be skipped, mapped to the task that caused them to be skipped.\n       */\n\n      this.tasksToSkip = new Map();\n    }\n\n    Object.defineProperty(BaseTaskQueue.prototype, \"allTasksCompleted\", {\n      get: function get() {\n        return this.tasks.length === 0 && this.inProgressTasks.size === 0;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    BaseTaskQueue.prototype.getNextTask = function () {\n      var nextTask = this.computeNextTask();\n\n      while (nextTask !== null) {\n        if (!this.tasksToSkip.has(nextTask)) {\n          break;\n        } // We are skipping this task so mark it as complete\n\n\n        this.markAsCompleted(nextTask);\n        var failedTask = this.tasksToSkip.get(nextTask);\n        this.logger.warn(\"Skipping processing of \" + nextTask.entryPoint.name + \" because its dependency \" + failedTask.entryPoint.name + \" failed to compile.\");\n        nextTask = this.computeNextTask();\n      }\n\n      return nextTask;\n    };\n\n    BaseTaskQueue.prototype.markAsCompleted = function (task) {\n      if (!this.inProgressTasks.has(task)) {\n        throw new Error(\"Trying to mark task that was not in progress as completed: \" + utils_1.stringifyTask(task));\n      }\n\n      this.inProgressTasks.delete(task);\n    };\n\n    BaseTaskQueue.prototype.markAsFailed = function (task) {\n      var e_1, _a;\n\n      if (this.dependencies.has(task)) {\n        try {\n          for (var _b = tslib_1.__values(this.dependencies.get(task)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var dependentTask = _c.value;\n            this.skipDependentTasks(dependentTask, task);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n    };\n\n    BaseTaskQueue.prototype.markAsUnprocessed = function (task) {\n      if (!this.inProgressTasks.has(task)) {\n        throw new Error(\"Trying to mark task that was not in progress as unprocessed: \" + utils_1.stringifyTask(task));\n      }\n\n      this.inProgressTasks.delete(task);\n      this.tasks.unshift(task);\n    };\n\n    BaseTaskQueue.prototype.toString = function () {\n      var inProgTasks = Array.from(this.inProgressTasks);\n      return this.constructor.name + \"\\n\" + (\"  All tasks completed: \" + this.allTasksCompleted + \"\\n\") + (\"  Unprocessed tasks (\" + this.tasks.length + \"): \" + this.stringifyTasks(this.tasks, '    ') + \"\\n\") + (\"  In-progress tasks (\" + inProgTasks.length + \"): \" + this.stringifyTasks(inProgTasks, '    '));\n    };\n    /**\n     * Mark the given `task` as to be skipped, then recursive skip all its dependents.\n     *\n     * @param task The task to skip\n     * @param failedTask The task that failed, causing this task to be skipped\n     */\n\n\n    BaseTaskQueue.prototype.skipDependentTasks = function (task, failedTask) {\n      var e_2, _a;\n\n      this.tasksToSkip.set(task, failedTask);\n\n      if (this.dependencies.has(task)) {\n        try {\n          for (var _b = tslib_1.__values(this.dependencies.get(task)), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var dependentTask = _c.value;\n            this.skipDependentTasks(dependentTask, failedTask);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n    };\n\n    BaseTaskQueue.prototype.stringifyTasks = function (tasks, indentation) {\n      return tasks.map(function (task) {\n        return \"\\n\" + indentation + \"- \" + utils_1.stringifyTask(task);\n      }).join('');\n    };\n\n    return BaseTaskQueue;\n  }();\n\n  exports.BaseTaskQueue = BaseTaskQueue;\n});","map":{"version":3,"sources":["../../../../../../../../../../packages/compiler-cli/ngcc/src/execution/tasks/queues/base_task_queue.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Logger} from '../../../../../src/ngtsc/logging';\nimport {PartiallyOrderedTasks, Task, TaskDependencies, TaskQueue} from '../api';\nimport {stringifyTask} from '../utils';\n\n\n/**\n * A base `TaskQueue` implementation to be used as base for concrete implementations.\n */\nexport abstract class BaseTaskQueue implements TaskQueue {\n  get allTasksCompleted(): boolean {\n    return (this.tasks.length === 0) && (this.inProgressTasks.size === 0);\n  }\n  protected inProgressTasks = new Set<Task>();\n\n  /**\n   * A map of tasks that should be skipped, mapped to the task that caused them to be skipped.\n   */\n  private tasksToSkip = new Map<Task, Task>();\n\n  constructor(\n      protected logger: Logger, protected tasks: PartiallyOrderedTasks,\n      protected dependencies: TaskDependencies) {}\n\n  protected abstract computeNextTask(): Task|null;\n\n  getNextTask(): Task|null {\n    let nextTask = this.computeNextTask();\n    while (nextTask !== null) {\n      if (!this.tasksToSkip.has(nextTask)) {\n        break;\n      }\n      // We are skipping this task so mark it as complete\n      this.markAsCompleted(nextTask);\n      const failedTask = this.tasksToSkip.get(nextTask)!;\n      this.logger.warn(`Skipping processing of ${nextTask.entryPoint.name} because its dependency ${\n          failedTask.entryPoint.name} failed to compile.`);\n      nextTask = this.computeNextTask();\n    }\n    return nextTask;\n  }\n\n  markAsCompleted(task: Task): void {\n    if (!this.inProgressTasks.has(task)) {\n      throw new Error(\n          `Trying to mark task that was not in progress as completed: ${stringifyTask(task)}`);\n    }\n\n    this.inProgressTasks.delete(task);\n  }\n\n  markAsFailed(task: Task): void {\n    if (this.dependencies.has(task)) {\n      for (const dependentTask of this.dependencies.get(task)!) {\n        this.skipDependentTasks(dependentTask, task);\n      }\n    }\n  }\n\n  markAsUnprocessed(task: Task): void {\n    if (!this.inProgressTasks.has(task)) {\n      throw new Error(\n          `Trying to mark task that was not in progress as unprocessed: ${stringifyTask(task)}`);\n    }\n\n    this.inProgressTasks.delete(task);\n    this.tasks.unshift(task);\n  }\n\n  toString(): string {\n    const inProgTasks = Array.from(this.inProgressTasks);\n\n    return `${this.constructor.name}\\n` +\n        `  All tasks completed: ${this.allTasksCompleted}\\n` +\n        `  Unprocessed tasks (${this.tasks.length}): ${this.stringifyTasks(this.tasks, '    ')}\\n` +\n        `  In-progress tasks (${inProgTasks.length}): ${this.stringifyTasks(inProgTasks, '    ')}`;\n  }\n\n  /**\n   * Mark the given `task` as to be skipped, then recursive skip all its dependents.\n   *\n   * @param task The task to skip\n   * @param failedTask The task that failed, causing this task to be skipped\n   */\n  protected skipDependentTasks(task: Task, failedTask: Task) {\n    this.tasksToSkip.set(task, failedTask);\n    if (this.dependencies.has(task)) {\n      for (const dependentTask of this.dependencies.get(task)!) {\n        this.skipDependentTasks(dependentTask, failedTask);\n      }\n    }\n  }\n\n  protected stringifyTasks(tasks: Task[], indentation: string): string {\n    return tasks.map(task => `\\n${indentation}- ${stringifyTask(task)}`).join('');\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}