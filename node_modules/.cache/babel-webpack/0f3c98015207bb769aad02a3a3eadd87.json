{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/output/value_util\", [\"require\", \"exports\", \"@angular/compiler/src/util\", \"@angular/compiler/src/output/output_ast\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.convertValueToOutputAst = exports.QUOTED_KEYS = void 0;\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  exports.QUOTED_KEYS = '$quoted$';\n\n  function convertValueToOutputAst(ctx, value, type) {\n    if (type === void 0) {\n      type = null;\n    }\n\n    return util_1.visitValue(value, new _ValueOutputAstTransformer(ctx), type);\n  }\n\n  exports.convertValueToOutputAst = convertValueToOutputAst;\n\n  var _ValueOutputAstTransformer =\n  /** @class */\n  function () {\n    function _ValueOutputAstTransformer(ctx) {\n      this.ctx = ctx;\n    }\n\n    _ValueOutputAstTransformer.prototype.visitArray = function (arr, type) {\n      var values = []; // Note Array.map() must not be used to convert the values because it will\n      // skip over empty elements in arrays constructed using `new Array(length)`,\n      // resulting in `undefined` elements. This breaks the type guarantee that\n      // all values in `o.LiteralArrayExpr` are of type `o.Expression`.\n      // See test case in `value_util_spec.ts`.\n\n      for (var i = 0; i < arr.length; ++i) {\n        values.push(util_1.visitValue(arr[i], this, null\n        /* context */\n        ));\n      }\n\n      return o.literalArr(values, type);\n    };\n\n    _ValueOutputAstTransformer.prototype.visitStringMap = function (map, type) {\n      var _this = this;\n\n      var entries = [];\n      var quotedSet = new Set(map && map[exports.QUOTED_KEYS]);\n      Object.keys(map).forEach(function (key) {\n        entries.push(new o.LiteralMapEntry(key, util_1.visitValue(map[key], _this, null), quotedSet.has(key)));\n      });\n      return new o.LiteralMapExpr(entries, type);\n    };\n\n    _ValueOutputAstTransformer.prototype.visitPrimitive = function (value, type) {\n      return o.literal(value, type);\n    };\n\n    _ValueOutputAstTransformer.prototype.visitOther = function (value, type) {\n      if (value instanceof o.Expression) {\n        return value;\n      } else {\n        return this.ctx.importExpr(value);\n      }\n    };\n\n    return _ValueOutputAstTransformer;\n  }();\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/output/value_util.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAGH,MAAA,MAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AAEA,MAAA,CAAA,GAAA,OAAA,CAAA,yCAAA,CAAA;;AAEa,EAAA,OAAA,CAAA,WAAA,GAAc,UAAd;;AAEb,WAAgB,uBAAhB,CACI,GADJ,EACwB,KADxB,EACoC,IADpC,EAC4D;AAAxB,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAA,IAAA;AAAwB;;AAC1D,WAAO,MAAA,CAAA,UAAA,CAAW,KAAX,EAAkB,IAAI,0BAAJ,CAA+B,GAA/B,CAAlB,EAAuD,IAAvD,CAAP;AACD;;AAHD,EAAA,OAAA,CAAA,uBAAA,GAAA,uBAAA;;AAKA,MAAA,0BAAA;AAAA;AAAA,cAAA;AACE,aAAA,0BAAA,CAAoB,GAApB,EAAsC;AAAlB,WAAA,GAAA,GAAA,GAAA;AAAsB;;AAC1C,IAAA,0BAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,GAAX,EAAuB,IAAvB,EAAmC;AACjC,UAAM,MAAM,GAAmB,EAA/B,CADiC,CAEjC;AACA;AACA;AACA;AACA;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,GAAG,CAAC,MAAxB,EAAgC,EAAE,CAAlC,EAAqC;AACnC,QAAA,MAAM,CAAC,IAAP,CAAY,MAAA,CAAA,UAAA,CAAW,GAAG,CAAC,CAAD,CAAd,EAAmB,IAAnB,EAAyB;AAAK;AAA9B,SAAZ;AACD;;AACD,aAAO,CAAC,CAAC,UAAF,CAAa,MAAb,EAAqB,IAArB,CAAP;AACD,KAXD;;AAaA,IAAA,0BAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,GAAf,EAA0C,IAA1C,EAAyD;AAAzD,UAAA,KAAA,GAAA,IAAA;;AACE,UAAM,OAAO,GAAwB,EAArC;AACA,UAAM,SAAS,GAAG,IAAI,GAAJ,CAAgB,GAAG,IAAI,GAAG,CAAC,OAAA,CAAA,WAAD,CAA1B,CAAlB;AACA,MAAA,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,OAAjB,CAAyB,UAAA,GAAA,EAAG;AAC1B,QAAA,OAAO,CAAC,IAAR,CACI,IAAI,CAAC,CAAC,eAAN,CAAsB,GAAtB,EAA2B,MAAA,CAAA,UAAA,CAAW,GAAG,CAAC,GAAD,CAAd,EAAqB,KAArB,EAA2B,IAA3B,CAA3B,EAA6D,SAAS,CAAC,GAAV,CAAc,GAAd,CAA7D,CADJ;AAED,OAHD;AAIA,aAAO,IAAI,CAAC,CAAC,cAAN,CAAqB,OAArB,EAA8B,IAA9B,CAAP;AACD,KARD;;AAUA,IAAA,0BAAA,CAAA,SAAA,CAAA,cAAA,GAAA,UAAe,KAAf,EAA2B,IAA3B,EAAuC;AACrC,aAAO,CAAC,CAAC,OAAF,CAAU,KAAV,EAAiB,IAAjB,CAAP;AACD,KAFD;;AAIA,IAAA,0BAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,KAAX,EAAuB,IAAvB,EAAmC;AACjC,UAAI,KAAK,YAAY,CAAC,CAAC,UAAvB,EAAmC;AACjC,eAAO,KAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAK,GAAL,CAAS,UAAT,CAAoB,KAApB,CAAP;AACD;AACF,KAND;;AAOF,WAAA,0BAAA;AAAC,GApCD,EAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {OutputContext, ValueTransformer, visitValue} from '../util';\n\nimport * as o from './output_ast';\n\nexport const QUOTED_KEYS = '$quoted$';\n\nexport function convertValueToOutputAst(\n    ctx: OutputContext, value: any, type: o.Type|null = null): o.Expression {\n  return visitValue(value, new _ValueOutputAstTransformer(ctx), type);\n}\n\nclass _ValueOutputAstTransformer implements ValueTransformer {\n  constructor(private ctx: OutputContext) {}\n  visitArray(arr: any[], type: o.Type): o.Expression {\n    const values: o.Expression[] = [];\n    // Note Array.map() must not be used to convert the values because it will\n    // skip over empty elements in arrays constructed using `new Array(length)`,\n    // resulting in `undefined` elements. This breaks the type guarantee that\n    // all values in `o.LiteralArrayExpr` are of type `o.Expression`.\n    // See test case in `value_util_spec.ts`.\n    for (let i = 0; i < arr.length; ++i) {\n      values.push(visitValue(arr[i], this, null /* context */));\n    }\n    return o.literalArr(values, type);\n  }\n\n  visitStringMap(map: {[key: string]: any}, type: o.MapType): o.Expression {\n    const entries: o.LiteralMapEntry[] = [];\n    const quotedSet = new Set<string>(map && map[QUOTED_KEYS]);\n    Object.keys(map).forEach(key => {\n      entries.push(\n          new o.LiteralMapEntry(key, visitValue(map[key], this, null), quotedSet.has(key)));\n    });\n    return new o.LiteralMapExpr(entries, type);\n  }\n\n  visitPrimitive(value: any, type: o.Type): o.Expression {\n    return o.literal(value, type);\n  }\n\n  visitOther(value: any, type: o.Type): o.Expression {\n    if (value instanceof o.Expression) {\n      return value;\n    } else {\n      return this.ctx.importExpr(value);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}