{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/create_compile_function\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/ngcc/src/packages/entry_point\", \"@angular/compiler-cli/ngcc/src/packages/entry_point_bundle\", \"@angular/compiler-cli/ngcc/src/packages/source_file_cache\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getCreateCompileFn = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point\");\n\n  var entry_point_bundle_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point_bundle\");\n\n  var source_file_cache_1 = require(\"@angular/compiler-cli/ngcc/src/packages/source_file_cache\");\n  /**\n   * The function for creating the `compile()` function.\n   */\n\n\n  function getCreateCompileFn(fileSystem, logger, fileWriter, enableI18nLegacyMessageIdFormat, tsConfig, pathMappings) {\n    return function (beforeWritingFiles, onTaskCompleted) {\n      var Transformer = require('../packages/transformer').Transformer;\n\n      var transformer = new Transformer(fileSystem, logger, tsConfig);\n      var sharedFileCache = new source_file_cache_1.SharedFileCache(fileSystem);\n      var moduleResolutionCache = source_file_cache_1.createModuleResolutionCache(fileSystem);\n      return function (task) {\n        var entryPoint = task.entryPoint,\n            formatProperty = task.formatProperty,\n            formatPropertiesToMarkAsProcessed = task.formatPropertiesToMarkAsProcessed,\n            processDts = task.processDts;\n        var isCore = entryPoint.name === '@angular/core'; // Are we compiling the Angular core?\n\n        var packageJson = entryPoint.packageJson;\n        var formatPath = packageJson[formatProperty];\n        var format = entry_point_1.getEntryPointFormat(fileSystem, entryPoint, formatProperty); // All properties listed in `propertiesToProcess` are guaranteed to point to a format-path\n        // (i.e. they are defined in `entryPoint.packageJson`). Furthermore, they are also guaranteed\n        // to be among `SUPPORTED_FORMAT_PROPERTIES`.\n        // Based on the above, `formatPath` should always be defined and `getEntryPointFormat()`\n        // should always return a format here (and not `undefined`) unless `formatPath` points to a\n        // missing or empty file.\n\n        if (!formatPath || !format) {\n          onTaskCompleted(task, 1\n          /* Failed */\n          , \"property `\" + formatProperty + \"` pointing to a missing or empty file: \" + formatPath);\n          return;\n        }\n\n        logger.info(\"Compiling \" + entryPoint.name + \" : \" + formatProperty + \" as \" + format);\n        var bundle = entry_point_bundle_1.makeEntryPointBundle(fileSystem, entryPoint, sharedFileCache, moduleResolutionCache, formatPath, isCore, format, processDts, pathMappings, true, enableI18nLegacyMessageIdFormat);\n        var result = transformer.transform(bundle);\n\n        if (result.success) {\n          if (result.diagnostics.length > 0) {\n            logger.warn(diagnostics_1.replaceTsWithNgInErrors(ts.formatDiagnosticsWithColorAndContext(result.diagnostics, bundle.src.host)));\n          }\n\n          var writeBundle = function writeBundle() {\n            fileWriter.writeBundle(bundle, result.transformedFiles, formatPropertiesToMarkAsProcessed);\n            logger.debug(\"  Successfully compiled \" + entryPoint.name + \" : \" + formatProperty);\n            onTaskCompleted(task, 0\n            /* Processed */\n            , null);\n          };\n\n          var beforeWritingResult = beforeWritingFiles(result.transformedFiles);\n          return beforeWritingResult instanceof Promise ? beforeWritingResult.then(writeBundle) : writeBundle();\n        } else {\n          var errors = diagnostics_1.replaceTsWithNgInErrors(ts.formatDiagnosticsWithColorAndContext(result.diagnostics, bundle.src.host));\n          onTaskCompleted(task, 1\n          /* Failed */\n          , \"compilation errors:\\n\" + errors);\n        }\n      };\n    };\n  }\n\n  exports.getCreateCompileFn = getCreateCompileFn;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/execution/create_compile_function.ts"],"names":[],"mappings":"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","sourcesContent":["\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {replaceTsWithNgInErrors} from '../../../src/ngtsc/diagnostics';\nimport {FileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {ParsedConfiguration} from '../../../src/perform_compile';\nimport {getEntryPointFormat} from '../packages/entry_point';\nimport {makeEntryPointBundle} from '../packages/entry_point_bundle';\nimport {createModuleResolutionCache, SharedFileCache} from '../packages/source_file_cache';\nimport {PathMappings} from '../path_mappings';\nimport {FileWriter} from '../writing/file_writer';\n\nimport {CreateCompileFn} from './api';\nimport {Task, TaskProcessingOutcome} from './tasks/api';\n\n/**\n * The function for creating the `compile()` function.\n */\nexport function getCreateCompileFn(\n    fileSystem: FileSystem, logger: Logger, fileWriter: FileWriter,\n    enableI18nLegacyMessageIdFormat: boolean, tsConfig: ParsedConfiguration|null,\n    pathMappings: PathMappings|undefined): CreateCompileFn {\n  return (beforeWritingFiles, onTaskCompleted) => {\n    const {Transformer} = require('../packages/transformer');\n    const transformer = new Transformer(fileSystem, logger, tsConfig);\n    const sharedFileCache = new SharedFileCache(fileSystem);\n    const moduleResolutionCache = createModuleResolutionCache(fileSystem);\n\n    return (task: Task) => {\n      const {entryPoint, formatProperty, formatPropertiesToMarkAsProcessed, processDts} = task;\n\n      const isCore = entryPoint.name === '@angular/core';  // Are we compiling the Angular core?\n      const packageJson = entryPoint.packageJson;\n      const formatPath = packageJson[formatProperty];\n      const format = getEntryPointFormat(fileSystem, entryPoint, formatProperty);\n\n      // All properties listed in `propertiesToProcess` are guaranteed to point to a format-path\n      // (i.e. they are defined in `entryPoint.packageJson`). Furthermore, they are also guaranteed\n      // to be among `SUPPORTED_FORMAT_PROPERTIES`.\n      // Based on the above, `formatPath` should always be defined and `getEntryPointFormat()`\n      // should always return a format here (and not `undefined`) unless `formatPath` points to a\n      // missing or empty file.\n      if (!formatPath || !format) {\n        onTaskCompleted(\n            task, TaskProcessingOutcome.Failed,\n            `property \\`${formatProperty}\\` pointing to a missing or empty file: ${formatPath}`);\n        return;\n      }\n\n      logger.info(`Compiling ${entryPoint.name} : ${formatProperty} as ${format}`);\n\n      const bundle = makeEntryPointBundle(\n          fileSystem, entryPoint, sharedFileCache, moduleResolutionCache, formatPath, isCore,\n          format, processDts, pathMappings, true, enableI18nLegacyMessageIdFormat);\n\n      const result = transformer.transform(bundle);\n      if (result.success) {\n        if (result.diagnostics.length > 0) {\n          logger.warn(replaceTsWithNgInErrors(\n              ts.formatDiagnosticsWithColorAndContext(result.diagnostics, bundle.src.host)));\n        }\n\n        const writeBundle = () => {\n          fileWriter.writeBundle(\n              bundle, result.transformedFiles, formatPropertiesToMarkAsProcessed);\n\n          logger.debug(`  Successfully compiled ${entryPoint.name} : ${formatProperty}`);\n          onTaskCompleted(task, TaskProcessingOutcome.Processed, null);\n        };\n\n        const beforeWritingResult = beforeWritingFiles(result.transformedFiles);\n\n        return (beforeWritingResult instanceof Promise) ?\n            beforeWritingResult.then(writeBundle) as ReturnType<typeof beforeWritingFiles>:\n            writeBundle();\n      } else {\n        const errors = replaceTsWithNgInErrors(\n            ts.formatDiagnosticsWithColorAndContext(result.diagnostics, bundle.src.host));\n        onTaskCompleted(task, TaskProcessingOutcome.Failed, `compilation errors:\\n${errors}`);\n      }\n    };\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}