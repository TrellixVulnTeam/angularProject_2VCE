{"ast":null,"code":"/* jshint node: true */\n'use strict';\n\nvar REGEXP_PARTS = /(\\*|\\?)/g;\n/**\n  # wildcard\n\n  Very simple wildcard matching, which is designed to provide the same\n  functionality that is found in the\n  [eve](https://github.com/adobe-webplatform/eve) eventing library.\n\n  ## Usage\n\n  It works with strings:\n\n  <<< examples/strings.js\n\n  Arrays:\n\n  <<< examples/arrays.js\n\n  Objects (matching against keys):\n\n  <<< examples/objects.js\n\n  ## Alternative Implementations\n\n  - <https://github.com/isaacs/node-glob>\n\n    Great for full file-based wildcard matching.\n\n  - <https://github.com/sindresorhus/matcher>\n\n     A well cared for and loved JS wildcard matcher.\n**/\n\nfunction WildcardMatcher(text, separator) {\n  this.text = text = text || '';\n  this.hasWild = text.indexOf('*') >= 0;\n  this.separator = separator;\n  this.parts = text.split(separator).map(this.classifyPart.bind(this));\n}\n\nWildcardMatcher.prototype.match = function (input) {\n  var matches = true;\n  var parts = this.parts;\n  var ii;\n  var partsCount = parts.length;\n  var testParts;\n\n  if (typeof input == 'string' || input instanceof String) {\n    if (!this.hasWild && this.text != input) {\n      matches = false;\n    } else {\n      testParts = (input || '').split(this.separator);\n\n      for (ii = 0; matches && ii < partsCount; ii++) {\n        if (parts[ii] === '*') {\n          continue;\n        } else if (ii < testParts.length) {\n          matches = parts[ii] instanceof RegExp ? parts[ii].test(testParts[ii]) : parts[ii] === testParts[ii];\n        } else {\n          matches = false;\n        }\n      } // If matches, then return the component parts\n\n\n      matches = matches && testParts;\n    }\n  } else if (typeof input.splice == 'function') {\n    matches = [];\n\n    for (ii = input.length; ii--;) {\n      if (this.match(input[ii])) {\n        matches[matches.length] = input[ii];\n      }\n    }\n  } else if (typeof input == 'object') {\n    matches = {};\n\n    for (var key in input) {\n      if (this.match(key)) {\n        matches[key] = input[key];\n      }\n    }\n  }\n\n  return matches;\n};\n\nWildcardMatcher.prototype.classifyPart = function (part) {\n  // in the event that we have been provided a part that is not just a wildcard\n  // then turn this into a regular expression for matching purposes\n  if (part === '*') {\n    return part;\n  } else if (part.indexOf('*') >= 0 || part.indexOf('?') >= 0) {\n    return new RegExp(part.replace(REGEXP_PARTS, '\\.$1'));\n  }\n\n  return part;\n};\n\nmodule.exports = function (text, test, separator) {\n  var matcher = new WildcardMatcher(text, separator || /[\\/\\.]/);\n\n  if (typeof test != 'undefined') {\n    return matcher.match(test);\n  }\n\n  return matcher;\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/wildcard/index.js"],"names":["REGEXP_PARTS","WildcardMatcher","text","separator","hasWild","indexOf","parts","split","map","classifyPart","bind","prototype","match","input","matches","ii","partsCount","length","testParts","String","RegExp","test","splice","key","part","replace","module","exports","matcher"],"mappings":"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","sourcesContent":["/* jshint node: true */\n'use strict';\n\nvar REGEXP_PARTS = /(\\*|\\?)/g;\n\n/**\n  # wildcard\n\n  Very simple wildcard matching, which is designed to provide the same\n  functionality that is found in the\n  [eve](https://github.com/adobe-webplatform/eve) eventing library.\n\n  ## Usage\n\n  It works with strings:\n\n  <<< examples/strings.js\n\n  Arrays:\n\n  <<< examples/arrays.js\n\n  Objects (matching against keys):\n\n  <<< examples/objects.js\n\n  ## Alternative Implementations\n\n  - <https://github.com/isaacs/node-glob>\n\n    Great for full file-based wildcard matching.\n\n  - <https://github.com/sindresorhus/matcher>\n\n     A well cared for and loved JS wildcard matcher.\n**/\n\nfunction WildcardMatcher(text, separator) {\n  this.text = text = text || '';\n  this.hasWild = text.indexOf('*') >= 0;\n  this.separator = separator;\n  this.parts = text.split(separator).map(this.classifyPart.bind(this));\n}\n\nWildcardMatcher.prototype.match = function(input) {\n  var matches = true;\n  var parts = this.parts;\n  var ii;\n  var partsCount = parts.length;\n  var testParts;\n\n  if (typeof input == 'string' || input instanceof String) {\n    if (!this.hasWild && this.text != input) {\n      matches = false;\n    } else {\n      testParts = (input || '').split(this.separator);\n      for (ii = 0; matches && ii < partsCount; ii++) {\n        if (parts[ii] === '*')  {\n          continue;\n        } else if (ii < testParts.length) {\n          matches = parts[ii] instanceof RegExp\n            ? parts[ii].test(testParts[ii])\n            : parts[ii] === testParts[ii];\n        } else {\n          matches = false;\n        }\n      }\n\n      // If matches, then return the component parts\n      matches = matches && testParts;\n    }\n  }\n  else if (typeof input.splice == 'function') {\n    matches = [];\n\n    for (ii = input.length; ii--; ) {\n      if (this.match(input[ii])) {\n        matches[matches.length] = input[ii];\n      }\n    }\n  }\n  else if (typeof input == 'object') {\n    matches = {};\n\n    for (var key in input) {\n      if (this.match(key)) {\n        matches[key] = input[key];\n      }\n    }\n  }\n\n  return matches;\n};\n\nWildcardMatcher.prototype.classifyPart = function(part) {\n  // in the event that we have been provided a part that is not just a wildcard\n  // then turn this into a regular expression for matching purposes\n  if (part === '*') {\n    return part;\n  } else if (part.indexOf('*') >= 0 || part.indexOf('?') >= 0) {\n    return new RegExp(part.replace(REGEXP_PARTS, '\\.$1'));\n  }\n\n  return part;\n};\n\nmodule.exports = function(text, test, separator) {\n  var matcher = new WildcardMatcher(text, separator || /[\\/\\.]/);\n  if (typeof test != 'undefined') {\n    return matcher.match(test);\n  }\n\n  return matcher;\n};\n"]},"metadata":{},"sourceType":"script"}