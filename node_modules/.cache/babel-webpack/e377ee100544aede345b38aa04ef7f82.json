{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/i18n/localize_utils\", [\"require\", \"exports\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/render3/view/i18n/icu_serializer\", \"@angular/compiler/src/render3/view/i18n/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.serializeI18nMessageForLocalize = exports.createLocalizeStatements = void 0;\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var icu_serializer_1 = require(\"@angular/compiler/src/render3/view/i18n/icu_serializer\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/view/i18n/util\");\n\n  function createLocalizeStatements(variable, message, params) {\n    var _a = serializeI18nMessageForLocalize(message),\n        messageParts = _a.messageParts,\n        placeHolders = _a.placeHolders;\n\n    var sourceSpan = getSourceSpan(message);\n    var expressions = placeHolders.map(function (ph) {\n      return params[ph.text];\n    });\n    var localizedString = o.localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n    var variableInitialization = variable.set(localizedString);\n    return [new o.ExpressionStatement(variableInitialization)];\n  }\n\n  exports.createLocalizeStatements = createLocalizeStatements;\n  /**\n   * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n   *\n   * The result can be used for generating the `$localize` tagged template literals.\n   */\n\n  var LocalizeSerializerVisitor =\n  /** @class */\n  function () {\n    function LocalizeSerializerVisitor() {}\n\n    LocalizeSerializerVisitor.prototype.visitText = function (text, context) {\n      if (context[context.length - 1] instanceof o.LiteralPiece) {\n        // Two literal pieces in a row means that there was some comment node in-between.\n        context[context.length - 1].text += text.value;\n      } else {\n        context.push(new o.LiteralPiece(text.value, text.sourceSpan));\n      }\n    };\n\n    LocalizeSerializerVisitor.prototype.visitContainer = function (container, context) {\n      var _this = this;\n\n      container.children.forEach(function (child) {\n        return child.visit(_this, context);\n      });\n    };\n\n    LocalizeSerializerVisitor.prototype.visitIcu = function (icu, context) {\n      context.push(new o.LiteralPiece(icu_serializer_1.serializeIcuNode(icu), icu.sourceSpan));\n    };\n\n    LocalizeSerializerVisitor.prototype.visitTagPlaceholder = function (ph, context) {\n      var _this = this;\n\n      var _a, _b;\n\n      context.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));\n\n      if (!ph.isVoid) {\n        ph.children.forEach(function (child) {\n          return child.visit(_this, context);\n        });\n        context.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));\n      }\n    };\n\n    LocalizeSerializerVisitor.prototype.visitPlaceholder = function (ph, context) {\n      context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n    };\n\n    LocalizeSerializerVisitor.prototype.visitIcuPlaceholder = function (ph, context) {\n      context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n    };\n\n    LocalizeSerializerVisitor.prototype.createPlaceholderPiece = function (name, sourceSpan) {\n      return new o.PlaceholderPiece(util_1.formatI18nPlaceholderName(name,\n      /* useCamelCase */\n      false), sourceSpan);\n    };\n\n    return LocalizeSerializerVisitor;\n  }();\n\n  var serializerVisitor = new LocalizeSerializerVisitor();\n  /**\n   * Serialize an i18n message into two arrays: messageParts and placeholders.\n   *\n   * These arrays will be used to generate `$localize` tagged template literals.\n   *\n   * @param message The message to be serialized.\n   * @returns an object containing the messageParts and placeholders.\n   */\n\n  function serializeI18nMessageForLocalize(message) {\n    var pieces = [];\n    message.nodes.forEach(function (node) {\n      return node.visit(serializerVisitor, pieces);\n    });\n    return processMessagePieces(pieces);\n  }\n\n  exports.serializeI18nMessageForLocalize = serializeI18nMessageForLocalize;\n\n  function getSourceSpan(message) {\n    var startNode = message.nodes[0];\n    var endNode = message.nodes[message.nodes.length - 1];\n    return new parse_util_1.ParseSourceSpan(startNode.sourceSpan.start, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\n  }\n  /**\n   * Convert the list of serialized MessagePieces into two arrays.\n   *\n   * One contains the literal string pieces and the other the placeholders that will be replaced by\n   * expressions when rendering `$localize` tagged template literals.\n   *\n   * @param pieces The pieces to process.\n   * @returns an object containing the messageParts and placeholders.\n   */\n\n\n  function processMessagePieces(pieces) {\n    var messageParts = [];\n    var placeHolders = [];\n\n    if (pieces[0] instanceof o.PlaceholderPiece) {\n      // The first piece was a placeholder so we need to add an initial empty message part.\n      messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n    }\n\n    for (var i = 0; i < pieces.length; i++) {\n      var part = pieces[i];\n\n      if (part instanceof o.LiteralPiece) {\n        messageParts.push(part);\n      } else {\n        placeHolders.push(part);\n\n        if (pieces[i - 1] instanceof o.PlaceholderPiece) {\n          // There were two placeholders in a row, so we need to add an empty message part.\n          messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n        }\n      }\n    }\n\n    if (pieces[pieces.length - 1] instanceof o.PlaceholderPiece) {\n      // The last piece was a placeholder so we need to add a final empty message part.\n      messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n    }\n\n    return {\n      messageParts: messageParts,\n      placeHolders: placeHolders\n    };\n  }\n\n  function createEmptyMessagePart(location) {\n    return new o.LiteralPiece('', new parse_util_1.ParseSourceSpan(location, location));\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler/src/render3/view/i18n/localize_utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport * as o from '../../../output/output_ast';\nimport {ParseLocation, ParseSourceSpan} from '../../../parse_util';\n\nimport {serializeIcuNode} from './icu_serializer';\nimport {formatI18nPlaceholderName} from './util';\n\nexport function createLocalizeStatements(\n    variable: o.ReadVarExpr, message: i18n.Message,\n    params: {[name: string]: o.Expression}): o.Statement[] {\n  const {messageParts, placeHolders} = serializeI18nMessageForLocalize(message);\n  const sourceSpan = getSourceSpan(message);\n  const expressions = placeHolders.map(ph => params[ph.text]);\n  const localizedString =\n      o.localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n  const variableInitialization = variable.set(localizedString);\n  return [new o.ExpressionStatement(variableInitialization)];\n}\n\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\nclass LocalizeSerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: o.MessagePiece[]): any {\n    if (context[context.length - 1] instanceof o.LiteralPiece) {\n      // Two literal pieces in a row means that there was some comment node in-between.\n      context[context.length - 1].text += text.value;\n    } else {\n      context.push(new o.LiteralPiece(text.value, text.sourceSpan));\n    }\n  }\n\n  visitContainer(container: i18n.Container, context: o.MessagePiece[]): any {\n    container.children.forEach(child => child.visit(this, context));\n  }\n\n  visitIcu(icu: i18n.Icu, context: o.MessagePiece[]): any {\n    context.push(new o.LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: o.MessagePiece[]): any {\n    context.push(this.createPlaceholderPiece(ph.startName, ph.startSourceSpan ?? ph.sourceSpan));\n    if (!ph.isVoid) {\n      ph.children.forEach(child => child.visit(this, context));\n      context.push(this.createPlaceholderPiece(ph.closeName, ph.endSourceSpan ?? ph.sourceSpan));\n    }\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: o.MessagePiece[]): any {\n    context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n  }\n\n  private createPlaceholderPiece(name: string, sourceSpan: ParseSourceSpan): o.PlaceholderPiece {\n    return new o.PlaceholderPiece(\n        formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan);\n  }\n}\n\nconst serializerVisitor = new LocalizeSerializerVisitor();\n\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\nexport function serializeI18nMessageForLocalize(message: i18n.Message):\n    {messageParts: o.LiteralPiece[], placeHolders: o.PlaceholderPiece[]} {\n  const pieces: o.MessagePiece[] = [];\n  message.nodes.forEach(node => node.visit(serializerVisitor, pieces));\n  return processMessagePieces(pieces);\n}\n\nfunction getSourceSpan(message: i18n.Message): ParseSourceSpan {\n  const startNode = message.nodes[0];\n  const endNode = message.nodes[message.nodes.length - 1];\n  return new ParseSourceSpan(\n      startNode.sourceSpan.start, endNode.sourceSpan.end, startNode.sourceSpan.fullStart,\n      startNode.sourceSpan.details);\n}\n\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\nfunction processMessagePieces(pieces: o.MessagePiece[]):\n    {messageParts: o.LiteralPiece[], placeHolders: o.PlaceholderPiece[]} {\n  const messageParts: o.LiteralPiece[] = [];\n  const placeHolders: o.PlaceholderPiece[] = [];\n\n  if (pieces[0] instanceof o.PlaceholderPiece) {\n    // The first piece was a placeholder so we need to add an initial empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n  }\n\n  for (let i = 0; i < pieces.length; i++) {\n    const part = pieces[i];\n    if (part instanceof o.LiteralPiece) {\n      messageParts.push(part);\n    } else {\n      placeHolders.push(part);\n      if (pieces[i - 1] instanceof o.PlaceholderPiece) {\n        // There were two placeholders in a row, so we need to add an empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n      }\n    }\n  }\n  if (pieces[pieces.length - 1] instanceof o.PlaceholderPiece) {\n    // The last piece was a placeholder so we need to add a final empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n  }\n  return {messageParts, placeHolders};\n}\n\nfunction createEmptyMessagePart(location: ParseLocation): o.LiteralPiece {\n  return new o.LiteralPiece('', new ParseSourceSpan(location, location));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}