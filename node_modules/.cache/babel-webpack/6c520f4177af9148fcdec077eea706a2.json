{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/perf/src/api\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.PerfCheckpoint = exports.PerfEvent = exports.PerfPhase = void 0;\n  /**\n   * A phase of compilation for which time is tracked in a distinct bucket.\n   */\n\n  var PerfPhase;\n\n  (function (PerfPhase) {\n    /**\n     * The \"default\" phase which tracks time not spent in any other phase.\n     */\n    PerfPhase[PerfPhase[\"Unaccounted\"] = 0] = \"Unaccounted\";\n    /**\n     * Time spent setting up the compiler, before a TypeScript program is created.\n     *\n     * This includes operations like configuring the `ts.CompilerHost` and any wrappers.\n     */\n\n    PerfPhase[PerfPhase[\"Setup\"] = 1] = \"Setup\";\n    /**\n     * Time spent in `ts.createProgram`, including reading and parsing `ts.SourceFile`s in the\n     * `ts.CompilerHost`.\n     *\n     * This might be an incremental program creation operation.\n     */\n\n    PerfPhase[PerfPhase[\"TypeScriptProgramCreate\"] = 2] = \"TypeScriptProgramCreate\";\n    /**\n     * Time spent reconciling the contents of an old `ts.Program` with the new incremental one.\n     *\n     * Only present in incremental compilations.\n     */\n\n    PerfPhase[PerfPhase[\"Reconciliation\"] = 3] = \"Reconciliation\";\n    /**\n     * Time spent updating an `NgCompiler` instance with a resource-only change.\n     *\n     * Only present in incremental compilations where the change was resource-only.\n     */\n\n    PerfPhase[PerfPhase[\"ResourceUpdate\"] = 4] = \"ResourceUpdate\";\n    /**\n     * Time spent calculating the plain TypeScript diagnostics (structural and semantic).\n     */\n\n    PerfPhase[PerfPhase[\"TypeScriptDiagnostics\"] = 5] = \"TypeScriptDiagnostics\";\n    /**\n     * Time spent in Angular analysis of individual classes in the program.\n     */\n\n    PerfPhase[PerfPhase[\"Analysis\"] = 6] = \"Analysis\";\n    /**\n     * Time spent in Angular global analysis (synthesis of analysis information into a complete\n     * understanding of the program).\n     */\n\n    PerfPhase[PerfPhase[\"Resolve\"] = 7] = \"Resolve\";\n    /**\n     * Time spent building the import graph of the program in order to perform cycle detection.\n     */\n\n    PerfPhase[PerfPhase[\"CycleDetection\"] = 8] = \"CycleDetection\";\n    /**\n     * Time spent generating the text of Type Check Blocks in order to perform template type checking.\n     */\n\n    PerfPhase[PerfPhase[\"TcbGeneration\"] = 9] = \"TcbGeneration\";\n    /**\n     * Time spent updating the `ts.Program` with new Type Check Block code.\n     */\n\n    PerfPhase[PerfPhase[\"TcbUpdateProgram\"] = 10] = \"TcbUpdateProgram\";\n    /**\n     * Time spent by TypeScript performing its emit operations, including downleveling and writing\n     * output files.\n     */\n\n    PerfPhase[PerfPhase[\"TypeScriptEmit\"] = 11] = \"TypeScriptEmit\";\n    /**\n     * Time spent by Angular performing code transformations of ASTs as they're about to be emitted.\n     *\n     * This includes the actual code generation step for templates, and occurs during the emit phase\n     * (but is tracked separately from `TypeScriptEmit` time).\n     */\n\n    PerfPhase[PerfPhase[\"Compile\"] = 12] = \"Compile\";\n    /**\n     * Time spent performing a `TemplateTypeChecker` autocompletion operation.\n     */\n\n    PerfPhase[PerfPhase[\"TtcAutocompletion\"] = 13] = \"TtcAutocompletion\";\n    /**\n     * Time spent computing template type-checking diagnostics.\n     */\n\n    PerfPhase[PerfPhase[\"TtcDiagnostics\"] = 14] = \"TtcDiagnostics\";\n    /**\n     * Time spent getting a `Symbol` from the `TemplateTypeChecker`.\n     */\n\n    PerfPhase[PerfPhase[\"TtcSymbol\"] = 15] = \"TtcSymbol\";\n    /**\n     * Time spent by the Angular Language Service calculating a \"get references\" or a renaming\n     * operation.\n     */\n\n    PerfPhase[PerfPhase[\"LsReferencesAndRenames\"] = 16] = \"LsReferencesAndRenames\";\n    /**\n     * Time spent by the Angular Language Service calculating a \"quick info\" operation.\n     */\n\n    PerfPhase[PerfPhase[\"LsQuickInfo\"] = 17] = \"LsQuickInfo\";\n    /**\n     * Time spent by the Angular Language Service calculating a \"get type definition\" or \"get\n     * definition\" operation.\n     */\n\n    PerfPhase[PerfPhase[\"LsDefinition\"] = 18] = \"LsDefinition\";\n    /**\n     * Time spent by the Angular Language Service calculating a \"get completions\" (AKA autocomplete)\n     * operation.\n     */\n\n    PerfPhase[PerfPhase[\"LsCompletions\"] = 19] = \"LsCompletions\";\n    /**\n     * Time spent by the Angular Language Service calculating a \"view template typecheck block\"\n     * operation.\n     */\n\n    PerfPhase[PerfPhase[\"LsTcb\"] = 20] = \"LsTcb\";\n    /**\n     * Time spent by the Angular Language Service calculating diagnostics.\n     */\n\n    PerfPhase[PerfPhase[\"LsDiagnostics\"] = 21] = \"LsDiagnostics\";\n    /**\n     * Time spent by the Angular Language Service calculating a \"get component locations for template\"\n     * operation.\n     */\n\n    PerfPhase[PerfPhase[\"LsComponentLocations\"] = 22] = \"LsComponentLocations\";\n    /**\n     * Tracks the number of `PerfPhase`s, and must appear at the end of the list.\n     */\n\n    PerfPhase[PerfPhase[\"LAST\"] = 23] = \"LAST\";\n  })(PerfPhase = exports.PerfPhase || (exports.PerfPhase = {}));\n  /**\n   * Represents some occurrence during compilation, and is tracked with a counter.\n   */\n\n\n  var PerfEvent;\n\n  (function (PerfEvent) {\n    /**\n     * Counts the number of `.d.ts` files in the program.\n     */\n    PerfEvent[PerfEvent[\"InputDtsFile\"] = 0] = \"InputDtsFile\";\n    /**\n     * Counts the number of non-`.d.ts` files in the program.\n     */\n\n    PerfEvent[PerfEvent[\"InputTsFile\"] = 1] = \"InputTsFile\";\n    /**\n     * An `@Component` class was analyzed.\n     */\n\n    PerfEvent[PerfEvent[\"AnalyzeComponent\"] = 2] = \"AnalyzeComponent\";\n    /**\n     * An `@Directive` class was analyzed.\n     */\n\n    PerfEvent[PerfEvent[\"AnalyzeDirective\"] = 3] = \"AnalyzeDirective\";\n    /**\n     * An `@Injectable` class was analyzed.\n     */\n\n    PerfEvent[PerfEvent[\"AnalyzeInjectable\"] = 4] = \"AnalyzeInjectable\";\n    /**\n     * An `@NgModule` class was analyzed.\n     */\n\n    PerfEvent[PerfEvent[\"AnalyzeNgModule\"] = 5] = \"AnalyzeNgModule\";\n    /**\n     * An `@Pipe` class was analyzed.\n     */\n\n    PerfEvent[PerfEvent[\"AnalyzePipe\"] = 6] = \"AnalyzePipe\";\n    /**\n     * A trait was analyzed.\n     *\n     * In theory, this should be the sum of the `Analyze` counters for each decorator type.\n     */\n\n    PerfEvent[PerfEvent[\"TraitAnalyze\"] = 7] = \"TraitAnalyze\";\n    /**\n     * A trait had a prior analysis available from an incremental program, and did not need to be\n     * re-analyzed.\n     */\n\n    PerfEvent[PerfEvent[\"TraitReuseAnalysis\"] = 8] = \"TraitReuseAnalysis\";\n    /**\n     * A `ts.SourceFile` directly changed between the prior program and a new incremental compilation.\n     */\n\n    PerfEvent[PerfEvent[\"SourceFilePhysicalChange\"] = 9] = \"SourceFilePhysicalChange\";\n    /**\n     * A `ts.SourceFile` did not physically changed, but according to the file dependency graph, has\n     * logically changed between the prior program and a new incremental compilation.\n     */\n\n    PerfEvent[PerfEvent[\"SourceFileLogicalChange\"] = 10] = \"SourceFileLogicalChange\";\n    /**\n     * A `ts.SourceFile` has not logically changed and all of its analysis results were thus available\n     * for reuse.\n     */\n\n    PerfEvent[PerfEvent[\"SourceFileReuseAnalysis\"] = 11] = \"SourceFileReuseAnalysis\";\n    /**\n     * A Type Check Block (TCB) was generated.\n     */\n\n    PerfEvent[PerfEvent[\"GenerateTcb\"] = 12] = \"GenerateTcb\";\n    /**\n     * A Type Check Block (TCB) could not be generated because inlining was disabled, and the block\n     * would've required inlining.\n     */\n\n    PerfEvent[PerfEvent[\"SkipGenerateTcbNoInline\"] = 13] = \"SkipGenerateTcbNoInline\";\n    /**\n     * A `.ngtypecheck.ts` file could be reused from the previous program and did not need to be\n     * regenerated.\n     */\n\n    PerfEvent[PerfEvent[\"ReuseTypeCheckFile\"] = 14] = \"ReuseTypeCheckFile\";\n    /**\n     * The template type-checking program required changes and had to be updated in an incremental\n     * step.\n     */\n\n    PerfEvent[PerfEvent[\"UpdateTypeCheckProgram\"] = 15] = \"UpdateTypeCheckProgram\";\n    /**\n     * The compiler was able to prove that a `ts.SourceFile` did not need to be re-emitted.\n     */\n\n    PerfEvent[PerfEvent[\"EmitSkipSourceFile\"] = 16] = \"EmitSkipSourceFile\";\n    /**\n     * A `ts.SourceFile` was emitted.\n     */\n\n    PerfEvent[PerfEvent[\"EmitSourceFile\"] = 17] = \"EmitSourceFile\";\n    /**\n     * Tracks the number of `PrefEvent`s, and must appear at the end of the list.\n     */\n\n    PerfEvent[PerfEvent[\"LAST\"] = 18] = \"LAST\";\n  })(PerfEvent = exports.PerfEvent || (exports.PerfEvent = {}));\n  /**\n   * Represents a checkpoint during compilation at which the memory usage of the compiler should be\n   * recorded.\n   */\n\n\n  var PerfCheckpoint;\n\n  (function (PerfCheckpoint) {\n    /**\n     * The point at which the `PerfRecorder` was created, and ideally tracks memory used before any\n     * compilation structures are created.\n     */\n    PerfCheckpoint[PerfCheckpoint[\"Initial\"] = 0] = \"Initial\";\n    /**\n     * The point just after the `ts.Program` has been created.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"TypeScriptProgramCreate\"] = 1] = \"TypeScriptProgramCreate\";\n    /**\n     * The point just before Angular analysis starts.\n     *\n     * In the main usage pattern for the compiler, TypeScript diagnostics have been calculated at this\n     * point, so the `ts.TypeChecker` has fully ingested the current program, all `ts.Type` structures\n     * and `ts.Symbol`s have been created.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"PreAnalysis\"] = 2] = \"PreAnalysis\";\n    /**\n     * The point just after Angular analysis completes.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"Analysis\"] = 3] = \"Analysis\";\n    /**\n     * The point just after Angular resolution is complete.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"Resolve\"] = 4] = \"Resolve\";\n    /**\n     * The point just after Type Check Blocks (TCBs) have been generated.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"TtcGeneration\"] = 5] = \"TtcGeneration\";\n    /**\n     * The point just after the template type-checking program has been updated with any new TCBs.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"TtcUpdateProgram\"] = 6] = \"TtcUpdateProgram\";\n    /**\n     * The point just before emit begins.\n     *\n     * In the main usage pattern for the compiler, all template type-checking diagnostics have been\n     * requested at this point.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"PreEmit\"] = 7] = \"PreEmit\";\n    /**\n     * The point just after the program has been fully emitted.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"Emit\"] = 8] = \"Emit\";\n    /**\n     * Tracks the number of `PerfCheckpoint`s, and must appear at the end of the list.\n     */\n\n    PerfCheckpoint[PerfCheckpoint[\"LAST\"] = 9] = \"LAST\";\n  })(PerfCheckpoint = exports.PerfCheckpoint || (exports.PerfCheckpoint = {}));\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/perf/src/api.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A phase of compilation for which time is tracked in a distinct bucket.\n */\nexport enum PerfPhase {\n  /**\n   * The \"default\" phase which tracks time not spent in any other phase.\n   */\n  Unaccounted,\n\n  /**\n   * Time spent setting up the compiler, before a TypeScript program is created.\n   *\n   * This includes operations like configuring the `ts.CompilerHost` and any wrappers.\n   */\n  Setup,\n\n  /**\n   * Time spent in `ts.createProgram`, including reading and parsing `ts.SourceFile`s in the\n   * `ts.CompilerHost`.\n   *\n   * This might be an incremental program creation operation.\n   */\n  TypeScriptProgramCreate,\n\n  /**\n   * Time spent reconciling the contents of an old `ts.Program` with the new incremental one.\n   *\n   * Only present in incremental compilations.\n   */\n  Reconciliation,\n\n  /**\n   * Time spent updating an `NgCompiler` instance with a resource-only change.\n   *\n   * Only present in incremental compilations where the change was resource-only.\n   */\n  ResourceUpdate,\n\n  /**\n   * Time spent calculating the plain TypeScript diagnostics (structural and semantic).\n   */\n  TypeScriptDiagnostics,\n\n  /**\n   * Time spent in Angular analysis of individual classes in the program.\n   */\n  Analysis,\n\n  /**\n   * Time spent in Angular global analysis (synthesis of analysis information into a complete\n   * understanding of the program).\n   */\n  Resolve,\n\n  /**\n   * Time spent building the import graph of the program in order to perform cycle detection.\n   */\n  CycleDetection,\n\n  /**\n   * Time spent generating the text of Type Check Blocks in order to perform template type checking.\n   */\n  TcbGeneration,\n\n  /**\n   * Time spent updating the `ts.Program` with new Type Check Block code.\n   */\n  TcbUpdateProgram,\n\n  /**\n   * Time spent by TypeScript performing its emit operations, including downleveling and writing\n   * output files.\n   */\n  TypeScriptEmit,\n\n  /**\n   * Time spent by Angular performing code transformations of ASTs as they're about to be emitted.\n   *\n   * This includes the actual code generation step for templates, and occurs during the emit phase\n   * (but is tracked separately from `TypeScriptEmit` time).\n   */\n  Compile,\n\n  /**\n   * Time spent performing a `TemplateTypeChecker` autocompletion operation.\n   */\n  TtcAutocompletion,\n\n  /**\n   * Time spent computing template type-checking diagnostics.\n   */\n  TtcDiagnostics,\n\n  /**\n   * Time spent getting a `Symbol` from the `TemplateTypeChecker`.\n   */\n  TtcSymbol,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"get references\" or a renaming\n   * operation.\n   */\n  LsReferencesAndRenames,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"quick info\" operation.\n   */\n  LsQuickInfo,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"get type definition\" or \"get\n   * definition\" operation.\n   */\n  LsDefinition,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"get completions\" (AKA autocomplete)\n   * operation.\n   */\n  LsCompletions,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"view template typecheck block\"\n   * operation.\n   */\n  LsTcb,\n\n  /**\n   * Time spent by the Angular Language Service calculating diagnostics.\n   */\n  LsDiagnostics,\n\n  /**\n   * Time spent by the Angular Language Service calculating a \"get component locations for template\"\n   * operation.\n   */\n  LsComponentLocations,\n\n  /**\n   * Tracks the number of `PerfPhase`s, and must appear at the end of the list.\n   */\n  LAST,\n}\n\n/**\n * Represents some occurrence during compilation, and is tracked with a counter.\n */\nexport enum PerfEvent {\n  /**\n   * Counts the number of `.d.ts` files in the program.\n   */\n  InputDtsFile,\n\n  /**\n   * Counts the number of non-`.d.ts` files in the program.\n   */\n  InputTsFile,\n\n  /**\n   * An `@Component` class was analyzed.\n   */\n  AnalyzeComponent,\n\n  /**\n   * An `@Directive` class was analyzed.\n   */\n  AnalyzeDirective,\n\n  /**\n   * An `@Injectable` class was analyzed.\n   */\n  AnalyzeInjectable,\n\n  /**\n   * An `@NgModule` class was analyzed.\n   */\n  AnalyzeNgModule,\n\n  /**\n   * An `@Pipe` class was analyzed.\n   */\n  AnalyzePipe,\n\n  /**\n   * A trait was analyzed.\n   *\n   * In theory, this should be the sum of the `Analyze` counters for each decorator type.\n   */\n  TraitAnalyze,\n\n  /**\n   * A trait had a prior analysis available from an incremental program, and did not need to be\n   * re-analyzed.\n   */\n  TraitReuseAnalysis,\n\n  /**\n   * A `ts.SourceFile` directly changed between the prior program and a new incremental compilation.\n   */\n  SourceFilePhysicalChange,\n\n  /**\n   * A `ts.SourceFile` did not physically changed, but according to the file dependency graph, has\n   * logically changed between the prior program and a new incremental compilation.\n   */\n  SourceFileLogicalChange,\n\n  /**\n   * A `ts.SourceFile` has not logically changed and all of its analysis results were thus available\n   * for reuse.\n   */\n  SourceFileReuseAnalysis,\n\n  /**\n   * A Type Check Block (TCB) was generated.\n   */\n  GenerateTcb,\n\n  /**\n   * A Type Check Block (TCB) could not be generated because inlining was disabled, and the block\n   * would've required inlining.\n   */\n  SkipGenerateTcbNoInline,\n\n  /**\n   * A `.ngtypecheck.ts` file could be reused from the previous program and did not need to be\n   * regenerated.\n   */\n  ReuseTypeCheckFile,\n\n  /**\n   * The template type-checking program required changes and had to be updated in an incremental\n   * step.\n   */\n  UpdateTypeCheckProgram,\n\n  /**\n   * The compiler was able to prove that a `ts.SourceFile` did not need to be re-emitted.\n   */\n  EmitSkipSourceFile,\n\n  /**\n   * A `ts.SourceFile` was emitted.\n   */\n  EmitSourceFile,\n\n  /**\n   * Tracks the number of `PrefEvent`s, and must appear at the end of the list.\n   */\n  LAST,\n}\n\n/**\n * Represents a checkpoint during compilation at which the memory usage of the compiler should be\n * recorded.\n */\nexport enum PerfCheckpoint {\n  /**\n   * The point at which the `PerfRecorder` was created, and ideally tracks memory used before any\n   * compilation structures are created.\n   */\n  Initial,\n\n  /**\n   * The point just after the `ts.Program` has been created.\n   */\n  TypeScriptProgramCreate,\n\n  /**\n   * The point just before Angular analysis starts.\n   *\n   * In the main usage pattern for the compiler, TypeScript diagnostics have been calculated at this\n   * point, so the `ts.TypeChecker` has fully ingested the current program, all `ts.Type` structures\n   * and `ts.Symbol`s have been created.\n   */\n  PreAnalysis,\n\n  /**\n   * The point just after Angular analysis completes.\n   */\n  Analysis,\n\n  /**\n   * The point just after Angular resolution is complete.\n   */\n  Resolve,\n\n  /**\n   * The point just after Type Check Blocks (TCBs) have been generated.\n   */\n  TtcGeneration,\n\n  /**\n   * The point just after the template type-checking program has been updated with any new TCBs.\n   */\n  TtcUpdateProgram,\n\n  /**\n   * The point just before emit begins.\n   *\n   * In the main usage pattern for the compiler, all template type-checking diagnostics have been\n   * requested at this point.\n   */\n  PreEmit,\n\n  /**\n   * The point just after the program has been fully emitted.\n   */\n  Emit,\n\n  /**\n   * Tracks the number of `PerfCheckpoint`s, and must appear at the end of the list.\n   */\n  LAST,\n}\n\n/**\n * Records timing, memory, or counts at specific points in the compiler's operation.\n */\nexport interface PerfRecorder {\n  /**\n   * Set the current phase of compilation.\n   *\n   * Time spent in the previous phase will be accounted to that phase. The caller is responsible for\n   * exiting the phase when work that should be tracked within it is completed, and either returning\n   * to the previous phase or transitioning to the next one directly.\n   *\n   * In general, prefer using `inPhase()` to instrument a section of code, as it automatically\n   * handles entering and exiting the phase. `phase()` should only be used when the former API\n   * cannot be cleanly applied to a particular operation.\n   *\n   * @returns the previous phase\n   */\n  phase(phase: PerfPhase): PerfPhase;\n\n  /**\n   * Run `fn` in the given `PerfPhase` and return the result.\n   *\n   * Enters `phase` before executing the given `fn`, then exits the phase and returns the result.\n   * Prefer this API to `phase()` where possible.\n   */\n  inPhase<T>(phase: PerfPhase, fn: () => T): T;\n\n  /**\n   * Record the memory usage of the compiler at the given checkpoint.\n   */\n  memory(after: PerfCheckpoint): void;\n\n  /**\n   * Record that a specific event has occurred, possibly more than once.\n   */\n  eventCount(event: PerfEvent, incrementBy?: number): void;\n\n  /**\n   * Return the `PerfRecorder` to an empty state (clear all tracked statistics) and reset the zero\n   * point to the current time.\n   */\n  reset(): void;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}