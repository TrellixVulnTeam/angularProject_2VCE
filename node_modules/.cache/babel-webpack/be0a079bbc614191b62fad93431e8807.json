{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/partial/component\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/core\", \"@angular/compiler/src/ml_parser/interpolation_config\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/render3/r3_identifiers\", \"@angular/compiler/src/render3/view/compiler\", \"@angular/compiler/src/render3/view/util\", \"@angular/compiler/src/render3/partial/directive\", \"@angular/compiler/src/render3/partial/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.createComponentDefinitionMap = exports.compileDeclareComponentFromMetadata = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var core = require(\"@angular/compiler/src/core\");\n\n  var interpolation_config_1 = require(\"@angular/compiler/src/ml_parser/interpolation_config\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var r3_identifiers_1 = require(\"@angular/compiler/src/render3/r3_identifiers\");\n\n  var compiler_1 = require(\"@angular/compiler/src/render3/view/compiler\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/view/util\");\n\n  var directive_1 = require(\"@angular/compiler/src/render3/partial/directive\");\n\n  var util_2 = require(\"@angular/compiler/src/render3/partial/util\");\n  /**\n   * Compile a component declaration defined by the `R3ComponentMetadata`.\n   */\n\n\n  function compileDeclareComponentFromMetadata(meta, template) {\n    var definitionMap = createComponentDefinitionMap(meta, template);\n    var expression = o.importExpr(r3_identifiers_1.Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);\n    var type = compiler_1.createComponentType(meta);\n    return {\n      expression: expression,\n      type: type\n    };\n  }\n\n  exports.compileDeclareComponentFromMetadata = compileDeclareComponentFromMetadata;\n  /**\n   * Gathers the declaration fields for a component into a `DefinitionMap`.\n   */\n\n  function createComponentDefinitionMap(meta, template) {\n    var definitionMap = directive_1.createDirectiveDefinitionMap(meta);\n    definitionMap.set('template', getTemplateExpression(template));\n\n    if (template.isInline) {\n      definitionMap.set('isInline', o.literal(true));\n    }\n\n    definitionMap.set('styles', util_2.toOptionalLiteralArray(meta.styles, o.literal));\n    definitionMap.set('directives', compileUsedDirectiveMetadata(meta));\n    definitionMap.set('pipes', compileUsedPipeMetadata(meta));\n    definitionMap.set('viewProviders', meta.viewProviders);\n    definitionMap.set('animations', meta.animations);\n\n    if (meta.changeDetection !== undefined) {\n      definitionMap.set('changeDetection', o.importExpr(r3_identifiers_1.Identifiers.ChangeDetectionStrategy).prop(core.ChangeDetectionStrategy[meta.changeDetection]));\n    }\n\n    if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n      definitionMap.set('encapsulation', o.importExpr(r3_identifiers_1.Identifiers.ViewEncapsulation).prop(core.ViewEncapsulation[meta.encapsulation]));\n    }\n\n    if (meta.interpolation !== interpolation_config_1.DEFAULT_INTERPOLATION_CONFIG) {\n      definitionMap.set('interpolation', o.literalArr([o.literal(meta.interpolation.start), o.literal(meta.interpolation.end)]));\n    }\n\n    if (template.preserveWhitespaces === true) {\n      definitionMap.set('preserveWhitespaces', o.literal(true));\n    }\n\n    return definitionMap;\n  }\n\n  exports.createComponentDefinitionMap = createComponentDefinitionMap;\n\n  function getTemplateExpression(template) {\n    if (typeof template.template === 'string') {\n      if (template.isInline) {\n        // The template is inline but not a simple literal string, so give up with trying to\n        // source-map it and just return a simple literal here.\n        return o.literal(template.template);\n      } else {\n        // The template is external so we must synthesize an expression node with the appropriate\n        // source-span.\n        var contents = template.template;\n        var file = new parse_util_1.ParseSourceFile(contents, template.templateUrl);\n        var start = new parse_util_1.ParseLocation(file, 0, 0, 0);\n        var end = computeEndLocation(file, contents);\n        var span = new parse_util_1.ParseSourceSpan(start, end);\n        return o.literal(contents, null, span);\n      }\n    } else {\n      // The template is inline so we can just reuse the current expression node.\n      return template.template;\n    }\n  }\n\n  function computeEndLocation(file, contents) {\n    var length = contents.length;\n    var lineStart = 0;\n    var lastLineStart = 0;\n    var line = 0;\n\n    do {\n      lineStart = contents.indexOf('\\n', lastLineStart);\n\n      if (lineStart !== -1) {\n        lastLineStart = lineStart + 1;\n        line++;\n      }\n    } while (lineStart !== -1);\n\n    return new parse_util_1.ParseLocation(file, length, line, length - lastLineStart);\n  }\n  /**\n   * Compiles the directives as registered in the component metadata into an array literal of the\n   * individual directives. If the component does not use any directives, then null is returned.\n   */\n\n\n  function compileUsedDirectiveMetadata(meta) {\n    var wrapType = meta.declarationListEmitMode !== 0\n    /* Direct */\n    ? generateForwardRef : function (expr) {\n      return expr;\n    };\n    return util_2.toOptionalLiteralArray(meta.directives, function (directive) {\n      var dirMeta = new util_1.DefinitionMap();\n      dirMeta.set('type', wrapType(directive.type));\n      dirMeta.set('selector', o.literal(directive.selector));\n      dirMeta.set('inputs', util_2.toOptionalLiteralArray(directive.inputs, o.literal));\n      dirMeta.set('outputs', util_2.toOptionalLiteralArray(directive.outputs, o.literal));\n      dirMeta.set('exportAs', util_2.toOptionalLiteralArray(directive.exportAs, o.literal));\n      return dirMeta.toLiteralMap();\n    });\n  }\n  /**\n   * Compiles the pipes as registered in the component metadata into an object literal, where the\n   * pipe's name is used as key and a reference to its type as value. If the component does not use\n   * any pipes, then null is returned.\n   */\n\n\n  function compileUsedPipeMetadata(meta) {\n    var e_1, _a;\n\n    if (meta.pipes.size === 0) {\n      return null;\n    }\n\n    var wrapType = meta.declarationListEmitMode !== 0\n    /* Direct */\n    ? generateForwardRef : function (expr) {\n      return expr;\n    };\n    var entries = [];\n\n    try {\n      for (var _b = tslib_1.__values(meta.pipes), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = tslib_1.__read(_c.value, 2),\n            name_1 = _d[0],\n            pipe = _d[1];\n\n        entries.push({\n          key: name_1,\n          value: wrapType(pipe),\n          quoted: true\n        });\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return o.literalMap(entries);\n  }\n\n  function generateForwardRef(expr) {\n    return o.importExpr(r3_identifiers_1.Identifiers.forwardRef).callFn([o.fn([], [new o.ReturnStatement(expr)])]);\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/partial/component.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as core from '../../core';\nimport {DEFAULT_INTERPOLATION_CONFIG} from '../../ml_parser/interpolation_config';\nimport * as o from '../../output/output_ast';\nimport {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../parse_util';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {DeclarationListEmitMode, R3ComponentDef, R3ComponentMetadata, R3UsedDirectiveMetadata} from '../view/api';\nimport {createComponentType} from '../view/compiler';\nimport {ParsedTemplate} from '../view/template';\nimport {DefinitionMap} from '../view/util';\n\nimport {R3DeclareComponentMetadata} from './api';\nimport {createDirectiveDefinitionMap} from './directive';\nimport {toOptionalLiteralArray} from './util';\n\n\n/**\n * Compile a component declaration defined by the `R3ComponentMetadata`.\n */\nexport function compileDeclareComponentFromMetadata(\n    meta: R3ComponentMetadata, template: ParsedTemplate): R3ComponentDef {\n  const definitionMap = createComponentDefinitionMap(meta, template);\n\n  const expression = o.importExpr(R3.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  const type = createComponentType(meta);\n\n  return {expression, type};\n}\n\n/**\n * Gathers the declaration fields for a component into a `DefinitionMap`.\n */\nexport function createComponentDefinitionMap(meta: R3ComponentMetadata, template: ParsedTemplate):\n    DefinitionMap<R3DeclareComponentMetadata> {\n  const definitionMap: DefinitionMap<R3DeclareComponentMetadata> =\n      createDirectiveDefinitionMap(meta);\n\n  definitionMap.set('template', getTemplateExpression(template));\n  if (template.isInline) {\n    definitionMap.set('isInline', o.literal(true));\n  }\n\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, o.literal));\n  definitionMap.set('directives', compileUsedDirectiveMetadata(meta));\n  definitionMap.set('pipes', compileUsedPipeMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n\n  if (meta.changeDetection !== undefined) {\n    definitionMap.set(\n        'changeDetection',\n        o.importExpr(R3.ChangeDetectionStrategy)\n            .prop(core.ChangeDetectionStrategy[meta.changeDetection]));\n  }\n  if (meta.encapsulation !== core.ViewEncapsulation.Emulated) {\n    definitionMap.set(\n        'encapsulation',\n        o.importExpr(R3.ViewEncapsulation).prop(core.ViewEncapsulation[meta.encapsulation]));\n  }\n  if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n    definitionMap.set(\n        'interpolation',\n        o.literalArr([o.literal(meta.interpolation.start), o.literal(meta.interpolation.end)]));\n  }\n\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', o.literal(true));\n  }\n\n  return definitionMap;\n}\n\nfunction getTemplateExpression(template: ParsedTemplate): o.Expression {\n  if (typeof template.template === 'string') {\n    if (template.isInline) {\n      // The template is inline but not a simple literal string, so give up with trying to\n      // source-map it and just return a simple literal here.\n      return o.literal(template.template);\n    } else {\n      // The template is external so we must synthesize an expression node with the appropriate\n      // source-span.\n      const contents = template.template;\n      const file = new ParseSourceFile(contents, template.templateUrl);\n      const start = new ParseLocation(file, 0, 0, 0);\n      const end = computeEndLocation(file, contents);\n      const span = new ParseSourceSpan(start, end);\n      return o.literal(contents, null, span);\n    }\n  } else {\n    // The template is inline so we can just reuse the current expression node.\n    return template.template;\n  }\n}\n\nfunction computeEndLocation(file: ParseSourceFile, contents: string): ParseLocation {\n  const length = contents.length;\n  let lineStart = 0;\n  let lastLineStart = 0;\n  let line = 0;\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\n\n/**\n * Compiles the directives as registered in the component metadata into an array literal of the\n * individual directives. If the component does not use any directives, then null is returned.\n */\nfunction compileUsedDirectiveMetadata(meta: R3ComponentMetadata): o.LiteralArrayExpr|null {\n  const wrapType = meta.declarationListEmitMode !== DeclarationListEmitMode.Direct ?\n      generateForwardRef :\n      (expr: o.Expression) => expr;\n\n  return toOptionalLiteralArray(meta.directives, directive => {\n    const dirMeta = new DefinitionMap<R3UsedDirectiveMetadata>();\n    dirMeta.set('type', wrapType(directive.type));\n    dirMeta.set('selector', o.literal(directive.selector));\n    dirMeta.set('inputs', toOptionalLiteralArray(directive.inputs, o.literal));\n    dirMeta.set('outputs', toOptionalLiteralArray(directive.outputs, o.literal));\n    dirMeta.set('exportAs', toOptionalLiteralArray(directive.exportAs, o.literal));\n    return dirMeta.toLiteralMap();\n  });\n}\n\n/**\n * Compiles the pipes as registered in the component metadata into an object literal, where the\n * pipe's name is used as key and a reference to its type as value. If the component does not use\n * any pipes, then null is returned.\n */\nfunction compileUsedPipeMetadata(meta: R3ComponentMetadata): o.LiteralMapExpr|null {\n  if (meta.pipes.size === 0) {\n    return null;\n  }\n\n  const wrapType = meta.declarationListEmitMode !== DeclarationListEmitMode.Direct ?\n      generateForwardRef :\n      (expr: o.Expression) => expr;\n\n  const entries = [];\n  for (const [name, pipe] of meta.pipes) {\n    entries.push({key: name, value: wrapType(pipe), quoted: true});\n  }\n  return o.literalMap(entries);\n}\n\nfunction generateForwardRef(expr: o.Expression): o.Expression {\n  return o.importExpr(R3.forwardRef).callFn([o.fn([], [new o.ReturnStatement(expr)])]);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}