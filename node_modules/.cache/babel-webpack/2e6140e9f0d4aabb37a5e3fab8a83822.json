{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/entry_point_finder/tracing_entry_point_finder\", [\"require\", \"exports\", \"@angular/compiler-cli/ngcc/src/entry_point_finder/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TracingEntryPointFinder = void 0;\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/entry_point_finder/utils\");\n  /**\n   * An EntryPointFinder that starts from a set of initial files and only returns entry-points that\n   * are dependencies of these files.\n   *\n   * This is faster than processing all entry-points in the entire file-system, and is used primarily\n   * by the CLI integration.\n   *\n   * There are two concrete implementations of this class.\n   *\n   * * `TargetEntryPointFinder` - is given a single entry-point as the initial entry-point. This can\n   *   be used in the synchronous CLI integration where the build tool has identified an external\n   *   import to one of the source files being built.\n   * * `ProgramBasedEntryPointFinder` - computes the initial entry-points from the source files\n   *   computed from a `tsconfig.json` file. This can be used in the asynchronous CLI integration\n   *   where the `tsconfig.json` to be used to do the build is known.\n   */\n\n\n  var TracingEntryPointFinder =\n  /** @class */\n  function () {\n    function TracingEntryPointFinder(fs, config, logger, resolver, basePath, pathMappings) {\n      this.fs = fs;\n      this.config = config;\n      this.logger = logger;\n      this.resolver = resolver;\n      this.basePath = basePath;\n      this.pathMappings = pathMappings;\n      this.basePaths = null;\n    }\n    /**\n     * Search for Angular package entry-points.\n     */\n\n\n    TracingEntryPointFinder.prototype.findEntryPoints = function () {\n      var unsortedEntryPoints = new Map();\n      var unprocessedPaths = this.getInitialEntryPointPaths();\n\n      while (unprocessedPaths.length > 0) {\n        var path = unprocessedPaths.shift();\n        var entryPointWithDeps = this.getEntryPointWithDeps(path);\n\n        if (entryPointWithDeps === null) {\n          continue;\n        }\n\n        unsortedEntryPoints.set(entryPointWithDeps.entryPoint.path, entryPointWithDeps);\n        entryPointWithDeps.depInfo.dependencies.forEach(function (dep) {\n          if (!unsortedEntryPoints.has(dep)) {\n            unprocessedPaths.push(dep);\n          }\n        });\n      }\n\n      return this.resolver.sortEntryPointsByDependency(Array.from(unsortedEntryPoints.values()));\n    };\n    /**\n     * Parse the path-mappings to compute the base-paths that need to be considered when finding\n     * entry-points.\n     *\n     * This processing can be time-consuming if the path-mappings are complex or extensive.\n     * So the result is cached locally once computed.\n     */\n\n\n    TracingEntryPointFinder.prototype.getBasePaths = function () {\n      if (this.basePaths === null) {\n        this.basePaths = utils_1.getBasePaths(this.logger, this.basePath, this.pathMappings);\n      }\n\n      return this.basePaths;\n    };\n\n    return TracingEntryPointFinder;\n  }();\n\n  exports.TracingEntryPointFinder = TracingEntryPointFinder;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/entry_point_finder/tracing_entry_point_finder.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;AAeA,MAAA,OAAA,GAAA,OAAA,CAAA,yDAAA,CAAA;AAEA;;;;;;;;;;;;;;;AAeG;;;AACH,MAAA,uBAAA;AAAA;AAAA,cAAA;AAGE,aAAA,uBAAA,CACc,EADd,EACgD,MADhD,EAEc,MAFd,EAEwC,QAFxC,EAGc,QAHd,EAGkD,YAHlD,EAGsF;AAFxE,WAAA,EAAA,GAAA,EAAA;AAAkC,WAAA,MAAA,GAAA,MAAA;AAClC,WAAA,MAAA,GAAA,MAAA;AAA0B,WAAA,QAAA,GAAA,QAAA;AAC1B,WAAA,QAAA,GAAA,QAAA;AAAoC,WAAA,YAAA,GAAA,YAAA;AAL1C,WAAA,SAAA,GAAmC,IAAnC;AAKkF;AAE1F;;AAEG;;;AACH,IAAA,uBAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,UAAM,mBAAmB,GAAG,IAAI,GAAJ,EAA5B;AACA,UAAM,gBAAgB,GAAG,KAAK,yBAAL,EAAzB;;AACA,aAAO,gBAAgB,CAAC,MAAjB,GAA0B,CAAjC,EAAoC;AAClC,YAAM,IAAI,GAAG,gBAAgB,CAAC,KAAjB,EAAb;AACA,YAAM,kBAAkB,GAAG,KAAK,qBAAL,CAA2B,IAA3B,CAA3B;;AACA,YAAI,kBAAkB,KAAK,IAA3B,EAAiC;AAC/B;AACD;;AACD,QAAA,mBAAmB,CAAC,GAApB,CAAwB,kBAAkB,CAAC,UAAnB,CAA8B,IAAtD,EAA4D,kBAA5D;AACA,QAAA,kBAAkB,CAAC,OAAnB,CAA2B,YAA3B,CAAwC,OAAxC,CAAgD,UAAA,GAAA,EAAG;AACjD,cAAI,CAAC,mBAAmB,CAAC,GAApB,CAAwB,GAAxB,CAAL,EAAmC;AACjC,YAAA,gBAAgB,CAAC,IAAjB,CAAsB,GAAtB;AACD;AACF,SAJD;AAKD;;AACD,aAAO,KAAK,QAAL,CAAc,2BAAd,CAA0C,KAAK,CAAC,IAAN,CAAW,mBAAmB,CAAC,MAApB,EAAX,CAA1C,CAAP;AACD,KAjBD;AAuCA;;;;;;AAMG;;;AACO,IAAA,uBAAA,CAAA,SAAA,CAAA,YAAA,GAAV,YAAA;AACE,UAAI,KAAK,SAAL,KAAmB,IAAvB,EAA6B;AAC3B,aAAK,SAAL,GAAiB,OAAA,CAAA,YAAA,CAAa,KAAK,MAAlB,EAA0B,KAAK,QAA/B,EAAyC,KAAK,YAA9C,CAAjB;AACD;;AACD,aAAO,KAAK,SAAZ;AACD,KALS;;AAMZ,WAAA,uBAAA;AAAC,GA/DD,EAAA;;AAAsB,EAAA,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, PathManipulation, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {EntryPointWithDependencies} from '../dependencies/dependency_host';\nimport {DependencyResolver, SortedEntryPointsInfo} from '../dependencies/dependency_resolver';\nimport {NgccConfiguration} from '../packages/configuration';\nimport {PathMappings} from '../path_mappings';\n\nimport {EntryPointFinder} from './interface';\nimport {getBasePaths} from './utils';\n\n/**\n * An EntryPointFinder that starts from a set of initial files and only returns entry-points that\n * are dependencies of these files.\n *\n * This is faster than processing all entry-points in the entire file-system, and is used primarily\n * by the CLI integration.\n *\n * There are two concrete implementations of this class.\n *\n * * `TargetEntryPointFinder` - is given a single entry-point as the initial entry-point. This can\n *   be used in the synchronous CLI integration where the build tool has identified an external\n *   import to one of the source files being built.\n * * `ProgramBasedEntryPointFinder` - computes the initial entry-points from the source files\n *   computed from a `tsconfig.json` file. This can be used in the asynchronous CLI integration\n *   where the `tsconfig.json` to be used to do the build is known.\n */\nexport abstract class TracingEntryPointFinder implements EntryPointFinder {\n  private basePaths: AbsoluteFsPath[]|null = null;\n\n  constructor(\n      protected fs: ReadonlyFileSystem, protected config: NgccConfiguration,\n      protected logger: Logger, protected resolver: DependencyResolver,\n      protected basePath: AbsoluteFsPath, protected pathMappings: PathMappings|undefined) {}\n\n  /**\n   * Search for Angular package entry-points.\n   */\n  findEntryPoints(): SortedEntryPointsInfo {\n    const unsortedEntryPoints = new Map<AbsoluteFsPath, EntryPointWithDependencies>();\n    const unprocessedPaths = this.getInitialEntryPointPaths();\n    while (unprocessedPaths.length > 0) {\n      const path = unprocessedPaths.shift()!;\n      const entryPointWithDeps = this.getEntryPointWithDeps(path);\n      if (entryPointWithDeps === null) {\n        continue;\n      }\n      unsortedEntryPoints.set(entryPointWithDeps.entryPoint.path, entryPointWithDeps);\n      entryPointWithDeps.depInfo.dependencies.forEach(dep => {\n        if (!unsortedEntryPoints.has(dep)) {\n          unprocessedPaths.push(dep);\n        }\n      });\n    }\n    return this.resolver.sortEntryPointsByDependency(Array.from(unsortedEntryPoints.values()));\n  }\n\n\n  /**\n   * Return an array of entry-point paths from which to start the trace.\n   */\n  protected abstract getInitialEntryPointPaths(): AbsoluteFsPath[];\n\n  /**\n   * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including\n   * paths to other entry-points that this entry-point depends upon.\n   *\n   * @param entryPointPath the path to the entry-point whose information and dependencies are to be\n   *     retrieved or computed.\n   *\n   * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by\n   *     Angular or cannot be determined.\n   */\n  protected abstract getEntryPointWithDeps(entryPointPath: AbsoluteFsPath):\n      EntryPointWithDependencies|null;\n\n\n  /**\n   * Parse the path-mappings to compute the base-paths that need to be considered when finding\n   * entry-points.\n   *\n   * This processing can be time-consuming if the path-mappings are complex or extensive.\n   * So the result is cached locally once computed.\n   */\n  protected getBasePaths() {\n    if (this.basePaths === null) {\n      this.basePaths = getBasePaths(this.logger, this.basePath, this.pathMappings);\n    }\n    return this.basePaths;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}