{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/comments\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.hasExpressionIdentifier = exports.findAllMatchingNodes = exports.findFirstMatchingNode = exports.hasIgnoreForDiagnosticsMarker = exports.markIgnoreDiagnostics = exports.addExpressionIdentifier = exports.ExpressionIdentifier = exports.CommentTriviaType = exports.readSpanComment = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var parseSpanComment = /^(\\d+),(\\d+)$/;\n  /**\n   * Reads the trailing comments and finds the first match which is a span comment (i.e. 4,10) on a\n   * node and returns it as an `AbsoluteSourceSpan`.\n   *\n   * Will return `null` if no trailing comments on the node match the expected form of a source span.\n   */\n\n  function readSpanComment(node, sourceFile) {\n    if (sourceFile === void 0) {\n      sourceFile = node.getSourceFile();\n    }\n\n    return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), function (pos, end, kind) {\n      if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n        return null;\n      }\n\n      var commentText = sourceFile.text.substring(pos + 2, end - 2);\n      var match = commentText.match(parseSpanComment);\n\n      if (match === null) {\n        return null;\n      }\n\n      return new compiler_1.AbsoluteSourceSpan(+match[1], +match[2]);\n    }) || null;\n  }\n\n  exports.readSpanComment = readSpanComment;\n  /** Used to identify what type the comment is. */\n\n  var CommentTriviaType;\n\n  (function (CommentTriviaType) {\n    CommentTriviaType[\"DIAGNOSTIC\"] = \"D\";\n    CommentTriviaType[\"EXPRESSION_TYPE_IDENTIFIER\"] = \"T\";\n  })(CommentTriviaType = exports.CommentTriviaType || (exports.CommentTriviaType = {}));\n  /** Identifies what the TCB expression is for (for example, a directive declaration). */\n\n\n  var ExpressionIdentifier;\n\n  (function (ExpressionIdentifier) {\n    ExpressionIdentifier[\"DIRECTIVE\"] = \"DIR\";\n    ExpressionIdentifier[\"COMPONENT_COMPLETION\"] = \"COMPCOMP\";\n    ExpressionIdentifier[\"EVENT_PARAMETER\"] = \"EP\";\n  })(ExpressionIdentifier = exports.ExpressionIdentifier || (exports.ExpressionIdentifier = {}));\n  /** Tags the node with the given expression identifier. */\n\n\n  function addExpressionIdentifier(node, identifier) {\n    ts.addSyntheticTrailingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER + \":\" + identifier,\n    /* hasTrailingNewLine */\n    false);\n  }\n\n  exports.addExpressionIdentifier = addExpressionIdentifier;\n  var IGNORE_FOR_DIAGNOSTICS_MARKER = CommentTriviaType.DIAGNOSTIC + \":ignore\";\n  /**\n   * Tag the `ts.Node` with an indication that any errors arising from the evaluation of the node\n   * should be ignored.\n   */\n\n  function markIgnoreDiagnostics(node) {\n    ts.addSyntheticTrailingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, IGNORE_FOR_DIAGNOSTICS_MARKER,\n    /* hasTrailingNewLine */\n    false);\n  }\n\n  exports.markIgnoreDiagnostics = markIgnoreDiagnostics;\n  /** Returns true if the node has a marker that indicates diagnostics errors should be ignored.  */\n\n  function hasIgnoreForDiagnosticsMarker(node, sourceFile) {\n    return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), function (pos, end, kind) {\n      if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n        return null;\n      }\n\n      var commentText = sourceFile.text.substring(pos + 2, end - 2);\n      return commentText === IGNORE_FOR_DIAGNOSTICS_MARKER;\n    }) === true;\n  }\n\n  exports.hasIgnoreForDiagnosticsMarker = hasIgnoreForDiagnosticsMarker;\n\n  function makeRecursiveVisitor(visitor) {\n    function recursiveVisitor(node) {\n      var res = visitor(node);\n      return res !== null ? res : node.forEachChild(recursiveVisitor);\n    }\n\n    return recursiveVisitor;\n  }\n\n  function getSpanFromOptions(opts) {\n    var withSpan = null;\n\n    if (opts.withSpan !== undefined) {\n      if (opts.withSpan instanceof compiler_1.AbsoluteSourceSpan) {\n        withSpan = opts.withSpan;\n      } else {\n        withSpan = {\n          start: opts.withSpan.start.offset,\n          end: opts.withSpan.end.offset\n        };\n      }\n    }\n\n    return withSpan;\n  }\n  /**\n   * Given a `ts.Node` with finds the first node whose matching the criteria specified\n   * by the `FindOptions`.\n   *\n   * Returns `null` when no `ts.Node` matches the given conditions.\n   */\n\n\n  function findFirstMatchingNode(tcb, opts) {\n    var _a;\n\n    var withSpan = getSpanFromOptions(opts);\n    var withExpressionIdentifier = opts.withExpressionIdentifier;\n    var sf = tcb.getSourceFile();\n    var visitor = makeRecursiveVisitor(function (node) {\n      if (!opts.filter(node)) {\n        return null;\n      }\n\n      if (withSpan !== null) {\n        var comment = readSpanComment(node, sf);\n\n        if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n          return null;\n        }\n      }\n\n      if (withExpressionIdentifier !== undefined && !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n        return null;\n      }\n\n      return node;\n    });\n    return (_a = tcb.forEachChild(visitor)) !== null && _a !== void 0 ? _a : null;\n  }\n\n  exports.findFirstMatchingNode = findFirstMatchingNode;\n  /**\n   * Given a `ts.Node` with source span comments, finds the first node whose source span comment\n   * matches the given `sourceSpan`. Additionally, the `filter` function allows matching only\n   * `ts.Nodes` of a given type, which provides the ability to select only matches of a given type\n   * when there may be more than one.\n   *\n   * Returns `null` when no `ts.Node` matches the given conditions.\n   */\n\n  function findAllMatchingNodes(tcb, opts) {\n    var withSpan = getSpanFromOptions(opts);\n    var withExpressionIdentifier = opts.withExpressionIdentifier;\n    var results = [];\n    var stack = [tcb];\n    var sf = tcb.getSourceFile();\n\n    while (stack.length > 0) {\n      var node = stack.pop();\n\n      if (!opts.filter(node)) {\n        stack.push.apply(stack, tslib_1.__spread(node.getChildren()));\n        continue;\n      }\n\n      if (withSpan !== null) {\n        var comment = readSpanComment(node, sf);\n\n        if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n          stack.push.apply(stack, tslib_1.__spread(node.getChildren()));\n          continue;\n        }\n      }\n\n      if (withExpressionIdentifier !== undefined && !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n        continue;\n      }\n\n      results.push(node);\n    }\n\n    return results;\n  }\n\n  exports.findAllMatchingNodes = findAllMatchingNodes;\n\n  function hasExpressionIdentifier(sourceFile, node, identifier) {\n    return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), function (pos, end, kind) {\n      if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n        return false;\n      }\n\n      var commentText = sourceFile.text.substring(pos + 2, end - 2);\n      return commentText === CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER + \":\" + identifier;\n    }) || false;\n  }\n\n  exports.hasExpressionIdentifier = hasExpressionIdentifier;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/comments.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AbsoluteSourceSpan, ParseSourceSpan} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nconst parseSpanComment = /^(\\d+),(\\d+)$/;\n\n/**\n * Reads the trailing comments and finds the first match which is a span comment (i.e. 4,10) on a\n * node and returns it as an `AbsoluteSourceSpan`.\n *\n * Will return `null` if no trailing comments on the node match the expected form of a source span.\n */\nexport function readSpanComment(\n    node: ts.Node, sourceFile: ts.SourceFile = node.getSourceFile()): AbsoluteSourceSpan|null {\n  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    const match = commentText.match(parseSpanComment);\n    if (match === null) {\n      return null;\n    }\n\n    return new AbsoluteSourceSpan(+match[1], +match[2]);\n  }) || null;\n}\n\n/** Used to identify what type the comment is. */\nexport enum CommentTriviaType {\n  DIAGNOSTIC = 'D',\n  EXPRESSION_TYPE_IDENTIFIER = 'T',\n}\n\n/** Identifies what the TCB expression is for (for example, a directive declaration). */\nexport enum ExpressionIdentifier {\n  DIRECTIVE = 'DIR',\n  COMPONENT_COMPLETION = 'COMPCOMP',\n  EVENT_PARAMETER = 'EP',\n}\n\n/** Tags the node with the given expression identifier. */\nexport function addExpressionIdentifier(node: ts.Node, identifier: ExpressionIdentifier) {\n  ts.addSyntheticTrailingComment(\n      node, ts.SyntaxKind.MultiLineCommentTrivia,\n      `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`,\n      /* hasTrailingNewLine */ false);\n}\n\nconst IGNORE_FOR_DIAGNOSTICS_MARKER = `${CommentTriviaType.DIAGNOSTIC}:ignore`;\n\n/**\n * Tag the `ts.Node` with an indication that any errors arising from the evaluation of the node\n * should be ignored.\n */\nexport function markIgnoreDiagnostics(node: ts.Node): void {\n  ts.addSyntheticTrailingComment(\n      node, ts.SyntaxKind.MultiLineCommentTrivia, IGNORE_FOR_DIAGNOSTICS_MARKER,\n      /* hasTrailingNewLine */ false);\n}\n\n/** Returns true if the node has a marker that indicates diagnostics errors should be ignored.  */\nexport function hasIgnoreForDiagnosticsMarker(node: ts.Node, sourceFile: ts.SourceFile): boolean {\n  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return null;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText === IGNORE_FOR_DIAGNOSTICS_MARKER;\n  }) === true;\n}\n\nfunction makeRecursiveVisitor<T extends ts.Node>(visitor: (node: ts.Node) => T | null):\n    (node: ts.Node) => T | undefined {\n  function recursiveVisitor(node: ts.Node): T|undefined {\n    const res = visitor(node);\n    return res !== null ? res : node.forEachChild(recursiveVisitor);\n  }\n  return recursiveVisitor;\n}\n\nexport interface FindOptions<T extends ts.Node> {\n  filter: (node: ts.Node) => node is T;\n  withExpressionIdentifier?: ExpressionIdentifier;\n  withSpan?: AbsoluteSourceSpan|ParseSourceSpan;\n}\n\nfunction getSpanFromOptions(opts: FindOptions<ts.Node>) {\n  let withSpan: {start: number, end: number}|null = null;\n  if (opts.withSpan !== undefined) {\n    if (opts.withSpan instanceof AbsoluteSourceSpan) {\n      withSpan = opts.withSpan;\n    } else {\n      withSpan = {start: opts.withSpan.start.offset, end: opts.withSpan.end.offset};\n    }\n  }\n  return withSpan;\n}\n\n/**\n * Given a `ts.Node` with finds the first node whose matching the criteria specified\n * by the `FindOptions`.\n *\n * Returns `null` when no `ts.Node` matches the given conditions.\n */\nexport function findFirstMatchingNode<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T|\n    null {\n  const withSpan = getSpanFromOptions(opts);\n  const withExpressionIdentifier = opts.withExpressionIdentifier;\n  const sf = tcb.getSourceFile();\n  const visitor = makeRecursiveVisitor<T>(node => {\n    if (!opts.filter(node)) {\n      return null;\n    }\n    if (withSpan !== null) {\n      const comment = readSpanComment(node, sf);\n      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n        return null;\n      }\n    }\n    if (withExpressionIdentifier !== undefined &&\n        !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n      return null;\n    }\n    return node;\n  });\n  return tcb.forEachChild(visitor) ?? null;\n}\n\n/**\n * Given a `ts.Node` with source span comments, finds the first node whose source span comment\n * matches the given `sourceSpan`. Additionally, the `filter` function allows matching only\n * `ts.Nodes` of a given type, which provides the ability to select only matches of a given type\n * when there may be more than one.\n *\n * Returns `null` when no `ts.Node` matches the given conditions.\n */\nexport function findAllMatchingNodes<T extends ts.Node>(tcb: ts.Node, opts: FindOptions<T>): T[] {\n  const withSpan = getSpanFromOptions(opts);\n  const withExpressionIdentifier = opts.withExpressionIdentifier;\n  const results: T[] = [];\n  const stack: ts.Node[] = [tcb];\n  const sf = tcb.getSourceFile();\n\n  while (stack.length > 0) {\n    const node = stack.pop()!;\n\n    if (!opts.filter(node)) {\n      stack.push(...node.getChildren());\n      continue;\n    }\n    if (withSpan !== null) {\n      const comment = readSpanComment(node, sf);\n      if (comment === null || withSpan.start !== comment.start || withSpan.end !== comment.end) {\n        stack.push(...node.getChildren());\n        continue;\n      }\n    }\n    if (withExpressionIdentifier !== undefined &&\n        !hasExpressionIdentifier(sf, node, withExpressionIdentifier)) {\n      continue;\n    }\n\n    results.push(node);\n  }\n\n  return results;\n}\n\nexport function hasExpressionIdentifier(\n    sourceFile: ts.SourceFile, node: ts.Node, identifier: ExpressionIdentifier): boolean {\n  return ts.forEachTrailingCommentRange(sourceFile.text, node.getEnd(), (pos, end, kind) => {\n    if (kind !== ts.SyntaxKind.MultiLineCommentTrivia) {\n      return false;\n    }\n    const commentText = sourceFile.text.substring(pos + 2, end - 2);\n    return commentText === `${CommentTriviaType.EXPRESSION_TYPE_IDENTIFIER}:${identifier}`;\n  }) || false;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}