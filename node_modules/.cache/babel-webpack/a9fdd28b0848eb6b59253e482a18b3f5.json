{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/r3_metadata_transform\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/metadata/index\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.PartialModuleMetadataTransformer = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var index_1 = require(\"@angular/compiler-cli/src/metadata/index\");\n\n  var PartialModuleMetadataTransformer =\n  /** @class */\n  function () {\n    function PartialModuleMetadataTransformer(modules) {\n      this.moduleMap = new Map(modules.map(function (m) {\n        return [m.fileName, m];\n      }));\n    }\n\n    PartialModuleMetadataTransformer.prototype.start = function (sourceFile) {\n      var partialModule = this.moduleMap.get(sourceFile.fileName);\n\n      if (partialModule) {\n        var classMap_1 = new Map(partialModule.statements.filter(isClassStmt).map(function (s) {\n          return [s.name, s];\n        }));\n\n        if (classMap_1.size > 0) {\n          return function (value, node) {\n            var e_1, _a, _b; // For class metadata that is going to be transformed to have a static method ensure the\n            // metadata contains a static declaration the new static method.\n\n\n            if (index_1.isClassMetadata(value) && node.kind === ts.SyntaxKind.ClassDeclaration) {\n              var classDeclaration = node;\n\n              if (classDeclaration.name) {\n                var partialClass = classMap_1.get(classDeclaration.name.text);\n\n                if (partialClass) {\n                  try {\n                    for (var _c = tslib_1.__values(partialClass.fields), _d = _c.next(); !_d.done; _d = _c.next()) {\n                      var field = _d.value;\n\n                      if (field.name && field.modifiers && field.modifiers.some(function (modifier) {\n                        return modifier === compiler_1.StmtModifier.Static;\n                      })) {\n                        value.statics = tslib_1.__assign(tslib_1.__assign({}, value.statics || {}), (_b = {}, _b[field.name] = {}, _b));\n                      }\n                    }\n                  } catch (e_1_1) {\n                    e_1 = {\n                      error: e_1_1\n                    };\n                  } finally {\n                    try {\n                      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n                    } finally {\n                      if (e_1) throw e_1.error;\n                    }\n                  }\n                }\n              }\n            }\n\n            return value;\n          };\n        }\n      }\n    };\n\n    return PartialModuleMetadataTransformer;\n  }();\n\n  exports.PartialModuleMetadataTransformer = PartialModuleMetadataTransformer;\n\n  function isClassStmt(v) {\n    return v instanceof compiler_1.ClassStmt;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/r3_metadata_transform.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,UAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,OAAA,GAAA,OAAA,CAAA,0CAAA,CAAA;;AAIA,MAAA,gCAAA;AAAA;AAAA,cAAA;AAGE,aAAA,gCAAA,CAAY,OAAZ,EAAoC;AAClC,WAAK,SAAL,GAAiB,IAAI,GAAJ,CAAQ,OAAO,CAAC,GAAR,CAAqC,UAAA,CAAA,EAAC;AAAI,eAAA,CAAC,CAAC,CAAC,QAAH,EAAA,CAAA,CAAA;AAAe,OAAzD,CAAR,CAAjB;AACD;;AAED,IAAA,gCAAA,CAAA,SAAA,CAAA,KAAA,GAAA,UAAM,UAAN,EAA+B;AAC7B,UAAM,aAAa,GAAG,KAAK,SAAL,CAAe,GAAf,CAAmB,UAAU,CAAC,QAA9B,CAAtB;;AACA,UAAI,aAAJ,EAAmB;AACjB,YAAM,UAAQ,GAAG,IAAI,GAAJ,CACb,aAAa,CAAC,UAAd,CAAyB,MAAzB,CAAgC,WAAhC,EAA6C,GAA7C,CAAsE,UAAA,CAAA,EAAC;AAAI,iBAAA,CAAC,CAAC,CAAC,IAAH,EAAA,CAAA,CAAA;AAAW,SAAtF,CADa,CAAjB;;AAEA,YAAI,UAAQ,CAAC,IAAT,GAAgB,CAApB,EAAuB;AACrB,iBAAO,UAAC,KAAD,EAAuB,IAAvB,EAAoC;4BAAA,CACzC;AACA;;;AACA,gBAAI,OAAA,CAAA,eAAA,CAAgB,KAAhB,KAA0B,IAAI,CAAC,IAAL,KAAc,EAAE,CAAC,UAAH,CAAc,gBAA1D,EAA4E;AAC1E,kBAAM,gBAAgB,GAAG,IAAzB;;AACA,kBAAI,gBAAgB,CAAC,IAArB,EAA2B;AACzB,oBAAM,YAAY,GAAG,UAAQ,CAAC,GAAT,CAAa,gBAAgB,CAAC,IAAjB,CAAsB,IAAnC,CAArB;;AACA,oBAAI,YAAJ,EAAkB;;AAChB,yBAAoB,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,YAAY,CAAC,MAAb,CAAA,EAAmB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAuC,CAAA,EAAA,CAAA,IAAvC,EAAuC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAvC,EAAyC;AAApC,0BAAM,KAAK,GAAA,EAAA,CAAA,KAAX;;AACH,0BAAI,KAAK,CAAC,IAAN,IAAc,KAAK,CAAC,SAApB,IACA,KAAK,CAAC,SAAN,CAAgB,IAAhB,CAAqB,UAAA,QAAA,EAAQ;AAAI,+BAAA,QAAQ,KAAK,UAAA,CAAA,YAAA,CAAb,MAAA;AAAgC,uBAAjE,CADJ,EACwE;AACtE,wBAAA,KAAK,CAAC,OAAN,GAAa,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EAAQ,KAAK,CAAC,OAAN,IAAiB,EAAzB,CAAA,GAA4B,EAAA,GAAA,EAAA,EAAA,EAAA,CAAG,KAAK,CAAC,IAAT,CAAA,GAAgB,EAAhB,EAAkB,EAA9C,EAAb;AACD;AACF;;;;;;;;;;;;AACF;AACF;AACF;;AACD,mBAAO,KAAP;AACD,WAlBD;AAmBD;AACF;AACF,KA3BD;;AA4BF,WAAA,gCAAA;AAAC,GAnCD,EAAA;;AAAa,EAAA,OAAA,CAAA,gCAAA,GAAA,gCAAA;;AAqCb,WAAS,WAAT,CAAqB,CAArB,EAAiC;AAC/B,WAAO,CAAC,YAAY,UAAA,CAAA,SAApB;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ClassStmt, PartialModule, Statement, StmtModifier} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {isClassMetadata, MetadataCollector, MetadataValue, ModuleMetadata} from '../metadata/index';\n\nimport {MetadataTransformer, ValueTransform} from './metadata_cache';\n\nexport class PartialModuleMetadataTransformer implements MetadataTransformer {\n  private moduleMap: Map<string, PartialModule>;\n\n  constructor(modules: PartialModule[]) {\n    this.moduleMap = new Map(modules.map<[string, PartialModule]>(m => [m.fileName, m]));\n  }\n\n  start(sourceFile: ts.SourceFile): ValueTransform|undefined {\n    const partialModule = this.moduleMap.get(sourceFile.fileName);\n    if (partialModule) {\n      const classMap = new Map<string, ClassStmt>(\n          partialModule.statements.filter(isClassStmt).map<[string, ClassStmt]>(s => [s.name, s]));\n      if (classMap.size > 0) {\n        return (value: MetadataValue, node: ts.Node): MetadataValue => {\n          // For class metadata that is going to be transformed to have a static method ensure the\n          // metadata contains a static declaration the new static method.\n          if (isClassMetadata(value) && node.kind === ts.SyntaxKind.ClassDeclaration) {\n            const classDeclaration = node as ts.ClassDeclaration;\n            if (classDeclaration.name) {\n              const partialClass = classMap.get(classDeclaration.name.text);\n              if (partialClass) {\n                for (const field of partialClass.fields) {\n                  if (field.name && field.modifiers &&\n                      field.modifiers.some(modifier => modifier === StmtModifier.Static)) {\n                    value.statics = {...(value.statics || {}), [field.name]: {}};\n                  }\n                }\n              }\n            }\n          }\n          return value;\n        };\n      }\n    }\n  }\n}\n\nfunction isClassStmt(v: Statement): v is ClassStmt {\n  return v instanceof ClassStmt;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}