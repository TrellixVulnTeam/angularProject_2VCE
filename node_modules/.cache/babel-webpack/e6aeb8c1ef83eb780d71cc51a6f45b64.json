{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\n\nvar LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\n\nvar addToSetMap = function addToSetMap(map, key, value) {\n  var set = map.get(key);\n\n  if (set === undefined) {\n    map.set(key, new Set([value]));\n  } else {\n    set.add(value);\n  }\n};\n\nvar LimitChunkCountPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {LimitChunkCountPluginOptions=} options options object\n   */\n  function LimitChunkCountPlugin(options) {\n    _classCallCheck(this, LimitChunkCountPlugin);\n\n    if (!options) options = {};\n    validateOptions(schema, options, \"Limit Chunk Count Plugin\");\n    this.options = options;\n  }\n  /**\n   * @param {Compiler} compiler the webpack compiler\n   * @returns {void}\n   */\n\n\n  _createClass(LimitChunkCountPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var options = this.options;\n      compiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", function (compilation) {\n        compilation.hooks.optimizeChunksAdvanced.tap(\"LimitChunkCountPlugin\", function (chunks) {\n          var maxChunks = options.maxChunks;\n          if (!maxChunks) return;\n          if (maxChunks < 1) return;\n          if (chunks.length <= maxChunks) return;\n          var remainingChunksToMerge = chunks.length - maxChunks; // order chunks in a deterministic way\n\n          var orderedChunks = chunks.slice().sort(function (a, b) {\n            return a.compareTo(b);\n          }); // create a lazy sorted data structure to keep all combinations\n          // this is large. Size = chunks * (chunks - 1) / 2\n          // It uses a multi layer bucket sort plus normal sort in the last layer\n          // It's also lazy so only accessed buckets are sorted\n\n          var combinations = new LazyBucketSortedSet( // Layer 1: ordered by largest size benefit\n          function (c) {\n            return c.sizeDiff;\n          }, function (a, b) {\n            return b - a;\n          }, // Layer 2: ordered by smallest combined size\n          function (c) {\n            return c.integratedSize;\n          }, function (a, b) {\n            return a - b;\n          }, // Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n          function (c) {\n            return c.bIdx - c.aIdx;\n          }, function (a, b) {\n            return a - b;\n          }, // Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n          function (a, b) {\n            return a.bIdx - b.bIdx;\n          }); // we keep a mappng from chunk to all combinations\n          // but this mapping is not kept up-to-date with deletions\n          // so `deleted` flag need to be considered when iterating this\n\n          /** @type {Map<Chunk, Set<ChunkCombination>>} */\n\n          var combinationsByChunk = new Map();\n          orderedChunks.forEach(function (b, bIdx) {\n            // create combination pairs with size and integrated size\n            for (var aIdx = 0; aIdx < bIdx; aIdx++) {\n              var a = orderedChunks[aIdx];\n              var integratedSize = a.integratedSize(b, options); // filter pairs that do not have an integratedSize\n              // meaning they can NOT be integrated!\n\n              if (integratedSize === false) continue;\n              var aSize = a.size(options);\n              var bSize = b.size(options);\n              var c = {\n                deleted: false,\n                sizeDiff: aSize + bSize - integratedSize,\n                integratedSize: integratedSize,\n                a: a,\n                b: b,\n                aIdx: aIdx,\n                bIdx: bIdx,\n                aSize: aSize,\n                bSize: bSize\n              };\n              combinations.add(c);\n              addToSetMap(combinationsByChunk, a, c);\n              addToSetMap(combinationsByChunk, b, c);\n            }\n\n            return combinations;\n          }); // list of modified chunks during this run\n          // combinations affected by this change are skipped to allow\n          // futher optimizations\n\n          /** @type {Set<Chunk>} */\n\n          var modifiedChunks = new Set();\n          var changed = false; // eslint-disable-next-line no-constant-condition\n\n          loop: while (true) {\n            var combination = combinations.popFirst();\n            if (combination === undefined) break;\n            combination.deleted = true;\n            var a = combination.a,\n                b = combination.b,\n                integratedSize = combination.integratedSize; // skip over pair when\n            // one of the already merged chunks is a parent of one of the chunks\n\n            if (modifiedChunks.size > 0) {\n              var queue = new Set(a.groupsIterable);\n\n              var _iterator = _createForOfIteratorHelper(b.groupsIterable),\n                  _step;\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var group = _step.value;\n                  queue.add(group);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              var _iterator2 = _createForOfIteratorHelper(queue),\n                  _step2;\n\n              try {\n                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                  var _group = _step2.value;\n\n                  var _iterator3 = _createForOfIteratorHelper(modifiedChunks),\n                      _step3;\n\n                  try {\n                    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                      var mChunk = _step3.value;\n\n                      if (mChunk !== a && mChunk !== b && mChunk.isInGroup(_group)) {\n                        // This is a potential pair which needs recalculation\n                        // We can't do that now, but it merge before following pairs\n                        // so we leave space for it, and consider chunks as modified\n                        // just for the worse case\n                        remainingChunksToMerge--;\n                        if (remainingChunksToMerge <= 0) break loop;\n                        modifiedChunks.add(a);\n                        modifiedChunks.add(b);\n                        continue loop;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator3.e(err);\n                  } finally {\n                    _iterator3.f();\n                  }\n\n                  var _iterator4 = _createForOfIteratorHelper(_group.parentsIterable),\n                      _step4;\n\n                  try {\n                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                      var parent = _step4.value;\n                      queue.add(parent);\n                    }\n                  } catch (err) {\n                    _iterator4.e(err);\n                  } finally {\n                    _iterator4.f();\n                  }\n                }\n              } catch (err) {\n                _iterator2.e(err);\n              } finally {\n                _iterator2.f();\n              }\n            } // merge the chunks\n\n\n            if (a.integrate(b, \"limit\")) {\n              chunks.splice(chunks.indexOf(b), 1); // flag chunk a as modified as further optimization are possible for all children here\n\n              modifiedChunks.add(a);\n              changed = true;\n              remainingChunksToMerge--;\n              if (remainingChunksToMerge <= 0) break; // Update all affected combinations\n              // delete all combination with the removed chunk\n              // we will use combinations with the kept chunk instead\n\n              var _iterator5 = _createForOfIteratorHelper(combinationsByChunk.get(b)),\n                  _step5;\n\n              try {\n                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                  var _combination = _step5.value;\n                  if (_combination.deleted) continue;\n                  _combination.deleted = true;\n                  combinations.delete(_combination);\n                } // Update combinations with the kept chunk with new sizes\n\n              } catch (err) {\n                _iterator5.e(err);\n              } finally {\n                _iterator5.f();\n              }\n\n              var _iterator6 = _createForOfIteratorHelper(combinationsByChunk.get(a)),\n                  _step6;\n\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  var _combination2 = _step6.value;\n                  if (_combination2.deleted) continue;\n\n                  if (_combination2.a === a) {\n                    // Update size\n                    var newIntegratedSize = a.integratedSize(_combination2.b, options);\n\n                    if (newIntegratedSize === false) {\n                      _combination2.deleted = true;\n                      combinations.delete(_combination2);\n                      continue;\n                    }\n\n                    var finishUpdate = combinations.startUpdate(_combination2);\n                    _combination2.integratedSize = newIntegratedSize;\n                    _combination2.aSize = integratedSize;\n                    _combination2.sizeDiff = _combination2.bSize + integratedSize - newIntegratedSize;\n                    finishUpdate();\n                  } else if (_combination2.b === a) {\n                    // Update size\n                    var _newIntegratedSize = _combination2.a.integratedSize(a, options);\n\n                    if (_newIntegratedSize === false) {\n                      _combination2.deleted = true;\n                      combinations.delete(_combination2);\n                      continue;\n                    }\n\n                    var _finishUpdate = combinations.startUpdate(_combination2);\n\n                    _combination2.integratedSize = _newIntegratedSize;\n                    _combination2.bSize = integratedSize;\n                    _combination2.sizeDiff = integratedSize + _combination2.aSize - _newIntegratedSize;\n\n                    _finishUpdate();\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n            }\n          }\n\n          if (changed) return true;\n        });\n      });\n    }\n  }]);\n\n  return LimitChunkCountPlugin;\n}();\n\nmodule.exports = LimitChunkCountPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/optimize/LimitChunkCountPlugin.js"],"names":["validateOptions","require","schema","LazyBucketSortedSet","addToSetMap","map","key","value","set","get","undefined","Set","add","LimitChunkCountPlugin","options","compiler","hooks","compilation","tap","optimizeChunksAdvanced","chunks","maxChunks","length","remainingChunksToMerge","orderedChunks","slice","sort","a","b","compareTo","combinations","c","sizeDiff","integratedSize","bIdx","aIdx","combinationsByChunk","Map","forEach","aSize","size","bSize","deleted","modifiedChunks","changed","loop","combination","popFirst","queue","groupsIterable","group","mChunk","isInGroup","parentsIterable","parent","integrate","splice","indexOf","delete","newIntegratedSize","finishUpdate","startUpdate","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAEA,IAAMA,eAAe,GAAGC,OAAO,CAAC,cAAD,CAA/B;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,2DAAD,CAAtB;;AACA,IAAME,mBAAmB,GAAGF,OAAO,CAAC,6BAAD,CAAnC;AAEA;;AACA;;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,IAAMG,WAAW,GAAG,SAAdA,WAAc,CAACC,GAAD,EAAMC,GAAN,EAAWC,KAAX,EAAqB;AACxC,MAAMC,GAAG,GAAGH,GAAG,CAACI,GAAJ,CAAQH,GAAR,CAAZ;;AACA,MAAIE,GAAG,KAAKE,SAAZ,EAAuB;AACtBL,IAAAA,GAAG,CAACG,GAAJ,CAAQF,GAAR,EAAa,IAAIK,GAAJ,CAAQ,CAACJ,KAAD,CAAR,CAAb;AACA,GAFD,MAEO;AACNC,IAAAA,GAAG,CAACI,GAAJ,CAAQL,KAAR;AACA;AACD,CAPD;;IASMM,qB;AACL;AACD;AACA;AACC,iCAAYC,OAAZ,EAAqB;AAAA;;AACpB,QAAI,CAACA,OAAL,EAAcA,OAAO,GAAG,EAAV;AAEdd,IAAAA,eAAe,CAACE,MAAD,EAASY,OAAT,EAAkB,0BAAlB,CAAf;AACA,SAAKA,OAAL,GAAeA,OAAf;AACA;AAED;AACD;AACA;AACA;;;;;WACC,eAAMC,QAAN,EAAgB;AACf,UAAMD,OAAO,GAAG,KAAKA,OAArB;AACAC,MAAAA,QAAQ,CAACC,KAAT,CAAeC,WAAf,CAA2BC,GAA3B,CAA+B,uBAA/B,EAAwD,UAAAD,WAAW,EAAI;AACtEA,QAAAA,WAAW,CAACD,KAAZ,CAAkBG,sBAAlB,CAAyCD,GAAzC,CACC,uBADD,EAEC,UAAAE,MAAM,EAAI;AACT,cAAMC,SAAS,GAAGP,OAAO,CAACO,SAA1B;AACA,cAAI,CAACA,SAAL,EAAgB;AAChB,cAAIA,SAAS,GAAG,CAAhB,EAAmB;AACnB,cAAID,MAAM,CAACE,MAAP,IAAiBD,SAArB,EAAgC;AAEhC,cAAIE,sBAAsB,GAAGH,MAAM,CAACE,MAAP,GAAgBD,SAA7C,CANS,CAQT;;AACA,cAAMG,aAAa,GAAGJ,MAAM,CAACK,KAAP,GAAeC,IAAf,CAAoB,UAACC,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,CAACE,SAAF,CAAYD,CAAZ,CAAV;AAAA,WAApB,CAAtB,CATS,CAWT;AACA;AACA;AACA;;AACA,cAAME,YAAY,GAAG,IAAI3B,mBAAJ,EACpB;AACA,oBAAA4B,CAAC;AAAA,mBAAIA,CAAC,CAACC,QAAN;AAAA,WAFmB,EAGpB,UAACL,CAAD,EAAIC,CAAJ;AAAA,mBAAUA,CAAC,GAAGD,CAAd;AAAA,WAHoB,EAIpB;AACA,oBAAAI,CAAC;AAAA,mBAAIA,CAAC,CAACE,cAAN;AAAA,WALmB,EAMpB,UAACN,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WANoB,EAOpB;AACA,oBAAAG,CAAC;AAAA,mBAAIA,CAAC,CAACG,IAAF,GAASH,CAAC,CAACI,IAAf;AAAA,WARmB,EASpB,UAACR,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,GAAGC,CAAd;AAAA,WAToB,EAUpB;AACA,oBAACD,CAAD,EAAIC,CAAJ;AAAA,mBAAUD,CAAC,CAACO,IAAF,GAASN,CAAC,CAACM,IAArB;AAAA,WAXoB,CAArB,CAfS,CA6BT;AACA;AACA;;AACA;;AACA,cAAME,mBAAmB,GAAG,IAAIC,GAAJ,EAA5B;AAEAb,UAAAA,aAAa,CAACc,OAAd,CAAsB,UAACV,CAAD,EAAIM,IAAJ,EAAa;AAClC;AACA,iBAAK,IAAIC,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGD,IAA1B,EAAgCC,IAAI,EAApC,EAAwC;AACvC,kBAAMR,CAAC,GAAGH,aAAa,CAACW,IAAD,CAAvB;AACA,kBAAMF,cAAc,GAAGN,CAAC,CAACM,cAAF,CAAiBL,CAAjB,EAAoBd,OAApB,CAAvB,CAFuC,CAIvC;AACA;;AACA,kBAAImB,cAAc,KAAK,KAAvB,EAA8B;AAE9B,kBAAMM,KAAK,GAAGZ,CAAC,CAACa,IAAF,CAAO1B,OAAP,CAAd;AACA,kBAAM2B,KAAK,GAAGb,CAAC,CAACY,IAAF,CAAO1B,OAAP,CAAd;AACA,kBAAMiB,CAAC,GAAG;AACTW,gBAAAA,OAAO,EAAE,KADA;AAETV,gBAAAA,QAAQ,EAAEO,KAAK,GAAGE,KAAR,GAAgBR,cAFjB;AAGTA,gBAAAA,cAAc,EAAdA,cAHS;AAITN,gBAAAA,CAAC,EAADA,CAJS;AAKTC,gBAAAA,CAAC,EAADA,CALS;AAMTO,gBAAAA,IAAI,EAAJA,IANS;AAOTD,gBAAAA,IAAI,EAAJA,IAPS;AAQTK,gBAAAA,KAAK,EAALA,KARS;AASTE,gBAAAA,KAAK,EAALA;AATS,eAAV;AAWAX,cAAAA,YAAY,CAAClB,GAAb,CAAiBmB,CAAjB;AACA3B,cAAAA,WAAW,CAACgC,mBAAD,EAAsBT,CAAtB,EAAyBI,CAAzB,CAAX;AACA3B,cAAAA,WAAW,CAACgC,mBAAD,EAAsBR,CAAtB,EAAyBG,CAAzB,CAAX;AACA;;AACD,mBAAOD,YAAP;AACA,WA5BD,EAnCS,CAiET;AACA;AACA;;AACA;;AACA,cAAMa,cAAc,GAAG,IAAIhC,GAAJ,EAAvB;AAEA,cAAIiC,OAAO,GAAG,KAAd,CAvES,CAwET;;AACAC,UAAAA,IAAI,EAAE,OAAO,IAAP,EAAa;AAClB,gBAAMC,WAAW,GAAGhB,YAAY,CAACiB,QAAb,EAApB;AACA,gBAAID,WAAW,KAAKpC,SAApB,EAA+B;AAE/BoC,YAAAA,WAAW,CAACJ,OAAZ,GAAsB,IAAtB;AACA,gBAAQf,CAAR,GAAiCmB,WAAjC,CAAQnB,CAAR;AAAA,gBAAWC,CAAX,GAAiCkB,WAAjC,CAAWlB,CAAX;AAAA,gBAAcK,cAAd,GAAiCa,WAAjC,CAAcb,cAAd,CALkB,CAOlB;AACA;;AACA,gBAAIU,cAAc,CAACH,IAAf,GAAsB,CAA1B,EAA6B;AAC5B,kBAAMQ,KAAK,GAAG,IAAIrC,GAAJ,CAAQgB,CAAC,CAACsB,cAAV,CAAd;;AAD4B,yDAERrB,CAAC,CAACqB,cAFM;AAAA;;AAAA;AAE5B,oEAAsC;AAAA,sBAA3BC,KAA2B;AACrCF,kBAAAA,KAAK,CAACpC,GAAN,CAAUsC,KAAV;AACA;AAJ2B;AAAA;AAAA;AAAA;AAAA;;AAAA,0DAKRF,KALQ;AAAA;;AAAA;AAK5B,uEAA2B;AAAA,sBAAhBE,MAAgB;;AAAA,8DACLP,cADK;AAAA;;AAAA;AAC1B,2EAAqC;AAAA,0BAA1BQ,MAA0B;;AACpC,0BAAIA,MAAM,KAAKxB,CAAX,IAAgBwB,MAAM,KAAKvB,CAA3B,IAAgCuB,MAAM,CAACC,SAAP,CAAiBF,MAAjB,CAApC,EAA6D;AAC5D;AACA;AACA;AACA;AACA3B,wBAAAA,sBAAsB;AACtB,4BAAIA,sBAAsB,IAAI,CAA9B,EAAiC,MAAMsB,IAAN;AACjCF,wBAAAA,cAAc,CAAC/B,GAAf,CAAmBe,CAAnB;AACAgB,wBAAAA,cAAc,CAAC/B,GAAf,CAAmBgB,CAAnB;AACA,iCAASiB,IAAT;AACA;AACD;AAbyB;AAAA;AAAA;AAAA;AAAA;;AAAA,8DAcLK,MAAK,CAACG,eAdD;AAAA;;AAAA;AAc1B,2EAA4C;AAAA,0BAAjCC,MAAiC;AAC3CN,sBAAAA,KAAK,CAACpC,GAAN,CAAU0C,MAAV;AACA;AAhByB;AAAA;AAAA;AAAA;AAAA;AAiB1B;AAtB2B;AAAA;AAAA;AAAA;AAAA;AAuB5B,aAhCiB,CAkClB;;;AACA,gBAAI3B,CAAC,CAAC4B,SAAF,CAAY3B,CAAZ,EAAe,OAAf,CAAJ,EAA6B;AAC5BR,cAAAA,MAAM,CAACoC,MAAP,CAAcpC,MAAM,CAACqC,OAAP,CAAe7B,CAAf,CAAd,EAAiC,CAAjC,EAD4B,CAG5B;;AACAe,cAAAA,cAAc,CAAC/B,GAAf,CAAmBe,CAAnB;AAEAiB,cAAAA,OAAO,GAAG,IAAV;AACArB,cAAAA,sBAAsB;AACtB,kBAAIA,sBAAsB,IAAI,CAA9B,EAAiC,MARL,CAU5B;AACA;AACA;;AAZ4B,0DAaFa,mBAAmB,CAAC3B,GAApB,CAAwBmB,CAAxB,CAbE;AAAA;;AAAA;AAa5B,uEAAsD;AAAA,sBAA3CkB,YAA2C;AACrD,sBAAIA,YAAW,CAACJ,OAAhB,EAAyB;AACzBI,kBAAAA,YAAW,CAACJ,OAAZ,GAAsB,IAAtB;AACAZ,kBAAAA,YAAY,CAAC4B,MAAb,CAAoBZ,YAApB;AACA,iBAjB2B,CAmB5B;;AAnB4B;AAAA;AAAA;AAAA;AAAA;;AAAA,0DAoBFV,mBAAmB,CAAC3B,GAApB,CAAwBkB,CAAxB,CApBE;AAAA;;AAAA;AAoB5B,uEAAsD;AAAA,sBAA3CmB,aAA2C;AACrD,sBAAIA,aAAW,CAACJ,OAAhB,EAAyB;;AACzB,sBAAII,aAAW,CAACnB,CAAZ,KAAkBA,CAAtB,EAAyB;AACxB;AACA,wBAAMgC,iBAAiB,GAAGhC,CAAC,CAACM,cAAF,CACzBa,aAAW,CAAClB,CADa,EAEzBd,OAFyB,CAA1B;;AAIA,wBAAI6C,iBAAiB,KAAK,KAA1B,EAAiC;AAChCb,sBAAAA,aAAW,CAACJ,OAAZ,GAAsB,IAAtB;AACAZ,sBAAAA,YAAY,CAAC4B,MAAb,CAAoBZ,aAApB;AACA;AACA;;AACD,wBAAMc,YAAY,GAAG9B,YAAY,CAAC+B,WAAb,CAAyBf,aAAzB,CAArB;AACAA,oBAAAA,aAAW,CAACb,cAAZ,GAA6B0B,iBAA7B;AACAb,oBAAAA,aAAW,CAACP,KAAZ,GAAoBN,cAApB;AACAa,oBAAAA,aAAW,CAACd,QAAZ,GACCc,aAAW,CAACL,KAAZ,GAAoBR,cAApB,GAAqC0B,iBADtC;AAEAC,oBAAAA,YAAY;AACZ,mBAjBD,MAiBO,IAAId,aAAW,CAAClB,CAAZ,KAAkBD,CAAtB,EAAyB;AAC/B;AACA,wBAAMgC,kBAAiB,GAAGb,aAAW,CAACnB,CAAZ,CAAcM,cAAd,CACzBN,CADyB,EAEzBb,OAFyB,CAA1B;;AAIA,wBAAI6C,kBAAiB,KAAK,KAA1B,EAAiC;AAChCb,sBAAAA,aAAW,CAACJ,OAAZ,GAAsB,IAAtB;AACAZ,sBAAAA,YAAY,CAAC4B,MAAb,CAAoBZ,aAApB;AACA;AACA;;AACD,wBAAMc,aAAY,GAAG9B,YAAY,CAAC+B,WAAb,CAAyBf,aAAzB,CAArB;;AACAA,oBAAAA,aAAW,CAACb,cAAZ,GAA6B0B,kBAA7B;AACAb,oBAAAA,aAAW,CAACL,KAAZ,GAAoBR,cAApB;AACAa,oBAAAA,aAAW,CAACd,QAAZ,GACCC,cAAc,GAAGa,aAAW,CAACP,KAA7B,GAAqCoB,kBADtC;;AAEAC,oBAAAA,aAAY;AACZ;AACD;AAzD2B;AAAA;AAAA;AAAA;AAAA;AA0D5B;AACD;;AACD,cAAIhB,OAAJ,EAAa,OAAO,IAAP;AACb,SA3KF;AA6KA,OA9KD;AA+KA;;;;;;AAEFkB,MAAM,CAACC,OAAP,GAAiBlD,qBAAjB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/LimitChunkCountPlugin.json\");\nconst LazyBucketSortedSet = require(\"../util/LazyBucketSortedSet\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/LimitChunkCountPlugin\").LimitChunkCountPluginOptions} LimitChunkCountPluginOptions */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/**\n * @typedef {Object} ChunkCombination\n * @property {boolean} deleted this is set to true when combination was removed\n * @property {number} sizeDiff\n * @property {number} integratedSize\n * @property {Chunk} a\n * @property {Chunk} b\n * @property {number} aIdx\n * @property {number} bIdx\n * @property {number} aSize\n * @property {number} bSize\n */\n\nconst addToSetMap = (map, key, value) => {\n\tconst set = map.get(key);\n\tif (set === undefined) {\n\t\tmap.set(key, new Set([value]));\n\t} else {\n\t\tset.add(value);\n\t}\n};\n\nclass LimitChunkCountPlugin {\n\t/**\n\t * @param {LimitChunkCountPluginOptions=} options options object\n\t */\n\tconstructor(options) {\n\t\tif (!options) options = {};\n\n\t\tvalidateOptions(schema, options, \"Limit Chunk Count Plugin\");\n\t\tthis.options = options;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst options = this.options;\n\t\tcompiler.hooks.compilation.tap(\"LimitChunkCountPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"LimitChunkCountPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tconst maxChunks = options.maxChunks;\n\t\t\t\t\tif (!maxChunks) return;\n\t\t\t\t\tif (maxChunks < 1) return;\n\t\t\t\t\tif (chunks.length <= maxChunks) return;\n\n\t\t\t\t\tlet remainingChunksToMerge = chunks.length - maxChunks;\n\n\t\t\t\t\t// order chunks in a deterministic way\n\t\t\t\t\tconst orderedChunks = chunks.slice().sort((a, b) => a.compareTo(b));\n\n\t\t\t\t\t// create a lazy sorted data structure to keep all combinations\n\t\t\t\t\t// this is large. Size = chunks * (chunks - 1) / 2\n\t\t\t\t\t// It uses a multi layer bucket sort plus normal sort in the last layer\n\t\t\t\t\t// It's also lazy so only accessed buckets are sorted\n\t\t\t\t\tconst combinations = new LazyBucketSortedSet(\n\t\t\t\t\t\t// Layer 1: ordered by largest size benefit\n\t\t\t\t\t\tc => c.sizeDiff,\n\t\t\t\t\t\t(a, b) => b - a,\n\t\t\t\t\t\t// Layer 2: ordered by smallest combined size\n\t\t\t\t\t\tc => c.integratedSize,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 3: ordered by position difference in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\tc => c.bIdx - c.aIdx,\n\t\t\t\t\t\t(a, b) => a - b,\n\t\t\t\t\t\t// Layer 4: ordered by position in orderedChunk (-> to be deterministic)\n\t\t\t\t\t\t(a, b) => a.bIdx - b.bIdx\n\t\t\t\t\t);\n\n\t\t\t\t\t// we keep a mappng from chunk to all combinations\n\t\t\t\t\t// but this mapping is not kept up-to-date with deletions\n\t\t\t\t\t// so `deleted` flag need to be considered when iterating this\n\t\t\t\t\t/** @type {Map<Chunk, Set<ChunkCombination>>} */\n\t\t\t\t\tconst combinationsByChunk = new Map();\n\n\t\t\t\t\torderedChunks.forEach((b, bIdx) => {\n\t\t\t\t\t\t// create combination pairs with size and integrated size\n\t\t\t\t\t\tfor (let aIdx = 0; aIdx < bIdx; aIdx++) {\n\t\t\t\t\t\t\tconst a = orderedChunks[aIdx];\n\t\t\t\t\t\t\tconst integratedSize = a.integratedSize(b, options);\n\n\t\t\t\t\t\t\t// filter pairs that do not have an integratedSize\n\t\t\t\t\t\t\t// meaning they can NOT be integrated!\n\t\t\t\t\t\t\tif (integratedSize === false) continue;\n\n\t\t\t\t\t\t\tconst aSize = a.size(options);\n\t\t\t\t\t\t\tconst bSize = b.size(options);\n\t\t\t\t\t\t\tconst c = {\n\t\t\t\t\t\t\t\tdeleted: false,\n\t\t\t\t\t\t\t\tsizeDiff: aSize + bSize - integratedSize,\n\t\t\t\t\t\t\t\tintegratedSize,\n\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\tb,\n\t\t\t\t\t\t\t\taIdx,\n\t\t\t\t\t\t\t\tbIdx,\n\t\t\t\t\t\t\t\taSize,\n\t\t\t\t\t\t\t\tbSize\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcombinations.add(c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, a, c);\n\t\t\t\t\t\t\taddToSetMap(combinationsByChunk, b, c);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn combinations;\n\t\t\t\t\t});\n\n\t\t\t\t\t// list of modified chunks during this run\n\t\t\t\t\t// combinations affected by this change are skipped to allow\n\t\t\t\t\t// futher optimizations\n\t\t\t\t\t/** @type {Set<Chunk>} */\n\t\t\t\t\tconst modifiedChunks = new Set();\n\n\t\t\t\t\tlet changed = false;\n\t\t\t\t\t// eslint-disable-next-line no-constant-condition\n\t\t\t\t\tloop: while (true) {\n\t\t\t\t\t\tconst combination = combinations.popFirst();\n\t\t\t\t\t\tif (combination === undefined) break;\n\n\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\tconst { a, b, integratedSize } = combination;\n\n\t\t\t\t\t\t// skip over pair when\n\t\t\t\t\t\t// one of the already merged chunks is a parent of one of the chunks\n\t\t\t\t\t\tif (modifiedChunks.size > 0) {\n\t\t\t\t\t\t\tconst queue = new Set(a.groupsIterable);\n\t\t\t\t\t\t\tfor (const group of b.groupsIterable) {\n\t\t\t\t\t\t\t\tqueue.add(group);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const group of queue) {\n\t\t\t\t\t\t\t\tfor (const mChunk of modifiedChunks) {\n\t\t\t\t\t\t\t\t\tif (mChunk !== a && mChunk !== b && mChunk.isInGroup(group)) {\n\t\t\t\t\t\t\t\t\t\t// This is a potential pair which needs recalculation\n\t\t\t\t\t\t\t\t\t\t// We can't do that now, but it merge before following pairs\n\t\t\t\t\t\t\t\t\t\t// so we leave space for it, and consider chunks as modified\n\t\t\t\t\t\t\t\t\t\t// just for the worse case\n\t\t\t\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break loop;\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\t\t\t\t\t\t\t\t\t\tmodifiedChunks.add(b);\n\t\t\t\t\t\t\t\t\t\tcontinue loop;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const parent of group.parentsIterable) {\n\t\t\t\t\t\t\t\t\tqueue.add(parent);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// merge the chunks\n\t\t\t\t\t\tif (a.integrate(b, \"limit\")) {\n\t\t\t\t\t\t\tchunks.splice(chunks.indexOf(b), 1);\n\n\t\t\t\t\t\t\t// flag chunk a as modified as further optimization are possible for all children here\n\t\t\t\t\t\t\tmodifiedChunks.add(a);\n\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tremainingChunksToMerge--;\n\t\t\t\t\t\t\tif (remainingChunksToMerge <= 0) break;\n\n\t\t\t\t\t\t\t// Update all affected combinations\n\t\t\t\t\t\t\t// delete all combination with the removed chunk\n\t\t\t\t\t\t\t// we will use combinations with the kept chunk instead\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(b)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Update combinations with the kept chunk with new sizes\n\t\t\t\t\t\t\tfor (const combination of combinationsByChunk.get(a)) {\n\t\t\t\t\t\t\t\tif (combination.deleted) continue;\n\t\t\t\t\t\t\t\tif (combination.a === a) {\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = a.integratedSize(\n\t\t\t\t\t\t\t\t\t\tcombination.b,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (newIntegratedSize === false) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.aSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tcombination.bSize + integratedSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t} else if (combination.b === a) {\n\t\t\t\t\t\t\t\t\t// Update size\n\t\t\t\t\t\t\t\t\tconst newIntegratedSize = combination.a.integratedSize(\n\t\t\t\t\t\t\t\t\t\ta,\n\t\t\t\t\t\t\t\t\t\toptions\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (newIntegratedSize === false) {\n\t\t\t\t\t\t\t\t\t\tcombination.deleted = true;\n\t\t\t\t\t\t\t\t\t\tcombinations.delete(combination);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst finishUpdate = combinations.startUpdate(combination);\n\t\t\t\t\t\t\t\t\tcombination.integratedSize = newIntegratedSize;\n\t\t\t\t\t\t\t\t\tcombination.bSize = integratedSize;\n\t\t\t\t\t\t\t\t\tcombination.sizeDiff =\n\t\t\t\t\t\t\t\t\t\tintegratedSize + combination.aSize - newIntegratedSize;\n\t\t\t\t\t\t\t\t\tfinishUpdate();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (changed) return true;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = LimitChunkCountPlugin;\n"]},"metadata":{},"sourceType":"script"}