{"ast":null,"code":"var debug = require('debug')('log4js:categories');\n\nvar configuration = require('./configuration');\n\nvar levels = require('./levels');\n\nvar appenders = require('./appenders');\n\nvar categories = new Map();\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\n\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  var lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n\n  var parentCategoryName = categoryName.substring(0, lastDotIndex);\n  var parentCategory = config.categories[parentCategoryName];\n\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = {\n      inherit: true,\n      appenders: []\n    };\n  } // make sure parent has had its inheritance taken care of before pulling its properties to this child\n\n\n  inheritFromParent(config, parentCategory, parentCategoryName); // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n\n  if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level; // merge in appenders from parent (parent is already holding its inherited appenders)\n\n  parentCategory.appenders.forEach(function (ap) {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\n\n\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  var categoryNames = Object.keys(config.categories);\n  categoryNames.forEach(function (name) {\n    var category = config.categories[name]; // add inherited appenders and level to this category\n\n    inheritFromParent(config, category, name);\n  });\n}\n\nconfiguration.addPreProcessingListener(function (config) {\n  return addCategoryInheritance(config);\n});\nconfiguration.addListener(function (config) {\n  configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.categories)), 'must have a property \"categories\" of type object.');\n  var categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(config, configuration.not(categoryNames.length), 'must define at least one category.');\n  categoryNames.forEach(function (name) {\n    var category = config.categories[name];\n    configuration.throwExceptionIf(config, [configuration.not(category.appenders), configuration.not(category.level)], \"category \\\"\".concat(name, \"\\\" is not valid (must be an object with properties \\\"appenders\\\" and \\\"level\\\")\"));\n    configuration.throwExceptionIf(config, configuration.not(Array.isArray(category.appenders)), \"category \\\"\".concat(name, \"\\\" is not valid (appenders must be an array of appender names)\"));\n    configuration.throwExceptionIf(config, configuration.not(category.appenders.length), \"category \\\"\".concat(name, \"\\\" is not valid (appenders must contain at least one appender name)\"));\n\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(config, typeof category.enableCallStack !== 'boolean', \"category \\\"\".concat(name, \"\\\" is not valid (enableCallStack must be boolean type)\"));\n    }\n\n    category.appenders.forEach(function (appender) {\n      configuration.throwExceptionIf(config, configuration.not(appenders.get(appender)), \"category \\\"\".concat(name, \"\\\" is not valid (appender \\\"\").concat(appender, \"\\\" is not defined)\"));\n    });\n    configuration.throwExceptionIf(config, configuration.not(levels.getLevel(category.level)), \"category \\\"\".concat(name, \"\\\" is not valid (level \\\"\").concat(category.level, \"\\\" not recognised;\") + \" valid levels are \".concat(levels.levels.join(', '), \")\"));\n  });\n  configuration.throwExceptionIf(config, configuration.not(config.categories.default), 'must define a \"default\" category.');\n});\n\nvar setup = function setup(config) {\n  categories.clear();\n  var categoryNames = Object.keys(config.categories);\n  categoryNames.forEach(function (name) {\n    var category = config.categories[name];\n    var categoryAppenders = [];\n    category.appenders.forEach(function (appender) {\n      categoryAppenders.push(appenders.get(appender));\n      debug(\"Creating category \".concat(name));\n      categories.set(name, {\n        appenders: categoryAppenders,\n        level: levels.getLevel(category.level),\n        enableCallStack: category.enableCallStack || false\n      });\n    });\n  });\n};\n\nsetup({\n  categories: {\n    default: {\n      appenders: ['out'],\n      level: 'OFF'\n    }\n  }\n});\nconfiguration.addListener(setup);\n\nvar configForCategory = function configForCategory(category) {\n  debug(\"configForCategory: searching for config for \".concat(category));\n\n  if (categories.has(category)) {\n    debug(\"configForCategory: \".concat(category, \" exists in config, returning it\"));\n    return categories.get(category);\n  }\n\n  if (category.indexOf('.') > 0) {\n    debug(\"configForCategory: \".concat(category, \" has hierarchy, searching for parents\"));\n    return configForCategory(category.substring(0, category.lastIndexOf('.')));\n  }\n\n  debug('configForCategory: returning config for default category');\n  return configForCategory('default');\n};\n\nvar appendersForCategory = function appendersForCategory(category) {\n  return configForCategory(category).appenders;\n};\n\nvar getLevelForCategory = function getLevelForCategory(category) {\n  return configForCategory(category).level;\n};\n\nvar setLevelForCategory = function setLevelForCategory(category, level) {\n  var categoryConfig = categories.get(category);\n  debug(\"setLevelForCategory: found \".concat(categoryConfig, \" for \").concat(category));\n\n  if (!categoryConfig) {\n    var sourceCategoryConfig = configForCategory(category);\n    debug('setLevelForCategory: no config found for category, ' + \"found \".concat(sourceCategoryConfig, \" for parents of \").concat(category));\n    categoryConfig = {\n      appenders: sourceCategoryConfig.appenders\n    };\n  }\n\n  categoryConfig.level = level;\n  categories.set(category, categoryConfig);\n};\n\nvar getEnableCallStackForCategory = function getEnableCallStackForCategory(category) {\n  return configForCategory(category).enableCallStack === true;\n};\n\nvar setEnableCallStackForCategory = function setEnableCallStackForCategory(category, useCallStack) {\n  configForCategory(category).enableCallStack = useCallStack;\n};\n\nmodule.exports = {\n  appendersForCategory: appendersForCategory,\n  getLevelForCategory: getLevelForCategory,\n  setLevelForCategory: setLevelForCategory,\n  getEnableCallStackForCategory: getEnableCallStackForCategory,\n  setEnableCallStackForCategory: setEnableCallStackForCategory\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/log4js/lib/categories.js"],"names":["debug","require","configuration","levels","appenders","categories","Map","inheritFromParent","config","category","categoryName","inherit","lastDotIndex","lastIndexOf","parentCategoryName","substring","parentCategory","length","level","forEach","ap","includes","push","parent","addCategoryInheritance","categoryNames","Object","keys","name","addPreProcessingListener","addListener","throwExceptionIf","not","anObject","Array","isArray","prototype","hasOwnProperty","call","enableCallStack","appender","get","getLevel","join","default","setup","clear","categoryAppenders","set","configForCategory","has","indexOf","appendersForCategory","getLevelForCategory","setLevelForCategory","categoryConfig","sourceCategoryConfig","getEnableCallStackForCategory","setEnableCallStackForCategory","useCallStack","module","exports"],"mappings":"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","sourcesContent":["const debug = require('debug')('log4js:categories');\nconst configuration = require('./configuration');\nconst levels = require('./levels');\nconst appenders = require('./appenders');\n\nconst categories = new Map();\n\n/**\n * Add inherited config to this category.  That includes extra appenders from parent,\n * and level, if none is set on this category.\n * This is recursive, so each parent also gets loaded with inherited appenders.\n * Inheritance is blocked if a category has inherit=false\n * @param  {*} config\n * @param  {*} category the child category\n * @param  {string} categoryName dotted path to category\n * @return {void}\n */\nfunction inheritFromParent(config, category, categoryName) {\n  if (category.inherit === false) return;\n  const lastDotIndex = categoryName.lastIndexOf('.');\n  if (lastDotIndex < 0) return; // category is not a child\n  const parentCategoryName = categoryName.substring(0, lastDotIndex);\n  let parentCategory = config.categories[parentCategoryName];\n\n\n  if (!parentCategory) {\n    // parent is missing, so implicitly create it, so that it can inherit from its parents\n    parentCategory = { inherit: true, appenders: [] };\n  }\n\n  // make sure parent has had its inheritance taken care of before pulling its properties to this child\n  inheritFromParent(config, parentCategory, parentCategoryName);\n\n  // if the parent is not in the config (because we just created it above),\n  // and it inherited a valid configuration, add it to config.categories\n  if (!config.categories[parentCategoryName]\n    && parentCategory.appenders\n    && parentCategory.appenders.length\n    && parentCategory.level) {\n    config.categories[parentCategoryName] = parentCategory;\n  }\n\n  category.appenders = category.appenders || [];\n  category.level = category.level || parentCategory.level;\n\n  // merge in appenders from parent (parent is already holding its inherited appenders)\n  parentCategory.appenders.forEach((ap) => {\n    if (!category.appenders.includes(ap)) {\n      category.appenders.push(ap);\n    }\n  });\n  category.parent = parentCategory;\n}\n\n\n/**\n * Walk all categories in the config, and pull down any configuration from parent to child.\n * This includes inherited appenders, and level, where level is not set.\n * Inheritance is skipped where a category has inherit=false.\n * @param  {*} config\n */\nfunction addCategoryInheritance(config) {\n  if (!config.categories) return;\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    // add inherited appenders and level to this category\n    inheritFromParent(config, category, name);\n  });\n}\n\nconfiguration.addPreProcessingListener(config => addCategoryInheritance(config));\n\nconfiguration.addListener((config) => {\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(configuration.anObject(config.categories)),\n    'must have a property \"categories\" of type object.'\n  );\n\n  const categoryNames = Object.keys(config.categories);\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(categoryNames.length),\n    'must define at least one category.'\n  );\n\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    configuration.throwExceptionIf(\n      config,\n      [\n        configuration.not(category.appenders),\n        configuration.not(category.level)\n      ],\n      `category \"${name}\" is not valid (must be an object with properties \"appenders\" and \"level\")`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(Array.isArray(category.appenders)),\n      `category \"${name}\" is not valid (appenders must be an array of appender names)`\n    );\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(category.appenders.length),\n      `category \"${name}\" is not valid (appenders must contain at least one appender name)`\n    );\n\n    if (Object.prototype.hasOwnProperty.call(category, 'enableCallStack')) {\n      configuration.throwExceptionIf(\n        config,\n        typeof category.enableCallStack !== 'boolean',\n        `category \"${name}\" is not valid (enableCallStack must be boolean type)`\n      );\n    }\n\n    category.appenders.forEach((appender) => {\n      configuration.throwExceptionIf(\n        config,\n        configuration.not(appenders.get(appender)),\n        `category \"${name}\" is not valid (appender \"${appender}\" is not defined)`\n      );\n    });\n\n    configuration.throwExceptionIf(\n      config,\n      configuration.not(levels.getLevel(category.level)),\n      `category \"${name}\" is not valid (level \"${category.level}\" not recognised;`\n      + ` valid levels are ${levels.levels.join(', ')})`\n    );\n  });\n\n  configuration.throwExceptionIf(\n    config,\n    configuration.not(config.categories.default),\n    'must define a \"default\" category.'\n  );\n});\n\nconst setup = (config) => {\n  categories.clear();\n\n  const categoryNames = Object.keys(config.categories);\n  categoryNames.forEach((name) => {\n    const category = config.categories[name];\n    const categoryAppenders = [];\n    category.appenders.forEach((appender) => {\n      categoryAppenders.push(appenders.get(appender));\n      debug(`Creating category ${name}`);\n      categories.set(\n        name,\n        {\n          appenders: categoryAppenders,\n          level: levels.getLevel(category.level),\n          enableCallStack: category.enableCallStack || false\n        }\n      );\n    });\n  });\n};\n\nsetup({ categories: { default: { appenders: ['out'], level: 'OFF' } } });\nconfiguration.addListener(setup);\n\nconst configForCategory = (category) => {\n  debug(`configForCategory: searching for config for ${category}`);\n  if (categories.has(category)) {\n    debug(`configForCategory: ${category} exists in config, returning it`);\n    return categories.get(category);\n  }\n  if (category.indexOf('.') > 0) {\n    debug(`configForCategory: ${category} has hierarchy, searching for parents`);\n    return configForCategory(category.substring(0, category.lastIndexOf('.')));\n  }\n  debug('configForCategory: returning config for default category');\n  return configForCategory('default');\n};\n\nconst appendersForCategory = category => configForCategory(category).appenders;\nconst getLevelForCategory = category => configForCategory(category).level;\n\nconst setLevelForCategory = (category, level) => {\n  let categoryConfig = categories.get(category);\n  debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);\n  if (!categoryConfig) {\n    const sourceCategoryConfig = configForCategory(category);\n    debug('setLevelForCategory: no config found for category, '\n      + `found ${sourceCategoryConfig} for parents of ${category}`);\n    categoryConfig = { appenders: sourceCategoryConfig.appenders };\n  }\n  categoryConfig.level = level;\n  categories.set(category, categoryConfig);\n};\n\nconst getEnableCallStackForCategory = category => configForCategory(category).enableCallStack === true;\nconst setEnableCallStackForCategory = (category, useCallStack) => {\n  configForCategory(category).enableCallStack = useCallStack;\n};\n\nmodule.exports = {\n  appendersForCategory,\n  getLevelForCategory,\n  setLevelForCategory,\n  getEnableCallStackForCategory,\n  setEnableCallStackForCategory,\n};\n"]},"metadata":{},"sourceType":"script"}