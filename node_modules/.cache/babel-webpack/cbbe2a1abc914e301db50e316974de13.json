{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/aot/compiler\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/constant_pool\", \"@angular/compiler/src/core\", \"@angular/compiler/src/i18n/message_bundle\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/ml_parser/html_parser\", \"@angular/compiler/src/ml_parser/interpolation_config\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/util\", \"@angular/compiler/src/aot/generated_file\", \"@angular/compiler/src/aot/lazy_routes\", \"@angular/compiler/src/aot/static_symbol\", \"@angular/compiler/src/aot/summary_serializer\", \"@angular/compiler/src/aot/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.mergeAnalyzedFiles = exports.analyzeFileForInjectables = exports.analyzeFile = exports.analyzeAndValidateNgModules = exports.analyzeNgModules = exports.AotCompiler = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var constant_pool_1 = require(\"@angular/compiler/src/constant_pool\");\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var message_bundle_1 = require(\"@angular/compiler/src/i18n/message_bundle\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var html_parser_1 = require(\"@angular/compiler/src/ml_parser/html_parser\");\n\n  var interpolation_config_1 = require(\"@angular/compiler/src/ml_parser/interpolation_config\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var generated_file_1 = require(\"@angular/compiler/src/aot/generated_file\");\n\n  var lazy_routes_1 = require(\"@angular/compiler/src/aot/lazy_routes\");\n\n  var static_symbol_1 = require(\"@angular/compiler/src/aot/static_symbol\");\n\n  var summary_serializer_1 = require(\"@angular/compiler/src/aot/summary_serializer\");\n\n  var util_2 = require(\"@angular/compiler/src/aot/util\");\n\n  var AotCompiler =\n  /** @class */\n  function () {\n    function AotCompiler(_config, _options, _host, reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _typeCheckCompiler, _ngModuleCompiler, _injectableCompiler, _outputEmitter, _summaryResolver, _symbolResolver) {\n      this._config = _config;\n      this._options = _options;\n      this._host = _host;\n      this.reflector = reflector;\n      this._metadataResolver = _metadataResolver;\n      this._templateParser = _templateParser;\n      this._styleCompiler = _styleCompiler;\n      this._viewCompiler = _viewCompiler;\n      this._typeCheckCompiler = _typeCheckCompiler;\n      this._ngModuleCompiler = _ngModuleCompiler;\n      this._injectableCompiler = _injectableCompiler;\n      this._outputEmitter = _outputEmitter;\n      this._summaryResolver = _summaryResolver;\n      this._symbolResolver = _symbolResolver;\n      this._templateAstCache = new Map();\n      this._analyzedFiles = new Map();\n      this._analyzedFilesForInjectables = new Map();\n    }\n\n    AotCompiler.prototype.clearCache = function () {\n      this._metadataResolver.clearCache();\n    };\n\n    AotCompiler.prototype.analyzeModulesSync = function (rootFiles) {\n      var _this = this;\n\n      var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n      analyzeResult.ngModules.forEach(function (ngModule) {\n        return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true);\n      });\n      return analyzeResult;\n    };\n\n    AotCompiler.prototype.analyzeModulesAsync = function (rootFiles) {\n      var _this = this;\n\n      var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n      return Promise.all(analyzeResult.ngModules.map(function (ngModule) {\n        return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);\n      })).then(function () {\n        return analyzeResult;\n      });\n    };\n\n    AotCompiler.prototype._analyzeFile = function (fileName) {\n      var analyzedFile = this._analyzedFiles.get(fileName);\n\n      if (!analyzedFile) {\n        analyzedFile = analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\n\n        this._analyzedFiles.set(fileName, analyzedFile);\n      }\n\n      return analyzedFile;\n    };\n\n    AotCompiler.prototype._analyzeFileForInjectables = function (fileName) {\n      var analyzedFile = this._analyzedFilesForInjectables.get(fileName);\n\n      if (!analyzedFile) {\n        analyzedFile = analyzeFileForInjectables(this._host, this._symbolResolver, this._metadataResolver, fileName);\n\n        this._analyzedFilesForInjectables.set(fileName, analyzedFile);\n      }\n\n      return analyzedFile;\n    };\n\n    AotCompiler.prototype.findGeneratedFileNames = function (fileName) {\n      var _this = this;\n\n      var genFileNames = [];\n\n      var file = this._analyzeFile(fileName); // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\n      // or a reference to a non source file.\n      // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\n      // Only do this for StubEmitFlags.Basic, as adding a type check block\n      // does not change this file (as we generate type check blocks based on NgModules).\n\n\n      if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length || file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\n        genFileNames.push(util_2.ngfactoryFilePath(file.fileName, true));\n\n        if (this._options.enableSummariesForJit) {\n          genFileNames.push(util_2.summaryForJitFileName(file.fileName, true));\n        }\n      }\n\n      var fileSuffix = util_2.normalizeGenFileSuffix(util_2.splitTypescriptSuffix(file.fileName, true)[1]);\n      file.directives.forEach(function (dirSymbol) {\n        var compMeta = _this._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol).metadata;\n\n        if (!compMeta.isComponent) {\n          return;\n        } // Note: compMeta is a component and therefore template is non null.\n\n\n        compMeta.template.styleUrls.forEach(function (styleUrl) {\n          var normalizedUrl = _this._host.resourceNameToFileName(styleUrl, file.fileName);\n\n          if (!normalizedUrl) {\n            throw util_1.syntaxError(\"Couldn't resolve resource \" + styleUrl + \" relative to \" + file.fileName);\n          }\n\n          var needsShim = (compMeta.template.encapsulation || _this._config.defaultEncapsulation) === core_1.ViewEncapsulation.Emulated;\n          genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\n\n          if (_this._options.allowEmptyCodegenFiles) {\n            genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\n          }\n        });\n      });\n      return genFileNames;\n    };\n\n    AotCompiler.prototype.emitBasicStub = function (genFileName, originalFileName) {\n      var outputCtx = this._createOutputContext(genFileName);\n\n      if (genFileName.endsWith('.ngfactory.ts')) {\n        if (!originalFileName) {\n          throw new Error(\"Assertion error: require the original file for .ngfactory.ts stubs. File: \" + genFileName);\n        }\n\n        var originalFile = this._analyzeFile(originalFileName);\n\n        this._createNgFactoryStub(outputCtx, originalFile, 1\n        /* Basic */\n        );\n      } else if (genFileName.endsWith('.ngsummary.ts')) {\n        if (this._options.enableSummariesForJit) {\n          if (!originalFileName) {\n            throw new Error(\"Assertion error: require the original file for .ngsummary.ts stubs. File: \" + genFileName);\n          }\n\n          var originalFile = this._analyzeFile(originalFileName);\n\n          _createEmptyStub(outputCtx);\n\n          originalFile.ngModules.forEach(function (ngModule) {\n            // create exports that user code can reference\n            summary_serializer_1.createForJitStub(outputCtx, ngModule.type.reference);\n          });\n        }\n      } else if (genFileName.endsWith('.ngstyle.ts')) {\n        _createEmptyStub(outputCtx);\n      } // Note: for the stubs, we don't need a property srcFileUrl,\n      // as later on in emitAllImpls we will create the proper GeneratedFiles with the\n      // correct srcFileUrl.\n      // This is good as e.g. for .ngstyle.ts files we can't derive\n      // the url of components based on the genFileUrl.\n\n\n      return this._codegenSourceModule('unknown', outputCtx);\n    };\n\n    AotCompiler.prototype.emitTypeCheckStub = function (genFileName, originalFileName) {\n      var originalFile = this._analyzeFile(originalFileName);\n\n      var outputCtx = this._createOutputContext(genFileName);\n\n      if (genFileName.endsWith('.ngfactory.ts')) {\n        this._createNgFactoryStub(outputCtx, originalFile, 2\n        /* TypeCheck */\n        );\n      }\n\n      return outputCtx.statements.length > 0 ? this._codegenSourceModule(originalFile.fileName, outputCtx) : null;\n    };\n\n    AotCompiler.prototype.loadFilesAsync = function (fileNames, tsFiles) {\n      var _this = this;\n\n      var files = fileNames.map(function (fileName) {\n        return _this._analyzeFile(fileName);\n      });\n      var loadingPromises = [];\n      files.forEach(function (file) {\n        return file.ngModules.forEach(function (ngModule) {\n          return loadingPromises.push(_this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false));\n        });\n      });\n      var analyzedInjectables = tsFiles.map(function (tsFile) {\n        return _this._analyzeFileForInjectables(tsFile);\n      });\n      return Promise.all(loadingPromises).then(function (_) {\n        return {\n          analyzedModules: mergeAndValidateNgFiles(files),\n          analyzedInjectables: analyzedInjectables\n        };\n      });\n    };\n\n    AotCompiler.prototype.loadFilesSync = function (fileNames, tsFiles) {\n      var _this = this;\n\n      var files = fileNames.map(function (fileName) {\n        return _this._analyzeFile(fileName);\n      });\n      files.forEach(function (file) {\n        return file.ngModules.forEach(function (ngModule) {\n          return _this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true);\n        });\n      });\n      var analyzedInjectables = tsFiles.map(function (tsFile) {\n        return _this._analyzeFileForInjectables(tsFile);\n      });\n      return {\n        analyzedModules: mergeAndValidateNgFiles(files),\n        analyzedInjectables: analyzedInjectables\n      };\n    };\n\n    AotCompiler.prototype._createNgFactoryStub = function (outputCtx, file, emitFlags) {\n      var _this = this;\n\n      var componentId = 0;\n      file.ngModules.forEach(function (ngModuleMeta, ngModuleIndex) {\n        // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\n        // so we don't change the .ngfactory file too much when adding the type-check block.\n        // create exports that user code can reference\n        _this._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference); // add references to the symbols from the metadata.\n        // These can be used by the type check block for components,\n        // and they also cause TypeScript to include these files into the program too,\n        // which will make them part of the analyzedFiles.\n\n\n        var externalReferences = tslib_1.__spread(ngModuleMeta.transitiveModule.directives.map(function (d) {\n          return d.reference;\n        }), ngModuleMeta.transitiveModule.pipes.map(function (d) {\n          return d.reference;\n        }), ngModuleMeta.importedModules.map(function (m) {\n          return m.type.reference;\n        }), ngModuleMeta.exportedModules.map(function (m) {\n          return m.type.reference;\n        }), _this._externalIdentifierReferences([identifiers_1.Identifiers.TemplateRef, identifiers_1.Identifiers.ElementRef]));\n\n        var externalReferenceVars = new Map();\n        externalReferences.forEach(function (ref, typeIndex) {\n          externalReferenceVars.set(ref, \"_decl\" + ngModuleIndex + \"_\" + typeIndex);\n        });\n        externalReferenceVars.forEach(function (varName, reference) {\n          outputCtx.statements.push(o.variable(varName).set(o.NULL_EXPR.cast(o.DYNAMIC_TYPE)).toDeclStmt(o.expressionType(outputCtx.importExpr(reference,\n          /* typeParams */\n          null,\n          /* useSummaries */\n          false))));\n        });\n\n        if (emitFlags & 2\n        /* TypeCheck */\n        ) {\n            // add the type-check block for all components of the NgModule\n            ngModuleMeta.declaredDirectives.forEach(function (dirId) {\n              var compMeta = _this._metadataResolver.getDirectiveMetadata(dirId.reference);\n\n              if (!compMeta.isComponent) {\n                return;\n              }\n\n              componentId++;\n\n              _this._createTypeCheckBlock(outputCtx, compMeta.type.reference.name + \"_Host_\" + componentId, ngModuleMeta, _this._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type], externalReferenceVars);\n\n              _this._createTypeCheckBlock(outputCtx, compMeta.type.reference.name + \"_\" + componentId, ngModuleMeta, compMeta, ngModuleMeta.transitiveModule.directives, externalReferenceVars);\n            });\n          }\n      });\n\n      if (outputCtx.statements.length === 0) {\n        _createEmptyStub(outputCtx);\n      }\n    };\n\n    AotCompiler.prototype._externalIdentifierReferences = function (references) {\n      var e_1, _a;\n\n      var result = [];\n\n      try {\n        for (var references_1 = tslib_1.__values(references), references_1_1 = references_1.next(); !references_1_1.done; references_1_1 = references_1.next()) {\n          var reference = references_1_1.value;\n          var token = identifiers_1.createTokenForExternalReference(this.reflector, reference);\n\n          if (token.identifier) {\n            result.push(token.identifier.reference);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (references_1_1 && !references_1_1.done && (_a = references_1.return)) _a.call(references_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return result;\n    };\n\n    AotCompiler.prototype._createTypeCheckBlock = function (ctx, componentId, moduleMeta, compMeta, directives, externalReferenceVars) {\n      var _a;\n\n      var _b = this._parseTemplate(compMeta, moduleMeta, directives),\n          parsedTemplate = _b.template,\n          usedPipes = _b.pipes;\n\n      (_a = ctx.statements).push.apply(_a, tslib_1.__spread(this._typeCheckCompiler.compileComponent(componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx)));\n    };\n\n    AotCompiler.prototype.emitMessageBundle = function (analyzeResult, locale) {\n      var _this = this;\n\n      var errors = [];\n      var htmlParser = new html_parser_1.HtmlParser(); // TODO(vicb): implicit tags & attributes\n\n      var messageBundle = new message_bundle_1.MessageBundle(htmlParser, [], {}, locale);\n      analyzeResult.files.forEach(function (file) {\n        var compMetas = [];\n        file.directives.forEach(function (directiveType) {\n          var dirMeta = _this._metadataResolver.getDirectiveMetadata(directiveType);\n\n          if (dirMeta && dirMeta.isComponent) {\n            compMetas.push(dirMeta);\n          }\n        });\n        compMetas.forEach(function (compMeta) {\n          var html = compMeta.template.template; // Template URL points to either an HTML or TS file depending on whether\n          // the file is used with `templateUrl:` or `template:`, respectively.\n\n          var templateUrl = compMeta.template.templateUrl;\n          var interpolationConfig = interpolation_config_1.InterpolationConfig.fromArray(compMeta.template.interpolation);\n          errors.push.apply(errors, tslib_1.__spread(messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));\n        });\n      });\n\n      if (errors.length) {\n        throw new Error(errors.map(function (e) {\n          return e.toString();\n        }).join('\\n'));\n      }\n\n      return messageBundle;\n    };\n\n    AotCompiler.prototype.emitAllPartialModules2 = function (files) {\n      var _this = this; // Using reduce like this is a select many pattern (where map is a select pattern)\n\n\n      return files.reduce(function (r, file) {\n        r.push.apply(r, tslib_1.__spread(_this._emitPartialModule2(file.fileName, file.injectables)));\n        return r;\n      }, []);\n    };\n\n    AotCompiler.prototype._emitPartialModule2 = function (fileName, injectables) {\n      var _this = this;\n\n      var context = this._createOutputContext(fileName);\n\n      injectables.forEach(function (injectable) {\n        return _this._injectableCompiler.compile(injectable, context);\n      });\n\n      if (context.statements && context.statements.length > 0) {\n        return [{\n          fileName: fileName,\n          statements: tslib_1.__spread(context.constantPool.statements, context.statements)\n        }];\n      }\n\n      return [];\n    };\n\n    AotCompiler.prototype.emitAllImpls = function (analyzeResult) {\n      var _this = this;\n\n      var ngModuleByPipeOrDirective = analyzeResult.ngModuleByPipeOrDirective,\n          files = analyzeResult.files;\n      var sourceModules = files.map(function (file) {\n        return _this._compileImplFile(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables);\n      });\n      return compile_metadata_1.flatten(sourceModules);\n    };\n\n    AotCompiler.prototype._compileImplFile = function (srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n      var _this = this;\n\n      var fileSuffix = util_2.normalizeGenFileSuffix(util_2.splitTypescriptSuffix(srcFileUrl, true)[1]);\n      var generatedFiles = [];\n\n      var outputCtx = this._createOutputContext(util_2.ngfactoryFilePath(srcFileUrl, true));\n\n      generatedFiles.push.apply(generatedFiles, tslib_1.__spread(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx))); // compile all ng modules\n\n      ngModules.forEach(function (ngModuleMeta) {\n        return _this._compileModule(outputCtx, ngModuleMeta);\n      }); // compile components\n\n      directives.forEach(function (dirType) {\n        var compMeta = _this._metadataResolver.getDirectiveMetadata(dirType);\n\n        if (!compMeta.isComponent) {\n          return;\n        }\n\n        var ngModule = ngModuleByPipeOrDirective.get(dirType);\n\n        if (!ngModule) {\n          throw new Error(\"Internal Error: cannot determine the module for component \" + compile_metadata_1.identifierName(compMeta.type) + \"!\");\n        } // compile styles\n\n\n        var componentStylesheet = _this._styleCompiler.compileComponent(outputCtx, compMeta); // Note: compMeta is a component and therefore template is non null.\n\n\n        compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {\n          // Note: fill non shim and shim style files as they might\n          // be shared by component with and without ViewEncapsulation.\n          var shim = _this._styleCompiler.needsStyleShim(compMeta);\n\n          generatedFiles.push(_this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\n\n          if (_this._options.allowEmptyCodegenFiles) {\n            generatedFiles.push(_this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\n          }\n        }); // compile components\n\n        var compViewVars = _this._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);\n\n        _this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n      });\n\n      if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\n        var srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n\n        generatedFiles.unshift(srcModule);\n      }\n\n      return generatedFiles;\n    };\n\n    AotCompiler.prototype._createSummary = function (srcFileName, directives, pipes, ngModules, injectables, ngFactoryCtx) {\n      var _this = this;\n\n      var symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName).map(function (symbol) {\n        return _this._symbolResolver.resolveSymbol(symbol);\n      });\n\n      var typeData = tslib_1.__spread(ngModules.map(function (meta) {\n        return {\n          summary: _this._metadataResolver.getNgModuleSummary(meta.type.reference),\n          metadata: _this._metadataResolver.getNgModuleMetadata(meta.type.reference)\n        };\n      }), directives.map(function (ref) {\n        return {\n          summary: _this._metadataResolver.getDirectiveSummary(ref),\n          metadata: _this._metadataResolver.getDirectiveMetadata(ref)\n        };\n      }), pipes.map(function (ref) {\n        return {\n          summary: _this._metadataResolver.getPipeSummary(ref),\n          metadata: _this._metadataResolver.getPipeMetadata(ref)\n        };\n      }), injectables.map(function (ref) {\n        return {\n          summary: _this._metadataResolver.getInjectableSummary(ref.symbol),\n          metadata: _this._metadataResolver.getInjectableSummary(ref.symbol).type\n        };\n      }));\n\n      var forJitOutputCtx = this._options.enableSummariesForJit ? this._createOutputContext(util_2.summaryForJitFileName(srcFileName, true)) : null;\n\n      var _a = summary_serializer_1.serializeSummaries(srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData, this._options.createExternalSymbolFactoryReexports),\n          json = _a.json,\n          exportAs = _a.exportAs;\n\n      exportAs.forEach(function (entry) {\n        ngFactoryCtx.statements.push(o.variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [o.StmtModifier.Exported]));\n      });\n      var summaryJson = new generated_file_1.GeneratedFile(srcFileName, util_2.summaryFileName(srcFileName), json);\n      var result = [summaryJson];\n\n      if (forJitOutputCtx) {\n        result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\n      }\n\n      return result;\n    };\n\n    AotCompiler.prototype._compileModule = function (outputCtx, ngModule) {\n      var providers = [];\n\n      if (this._options.locale) {\n        var normalizedLocale = this._options.locale.replace(/_/g, '-');\n\n        providers.push({\n          token: identifiers_1.createTokenForExternalReference(this.reflector, identifiers_1.Identifiers.LOCALE_ID),\n          useValue: normalizedLocale\n        });\n      }\n\n      if (this._options.i18nFormat) {\n        providers.push({\n          token: identifiers_1.createTokenForExternalReference(this.reflector, identifiers_1.Identifiers.TRANSLATIONS_FORMAT),\n          useValue: this._options.i18nFormat\n        });\n      }\n\n      this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n    };\n\n    AotCompiler.prototype._compileComponentFactory = function (outputCtx, compMeta, ngModule, fileSuffix) {\n      var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\n\n      var hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix).viewClassVar;\n\n      var compFactoryVar = compile_metadata_1.componentFactoryName(compMeta.type.reference);\n      var inputsExprs = [];\n\n      for (var propName in compMeta.inputs) {\n        var templateName = compMeta.inputs[propName]; // Don't quote so that the key gets minified...\n\n        inputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n      }\n\n      var outputsExprs = [];\n\n      for (var propName in compMeta.outputs) {\n        var templateName = compMeta.outputs[propName]; // Don't quote so that the key gets minified...\n\n        outputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n      }\n\n      outputCtx.statements.push(o.variable(compFactoryVar).set(o.importExpr(identifiers_1.Identifiers.createComponentFactory).callFn([o.literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference), o.variable(hostViewFactoryVar), new o.LiteralMapExpr(inputsExprs), new o.LiteralMapExpr(outputsExprs), o.literalArr(compMeta.template.ngContentSelectors.map(function (selector) {\n        return o.literal(selector);\n      }))])).toDeclStmt(o.importType(identifiers_1.Identifiers.ComponentFactory, [o.expressionType(outputCtx.importExpr(compMeta.type.reference))], [o.TypeModifier.Const]), [o.StmtModifier.Final, o.StmtModifier.Exported]));\n    };\n\n    AotCompiler.prototype._compileComponent = function (outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {\n      var _a = this._parseTemplate(compMeta, ngModule, directiveIdentifiers),\n          parsedTemplate = _a.template,\n          usedPipes = _a.pipes;\n\n      var stylesExpr = componentStyles ? o.variable(componentStyles.stylesVar) : o.literalArr([]);\n\n      var viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n\n      if (componentStyles) {\n        _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);\n      }\n\n      return viewResult;\n    };\n\n    AotCompiler.prototype._parseTemplate = function (compMeta, ngModule, directiveIdentifiers) {\n      var _this = this;\n\n      if (this._templateAstCache.has(compMeta.type.reference)) {\n        return this._templateAstCache.get(compMeta.type.reference);\n      }\n\n      var preserveWhitespaces = compMeta.template.preserveWhitespaces;\n      var directives = directiveIdentifiers.map(function (dir) {\n        return _this._metadataResolver.getDirectiveSummary(dir.reference);\n      });\n      var pipes = ngModule.transitiveModule.pipes.map(function (pipe) {\n        return _this._metadataResolver.getPipeSummary(pipe.reference);\n      });\n\n      var result = this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, compile_metadata_1.templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\n\n      this._templateAstCache.set(compMeta.type.reference, result);\n\n      return result;\n    };\n\n    AotCompiler.prototype._createOutputContext = function (genFilePath) {\n      var _this = this;\n\n      var importExpr = function importExpr(symbol, typeParams, useSummaries) {\n        if (typeParams === void 0) {\n          typeParams = null;\n        }\n\n        if (useSummaries === void 0) {\n          useSummaries = true;\n        }\n\n        if (!(symbol instanceof static_symbol_1.StaticSymbol)) {\n          throw new Error(\"Internal error: unknown identifier \" + JSON.stringify(symbol));\n        }\n\n        var arity = _this._symbolResolver.getTypeArity(symbol) || 0;\n\n        var _a = _this._symbolResolver.getImportAs(symbol, useSummaries) || symbol,\n            filePath = _a.filePath,\n            name = _a.name,\n            members = _a.members;\n\n        var importModule = _this._fileNameToModuleName(filePath, genFilePath); // It should be good enough to compare filePath to genFilePath and if they are equal\n        // there is a self reference. However, ngfactory files generate to .ts but their\n        // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n        // and is tracked by #17705.\n\n\n        var selfReference = _this._fileNameToModuleName(genFilePath, genFilePath);\n\n        var moduleName = importModule === selfReference ? null : importModule; // If we are in a type expression that refers to a generic type then supply\n        // the required type parameters. If there were not enough type parameters\n        // supplied, supply any as the type. Outside a type expression the reference\n        // should not supply type parameters and be treated as a simple value reference\n        // to the constructor function itself.\n\n        var suppliedTypeParams = typeParams || [];\n        var missingTypeParamsCount = arity - suppliedTypeParams.length;\n        var allTypeParams = suppliedTypeParams.concat(util_1.newArray(missingTypeParamsCount, o.DYNAMIC_TYPE));\n        return members.reduce(function (expr, memberName) {\n          return expr.prop(memberName);\n        }, o.importExpr(new o.ExternalReference(moduleName, name, null), allTypeParams));\n      };\n\n      return {\n        statements: [],\n        genFilePath: genFilePath,\n        importExpr: importExpr,\n        constantPool: new constant_pool_1.ConstantPool()\n      };\n    };\n\n    AotCompiler.prototype._fileNameToModuleName = function (importedFilePath, containingFilePath) {\n      return this._summaryResolver.getKnownModuleName(importedFilePath) || this._symbolResolver.getKnownModuleName(importedFilePath) || this._host.fileNameToModuleName(importedFilePath, containingFilePath);\n    };\n\n    AotCompiler.prototype._codegenStyles = function (srcFileUrl, compMeta, stylesheetMetadata, isShimmed, fileSuffix) {\n      var outputCtx = this._createOutputContext(_stylesModuleUrl(stylesheetMetadata.moduleUrl, isShimmed, fileSuffix));\n\n      var compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\n\n      _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\n\n      return this._codegenSourceModule(srcFileUrl, outputCtx);\n    };\n\n    AotCompiler.prototype._codegenSourceModule = function (srcFileUrl, ctx) {\n      return new generated_file_1.GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n    };\n\n    AotCompiler.prototype.listLazyRoutes = function (entryRoute, analyzedModules) {\n      var e_2, _a, e_3, _b;\n\n      var self = this;\n\n      if (entryRoute) {\n        var symbol = lazy_routes_1.parseLazyRoute(entryRoute, this.reflector).referencedModule;\n        return visitLazyRoute(symbol);\n      } else if (analyzedModules) {\n        var allLazyRoutes = [];\n\n        try {\n          for (var _c = tslib_1.__values(analyzedModules.ngModules), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var ngModule = _d.value;\n            var lazyRoutes = lazy_routes_1.listLazyRoutes(ngModule, this.reflector);\n\n            try {\n              for (var lazyRoutes_1 = (e_3 = void 0, tslib_1.__values(lazyRoutes)), lazyRoutes_1_1 = lazyRoutes_1.next(); !lazyRoutes_1_1.done; lazyRoutes_1_1 = lazyRoutes_1.next()) {\n                var lazyRoute = lazyRoutes_1_1.value;\n                allLazyRoutes.push(lazyRoute);\n              }\n            } catch (e_3_1) {\n              e_3 = {\n                error: e_3_1\n              };\n            } finally {\n              try {\n                if (lazyRoutes_1_1 && !lazyRoutes_1_1.done && (_b = lazyRoutes_1.return)) _b.call(lazyRoutes_1);\n              } finally {\n                if (e_3) throw e_3.error;\n              }\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        return allLazyRoutes;\n      } else {\n        throw new Error(\"Either route or analyzedModules has to be specified!\");\n      }\n\n      function visitLazyRoute(symbol, seenRoutes, allLazyRoutes) {\n        var e_4, _a;\n\n        if (seenRoutes === void 0) {\n          seenRoutes = new Set();\n        }\n\n        if (allLazyRoutes === void 0) {\n          allLazyRoutes = [];\n        } // Support pointing to default exports, but stop recursing there,\n        // as the StaticReflector does not yet support default exports.\n\n\n        if (seenRoutes.has(symbol) || !symbol.name) {\n          return allLazyRoutes;\n        }\n\n        seenRoutes.add(symbol);\n        var lazyRoutes = lazy_routes_1.listLazyRoutes(self._metadataResolver.getNgModuleMetadata(symbol, true), self.reflector);\n\n        try {\n          for (var lazyRoutes_2 = tslib_1.__values(lazyRoutes), lazyRoutes_2_1 = lazyRoutes_2.next(); !lazyRoutes_2_1.done; lazyRoutes_2_1 = lazyRoutes_2.next()) {\n            var lazyRoute = lazyRoutes_2_1.value;\n            allLazyRoutes.push(lazyRoute);\n            visitLazyRoute(lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (lazyRoutes_2_1 && !lazyRoutes_2_1.done && (_a = lazyRoutes_2.return)) _a.call(lazyRoutes_2);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n\n        return allLazyRoutes;\n      }\n    };\n\n    return AotCompiler;\n  }();\n\n  exports.AotCompiler = AotCompiler;\n\n  function _createEmptyStub(outputCtx) {\n    // Note: We need to produce at least one import statement so that\n    // TypeScript knows that the file is an es6 module. Otherwise our generated\n    // exports / imports won't be emitted properly by TypeScript.\n    outputCtx.statements.push(o.importExpr(identifiers_1.Identifiers.ComponentFactory).toStmt());\n  }\n\n  function _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {\n    compileResult.dependencies.forEach(function (dep) {\n      dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n    });\n  }\n\n  function _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n    return \"\" + stylesheetUrl + (shim ? '.shim' : '') + \".ngstyle\" + suffix;\n  }\n\n  function analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n    var files = _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver);\n\n    return mergeAnalyzedFiles(files);\n  }\n\n  exports.analyzeNgModules = analyzeNgModules;\n\n  function analyzeAndValidateNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n    return validateAnalyzedModules(analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\n  }\n\n  exports.analyzeAndValidateNgModules = analyzeAndValidateNgModules;\n\n  function validateAnalyzedModules(analyzedModules) {\n    if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\n      var messages = analyzedModules.symbolsMissingModule.map(function (s) {\n        return \"Cannot determine the module for class \" + s.name + \" in \" + s.filePath + \"! Add \" + s.name + \" to the NgModule to fix it.\";\n      });\n      throw util_1.syntaxError(messages.join('\\n'));\n    }\n\n    return analyzedModules;\n  } // Analyzes all of the program files,\n  // including files that are not part of the program\n  // but are referenced by an NgModule.\n\n\n  function _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver) {\n    var seenFiles = new Set();\n    var files = [];\n\n    var visitFile = function visitFile(fileName) {\n      if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\n        return false;\n      }\n\n      seenFiles.add(fileName);\n      var analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\n      files.push(analyzedFile);\n      analyzedFile.ngModules.forEach(function (ngModule) {\n        ngModule.transitiveModule.modules.forEach(function (modMeta) {\n          return visitFile(modMeta.reference.filePath);\n        });\n      });\n    };\n\n    fileNames.forEach(function (fileName) {\n      return visitFile(fileName);\n    });\n    return files;\n  }\n\n  function analyzeFile(host, staticSymbolResolver, metadataResolver, fileName) {\n    var abstractDirectives = [];\n    var directives = [];\n    var pipes = [];\n    var injectables = [];\n    var ngModules = [];\n    var hasDecorators = staticSymbolResolver.hasDecorators(fileName);\n    var exportsNonSourceFiles = false;\n    var isDeclarationFile = fileName.endsWith('.d.ts'); // Don't analyze .d.ts files that have no decorators as a shortcut\n    // to speed up the analysis. This prevents us from\n    // resolving the references in these files.\n    // Note: exportsNonSourceFiles is only needed when compiling with summaries,\n    // which is not the case when .d.ts files are treated as input files.\n\n    if (!isDeclarationFile || hasDecorators) {\n      staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {\n        var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n        var symbolMeta = resolvedSymbol.metadata;\n\n        if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n          return;\n        }\n\n        var isNgSymbol = false;\n\n        if (symbolMeta.__symbolic === 'class') {\n          if (metadataResolver.isDirective(symbol)) {\n            isNgSymbol = true; // This directive either has a selector or doesn't. Selector-less directives get tracked\n            // in abstractDirectives, not directives. The compiler doesn't deal with selector-less\n            // directives at all, really, other than to persist their metadata. This is done so that\n            // apps will have an easier time migrating to Ivy, which requires the selector-less\n            // annotations to be applied.\n\n            if (!metadataResolver.isAbstractDirective(symbol)) {\n              // The directive is an ordinary directive.\n              directives.push(symbol);\n            } else {\n              // The directive has no selector and is an \"abstract\" directive, so track it\n              // accordingly.\n              abstractDirectives.push(symbol);\n            }\n          } else if (metadataResolver.isPipe(symbol)) {\n            isNgSymbol = true;\n            pipes.push(symbol);\n          } else if (metadataResolver.isNgModule(symbol)) {\n            var ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\n\n            if (ngModule) {\n              isNgSymbol = true;\n              ngModules.push(ngModule);\n            }\n          } else if (metadataResolver.isInjectable(symbol)) {\n            isNgSymbol = true;\n            var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n\n            if (injectable) {\n              injectables.push(injectable);\n            }\n          }\n        }\n\n        if (!isNgSymbol) {\n          exportsNonSourceFiles = exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\n        }\n      });\n    }\n\n    return {\n      fileName: fileName,\n      directives: directives,\n      abstractDirectives: abstractDirectives,\n      pipes: pipes,\n      ngModules: ngModules,\n      injectables: injectables,\n      exportsNonSourceFiles: exportsNonSourceFiles\n    };\n  }\n\n  exports.analyzeFile = analyzeFile;\n\n  function analyzeFileForInjectables(host, staticSymbolResolver, metadataResolver, fileName) {\n    var injectables = [];\n    var shallowModules = [];\n\n    if (staticSymbolResolver.hasDecorators(fileName)) {\n      staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {\n        var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n        var symbolMeta = resolvedSymbol.metadata;\n\n        if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n          return;\n        }\n\n        if (symbolMeta.__symbolic === 'class') {\n          if (metadataResolver.isInjectable(symbol)) {\n            var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n\n            if (injectable) {\n              injectables.push(injectable);\n            }\n          } else if (metadataResolver.isNgModule(symbol)) {\n            var module = metadataResolver.getShallowModuleMetadata(symbol);\n\n            if (module) {\n              shallowModules.push(module);\n            }\n          }\n        }\n      });\n    }\n\n    return {\n      fileName: fileName,\n      injectables: injectables,\n      shallowModules: shallowModules\n    };\n  }\n\n  exports.analyzeFileForInjectables = analyzeFileForInjectables;\n\n  function isValueExportingNonSourceFile(host, metadata) {\n    var exportsNonSourceFiles = false;\n\n    var Visitor =\n    /** @class */\n    function () {\n      function Visitor() {}\n\n      Visitor.prototype.visitArray = function (arr, context) {\n        var _this = this;\n\n        arr.forEach(function (v) {\n          return util_1.visitValue(v, _this, context);\n        });\n      };\n\n      Visitor.prototype.visitStringMap = function (map, context) {\n        var _this = this;\n\n        Object.keys(map).forEach(function (key) {\n          return util_1.visitValue(map[key], _this, context);\n        });\n      };\n\n      Visitor.prototype.visitPrimitive = function (value, context) {};\n\n      Visitor.prototype.visitOther = function (value, context) {\n        if (value instanceof static_symbol_1.StaticSymbol && !host.isSourceFile(value.filePath)) {\n          exportsNonSourceFiles = true;\n        }\n      };\n\n      return Visitor;\n    }();\n\n    util_1.visitValue(metadata, new Visitor(), null);\n    return exportsNonSourceFiles;\n  }\n\n  function mergeAnalyzedFiles(analyzedFiles) {\n    var allNgModules = [];\n    var ngModuleByPipeOrDirective = new Map();\n    var allPipesAndDirectives = new Set();\n    analyzedFiles.forEach(function (af) {\n      af.ngModules.forEach(function (ngModule) {\n        allNgModules.push(ngModule);\n        ngModule.declaredDirectives.forEach(function (d) {\n          return ngModuleByPipeOrDirective.set(d.reference, ngModule);\n        });\n        ngModule.declaredPipes.forEach(function (p) {\n          return ngModuleByPipeOrDirective.set(p.reference, ngModule);\n        });\n      });\n      af.directives.forEach(function (d) {\n        return allPipesAndDirectives.add(d);\n      });\n      af.pipes.forEach(function (p) {\n        return allPipesAndDirectives.add(p);\n      });\n    });\n    var symbolsMissingModule = [];\n    allPipesAndDirectives.forEach(function (ref) {\n      if (!ngModuleByPipeOrDirective.has(ref)) {\n        symbolsMissingModule.push(ref);\n      }\n    });\n    return {\n      ngModules: allNgModules,\n      ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n      symbolsMissingModule: symbolsMissingModule,\n      files: analyzedFiles\n    };\n  }\n\n  exports.mergeAnalyzedFiles = mergeAnalyzedFiles;\n\n  function mergeAndValidateNgFiles(files) {\n    return validateAnalyzedModules(mergeAnalyzedFiles(files));\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/compiler.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, CompileIdentifierMetadata, CompileInjectableMetadata, CompileNgModuleMetadata, CompilePipeMetadata, CompilePipeSummary, CompileProviderMetadata, CompileShallowModuleMetadata, CompileStylesheetMetadata, CompileTypeMetadata, CompileTypeSummary, componentFactoryName, flatten, identifierName, templateSourceUrl} from '../compile_metadata';\nimport {CompilerConfig} from '../config';\nimport {ConstantPool} from '../constant_pool';\nimport {ViewEncapsulation} from '../core';\nimport {MessageBundle} from '../i18n/message_bundle';\nimport {createTokenForExternalReference, Identifiers} from '../identifiers';\nimport {InjectableCompiler} from '../injectable_compiler';\nimport {CompileMetadataResolver} from '../metadata_resolver';\nimport {HtmlParser} from '../ml_parser/html_parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {NgModuleCompiler} from '../ng_module_compiler';\nimport {OutputEmitter} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\nimport {ParseError} from '../parse_util';\nimport {CompiledStylesheet, StyleCompiler} from '../style_compiler';\nimport {SummaryResolver} from '../summary_resolver';\nimport {TemplateAst} from '../template_parser/template_ast';\nimport {TemplateParser} from '../template_parser/template_parser';\nimport {newArray, OutputContext, syntaxError, ValueVisitor, visitValue} from '../util';\nimport {TypeCheckCompiler} from '../view_compiler/type_check_compiler';\nimport {ViewCompiler, ViewCompileResult} from '../view_compiler/view_compiler';\n\nimport {AotCompilerHost} from './compiler_host';\nimport {AotCompilerOptions} from './compiler_options';\nimport {GeneratedFile} from './generated_file';\nimport {LazyRoute, listLazyRoutes, parseLazyRoute} from './lazy_routes';\nimport {PartialModule} from './partial_module';\nimport {StaticReflector} from './static_reflector';\nimport {StaticSymbol} from './static_symbol';\nimport {StaticSymbolResolver} from './static_symbol_resolver';\nimport {createForJitStub, serializeSummaries} from './summary_serializer';\nimport {ngfactoryFilePath, normalizeGenFileSuffix, splitTypescriptSuffix, summaryFileName, summaryForJitFileName} from './util';\n\nconst enum StubEmitFlags {\n  Basic = 1 << 0,\n  TypeCheck = 1 << 1,\n  All = TypeCheck | Basic\n}\n\nexport class AotCompiler {\n  private _templateAstCache =\n      new Map<StaticSymbol, {template: TemplateAst[], pipes: CompilePipeSummary[]}>();\n  private _analyzedFiles = new Map<string, NgAnalyzedFile>();\n  private _analyzedFilesForInjectables = new Map<string, NgAnalyzedFileWithInjectables>();\n\n  constructor(\n      private _config: CompilerConfig, private _options: AotCompilerOptions,\n      private _host: AotCompilerHost, readonly reflector: StaticReflector,\n      private _metadataResolver: CompileMetadataResolver, private _templateParser: TemplateParser,\n      private _styleCompiler: StyleCompiler, private _viewCompiler: ViewCompiler,\n      private _typeCheckCompiler: TypeCheckCompiler, private _ngModuleCompiler: NgModuleCompiler,\n      private _injectableCompiler: InjectableCompiler, private _outputEmitter: OutputEmitter,\n      private _summaryResolver: SummaryResolver<StaticSymbol>,\n      private _symbolResolver: StaticSymbolResolver) {}\n\n  clearCache() {\n    this._metadataResolver.clearCache();\n  }\n\n  analyzeModulesSync(rootFiles: string[]): NgAnalyzedModules {\n    const analyzeResult = analyzeAndValidateNgModules(\n        rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n    analyzeResult.ngModules.forEach(\n        ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n            ngModule.type.reference, true));\n    return analyzeResult;\n  }\n\n  analyzeModulesAsync(rootFiles: string[]): Promise<NgAnalyzedModules> {\n    const analyzeResult = analyzeAndValidateNgModules(\n        rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n    return Promise\n        .all(analyzeResult.ngModules.map(\n            ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n                ngModule.type.reference, false)))\n        .then(() => analyzeResult);\n  }\n\n  private _analyzeFile(fileName: string): NgAnalyzedFile {\n    let analyzedFile = this._analyzedFiles.get(fileName);\n    if (!analyzedFile) {\n      analyzedFile =\n          analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\n      this._analyzedFiles.set(fileName, analyzedFile);\n    }\n    return analyzedFile;\n  }\n\n  private _analyzeFileForInjectables(fileName: string): NgAnalyzedFileWithInjectables {\n    let analyzedFile = this._analyzedFilesForInjectables.get(fileName);\n    if (!analyzedFile) {\n      analyzedFile = analyzeFileForInjectables(\n          this._host, this._symbolResolver, this._metadataResolver, fileName);\n      this._analyzedFilesForInjectables.set(fileName, analyzedFile);\n    }\n    return analyzedFile;\n  }\n\n  findGeneratedFileNames(fileName: string): string[] {\n    const genFileNames: string[] = [];\n    const file = this._analyzeFile(fileName);\n    // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\n    // or a reference to a non source file.\n    // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\n    // Only do this for StubEmitFlags.Basic, as adding a type check block\n    // does not change this file (as we generate type check blocks based on NgModules).\n    if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length ||\n        file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\n      genFileNames.push(ngfactoryFilePath(file.fileName, true));\n      if (this._options.enableSummariesForJit) {\n        genFileNames.push(summaryForJitFileName(file.fileName, true));\n      }\n    }\n    const fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(file.fileName, true)[1]);\n    file.directives.forEach((dirSymbol) => {\n      const compMeta =\n          this._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol)!.metadata;\n      if (!compMeta.isComponent) {\n        return;\n      }\n      // Note: compMeta is a component and therefore template is non null.\n      compMeta.template !.styleUrls.forEach((styleUrl) => {\n        const normalizedUrl = this._host.resourceNameToFileName(styleUrl, file.fileName);\n        if (!normalizedUrl) {\n          throw syntaxError(`Couldn't resolve resource ${styleUrl} relative to ${file.fileName}`);\n        }\n        const needsShim = (compMeta.template !.encapsulation ||\n                           this._config.defaultEncapsulation) === ViewEncapsulation.Emulated;\n        genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\n        if (this._options.allowEmptyCodegenFiles) {\n          genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\n        }\n      });\n    });\n    return genFileNames;\n  }\n\n  emitBasicStub(genFileName: string, originalFileName?: string): GeneratedFile {\n    const outputCtx = this._createOutputContext(genFileName);\n    if (genFileName.endsWith('.ngfactory.ts')) {\n      if (!originalFileName) {\n        throw new Error(\n            `Assertion error: require the original file for .ngfactory.ts stubs. File: ${\n                genFileName}`);\n      }\n      const originalFile = this._analyzeFile(originalFileName);\n      this._createNgFactoryStub(outputCtx, originalFile, StubEmitFlags.Basic);\n    } else if (genFileName.endsWith('.ngsummary.ts')) {\n      if (this._options.enableSummariesForJit) {\n        if (!originalFileName) {\n          throw new Error(\n              `Assertion error: require the original file for .ngsummary.ts stubs. File: ${\n                  genFileName}`);\n        }\n        const originalFile = this._analyzeFile(originalFileName);\n        _createEmptyStub(outputCtx);\n        originalFile.ngModules.forEach(ngModule => {\n          // create exports that user code can reference\n          createForJitStub(outputCtx, ngModule.type.reference);\n        });\n      }\n    } else if (genFileName.endsWith('.ngstyle.ts')) {\n      _createEmptyStub(outputCtx);\n    }\n    // Note: for the stubs, we don't need a property srcFileUrl,\n    // as later on in emitAllImpls we will create the proper GeneratedFiles with the\n    // correct srcFileUrl.\n    // This is good as e.g. for .ngstyle.ts files we can't derive\n    // the url of components based on the genFileUrl.\n    return this._codegenSourceModule('unknown', outputCtx);\n  }\n\n  emitTypeCheckStub(genFileName: string, originalFileName: string): GeneratedFile|null {\n    const originalFile = this._analyzeFile(originalFileName);\n    const outputCtx = this._createOutputContext(genFileName);\n    if (genFileName.endsWith('.ngfactory.ts')) {\n      this._createNgFactoryStub(outputCtx, originalFile, StubEmitFlags.TypeCheck);\n    }\n    return outputCtx.statements.length > 0 ?\n        this._codegenSourceModule(originalFile.fileName, outputCtx) :\n        null;\n  }\n\n  loadFilesAsync(fileNames: string[], tsFiles: string[]): Promise<\n      {analyzedModules: NgAnalyzedModules, analyzedInjectables: NgAnalyzedFileWithInjectables[]}> {\n    const files = fileNames.map(fileName => this._analyzeFile(fileName));\n    const loadingPromises: Promise<NgAnalyzedModules>[] = [];\n    files.forEach(\n        file => file.ngModules.forEach(\n            ngModule =>\n                loadingPromises.push(this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n                    ngModule.type.reference, false))));\n    const analyzedInjectables = tsFiles.map(tsFile => this._analyzeFileForInjectables(tsFile));\n    return Promise.all(loadingPromises).then(_ => ({\n                                               analyzedModules: mergeAndValidateNgFiles(files),\n                                               analyzedInjectables: analyzedInjectables,\n                                             }));\n  }\n\n  loadFilesSync(fileNames: string[], tsFiles: string[]):\n      {analyzedModules: NgAnalyzedModules, analyzedInjectables: NgAnalyzedFileWithInjectables[]} {\n    const files = fileNames.map(fileName => this._analyzeFile(fileName));\n    files.forEach(\n        file => file.ngModules.forEach(\n            ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(\n                ngModule.type.reference, true)));\n    const analyzedInjectables = tsFiles.map(tsFile => this._analyzeFileForInjectables(tsFile));\n    return {\n      analyzedModules: mergeAndValidateNgFiles(files),\n      analyzedInjectables: analyzedInjectables,\n    };\n  }\n\n  private _createNgFactoryStub(\n      outputCtx: OutputContext, file: NgAnalyzedFile, emitFlags: StubEmitFlags) {\n    let componentId = 0;\n    file.ngModules.forEach((ngModuleMeta, ngModuleIndex) => {\n      // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\n      // so we don't change the .ngfactory file too much when adding the type-check block.\n\n      // create exports that user code can reference\n      this._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference);\n\n      // add references to the symbols from the metadata.\n      // These can be used by the type check block for components,\n      // and they also cause TypeScript to include these files into the program too,\n      // which will make them part of the analyzedFiles.\n      const externalReferences: StaticSymbol[] = [\n        // Add references that are available from all the modules and imports.\n        ...ngModuleMeta.transitiveModule.directives.map(d => d.reference),\n        ...ngModuleMeta.transitiveModule.pipes.map(d => d.reference),\n        ...ngModuleMeta.importedModules.map(m => m.type.reference),\n        ...ngModuleMeta.exportedModules.map(m => m.type.reference),\n\n        // Add references that might be inserted by the template compiler.\n        ...this._externalIdentifierReferences([Identifiers.TemplateRef, Identifiers.ElementRef]),\n      ];\n\n      const externalReferenceVars = new Map<any, string>();\n      externalReferences.forEach((ref, typeIndex) => {\n        externalReferenceVars.set(ref, `_decl${ngModuleIndex}_${typeIndex}`);\n      });\n      externalReferenceVars.forEach((varName, reference) => {\n        outputCtx.statements.push(\n            o.variable(varName)\n                .set(o.NULL_EXPR.cast(o.DYNAMIC_TYPE))\n                .toDeclStmt(o.expressionType(outputCtx.importExpr(\n                    reference, /* typeParams */ null, /* useSummaries */ false))));\n      });\n\n      if (emitFlags & StubEmitFlags.TypeCheck) {\n        // add the type-check block for all components of the NgModule\n        ngModuleMeta.declaredDirectives.forEach((dirId) => {\n          const compMeta = this._metadataResolver.getDirectiveMetadata(dirId.reference);\n          if (!compMeta.isComponent) {\n            return;\n          }\n          componentId++;\n          this._createTypeCheckBlock(\n              outputCtx, `${compMeta.type.reference.name}_Host_${componentId}`, ngModuleMeta,\n              this._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type],\n              externalReferenceVars);\n          this._createTypeCheckBlock(\n              outputCtx, `${compMeta.type.reference.name}_${componentId}`, ngModuleMeta, compMeta,\n              ngModuleMeta.transitiveModule.directives, externalReferenceVars);\n        });\n      }\n    });\n\n    if (outputCtx.statements.length === 0) {\n      _createEmptyStub(outputCtx);\n    }\n  }\n\n  private _externalIdentifierReferences(references: o.ExternalReference[]): StaticSymbol[] {\n    const result: StaticSymbol[] = [];\n    for (let reference of references) {\n      const token = createTokenForExternalReference(this.reflector, reference);\n      if (token.identifier) {\n        result.push(token.identifier.reference);\n      }\n    }\n    return result;\n  }\n\n  private _createTypeCheckBlock(\n      ctx: OutputContext, componentId: string, moduleMeta: CompileNgModuleMetadata,\n      compMeta: CompileDirectiveMetadata, directives: CompileIdentifierMetadata[],\n      externalReferenceVars: Map<any, string>) {\n    const {template: parsedTemplate, pipes: usedPipes} =\n        this._parseTemplate(compMeta, moduleMeta, directives);\n    ctx.statements.push(...this._typeCheckCompiler.compileComponent(\n        componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx));\n  }\n\n  emitMessageBundle(analyzeResult: NgAnalyzedModules, locale: string|null): MessageBundle {\n    const errors: ParseError[] = [];\n    const htmlParser = new HtmlParser();\n\n    // TODO(vicb): implicit tags & attributes\n    const messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n\n    analyzeResult.files.forEach(file => {\n      const compMetas: CompileDirectiveMetadata[] = [];\n      file.directives.forEach(directiveType => {\n        const dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);\n        if (dirMeta && dirMeta.isComponent) {\n          compMetas.push(dirMeta);\n        }\n      });\n      compMetas.forEach(compMeta => {\n        const html = compMeta.template !.template !;\n        // Template URL points to either an HTML or TS file depending on whether\n        // the file is used with `templateUrl:` or `template:`, respectively.\n        const templateUrl = compMeta.template !.templateUrl!;\n        const interpolationConfig =\n            InterpolationConfig.fromArray(compMeta.template !.interpolation);\n        errors.push(...messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)!);\n      });\n    });\n\n    if (errors.length) {\n      throw new Error(errors.map(e => e.toString()).join('\\n'));\n    }\n\n    return messageBundle;\n  }\n\n  emitAllPartialModules2(files: NgAnalyzedFileWithInjectables[]): PartialModule[] {\n    // Using reduce like this is a select many pattern (where map is a select pattern)\n    return files.reduce<PartialModule[]>((r, file) => {\n      r.push(...this._emitPartialModule2(file.fileName, file.injectables));\n      return r;\n    }, []);\n  }\n\n  private _emitPartialModule2(fileName: string, injectables: CompileInjectableMetadata[]):\n      PartialModule[] {\n    const context = this._createOutputContext(fileName);\n\n    injectables.forEach(injectable => this._injectableCompiler.compile(injectable, context));\n\n    if (context.statements && context.statements.length > 0) {\n      return [{fileName, statements: [...context.constantPool.statements, ...context.statements]}];\n    }\n    return [];\n  }\n\n  emitAllImpls(analyzeResult: NgAnalyzedModules): GeneratedFile[] {\n    const {ngModuleByPipeOrDirective, files} = analyzeResult;\n    const sourceModules = files.map(\n        file => this._compileImplFile(\n            file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules,\n            file.injectables));\n    return flatten(sourceModules);\n  }\n\n  private _compileImplFile(\n      srcFileUrl: string, ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>,\n      directives: StaticSymbol[], pipes: StaticSymbol[], ngModules: CompileNgModuleMetadata[],\n      injectables: CompileInjectableMetadata[]): GeneratedFile[] {\n    const fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(srcFileUrl, true)[1]);\n    const generatedFiles: GeneratedFile[] = [];\n\n    const outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n\n    generatedFiles.push(\n        ...this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx));\n\n    // compile all ng modules\n    ngModules.forEach((ngModuleMeta) => this._compileModule(outputCtx, ngModuleMeta));\n\n    // compile components\n    directives.forEach((dirType) => {\n      const compMeta = this._metadataResolver.getDirectiveMetadata(<any>dirType);\n      if (!compMeta.isComponent) {\n        return;\n      }\n      const ngModule = ngModuleByPipeOrDirective.get(dirType);\n      if (!ngModule) {\n        throw new Error(`Internal Error: cannot determine the module for component ${\n            identifierName(compMeta.type)}!`);\n      }\n\n      // compile styles\n      const componentStylesheet = this._styleCompiler.compileComponent(outputCtx, compMeta);\n      // Note: compMeta is a component and therefore template is non null.\n      compMeta.template !.externalStylesheets.forEach((stylesheetMeta) => {\n        // Note: fill non shim and shim style files as they might\n        // be shared by component with and without ViewEncapsulation.\n        const shim = this._styleCompiler.needsStyleShim(compMeta);\n        generatedFiles.push(\n            this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\n        if (this._options.allowEmptyCodegenFiles) {\n          generatedFiles.push(\n              this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\n        }\n      });\n\n      // compile components\n      const compViewVars = this._compileComponent(\n          outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet,\n          fileSuffix);\n      this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n    });\n    if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\n      const srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n      generatedFiles.unshift(srcModule);\n    }\n    return generatedFiles;\n  }\n\n  private _createSummary(\n      srcFileName: string, directives: StaticSymbol[], pipes: StaticSymbol[],\n      ngModules: CompileNgModuleMetadata[], injectables: CompileInjectableMetadata[],\n      ngFactoryCtx: OutputContext): GeneratedFile[] {\n    const symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName)\n                                .map(symbol => this._symbolResolver.resolveSymbol(symbol));\n    const typeData: {\n      summary: CompileTypeSummary,\n      metadata: CompileNgModuleMetadata|CompileDirectiveMetadata|CompilePipeMetadata|\n      CompileTypeMetadata\n    }[] =\n        [\n          ...ngModules.map(\n              meta => ({\n                summary: this._metadataResolver.getNgModuleSummary(meta.type.reference)!,\n                metadata: this._metadataResolver.getNgModuleMetadata(meta.type.reference)!\n              })),\n          ...directives.map(ref => ({\n                              summary: this._metadataResolver.getDirectiveSummary(ref)!,\n                              metadata: this._metadataResolver.getDirectiveMetadata(ref)!\n                            })),\n          ...pipes.map(ref => ({\n                         summary: this._metadataResolver.getPipeSummary(ref)!,\n                         metadata: this._metadataResolver.getPipeMetadata(ref)!\n                       })),\n          ...injectables.map(\n              ref => ({\n                summary: this._metadataResolver.getInjectableSummary(ref.symbol)!,\n                metadata: this._metadataResolver.getInjectableSummary(ref.symbol)!.type\n              }))\n        ];\n    const forJitOutputCtx = this._options.enableSummariesForJit ?\n        this._createOutputContext(summaryForJitFileName(srcFileName, true)) :\n        null;\n    const {json, exportAs} = serializeSummaries(\n        srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries,\n        typeData, this._options.createExternalSymbolFactoryReexports);\n    exportAs.forEach((entry) => {\n      ngFactoryCtx.statements.push(\n          o.variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [\n            o.StmtModifier.Exported\n          ]));\n    });\n    const summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);\n    const result = [summaryJson];\n    if (forJitOutputCtx) {\n      result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\n    }\n    return result;\n  }\n\n  private _compileModule(outputCtx: OutputContext, ngModule: CompileNgModuleMetadata): void {\n    const providers: CompileProviderMetadata[] = [];\n\n    if (this._options.locale) {\n      const normalizedLocale = this._options.locale.replace(/_/g, '-');\n      providers.push({\n        token: createTokenForExternalReference(this.reflector, Identifiers.LOCALE_ID),\n        useValue: normalizedLocale,\n      });\n    }\n\n    if (this._options.i18nFormat) {\n      providers.push({\n        token: createTokenForExternalReference(this.reflector, Identifiers.TRANSLATIONS_FORMAT),\n        useValue: this._options.i18nFormat\n      });\n    }\n\n    this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n  }\n\n  private _compileComponentFactory(\n      outputCtx: OutputContext, compMeta: CompileDirectiveMetadata,\n      ngModule: CompileNgModuleMetadata, fileSuffix: string): void {\n    const hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\n    const hostViewFactoryVar =\n        this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix)\n            .viewClassVar;\n    const compFactoryVar = componentFactoryName(compMeta.type.reference);\n    const inputsExprs: o.LiteralMapEntry[] = [];\n    for (let propName in compMeta.inputs) {\n      const templateName = compMeta.inputs[propName];\n      // Don't quote so that the key gets minified...\n      inputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n    }\n    const outputsExprs: o.LiteralMapEntry[] = [];\n    for (let propName in compMeta.outputs) {\n      const templateName = compMeta.outputs[propName];\n      // Don't quote so that the key gets minified...\n      outputsExprs.push(new o.LiteralMapEntry(propName, o.literal(templateName), false));\n    }\n\n    outputCtx.statements.push(\n        o.variable(compFactoryVar)\n            .set(o.importExpr(Identifiers.createComponentFactory).callFn([\n              o.literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference),\n              o.variable(hostViewFactoryVar), new o.LiteralMapExpr(inputsExprs),\n              new o.LiteralMapExpr(outputsExprs),\n              o.literalArr(\n                  compMeta.template !.ngContentSelectors.map(selector => o.literal(selector)))\n            ]))\n            .toDeclStmt(\n                o.importType(\n                    Identifiers.ComponentFactory,\n                    [o.expressionType(outputCtx.importExpr(compMeta.type.reference))!],\n                    [o.TypeModifier.Const]),\n                [o.StmtModifier.Final, o.StmtModifier.Exported]));\n  }\n\n  private _compileComponent(\n      outputCtx: OutputContext, compMeta: CompileDirectiveMetadata,\n      ngModule: CompileNgModuleMetadata, directiveIdentifiers: CompileIdentifierMetadata[],\n      componentStyles: CompiledStylesheet|null, fileSuffix: string): ViewCompileResult {\n    const {template: parsedTemplate, pipes: usedPipes} =\n        this._parseTemplate(compMeta, ngModule, directiveIdentifiers);\n    const stylesExpr = componentStyles ? o.variable(componentStyles.stylesVar) : o.literalArr([]);\n    const viewResult = this._viewCompiler.compileComponent(\n        outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n    if (componentStyles) {\n      _resolveStyleStatements(\n          this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta),\n          fileSuffix);\n    }\n    return viewResult;\n  }\n\n  private _parseTemplate(\n      compMeta: CompileDirectiveMetadata, ngModule: CompileNgModuleMetadata,\n      directiveIdentifiers: CompileIdentifierMetadata[]):\n      {template: TemplateAst[], pipes: CompilePipeSummary[]} {\n    if (this._templateAstCache.has(compMeta.type.reference)) {\n      return this._templateAstCache.get(compMeta.type.reference)!;\n    }\n    const preserveWhitespaces = compMeta!.template !.preserveWhitespaces;\n    const directives =\n        directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\n    const pipes = ngModule.transitiveModule.pipes.map(\n        pipe => this._metadataResolver.getPipeSummary(pipe.reference));\n    const result = this._templateParser.parse(\n        compMeta, compMeta.template !.htmlAst!, directives, pipes, ngModule.schemas,\n        templateSourceUrl(ngModule.type, compMeta, compMeta.template !), preserveWhitespaces);\n    this._templateAstCache.set(compMeta.type.reference, result);\n    return result;\n  }\n\n  private _createOutputContext(genFilePath: string): OutputContext {\n    const importExpr =\n        (symbol: StaticSymbol, typeParams: o.Type[]|null = null, useSummaries: boolean = true) => {\n          if (!(symbol instanceof StaticSymbol)) {\n            throw new Error(`Internal error: unknown identifier ${JSON.stringify(symbol)}`);\n          }\n          const arity = this._symbolResolver.getTypeArity(symbol) || 0;\n          const {filePath, name, members} =\n              this._symbolResolver.getImportAs(symbol, useSummaries) || symbol;\n          const importModule = this._fileNameToModuleName(filePath, genFilePath);\n\n          // It should be good enough to compare filePath to genFilePath and if they are equal\n          // there is a self reference. However, ngfactory files generate to .ts but their\n          // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n          // and is tracked by #17705.\n          const selfReference = this._fileNameToModuleName(genFilePath, genFilePath);\n          const moduleName = importModule === selfReference ? null : importModule;\n\n          // If we are in a type expression that refers to a generic type then supply\n          // the required type parameters. If there were not enough type parameters\n          // supplied, supply any as the type. Outside a type expression the reference\n          // should not supply type parameters and be treated as a simple value reference\n          // to the constructor function itself.\n          const suppliedTypeParams = typeParams || [];\n          const missingTypeParamsCount = arity - suppliedTypeParams.length;\n          const allTypeParams =\n              suppliedTypeParams.concat(newArray(missingTypeParamsCount, o.DYNAMIC_TYPE));\n          return members.reduce(\n              (expr, memberName) => expr.prop(memberName),\n              <o.Expression>o.importExpr(\n                  new o.ExternalReference(moduleName, name, null), allTypeParams));\n        };\n\n    return {statements: [], genFilePath, importExpr, constantPool: new ConstantPool()};\n  }\n\n  private _fileNameToModuleName(importedFilePath: string, containingFilePath: string): string {\n    return this._summaryResolver.getKnownModuleName(importedFilePath) ||\n        this._symbolResolver.getKnownModuleName(importedFilePath) ||\n        this._host.fileNameToModuleName(importedFilePath, containingFilePath);\n  }\n\n  private _codegenStyles(\n      srcFileUrl: string, compMeta: CompileDirectiveMetadata,\n      stylesheetMetadata: CompileStylesheetMetadata, isShimmed: boolean,\n      fileSuffix: string): GeneratedFile {\n    const outputCtx = this._createOutputContext(\n        _stylesModuleUrl(stylesheetMetadata.moduleUrl!, isShimmed, fileSuffix));\n    const compiledStylesheet =\n        this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\n    _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\n    return this._codegenSourceModule(srcFileUrl, outputCtx);\n  }\n\n  private _codegenSourceModule(srcFileUrl: string, ctx: OutputContext): GeneratedFile {\n    return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n  }\n\n  listLazyRoutes(entryRoute?: string, analyzedModules?: NgAnalyzedModules): LazyRoute[] {\n    const self = this;\n    if (entryRoute) {\n      const symbol = parseLazyRoute(entryRoute, this.reflector).referencedModule;\n      return visitLazyRoute(symbol);\n    } else if (analyzedModules) {\n      const allLazyRoutes: LazyRoute[] = [];\n      for (const ngModule of analyzedModules.ngModules) {\n        const lazyRoutes = listLazyRoutes(ngModule, this.reflector);\n        for (const lazyRoute of lazyRoutes) {\n          allLazyRoutes.push(lazyRoute);\n        }\n      }\n      return allLazyRoutes;\n    } else {\n      throw new Error(`Either route or analyzedModules has to be specified!`);\n    }\n\n    function visitLazyRoute(\n        symbol: StaticSymbol, seenRoutes = new Set<StaticSymbol>(),\n        allLazyRoutes: LazyRoute[] = []): LazyRoute[] {\n      // Support pointing to default exports, but stop recursing there,\n      // as the StaticReflector does not yet support default exports.\n      if (seenRoutes.has(symbol) || !symbol.name) {\n        return allLazyRoutes;\n      }\n      seenRoutes.add(symbol);\n      const lazyRoutes =\n          listLazyRoutes(self._metadataResolver.getNgModuleMetadata(symbol, true)!, self.reflector);\n      for (const lazyRoute of lazyRoutes) {\n        allLazyRoutes.push(lazyRoute);\n        visitLazyRoute(lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\n      }\n      return allLazyRoutes;\n    }\n  }\n}\n\nfunction _createEmptyStub(outputCtx: OutputContext) {\n  // Note: We need to produce at least one import statement so that\n  // TypeScript knows that the file is an es6 module. Otherwise our generated\n  // exports / imports won't be emitted properly by TypeScript.\n  outputCtx.statements.push(o.importExpr(Identifiers.ComponentFactory).toStmt());\n}\n\n\nfunction _resolveStyleStatements(\n    symbolResolver: StaticSymbolResolver, compileResult: CompiledStylesheet, needsShim: boolean,\n    fileSuffix: string): void {\n  compileResult.dependencies.forEach((dep) => {\n    dep.setValue(symbolResolver.getStaticSymbol(\n        _stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n  });\n}\n\nfunction _stylesModuleUrl(stylesheetUrl: string, shim: boolean, suffix: string): string {\n  return `${stylesheetUrl}${shim ? '.shim' : ''}.ngstyle${suffix}`;\n}\n\nexport interface NgAnalyzedModules {\n  ngModules: CompileNgModuleMetadata[];\n  ngModuleByPipeOrDirective: Map<StaticSymbol, CompileNgModuleMetadata>;\n  files: NgAnalyzedFile[];\n  symbolsMissingModule?: StaticSymbol[];\n}\n\nexport interface NgAnalyzedFileWithInjectables {\n  fileName: string;\n  injectables: CompileInjectableMetadata[];\n  shallowModules: CompileShallowModuleMetadata[];\n}\n\nexport interface NgAnalyzedFile {\n  fileName: string;\n  directives: StaticSymbol[];\n  abstractDirectives: StaticSymbol[];\n  pipes: StaticSymbol[];\n  ngModules: CompileNgModuleMetadata[];\n  injectables: CompileInjectableMetadata[];\n  exportsNonSourceFiles: boolean;\n}\n\nexport interface NgAnalyzeModulesHost {\n  isSourceFile(filePath: string): boolean;\n}\n\nexport function analyzeNgModules(\n    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver): NgAnalyzedModules {\n  const files = _analyzeFilesIncludingNonProgramFiles(\n      fileNames, host, staticSymbolResolver, metadataResolver);\n  return mergeAnalyzedFiles(files);\n}\n\nexport function analyzeAndValidateNgModules(\n    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver): NgAnalyzedModules {\n  return validateAnalyzedModules(\n      analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\n}\n\nfunction validateAnalyzedModules(analyzedModules: NgAnalyzedModules): NgAnalyzedModules {\n  if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\n    const messages = analyzedModules.symbolsMissingModule.map(\n        s => `Cannot determine the module for class ${s.name} in ${s.filePath}! Add ${\n            s.name} to the NgModule to fix it.`);\n    throw syntaxError(messages.join('\\n'));\n  }\n  return analyzedModules;\n}\n\n// Analyzes all of the program files,\n// including files that are not part of the program\n// but are referenced by an NgModule.\nfunction _analyzeFilesIncludingNonProgramFiles(\n    fileNames: string[], host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver): NgAnalyzedFile[] {\n  const seenFiles = new Set<string>();\n  const files: NgAnalyzedFile[] = [];\n\n  const visitFile = (fileName: string) => {\n    if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\n      return false;\n    }\n    seenFiles.add(fileName);\n    const analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\n    files.push(analyzedFile);\n    analyzedFile.ngModules.forEach(ngModule => {\n      ngModule.transitiveModule.modules.forEach(modMeta => visitFile(modMeta.reference.filePath));\n    });\n  };\n  fileNames.forEach((fileName) => visitFile(fileName));\n  return files;\n}\n\nexport function analyzeFile(\n    host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver, fileName: string): NgAnalyzedFile {\n  const abstractDirectives: StaticSymbol[] = [];\n  const directives: StaticSymbol[] = [];\n  const pipes: StaticSymbol[] = [];\n  const injectables: CompileInjectableMetadata[] = [];\n  const ngModules: CompileNgModuleMetadata[] = [];\n  const hasDecorators = staticSymbolResolver.hasDecorators(fileName);\n  let exportsNonSourceFiles = false;\n  const isDeclarationFile = fileName.endsWith('.d.ts');\n  // Don't analyze .d.ts files that have no decorators as a shortcut\n  // to speed up the analysis. This prevents us from\n  // resolving the references in these files.\n  // Note: exportsNonSourceFiles is only needed when compiling with summaries,\n  // which is not the case when .d.ts files are treated as input files.\n  if (!isDeclarationFile || hasDecorators) {\n    staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\n      const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n      const symbolMeta = resolvedSymbol.metadata;\n      if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n        return;\n      }\n      let isNgSymbol = false;\n      if (symbolMeta.__symbolic === 'class') {\n        if (metadataResolver.isDirective(symbol)) {\n          isNgSymbol = true;\n          // This directive either has a selector or doesn't. Selector-less directives get tracked\n          // in abstractDirectives, not directives. The compiler doesn't deal with selector-less\n          // directives at all, really, other than to persist their metadata. This is done so that\n          // apps will have an easier time migrating to Ivy, which requires the selector-less\n          // annotations to be applied.\n          if (!metadataResolver.isAbstractDirective(symbol)) {\n            // The directive is an ordinary directive.\n            directives.push(symbol);\n          } else {\n            // The directive has no selector and is an \"abstract\" directive, so track it\n            // accordingly.\n            abstractDirectives.push(symbol);\n          }\n        } else if (metadataResolver.isPipe(symbol)) {\n          isNgSymbol = true;\n          pipes.push(symbol);\n        } else if (metadataResolver.isNgModule(symbol)) {\n          const ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\n          if (ngModule) {\n            isNgSymbol = true;\n            ngModules.push(ngModule);\n          }\n        } else if (metadataResolver.isInjectable(symbol)) {\n          isNgSymbol = true;\n          const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n          if (injectable) {\n            injectables.push(injectable);\n          }\n        }\n      }\n      if (!isNgSymbol) {\n        exportsNonSourceFiles =\n            exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\n      }\n    });\n  }\n  return {\n    fileName,\n    directives,\n    abstractDirectives,\n    pipes,\n    ngModules,\n    injectables,\n    exportsNonSourceFiles,\n  };\n}\n\nexport function analyzeFileForInjectables(\n    host: NgAnalyzeModulesHost, staticSymbolResolver: StaticSymbolResolver,\n    metadataResolver: CompileMetadataResolver, fileName: string): NgAnalyzedFileWithInjectables {\n  const injectables: CompileInjectableMetadata[] = [];\n  const shallowModules: CompileShallowModuleMetadata[] = [];\n  if (staticSymbolResolver.hasDecorators(fileName)) {\n    staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\n      const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n      const symbolMeta = resolvedSymbol.metadata;\n      if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n        return;\n      }\n      if (symbolMeta.__symbolic === 'class') {\n        if (metadataResolver.isInjectable(symbol)) {\n          const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n          if (injectable) {\n            injectables.push(injectable);\n          }\n        } else if (metadataResolver.isNgModule(symbol)) {\n          const module = metadataResolver.getShallowModuleMetadata(symbol);\n          if (module) {\n            shallowModules.push(module);\n          }\n        }\n      }\n    });\n  }\n  return {fileName, injectables, shallowModules};\n}\n\nfunction isValueExportingNonSourceFile(host: NgAnalyzeModulesHost, metadata: any): boolean {\n  let exportsNonSourceFiles = false;\n\n  class Visitor implements ValueVisitor {\n    visitArray(arr: any[], context: any): any {\n      arr.forEach(v => visitValue(v, this, context));\n    }\n    visitStringMap(map: {[key: string]: any}, context: any): any {\n      Object.keys(map).forEach((key) => visitValue(map[key], this, context));\n    }\n    visitPrimitive(value: any, context: any): any {}\n    visitOther(value: any, context: any): any {\n      if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {\n        exportsNonSourceFiles = true;\n      }\n    }\n  }\n\n  visitValue(metadata, new Visitor(), null);\n  return exportsNonSourceFiles;\n}\n\nexport function mergeAnalyzedFiles(analyzedFiles: NgAnalyzedFile[]): NgAnalyzedModules {\n  const allNgModules: CompileNgModuleMetadata[] = [];\n  const ngModuleByPipeOrDirective = new Map<StaticSymbol, CompileNgModuleMetadata>();\n  const allPipesAndDirectives = new Set<StaticSymbol>();\n\n  analyzedFiles.forEach(af => {\n    af.ngModules.forEach(ngModule => {\n      allNgModules.push(ngModule);\n      ngModule.declaredDirectives.forEach(\n          d => ngModuleByPipeOrDirective.set(d.reference, ngModule));\n      ngModule.declaredPipes.forEach(p => ngModuleByPipeOrDirective.set(p.reference, ngModule));\n    });\n    af.directives.forEach(d => allPipesAndDirectives.add(d));\n    af.pipes.forEach(p => allPipesAndDirectives.add(p));\n  });\n\n  const symbolsMissingModule: StaticSymbol[] = [];\n  allPipesAndDirectives.forEach(ref => {\n    if (!ngModuleByPipeOrDirective.has(ref)) {\n      symbolsMissingModule.push(ref);\n    }\n  });\n  return {\n    ngModules: allNgModules,\n    ngModuleByPipeOrDirective,\n    symbolsMissingModule,\n    files: analyzedFiles\n  };\n}\n\nfunction mergeAndValidateNgFiles(files: NgAnalyzedFile[]): NgAnalyzedModules {\n  return validateAnalyzedModules(mergeAnalyzedFiles(files));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}