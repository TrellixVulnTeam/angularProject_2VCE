{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/program\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/typescript_support\", \"@angular/compiler-cli/src/ngtsc/core\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/incremental\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/shims\", \"@angular/compiler-cli/src/ngtsc/typecheck\", \"@angular/compiler-cli/src/ngtsc/typecheck/api\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NgtscProgram = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var typescript_support_1 = require(\"@angular/compiler-cli/src/typescript_support\");\n\n  var core_1 = require(\"@angular/compiler-cli/src/ngtsc/core\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var incremental_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var shims_1 = require(\"@angular/compiler-cli/src/ngtsc/shims\");\n\n  var typecheck_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/api\");\n  /**\n   * Entrypoint to the Angular Compiler (Ivy+) which sits behind the `api.Program` interface, allowing\n   * it to be a drop-in replacement for the legacy View Engine compiler to tooling such as the\n   * command-line main() function or the Angular CLI.\n   */\n\n\n  var NgtscProgram =\n  /** @class */\n  function () {\n    function NgtscProgram(rootNames, options, delegateHost, oldProgram) {\n      var e_1, _a;\n\n      var _this = this;\n\n      this.options = options;\n      var perfRecorder = perf_1.ActivePerfRecorder.zeroedToNow();\n      perfRecorder.phase(perf_1.PerfPhase.Setup); // First, check whether the current TS version is supported.\n\n      if (!options.disableTypeScriptVersionCheck) {\n        typescript_support_1.verifySupportedTypeScriptVersion();\n      }\n\n      this.closureCompilerEnabled = !!options.annotateForClosureCompiler;\n      var reuseProgram = oldProgram === null || oldProgram === void 0 ? void 0 : oldProgram.reuseTsProgram;\n      this.host = core_1.NgCompilerHost.wrap(delegateHost, rootNames, options, reuseProgram !== null && reuseProgram !== void 0 ? reuseProgram : null);\n\n      if (reuseProgram !== undefined) {\n        // Prior to reusing the old program, restore shim tagging for all its `ts.SourceFile`s.\n        // TypeScript checks the `referencedFiles` of `ts.SourceFile`s for changes when evaluating\n        // incremental reuse of data from the old program, so it's important that these match in order\n        // to get the most benefit out of reuse.\n        shims_1.retagAllTsFiles(reuseProgram);\n      }\n\n      this.tsProgram = perfRecorder.inPhase(perf_1.PerfPhase.TypeScriptProgramCreate, function () {\n        return ts.createProgram(_this.host.inputFiles, options, _this.host, reuseProgram);\n      });\n      this.reuseTsProgram = this.tsProgram;\n      perfRecorder.phase(perf_1.PerfPhase.Unaccounted);\n      perfRecorder.memory(perf_1.PerfCheckpoint.TypeScriptProgramCreate);\n      this.host.postProgramCreationCleanup(); // Shim tagging has served its purpose, and tags can now be removed from all `ts.SourceFile`s in\n      // the program.\n\n      shims_1.untagAllTsFiles(this.tsProgram);\n      var reusedProgramStrategy = new typecheck_1.ReusedProgramStrategy(this.tsProgram, this.host, this.options, this.host.shimExtensionPrefixes);\n      this.incrementalStrategy = oldProgram !== undefined ? oldProgram.incrementalStrategy.toNextBuildStrategy() : new incremental_1.TrackedIncrementalBuildStrategy();\n      var modifiedResourceFiles = new Set();\n\n      if (this.host.getModifiedResourceFiles !== undefined) {\n        var strings = this.host.getModifiedResourceFiles();\n\n        if (strings !== undefined) {\n          try {\n            for (var strings_1 = tslib_1.__values(strings), strings_1_1 = strings_1.next(); !strings_1_1.done; strings_1_1 = strings_1.next()) {\n              var fileString = strings_1_1.value;\n              modifiedResourceFiles.add(file_system_1.absoluteFrom(fileString));\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (strings_1_1 && !strings_1_1.done && (_a = strings_1.return)) _a.call(strings_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        }\n      }\n\n      var ticket;\n\n      if (oldProgram === undefined) {\n        ticket = core_1.freshCompilationTicket(this.tsProgram, options, this.incrementalStrategy, reusedProgramStrategy, perfRecorder,\n        /* enableTemplateTypeChecker */\n        false,\n        /* usePoisonedData */\n        false);\n      } else {\n        ticket = core_1.incrementalFromCompilerTicket(oldProgram.compiler, this.tsProgram, this.incrementalStrategy, reusedProgramStrategy, modifiedResourceFiles, perfRecorder);\n      } // Create the NgCompiler which will drive the rest of the compilation.\n\n\n      this.compiler = core_1.NgCompiler.fromTicket(ticket, this.host);\n    }\n\n    NgtscProgram.prototype.getTsProgram = function () {\n      return this.tsProgram;\n    };\n\n    NgtscProgram.prototype.getReuseTsProgram = function () {\n      return this.reuseTsProgram;\n    };\n\n    NgtscProgram.prototype.getTsOptionDiagnostics = function (cancellationToken) {\n      var _this = this;\n\n      return this.compiler.perfRecorder.inPhase(perf_1.PerfPhase.TypeScriptDiagnostics, function () {\n        return _this.tsProgram.getOptionsDiagnostics(cancellationToken);\n      });\n    };\n\n    NgtscProgram.prototype.getTsSyntacticDiagnostics = function (sourceFile, cancellationToken) {\n      var _this = this;\n\n      return this.compiler.perfRecorder.inPhase(perf_1.PerfPhase.TypeScriptDiagnostics, function () {\n        var e_2, _a;\n\n        var ignoredFiles = _this.compiler.ignoreForDiagnostics;\n        var res;\n\n        if (sourceFile !== undefined) {\n          if (ignoredFiles.has(sourceFile)) {\n            return [];\n          }\n\n          res = _this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n        } else {\n          var diagnostics = [];\n\n          try {\n            for (var _b = tslib_1.__values(_this.tsProgram.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var sf = _c.value;\n\n              if (!ignoredFiles.has(sf)) {\n                diagnostics.push.apply(diagnostics, tslib_1.__spread(_this.tsProgram.getSyntacticDiagnostics(sf, cancellationToken)));\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n\n          res = diagnostics;\n        }\n\n        return res;\n      });\n    };\n\n    NgtscProgram.prototype.getTsSemanticDiagnostics = function (sourceFile, cancellationToken) {\n      var _this = this;\n\n      return this.compiler.perfRecorder.inPhase(perf_1.PerfPhase.TypeScriptDiagnostics, function () {\n        var e_3, _a;\n\n        var ignoredFiles = _this.compiler.ignoreForDiagnostics;\n        var res;\n\n        if (sourceFile !== undefined) {\n          if (ignoredFiles.has(sourceFile)) {\n            return [];\n          }\n\n          res = _this.tsProgram.getSemanticDiagnostics(sourceFile, cancellationToken);\n        } else {\n          var diagnostics = [];\n\n          try {\n            for (var _b = tslib_1.__values(_this.tsProgram.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n              var sf = _c.value;\n\n              if (!ignoredFiles.has(sf)) {\n                diagnostics.push.apply(diagnostics, tslib_1.__spread(_this.tsProgram.getSemanticDiagnostics(sf, cancellationToken)));\n              }\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n\n          res = diagnostics;\n        }\n\n        return res;\n      });\n    };\n\n    NgtscProgram.prototype.getNgOptionDiagnostics = function (cancellationToken) {\n      return this.compiler.getOptionDiagnostics();\n    };\n\n    NgtscProgram.prototype.getNgStructuralDiagnostics = function (cancellationToken) {\n      return [];\n    };\n\n    NgtscProgram.prototype.getNgSemanticDiagnostics = function (fileName, cancellationToken) {\n      var sf = undefined;\n\n      if (fileName !== undefined) {\n        sf = this.tsProgram.getSourceFile(fileName);\n\n        if (sf === undefined) {\n          // There are no diagnostics for files which don't exist in the program - maybe the caller\n          // has stale data?\n          return [];\n        }\n      }\n\n      var diagnostics = sf === undefined ? this.compiler.getDiagnostics() : this.compiler.getDiagnosticsForFile(sf, api_1.OptimizeFor.WholeProgram);\n      this.reuseTsProgram = this.compiler.getNextProgram();\n      return diagnostics;\n    };\n    /**\n     * Ensure that the `NgCompiler` has properly analyzed the program, and allow for the asynchronous\n     * loading of any resources during the process.\n     *\n     * This is used by the Angular CLI to allow for spawning (async) child compilations for things\n     * like SASS files used in `styleUrls`.\n     */\n\n\n    NgtscProgram.prototype.loadNgStructureAsync = function () {\n      return this.compiler.analyzeAsync();\n    };\n\n    NgtscProgram.prototype.listLazyRoutes = function (entryRoute) {\n      return this.compiler.listLazyRoutes(entryRoute);\n    };\n\n    NgtscProgram.prototype.emit = function (opts) {\n      var _this = this;\n\n      this.compiler.perfRecorder.memory(perf_1.PerfCheckpoint.PreEmit);\n      var res = this.compiler.perfRecorder.inPhase(perf_1.PerfPhase.TypeScriptEmit, function () {\n        var e_4, _a;\n\n        var transformers = _this.compiler.prepareEmit().transformers;\n\n        var ignoreFiles = _this.compiler.ignoreForEmit;\n        var emitCallback = opts && opts.emitCallback || defaultEmitCallback;\n\n        var writeFile = function writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles) {\n          var e_5, _a;\n\n          if (sourceFiles !== undefined) {\n            try {\n              // Record successful writes for any `ts.SourceFile` (that's not a declaration file)\n              // that's an input to this write.\n              for (var sourceFiles_1 = tslib_1.__values(sourceFiles), sourceFiles_1_1 = sourceFiles_1.next(); !sourceFiles_1_1.done; sourceFiles_1_1 = sourceFiles_1.next()) {\n                var writtenSf = sourceFiles_1_1.value;\n\n                if (writtenSf.isDeclarationFile) {\n                  continue;\n                }\n\n                _this.compiler.incrementalDriver.recordSuccessfulEmit(writtenSf);\n              }\n            } catch (e_5_1) {\n              e_5 = {\n                error: e_5_1\n              };\n            } finally {\n              try {\n                if (sourceFiles_1_1 && !sourceFiles_1_1.done && (_a = sourceFiles_1.return)) _a.call(sourceFiles_1);\n              } finally {\n                if (e_5) throw e_5.error;\n              }\n            }\n          }\n\n          _this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n        };\n\n        var customTransforms = opts && opts.customTransformers;\n        var beforeTransforms = transformers.before || [];\n        var afterDeclarationsTransforms = transformers.afterDeclarations;\n\n        if (customTransforms !== undefined && customTransforms.beforeTs !== undefined) {\n          beforeTransforms.push.apply(beforeTransforms, tslib_1.__spread(customTransforms.beforeTs));\n        }\n\n        var emitResults = [];\n\n        try {\n          for (var _b = tslib_1.__values(_this.tsProgram.getSourceFiles()), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var targetSourceFile = _c.value;\n\n            if (targetSourceFile.isDeclarationFile || ignoreFiles.has(targetSourceFile)) {\n              continue;\n            }\n\n            if (_this.compiler.incrementalDriver.safeToSkipEmit(targetSourceFile)) {\n              _this.compiler.perfRecorder.eventCount(perf_1.PerfEvent.EmitSkipSourceFile);\n\n              continue;\n            }\n\n            _this.compiler.perfRecorder.eventCount(perf_1.PerfEvent.EmitSourceFile);\n\n            emitResults.push(emitCallback({\n              targetSourceFile: targetSourceFile,\n              program: _this.tsProgram,\n              host: _this.host,\n              options: _this.options,\n              emitOnlyDtsFiles: false,\n              writeFile: writeFile,\n              customTransformers: {\n                before: beforeTransforms,\n                after: customTransforms && customTransforms.afterTs,\n                afterDeclarations: afterDeclarationsTransforms\n              }\n            }));\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n\n        _this.compiler.perfRecorder.memory(perf_1.PerfCheckpoint.Emit); // Run the emit, including a custom transformer that will downlevel the Ivy decorators in\n        // code.\n\n\n        return (opts && opts.mergeEmitResultsCallback || mergeEmitResults)(emitResults);\n      }); // Record performance analysis information to disk if we've been asked to do so.\n\n      if (this.options.tracePerformance !== undefined) {\n        var perf = this.compiler.perfRecorder.finalize();\n        file_system_1.getFileSystem().writeFile(file_system_1.getFileSystem().resolve(this.options.tracePerformance), JSON.stringify(perf, null, 2));\n      }\n\n      return res;\n    };\n\n    NgtscProgram.prototype.getIndexedComponents = function () {\n      return this.compiler.getIndexedComponents();\n    };\n\n    NgtscProgram.prototype.getLibrarySummaries = function () {\n      throw new Error('Method not implemented.');\n    };\n\n    NgtscProgram.prototype.getEmittedGeneratedFiles = function () {\n      throw new Error('Method not implemented.');\n    };\n\n    NgtscProgram.prototype.getEmittedSourceFiles = function () {\n      throw new Error('Method not implemented.');\n    };\n\n    return NgtscProgram;\n  }();\n\n  exports.NgtscProgram = NgtscProgram;\n\n  var defaultEmitCallback = function defaultEmitCallback(_a) {\n    var program = _a.program,\n        targetSourceFile = _a.targetSourceFile,\n        writeFile = _a.writeFile,\n        cancellationToken = _a.cancellationToken,\n        emitOnlyDtsFiles = _a.emitOnlyDtsFiles,\n        customTransformers = _a.customTransformers;\n    return program.emit(targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\n  };\n\n  function mergeEmitResults(emitResults) {\n    var e_6, _a;\n\n    var diagnostics = [];\n    var emitSkipped = false;\n    var emittedFiles = [];\n\n    try {\n      for (var emitResults_1 = tslib_1.__values(emitResults), emitResults_1_1 = emitResults_1.next(); !emitResults_1_1.done; emitResults_1_1 = emitResults_1.next()) {\n        var er = emitResults_1_1.value;\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(er.diagnostics));\n        emitSkipped = emitSkipped || er.emitSkipped;\n        emittedFiles.push.apply(emittedFiles, tslib_1.__spread(er.emittedFiles || []));\n      }\n    } catch (e_6_1) {\n      e_6 = {\n        error: e_6_1\n      };\n    } finally {\n      try {\n        if (emitResults_1_1 && !emitResults_1_1.done && (_a = emitResults_1.return)) _a.call(emitResults_1);\n      } finally {\n        if (e_6) throw e_6.error;\n      }\n    }\n\n    return {\n      diagnostics: diagnostics,\n      emitSkipped: emitSkipped,\n      emittedFiles: emittedFiles\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/ngtsc/program.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {GeneratedFile} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport * as api from '../transformers/api';\nimport {verifySupportedTypeScriptVersion} from '../typescript_support';\n\nimport {CompilationTicket, freshCompilationTicket, incrementalFromCompilerTicket, NgCompiler, NgCompilerHost} from './core';\nimport {NgCompilerOptions} from './core/api';\nimport {absoluteFrom, AbsoluteFsPath, getFileSystem} from './file_system';\nimport {TrackedIncrementalBuildStrategy} from './incremental';\nimport {IndexedComponent} from './indexer';\nimport {ActivePerfRecorder, PerfCheckpoint as PerfCheckpoint, PerfEvent, PerfPhase} from './perf';\nimport {DeclarationNode} from './reflection';\nimport {retagAllTsFiles, untagAllTsFiles} from './shims';\nimport {ReusedProgramStrategy} from './typecheck';\nimport {OptimizeFor} from './typecheck/api';\n\n\n\n/**\n * Entrypoint to the Angular Compiler (Ivy+) which sits behind the `api.Program` interface, allowing\n * it to be a drop-in replacement for the legacy View Engine compiler to tooling such as the\n * command-line main() function or the Angular CLI.\n */\nexport class NgtscProgram implements api.Program {\n  readonly compiler: NgCompiler;\n\n  /**\n   * The primary TypeScript program, which is used for analysis and emit.\n   */\n  private tsProgram: ts.Program;\n\n  /**\n   * The TypeScript program to use for the next incremental compilation.\n   *\n   * Once a TS program is used to create another (an incremental compilation operation), it can no\n   * longer be used to do so again.\n   *\n   * Since template type-checking uses the primary program to create a type-checking program, after\n   * this happens the primary program is no longer suitable for starting a subsequent compilation,\n   * and the template type-checking program should be used instead.\n   *\n   * Thus, the program which should be used for the next incremental compilation is tracked in\n   * `reuseTsProgram`, separately from the \"primary\" program which is always used for emit.\n   */\n  private reuseTsProgram: ts.Program;\n  private closureCompilerEnabled: boolean;\n  private host: NgCompilerHost;\n  private incrementalStrategy: TrackedIncrementalBuildStrategy;\n\n  constructor(\n      rootNames: ReadonlyArray<string>, private options: NgCompilerOptions,\n      delegateHost: api.CompilerHost, oldProgram?: NgtscProgram) {\n    const perfRecorder = ActivePerfRecorder.zeroedToNow();\n\n    perfRecorder.phase(PerfPhase.Setup);\n\n    // First, check whether the current TS version is supported.\n    if (!options.disableTypeScriptVersionCheck) {\n      verifySupportedTypeScriptVersion();\n    }\n\n    this.closureCompilerEnabled = !!options.annotateForClosureCompiler;\n\n    const reuseProgram = oldProgram?.reuseTsProgram;\n    this.host = NgCompilerHost.wrap(delegateHost, rootNames, options, reuseProgram ?? null);\n\n    if (reuseProgram !== undefined) {\n      // Prior to reusing the old program, restore shim tagging for all its `ts.SourceFile`s.\n      // TypeScript checks the `referencedFiles` of `ts.SourceFile`s for changes when evaluating\n      // incremental reuse of data from the old program, so it's important that these match in order\n      // to get the most benefit out of reuse.\n      retagAllTsFiles(reuseProgram);\n    }\n\n    this.tsProgram = perfRecorder.inPhase(\n        PerfPhase.TypeScriptProgramCreate,\n        () => ts.createProgram(this.host.inputFiles, options, this.host, reuseProgram));\n    this.reuseTsProgram = this.tsProgram;\n\n    perfRecorder.phase(PerfPhase.Unaccounted);\n    perfRecorder.memory(PerfCheckpoint.TypeScriptProgramCreate);\n\n    this.host.postProgramCreationCleanup();\n\n    // Shim tagging has served its purpose, and tags can now be removed from all `ts.SourceFile`s in\n    // the program.\n    untagAllTsFiles(this.tsProgram);\n\n    const reusedProgramStrategy = new ReusedProgramStrategy(\n        this.tsProgram, this.host, this.options, this.host.shimExtensionPrefixes);\n\n    this.incrementalStrategy = oldProgram !== undefined ?\n        oldProgram.incrementalStrategy.toNextBuildStrategy() :\n        new TrackedIncrementalBuildStrategy();\n    const modifiedResourceFiles = new Set<AbsoluteFsPath>();\n    if (this.host.getModifiedResourceFiles !== undefined) {\n      const strings = this.host.getModifiedResourceFiles();\n      if (strings !== undefined) {\n        for (const fileString of strings) {\n          modifiedResourceFiles.add(absoluteFrom(fileString));\n        }\n      }\n    }\n\n    let ticket: CompilationTicket;\n    if (oldProgram === undefined) {\n      ticket = freshCompilationTicket(\n          this.tsProgram, options, this.incrementalStrategy, reusedProgramStrategy, perfRecorder,\n          /* enableTemplateTypeChecker */ false, /* usePoisonedData */ false);\n    } else {\n      ticket = incrementalFromCompilerTicket(\n          oldProgram.compiler,\n          this.tsProgram,\n          this.incrementalStrategy,\n          reusedProgramStrategy,\n          modifiedResourceFiles,\n          perfRecorder,\n      );\n    }\n\n\n    // Create the NgCompiler which will drive the rest of the compilation.\n    this.compiler = NgCompiler.fromTicket(ticket, this.host);\n  }\n\n  getTsProgram(): ts.Program {\n    return this.tsProgram;\n  }\n\n  getReuseTsProgram(): ts.Program {\n    return this.reuseTsProgram;\n  }\n\n  getTsOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n                         undefined): readonly ts.Diagnostic[] {\n    return this.compiler.perfRecorder.inPhase(\n        PerfPhase.TypeScriptDiagnostics,\n        () => this.tsProgram.getOptionsDiagnostics(cancellationToken));\n  }\n\n  getTsSyntacticDiagnostics(\n      sourceFile?: ts.SourceFile|undefined,\n      cancellationToken?: ts.CancellationToken|undefined): readonly ts.Diagnostic[] {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n      let res: readonly ts.Diagnostic[];\n      if (sourceFile !== undefined) {\n        if (ignoredFiles.has(sourceFile)) {\n          return [];\n        }\n\n        res = this.tsProgram.getSyntacticDiagnostics(sourceFile, cancellationToken);\n      } else {\n        const diagnostics: ts.Diagnostic[] = [];\n        for (const sf of this.tsProgram.getSourceFiles()) {\n          if (!ignoredFiles.has(sf)) {\n            diagnostics.push(...this.tsProgram.getSyntacticDiagnostics(sf, cancellationToken));\n          }\n        }\n        res = diagnostics;\n      }\n      return res;\n    });\n  }\n\n  getTsSemanticDiagnostics(\n      sourceFile?: ts.SourceFile|undefined,\n      cancellationToken?: ts.CancellationToken|undefined): readonly ts.Diagnostic[] {\n    return this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptDiagnostics, () => {\n      const ignoredFiles = this.compiler.ignoreForDiagnostics;\n      let res: readonly ts.Diagnostic[];\n      if (sourceFile !== undefined) {\n        if (ignoredFiles.has(sourceFile)) {\n          return [];\n        }\n\n        res = this.tsProgram.getSemanticDiagnostics(sourceFile, cancellationToken);\n      } else {\n        const diagnostics: ts.Diagnostic[] = [];\n        for (const sf of this.tsProgram.getSourceFiles()) {\n          if (!ignoredFiles.has(sf)) {\n            diagnostics.push(...this.tsProgram.getSemanticDiagnostics(sf, cancellationToken));\n          }\n        }\n        res = diagnostics;\n      }\n      return res;\n    });\n  }\n\n  getNgOptionDiagnostics(cancellationToken?: ts.CancellationToken|\n                         undefined): readonly(ts.Diagnostic|api.Diagnostic)[] {\n    return this.compiler.getOptionDiagnostics();\n  }\n\n  getNgStructuralDiagnostics(cancellationToken?: ts.CancellationToken|\n                             undefined): readonly api.Diagnostic[] {\n    return [];\n  }\n\n  getNgSemanticDiagnostics(\n      fileName?: string|undefined, cancellationToken?: ts.CancellationToken|undefined):\n      readonly(ts.Diagnostic|api.Diagnostic)[] {\n    let sf: ts.SourceFile|undefined = undefined;\n    if (fileName !== undefined) {\n      sf = this.tsProgram.getSourceFile(fileName);\n      if (sf === undefined) {\n        // There are no diagnostics for files which don't exist in the program - maybe the caller\n        // has stale data?\n        return [];\n      }\n    }\n\n    const diagnostics = sf === undefined ?\n        this.compiler.getDiagnostics() :\n        this.compiler.getDiagnosticsForFile(sf, OptimizeFor.WholeProgram);\n    this.reuseTsProgram = this.compiler.getNextProgram();\n    return diagnostics;\n  }\n\n  /**\n   * Ensure that the `NgCompiler` has properly analyzed the program, and allow for the asynchronous\n   * loading of any resources during the process.\n   *\n   * This is used by the Angular CLI to allow for spawning (async) child compilations for things\n   * like SASS files used in `styleUrls`.\n   */\n  loadNgStructureAsync(): Promise<void> {\n    return this.compiler.analyzeAsync();\n  }\n\n  listLazyRoutes(entryRoute?: string|undefined): api.LazyRoute[] {\n    return this.compiler.listLazyRoutes(entryRoute);\n  }\n\n  emit(opts?: {\n    emitFlags?: api.EmitFlags|undefined;\n    cancellationToken?: ts.CancellationToken | undefined;\n    customTransformers?: api.CustomTransformers | undefined;\n    emitCallback?: api.TsEmitCallback | undefined;\n    mergeEmitResultsCallback?: api.TsMergeEmitResultsCallback | undefined;\n  }|undefined): ts.EmitResult {\n    this.compiler.perfRecorder.memory(PerfCheckpoint.PreEmit);\n\n    const res = this.compiler.perfRecorder.inPhase(PerfPhase.TypeScriptEmit, () => {\n      const {transformers} = this.compiler.prepareEmit();\n      const ignoreFiles = this.compiler.ignoreForEmit;\n      const emitCallback = opts && opts.emitCallback || defaultEmitCallback;\n\n      const writeFile: ts.WriteFileCallback =\n          (fileName: string, data: string, writeByteOrderMark: boolean,\n           onError: ((message: string) => void)|undefined,\n           sourceFiles: ReadonlyArray<ts.SourceFile>|undefined) => {\n            if (sourceFiles !== undefined) {\n              // Record successful writes for any `ts.SourceFile` (that's not a declaration file)\n              // that's an input to this write.\n              for (const writtenSf of sourceFiles) {\n                if (writtenSf.isDeclarationFile) {\n                  continue;\n                }\n\n                this.compiler.incrementalDriver.recordSuccessfulEmit(writtenSf);\n              }\n            }\n            this.host.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n          };\n\n      const customTransforms = opts && opts.customTransformers;\n      const beforeTransforms = transformers.before || [];\n      const afterDeclarationsTransforms = transformers.afterDeclarations;\n\n      if (customTransforms !== undefined && customTransforms.beforeTs !== undefined) {\n        beforeTransforms.push(...customTransforms.beforeTs);\n      }\n\n      const emitResults: ts.EmitResult[] = [];\n\n      for (const targetSourceFile of this.tsProgram.getSourceFiles()) {\n        if (targetSourceFile.isDeclarationFile || ignoreFiles.has(targetSourceFile)) {\n          continue;\n        }\n\n        if (this.compiler.incrementalDriver.safeToSkipEmit(targetSourceFile)) {\n          this.compiler.perfRecorder.eventCount(PerfEvent.EmitSkipSourceFile);\n          continue;\n        }\n\n        this.compiler.perfRecorder.eventCount(PerfEvent.EmitSourceFile);\n\n        emitResults.push(emitCallback({\n          targetSourceFile,\n          program: this.tsProgram,\n          host: this.host,\n          options: this.options,\n          emitOnlyDtsFiles: false,\n          writeFile,\n          customTransformers: {\n            before: beforeTransforms,\n            after: customTransforms && customTransforms.afterTs,\n            afterDeclarations: afterDeclarationsTransforms,\n          } as any,\n        }));\n      }\n\n      this.compiler.perfRecorder.memory(PerfCheckpoint.Emit);\n\n      // Run the emit, including a custom transformer that will downlevel the Ivy decorators in\n      // code.\n      return ((opts && opts.mergeEmitResultsCallback) || mergeEmitResults)(emitResults);\n    });\n\n    // Record performance analysis information to disk if we've been asked to do so.\n    if (this.options.tracePerformance !== undefined) {\n      const perf = this.compiler.perfRecorder.finalize();\n      getFileSystem().writeFile(\n          getFileSystem().resolve(this.options.tracePerformance), JSON.stringify(perf, null, 2));\n    }\n    return res;\n  }\n\n  getIndexedComponents(): Map<DeclarationNode, IndexedComponent> {\n    return this.compiler.getIndexedComponents();\n  }\n\n  getLibrarySummaries(): Map<string, api.LibrarySummary> {\n    throw new Error('Method not implemented.');\n  }\n\n  getEmittedGeneratedFiles(): Map<string, GeneratedFile> {\n    throw new Error('Method not implemented.');\n  }\n\n  getEmittedSourceFiles(): Map<string, ts.SourceFile> {\n    throw new Error('Method not implemented.');\n  }\n}\n\nconst defaultEmitCallback: api.TsEmitCallback = ({\n  program,\n  targetSourceFile,\n  writeFile,\n  cancellationToken,\n  emitOnlyDtsFiles,\n  customTransformers\n}) =>\n    program.emit(\n        targetSourceFile, writeFile, cancellationToken, emitOnlyDtsFiles, customTransformers);\n\nfunction mergeEmitResults(emitResults: ts.EmitResult[]): ts.EmitResult {\n  const diagnostics: ts.Diagnostic[] = [];\n  let emitSkipped = false;\n  const emittedFiles: string[] = [];\n  for (const er of emitResults) {\n    diagnostics.push(...er.diagnostics);\n    emitSkipped = emitSkipped || er.emitSkipped;\n    emittedFiles.push(...(er.emittedFiles || []));\n  }\n\n  return {diagnostics, emitSkipped, emittedFiles};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}