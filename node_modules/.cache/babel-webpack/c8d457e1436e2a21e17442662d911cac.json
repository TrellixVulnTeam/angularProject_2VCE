{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/transformers/patch_alias_reference_resolution\", [\"require\", \"exports\", \"tslib\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isAliasImportDeclaration = exports.loadIsReferencedAliasDeclarationPatch = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var patchedReferencedAliasesSymbol = Symbol('patchedReferencedAliases');\n  /**\n   * Patches the alias declaration reference resolution for a given transformation context\n   * so that TypeScript knows about the specified alias declarations being referenced.\n   *\n   * This exists because TypeScript performs analysis of import usage before transformers\n   * run and doesn't refresh its state after transformations. This means that imports\n   * for symbols used as constructor types are elided due to their original type-only usage.\n   *\n   * In reality though, since we downlevel decorators and constructor parameters, we want\n   * these symbols to be retained in the JavaScript output as they will be used as values\n   * at runtime. We can instruct TypeScript to preserve imports for such identifiers by\n   * creating a mutable clone of a given import specifier/clause or namespace, but that\n   * has the downside of preserving the full import in the JS output. See:\n   * https://github.com/microsoft/TypeScript/blob/3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/src/compiler/transformers/ts.ts#L242-L250.\n   *\n   * This is a trick the CLI used in the past  for constructor parameter downleveling in JIT:\n   * https://github.com/angular/angular-cli/blob/b3f84cc5184337666ce61c07b7b9df418030106f/packages/ngtools/webpack/src/transformers/ctor-parameters.ts#L323-L325\n   * The trick is not ideal though as it preserves the full import (as outlined before), and it\n   * results in a slow-down due to the type checker being involved multiple times. The CLI worked\n   * around this import preserving issue by having another complex post-process step that detects and\n   * elides unused imports. Note that these unused imports could cause unused chunks being generated\n   * by Webpack if the application or library is not marked as side-effect free.\n   *\n   * This is not ideal though, as we basically re-implement the complex import usage resolution\n   * from TypeScript. We can do better by letting TypeScript do the import eliding, but providing\n   * information about the alias declarations (e.g. import specifiers) that should not be elided\n   * because they are actually referenced (as they will now appear in static properties).\n   *\n   * More information about these limitations with transformers can be found in:\n   *   1. https://github.com/Microsoft/TypeScript/issues/17552.\n   *   2. https://github.com/microsoft/TypeScript/issues/17516.\n   *   3. https://github.com/angular/tsickle/issues/635.\n   *\n   * The patch we apply to tell TypeScript about actual referenced aliases (i.e. imported symbols),\n   * matches conceptually with the logic that runs internally in TypeScript when the\n   * `emitDecoratorMetadata` flag is enabled. TypeScript basically surfaces the same problem and\n   * solves it conceptually the same way, but obviously doesn't need to access an `@internal` API.\n   *\n   * The set that is returned by this function is meant to be filled with import declaration nodes\n   * that have been referenced in a value-position by the transform, such the installed patch can\n   * ensure that those import declarations are not elided.\n   *\n   * See below. Note that this uses sourcegraph as the TypeScript checker file doesn't display on\n   * Github.\n   * https://sourcegraph.com/github.com/microsoft/TypeScript@3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/-/blob/src/compiler/checker.ts#L31219-31257\n   */\n\n  function loadIsReferencedAliasDeclarationPatch(context) {\n    // If the `getEmitResolver` method is not available, TS most likely changed the\n    // internal structure of the transformation context. We will abort gracefully.\n    if (!isTransformationContextWithEmitResolver(context)) {\n      throwIncompatibleTransformationContextError();\n    }\n\n    var emitResolver = context.getEmitResolver(); // The emit resolver may have been patched already, in which case we return the set of referenced\n    // aliases that was created when the patch was first applied.\n    // See https://github.com/angular/angular/issues/40276.\n\n    var existingReferencedAliases = emitResolver[patchedReferencedAliasesSymbol];\n\n    if (existingReferencedAliases !== undefined) {\n      return existingReferencedAliases;\n    }\n\n    var originalIsReferencedAliasDeclaration = emitResolver.isReferencedAliasDeclaration; // If the emit resolver does not have a function called `isReferencedAliasDeclaration`, then\n    // we abort gracefully as most likely TS changed the internal structure of the emit resolver.\n\n    if (originalIsReferencedAliasDeclaration === undefined) {\n      throwIncompatibleTransformationContextError();\n    }\n\n    var referencedAliases = new Set();\n\n    emitResolver.isReferencedAliasDeclaration = function (node) {\n      var args = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n      }\n\n      if (isAliasImportDeclaration(node) && referencedAliases.has(node)) {\n        return true;\n      }\n\n      return originalIsReferencedAliasDeclaration.call.apply(originalIsReferencedAliasDeclaration, tslib_1.__spread([emitResolver, node], args));\n    };\n\n    return emitResolver[patchedReferencedAliasesSymbol] = referencedAliases;\n  }\n\n  exports.loadIsReferencedAliasDeclarationPatch = loadIsReferencedAliasDeclarationPatch;\n  /**\n   * Gets whether a given node corresponds to an import alias declaration. Alias\n   * declarations can be import specifiers, namespace imports or import clauses\n   * as these do not declare an actual symbol but just point to a target declaration.\n   */\n\n  function isAliasImportDeclaration(node) {\n    return ts.isImportSpecifier(node) || ts.isNamespaceImport(node) || ts.isImportClause(node);\n  }\n\n  exports.isAliasImportDeclaration = isAliasImportDeclaration;\n  /** Whether the transformation context exposes its emit resolver. */\n\n  function isTransformationContextWithEmitResolver(context) {\n    return context.getEmitResolver !== undefined;\n  }\n  /**\n   * Throws an error about an incompatible TypeScript version for which the alias\n   * declaration reference resolution could not be monkey-patched. The error will\n   * also propose potential solutions that can be applied by developers.\n   */\n\n\n  function throwIncompatibleTransformationContextError() {\n    throw Error('Unable to downlevel Angular decorators due to an incompatible TypeScript ' + 'version.\\nIf you recently updated TypeScript and this issue surfaces now, consider ' + 'downgrading.\\n\\n' + 'Please report an issue on the Angular repositories when this issue ' + 'surfaces and you are using a supposedly compatible TypeScript version.');\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/transformers/patch_alias_reference_resolution.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAWA,MAAM,8BAA8B,GAAG,MAAM,CAAC,0BAAD,CAA7C;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CG;;AACH,WAAgB,qCAAhB,CAAsD,OAAtD,EAAuF;AAErF;AACA;AACA,QAAI,CAAC,uCAAuC,CAAC,OAAD,CAA5C,EAAuD;AACrD,MAAA,2CAA2C;AAC5C;;AACD,QAAM,YAAY,GAAG,OAAO,CAAC,eAAR,EAArB,CAPqF,CASrF;AACA;AACA;;AACA,QAAM,yBAAyB,GAAG,YAAY,CAAC,8BAAD,CAA9C;;AACA,QAAI,yBAAyB,KAAK,SAAlC,EAA6C;AAC3C,aAAO,yBAAP;AACD;;AAED,QAAM,oCAAoC,GAAG,YAAY,CAAC,4BAA1D,CAjBqF,CAkBrF;AACA;;AACA,QAAI,oCAAoC,KAAK,SAA7C,EAAwD;AACtD,MAAA,2CAA2C;AAC5C;;AAED,QAAM,iBAAiB,GAAG,IAAI,GAAJ,EAA1B;;AACA,IAAA,YAAY,CAAC,4BAAb,GAA4C,UAAS,IAAT,EAAa;AAAE,UAAA,IAAA,GAAA,EAAA;;WAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAO;AAAP,QAAA,IAAA,CAAA,EAAA,GAAA,CAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACzD,UAAI,wBAAwB,CAAC,IAAD,CAAxB,IAAkC,iBAAiB,CAAC,GAAlB,CAAsB,IAAtB,CAAtC,EAAmE;AACjE,eAAO,IAAP;AACD;;AACD,aAAO,oCAAoC,CAAC,IAArC,CAAyC,KAAzC,CAAA,oCAAA,EAAoC,OAAA,CAAA,QAAA,CAAA,CAAM,YAAN,EAAoB,IAApB,CAAA,EAA6B,IAA7B,CAApC,CAAP;AACD,KALD;;AAMA,WAAO,YAAY,CAAC,8BAAD,CAAZ,GAA+C,iBAAtD;AACD;;AAhCD,EAAA,OAAA,CAAA,qCAAA,GAAA,qCAAA;AAkCA;;;;AAIG;;AACH,WAAgB,wBAAhB,CAAyC,IAAzC,EAAsD;AAEpD,WAAO,EAAE,CAAC,iBAAH,CAAqB,IAArB,KAA8B,EAAE,CAAC,iBAAH,CAAqB,IAArB,CAA9B,IAA4D,EAAE,CAAC,cAAH,CAAkB,IAAlB,CAAnE;AACD;;AAHD,EAAA,OAAA,CAAA,wBAAA,GAAA,wBAAA;AAKA;;AACA,WAAS,uCAAT,CAAiD,OAAjD,EAAkF;AAEhF,WAAQ,OAAsD,CAAC,eAAvD,KAA2E,SAAnF;AACD;AAGD;;;;AAIG;;;AACH,WAAS,2CAAT,GAAoD;AAClD,UAAM,KAAK,CACP,8EACA,qFADA,GAEA,kBAFA,GAGA,qEAHA,GAIA,wEALO,CAAX;AAMD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\n/**\n * Describes a TypeScript transformation context with the internal emit\n * resolver exposed. There are requests upstream in TypeScript to expose\n * that as public API: https://github.com/microsoft/TypeScript/issues/17516..\n */\ninterface TransformationContextWithResolver extends ts.TransformationContext {\n  getEmitResolver: () => EmitResolver;\n}\n\nconst patchedReferencedAliasesSymbol = Symbol('patchedReferencedAliases');\n\n/** Describes a subset of the TypeScript internal emit resolver. */\ninterface EmitResolver {\n  isReferencedAliasDeclaration?(node: ts.Node, ...args: unknown[]): void;\n  [patchedReferencedAliasesSymbol]?: Set<ts.Declaration>;\n}\n\n/**\n * Patches the alias declaration reference resolution for a given transformation context\n * so that TypeScript knows about the specified alias declarations being referenced.\n *\n * This exists because TypeScript performs analysis of import usage before transformers\n * run and doesn't refresh its state after transformations. This means that imports\n * for symbols used as constructor types are elided due to their original type-only usage.\n *\n * In reality though, since we downlevel decorators and constructor parameters, we want\n * these symbols to be retained in the JavaScript output as they will be used as values\n * at runtime. We can instruct TypeScript to preserve imports for such identifiers by\n * creating a mutable clone of a given import specifier/clause or namespace, but that\n * has the downside of preserving the full import in the JS output. See:\n * https://github.com/microsoft/TypeScript/blob/3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/src/compiler/transformers/ts.ts#L242-L250.\n *\n * This is a trick the CLI used in the past  for constructor parameter downleveling in JIT:\n * https://github.com/angular/angular-cli/blob/b3f84cc5184337666ce61c07b7b9df418030106f/packages/ngtools/webpack/src/transformers/ctor-parameters.ts#L323-L325\n * The trick is not ideal though as it preserves the full import (as outlined before), and it\n * results in a slow-down due to the type checker being involved multiple times. The CLI worked\n * around this import preserving issue by having another complex post-process step that detects and\n * elides unused imports. Note that these unused imports could cause unused chunks being generated\n * by Webpack if the application or library is not marked as side-effect free.\n *\n * This is not ideal though, as we basically re-implement the complex import usage resolution\n * from TypeScript. We can do better by letting TypeScript do the import eliding, but providing\n * information about the alias declarations (e.g. import specifiers) that should not be elided\n * because they are actually referenced (as they will now appear in static properties).\n *\n * More information about these limitations with transformers can be found in:\n *   1. https://github.com/Microsoft/TypeScript/issues/17552.\n *   2. https://github.com/microsoft/TypeScript/issues/17516.\n *   3. https://github.com/angular/tsickle/issues/635.\n *\n * The patch we apply to tell TypeScript about actual referenced aliases (i.e. imported symbols),\n * matches conceptually with the logic that runs internally in TypeScript when the\n * `emitDecoratorMetadata` flag is enabled. TypeScript basically surfaces the same problem and\n * solves it conceptually the same way, but obviously doesn't need to access an `@internal` API.\n *\n * The set that is returned by this function is meant to be filled with import declaration nodes\n * that have been referenced in a value-position by the transform, such the installed patch can\n * ensure that those import declarations are not elided.\n *\n * See below. Note that this uses sourcegraph as the TypeScript checker file doesn't display on\n * Github.\n * https://sourcegraph.com/github.com/microsoft/TypeScript@3eaa7c65f6f076a08a5f7f1946fd0df7c7430259/-/blob/src/compiler/checker.ts#L31219-31257\n */\nexport function loadIsReferencedAliasDeclarationPatch(context: ts.TransformationContext):\n    Set<ts.Declaration> {\n  // If the `getEmitResolver` method is not available, TS most likely changed the\n  // internal structure of the transformation context. We will abort gracefully.\n  if (!isTransformationContextWithEmitResolver(context)) {\n    throwIncompatibleTransformationContextError();\n  }\n  const emitResolver = context.getEmitResolver();\n\n  // The emit resolver may have been patched already, in which case we return the set of referenced\n  // aliases that was created when the patch was first applied.\n  // See https://github.com/angular/angular/issues/40276.\n  const existingReferencedAliases = emitResolver[patchedReferencedAliasesSymbol];\n  if (existingReferencedAliases !== undefined) {\n    return existingReferencedAliases;\n  }\n\n  const originalIsReferencedAliasDeclaration = emitResolver.isReferencedAliasDeclaration;\n  // If the emit resolver does not have a function called `isReferencedAliasDeclaration`, then\n  // we abort gracefully as most likely TS changed the internal structure of the emit resolver.\n  if (originalIsReferencedAliasDeclaration === undefined) {\n    throwIncompatibleTransformationContextError();\n  }\n\n  const referencedAliases = new Set<ts.Declaration>();\n  emitResolver.isReferencedAliasDeclaration = function(node, ...args) {\n    if (isAliasImportDeclaration(node) && referencedAliases.has(node)) {\n      return true;\n    }\n    return originalIsReferencedAliasDeclaration.call(emitResolver, node, ...args);\n  };\n  return emitResolver[patchedReferencedAliasesSymbol] = referencedAliases;\n}\n\n/**\n * Gets whether a given node corresponds to an import alias declaration. Alias\n * declarations can be import specifiers, namespace imports or import clauses\n * as these do not declare an actual symbol but just point to a target declaration.\n */\nexport function isAliasImportDeclaration(node: ts.Node): node is ts.ImportSpecifier|\n    ts.NamespaceImport|ts.ImportClause {\n  return ts.isImportSpecifier(node) || ts.isNamespaceImport(node) || ts.isImportClause(node);\n}\n\n/** Whether the transformation context exposes its emit resolver. */\nfunction isTransformationContextWithEmitResolver(context: ts.TransformationContext):\n    context is TransformationContextWithResolver {\n  return (context as Partial<TransformationContextWithResolver>).getEmitResolver !== undefined;\n}\n\n\n/**\n * Throws an error about an incompatible TypeScript version for which the alias\n * declaration reference resolution could not be monkey-patched. The error will\n * also propose potential solutions that can be applied by developers.\n */\nfunction throwIncompatibleTransformationContextError(): never {\n  throw Error(\n      'Unable to downlevel Angular decorators due to an incompatible TypeScript ' +\n      'version.\\nIf you recently updated TypeScript and this issue surfaces now, consider ' +\n      'downgrading.\\n\\n' +\n      'Please report an issue on the Angular repositories when this issue ' +\n      'surfaces and you are using a supposedly compatible TypeScript version.');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}