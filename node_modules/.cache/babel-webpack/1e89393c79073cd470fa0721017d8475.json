{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar ConstDependency = require(\"./dependencies/ConstDependency\");\n\nvar NullFactory = require(\"./NullFactory\");\n\nvar ParserHelpers = require(\"./ParserHelpers\");\n\nvar getQuery = function getQuery(request) {\n  var i = request.indexOf(\"?\");\n  return i !== -1 ? request.substr(i) : \"\";\n};\n\nvar collectDeclaration = function collectDeclaration(declarations, pattern) {\n  var stack = [pattern];\n\n  while (stack.length > 0) {\n    var node = stack.pop();\n\n    switch (node.type) {\n      case \"Identifier\":\n        declarations.add(node.name);\n        break;\n\n      case \"ArrayPattern\":\n        var _iterator = _createForOfIteratorHelper(node.elements),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var element = _step.value;\n\n            if (element) {\n              stack.push(element);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        stack.push(node.left);\n        break;\n\n      case \"ObjectPattern\":\n        var _iterator2 = _createForOfIteratorHelper(node.properties),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var property = _step2.value;\n            stack.push(property.value);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        break;\n\n      case \"RestElement\":\n        stack.push(node.argument);\n        break;\n    }\n  }\n};\n\nvar getHoistedDeclarations = function getHoistedDeclarations(branch, includeFunctionDeclarations) {\n  var declarations = new Set();\n  var stack = [branch];\n\n  while (stack.length > 0) {\n    var node = stack.pop(); // Some node could be `null` or `undefined`.\n\n    if (!node) continue;\n\n    switch (node.type) {\n      // Walk through control statements to look for hoisted declarations.\n      // Some branches are skipped since they do not allow declarations.\n      case \"BlockStatement\":\n        var _iterator3 = _createForOfIteratorHelper(node.body),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var stmt = _step3.value;\n            stack.push(stmt);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        break;\n\n      case \"IfStatement\":\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n        break;\n\n      case \"ForStatement\":\n        stack.push(node.init);\n        stack.push(node.body);\n        break;\n\n      case \"ForInStatement\":\n      case \"ForOfStatement\":\n        stack.push(node.left);\n        stack.push(node.body);\n        break;\n\n      case \"DoWhileStatement\":\n      case \"WhileStatement\":\n      case \"LabeledStatement\":\n        stack.push(node.body);\n        break;\n\n      case \"SwitchStatement\":\n        var _iterator4 = _createForOfIteratorHelper(node.cases),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var cs = _step4.value;\n\n            var _iterator5 = _createForOfIteratorHelper(cs.consequent),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var consequent = _step5.value;\n                stack.push(consequent);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        break;\n\n      case \"TryStatement\":\n        stack.push(node.block);\n\n        if (node.handler) {\n          stack.push(node.handler.body);\n        }\n\n        stack.push(node.finalizer);\n        break;\n\n      case \"FunctionDeclaration\":\n        if (includeFunctionDeclarations) {\n          collectDeclaration(declarations, node.id);\n        }\n\n        break;\n\n      case \"VariableDeclaration\":\n        if (node.kind === \"var\") {\n          var _iterator6 = _createForOfIteratorHelper(node.declarations),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var decl = _step6.value;\n              collectDeclaration(declarations, decl.id);\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n\n        break;\n    }\n  }\n\n  return Array.from(declarations);\n};\n\nvar ConstPlugin = /*#__PURE__*/function () {\n  function ConstPlugin() {\n    _classCallCheck(this, ConstPlugin);\n  }\n\n  _createClass(ConstPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      compiler.hooks.compilation.tap(\"ConstPlugin\", function (compilation, _ref) {\n        var normalModuleFactory = _ref.normalModuleFactory;\n        compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n\n        var handler = function handler(parser) {\n          parser.hooks.statementIf.tap(\"ConstPlugin\", function (statement) {\n            if (parser.scope.isAsmJs) return;\n            var param = parser.evaluateExpression(statement.test);\n            var bool = param.asBool();\n\n            if (typeof bool === \"boolean\") {\n              if (statement.test.type !== \"Literal\") {\n                var dep = new ConstDependency(\"\".concat(bool), param.range);\n                dep.loc = statement.loc;\n                parser.state.current.addDependency(dep);\n              }\n\n              var branchToRemove = bool ? statement.alternate : statement.consequent;\n\n              if (branchToRemove) {\n                // Before removing the dead branch, the hoisted declarations\n                // must be collected.\n                //\n                // Given the following code:\n                //\n                //     if (true) f() else g()\n                //     if (false) {\n                //       function f() {}\n                //       const g = function g() {}\n                //       if (someTest) {\n                //         let a = 1\n                //         var x, {y, z} = obj\n                //       }\n                //     } else {\n                //       …\n                //     }\n                //\n                // the generated code is:\n                //\n                //     if (true) f() else {}\n                //     if (false) {\n                //       var f, x, y, z;   (in loose mode)\n                //       var x, y, z;      (in strict mode)\n                //     } else {\n                //       …\n                //     }\n                //\n                // NOTE: When code runs in strict mode, `var` declarations\n                // are hoisted but `function` declarations don't.\n                //\n                var declarations;\n\n                if (parser.scope.isStrict) {\n                  // If the code runs in strict mode, variable declarations\n                  // using `var` must be hoisted.\n                  declarations = getHoistedDeclarations(branchToRemove, false);\n                } else {\n                  // Otherwise, collect all hoisted declaration.\n                  declarations = getHoistedDeclarations(branchToRemove, true);\n                }\n\n                var replacement;\n\n                if (declarations.length > 0) {\n                  replacement = \"{ var \".concat(declarations.join(\", \"), \"; }\");\n                } else {\n                  replacement = \"{}\";\n                }\n\n                var _dep = new ConstDependency(replacement, branchToRemove.range);\n\n                _dep.loc = branchToRemove.loc;\n                parser.state.current.addDependency(_dep);\n              }\n\n              return bool;\n            }\n          });\n          parser.hooks.expressionConditionalOperator.tap(\"ConstPlugin\", function (expression) {\n            if (parser.scope.isAsmJs) return;\n            var param = parser.evaluateExpression(expression.test);\n            var bool = param.asBool();\n\n            if (typeof bool === \"boolean\") {\n              if (expression.test.type !== \"Literal\") {\n                var _dep2 = new ConstDependency(\" \".concat(bool), param.range);\n\n                _dep2.loc = expression.loc;\n                parser.state.current.addDependency(_dep2);\n              } // Expressions do not hoist.\n              // It is safe to remove the dead branch.\n              //\n              // Given the following code:\n              //\n              //   false ? someExpression() : otherExpression();\n              //\n              // the generated code is:\n              //\n              //   false ? undefined : otherExpression();\n              //\n\n\n              var branchToRemove = bool ? expression.alternate : expression.consequent;\n              var dep = new ConstDependency(\"undefined\", branchToRemove.range);\n              dep.loc = branchToRemove.loc;\n              parser.state.current.addDependency(dep);\n              return bool;\n            }\n          });\n          parser.hooks.expressionLogicalOperator.tap(\"ConstPlugin\", function (expression) {\n            if (parser.scope.isAsmJs) return;\n\n            if (expression.operator === \"&&\" || expression.operator === \"||\") {\n              var param = parser.evaluateExpression(expression.left);\n              var bool = param.asBool();\n\n              if (typeof bool === \"boolean\") {\n                // Expressions do not hoist.\n                // It is safe to remove the dead branch.\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   falsyExpression() && someExpression();\n                //\n                // the generated code is:\n                //\n                //   falsyExpression() && false;\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   truthyExpression() && someExpression();\n                //\n                // the generated code is:\n                //\n                //   true && someExpression();\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   truthyExpression() || someExpression();\n                //\n                // the generated code is:\n                //\n                //   truthyExpression() || false;\n                //\n                // ------------------------------------------\n                //\n                // Given the following code:\n                //\n                //   falsyExpression() || someExpression();\n                //\n                // the generated code is:\n                //\n                //   false && someExpression();\n                //\n                var keepRight = expression.operator === \"&&\" && bool || expression.operator === \"||\" && !bool;\n\n                if (param.isBoolean() || keepRight) {\n                  // for case like\n                  //\n                  //   return'development'===process.env.NODE_ENV&&'foo'\n                  //\n                  // we need a space before the bool to prevent result like\n                  //\n                  //   returnfalse&&'foo'\n                  //\n                  var dep = new ConstDependency(\" \".concat(bool), param.range);\n                  dep.loc = expression.loc;\n                  parser.state.current.addDependency(dep);\n                } else {\n                  parser.walkExpression(expression.left);\n                }\n\n                if (!keepRight) {\n                  var _dep3 = new ConstDependency(\"false\", expression.right.range);\n\n                  _dep3.loc = expression.loc;\n                  parser.state.current.addDependency(_dep3);\n                }\n\n                return keepRight;\n              }\n            }\n          });\n          parser.hooks.evaluateIdentifier.for(\"__resourceQuery\").tap(\"ConstPlugin\", function (expr) {\n            if (parser.scope.isAsmJs) return;\n            if (!parser.state.module) return;\n            return ParserHelpers.evaluateToString(getQuery(parser.state.module.resource))(expr);\n          });\n          parser.hooks.expression.for(\"__resourceQuery\").tap(\"ConstPlugin\", function () {\n            if (parser.scope.isAsmJs) return;\n            if (!parser.state.module) return;\n            parser.state.current.addVariable(\"__resourceQuery\", JSON.stringify(getQuery(parser.state.module.resource)));\n            return true;\n          });\n        };\n\n        normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"ConstPlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"ConstPlugin\", handler);\n        normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"ConstPlugin\", handler);\n      });\n    }\n  }]);\n\n  return ConstPlugin;\n}();\n\nmodule.exports = ConstPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/ConstPlugin.js"],"names":["ConstDependency","require","NullFactory","ParserHelpers","getQuery","request","i","indexOf","substr","collectDeclaration","declarations","pattern","stack","length","node","pop","type","add","name","elements","element","push","left","properties","property","value","argument","getHoistedDeclarations","branch","includeFunctionDeclarations","Set","body","stmt","consequent","alternate","init","cases","cs","block","handler","finalizer","id","kind","decl","Array","from","ConstPlugin","compiler","hooks","compilation","tap","normalModuleFactory","dependencyFactories","set","dependencyTemplates","Template","parser","statementIf","statement","scope","isAsmJs","param","evaluateExpression","test","bool","asBool","dep","range","loc","state","current","addDependency","branchToRemove","isStrict","replacement","join","expressionConditionalOperator","expression","expressionLogicalOperator","operator","keepRight","isBoolean","walkExpression","right","evaluateIdentifier","for","expr","module","evaluateToString","resource","addVariable","JSON","stringify","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst NullFactory = require(\"./NullFactory\");\nconst ParserHelpers = require(\"./ParserHelpers\");\n\nconst getQuery = request => {\n\tconst i = request.indexOf(\"?\");\n\treturn i !== -1 ? request.substr(i) : \"\";\n};\n\nconst collectDeclaration = (declarations, pattern) => {\n\tconst stack = [pattern];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop();\n\t\tswitch (node.type) {\n\t\t\tcase \"Identifier\":\n\t\t\t\tdeclarations.add(node.name);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tfor (const element of node.elements) {\n\t\t\t\t\tif (element) {\n\t\t\t\t\t\tstack.push(element);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tstack.push(node.left);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tfor (const property of node.properties) {\n\t\t\t\t\tstack.push(property.value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tstack.push(node.argument);\n\t\t\t\tbreak;\n\t\t}\n\t}\n};\n\nconst getHoistedDeclarations = (branch, includeFunctionDeclarations) => {\n\tconst declarations = new Set();\n\tconst stack = [branch];\n\twhile (stack.length > 0) {\n\t\tconst node = stack.pop();\n\t\t// Some node could be `null` or `undefined`.\n\t\tif (!node) continue;\n\t\tswitch (node.type) {\n\t\t\t// Walk through control statements to look for hoisted declarations.\n\t\t\t// Some branches are skipped since they do not allow declarations.\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tfor (const stmt of node.body) {\n\t\t\t\t\tstack.push(stmt);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tstack.push(node.consequent);\n\t\t\t\tstack.push(node.alternate);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tstack.push(node.init);\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tstack.push(node.left);\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\tcase \"WhileStatement\":\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tstack.push(node.body);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tfor (const cs of node.cases) {\n\t\t\t\t\tfor (const consequent of cs.consequent) {\n\t\t\t\t\t\tstack.push(consequent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tstack.push(node.block);\n\t\t\t\tif (node.handler) {\n\t\t\t\t\tstack.push(node.handler.body);\n\t\t\t\t}\n\t\t\t\tstack.push(node.finalizer);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tif (includeFunctionDeclarations) {\n\t\t\t\t\tcollectDeclaration(declarations, node.id);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tif (node.kind === \"var\") {\n\t\t\t\t\tfor (const decl of node.declarations) {\n\t\t\t\t\t\tcollectDeclaration(declarations, decl.id);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn Array.from(declarations);\n};\n\nclass ConstPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"ConstPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tcompilation.dependencyFactories.set(ConstDependency, new NullFactory());\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\tparser.hooks.statementIf.tap(\"ConstPlugin\", statement => {\n\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\tconst param = parser.evaluateExpression(statement.test);\n\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\tif (statement.test.type !== \"Literal\") {\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(`${bool}`, param.range);\n\t\t\t\t\t\t\t\tdep.loc = statement.loc;\n\t\t\t\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst branchToRemove = bool\n\t\t\t\t\t\t\t\t? statement.alternate\n\t\t\t\t\t\t\t\t: statement.consequent;\n\t\t\t\t\t\t\tif (branchToRemove) {\n\t\t\t\t\t\t\t\t// Before removing the dead branch, the hoisted declarations\n\t\t\t\t\t\t\t\t// must be collected.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//     if (true) f() else g()\n\t\t\t\t\t\t\t\t//     if (false) {\n\t\t\t\t\t\t\t\t//       function f() {}\n\t\t\t\t\t\t\t\t//       const g = function g() {}\n\t\t\t\t\t\t\t\t//       if (someTest) {\n\t\t\t\t\t\t\t\t//         let a = 1\n\t\t\t\t\t\t\t\t//         var x, {y, z} = obj\n\t\t\t\t\t\t\t\t//       }\n\t\t\t\t\t\t\t\t//     } else {\n\t\t\t\t\t\t\t\t//       …\n\t\t\t\t\t\t\t\t//     }\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//     if (true) f() else {}\n\t\t\t\t\t\t\t\t//     if (false) {\n\t\t\t\t\t\t\t\t//       var f, x, y, z;   (in loose mode)\n\t\t\t\t\t\t\t\t//       var x, y, z;      (in strict mode)\n\t\t\t\t\t\t\t\t//     } else {\n\t\t\t\t\t\t\t\t//       …\n\t\t\t\t\t\t\t\t//     }\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// NOTE: When code runs in strict mode, `var` declarations\n\t\t\t\t\t\t\t\t// are hoisted but `function` declarations don't.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tlet declarations;\n\t\t\t\t\t\t\t\tif (parser.scope.isStrict) {\n\t\t\t\t\t\t\t\t\t// If the code runs in strict mode, variable declarations\n\t\t\t\t\t\t\t\t\t// using `var` must be hoisted.\n\t\t\t\t\t\t\t\t\tdeclarations = getHoistedDeclarations(branchToRemove, false);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// Otherwise, collect all hoisted declaration.\n\t\t\t\t\t\t\t\t\tdeclarations = getHoistedDeclarations(branchToRemove, true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet replacement;\n\t\t\t\t\t\t\t\tif (declarations.length > 0) {\n\t\t\t\t\t\t\t\t\treplacement = `{ var ${declarations.join(\", \")}; }`;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\treplacement = \"{}\";\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\treplacement,\n\t\t\t\t\t\t\t\t\tbranchToRemove.range\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = branchToRemove.loc;\n\t\t\t\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn bool;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expressionConditionalOperator.tap(\n\t\t\t\t\t\t\"ConstPlugin\",\n\t\t\t\t\t\texpression => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.test);\n\t\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\t\tif (expression.test.type !== \"Literal\") {\n\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(` ${bool}`, param.range);\n\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Expressions do not hoist.\n\t\t\t\t\t\t\t\t// It is safe to remove the dead branch.\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   false ? someExpression() : otherExpression();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t//   false ? undefined : otherExpression();\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\tconst branchToRemove = bool\n\t\t\t\t\t\t\t\t\t? expression.alternate\n\t\t\t\t\t\t\t\t\t: expression.consequent;\n\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\"undefined\",\n\t\t\t\t\t\t\t\t\tbranchToRemove.range\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tdep.loc = branchToRemove.loc;\n\t\t\t\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t\t\t\t\treturn bool;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tparser.hooks.expressionLogicalOperator.tap(\n\t\t\t\t\t\t\"ConstPlugin\",\n\t\t\t\t\t\texpression => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\texpression.operator === \"&&\" ||\n\t\t\t\t\t\t\t\texpression.operator === \"||\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst param = parser.evaluateExpression(expression.left);\n\t\t\t\t\t\t\t\tconst bool = param.asBool();\n\t\t\t\t\t\t\t\tif (typeof bool === \"boolean\") {\n\t\t\t\t\t\t\t\t\t// Expressions do not hoist.\n\t\t\t\t\t\t\t\t\t// It is safe to remove the dead branch.\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() && false;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   true && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() || someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   truthyExpression() || false;\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// ------------------------------------------\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// Given the following code:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   falsyExpression() || someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t// the generated code is:\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t//   false && someExpression();\n\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\tconst keepRight =\n\t\t\t\t\t\t\t\t\t\t(expression.operator === \"&&\" && bool) ||\n\t\t\t\t\t\t\t\t\t\t(expression.operator === \"||\" && !bool);\n\n\t\t\t\t\t\t\t\t\tif (param.isBoolean() || keepRight) {\n\t\t\t\t\t\t\t\t\t\t// for case like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   return'development'===process.env.NODE_ENV&&'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t// we need a space before the bool to prevent result like\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\t//   returnfalse&&'foo'\n\t\t\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(` ${bool}`, param.range);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tparser.walkExpression(expression.left);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!keepRight) {\n\t\t\t\t\t\t\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t\t\t\t\t\t\t\"false\",\n\t\t\t\t\t\t\t\t\t\t\texpression.right.range\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tdep.loc = expression.loc;\n\t\t\t\t\t\t\t\t\t\tparser.state.current.addDependency(dep);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn keepRight;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t.for(\"__resourceQuery\")\n\t\t\t\t\t\t.tap(\"ConstPlugin\", expr => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\treturn ParserHelpers.evaluateToString(\n\t\t\t\t\t\t\t\tgetQuery(parser.state.module.resource)\n\t\t\t\t\t\t\t)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\tparser.hooks.expression\n\t\t\t\t\t\t.for(\"__resourceQuery\")\n\t\t\t\t\t\t.tap(\"ConstPlugin\", () => {\n\t\t\t\t\t\t\tif (parser.scope.isAsmJs) return;\n\t\t\t\t\t\t\tif (!parser.state.module) return;\n\t\t\t\t\t\t\tparser.state.current.addVariable(\n\t\t\t\t\t\t\t\t\"__resourceQuery\",\n\t\t\t\t\t\t\t\tJSON.stringify(getQuery(parser.state.module.resource))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/auto\")\n\t\t\t\t\t.tap(\"ConstPlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/dynamic\")\n\t\t\t\t\t.tap(\"ConstPlugin\", handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(\"javascript/esm\")\n\t\t\t\t\t.tap(\"ConstPlugin\", handler);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = ConstPlugin;\n"]},"metadata":{},"sourceType":"script"}