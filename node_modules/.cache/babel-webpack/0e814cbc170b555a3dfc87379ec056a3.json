{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeTransform = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ts = require(\"typescript\");\n\nvar elide_imports_1 = require(\"./elide_imports\");\n\nvar interfaces_1 = require(\"./interfaces\");\n\nfunction makeTransform(standardTransform, getTypeChecker) {\n  return function (context) {\n    var transformer = function transformer(sf) {\n      var ops = standardTransform(sf);\n      var removeOps = ops.filter(function (op) {\n        return op.kind === interfaces_1.OPERATION_KIND.Remove;\n      });\n      var addOps = ops.filter(function (op) {\n        return op.kind === interfaces_1.OPERATION_KIND.Add;\n      });\n      var replaceOps = ops.filter(function (op) {\n        return op.kind === interfaces_1.OPERATION_KIND.Replace;\n      }); // If nodes are removed, elide the imports as well.\n      // Mainly a workaround for https://github.com/Microsoft/TypeScript/issues/17552.\n      // WARNING: this assumes that replaceOps DO NOT reuse any of the nodes they are replacing.\n      // This is currently true for transforms that use replaceOps (replace_bootstrap and\n      // replace_resources), but may not be true for new transforms.\n\n      if (getTypeChecker && removeOps.length + replaceOps.length > 0) {\n        var removedNodes = removeOps.concat(replaceOps).map(function (op) {\n          return op.target;\n        });\n        removeOps.push.apply(removeOps, _toConsumableArray(elide_imports_1.elideImports(sf, removedNodes, getTypeChecker, context.getCompilerOptions())));\n      }\n\n      var visitor = function visitor(node) {\n        var modified = false;\n        var modifiedNodes = [node]; // Check if node should be dropped.\n\n        if (removeOps.find(function (op) {\n          return op.target === node;\n        })) {\n          modifiedNodes = [];\n          modified = true;\n        } // Check if node should be replaced (only replaces with first op found).\n\n\n        var replace = replaceOps.find(function (op) {\n          return op.target === node;\n        });\n\n        if (replace) {\n          modifiedNodes = [replace.replacement];\n          modified = true;\n        } // Check if node should be added to.\n\n\n        var add = addOps.filter(function (op) {\n          return op.target === node;\n        });\n\n        if (add.length > 0) {\n          modifiedNodes = [].concat(_toConsumableArray(add.filter(function (op) {\n            return op.before;\n          }).map(function (op) {\n            return op.before;\n          })), _toConsumableArray(modifiedNodes), _toConsumableArray(add.filter(function (op) {\n            return op.after;\n          }).map(function (op) {\n            return op.after;\n          })));\n          modified = true;\n        } // If we changed anything, return modified nodes without visiting further.\n\n\n        if (modified) {\n          return modifiedNodes;\n        } else {\n          // Otherwise return node as is and visit children.\n          return ts.visitEachChild(node, visitor, context);\n        }\n      }; // Don't visit the sourcefile at all if we don't have ops for it.\n\n\n      if (ops.length === 0) {\n        return sf;\n      }\n\n      var result = ts.visitNode(sf, visitor); // If we removed any decorators, we need to clean up the decorator arrays.\n\n      if (removeOps.some(function (op) {\n        return op.target.kind === ts.SyntaxKind.Decorator;\n      })) {\n        cleanupDecorators(result);\n      }\n\n      return result;\n    };\n\n    return transformer;\n  };\n}\n\nexports.makeTransform = makeTransform; // If TS sees an empty decorator array, it will still emit a `__decorate` call.\n//    This seems to be a TS bug.\n\nfunction cleanupDecorators(node) {\n  var _a;\n\n  if (((_a = node.decorators) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n    // tslint:disable-next-line:no-any\n    node.decorators = undefined;\n  }\n\n  ts.forEachChild(node, function (node) {\n    return cleanupDecorators(node);\n  });\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/transformers/make_transform.js"],"names":["Object","defineProperty","exports","value","makeTransform","ts","require","elide_imports_1","interfaces_1","standardTransform","getTypeChecker","context","transformer","sf","ops","removeOps","filter","op","kind","OPERATION_KIND","Remove","addOps","Add","replaceOps","Replace","length","removedNodes","concat","map","target","push","elideImports","getCompilerOptions","visitor","node","modified","modifiedNodes","find","replace","replacement","add","before","after","visitEachChild","result","visitNode","some","SyntaxKind","Decorator","cleanupDecorators","_a","decorators","undefined","forEachChild"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeTransform = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ts = require(\"typescript\");\nconst elide_imports_1 = require(\"./elide_imports\");\nconst interfaces_1 = require(\"./interfaces\");\nfunction makeTransform(standardTransform, getTypeChecker) {\n    return (context) => {\n        const transformer = (sf) => {\n            const ops = standardTransform(sf);\n            const removeOps = ops.filter(op => op.kind === interfaces_1.OPERATION_KIND.Remove);\n            const addOps = ops.filter(op => op.kind === interfaces_1.OPERATION_KIND.Add);\n            const replaceOps = ops.filter(op => op.kind === interfaces_1.OPERATION_KIND.Replace);\n            // If nodes are removed, elide the imports as well.\n            // Mainly a workaround for https://github.com/Microsoft/TypeScript/issues/17552.\n            // WARNING: this assumes that replaceOps DO NOT reuse any of the nodes they are replacing.\n            // This is currently true for transforms that use replaceOps (replace_bootstrap and\n            // replace_resources), but may not be true for new transforms.\n            if (getTypeChecker && removeOps.length + replaceOps.length > 0) {\n                const removedNodes = removeOps.concat(replaceOps).map(op => op.target);\n                removeOps.push(...elide_imports_1.elideImports(sf, removedNodes, getTypeChecker, context.getCompilerOptions()));\n            }\n            const visitor = node => {\n                let modified = false;\n                let modifiedNodes = [node];\n                // Check if node should be dropped.\n                if (removeOps.find(op => op.target === node)) {\n                    modifiedNodes = [];\n                    modified = true;\n                }\n                // Check if node should be replaced (only replaces with first op found).\n                const replace = replaceOps.find(op => op.target === node);\n                if (replace) {\n                    modifiedNodes = [replace.replacement];\n                    modified = true;\n                }\n                // Check if node should be added to.\n                const add = addOps.filter(op => op.target === node);\n                if (add.length > 0) {\n                    modifiedNodes = [\n                        ...add.filter(op => op.before).map(op => op.before),\n                        ...modifiedNodes,\n                        ...add.filter(op => op.after).map(op => op.after),\n                    ];\n                    modified = true;\n                }\n                // If we changed anything, return modified nodes without visiting further.\n                if (modified) {\n                    return modifiedNodes;\n                }\n                else {\n                    // Otherwise return node as is and visit children.\n                    return ts.visitEachChild(node, visitor, context);\n                }\n            };\n            // Don't visit the sourcefile at all if we don't have ops for it.\n            if (ops.length === 0) {\n                return sf;\n            }\n            const result = ts.visitNode(sf, visitor);\n            // If we removed any decorators, we need to clean up the decorator arrays.\n            if (removeOps.some(op => op.target.kind === ts.SyntaxKind.Decorator)) {\n                cleanupDecorators(result);\n            }\n            return result;\n        };\n        return transformer;\n    };\n}\nexports.makeTransform = makeTransform;\n// If TS sees an empty decorator array, it will still emit a `__decorate` call.\n//    This seems to be a TS bug.\nfunction cleanupDecorators(node) {\n    var _a;\n    if (((_a = node.decorators) === null || _a === void 0 ? void 0 : _a.length) === 0) {\n        // tslint:disable-next-line:no-any\n        node.decorators = undefined;\n    }\n    ts.forEachChild(node, node => cleanupDecorators(node));\n}\n"]},"metadata":{},"sourceType":"script"}