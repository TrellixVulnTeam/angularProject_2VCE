{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/dependencies/esm_dependency_host\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isStringImportOrReexport = exports.hasImportOrReexportStatements = exports.EsmDependencyHost = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var dependency_host_1 = require(\"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\");\n  /**\n   * Helper functions for computing dependencies.\n   */\n\n\n  var EsmDependencyHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(EsmDependencyHost, _super);\n\n    function EsmDependencyHost(fs, moduleResolver, scanImportExpressions) {\n      if (scanImportExpressions === void 0) {\n        scanImportExpressions = true;\n      }\n\n      var _this = _super.call(this, fs, moduleResolver) || this;\n\n      _this.scanImportExpressions = scanImportExpressions; // By skipping trivia here we don't have to account for it in the processing below\n      // It has no relevance to capturing imports.\n\n      _this.scanner = ts.createScanner(ts.ScriptTarget.Latest,\n      /* skipTrivia */\n      true);\n      return _this;\n    }\n\n    EsmDependencyHost.prototype.canSkipFile = function (fileContents) {\n      return !hasImportOrReexportStatements(fileContents);\n    };\n    /**\n     * Extract any import paths from imports found in the contents of this file.\n     *\n     * This implementation uses the TypeScript scanner, which tokenizes source code,\n     * to process the string. This is halfway between working with the string directly,\n     * which is too difficult due to corner cases, and parsing the string into a full\n     * TypeScript Abstract Syntax Tree (AST), which ends up doing more processing than\n     * is needed.\n     *\n     * The scanning is not trivial because we must hold state between each token since\n     * the context of the token affects how it should be scanned, and the scanner does\n     * not manage this for us.\n     *\n     * Specifically, backticked strings are particularly challenging since it is possible\n     * to recursively nest backticks and TypeScript expressions within each other.\n     */\n\n\n    EsmDependencyHost.prototype.extractImports = function (file, fileContents) {\n      var imports = new Set();\n      var templateStack = [];\n      var lastToken = ts.SyntaxKind.Unknown;\n      var currentToken = ts.SyntaxKind.Unknown;\n      var stopAtIndex = findLastPossibleImportOrReexport(fileContents);\n      this.scanner.setText(fileContents);\n\n      while ((currentToken = this.scanner.scan()) !== ts.SyntaxKind.EndOfFileToken) {\n        if (this.scanner.getTokenPos() > stopAtIndex) {\n          break;\n        }\n\n        switch (currentToken) {\n          case ts.SyntaxKind.TemplateHead:\n            // TemplateHead indicates the beginning of a backticked string\n            // Capture this in the `templateStack` to indicate we are currently processing\n            // within the static text part of a backticked string.\n            templateStack.push(currentToken);\n            break;\n\n          case ts.SyntaxKind.OpenBraceToken:\n            if (templateStack.length > 0) {\n              // We are processing a backticked string. This indicates that we are either\n              // entering an interpolation expression or entering an object literal expression.\n              // We add it to the `templateStack` so we can track when we leave the interpolation or\n              // object literal.\n              templateStack.push(currentToken);\n            }\n\n            break;\n\n          case ts.SyntaxKind.CloseBraceToken:\n            if (templateStack.length > 0) {\n              // We are processing a backticked string then this indicates that we are either\n              // leaving an interpolation expression or leaving an object literal expression.\n              var templateToken = templateStack[templateStack.length - 1];\n\n              if (templateToken === ts.SyntaxKind.TemplateHead) {\n                // We have hit a nested backticked string so we need to rescan it in that context\n                currentToken = this.scanner.reScanTemplateToken(\n                /* isTaggedTemplate */\n                false);\n\n                if (currentToken === ts.SyntaxKind.TemplateTail) {\n                  // We got to the end of the backticked string so pop the token that started it off\n                  // the stack.\n                  templateStack.pop();\n                }\n              } else {\n                // We hit the end of an object-literal expression so pop the open-brace that started\n                // it off the stack.\n                templateStack.pop();\n              }\n            }\n\n            break;\n\n          case ts.SyntaxKind.SlashToken:\n          case ts.SyntaxKind.SlashEqualsToken:\n            if (canPrecedeARegex(lastToken)) {\n              // We have hit a slash (`/`) in a context where it could be the start of a regular\n              // expression so rescan it in that context\n              currentToken = this.scanner.reScanSlashToken();\n            }\n\n            break;\n\n          case ts.SyntaxKind.ImportKeyword:\n            var importPath = this.extractImportPath();\n\n            if (importPath !== null) {\n              imports.add(importPath);\n            }\n\n            break;\n\n          case ts.SyntaxKind.ExportKeyword:\n            var reexportPath = this.extractReexportPath();\n\n            if (reexportPath !== null) {\n              imports.add(reexportPath);\n            }\n\n            break;\n        }\n\n        lastToken = currentToken;\n      } // Clear the text from the scanner to avoid holding on to potentially large strings of source\n      // content after the scanning has completed.\n\n\n      this.scanner.setText('');\n      return imports;\n    };\n    /**\n     * We have found an `import` token so now try to identify the import path.\n     *\n     * This method will use the current state of `this.scanner` to extract a string literal module\n     * specifier. It expects that the current state of the scanner is that an `import` token has just\n     * been scanned.\n     *\n     * The following forms of import are matched:\n     *\n     * * `import \"module-specifier\";`\n     * * `import(\"module-specifier\")`\n     * * `import defaultBinding from \"module-specifier\";`\n     * * `import defaultBinding, * as identifier from \"module-specifier\";`\n     * * `import defaultBinding, {...} from \"module-specifier\";`\n     * * `import * as identifier from \"module-specifier\";`\n     * * `import {...} from \"module-specifier\";`\n     *\n     * @returns the import path or null if there is no import or it is not a string literal.\n     */\n\n\n    EsmDependencyHost.prototype.extractImportPath = function () {\n      // Check for side-effect import\n      var sideEffectImportPath = this.tryStringLiteral();\n\n      if (sideEffectImportPath !== null) {\n        return sideEffectImportPath;\n      }\n\n      var kind = this.scanner.getToken(); // Check for dynamic import expression\n\n      if (kind === ts.SyntaxKind.OpenParenToken) {\n        return this.scanImportExpressions ? this.tryStringLiteral() : null;\n      } // Check for defaultBinding\n\n\n      if (kind === ts.SyntaxKind.Identifier) {\n        // Skip default binding\n        kind = this.scanner.scan();\n\n        if (kind === ts.SyntaxKind.CommaToken) {\n          // Skip comma that indicates additional import bindings\n          kind = this.scanner.scan();\n        }\n      } // Check for namespace import clause\n\n\n      if (kind === ts.SyntaxKind.AsteriskToken) {\n        kind = this.skipNamespacedClause();\n\n        if (kind === null) {\n          return null;\n        }\n      } // Check for named imports clause\n      else if (kind === ts.SyntaxKind.OpenBraceToken) {\n          kind = this.skipNamedClause();\n        } // Expect a `from` clause, if not bail out\n\n\n      if (kind !== ts.SyntaxKind.FromKeyword) {\n        return null;\n      }\n\n      return this.tryStringLiteral();\n    };\n    /**\n     * We have found an `export` token so now try to identify a re-export path.\n     *\n     * This method will use the current state of `this.scanner` to extract a string literal module\n     * specifier. It expects that the current state of the scanner is that an `export` token has\n     * just been scanned.\n     *\n     * There are three forms of re-export that are matched:\n     *\n     * * `export * from '...';\n     * * `export * as alias from '...';\n     * * `export {...} from '...';\n     */\n\n\n    EsmDependencyHost.prototype.extractReexportPath = function () {\n      // Skip the `export` keyword\n      var token = this.scanner.scan();\n\n      if (token === ts.SyntaxKind.AsteriskToken) {\n        token = this.skipNamespacedClause();\n\n        if (token === null) {\n          return null;\n        }\n      } else if (token === ts.SyntaxKind.OpenBraceToken) {\n        token = this.skipNamedClause();\n      } // Expect a `from` clause, if not bail out\n\n\n      if (token !== ts.SyntaxKind.FromKeyword) {\n        return null;\n      }\n\n      return this.tryStringLiteral();\n    };\n\n    EsmDependencyHost.prototype.skipNamespacedClause = function () {\n      // Skip past the `*`\n      var token = this.scanner.scan(); // Check for a `* as identifier` alias clause\n\n      if (token === ts.SyntaxKind.AsKeyword) {\n        // Skip past the `as` keyword\n        token = this.scanner.scan(); // Expect an identifier, if not bail out\n\n        if (token !== ts.SyntaxKind.Identifier) {\n          return null;\n        } // Skip past the identifier\n\n\n        token = this.scanner.scan();\n      }\n\n      return token;\n    };\n\n    EsmDependencyHost.prototype.skipNamedClause = function () {\n      var braceCount = 1; // Skip past the initial opening brace `{`\n\n      var token = this.scanner.scan(); // Search for the matching closing brace `}`\n\n      while (braceCount > 0 && token !== ts.SyntaxKind.EndOfFileToken) {\n        if (token === ts.SyntaxKind.OpenBraceToken) {\n          braceCount++;\n        } else if (token === ts.SyntaxKind.CloseBraceToken) {\n          braceCount--;\n        }\n\n        token = this.scanner.scan();\n      }\n\n      return token;\n    };\n\n    EsmDependencyHost.prototype.tryStringLiteral = function () {\n      return this.scanner.scan() === ts.SyntaxKind.StringLiteral ? this.scanner.getTokenValue() : null;\n    };\n\n    return EsmDependencyHost;\n  }(dependency_host_1.DependencyHostBase);\n\n  exports.EsmDependencyHost = EsmDependencyHost;\n  /**\n   * Check whether a source file needs to be parsed for imports.\n   * This is a performance short-circuit, which saves us from creating\n   * a TypeScript AST unnecessarily.\n   *\n   * @param source The content of the source file to check.\n   *\n   * @returns false if there are definitely no import or re-export statements\n   * in this file, true otherwise.\n   */\n\n  function hasImportOrReexportStatements(source) {\n    return /(?:import|export)[\\s\\S]+?([\"'])(?:\\\\\\1|.)+?\\1/.test(source);\n  }\n\n  exports.hasImportOrReexportStatements = hasImportOrReexportStatements;\n\n  function findLastPossibleImportOrReexport(source) {\n    return Math.max(source.lastIndexOf('import'), source.lastIndexOf(' from '));\n  }\n  /**\n   * Check whether the given statement is an import with a string literal module specifier.\n   * @param stmt the statement node to check.\n   * @returns true if the statement is an import with a string literal module specifier.\n   */\n\n\n  function isStringImportOrReexport(stmt) {\n    return ts.isImportDeclaration(stmt) || ts.isExportDeclaration(stmt) && !!stmt.moduleSpecifier && ts.isStringLiteral(stmt.moduleSpecifier);\n  }\n\n  exports.isStringImportOrReexport = isStringImportOrReexport;\n\n  function canPrecedeARegex(kind) {\n    switch (kind) {\n      case ts.SyntaxKind.Identifier:\n      case ts.SyntaxKind.StringLiteral:\n      case ts.SyntaxKind.NumericLiteral:\n      case ts.SyntaxKind.BigIntLiteral:\n      case ts.SyntaxKind.RegularExpressionLiteral:\n      case ts.SyntaxKind.ThisKeyword:\n      case ts.SyntaxKind.PlusPlusToken:\n      case ts.SyntaxKind.MinusMinusToken:\n      case ts.SyntaxKind.CloseParenToken:\n      case ts.SyntaxKind.CloseBracketToken:\n      case ts.SyntaxKind.CloseBraceToken:\n      case ts.SyntaxKind.TrueKeyword:\n      case ts.SyntaxKind.FalseKeyword:\n        return false;\n\n      default:\n        return true;\n    }\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/dependencies/esm_dependency_host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport {AbsoluteFsPath, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {DependencyHostBase} from './dependency_host';\nimport {ModuleResolver} from './module_resolver';\n\n/**\n * Helper functions for computing dependencies.\n */\nexport class EsmDependencyHost extends DependencyHostBase {\n  constructor(\n      fs: ReadonlyFileSystem, moduleResolver: ModuleResolver,\n      private scanImportExpressions = true) {\n    super(fs, moduleResolver);\n  }\n  // By skipping trivia here we don't have to account for it in the processing below\n  // It has no relevance to capturing imports.\n  private scanner = ts.createScanner(ts.ScriptTarget.Latest, /* skipTrivia */ true);\n\n  protected canSkipFile(fileContents: string): boolean {\n    return !hasImportOrReexportStatements(fileContents);\n  }\n\n  /**\n   * Extract any import paths from imports found in the contents of this file.\n   *\n   * This implementation uses the TypeScript scanner, which tokenizes source code,\n   * to process the string. This is halfway between working with the string directly,\n   * which is too difficult due to corner cases, and parsing the string into a full\n   * TypeScript Abstract Syntax Tree (AST), which ends up doing more processing than\n   * is needed.\n   *\n   * The scanning is not trivial because we must hold state between each token since\n   * the context of the token affects how it should be scanned, and the scanner does\n   * not manage this for us.\n   *\n   * Specifically, backticked strings are particularly challenging since it is possible\n   * to recursively nest backticks and TypeScript expressions within each other.\n   */\n  protected extractImports(file: AbsoluteFsPath, fileContents: string): Set<string> {\n    const imports = new Set<string>();\n    const templateStack: ts.SyntaxKind[] = [];\n    let lastToken: ts.SyntaxKind = ts.SyntaxKind.Unknown;\n    let currentToken: ts.SyntaxKind = ts.SyntaxKind.Unknown;\n    const stopAtIndex = findLastPossibleImportOrReexport(fileContents);\n\n    this.scanner.setText(fileContents);\n\n    while ((currentToken = this.scanner.scan()) !== ts.SyntaxKind.EndOfFileToken) {\n      if (this.scanner.getTokenPos() > stopAtIndex) {\n        break;\n      }\n      switch (currentToken) {\n        case ts.SyntaxKind.TemplateHead:\n          // TemplateHead indicates the beginning of a backticked string\n          // Capture this in the `templateStack` to indicate we are currently processing\n          // within the static text part of a backticked string.\n          templateStack.push(currentToken);\n          break;\n        case ts.SyntaxKind.OpenBraceToken:\n          if (templateStack.length > 0) {\n            // We are processing a backticked string. This indicates that we are either\n            // entering an interpolation expression or entering an object literal expression.\n            // We add it to the `templateStack` so we can track when we leave the interpolation or\n            // object literal.\n            templateStack.push(currentToken);\n          }\n          break;\n        case ts.SyntaxKind.CloseBraceToken:\n          if (templateStack.length > 0) {\n            // We are processing a backticked string then this indicates that we are either\n            // leaving an interpolation expression or leaving an object literal expression.\n            const templateToken = templateStack[templateStack.length - 1];\n            if (templateToken === ts.SyntaxKind.TemplateHead) {\n              // We have hit a nested backticked string so we need to rescan it in that context\n              currentToken = this.scanner.reScanTemplateToken(/* isTaggedTemplate */ false);\n              if (currentToken === ts.SyntaxKind.TemplateTail) {\n                // We got to the end of the backticked string so pop the token that started it off\n                // the stack.\n                templateStack.pop();\n              }\n            } else {\n              // We hit the end of an object-literal expression so pop the open-brace that started\n              // it off the stack.\n              templateStack.pop();\n            }\n          }\n          break;\n        case ts.SyntaxKind.SlashToken:\n        case ts.SyntaxKind.SlashEqualsToken:\n          if (canPrecedeARegex(lastToken)) {\n            // We have hit a slash (`/`) in a context where it could be the start of a regular\n            // expression so rescan it in that context\n            currentToken = this.scanner.reScanSlashToken();\n          }\n          break;\n        case ts.SyntaxKind.ImportKeyword:\n          const importPath = this.extractImportPath();\n          if (importPath !== null) {\n            imports.add(importPath);\n          }\n          break;\n        case ts.SyntaxKind.ExportKeyword:\n          const reexportPath = this.extractReexportPath();\n          if (reexportPath !== null) {\n            imports.add(reexportPath);\n          }\n          break;\n      }\n      lastToken = currentToken;\n    }\n\n    // Clear the text from the scanner to avoid holding on to potentially large strings of source\n    // content after the scanning has completed.\n    this.scanner.setText('');\n\n    return imports;\n  }\n\n\n  /**\n   * We have found an `import` token so now try to identify the import path.\n   *\n   * This method will use the current state of `this.scanner` to extract a string literal module\n   * specifier. It expects that the current state of the scanner is that an `import` token has just\n   * been scanned.\n   *\n   * The following forms of import are matched:\n   *\n   * * `import \"module-specifier\";`\n   * * `import(\"module-specifier\")`\n   * * `import defaultBinding from \"module-specifier\";`\n   * * `import defaultBinding, * as identifier from \"module-specifier\";`\n   * * `import defaultBinding, {...} from \"module-specifier\";`\n   * * `import * as identifier from \"module-specifier\";`\n   * * `import {...} from \"module-specifier\";`\n   *\n   * @returns the import path or null if there is no import or it is not a string literal.\n   */\n  protected extractImportPath(): string|null {\n    // Check for side-effect import\n    let sideEffectImportPath = this.tryStringLiteral();\n    if (sideEffectImportPath !== null) {\n      return sideEffectImportPath;\n    }\n\n    let kind: ts.SyntaxKind|null = this.scanner.getToken();\n\n    // Check for dynamic import expression\n    if (kind === ts.SyntaxKind.OpenParenToken) {\n      return this.scanImportExpressions ? this.tryStringLiteral() : null;\n    }\n\n    // Check for defaultBinding\n    if (kind === ts.SyntaxKind.Identifier) {\n      // Skip default binding\n      kind = this.scanner.scan();\n      if (kind === ts.SyntaxKind.CommaToken) {\n        // Skip comma that indicates additional import bindings\n        kind = this.scanner.scan();\n      }\n    }\n\n    // Check for namespace import clause\n    if (kind === ts.SyntaxKind.AsteriskToken) {\n      kind = this.skipNamespacedClause();\n      if (kind === null) {\n        return null;\n      }\n    }\n    // Check for named imports clause\n    else if (kind === ts.SyntaxKind.OpenBraceToken) {\n      kind = this.skipNamedClause();\n    }\n\n    // Expect a `from` clause, if not bail out\n    if (kind !== ts.SyntaxKind.FromKeyword) {\n      return null;\n    }\n\n    return this.tryStringLiteral();\n  }\n\n  /**\n   * We have found an `export` token so now try to identify a re-export path.\n   *\n   * This method will use the current state of `this.scanner` to extract a string literal module\n   * specifier. It expects that the current state of the scanner is that an `export` token has\n   * just been scanned.\n   *\n   * There are three forms of re-export that are matched:\n   *\n   * * `export * from '...';\n   * * `export * as alias from '...';\n   * * `export {...} from '...';\n   */\n  protected extractReexportPath(): string|null {\n    // Skip the `export` keyword\n    let token: ts.SyntaxKind|null = this.scanner.scan();\n    if (token === ts.SyntaxKind.AsteriskToken) {\n      token = this.skipNamespacedClause();\n      if (token === null) {\n        return null;\n      }\n    } else if (token === ts.SyntaxKind.OpenBraceToken) {\n      token = this.skipNamedClause();\n    }\n    // Expect a `from` clause, if not bail out\n    if (token !== ts.SyntaxKind.FromKeyword) {\n      return null;\n    }\n    return this.tryStringLiteral();\n  }\n\n  protected skipNamespacedClause(): ts.SyntaxKind|null {\n    // Skip past the `*`\n    let token = this.scanner.scan();\n    // Check for a `* as identifier` alias clause\n    if (token === ts.SyntaxKind.AsKeyword) {\n      // Skip past the `as` keyword\n      token = this.scanner.scan();\n      // Expect an identifier, if not bail out\n      if (token !== ts.SyntaxKind.Identifier) {\n        return null;\n      }\n      // Skip past the identifier\n      token = this.scanner.scan();\n    }\n    return token;\n  }\n\n  protected skipNamedClause(): ts.SyntaxKind {\n    let braceCount = 1;\n    // Skip past the initial opening brace `{`\n    let token = this.scanner.scan();\n    // Search for the matching closing brace `}`\n    while (braceCount > 0 && token !== ts.SyntaxKind.EndOfFileToken) {\n      if (token === ts.SyntaxKind.OpenBraceToken) {\n        braceCount++;\n      } else if (token === ts.SyntaxKind.CloseBraceToken) {\n        braceCount--;\n      }\n      token = this.scanner.scan();\n    }\n    return token;\n  }\n\n  protected tryStringLiteral(): string|null {\n    return this.scanner.scan() === ts.SyntaxKind.StringLiteral ? this.scanner.getTokenValue() :\n                                                                 null;\n  }\n}\n\n/**\n * Check whether a source file needs to be parsed for imports.\n * This is a performance short-circuit, which saves us from creating\n * a TypeScript AST unnecessarily.\n *\n * @param source The content of the source file to check.\n *\n * @returns false if there are definitely no import or re-export statements\n * in this file, true otherwise.\n */\nexport function hasImportOrReexportStatements(source: string): boolean {\n  return /(?:import|export)[\\s\\S]+?([\"'])(?:\\\\\\1|.)+?\\1/.test(source);\n}\n\nfunction findLastPossibleImportOrReexport(source: string): number {\n  return Math.max(source.lastIndexOf('import'), source.lastIndexOf(' from '));\n}\n\n/**\n * Check whether the given statement is an import with a string literal module specifier.\n * @param stmt the statement node to check.\n * @returns true if the statement is an import with a string literal module specifier.\n */\nexport function isStringImportOrReexport(stmt: ts.Statement): stmt is ts.ImportDeclaration&\n    {moduleSpecifier: ts.StringLiteral} {\n  return ts.isImportDeclaration(stmt) ||\n      ts.isExportDeclaration(stmt) && !!stmt.moduleSpecifier &&\n      ts.isStringLiteral(stmt.moduleSpecifier);\n}\n\n\nfunction canPrecedeARegex(kind: ts.SyntaxKind): boolean {\n  switch (kind) {\n    case ts.SyntaxKind.Identifier:\n    case ts.SyntaxKind.StringLiteral:\n    case ts.SyntaxKind.NumericLiteral:\n    case ts.SyntaxKind.BigIntLiteral:\n    case ts.SyntaxKind.RegularExpressionLiteral:\n    case ts.SyntaxKind.ThisKeyword:\n    case ts.SyntaxKind.PlusPlusToken:\n    case ts.SyntaxKind.MinusMinusToken:\n    case ts.SyntaxKind.CloseParenToken:\n    case ts.SyntaxKind.CloseBracketToken:\n    case ts.SyntaxKind.CloseBraceToken:\n    case ts.SyntaxKind.TrueKeyword:\n    case ts.SyntaxKind.FalseKeyword:\n      return false;\n    default:\n      return true;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}