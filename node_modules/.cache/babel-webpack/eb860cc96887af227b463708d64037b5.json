{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/parse_util\", [\"require\", \"exports\", \"@angular/compiler/src/chars\", \"@angular/compiler/src/compile_metadata\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.r3JitTypeSourceSpan = exports.typeSourceSpan = exports.ParseError = exports.ParseErrorLevel = exports.ParseSourceSpan = exports.ParseSourceFile = exports.ParseLocation = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var chars = require(\"@angular/compiler/src/chars\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var ParseLocation =\n  /** @class */\n  function () {\n    function ParseLocation(file, offset, line, col) {\n      this.file = file;\n      this.offset = offset;\n      this.line = line;\n      this.col = col;\n    }\n\n    ParseLocation.prototype.toString = function () {\n      return this.offset != null ? this.file.url + \"@\" + this.line + \":\" + this.col : this.file.url;\n    };\n\n    ParseLocation.prototype.moveBy = function (delta) {\n      var source = this.file.content;\n      var len = source.length;\n      var offset = this.offset;\n      var line = this.line;\n      var col = this.col;\n\n      while (offset > 0 && delta < 0) {\n        offset--;\n        delta++;\n        var ch = source.charCodeAt(offset);\n\n        if (ch == chars.$LF) {\n          line--;\n          var priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n          col = priorLine > 0 ? offset - priorLine : offset;\n        } else {\n          col--;\n        }\n      }\n\n      while (offset < len && delta > 0) {\n        var ch = source.charCodeAt(offset);\n        offset++;\n        delta--;\n\n        if (ch == chars.$LF) {\n          line++;\n          col = 0;\n        } else {\n          col++;\n        }\n      }\n\n      return new ParseLocation(this.file, offset, line, col);\n    }; // Return the source around the location\n    // Up to `maxChars` or `maxLines` on each side of the location\n\n\n    ParseLocation.prototype.getContext = function (maxChars, maxLines) {\n      var content = this.file.content;\n      var startOffset = this.offset;\n\n      if (startOffset != null) {\n        if (startOffset > content.length - 1) {\n          startOffset = content.length - 1;\n        }\n\n        var endOffset = startOffset;\n        var ctxChars = 0;\n        var ctxLines = 0;\n\n        while (ctxChars < maxChars && startOffset > 0) {\n          startOffset--;\n          ctxChars++;\n\n          if (content[startOffset] == '\\n') {\n            if (++ctxLines == maxLines) {\n              break;\n            }\n          }\n        }\n\n        ctxChars = 0;\n        ctxLines = 0;\n\n        while (ctxChars < maxChars && endOffset < content.length - 1) {\n          endOffset++;\n          ctxChars++;\n\n          if (content[endOffset] == '\\n') {\n            if (++ctxLines == maxLines) {\n              break;\n            }\n          }\n        }\n\n        return {\n          before: content.substring(startOffset, this.offset),\n          after: content.substring(this.offset, endOffset + 1)\n        };\n      }\n\n      return null;\n    };\n\n    return ParseLocation;\n  }();\n\n  exports.ParseLocation = ParseLocation;\n\n  var ParseSourceFile =\n  /** @class */\n  function () {\n    function ParseSourceFile(content, url) {\n      this.content = content;\n      this.url = url;\n    }\n\n    return ParseSourceFile;\n  }();\n\n  exports.ParseSourceFile = ParseSourceFile;\n\n  var ParseSourceSpan =\n  /** @class */\n  function () {\n    /**\n     * Create an object that holds information about spans of tokens/nodes captured during\n     * lexing/parsing of text.\n     *\n     * @param start\n     * The location of the start of the span (having skipped leading trivia).\n     * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n     * elements will appear to begin at the start of the opening tag, rather than at the start of any\n     * leading trivia, which could include newlines.\n     *\n     * @param end\n     * The location of the end of the span.\n     *\n     * @param fullStart\n     * The start of the token without skipping the leading trivia.\n     * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n     * from text tokens. Such tooling creates new source-spans relative to the original token's\n     * source-span. If leading trivia characters have been skipped then the new source-spans may be\n     * incorrectly offset.\n     *\n     * @param details\n     * Additional information (such as identifier names) that should be associated with the span.\n     */\n    function ParseSourceSpan(start, end, fullStart, details) {\n      if (fullStart === void 0) {\n        fullStart = start;\n      }\n\n      if (details === void 0) {\n        details = null;\n      }\n\n      this.start = start;\n      this.end = end;\n      this.fullStart = fullStart;\n      this.details = details;\n    }\n\n    ParseSourceSpan.prototype.toString = function () {\n      return this.start.file.content.substring(this.start.offset, this.end.offset);\n    };\n\n    return ParseSourceSpan;\n  }();\n\n  exports.ParseSourceSpan = ParseSourceSpan;\n  var ParseErrorLevel;\n\n  (function (ParseErrorLevel) {\n    ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n    ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n  })(ParseErrorLevel = exports.ParseErrorLevel || (exports.ParseErrorLevel = {}));\n\n  var ParseError =\n  /** @class */\n  function () {\n    function ParseError(span, msg, level) {\n      if (level === void 0) {\n        level = ParseErrorLevel.ERROR;\n      }\n\n      this.span = span;\n      this.msg = msg;\n      this.level = level;\n    }\n\n    ParseError.prototype.contextualMessage = function () {\n      var ctx = this.span.start.getContext(100, 3);\n      return ctx ? this.msg + \" (\\\"\" + ctx.before + \"[\" + ParseErrorLevel[this.level] + \" ->]\" + ctx.after + \"\\\")\" : this.msg;\n    };\n\n    ParseError.prototype.toString = function () {\n      var details = this.span.details ? \", \" + this.span.details : '';\n      return this.contextualMessage() + \": \" + this.span.start + details;\n    };\n\n    return ParseError;\n  }();\n\n  exports.ParseError = ParseError;\n\n  function typeSourceSpan(kind, type) {\n    var moduleUrl = compile_metadata_1.identifierModuleUrl(type);\n    var sourceFileName = moduleUrl != null ? \"in \" + kind + \" \" + compile_metadata_1.identifierName(type) + \" in \" + moduleUrl : \"in \" + kind + \" \" + compile_metadata_1.identifierName(type);\n    var sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n  }\n\n  exports.typeSourceSpan = typeSourceSpan;\n  /**\n   * Generates Source Span object for a given R3 Type for JIT mode.\n   *\n   * @param kind Component or Directive.\n   * @param typeName name of the Component or Directive.\n   * @param sourceUrl reference to Component or Directive source.\n   * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n   */\n\n  function r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n    var sourceFileName = \"in \" + kind + \" \" + typeName + \" in \" + sourceUrl;\n    var sourceFile = new ParseSourceFile('', sourceFileName);\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n  }\n\n  exports.r3JitTypeSourceSpan = r3JitTypeSourceSpan;\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/parse_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from './chars';\nimport {CompileIdentifierMetadata, identifierModuleUrl, identifierName} from './compile_metadata';\n\nexport class ParseLocation {\n  constructor(\n      public file: ParseSourceFile, public offset: number, public line: number,\n      public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string, after: string}|null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url: string) {}\n}\n\nexport class ParseSourceSpan {\n  /**\n   * Create an object that holds information about spans of tokens/nodes captured during\n   * lexing/parsing of text.\n   *\n   * @param start\n   * The location of the start of the span (having skipped leading trivia).\n   * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n   * elements will appear to begin at the start of the opening tag, rather than at the start of any\n   * leading trivia, which could include newlines.\n   *\n   * @param end\n   * The location of the end of the span.\n   *\n   * @param fullStart\n   * The start of the token without skipping the leading trivia.\n   * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n   * from text tokens. Such tooling creates new source-spans relative to the original token's\n   * source-span. If leading trivia characters have been skipped then the new source-spans may be\n   * incorrectly offset.\n   *\n   * @param details\n   * Additional information (such as identifier names) that should be associated with the span.\n   */\n  constructor(\n      public start: ParseLocation, public end: ParseLocation,\n      public fullStart: ParseLocation = start, public details: string|null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError {\n  constructor(\n      public span: ParseSourceSpan, public msg: string,\n      public level: ParseErrorLevel = ParseErrorLevel.ERROR) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n                 this.msg;\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\nexport function typeSourceSpan(kind: string, type: CompileIdentifierMetadata): ParseSourceSpan {\n  const moduleUrl = identifierModuleUrl(type);\n  const sourceFileName = moduleUrl != null ? `in ${kind} ${identifierName(type)} in ${moduleUrl}` :\n                                             `in ${kind} ${identifierName(type)}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nexport function r3JitTypeSourceSpan(\n    kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}