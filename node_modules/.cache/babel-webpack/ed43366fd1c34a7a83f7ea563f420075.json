{"ast":null,"code":"var _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Minipass = require('minipass');\n\nvar _flush = Symbol('_flush');\n\nvar _flushed = Symbol('_flushed');\n\nvar _flushing = Symbol('_flushing');\n\nvar Flush = /*#__PURE__*/function (_Minipass) {\n  \"use strict\";\n\n  _inherits(Flush, _Minipass);\n\n  var _super = _createSuper(Flush);\n\n  function Flush() {\n    var _this;\n\n    var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Flush);\n\n    if (typeof opt === 'function') opt = {\n      flush: opt\n    };\n    _this = _super.call(this, opt); // or extend this class and provide a 'flush' method in your subclass\n\n    if (typeof opt.flush !== 'function' && typeof _this.flush !== 'function') throw new TypeError('must provide flush function in options');\n    _this[_flush] = opt.flush || _this.flush;\n    return _this;\n  }\n\n  _createClass(Flush, [{\n    key: \"emit\",\n    value: function emit(ev) {\n      var _get2,\n          _this2 = this;\n\n      for (var _len = arguments.length, data = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        data[_key - 1] = arguments[_key];\n      }\n\n      if (ev !== 'end' && ev !== 'finish' || this[_flushed]) return (_get2 = _get(_getPrototypeOf(Flush.prototype), \"emit\", this)).call.apply(_get2, [this, ev].concat(data));\n      if (this[_flushing]) return;\n      this[_flushing] = true;\n\n      var afterFlush = function afterFlush(er) {\n        _this2[_flushed] = true;\n        er ? _get(_getPrototypeOf(Flush.prototype), \"emit\", _this2).call(_this2, 'error', er) : _get(_getPrototypeOf(Flush.prototype), \"emit\", _this2).call(_this2, 'end');\n      };\n\n      var ret = this[_flush](afterFlush);\n\n      if (ret && ret.then) ret.then(function () {\n        return afterFlush();\n      }, function (er) {\n        return afterFlush(er);\n      });\n    }\n  }]);\n\n  return Flush;\n}(Minipass);\n\nmodule.exports = Flush;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/minipass-flush/index.js"],"names":["Minipass","require","_flush","Symbol","_flushed","_flushing","Flush","opt","flush","TypeError","ev","data","afterFlush","er","ret","then","module","exports"],"mappings":";;;;;;;;;;;;AAAA,IAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMC,MAAM,GAAGC,MAAM,CAAC,QAAD,CAArB;;AACA,IAAMC,QAAQ,GAAGD,MAAM,CAAC,UAAD,CAAvB;;AACA,IAAME,SAAS,GAAGF,MAAM,CAAC,WAAD,CAAxB;;IACMG,K;;;;;;;AACJ,mBAAuB;AAAA;;AAAA,QAAVC,GAAU,uEAAJ,EAAI;;AAAA;;AACrB,QAAI,OAAOA,GAAP,KAAe,UAAnB,EACEA,GAAG,GAAG;AAAEC,MAAAA,KAAK,EAAED;AAAT,KAAN;AAEF,8BAAMA,GAAN,EAJqB,CAMrB;;AACA,QAAI,OAAOA,GAAG,CAACC,KAAX,KAAqB,UAArB,IAAmC,OAAO,MAAKA,KAAZ,KAAsB,UAA7D,EACE,MAAM,IAAIC,SAAJ,CAAc,wCAAd,CAAN;AAEF,UAAKP,MAAL,IAAeK,GAAG,CAACC,KAAJ,IAAa,MAAKA,KAAjC;AAVqB;AAWtB;;;;WAED,cAAME,EAAN,EAAmB;AAAA;AAAA;;AAAA,wCAANC,IAAM;AAANA,QAAAA,IAAM;AAAA;;AACjB,UAAKD,EAAE,KAAK,KAAP,IAAgBA,EAAE,KAAK,QAAxB,IAAqC,KAAKN,QAAL,CAAzC,EACE,+FAAkBM,EAAlB,SAAyBC,IAAzB;AAEF,UAAI,KAAKN,SAAL,CAAJ,EACE;AAEF,WAAKA,SAAL,IAAkB,IAAlB;;AAEA,UAAMO,UAAU,GAAG,SAAbA,UAAa,CAAAC,EAAE,EAAI;AACvB,QAAA,MAAI,CAACT,QAAD,CAAJ,GAAiB,IAAjB;AACAS,QAAAA,EAAE,uEAAc,OAAd,EAAuBA,EAAvB,wEAAwC,KAAxC,CAAF;AACD,OAHD;;AAKA,UAAMC,GAAG,GAAG,KAAKZ,MAAL,EAAaU,UAAb,CAAZ;;AACA,UAAIE,GAAG,IAAIA,GAAG,CAACC,IAAf,EACED,GAAG,CAACC,IAAJ,CAAS;AAAA,eAAMH,UAAU,EAAhB;AAAA,OAAT,EAA6B,UAAAC,EAAE;AAAA,eAAID,UAAU,CAACC,EAAD,CAAd;AAAA,OAA/B;AACH;;;;EA/BiBb,Q;;AAkCpBgB,MAAM,CAACC,OAAP,GAAiBX,KAAjB","sourcesContent":["const Minipass = require('minipass')\nconst _flush = Symbol('_flush')\nconst _flushed = Symbol('_flushed')\nconst _flushing = Symbol('_flushing')\nclass Flush extends Minipass {\n  constructor (opt = {}) {\n    if (typeof opt === 'function')\n      opt = { flush: opt }\n\n    super(opt)\n\n    // or extend this class and provide a 'flush' method in your subclass\n    if (typeof opt.flush !== 'function' && typeof this.flush !== 'function')\n      throw new TypeError('must provide flush function in options')\n\n    this[_flush] = opt.flush || this.flush\n  }\n\n  emit (ev, ...data) {\n    if ((ev !== 'end' && ev !== 'finish') || this[_flushed])\n      return super.emit(ev, ...data)\n\n    if (this[_flushing])\n      return\n\n    this[_flushing] = true\n\n    const afterFlush = er => {\n      this[_flushed] = true\n      er ? super.emit('error', er) : super.emit('end')\n    }\n\n    const ret = this[_flush](afterFlush)\n    if (ret && ret.then)\n      ret.then(() => afterFlush(), er => afterFlush(er))\n  }\n}\n\nmodule.exports = Flush\n"]},"metadata":{},"sourceType":"script"}