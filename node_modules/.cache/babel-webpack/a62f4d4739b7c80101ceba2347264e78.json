{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/execution/tasks/queues/serial_task_queue\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/execution/tasks/utils\", \"@angular/compiler-cli/ngcc/src/execution/tasks/queues/base_task_queue\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SerialTaskQueue = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/utils\");\n\n  var base_task_queue_1 = require(\"@angular/compiler-cli/ngcc/src/execution/tasks/queues/base_task_queue\");\n  /**\n   * A `TaskQueue` implementation that assumes tasks are processed serially and each one is completed\n   * before requesting the next one.\n   */\n\n\n  var SerialTaskQueue =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(SerialTaskQueue, _super);\n\n    function SerialTaskQueue() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    SerialTaskQueue.prototype.computeNextTask = function () {\n      var nextTask = this.tasks.shift() || null;\n\n      if (nextTask) {\n        if (this.inProgressTasks.size > 0) {\n          // `SerialTaskQueue` can have max one in-progress task.\n          var inProgressTask = this.inProgressTasks.values().next().value;\n          throw new Error('Trying to get next task, while there is already a task in progress: ' + utils_1.stringifyTask(inProgressTask));\n        }\n\n        this.inProgressTasks.add(nextTask);\n      }\n\n      return nextTask;\n    };\n\n    return SerialTaskQueue;\n  }(base_task_queue_1.BaseTaskQueue);\n\n  exports.SerialTaskQueue = SerialTaskQueue;\n});","map":{"version":3,"sources":["../../../../../../../../../../packages/compiler-cli/ngcc/src/execution/tasks/queues/serial_task_queue.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAGH,MAAA,OAAA,GAAA,OAAA,CAAA,sDAAA,CAAA;;AAEA,MAAA,iBAAA,GAAA,OAAA,CAAA,uEAAA,CAAA;AAGA;;;AAGG;;;AACH,MAAA,eAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAqC,IAAA,OAAA,CAAA,SAAA,CAAA,eAAA,EAAA,MAAA;;AAArC,aAAA,eAAA,GAAA;;AAkBC;;AAjBC,IAAA,eAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,UAAM,QAAQ,GAAG,KAAK,KAAL,CAAW,KAAX,MAAsB,IAAvC;;AAEA,UAAI,QAAJ,EAAc;AACZ,YAAI,KAAK,eAAL,CAAqB,IAArB,GAA4B,CAAhC,EAAmC;AACjC;AACA,cAAM,cAAc,GAAG,KAAK,eAAL,CAAqB,MAArB,GAA8B,IAA9B,GAAqC,KAA5D;AACA,gBAAM,IAAI,KAAJ,CACF,yEACA,OAAA,CAAA,aAAA,CAAc,cAAd,CAFE,CAAN;AAGD;;AAED,aAAK,eAAL,CAAqB,GAArB,CAAyB,QAAzB;AACD;;AAED,aAAO,QAAP;AACD,KAhBD;;AAiBF,WAAA,eAAA;AAAC,GAlBD,CAAqC,iBAAA,CAAA,aAArC,CAAA;;AAAa,EAAA,OAAA,CAAA,eAAA,GAAA,eAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Task} from '../api';\nimport {stringifyTask} from '../utils';\n\nimport {BaseTaskQueue} from './base_task_queue';\n\n\n/**\n * A `TaskQueue` implementation that assumes tasks are processed serially and each one is completed\n * before requesting the next one.\n */\nexport class SerialTaskQueue extends BaseTaskQueue {\n  computeNextTask(): Task|null {\n    const nextTask = this.tasks.shift() || null;\n\n    if (nextTask) {\n      if (this.inProgressTasks.size > 0) {\n        // `SerialTaskQueue` can have max one in-progress task.\n        const inProgressTask = this.inProgressTasks.values().next().value;\n        throw new Error(\n            'Trying to get next task, while there is already a task in progress: ' +\n            stringifyTask(inProgressTask));\n      }\n\n      this.inProgressTasks.add(nextTask);\n    }\n\n    return nextTask;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}