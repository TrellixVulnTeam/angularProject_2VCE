{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/metadata/evaluator\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/metadata/schema\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Evaluator = exports.errorSymbol = exports.sourceInfo = exports.isPrimitive = exports.recordMapEntry = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var schema_1 = require(\"@angular/compiler-cli/src/metadata/schema\"); // In TypeScript 2.1 the spread element kind was renamed.\n\n\n  var spreadElementSyntaxKind = ts.SyntaxKind.SpreadElement || ts.SyntaxKind.SpreadElementExpression;\n\n  function isMethodCallOf(callExpression, memberName) {\n    var expression = callExpression.expression;\n\n    if (expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n      var propertyAccessExpression = expression;\n      var name = propertyAccessExpression.name;\n\n      if (name.kind == ts.SyntaxKind.Identifier) {\n        return name.text === memberName;\n      }\n    }\n\n    return false;\n  }\n\n  function isCallOf(callExpression, ident) {\n    var expression = callExpression.expression;\n\n    if (expression.kind === ts.SyntaxKind.Identifier) {\n      var identifier = expression;\n      return identifier.text === ident;\n    }\n\n    return false;\n  }\n  /* @internal */\n\n\n  function recordMapEntry(entry, node, nodeMap, sourceFile) {\n    if (!nodeMap.has(entry)) {\n      nodeMap.set(entry, node);\n\n      if (node && (schema_1.isMetadataImportedSymbolReferenceExpression(entry) || schema_1.isMetadataImportDefaultReference(entry)) && entry.line == null) {\n        var info = sourceInfo(node, sourceFile);\n        if (info.line != null) entry.line = info.line;\n        if (info.character != null) entry.character = info.character;\n      }\n    }\n\n    return entry;\n  }\n\n  exports.recordMapEntry = recordMapEntry;\n  /**\n   * ts.forEachChild stops iterating children when the callback return a truthy value.\n   * This method inverts this to implement an `every` style iterator. It will return\n   * true if every call to `cb` returns `true`.\n   */\n\n  function everyNodeChild(node, cb) {\n    return !ts.forEachChild(node, function (node) {\n      return !cb(node);\n    });\n  }\n\n  function isPrimitive(value) {\n    return Object(value) !== value;\n  }\n\n  exports.isPrimitive = isPrimitive;\n\n  function isDefined(obj) {\n    return obj !== undefined;\n  }\n\n  function getSourceFileOfNode(node) {\n    while (node && node.kind != ts.SyntaxKind.SourceFile) {\n      node = node.parent;\n    }\n\n    return node;\n  }\n  /* @internal */\n\n\n  function sourceInfo(node, sourceFile) {\n    if (node) {\n      sourceFile = sourceFile || getSourceFileOfNode(node);\n\n      if (sourceFile) {\n        return ts.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));\n      }\n    }\n\n    return {};\n  }\n\n  exports.sourceInfo = sourceInfo;\n  /* @internal */\n\n  function errorSymbol(message, node, context, sourceFile) {\n    var result = tslib_1.__assign({\n      __symbolic: 'error',\n      message: message\n    }, sourceInfo(node, sourceFile));\n\n    if (context) {\n      result.context = context;\n    }\n\n    return result;\n  }\n\n  exports.errorSymbol = errorSymbol;\n  /**\n   * Produce a symbolic representation of an expression folding values into their final value when\n   * possible.\n   */\n\n  var Evaluator =\n  /** @class */\n  function () {\n    function Evaluator(symbols, nodeMap, options, recordExport) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      this.symbols = symbols;\n      this.nodeMap = nodeMap;\n      this.options = options;\n      this.recordExport = recordExport;\n    }\n\n    Evaluator.prototype.nameOf = function (node) {\n      if (node && node.kind == ts.SyntaxKind.Identifier) {\n        return node.text;\n      }\n\n      var result = node && this.evaluateNode(node);\n\n      if (schema_1.isMetadataError(result) || typeof result === 'string') {\n        return result;\n      } else {\n        return errorSymbol('Name expected', node, {\n          received: node && node.getText() || '<missing>'\n        });\n      }\n    };\n    /**\n     * Returns true if the expression represented by `node` can be folded into a literal expression.\n     *\n     * For example, a literal is always foldable. This means that literal expressions such as `1.2`\n     * `\"Some value\"` `true` `false` are foldable.\n     *\n     * - An object literal is foldable if all the properties in the literal are foldable.\n     * - An array literal is foldable if all the elements are foldable.\n     * - A call is foldable if it is a call to a Array.prototype.concat or a call to CONST_EXPR.\n     * - A property access is foldable if the object is foldable.\n     * - A array index is foldable if index expression is foldable and the array is foldable.\n     * - Binary operator expressions are foldable if the left and right expressions are foldable and\n     *   it is one of '+', '-', '*', '/', '%', '||', and '&&'.\n     * - An identifier is foldable if a value can be found for its symbol in the evaluator symbol\n     *   table.\n     */\n\n\n    Evaluator.prototype.isFoldable = function (node) {\n      return this.isFoldableWorker(node, new Map());\n    };\n\n    Evaluator.prototype.isFoldableWorker = function (node, folding) {\n      var _this = this;\n\n      if (node) {\n        switch (node.kind) {\n          case ts.SyntaxKind.ObjectLiteralExpression:\n            return everyNodeChild(node, function (child) {\n              if (child.kind === ts.SyntaxKind.PropertyAssignment) {\n                var propertyAssignment = child;\n                return _this.isFoldableWorker(propertyAssignment.initializer, folding);\n              }\n\n              return false;\n            });\n\n          case ts.SyntaxKind.ArrayLiteralExpression:\n            return everyNodeChild(node, function (child) {\n              return _this.isFoldableWorker(child, folding);\n            });\n\n          case ts.SyntaxKind.CallExpression:\n            var callExpression = node; // We can fold a <array>.concat(<v>).\n\n            if (isMethodCallOf(callExpression, 'concat') && arrayOrEmpty(callExpression.arguments).length === 1) {\n              var arrayNode = callExpression.expression.expression;\n\n              if (this.isFoldableWorker(arrayNode, folding) && this.isFoldableWorker(callExpression.arguments[0], folding)) {\n                // It needs to be an array.\n                var arrayValue = this.evaluateNode(arrayNode);\n\n                if (arrayValue && Array.isArray(arrayValue)) {\n                  return true;\n                }\n              }\n            } // We can fold a call to CONST_EXPR\n\n\n            if (isCallOf(callExpression, 'CONST_EXPR') && arrayOrEmpty(callExpression.arguments).length === 1) return this.isFoldableWorker(callExpression.arguments[0], folding);\n            return false;\n\n          case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n          case ts.SyntaxKind.StringLiteral:\n          case ts.SyntaxKind.NumericLiteral:\n          case ts.SyntaxKind.NullKeyword:\n          case ts.SyntaxKind.TrueKeyword:\n          case ts.SyntaxKind.FalseKeyword:\n          case ts.SyntaxKind.TemplateHead:\n          case ts.SyntaxKind.TemplateMiddle:\n          case ts.SyntaxKind.TemplateTail:\n            return true;\n\n          case ts.SyntaxKind.ParenthesizedExpression:\n            var parenthesizedExpression = node;\n            return this.isFoldableWorker(parenthesizedExpression.expression, folding);\n\n          case ts.SyntaxKind.BinaryExpression:\n            var binaryExpression = node;\n\n            switch (binaryExpression.operatorToken.kind) {\n              case ts.SyntaxKind.PlusToken:\n              case ts.SyntaxKind.MinusToken:\n              case ts.SyntaxKind.AsteriskToken:\n              case ts.SyntaxKind.SlashToken:\n              case ts.SyntaxKind.PercentToken:\n              case ts.SyntaxKind.AmpersandAmpersandToken:\n              case ts.SyntaxKind.BarBarToken:\n                return this.isFoldableWorker(binaryExpression.left, folding) && this.isFoldableWorker(binaryExpression.right, folding);\n\n              default:\n                return false;\n            }\n\n          case ts.SyntaxKind.PropertyAccessExpression:\n            var propertyAccessExpression = node;\n            return this.isFoldableWorker(propertyAccessExpression.expression, folding);\n\n          case ts.SyntaxKind.ElementAccessExpression:\n            var elementAccessExpression = node;\n            return this.isFoldableWorker(elementAccessExpression.expression, folding) && this.isFoldableWorker(elementAccessExpression.argumentExpression, folding);\n\n          case ts.SyntaxKind.Identifier:\n            var identifier = node;\n            var reference = this.symbols.resolve(identifier.text);\n\n            if (reference !== undefined && isPrimitive(reference)) {\n              return true;\n            }\n\n            break;\n\n          case ts.SyntaxKind.TemplateExpression:\n            var templateExpression = node;\n            return templateExpression.templateSpans.every(function (span) {\n              return _this.isFoldableWorker(span.expression, folding);\n            });\n        }\n      }\n\n      return false;\n    };\n    /**\n     * Produce a JSON serialiable object representing `node`. The foldable values in the expression\n     * tree are folded. For example, a node representing `1 + 2` is folded into `3`.\n     */\n\n\n    Evaluator.prototype.evaluateNode = function (node, preferReference) {\n      var _this = this;\n\n      var t = this;\n      var error;\n\n      function recordEntry(entry, node) {\n        if (t.options.substituteExpression) {\n          var newEntry = t.options.substituteExpression(entry, node);\n\n          if (t.recordExport && newEntry != entry && schema_1.isMetadataGlobalReferenceExpression(newEntry)) {\n            t.recordExport(newEntry.name, entry);\n          }\n\n          entry = newEntry;\n        }\n\n        return recordMapEntry(entry, node, t.nodeMap);\n      }\n\n      function isFoldableError(value) {\n        return !t.options.verboseInvalidExpression && schema_1.isMetadataError(value);\n      }\n\n      var resolveName = function resolveName(name, preferReference) {\n        var reference = _this.symbols.resolve(name, preferReference);\n\n        if (reference === undefined) {\n          // Encode as a global reference. StaticReflector will check the reference.\n          return recordEntry({\n            __symbolic: 'reference',\n            name: name\n          }, node);\n        }\n\n        if (reference && schema_1.isMetadataSymbolicReferenceExpression(reference)) {\n          return recordEntry(tslib_1.__assign({}, reference), node);\n        }\n\n        return reference;\n      };\n\n      switch (node.kind) {\n        case ts.SyntaxKind.ObjectLiteralExpression:\n          var obj_1 = {};\n          var quoted_1 = [];\n          ts.forEachChild(node, function (child) {\n            switch (child.kind) {\n              case ts.SyntaxKind.ShorthandPropertyAssignment:\n              case ts.SyntaxKind.PropertyAssignment:\n                var assignment = child;\n\n                if (assignment.name.kind == ts.SyntaxKind.StringLiteral) {\n                  var name_1 = assignment.name.text;\n                  quoted_1.push(name_1);\n                }\n\n                var propertyName = _this.nameOf(assignment.name);\n\n                if (isFoldableError(propertyName)) {\n                  error = propertyName;\n                  return true;\n                }\n\n                var propertyValue = isPropertyAssignment(assignment) ? _this.evaluateNode(assignment.initializer,\n                /* preferReference */\n                true) : resolveName(propertyName,\n                /* preferReference */\n                true);\n\n                if (isFoldableError(propertyValue)) {\n                  error = propertyValue;\n                  return true; // Stop the forEachChild.\n                } else {\n                  obj_1[propertyName] = isPropertyAssignment(assignment) ? recordEntry(propertyValue, assignment.initializer) : propertyValue;\n                }\n\n            }\n          });\n          if (error) return error;\n\n          if (this.options.quotedNames && quoted_1.length) {\n            obj_1['$quoted$'] = quoted_1;\n          }\n\n          return recordEntry(obj_1, node);\n\n        case ts.SyntaxKind.ArrayLiteralExpression:\n          var arr_1 = [];\n          ts.forEachChild(node, function (child) {\n            var e_1, _a;\n\n            var value = _this.evaluateNode(child,\n            /* preferReference */\n            true); // Check for error\n\n\n            if (isFoldableError(value)) {\n              error = value;\n              return true; // Stop the forEachChild.\n            } // Handle spread expressions\n\n\n            if (schema_1.isMetadataSymbolicSpreadExpression(value)) {\n              if (Array.isArray(value.expression)) {\n                try {\n                  for (var _b = tslib_1.__values(value.expression), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var spreadValue = _c.value;\n                    arr_1.push(spreadValue);\n                  }\n                } catch (e_1_1) {\n                  e_1 = {\n                    error: e_1_1\n                  };\n                } finally {\n                  try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                  } finally {\n                    if (e_1) throw e_1.error;\n                  }\n                }\n\n                return;\n              }\n            }\n\n            arr_1.push(value);\n          });\n          if (error) return error;\n          return recordEntry(arr_1, node);\n\n        case spreadElementSyntaxKind:\n          var spreadExpression = this.evaluateNode(node.expression);\n          return recordEntry({\n            __symbolic: 'spread',\n            expression: spreadExpression\n          }, node);\n\n        case ts.SyntaxKind.CallExpression:\n          var callExpression = node;\n\n          if (isCallOf(callExpression, 'forwardRef') && arrayOrEmpty(callExpression.arguments).length === 1) {\n            var firstArgument = callExpression.arguments[0];\n\n            if (firstArgument.kind == ts.SyntaxKind.ArrowFunction) {\n              var arrowFunction = firstArgument;\n              return recordEntry(this.evaluateNode(arrowFunction.body), node);\n            }\n          }\n\n          var args = arrayOrEmpty(callExpression.arguments).map(function (arg) {\n            return _this.evaluateNode(arg);\n          });\n\n          if (this.isFoldable(callExpression)) {\n            if (isMethodCallOf(callExpression, 'concat')) {\n              var arrayValue = this.evaluateNode(callExpression.expression.expression);\n              if (isFoldableError(arrayValue)) return arrayValue;\n              return arrayValue.concat(args[0]);\n            }\n          } // Always fold a CONST_EXPR even if the argument is not foldable.\n\n\n          if (isCallOf(callExpression, 'CONST_EXPR') && arrayOrEmpty(callExpression.arguments).length === 1) {\n            return recordEntry(args[0], node);\n          }\n\n          var expression = this.evaluateNode(callExpression.expression);\n\n          if (isFoldableError(expression)) {\n            return recordEntry(expression, node);\n          }\n\n          var result = {\n            __symbolic: 'call',\n            expression: expression\n          };\n\n          if (args && args.length) {\n            result.arguments = args;\n          }\n\n          return recordEntry(result, node);\n\n        case ts.SyntaxKind.NewExpression:\n          var newExpression = node;\n          var newArgs = arrayOrEmpty(newExpression.arguments).map(function (arg) {\n            return _this.evaluateNode(arg);\n          });\n          var newTarget = this.evaluateNode(newExpression.expression);\n\n          if (schema_1.isMetadataError(newTarget)) {\n            return recordEntry(newTarget, node);\n          }\n\n          var call = {\n            __symbolic: 'new',\n            expression: newTarget\n          };\n\n          if (newArgs.length) {\n            call.arguments = newArgs;\n          }\n\n          return recordEntry(call, node);\n\n        case ts.SyntaxKind.PropertyAccessExpression:\n          {\n            var propertyAccessExpression = node;\n            var expression_1 = this.evaluateNode(propertyAccessExpression.expression);\n\n            if (isFoldableError(expression_1)) {\n              return recordEntry(expression_1, node);\n            }\n\n            var member = this.nameOf(propertyAccessExpression.name);\n\n            if (isFoldableError(member)) {\n              return recordEntry(member, node);\n            }\n\n            if (expression_1 && this.isFoldable(propertyAccessExpression.expression)) return expression_1[member];\n\n            if (schema_1.isMetadataModuleReferenceExpression(expression_1)) {\n              // A select into a module reference and be converted into a reference to the symbol\n              // in the module\n              return recordEntry({\n                __symbolic: 'reference',\n                module: expression_1.module,\n                name: member\n              }, node);\n            }\n\n            return recordEntry({\n              __symbolic: 'select',\n              expression: expression_1,\n              member: member\n            }, node);\n          }\n\n        case ts.SyntaxKind.ElementAccessExpression:\n          {\n            var elementAccessExpression = node;\n            var expression_2 = this.evaluateNode(elementAccessExpression.expression);\n\n            if (isFoldableError(expression_2)) {\n              return recordEntry(expression_2, node);\n            }\n\n            if (!elementAccessExpression.argumentExpression) {\n              return recordEntry(errorSymbol('Expression form not supported', node), node);\n            }\n\n            var index = this.evaluateNode(elementAccessExpression.argumentExpression);\n\n            if (isFoldableError(expression_2)) {\n              return recordEntry(expression_2, node);\n            }\n\n            if (this.isFoldable(elementAccessExpression.expression) && this.isFoldable(elementAccessExpression.argumentExpression)) return expression_2[index];\n            return recordEntry({\n              __symbolic: 'index',\n              expression: expression_2,\n              index: index\n            }, node);\n          }\n\n        case ts.SyntaxKind.Identifier:\n          var identifier = node;\n          var name = identifier.text;\n          return resolveName(name, preferReference);\n\n        case ts.SyntaxKind.TypeReference:\n          var typeReferenceNode = node;\n          var typeNameNode_1 = typeReferenceNode.typeName;\n\n          var getReference = function getReference(node) {\n            if (typeNameNode_1.kind === ts.SyntaxKind.QualifiedName) {\n              var qualifiedName = node;\n\n              var left_1 = _this.evaluateNode(qualifiedName.left);\n\n              if (schema_1.isMetadataModuleReferenceExpression(left_1)) {\n                return recordEntry({\n                  __symbolic: 'reference',\n                  module: left_1.module,\n                  name: qualifiedName.right.text\n                }, node);\n              } // Record a type reference to a declared type as a select.\n\n\n              return {\n                __symbolic: 'select',\n                expression: left_1,\n                member: qualifiedName.right.text\n              };\n            } else {\n              var identifier_1 = typeNameNode_1;\n\n              var symbol = _this.symbols.resolve(identifier_1.text);\n\n              if (isFoldableError(symbol) || schema_1.isMetadataSymbolicReferenceExpression(symbol)) {\n                return recordEntry(symbol, node);\n              }\n\n              return recordEntry(errorSymbol('Could not resolve type', node, {\n                typeName: identifier_1.text\n              }), node);\n            }\n          };\n\n          var typeReference = getReference(typeNameNode_1);\n\n          if (isFoldableError(typeReference)) {\n            return recordEntry(typeReference, node);\n          }\n\n          if (!schema_1.isMetadataModuleReferenceExpression(typeReference) && typeReferenceNode.typeArguments && typeReferenceNode.typeArguments.length) {\n            var args_1 = typeReferenceNode.typeArguments.map(function (element) {\n              return _this.evaluateNode(element);\n            }); // TODO: Remove typecast when upgraded to 2.0 as it will be correctly inferred.\n            // Some versions of 1.9 do not infer this correctly.\n\n            typeReference.arguments = args_1;\n          }\n\n          return recordEntry(typeReference, node);\n\n        case ts.SyntaxKind.UnionType:\n          var unionType = node; // Remove null and undefined from the list of unions.\n\n          var references = unionType.types.filter(function (n) {\n            return n.kind !== ts.SyntaxKind.UndefinedKeyword && !(ts.isLiteralTypeNode(n) && n.literal.kind === ts.SyntaxKind.NullKeyword);\n          }).map(function (n) {\n            return _this.evaluateNode(n);\n          }); // The remmaining reference must be the same. If two have type arguments consider them\n          // different even if the type arguments are the same.\n\n          var candidate = null;\n\n          for (var i = 0; i < references.length; i++) {\n            var reference = references[i];\n\n            if (schema_1.isMetadataSymbolicReferenceExpression(reference)) {\n              if (candidate) {\n                if (reference.name == candidate.name && reference.module == candidate.module && !reference.arguments) {\n                  candidate = reference;\n                }\n              } else {\n                candidate = reference;\n              }\n            } else {\n              return reference;\n            }\n          }\n\n          if (candidate) return candidate;\n          break;\n\n        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n        case ts.SyntaxKind.StringLiteral:\n        case ts.SyntaxKind.TemplateHead:\n        case ts.SyntaxKind.TemplateTail:\n        case ts.SyntaxKind.TemplateMiddle:\n          return node.text;\n\n        case ts.SyntaxKind.NumericLiteral:\n          return parseFloat(node.text);\n\n        case ts.SyntaxKind.AnyKeyword:\n          return recordEntry({\n            __symbolic: 'reference',\n            name: 'any'\n          }, node);\n\n        case ts.SyntaxKind.StringKeyword:\n          return recordEntry({\n            __symbolic: 'reference',\n            name: 'string'\n          }, node);\n\n        case ts.SyntaxKind.NumberKeyword:\n          return recordEntry({\n            __symbolic: 'reference',\n            name: 'number'\n          }, node);\n\n        case ts.SyntaxKind.BooleanKeyword:\n          return recordEntry({\n            __symbolic: 'reference',\n            name: 'boolean'\n          }, node);\n\n        case ts.SyntaxKind.ArrayType:\n          var arrayTypeNode = node;\n          return recordEntry({\n            __symbolic: 'reference',\n            name: 'Array',\n            arguments: [this.evaluateNode(arrayTypeNode.elementType)]\n          }, node);\n\n        case ts.SyntaxKind.NullKeyword:\n          return null;\n\n        case ts.SyntaxKind.TrueKeyword:\n          return true;\n\n        case ts.SyntaxKind.FalseKeyword:\n          return false;\n\n        case ts.SyntaxKind.ParenthesizedExpression:\n          var parenthesizedExpression = node;\n          return this.evaluateNode(parenthesizedExpression.expression);\n\n        case ts.SyntaxKind.TypeAssertionExpression:\n          var typeAssertion = node;\n          return this.evaluateNode(typeAssertion.expression);\n\n        case ts.SyntaxKind.PrefixUnaryExpression:\n          var prefixUnaryExpression = node;\n          var operand = this.evaluateNode(prefixUnaryExpression.operand);\n\n          if (isDefined(operand) && isPrimitive(operand)) {\n            switch (prefixUnaryExpression.operator) {\n              case ts.SyntaxKind.PlusToken:\n                return +operand;\n\n              case ts.SyntaxKind.MinusToken:\n                return -operand;\n\n              case ts.SyntaxKind.TildeToken:\n                return ~operand;\n\n              case ts.SyntaxKind.ExclamationToken:\n                return !operand;\n            }\n          }\n\n          var operatorText = void 0;\n\n          switch (prefixUnaryExpression.operator) {\n            case ts.SyntaxKind.PlusToken:\n              operatorText = '+';\n              break;\n\n            case ts.SyntaxKind.MinusToken:\n              operatorText = '-';\n              break;\n\n            case ts.SyntaxKind.TildeToken:\n              operatorText = '~';\n              break;\n\n            case ts.SyntaxKind.ExclamationToken:\n              operatorText = '!';\n              break;\n\n            default:\n              return undefined;\n          }\n\n          return recordEntry({\n            __symbolic: 'pre',\n            operator: operatorText,\n            operand: operand\n          }, node);\n\n        case ts.SyntaxKind.BinaryExpression:\n          var binaryExpression = node;\n          var left = this.evaluateNode(binaryExpression.left);\n          var right = this.evaluateNode(binaryExpression.right);\n\n          if (isDefined(left) && isDefined(right)) {\n            if (isPrimitive(left) && isPrimitive(right)) switch (binaryExpression.operatorToken.kind) {\n              case ts.SyntaxKind.BarBarToken:\n                return left || right;\n\n              case ts.SyntaxKind.AmpersandAmpersandToken:\n                return left && right;\n\n              case ts.SyntaxKind.AmpersandToken:\n                return left & right;\n\n              case ts.SyntaxKind.BarToken:\n                return left | right;\n\n              case ts.SyntaxKind.CaretToken:\n                return left ^ right;\n\n              case ts.SyntaxKind.EqualsEqualsToken:\n                return left == right;\n\n              case ts.SyntaxKind.ExclamationEqualsToken:\n                return left != right;\n\n              case ts.SyntaxKind.EqualsEqualsEqualsToken:\n                return left === right;\n\n              case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n                return left !== right;\n\n              case ts.SyntaxKind.LessThanToken:\n                return left < right;\n\n              case ts.SyntaxKind.GreaterThanToken:\n                return left > right;\n\n              case ts.SyntaxKind.LessThanEqualsToken:\n                return left <= right;\n\n              case ts.SyntaxKind.GreaterThanEqualsToken:\n                return left >= right;\n\n              case ts.SyntaxKind.LessThanLessThanToken:\n                return left << right;\n\n              case ts.SyntaxKind.GreaterThanGreaterThanToken:\n                return left >> right;\n\n              case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n                return left >>> right;\n\n              case ts.SyntaxKind.PlusToken:\n                return left + right;\n\n              case ts.SyntaxKind.MinusToken:\n                return left - right;\n\n              case ts.SyntaxKind.AsteriskToken:\n                return left * right;\n\n              case ts.SyntaxKind.SlashToken:\n                return left / right;\n\n              case ts.SyntaxKind.PercentToken:\n                return left % right;\n            }\n            return recordEntry({\n              __symbolic: 'binop',\n              operator: binaryExpression.operatorToken.getText(),\n              left: left,\n              right: right\n            }, node);\n          }\n\n          break;\n\n        case ts.SyntaxKind.ConditionalExpression:\n          var conditionalExpression = node;\n          var condition = this.evaluateNode(conditionalExpression.condition);\n          var thenExpression = this.evaluateNode(conditionalExpression.whenTrue);\n          var elseExpression = this.evaluateNode(conditionalExpression.whenFalse);\n\n          if (isPrimitive(condition)) {\n            return condition ? thenExpression : elseExpression;\n          }\n\n          return recordEntry({\n            __symbolic: 'if',\n            condition: condition,\n            thenExpression: thenExpression,\n            elseExpression: elseExpression\n          }, node);\n\n        case ts.SyntaxKind.FunctionExpression:\n        case ts.SyntaxKind.ArrowFunction:\n          return recordEntry(errorSymbol('Lambda not supported', node), node);\n\n        case ts.SyntaxKind.TaggedTemplateExpression:\n          return recordEntry(errorSymbol('Tagged template expressions are not supported in metadata', node), node);\n\n        case ts.SyntaxKind.TemplateExpression:\n          var templateExpression = node;\n\n          if (this.isFoldable(node)) {\n            return templateExpression.templateSpans.reduce(function (previous, current) {\n              return previous + _this.evaluateNode(current.expression) + _this.evaluateNode(current.literal);\n            }, this.evaluateNode(templateExpression.head));\n          } else {\n            return templateExpression.templateSpans.reduce(function (previous, current) {\n              var expr = _this.evaluateNode(current.expression);\n\n              var literal = _this.evaluateNode(current.literal);\n\n              if (isFoldableError(expr)) return expr;\n              if (isFoldableError(literal)) return literal;\n\n              if (typeof previous === 'string' && typeof expr === 'string' && typeof literal === 'string') {\n                return previous + expr + literal;\n              }\n\n              var result = expr;\n\n              if (previous !== '') {\n                result = {\n                  __symbolic: 'binop',\n                  operator: '+',\n                  left: previous,\n                  right: expr\n                };\n              }\n\n              if (literal != '') {\n                result = {\n                  __symbolic: 'binop',\n                  operator: '+',\n                  left: result,\n                  right: literal\n                };\n              }\n\n              return result;\n            }, this.evaluateNode(templateExpression.head));\n          }\n\n        case ts.SyntaxKind.AsExpression:\n          var asExpression = node;\n          return this.evaluateNode(asExpression.expression);\n\n        case ts.SyntaxKind.ClassExpression:\n          return {\n            __symbolic: 'class'\n          };\n      }\n\n      return recordEntry(errorSymbol('Expression form not supported', node), node);\n    };\n\n    return Evaluator;\n  }();\n\n  exports.Evaluator = Evaluator;\n\n  function isPropertyAssignment(node) {\n    return node.kind == ts.SyntaxKind.PropertyAssignment;\n  }\n\n  var empty = ts.createNodeArray();\n\n  function arrayOrEmpty(v) {\n    return v || empty;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/metadata/evaluator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {CollectorOptions} from './collector';\nimport {ClassMetadata, FunctionMetadata, InterfaceMetadata, isMetadataError, isMetadataGlobalReferenceExpression, isMetadataImportDefaultReference, isMetadataImportedSymbolReferenceExpression, isMetadataModuleReferenceExpression, isMetadataSymbolicReferenceExpression, isMetadataSymbolicSpreadExpression, MetadataEntry, MetadataError, MetadataImportedSymbolReferenceExpression, MetadataSourceLocationInfo, MetadataSymbolicCallExpression, MetadataValue} from './schema';\nimport {Symbols} from './symbols';\n\n\n\n// In TypeScript 2.1 the spread element kind was renamed.\nconst spreadElementSyntaxKind: ts.SyntaxKind =\n    (ts.SyntaxKind as any).SpreadElement || (ts.SyntaxKind as any).SpreadElementExpression;\n\nfunction isMethodCallOf(callExpression: ts.CallExpression, memberName: string): boolean {\n  const expression = callExpression.expression;\n  if (expression.kind === ts.SyntaxKind.PropertyAccessExpression) {\n    const propertyAccessExpression = <ts.PropertyAccessExpression>expression;\n    const name = propertyAccessExpression.name;\n    if (name.kind == ts.SyntaxKind.Identifier) {\n      return name.text === memberName;\n    }\n  }\n  return false;\n}\n\nfunction isCallOf(callExpression: ts.CallExpression, ident: string): boolean {\n  const expression = callExpression.expression;\n  if (expression.kind === ts.SyntaxKind.Identifier) {\n    const identifier = <ts.Identifier>expression;\n    return identifier.text === ident;\n  }\n  return false;\n}\n\n/* @internal */\nexport function recordMapEntry<T extends MetadataEntry>(\n    entry: T, node: ts.Node,\n    nodeMap: Map<MetadataValue|ClassMetadata|InterfaceMetadata|FunctionMetadata, ts.Node>,\n    sourceFile?: ts.SourceFile) {\n  if (!nodeMap.has(entry)) {\n    nodeMap.set(entry, node);\n    if (node &&\n        (isMetadataImportedSymbolReferenceExpression(entry) ||\n         isMetadataImportDefaultReference(entry)) &&\n        entry.line == null) {\n      const info = sourceInfo(node, sourceFile);\n      if (info.line != null) entry.line = info.line;\n      if (info.character != null) entry.character = info.character;\n    }\n  }\n  return entry;\n}\n\n/**\n * ts.forEachChild stops iterating children when the callback return a truthy value.\n * This method inverts this to implement an `every` style iterator. It will return\n * true if every call to `cb` returns `true`.\n */\nfunction everyNodeChild(node: ts.Node, cb: (node: ts.Node) => boolean) {\n  return !ts.forEachChild(node, node => !cb(node));\n}\n\nexport function isPrimitive(value: any): boolean {\n  return Object(value) !== value;\n}\n\nfunction isDefined(obj: any): boolean {\n  return obj !== undefined;\n}\n\n// import {propertyName as name} from 'place'\n// import {name} from 'place'\nexport interface ImportSpecifierMetadata {\n  name: string;\n  propertyName?: string;\n}\nexport interface ImportMetadata {\n  defaultName?: string;                      // import d from 'place'\n  namespace?: string;                        // import * as d from 'place'\n  namedImports?: ImportSpecifierMetadata[];  // import {a} from 'place'\n  from: string;                              // from 'place'\n}\n\n\nfunction getSourceFileOfNode(node: ts.Node|undefined): ts.SourceFile {\n  while (node && node.kind != ts.SyntaxKind.SourceFile) {\n    node = node.parent;\n  }\n  return <ts.SourceFile>node;\n}\n\n/* @internal */\nexport function sourceInfo(\n    node: ts.Node|undefined, sourceFile: ts.SourceFile|undefined): MetadataSourceLocationInfo {\n  if (node) {\n    sourceFile = sourceFile || getSourceFileOfNode(node);\n    if (sourceFile) {\n      return ts.getLineAndCharacterOfPosition(sourceFile, node.getStart(sourceFile));\n    }\n  }\n  return {};\n}\n\n/* @internal */\nexport function errorSymbol(\n    message: string, node?: ts.Node, context?: {[name: string]: string},\n    sourceFile?: ts.SourceFile): MetadataError {\n  const result: MetadataError = {__symbolic: 'error', message, ...sourceInfo(node, sourceFile)};\n  if (context) {\n    result.context = context;\n  }\n  return result;\n}\n\n/**\n * Produce a symbolic representation of an expression folding values into their final value when\n * possible.\n */\nexport class Evaluator {\n  constructor(\n      private symbols: Symbols, private nodeMap: Map<MetadataEntry, ts.Node>,\n      private options: CollectorOptions = {},\n      private recordExport?: (name: string, value: MetadataValue) => void) {}\n\n  nameOf(node: ts.Node|undefined): string|MetadataError {\n    if (node && node.kind == ts.SyntaxKind.Identifier) {\n      return (<ts.Identifier>node).text;\n    }\n    const result = node && this.evaluateNode(node);\n    if (isMetadataError(result) || typeof result === 'string') {\n      return result;\n    } else {\n      return errorSymbol(\n          'Name expected', node, {received: (node && node.getText()) || '<missing>'});\n    }\n  }\n\n  /**\n   * Returns true if the expression represented by `node` can be folded into a literal expression.\n   *\n   * For example, a literal is always foldable. This means that literal expressions such as `1.2`\n   * `\"Some value\"` `true` `false` are foldable.\n   *\n   * - An object literal is foldable if all the properties in the literal are foldable.\n   * - An array literal is foldable if all the elements are foldable.\n   * - A call is foldable if it is a call to a Array.prototype.concat or a call to CONST_EXPR.\n   * - A property access is foldable if the object is foldable.\n   * - A array index is foldable if index expression is foldable and the array is foldable.\n   * - Binary operator expressions are foldable if the left and right expressions are foldable and\n   *   it is one of '+', '-', '*', '/', '%', '||', and '&&'.\n   * - An identifier is foldable if a value can be found for its symbol in the evaluator symbol\n   *   table.\n   */\n  public isFoldable(node: ts.Node): boolean {\n    return this.isFoldableWorker(node, new Map<ts.Node, boolean>());\n  }\n\n  private isFoldableWorker(node: ts.Node|undefined, folding: Map<ts.Node, boolean>): boolean {\n    if (node) {\n      switch (node.kind) {\n        case ts.SyntaxKind.ObjectLiteralExpression:\n          return everyNodeChild(node, child => {\n            if (child.kind === ts.SyntaxKind.PropertyAssignment) {\n              const propertyAssignment = <ts.PropertyAssignment>child;\n              return this.isFoldableWorker(propertyAssignment.initializer, folding);\n            }\n            return false;\n          });\n        case ts.SyntaxKind.ArrayLiteralExpression:\n          return everyNodeChild(node, child => this.isFoldableWorker(child, folding));\n        case ts.SyntaxKind.CallExpression:\n          const callExpression = <ts.CallExpression>node;\n          // We can fold a <array>.concat(<v>).\n          if (isMethodCallOf(callExpression, 'concat') &&\n              arrayOrEmpty(callExpression.arguments).length === 1) {\n            const arrayNode = (<ts.PropertyAccessExpression>callExpression.expression).expression;\n            if (this.isFoldableWorker(arrayNode, folding) &&\n                this.isFoldableWorker(callExpression.arguments[0], folding)) {\n              // It needs to be an array.\n              const arrayValue = this.evaluateNode(arrayNode);\n              if (arrayValue && Array.isArray(arrayValue)) {\n                return true;\n              }\n            }\n          }\n\n          // We can fold a call to CONST_EXPR\n          if (isCallOf(callExpression, 'CONST_EXPR') &&\n              arrayOrEmpty(callExpression.arguments).length === 1)\n            return this.isFoldableWorker(callExpression.arguments[0], folding);\n          return false;\n        case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n        case ts.SyntaxKind.StringLiteral:\n        case ts.SyntaxKind.NumericLiteral:\n        case ts.SyntaxKind.NullKeyword:\n        case ts.SyntaxKind.TrueKeyword:\n        case ts.SyntaxKind.FalseKeyword:\n        case ts.SyntaxKind.TemplateHead:\n        case ts.SyntaxKind.TemplateMiddle:\n        case ts.SyntaxKind.TemplateTail:\n          return true;\n        case ts.SyntaxKind.ParenthesizedExpression:\n          const parenthesizedExpression = <ts.ParenthesizedExpression>node;\n          return this.isFoldableWorker(parenthesizedExpression.expression, folding);\n        case ts.SyntaxKind.BinaryExpression:\n          const binaryExpression = <ts.BinaryExpression>node;\n          switch (binaryExpression.operatorToken.kind) {\n            case ts.SyntaxKind.PlusToken:\n            case ts.SyntaxKind.MinusToken:\n            case ts.SyntaxKind.AsteriskToken:\n            case ts.SyntaxKind.SlashToken:\n            case ts.SyntaxKind.PercentToken:\n            case ts.SyntaxKind.AmpersandAmpersandToken:\n            case ts.SyntaxKind.BarBarToken:\n              return this.isFoldableWorker(binaryExpression.left, folding) &&\n                  this.isFoldableWorker(binaryExpression.right, folding);\n            default:\n              return false;\n          }\n        case ts.SyntaxKind.PropertyAccessExpression:\n          const propertyAccessExpression = <ts.PropertyAccessExpression>node;\n          return this.isFoldableWorker(propertyAccessExpression.expression, folding);\n        case ts.SyntaxKind.ElementAccessExpression:\n          const elementAccessExpression = <ts.ElementAccessExpression>node;\n          return this.isFoldableWorker(elementAccessExpression.expression, folding) &&\n              this.isFoldableWorker(elementAccessExpression.argumentExpression, folding);\n        case ts.SyntaxKind.Identifier:\n          let identifier = <ts.Identifier>node;\n          let reference = this.symbols.resolve(identifier.text);\n          if (reference !== undefined && isPrimitive(reference)) {\n            return true;\n          }\n          break;\n        case ts.SyntaxKind.TemplateExpression:\n          const templateExpression = <ts.TemplateExpression>node;\n          return templateExpression.templateSpans.every(\n              span => this.isFoldableWorker(span.expression, folding));\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Produce a JSON serialiable object representing `node`. The foldable values in the expression\n   * tree are folded. For example, a node representing `1 + 2` is folded into `3`.\n   */\n  public evaluateNode(node: ts.Node, preferReference?: boolean): MetadataValue {\n    const t = this;\n    let error: MetadataError|undefined;\n\n    function recordEntry(entry: MetadataValue, node: ts.Node): MetadataValue {\n      if (t.options.substituteExpression) {\n        const newEntry = t.options.substituteExpression(entry, node);\n        if (t.recordExport && newEntry != entry && isMetadataGlobalReferenceExpression(newEntry)) {\n          t.recordExport(newEntry.name, entry);\n        }\n        entry = newEntry;\n      }\n      return recordMapEntry(entry, node, t.nodeMap);\n    }\n\n    function isFoldableError(value: any): value is MetadataError {\n      return !t.options.verboseInvalidExpression && isMetadataError(value);\n    }\n\n    const resolveName = (name: string, preferReference?: boolean): MetadataValue => {\n      const reference = this.symbols.resolve(name, preferReference);\n      if (reference === undefined) {\n        // Encode as a global reference. StaticReflector will check the reference.\n        return recordEntry({__symbolic: 'reference', name}, node);\n      }\n      if (reference && isMetadataSymbolicReferenceExpression(reference)) {\n        return recordEntry({...reference}, node);\n      }\n      return reference;\n    };\n\n    switch (node.kind) {\n      case ts.SyntaxKind.ObjectLiteralExpression:\n        let obj: {[name: string]: any} = {};\n        let quoted: string[] = [];\n        ts.forEachChild(node, child => {\n          switch (child.kind) {\n            case ts.SyntaxKind.ShorthandPropertyAssignment:\n            case ts.SyntaxKind.PropertyAssignment:\n              const assignment = <ts.PropertyAssignment|ts.ShorthandPropertyAssignment>child;\n              if (assignment.name.kind == ts.SyntaxKind.StringLiteral) {\n                const name = (assignment.name as ts.StringLiteral).text;\n                quoted.push(name);\n              }\n              const propertyName = this.nameOf(assignment.name);\n              if (isFoldableError(propertyName)) {\n                error = propertyName;\n                return true;\n              }\n              const propertyValue = isPropertyAssignment(assignment) ?\n                  this.evaluateNode(assignment.initializer, /* preferReference */ true) :\n                  resolveName(propertyName, /* preferReference */ true);\n              if (isFoldableError(propertyValue)) {\n                error = propertyValue;\n                return true;  // Stop the forEachChild.\n              } else {\n                obj[propertyName] = isPropertyAssignment(assignment) ?\n                    recordEntry(propertyValue, assignment.initializer) :\n                    propertyValue;\n              }\n          }\n        });\n        if (error) return error;\n        if (this.options.quotedNames && quoted.length) {\n          obj['$quoted$'] = quoted;\n        }\n        return recordEntry(obj, node);\n      case ts.SyntaxKind.ArrayLiteralExpression:\n        let arr: MetadataValue[] = [];\n        ts.forEachChild(node, child => {\n          const value = this.evaluateNode(child, /* preferReference */ true);\n\n          // Check for error\n          if (isFoldableError(value)) {\n            error = value;\n            return true;  // Stop the forEachChild.\n          }\n\n          // Handle spread expressions\n          if (isMetadataSymbolicSpreadExpression(value)) {\n            if (Array.isArray(value.expression)) {\n              for (const spreadValue of value.expression) {\n                arr.push(spreadValue);\n              }\n              return;\n            }\n          }\n\n          arr.push(value);\n        });\n        if (error) return error;\n        return recordEntry(arr, node);\n      case spreadElementSyntaxKind:\n        let spreadExpression = this.evaluateNode((node as any).expression);\n        return recordEntry({__symbolic: 'spread', expression: spreadExpression}, node);\n      case ts.SyntaxKind.CallExpression:\n        const callExpression = <ts.CallExpression>node;\n        if (isCallOf(callExpression, 'forwardRef') &&\n            arrayOrEmpty(callExpression.arguments).length === 1) {\n          const firstArgument = callExpression.arguments[0];\n          if (firstArgument.kind == ts.SyntaxKind.ArrowFunction) {\n            const arrowFunction = <ts.ArrowFunction>firstArgument;\n            return recordEntry(this.evaluateNode(arrowFunction.body), node);\n          }\n        }\n        const args = arrayOrEmpty(callExpression.arguments).map(arg => this.evaluateNode(arg));\n        if (this.isFoldable(callExpression)) {\n          if (isMethodCallOf(callExpression, 'concat')) {\n            const arrayValue = <MetadataValue[]>this.evaluateNode(\n                (<ts.PropertyAccessExpression>callExpression.expression).expression);\n            if (isFoldableError(arrayValue)) return arrayValue;\n            return arrayValue.concat(args[0]);\n          }\n        }\n        // Always fold a CONST_EXPR even if the argument is not foldable.\n        if (isCallOf(callExpression, 'CONST_EXPR') &&\n            arrayOrEmpty(callExpression.arguments).length === 1) {\n          return recordEntry(args[0], node);\n        }\n        const expression = this.evaluateNode(callExpression.expression);\n        if (isFoldableError(expression)) {\n          return recordEntry(expression, node);\n        }\n        let result: MetadataSymbolicCallExpression = {__symbolic: 'call', expression: expression};\n        if (args && args.length) {\n          result.arguments = args;\n        }\n        return recordEntry(result, node);\n      case ts.SyntaxKind.NewExpression:\n        const newExpression = <ts.NewExpression>node;\n        const newArgs = arrayOrEmpty(newExpression.arguments).map(arg => this.evaluateNode(arg));\n        const newTarget = this.evaluateNode(newExpression.expression);\n        if (isMetadataError(newTarget)) {\n          return recordEntry(newTarget, node);\n        }\n        const call: MetadataSymbolicCallExpression = {__symbolic: 'new', expression: newTarget};\n        if (newArgs.length) {\n          call.arguments = newArgs;\n        }\n        return recordEntry(call, node);\n      case ts.SyntaxKind.PropertyAccessExpression: {\n        const propertyAccessExpression = <ts.PropertyAccessExpression>node;\n        const expression = this.evaluateNode(propertyAccessExpression.expression);\n        if (isFoldableError(expression)) {\n          return recordEntry(expression, node);\n        }\n        const member = this.nameOf(propertyAccessExpression.name);\n        if (isFoldableError(member)) {\n          return recordEntry(member, node);\n        }\n        if (expression && this.isFoldable(propertyAccessExpression.expression))\n          return (<any>expression)[member];\n        if (isMetadataModuleReferenceExpression(expression)) {\n          // A select into a module reference and be converted into a reference to the symbol\n          // in the module\n          return recordEntry(\n              {__symbolic: 'reference', module: expression.module, name: member}, node);\n        }\n        return recordEntry({__symbolic: 'select', expression, member}, node);\n      }\n      case ts.SyntaxKind.ElementAccessExpression: {\n        const elementAccessExpression = <ts.ElementAccessExpression>node;\n        const expression = this.evaluateNode(elementAccessExpression.expression);\n        if (isFoldableError(expression)) {\n          return recordEntry(expression, node);\n        }\n        if (!elementAccessExpression.argumentExpression) {\n          return recordEntry(errorSymbol('Expression form not supported', node), node);\n        }\n        const index = this.evaluateNode(elementAccessExpression.argumentExpression);\n        if (isFoldableError(expression)) {\n          return recordEntry(expression, node);\n        }\n        if (this.isFoldable(elementAccessExpression.expression) &&\n            this.isFoldable(elementAccessExpression.argumentExpression))\n          return (<any>expression)[<string|number>index];\n        return recordEntry({__symbolic: 'index', expression, index}, node);\n      }\n      case ts.SyntaxKind.Identifier:\n        const identifier = <ts.Identifier>node;\n        const name = identifier.text;\n        return resolveName(name, preferReference);\n      case ts.SyntaxKind.TypeReference:\n        const typeReferenceNode = <ts.TypeReferenceNode>node;\n        const typeNameNode = typeReferenceNode.typeName;\n        const getReference: (typeNameNode: ts.Identifier|ts.QualifiedName) => MetadataValue =\n            node => {\n              if (typeNameNode.kind === ts.SyntaxKind.QualifiedName) {\n                const qualifiedName = <ts.QualifiedName>node;\n                const left = this.evaluateNode(qualifiedName.left);\n                if (isMetadataModuleReferenceExpression(left)) {\n                  return recordEntry(\n                      <MetadataImportedSymbolReferenceExpression>{\n                        __symbolic: 'reference',\n                        module: left.module,\n                        name: qualifiedName.right.text\n                      },\n                      node);\n                }\n                // Record a type reference to a declared type as a select.\n                return {__symbolic: 'select', expression: left, member: qualifiedName.right.text};\n              } else {\n                const identifier = <ts.Identifier>typeNameNode;\n                const symbol = this.symbols.resolve(identifier.text);\n                if (isFoldableError(symbol) || isMetadataSymbolicReferenceExpression(symbol)) {\n                  return recordEntry(symbol, node);\n                }\n                return recordEntry(\n                    errorSymbol('Could not resolve type', node, {typeName: identifier.text}), node);\n              }\n            };\n        const typeReference = getReference(typeNameNode);\n        if (isFoldableError(typeReference)) {\n          return recordEntry(typeReference, node);\n        }\n        if (!isMetadataModuleReferenceExpression(typeReference) &&\n            typeReferenceNode.typeArguments && typeReferenceNode.typeArguments.length) {\n          const args = typeReferenceNode.typeArguments.map(element => this.evaluateNode(element));\n          // TODO: Remove typecast when upgraded to 2.0 as it will be correctly inferred.\n          // Some versions of 1.9 do not infer this correctly.\n          (<MetadataImportedSymbolReferenceExpression>typeReference).arguments = args;\n        }\n        return recordEntry(typeReference, node);\n      case ts.SyntaxKind.UnionType:\n        const unionType = <ts.UnionTypeNode>node;\n        // Remove null and undefined from the list of unions.\n        const references =\n            unionType.types\n                .filter(\n                    n => n.kind !== ts.SyntaxKind.UndefinedKeyword &&\n                        !(ts.isLiteralTypeNode(n) && n.literal.kind === ts.SyntaxKind.NullKeyword))\n                .map(n => this.evaluateNode(n));\n\n        // The remmaining reference must be the same. If two have type arguments consider them\n        // different even if the type arguments are the same.\n        let candidate: any = null;\n        for (let i = 0; i < references.length; i++) {\n          const reference = references[i];\n          if (isMetadataSymbolicReferenceExpression(reference)) {\n            if (candidate) {\n              if ((reference as any).name == candidate.name &&\n                  (reference as any).module == candidate.module && !(reference as any).arguments) {\n                candidate = reference;\n              }\n            } else {\n              candidate = reference;\n            }\n          } else {\n            return reference;\n          }\n        }\n        if (candidate) return candidate;\n        break;\n      case ts.SyntaxKind.NoSubstitutionTemplateLiteral:\n      case ts.SyntaxKind.StringLiteral:\n      case ts.SyntaxKind.TemplateHead:\n      case ts.SyntaxKind.TemplateTail:\n      case ts.SyntaxKind.TemplateMiddle:\n        return (<ts.LiteralLikeNode>node).text;\n      case ts.SyntaxKind.NumericLiteral:\n        return parseFloat((<ts.LiteralExpression>node).text);\n      case ts.SyntaxKind.AnyKeyword:\n        return recordEntry({__symbolic: 'reference', name: 'any'}, node);\n      case ts.SyntaxKind.StringKeyword:\n        return recordEntry({__symbolic: 'reference', name: 'string'}, node);\n      case ts.SyntaxKind.NumberKeyword:\n        return recordEntry({__symbolic: 'reference', name: 'number'}, node);\n      case ts.SyntaxKind.BooleanKeyword:\n        return recordEntry({__symbolic: 'reference', name: 'boolean'}, node);\n      case ts.SyntaxKind.ArrayType:\n        const arrayTypeNode = <ts.ArrayTypeNode>node;\n        return recordEntry(\n            {\n              __symbolic: 'reference',\n              name: 'Array',\n              arguments: [this.evaluateNode(arrayTypeNode.elementType)]\n            },\n            node);\n      case ts.SyntaxKind.NullKeyword:\n        return null;\n      case ts.SyntaxKind.TrueKeyword:\n        return true;\n      case ts.SyntaxKind.FalseKeyword:\n        return false;\n      case ts.SyntaxKind.ParenthesizedExpression:\n        const parenthesizedExpression = <ts.ParenthesizedExpression>node;\n        return this.evaluateNode(parenthesizedExpression.expression);\n      case ts.SyntaxKind.TypeAssertionExpression:\n        const typeAssertion = <ts.TypeAssertion>node;\n        return this.evaluateNode(typeAssertion.expression);\n      case ts.SyntaxKind.PrefixUnaryExpression:\n        const prefixUnaryExpression = <ts.PrefixUnaryExpression>node;\n        const operand = this.evaluateNode(prefixUnaryExpression.operand);\n        if (isDefined(operand) && isPrimitive(operand)) {\n          switch (prefixUnaryExpression.operator) {\n            case ts.SyntaxKind.PlusToken:\n              return +(operand as any);\n            case ts.SyntaxKind.MinusToken:\n              return -(operand as any);\n            case ts.SyntaxKind.TildeToken:\n              return ~(operand as any);\n            case ts.SyntaxKind.ExclamationToken:\n              return !operand;\n          }\n        }\n        let operatorText: '+'|'-'|'~'|'!';\n        switch (prefixUnaryExpression.operator) {\n          case ts.SyntaxKind.PlusToken:\n            operatorText = '+';\n            break;\n          case ts.SyntaxKind.MinusToken:\n            operatorText = '-';\n            break;\n          case ts.SyntaxKind.TildeToken:\n            operatorText = '~';\n            break;\n          case ts.SyntaxKind.ExclamationToken:\n            operatorText = '!';\n            break;\n          default:\n            return undefined;\n        }\n        return recordEntry({__symbolic: 'pre', operator: operatorText, operand: operand}, node);\n      case ts.SyntaxKind.BinaryExpression:\n        const binaryExpression = <ts.BinaryExpression>node;\n        const left = this.evaluateNode(binaryExpression.left);\n        const right = this.evaluateNode(binaryExpression.right);\n        if (isDefined(left) && isDefined(right)) {\n          if (isPrimitive(left) && isPrimitive(right))\n            switch (binaryExpression.operatorToken.kind) {\n              case ts.SyntaxKind.BarBarToken:\n                return <any>left || <any>right;\n              case ts.SyntaxKind.AmpersandAmpersandToken:\n                return <any>left && <any>right;\n              case ts.SyntaxKind.AmpersandToken:\n                return <any>left & <any>right;\n              case ts.SyntaxKind.BarToken:\n                return <any>left | <any>right;\n              case ts.SyntaxKind.CaretToken:\n                return <any>left ^ <any>right;\n              case ts.SyntaxKind.EqualsEqualsToken:\n                return <any>left == <any>right;\n              case ts.SyntaxKind.ExclamationEqualsToken:\n                return <any>left != <any>right;\n              case ts.SyntaxKind.EqualsEqualsEqualsToken:\n                return <any>left === <any>right;\n              case ts.SyntaxKind.ExclamationEqualsEqualsToken:\n                return <any>left !== <any>right;\n              case ts.SyntaxKind.LessThanToken:\n                return <any>left < <any>right;\n              case ts.SyntaxKind.GreaterThanToken:\n                return <any>left > <any>right;\n              case ts.SyntaxKind.LessThanEqualsToken:\n                return <any>left <= <any>right;\n              case ts.SyntaxKind.GreaterThanEqualsToken:\n                return <any>left >= <any>right;\n              case ts.SyntaxKind.LessThanLessThanToken:\n                return (<any>left) << (<any>right);\n              case ts.SyntaxKind.GreaterThanGreaterThanToken:\n                return <any>left >> <any>right;\n              case ts.SyntaxKind.GreaterThanGreaterThanGreaterThanToken:\n                return <any>left >>> <any>right;\n              case ts.SyntaxKind.PlusToken:\n                return <any>left + <any>right;\n              case ts.SyntaxKind.MinusToken:\n                return <any>left - <any>right;\n              case ts.SyntaxKind.AsteriskToken:\n                return <any>left * <any>right;\n              case ts.SyntaxKind.SlashToken:\n                return <any>left / <any>right;\n              case ts.SyntaxKind.PercentToken:\n                return <any>left % <any>right;\n            }\n          return recordEntry(\n              {\n                __symbolic: 'binop',\n                operator: binaryExpression.operatorToken.getText(),\n                left: left,\n                right: right\n              },\n              node);\n        }\n        break;\n      case ts.SyntaxKind.ConditionalExpression:\n        const conditionalExpression = <ts.ConditionalExpression>node;\n        const condition = this.evaluateNode(conditionalExpression.condition);\n        const thenExpression = this.evaluateNode(conditionalExpression.whenTrue);\n        const elseExpression = this.evaluateNode(conditionalExpression.whenFalse);\n        if (isPrimitive(condition)) {\n          return condition ? thenExpression : elseExpression;\n        }\n        return recordEntry({__symbolic: 'if', condition, thenExpression, elseExpression}, node);\n      case ts.SyntaxKind.FunctionExpression:\n      case ts.SyntaxKind.ArrowFunction:\n        return recordEntry(errorSymbol('Lambda not supported', node), node);\n      case ts.SyntaxKind.TaggedTemplateExpression:\n        return recordEntry(\n            errorSymbol('Tagged template expressions are not supported in metadata', node), node);\n      case ts.SyntaxKind.TemplateExpression:\n        const templateExpression = <ts.TemplateExpression>node;\n        if (this.isFoldable(node)) {\n          return templateExpression.templateSpans.reduce(\n              (previous, current) => previous + <string>this.evaluateNode(current.expression) +\n                  <string>this.evaluateNode(current.literal),\n              this.evaluateNode(templateExpression.head));\n        } else {\n          return templateExpression.templateSpans.reduce((previous, current) => {\n            const expr = this.evaluateNode(current.expression);\n            const literal = this.evaluateNode(current.literal);\n            if (isFoldableError(expr)) return expr;\n            if (isFoldableError(literal)) return literal;\n            if (typeof previous === 'string' && typeof expr === 'string' &&\n                typeof literal === 'string') {\n              return previous + expr + literal;\n            }\n            let result = expr;\n            if (previous !== '') {\n              result = {__symbolic: 'binop', operator: '+', left: previous, right: expr};\n            }\n            if (literal != '') {\n              result = {__symbolic: 'binop', operator: '+', left: result, right: literal};\n            }\n            return result;\n          }, this.evaluateNode(templateExpression.head));\n        }\n      case ts.SyntaxKind.AsExpression:\n        const asExpression = <ts.AsExpression>node;\n        return this.evaluateNode(asExpression.expression);\n      case ts.SyntaxKind.ClassExpression:\n        return {__symbolic: 'class'};\n    }\n    return recordEntry(errorSymbol('Expression form not supported', node), node);\n  }\n}\n\nfunction isPropertyAssignment(node: ts.Node): node is ts.PropertyAssignment {\n  return node.kind == ts.SyntaxKind.PropertyAssignment;\n}\n\nconst empty = ts.createNodeArray<any>();\n\nfunction arrayOrEmpty<T extends ts.Node>(v: ts.NodeArray<T>|undefined): ts.NodeArray<T> {\n  return v || empty;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}