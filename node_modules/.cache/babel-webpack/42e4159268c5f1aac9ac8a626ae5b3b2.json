{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/view/t2_api\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler/src/render3/view/t2_api.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AST} from '../../expression_parser/ast';\nimport {BoundAttribute, BoundEvent, Element, Node, Reference, Template, TextAttribute, Variable} from '../r3_ast';\n\n\n/*\n * t2 is the replacement for the `TemplateDefinitionBuilder`. It handles the operations of\n * analyzing Angular templates, extracting semantic info, and ultimately producing a template\n * definition function which renders the template using Ivy instructions.\n *\n * t2 data is also utilized by the template type-checking facilities to understand a template enough\n * to generate type-checking code for it.\n */\n\n/**\n * A logical target for analysis, which could contain a template or other types of bindings.\n */\nexport interface Target {\n  template?: Node[];\n}\n\n/**\n * A data structure which can indicate whether a given property name is present or not.\n *\n * This is used to represent the set of inputs or outputs present on a directive, and allows the\n * binder to query for the presence of a mapping for property names.\n */\nexport interface InputOutputPropertySet {\n  hasBindingPropertyName(propertyName: string): boolean;\n}\n\n/**\n * Metadata regarding a directive that's needed to match it against template elements. This is\n * provided by a consumer of the t2 APIs.\n */\nexport interface DirectiveMeta {\n  /**\n   * Name of the directive class (used for debugging).\n   */\n  name: string;\n\n  /** The selector for the directive or `null` if there isn't one. */\n  selector: string|null;\n\n  /**\n   * Whether the directive is a component.\n   */\n  isComponent: boolean;\n\n  /**\n   * Set of inputs which this directive claims.\n   *\n   * Goes from property names to field names.\n   */\n  inputs: InputOutputPropertySet;\n\n  /**\n   * Set of outputs which this directive claims.\n   *\n   * Goes from property names to field names.\n   */\n  outputs: InputOutputPropertySet;\n\n  /**\n   * Name under which the directive is exported, if any (exportAs in Angular).\n   *\n   * Null otherwise\n   */\n  exportAs: string[]|null;\n\n  isStructural: boolean;\n}\n\n/**\n * Interface to the binding API, which processes a template and returns an object similar to the\n * `ts.TypeChecker`.\n *\n * The returned `BoundTarget` has an API for extracting information about the processed target.\n */\nexport interface TargetBinder<D extends DirectiveMeta> {\n  bind(target: Target): BoundTarget<D>;\n}\n\n/**\n * Result of performing the binding operation against a `Target`.\n *\n * The original `Target` is accessible, as well as a suite of methods for extracting binding\n * information regarding the `Target`.\n *\n * @param DirectiveT directive metadata type\n */\nexport interface BoundTarget<DirectiveT extends DirectiveMeta> {\n  /**\n   * Get the original `Target` that was bound.\n   */\n  readonly target: Target;\n\n  /**\n   * For a given template node (either an `Element` or a `Template`), get the set of directives\n   * which matched the node, if any.\n   */\n  getDirectivesOfNode(node: Element|Template): DirectiveT[]|null;\n\n  /**\n   * For a given `Reference`, get the reference's target - either an `Element`, a `Template`, or\n   * a directive on a particular node.\n   */\n  getReferenceTarget(ref: Reference): {directive: DirectiveT, node: Element|Template}|Element\n      |Template|null;\n\n  /**\n   * For a given binding, get the entity to which the binding is being made.\n   *\n   * This will either be a directive or the node itself.\n   */\n  getConsumerOfBinding(binding: BoundAttribute|BoundEvent|TextAttribute): DirectiveT|Element\n      |Template|null;\n\n  /**\n   * If the given `AST` expression refers to a `Reference` or `Variable` within the `Target`, then\n   * return that.\n   *\n   * Otherwise, returns `null`.\n   *\n   * This is only defined for `AST` expressions that read or write to a property of an\n   * `ImplicitReceiver`.\n   */\n  getExpressionTarget(expr: AST): Reference|Variable|null;\n\n  /**\n   * Given a particular `Reference` or `Variable`, get the `Template` which created it.\n   *\n   * All `Variable`s are defined on templates, so this will always return a value for a `Variable`\n   * from the `Target`. For `Reference`s this only returns a value if the `Reference` points to a\n   * `Template`. Returns `null` otherwise.\n   */\n  getTemplateOfSymbol(symbol: Reference|Variable): Template|null;\n\n  /**\n   * Get the nesting level of a particular `Template`.\n   *\n   * This starts at 1 for top-level `Template`s within the `Target` and increases for `Template`s\n   * nested at deeper levels.\n   */\n  getNestingLevel(template: Template): number;\n\n  /**\n   * Get all `Reference`s and `Variables` visible within the given `Template` (or at the top level,\n   * if `null` is passed).\n   */\n  getEntitiesInTemplateScope(template: Template|null): ReadonlySet<Reference|Variable>;\n\n  /**\n   * Get a list of all the directives used by the target.\n   */\n  getUsedDirectives(): DirectiveT[];\n\n  /**\n   * Get a list of all the pipes used by the target.\n   */\n  getUsedPipes(): string[];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}