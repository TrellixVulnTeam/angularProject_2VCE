{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/result\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.traceDynamicValue = exports.describeResolvedType = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var dynamic_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/dynamic\");\n\n  var result_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator/src/result\");\n  /**\n   * Derives a type representation from a resolved value to be reported in a diagnostic.\n   *\n   * @param value The resolved value for which a type representation should be derived.\n   * @param maxDepth The maximum nesting depth of objects and arrays, defaults to 1 level.\n   */\n\n\n  function describeResolvedType(value, maxDepth) {\n    var _a, _b;\n\n    if (maxDepth === void 0) {\n      maxDepth = 1;\n    }\n\n    if (value === null) {\n      return 'null';\n    } else if (value === undefined) {\n      return 'undefined';\n    } else if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string') {\n      return typeof value;\n    } else if (value instanceof Map) {\n      if (maxDepth === 0) {\n        return 'object';\n      }\n\n      var entries = Array.from(value.entries()).map(function (_a) {\n        var _b = tslib_1.__read(_a, 2),\n            key = _b[0],\n            v = _b[1];\n\n        return quoteKey(key) + \": \" + describeResolvedType(v, maxDepth - 1);\n      });\n      return entries.length > 0 ? \"{ \" + entries.join('; ') + \" }\" : '{}';\n    } else if (value instanceof result_1.ResolvedModule) {\n      return '(module)';\n    } else if (value instanceof result_1.EnumValue) {\n      return (_a = value.enumRef.debugName) !== null && _a !== void 0 ? _a : '(anonymous)';\n    } else if (value instanceof imports_1.Reference) {\n      return (_b = value.debugName) !== null && _b !== void 0 ? _b : '(anonymous)';\n    } else if (Array.isArray(value)) {\n      if (maxDepth === 0) {\n        return 'Array';\n      }\n\n      return \"[\" + value.map(function (v) {\n        return describeResolvedType(v, maxDepth - 1);\n      }).join(', ') + \"]\";\n    } else if (value instanceof dynamic_1.DynamicValue) {\n      return '(not statically analyzable)';\n    } else if (value instanceof result_1.KnownFn) {\n      return 'Function';\n    } else {\n      return 'unknown';\n    }\n  }\n\n  exports.describeResolvedType = describeResolvedType;\n\n  function quoteKey(key) {\n    if (/^[a-z0-9_]+$/i.test(key)) {\n      return key;\n    } else {\n      return \"'\" + key.replace(/'/g, '\\\\\\'') + \"'\";\n    }\n  }\n  /**\n   * Creates an array of related information diagnostics for a `DynamicValue` that describe the trace\n   * of why an expression was evaluated as dynamic.\n   *\n   * @param node The node for which a `ts.Diagnostic` is to be created with the trace.\n   * @param value The dynamic value for which a trace should be created.\n   */\n\n\n  function traceDynamicValue(node, value) {\n    return value.accept(new TraceDynamicValueVisitor(node));\n  }\n\n  exports.traceDynamicValue = traceDynamicValue;\n\n  var TraceDynamicValueVisitor =\n  /** @class */\n  function () {\n    function TraceDynamicValueVisitor(node) {\n      this.node = node;\n      this.currentContainerNode = null;\n    }\n\n    TraceDynamicValueVisitor.prototype.visitDynamicInput = function (value) {\n      var trace = value.reason.accept(this);\n\n      if (this.shouldTrace(value.node)) {\n        var info = diagnostics_1.makeRelatedInformation(value.node, 'Unable to evaluate this expression statically.');\n        trace.unshift(info);\n      }\n\n      return trace;\n    };\n\n    TraceDynamicValueVisitor.prototype.visitDynamicString = function (value) {\n      return [diagnostics_1.makeRelatedInformation(value.node, 'A string value could not be determined statically.')];\n    };\n\n    TraceDynamicValueVisitor.prototype.visitExternalReference = function (value) {\n      var name = value.reason.debugName;\n      var description = name !== null ? \"'\" + name + \"'\" : 'an anonymous declaration';\n      return [diagnostics_1.makeRelatedInformation(value.node, \"A value for \" + description + \" cannot be determined statically, as it is an external declaration.\")];\n    };\n\n    TraceDynamicValueVisitor.prototype.visitComplexFunctionCall = function (value) {\n      return [diagnostics_1.makeRelatedInformation(value.node, 'Unable to evaluate function call of complex function. A function must have exactly one return statement.'), diagnostics_1.makeRelatedInformation(value.reason.node, 'Function is declared here.')];\n    };\n\n    TraceDynamicValueVisitor.prototype.visitInvalidExpressionType = function (value) {\n      return [diagnostics_1.makeRelatedInformation(value.node, 'Unable to evaluate an invalid expression.')];\n    };\n\n    TraceDynamicValueVisitor.prototype.visitUnknown = function (value) {\n      return [diagnostics_1.makeRelatedInformation(value.node, 'Unable to evaluate statically.')];\n    };\n\n    TraceDynamicValueVisitor.prototype.visitUnknownIdentifier = function (value) {\n      return [diagnostics_1.makeRelatedInformation(value.node, 'Unknown reference.')];\n    };\n\n    TraceDynamicValueVisitor.prototype.visitUnsupportedSyntax = function (value) {\n      return [diagnostics_1.makeRelatedInformation(value.node, 'This syntax is not supported.')];\n    };\n    /**\n     * Determines whether the dynamic value reported for the node should be traced, i.e. if it is not\n     * part of the container for which the most recent trace was created.\n     */\n\n\n    TraceDynamicValueVisitor.prototype.shouldTrace = function (node) {\n      if (node === this.node) {\n        // Do not include a dynamic value for the origin node, as the main diagnostic is already\n        // reported on that node.\n        return false;\n      }\n\n      var container = getContainerNode(node);\n\n      if (container === this.currentContainerNode) {\n        // The node is part of the same container as the previous trace entry, so this dynamic value\n        // should not become part of the trace.\n        return false;\n      }\n\n      this.currentContainerNode = container;\n      return true;\n    };\n\n    return TraceDynamicValueVisitor;\n  }();\n  /**\n   * Determines the closest parent node that is to be considered as container, which is used to reduce\n   * the granularity of tracing the dynamic values to a single entry per container. Currently, full\n   * statements and destructuring patterns are considered as container.\n   */\n\n\n  function getContainerNode(node) {\n    var currentNode = node;\n\n    while (currentNode !== undefined) {\n      switch (currentNode.kind) {\n        case ts.SyntaxKind.ExpressionStatement:\n        case ts.SyntaxKind.VariableStatement:\n        case ts.SyntaxKind.ReturnStatement:\n        case ts.SyntaxKind.IfStatement:\n        case ts.SyntaxKind.SwitchStatement:\n        case ts.SyntaxKind.DoStatement:\n        case ts.SyntaxKind.WhileStatement:\n        case ts.SyntaxKind.ForStatement:\n        case ts.SyntaxKind.ForInStatement:\n        case ts.SyntaxKind.ForOfStatement:\n        case ts.SyntaxKind.ContinueStatement:\n        case ts.SyntaxKind.BreakStatement:\n        case ts.SyntaxKind.ThrowStatement:\n        case ts.SyntaxKind.ObjectBindingPattern:\n        case ts.SyntaxKind.ArrayBindingPattern:\n          return currentNode;\n      }\n\n      currentNode = currentNode.parent;\n    }\n\n    return node.getSourceFile();\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/partial_evaluator/src/diagnostics.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {makeRelatedInformation} from '../../diagnostics';\nimport {Reference} from '../../imports';\nimport {FunctionDefinition} from '../../reflection';\nimport {DynamicValue, DynamicValueVisitor} from './dynamic';\nimport {EnumValue, KnownFn, ResolvedModule, ResolvedValue} from './result';\n\n/**\n * Derives a type representation from a resolved value to be reported in a diagnostic.\n *\n * @param value The resolved value for which a type representation should be derived.\n * @param maxDepth The maximum nesting depth of objects and arrays, defaults to 1 level.\n */\nexport function describeResolvedType(value: ResolvedValue, maxDepth: number = 1): string {\n  if (value === null) {\n    return 'null';\n  } else if (value === undefined) {\n    return 'undefined';\n  } else if (typeof value === 'number' || typeof value === 'boolean' || typeof value === 'string') {\n    return typeof value;\n  } else if (value instanceof Map) {\n    if (maxDepth === 0) {\n      return 'object';\n    }\n    const entries = Array.from(value.entries()).map(([key, v]) => {\n      return `${quoteKey(key)}: ${describeResolvedType(v, maxDepth - 1)}`;\n    });\n    return entries.length > 0 ? `{ ${entries.join('; ')} }` : '{}';\n  } else if (value instanceof ResolvedModule) {\n    return '(module)';\n  } else if (value instanceof EnumValue) {\n    return value.enumRef.debugName ?? '(anonymous)';\n  } else if (value instanceof Reference) {\n    return value.debugName ?? '(anonymous)';\n  } else if (Array.isArray(value)) {\n    if (maxDepth === 0) {\n      return 'Array';\n    }\n    return `[${value.map(v => describeResolvedType(v, maxDepth - 1)).join(', ')}]`;\n  } else if (value instanceof DynamicValue) {\n    return '(not statically analyzable)';\n  } else if (value instanceof KnownFn) {\n    return 'Function';\n  } else {\n    return 'unknown';\n  }\n}\n\nfunction quoteKey(key: string): string {\n  if (/^[a-z0-9_]+$/i.test(key)) {\n    return key;\n  } else {\n    return `'${key.replace(/'/g, '\\\\\\'')}'`;\n  }\n}\n\n/**\n * Creates an array of related information diagnostics for a `DynamicValue` that describe the trace\n * of why an expression was evaluated as dynamic.\n *\n * @param node The node for which a `ts.Diagnostic` is to be created with the trace.\n * @param value The dynamic value for which a trace should be created.\n */\nexport function traceDynamicValue(\n    node: ts.Node, value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n  return value.accept(new TraceDynamicValueVisitor(node));\n}\n\nclass TraceDynamicValueVisitor implements DynamicValueVisitor<ts.DiagnosticRelatedInformation[]> {\n  private currentContainerNode: ts.Node|null = null;\n\n  constructor(private node: ts.Node) {}\n\n  visitDynamicInput(value: DynamicValue<DynamicValue>): ts.DiagnosticRelatedInformation[] {\n    const trace = value.reason.accept(this);\n    if (this.shouldTrace(value.node)) {\n      const info =\n          makeRelatedInformation(value.node, 'Unable to evaluate this expression statically.');\n      trace.unshift(info);\n    }\n    return trace;\n  }\n\n  visitDynamicString(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(\n        value.node, 'A string value could not be determined statically.')];\n  }\n\n  visitExternalReference(value: DynamicValue<Reference<ts.Declaration>>):\n      ts.DiagnosticRelatedInformation[] {\n    const name = value.reason.debugName;\n    const description = name !== null ? `'${name}'` : 'an anonymous declaration';\n    return [makeRelatedInformation(\n        value.node,\n        `A value for ${\n            description} cannot be determined statically, as it is an external declaration.`)];\n  }\n\n  visitComplexFunctionCall(value: DynamicValue<FunctionDefinition>):\n      ts.DiagnosticRelatedInformation[] {\n    return [\n      makeRelatedInformation(\n          value.node,\n          'Unable to evaluate function call of complex function. A function must have exactly one return statement.'),\n      makeRelatedInformation(value.reason.node, 'Function is declared here.')\n    ];\n  }\n\n  visitInvalidExpressionType(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'Unable to evaluate an invalid expression.')];\n  }\n\n  visitUnknown(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'Unable to evaluate statically.')];\n  }\n\n  visitUnknownIdentifier(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'Unknown reference.')];\n  }\n\n  visitUnsupportedSyntax(value: DynamicValue): ts.DiagnosticRelatedInformation[] {\n    return [makeRelatedInformation(value.node, 'This syntax is not supported.')];\n  }\n\n  /**\n   * Determines whether the dynamic value reported for the node should be traced, i.e. if it is not\n   * part of the container for which the most recent trace was created.\n   */\n  private shouldTrace(node: ts.Node): boolean {\n    if (node === this.node) {\n      // Do not include a dynamic value for the origin node, as the main diagnostic is already\n      // reported on that node.\n      return false;\n    }\n\n    const container = getContainerNode(node);\n    if (container === this.currentContainerNode) {\n      // The node is part of the same container as the previous trace entry, so this dynamic value\n      // should not become part of the trace.\n      return false;\n    }\n\n    this.currentContainerNode = container;\n    return true;\n  }\n}\n\n/**\n * Determines the closest parent node that is to be considered as container, which is used to reduce\n * the granularity of tracing the dynamic values to a single entry per container. Currently, full\n * statements and destructuring patterns are considered as container.\n */\nfunction getContainerNode(node: ts.Node): ts.Node {\n  let currentNode: ts.Node|undefined = node;\n  while (currentNode !== undefined) {\n    switch (currentNode.kind) {\n      case ts.SyntaxKind.ExpressionStatement:\n      case ts.SyntaxKind.VariableStatement:\n      case ts.SyntaxKind.ReturnStatement:\n      case ts.SyntaxKind.IfStatement:\n      case ts.SyntaxKind.SwitchStatement:\n      case ts.SyntaxKind.DoStatement:\n      case ts.SyntaxKind.WhileStatement:\n      case ts.SyntaxKind.ForStatement:\n      case ts.SyntaxKind.ForInStatement:\n      case ts.SyntaxKind.ForOfStatement:\n      case ts.SyntaxKind.ContinueStatement:\n      case ts.SyntaxKind.BreakStatement:\n      case ts.SyntaxKind.ThrowStatement:\n      case ts.SyntaxKind.ObjectBindingPattern:\n      case ts.SyntaxKind.ArrayBindingPattern:\n        return currentNode;\n    }\n\n    currentNode = currentNode.parent;\n  }\n  return node.getSourceFile();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}