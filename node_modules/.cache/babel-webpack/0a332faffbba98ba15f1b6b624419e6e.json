{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/util/src/visitor\", [\"require\", \"exports\", \"tslib\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Visitor = exports.visit = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n  /**\n   * Visit a node with the given visitor and return a transformed copy.\n   */\n\n\n  function visit(node, visitor, context) {\n    return visitor._visit(node, context);\n  }\n\n  exports.visit = visit;\n  /**\n   * Abstract base class for visitors, which processes certain nodes specially to allow insertion\n   * of other nodes before them.\n   */\n\n  var Visitor =\n  /** @class */\n  function () {\n    function Visitor() {\n      /**\n       * Maps statements to an array of statements that should be inserted before them.\n       */\n      this._before = new Map();\n      /**\n       * Maps statements to an array of statements that should be inserted after them.\n       */\n\n      this._after = new Map();\n    }\n    /**\n     * Visit a class declaration, returning at least the transformed declaration and optionally other\n     * nodes to insert before the declaration.\n     */\n\n\n    Visitor.prototype.visitClassDeclaration = function (node) {\n      return {\n        node: node\n      };\n    };\n\n    Visitor.prototype._visitListEntryNode = function (node, visitor) {\n      var result = visitor(node);\n\n      if (result.before !== undefined) {\n        // Record that some nodes should be inserted before the given declaration. The declaration's\n        // parent's _visit call is responsible for performing this insertion.\n        this._before.set(result.node, result.before);\n      }\n\n      if (result.after !== undefined) {\n        // Same with nodes that should be inserted after.\n        this._after.set(result.node, result.after);\n      }\n\n      return result.node;\n    };\n    /**\n     * Visit types of nodes which don't have their own explicit visitor.\n     */\n\n\n    Visitor.prototype.visitOtherNode = function (node) {\n      return node;\n    };\n    /**\n     * @internal\n     */\n\n\n    Visitor.prototype._visit = function (node, context) {\n      var _this = this; // First, visit the node. visitedNode starts off as `null` but should be set after visiting\n      // is completed.\n\n\n      var visitedNode = null;\n      node = ts.visitEachChild(node, function (child) {\n        return _this._visit(child, context);\n      }, context);\n\n      if (ts.isClassDeclaration(node)) {\n        visitedNode = this._visitListEntryNode(node, function (node) {\n          return _this.visitClassDeclaration(node);\n        });\n      } else {\n        visitedNode = this.visitOtherNode(node);\n      } // If the visited node has a `statements` array then process them, maybe replacing the visited\n      // node and adding additional statements.\n\n\n      if (hasStatements(visitedNode)) {\n        visitedNode = this._maybeProcessStatements(visitedNode);\n      }\n\n      return visitedNode;\n    };\n\n    Visitor.prototype._maybeProcessStatements = function (node) {\n      var _this = this; // Shortcut - if every statement doesn't require nodes to be prepended or appended,\n      // this is a no-op.\n\n\n      if (node.statements.every(function (stmt) {\n        return !_this._before.has(stmt) && !_this._after.has(stmt);\n      })) {\n        return node;\n      } // There are statements to prepend, so clone the original node.\n\n\n      var clone = ts.getMutableClone(node); // Build a new list of statements and patch it onto the clone.\n\n      var newStatements = [];\n      clone.statements.forEach(function (stmt) {\n        if (_this._before.has(stmt)) {\n          newStatements.push.apply(newStatements, tslib_1.__spread(_this._before.get(stmt)));\n\n          _this._before.delete(stmt);\n        }\n\n        newStatements.push(stmt);\n\n        if (_this._after.has(stmt)) {\n          newStatements.push.apply(newStatements, tslib_1.__spread(_this._after.get(stmt)));\n\n          _this._after.delete(stmt);\n        }\n      });\n      clone.statements = ts.createNodeArray(newStatements, node.statements.hasTrailingComma);\n      return clone;\n    };\n\n    return Visitor;\n  }();\n\n  exports.Visitor = Visitor;\n\n  function hasStatements(node) {\n    var block = node;\n    return block.statements !== undefined && Array.isArray(block.statements);\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/util/src/visitor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\n/**\n * Result type of visiting a node that's typically an entry in a list, which allows specifying that\n * nodes should be added before the visited node in the output.\n */\nexport type VisitListEntryResult<B extends ts.Node, T extends B> = {\n  node: T,\n  before?: B[],\n  after?: B[],\n};\n\n/**\n * Visit a node with the given visitor and return a transformed copy.\n */\nexport function visit<T extends ts.Node>(\n    node: T, visitor: Visitor, context: ts.TransformationContext): T {\n  return visitor._visit(node, context);\n}\n\n/**\n * Abstract base class for visitors, which processes certain nodes specially to allow insertion\n * of other nodes before them.\n */\nexport abstract class Visitor {\n  /**\n   * Maps statements to an array of statements that should be inserted before them.\n   */\n  private _before = new Map<ts.Node, ts.Statement[]>();\n\n  /**\n   * Maps statements to an array of statements that should be inserted after them.\n   */\n  private _after = new Map<ts.Node, ts.Statement[]>();\n\n  /**\n   * Visit a class declaration, returning at least the transformed declaration and optionally other\n   * nodes to insert before the declaration.\n   */\n  visitClassDeclaration(node: ts.ClassDeclaration):\n      VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n    return {node};\n  }\n\n  private _visitListEntryNode<T extends ts.Statement>(\n      node: T, visitor: (node: T) => VisitListEntryResult<ts.Statement, T>): T {\n    const result = visitor(node);\n    if (result.before !== undefined) {\n      // Record that some nodes should be inserted before the given declaration. The declaration's\n      // parent's _visit call is responsible for performing this insertion.\n      this._before.set(result.node, result.before);\n    }\n    if (result.after !== undefined) {\n      // Same with nodes that should be inserted after.\n      this._after.set(result.node, result.after);\n    }\n    return result.node;\n  }\n\n  /**\n   * Visit types of nodes which don't have their own explicit visitor.\n   */\n  visitOtherNode<T extends ts.Node>(node: T): T {\n    return node;\n  }\n\n  /**\n   * @internal\n   */\n  _visit<T extends ts.Node>(node: T, context: ts.TransformationContext): T {\n    // First, visit the node. visitedNode starts off as `null` but should be set after visiting\n    // is completed.\n    let visitedNode: T|null = null;\n\n    node = ts.visitEachChild(node, child => this._visit(child, context), context) as T;\n\n    if (ts.isClassDeclaration(node)) {\n      visitedNode =\n          this._visitListEntryNode(\n              node, (node: ts.ClassDeclaration) => this.visitClassDeclaration(node)) as typeof node;\n    } else {\n      visitedNode = this.visitOtherNode(node);\n    }\n\n    // If the visited node has a `statements` array then process them, maybe replacing the visited\n    // node and adding additional statements.\n    if (hasStatements(visitedNode)) {\n      visitedNode = this._maybeProcessStatements(visitedNode);\n    }\n\n    return visitedNode;\n  }\n\n  private _maybeProcessStatements<T extends ts.Node&{statements: ts.NodeArray<ts.Statement>}>(\n      node: T): T {\n    // Shortcut - if every statement doesn't require nodes to be prepended or appended,\n    // this is a no-op.\n    if (node.statements.every(stmt => !this._before.has(stmt) && !this._after.has(stmt))) {\n      return node;\n    }\n\n    // There are statements to prepend, so clone the original node.\n    const clone = ts.getMutableClone(node);\n\n    // Build a new list of statements and patch it onto the clone.\n    const newStatements: ts.Statement[] = [];\n    clone.statements.forEach(stmt => {\n      if (this._before.has(stmt)) {\n        newStatements.push(...(this._before.get(stmt)! as ts.Statement[]));\n        this._before.delete(stmt);\n      }\n      newStatements.push(stmt);\n      if (this._after.has(stmt)) {\n        newStatements.push(...(this._after.get(stmt)! as ts.Statement[]));\n        this._after.delete(stmt);\n      }\n    });\n    clone.statements = ts.createNodeArray(newStatements, node.statements.hasTrailingComma);\n    return clone;\n  }\n}\n\nfunction hasStatements(node: ts.Node): node is ts.Node&{statements: ts.NodeArray<ts.Statement>} {\n  const block = node as {statements?: any};\n  return block.statements !== undefined && Array.isArray(block.statements);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}