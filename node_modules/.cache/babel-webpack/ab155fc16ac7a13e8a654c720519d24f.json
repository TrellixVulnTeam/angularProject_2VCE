{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/entry_point_finder/program_based_entry_point_finder\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\", \"@angular/compiler-cli/ngcc/src/dependencies/esm_dependency_host\", \"@angular/compiler-cli/ngcc/src/dependencies/module_resolver\", \"@angular/compiler-cli/ngcc/src/path_mappings\", \"@angular/compiler-cli/ngcc/src/entry_point_finder/tracing_entry_point_finder\", \"@angular/compiler-cli/ngcc/src/entry_point_finder/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ProgramBasedEntryPointFinder = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var dependency_host_1 = require(\"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\");\n\n  var esm_dependency_host_1 = require(\"@angular/compiler-cli/ngcc/src/dependencies/esm_dependency_host\");\n\n  var module_resolver_1 = require(\"@angular/compiler-cli/ngcc/src/dependencies/module_resolver\");\n\n  var path_mappings_1 = require(\"@angular/compiler-cli/ngcc/src/path_mappings\");\n\n  var tracing_entry_point_finder_1 = require(\"@angular/compiler-cli/ngcc/src/entry_point_finder/tracing_entry_point_finder\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/entry_point_finder/utils\");\n  /**\n   * An EntryPointFinder that starts from the files in the program defined by the given tsconfig.json\n   * and only returns entry-points that are dependencies of these files.\n   *\n   * This is faster than searching the entire file-system for all the entry-points,\n   * and is used primarily by the CLI integration.\n   */\n\n\n  var ProgramBasedEntryPointFinder =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ProgramBasedEntryPointFinder, _super);\n\n    function ProgramBasedEntryPointFinder(fs, config, logger, resolver, entryPointCollector, entryPointManifest, basePath, tsConfig, projectPath) {\n      var _this = _super.call(this, fs, config, logger, resolver, basePath, path_mappings_1.getPathMappingsFromTsConfig(fs, tsConfig, projectPath)) || this;\n\n      _this.entryPointCollector = entryPointCollector;\n      _this.entryPointManifest = entryPointManifest;\n      _this.tsConfig = tsConfig;\n      _this.entryPointsWithDependencies = null;\n      return _this;\n    }\n    /**\n     * Return an array containing the external import paths that were extracted from the source-files\n     * of the program defined by the tsconfig.json.\n     */\n\n\n    ProgramBasedEntryPointFinder.prototype.getInitialEntryPointPaths = function () {\n      var _this = this;\n\n      var moduleResolver = new module_resolver_1.ModuleResolver(this.fs, this.pathMappings, ['', '.ts', '/index.ts']);\n      var host = new esm_dependency_host_1.EsmDependencyHost(this.fs, moduleResolver);\n      var dependencies = dependency_host_1.createDependencyInfo();\n      var rootFiles = this.tsConfig.rootNames.map(function (rootName) {\n        return _this.fs.resolve(rootName);\n      });\n      this.logger.debug(\"Using the program from \" + this.tsConfig.project + \" to seed the entry-point finding.\");\n      this.logger.debug(\"Collecting dependencies from the following files:\" + rootFiles.map(function (file) {\n        return \"\\n- \" + file;\n      }));\n      host.collectDependenciesInFiles(rootFiles, dependencies);\n      return Array.from(dependencies.dependencies);\n    };\n    /**\n     * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including\n     * paths to other entry-points that this entry-point depends upon.\n     *\n     * In this entry-point finder, we use the `EntryPointManifest` to avoid computing each\n     * entry-point's dependencies in the case that this had been done previously.\n     *\n     * @param entryPointPath the path to the entry-point whose information and dependencies are to be\n     *     retrieved or computed.\n     *\n     * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by\n     *     Angular or cannot be determined.\n     */\n\n\n    ProgramBasedEntryPointFinder.prototype.getEntryPointWithDeps = function (entryPointPath) {\n      var entryPoints = this.findOrLoadEntryPoints();\n\n      if (!entryPoints.has(entryPointPath)) {\n        return null;\n      }\n\n      var entryPointWithDeps = entryPoints.get(entryPointPath);\n\n      if (!entryPointWithDeps.entryPoint.compiledByAngular) {\n        return null;\n      }\n\n      return entryPointWithDeps;\n    };\n    /**\n     * Walk the base paths looking for entry-points or load this information from an entry-point\n     * manifest, if available.\n     */\n\n\n    ProgramBasedEntryPointFinder.prototype.findOrLoadEntryPoints = function () {\n      var e_1, _a, e_2, _b;\n\n      if (this.entryPointsWithDependencies === null) {\n        var entryPointsWithDependencies = this.entryPointsWithDependencies = new Map();\n\n        try {\n          for (var _c = tslib_1.__values(this.getBasePaths()), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var basePath = _d.value;\n            var entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) || this.walkBasePathForPackages(basePath);\n\n            try {\n              for (var entryPoints_1 = (e_2 = void 0, tslib_1.__values(entryPoints)), entryPoints_1_1 = entryPoints_1.next(); !entryPoints_1_1.done; entryPoints_1_1 = entryPoints_1.next()) {\n                var e = entryPoints_1_1.value;\n                entryPointsWithDependencies.set(e.entryPoint.path, e);\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (entryPoints_1_1 && !entryPoints_1_1.done && (_b = entryPoints_1.return)) _b.call(entryPoints_1);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n\n      return this.entryPointsWithDependencies;\n    };\n    /**\n     * Search the `basePath` for possible Angular packages and entry-points.\n     *\n     * @param basePath The path at which to start the search.\n     * @returns an array of `EntryPoint`s that were found within `basePath`.\n     */\n\n\n    ProgramBasedEntryPointFinder.prototype.walkBasePathForPackages = function (basePath) {\n      var _this = this;\n\n      this.logger.debug(\"No manifest found for \" + basePath + \" so walking the directories for entry-points.\");\n      var entryPoints = utils_1.trackDuration(function () {\n        return _this.entryPointCollector.walkDirectoryForPackages(basePath);\n      }, function (duration) {\n        return _this.logger.debug(\"Walking \" + basePath + \" for entry-points took \" + duration + \"s.\");\n      });\n      this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);\n      return entryPoints;\n    };\n\n    return ProgramBasedEntryPointFinder;\n  }(tracing_entry_point_finder_1.TracingEntryPointFinder);\n\n  exports.ProgramBasedEntryPointFinder = ProgramBasedEntryPointFinder;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/entry_point_finder/program_based_entry_point_finder.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {ParsedConfiguration} from '../../../src/perform_compile';\n\nimport {createDependencyInfo, EntryPointWithDependencies} from '../dependencies/dependency_host';\nimport {DependencyResolver} from '../dependencies/dependency_resolver';\nimport {EsmDependencyHost} from '../dependencies/esm_dependency_host';\nimport {ModuleResolver} from '../dependencies/module_resolver';\nimport {NgccConfiguration} from '../packages/configuration';\nimport {EntryPointManifest} from '../packages/entry_point_manifest';\nimport {getPathMappingsFromTsConfig} from '../path_mappings';\n\nimport {EntryPointCollector} from './entry_point_collector';\nimport {TracingEntryPointFinder} from './tracing_entry_point_finder';\nimport {trackDuration} from './utils';\n\n/**\n * An EntryPointFinder that starts from the files in the program defined by the given tsconfig.json\n * and only returns entry-points that are dependencies of these files.\n *\n * This is faster than searching the entire file-system for all the entry-points,\n * and is used primarily by the CLI integration.\n */\nexport class ProgramBasedEntryPointFinder extends TracingEntryPointFinder {\n  private entryPointsWithDependencies: Map<AbsoluteFsPath, EntryPointWithDependencies>|null = null;\n\n  constructor(\n      fs: ReadonlyFileSystem, config: NgccConfiguration, logger: Logger,\n      resolver: DependencyResolver, private entryPointCollector: EntryPointCollector,\n      private entryPointManifest: EntryPointManifest, basePath: AbsoluteFsPath,\n      private tsConfig: ParsedConfiguration, projectPath: AbsoluteFsPath) {\n    super(\n        fs, config, logger, resolver, basePath,\n        getPathMappingsFromTsConfig(fs, tsConfig, projectPath));\n  }\n\n  /**\n   * Return an array containing the external import paths that were extracted from the source-files\n   * of the program defined by the tsconfig.json.\n   */\n  protected getInitialEntryPointPaths(): AbsoluteFsPath[] {\n    const moduleResolver = new ModuleResolver(this.fs, this.pathMappings, ['', '.ts', '/index.ts']);\n    const host = new EsmDependencyHost(this.fs, moduleResolver);\n    const dependencies = createDependencyInfo();\n    const rootFiles = this.tsConfig.rootNames.map(rootName => this.fs.resolve(rootName));\n    this.logger.debug(\n        `Using the program from ${this.tsConfig.project} to seed the entry-point finding.`);\n    this.logger.debug(\n        `Collecting dependencies from the following files:` + rootFiles.map(file => `\\n- ${file}`));\n    host.collectDependenciesInFiles(rootFiles, dependencies);\n    return Array.from(dependencies.dependencies);\n  }\n\n  /**\n   * For the given `entryPointPath`, compute, or retrieve, the entry-point information, including\n   * paths to other entry-points that this entry-point depends upon.\n   *\n   * In this entry-point finder, we use the `EntryPointManifest` to avoid computing each\n   * entry-point's dependencies in the case that this had been done previously.\n   *\n   * @param entryPointPath the path to the entry-point whose information and dependencies are to be\n   *     retrieved or computed.\n   *\n   * @returns the entry-point and its dependencies or `null` if the entry-point is not compiled by\n   *     Angular or cannot be determined.\n   */\n  protected getEntryPointWithDeps(entryPointPath: AbsoluteFsPath): EntryPointWithDependencies|null {\n    const entryPoints = this.findOrLoadEntryPoints();\n    if (!entryPoints.has(entryPointPath)) {\n      return null;\n    }\n    const entryPointWithDeps = entryPoints.get(entryPointPath)!;\n    if (!entryPointWithDeps.entryPoint.compiledByAngular) {\n      return null;\n    }\n    return entryPointWithDeps;\n  }\n\n  /**\n   * Walk the base paths looking for entry-points or load this information from an entry-point\n   * manifest, if available.\n   */\n  private findOrLoadEntryPoints(): Map<AbsoluteFsPath, EntryPointWithDependencies> {\n    if (this.entryPointsWithDependencies === null) {\n      const entryPointsWithDependencies = this.entryPointsWithDependencies =\n          new Map<AbsoluteFsPath, EntryPointWithDependencies>();\n      for (const basePath of this.getBasePaths()) {\n        const entryPoints = this.entryPointManifest.readEntryPointsUsingManifest(basePath) ||\n            this.walkBasePathForPackages(basePath);\n        for (const e of entryPoints) {\n          entryPointsWithDependencies.set(e.entryPoint.path, e);\n        }\n      }\n    }\n    return this.entryPointsWithDependencies;\n  }\n\n  /**\n   * Search the `basePath` for possible Angular packages and entry-points.\n   *\n   * @param basePath The path at which to start the search.\n   * @returns an array of `EntryPoint`s that were found within `basePath`.\n   */\n  walkBasePathForPackages(basePath: AbsoluteFsPath): EntryPointWithDependencies[] {\n    this.logger.debug(\n        `No manifest found for ${basePath} so walking the directories for entry-points.`);\n    const entryPoints = trackDuration(\n        () => this.entryPointCollector.walkDirectoryForPackages(basePath),\n        duration => this.logger.debug(`Walking ${basePath} for entry-points took ${duration}s.`));\n    this.entryPointManifest.writeEntryPointManifest(basePath, entryPoints);\n    return entryPoints;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}