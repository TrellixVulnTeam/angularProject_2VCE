{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/source_file_cache\", [\"require\", \"exports\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.createModuleResolutionCache = exports.EntryPointFileCache = exports.isAngularDts = exports.isDefaultLibrary = exports.SharedFileCache = void 0;\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n  var ts = require(\"typescript\");\n  /**\n   * A cache that holds on to source files that can be shared for processing all entry-points in a\n   * single invocation of ngcc. In particular, the following files are shared across all entry-points\n   * through this cache:\n   *\n   * 1. Default library files such as `lib.dom.d.ts` and `lib.es5.d.ts`. These files don't change\n   *    and some are very large, so parsing is expensive. Therefore, the parsed `ts.SourceFile`s for\n   *    the default library files are cached.\n   * 2. The typings of @angular scoped packages. The typing files for @angular packages are typically\n   *    used in the entry-points that ngcc processes, so benefit from a single source file cache.\n   *    Especially `@angular/core/core.d.ts` is large and expensive to parse repeatedly. In contrast\n   *    to default library files, we have to account for these files to be invalidated during a single\n   *    invocation of ngcc, as ngcc will overwrite the .d.ts files during its processing.\n   *\n   * The lifecycle of this cache corresponds with a single invocation of ngcc. Separate invocations,\n   * e.g. the CLI's synchronous module resolution fallback will therefore all have their own cache.\n   * This allows for the source file cache to be garbage collected once ngcc processing has completed.\n   */\n\n\n  var SharedFileCache =\n  /** @class */\n  function () {\n    function SharedFileCache(fs) {\n      this.fs = fs;\n      this.sfCache = new Map();\n    }\n    /**\n     * Loads a `ts.SourceFile` if the provided `fileName` is deemed appropriate to be cached. To\n     * optimize for memory usage, only files that are generally used in all entry-points are cached.\n     * If `fileName` is not considered to benefit from caching or the requested file does not exist,\n     * then `undefined` is returned.\n     */\n\n\n    SharedFileCache.prototype.getCachedSourceFile = function (fileName) {\n      var absPath = this.fs.resolve(fileName);\n\n      if (isDefaultLibrary(absPath, this.fs)) {\n        return this.getStableCachedFile(absPath);\n      } else if (isAngularDts(absPath, this.fs)) {\n        return this.getVolatileCachedFile(absPath);\n      } else {\n        return undefined;\n      }\n    };\n    /**\n     * Attempts to load the source file from the cache, or parses the file into a `ts.SourceFile` if\n     * it's not yet cached. This method assumes that the file will not be modified for the duration\n     * that this cache is valid for. If that assumption does not hold, the `getVolatileCachedFile`\n     * method is to be used instead.\n     */\n\n\n    SharedFileCache.prototype.getStableCachedFile = function (absPath) {\n      if (!this.sfCache.has(absPath)) {\n        var content = readFile(absPath, this.fs);\n\n        if (content === undefined) {\n          return undefined;\n        }\n\n        var sf = ts.createSourceFile(absPath, content, ts.ScriptTarget.ES2015);\n        this.sfCache.set(absPath, sf);\n      }\n\n      return this.sfCache.get(absPath);\n    };\n    /**\n     * In contrast to `getStableCachedFile`, this method always verifies that the cached source file\n     * is the same as what's stored on disk. This is done for files that are expected to change during\n     * ngcc's processing, such as @angular scoped packages for which the .d.ts files are overwritten\n     * by ngcc. If the contents on disk have changed compared to a previously cached source file, the\n     * content from disk is re-parsed and the cache entry is replaced.\n     */\n\n\n    SharedFileCache.prototype.getVolatileCachedFile = function (absPath) {\n      var content = readFile(absPath, this.fs);\n\n      if (content === undefined) {\n        return undefined;\n      }\n\n      if (!this.sfCache.has(absPath) || this.sfCache.get(absPath).text !== content) {\n        var sf = ts.createSourceFile(absPath, content, ts.ScriptTarget.ES2015);\n        this.sfCache.set(absPath, sf);\n      }\n\n      return this.sfCache.get(absPath);\n    };\n\n    return SharedFileCache;\n  }();\n\n  exports.SharedFileCache = SharedFileCache;\n  var DEFAULT_LIB_PATTERN = ['node_modules', 'typescript', 'lib', /^lib\\..+\\.d\\.ts$/];\n  /**\n   * Determines whether the provided path corresponds with a default library file inside of the\n   * typescript package.\n   *\n   * @param absPath The path for which to determine if it corresponds with a default library file.\n   * @param fs The filesystem to use for inspecting the path.\n   */\n\n  function isDefaultLibrary(absPath, fs) {\n    return isFile(absPath, DEFAULT_LIB_PATTERN, fs);\n  }\n\n  exports.isDefaultLibrary = isDefaultLibrary;\n  var ANGULAR_DTS_PATTERN = ['node_modules', '@angular', /./, /\\.d\\.ts$/];\n  /**\n   * Determines whether the provided path corresponds with a .d.ts file inside of an @angular\n   * scoped package. This logic only accounts for the .d.ts files in the root, which is sufficient\n   * to find the large, flattened entry-point files that benefit from caching.\n   *\n   * @param absPath The path for which to determine if it corresponds with an @angular .d.ts file.\n   * @param fs The filesystem to use for inspecting the path.\n   */\n\n  function isAngularDts(absPath, fs) {\n    return isFile(absPath, ANGULAR_DTS_PATTERN, fs);\n  }\n\n  exports.isAngularDts = isAngularDts;\n  /**\n   * Helper function to determine whether a file corresponds with a given pattern of segments.\n   *\n   * @param path The path for which to determine if it corresponds with the provided segments.\n   * @param segments Array of segments; the `path` must have ending segments that match the\n   * patterns in this array.\n   * @param fs The filesystem to use for inspecting the path.\n   */\n\n  function isFile(path, segments, fs) {\n    for (var i = segments.length - 1; i >= 0; i--) {\n      var pattern = segments[i];\n      var segment = fs.basename(path);\n\n      if (typeof pattern === 'string') {\n        if (pattern !== segment) {\n          return false;\n        }\n      } else {\n        if (!pattern.test(segment)) {\n          return false;\n        }\n      }\n\n      path = fs.dirname(path);\n    }\n\n    return true;\n  }\n  /**\n   * A cache for processing a single entry-point. This exists to share `ts.SourceFile`s between the\n   * source and typing programs that are created for a single program.\n   */\n\n\n  var EntryPointFileCache =\n  /** @class */\n  function () {\n    function EntryPointFileCache(fs, sharedFileCache) {\n      this.fs = fs;\n      this.sharedFileCache = sharedFileCache;\n      this.sfCache = new Map();\n    }\n    /**\n     * Returns and caches a parsed `ts.SourceFile` for the provided `fileName`. If the `fileName` is\n     * cached in the shared file cache, that result is used. Otherwise, the source file is cached\n     * internally. This method returns `undefined` if the requested file does not exist.\n     *\n     * @param fileName The path of the file to retrieve a source file for.\n     * @param languageVersion The language version to use for parsing the file.\n     */\n\n\n    EntryPointFileCache.prototype.getCachedSourceFile = function (fileName, languageVersion) {\n      var staticSf = this.sharedFileCache.getCachedSourceFile(fileName);\n\n      if (staticSf !== undefined) {\n        return staticSf;\n      }\n\n      var absPath = this.fs.resolve(fileName);\n\n      if (this.sfCache.has(absPath)) {\n        return this.sfCache.get(absPath);\n      }\n\n      var content = readFile(absPath, this.fs);\n\n      if (content === undefined) {\n        return undefined;\n      }\n\n      var sf = ts.createSourceFile(fileName, content, languageVersion);\n      this.sfCache.set(absPath, sf);\n      return sf;\n    };\n\n    return EntryPointFileCache;\n  }();\n\n  exports.EntryPointFileCache = EntryPointFileCache;\n\n  function readFile(absPath, fs) {\n    if (!fs.exists(absPath) || !fs.stat(absPath).isFile()) {\n      return undefined;\n    }\n\n    return fs.readFile(absPath);\n  }\n  /**\n   * Creates a `ts.ModuleResolutionCache` that uses the provided filesystem for path operations.\n   *\n   * @param fs The filesystem to use for path operations.\n   */\n\n\n  function createModuleResolutionCache(fs) {\n    return ts.createModuleResolutionCache(fs.pwd(), function (fileName) {\n      return fs.isCaseSensitive() ? fileName : fileName.toLowerCase();\n    });\n  }\n\n  exports.createModuleResolutionCache = createModuleResolutionCache;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/source_file_cache.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\nimport {AbsoluteFsPath, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\n\n/**\n * A cache that holds on to source files that can be shared for processing all entry-points in a\n * single invocation of ngcc. In particular, the following files are shared across all entry-points\n * through this cache:\n *\n * 1. Default library files such as `lib.dom.d.ts` and `lib.es5.d.ts`. These files don't change\n *    and some are very large, so parsing is expensive. Therefore, the parsed `ts.SourceFile`s for\n *    the default library files are cached.\n * 2. The typings of @angular scoped packages. The typing files for @angular packages are typically\n *    used in the entry-points that ngcc processes, so benefit from a single source file cache.\n *    Especially `@angular/core/core.d.ts` is large and expensive to parse repeatedly. In contrast\n *    to default library files, we have to account for these files to be invalidated during a single\n *    invocation of ngcc, as ngcc will overwrite the .d.ts files during its processing.\n *\n * The lifecycle of this cache corresponds with a single invocation of ngcc. Separate invocations,\n * e.g. the CLI's synchronous module resolution fallback will therefore all have their own cache.\n * This allows for the source file cache to be garbage collected once ngcc processing has completed.\n */\nexport class SharedFileCache {\n  private sfCache = new Map<AbsoluteFsPath, ts.SourceFile>();\n\n  constructor(private fs: ReadonlyFileSystem) {}\n\n  /**\n   * Loads a `ts.SourceFile` if the provided `fileName` is deemed appropriate to be cached. To\n   * optimize for memory usage, only files that are generally used in all entry-points are cached.\n   * If `fileName` is not considered to benefit from caching or the requested file does not exist,\n   * then `undefined` is returned.\n   */\n  getCachedSourceFile(fileName: string): ts.SourceFile|undefined {\n    const absPath = this.fs.resolve(fileName);\n    if (isDefaultLibrary(absPath, this.fs)) {\n      return this.getStableCachedFile(absPath);\n    } else if (isAngularDts(absPath, this.fs)) {\n      return this.getVolatileCachedFile(absPath);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Attempts to load the source file from the cache, or parses the file into a `ts.SourceFile` if\n   * it's not yet cached. This method assumes that the file will not be modified for the duration\n   * that this cache is valid for. If that assumption does not hold, the `getVolatileCachedFile`\n   * method is to be used instead.\n   */\n  private getStableCachedFile(absPath: AbsoluteFsPath): ts.SourceFile|undefined {\n    if (!this.sfCache.has(absPath)) {\n      const content = readFile(absPath, this.fs);\n      if (content === undefined) {\n        return undefined;\n      }\n      const sf = ts.createSourceFile(absPath, content, ts.ScriptTarget.ES2015);\n      this.sfCache.set(absPath, sf);\n    }\n    return this.sfCache.get(absPath)!;\n  }\n\n  /**\n   * In contrast to `getStableCachedFile`, this method always verifies that the cached source file\n   * is the same as what's stored on disk. This is done for files that are expected to change during\n   * ngcc's processing, such as @angular scoped packages for which the .d.ts files are overwritten\n   * by ngcc. If the contents on disk have changed compared to a previously cached source file, the\n   * content from disk is re-parsed and the cache entry is replaced.\n   */\n  private getVolatileCachedFile(absPath: AbsoluteFsPath): ts.SourceFile|undefined {\n    const content = readFile(absPath, this.fs);\n    if (content === undefined) {\n      return undefined;\n    }\n    if (!this.sfCache.has(absPath) || this.sfCache.get(absPath)!.text !== content) {\n      const sf = ts.createSourceFile(absPath, content, ts.ScriptTarget.ES2015);\n      this.sfCache.set(absPath, sf);\n    }\n    return this.sfCache.get(absPath)!;\n  }\n}\n\nconst DEFAULT_LIB_PATTERN = ['node_modules', 'typescript', 'lib', /^lib\\..+\\.d\\.ts$/];\n\n/**\n * Determines whether the provided path corresponds with a default library file inside of the\n * typescript package.\n *\n * @param absPath The path for which to determine if it corresponds with a default library file.\n * @param fs The filesystem to use for inspecting the path.\n */\nexport function isDefaultLibrary(absPath: AbsoluteFsPath, fs: ReadonlyFileSystem): boolean {\n  return isFile(absPath, DEFAULT_LIB_PATTERN, fs);\n}\n\nconst ANGULAR_DTS_PATTERN = ['node_modules', '@angular', /./, /\\.d\\.ts$/];\n\n/**\n * Determines whether the provided path corresponds with a .d.ts file inside of an @angular\n * scoped package. This logic only accounts for the .d.ts files in the root, which is sufficient\n * to find the large, flattened entry-point files that benefit from caching.\n *\n * @param absPath The path for which to determine if it corresponds with an @angular .d.ts file.\n * @param fs The filesystem to use for inspecting the path.\n */\nexport function isAngularDts(absPath: AbsoluteFsPath, fs: ReadonlyFileSystem): boolean {\n  return isFile(absPath, ANGULAR_DTS_PATTERN, fs);\n}\n\n/**\n * Helper function to determine whether a file corresponds with a given pattern of segments.\n *\n * @param path The path for which to determine if it corresponds with the provided segments.\n * @param segments Array of segments; the `path` must have ending segments that match the\n * patterns in this array.\n * @param fs The filesystem to use for inspecting the path.\n */\nfunction isFile(\n    path: AbsoluteFsPath, segments: ReadonlyArray<string|RegExp>, fs: ReadonlyFileSystem): boolean {\n  for (let i = segments.length - 1; i >= 0; i--) {\n    const pattern = segments[i];\n    const segment = fs.basename(path);\n    if (typeof pattern === 'string') {\n      if (pattern !== segment) {\n        return false;\n      }\n    } else {\n      if (!pattern.test(segment)) {\n        return false;\n      }\n    }\n    path = fs.dirname(path);\n  }\n  return true;\n}\n\n/**\n * A cache for processing a single entry-point. This exists to share `ts.SourceFile`s between the\n * source and typing programs that are created for a single program.\n */\nexport class EntryPointFileCache {\n  private readonly sfCache = new Map<AbsoluteFsPath, ts.SourceFile>();\n\n  constructor(private fs: ReadonlyFileSystem, private sharedFileCache: SharedFileCache) {}\n\n  /**\n   * Returns and caches a parsed `ts.SourceFile` for the provided `fileName`. If the `fileName` is\n   * cached in the shared file cache, that result is used. Otherwise, the source file is cached\n   * internally. This method returns `undefined` if the requested file does not exist.\n   *\n   * @param fileName The path of the file to retrieve a source file for.\n   * @param languageVersion The language version to use for parsing the file.\n   */\n  getCachedSourceFile(fileName: string, languageVersion: ts.ScriptTarget): ts.SourceFile|undefined {\n    const staticSf = this.sharedFileCache.getCachedSourceFile(fileName);\n    if (staticSf !== undefined) {\n      return staticSf;\n    }\n\n    const absPath = this.fs.resolve(fileName);\n    if (this.sfCache.has(absPath)) {\n      return this.sfCache.get(absPath);\n    }\n\n    const content = readFile(absPath, this.fs);\n    if (content === undefined) {\n      return undefined;\n    }\n    const sf = ts.createSourceFile(fileName, content, languageVersion);\n    this.sfCache.set(absPath, sf);\n    return sf;\n  }\n}\n\nfunction readFile(absPath: AbsoluteFsPath, fs: ReadonlyFileSystem): string|undefined {\n  if (!fs.exists(absPath) || !fs.stat(absPath).isFile()) {\n    return undefined;\n  }\n  return fs.readFile(absPath);\n}\n\n/**\n * Creates a `ts.ModuleResolutionCache` that uses the provided filesystem for path operations.\n *\n * @param fs The filesystem to use for path operations.\n */\nexport function createModuleResolutionCache(fs: ReadonlyFileSystem): ts.ModuleResolutionCache {\n  return ts.createModuleResolutionCache(fs.pwd(), fileName => {\n    return fs.isCaseSensitive() ? fileName : fileName.toLowerCase();\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}