{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar validateOptions = require(\"schema-utils\");\n\nvar schema = require(\"../../schemas/plugins/optimize/OccurrenceOrderModuleIdsPlugin.json\");\n/** @typedef {import(\"../../declarations/plugins/optimize/OccurrenceOrderModuleIdsPlugin\").OccurrenceOrderModuleIdsPluginOptions} OccurrenceOrderModuleIdsPluginOptions */\n\n\nvar OccurrenceOrderModuleIdsPlugin = /*#__PURE__*/function () {\n  /**\n   * @param {OccurrenceOrderModuleIdsPluginOptions=} options options object\n   */\n  function OccurrenceOrderModuleIdsPlugin() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, OccurrenceOrderModuleIdsPlugin);\n\n    validateOptions(schema, options, \"Occurrence Order Module Ids Plugin\");\n    this.options = options;\n  }\n\n  _createClass(OccurrenceOrderModuleIdsPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      var prioritiseInitial = this.options.prioritiseInitial;\n      compiler.hooks.compilation.tap(\"OccurrenceOrderModuleIdsPlugin\", function (compilation) {\n        compilation.hooks.optimizeModuleOrder.tap(\"OccurrenceOrderModuleIdsPlugin\", function (modules) {\n          var occursInInitialChunksMap = new Map();\n          var occursInAllChunksMap = new Map();\n          var initialChunkChunkMap = new Map();\n          var entryCountMap = new Map();\n\n          var _iterator = _createForOfIteratorHelper(modules),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var _m = _step.value;\n              var initial = 0;\n              var entry = 0;\n\n              var _iterator4 = _createForOfIteratorHelper(_m.chunksIterable),\n                  _step4;\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var c = _step4.value;\n                  if (c.canBeInitial()) initial++;\n                  if (c.entryModule === _m) entry++;\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n\n              initialChunkChunkMap.set(_m, initial);\n              entryCountMap.set(_m, entry);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          var countOccursInEntry = function countOccursInEntry(sum, r) {\n            if (!r.module) {\n              return sum;\n            }\n\n            var count = initialChunkChunkMap.get(r.module);\n\n            if (!count) {\n              return sum;\n            }\n\n            return sum + count;\n          };\n\n          var countOccurs = function countOccurs(sum, r) {\n            if (!r.module) {\n              return sum;\n            }\n\n            var factor = 1;\n\n            if (typeof r.dependency.getNumberOfIdOccurrences === \"function\") {\n              factor = r.dependency.getNumberOfIdOccurrences();\n            }\n\n            if (factor === 0) {\n              return sum;\n            }\n\n            return sum + factor * r.module.getNumberOfChunks();\n          };\n\n          if (prioritiseInitial) {\n            var _iterator2 = _createForOfIteratorHelper(modules),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var m = _step2.value;\n                var result = m.reasons.reduce(countOccursInEntry, 0) + initialChunkChunkMap.get(m) + entryCountMap.get(m);\n                occursInInitialChunksMap.set(m, result);\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n          }\n\n          var originalOrder = new Map();\n          var i = 0;\n\n          var _iterator3 = _createForOfIteratorHelper(modules),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var _m2 = _step3.value;\n\n              var _result = _m2.reasons.reduce(countOccurs, 0) + _m2.getNumberOfChunks() + entryCountMap.get(_m2);\n\n              occursInAllChunksMap.set(_m2, _result);\n              originalOrder.set(_m2, i++);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n\n          modules.sort(function (a, b) {\n            if (prioritiseInitial) {\n              var aEntryOccurs = occursInInitialChunksMap.get(a);\n              var bEntryOccurs = occursInInitialChunksMap.get(b);\n              if (aEntryOccurs > bEntryOccurs) return -1;\n              if (aEntryOccurs < bEntryOccurs) return 1;\n            }\n\n            var aOccurs = occursInAllChunksMap.get(a);\n            var bOccurs = occursInAllChunksMap.get(b);\n            if (aOccurs > bOccurs) return -1;\n            if (aOccurs < bOccurs) return 1;\n            var orgA = originalOrder.get(a);\n            var orgB = originalOrder.get(b);\n            return orgA - orgB;\n          });\n        });\n      });\n    }\n  }]);\n\n  return OccurrenceOrderModuleIdsPlugin;\n}();\n\nmodule.exports = OccurrenceOrderModuleIdsPlugin;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack/lib/optimize/OccurrenceModuleOrderPlugin.js"],"names":["validateOptions","require","schema","OccurrenceOrderModuleIdsPlugin","options","compiler","prioritiseInitial","hooks","compilation","tap","optimizeModuleOrder","modules","occursInInitialChunksMap","Map","occursInAllChunksMap","initialChunkChunkMap","entryCountMap","m","initial","entry","chunksIterable","c","canBeInitial","entryModule","set","countOccursInEntry","sum","r","module","count","get","countOccurs","factor","dependency","getNumberOfIdOccurrences","getNumberOfChunks","result","reasons","reduce","originalOrder","i","sort","a","b","aEntryOccurs","bEntryOccurs","aOccurs","bOccurs","orgA","orgB","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/optimize/OccurrenceOrderModuleIdsPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/optimize/OccurrenceOrderModuleIdsPlugin\").OccurrenceOrderModuleIdsPluginOptions} OccurrenceOrderModuleIdsPluginOptions */\n\nclass OccurrenceOrderModuleIdsPlugin {\n\t/**\n\t * @param {OccurrenceOrderModuleIdsPluginOptions=} options options object\n\t */\n\tconstructor(options = {}) {\n\t\tvalidateOptions(schema, options, \"Occurrence Order Module Ids Plugin\");\n\t\tthis.options = options;\n\t}\n\n\tapply(compiler) {\n\t\tconst prioritiseInitial = this.options.prioritiseInitial;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"OccurrenceOrderModuleIdsPlugin\",\n\t\t\tcompilation => {\n\t\t\t\tcompilation.hooks.optimizeModuleOrder.tap(\n\t\t\t\t\t\"OccurrenceOrderModuleIdsPlugin\",\n\t\t\t\t\tmodules => {\n\t\t\t\t\t\tconst occursInInitialChunksMap = new Map();\n\t\t\t\t\t\tconst occursInAllChunksMap = new Map();\n\n\t\t\t\t\t\tconst initialChunkChunkMap = new Map();\n\t\t\t\t\t\tconst entryCountMap = new Map();\n\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\tlet initial = 0;\n\t\t\t\t\t\t\tlet entry = 0;\n\t\t\t\t\t\t\tfor (const c of m.chunksIterable) {\n\t\t\t\t\t\t\t\tif (c.canBeInitial()) initial++;\n\t\t\t\t\t\t\t\tif (c.entryModule === m) entry++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinitialChunkChunkMap.set(m, initial);\n\t\t\t\t\t\t\tentryCountMap.set(m, entry);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst countOccursInEntry = (sum, r) => {\n\t\t\t\t\t\t\tif (!r.module) {\n\t\t\t\t\t\t\t\treturn sum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst count = initialChunkChunkMap.get(r.module);\n\t\t\t\t\t\t\tif (!count) {\n\t\t\t\t\t\t\t\treturn sum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn sum + count;\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst countOccurs = (sum, r) => {\n\t\t\t\t\t\t\tif (!r.module) {\n\t\t\t\t\t\t\t\treturn sum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet factor = 1;\n\t\t\t\t\t\t\tif (typeof r.dependency.getNumberOfIdOccurrences === \"function\") {\n\t\t\t\t\t\t\t\tfactor = r.dependency.getNumberOfIdOccurrences();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (factor === 0) {\n\t\t\t\t\t\t\t\treturn sum;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn sum + factor * r.module.getNumberOfChunks();\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif (prioritiseInitial) {\n\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\t\tm.reasons.reduce(countOccursInEntry, 0) +\n\t\t\t\t\t\t\t\t\tinitialChunkChunkMap.get(m) +\n\t\t\t\t\t\t\t\t\tentryCountMap.get(m);\n\t\t\t\t\t\t\t\toccursInInitialChunksMap.set(m, result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst originalOrder = new Map();\n\t\t\t\t\t\tlet i = 0;\n\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\tm.reasons.reduce(countOccurs, 0) +\n\t\t\t\t\t\t\t\tm.getNumberOfChunks() +\n\t\t\t\t\t\t\t\tentryCountMap.get(m);\n\t\t\t\t\t\t\toccursInAllChunksMap.set(m, result);\n\t\t\t\t\t\t\toriginalOrder.set(m, i++);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodules.sort((a, b) => {\n\t\t\t\t\t\t\tif (prioritiseInitial) {\n\t\t\t\t\t\t\t\tconst aEntryOccurs = occursInInitialChunksMap.get(a);\n\t\t\t\t\t\t\t\tconst bEntryOccurs = occursInInitialChunksMap.get(b);\n\t\t\t\t\t\t\t\tif (aEntryOccurs > bEntryOccurs) return -1;\n\t\t\t\t\t\t\t\tif (aEntryOccurs < bEntryOccurs) return 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst aOccurs = occursInAllChunksMap.get(a);\n\t\t\t\t\t\t\tconst bOccurs = occursInAllChunksMap.get(b);\n\t\t\t\t\t\t\tif (aOccurs > bOccurs) return -1;\n\t\t\t\t\t\t\tif (aOccurs < bOccurs) return 1;\n\t\t\t\t\t\t\tconst orgA = originalOrder.get(a);\n\t\t\t\t\t\t\tconst orgB = originalOrder.get(b);\n\t\t\t\t\t\t\treturn orgA - orgB;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = OccurrenceOrderModuleIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}