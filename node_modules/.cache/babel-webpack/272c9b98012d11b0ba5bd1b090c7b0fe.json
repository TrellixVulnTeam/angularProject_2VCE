{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar pLimit = require('p-limit');\n\nvar EndError = /*#__PURE__*/function (_Error) {\n  _inherits(EndError, _Error);\n\n  var _super = _createSuper(EndError);\n\n  function EndError(value) {\n    var _this;\n\n    _classCallCheck(this, EndError);\n\n    _this = _super.call(this);\n    _this.value = value;\n    return _this;\n  }\n\n  return EndError;\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // The input can also be a promise, so we await it\n\n\nvar testElement = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(element, tester) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = tester;\n            _context.next = 3;\n            return element;\n\n          case 3:\n            _context.t1 = _context.sent;\n            return _context.abrupt(\"return\", (0, _context.t0)(_context.t1));\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function testElement(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // The input can also be a promise, so we `Promise.all()` them both\n\n\nvar finder = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(element) {\n    var values;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return Promise.all(element);\n\n          case 2:\n            values = _context2.sent;\n\n            if (!(values[1] === true)) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new EndError(values[0]);\n\n          case 5:\n            return _context2.abrupt(\"return\", false);\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function finder(_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar pLocate = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(iterable, tester, options) {\n    var limit, items, checkLimit;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = _objectSpread({\n              concurrency: Infinity,\n              preserveOrder: true\n            }, options);\n            limit = pLimit(options.concurrency); // Start all the promises concurrently with optional limit\n\n            items = _toConsumableArray(iterable).map(function (element) {\n              return [element, limit(testElement, element, tester)];\n            }); // Check the promises either serially or concurrently\n\n            checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n            _context3.prev = 4;\n            _context3.next = 7;\n            return Promise.all(items.map(function (element) {\n              return checkLimit(finder, element);\n            }));\n\n          case 7:\n            _context3.next = 14;\n            break;\n\n          case 9:\n            _context3.prev = 9;\n            _context3.t0 = _context3[\"catch\"](4);\n\n            if (!(_context3.t0 instanceof EndError)) {\n              _context3.next = 13;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", _context3.t0.value);\n\n          case 13:\n            throw _context3.t0;\n\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[4, 9]]);\n  }));\n\n  return function pLocate(_x4, _x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nmodule.exports = pLocate; // TODO: Remove this for the next major release\n\nmodule.exports.default = pLocate;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/find-cache-dir/node_modules/p-locate/index.js"],"names":["pLimit","require","EndError","value","Error","testElement","element","tester","finder","Promise","all","values","pLocate","iterable","options","concurrency","Infinity","preserveOrder","limit","items","map","checkLimit","module","exports","default"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;AACA,IAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;IAEMC,Q;;;;;AACL,oBAAYC,KAAZ,EAAmB;AAAA;;AAAA;;AAClB;AACA,UAAKA,KAAL,GAAaA,KAAb;AAFkB;AAGlB;;;iCAJqBC,K,IAOvB;;;AACA,IAAMC,WAAW;AAAA,sEAAG,iBAAOC,OAAP,EAAgBC,MAAhB;AAAA;AAAA;AAAA;AAAA;AAAA,0BAA2BA,MAA3B;AAAA;AAAA,mBAAwCD,OAAxC;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAXD,WAAW;AAAA;AAAA;AAAA,GAAjB,C,CAEA;;;AACA,IAAMG,MAAM;AAAA,uEAAG,kBAAMF,OAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBACOG,OAAO,CAACC,GAAR,CAAYJ,OAAZ,CADP;;AAAA;AACRK,YAAAA,MADQ;;AAAA,kBAEVA,MAAM,CAAC,CAAD,CAAN,KAAc,IAFJ;AAAA;AAAA;AAAA;;AAAA,kBAGP,IAAIT,QAAJ,CAAaS,MAAM,CAAC,CAAD,CAAnB,CAHO;;AAAA;AAAA,8CAMP,KANO;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAANH,MAAM;AAAA;AAAA;AAAA,GAAZ;;AASA,IAAMI,OAAO;AAAA,uEAAG,kBAAOC,QAAP,EAAiBN,MAAjB,EAAyBO,OAAzB;AAAA;AAAA;AAAA;AAAA;AAAA;AACfA,YAAAA,OAAO;AACNC,cAAAA,WAAW,EAAEC,QADP;AAENC,cAAAA,aAAa,EAAE;AAFT,eAGHH,OAHG,CAAP;AAMMI,YAAAA,KAPS,GAODlB,MAAM,CAACc,OAAO,CAACC,WAAT,CAPL,EASf;;AACMI,YAAAA,KAVS,GAUD,mBAAIN,QAAJ,EAAcO,GAAd,CAAkB,UAAAd,OAAO;AAAA,qBAAI,CAACA,OAAD,EAAUY,KAAK,CAACb,WAAD,EAAcC,OAAd,EAAuBC,MAAvB,CAAf,CAAJ;AAAA,aAAzB,CAVC,EAYf;;AACMc,YAAAA,UAbS,GAaIrB,MAAM,CAACc,OAAO,CAACG,aAAR,GAAwB,CAAxB,GAA4BD,QAA7B,CAbV;AAAA;AAAA;AAAA,mBAgBRP,OAAO,CAACC,GAAR,CAAYS,KAAK,CAACC,GAAN,CAAU,UAAAd,OAAO;AAAA,qBAAIe,UAAU,CAACb,MAAD,EAASF,OAAT,CAAd;AAAA,aAAjB,CAAZ,CAhBQ;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,kBAkBV,wBAAiBJ,QAlBP;AAAA;AAAA;AAAA;;AAAA,8CAmBN,aAAMC,KAnBA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAAH;;AAAA,kBAAPS,OAAO;AAAA;AAAA;AAAA,GAAb;;AA0BAU,MAAM,CAACC,OAAP,GAAiBX,OAAjB,C,CACA;;AACAU,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyBZ,OAAzB","sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n\toptions = {\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true,\n\t\t...options\n\t};\n\n\tconst limit = pLimit(options.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n};\n\nmodule.exports = pLocate;\n// TODO: Remove this for the next major release\nmodule.exports.default = pLocate;\n"]},"metadata":{},"sourceType":"script"}