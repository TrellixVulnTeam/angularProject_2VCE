{"ast":null,"code":"var path = require('path');\n\nvar log = require('../logger').create('launcher');\n\nvar env = process.env;\n\nfunction ProcessLauncher(spawn, tempDir, timer, processKillTimeout) {\n  var self = this;\n  var onExitCallback;\n  var killTimeout = processKillTimeout || 2000; // Will hold output from the spawned child process\n\n  var streamedOutputs = {\n    stdout: '',\n    stderr: ''\n  };\n  this._tempDir = tempDir.getPath(\"/karma-\".concat(this.id.toString()));\n  this.on('start', function (url) {\n    tempDir.create(self._tempDir);\n\n    self._start(url);\n  });\n  this.on('kill', function (done) {\n    if (!self._process) {\n      return process.nextTick(done);\n    }\n\n    onExitCallback = done;\n\n    self._process.kill();\n\n    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout);\n  });\n\n  this._start = function (url) {\n    self._execCommand(self._getCommand(), self._getOptions(url));\n  };\n\n  this._getCommand = function () {\n    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform];\n  };\n\n  this._getOptions = function (url) {\n    return [url];\n  }; // Normalize the command, remove quotes (spawn does not like them).\n\n\n  this._normalizeCommand = function (cmd) {\n    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) && '\\'`\"'.includes(cmd.charAt(0))) {\n      cmd = cmd.substring(1, cmd.length - 1);\n      log.warn(\"The path should not be quoted.\\n  Normalized the path to \".concat(cmd));\n    }\n\n    return path.normalize(cmd);\n  };\n\n  this._onStdout = function (data) {\n    streamedOutputs.stdout += data;\n  };\n\n  this._onStderr = function (data) {\n    streamedOutputs.stderr += data;\n  };\n\n  this._execCommand = function (cmd, args) {\n    if (!cmd) {\n      log.error(\"No binary for \".concat(self.name, \" browser on your platform.\\n  Please, set \\\"\").concat(self.ENV_CMD, \"\\\" env variable.\")); // disable restarting\n\n      self._retryLimit = -1;\n      return self._clearTempDirAndReportDone('no binary');\n    }\n\n    cmd = this._normalizeCommand(cmd);\n    log.debug(cmd + ' ' + args.join(' '));\n    self._process = spawn(cmd, args);\n    var errorOutput = '';\n\n    self._process.stdout.on('data', self._onStdout);\n\n    self._process.stderr.on('data', self._onStderr);\n\n    self._process.on('exit', function (code, signal) {\n      self._onProcessExit(code, signal, errorOutput);\n    });\n\n    self._process.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        self._retryLimit = -1;\n        errorOutput = \"Can not find the binary \".concat(cmd, \"\\n\\tPlease set env variable \").concat(self.ENV_CMD);\n      } else if (err.code === 'EACCES') {\n        self._retryLimit = -1;\n        errorOutput = \"Permission denied accessing the binary \".concat(cmd, \"\\n\\tMaybe it's a directory?\");\n      } else {\n        errorOutput += err.toString();\n      }\n    });\n\n    self._process.stderr.on('data', function (errBuff) {\n      errorOutput += errBuff.toString();\n    });\n  };\n\n  this._onProcessExit = function (code, signal, errorOutput) {\n    log.debug(\"Process \".concat(self.name, \" exited with code \").concat(code, \" and signal \").concat(signal));\n    var error = null;\n\n    if (self.state === self.STATE_BEING_CAPTURED) {\n      log.error(\"Cannot start \".concat(self.name, \"\\n\\t\").concat(errorOutput));\n      error = 'cannot start';\n    }\n\n    if (self.state === self.STATE_CAPTURED) {\n      log.error(\"\".concat(self.name, \" crashed.\\n\\t\").concat(errorOutput));\n      error = 'crashed';\n    }\n\n    if (error) {\n      log.error(\"\".concat(self.name, \" stdout: \").concat(streamedOutputs.stdout));\n      log.error(\"\".concat(self.name, \" stderr: \").concat(streamedOutputs.stderr));\n    }\n\n    self._process = null;\n    streamedOutputs.stdout = '';\n    streamedOutputs.stderr = '';\n\n    if (self._killTimer) {\n      timer.clearTimeout(self._killTimer);\n      self._killTimer = null;\n    }\n\n    self._clearTempDirAndReportDone(error);\n  };\n\n  this._clearTempDirAndReportDone = function (error) {\n    tempDir.remove(self._tempDir, function () {\n      self._done(error);\n\n      if (onExitCallback) {\n        onExitCallback();\n        onExitCallback = null;\n      }\n    });\n  };\n\n  this._onKillTimeout = function () {\n    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {\n      return;\n    }\n\n    log.warn(\"\".concat(self.name, \" was not killed in \").concat(killTimeout, \" ms, sending SIGKILL.\"));\n\n    self._process.kill('SIGKILL'); // NOTE: https://github.com/karma-runner/karma/pull/1184\n    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.\n    // If a process gets into a state where it doesn't respond in a reasonable amount of time\n    // Karma should warn, and continue as though the kill succeeded.\n    // This a certainly suboptimal, but it is better than having the test harness hang waiting\n    // for a zombie child process to exit.\n\n\n    self._killTimer = timer.setTimeout(function () {\n      log.warn(\"\".concat(self.name, \" was not killed by SIGKILL in \").concat(killTimeout, \" ms, continuing.\"));\n\n      self._onProcessExit(-1, null, '');\n    }, killTimeout);\n  };\n}\n\nProcessLauncher.decoratorFactory = function (timer) {\n  return function (launcher, processKillTimeout) {\n    var spawn = require('child_process').spawn;\n\n    function spawnWithoutOutput() {\n      var proc = spawn.apply(null, arguments);\n      proc.stdout.resume();\n      proc.stderr.resume();\n      return proc;\n    }\n\n    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout);\n  };\n};\n\nmodule.exports = ProcessLauncher;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/karma/lib/launchers/process.js"],"names":["path","require","log","create","env","process","ProcessLauncher","spawn","tempDir","timer","processKillTimeout","self","onExitCallback","killTimeout","streamedOutputs","stdout","stderr","_tempDir","getPath","id","toString","on","url","_start","done","_process","nextTick","kill","_killTimer","setTimeout","_onKillTimeout","_execCommand","_getCommand","_getOptions","ENV_CMD","DEFAULT_CMD","platform","_normalizeCommand","cmd","charAt","length","includes","substring","warn","normalize","_onStdout","data","_onStderr","args","error","name","_retryLimit","_clearTempDirAndReportDone","debug","join","errorOutput","code","signal","_onProcessExit","err","errBuff","state","STATE_BEING_CAPTURED","STATE_CAPTURED","clearTimeout","remove","_done","STATE_BEING_KILLED","STATE_BEING_FORCE_KILLED","decoratorFactory","launcher","spawnWithoutOutput","proc","apply","arguments","resume","call","module","exports"],"mappings":"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","sourcesContent":["const path = require('path')\nconst log = require('../logger').create('launcher')\nconst env = process.env\n\nfunction ProcessLauncher (spawn, tempDir, timer, processKillTimeout) {\n  const self = this\n  let onExitCallback\n  const killTimeout = processKillTimeout || 2000\n  // Will hold output from the spawned child process\n  const streamedOutputs = {\n    stdout: '',\n    stderr: ''\n  }\n\n  this._tempDir = tempDir.getPath(`/karma-${this.id.toString()}`)\n\n  this.on('start', function (url) {\n    tempDir.create(self._tempDir)\n    self._start(url)\n  })\n\n  this.on('kill', function (done) {\n    if (!self._process) {\n      return process.nextTick(done)\n    }\n\n    onExitCallback = done\n    self._process.kill()\n    self._killTimer = timer.setTimeout(self._onKillTimeout, killTimeout)\n  })\n\n  this._start = function (url) {\n    self._execCommand(self._getCommand(), self._getOptions(url))\n  }\n\n  this._getCommand = function () {\n    return env[self.ENV_CMD] || self.DEFAULT_CMD[process.platform]\n  }\n\n  this._getOptions = function (url) {\n    return [url]\n  }\n\n  // Normalize the command, remove quotes (spawn does not like them).\n  this._normalizeCommand = function (cmd) {\n    if (cmd.charAt(0) === cmd.charAt(cmd.length - 1) && '\\'`\"'.includes(cmd.charAt(0))) {\n      cmd = cmd.substring(1, cmd.length - 1)\n      log.warn(`The path should not be quoted.\\n  Normalized the path to ${cmd}`)\n    }\n\n    return path.normalize(cmd)\n  }\n\n  this._onStdout = function (data) {\n    streamedOutputs.stdout += data\n  }\n\n  this._onStderr = function (data) {\n    streamedOutputs.stderr += data\n  }\n\n  this._execCommand = function (cmd, args) {\n    if (!cmd) {\n      log.error(`No binary for ${self.name} browser on your platform.\\n  Please, set \"${self.ENV_CMD}\" env variable.`)\n\n      // disable restarting\n      self._retryLimit = -1\n\n      return self._clearTempDirAndReportDone('no binary')\n    }\n\n    cmd = this._normalizeCommand(cmd)\n\n    log.debug(cmd + ' ' + args.join(' '))\n    self._process = spawn(cmd, args)\n    let errorOutput = ''\n\n    self._process.stdout.on('data', self._onStdout)\n\n    self._process.stderr.on('data', self._onStderr)\n\n    self._process.on('exit', function (code, signal) {\n      self._onProcessExit(code, signal, errorOutput)\n    })\n\n    self._process.on('error', function (err) {\n      if (err.code === 'ENOENT') {\n        self._retryLimit = -1\n        errorOutput = `Can not find the binary ${cmd}\\n\\tPlease set env variable ${self.ENV_CMD}`\n      } else if (err.code === 'EACCES') {\n        self._retryLimit = -1\n        errorOutput = `Permission denied accessing the binary ${cmd}\\n\\tMaybe it's a directory?`\n      } else {\n        errorOutput += err.toString()\n      }\n    })\n\n    self._process.stderr.on('data', function (errBuff) {\n      errorOutput += errBuff.toString()\n    })\n  }\n\n  this._onProcessExit = function (code, signal, errorOutput) {\n    log.debug(`Process ${self.name} exited with code ${code} and signal ${signal}`)\n\n    let error = null\n\n    if (self.state === self.STATE_BEING_CAPTURED) {\n      log.error(`Cannot start ${self.name}\\n\\t${errorOutput}`)\n      error = 'cannot start'\n    }\n\n    if (self.state === self.STATE_CAPTURED) {\n      log.error(`${self.name} crashed.\\n\\t${errorOutput}`)\n      error = 'crashed'\n    }\n\n    if (error) {\n      log.error(`${self.name} stdout: ${streamedOutputs.stdout}`)\n      log.error(`${self.name} stderr: ${streamedOutputs.stderr}`)\n    }\n\n    self._process = null\n    streamedOutputs.stdout = ''\n    streamedOutputs.stderr = ''\n    if (self._killTimer) {\n      timer.clearTimeout(self._killTimer)\n      self._killTimer = null\n    }\n    self._clearTempDirAndReportDone(error)\n  }\n\n  this._clearTempDirAndReportDone = function (error) {\n    tempDir.remove(self._tempDir, function () {\n      self._done(error)\n      if (onExitCallback) {\n        onExitCallback()\n        onExitCallback = null\n      }\n    })\n  }\n\n  this._onKillTimeout = function () {\n    if (self.state !== self.STATE_BEING_KILLED && self.state !== self.STATE_BEING_FORCE_KILLED) {\n      return\n    }\n\n    log.warn(`${self.name} was not killed in ${killTimeout} ms, sending SIGKILL.`)\n    self._process.kill('SIGKILL')\n\n    // NOTE: https://github.com/karma-runner/karma/pull/1184\n    // NOTE: SIGKILL is just a signal.  Processes should never ignore it, but they can.\n    // If a process gets into a state where it doesn't respond in a reasonable amount of time\n    // Karma should warn, and continue as though the kill succeeded.\n    // This a certainly suboptimal, but it is better than having the test harness hang waiting\n    // for a zombie child process to exit.\n    self._killTimer = timer.setTimeout(function () {\n      log.warn(`${self.name} was not killed by SIGKILL in ${killTimeout} ms, continuing.`)\n      self._onProcessExit(-1, null, '')\n    }, killTimeout)\n  }\n}\n\nProcessLauncher.decoratorFactory = function (timer) {\n  return function (launcher, processKillTimeout) {\n    const spawn = require('child_process').spawn\n\n    function spawnWithoutOutput () {\n      const proc = spawn.apply(null, arguments)\n      proc.stdout.resume()\n      proc.stderr.resume()\n\n      return proc\n    }\n\n    ProcessLauncher.call(launcher, spawnWithoutOutput, require('../temp_dir'), timer, processKillTimeout)\n  }\n}\n\nmodule.exports = ProcessLauncher\n"]},"metadata":{},"sourceType":"script"}