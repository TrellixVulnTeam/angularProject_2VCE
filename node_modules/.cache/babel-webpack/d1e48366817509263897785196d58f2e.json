{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/cycles/src/analyzer\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.Cycle = exports.CycleAnalyzer = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * Analyzes a `ts.Program` for cycles.\n   */\n\n\n  var CycleAnalyzer =\n  /** @class */\n  function () {\n    function CycleAnalyzer(importGraph) {\n      this.importGraph = importGraph;\n    }\n    /**\n     * Check for a cycle to be created in the `ts.Program` by adding an import between `from` and\n     * `to`.\n     *\n     * @returns a `Cycle` object if an import between `from` and `to` would create a cycle; `null`\n     *     otherwise.\n     */\n\n\n    CycleAnalyzer.prototype.wouldCreateCycle = function (from, to) {\n      // Import of 'from' -> 'to' is illegal if an edge 'to' -> 'from' already exists.\n      return this.importGraph.transitiveImportsOf(to).has(from) ? new Cycle(this.importGraph, from, to) : null;\n    };\n    /**\n     * Record a synthetic import from `from` to `to`.\n     *\n     * This is an import that doesn't exist in the `ts.Program` but will be considered as part of the\n     * import graph for cycle creation.\n     */\n\n\n    CycleAnalyzer.prototype.recordSyntheticImport = function (from, to) {\n      this.importGraph.addSyntheticImport(from, to);\n    };\n\n    return CycleAnalyzer;\n  }();\n\n  exports.CycleAnalyzer = CycleAnalyzer;\n  /**\n   * Represents an import cycle between `from` and `to` in the program.\n   *\n   * This class allows us to do the work to compute the cyclic path between `from` and `to` only if\n   * needed.\n   */\n\n  var Cycle =\n  /** @class */\n  function () {\n    function Cycle(importGraph, from, to) {\n      this.importGraph = importGraph;\n      this.from = from;\n      this.to = to;\n    }\n    /**\n     * Compute an array of source-files that illustrates the cyclic path between `from` and `to`.\n     *\n     * Note that a `Cycle` will not be created unless a path is available between `to` and `from`,\n     * so `findPath()` will never return `null`.\n     */\n\n\n    Cycle.prototype.getPath = function () {\n      return tslib_1.__spread([this.from], this.importGraph.findPath(this.to, this.from));\n    };\n\n    return Cycle;\n  }();\n\n  exports.Cycle = Cycle;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/cycles/src/analyzer.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;AAMH;;AAEG;;;AACH,MAAA,aAAA;AAAA;AAAA,cAAA;AACE,aAAA,aAAA,CAAoB,WAApB,EAA4C;AAAxB,WAAA,WAAA,GAAA,WAAA;AAA4B;AAEhD;;;;;;AAMG;;;AACH,IAAA,aAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,IAAjB,EAAsC,EAAtC,EAAuD;AACrD;AACA,aAAO,KAAK,WAAL,CAAiB,mBAAjB,CAAqC,EAArC,EAAyC,GAAzC,CAA6C,IAA7C,IACH,IAAI,KAAJ,CAAU,KAAK,WAAf,EAA4B,IAA5B,EAAkC,EAAlC,CADG,GAEH,IAFJ;AAGD,KALD;AAOA;;;;;AAKG;;;AACH,IAAA,aAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,IAAtB,EAA2C,EAA3C,EAA4D;AAC1D,WAAK,WAAL,CAAiB,kBAAjB,CAAoC,IAApC,EAA0C,EAA1C;AACD,KAFD;;AAGF,WAAA,aAAA;AAAC,GA1BD,EAAA;;AAAa,EAAA,OAAA,CAAA,aAAA,GAAA,aAAA;AA4Bb;;;;;AAKG;;AACH,MAAA,KAAA;AAAA;AAAA,cAAA;AACE,aAAA,KAAA,CACY,WADZ,EAC+C,IAD/C,EAC6E,EAD7E,EAC8F;AAAlF,WAAA,WAAA,GAAA,WAAA;AAAmC,WAAA,IAAA,GAAA,IAAA;AAA8B,WAAA,EAAA,GAAA,EAAA;AAAqB;AAElG;;;;;AAKG;;;AACH,IAAA,KAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;AACE,aAAA,OAAA,CAAA,QAAA,CAAA,CAAQ,KAAK,IAAb,CAAA,EAAsB,KAAK,WAAL,CAAiB,QAAjB,CAA0B,KAAK,EAA/B,EAAmC,KAAK,IAAxC,CAAtB,CAAA;AACD,KAFD;;AAGF,WAAA,KAAA;AAAC,GAbD,EAAA;;AAAa,EAAA,OAAA,CAAA,KAAA,GAAA,KAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {ImportGraph} from './imports';\n\n/**\n * Analyzes a `ts.Program` for cycles.\n */\nexport class CycleAnalyzer {\n  constructor(private importGraph: ImportGraph) {}\n\n  /**\n   * Check for a cycle to be created in the `ts.Program` by adding an import between `from` and\n   * `to`.\n   *\n   * @returns a `Cycle` object if an import between `from` and `to` would create a cycle; `null`\n   *     otherwise.\n   */\n  wouldCreateCycle(from: ts.SourceFile, to: ts.SourceFile): Cycle|null {\n    // Import of 'from' -> 'to' is illegal if an edge 'to' -> 'from' already exists.\n    return this.importGraph.transitiveImportsOf(to).has(from) ?\n        new Cycle(this.importGraph, from, to) :\n        null;\n  }\n\n  /**\n   * Record a synthetic import from `from` to `to`.\n   *\n   * This is an import that doesn't exist in the `ts.Program` but will be considered as part of the\n   * import graph for cycle creation.\n   */\n  recordSyntheticImport(from: ts.SourceFile, to: ts.SourceFile): void {\n    this.importGraph.addSyntheticImport(from, to);\n  }\n}\n\n/**\n * Represents an import cycle between `from` and `to` in the program.\n *\n * This class allows us to do the work to compute the cyclic path between `from` and `to` only if\n * needed.\n */\nexport class Cycle {\n  constructor(\n      private importGraph: ImportGraph, readonly from: ts.SourceFile, readonly to: ts.SourceFile) {}\n\n  /**\n   * Compute an array of source-files that illustrates the cyclic path between `from` and `to`.\n   *\n   * Note that a `Cycle` will not be created unless a path is available between `to` and `from`,\n   * so `findPath()` will never return `null`.\n   */\n  getPath(): ts.SourceFile[] {\n    return [this.from, ...this.importGraph.findPath(this.to, this.from)!];\n  }\n}\n\n\n/**\n * What to do if a cycle is detected.\n */\nexport const enum CycleHandlingStrategy {\n  /** Add \"remote scoping\" code to avoid creating a cycle. */\n  UseRemoteScoping,\n  /** Fail the compilation with an error. */\n  Error,\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}