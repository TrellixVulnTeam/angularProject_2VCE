{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/transform/src/utils\", [\"require\", \"exports\", \"tslib\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.addImports = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n  /**\n   * Adds extra imports in the import manage for this source file, after the existing imports\n   * and before the module body.\n   * Can optionally add extra statements (e.g. new constants) before the body as well.\n   */\n\n\n  function addImports(importManager, sf, extraStatements) {\n    if (extraStatements === void 0) {\n      extraStatements = [];\n    } // Generate the import statements to prepend.\n\n\n    var addedImports = importManager.getAllImports(sf.fileName).map(function (i) {\n      var qualifier = ts.createIdentifier(i.qualifier.text);\n      var importClause = ts.createImportClause(\n      /* name */\n      undefined,\n      /* namedBindings */\n      ts.createNamespaceImport(qualifier));\n      var decl = ts.createImportDeclaration(\n      /* decorators */\n      undefined,\n      /* modifiers */\n      undefined,\n      /* importClause */\n      importClause,\n      /* moduleSpecifier */\n      ts.createLiteral(i.specifier)); // Set the qualifier's original TS node to the `ts.ImportDeclaration`. This allows downstream\n      // transforms such as tsickle to properly process references to this import.\n      //\n      // This operation is load-bearing in g3 as some imported modules contain special metadata\n      // generated by clutz, which tsickle uses to transform imports and references to those imports.\n      //\n      // TODO(alxhub): add a test for this when tsickle is updated externally to depend on this\n      // behavior.\n\n      ts.setOriginalNode(i.qualifier, decl);\n      return decl;\n    }); // Filter out the existing imports and the source file body. All new statements\n    // will be inserted between them.\n\n    var existingImports = sf.statements.filter(function (stmt) {\n      return isImportStatement(stmt);\n    });\n    var body = sf.statements.filter(function (stmt) {\n      return !isImportStatement(stmt);\n    }); // Prepend imports if needed.\n\n    if (addedImports.length > 0) {\n      // If we prepend imports, we also prepend NotEmittedStatement to use it as an anchor\n      // for @fileoverview Closure annotation. If there is no @fileoverview annotations, this\n      // statement would be a noop.\n      var fileoverviewAnchorStmt = ts.createNotEmittedStatement(sf);\n      return ts.updateSourceFileNode(sf, ts.createNodeArray(tslib_1.__spread([fileoverviewAnchorStmt], existingImports, addedImports, extraStatements, body)));\n    }\n\n    return sf;\n  }\n\n  exports.addImports = addImports;\n\n  function isImportStatement(stmt) {\n    return ts.isImportDeclaration(stmt) || ts.isImportEqualsDeclaration(stmt) || ts.isNamespaceImport(stmt);\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAMG;;;AACH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;AAIA;;;;AAIG;;;AACH,WAAgB,UAAhB,CACI,aADJ,EACkC,EADlC,EAEI,eAFJ,EAEwC;AAApC,QAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,eAAA,GAAA,EAAA;AAAoC,KAAA,CACtC;;;AACA,QAAM,YAAY,GAAG,aAAa,CAAC,aAAd,CAA4B,EAAE,CAAC,QAA/B,EAAyC,GAAzC,CAA6C,UAAA,CAAA,EAAC;AACjE,UAAM,SAAS,GAAG,EAAE,CAAC,gBAAH,CAAoB,CAAC,CAAC,SAAF,CAAY,IAAhC,CAAlB;AACA,UAAM,YAAY,GAAG,EAAE,CAAC,kBAAH;AACjB;AAAW,MAAA,SADM;AAEjB;AAAoB,MAAA,EAAE,CAAC,qBAAH,CAAyB,SAAzB,CAFH,CAArB;AAGA,UAAM,IAAI,GAAG,EAAE,CAAC,uBAAH;AACT;AAAiB,MAAA,SADR;AAET;AAAgB,MAAA,SAFP;AAGT;AAAmB,MAAA,YAHV;AAIT;AAAsB,MAAA,EAAE,CAAC,aAAH,CAAiB,CAAC,CAAC,SAAnB,CAJb,CAAb,CALiE,CAWjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAA,EAAE,CAAC,eAAH,CAAmB,CAAC,CAAC,SAArB,EAAgC,IAAhC;AAEA,aAAO,IAAP;AACD,KAtBoB,CAArB,CAFsC,CA0BtC;AACA;;AACA,QAAM,eAAe,GAAG,EAAE,CAAC,UAAH,CAAc,MAAd,CAAqB,UAAA,IAAA,EAAI;AAAI,aAAA,iBAAiB,CAAjB,IAAiB,CAAjB;AAAuB,KAApD,CAAxB;AACA,QAAM,IAAI,GAAG,EAAE,CAAC,UAAH,CAAc,MAAd,CAAqB,UAAA,IAAA,EAAI;AAAI,aAAA,CAAC,iBAAiB,CAAlB,IAAkB,CAAlB;AAAwB,KAArD,CAAb,CA7BsC,CA8BtC;;AACA,QAAI,YAAY,CAAC,MAAb,GAAsB,CAA1B,EAA6B;AAC3B;AACA;AACA;AACA,UAAM,sBAAsB,GAAG,EAAE,CAAC,yBAAH,CAA6B,EAA7B,CAA/B;AACA,aAAO,EAAE,CAAC,oBAAH,CAAwB,EAAxB,EAA4B,EAAE,CAAC,eAAH,CAAkB,OAAA,CAAA,QAAA,CAAA,CACnD,sBADmD,CAAA,EACxB,eADwB,EACJ,YADI,EACa,eADb,EACiC,IADjC,CAAlB,CAA5B,CAAP;AAGD;;AAED,WAAO,EAAP;AACD;;AA5CD,EAAA,OAAA,CAAA,UAAA,GAAA,UAAA;;AA8CA,WAAS,iBAAT,CAA2B,IAA3B,EAA6C;AAC3C,WAAO,EAAE,CAAC,mBAAH,CAAuB,IAAvB,KAAgC,EAAE,CAAC,yBAAH,CAA6B,IAA7B,CAAhC,IACH,EAAE,CAAC,iBAAH,CAAqB,IAArB,CADJ;AAED","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {ImportManager} from '../../translator';\n\n/**\n * Adds extra imports in the import manage for this source file, after the existing imports\n * and before the module body.\n * Can optionally add extra statements (e.g. new constants) before the body as well.\n */\nexport function addImports(\n    importManager: ImportManager, sf: ts.SourceFile,\n    extraStatements: ts.Statement[] = []): ts.SourceFile {\n  // Generate the import statements to prepend.\n  const addedImports = importManager.getAllImports(sf.fileName).map(i => {\n    const qualifier = ts.createIdentifier(i.qualifier.text);\n    const importClause = ts.createImportClause(\n        /* name */ undefined,\n        /* namedBindings */ ts.createNamespaceImport(qualifier));\n    const decl = ts.createImportDeclaration(\n        /* decorators */ undefined,\n        /* modifiers */ undefined,\n        /* importClause */ importClause,\n        /* moduleSpecifier */ ts.createLiteral(i.specifier));\n\n    // Set the qualifier's original TS node to the `ts.ImportDeclaration`. This allows downstream\n    // transforms such as tsickle to properly process references to this import.\n    //\n    // This operation is load-bearing in g3 as some imported modules contain special metadata\n    // generated by clutz, which tsickle uses to transform imports and references to those imports.\n    //\n    // TODO(alxhub): add a test for this when tsickle is updated externally to depend on this\n    // behavior.\n    ts.setOriginalNode(i.qualifier, decl);\n\n    return decl;\n  });\n\n  // Filter out the existing imports and the source file body. All new statements\n  // will be inserted between them.\n  const existingImports = sf.statements.filter(stmt => isImportStatement(stmt));\n  const body = sf.statements.filter(stmt => !isImportStatement(stmt));\n  // Prepend imports if needed.\n  if (addedImports.length > 0) {\n    // If we prepend imports, we also prepend NotEmittedStatement to use it as an anchor\n    // for @fileoverview Closure annotation. If there is no @fileoverview annotations, this\n    // statement would be a noop.\n    const fileoverviewAnchorStmt = ts.createNotEmittedStatement(sf);\n    return ts.updateSourceFileNode(sf, ts.createNodeArray([\n      fileoverviewAnchorStmt, ...existingImports, ...addedImports, ...extraStatements, ...body\n    ]));\n  }\n\n  return sf;\n}\n\nfunction isImportStatement(stmt: ts.Statement): boolean {\n  return ts.isImportDeclaration(stmt) || ts.isImportEqualsDeclaration(stmt) ||\n      ts.isNamespaceImport(stmt);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}