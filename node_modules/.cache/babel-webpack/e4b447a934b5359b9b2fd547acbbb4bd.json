{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/dependencies/dependency_resolver\", [\"require\", \"exports\", \"tslib\", \"dependency-graph\", \"@angular/compiler-cli/ngcc/src/packages/entry_point\", \"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.DependencyResolver = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var dependency_graph_1 = require(\"dependency-graph\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point\");\n\n  var dependency_host_1 = require(\"@angular/compiler-cli/ngcc/src/dependencies/dependency_host\");\n\n  var builtinNodeJsModules = new Set(require('module').builtinModules);\n  /**\n   * A class that resolves dependencies between entry-points.\n   */\n\n  var DependencyResolver =\n  /** @class */\n  function () {\n    function DependencyResolver(fs, logger, config, hosts, typingsHost) {\n      this.fs = fs;\n      this.logger = logger;\n      this.config = config;\n      this.hosts = hosts;\n      this.typingsHost = typingsHost;\n    }\n    /**\n     * Sort the array of entry points so that the dependant entry points always come later than\n     * their dependencies in the array.\n     * @param entryPoints An array entry points to sort.\n     * @param target If provided, only return entry-points depended on by this entry-point.\n     * @returns the result of sorting the entry points by dependency.\n     */\n\n\n    DependencyResolver.prototype.sortEntryPointsByDependency = function (entryPoints, target) {\n      var _a = this.computeDependencyGraph(entryPoints),\n          invalidEntryPoints = _a.invalidEntryPoints,\n          ignoredDependencies = _a.ignoredDependencies,\n          graph = _a.graph;\n\n      var sortedEntryPointNodes;\n\n      if (target) {\n        if (target.compiledByAngular && graph.hasNode(target.path)) {\n          sortedEntryPointNodes = graph.dependenciesOf(target.path);\n          sortedEntryPointNodes.push(target.path);\n        } else {\n          sortedEntryPointNodes = [];\n        }\n      } else {\n        sortedEntryPointNodes = graph.overallOrder();\n      }\n\n      return {\n        entryPoints: sortedEntryPointNodes.map(function (path) {\n          return graph.getNodeData(path);\n        }),\n        graph: graph,\n        invalidEntryPoints: invalidEntryPoints,\n        ignoredDependencies: ignoredDependencies\n      };\n    };\n\n    DependencyResolver.prototype.getEntryPointWithDependencies = function (entryPoint) {\n      var dependencies = dependency_host_1.createDependencyInfo();\n\n      if (entryPoint.compiledByAngular) {\n        // Only bother to compute dependencies of entry-points that have been compiled by Angular\n        var formatInfo = this.getEntryPointFormatInfo(entryPoint);\n        var host = this.hosts[formatInfo.format];\n\n        if (!host) {\n          throw new Error(\"Could not find a suitable format for computing dependencies of entry-point: '\" + entryPoint.path + \"'.\");\n        }\n\n        host.collectDependencies(formatInfo.path, dependencies);\n        this.typingsHost.collectDependencies(entryPoint.typings, dependencies);\n      }\n\n      return {\n        entryPoint: entryPoint,\n        depInfo: dependencies\n      };\n    };\n    /**\n     * Computes a dependency graph of the given entry-points.\n     *\n     * The graph only holds entry-points that ngcc cares about and whose dependencies\n     * (direct and transitive) all exist.\n     */\n\n\n    DependencyResolver.prototype.computeDependencyGraph = function (entryPoints) {\n      var _this = this;\n\n      var invalidEntryPoints = [];\n      var ignoredDependencies = [];\n      var graph = new dependency_graph_1.DepGraph();\n      var angularEntryPoints = entryPoints.filter(function (e) {\n        return e.entryPoint.compiledByAngular;\n      }); // Add the Angular compiled entry points to the graph as nodes\n\n      angularEntryPoints.forEach(function (e) {\n        return graph.addNode(e.entryPoint.path, e.entryPoint);\n      }); // Now add the dependencies between them\n\n      angularEntryPoints.forEach(function (_a) {\n        var entryPoint = _a.entryPoint,\n            _b = _a.depInfo,\n            dependencies = _b.dependencies,\n            missing = _b.missing,\n            deepImports = _b.deepImports;\n        var missingDependencies = Array.from(missing).filter(function (dep) {\n          return !builtinNodeJsModules.has(dep);\n        });\n\n        if (missingDependencies.length > 0 && !entryPoint.ignoreMissingDependencies) {\n          // This entry point has dependencies that are missing\n          // so remove it from the graph.\n          removeNodes(entryPoint, missingDependencies);\n        } else {\n          dependencies.forEach(function (dependencyPath) {\n            if (!graph.hasNode(entryPoint.path)) {// The entry-point has already been identified as invalid so we don't need\n              // to do any further work on it.\n            } else if (graph.hasNode(dependencyPath)) {\n              // The entry-point is still valid (i.e. has no missing dependencies) and\n              // the dependency maps to an entry point that exists in the graph so add it\n              graph.addDependency(entryPoint.path, dependencyPath);\n            } else if (invalidEntryPoints.some(function (i) {\n              return i.entryPoint.path === dependencyPath;\n            })) {\n              // The dependency path maps to an entry-point that was previously removed\n              // from the graph, so remove this entry-point as well.\n              removeNodes(entryPoint, [dependencyPath]);\n            } else {\n              // The dependency path points to a package that ngcc does not care about.\n              ignoredDependencies.push({\n                entryPoint: entryPoint,\n                dependencyPath: dependencyPath\n              });\n            }\n          });\n        }\n\n        if (deepImports.size > 0) {\n          var notableDeepImports = _this.filterIgnorableDeepImports(entryPoint, deepImports);\n\n          if (notableDeepImports.length > 0) {\n            var imports = notableDeepImports.map(function (i) {\n              return \"'\" + i + \"'\";\n            }).join(', ');\n\n            _this.logger.warn(\"Entry point '\" + entryPoint.name + \"' contains deep imports into \" + imports + \". \" + \"This is probably not a problem, but may cause the compilation of entry points to be out of order.\");\n          }\n        }\n      });\n      return {\n        invalidEntryPoints: invalidEntryPoints,\n        ignoredDependencies: ignoredDependencies,\n        graph: graph\n      };\n\n      function removeNodes(entryPoint, missingDependencies) {\n        var nodesToRemove = tslib_1.__spread([entryPoint.path], graph.dependantsOf(entryPoint.path));\n\n        nodesToRemove.forEach(function (node) {\n          invalidEntryPoints.push({\n            entryPoint: graph.getNodeData(node),\n            missingDependencies: missingDependencies\n          });\n          graph.removeNode(node);\n        });\n      }\n    };\n\n    DependencyResolver.prototype.getEntryPointFormatInfo = function (entryPoint) {\n      var e_1, _a;\n\n      try {\n        for (var SUPPORTED_FORMAT_PROPERTIES_1 = tslib_1.__values(entry_point_1.SUPPORTED_FORMAT_PROPERTIES), SUPPORTED_FORMAT_PROPERTIES_1_1 = SUPPORTED_FORMAT_PROPERTIES_1.next(); !SUPPORTED_FORMAT_PROPERTIES_1_1.done; SUPPORTED_FORMAT_PROPERTIES_1_1 = SUPPORTED_FORMAT_PROPERTIES_1.next()) {\n          var property = SUPPORTED_FORMAT_PROPERTIES_1_1.value;\n          var formatPath = entryPoint.packageJson[property];\n          if (formatPath === undefined) continue;\n          var format = entry_point_1.getEntryPointFormat(this.fs, entryPoint, property);\n          if (format === undefined) continue;\n          return {\n            format: format,\n            path: this.fs.resolve(entryPoint.path, formatPath)\n          };\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (SUPPORTED_FORMAT_PROPERTIES_1_1 && !SUPPORTED_FORMAT_PROPERTIES_1_1.done && (_a = SUPPORTED_FORMAT_PROPERTIES_1.return)) _a.call(SUPPORTED_FORMAT_PROPERTIES_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      throw new Error(\"There is no appropriate source code format in '\" + entryPoint.path + \"' entry-point.\");\n    };\n    /**\n     * Filter out the deepImports that can be ignored, according to this entryPoint's config.\n     */\n\n\n    DependencyResolver.prototype.filterIgnorableDeepImports = function (entryPoint, deepImports) {\n      var version = entryPoint.packageJson.version || null;\n      var packageConfig = this.config.getPackageConfig(entryPoint.packageName, entryPoint.packagePath, version);\n      var matchers = packageConfig.ignorableDeepImportMatchers;\n      return Array.from(deepImports).filter(function (deepImport) {\n        return !matchers.some(function (matcher) {\n          return matcher.test(deepImport);\n        });\n      });\n    };\n\n    return DependencyResolver;\n  }();\n\n  exports.DependencyResolver = DependencyResolver;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/dependencies/dependency_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DepGraph} from 'dependency-graph';\n\nimport {AbsoluteFsPath, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {NgccConfiguration} from '../packages/configuration';\nimport {EntryPoint, EntryPointFormat, getEntryPointFormat, SUPPORTED_FORMAT_PROPERTIES} from '../packages/entry_point';\nimport {PartiallyOrderedList} from '../utils';\n\nimport {createDependencyInfo, DependencyHost, EntryPointWithDependencies} from './dependency_host';\n\nconst builtinNodeJsModules = new Set<string>(require('module').builtinModules);\n\n/**\n * Holds information about entry points that are removed because\n * they have dependencies that are missing (directly or transitively).\n *\n * This might not be an error, because such an entry point might not actually be used\n * in the application. If it is used then the `ngc` application compilation would\n * fail also, so we don't need ngcc to catch this.\n *\n * For example, consider an application that uses the `@angular/router` package.\n * This package includes an entry-point called `@angular/router/upgrade`, which has a dependency\n * on the `@angular/upgrade` package.\n * If the application never uses code from `@angular/router/upgrade` then there is no need for\n * `@angular/upgrade` to be installed.\n * In this case the ngcc tool should just ignore the `@angular/router/upgrade` end-point.\n */\nexport interface InvalidEntryPoint {\n  entryPoint: EntryPoint;\n  missingDependencies: string[];\n}\n\n/**\n * Holds information about dependencies of an entry-point that do not need to be processed\n * by the ngcc tool.\n *\n * For example, the `rxjs` package does not contain any Angular decorators that need to be\n * compiled and so this can be safely ignored by ngcc.\n */\nexport interface IgnoredDependency {\n  entryPoint: EntryPoint;\n  dependencyPath: string;\n}\n\nexport interface DependencyDiagnostics {\n  invalidEntryPoints: InvalidEntryPoint[];\n  ignoredDependencies: IgnoredDependency[];\n}\n\n/**\n * Represents a partially ordered list of entry-points.\n *\n * The entry-points' order/precedence is such that dependent entry-points always come later than\n * their dependencies in the list.\n *\n * See `DependencyResolver#sortEntryPointsByDependency()`.\n */\nexport type PartiallyOrderedEntryPoints = PartiallyOrderedList<EntryPoint>;\n\n/**\n * A list of entry-points, sorted by their dependencies, and the dependency graph.\n *\n * The `entryPoints` array will be ordered so that no entry point depends upon an entry point that\n * appears later in the array.\n *\n * Some entry points or their dependencies may have been ignored. These are captured for\n * diagnostic purposes in `invalidEntryPoints` and `ignoredDependencies` respectively.\n */\nexport interface SortedEntryPointsInfo extends DependencyDiagnostics {\n  entryPoints: PartiallyOrderedEntryPoints;\n  graph: DepGraph<EntryPoint>;\n}\n\n/**\n * A class that resolves dependencies between entry-points.\n */\nexport class DependencyResolver {\n  constructor(\n      private fs: ReadonlyFileSystem, private logger: Logger, private config: NgccConfiguration,\n      private hosts: Partial<Record<EntryPointFormat, DependencyHost>>,\n      private typingsHost: DependencyHost) {}\n  /**\n   * Sort the array of entry points so that the dependant entry points always come later than\n   * their dependencies in the array.\n   * @param entryPoints An array entry points to sort.\n   * @param target If provided, only return entry-points depended on by this entry-point.\n   * @returns the result of sorting the entry points by dependency.\n   */\n  sortEntryPointsByDependency(entryPoints: EntryPointWithDependencies[], target?: EntryPoint):\n      SortedEntryPointsInfo {\n    const {invalidEntryPoints, ignoredDependencies, graph} =\n        this.computeDependencyGraph(entryPoints);\n\n    let sortedEntryPointNodes: string[];\n    if (target) {\n      if (target.compiledByAngular && graph.hasNode(target.path)) {\n        sortedEntryPointNodes = graph.dependenciesOf(target.path);\n        sortedEntryPointNodes.push(target.path);\n      } else {\n        sortedEntryPointNodes = [];\n      }\n    } else {\n      sortedEntryPointNodes = graph.overallOrder();\n    }\n\n    return {\n      entryPoints: (sortedEntryPointNodes as PartiallyOrderedList<string>)\n                       .map(path => graph.getNodeData(path)),\n      graph,\n      invalidEntryPoints,\n      ignoredDependencies,\n    };\n  }\n\n  getEntryPointWithDependencies(entryPoint: EntryPoint): EntryPointWithDependencies {\n    const dependencies = createDependencyInfo();\n    if (entryPoint.compiledByAngular) {\n      // Only bother to compute dependencies of entry-points that have been compiled by Angular\n      const formatInfo = this.getEntryPointFormatInfo(entryPoint);\n      const host = this.hosts[formatInfo.format];\n      if (!host) {\n        throw new Error(\n            `Could not find a suitable format for computing dependencies of entry-point: '${\n                entryPoint.path}'.`);\n      }\n      host.collectDependencies(formatInfo.path, dependencies);\n      this.typingsHost.collectDependencies(entryPoint.typings, dependencies);\n    }\n    return {entryPoint, depInfo: dependencies};\n  }\n\n  /**\n   * Computes a dependency graph of the given entry-points.\n   *\n   * The graph only holds entry-points that ngcc cares about and whose dependencies\n   * (direct and transitive) all exist.\n   */\n  private computeDependencyGraph(entryPoints: EntryPointWithDependencies[]): DependencyGraph {\n    const invalidEntryPoints: InvalidEntryPoint[] = [];\n    const ignoredDependencies: IgnoredDependency[] = [];\n    const graph = new DepGraph<EntryPoint>();\n\n    const angularEntryPoints = entryPoints.filter(e => e.entryPoint.compiledByAngular);\n\n    // Add the Angular compiled entry points to the graph as nodes\n    angularEntryPoints.forEach(e => graph.addNode(e.entryPoint.path, e.entryPoint));\n\n    // Now add the dependencies between them\n    angularEntryPoints.forEach(({entryPoint, depInfo: {dependencies, missing, deepImports}}) => {\n      const missingDependencies = Array.from(missing).filter(dep => !builtinNodeJsModules.has(dep));\n\n      if (missingDependencies.length > 0 && !entryPoint.ignoreMissingDependencies) {\n        // This entry point has dependencies that are missing\n        // so remove it from the graph.\n        removeNodes(entryPoint, missingDependencies);\n      } else {\n        dependencies.forEach(dependencyPath => {\n          if (!graph.hasNode(entryPoint.path)) {\n            // The entry-point has already been identified as invalid so we don't need\n            // to do any further work on it.\n          } else if (graph.hasNode(dependencyPath)) {\n            // The entry-point is still valid (i.e. has no missing dependencies) and\n            // the dependency maps to an entry point that exists in the graph so add it\n            graph.addDependency(entryPoint.path, dependencyPath);\n          } else if (invalidEntryPoints.some(i => i.entryPoint.path === dependencyPath)) {\n            // The dependency path maps to an entry-point that was previously removed\n            // from the graph, so remove this entry-point as well.\n            removeNodes(entryPoint, [dependencyPath]);\n          } else {\n            // The dependency path points to a package that ngcc does not care about.\n            ignoredDependencies.push({entryPoint, dependencyPath});\n          }\n        });\n      }\n\n      if (deepImports.size > 0) {\n        const notableDeepImports = this.filterIgnorableDeepImports(entryPoint, deepImports);\n        if (notableDeepImports.length > 0) {\n          const imports = notableDeepImports.map(i => `'${i}'`).join(', ');\n          this.logger.warn(\n              `Entry point '${entryPoint.name}' contains deep imports into ${imports}. ` +\n              `This is probably not a problem, but may cause the compilation of entry points to be out of order.`);\n        }\n      }\n    });\n\n    return {invalidEntryPoints, ignoredDependencies, graph};\n\n    function removeNodes(entryPoint: EntryPoint, missingDependencies: string[]) {\n      const nodesToRemove = [entryPoint.path, ...graph.dependantsOf(entryPoint.path)];\n      nodesToRemove.forEach(node => {\n        invalidEntryPoints.push({entryPoint: graph.getNodeData(node), missingDependencies});\n        graph.removeNode(node);\n      });\n    }\n  }\n\n  private getEntryPointFormatInfo(entryPoint: EntryPoint):\n      {format: EntryPointFormat, path: AbsoluteFsPath} {\n    for (const property of SUPPORTED_FORMAT_PROPERTIES) {\n      const formatPath = entryPoint.packageJson[property];\n      if (formatPath === undefined) continue;\n\n      const format = getEntryPointFormat(this.fs, entryPoint, property);\n      if (format === undefined) continue;\n\n      return {format, path: this.fs.resolve(entryPoint.path, formatPath)};\n    }\n\n    throw new Error(\n        `There is no appropriate source code format in '${entryPoint.path}' entry-point.`);\n  }\n\n  /**\n   * Filter out the deepImports that can be ignored, according to this entryPoint's config.\n   */\n  private filterIgnorableDeepImports(entryPoint: EntryPoint, deepImports: Set<AbsoluteFsPath>):\n      AbsoluteFsPath[] {\n    const version = (entryPoint.packageJson.version || null) as string | null;\n    const packageConfig =\n        this.config.getPackageConfig(entryPoint.packageName, entryPoint.packagePath, version);\n    const matchers = packageConfig.ignorableDeepImportMatchers;\n    return Array.from(deepImports)\n        .filter(deepImport => !matchers.some(matcher => matcher.test(deepImport)));\n  }\n}\n\ninterface DependencyGraph extends DependencyDiagnostics {\n  graph: DepGraph<EntryPoint>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}