{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/transform/src/declaration\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/translator\", \"@angular/compiler-cli/src/ngtsc/transform/src/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ReturnTypeTransform = exports.IvyDeclarationDtsTransform = exports.declarationTransformFactory = exports.DtsTransformRegistry = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var translator_1 = require(\"@angular/compiler-cli/src/ngtsc/translator\");\n\n  var utils_1 = require(\"@angular/compiler-cli/src/ngtsc/transform/src/utils\");\n  /**\n   * Keeps track of `DtsTransform`s per source file, so that it is known which source files need to\n   * have their declaration file transformed.\n   */\n\n\n  var DtsTransformRegistry =\n  /** @class */\n  function () {\n    function DtsTransformRegistry() {\n      this.ivyDeclarationTransforms = new Map();\n      this.returnTypeTransforms = new Map();\n    }\n\n    DtsTransformRegistry.prototype.getIvyDeclarationTransform = function (sf) {\n      if (!this.ivyDeclarationTransforms.has(sf)) {\n        this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());\n      }\n\n      return this.ivyDeclarationTransforms.get(sf);\n    };\n\n    DtsTransformRegistry.prototype.getReturnTypeTransform = function (sf) {\n      if (!this.returnTypeTransforms.has(sf)) {\n        this.returnTypeTransforms.set(sf, new ReturnTypeTransform());\n      }\n\n      return this.returnTypeTransforms.get(sf);\n    };\n    /**\n     * Gets the dts transforms to be applied for the given source file, or `null` if no transform is\n     * necessary.\n     */\n\n\n    DtsTransformRegistry.prototype.getAllTransforms = function (sf) {\n      // No need to transform if it's not a declarations file, or if no changes have been requested\n      // to the input file. Due to the way TypeScript afterDeclarations transformers work, the\n      // `ts.SourceFile` path is the same as the original .ts. The only way we know it's actually a\n      // declaration file is via the `isDeclarationFile` property.\n      if (!sf.isDeclarationFile) {\n        return null;\n      }\n\n      var originalSf = ts.getOriginalNode(sf);\n      var transforms = null;\n\n      if (this.ivyDeclarationTransforms.has(originalSf)) {\n        transforms = [];\n        transforms.push(this.ivyDeclarationTransforms.get(originalSf));\n      }\n\n      if (this.returnTypeTransforms.has(originalSf)) {\n        transforms = transforms || [];\n        transforms.push(this.returnTypeTransforms.get(originalSf));\n      }\n\n      return transforms;\n    };\n\n    return DtsTransformRegistry;\n  }();\n\n  exports.DtsTransformRegistry = DtsTransformRegistry;\n\n  function declarationTransformFactory(transformRegistry, importRewriter, importPrefix) {\n    return function (context) {\n      var transformer = new DtsTransformer(context, importRewriter, importPrefix);\n      return function (fileOrBundle) {\n        if (ts.isBundle(fileOrBundle)) {\n          // Only attempt to transform source files.\n          return fileOrBundle;\n        }\n\n        var transforms = transformRegistry.getAllTransforms(fileOrBundle);\n\n        if (transforms === null) {\n          return fileOrBundle;\n        }\n\n        return transformer.transform(fileOrBundle, transforms);\n      };\n    };\n  }\n\n  exports.declarationTransformFactory = declarationTransformFactory;\n  /**\n   * Processes .d.ts file text and adds static field declarations, with types.\n   */\n\n  var DtsTransformer =\n  /** @class */\n  function () {\n    function DtsTransformer(ctx, importRewriter, importPrefix) {\n      this.ctx = ctx;\n      this.importRewriter = importRewriter;\n      this.importPrefix = importPrefix;\n    }\n    /**\n     * Transform the declaration file and add any declarations which were recorded.\n     */\n\n\n    DtsTransformer.prototype.transform = function (sf, transforms) {\n      var _this = this;\n\n      var imports = new translator_1.ImportManager(this.importRewriter, this.importPrefix);\n\n      var visitor = function visitor(node) {\n        if (ts.isClassDeclaration(node)) {\n          return _this.transformClassDeclaration(node, transforms, imports);\n        } else if (ts.isFunctionDeclaration(node)) {\n          return _this.transformFunctionDeclaration(node, transforms, imports);\n        } else {\n          // Otherwise return node as is.\n          return ts.visitEachChild(node, visitor, _this.ctx);\n        }\n      }; // Recursively scan through the AST and process all nodes as desired.\n\n\n      sf = ts.visitNode(sf, visitor); // Add new imports for this file.\n\n      return utils_1.addImports(imports, sf);\n    };\n\n    DtsTransformer.prototype.transformClassDeclaration = function (clazz, transforms, imports) {\n      var e_1, _a, e_2, _b;\n\n      var elements = clazz.members;\n      var elementsChanged = false;\n\n      try {\n        for (var transforms_1 = tslib_1.__values(transforms), transforms_1_1 = transforms_1.next(); !transforms_1_1.done; transforms_1_1 = transforms_1.next()) {\n          var transform = transforms_1_1.value;\n\n          if (transform.transformClassElement !== undefined) {\n            for (var i = 0; i < elements.length; i++) {\n              var res = transform.transformClassElement(elements[i], imports);\n\n              if (res !== elements[i]) {\n                if (!elementsChanged) {\n                  elements = tslib_1.__spread(elements);\n                  elementsChanged = true;\n                }\n\n                elements[i] = res;\n              }\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (transforms_1_1 && !transforms_1_1.done && (_a = transforms_1.return)) _a.call(transforms_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var newClazz = clazz;\n\n      try {\n        for (var transforms_2 = tslib_1.__values(transforms), transforms_2_1 = transforms_2.next(); !transforms_2_1.done; transforms_2_1 = transforms_2.next()) {\n          var transform = transforms_2_1.value;\n\n          if (transform.transformClass !== undefined) {\n            // If no DtsTransform has changed the class yet, then the (possibly mutated) elements have\n            // not yet been incorporated. Otherwise, `newClazz.members` holds the latest class members.\n            var inputMembers = clazz === newClazz ? elements : newClazz.members;\n            newClazz = transform.transformClass(newClazz, inputMembers, imports);\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (transforms_2_1 && !transforms_2_1.done && (_b = transforms_2.return)) _b.call(transforms_2);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      } // If some elements have been transformed but the class itself has not been transformed, create\n      // an updated class declaration with the updated elements.\n\n\n      if (elementsChanged && clazz === newClazz) {\n        newClazz = ts.updateClassDeclaration(\n        /* node */\n        clazz,\n        /* decorators */\n        clazz.decorators,\n        /* modifiers */\n        clazz.modifiers,\n        /* name */\n        clazz.name,\n        /* typeParameters */\n        clazz.typeParameters,\n        /* heritageClauses */\n        clazz.heritageClauses,\n        /* members */\n        elements);\n      }\n\n      return newClazz;\n    };\n\n    DtsTransformer.prototype.transformFunctionDeclaration = function (declaration, transforms, imports) {\n      var e_3, _a;\n\n      var newDecl = declaration;\n\n      try {\n        for (var transforms_3 = tslib_1.__values(transforms), transforms_3_1 = transforms_3.next(); !transforms_3_1.done; transforms_3_1 = transforms_3.next()) {\n          var transform = transforms_3_1.value;\n\n          if (transform.transformFunctionDeclaration !== undefined) {\n            newDecl = transform.transformFunctionDeclaration(newDecl, imports);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (transforms_3_1 && !transforms_3_1.done && (_a = transforms_3.return)) _a.call(transforms_3);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      return newDecl;\n    };\n\n    return DtsTransformer;\n  }();\n\n  var IvyDeclarationDtsTransform =\n  /** @class */\n  function () {\n    function IvyDeclarationDtsTransform() {\n      this.declarationFields = new Map();\n    }\n\n    IvyDeclarationDtsTransform.prototype.addFields = function (decl, fields) {\n      this.declarationFields.set(decl, fields);\n    };\n\n    IvyDeclarationDtsTransform.prototype.transformClass = function (clazz, members, imports) {\n      var original = ts.getOriginalNode(clazz);\n\n      if (!this.declarationFields.has(original)) {\n        return clazz;\n      }\n\n      var fields = this.declarationFields.get(original);\n      var newMembers = fields.map(function (decl) {\n        var modifiers = [ts.createModifier(ts.SyntaxKind.StaticKeyword)];\n        var typeRef = translator_1.translateType(decl.type, imports);\n        markForEmitAsSingleLine(typeRef);\n        return ts.createProperty(\n        /* decorators */\n        undefined,\n        /* modifiers */\n        modifiers,\n        /* name */\n        decl.name,\n        /* questionOrExclamationToken */\n        undefined,\n        /* type */\n        typeRef,\n        /* initializer */\n        undefined);\n      });\n      return ts.updateClassDeclaration(\n      /* node */\n      clazz,\n      /* decorators */\n      clazz.decorators,\n      /* modifiers */\n      clazz.modifiers,\n      /* name */\n      clazz.name,\n      /* typeParameters */\n      clazz.typeParameters,\n      /* heritageClauses */\n      clazz.heritageClauses, tslib_1.__spread(members, newMembers));\n    };\n\n    return IvyDeclarationDtsTransform;\n  }();\n\n  exports.IvyDeclarationDtsTransform = IvyDeclarationDtsTransform;\n\n  function markForEmitAsSingleLine(node) {\n    ts.setEmitFlags(node, ts.EmitFlags.SingleLine);\n    ts.forEachChild(node, markForEmitAsSingleLine);\n  }\n\n  var ReturnTypeTransform =\n  /** @class */\n  function () {\n    function ReturnTypeTransform() {\n      this.typeReplacements = new Map();\n    }\n\n    ReturnTypeTransform.prototype.addTypeReplacement = function (declaration, type) {\n      this.typeReplacements.set(declaration, type);\n    };\n\n    ReturnTypeTransform.prototype.transformClassElement = function (element, imports) {\n      if (ts.isMethodDeclaration(element)) {\n        var original = ts.getOriginalNode(element, ts.isMethodDeclaration);\n\n        if (!this.typeReplacements.has(original)) {\n          return element;\n        }\n\n        var returnType = this.typeReplacements.get(original);\n        var tsReturnType = translator_1.translateType(returnType, imports);\n        return ts.updateMethod(element, element.decorators, element.modifiers, element.asteriskToken, element.name, element.questionToken, element.typeParameters, element.parameters, tsReturnType, element.body);\n      }\n\n      return element;\n    };\n\n    ReturnTypeTransform.prototype.transformFunctionDeclaration = function (element, imports) {\n      var original = ts.getOriginalNode(element);\n\n      if (!this.typeReplacements.has(original)) {\n        return element;\n      }\n\n      var returnType = this.typeReplacements.get(original);\n      var tsReturnType = translator_1.translateType(returnType, imports);\n      return ts.updateFunctionDeclaration(\n      /* node */\n      element,\n      /* decorators */\n      element.decorators,\n      /* modifiers */\n      element.modifiers,\n      /* asteriskToken */\n      element.asteriskToken,\n      /* name */\n      element.name,\n      /* typeParameters */\n      element.typeParameters,\n      /* parameters */\n      element.parameters,\n      /* type */\n      tsReturnType,\n      /* body */\n      element.body);\n    };\n\n    return ReturnTypeTransform;\n  }();\n\n  exports.ReturnTypeTransform = ReturnTypeTransform;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/declaration.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ImportRewriter} from '../../imports';\nimport {ClassDeclaration} from '../../reflection';\nimport {ImportManager, translateType} from '../../translator';\n\nimport {DtsTransform} from './api';\nimport {addImports} from './utils';\n\n/**\n * Keeps track of `DtsTransform`s per source file, so that it is known which source files need to\n * have their declaration file transformed.\n */\nexport class DtsTransformRegistry {\n  private ivyDeclarationTransforms = new Map<ts.SourceFile, IvyDeclarationDtsTransform>();\n  private returnTypeTransforms = new Map<ts.SourceFile, ReturnTypeTransform>();\n\n  getIvyDeclarationTransform(sf: ts.SourceFile): IvyDeclarationDtsTransform {\n    if (!this.ivyDeclarationTransforms.has(sf)) {\n      this.ivyDeclarationTransforms.set(sf, new IvyDeclarationDtsTransform());\n    }\n    return this.ivyDeclarationTransforms.get(sf)!;\n  }\n\n  getReturnTypeTransform(sf: ts.SourceFile): ReturnTypeTransform {\n    if (!this.returnTypeTransforms.has(sf)) {\n      this.returnTypeTransforms.set(sf, new ReturnTypeTransform());\n    }\n    return this.returnTypeTransforms.get(sf)!;\n  }\n\n  /**\n   * Gets the dts transforms to be applied for the given source file, or `null` if no transform is\n   * necessary.\n   */\n  getAllTransforms(sf: ts.SourceFile): DtsTransform[]|null {\n    // No need to transform if it's not a declarations file, or if no changes have been requested\n    // to the input file. Due to the way TypeScript afterDeclarations transformers work, the\n    // `ts.SourceFile` path is the same as the original .ts. The only way we know it's actually a\n    // declaration file is via the `isDeclarationFile` property.\n    if (!sf.isDeclarationFile) {\n      return null;\n    }\n    const originalSf = ts.getOriginalNode(sf) as ts.SourceFile;\n\n    let transforms: DtsTransform[]|null = null;\n    if (this.ivyDeclarationTransforms.has(originalSf)) {\n      transforms = [];\n      transforms.push(this.ivyDeclarationTransforms.get(originalSf)!);\n    }\n    if (this.returnTypeTransforms.has(originalSf)) {\n      transforms = transforms || [];\n      transforms.push(this.returnTypeTransforms.get(originalSf)!);\n    }\n    return transforms;\n  }\n}\n\nexport function declarationTransformFactory(\n    transformRegistry: DtsTransformRegistry, importRewriter: ImportRewriter,\n    importPrefix?: string): ts.TransformerFactory<ts.SourceFile> {\n  return (context: ts.TransformationContext) => {\n    const transformer = new DtsTransformer(context, importRewriter, importPrefix);\n    return (fileOrBundle) => {\n      if (ts.isBundle(fileOrBundle)) {\n        // Only attempt to transform source files.\n        return fileOrBundle;\n      }\n      const transforms = transformRegistry.getAllTransforms(fileOrBundle);\n      if (transforms === null) {\n        return fileOrBundle;\n      }\n      return transformer.transform(fileOrBundle, transforms);\n    };\n  };\n}\n\n/**\n * Processes .d.ts file text and adds static field declarations, with types.\n */\nclass DtsTransformer {\n  constructor(\n      private ctx: ts.TransformationContext, private importRewriter: ImportRewriter,\n      private importPrefix?: string) {}\n\n  /**\n   * Transform the declaration file and add any declarations which were recorded.\n   */\n  transform(sf: ts.SourceFile, transforms: DtsTransform[]): ts.SourceFile {\n    const imports = new ImportManager(this.importRewriter, this.importPrefix);\n\n    const visitor: ts.Visitor = (node: ts.Node): ts.VisitResult<ts.Node> => {\n      if (ts.isClassDeclaration(node)) {\n        return this.transformClassDeclaration(node, transforms, imports);\n      } else if (ts.isFunctionDeclaration(node)) {\n        return this.transformFunctionDeclaration(node, transforms, imports);\n      } else {\n        // Otherwise return node as is.\n        return ts.visitEachChild(node, visitor, this.ctx);\n      }\n    };\n\n    // Recursively scan through the AST and process all nodes as desired.\n    sf = ts.visitNode(sf, visitor);\n\n    // Add new imports for this file.\n    return addImports(imports, sf);\n  }\n\n  private transformClassDeclaration(\n      clazz: ts.ClassDeclaration, transforms: DtsTransform[],\n      imports: ImportManager): ts.ClassDeclaration {\n    let elements: ts.ClassElement[]|ReadonlyArray<ts.ClassElement> = clazz.members;\n    let elementsChanged = false;\n\n    for (const transform of transforms) {\n      if (transform.transformClassElement !== undefined) {\n        for (let i = 0; i < elements.length; i++) {\n          const res = transform.transformClassElement(elements[i], imports);\n          if (res !== elements[i]) {\n            if (!elementsChanged) {\n              elements = [...elements];\n              elementsChanged = true;\n            }\n            (elements as ts.ClassElement[])[i] = res;\n          }\n        }\n      }\n    }\n\n    let newClazz: ts.ClassDeclaration = clazz;\n\n    for (const transform of transforms) {\n      if (transform.transformClass !== undefined) {\n        // If no DtsTransform has changed the class yet, then the (possibly mutated) elements have\n        // not yet been incorporated. Otherwise, `newClazz.members` holds the latest class members.\n        const inputMembers = (clazz === newClazz ? elements : newClazz.members);\n\n        newClazz = transform.transformClass(newClazz, inputMembers, imports);\n      }\n    }\n\n    // If some elements have been transformed but the class itself has not been transformed, create\n    // an updated class declaration with the updated elements.\n    if (elementsChanged && clazz === newClazz) {\n      newClazz = ts.updateClassDeclaration(\n          /* node */ clazz,\n          /* decorators */ clazz.decorators,\n          /* modifiers */ clazz.modifiers,\n          /* name */ clazz.name,\n          /* typeParameters */ clazz.typeParameters,\n          /* heritageClauses */ clazz.heritageClauses,\n          /* members */ elements);\n    }\n\n    return newClazz;\n  }\n\n  private transformFunctionDeclaration(\n      declaration: ts.FunctionDeclaration, transforms: DtsTransform[],\n      imports: ImportManager): ts.FunctionDeclaration {\n    let newDecl = declaration;\n\n    for (const transform of transforms) {\n      if (transform.transformFunctionDeclaration !== undefined) {\n        newDecl = transform.transformFunctionDeclaration(newDecl, imports);\n      }\n    }\n\n    return newDecl;\n  }\n}\n\nexport interface IvyDeclarationField {\n  name: string;\n  type: Type;\n}\n\nexport class IvyDeclarationDtsTransform implements DtsTransform {\n  private declarationFields = new Map<ClassDeclaration, IvyDeclarationField[]>();\n\n  addFields(decl: ClassDeclaration, fields: IvyDeclarationField[]): void {\n    this.declarationFields.set(decl, fields);\n  }\n\n  transformClass(\n      clazz: ts.ClassDeclaration, members: ReadonlyArray<ts.ClassElement>,\n      imports: ImportManager): ts.ClassDeclaration {\n    const original = ts.getOriginalNode(clazz) as ClassDeclaration;\n\n    if (!this.declarationFields.has(original)) {\n      return clazz;\n    }\n    const fields = this.declarationFields.get(original)!;\n\n    const newMembers = fields.map(decl => {\n      const modifiers = [ts.createModifier(ts.SyntaxKind.StaticKeyword)];\n      const typeRef = translateType(decl.type, imports);\n      markForEmitAsSingleLine(typeRef);\n      return ts.createProperty(\n          /* decorators */ undefined,\n          /* modifiers */ modifiers,\n          /* name */ decl.name,\n          /* questionOrExclamationToken */ undefined,\n          /* type */ typeRef,\n          /* initializer */ undefined);\n    });\n\n    return ts.updateClassDeclaration(\n        /* node */ clazz,\n        /* decorators */ clazz.decorators,\n        /* modifiers */ clazz.modifiers,\n        /* name */ clazz.name,\n        /* typeParameters */ clazz.typeParameters,\n        /* heritageClauses */ clazz.heritageClauses,\n        /* members */[...members, ...newMembers]);\n  }\n}\n\nfunction markForEmitAsSingleLine(node: ts.Node) {\n  ts.setEmitFlags(node, ts.EmitFlags.SingleLine);\n  ts.forEachChild(node, markForEmitAsSingleLine);\n}\n\nexport class ReturnTypeTransform implements DtsTransform {\n  private typeReplacements = new Map<ts.Declaration, Type>();\n\n  addTypeReplacement(declaration: ts.Declaration, type: Type): void {\n    this.typeReplacements.set(declaration, type);\n  }\n\n  transformClassElement(element: ts.ClassElement, imports: ImportManager): ts.ClassElement {\n    if (ts.isMethodDeclaration(element)) {\n      const original = ts.getOriginalNode(element, ts.isMethodDeclaration);\n      if (!this.typeReplacements.has(original)) {\n        return element;\n      }\n      const returnType = this.typeReplacements.get(original)!;\n      const tsReturnType = translateType(returnType, imports);\n\n      return ts.updateMethod(\n          element, element.decorators, element.modifiers, element.asteriskToken, element.name,\n          element.questionToken, element.typeParameters, element.parameters, tsReturnType,\n          element.body);\n    }\n\n    return element;\n  }\n\n  transformFunctionDeclaration(element: ts.FunctionDeclaration, imports: ImportManager):\n      ts.FunctionDeclaration {\n    const original = ts.getOriginalNode(element) as ts.FunctionDeclaration;\n    if (!this.typeReplacements.has(original)) {\n      return element;\n    }\n    const returnType = this.typeReplacements.get(original)!;\n    const tsReturnType = translateType(returnType, imports);\n\n    return ts.updateFunctionDeclaration(\n        /* node */ element,\n        /* decorators */ element.decorators,\n        /* modifiers */ element.modifiers,\n        /* asteriskToken */ element.asteriskToken,\n        /* name */ element.name,\n        /* typeParameters */ element.typeParameters,\n        /* parameters */ element.parameters,\n        /* type */ tsReturnType,\n        /* body */ element.body);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}