{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeJsonWorkspace = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar magic_string_1 = require(\"magic-string\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar utilities_1 = require(\"./utilities\");\n\nfunction writeJsonWorkspace(_x, _x2, _x3) {\n  return _writeJsonWorkspace.apply(this, arguments);\n}\n\nfunction _writeJsonWorkspace() {\n  _writeJsonWorkspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(workspace, host, path) {\n    var options,\n        metadata,\n        data,\n        obj,\n        _data,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n            metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n\n            if (!metadata) {\n              _context.next = 9;\n              break;\n            }\n\n            if (metadata.hasChanges) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 5:\n            // update existing JSON workspace\n            data = updateJsonWorkspace(metadata);\n            return _context.abrupt(\"return\", host.writeFile(path || metadata.filePath, data));\n\n          case 9:\n            if (path) {\n              _context.next = 11;\n              break;\n            }\n\n            throw new Error('path option is required');\n\n          case 11:\n            obj = convertJsonWorkspace(workspace, options.schema);\n            _data = JSON.stringify(obj, null, 2);\n            return _context.abrupt(\"return\", host.writeFile(path, _data));\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _writeJsonWorkspace.apply(this, arguments);\n}\n\nexports.writeJsonWorkspace = writeJsonWorkspace;\n\nfunction convertJsonWorkspace(workspace, schema) {\n  var obj = _objectSpread(_objectSpread({\n    $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n    version: 1\n  }, workspace.extensions), {}, {\n    projects: workspace.projects ? convertJsonProjectCollection(workspace.projects) : {}\n  });\n\n  return obj;\n}\n\nfunction convertJsonProjectCollection(collection) {\n  var projects = Object.create(null);\n\n  var _iterator = _createForOfIteratorHelper(collection),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          projectName = _step$value[0],\n          project = _step$value[1];\n\n      projects[projectName] = convertJsonProject(project);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return projects;\n}\n\nfunction convertJsonProject(project) {\n  var targets;\n\n  if (project.targets.size > 0) {\n    targets = Object.create(null);\n\n    var _iterator2 = _createForOfIteratorHelper(project.targets),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            targetName = _step2$value[0],\n            target = _step2$value[1];\n\n        targets[targetName] = convertJsonTarget(target);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  var obj = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, project.extensions), {}, {\n    root: project.root\n  }, project.sourceRoot === undefined ? {} : {\n    sourceRoot: project.sourceRoot\n  }), project.prefix === undefined ? {} : {\n    prefix: project.prefix\n  }), targets === undefined ? {} : {\n    architect: targets\n  });\n\n  return obj;\n}\n\nfunction isEmpty(obj) {\n  return obj === undefined || Object.keys(obj).length === 0;\n}\n\nfunction convertJsonTarget(target) {\n  return _objectSpread(_objectSpread({\n    builder: target.builder\n  }, isEmpty(target.options) ? {} : {\n    options: target.options\n  }), isEmpty(target.configurations) ? {} : {\n    configurations: target.configurations\n  });\n}\n\nfunction convertJsonTargetCollection(collection) {\n  var targets = Object.create(null);\n\n  var _iterator3 = _createForOfIteratorHelper(collection),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n          projectName = _step3$value[0],\n          target = _step3$value[1];\n\n      targets[projectName] = convertJsonTarget(target);\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  return targets;\n}\n\nfunction findFullStart(node, raw) {\n  var i = node.start.offset;\n\n  while (i > 0 && /\\s/.test(raw[i - 1])) {\n    --i;\n  }\n\n  return i;\n}\n\nfunction findFullEnd(node, raw) {\n  var i = node.end.offset;\n\n  if (i >= raw.length) {\n    return raw.length;\n  } else if (raw[i] === ',') {\n    return i + 1;\n  }\n\n  while (i > node.start.offset && /\\s/.test(raw[i - 1])) {\n    --i;\n  }\n\n  return i;\n}\n\nfunction findPrecedingComma(node, raw) {\n  var i = node.start.offset;\n\n  if (node.comments && node.comments.length > 0) {\n    i = node.comments[0].start.offset;\n  }\n\n  while (i > 0 && /\\s/.test(raw[i - 1])) {\n    --i;\n  }\n\n  if (raw[i - 1] === ',') {\n    return i - 1;\n  }\n\n  return -1;\n}\n\nfunction stringify(value, multiline, depth, indent) {\n  if (value === undefined) {\n    return '';\n  }\n\n  if (multiline) {\n    var content = JSON.stringify(value, null, indent);\n    var spacing = '\\n' + indent.repeat(depth);\n    return content.replace(/\\n/g, spacing);\n  } else {\n    return JSON.stringify(value);\n  }\n}\n\nfunction normalizeValue(value, type) {\n  switch (type) {\n    case 'project':\n      return convertJsonProject(value);\n\n    case 'projectcollection':\n      var projects = convertJsonProjectCollection(value);\n      return Object.keys(projects).length === 0 ? undefined : projects;\n\n    case 'target':\n      return convertJsonTarget(value);\n\n    case 'targetcollection':\n      var targets = convertJsonTargetCollection(value);\n      return Object.keys(targets).length === 0 ? undefined : targets;\n\n    default:\n      return value;\n  }\n}\n\nfunction updateJsonWorkspace(metadata) {\n  var data = new magic_string_1.default(metadata.raw);\n  var indent = data.getIndentString();\n  var removedCommas = new Set();\n  var nodeChanges = new Map();\n\n  var _iterator4 = _createForOfIteratorHelper(metadata.changes),\n      _step4;\n\n  try {\n    var _loop = function _loop() {\n      var _step4$value = _step4.value,\n          op = _step4$value.op,\n          path = _step4$value.path,\n          node = _step4$value.node,\n          value = _step4$value.value,\n          type = _step4$value.type;\n      // targets/projects are typically large objects so always use multiline\n      var multiline = node.start.line !== node.end.line || type !== 'json';\n      var pathSegments = path.split('/');\n      var depth = pathSegments.length - 1; // TODO: more complete analysis\n\n      var propertyOrIndex = utilities_1.unescapeKey(pathSegments[depth]);\n      var jsonValue = normalizeValue(value, type);\n\n      if (op === 'add' && jsonValue === undefined) {\n        return \"continue\";\n      } // Track changes to the order/size of any modified objects/arrays\n\n\n      var elements = nodeChanges.get(node);\n\n      if (!elements) {\n        if (node.kind === 'array') {\n          elements = node.elements.slice();\n          nodeChanges.set(node, elements);\n        } else if (node.kind === 'object') {\n          elements = node.properties.slice();\n          nodeChanges.set(node, elements);\n        } else {\n          // keyvalue\n          elements = [];\n        }\n      }\n\n      switch (op) {\n        case 'add':\n          var contentPrefix = '';\n\n          if (node.kind === 'object') {\n            contentPrefix = \"\\\"\".concat(propertyOrIndex, \"\\\": \");\n          }\n\n          var spacing = multiline ? '\\n' + indent.repeat(depth) : ' ';\n          var content = spacing + contentPrefix + stringify(jsonValue, multiline, depth, indent); // Additions are handled after analyzing all operations\n          // This is mainly to support array operations which can occur at arbitrary indices\n\n          if (node.kind === 'object') {\n            // Object property additions are always added at the end for simplicity\n            elements.push(content);\n          } else {\n            // Add place holders if adding an index past the length\n            // An empty string is an impossible real value\n            for (var i = elements.length; i < +propertyOrIndex; ++i) {\n              elements[i] = '';\n            }\n\n            if (elements[+propertyOrIndex] === '') {\n              elements[+propertyOrIndex] = content;\n            } else {\n              elements.splice(+propertyOrIndex, 0, content);\n            }\n          }\n\n          break;\n\n        case 'remove':\n          var removalIndex = -1;\n\n          if (node.kind === 'object') {\n            removalIndex = elements.findIndex(function (e) {\n              return typeof e != 'string' && e.kind === 'keyvalue' && e.key.value === propertyOrIndex;\n            });\n          } else if (node.kind === 'array') {\n            removalIndex = +propertyOrIndex;\n          }\n\n          if (removalIndex === -1) {\n            return \"continue\";\n          }\n\n          var nodeToRemove = elements[removalIndex];\n\n          if (typeof nodeToRemove === 'string') {\n            // synthetic\n            elements.splice(removalIndex, 1);\n            return \"continue\";\n          }\n\n          if (elements.length - 1 === removalIndex) {\n            // If the element is a terminal element remove the otherwise trailing comma\n            var commaIndex = findPrecedingComma(nodeToRemove, data.original);\n\n            if (commaIndex !== -1) {\n              data.remove(commaIndex, commaIndex + 1);\n              removedCommas.add(commaIndex);\n            }\n          }\n\n          data.remove(findFullStart(nodeToRemove, data.original), findFullEnd(nodeToRemove, data.original));\n          elements.splice(removalIndex, 1);\n          break;\n\n        case 'replace':\n          var nodeToReplace;\n\n          if (node.kind === 'keyvalue') {\n            nodeToReplace = node.value;\n          } else if (node.kind === 'array') {\n            nodeToReplace = elements[+propertyOrIndex];\n\n            if (typeof nodeToReplace === 'string') {\n              // Was already modified. This is already handled.\n              return \"continue\";\n            }\n          } else {\n            return \"continue\";\n          }\n\n          nodeChanges.delete(nodeToReplace);\n          data.overwrite(nodeToReplace.start.offset, nodeToReplace.end.offset, stringify(jsonValue, multiline, depth, indent));\n          break;\n      }\n    };\n\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  var _iterator5 = _createForOfIteratorHelper(nodeChanges.entries()),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _step5$value = _slicedToArray(_step5.value, 2),\n          node = _step5$value[0],\n          elements = _step5$value[1];\n\n      var parentPoint = 1 + data.original.indexOf(node.kind === 'array' ? '[' : '{', node.start.offset); // Short-circuit for simple case\n\n      if (elements.length === 1 && typeof elements[0] === 'string') {\n        data.appendRight(parentPoint, elements[0]);\n        continue;\n      } // Combine adjecent element additions to minimize/simplify insertions\n\n\n      var optimizedElements = [];\n\n      for (var i = 0; i < elements.length; ++i) {\n        var element = elements[i];\n\n        if (typeof element === 'string' && i > 0 && typeof elements[i - 1] === 'string') {\n          optimizedElements[optimizedElements.length - 1] += ',' + element;\n        } else {\n          optimizedElements.push(element);\n        }\n      }\n\n      var prefixComma = false;\n\n      for (var _i = 0, _optimizedElements = optimizedElements; _i < _optimizedElements.length; _i++) {\n        var _element = _optimizedElements[_i];\n\n        if (typeof _element === 'string') {\n          data.appendRight(parentPoint, (prefixComma ? ',' : '') + _element);\n        } else {\n          parentPoint = findFullEnd(_element, data.original);\n          prefixComma = data.original[parentPoint - 1] !== ',' || removedCommas.has(parentPoint - 1);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  var result = data.toString();\n  return result;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/workspace/json/writer.js"],"names":["Object","defineProperty","exports","value","writeJsonWorkspace","magic_string_1","require","metadata_1","utilities_1","workspace","host","path","options","metadata","JsonWorkspaceSymbol","hasChanges","data","updateJsonWorkspace","writeFile","filePath","Error","obj","convertJsonWorkspace","schema","JSON","stringify","$schema","version","extensions","projects","convertJsonProjectCollection","collection","create","projectName","project","convertJsonProject","targets","size","targetName","target","convertJsonTarget","root","sourceRoot","undefined","prefix","architect","isEmpty","keys","length","builder","configurations","convertJsonTargetCollection","findFullStart","node","raw","i","start","offset","test","findFullEnd","end","findPrecedingComma","comments","multiline","depth","indent","content","spacing","repeat","replace","normalizeValue","type","default","getIndentString","removedCommas","Set","nodeChanges","Map","changes","op","line","pathSegments","split","propertyOrIndex","unescapeKey","jsonValue","elements","get","kind","slice","set","properties","contentPrefix","push","splice","removalIndex","findIndex","e","key","nodeToRemove","commaIndex","original","remove","add","nodeToReplace","delete","overwrite","entries","parentPoint","indexOf","appendRight","optimizedElements","element","prefixComma","has","result","toString"],"mappings":"AAAA;;;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,kBAAR,GAA6B,KAAK,CAAlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,cAAc,GAAGC,OAAO,CAAC,cAAD,CAA9B;;AACA,IAAMC,UAAU,GAAGD,OAAO,CAAC,YAAD,CAA1B;;AACA,IAAME,WAAW,GAAGF,OAAO,CAAC,aAAD,CAA3B;;SACeF,kB;;;;;iFAAf,iBAAkCK,SAAlC,EAA6CC,IAA7C,EAAmDC,IAAnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAyDC,YAAAA,OAAzD,2DAAmE,EAAnE;AACUC,YAAAA,QADV,GACqBJ,SAAS,CAACF,UAAU,CAACO,mBAAZ,CAD9B;;AAAA,iBAEQD,QAFR;AAAA;AAAA;AAAA;;AAAA,gBAGaA,QAAQ,CAACE,UAHtB;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAOQ;AACMC,YAAAA,IARd,GAQqBC,mBAAmB,CAACJ,QAAD,CARxC;AAAA,6CASeH,IAAI,CAACQ,SAAL,CAAeP,IAAI,IAAIE,QAAQ,CAACM,QAAhC,EAA0CH,IAA1C,CATf;;AAAA;AAAA,gBAaaL,IAbb;AAAA;AAAA;AAAA;;AAAA,kBAckB,IAAIS,KAAJ,CAAU,yBAAV,CAdlB;;AAAA;AAgBcC,YAAAA,GAhBd,GAgBoBC,oBAAoB,CAACb,SAAD,EAAYG,OAAO,CAACW,MAApB,CAhBxC;AAiBcP,YAAAA,KAjBd,GAiBqBQ,IAAI,CAACC,SAAL,CAAeJ,GAAf,EAAoB,IAApB,EAA0B,CAA1B,CAjBrB;AAAA,6CAkBeX,IAAI,CAACQ,SAAL,CAAeP,IAAf,EAAqBK,KAArB,CAlBf;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAqBAd,OAAO,CAACE,kBAAR,GAA6BA,kBAA7B;;AACA,SAASkB,oBAAT,CAA8Bb,SAA9B,EAAyCc,MAAzC,EAAiD;AAC7C,MAAMF,GAAG;AACLK,IAAAA,OAAO,EAAEH,MAAM,IAAI,oDADd;AAELI,IAAAA,OAAO,EAAE;AAFJ,KAGFlB,SAAS,CAACmB,UAHR;AAILC,IAAAA,QAAQ,EAAEpB,SAAS,CAACoB,QAAV,GAAqBC,4BAA4B,CAACrB,SAAS,CAACoB,QAAX,CAAjD,GAAwE;AAJ7E,IAAT;;AAMA,SAAOR,GAAP;AACH;;AACD,SAASS,4BAAT,CAAsCC,UAAtC,EAAkD;AAC9C,MAAMF,QAAQ,GAAG7B,MAAM,CAACgC,MAAP,CAAc,IAAd,CAAjB;;AAD8C,6CAETD,UAFS;AAAA;;AAAA;AAE9C,wDAAiD;AAAA;AAAA,UAArCE,WAAqC;AAAA,UAAxBC,OAAwB;;AAC7CL,MAAAA,QAAQ,CAACI,WAAD,CAAR,GAAwBE,kBAAkB,CAACD,OAAD,CAA1C;AACH;AAJ6C;AAAA;AAAA;AAAA;AAAA;;AAK9C,SAAOL,QAAP;AACH;;AACD,SAASM,kBAAT,CAA4BD,OAA5B,EAAqC;AACjC,MAAIE,OAAJ;;AACA,MAAIF,OAAO,CAACE,OAAR,CAAgBC,IAAhB,GAAuB,CAA3B,EAA8B;AAC1BD,IAAAA,OAAO,GAAGpC,MAAM,CAACgC,MAAP,CAAc,IAAd,CAAV;;AAD0B,gDAESE,OAAO,CAACE,OAFjB;AAAA;;AAAA;AAE1B,6DAAoD;AAAA;AAAA,YAAxCE,UAAwC;AAAA,YAA5BC,MAA4B;;AAChDH,QAAAA,OAAO,CAACE,UAAD,CAAP,GAAsBE,iBAAiB,CAACD,MAAD,CAAvC;AACH;AAJyB;AAAA;AAAA;AAAA;AAAA;AAK7B;;AACD,MAAMlB,GAAG,+DACFa,OAAO,CAACN,UADN;AAELa,IAAAA,IAAI,EAAEP,OAAO,CAACO;AAFT,KAGDP,OAAO,CAACQ,UAAR,KAAuBC,SAAvB,GAAmC,EAAnC,GAAwC;AAAED,IAAAA,UAAU,EAAER,OAAO,CAACQ;AAAtB,GAHvC,GAIDR,OAAO,CAACU,MAAR,KAAmBD,SAAnB,GAA+B,EAA/B,GAAoC;AAAEC,IAAAA,MAAM,EAAEV,OAAO,CAACU;AAAlB,GAJnC,GAKDR,OAAO,KAAKO,SAAZ,GAAwB,EAAxB,GAA6B;AAAEE,IAAAA,SAAS,EAAET;AAAb,GAL5B,CAAT;;AAOA,SAAOf,GAAP;AACH;;AACD,SAASyB,OAAT,CAAiBzB,GAAjB,EAAsB;AAClB,SAAOA,GAAG,KAAKsB,SAAR,IAAqB3C,MAAM,CAAC+C,IAAP,CAAY1B,GAAZ,EAAiB2B,MAAjB,KAA4B,CAAxD;AACH;;AACD,SAASR,iBAAT,CAA2BD,MAA3B,EAAmC;AAC/B;AACIU,IAAAA,OAAO,EAAEV,MAAM,CAACU;AADpB,KAEQH,OAAO,CAACP,MAAM,CAAC3B,OAAR,CAAP,GAA0B,EAA1B,GAA+B;AAAEA,IAAAA,OAAO,EAAE2B,MAAM,CAAC3B;AAAlB,GAFvC,GAGQkC,OAAO,CAACP,MAAM,CAACW,cAAR,CAAP,GACE,EADF,GAEE;AAAEA,IAAAA,cAAc,EAAEX,MAAM,CAACW;AAAzB,GALV;AAOH;;AACD,SAASC,2BAAT,CAAqCpB,UAArC,EAAiD;AAC7C,MAAMK,OAAO,GAAGpC,MAAM,CAACgC,MAAP,CAAc,IAAd,CAAhB;;AAD6C,8CAETD,UAFS;AAAA;;AAAA;AAE7C,2DAAgD;AAAA;AAAA,UAApCE,WAAoC;AAAA,UAAvBM,MAAuB;;AAC5CH,MAAAA,OAAO,CAACH,WAAD,CAAP,GAAuBO,iBAAiB,CAACD,MAAD,CAAxC;AACH;AAJ4C;AAAA;AAAA;AAAA;AAAA;;AAK7C,SAAOH,OAAP;AACH;;AACD,SAASgB,aAAT,CAAuBC,IAAvB,EAA6BC,GAA7B,EAAkC;AAC9B,MAAIC,CAAC,GAAGF,IAAI,CAACG,KAAL,CAAWC,MAAnB;;AACA,SAAOF,CAAC,GAAG,CAAJ,IAAS,KAAKG,IAAL,CAAUJ,GAAG,CAACC,CAAC,GAAG,CAAL,CAAb,CAAhB,EAAuC;AACnC,MAAEA,CAAF;AACH;;AACD,SAAOA,CAAP;AACH;;AACD,SAASI,WAAT,CAAqBN,IAArB,EAA2BC,GAA3B,EAAgC;AAC5B,MAAIC,CAAC,GAAGF,IAAI,CAACO,GAAL,CAASH,MAAjB;;AACA,MAAIF,CAAC,IAAID,GAAG,CAACN,MAAb,EAAqB;AACjB,WAAOM,GAAG,CAACN,MAAX;AACH,GAFD,MAGK,IAAIM,GAAG,CAACC,CAAD,CAAH,KAAW,GAAf,EAAoB;AACrB,WAAOA,CAAC,GAAG,CAAX;AACH;;AACD,SAAOA,CAAC,GAAGF,IAAI,CAACG,KAAL,CAAWC,MAAf,IAAyB,KAAKC,IAAL,CAAUJ,GAAG,CAACC,CAAC,GAAG,CAAL,CAAb,CAAhC,EAAuD;AACnD,MAAEA,CAAF;AACH;;AACD,SAAOA,CAAP;AACH;;AACD,SAASM,kBAAT,CAA4BR,IAA5B,EAAkCC,GAAlC,EAAuC;AACnC,MAAIC,CAAC,GAAGF,IAAI,CAACG,KAAL,CAAWC,MAAnB;;AACA,MAAIJ,IAAI,CAACS,QAAL,IAAiBT,IAAI,CAACS,QAAL,CAAcd,MAAd,GAAuB,CAA5C,EAA+C;AAC3CO,IAAAA,CAAC,GAAGF,IAAI,CAACS,QAAL,CAAc,CAAd,EAAiBN,KAAjB,CAAuBC,MAA3B;AACH;;AACD,SAAOF,CAAC,GAAG,CAAJ,IAAS,KAAKG,IAAL,CAAUJ,GAAG,CAACC,CAAC,GAAG,CAAL,CAAb,CAAhB,EAAuC;AACnC,MAAEA,CAAF;AACH;;AACD,MAAID,GAAG,CAACC,CAAC,GAAG,CAAL,CAAH,KAAe,GAAnB,EAAwB;AACpB,WAAOA,CAAC,GAAG,CAAX;AACH;;AACD,SAAO,CAAC,CAAR;AACH;;AACD,SAAS9B,SAAT,CAAmBtB,KAAnB,EAA0B4D,SAA1B,EAAqCC,KAArC,EAA4CC,MAA5C,EAAoD;AAChD,MAAI9D,KAAK,KAAKwC,SAAd,EAAyB;AACrB,WAAO,EAAP;AACH;;AACD,MAAIoB,SAAJ,EAAe;AACX,QAAMG,OAAO,GAAG1C,IAAI,CAACC,SAAL,CAAetB,KAAf,EAAsB,IAAtB,EAA4B8D,MAA5B,CAAhB;AACA,QAAME,OAAO,GAAG,OAAOF,MAAM,CAACG,MAAP,CAAcJ,KAAd,CAAvB;AACA,WAAOE,OAAO,CAACG,OAAR,CAAgB,KAAhB,EAAuBF,OAAvB,CAAP;AACH,GAJD,MAKK;AACD,WAAO3C,IAAI,CAACC,SAAL,CAAetB,KAAf,CAAP;AACH;AACJ;;AACD,SAASmE,cAAT,CAAwBnE,KAAxB,EAA+BoE,IAA/B,EAAqC;AACjC,UAAQA,IAAR;AACI,SAAK,SAAL;AACI,aAAOpC,kBAAkB,CAAChC,KAAD,CAAzB;;AACJ,SAAK,mBAAL;AACI,UAAM0B,QAAQ,GAAGC,4BAA4B,CAAC3B,KAAD,CAA7C;AACA,aAAOH,MAAM,CAAC+C,IAAP,CAAYlB,QAAZ,EAAsBmB,MAAtB,KAAiC,CAAjC,GAAqCL,SAArC,GAAiDd,QAAxD;;AACJ,SAAK,QAAL;AACI,aAAOW,iBAAiB,CAACrC,KAAD,CAAxB;;AACJ,SAAK,kBAAL;AACI,UAAMiC,OAAO,GAAGe,2BAA2B,CAAChD,KAAD,CAA3C;AACA,aAAOH,MAAM,CAAC+C,IAAP,CAAYX,OAAZ,EAAqBY,MAArB,KAAgC,CAAhC,GAAoCL,SAApC,GAAgDP,OAAvD;;AACJ;AACI,aAAOjC,KAAP;AAZR;AAcH;;AACD,SAASc,mBAAT,CAA6BJ,QAA7B,EAAuC;AACnC,MAAMG,IAAI,GAAG,IAAIX,cAAc,CAACmE,OAAnB,CAA2B3D,QAAQ,CAACyC,GAApC,CAAb;AACA,MAAMW,MAAM,GAAGjD,IAAI,CAACyD,eAAL,EAAf;AACA,MAAMC,aAAa,GAAG,IAAIC,GAAJ,EAAtB;AACA,MAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;;AAJmC,8CAKWhE,QAAQ,CAACiE,OALpB;AAAA;;AAAA;AAAA;AAAA;AAAA,UAKtBC,EALsB,gBAKtBA,EALsB;AAAA,UAKlBpE,IALkB,gBAKlBA,IALkB;AAAA,UAKZ0C,IALY,gBAKZA,IALY;AAAA,UAKNlD,KALM,gBAKNA,KALM;AAAA,UAKCoE,IALD,gBAKCA,IALD;AAM/B;AACA,UAAMR,SAAS,GAAGV,IAAI,CAACG,KAAL,CAAWwB,IAAX,KAAoB3B,IAAI,CAACO,GAAL,CAASoB,IAA7B,IAAqCT,IAAI,KAAK,MAAhE;AACA,UAAMU,YAAY,GAAGtE,IAAI,CAACuE,KAAL,CAAW,GAAX,CAArB;AACA,UAAMlB,KAAK,GAAGiB,YAAY,CAACjC,MAAb,GAAsB,CAApC,CAT+B,CASQ;;AACvC,UAAMmC,eAAe,GAAG3E,WAAW,CAAC4E,WAAZ,CAAwBH,YAAY,CAACjB,KAAD,CAApC,CAAxB;AACA,UAAMqB,SAAS,GAAGf,cAAc,CAACnE,KAAD,EAAQoE,IAAR,CAAhC;;AACA,UAAIQ,EAAE,KAAK,KAAP,IAAgBM,SAAS,KAAK1C,SAAlC,EAA6C;AACzC;AACH,OAd8B,CAe/B;;;AACA,UAAI2C,QAAQ,GAAGV,WAAW,CAACW,GAAZ,CAAgBlC,IAAhB,CAAf;;AACA,UAAI,CAACiC,QAAL,EAAe;AACX,YAAIjC,IAAI,CAACmC,IAAL,KAAc,OAAlB,EAA2B;AACvBF,UAAAA,QAAQ,GAAGjC,IAAI,CAACiC,QAAL,CAAcG,KAAd,EAAX;AACAb,UAAAA,WAAW,CAACc,GAAZ,CAAgBrC,IAAhB,EAAsBiC,QAAtB;AACH,SAHD,MAIK,IAAIjC,IAAI,CAACmC,IAAL,KAAc,QAAlB,EAA4B;AAC7BF,UAAAA,QAAQ,GAAGjC,IAAI,CAACsC,UAAL,CAAgBF,KAAhB,EAAX;AACAb,UAAAA,WAAW,CAACc,GAAZ,CAAgBrC,IAAhB,EAAsBiC,QAAtB;AACH,SAHI,MAIA;AACD;AACAA,UAAAA,QAAQ,GAAG,EAAX;AACH;AACJ;;AACD,cAAQP,EAAR;AACI,aAAK,KAAL;AACI,cAAIa,aAAa,GAAG,EAApB;;AACA,cAAIvC,IAAI,CAACmC,IAAL,KAAc,QAAlB,EAA4B;AACxBI,YAAAA,aAAa,eAAOT,eAAP,SAAb;AACH;;AACD,cAAMhB,OAAO,GAAGJ,SAAS,GAAG,OAAOE,MAAM,CAACG,MAAP,CAAcJ,KAAd,CAAV,GAAiC,GAA1D;AACA,cAAME,OAAO,GAAGC,OAAO,GAAGyB,aAAV,GAA0BnE,SAAS,CAAC4D,SAAD,EAAYtB,SAAZ,EAAuBC,KAAvB,EAA8BC,MAA9B,CAAnD,CANJ,CAOI;AACA;;AACA,cAAIZ,IAAI,CAACmC,IAAL,KAAc,QAAlB,EAA4B;AACxB;AACAF,YAAAA,QAAQ,CAACO,IAAT,CAAc3B,OAAd;AACH,WAHD,MAIK;AACD;AACA;AACA,iBAAK,IAAIX,CAAC,GAAG+B,QAAQ,CAACtC,MAAtB,EAA8BO,CAAC,GAAG,CAAC4B,eAAnC,EAAoD,EAAE5B,CAAtD,EAAyD;AACrD+B,cAAAA,QAAQ,CAAC/B,CAAD,CAAR,GAAc,EAAd;AACH;;AACD,gBAAI+B,QAAQ,CAAC,CAACH,eAAF,CAAR,KAA+B,EAAnC,EAAuC;AACnCG,cAAAA,QAAQ,CAAC,CAACH,eAAF,CAAR,GAA6BjB,OAA7B;AACH,aAFD,MAGK;AACDoB,cAAAA,QAAQ,CAACQ,MAAT,CAAgB,CAACX,eAAjB,EAAkC,CAAlC,EAAqCjB,OAArC;AACH;AACJ;;AACD;;AACJ,aAAK,QAAL;AACI,cAAI6B,YAAY,GAAG,CAAC,CAApB;;AACA,cAAI1C,IAAI,CAACmC,IAAL,KAAc,QAAlB,EAA4B;AACxBO,YAAAA,YAAY,GAAGT,QAAQ,CAACU,SAAT,CAAmB,UAAAC,CAAC,EAAI;AACnC,qBAAO,OAAOA,CAAP,IAAY,QAAZ,IAAwBA,CAAC,CAACT,IAAF,KAAW,UAAnC,IAAiDS,CAAC,CAACC,GAAF,CAAM/F,KAAN,KAAgBgF,eAAxE;AACH,aAFc,CAAf;AAGH,WAJD,MAKK,IAAI9B,IAAI,CAACmC,IAAL,KAAc,OAAlB,EAA2B;AAC5BO,YAAAA,YAAY,GAAG,CAACZ,eAAhB;AACH;;AACD,cAAIY,YAAY,KAAK,CAAC,CAAtB,EAAyB;AACrB;AACH;;AACD,cAAMI,YAAY,GAAGb,QAAQ,CAACS,YAAD,CAA7B;;AACA,cAAI,OAAOI,YAAP,KAAwB,QAA5B,EAAsC;AAClC;AACAb,YAAAA,QAAQ,CAACQ,MAAT,CAAgBC,YAAhB,EAA8B,CAA9B;AACA;AACH;;AACD,cAAIT,QAAQ,CAACtC,MAAT,GAAkB,CAAlB,KAAwB+C,YAA5B,EAA0C;AACtC;AACA,gBAAMK,UAAU,GAAGvC,kBAAkB,CAACsC,YAAD,EAAenF,IAAI,CAACqF,QAApB,CAArC;;AACA,gBAAID,UAAU,KAAK,CAAC,CAApB,EAAuB;AACnBpF,cAAAA,IAAI,CAACsF,MAAL,CAAYF,UAAZ,EAAwBA,UAAU,GAAG,CAArC;AACA1B,cAAAA,aAAa,CAAC6B,GAAd,CAAkBH,UAAlB;AACH;AACJ;;AACDpF,UAAAA,IAAI,CAACsF,MAAL,CAAYlD,aAAa,CAAC+C,YAAD,EAAenF,IAAI,CAACqF,QAApB,CAAzB,EAAwD1C,WAAW,CAACwC,YAAD,EAAenF,IAAI,CAACqF,QAApB,CAAnE;AACAf,UAAAA,QAAQ,CAACQ,MAAT,CAAgBC,YAAhB,EAA8B,CAA9B;AACA;;AACJ,aAAK,SAAL;AACI,cAAIS,aAAJ;;AACA,cAAInD,IAAI,CAACmC,IAAL,KAAc,UAAlB,EAA8B;AAC1BgB,YAAAA,aAAa,GAAGnD,IAAI,CAAClD,KAArB;AACH,WAFD,MAGK,IAAIkD,IAAI,CAACmC,IAAL,KAAc,OAAlB,EAA2B;AAC5BgB,YAAAA,aAAa,GAAGlB,QAAQ,CAAC,CAACH,eAAF,CAAxB;;AACA,gBAAI,OAAOqB,aAAP,KAAyB,QAA7B,EAAuC;AACnC;AACA;AACH;AACJ,WANI,MAOA;AACD;AACH;;AACD5B,UAAAA,WAAW,CAAC6B,MAAZ,CAAmBD,aAAnB;AACAxF,UAAAA,IAAI,CAAC0F,SAAL,CAAeF,aAAa,CAAChD,KAAd,CAAoBC,MAAnC,EAA2C+C,aAAa,CAAC5C,GAAd,CAAkBH,MAA7D,EAAqEhC,SAAS,CAAC4D,SAAD,EAAYtB,SAAZ,EAAuBC,KAAvB,EAA8BC,MAA9B,CAA9E;AACA;AA3ER;AA/B+B;;AAKnC,2DAAgE;AAAA;;AAAA,+BAiGhD;AAMf;AA5GkC;AAAA;AAAA;AAAA;AAAA;;AAAA,8CA6GJW,WAAW,CAAC+B,OAAZ,EA7GI;AAAA;;AAAA;AA6GnC,2DAAsD;AAAA;AAAA,UAA1CtD,IAA0C;AAAA,UAApCiC,QAAoC;;AAClD,UAAIsB,WAAW,GAAG,IAAI5F,IAAI,CAACqF,QAAL,CAAcQ,OAAd,CAAsBxD,IAAI,CAACmC,IAAL,KAAc,OAAd,GAAwB,GAAxB,GAA8B,GAApD,EAAyDnC,IAAI,CAACG,KAAL,CAAWC,MAApE,CAAtB,CADkD,CAElD;;AACA,UAAI6B,QAAQ,CAACtC,MAAT,KAAoB,CAApB,IAAyB,OAAOsC,QAAQ,CAAC,CAAD,CAAf,KAAuB,QAApD,EAA8D;AAC1DtE,QAAAA,IAAI,CAAC8F,WAAL,CAAiBF,WAAjB,EAA8BtB,QAAQ,CAAC,CAAD,CAAtC;AACA;AACH,OANiD,CAOlD;;;AACA,UAAMyB,iBAAiB,GAAG,EAA1B;;AACA,WAAK,IAAIxD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+B,QAAQ,CAACtC,MAA7B,EAAqC,EAAEO,CAAvC,EAA0C;AACtC,YAAMyD,OAAO,GAAG1B,QAAQ,CAAC/B,CAAD,CAAxB;;AACA,YAAI,OAAOyD,OAAP,KAAmB,QAAnB,IAA+BzD,CAAC,GAAG,CAAnC,IAAwC,OAAO+B,QAAQ,CAAC/B,CAAC,GAAG,CAAL,CAAf,KAA2B,QAAvE,EAAiF;AAC7EwD,UAAAA,iBAAiB,CAACA,iBAAiB,CAAC/D,MAAlB,GAA2B,CAA5B,CAAjB,IAAmD,MAAMgE,OAAzD;AACH,SAFD,MAGK;AACDD,UAAAA,iBAAiB,CAAClB,IAAlB,CAAuBmB,OAAvB;AACH;AACJ;;AACD,UAAIC,WAAW,GAAG,KAAlB;;AACA,4CAAsBF,iBAAtB,wCAAyC;AAApC,YAAMC,QAAO,yBAAb;;AACD,YAAI,OAAOA,QAAP,KAAmB,QAAvB,EAAiC;AAC7BhG,UAAAA,IAAI,CAAC8F,WAAL,CAAiBF,WAAjB,EAA8B,CAACK,WAAW,GAAG,GAAH,GAAS,EAArB,IAA2BD,QAAzD;AACH,SAFD,MAGK;AACDJ,UAAAA,WAAW,GAAGjD,WAAW,CAACqD,QAAD,EAAUhG,IAAI,CAACqF,QAAf,CAAzB;AACAY,UAAAA,WAAW,GAAGjG,IAAI,CAACqF,QAAL,CAAcO,WAAW,GAAG,CAA5B,MAAmC,GAAnC,IAA0ClC,aAAa,CAACwC,GAAd,CAAkBN,WAAW,GAAG,CAAhC,CAAxD;AACH;AACJ;AACJ;AAzIkC;AAAA;AAAA;AAAA;AAAA;;AA0InC,MAAMO,MAAM,GAAGnG,IAAI,CAACoG,QAAL,EAAf;AACA,SAAOD,MAAP;AACH","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.writeJsonWorkspace = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst magic_string_1 = require(\"magic-string\");\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nasync function writeJsonWorkspace(workspace, host, path, options = {}) {\n    const metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n    if (metadata) {\n        if (!metadata.hasChanges) {\n            // nothing to do\n            return;\n        }\n        // update existing JSON workspace\n        const data = updateJsonWorkspace(metadata);\n        return host.writeFile(path || metadata.filePath, data);\n    }\n    else {\n        // serialize directly\n        if (!path) {\n            throw new Error('path option is required');\n        }\n        const obj = convertJsonWorkspace(workspace, options.schema);\n        const data = JSON.stringify(obj, null, 2);\n        return host.writeFile(path, data);\n    }\n}\nexports.writeJsonWorkspace = writeJsonWorkspace;\nfunction convertJsonWorkspace(workspace, schema) {\n    const obj = {\n        $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n        version: 1,\n        ...workspace.extensions,\n        projects: workspace.projects ? convertJsonProjectCollection(workspace.projects) : {},\n    };\n    return obj;\n}\nfunction convertJsonProjectCollection(collection) {\n    const projects = Object.create(null);\n    for (const [projectName, project] of collection) {\n        projects[projectName] = convertJsonProject(project);\n    }\n    return projects;\n}\nfunction convertJsonProject(project) {\n    let targets;\n    if (project.targets.size > 0) {\n        targets = Object.create(null);\n        for (const [targetName, target] of project.targets) {\n            targets[targetName] = convertJsonTarget(target);\n        }\n    }\n    const obj = {\n        ...project.extensions,\n        root: project.root,\n        ...(project.sourceRoot === undefined ? {} : { sourceRoot: project.sourceRoot }),\n        ...(project.prefix === undefined ? {} : { prefix: project.prefix }),\n        ...(targets === undefined ? {} : { architect: targets }),\n    };\n    return obj;\n}\nfunction isEmpty(obj) {\n    return obj === undefined || Object.keys(obj).length === 0;\n}\nfunction convertJsonTarget(target) {\n    return {\n        builder: target.builder,\n        ...(isEmpty(target.options) ? {} : { options: target.options }),\n        ...(isEmpty(target.configurations)\n            ? {}\n            : { configurations: target.configurations }),\n    };\n}\nfunction convertJsonTargetCollection(collection) {\n    const targets = Object.create(null);\n    for (const [projectName, target] of collection) {\n        targets[projectName] = convertJsonTarget(target);\n    }\n    return targets;\n}\nfunction findFullStart(node, raw) {\n    let i = node.start.offset;\n    while (i > 0 && /\\s/.test(raw[i - 1])) {\n        --i;\n    }\n    return i;\n}\nfunction findFullEnd(node, raw) {\n    let i = node.end.offset;\n    if (i >= raw.length) {\n        return raw.length;\n    }\n    else if (raw[i] === ',') {\n        return i + 1;\n    }\n    while (i > node.start.offset && /\\s/.test(raw[i - 1])) {\n        --i;\n    }\n    return i;\n}\nfunction findPrecedingComma(node, raw) {\n    let i = node.start.offset;\n    if (node.comments && node.comments.length > 0) {\n        i = node.comments[0].start.offset;\n    }\n    while (i > 0 && /\\s/.test(raw[i - 1])) {\n        --i;\n    }\n    if (raw[i - 1] === ',') {\n        return i - 1;\n    }\n    return -1;\n}\nfunction stringify(value, multiline, depth, indent) {\n    if (value === undefined) {\n        return '';\n    }\n    if (multiline) {\n        const content = JSON.stringify(value, null, indent);\n        const spacing = '\\n' + indent.repeat(depth);\n        return content.replace(/\\n/g, spacing);\n    }\n    else {\n        return JSON.stringify(value);\n    }\n}\nfunction normalizeValue(value, type) {\n    switch (type) {\n        case 'project':\n            return convertJsonProject(value);\n        case 'projectcollection':\n            const projects = convertJsonProjectCollection(value);\n            return Object.keys(projects).length === 0 ? undefined : projects;\n        case 'target':\n            return convertJsonTarget(value);\n        case 'targetcollection':\n            const targets = convertJsonTargetCollection(value);\n            return Object.keys(targets).length === 0 ? undefined : targets;\n        default:\n            return value;\n    }\n}\nfunction updateJsonWorkspace(metadata) {\n    const data = new magic_string_1.default(metadata.raw);\n    const indent = data.getIndentString();\n    const removedCommas = new Set();\n    const nodeChanges = new Map();\n    for (const { op, path, node, value, type } of metadata.changes) {\n        // targets/projects are typically large objects so always use multiline\n        const multiline = node.start.line !== node.end.line || type !== 'json';\n        const pathSegments = path.split('/');\n        const depth = pathSegments.length - 1; // TODO: more complete analysis\n        const propertyOrIndex = utilities_1.unescapeKey(pathSegments[depth]);\n        const jsonValue = normalizeValue(value, type);\n        if (op === 'add' && jsonValue === undefined) {\n            continue;\n        }\n        // Track changes to the order/size of any modified objects/arrays\n        let elements = nodeChanges.get(node);\n        if (!elements) {\n            if (node.kind === 'array') {\n                elements = node.elements.slice();\n                nodeChanges.set(node, elements);\n            }\n            else if (node.kind === 'object') {\n                elements = node.properties.slice();\n                nodeChanges.set(node, elements);\n            }\n            else {\n                // keyvalue\n                elements = [];\n            }\n        }\n        switch (op) {\n            case 'add':\n                let contentPrefix = '';\n                if (node.kind === 'object') {\n                    contentPrefix = `\"${propertyOrIndex}\": `;\n                }\n                const spacing = multiline ? '\\n' + indent.repeat(depth) : ' ';\n                const content = spacing + contentPrefix + stringify(jsonValue, multiline, depth, indent);\n                // Additions are handled after analyzing all operations\n                // This is mainly to support array operations which can occur at arbitrary indices\n                if (node.kind === 'object') {\n                    // Object property additions are always added at the end for simplicity\n                    elements.push(content);\n                }\n                else {\n                    // Add place holders if adding an index past the length\n                    // An empty string is an impossible real value\n                    for (let i = elements.length; i < +propertyOrIndex; ++i) {\n                        elements[i] = '';\n                    }\n                    if (elements[+propertyOrIndex] === '') {\n                        elements[+propertyOrIndex] = content;\n                    }\n                    else {\n                        elements.splice(+propertyOrIndex, 0, content);\n                    }\n                }\n                break;\n            case 'remove':\n                let removalIndex = -1;\n                if (node.kind === 'object') {\n                    removalIndex = elements.findIndex(e => {\n                        return typeof e != 'string' && e.kind === 'keyvalue' && e.key.value === propertyOrIndex;\n                    });\n                }\n                else if (node.kind === 'array') {\n                    removalIndex = +propertyOrIndex;\n                }\n                if (removalIndex === -1) {\n                    continue;\n                }\n                const nodeToRemove = elements[removalIndex];\n                if (typeof nodeToRemove === 'string') {\n                    // synthetic\n                    elements.splice(removalIndex, 1);\n                    continue;\n                }\n                if (elements.length - 1 === removalIndex) {\n                    // If the element is a terminal element remove the otherwise trailing comma\n                    const commaIndex = findPrecedingComma(nodeToRemove, data.original);\n                    if (commaIndex !== -1) {\n                        data.remove(commaIndex, commaIndex + 1);\n                        removedCommas.add(commaIndex);\n                    }\n                }\n                data.remove(findFullStart(nodeToRemove, data.original), findFullEnd(nodeToRemove, data.original));\n                elements.splice(removalIndex, 1);\n                break;\n            case 'replace':\n                let nodeToReplace;\n                if (node.kind === 'keyvalue') {\n                    nodeToReplace = node.value;\n                }\n                else if (node.kind === 'array') {\n                    nodeToReplace = elements[+propertyOrIndex];\n                    if (typeof nodeToReplace === 'string') {\n                        // Was already modified. This is already handled.\n                        continue;\n                    }\n                }\n                else {\n                    continue;\n                }\n                nodeChanges.delete(nodeToReplace);\n                data.overwrite(nodeToReplace.start.offset, nodeToReplace.end.offset, stringify(jsonValue, multiline, depth, indent));\n                break;\n        }\n    }\n    for (const [node, elements] of nodeChanges.entries()) {\n        let parentPoint = 1 + data.original.indexOf(node.kind === 'array' ? '[' : '{', node.start.offset);\n        // Short-circuit for simple case\n        if (elements.length === 1 && typeof elements[0] === 'string') {\n            data.appendRight(parentPoint, elements[0]);\n            continue;\n        }\n        // Combine adjecent element additions to minimize/simplify insertions\n        const optimizedElements = [];\n        for (let i = 0; i < elements.length; ++i) {\n            const element = elements[i];\n            if (typeof element === 'string' && i > 0 && typeof elements[i - 1] === 'string') {\n                optimizedElements[optimizedElements.length - 1] += ',' + element;\n            }\n            else {\n                optimizedElements.push(element);\n            }\n        }\n        let prefixComma = false;\n        for (const element of optimizedElements) {\n            if (typeof element === 'string') {\n                data.appendRight(parentPoint, (prefixComma ? ',' : '') + element);\n            }\n            else {\n                parentPoint = findFullEnd(element, data.original);\n                prefixComma = data.original[parentPoint - 1] !== ',' || removedCommas.has(parentPoint - 1);\n            }\n        }\n    }\n    const result = data.toString();\n    return result;\n}\n"]},"metadata":{},"sourceType":"script"}