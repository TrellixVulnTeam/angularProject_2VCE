{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar BrowserResult = require('./browser_result');\n\nvar helper = require('./helper');\n\nvar BrowserCollection = /*#__PURE__*/function () {\n  function BrowserCollection(emitter) {\n    var browsers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, BrowserCollection);\n\n    this.browsers = browsers;\n    this.emitter = emitter;\n  }\n\n  _createClass(BrowserCollection, [{\n    key: \"add\",\n    value: function add(browser) {\n      this.browsers.push(browser);\n      this.emitter.emit('browsers_change', this);\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(browser) {\n      if (helper.arrayRemove(this.browsers, browser)) {\n        this.emitter.emit('browsers_change', this);\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getById\",\n    value: function getById(browserId) {\n      return this.browsers.find(function (browser) {\n        return browser.id === browserId;\n      }) || null;\n    }\n  }, {\n    key: \"getNonReady\",\n    value: function getNonReady() {\n      return this.browsers.filter(function (browser) {\n        return !browser.isConnected();\n      });\n    }\n  }, {\n    key: \"areAllReady\",\n    value: function areAllReady() {\n      return this.browsers.every(function (browser) {\n        return browser.isConnected();\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return this.browsers.map(function (browser) {\n        return browser.serialize();\n      });\n    }\n  }, {\n    key: \"calculateExitCode\",\n    value: function calculateExitCode(results, singleRunBrowserNotCaptured, config) {\n      config = config || {};\n\n      if (results.disconnected || singleRunBrowserNotCaptured) {\n        return 1;\n      }\n\n      if (results.skipped && config.failOnSkippedTests) {\n        return 1;\n      }\n\n      if (results.success + results.failed === 0 && !!config.failOnEmptyTestSuite) {\n        return 1;\n      }\n\n      if (results.error) {\n        return 1;\n      }\n\n      if (config.failOnFailingTestSuite === false) {\n        return 0; // Tests executed without infrastructure error, exit with 0 independent of test status.\n      }\n\n      return results.failed ? 1 : 0;\n    }\n  }, {\n    key: \"getResults\",\n    value: function getResults(singleRunBrowserNotCaptured, config) {\n      var results = {\n        success: 0,\n        failed: 0,\n        skipped: 0,\n        error: false,\n        disconnected: false,\n        exitCode: 0\n      };\n      this.browsers.forEach(function (browser) {\n        results.success += browser.lastResult.success;\n        results.failed += browser.lastResult.failed;\n        results.skipped += browser.lastResult.skipped;\n        results.error = results.error || browser.lastResult.error;\n        results.disconnected = results.disconnected || browser.lastResult.disconnected;\n      });\n      results.exitCode = this.calculateExitCode(results, singleRunBrowserNotCaptured, config);\n      return results;\n    }\n  }, {\n    key: \"clearResults\",\n    value: function clearResults() {\n      this.browsers.forEach(function (browser) {\n        browser.lastResult = new BrowserResult();\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new BrowserCollection(this.emitter, this.browsers.slice());\n    } // Array APIs\n\n  }, {\n    key: \"map\",\n    value: function map(callback, context) {\n      return this.browsers.map(callback, context);\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, context) {\n      return this.browsers.forEach(callback, context);\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.browsers.length;\n    }\n  }]);\n\n  return BrowserCollection;\n}();\n\nBrowserCollection.factory = function (emitter) {\n  return new BrowserCollection(emitter);\n};\n\nmodule.exports = BrowserCollection;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/karma/lib/browser_collection.js"],"names":["BrowserResult","require","helper","BrowserCollection","emitter","browsers","browser","push","emit","arrayRemove","browserId","find","id","filter","isConnected","every","map","serialize","results","singleRunBrowserNotCaptured","config","disconnected","skipped","failOnSkippedTests","success","failed","failOnEmptyTestSuite","error","failOnFailingTestSuite","exitCode","forEach","lastResult","calculateExitCode","slice","callback","context","length","factory","module","exports"],"mappings":"AAAA;;;;;;AAEA,IAAMA,aAAa,GAAGC,OAAO,CAAC,kBAAD,CAA7B;;AACA,IAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;IAEME,iB;AACJ,6BAAaC,OAAb,EAAqC;AAAA,QAAfC,QAAe,uEAAJ,EAAI;;AAAA;;AACnC,SAAKA,QAAL,GAAgBA,QAAhB;AACA,SAAKD,OAAL,GAAeA,OAAf;AACD;;;;WAED,aAAKE,OAAL,EAAc;AACZ,WAAKD,QAAL,CAAcE,IAAd,CAAmBD,OAAnB;AACA,WAAKF,OAAL,CAAaI,IAAb,CAAkB,iBAAlB,EAAqC,IAArC;AACD;;;WAED,gBAAQF,OAAR,EAAiB;AACf,UAAIJ,MAAM,CAACO,WAAP,CAAmB,KAAKJ,QAAxB,EAAkCC,OAAlC,CAAJ,EAAgD;AAC9C,aAAKF,OAAL,CAAaI,IAAb,CAAkB,iBAAlB,EAAqC,IAArC;AACA,eAAO,IAAP;AACD;;AACD,aAAO,KAAP;AACD;;;WAED,iBAASE,SAAT,EAAoB;AAClB,aAAO,KAAKL,QAAL,CAAcM,IAAd,CAAmB,UAACL,OAAD;AAAA,eAAaA,OAAO,CAACM,EAAR,KAAeF,SAA5B;AAAA,OAAnB,KAA6D,IAApE;AACD;;;WAED,uBAAe;AACb,aAAO,KAAKL,QAAL,CAAcQ,MAAd,CAAqB,UAACP,OAAD;AAAA,eAAa,CAACA,OAAO,CAACQ,WAAR,EAAd;AAAA,OAArB,CAAP;AACD;;;WAED,uBAAe;AACb,aAAO,KAAKT,QAAL,CAAcU,KAAd,CAAoB,UAACT,OAAD;AAAA,eAAaA,OAAO,CAACQ,WAAR,EAAb;AAAA,OAApB,CAAP;AACD;;;WAED,qBAAa;AACX,aAAO,KAAKT,QAAL,CAAcW,GAAd,CAAkB,UAACV,OAAD;AAAA,eAAaA,OAAO,CAACW,SAAR,EAAb;AAAA,OAAlB,CAAP;AACD;;;WAED,2BAAmBC,OAAnB,EAA4BC,2BAA5B,EAAyDC,MAAzD,EAAiE;AAC/DA,MAAAA,MAAM,GAAGA,MAAM,IAAI,EAAnB;;AACA,UAAIF,OAAO,CAACG,YAAR,IAAwBF,2BAA5B,EAAyD;AACvD,eAAO,CAAP;AACD;;AACD,UAAID,OAAO,CAACI,OAAR,IAAmBF,MAAM,CAACG,kBAA9B,EAAkD;AAChD,eAAO,CAAP;AACD;;AACD,UAAIL,OAAO,CAACM,OAAR,GAAkBN,OAAO,CAACO,MAA1B,KAAqC,CAArC,IAA0C,CAAC,CAACL,MAAM,CAACM,oBAAvD,EAA6E;AAC3E,eAAO,CAAP;AACD;;AACD,UAAIR,OAAO,CAACS,KAAZ,EAAmB;AACjB,eAAO,CAAP;AACD;;AACD,UAAIP,MAAM,CAACQ,sBAAP,KAAkC,KAAtC,EAA6C;AAC3C,eAAO,CAAP,CAD2C,CAClC;AACV;;AACD,aAAOV,OAAO,CAACO,MAAR,GAAiB,CAAjB,GAAqB,CAA5B;AACD;;;WAED,oBAAYN,2BAAZ,EAAyCC,MAAzC,EAAiD;AAC/C,UAAMF,OAAO,GAAG;AAAEM,QAAAA,OAAO,EAAE,CAAX;AAAcC,QAAAA,MAAM,EAAE,CAAtB;AAAyBH,QAAAA,OAAO,EAAE,CAAlC;AAAqCK,QAAAA,KAAK,EAAE,KAA5C;AAAmDN,QAAAA,YAAY,EAAE,KAAjE;AAAwEQ,QAAAA,QAAQ,EAAE;AAAlF,OAAhB;AACA,WAAKxB,QAAL,CAAcyB,OAAd,CAAsB,UAACxB,OAAD,EAAa;AACjCY,QAAAA,OAAO,CAACM,OAAR,IAAmBlB,OAAO,CAACyB,UAAR,CAAmBP,OAAtC;AACAN,QAAAA,OAAO,CAACO,MAAR,IAAkBnB,OAAO,CAACyB,UAAR,CAAmBN,MAArC;AACAP,QAAAA,OAAO,CAACI,OAAR,IAAmBhB,OAAO,CAACyB,UAAR,CAAmBT,OAAtC;AACAJ,QAAAA,OAAO,CAACS,KAAR,GAAgBT,OAAO,CAACS,KAAR,IAAiBrB,OAAO,CAACyB,UAAR,CAAmBJ,KAApD;AACAT,QAAAA,OAAO,CAACG,YAAR,GAAuBH,OAAO,CAACG,YAAR,IAAwBf,OAAO,CAACyB,UAAR,CAAmBV,YAAlE;AACD,OAND;AAQAH,MAAAA,OAAO,CAACW,QAAR,GAAmB,KAAKG,iBAAL,CAAuBd,OAAvB,EAAgCC,2BAAhC,EAA6DC,MAA7D,CAAnB;AACA,aAAOF,OAAP;AACD;;;WAED,wBAAgB;AACd,WAAKb,QAAL,CAAcyB,OAAd,CAAsB,UAACxB,OAAD,EAAa;AACjCA,QAAAA,OAAO,CAACyB,UAAR,GAAqB,IAAI/B,aAAJ,EAArB;AACD,OAFD;AAGD;;;WAED,iBAAS;AACP,aAAO,IAAIG,iBAAJ,CAAsB,KAAKC,OAA3B,EAAoC,KAAKC,QAAL,CAAc4B,KAAd,EAApC,CAAP;AACD,K,CAED;;;;WACA,aAAKC,QAAL,EAAeC,OAAf,EAAwB;AACtB,aAAO,KAAK9B,QAAL,CAAcW,GAAd,CAAkBkB,QAAlB,EAA4BC,OAA5B,CAAP;AACD;;;WAED,iBAASD,QAAT,EAAmBC,OAAnB,EAA4B;AAC1B,aAAO,KAAK9B,QAAL,CAAcyB,OAAd,CAAsBI,QAAtB,EAAgCC,OAAhC,CAAP;AACD;;;SAED,eAAc;AACZ,aAAO,KAAK9B,QAAL,CAAc+B,MAArB;AACD;;;;;;AAGHjC,iBAAiB,CAACkC,OAAlB,GAA4B,UAAUjC,OAAV,EAAmB;AAC7C,SAAO,IAAID,iBAAJ,CAAsBC,OAAtB,CAAP;AACD,CAFD;;AAIAkC,MAAM,CAACC,OAAP,GAAiBpC,iBAAjB","sourcesContent":["'use strict'\n\nconst BrowserResult = require('./browser_result')\nconst helper = require('./helper')\n\nclass BrowserCollection {\n  constructor (emitter, browsers = []) {\n    this.browsers = browsers\n    this.emitter = emitter\n  }\n\n  add (browser) {\n    this.browsers.push(browser)\n    this.emitter.emit('browsers_change', this)\n  }\n\n  remove (browser) {\n    if (helper.arrayRemove(this.browsers, browser)) {\n      this.emitter.emit('browsers_change', this)\n      return true\n    }\n    return false\n  }\n\n  getById (browserId) {\n    return this.browsers.find((browser) => browser.id === browserId) || null\n  }\n\n  getNonReady () {\n    return this.browsers.filter((browser) => !browser.isConnected())\n  }\n\n  areAllReady () {\n    return this.browsers.every((browser) => browser.isConnected())\n  }\n\n  serialize () {\n    return this.browsers.map((browser) => browser.serialize())\n  }\n\n  calculateExitCode (results, singleRunBrowserNotCaptured, config) {\n    config = config || {}\n    if (results.disconnected || singleRunBrowserNotCaptured) {\n      return 1\n    }\n    if (results.skipped && config.failOnSkippedTests) {\n      return 1\n    }\n    if (results.success + results.failed === 0 && !!config.failOnEmptyTestSuite) {\n      return 1\n    }\n    if (results.error) {\n      return 1\n    }\n    if (config.failOnFailingTestSuite === false) {\n      return 0 // Tests executed without infrastructure error, exit with 0 independent of test status.\n    }\n    return results.failed ? 1 : 0\n  }\n\n  getResults (singleRunBrowserNotCaptured, config) {\n    const results = { success: 0, failed: 0, skipped: 0, error: false, disconnected: false, exitCode: 0 }\n    this.browsers.forEach((browser) => {\n      results.success += browser.lastResult.success\n      results.failed += browser.lastResult.failed\n      results.skipped += browser.lastResult.skipped\n      results.error = results.error || browser.lastResult.error\n      results.disconnected = results.disconnected || browser.lastResult.disconnected\n    })\n\n    results.exitCode = this.calculateExitCode(results, singleRunBrowserNotCaptured, config)\n    return results\n  }\n\n  clearResults () {\n    this.browsers.forEach((browser) => {\n      browser.lastResult = new BrowserResult()\n    })\n  }\n\n  clone () {\n    return new BrowserCollection(this.emitter, this.browsers.slice())\n  }\n\n  // Array APIs\n  map (callback, context) {\n    return this.browsers.map(callback, context)\n  }\n\n  forEach (callback, context) {\n    return this.browsers.forEach(callback, context)\n  }\n\n  get length () {\n    return this.browsers.length\n  }\n}\n\nBrowserCollection.factory = function (emitter) {\n  return new BrowserCollection(emitter)\n}\n\nmodule.exports = BrowserCollection\n"]},"metadata":{},"sourceType":"script"}