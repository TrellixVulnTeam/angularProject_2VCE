{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/template_parser/template_parser\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/expression_parser/ast\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/ml_parser/ast\", \"@angular/compiler/src/ml_parser/html_parser\", \"@angular/compiler/src/ml_parser/html_whitespaces\", \"@angular/compiler/src/ml_parser/icu_ast_expander\", \"@angular/compiler/src/ml_parser/interpolation_config\", \"@angular/compiler/src/ml_parser/tags\", \"@angular/compiler/src/parse_util\", \"@angular/compiler/src/provider_analyzer\", \"@angular/compiler/src/selector\", \"@angular/compiler/src/style_url_resolver\", \"@angular/compiler/src/util\", \"@angular/compiler/src/template_parser/binding_parser\", \"@angular/compiler/src/template_parser/template_ast\", \"@angular/compiler/src/template_parser/template_preparser\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isEmptyExpression = exports.removeSummaryDuplicates = exports.createElementCssSelector = exports.splitClasses = exports.TemplateParser = exports.TemplateParseResult = exports.TemplateParseError = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var ast_1 = require(\"@angular/compiler/src/expression_parser/ast\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var html = require(\"@angular/compiler/src/ml_parser/ast\");\n\n  var html_parser_1 = require(\"@angular/compiler/src/ml_parser/html_parser\");\n\n  var html_whitespaces_1 = require(\"@angular/compiler/src/ml_parser/html_whitespaces\");\n\n  var icu_ast_expander_1 = require(\"@angular/compiler/src/ml_parser/icu_ast_expander\");\n\n  var interpolation_config_1 = require(\"@angular/compiler/src/ml_parser/interpolation_config\");\n\n  var tags_1 = require(\"@angular/compiler/src/ml_parser/tags\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var provider_analyzer_1 = require(\"@angular/compiler/src/provider_analyzer\");\n\n  var selector_1 = require(\"@angular/compiler/src/selector\");\n\n  var style_url_resolver_1 = require(\"@angular/compiler/src/style_url_resolver\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var binding_parser_1 = require(\"@angular/compiler/src/template_parser/binding_parser\");\n\n  var t = require(\"@angular/compiler/src/template_parser/template_ast\");\n\n  var template_preparser_1 = require(\"@angular/compiler/src/template_parser/template_preparser\");\n\n  var BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/; // Group 1 = \"bind-\"\n\n  var KW_BIND_IDX = 1; // Group 2 = \"let-\"\n\n  var KW_LET_IDX = 2; // Group 3 = \"ref-/#\"\n\n  var KW_REF_IDX = 3; // Group 4 = \"on-\"\n\n  var KW_ON_IDX = 4; // Group 5 = \"bindon-\"\n\n  var KW_BINDON_IDX = 5; // Group 6 = \"@\"\n\n  var KW_AT_IDX = 6; // Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n\n  var IDENT_KW_IDX = 7; // Group 8 = identifier inside [()]\n\n  var IDENT_BANANA_BOX_IDX = 8; // Group 9 = identifier inside []\n\n  var IDENT_PROPERTY_IDX = 9; // Group 10 = identifier inside ()\n\n  var IDENT_EVENT_IDX = 10;\n  var TEMPLATE_ATTR_PREFIX = '*';\n  var CLASS_ATTR = 'class';\n\n  var _TEXT_CSS_SELECTOR;\n\n  function TEXT_CSS_SELECTOR() {\n    if (!_TEXT_CSS_SELECTOR) {\n      _TEXT_CSS_SELECTOR = selector_1.CssSelector.parse('*')[0];\n    }\n\n    return _TEXT_CSS_SELECTOR;\n  }\n\n  var TemplateParseError =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TemplateParseError, _super);\n\n    function TemplateParseError(message, span, level) {\n      return _super.call(this, span, message, level) || this;\n    }\n\n    return TemplateParseError;\n  }(parse_util_1.ParseError);\n\n  exports.TemplateParseError = TemplateParseError;\n\n  var TemplateParseResult =\n  /** @class */\n  function () {\n    function TemplateParseResult(templateAst, usedPipes, errors) {\n      this.templateAst = templateAst;\n      this.usedPipes = usedPipes;\n      this.errors = errors;\n    }\n\n    return TemplateParseResult;\n  }();\n\n  exports.TemplateParseResult = TemplateParseResult;\n\n  var TemplateParser =\n  /** @class */\n  function () {\n    function TemplateParser(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n      this._config = _config;\n      this._reflector = _reflector;\n      this._exprParser = _exprParser;\n      this._schemaRegistry = _schemaRegistry;\n      this._htmlParser = _htmlParser;\n      this._console = _console;\n      this.transforms = transforms;\n    }\n\n    Object.defineProperty(TemplateParser.prototype, \"expressionParser\", {\n      get: function get() {\n        return this._exprParser;\n      },\n      enumerable: false,\n      configurable: true\n    });\n\n    TemplateParser.prototype.parse = function (component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n      var _a;\n\n      var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n      var warnings = result.errors.filter(function (error) {\n        return error.level === parse_util_1.ParseErrorLevel.WARNING;\n      });\n      var errors = result.errors.filter(function (error) {\n        return error.level === parse_util_1.ParseErrorLevel.ERROR;\n      });\n\n      if (warnings.length > 0) {\n        (_a = this._console) === null || _a === void 0 ? void 0 : _a.warn(\"Template parse warnings:\\n\" + warnings.join('\\n'));\n      }\n\n      if (errors.length > 0) {\n        var errorString = errors.join('\\n');\n        throw util_1.syntaxError(\"Template parse errors:\\n\" + errorString, errors);\n      }\n\n      return {\n        template: result.templateAst,\n        pipes: result.usedPipes\n      };\n    };\n\n    TemplateParser.prototype.tryParse = function (component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n      var htmlParseResult = typeof template === 'string' ? this._htmlParser.parse(template, templateUrl, {\n        tokenizeExpansionForms: true,\n        interpolationConfig: this.getInterpolationConfig(component)\n      }) : template;\n\n      if (!preserveWhitespaces) {\n        htmlParseResult = html_whitespaces_1.removeWhitespaces(htmlParseResult);\n      }\n\n      return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n    };\n\n    TemplateParser.prototype.tryParseHtml = function (htmlAstWithErrors, component, directives, pipes, schemas) {\n      var result;\n      var errors = htmlAstWithErrors.errors;\n      var usedPipes = [];\n\n      if (htmlAstWithErrors.rootNodes.length > 0) {\n        var uniqDirectives = removeSummaryDuplicates(directives);\n        var uniqPipes = removeSummaryDuplicates(pipes);\n        var providerViewContext = new provider_analyzer_1.ProviderViewContext(this._reflector, component);\n        var interpolationConfig = undefined;\n\n        if (component.template && component.template.interpolation) {\n          interpolationConfig = {\n            start: component.template.interpolation[0],\n            end: component.template.interpolation[1]\n          };\n        }\n\n        var bindingParser = new binding_parser_1.BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\n        var parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n        result = html.visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n        errors.push.apply(errors, tslib_1.__spread(providerViewContext.errors));\n        usedPipes.push.apply(usedPipes, tslib_1.__spread(bindingParser.getUsedPipes()));\n      } else {\n        result = [];\n      }\n\n      this._assertNoReferenceDuplicationOnTemplate(result, errors);\n\n      if (errors.length > 0) {\n        return new TemplateParseResult(result, usedPipes, errors);\n      }\n\n      if (this.transforms) {\n        this.transforms.forEach(function (transform) {\n          result = t.templateVisitAll(transform, result);\n        });\n      }\n\n      return new TemplateParseResult(result, usedPipes, errors);\n    };\n\n    TemplateParser.prototype.expandHtml = function (htmlAstWithErrors, forced) {\n      if (forced === void 0) {\n        forced = false;\n      }\n\n      var errors = htmlAstWithErrors.errors;\n\n      if (errors.length == 0 || forced) {\n        // Transform ICU messages to angular directives\n        var expandedHtmlAst = icu_ast_expander_1.expandNodes(htmlAstWithErrors.rootNodes);\n        errors.push.apply(errors, tslib_1.__spread(expandedHtmlAst.errors));\n        htmlAstWithErrors = new html_parser_1.ParseTreeResult(expandedHtmlAst.nodes, errors);\n      }\n\n      return htmlAstWithErrors;\n    };\n\n    TemplateParser.prototype.getInterpolationConfig = function (component) {\n      if (component.template) {\n        return interpolation_config_1.InterpolationConfig.fromArray(component.template.interpolation);\n      }\n\n      return undefined;\n    };\n    /** @internal */\n\n\n    TemplateParser.prototype._assertNoReferenceDuplicationOnTemplate = function (result, errors) {\n      var existingReferences = [];\n      result.filter(function (element) {\n        return !!element.references;\n      }).forEach(function (element) {\n        return element.references.forEach(function (reference) {\n          var name = reference.name;\n\n          if (existingReferences.indexOf(name) < 0) {\n            existingReferences.push(name);\n          } else {\n            var error = new TemplateParseError(\"Reference \\\"#\" + name + \"\\\" is defined several times\", reference.sourceSpan, parse_util_1.ParseErrorLevel.ERROR);\n            errors.push(error);\n          }\n        });\n      });\n    };\n\n    return TemplateParser;\n  }();\n\n  exports.TemplateParser = TemplateParser;\n\n  var TemplateParseVisitor =\n  /** @class */\n  function () {\n    function TemplateParseVisitor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n      var _this = this;\n\n      this.reflector = reflector;\n      this.config = config;\n      this.providerViewContext = providerViewContext;\n      this._bindingParser = _bindingParser;\n      this._schemaRegistry = _schemaRegistry;\n      this._schemas = _schemas;\n      this._targetErrors = _targetErrors;\n      this.selectorMatcher = new selector_1.SelectorMatcher();\n      this.directivesIndex = new Map();\n      this.ngContentCount = 0; // Note: queries start with id 1 so we can use the number in a Bloom filter!\n\n      this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n      directives.forEach(function (directive, index) {\n        var selector = selector_1.CssSelector.parse(directive.selector);\n\n        _this.selectorMatcher.addSelectables(selector, directive);\n\n        _this.directivesIndex.set(directive, index);\n      });\n    }\n\n    TemplateParseVisitor.prototype.visitExpansion = function (expansion, context) {\n      return null;\n    };\n\n    TemplateParseVisitor.prototype.visitExpansionCase = function (expansionCase, context) {\n      return null;\n    };\n\n    TemplateParseVisitor.prototype.visitText = function (text, parent) {\n      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n      var valueNoNgsp = html_whitespaces_1.replaceNgsp(text.value);\n\n      var expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\n\n      return expr ? new t.BoundTextAst(expr, ngContentIndex, text.sourceSpan) : new t.TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);\n    };\n\n    TemplateParseVisitor.prototype.visitAttribute = function (attribute, context) {\n      return new t.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n\n    TemplateParseVisitor.prototype.visitComment = function (comment, context) {\n      return null;\n    };\n\n    TemplateParseVisitor.prototype.visitElement = function (element, parent) {\n      var _this = this;\n\n      var queryStartIndex = this.contentQueryStartId;\n      var elName = element.name;\n      var preparsedElement = template_preparser_1.preparseElement(element);\n\n      if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT || preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE) {\n        // Skipping <script> for security reasons\n        // Skipping <style> as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      if (preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET && style_url_resolver_1.isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n        // Skipping stylesheets with either relative urls or package scheme as we already processed\n        // them in the StyleCompiler\n        return null;\n      }\n\n      var matchableAttrs = [];\n      var elementOrDirectiveProps = [];\n      var elementOrDirectiveRefs = [];\n      var elementVars = [];\n      var events = [];\n      var templateElementOrDirectiveProps = [];\n      var templateMatchableAttrs = [];\n      var templateElementVars = [];\n      var hasInlineTemplates = false;\n      var attrs = [];\n      var isTemplateElement = tags_1.isNgTemplate(element.name);\n      element.attrs.forEach(function (attr) {\n        var parsedVariables = [];\n\n        var hasBinding = _this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n\n        elementVars.push.apply(elementVars, tslib_1.__spread(parsedVariables.map(function (v) {\n          return t.VariableAst.fromParsedVariable(v);\n        })));\n        var templateValue;\n        var templateKey;\n\n        var normalizedName = _this._normalizeAttributeName(attr.name);\n\n        if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n          templateValue = attr.value;\n          templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n        }\n\n        var hasTemplateBinding = templateValue != null;\n\n        if (hasTemplateBinding) {\n          if (hasInlineTemplates) {\n            _this._reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attr.sourceSpan);\n          }\n\n          hasInlineTemplates = true;\n          var parsedVariables_1 = [];\n          var absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;\n\n          _this._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, absoluteOffset, templateMatchableAttrs, templateElementOrDirectiveProps, parsedVariables_1, false\n          /* isIvyAst */\n          );\n\n          templateElementVars.push.apply(templateElementVars, tslib_1.__spread(parsedVariables_1.map(function (v) {\n            return t.VariableAst.fromParsedVariable(v);\n          })));\n        }\n\n        if (!hasBinding && !hasTemplateBinding) {\n          // don't include the bindings as attributes as well in the AST\n          attrs.push(_this.visitAttribute(attr, null));\n          matchableAttrs.push([attr.name, attr.value]);\n        }\n      });\n      var elementCssSelector = createElementCssSelector(elName, matchableAttrs);\n\n      var _a = this._parseDirectives(this.selectorMatcher, elementCssSelector),\n          directiveMetas = _a.directives,\n          matchElement = _a.matchElement;\n\n      var references = [];\n      var boundDirectivePropNames = new Set();\n\n      var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n\n      var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n\n      var isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n      var providerContext = new provider_analyzer_1.ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);\n      var children = html.visitAll(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\n      providerContext.afterElement(); // Override the actual selector when the `ngProjectAs` attribute is provided\n\n      var projectionSelector = preparsedElement.projectAs != '' ? selector_1.CssSelector.parse(preparsedElement.projectAs)[0] : elementCssSelector;\n      var ngContentIndex = parent.findNgContentIndex(projectionSelector);\n      var parsedElement;\n\n      if (preparsedElement.type === template_preparser_1.PreparsedElementType.NG_CONTENT) {\n        // `<ng-content>` element\n        if (element.children && !element.children.every(_isEmptyTextNode)) {\n          this._reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n        }\n\n        parsedElement = new t.NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n      } else if (isTemplateElement) {\n        // `<ng-template>` element\n        this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n\n        this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\n\n        parsedElement = new t.EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n      } else {\n        // element other than `<ng-content>` and `<ng-template>`\n        this._assertElementExists(matchElement, element);\n\n        this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n\n        var ngContentIndex_1 = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n        parsedElement = new t.ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex_1, element.sourceSpan, element.endSourceSpan || null);\n      }\n\n      if (hasInlineTemplates) {\n        // The element as a *-attribute\n        var templateQueryStartIndex = this.contentQueryStartId;\n        var templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\n\n        var directives = this._parseDirectives(this.selectorMatcher, templateSelector).directives;\n\n        var templateBoundDirectivePropNames = new Set();\n\n        var templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);\n\n        var templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n\n        this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\n\n        var templateProviderContext = new provider_analyzer_1.ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n        templateProviderContext.afterElement();\n        parsedElement = new t.EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);\n      }\n\n      return parsedElement;\n    };\n\n    TemplateParseVisitor.prototype._parseAttr = function (isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n      var name = this._normalizeAttributeName(attr.name);\n\n      var value = attr.value;\n      var srcSpan = attr.sourceSpan;\n      var absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;\n      var boundEvents = [];\n      var bindParts = name.match(BIND_NAME_REGEXP);\n      var hasBinding = false;\n\n      if (bindParts !== null) {\n        hasBinding = true;\n\n        if (bindParts[KW_BIND_IDX] != null) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[KW_LET_IDX]) {\n          if (isTemplateElement) {\n            var identifier = bindParts[IDENT_KW_IDX];\n\n            this._parseVariable(identifier, value, srcSpan, targetVars);\n          } else {\n            this._reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n          }\n        } else if (bindParts[KW_REF_IDX]) {\n          var identifier = bindParts[IDENT_KW_IDX];\n\n          this._parseReference(identifier, value, srcSpan, targetRefs);\n        } else if (bindParts[KW_ON_IDX]) {\n          this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[KW_BINDON_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n\n          this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[KW_AT_IDX]) {\n          this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n\n          this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[IDENT_PROPERTY_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[IDENT_EVENT_IDX]) {\n          this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        }\n      } else {\n        hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);\n      }\n\n      if (!hasBinding) {\n        this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n      }\n\n      targetEvents.push.apply(targetEvents, tslib_1.__spread(boundEvents.map(function (e) {\n        return t.BoundEventAst.fromParsedEvent(e);\n      })));\n      return hasBinding;\n    };\n\n    TemplateParseVisitor.prototype._normalizeAttributeName = function (attrName) {\n      return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    };\n\n    TemplateParseVisitor.prototype._parseVariable = function (identifier, value, sourceSpan, targetVars) {\n      if (identifier.indexOf('-') > -1) {\n        this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this._reportError(\"Variable does not have a name\", sourceSpan);\n      }\n\n      targetVars.push(new t.VariableAst(identifier, value, sourceSpan));\n    };\n\n    TemplateParseVisitor.prototype._parseReference = function (identifier, value, sourceSpan, targetRefs) {\n      if (identifier.indexOf('-') > -1) {\n        this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this._reportError(\"Reference does not have a name\", sourceSpan);\n      }\n\n      targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    };\n\n    TemplateParseVisitor.prototype._parseAssignmentEvent = function (name, expression, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents) {\n      this._bindingParser.parseEvent(name + \"Change\", expression + \"=$event\", sourceSpan, valueSpan, targetMatchableAttrs, targetEvents);\n    };\n\n    TemplateParseVisitor.prototype._parseDirectives = function (selectorMatcher, elementCssSelector) {\n      var _this = this; // Need to sort the directives so that we get consistent results throughout,\n      // as selectorMatcher uses Maps inside.\n      // Also deduplicate directives as they might match more than one time!\n\n\n      var directives = util_1.newArray(this.directivesIndex.size); // Whether any directive selector matches on the element name\n\n      var matchElement = false;\n      selectorMatcher.match(elementCssSelector, function (selector, directive) {\n        directives[_this.directivesIndex.get(directive)] = directive;\n        matchElement = matchElement || selector.hasElementSelector();\n      });\n      return {\n        directives: directives.filter(function (dir) {\n          return !!dir;\n        }),\n        matchElement: matchElement\n      };\n    };\n\n    TemplateParseVisitor.prototype._createDirectiveAsts = function (isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n      var _this = this;\n\n      var matchedReferences = new Set();\n      var component = null;\n      var directiveAsts = directives.map(function (directive) {\n        var sourceSpan = new parse_util_1.ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, elementSourceSpan.fullStart, \"Directive \" + compile_metadata_1.identifierName(directive.type));\n\n        if (directive.isComponent) {\n          component = directive;\n        }\n\n        var directiveProperties = [];\n\n        var boundProperties = _this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);\n\n        var hostProperties = boundProperties.map(function (prop) {\n          return t.BoundElementPropertyAst.fromBoundProperty(prop);\n        }); // Note: We need to check the host properties here as well,\n        // as we don't know the element name in the DirectiveWrapperCompiler yet.\n\n        hostProperties = _this._checkPropertiesInSchema(elementName, hostProperties);\n\n        var parsedEvents = _this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\n\n        _this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n          if (elOrDirRef.value.length === 0 && directive.isComponent || elOrDirRef.isReferenceToDirective(directive)) {\n            targetReferences.push(new t.ReferenceAst(elOrDirRef.name, identifiers_1.createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));\n            matchedReferences.add(elOrDirRef.name);\n          }\n        });\n        var hostEvents = parsedEvents.map(function (e) {\n          return t.BoundEventAst.fromParsedEvent(e);\n        });\n        var contentQueryStartId = _this.contentQueryStartId;\n        _this.contentQueryStartId += directive.queries.length;\n        return new t.DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n      });\n      elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n        if (elOrDirRef.value.length > 0) {\n          if (!matchedReferences.has(elOrDirRef.name)) {\n            _this._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\" + elOrDirRef.value + \"\\\"\", elOrDirRef.sourceSpan);\n          }\n        } else if (!component) {\n          var refToken = null;\n\n          if (isTemplateElement) {\n            refToken = identifiers_1.createTokenForExternalReference(_this.reflector, identifiers_1.Identifiers.TemplateRef);\n          }\n\n          targetReferences.push(new t.ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\n        }\n      });\n      return directiveAsts;\n    };\n\n    TemplateParseVisitor.prototype._createDirectivePropertyAsts = function (directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n      if (directiveProperties) {\n        var boundPropsByName_1 = new Map();\n        boundProps.forEach(function (boundProp) {\n          var prevValue = boundPropsByName_1.get(boundProp.name);\n\n          if (!prevValue || prevValue.isLiteral) {\n            // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n            boundPropsByName_1.set(boundProp.name, boundProp);\n          }\n        });\n        Object.keys(directiveProperties).forEach(function (dirProp) {\n          var elProp = directiveProperties[dirProp];\n          var boundProp = boundPropsByName_1.get(elProp); // Bindings are optional, so this binding only needs to be set up if an expression is given.\n\n          if (boundProp) {\n            targetBoundDirectivePropNames.add(boundProp.name);\n\n            if (!isEmptyExpression(boundProp.expression)) {\n              targetBoundDirectiveProps.push(new t.BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n            }\n          }\n        });\n      }\n    };\n\n    TemplateParseVisitor.prototype._createElementPropertyAsts = function (elementName, props, boundDirectivePropNames) {\n      var _this = this;\n\n      var boundElementProps = [];\n      props.forEach(function (prop) {\n        if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n          var boundProp = _this._bindingParser.createBoundElementProperty(elementName, prop);\n\n          boundElementProps.push(t.BoundElementPropertyAst.fromBoundProperty(boundProp));\n        }\n      });\n      return this._checkPropertiesInSchema(elementName, boundElementProps);\n    };\n\n    TemplateParseVisitor.prototype._findComponentDirectives = function (directives) {\n      return directives.filter(function (directive) {\n        return directive.directive.isComponent;\n      });\n    };\n\n    TemplateParseVisitor.prototype._findComponentDirectiveNames = function (directives) {\n      return this._findComponentDirectives(directives).map(function (directive) {\n        return compile_metadata_1.identifierName(directive.directive.type);\n      });\n    };\n\n    TemplateParseVisitor.prototype._assertOnlyOneComponent = function (directives, sourceSpan) {\n      var componentTypeNames = this._findComponentDirectiveNames(directives);\n\n      if (componentTypeNames.length > 1) {\n        this._reportError(\"More than one component matched on this element.\\n\" + \"Make sure that only one component's selector can match a given element.\\n\" + (\"Conflicting components: \" + componentTypeNames.join(',')), sourceSpan);\n      }\n    };\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param matchElement Whether any directive has matched on the tag name\n     * @param element the html element\n     */\n\n\n    TemplateParseVisitor.prototype._assertElementExists = function (matchElement, element) {\n      var elName = element.name.replace(/^:xhtml:/, '');\n\n      if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n        var errorMsg = \"'\" + elName + \"' is not a known element:\\n\";\n        errorMsg += \"1. If '\" + elName + \"' is an Angular component, then verify that it is part of this module.\\n\";\n\n        if (elName.indexOf('-') > -1) {\n          errorMsg += \"2. If '\" + elName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\";\n        } else {\n          errorMsg += \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n        }\n\n        this._reportError(errorMsg, element.sourceSpan);\n      }\n    };\n\n    TemplateParseVisitor.prototype._assertNoComponentsNorElementBindingsOnTemplate = function (directives, elementProps, sourceSpan) {\n      var _this = this;\n\n      var componentTypeNames = this._findComponentDirectiveNames(directives);\n\n      if (componentTypeNames.length > 0) {\n        this._reportError(\"Components on an embedded template: \" + componentTypeNames.join(','), sourceSpan);\n      }\n\n      elementProps.forEach(function (prop) {\n        _this._reportError(\"Property binding \" + prop.name + \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", sourceSpan);\n      });\n    };\n\n    TemplateParseVisitor.prototype._assertAllEventsPublishedByDirectives = function (directives, events) {\n      var _this = this;\n\n      var allDirectiveEvents = new Set();\n      directives.forEach(function (directive) {\n        Object.keys(directive.directive.outputs).forEach(function (k) {\n          var eventName = directive.directive.outputs[k];\n          allDirectiveEvents.add(eventName);\n        });\n      });\n      events.forEach(function (event) {\n        if (event.target != null || !allDirectiveEvents.has(event.name)) {\n          _this._reportError(\"Event binding \" + event.fullName + \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\", event.sourceSpan);\n        }\n      });\n    };\n\n    TemplateParseVisitor.prototype._checkPropertiesInSchema = function (elementName, boundProps) {\n      var _this = this; // Note: We can't filter out empty expressions before this method,\n      // as we still want to validate them!\n\n\n      return boundProps.filter(function (boundProp) {\n        if (boundProp.type === 0\n        /* Property */\n        && !_this._schemaRegistry.hasProperty(elementName, boundProp.name, _this._schemas)) {\n          var errorMsg = \"Can't bind to '\" + boundProp.name + \"' since it isn't a known property of '\" + elementName + \"'.\";\n\n          if (elementName.startsWith('ng-')) {\n            errorMsg += \"\\n1. If '\" + boundProp.name + \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\" + \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n          } else if (elementName.indexOf('-') > -1) {\n            errorMsg += \"\\n1. If '\" + elementName + \"' is an Angular component and it has '\" + boundProp.name + \"' input, then verify that it is part of this module.\" + (\"\\n2. If '\" + elementName + \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") + \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n          }\n\n          _this._reportError(errorMsg, boundProp.sourceSpan);\n        }\n\n        return !isEmptyExpression(boundProp.value);\n      });\n    };\n\n    TemplateParseVisitor.prototype._reportError = function (message, sourceSpan, level) {\n      if (level === void 0) {\n        level = parse_util_1.ParseErrorLevel.ERROR;\n      }\n\n      this._targetErrors.push(new parse_util_1.ParseError(sourceSpan, message, level));\n    };\n\n    return TemplateParseVisitor;\n  }();\n\n  var NonBindableVisitor =\n  /** @class */\n  function () {\n    function NonBindableVisitor() {}\n\n    NonBindableVisitor.prototype.visitElement = function (ast, parent) {\n      var preparsedElement = template_preparser_1.preparseElement(ast);\n\n      if (preparsedElement.type === template_preparser_1.PreparsedElementType.SCRIPT || preparsedElement.type === template_preparser_1.PreparsedElementType.STYLE || preparsedElement.type === template_preparser_1.PreparsedElementType.STYLESHEET) {\n        // Skipping <script> for security reasons\n        // Skipping <style> and stylesheets as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      var attrNameAndValues = ast.attrs.map(function (attr) {\n        return [attr.name, attr.value];\n      });\n      var selector = createElementCssSelector(ast.name, attrNameAndValues);\n      var ngContentIndex = parent.findNgContentIndex(selector);\n      var children = html.visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n      return new t.ElementAst(ast.name, html.visitAll(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    };\n\n    NonBindableVisitor.prototype.visitComment = function (comment, context) {\n      return null;\n    };\n\n    NonBindableVisitor.prototype.visitAttribute = function (attribute, context) {\n      return new t.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    };\n\n    NonBindableVisitor.prototype.visitText = function (text, parent) {\n      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n      return new t.TextAst(text.value, ngContentIndex, text.sourceSpan);\n    };\n\n    NonBindableVisitor.prototype.visitExpansion = function (expansion, context) {\n      return expansion;\n    };\n\n    NonBindableVisitor.prototype.visitExpansionCase = function (expansionCase, context) {\n      return expansionCase;\n    };\n\n    return NonBindableVisitor;\n  }();\n  /**\n   * A reference to an element or directive in a template. E.g., the reference in this template:\n   *\n   * <div #myMenu=\"coolMenu\">\n   *\n   * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\n   */\n\n\n  var ElementOrDirectiveRef =\n  /** @class */\n  function () {\n    function ElementOrDirectiveRef(name, value, sourceSpan) {\n      this.name = name;\n      this.value = value;\n      this.sourceSpan = sourceSpan;\n    }\n    /** Gets whether this is a reference to the given directive. */\n\n\n    ElementOrDirectiveRef.prototype.isReferenceToDirective = function (directive) {\n      return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n    };\n\n    return ElementOrDirectiveRef;\n  }();\n  /** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\n\n\n  function splitExportAs(exportAs) {\n    return exportAs ? exportAs.split(',').map(function (e) {\n      return e.trim();\n    }) : [];\n  }\n\n  function splitClasses(classAttrValue) {\n    return classAttrValue.trim().split(/\\s+/g);\n  }\n\n  exports.splitClasses = splitClasses;\n\n  var ElementContext =\n  /** @class */\n  function () {\n    function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n      this.isTemplateElement = isTemplateElement;\n      this._ngContentIndexMatcher = _ngContentIndexMatcher;\n      this._wildcardNgContentIndex = _wildcardNgContentIndex;\n      this.providerContext = providerContext;\n    }\n\n    ElementContext.create = function (isTemplateElement, directives, providerContext) {\n      var matcher = new selector_1.SelectorMatcher();\n      var wildcardNgContentIndex = null;\n      var component = directives.find(function (directive) {\n        return directive.directive.isComponent;\n      });\n\n      if (component) {\n        var ngContentSelectors = component.directive.template.ngContentSelectors;\n\n        for (var i = 0; i < ngContentSelectors.length; i++) {\n          var selector = ngContentSelectors[i];\n\n          if (selector === '*') {\n            wildcardNgContentIndex = i;\n          } else {\n            matcher.addSelectables(selector_1.CssSelector.parse(ngContentSelectors[i]), i);\n          }\n        }\n      }\n\n      return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    };\n\n    ElementContext.prototype.findNgContentIndex = function (selector) {\n      var ngContentIndices = [];\n\n      this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) {\n        ngContentIndices.push(ngContentIndex);\n      });\n\n      ngContentIndices.sort();\n\n      if (this._wildcardNgContentIndex != null) {\n        ngContentIndices.push(this._wildcardNgContentIndex);\n      }\n\n      return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    };\n\n    return ElementContext;\n  }();\n\n  function createElementCssSelector(elementName, attributes) {\n    var cssSelector = new selector_1.CssSelector();\n    var elNameNoNs = tags_1.splitNsName(elementName)[1];\n    cssSelector.setElement(elNameNoNs);\n\n    for (var i = 0; i < attributes.length; i++) {\n      var attrName = attributes[i][0];\n      var attrNameNoNs = tags_1.splitNsName(attrName)[1];\n      var attrValue = attributes[i][1];\n      cssSelector.addAttribute(attrNameNoNs, attrValue);\n\n      if (attrName.toLowerCase() == CLASS_ATTR) {\n        var classes = splitClasses(attrValue);\n        classes.forEach(function (className) {\n          return cssSelector.addClassName(className);\n        });\n      }\n    }\n\n    return cssSelector;\n  }\n\n  exports.createElementCssSelector = createElementCssSelector;\n  var EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new selector_1.SelectorMatcher(), null, null);\n  var NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\n  function _isEmptyTextNode(node) {\n    return node instanceof html.Text && node.value.trim().length == 0;\n  }\n\n  function removeSummaryDuplicates(items) {\n    var map = new Map();\n    items.forEach(function (item) {\n      if (!map.get(item.type.reference)) {\n        map.set(item.type.reference, item);\n      }\n    });\n    return Array.from(map.values());\n  }\n\n  exports.removeSummaryDuplicates = removeSummaryDuplicates;\n\n  function isEmptyExpression(ast) {\n    if (ast instanceof ast_1.ASTWithSource) {\n      ast = ast.ast;\n    }\n\n    return ast instanceof ast_1.EmptyExpr;\n  }\n\n  exports.isEmptyExpression = isEmptyExpression;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/template_parser/template_parser.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, CompileDirectiveSummary, CompilePipeSummary, CompileTokenMetadata, CompileTypeMetadata, identifierName} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {CompilerConfig} from '../config';\nimport {SchemaMetadata} from '../core';\nimport {AST, ASTWithSource, EmptyExpr, ParsedEvent, ParsedProperty, ParsedVariable} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {createTokenForExternalReference, createTokenForReference, Identifiers} from '../identifiers';\nimport * as html from '../ml_parser/ast';\nimport {HtmlParser, ParseTreeResult} from '../ml_parser/html_parser';\nimport {removeWhitespaces, replaceNgsp} from '../ml_parser/html_whitespaces';\nimport {expandNodes} from '../ml_parser/icu_ast_expander';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {isNgTemplate, splitNsName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ProviderElementContext, ProviderViewContext} from '../provider_analyzer';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector, SelectorMatcher} from '../selector';\nimport {isStyleUrlResolvable} from '../style_url_resolver';\nimport {Console, newArray, syntaxError} from '../util';\n\nimport {BindingParser} from './binding_parser';\nimport * as t from './template_ast';\nimport {PreparsedElementType, preparseElement} from './template_preparser';\n\nconst BIND_NAME_REGEXP =\n    /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\n\n// Group 1 = \"bind-\"\nconst KW_BIND_IDX = 1;\n// Group 2 = \"let-\"\nconst KW_LET_IDX = 2;\n// Group 3 = \"ref-/#\"\nconst KW_REF_IDX = 3;\n// Group 4 = \"on-\"\nconst KW_ON_IDX = 4;\n// Group 5 = \"bindon-\"\nconst KW_BINDON_IDX = 5;\n// Group 6 = \"@\"\nconst KW_AT_IDX = 6;\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\nconst IDENT_KW_IDX = 7;\n// Group 8 = identifier inside [()]\nconst IDENT_BANANA_BOX_IDX = 8;\n// Group 9 = identifier inside []\nconst IDENT_PROPERTY_IDX = 9;\n// Group 10 = identifier inside ()\nconst IDENT_EVENT_IDX = 10;\n\nconst TEMPLATE_ATTR_PREFIX = '*';\nconst CLASS_ATTR = 'class';\n\nlet _TEXT_CSS_SELECTOR!: CssSelector;\nfunction TEXT_CSS_SELECTOR(): CssSelector {\n  if (!_TEXT_CSS_SELECTOR) {\n    _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\n  }\n  return _TEXT_CSS_SELECTOR;\n}\n\nexport class TemplateParseError extends ParseError {\n  constructor(message: string, span: ParseSourceSpan, level: ParseErrorLevel) {\n    super(span, message, level);\n  }\n}\n\nexport class TemplateParseResult {\n  constructor(\n      public templateAst?: t.TemplateAst[], public usedPipes?: CompilePipeSummary[],\n      public errors?: ParseError[]) {}\n}\n\nexport class TemplateParser {\n  constructor(\n      private _config: CompilerConfig, private _reflector: CompileReflector,\n      private _exprParser: Parser, private _schemaRegistry: ElementSchemaRegistry,\n      private _htmlParser: HtmlParser, private _console: Console|null,\n      public transforms: t.TemplateAstVisitor[]) {}\n\n  public get expressionParser() {\n    return this._exprParser;\n  }\n\n  parse(\n      component: CompileDirectiveMetadata, template: string|ParseTreeResult,\n      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[],\n      templateUrl: string,\n      preserveWhitespaces: boolean): {template: t.TemplateAst[], pipes: CompilePipeSummary[]} {\n    const result = this.tryParse(\n        component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n    const warnings = result.errors!.filter(error => error.level === ParseErrorLevel.WARNING);\n\n    const errors = result.errors!.filter(error => error.level === ParseErrorLevel.ERROR);\n\n    if (warnings.length > 0) {\n      this._console?.warn(`Template parse warnings:\\n${warnings.join('\\n')}`);\n    }\n\n    if (errors.length > 0) {\n      const errorString = errors.join('\\n');\n      throw syntaxError(`Template parse errors:\\n${errorString}`, errors);\n    }\n\n    return {template: result.templateAst!, pipes: result.usedPipes!};\n  }\n\n  tryParse(\n      component: CompileDirectiveMetadata, template: string|ParseTreeResult,\n      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[], schemas: SchemaMetadata[],\n      templateUrl: string, preserveWhitespaces: boolean): TemplateParseResult {\n    let htmlParseResult = typeof template === 'string' ?\n        this._htmlParser!.parse(template, templateUrl, {\n          tokenizeExpansionForms: true,\n          interpolationConfig: this.getInterpolationConfig(component)\n        }) :\n        template;\n\n    if (!preserveWhitespaces) {\n      htmlParseResult = removeWhitespaces(htmlParseResult);\n    }\n\n    return this.tryParseHtml(\n        this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n  }\n\n  tryParseHtml(\n      htmlAstWithErrors: ParseTreeResult, component: CompileDirectiveMetadata,\n      directives: CompileDirectiveSummary[], pipes: CompilePipeSummary[],\n      schemas: SchemaMetadata[]): TemplateParseResult {\n    let result: t.TemplateAst[];\n    const errors = htmlAstWithErrors.errors;\n    const usedPipes: CompilePipeSummary[] = [];\n    if (htmlAstWithErrors.rootNodes.length > 0) {\n      const uniqDirectives = removeSummaryDuplicates(directives);\n      const uniqPipes = removeSummaryDuplicates(pipes);\n      const providerViewContext = new ProviderViewContext(this._reflector, component);\n      let interpolationConfig: InterpolationConfig = undefined!;\n      if (component.template && component.template.interpolation) {\n        interpolationConfig = {\n          start: component.template.interpolation[0],\n          end: component.template.interpolation[1]\n        };\n      }\n      const bindingParser = new BindingParser(\n          this._exprParser, interpolationConfig!, this._schemaRegistry, uniqPipes, errors);\n      const parseVisitor = new TemplateParseVisitor(\n          this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser,\n          this._schemaRegistry, schemas, errors);\n      result = html.visitAll(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n      errors.push(...providerViewContext.errors);\n      usedPipes.push(...bindingParser.getUsedPipes());\n    } else {\n      result = [];\n    }\n    this._assertNoReferenceDuplicationOnTemplate(result, errors);\n\n    if (errors.length > 0) {\n      return new TemplateParseResult(result, usedPipes, errors);\n    }\n\n    if (this.transforms) {\n      this.transforms.forEach((transform: t.TemplateAstVisitor) => {\n        result = t.templateVisitAll(transform, result);\n      });\n    }\n\n    return new TemplateParseResult(result, usedPipes, errors);\n  }\n\n  expandHtml(htmlAstWithErrors: ParseTreeResult, forced: boolean = false): ParseTreeResult {\n    const errors: ParseError[] = htmlAstWithErrors.errors;\n\n    if (errors.length == 0 || forced) {\n      // Transform ICU messages to angular directives\n      const expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n      errors.push(...expandedHtmlAst.errors);\n      htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n    }\n    return htmlAstWithErrors;\n  }\n\n  getInterpolationConfig(component: CompileDirectiveMetadata): InterpolationConfig|undefined {\n    if (component.template) {\n      return InterpolationConfig.fromArray(component.template.interpolation);\n    }\n    return undefined;\n  }\n\n  /** @internal */\n  _assertNoReferenceDuplicationOnTemplate(result: t.TemplateAst[], errors: TemplateParseError[]):\n      void {\n    const existingReferences: string[] = [];\n\n    result.filter(element => !!(<any>element).references)\n        .forEach(element => (<any>element).references.forEach((reference: t.ReferenceAst) => {\n          const name = reference.name;\n          if (existingReferences.indexOf(name) < 0) {\n            existingReferences.push(name);\n          } else {\n            const error = new TemplateParseError(\n                `Reference \"#${name}\" is defined several times`, reference.sourceSpan,\n                ParseErrorLevel.ERROR);\n            errors.push(error);\n          }\n        }));\n  }\n}\n\nclass TemplateParseVisitor implements html.Visitor {\n  selectorMatcher = new SelectorMatcher();\n  directivesIndex = new Map<CompileDirectiveSummary, number>();\n  ngContentCount = 0;\n  contentQueryStartId: number;\n\n  constructor(\n      private reflector: CompileReflector, private config: CompilerConfig,\n      public providerViewContext: ProviderViewContext, directives: CompileDirectiveSummary[],\n      private _bindingParser: BindingParser, private _schemaRegistry: ElementSchemaRegistry,\n      private _schemas: SchemaMetadata[], private _targetErrors: TemplateParseError[]) {\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\n    this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n    directives.forEach((directive, index) => {\n      const selector = CssSelector.parse(directive.selector!);\n      this.selectorMatcher.addSelectables(selector, directive);\n      this.directivesIndex.set(directive, index);\n    });\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any {\n    return null;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n    return null;\n  }\n\n  visitText(text: html.Text, parent: ElementContext): any {\n    const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR())!;\n    const valueNoNgsp = replaceNgsp(text.value);\n    const expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\n    return expr ? new t.BoundTextAst(expr, ngContentIndex, text.sourceSpan) :\n                  new t.TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return new t.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n  }\n\n  visitComment(comment: html.Comment, context: any): any {\n    return null;\n  }\n\n  visitElement(element: html.Element, parent: ElementContext): any {\n    const queryStartIndex = this.contentQueryStartId;\n    const elName = element.name;\n    const preparsedElement = preparseElement(element);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE) {\n      // Skipping <script> for security reasons\n      // Skipping <style> as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n    if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\n        isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n      // Skipping stylesheets with either relative urls or package scheme as we already processed\n      // them in the StyleCompiler\n      return null;\n    }\n\n    const matchableAttrs: [string, string][] = [];\n    const elementOrDirectiveProps: ParsedProperty[] = [];\n    const elementOrDirectiveRefs: ElementOrDirectiveRef[] = [];\n    const elementVars: t.VariableAst[] = [];\n    const events: t.BoundEventAst[] = [];\n\n    const templateElementOrDirectiveProps: ParsedProperty[] = [];\n    const templateMatchableAttrs: [string, string][] = [];\n    const templateElementVars: t.VariableAst[] = [];\n\n    let hasInlineTemplates = false;\n    const attrs: t.AttrAst[] = [];\n    const isTemplateElement = isNgTemplate(element.name);\n\n    element.attrs.forEach(attr => {\n      const parsedVariables: ParsedVariable[] = [];\n      const hasBinding = this._parseAttr(\n          isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events,\n          elementOrDirectiveRefs, elementVars);\n      elementVars.push(...parsedVariables.map(v => t.VariableAst.fromParsedVariable(v)));\n\n      let templateValue: string|undefined;\n      let templateKey: string|undefined;\n      const normalizedName = this._normalizeAttributeName(attr.name);\n\n      if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX)) {\n        templateValue = attr.value;\n        templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX.length);\n      }\n\n      const hasTemplateBinding = templateValue != null;\n      if (hasTemplateBinding) {\n        if (hasInlineTemplates) {\n          this._reportError(\n              `Can't have multiple template bindings on one element. Use only one attribute prefixed with *`,\n              attr.sourceSpan);\n        }\n        hasInlineTemplates = true;\n        const parsedVariables: ParsedVariable[] = [];\n        const absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;\n        this._bindingParser.parseInlineTemplateBinding(\n            templateKey!, templateValue!, attr.sourceSpan, absoluteOffset, templateMatchableAttrs,\n            templateElementOrDirectiveProps, parsedVariables, false /* isIvyAst */);\n        templateElementVars.push(...parsedVariables.map(v => t.VariableAst.fromParsedVariable(v)));\n      }\n\n      if (!hasBinding && !hasTemplateBinding) {\n        // don't include the bindings as attributes as well in the AST\n        attrs.push(this.visitAttribute(attr, null));\n        matchableAttrs.push([attr.name, attr.value]);\n      }\n    });\n\n    const elementCssSelector = createElementCssSelector(elName, matchableAttrs);\n    const {directives: directiveMetas, matchElement} =\n        this._parseDirectives(this.selectorMatcher, elementCssSelector);\n    const references: t.ReferenceAst[] = [];\n    const boundDirectivePropNames = new Set<string>();\n    const directiveAsts = this._createDirectiveAsts(\n        isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps,\n        elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n    const elementProps: t.BoundElementPropertyAst[] = this._createElementPropertyAsts(\n        element.name, elementOrDirectiveProps, boundDirectivePropNames);\n    const isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n\n    const providerContext = new ProviderElementContext(\n        this.providerViewContext, parent.providerContext!, isViewRoot, directiveAsts, attrs,\n        references, isTemplateElement, queryStartIndex, element.sourceSpan);\n\n    const children: t.TemplateAst[] = html.visitAll(\n        preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children,\n        ElementContext.create(\n            isTemplateElement, directiveAsts,\n            isTemplateElement ? parent.providerContext! : providerContext));\n    providerContext.afterElement();\n    // Override the actual selector when the `ngProjectAs` attribute is provided\n    const projectionSelector = preparsedElement.projectAs != '' ?\n        CssSelector.parse(preparsedElement.projectAs)[0] :\n        elementCssSelector;\n    const ngContentIndex = parent.findNgContentIndex(projectionSelector)!;\n    let parsedElement: t.TemplateAst;\n\n    if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n      // `<ng-content>` element\n      if (element.children && !element.children.every(_isEmptyTextNode)) {\n        this._reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\n      }\n\n      parsedElement = new t.NgContentAst(\n          this.ngContentCount++, hasInlineTemplates ? null! : ngContentIndex, element.sourceSpan);\n    } else if (isTemplateElement) {\n      // `<ng-template>` element\n      this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n      this._assertNoComponentsNorElementBindingsOnTemplate(\n          directiveAsts, elementProps, element.sourceSpan);\n\n      parsedElement = new t.EmbeddedTemplateAst(\n          attrs, events, references, elementVars, providerContext.transformedDirectiveAsts,\n          providerContext.transformProviders, providerContext.transformedHasViewContainer,\n          providerContext.queryMatches, children, hasInlineTemplates ? null! : ngContentIndex,\n          element.sourceSpan);\n    } else {\n      // element other than `<ng-content>` and `<ng-template>`\n      this._assertElementExists(matchElement, element);\n      this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n\n      const ngContentIndex =\n          hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n      parsedElement = new t.ElementAst(\n          elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts,\n          providerContext.transformProviders, providerContext.transformedHasViewContainer,\n          providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex,\n          element.sourceSpan, element.endSourceSpan || null);\n    }\n\n    if (hasInlineTemplates) {\n      // The element as a *-attribute\n      const templateQueryStartIndex = this.contentQueryStartId;\n      const templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\n      const {directives} = this._parseDirectives(this.selectorMatcher, templateSelector);\n      const templateBoundDirectivePropNames = new Set<string>();\n      const templateDirectiveAsts = this._createDirectiveAsts(\n          true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [],\n          templateBoundDirectivePropNames);\n      const templateElementProps: t.BoundElementPropertyAst[] = this._createElementPropertyAsts(\n          elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n      this._assertNoComponentsNorElementBindingsOnTemplate(\n          templateDirectiveAsts, templateElementProps, element.sourceSpan);\n      const templateProviderContext = new ProviderElementContext(\n          this.providerViewContext, parent.providerContext!, parent.isTemplateElement,\n          templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n      templateProviderContext.afterElement();\n\n      parsedElement = new t.EmbeddedTemplateAst(\n          [], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts,\n          templateProviderContext.transformProviders,\n          templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches,\n          [parsedElement], ngContentIndex, element.sourceSpan);\n    }\n\n    return parsedElement;\n  }\n\n  private _parseAttr(\n      isTemplateElement: boolean, attr: html.Attribute, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[], targetEvents: t.BoundEventAst[],\n      targetRefs: ElementOrDirectiveRef[], targetVars: t.VariableAst[]): boolean {\n    const name = this._normalizeAttributeName(attr.name);\n    const value = attr.value;\n    const srcSpan = attr.sourceSpan;\n    const absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;\n\n    const boundEvents: ParsedEvent[] = [];\n    const bindParts = name.match(BIND_NAME_REGEXP);\n    let hasBinding = false;\n\n    if (bindParts !== null) {\n      hasBinding = true;\n      if (bindParts[KW_BIND_IDX] != null) {\n        this._bindingParser.parsePropertyBinding(\n            bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan,\n            targetMatchableAttrs, targetProps);\n\n      } else if (bindParts[KW_LET_IDX]) {\n        if (isTemplateElement) {\n          const identifier = bindParts[IDENT_KW_IDX];\n          this._parseVariable(identifier, value, srcSpan, targetVars);\n        } else {\n          this._reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\n        }\n\n      } else if (bindParts[KW_REF_IDX]) {\n        const identifier = bindParts[IDENT_KW_IDX];\n        this._parseReference(identifier, value, srcSpan, targetRefs);\n\n      } else if (bindParts[KW_ON_IDX]) {\n        this._bindingParser.parseEvent(\n            bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan,\n            targetMatchableAttrs, boundEvents);\n\n      } else if (bindParts[KW_BINDON_IDX]) {\n        this._bindingParser.parsePropertyBinding(\n            bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan,\n            targetMatchableAttrs, targetProps);\n        this._parseAssignmentEvent(\n            bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan,\n            targetMatchableAttrs, boundEvents);\n\n      } else if (bindParts[KW_AT_IDX]) {\n        this._bindingParser.parseLiteralAttr(\n            name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs,\n            targetProps);\n\n      } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n        this._bindingParser.parsePropertyBinding(\n            bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan,\n            targetMatchableAttrs, targetProps);\n        this._parseAssignmentEvent(\n            bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan,\n            targetMatchableAttrs, boundEvents);\n\n      } else if (bindParts[IDENT_PROPERTY_IDX]) {\n        this._bindingParser.parsePropertyBinding(\n            bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan,\n            targetMatchableAttrs, targetProps);\n\n      } else if (bindParts[IDENT_EVENT_IDX]) {\n        this._bindingParser.parseEvent(\n            bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan,\n            targetMatchableAttrs, boundEvents);\n      }\n    } else {\n      hasBinding = this._bindingParser.parsePropertyInterpolation(\n          name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);\n    }\n\n    if (!hasBinding) {\n      this._bindingParser.parseLiteralAttr(\n          name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n    }\n\n    targetEvents.push(...boundEvents.map(e => t.BoundEventAst.fromParsedEvent(e)));\n\n    return hasBinding;\n  }\n\n  private _normalizeAttributeName(attrName: string): string {\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n  }\n\n  private _parseVariable(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan, targetVars: t.VariableAst[]) {\n    if (identifier.indexOf('-') > -1) {\n      this._reportError(`\"-\" is not allowed in variable names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this._reportError(`Variable does not have a name`, sourceSpan);\n    }\n\n    targetVars.push(new t.VariableAst(identifier, value, sourceSpan));\n  }\n\n  private _parseReference(\n      identifier: string, value: string, sourceSpan: ParseSourceSpan,\n      targetRefs: ElementOrDirectiveRef[]) {\n    if (identifier.indexOf('-') > -1) {\n      this._reportError(`\"-\" is not allowed in reference names`, sourceSpan);\n    } else if (identifier.length === 0) {\n      this._reportError(`Reference does not have a name`, sourceSpan);\n    }\n\n    targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n  }\n\n  private _parseAssignmentEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, valueSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    this._bindingParser.parseEvent(\n        `${name}Change`, `${expression}=$event`, sourceSpan, valueSpan, targetMatchableAttrs,\n        targetEvents);\n  }\n\n  private _parseDirectives(selectorMatcher: SelectorMatcher, elementCssSelector: CssSelector):\n      {directives: CompileDirectiveSummary[], matchElement: boolean} {\n    // Need to sort the directives so that we get consistent results throughout,\n    // as selectorMatcher uses Maps inside.\n    // Also deduplicate directives as they might match more than one time!\n    const directives = newArray(this.directivesIndex.size);\n    // Whether any directive selector matches on the element name\n    let matchElement = false;\n\n    selectorMatcher.match(elementCssSelector, (selector, directive) => {\n      directives[this.directivesIndex.get(directive)!] = directive;\n      matchElement = matchElement || selector.hasElementSelector();\n    });\n\n    return {\n      directives: directives.filter(dir => !!dir),\n      matchElement,\n    };\n  }\n\n  private _createDirectiveAsts(\n      isTemplateElement: boolean, elementName: string, directives: CompileDirectiveSummary[],\n      props: ParsedProperty[], elementOrDirectiveRefs: ElementOrDirectiveRef[],\n      elementSourceSpan: ParseSourceSpan, targetReferences: t.ReferenceAst[],\n      targetBoundDirectivePropNames: Set<string>): t.DirectiveAst[] {\n    const matchedReferences = new Set<string>();\n    let component: CompileDirectiveSummary = null!;\n\n    const directiveAsts = directives.map((directive) => {\n      const sourceSpan = new ParseSourceSpan(\n          elementSourceSpan.start, elementSourceSpan.end, elementSourceSpan.fullStart,\n          `Directive ${identifierName(directive.type)}`);\n\n      if (directive.isComponent) {\n        component = directive;\n      }\n      const directiveProperties: t.BoundDirectivePropertyAst[] = [];\n      const boundProperties =\n          this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan)!;\n\n      let hostProperties =\n          boundProperties.map(prop => t.BoundElementPropertyAst.fromBoundProperty(prop));\n      // Note: We need to check the host properties here as well,\n      // as we don't know the element name in the DirectiveWrapperCompiler yet.\n      hostProperties = this._checkPropertiesInSchema(elementName, hostProperties);\n      const parsedEvents = this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan)!;\n      this._createDirectivePropertyAsts(\n          directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n      elementOrDirectiveRefs.forEach((elOrDirRef) => {\n        if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\n            (elOrDirRef.isReferenceToDirective(directive))) {\n          targetReferences.push(new t.ReferenceAst(\n              elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value,\n              elOrDirRef.sourceSpan));\n          matchedReferences.add(elOrDirRef.name);\n        }\n      });\n      const hostEvents = parsedEvents.map(e => t.BoundEventAst.fromParsedEvent(e));\n      const contentQueryStartId = this.contentQueryStartId;\n      this.contentQueryStartId += directive.queries.length;\n      return new t.DirectiveAst(\n          directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId,\n          sourceSpan);\n    });\n\n    elementOrDirectiveRefs.forEach((elOrDirRef) => {\n      if (elOrDirRef.value.length > 0) {\n        if (!matchedReferences.has(elOrDirRef.name)) {\n          this._reportError(\n              `There is no directive with \"exportAs\" set to \"${elOrDirRef.value}\"`,\n              elOrDirRef.sourceSpan);\n        }\n      } else if (!component) {\n        let refToken: CompileTokenMetadata = null!;\n        if (isTemplateElement) {\n          refToken = createTokenForExternalReference(this.reflector, Identifiers.TemplateRef);\n        }\n        targetReferences.push(\n            new t.ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\n      }\n    });\n    return directiveAsts;\n  }\n\n  private _createDirectivePropertyAsts(\n      directiveProperties: {[key: string]: string}, boundProps: ParsedProperty[],\n      targetBoundDirectiveProps: t.BoundDirectivePropertyAst[],\n      targetBoundDirectivePropNames: Set<string>) {\n    if (directiveProperties) {\n      const boundPropsByName = new Map<string, ParsedProperty>();\n      boundProps.forEach(boundProp => {\n        const prevValue = boundPropsByName.get(boundProp.name);\n        if (!prevValue || prevValue.isLiteral) {\n          // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n          boundPropsByName.set(boundProp.name, boundProp);\n        }\n      });\n\n      Object.keys(directiveProperties).forEach(dirProp => {\n        const elProp = directiveProperties[dirProp];\n        const boundProp = boundPropsByName.get(elProp);\n\n        // Bindings are optional, so this binding only needs to be set up if an expression is given.\n        if (boundProp) {\n          targetBoundDirectivePropNames.add(boundProp.name);\n          if (!isEmptyExpression(boundProp.expression)) {\n            targetBoundDirectiveProps.push(new t.BoundDirectivePropertyAst(\n                dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n          }\n        }\n      });\n    }\n  }\n\n  private _createElementPropertyAsts(\n      elementName: string, props: ParsedProperty[],\n      boundDirectivePropNames: Set<string>): t.BoundElementPropertyAst[] {\n    const boundElementProps: t.BoundElementPropertyAst[] = [];\n\n    props.forEach((prop: ParsedProperty) => {\n      if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n        const boundProp = this._bindingParser.createBoundElementProperty(elementName, prop);\n        boundElementProps.push(t.BoundElementPropertyAst.fromBoundProperty(boundProp));\n      }\n    });\n    return this._checkPropertiesInSchema(elementName, boundElementProps);\n  }\n\n  private _findComponentDirectives(directives: t.DirectiveAst[]): t.DirectiveAst[] {\n    return directives.filter(directive => directive.directive.isComponent);\n  }\n\n  private _findComponentDirectiveNames(directives: t.DirectiveAst[]): string[] {\n    return this._findComponentDirectives(directives)\n        .map(directive => identifierName(directive.directive.type)!);\n  }\n\n  private _assertOnlyOneComponent(directives: t.DirectiveAst[], sourceSpan: ParseSourceSpan) {\n    const componentTypeNames = this._findComponentDirectiveNames(directives);\n    if (componentTypeNames.length > 1) {\n      this._reportError(\n          `More than one component matched on this element.\\n` +\n              `Make sure that only one component's selector can match a given element.\\n` +\n              `Conflicting components: ${componentTypeNames.join(',')}`,\n          sourceSpan);\n    }\n  }\n\n  /**\n   * Make sure that non-angular tags conform to the schemas.\n   *\n   * Note: An element is considered an angular tag when at least one directive selector matches the\n   * tag name.\n   *\n   * @param matchElement Whether any directive has matched on the tag name\n   * @param element the html element\n   */\n  private _assertElementExists(matchElement: boolean, element: html.Element) {\n    const elName = element.name.replace(/^:xhtml:/, '');\n\n    if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n      let errorMsg = `'${elName}' is not a known element:\\n`;\n      errorMsg += `1. If '${\n          elName}' is an Angular component, then verify that it is part of this module.\\n`;\n      if (elName.indexOf('-') > -1) {\n        errorMsg += `2. If '${\n            elName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;\n      } else {\n        errorMsg +=\n            `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n      }\n      this._reportError(errorMsg, element.sourceSpan);\n    }\n  }\n\n  private _assertNoComponentsNorElementBindingsOnTemplate(\n      directives: t.DirectiveAst[], elementProps: t.BoundElementPropertyAst[],\n      sourceSpan: ParseSourceSpan) {\n    const componentTypeNames: string[] = this._findComponentDirectiveNames(directives);\n    if (componentTypeNames.length > 0) {\n      this._reportError(\n          `Components on an embedded template: ${componentTypeNames.join(',')}`, sourceSpan);\n    }\n    elementProps.forEach(prop => {\n      this._reportError(\n          `Property binding ${\n              prop.name} not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`,\n          sourceSpan);\n    });\n  }\n\n  private _assertAllEventsPublishedByDirectives(\n      directives: t.DirectiveAst[], events: t.BoundEventAst[]) {\n    const allDirectiveEvents = new Set<string>();\n\n    directives.forEach(directive => {\n      Object.keys(directive.directive.outputs).forEach(k => {\n        const eventName = directive.directive.outputs[k];\n        allDirectiveEvents.add(eventName);\n      });\n    });\n\n    events.forEach(event => {\n      if (event.target != null || !allDirectiveEvents.has(event.name)) {\n        this._reportError(\n            `Event binding ${\n                event\n                    .fullName} not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`,\n            event.sourceSpan);\n      }\n    });\n  }\n\n  private _checkPropertiesInSchema(elementName: string, boundProps: t.BoundElementPropertyAst[]):\n      t.BoundElementPropertyAst[] {\n    // Note: We can't filter out empty expressions before this method,\n    // as we still want to validate them!\n    return boundProps.filter((boundProp) => {\n      if (boundProp.type === t.PropertyBindingType.Property &&\n          !this._schemaRegistry.hasProperty(elementName, boundProp.name, this._schemas)) {\n        let errorMsg = `Can't bind to '${boundProp.name}' since it isn't a known property of '${\n            elementName}'.`;\n        if (elementName.startsWith('ng-')) {\n          errorMsg +=\n              `\\n1. If '${\n                  boundProp\n                      .name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +\n              `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n        } else if (elementName.indexOf('-') > -1) {\n          errorMsg +=\n              `\\n1. If '${elementName}' is an Angular component and it has '${\n                  boundProp.name}' input, then verify that it is part of this module.` +\n              `\\n2. If '${\n                  elementName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +\n              `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\n        }\n        this._reportError(errorMsg, boundProp.sourceSpan);\n      }\n      return !isEmptyExpression(boundProp.value);\n    });\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this._targetErrors.push(new ParseError(sourceSpan, message, level));\n  }\n}\n\nclass NonBindableVisitor implements html.Visitor {\n  visitElement(ast: html.Element, parent: ElementContext): t.ElementAst|null {\n    const preparsedElement = preparseElement(ast);\n    if (preparsedElement.type === PreparsedElementType.SCRIPT ||\n        preparsedElement.type === PreparsedElementType.STYLE ||\n        preparsedElement.type === PreparsedElementType.STYLESHEET) {\n      // Skipping <script> for security reasons\n      // Skipping <style> and stylesheets as we already processed them\n      // in the StyleCompiler\n      return null;\n    }\n\n    const attrNameAndValues = ast.attrs.map((attr): [string, string] => [attr.name, attr.value]);\n    const selector = createElementCssSelector(ast.name, attrNameAndValues);\n    const ngContentIndex = parent.findNgContentIndex(selector);\n    const children: t.TemplateAst[] = html.visitAll(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n    return new t.ElementAst(\n        ast.name, html.visitAll(this, ast.attrs), [], [], [], [], [], false, [], children,\n        ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n  }\n  visitComment(comment: html.Comment, context: any): any {\n    return null;\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): t.AttrAst {\n    return new t.AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n  }\n\n  visitText(text: html.Text, parent: ElementContext): t.TextAst {\n    const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR())!;\n    return new t.TextAst(text.value, ngContentIndex, text.sourceSpan);\n  }\n\n  visitExpansion(expansion: html.Expansion, context: any): any {\n    return expansion;\n  }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any {\n    return expansionCase;\n  }\n}\n\n/**\n * A reference to an element or directive in a template. E.g., the reference in this template:\n *\n * <div #myMenu=\"coolMenu\">\n *\n * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\n */\nclass ElementOrDirectiveRef {\n  constructor(public name: string, public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  /** Gets whether this is a reference to the given directive. */\n  isReferenceToDirective(directive: CompileDirectiveSummary) {\n    return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n  }\n}\n\n/** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\nfunction splitExportAs(exportAs: string|null): string[] {\n  return exportAs ? exportAs.split(',').map(e => e.trim()) : [];\n}\n\nexport function splitClasses(classAttrValue: string): string[] {\n  return classAttrValue.trim().split(/\\s+/g);\n}\n\nclass ElementContext {\n  static create(\n      isTemplateElement: boolean, directives: t.DirectiveAst[],\n      providerContext: ProviderElementContext): ElementContext {\n    const matcher = new SelectorMatcher();\n    let wildcardNgContentIndex: number = null!;\n    const component = directives.find(directive => directive.directive.isComponent);\n    if (component) {\n      const ngContentSelectors = component.directive.template !.ngContentSelectors;\n      for (let i = 0; i < ngContentSelectors.length; i++) {\n        const selector = ngContentSelectors[i];\n        if (selector === '*') {\n          wildcardNgContentIndex = i;\n        } else {\n          matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n        }\n      }\n    }\n    return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n  }\n  constructor(\n      public isTemplateElement: boolean, private _ngContentIndexMatcher: SelectorMatcher,\n      private _wildcardNgContentIndex: number|null,\n      public providerContext: ProviderElementContext|null) {}\n\n  findNgContentIndex(selector: CssSelector): number|null {\n    const ngContentIndices: number[] = [];\n    this._ngContentIndexMatcher.match(selector, (selector, ngContentIndex) => {\n      ngContentIndices.push(ngContentIndex);\n    });\n    ngContentIndices.sort();\n    if (this._wildcardNgContentIndex != null) {\n      ngContentIndices.push(this._wildcardNgContentIndex);\n    }\n    return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n  }\n}\n\nexport function createElementCssSelector(\n    elementName: string, attributes: [string, string][]): CssSelector {\n  const cssSelector = new CssSelector();\n  const elNameNoNs = splitNsName(elementName)[1];\n\n  cssSelector.setElement(elNameNoNs);\n\n  for (let i = 0; i < attributes.length; i++) {\n    const attrName = attributes[i][0];\n    const attrNameNoNs = splitNsName(attrName)[1];\n    const attrValue = attributes[i][1];\n\n    cssSelector.addAttribute(attrNameNoNs, attrValue);\n    if (attrName.toLowerCase() == CLASS_ATTR) {\n      const classes = splitClasses(attrValue);\n      classes.forEach(className => cssSelector.addClassName(className));\n    }\n  }\n  return cssSelector;\n}\n\nconst EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction _isEmptyTextNode(node: html.Node): boolean {\n  return node instanceof html.Text && node.value.trim().length == 0;\n}\n\nexport function removeSummaryDuplicates<T extends {type: CompileTypeMetadata}>(items: T[]): T[] {\n  const map = new Map<any, T>();\n\n  items.forEach((item) => {\n    if (!map.get(item.type.reference)) {\n      map.set(item.type.reference, item);\n    }\n  });\n\n  return Array.from(map.values());\n}\n\nexport function isEmptyExpression(ast: AST): boolean {\n  if (ast instanceof ASTWithSource) {\n    ast = ast.ast;\n  }\n  return ast instanceof EmptyExpr;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}