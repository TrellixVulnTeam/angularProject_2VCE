{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar base64VLQ = require(\"./base64-vlq\");\n\nvar getNumberOfLines = require(\"./helpers\").getNumberOfLines;\n\nvar getUnfinishedLine = require(\"./helpers\").getUnfinishedLine;\n\nvar LINE_MAPPING = \";AACA\";\n\nvar SourceNode = /*#__PURE__*/function () {\n  function SourceNode(generatedCode, source, originalSource, startingLine) {\n    _classCallCheck(this, SourceNode);\n\n    this.generatedCode = generatedCode;\n    this.originalSource = originalSource;\n    this.source = source;\n    this.startingLine = startingLine || 1;\n    this._numberOfLines = getNumberOfLines(this.generatedCode);\n    this._endsWithNewLine = generatedCode[generatedCode.length - 1] === \"\\n\";\n  }\n\n  _createClass(SourceNode, [{\n    key: \"clone\",\n    value: function clone() {\n      return new SourceNode(this.generatedCode, this.source, this.originalSource, this.startingLine);\n    }\n  }, {\n    key: \"getGeneratedCode\",\n    value: function getGeneratedCode() {\n      return this.generatedCode;\n    }\n  }, {\n    key: \"addGeneratedCode\",\n    value: function addGeneratedCode(code) {\n      this.generatedCode += code;\n      this._numberOfLines += getNumberOfLines(code);\n      this._endsWithNewLine = code[code.length - 1] === \"\\n\";\n    }\n  }, {\n    key: \"getMappings\",\n    value: function getMappings(mappingsContext) {\n      if (!this.generatedCode) return \"\";\n      var lines = this._numberOfLines;\n      var sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);\n      var mappings = \"A\"; // generated column 0\n\n      if (mappingsContext.unfinishedGeneratedLine) mappings = \",\" + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);\n      mappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index\n\n      mappings += base64VLQ.encode(this.startingLine - mappingsContext.currentOriginalLine); // original line index\n\n      mappings += \"A\"; // original column 0\n\n      mappingsContext.currentSource = sourceIdx;\n      mappingsContext.currentOriginalLine = this.startingLine + lines - 1;\n      var unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode);\n      mappings += Array(lines).join(LINE_MAPPING);\n\n      if (unfinishedGeneratedLine === 0) {\n        mappings += \";\";\n      } else {\n        if (lines !== 0) {\n          mappings += LINE_MAPPING;\n        }\n\n        mappingsContext.currentOriginalLine++;\n      }\n\n      return mappings;\n    }\n  }, {\n    key: \"mapGeneratedCode\",\n    value: function mapGeneratedCode(fn) {\n      throw new Error(\"Cannot map generated code on a SourceMap. Normalize to SingleLineNode first.\");\n    }\n  }, {\n    key: \"getNormalizedNodes\",\n    value: function getNormalizedNodes() {\n      var results = [];\n      var currentLine = this.startingLine;\n      var generatedCode = this.generatedCode;\n      var index = 0;\n      var indexEnd = generatedCode.length;\n\n      while (index < indexEnd) {\n        // get one generated line\n        var nextLine = generatedCode.indexOf(\"\\n\", index) + 1;\n        if (nextLine === 0) nextLine = indexEnd;\n        var lineGenerated = generatedCode.substr(index, nextLine - index);\n        results.push(new SingleLineNode(lineGenerated, this.source, this.originalSource, currentLine)); // move cursors\n\n        index = nextLine;\n        currentLine++;\n      }\n\n      return results;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(otherNode) {\n      if (otherNode instanceof SourceNode) {\n        return this.mergeSourceNode(otherNode);\n      } else if (otherNode instanceof SingleLineNode) {\n        return this.mergeSingleLineNode(otherNode);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"mergeSourceNode\",\n    value: function mergeSourceNode(otherNode) {\n      if (this.source === otherNode.source && this._endsWithNewLine && this.startingLine + this._numberOfLines === otherNode.startingLine) {\n        this.generatedCode += otherNode.generatedCode;\n        this._numberOfLines += otherNode._numberOfLines;\n        this._endsWithNewLine = otherNode._endsWithNewLine;\n        return this;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"mergeSingleLineNode\",\n    value: function mergeSingleLineNode(otherNode) {\n      if (this.source === otherNode.source && this._endsWithNewLine && this.startingLine + this._numberOfLines === otherNode.line && otherNode._numberOfLines <= 1) {\n        this.addSingleLineNode(otherNode);\n        return this;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"addSingleLineNode\",\n    value: function addSingleLineNode(otherNode) {\n      this.generatedCode += otherNode.generatedCode;\n      this._numberOfLines += otherNode._numberOfLines;\n      this._endsWithNewLine = otherNode._endsWithNewLine;\n    }\n  }]);\n\n  return SourceNode;\n}();\n\nmodule.exports = SourceNode;\n\nvar SingleLineNode = require(\"./SingleLineNode\"); // circular dependency","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/source-list-map/lib/SourceNode.js"],"names":["base64VLQ","require","getNumberOfLines","getUnfinishedLine","LINE_MAPPING","SourceNode","generatedCode","source","originalSource","startingLine","_numberOfLines","_endsWithNewLine","length","code","mappingsContext","lines","sourceIdx","ensureSource","mappings","unfinishedGeneratedLine","encode","currentSource","currentOriginalLine","Array","join","fn","Error","results","currentLine","index","indexEnd","nextLine","indexOf","lineGenerated","substr","push","SingleLineNode","otherNode","mergeSourceNode","mergeSingleLineNode","line","addSingleLineNode","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst getNumberOfLines = require(\"./helpers\").getNumberOfLines;\nconst getUnfinishedLine = require(\"./helpers\").getUnfinishedLine;\n\nconst LINE_MAPPING = \";AACA\";\n\nclass SourceNode {\n\n\tconstructor(generatedCode, source, originalSource, startingLine) {\n\t\tthis.generatedCode = generatedCode;\n\t\tthis.originalSource = originalSource;\n\t\tthis.source = source;\n\t\tthis.startingLine = startingLine || 1;\n\t\tthis._numberOfLines = getNumberOfLines(this.generatedCode);\n\t\tthis._endsWithNewLine = generatedCode[generatedCode.length - 1] === \"\\n\";\n\t}\n\n\tclone() {\n\t\treturn new SourceNode(this.generatedCode, this.source, this.originalSource, this.startingLine);\n\t}\n\n\tgetGeneratedCode() {\n\t\treturn this.generatedCode;\n\t}\n\n\taddGeneratedCode(code) {\n\t\tthis.generatedCode += code;\n\t\tthis._numberOfLines += getNumberOfLines(code);\n\t\tthis._endsWithNewLine = code[code.length - 1] === \"\\n\";\n\t}\n\n\tgetMappings(mappingsContext) {\n\t\tif(!this.generatedCode)\n\t\t\treturn \"\";\n\t\tconst lines = this._numberOfLines;\n\t\tconst sourceIdx = mappingsContext.ensureSource(this.source, this.originalSource);\n\t\tlet mappings = \"A\"; // generated column 0\n\t\tif(mappingsContext.unfinishedGeneratedLine)\n\t\t\tmappings = \",\" + base64VLQ.encode(mappingsContext.unfinishedGeneratedLine);\n\t\tmappings += base64VLQ.encode(sourceIdx - mappingsContext.currentSource); // source index\n\t\tmappings += base64VLQ.encode(this.startingLine - mappingsContext.currentOriginalLine); // original line index\n\t\tmappings += \"A\"; // original column 0\n\t\tmappingsContext.currentSource = sourceIdx;\n\t\tmappingsContext.currentOriginalLine = this.startingLine + lines - 1;\n\t\tconst unfinishedGeneratedLine = mappingsContext.unfinishedGeneratedLine = getUnfinishedLine(this.generatedCode)\n\t\tmappings += Array(lines).join(LINE_MAPPING);\n\t\tif(unfinishedGeneratedLine === 0) {\n\t\t\tmappings += \";\";\n\t\t} else {\n\t\t\tif(lines !== 0) {\n\t\t\t\tmappings += LINE_MAPPING;\n\t\t\t}\n\t\t\tmappingsContext.currentOriginalLine++;\n\t\t}\n\t\treturn mappings;\n\t}\n\n\tmapGeneratedCode(fn) {\n\t\tthrow new Error(\"Cannot map generated code on a SourceMap. Normalize to SingleLineNode first.\");\n\t}\n\n\tgetNormalizedNodes() {\n\t\tvar results = [];\n\t\tvar currentLine = this.startingLine;\n\t\tvar generatedCode = this.generatedCode;\n\t\tvar index = 0;\n\t\tvar indexEnd = generatedCode.length;\n\t\twhile(index < indexEnd) {\n\t\t\t// get one generated line\n\t\t\tvar nextLine = generatedCode.indexOf(\"\\n\", index) + 1;\n\t\t\tif(nextLine === 0) nextLine = indexEnd;\n\t\t\tvar lineGenerated = generatedCode.substr(index, nextLine - index);\n\n\t\t\tresults.push(new SingleLineNode(lineGenerated, this.source, this.originalSource, currentLine));\n\n\t\t\t// move cursors\n\t\t\tindex = nextLine;\n\t\t\tcurrentLine++;\n\t\t}\n\t\treturn results;\n\t}\n\n\tmerge(otherNode) {\n\t\tif(otherNode instanceof SourceNode) {\n\t\t\treturn this.mergeSourceNode(otherNode);\n\t\t} else if(otherNode instanceof SingleLineNode) {\n\t\t\treturn this.mergeSingleLineNode(otherNode);\n\t\t}\n\t\treturn false;\n\t}\n\n\tmergeSourceNode(otherNode) {\n\t\tif(this.source === otherNode.source &&\n\t\t\tthis._endsWithNewLine &&\n\t\t\tthis.startingLine + this._numberOfLines === otherNode.startingLine) {\n\t\t\tthis.generatedCode += otherNode.generatedCode;\n\t\t\tthis._numberOfLines += otherNode._numberOfLines;\n\t\t\tthis._endsWithNewLine = otherNode._endsWithNewLine;\n\t\t\treturn this;\n\t\t}\n\t\treturn false;\n\t}\n\n\tmergeSingleLineNode(otherNode) {\n\t\tif(this.source === otherNode.source &&\n\t\t\tthis._endsWithNewLine &&\n\t\t\tthis.startingLine + this._numberOfLines === otherNode.line &&\n\t\t\totherNode._numberOfLines <= 1) {\n\t\t\tthis.addSingleLineNode(otherNode);\n\t\t\treturn this;\n\t\t}\n\t\treturn false;\n\t}\n\n\taddSingleLineNode(otherNode) {\n\t\tthis.generatedCode += otherNode.generatedCode;\n\t\tthis._numberOfLines += otherNode._numberOfLines\n\t\tthis._endsWithNewLine = otherNode._endsWithNewLine;\n\t}\n}\n\nmodule.exports = SourceNode;\nconst SingleLineNode = require(\"./SingleLineNode\"); // circular dependency\n"]},"metadata":{},"sourceType":"script"}