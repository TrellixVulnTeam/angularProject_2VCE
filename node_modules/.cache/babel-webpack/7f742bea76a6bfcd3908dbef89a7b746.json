{"ast":null,"code":"var _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\n// A simple implementation of make-array\nfunction makeArray(subject) {\n  return Array.isArray(subject) ? subject : [subject];\n}\n\nvar EMPTY = '';\nvar SPACE = ' ';\nvar ESCAPE = '\\\\';\nvar REGEX_TEST_BLANK_LINE = /^\\s+$/;\nvar REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;\nvar REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;\nvar REGEX_SPLITALL_CRLF = /\\r?\\n/g; // /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\n\nvar REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;\nvar SLASH = '/';\nvar KEY_IGNORE = typeof Symbol !== 'undefined' ? Symbol.for('node-ignore')\n/* istanbul ignore next */\n: 'node-ignore';\n\nvar define = function define(object, key, value) {\n  return Object.defineProperty(object, key, {\n    value: value\n  });\n};\n\nvar REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g; // Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\n\nvar sanitizeRange = function sanitizeRange(range) {\n  return range.replace(REGEX_REGEXP_RANGE, function (match, from, to) {\n    return from.charCodeAt(0) <= to.charCodeAt(0) ? match // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY;\n  });\n}; // See fixtures #59\n\n\nvar cleanRangeBackSlash = function cleanRangeBackSlash(slashes) {\n  var length = slashes.length;\n  return slashes.slice(0, length - length % 2);\n}; // > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n// '`foo/`' should not continue with the '`..`'\n\n\nvar REPLACERS = [// > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n[// (a\\ ) -> (a )\n// (a  ) -> (a)\n// (a \\ ) -> (a  )\n/\\\\?\\s+$/, function (match) {\n  return match.indexOf('\\\\') === 0 ? SPACE : EMPTY;\n}], // replace (\\ ) with ' '\n[/\\\\\\s/g, function () {\n  return SPACE;\n}], // Escape metacharacters\n// which is written down by users but means special for regular expressions.\n// > There are 12 characters with special meanings:\n// > - the backslash \\,\n// > - the caret ^,\n// > - the dollar sign $,\n// > - the period or dot .,\n// > - the vertical bar or pipe symbol |,\n// > - the question mark ?,\n// > - the asterisk or star *,\n// > - the plus sign +,\n// > - the opening parenthesis (,\n// > - the closing parenthesis ),\n// > - and the opening square bracket [,\n// > - the opening curly brace {,\n// > These special characters are often called \"metacharacters\".\n[/[\\\\$.|*+(){^]/g, function (match) {\n  return \"\\\\\".concat(match);\n}], [// > a question mark (?) matches a single character\n/(?!\\\\)\\?/g, function () {\n  return '[^/]';\n}], // leading slash\n[// > A leading slash matches the beginning of the pathname.\n// > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n// A leading slash matches the beginning of the pathname\n/^\\//, function () {\n  return '^';\n}], // replace special metacharacter slash after the leading slash\n[/\\//g, function () {\n  return '\\\\/';\n}], [// > A leading \"**\" followed by a slash means match in all directories.\n// > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n// > the same as pattern \"foo\".\n// > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n// >   under directory \"foo\".\n// Notice that the '*'s have been replaced as '\\\\*'\n/^\\^*\\\\\\*\\\\\\*\\\\\\//, // '**/foo' <-> 'foo'\nfunction () {\n  return '^(?:.*\\\\/)?';\n}], // starting\n[// there will be no leading '/'\n//   (which has been replaced by section \"leading slash\")\n// If starts with '**', adding a '^' to the regular expression also works\n/^(?=[^^])/, function startingReplacer() {\n  // If has a slash `/` at the beginning or middle\n  return !/\\/(?!$)/.test(this) // > Prior to 2.22.1\n  // > If the pattern does not contain a slash /,\n  // >   Git treats it as a shell glob pattern\n  // Actually, if there is only a trailing slash,\n  //   git also treats it as a shell glob pattern\n  // After 2.22.1 (compatible but clearer)\n  // > If there is a separator at the beginning or middle (or both)\n  // > of the pattern, then the pattern is relative to the directory\n  // > level of the particular .gitignore file itself.\n  // > Otherwise the pattern may also match at any level below\n  // > the .gitignore level.\n  ? '(?:^|\\\\/)' // > Otherwise, Git treats the pattern as a shell glob suitable for\n  // >   consumption by fnmatch(3)\n  : '^';\n}], // two globstars\n[// Use lookahead assertions so that we could match more than one `'/**'`\n/\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g, // Zero, one or several directories\n// should not use '*', or it will be replaced by the next replacer\n// Check if it is not the last `'/**'`\nfunction (_, index, str) {\n  return index + 6 < str.length // case: /**/\n  // > A slash followed by two consecutive asterisks then a slash matches\n  // >   zero or more directories.\n  // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n  // '/**/'\n  ? '(?:\\\\/[^\\\\/]+)*' // case: /**\n  // > A trailing `\"/**\"` matches everything inside.\n  // #21: everything inside but it should not include the current folder\n  : '\\\\/.+';\n}], // intermediate wildcards\n[// Never replace escaped '*'\n// ignore rule '\\*' will match the path '*'\n// 'abc.*/' -> go\n// 'abc.*'  -> skip this rule\n/(^|[^\\\\]+)\\\\\\*(?=.+)/g, // '*.js' matches '.js'\n// '*.js' doesn't match 'abc'\nfunction (_, p1) {\n  return \"\".concat(p1, \"[^\\\\/]*\");\n}], [// unescape, revert step 3 except for back slash\n// For example, if a user escape a '\\\\*',\n// after step 3, the result will be '\\\\\\\\\\\\*'\n/\\\\\\\\\\\\(?=[$.|*+(){^])/g, function () {\n  return ESCAPE;\n}], [// '\\\\\\\\' -> '\\\\'\n/\\\\\\\\/g, function () {\n  return ESCAPE;\n}], [// > The range notation, e.g. [a-zA-Z],\n// > can be used to match one of the characters in a range.\n// `\\` is escaped by step 3\n/(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g, function (match, leadEscape, range, endEscape, close) {\n  return leadEscape === ESCAPE // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n  ? \"\\\\[\".concat(range).concat(cleanRangeBackSlash(endEscape)).concat(close) : close === ']' ? endEscape.length % 2 === 0 // A normal case, and it is a range notation\n  // '[bar]'\n  // '[bar\\\\\\\\]'\n  ? \"[\".concat(sanitizeRange(range)).concat(endEscape, \"]\") // Invalid range notaton\n  // '[bar\\\\]' -> '[bar\\\\\\\\]'\n  : '[]' : '[]';\n}], // ending\n[// 'js' will not match 'js.'\n// 'ab' will not match 'abc'\n/(?:[^*])$/, // WTF!\n// https://git-scm.com/docs/gitignore\n// changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n// which re-fixes #24, #38\n// > If there is a separator at the end of the pattern then the pattern\n// > will only match directories, otherwise the pattern can match both\n// > files and directories.\n// 'js*' will not match 'a.js'\n// 'js/' will not match 'a.js'\n// 'js' will match 'a.js' and 'a.js/'\nfunction (match) {\n  return /\\/$/.test(match) // foo/ will not match 'foo'\n  ? \"\".concat(match, \"$\") // foo matches 'foo' and 'foo/'\n  : \"\".concat(match, \"(?=$|\\\\/$)\");\n}], // trailing wildcard\n[/(\\^|\\\\\\/)?\\\\\\*$/, function (_, p1) {\n  var prefix = p1 // '\\^':\n  // '/*' does not match EMPTY\n  // '/*' does not match everything\n  // '\\\\\\/':\n  // 'abc/*' does not match 'abc/'\n  ? \"\".concat(p1, \"[^/]+\") // 'a*' matches 'a'\n  // 'a*' matches 'aa'\n  : '[^/]*';\n  return \"\".concat(prefix, \"(?=$|\\\\/$)\");\n}]]; // A simple cache, because an ignore rule only has only one certain meaning\n\nvar regexCache = Object.create(null); // @param {pattern}\n\nvar makeRegex = function makeRegex(pattern, negative, ignorecase) {\n  var r = regexCache[pattern];\n\n  if (r) {\n    return r;\n  } // const replacers = negative\n  //   ? NEGATIVE_REPLACERS\n  //   : POSITIVE_REPLACERS\n\n\n  var source = REPLACERS.reduce(function (prev, current) {\n    return prev.replace(current[0], current[1].bind(pattern));\n  }, pattern);\n  return regexCache[pattern] = ignorecase ? new RegExp(source, 'i') : new RegExp(source);\n};\n\nvar isString = function isString(subject) {\n  return typeof subject === 'string';\n}; // > A blank line matches no files, so it can serve as a separator for readability.\n\n\nvar checkPattern = function checkPattern(pattern) {\n  return pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0;\n};\n\nvar splitPattern = function splitPattern(pattern) {\n  return pattern.split(REGEX_SPLITALL_CRLF);\n};\n\nvar IgnoreRule = function IgnoreRule(origin, pattern, negative, regex) {\n  \"use strict\";\n\n  _classCallCheck(this, IgnoreRule);\n\n  this.origin = origin;\n  this.pattern = pattern;\n  this.negative = negative;\n  this.regex = regex;\n};\n\nvar createRule = function createRule(pattern, ignorecase) {\n  var origin = pattern;\n  var negative = false; // > An optional prefix \"!\" which negates the pattern;\n\n  if (pattern.indexOf('!') === 0) {\n    negative = true;\n    pattern = pattern.substr(1);\n  }\n\n  pattern = pattern // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!') // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#');\n  var regex = makeRegex(pattern, negative, ignorecase);\n  return new IgnoreRule(origin, pattern, negative, regex);\n};\n\nvar throwError = function throwError(message, Ctor) {\n  throw new Ctor(message);\n};\n\nvar checkPath = function checkPath(path, originalPath, doThrow) {\n  if (!isString(path)) {\n    return doThrow(\"path must be a string, but got `\".concat(originalPath, \"`\"), TypeError);\n  } // We don't know if we should ignore EMPTY, so throw\n\n\n  if (!path) {\n    return doThrow(\"path must not be empty\", TypeError);\n  } // Check if it is a relative path\n\n\n  if (checkPath.isNotRelative(path)) {\n    var r = '`path.relative()`d';\n    return doThrow(\"path should be a \".concat(r, \" string, but got \\\"\").concat(originalPath, \"\\\"\"), RangeError);\n  }\n\n  return true;\n};\n\nvar isNotRelative = function isNotRelative(path) {\n  return REGEX_TEST_INVALID_PATH.test(path);\n};\n\ncheckPath.isNotRelative = isNotRelative;\n\ncheckPath.convert = function (p) {\n  return p;\n};\n\nvar Ignore = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Ignore() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$ignorecase = _ref.ignorecase,\n        ignorecase = _ref$ignorecase === void 0 ? true : _ref$ignorecase;\n\n    _classCallCheck(this, Ignore);\n\n    this._rules = [];\n    this._ignorecase = ignorecase;\n    define(this, KEY_IGNORE, true);\n\n    this._initCache();\n  }\n\n  _createClass(Ignore, [{\n    key: \"_initCache\",\n    value: function _initCache() {\n      this._ignoreCache = Object.create(null);\n      this._testCache = Object.create(null);\n    }\n  }, {\n    key: \"_addPattern\",\n    value: function _addPattern(pattern) {\n      // #32\n      if (pattern && pattern[KEY_IGNORE]) {\n        this._rules = this._rules.concat(pattern._rules);\n        this._added = true;\n        return;\n      }\n\n      if (checkPattern(pattern)) {\n        var rule = createRule(pattern, this._ignorecase);\n        this._added = true;\n\n        this._rules.push(rule);\n      }\n    } // @param {Array<string> | string | Ignore} pattern\n\n  }, {\n    key: \"add\",\n    value: function add(pattern) {\n      this._added = false;\n      makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this); // Some rules have just added to the ignore,\n      // making the behavior changed.\n\n      if (this._added) {\n        this._initCache();\n      }\n\n      return this;\n    } // legacy\n\n  }, {\n    key: \"addPattern\",\n    value: function addPattern(pattern) {\n      return this.add(pattern);\n    } //          |           ignored : unignored\n    // negative |   0:0   |   0:1   |   1:0   |   1:1\n    // -------- | ------- | ------- | ------- | --------\n    //     0    |  TEST   |  TEST   |  SKIP   |    X\n    //     1    |  TESTIF |  SKIP   |  TEST   |    X\n    // - SKIP: always skip\n    // - TEST: always test\n    // - TESTIF: only test if checkUnignored\n    // - X: that never happen\n    // @param {boolean} whether should check if the path is unignored,\n    //   setting `checkUnignored` to `false` could reduce additional\n    //   path matching.\n    // @returns {TestResult} true if a file is ignored\n\n  }, {\n    key: \"_testOne\",\n    value: function _testOne(path, checkUnignored) {\n      var ignored = false;\n      var unignored = false;\n\n      this._rules.forEach(function (rule) {\n        var negative = rule.negative;\n\n        if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {\n          return;\n        }\n\n        var matched = rule.regex.test(path);\n\n        if (matched) {\n          ignored = !negative;\n          unignored = negative;\n        }\n      });\n\n      return {\n        ignored: ignored,\n        unignored: unignored\n      };\n    } // @returns {TestResult}\n\n  }, {\n    key: \"_test\",\n    value: function _test(originalPath, cache, checkUnignored, slices) {\n      var path = originalPath // Supports nullable path\n      && checkPath.convert(originalPath);\n      checkPath(path, originalPath, throwError);\n      return this._t(path, cache, checkUnignored, slices);\n    }\n  }, {\n    key: \"_t\",\n    value: function _t(path, cache, checkUnignored, slices) {\n      if (path in cache) {\n        return cache[path];\n      }\n\n      if (!slices) {\n        // path/to/a.js\n        // ['path', 'to', 'a.js']\n        slices = path.split(SLASH);\n      }\n\n      slices.pop(); // If the path has no parent directory, just test it\n\n      if (!slices.length) {\n        return cache[path] = this._testOne(path, checkUnignored);\n      }\n\n      var parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices); // If the path contains a parent directory, check the parent first\n\n\n      return cache[path] = parent.ignored // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent : this._testOne(path, checkUnignored);\n    }\n  }, {\n    key: \"ignores\",\n    value: function ignores(path) {\n      return this._test(path, this._ignoreCache, false).ignored;\n    }\n  }, {\n    key: \"createFilter\",\n    value: function createFilter() {\n      var _this = this;\n\n      return function (path) {\n        return !_this.ignores(path);\n      };\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(paths) {\n      return makeArray(paths).filter(this.createFilter());\n    } // @returns {TestResult}\n\n  }, {\n    key: \"test\",\n    value: function test(path) {\n      return this._test(path, this._testCache, true);\n    }\n  }]);\n\n  return Ignore;\n}();\n\nvar factory = function factory(options) {\n  return new Ignore(options);\n};\n\nvar returnFalse = function returnFalse() {\n  return false;\n};\n\nvar isPathValid = function isPathValid(path) {\n  return checkPath(path && checkPath.convert(path), path, returnFalse);\n};\n\nfactory.isPathValid = isPathValid; // Fixes typescript\n\nfactory.default = factory;\nmodule.exports = factory; // Windows\n// --------------------------------------------------------------\n\n/* istanbul ignore if  */\n\nif ( // Detect `process` so that it can run in browsers.\ntypeof process !== 'undefined' && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === 'win32')) {\n  /* eslint no-control-regex: \"off\" */\n  var makePosix = function makePosix(str) {\n    return /^\\\\\\\\\\?\\\\/.test(str) || /[\\0-\\x1F\"<>\\|]+/.test(str) ? str : str.replace(/\\\\/g, '/');\n  };\n\n  checkPath.convert = makePosix; // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n\n  var REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;\n\n  checkPath.isNotRelative = function (path) {\n    return REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);\n  };\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/ignore/index.js"],"names":["makeArray","subject","Array","isArray","EMPTY","SPACE","ESCAPE","REGEX_TEST_BLANK_LINE","REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION","REGEX_REPLACE_LEADING_EXCAPED_HASH","REGEX_SPLITALL_CRLF","REGEX_TEST_INVALID_PATH","SLASH","KEY_IGNORE","Symbol","for","define","object","key","value","Object","defineProperty","REGEX_REGEXP_RANGE","sanitizeRange","range","replace","match","from","to","charCodeAt","cleanRangeBackSlash","slashes","length","slice","REPLACERS","indexOf","startingReplacer","test","_","index","str","p1","leadEscape","endEscape","close","prefix","regexCache","create","makeRegex","pattern","negative","ignorecase","r","source","reduce","prev","current","bind","RegExp","isString","checkPattern","splitPattern","split","IgnoreRule","origin","regex","createRule","substr","throwError","message","Ctor","checkPath","path","originalPath","doThrow","TypeError","isNotRelative","RangeError","convert","p","Ignore","_rules","_ignorecase","_initCache","_ignoreCache","_testCache","concat","_added","rule","push","forEach","_addPattern","add","checkUnignored","ignored","unignored","matched","cache","slices","_t","pop","_testOne","parent","join","_test","ignores","paths","filter","createFilter","factory","options","returnFalse","isPathValid","default","module","exports","process","env","IGNORE_TEST_WIN32","platform","makePosix","REGIX_IS_WINDOWS_PATH_ABSOLUTE"],"mappings":"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","sourcesContent":["// A simple implementation of make-array\nfunction makeArray (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst EMPTY = ''\nconst SPACE = ' '\nconst ESCAPE = '\\\\'\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\n// /foo,\n// ./foo,\n// ../foo,\n// .\n// ..\nconst REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/\n\nconst SLASH = '/'\nconst KEY_IGNORE = typeof Symbol !== 'undefined'\n  ? Symbol.for('node-ignore')\n  /* istanbul ignore next */\n  : 'node-ignore'\n\nconst define = (object, key, value) =>\n  Object.defineProperty(object, key, {value})\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY\n)\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {length} = slashes\n  return slashes.slice(0, length - length % 2)\n}\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a \\ ) -> (a  )\n    /\\\\?\\s+$/,\n    match => match.indexOf('\\\\') === 0\n      ? SPACE\n      : EMPTY\n  ],\n\n  // replace (\\ ) with ' '\n  [\n    /\\\\\\s/g,\n    () => SPACE\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\$.|*+(){^]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ],\n\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      // If has a slash `/` at the beginning or middle\n      return !/\\/(?!$)/.test(this)\n        // > Prior to 2.22.1\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n\n        // After 2.22.1 (compatible but clearer)\n        // > If there is a separator at the beginning or middle (or both)\n        // > of the pattern, then the pattern is relative to the directory\n        // > level of the particular .gitignore file itself.\n        // > Otherwise the pattern may also match at any level below\n        // > the .gitignore level.\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (_, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule\n    /(^|[^\\\\]+)\\\\\\*(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (_, p1) => `${p1}[^\\\\/]*`\n  ],\n\n  [\n    // unescape, revert step 3 except for back slash\n    // For example, if a user escape a '\\\\*',\n    // after step 3, the result will be '\\\\\\\\\\\\*'\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n    () => ESCAPE\n  ],\n\n  [\n    // '\\\\\\\\' -> '\\\\'\n    /\\\\\\\\/g,\n    () => ESCAPE\n  ],\n\n  [\n    // > The range notation, e.g. [a-zA-Z],\n    // > can be used to match one of the characters in a range.\n\n    // `\\` is escaped by step 3\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\n      : close === ']'\n        ? endEscape.length % 2 === 0\n          // A normal case, and it is a range notation\n          // '[bar]'\n          // '[bar\\\\\\\\]'\n          ? `[${sanitizeRange(range)}${endEscape}]`\n          // Invalid range notaton\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\n          : '[]'\n        : '[]'\n  ],\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*])$/,\n\n    // WTF!\n    // https://git-scm.com/docs/gitignore\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n    // which re-fixes #24, #38\n\n    // > If there is a separator at the end of the pattern then the pattern\n    // > will only match directories, otherwise the pattern can match both\n    // > files and directories.\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => /\\/$/.test(match)\n      // foo/ will not match 'foo'\n      ? `${match}$`\n      // foo matches 'foo' and 'foo/'\n      : `${match}(?=$|\\\\/$)`\n  ],\n\n  // trailing wildcard\n  [\n    /(\\^|\\\\\\/)?\\\\\\*$/,\n    (_, p1) => {\n      const prefix = p1\n        // '\\^':\n        // '/*' does not match EMPTY\n        // '/*' does not match everything\n\n        // '\\\\\\/':\n        // 'abc/*' does not match 'abc/'\n        ? `${p1}[^/]+`\n\n        // 'a*' matches 'a'\n        // 'a*' matches 'aa'\n        : '[^/]*'\n\n      return `${prefix}(?=$|\\\\/$)`\n    }\n  ],\n]\n\n// A simple cache, because an ignore rule only has only one certain meaning\nconst regexCache = Object.create(null)\n\n// @param {pattern}\nconst makeRegex = (pattern, negative, ignorecase) => {\n  const r = regexCache[pattern]\n  if (r) {\n    return r\n  }\n\n  // const replacers = negative\n  //   ? NEGATIVE_REPLACERS\n  //   : POSITIVE_REPLACERS\n\n  const source = REPLACERS.reduce(\n    (prev, current) => prev.replace(current[0], current[1].bind(pattern)),\n    pattern\n  )\n\n  return regexCache[pattern] = ignorecase\n    ? new RegExp(source, 'i')\n    : new RegExp(source)\n}\n\nconst isString = subject => typeof subject === 'string'\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && isString(pattern)\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst splitPattern = pattern => pattern.split(REGEX_SPLITALL_CRLF)\n\nclass IgnoreRule {\n  constructor (\n    origin,\n    pattern,\n    negative,\n    regex\n  ) {\n    this.origin = origin\n    this.pattern = pattern\n    this.negative = negative\n    this.regex = regex\n  }\n}\n\nconst createRule = (pattern, ignorecase) => {\n  const origin = pattern\n  let negative = false\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (pattern.indexOf('!') === 0) {\n    negative = true\n    pattern = pattern.substr(1)\n  }\n\n  pattern = pattern\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\n\n  const regex = makeRegex(pattern, negative, ignorecase)\n\n  return new IgnoreRule(\n    origin,\n    pattern,\n    negative,\n    regex\n  )\n}\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message)\n}\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(\n      `path must be a string, but got \\`${originalPath}\\``,\n      TypeError\n    )\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError)\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d'\n    return doThrow(\n      `path should be a ${r} string, but got \"${originalPath}\"`,\n      RangeError\n    )\n  }\n\n  return true\n}\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\n\ncheckPath.isNotRelative = isNotRelative\ncheckPath.convert = p => p\n\nclass Ignore {\n  constructor ({\n    ignorecase = true\n  } = {}) {\n    this._rules = []\n    this._ignorecase = ignorecase\n    define(this, KEY_IGNORE, true)\n    this._initCache()\n  }\n\n  _initCache () {\n    this._ignoreCache = Object.create(null)\n    this._testCache = Object.create(null)\n  }\n\n  _addPattern (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules)\n      this._added = true\n      return\n    }\n\n    if (checkPattern(pattern)) {\n      const rule = createRule(pattern, this._ignorecase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    makeArray(\n      isString(pattern)\n        ? splitPattern(pattern)\n        : pattern\n    ).forEach(this._addPattern, this)\n\n    // Some rules have just added to the ignore,\n    // making the behavior changed.\n    if (this._added) {\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  //          |           ignored : unignored\n  // negative |   0:0   |   0:1   |   1:0   |   1:1\n  // -------- | ------- | ------- | ------- | --------\n  //     0    |  TEST   |  TEST   |  SKIP   |    X\n  //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n  // - SKIP: always skip\n  // - TEST: always test\n  // - TESTIF: only test if checkUnignored\n  // - X: that never happen\n\n  // @param {boolean} whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n\n  // @returns {TestResult} true if a file is ignored\n  _testOne (path, checkUnignored) {\n    let ignored = false\n    let unignored = false\n\n    this._rules.forEach(rule => {\n      const {negative} = rule\n      if (\n        unignored === negative && ignored !== unignored\n        || negative && !ignored && !unignored && !checkUnignored\n      ) {\n        return\n      }\n\n      const matched = rule.regex.test(path)\n\n      if (matched) {\n        ignored = !negative\n        unignored = negative\n      }\n    })\n\n    return {\n      ignored,\n      unignored\n    }\n  }\n\n  // @returns {TestResult}\n  _test (originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath)\n\n    checkPath(path, originalPath, throwError)\n\n    return this._t(path, cache, checkUnignored, slices)\n  }\n\n  _t (path, cache, checkUnignored, slices) {\n    if (path in cache) {\n      return cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH)\n    }\n\n    slices.pop()\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._testOne(path, checkUnignored)\n    }\n\n    const parent = this._t(\n      slices.join(SLASH) + SLASH,\n      cache,\n      checkUnignored,\n      slices\n    )\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent\n      : this._testOne(path, checkUnignored)\n  }\n\n  ignores (path) {\n    return this._test(path, this._ignoreCache, false).ignored\n  }\n\n  createFilter () {\n    return path => !this.ignores(path)\n  }\n\n  filter (paths) {\n    return makeArray(paths).filter(this.createFilter())\n  }\n\n  // @returns {TestResult}\n  test (path) {\n    return this._test(path, this._testCache, true)\n  }\n}\n\nconst factory = options => new Ignore(options)\n\nconst returnFalse = () => false\n\nconst isPathValid = path =>\n  checkPath(path && checkPath.convert(path), path, returnFalse)\n\nfactory.isPathValid = isPathValid\n\n// Fixes typescript\nfactory.default = factory\n\nmodule.exports = factory\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore if  */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && (\n    process.env && process.env.IGNORE_TEST_WIN32\n    || process.platform === 'win32'\n  )\n) {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  checkPath.convert = makePosix\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\n  checkPath.isNotRelative = path =>\n    REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path)\n    || isNotRelative(path)\n}\n"]},"metadata":{},"sourceType":"script"}