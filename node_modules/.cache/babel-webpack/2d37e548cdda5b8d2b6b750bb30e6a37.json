{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/translator/src/typescript_ast_factory\", [\"require\", \"exports\", \"tslib\", \"typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.attachComments = exports.createTemplateTail = exports.createTemplateMiddle = exports.TypeScriptAstFactory = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var UNARY_OPERATORS = {\n    '+': ts.SyntaxKind.PlusToken,\n    '-': ts.SyntaxKind.MinusToken,\n    '!': ts.SyntaxKind.ExclamationToken\n  };\n  var BINARY_OPERATORS = {\n    '&&': ts.SyntaxKind.AmpersandAmpersandToken,\n    '>': ts.SyntaxKind.GreaterThanToken,\n    '>=': ts.SyntaxKind.GreaterThanEqualsToken,\n    '&': ts.SyntaxKind.AmpersandToken,\n    '/': ts.SyntaxKind.SlashToken,\n    '==': ts.SyntaxKind.EqualsEqualsToken,\n    '===': ts.SyntaxKind.EqualsEqualsEqualsToken,\n    '<': ts.SyntaxKind.LessThanToken,\n    '<=': ts.SyntaxKind.LessThanEqualsToken,\n    '-': ts.SyntaxKind.MinusToken,\n    '%': ts.SyntaxKind.PercentToken,\n    '*': ts.SyntaxKind.AsteriskToken,\n    '!=': ts.SyntaxKind.ExclamationEqualsToken,\n    '!==': ts.SyntaxKind.ExclamationEqualsEqualsToken,\n    '||': ts.SyntaxKind.BarBarToken,\n    '+': ts.SyntaxKind.PlusToken\n  };\n  var VAR_TYPES = {\n    'const': ts.NodeFlags.Const,\n    'let': ts.NodeFlags.Let,\n    'var': ts.NodeFlags.None\n  };\n  /**\n   * A TypeScript flavoured implementation of the AstFactory.\n   */\n\n  var TypeScriptAstFactory =\n  /** @class */\n  function () {\n    function TypeScriptAstFactory() {\n      this.externalSourceFiles = new Map();\n      this.attachComments = attachComments;\n      this.createArrayLiteral = ts.createArrayLiteral;\n      this.createConditional = ts.createConditional;\n      this.createElementAccess = ts.createElementAccess;\n      this.createExpressionStatement = ts.createExpressionStatement;\n      this.createIdentifier = ts.createIdentifier;\n      this.createParenthesizedExpression = ts.createParen;\n      this.createPropertyAccess = ts.createPropertyAccess;\n      this.createThrowStatement = ts.createThrow;\n      this.createTypeOfExpression = ts.createTypeOf;\n    }\n\n    TypeScriptAstFactory.prototype.createAssignment = function (target, value) {\n      return ts.createBinary(target, ts.SyntaxKind.EqualsToken, value);\n    };\n\n    TypeScriptAstFactory.prototype.createBinaryExpression = function (leftOperand, operator, rightOperand) {\n      return ts.createBinary(leftOperand, BINARY_OPERATORS[operator], rightOperand);\n    };\n\n    TypeScriptAstFactory.prototype.createBlock = function (body) {\n      return ts.createBlock(body);\n    };\n\n    TypeScriptAstFactory.prototype.createCallExpression = function (callee, args, pure) {\n      var call = ts.createCall(callee, undefined, args);\n\n      if (pure) {\n        ts.addSyntheticLeadingComment(call, ts.SyntaxKind.MultiLineCommentTrivia, '@__PURE__',\n        /* trailing newline */\n        false);\n      }\n\n      return call;\n    };\n\n    TypeScriptAstFactory.prototype.createFunctionDeclaration = function (functionName, parameters, body) {\n      if (!ts.isBlock(body)) {\n        throw new Error(\"Invalid syntax, expected a block, but got \" + ts.SyntaxKind[body.kind] + \".\");\n      }\n\n      return ts.createFunctionDeclaration(undefined, undefined, undefined, functionName, undefined, parameters.map(function (param) {\n        return ts.createParameter(undefined, undefined, undefined, param);\n      }), undefined, body);\n    };\n\n    TypeScriptAstFactory.prototype.createFunctionExpression = function (functionName, parameters, body) {\n      if (!ts.isBlock(body)) {\n        throw new Error(\"Invalid syntax, expected a block, but got \" + ts.SyntaxKind[body.kind] + \".\");\n      }\n\n      return ts.createFunctionExpression(undefined, undefined, functionName !== null && functionName !== void 0 ? functionName : undefined, undefined, parameters.map(function (param) {\n        return ts.createParameter(undefined, undefined, undefined, param);\n      }), undefined, body);\n    };\n\n    TypeScriptAstFactory.prototype.createIfStatement = function (condition, thenStatement, elseStatement) {\n      return ts.createIf(condition, thenStatement, elseStatement !== null && elseStatement !== void 0 ? elseStatement : undefined);\n    };\n\n    TypeScriptAstFactory.prototype.createLiteral = function (value) {\n      if (value === undefined) {\n        return ts.createIdentifier('undefined');\n      } else if (value === null) {\n        return ts.createNull();\n      } else {\n        return ts.createLiteral(value);\n      }\n    };\n\n    TypeScriptAstFactory.prototype.createNewExpression = function (expression, args) {\n      return ts.createNew(expression, undefined, args);\n    };\n\n    TypeScriptAstFactory.prototype.createObjectLiteral = function (properties) {\n      return ts.createObjectLiteral(properties.map(function (prop) {\n        return ts.createPropertyAssignment(prop.quoted ? ts.createLiteral(prop.propertyName) : ts.createIdentifier(prop.propertyName), prop.value);\n      }));\n    };\n\n    TypeScriptAstFactory.prototype.createReturnStatement = function (expression) {\n      return ts.createReturn(expression !== null && expression !== void 0 ? expression : undefined);\n    };\n\n    TypeScriptAstFactory.prototype.createTaggedTemplate = function (tag, template) {\n      var templateLiteral;\n      var length = template.elements.length;\n      var head = template.elements[0];\n\n      if (length === 1) {\n        templateLiteral = ts.createNoSubstitutionTemplateLiteral(head.cooked, head.raw);\n      } else {\n        var spans = []; // Create the middle parts\n\n        for (var i = 1; i < length - 1; i++) {\n          var _a = template.elements[i],\n              cooked = _a.cooked,\n              raw = _a.raw,\n              range = _a.range;\n          var middle = createTemplateMiddle(cooked, raw);\n\n          if (range !== null) {\n            this.setSourceMapRange(middle, range);\n          }\n\n          spans.push(ts.createTemplateSpan(template.expressions[i - 1], middle));\n        } // Create the tail part\n\n\n        var resolvedExpression = template.expressions[length - 2];\n        var templatePart = template.elements[length - 1];\n        var templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n\n        if (templatePart.range !== null) {\n          this.setSourceMapRange(templateTail, templatePart.range);\n        }\n\n        spans.push(ts.createTemplateSpan(resolvedExpression, templateTail)); // Put it all together\n\n        templateLiteral = ts.createTemplateExpression(ts.createTemplateHead(head.cooked, head.raw), spans);\n      }\n\n      if (head.range !== null) {\n        this.setSourceMapRange(templateLiteral, head.range);\n      }\n\n      return ts.createTaggedTemplate(tag, templateLiteral);\n    };\n\n    TypeScriptAstFactory.prototype.createUnaryExpression = function (operator, operand) {\n      return ts.createPrefix(UNARY_OPERATORS[operator], operand);\n    };\n\n    TypeScriptAstFactory.prototype.createVariableDeclaration = function (variableName, initializer, type) {\n      return ts.createVariableStatement(undefined, ts.createVariableDeclarationList([ts.createVariableDeclaration(variableName, undefined, initializer !== null && initializer !== void 0 ? initializer : undefined)], VAR_TYPES[type]));\n    };\n\n    TypeScriptAstFactory.prototype.setSourceMapRange = function (node, sourceMapRange) {\n      if (sourceMapRange === null) {\n        return node;\n      }\n\n      var url = sourceMapRange.url;\n\n      if (!this.externalSourceFiles.has(url)) {\n        this.externalSourceFiles.set(url, ts.createSourceMapSource(url, sourceMapRange.content, function (pos) {\n          return pos;\n        }));\n      }\n\n      var source = this.externalSourceFiles.get(url);\n      ts.setSourceMapRange(node, {\n        pos: sourceMapRange.start.offset,\n        end: sourceMapRange.end.offset,\n        source: source\n      });\n      return node;\n    };\n\n    return TypeScriptAstFactory;\n  }();\n\n  exports.TypeScriptAstFactory = TypeScriptAstFactory; // HACK: Use this in place of `ts.createTemplateMiddle()`.\n  // Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.\n\n  function createTemplateMiddle(cooked, raw) {\n    var node = ts.createTemplateHead(cooked, raw);\n    node.kind = ts.SyntaxKind.TemplateMiddle;\n    return node;\n  }\n\n  exports.createTemplateMiddle = createTemplateMiddle; // HACK: Use this in place of `ts.createTemplateTail()`.\n  // Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.\n\n  function createTemplateTail(cooked, raw) {\n    var node = ts.createTemplateHead(cooked, raw);\n    node.kind = ts.SyntaxKind.TemplateTail;\n    return node;\n  }\n\n  exports.createTemplateTail = createTemplateTail;\n  /**\n   * Attach the given `leadingComments` to the `statement` node.\n   *\n   * @param statement The statement that will have comments attached.\n   * @param leadingComments The comments to attach to the statement.\n   */\n\n  function attachComments(statement, leadingComments) {\n    var e_1, _a, e_2, _b;\n\n    try {\n      for (var leadingComments_1 = tslib_1.__values(leadingComments), leadingComments_1_1 = leadingComments_1.next(); !leadingComments_1_1.done; leadingComments_1_1 = leadingComments_1.next()) {\n        var comment = leadingComments_1_1.value;\n        var commentKind = comment.multiline ? ts.SyntaxKind.MultiLineCommentTrivia : ts.SyntaxKind.SingleLineCommentTrivia;\n\n        if (comment.multiline) {\n          ts.addSyntheticLeadingComment(statement, commentKind, comment.toString(), comment.trailingNewline);\n        } else {\n          try {\n            for (var _c = (e_2 = void 0, tslib_1.__values(comment.toString().split('\\n'))), _d = _c.next(); !_d.done; _d = _c.next()) {\n              var line = _d.value;\n              ts.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (leadingComments_1_1 && !leadingComments_1_1.done && (_a = leadingComments_1.return)) _a.call(leadingComments_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  exports.attachComments = attachComments;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/translator/src/typescript_ast_factory.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAMG;;;AACH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAIA,MAAM,eAAe,GAAkD;AACrE,SAAK,EAAE,CAAC,UAAH,CAAc,SADkD;AAErE,SAAK,EAAE,CAAC,UAAH,CAAc,UAFkD;AAGrE,SAAK,EAAE,CAAC,UAAH,CAAc;AAHkD,GAAvE;AAMA,MAAM,gBAAgB,GAA8C;AAClE,UAAM,EAAE,CAAC,UAAH,CAAc,uBAD8C;AAElE,SAAK,EAAE,CAAC,UAAH,CAAc,gBAF+C;AAGlE,UAAM,EAAE,CAAC,UAAH,CAAc,sBAH8C;AAIlE,SAAK,EAAE,CAAC,UAAH,CAAc,cAJ+C;AAKlE,SAAK,EAAE,CAAC,UAAH,CAAc,UAL+C;AAMlE,UAAM,EAAE,CAAC,UAAH,CAAc,iBAN8C;AAOlE,WAAO,EAAE,CAAC,UAAH,CAAc,uBAP6C;AAQlE,SAAK,EAAE,CAAC,UAAH,CAAc,aAR+C;AASlE,UAAM,EAAE,CAAC,UAAH,CAAc,mBAT8C;AAUlE,SAAK,EAAE,CAAC,UAAH,CAAc,UAV+C;AAWlE,SAAK,EAAE,CAAC,UAAH,CAAc,YAX+C;AAYlE,SAAK,EAAE,CAAC,UAAH,CAAc,aAZ+C;AAalE,UAAM,EAAE,CAAC,UAAH,CAAc,sBAb8C;AAclE,WAAO,EAAE,CAAC,UAAH,CAAc,4BAd6C;AAelE,UAAM,EAAE,CAAC,UAAH,CAAc,WAf8C;AAgBlE,SAAK,EAAE,CAAC,UAAH,CAAc;AAhB+C,GAApE;AAmBA,MAAM,SAAS,GAAkD;AAC/D,aAAS,EAAE,CAAC,SAAH,CAAa,KADyC;AAE/D,WAAO,EAAE,CAAC,SAAH,CAAa,GAF2C;AAG/D,WAAO,EAAE,CAAC,SAAH,CAAa;AAH2C,GAAjE;AAMA;;AAEG;;AACH,MAAA,oBAAA;AAAA;AAAA,cAAA;AAAA,aAAA,oBAAA,GAAA;AACU,WAAA,mBAAA,GAAsB,IAAI,GAAJ,EAAtB;AAER,WAAA,cAAA,GAAiB,cAAjB;AAEA,WAAA,kBAAA,GAAqB,EAAE,CAAC,kBAAxB;AAyBA,WAAA,iBAAA,GAAoB,EAAE,CAAC,iBAAvB;AAEA,WAAA,mBAAA,GAAsB,EAAE,CAAC,mBAAzB;AAEA,WAAA,yBAAA,GAA4B,EAAE,CAAC,yBAA/B;AAwBA,WAAA,gBAAA,GAAmB,EAAE,CAAC,gBAAtB;AA8BA,WAAA,6BAAA,GAAgC,EAAE,CAAC,WAAnC;AAEA,WAAA,oBAAA,GAAuB,EAAE,CAAC,oBAA1B;AA0CA,WAAA,oBAAA,GAAuB,EAAE,CAAC,WAA1B;AAEA,WAAA,sBAAA,GAAyB,EAAE,CAAC,YAA5B;AAiCD;;AAhKC,IAAA,oBAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,MAAjB,EAAwC,KAAxC,EAA4D;AAC1D,aAAO,EAAE,CAAC,YAAH,CAAgB,MAAhB,EAAwB,EAAE,CAAC,UAAH,CAAc,WAAtC,EAAmD,KAAnD,CAAP;AACD,KAFD;;AAIA,IAAA,oBAAA,CAAA,SAAA,CAAA,sBAAA,GAAA,UACI,WADJ,EACgC,QADhC,EAEI,YAFJ,EAE+B;AAC7B,aAAO,EAAE,CAAC,YAAH,CAAgB,WAAhB,EAA6B,gBAAgB,CAAC,QAAD,CAA7C,EAAyD,YAAzD,CAAP;AACD,KAJD;;AAMA,IAAA,oBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,IAAZ,EAAgC;AAC9B,aAAO,EAAE,CAAC,WAAH,CAAe,IAAf,CAAP;AACD,KAFD;;AAIA,IAAA,oBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,MAArB,EAA4C,IAA5C,EAAmE,IAAnE,EAAgF;AAC9E,UAAM,IAAI,GAAG,EAAE,CAAC,UAAH,CAAc,MAAd,EAAsB,SAAtB,EAAiC,IAAjC,CAAb;;AACA,UAAI,IAAJ,EAAU;AACR,QAAA,EAAE,CAAC,0BAAH,CACI,IADJ,EACU,EAAE,CAAC,UAAH,CAAc,sBADxB,EACgD,WADhD;AAC6D;AAAuB,aADpF;AAED;;AACD,aAAO,IAAP;AACD,KAPD;;AAeA,IAAA,oBAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UAA0B,YAA1B,EAAgD,UAAhD,EAAsE,IAAtE,EAAwF;AAEtF,UAAI,CAAC,EAAE,CAAC,OAAH,CAAW,IAAX,CAAL,EAAuB;AACrB,cAAM,IAAI,KAAJ,CAAU,+CAA6C,EAAE,CAAC,UAAH,CAAc,IAAI,CAAC,IAAnB,CAA7C,GAAqE,GAA/E,CAAN;AACD;;AACD,aAAO,EAAE,CAAC,yBAAH,CACH,SADG,EACQ,SADR,EACmB,SADnB,EAC8B,YAD9B,EAC4C,SAD5C,EAEH,UAAU,CAAC,GAAX,CAAe,UAAA,KAAA,EAAK;AAAI,eAAA,EAAE,CAAC,eAAH,CAAmB,SAAnB,EAA8B,SAA9B,EAAyC,SAAzC,EAAA,KAAA,CAAA;AAA0D,OAAlF,CAFG,EAGH,SAHG,EAGQ,IAHR,CAAP;AAID,KATD;;AAWA,IAAA,oBAAA,CAAA,SAAA,CAAA,wBAAA,GAAA,UAAyB,YAAzB,EAAoD,UAApD,EAA0E,IAA1E,EAA4F;AAE1F,UAAI,CAAC,EAAE,CAAC,OAAH,CAAW,IAAX,CAAL,EAAuB;AACrB,cAAM,IAAI,KAAJ,CAAU,+CAA6C,EAAE,CAAC,UAAH,CAAc,IAAI,CAAC,IAAnB,CAA7C,GAAqE,GAA/E,CAAN;AACD;;AACD,aAAO,EAAE,CAAC,wBAAH,CACH,SADG,EACQ,SADR,EACmB,YAAY,KAAA,IAAZ,IAAA,YAAY,KAAA,KAAA,CAAZ,GAAA,YAAA,GAAgB,SADnC,EAC8C,SAD9C,EAEH,UAAU,CAAC,GAAX,CAAe,UAAA,KAAA,EAAK;AAAI,eAAA,EAAE,CAAC,eAAH,CAAmB,SAAnB,EAA8B,SAA9B,EAAyC,SAAzC,EAAA,KAAA,CAAA;AAA0D,OAAlF,CAFG,EAGH,SAHG,EAGQ,IAHR,CAAP;AAID,KATD;;AAaA,IAAA,oBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UACI,SADJ,EAC8B,aAD9B,EAEI,aAFJ,EAEoC;AAClC,aAAO,EAAE,CAAC,QAAH,CAAY,SAAZ,EAAuB,aAAvB,EAAsC,aAAa,KAAA,IAAb,IAAA,aAAa,KAAA,KAAA,CAAb,GAAA,aAAA,GAAiB,SAAvD,CAAP;AACD,KAJD;;AAMA,IAAA,oBAAA,CAAA,SAAA,CAAA,aAAA,GAAA,UAAc,KAAd,EAAyD;AACvD,UAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,eAAO,EAAE,CAAC,gBAAH,CAAoB,WAApB,CAAP;AACD,OAFD,MAEO,IAAI,KAAK,KAAK,IAAd,EAAoB;AACzB,eAAO,EAAE,CAAC,UAAH,EAAP;AACD,OAFM,MAEA;AACL,eAAO,EAAE,CAAC,aAAH,CAAiB,KAAjB,CAAP;AACD;AACF,KARD;;AAUA,IAAA,oBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,UAApB,EAA+C,IAA/C,EAAoE;AAClE,aAAO,EAAE,CAAC,SAAH,CAAa,UAAb,EAAyB,SAAzB,EAAoC,IAApC,CAAP;AACD,KAFD;;AAIA,IAAA,oBAAA,CAAA,SAAA,CAAA,mBAAA,GAAA,UAAoB,UAApB,EAAsE;AACpE,aAAO,EAAE,CAAC,mBAAH,CAAuB,UAAU,CAAC,GAAX,CAC1B,UAAA,IAAA,EAAI;AAAI,eAAA,EAAE,CAAC,wBAAH,CACJ,IAAI,CAAC,MAAL,GAAc,EAAE,CAAC,aAAH,CAAiB,IAAI,CAAC,YAAtB,CAAd,GACc,EAAE,CAAC,gBAAH,CAAoB,IAAI,CAAC,YAAzB,CAFV,EAGJ,IAAI,CAHA,KAAA,CAAA;AAGO,OAJW,CAAvB,CAAP;AAKD,KAND;;AAYA,IAAA,oBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,UAAtB,EAAoD;AAClD,aAAO,EAAE,CAAC,YAAH,CAAgB,UAAU,KAAA,IAAV,IAAA,UAAU,KAAA,KAAA,CAAV,GAAA,UAAA,GAAc,SAA9B,CAAP;AACD,KAFD;;AAIA,IAAA,oBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,GAArB,EAAyC,QAAzC,EAAiF;AAE/E,UAAI,eAAJ;AACA,UAAM,MAAM,GAAG,QAAQ,CAAC,QAAT,CAAkB,MAAjC;AACA,UAAM,IAAI,GAAG,QAAQ,CAAC,QAAT,CAAkB,CAAlB,CAAb;;AACA,UAAI,MAAM,KAAK,CAAf,EAAkB;AAChB,QAAA,eAAe,GAAG,EAAE,CAAC,mCAAH,CAAuC,IAAI,CAAC,MAA5C,EAAoD,IAAI,CAAC,GAAzD,CAAlB;AACD,OAFD,MAEO;AACL,YAAM,KAAK,GAAsB,EAAjC,CADK,CAEL;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,GAAG,CAA7B,EAAgC,CAAC,EAAjC,EAAqC;AAC7B,cAAA,EAAA,GAAuB,QAAQ,CAAC,QAAT,CAAkB,CAAlB,CAAvB;AAAA,cAAC,MAAM,GAAA,EAAA,CAAA,MAAP;AAAA,cAAS,GAAG,GAAA,EAAA,CAAA,GAAZ;AAAA,cAAc,KAAK,GAAA,EAAA,CAAA,KAAnB;AACN,cAAM,MAAM,GAAG,oBAAoB,CAAC,MAAD,EAAS,GAAT,CAAnC;;AACA,cAAI,KAAK,KAAK,IAAd,EAAoB;AAClB,iBAAK,iBAAL,CAAuB,MAAvB,EAA+B,KAA/B;AACD;;AACD,UAAA,KAAK,CAAC,IAAN,CAAW,EAAE,CAAC,kBAAH,CAAsB,QAAQ,CAAC,WAAT,CAAqB,CAAC,GAAG,CAAzB,CAAtB,EAAmD,MAAnD,CAAX;AACD,SAVI,CAWL;;;AACA,YAAM,kBAAkB,GAAG,QAAQ,CAAC,WAAT,CAAqB,MAAM,GAAG,CAA9B,CAA3B;AACA,YAAM,YAAY,GAAG,QAAQ,CAAC,QAAT,CAAkB,MAAM,GAAG,CAA3B,CAArB;AACA,YAAM,YAAY,GAAG,kBAAkB,CAAC,YAAY,CAAC,MAAd,EAAsB,YAAY,CAAC,GAAnC,CAAvC;;AACA,YAAI,YAAY,CAAC,KAAb,KAAuB,IAA3B,EAAiC;AAC/B,eAAK,iBAAL,CAAuB,YAAvB,EAAqC,YAAY,CAAC,KAAlD;AACD;;AACD,QAAA,KAAK,CAAC,IAAN,CAAW,EAAE,CAAC,kBAAH,CAAsB,kBAAtB,EAA0C,YAA1C,CAAX,EAlBK,CAmBL;;AACA,QAAA,eAAe,GACX,EAAE,CAAC,wBAAH,CAA4B,EAAE,CAAC,kBAAH,CAAsB,IAAI,CAAC,MAA3B,EAAmC,IAAI,CAAC,GAAxC,CAA5B,EAA0E,KAA1E,CADJ;AAED;;AACD,UAAI,IAAI,CAAC,KAAL,KAAe,IAAnB,EAAyB;AACvB,aAAK,iBAAL,CAAuB,eAAvB,EAAwC,IAAI,CAAC,KAA7C;AACD;;AACD,aAAO,EAAE,CAAC,oBAAH,CAAwB,GAAxB,EAA6B,eAA7B,CAAP;AACD,KAlCD;;AAyCA,IAAA,oBAAA,CAAA,SAAA,CAAA,qBAAA,GAAA,UAAsB,QAAtB,EAA+C,OAA/C,EAAqE;AACnE,aAAO,EAAE,CAAC,YAAH,CAAgB,eAAe,CAAC,QAAD,CAA/B,EAA2C,OAA3C,CAAP;AACD,KAFD;;AAIA,IAAA,oBAAA,CAAA,SAAA,CAAA,yBAAA,GAAA,UACI,YADJ,EAC0B,WAD1B,EAEI,IAFJ,EAEiC;AAC/B,aAAO,EAAE,CAAC,uBAAH,CACH,SADG,EAEH,EAAE,CAAC,6BAAH,CACI,CAAC,EAAE,CAAC,yBAAH,CAA6B,YAA7B,EAA2C,SAA3C,EAAsD,WAAW,KAAA,IAAX,IAAA,WAAW,KAAA,KAAA,CAAX,GAAA,WAAA,GAAe,SAArE,CAAD,CADJ,EAEI,SAAS,CAAC,IAAD,CAFb,CAFG,CAAP;AAMD,KATD;;AAWA,IAAA,oBAAA,CAAA,SAAA,CAAA,iBAAA,GAAA,UAAqC,IAArC,EAA8C,cAA9C,EAAiF;AAC/E,UAAI,cAAc,KAAK,IAAvB,EAA6B;AAC3B,eAAO,IAAP;AACD;;AAED,UAAM,GAAG,GAAG,cAAc,CAAC,GAA3B;;AACA,UAAI,CAAC,KAAK,mBAAL,CAAyB,GAAzB,CAA6B,GAA7B,CAAL,EAAwC;AACtC,aAAK,mBAAL,CAAyB,GAAzB,CACI,GADJ,EACS,EAAE,CAAC,qBAAH,CAAyB,GAAzB,EAA8B,cAAc,CAAC,OAA7C,EAAsD,UAAA,GAAA,EAAG;AAAI,iBAAA,GAAA;AAAG,SAAhE,CADT;AAED;;AACD,UAAM,MAAM,GAAG,KAAK,mBAAL,CAAyB,GAAzB,CAA6B,GAA7B,CAAf;AACA,MAAA,EAAE,CAAC,iBAAH,CACI,IADJ,EACU;AAAC,QAAA,GAAG,EAAE,cAAc,CAAC,KAAf,CAAqB,MAA3B;AAAmC,QAAA,GAAG,EAAE,cAAc,CAAC,GAAf,CAAmB,MAA3D;AAAmE,QAAA,MAAM,EAAA;AAAzE,OADV;AAEA,aAAO,IAAP;AACD,KAdD;;AAeF,WAAA,oBAAA;AAAC,GAvKD,EAAA;;AAAa,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA,C,CAyKb;AACA;;AACA,WAAgB,oBAAhB,CAAqC,MAArC,EAAqD,GAArD,EAAgE;AAC9D,QAAM,IAAI,GAA+B,EAAE,CAAC,kBAAH,CAAsB,MAAtB,EAA8B,GAA9B,CAAzC;AACC,IAAA,IAAI,CAAC,IAAL,GAA8B,EAAE,CAAC,UAAH,CAAc,cAA5C;AACD,WAAO,IAAP;AACD;;AAJD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA,C,CAMA;AACA;;AACA,WAAgB,kBAAhB,CAAmC,MAAnC,EAAmD,GAAnD,EAA8D;AAC5D,QAAM,IAAI,GAA+B,EAAE,CAAC,kBAAH,CAAsB,MAAtB,EAA8B,GAA9B,CAAzC;AACC,IAAA,IAAI,CAAC,IAAL,GAA8B,EAAE,CAAC,UAAH,CAAc,YAA5C;AACD,WAAO,IAAP;AACD;;AAJD,EAAA,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAMA;;;;;AAKG;;AACH,WAAgB,cAAhB,CAA+B,SAA/B,EAAwD,eAAxD,EAAyF;;;;AACvF,WAAsB,IAAA,iBAAA,GAAA,OAAA,CAAA,QAAA,CAAA,eAAA,CAAA,EAAe,mBAAA,GAAA,iBAAA,CAAA,IAAA,EAArC,EAAqC,CAAA,mBAAA,CAAA,IAArC,EAAqC,mBAAA,GAAA,iBAAA,CAAA,IAAA,EAArC,EAAuC;AAAlC,YAAM,OAAO,GAAA,mBAAA,CAAA,KAAb;AACH,YAAM,WAAW,GAAG,OAAO,CAAC,SAAR,GAAoB,EAAE,CAAC,UAAH,CAAc,sBAAlC,GACoB,EAAE,CAAC,UAAH,CAAc,uBADtD;;AAEA,YAAI,OAAO,CAAC,SAAZ,EAAuB;AACrB,UAAA,EAAE,CAAC,0BAAH,CACI,SADJ,EACe,WADf,EAC4B,OAAO,CAAC,QAAR,EAD5B,EACgD,OAAO,CAAC,eADxD;AAED,SAHD,MAGO;;AACL,iBAAmB,IAAA,EAAA,IAAA,GAAA,GAAA,KAAA,CAAA,EAAA,OAAA,CAAA,QAAA,CAAA,OAAO,CAAC,QAAR,GAAmB,KAAnB,CAAyB,IAAzB,CAAA,CAAA,CAAA,EAA8B,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjD,EAAiD,CAAA,EAAA,CAAA,IAAjD,EAAiD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjD,EAAmD;AAA9C,kBAAM,IAAI,GAAA,EAAA,CAAA,KAAV;AACH,cAAA,EAAE,CAAC,0BAAH,CAA8B,SAA9B,EAAyC,WAAzC,EAAsD,IAAtD,EAA4D,OAAO,CAAC,eAApE;AACD;;;;;;;;;;;;AACF;AACF;;;;;;;;;;;;AACF;;AAbD,EAAA,OAAA,CAAA,cAAA,GAAA,cAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {AstFactory, BinaryOperator, LeadingComment, ObjectLiteralProperty, SourceMapRange, TemplateLiteral, UnaryOperator, VariableDeclarationType} from './api/ast_factory';\n\nconst UNARY_OPERATORS: Record<UnaryOperator, ts.PrefixUnaryOperator> = {\n  '+': ts.SyntaxKind.PlusToken,\n  '-': ts.SyntaxKind.MinusToken,\n  '!': ts.SyntaxKind.ExclamationToken,\n};\n\nconst BINARY_OPERATORS: Record<BinaryOperator, ts.BinaryOperator> = {\n  '&&': ts.SyntaxKind.AmpersandAmpersandToken,\n  '>': ts.SyntaxKind.GreaterThanToken,\n  '>=': ts.SyntaxKind.GreaterThanEqualsToken,\n  '&': ts.SyntaxKind.AmpersandToken,\n  '/': ts.SyntaxKind.SlashToken,\n  '==': ts.SyntaxKind.EqualsEqualsToken,\n  '===': ts.SyntaxKind.EqualsEqualsEqualsToken,\n  '<': ts.SyntaxKind.LessThanToken,\n  '<=': ts.SyntaxKind.LessThanEqualsToken,\n  '-': ts.SyntaxKind.MinusToken,\n  '%': ts.SyntaxKind.PercentToken,\n  '*': ts.SyntaxKind.AsteriskToken,\n  '!=': ts.SyntaxKind.ExclamationEqualsToken,\n  '!==': ts.SyntaxKind.ExclamationEqualsEqualsToken,\n  '||': ts.SyntaxKind.BarBarToken,\n  '+': ts.SyntaxKind.PlusToken,\n};\n\nconst VAR_TYPES: Record<VariableDeclarationType, ts.NodeFlags> = {\n  'const': ts.NodeFlags.Const,\n  'let': ts.NodeFlags.Let,\n  'var': ts.NodeFlags.None,\n};\n\n/**\n * A TypeScript flavoured implementation of the AstFactory.\n */\nexport class TypeScriptAstFactory implements AstFactory<ts.Statement, ts.Expression> {\n  private externalSourceFiles = new Map<string, ts.SourceMapSource>();\n\n  attachComments = attachComments;\n\n  createArrayLiteral = ts.createArrayLiteral;\n\n  createAssignment(target: ts.Expression, value: ts.Expression): ts.Expression {\n    return ts.createBinary(target, ts.SyntaxKind.EqualsToken, value);\n  }\n\n  createBinaryExpression(\n      leftOperand: ts.Expression, operator: BinaryOperator,\n      rightOperand: ts.Expression): ts.Expression {\n    return ts.createBinary(leftOperand, BINARY_OPERATORS[operator], rightOperand);\n  }\n\n  createBlock(body: ts.Statement[]): ts.Statement {\n    return ts.createBlock(body);\n  }\n\n  createCallExpression(callee: ts.Expression, args: ts.Expression[], pure: boolean): ts.Expression {\n    const call = ts.createCall(callee, undefined, args);\n    if (pure) {\n      ts.addSyntheticLeadingComment(\n          call, ts.SyntaxKind.MultiLineCommentTrivia, '@__PURE__', /* trailing newline */ false);\n    }\n    return call;\n  }\n\n  createConditional = ts.createConditional;\n\n  createElementAccess = ts.createElementAccess;\n\n  createExpressionStatement = ts.createExpressionStatement;\n\n  createFunctionDeclaration(functionName: string, parameters: string[], body: ts.Statement):\n      ts.Statement {\n    if (!ts.isBlock(body)) {\n      throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);\n    }\n    return ts.createFunctionDeclaration(\n        undefined, undefined, undefined, functionName, undefined,\n        parameters.map(param => ts.createParameter(undefined, undefined, undefined, param)),\n        undefined, body);\n  }\n\n  createFunctionExpression(functionName: string|null, parameters: string[], body: ts.Statement):\n      ts.Expression {\n    if (!ts.isBlock(body)) {\n      throw new Error(`Invalid syntax, expected a block, but got ${ts.SyntaxKind[body.kind]}.`);\n    }\n    return ts.createFunctionExpression(\n        undefined, undefined, functionName ?? undefined, undefined,\n        parameters.map(param => ts.createParameter(undefined, undefined, undefined, param)),\n        undefined, body);\n  }\n\n  createIdentifier = ts.createIdentifier;\n\n  createIfStatement(\n      condition: ts.Expression, thenStatement: ts.Statement,\n      elseStatement: ts.Statement|null): ts.Statement {\n    return ts.createIf(condition, thenStatement, elseStatement ?? undefined);\n  }\n\n  createLiteral(value: string|number|boolean|null|undefined): ts.Expression {\n    if (value === undefined) {\n      return ts.createIdentifier('undefined');\n    } else if (value === null) {\n      return ts.createNull();\n    } else {\n      return ts.createLiteral(value);\n    }\n  }\n\n  createNewExpression(expression: ts.Expression, args: ts.Expression[]): ts.Expression {\n    return ts.createNew(expression, undefined, args);\n  }\n\n  createObjectLiteral(properties: ObjectLiteralProperty<ts.Expression>[]): ts.Expression {\n    return ts.createObjectLiteral(properties.map(\n        prop => ts.createPropertyAssignment(\n            prop.quoted ? ts.createLiteral(prop.propertyName) :\n                          ts.createIdentifier(prop.propertyName),\n            prop.value)));\n  }\n\n  createParenthesizedExpression = ts.createParen;\n\n  createPropertyAccess = ts.createPropertyAccess;\n\n  createReturnStatement(expression: ts.Expression|null): ts.Statement {\n    return ts.createReturn(expression ?? undefined);\n  }\n\n  createTaggedTemplate(tag: ts.Expression, template: TemplateLiteral<ts.Expression>):\n      ts.Expression {\n    let templateLiteral: ts.TemplateLiteral;\n    const length = template.elements.length;\n    const head = template.elements[0];\n    if (length === 1) {\n      templateLiteral = ts.createNoSubstitutionTemplateLiteral(head.cooked, head.raw);\n    } else {\n      const spans: ts.TemplateSpan[] = [];\n      // Create the middle parts\n      for (let i = 1; i < length - 1; i++) {\n        const {cooked, raw, range} = template.elements[i];\n        const middle = createTemplateMiddle(cooked, raw);\n        if (range !== null) {\n          this.setSourceMapRange(middle, range);\n        }\n        spans.push(ts.createTemplateSpan(template.expressions[i - 1], middle));\n      }\n      // Create the tail part\n      const resolvedExpression = template.expressions[length - 2];\n      const templatePart = template.elements[length - 1];\n      const templateTail = createTemplateTail(templatePart.cooked, templatePart.raw);\n      if (templatePart.range !== null) {\n        this.setSourceMapRange(templateTail, templatePart.range);\n      }\n      spans.push(ts.createTemplateSpan(resolvedExpression, templateTail));\n      // Put it all together\n      templateLiteral =\n          ts.createTemplateExpression(ts.createTemplateHead(head.cooked, head.raw), spans);\n    }\n    if (head.range !== null) {\n      this.setSourceMapRange(templateLiteral, head.range);\n    }\n    return ts.createTaggedTemplate(tag, templateLiteral);\n  }\n\n  createThrowStatement = ts.createThrow;\n\n  createTypeOfExpression = ts.createTypeOf;\n\n\n  createUnaryExpression(operator: UnaryOperator, operand: ts.Expression): ts.Expression {\n    return ts.createPrefix(UNARY_OPERATORS[operator], operand);\n  }\n\n  createVariableDeclaration(\n      variableName: string, initializer: ts.Expression|null,\n      type: VariableDeclarationType): ts.Statement {\n    return ts.createVariableStatement(\n        undefined,\n        ts.createVariableDeclarationList(\n            [ts.createVariableDeclaration(variableName, undefined, initializer ?? undefined)],\n            VAR_TYPES[type]),\n    );\n  }\n\n  setSourceMapRange<T extends ts.Node>(node: T, sourceMapRange: SourceMapRange|null): T {\n    if (sourceMapRange === null) {\n      return node;\n    }\n\n    const url = sourceMapRange.url;\n    if (!this.externalSourceFiles.has(url)) {\n      this.externalSourceFiles.set(\n          url, ts.createSourceMapSource(url, sourceMapRange.content, pos => pos));\n    }\n    const source = this.externalSourceFiles.get(url);\n    ts.setSourceMapRange(\n        node, {pos: sourceMapRange.start.offset, end: sourceMapRange.end.offset, source});\n    return node;\n  }\n}\n\n// HACK: Use this in place of `ts.createTemplateMiddle()`.\n// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.\nexport function createTemplateMiddle(cooked: string, raw: string): ts.TemplateMiddle {\n  const node: ts.TemplateLiteralLikeNode = ts.createTemplateHead(cooked, raw);\n  (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateMiddle;\n  return node as ts.TemplateMiddle;\n}\n\n// HACK: Use this in place of `ts.createTemplateTail()`.\n// Revert once https://github.com/microsoft/TypeScript/issues/35374 is fixed.\nexport function createTemplateTail(cooked: string, raw: string): ts.TemplateTail {\n  const node: ts.TemplateLiteralLikeNode = ts.createTemplateHead(cooked, raw);\n  (node.kind as ts.SyntaxKind) = ts.SyntaxKind.TemplateTail;\n  return node as ts.TemplateTail;\n}\n\n/**\n * Attach the given `leadingComments` to the `statement` node.\n *\n * @param statement The statement that will have comments attached.\n * @param leadingComments The comments to attach to the statement.\n */\nexport function attachComments(statement: ts.Statement, leadingComments: LeadingComment[]): void {\n  for (const comment of leadingComments) {\n    const commentKind = comment.multiline ? ts.SyntaxKind.MultiLineCommentTrivia :\n                                            ts.SyntaxKind.SingleLineCommentTrivia;\n    if (comment.multiline) {\n      ts.addSyntheticLeadingComment(\n          statement, commentKind, comment.toString(), comment.trailingNewline);\n    } else {\n      for (const line of comment.toString().split('\\n')) {\n        ts.addSyntheticLeadingComment(statement, commentKind, line, comment.trailingNewline);\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}