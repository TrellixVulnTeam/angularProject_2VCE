{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/augmented_program\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/shims\", \"@angular/compiler-cli/src/ngtsc/typecheck/api\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/host\", \"@angular/compiler-cli/src/ngtsc/typecheck/src/shim\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ReusedProgramStrategy = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var shims_1 = require(\"@angular/compiler-cli/src/ngtsc/shims\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/api\");\n\n  var host_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/host\");\n\n  var shim_1 = require(\"@angular/compiler-cli/src/ngtsc/typecheck/src/shim\");\n  /**\n   * Implements a template type-checking program using `ts.createProgram` and TypeScript's program\n   * reuse functionality.\n   */\n\n\n  var ReusedProgramStrategy =\n  /** @class */\n  function () {\n    function ReusedProgramStrategy(originalProgram, originalHost, options, shimExtensionPrefixes) {\n      this.originalProgram = originalProgram;\n      this.originalHost = originalHost;\n      this.options = options;\n      this.shimExtensionPrefixes = shimExtensionPrefixes;\n      /**\n       * A map of source file paths to replacement `ts.SourceFile`s for those paths.\n       *\n       * Effectively, this tracks the delta between the user's program (represented by the\n       * `originalHost`) and the template type-checking program being managed.\n       */\n\n      this.sfMap = new Map();\n      this.program = this.originalProgram;\n      this.supportsInlineOperations = true;\n    }\n\n    ReusedProgramStrategy.prototype.getProgram = function () {\n      return this.program;\n    };\n\n    ReusedProgramStrategy.prototype.updateFiles = function (contents, updateMode) {\n      var e_1, _a;\n\n      if (contents.size === 0) {\n        // No changes have been requested. Is it safe to skip updating entirely?\n        // If UpdateMode is Incremental, then yes. If UpdateMode is Complete, then it's safe to skip\n        // only if there are no active changes already (that would be cleared by the update).\n        if (updateMode !== api_1.UpdateMode.Complete || this.sfMap.size === 0) {\n          // No changes would be made to the `ts.Program` anyway, so it's safe to do nothing here.\n          return;\n        }\n      }\n\n      if (updateMode === api_1.UpdateMode.Complete) {\n        this.sfMap.clear();\n      }\n\n      try {\n        for (var _b = tslib_1.__values(contents.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var _d = tslib_1.__read(_c.value, 2),\n              filePath = _d[0],\n              text = _d[1];\n\n          this.sfMap.set(filePath, ts.createSourceFile(filePath, text, ts.ScriptTarget.Latest, true));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var host = new host_1.TypeCheckProgramHost(this.sfMap, this.originalProgram, this.originalHost, this.shimExtensionPrefixes);\n      var oldProgram = this.program; // Retag the old program's `ts.SourceFile`s with shim tags, to allow TypeScript to reuse the\n      // most data.\n\n      shims_1.retagAllTsFiles(oldProgram);\n      this.program = ts.createProgram({\n        host: host,\n        rootNames: this.program.getRootFileNames(),\n        options: this.options,\n        oldProgram: oldProgram\n      });\n      host.postProgramCreationCleanup(); // And untag them afterwards. We explicitly untag both programs here, because the oldProgram\n      // may still be used for emit and needs to not contain tags.\n\n      shims_1.untagAllTsFiles(this.program);\n      shims_1.untagAllTsFiles(oldProgram);\n    };\n\n    ReusedProgramStrategy.prototype.shimPathForComponent = function (node) {\n      return shim_1.TypeCheckShimGenerator.shimFor(file_system_1.absoluteFromSourceFile(node.getSourceFile()));\n    };\n\n    return ReusedProgramStrategy;\n  }();\n\n  exports.ReusedProgramStrategy = ReusedProgramStrategy;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/augmented_program.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAEH,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,6CAAA,CAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,uCAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,+CAAA,CAAA;;AAEA,MAAA,MAAA,GAAA,OAAA,CAAA,oDAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,oDAAA,CAAA;AAEA;;;AAGG;;;AACH,MAAA,qBAAA;AAAA;AAAA,cAAA;AAWE,aAAA,qBAAA,CACY,eADZ,EACiD,YADjD,EAEY,OAFZ,EAEiD,qBAFjD,EAEgF;AADpE,WAAA,eAAA,GAAA,eAAA;AAAqC,WAAA,YAAA,GAAA,YAAA;AACrC,WAAA,OAAA,GAAA,OAAA;AAAqC,WAAA,qBAAA,GAAA,qBAAA;AAZjD;;;;;AAKG;;AACK,WAAA,KAAA,GAAQ,IAAI,GAAJ,EAAR;AAEA,WAAA,OAAA,GAAsB,KAAK,eAA3B;AAMC,WAAA,wBAAA,GAA2B,IAA3B;AAF2E;;AAIpF,IAAA,qBAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;AACE,aAAO,KAAK,OAAZ;AACD,KAFD;;AAIA,IAAA,qBAAA,CAAA,SAAA,CAAA,WAAA,GAAA,UAAY,QAAZ,EAAmD,UAAnD,EAAyE;;;AACvE,UAAI,QAAQ,CAAC,IAAT,KAAkB,CAAtB,EAAyB;AACvB;AACA;AACA;AAEA,YAAI,UAAU,KAAK,KAAA,CAAA,UAAA,CAAW,QAA1B,IAAsC,KAAK,KAAL,CAAW,IAAX,KAAoB,CAA9D,EAAiE;AAC/D;AACA;AACD;AACF;;AAED,UAAI,UAAU,KAAK,KAAA,CAAA,UAAA,CAAW,QAA9B,EAAwC;AACtC,aAAK,KAAL,CAAW,KAAX;AACD;;;AAED,aAA+B,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,QAAQ,CAAC,OAAT,EAAA,CAAA,EAAkB,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjD,EAAiD,CAAA,EAAA,CAAA,IAAjD,EAAiD,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjD,EAAmD;AAAxC,cAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAAA,EAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,cAAC,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAT;AAAA,cAAW,IAAI,GAAA,EAAA,CAAA,CAAA,CAAf;;AACT,eAAK,KAAL,CAAW,GAAX,CAAe,QAAf,EAAyB,EAAE,CAAC,gBAAH,CAAoB,QAApB,EAA8B,IAA9B,EAAoC,EAAE,CAAC,YAAH,CAAgB,MAApD,EAA4D,IAA5D,CAAzB;AACD;;;;;;;;;;;;;AAED,UAAM,IAAI,GAAG,IAAI,MAAA,CAAA,oBAAJ,CACT,KAAK,KADI,EACG,KAAK,eADR,EACyB,KAAK,YAD9B,EAC4C,KAAK,qBADjD,CAAb;AAEA,UAAM,UAAU,GAAG,KAAK,OAAxB,CAtBuE,CAwBvE;AACA;;AACA,MAAA,OAAA,CAAA,eAAA,CAAgB,UAAhB;AAEA,WAAK,OAAL,GAAe,EAAE,CAAC,aAAH,CAAiB;AAC9B,QAAA,IAAI,EAAA,IAD0B;AAE9B,QAAA,SAAS,EAAE,KAAK,OAAL,CAAa,gBAAb,EAFmB;AAG9B,QAAA,OAAO,EAAE,KAAK,OAHgB;AAI9B,QAAA,UAAU,EAAA;AAJoB,OAAjB,CAAf;AAMA,MAAA,IAAI,CAAC,0BAAL,GAlCuE,CAoCvE;AACA;;AACA,MAAA,OAAA,CAAA,eAAA,CAAgB,KAAK,OAArB;AACA,MAAA,OAAA,CAAA,eAAA,CAAgB,UAAhB;AACD,KAxCD;;AA0CA,IAAA,qBAAA,CAAA,SAAA,CAAA,oBAAA,GAAA,UAAqB,IAArB,EAA8C;AAC5C,aAAO,MAAA,CAAA,sBAAA,CAAuB,OAAvB,CAA+B,aAAA,CAAA,sBAAA,CAAuB,IAAI,CAAC,aAAL,EAAvB,CAA/B,CAAP;AACD,KAFD;;AAGF,WAAA,qBAAA;AAAC,GAlED,EAAA;;AAAa,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {absoluteFromSourceFile, AbsoluteFsPath} from '../../file_system';\nimport {retagAllTsFiles, untagAllTsFiles} from '../../shims';\nimport {TypeCheckingProgramStrategy, UpdateMode} from '../api';\n\nimport {TypeCheckProgramHost} from './host';\nimport {TypeCheckShimGenerator} from './shim';\n\n/**\n * Implements a template type-checking program using `ts.createProgram` and TypeScript's program\n * reuse functionality.\n */\nexport class ReusedProgramStrategy implements TypeCheckingProgramStrategy {\n  /**\n   * A map of source file paths to replacement `ts.SourceFile`s for those paths.\n   *\n   * Effectively, this tracks the delta between the user's program (represented by the\n   * `originalHost`) and the template type-checking program being managed.\n   */\n  private sfMap = new Map<string, ts.SourceFile>();\n\n  private program: ts.Program = this.originalProgram;\n\n  constructor(\n      private originalProgram: ts.Program, private originalHost: ts.CompilerHost,\n      private options: ts.CompilerOptions, private shimExtensionPrefixes: string[]) {}\n\n  readonly supportsInlineOperations = true;\n\n  getProgram(): ts.Program {\n    return this.program;\n  }\n\n  updateFiles(contents: Map<AbsoluteFsPath, string>, updateMode: UpdateMode): void {\n    if (contents.size === 0) {\n      // No changes have been requested. Is it safe to skip updating entirely?\n      // If UpdateMode is Incremental, then yes. If UpdateMode is Complete, then it's safe to skip\n      // only if there are no active changes already (that would be cleared by the update).\n\n      if (updateMode !== UpdateMode.Complete || this.sfMap.size === 0) {\n        // No changes would be made to the `ts.Program` anyway, so it's safe to do nothing here.\n        return;\n      }\n    }\n\n    if (updateMode === UpdateMode.Complete) {\n      this.sfMap.clear();\n    }\n\n    for (const [filePath, text] of contents.entries()) {\n      this.sfMap.set(filePath, ts.createSourceFile(filePath, text, ts.ScriptTarget.Latest, true));\n    }\n\n    const host = new TypeCheckProgramHost(\n        this.sfMap, this.originalProgram, this.originalHost, this.shimExtensionPrefixes);\n    const oldProgram = this.program;\n\n    // Retag the old program's `ts.SourceFile`s with shim tags, to allow TypeScript to reuse the\n    // most data.\n    retagAllTsFiles(oldProgram);\n\n    this.program = ts.createProgram({\n      host,\n      rootNames: this.program.getRootFileNames(),\n      options: this.options,\n      oldProgram,\n    });\n    host.postProgramCreationCleanup();\n\n    // And untag them afterwards. We explicitly untag both programs here, because the oldProgram\n    // may still be used for emit and needs to not contain tags.\n    untagAllTsFiles(this.program);\n    untagAllTsFiles(oldProgram);\n  }\n\n  shimPathForComponent(node: ts.ClassDeclaration): AbsoluteFsPath {\n    return TypeCheckShimGenerator.shimFor(absoluteFromSourceFile(node.getSourceFile()));\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}