{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/packages/entry_point_manifest\", [\"require\", \"exports\", \"tslib\", \"crypto\", \"@angular/compiler-cli/ngcc/src/packages/build_marker\", \"@angular/compiler-cli/ngcc/src/packages/entry_point\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.InvalidatingEntryPointManifest = exports.EntryPointManifest = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var crypto_1 = require(\"crypto\");\n\n  var build_marker_1 = require(\"@angular/compiler-cli/ngcc/src/packages/build_marker\");\n\n  var entry_point_1 = require(\"@angular/compiler-cli/ngcc/src/packages/entry_point\");\n  /**\n   * Manages reading and writing a manifest file that contains a list of all the entry-points that\n   * were found below a given basePath.\n   *\n   * This is a super-set of the entry-points that are actually processed for a given run of ngcc,\n   * since some may already be processed, or excluded if they do not have the required format.\n   */\n\n\n  var EntryPointManifest =\n  /** @class */\n  function () {\n    function EntryPointManifest(fs, config, logger) {\n      this.fs = fs;\n      this.config = config;\n      this.logger = logger;\n    }\n    /**\n     * Try to get the entry-point info from a manifest file for the given `basePath` if it exists and\n     * is not out of date.\n     *\n     * Reasons for the manifest to be out of date are:\n     *\n     * * the file does not exist\n     * * the ngcc version has changed\n     * * the package lock-file (i.e. yarn.lock or package-lock.json) has changed\n     * * the project configuration has changed\n     * * one or more entry-points in the manifest are not valid\n     *\n     * @param basePath The path that would contain the entry-points and the manifest file.\n     * @returns an array of entry-point information for all entry-points found below the given\n     * `basePath` or `null` if the manifest was out of date.\n     */\n\n\n    EntryPointManifest.prototype.readEntryPointsUsingManifest = function (basePath) {\n      var e_1, _a;\n\n      try {\n        if (this.fs.basename(basePath) !== 'node_modules') {\n          return null;\n        }\n\n        var manifestPath = this.getEntryPointManifestPath(basePath);\n\n        if (!this.fs.exists(manifestPath)) {\n          return null;\n        }\n\n        var computedLockFileHash = this.computeLockFileHash(basePath);\n\n        if (computedLockFileHash === null) {\n          return null;\n        }\n\n        var _b = JSON.parse(this.fs.readFile(manifestPath)),\n            ngccVersion = _b.ngccVersion,\n            configFileHash = _b.configFileHash,\n            lockFileHash = _b.lockFileHash,\n            entryPointPaths = _b.entryPointPaths;\n\n        if (ngccVersion !== build_marker_1.NGCC_VERSION || configFileHash !== this.config.hash || lockFileHash !== computedLockFileHash) {\n          return null;\n        }\n\n        this.logger.debug(\"Entry-point manifest found for \" + basePath + \" so loading entry-point information directly.\");\n        var startTime = Date.now();\n        var entryPoints = [];\n\n        try {\n          for (var entryPointPaths_1 = tslib_1.__values(entryPointPaths), entryPointPaths_1_1 = entryPointPaths_1.next(); !entryPointPaths_1_1.done; entryPointPaths_1_1 = entryPointPaths_1.next()) {\n            var _c = tslib_1.__read(entryPointPaths_1_1.value, 5),\n                packagePath = _c[0],\n                entryPointPath = _c[1],\n                _d = _c[2],\n                dependencyPaths = _d === void 0 ? [] : _d,\n                _e = _c[3],\n                missingPaths = _e === void 0 ? [] : _e,\n                _f = _c[4],\n                deepImportPaths = _f === void 0 ? [] : _f;\n\n            var result = entry_point_1.getEntryPointInfo(this.fs, this.config, this.logger, this.fs.resolve(basePath, packagePath), this.fs.resolve(basePath, entryPointPath));\n\n            if (!entry_point_1.isEntryPoint(result)) {\n              throw new Error(\"The entry-point manifest at \" + manifestPath + \" contained an invalid pair of package paths: [\" + packagePath + \", \" + entryPointPath + \"]\");\n            } else {\n              entryPoints.push({\n                entryPoint: result,\n                depInfo: {\n                  dependencies: new Set(dependencyPaths),\n                  missing: new Set(missingPaths),\n                  deepImports: new Set(deepImportPaths)\n                }\n              });\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (entryPointPaths_1_1 && !entryPointPaths_1_1.done && (_a = entryPointPaths_1.return)) _a.call(entryPointPaths_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        var duration = Math.round((Date.now() - startTime) / 100) / 10;\n        this.logger.debug(\"Reading entry-points using the manifest entries took \" + duration + \"s.\");\n        return entryPoints;\n      } catch (e) {\n        this.logger.warn(\"Unable to read the entry-point manifest for \" + basePath + \":\\n\", e.stack || e.toString());\n        return null;\n      }\n    };\n    /**\n     * Write a manifest file at the given `basePath`.\n     *\n     * The manifest includes the current ngcc version and hashes of the package lock-file and current\n     * project config. These will be used to check whether the manifest file is out of date. See\n     * `readEntryPointsUsingManifest()`.\n     *\n     * @param basePath The path where the manifest file is to be written.\n     * @param entryPoints A collection of entry-points to record in the manifest.\n     */\n\n\n    EntryPointManifest.prototype.writeEntryPointManifest = function (basePath, entryPoints) {\n      var _this = this;\n\n      if (this.fs.basename(basePath) !== 'node_modules') {\n        return;\n      }\n\n      var lockFileHash = this.computeLockFileHash(basePath);\n\n      if (lockFileHash === null) {\n        return;\n      }\n\n      var manifest = {\n        ngccVersion: build_marker_1.NGCC_VERSION,\n        configFileHash: this.config.hash,\n        lockFileHash: lockFileHash,\n        entryPointPaths: entryPoints.map(function (e) {\n          var entryPointPaths = [_this.fs.relative(basePath, e.entryPoint.packagePath), _this.fs.relative(basePath, e.entryPoint.path)]; // Only add depInfo arrays if needed.\n\n          if (e.depInfo.dependencies.size > 0) {\n            entryPointPaths[2] = Array.from(e.depInfo.dependencies);\n          } else if (e.depInfo.missing.size > 0 || e.depInfo.deepImports.size > 0) {\n            entryPointPaths[2] = [];\n          }\n\n          if (e.depInfo.missing.size > 0) {\n            entryPointPaths[3] = Array.from(e.depInfo.missing);\n          } else if (e.depInfo.deepImports.size > 0) {\n            entryPointPaths[3] = [];\n          }\n\n          if (e.depInfo.deepImports.size > 0) {\n            entryPointPaths[4] = Array.from(e.depInfo.deepImports);\n          }\n\n          return entryPointPaths;\n        })\n      };\n      this.fs.writeFile(this.getEntryPointManifestPath(basePath), JSON.stringify(manifest));\n    };\n\n    EntryPointManifest.prototype.getEntryPointManifestPath = function (basePath) {\n      return this.fs.resolve(basePath, '__ngcc_entry_points__.json');\n    };\n\n    EntryPointManifest.prototype.computeLockFileHash = function (basePath) {\n      var e_2, _a;\n\n      var directory = this.fs.dirname(basePath);\n\n      try {\n        for (var _b = tslib_1.__values(['yarn.lock', 'package-lock.json']), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var lockFileName = _c.value;\n          var lockFilePath = this.fs.resolve(directory, lockFileName);\n\n          if (this.fs.exists(lockFilePath)) {\n            var lockFileContents = this.fs.readFile(lockFilePath);\n            return crypto_1.createHash('md5').update(lockFileContents).digest('hex');\n          }\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      return null;\n    };\n\n    return EntryPointManifest;\n  }();\n\n  exports.EntryPointManifest = EntryPointManifest;\n  /**\n   * A specialized implementation of the `EntryPointManifest` that can be used to invalidate the\n   * current manifest file.\n   *\n   * It always returns `null` from the `readEntryPointsUsingManifest()` method, which forces a new\n   * manifest to be created, which will overwrite the current file when `writeEntryPointManifest()`\n   * is called.\n   */\n\n  var InvalidatingEntryPointManifest =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(InvalidatingEntryPointManifest, _super);\n\n    function InvalidatingEntryPointManifest() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    InvalidatingEntryPointManifest.prototype.readEntryPointsUsingManifest = function (_basePath) {\n      return null;\n    };\n\n    return InvalidatingEntryPointManifest;\n  }(EntryPointManifest);\n\n  exports.InvalidatingEntryPointManifest = InvalidatingEntryPointManifest;\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/packages/entry_point_manifest.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;;;;;;AAMG;;;AACH,MAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAMA,MAAA,cAAA,GAAA,OAAA,CAAA,sDAAA,CAAA;;AAEA,MAAA,aAAA,GAAA,OAAA,CAAA,qDAAA,CAAA;AAEA;;;;;;AAMG;;;AACH,MAAA,kBAAA;AAAA;AAAA,cAAA;AACE,aAAA,kBAAA,CAAoB,EAApB,EAA4C,MAA5C,EAA+E,MAA/E,EAA6F;AAAzE,WAAA,EAAA,GAAA,EAAA;AAAwB,WAAA,MAAA,GAAA,MAAA;AAAmC,WAAA,MAAA,GAAA,MAAA;AAAkB;AAEjG;;;;;;;;;;;;;;;AAeG;;;AACH,IAAA,kBAAA,CAAA,SAAA,CAAA,4BAAA,GAAA,UAA6B,QAA7B,EAAqD;;;AACnD,UAAI;AACF,YAAI,KAAK,EAAL,CAAQ,QAAR,CAAiB,QAAjB,MAA+B,cAAnC,EAAmD;AACjD,iBAAO,IAAP;AACD;;AAED,YAAM,YAAY,GAAG,KAAK,yBAAL,CAA+B,QAA/B,CAArB;;AACA,YAAI,CAAC,KAAK,EAAL,CAAQ,MAAR,CAAe,YAAf,CAAL,EAAmC;AACjC,iBAAO,IAAP;AACD;;AAED,YAAM,oBAAoB,GAAG,KAAK,mBAAL,CAAyB,QAAzB,CAA7B;;AACA,YAAI,oBAAoB,KAAK,IAA7B,EAAmC;AACjC,iBAAO,IAAP;AACD;;AAEK,YAAA,EAAA,GACF,IAAI,CAAC,KAAL,CAAW,KAAK,EAAL,CAAQ,QAAR,CAAiB,YAAjB,CAAX,CADE;AAAA,YAAC,WAAW,GAAA,EAAA,CAAA,WAAZ;AAAA,YAAc,cAAc,GAAA,EAAA,CAAA,cAA5B;AAAA,YAA8B,YAAY,GAAA,EAAA,CAAA,YAA1C;AAAA,YAA4C,eAAe,GAAA,EAAA,CAAA,eAA3D;;AAEN,YAAI,WAAW,KAAK,cAAA,CAAA,YAAhB,IAAgC,cAAc,KAAK,KAAK,MAAL,CAAY,IAA/D,IACA,YAAY,KAAK,oBADrB,EAC2C;AACzC,iBAAO,IAAP;AACD;;AAED,aAAK,MAAL,CAAY,KAAZ,CAAkB,oCACd,QADc,GACN,+CADZ;AAEA,YAAM,SAAS,GAAG,IAAI,CAAC,GAAL,EAAlB;AAEA,YAAM,WAAW,GAAiC,EAAlD;;;AACA,eAEgE,IAAA,iBAAA,GAAA,OAAA,CAAA,QAAA,CAAA,eAAA,CAAA,EAAe,mBAAA,GAAA,iBAAA,CAAA,IAAA,EAF/E,EAE+E,CAAA,mBAAA,CAAA,IAF/E,EAE+E,mBAAA,GAAA,iBAAA,CAAA,IAAA,EAF/E,EAEiF;AADxE,gBAAA,EAAA,GAAA,OAAA,CAAA,MAAA,CAAA,mBAAA,CAAA,KAAA,EAAA,CAAA,CAAA;AAAA,gBAAC,WAAW,GAAA,EAAA,CAAA,CAAA,CAAZ;AAAA,gBAAc,cAAc,GAAA,EAAA,CAAA,CAAA,CAA5B;AAAA,gBAA8B,EAAA,GAAA,EAAA,CAAA,CAAA,CAA9B;AAAA,gBAA8B,eAAe,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAAlD;AAAA,gBAAoD,EAAA,GAAA,EAAA,CAAA,CAAA,CAApD;AAAA,gBAAoD,YAAY,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAArE;AAAA,gBAC8B,EAAA,GAAA,EAAA,CAAA,CAAA,CAD9B;AAAA,gBAC8B,eAAe,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EADlD;;AAEP,gBAAM,MAAM,GAAG,aAAA,CAAA,iBAAA,CACX,KAAK,EADM,EACF,KAAK,MADH,EACW,KAAK,MADhB,EACwB,KAAK,EAAL,CAAQ,OAAR,CAAgB,QAAhB,EAA0B,WAA1B,CADxB,EAEX,KAAK,EAAL,CAAQ,OAAR,CAAgB,QAAhB,EAA0B,cAA1B,CAFW,CAAf;;AAGA,gBAAI,CAAC,aAAA,CAAA,YAAA,CAAa,MAAb,CAAL,EAA2B;AACzB,oBAAM,IAAI,KAAJ,CAAU,iCACZ,YADY,GACA,gDADA,GACiD,WADjD,GAC4D,IAD5D,GAEZ,cAFY,GAEE,GAFZ,CAAN;AAGD,aAJD,MAIO;AACL,cAAA,WAAW,CAAC,IAAZ,CAAiB;AACf,gBAAA,UAAU,EAAE,MADG;AAEf,gBAAA,OAAO,EAAE;AACP,kBAAA,YAAY,EAAE,IAAI,GAAJ,CAAQ,eAAR,CADP;AAEP,kBAAA,OAAO,EAAE,IAAI,GAAJ,CAAQ,YAAR,CAFF;AAGP,kBAAA,WAAW,EAAE,IAAI,GAAJ,CAAQ,eAAR;AAHN;AAFM,eAAjB;AAQD;AACF;;;;;;;;;;;;;AACD,YAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,IAAI,CAAC,GAAL,KAAa,SAAd,IAA2B,GAAtC,IAA6C,EAA9D;AACA,aAAK,MAAL,CAAY,KAAZ,CAAkB,0DAAwD,QAAxD,GAAgE,IAAlF;AACA,eAAO,WAAP;AACD,OAnDD,CAmDE,OAAO,CAAP,EAAU;AACV,aAAK,MAAL,CAAY,IAAZ,CACI,iDAA+C,QAA/C,GAAuD,KAD3D,EACkE,CAAC,CAAC,KAAF,IAAW,CAAC,CAAC,QAAF,EAD7E;AAEA,eAAO,IAAP;AACD;AACF,KAzDD;AA2DA;;;;;;;;;AASG;;;AACH,IAAA,kBAAA,CAAA,SAAA,CAAA,uBAAA,GAAA,UAAwB,QAAxB,EAAkD,WAAlD,EAA2F;AAA3F,UAAA,KAAA,GAAA,IAAA;;AAEE,UAAI,KAAK,EAAL,CAAQ,QAAR,CAAiB,QAAjB,MAA+B,cAAnC,EAAmD;AACjD;AACD;;AAED,UAAM,YAAY,GAAG,KAAK,mBAAL,CAAyB,QAAzB,CAArB;;AACA,UAAI,YAAY,KAAK,IAArB,EAA2B;AACzB;AACD;;AACD,UAAM,QAAQ,GAA2B;AACvC,QAAA,WAAW,EAAE,cAAA,CAAA,YAD0B;AAEvC,QAAA,cAAc,EAAE,KAAK,MAAL,CAAY,IAFW;AAGvC,QAAA,YAAY,EAAE,YAHyB;AAIvC,QAAA,eAAe,EAAE,WAAW,CAAC,GAAZ,CAAgB,UAAA,CAAA,EAAC;AAChC,cAAM,eAAe,GAAoB,CACvC,KAAI,CAAC,EAAL,CAAQ,QAAR,CAAiB,QAAjB,EAA2B,CAAC,CAAC,UAAF,CAAa,WAAxC,CADuC,EAEvC,KAAI,CAAC,EAAL,CAAQ,QAAR,CAAiB,QAAjB,EAA2B,CAAC,CAAC,UAAF,CAAa,IAAxC,CAFuC,CAAzC,CADgC,CAKhC;;AACA,cAAI,CAAC,CAAC,OAAF,CAAU,YAAV,CAAuB,IAAvB,GAA8B,CAAlC,EAAqC;AACnC,YAAA,eAAe,CAAC,CAAD,CAAf,GAAqB,KAAK,CAAC,IAAN,CAAW,CAAC,CAAC,OAAF,CAAU,YAArB,CAArB;AACD,WAFD,MAEO,IAAI,CAAC,CAAC,OAAF,CAAU,OAAV,CAAkB,IAAlB,GAAyB,CAAzB,IAA8B,CAAC,CAAC,OAAF,CAAU,WAAV,CAAsB,IAAtB,GAA6B,CAA/D,EAAkE;AACvE,YAAA,eAAe,CAAC,CAAD,CAAf,GAAqB,EAArB;AACD;;AACD,cAAI,CAAC,CAAC,OAAF,CAAU,OAAV,CAAkB,IAAlB,GAAyB,CAA7B,EAAgC;AAC9B,YAAA,eAAe,CAAC,CAAD,CAAf,GAAqB,KAAK,CAAC,IAAN,CAAW,CAAC,CAAC,OAAF,CAAU,OAArB,CAArB;AACD,WAFD,MAEO,IAAI,CAAC,CAAC,OAAF,CAAU,WAAV,CAAsB,IAAtB,GAA6B,CAAjC,EAAoC;AACzC,YAAA,eAAe,CAAC,CAAD,CAAf,GAAqB,EAArB;AACD;;AACD,cAAI,CAAC,CAAC,OAAF,CAAU,WAAV,CAAsB,IAAtB,GAA6B,CAAjC,EAAoC;AAClC,YAAA,eAAe,CAAC,CAAD,CAAf,GAAqB,KAAK,CAAC,IAAN,CAAW,CAAC,CAAC,OAAF,CAAU,WAArB,CAArB;AACD;;AACD,iBAAO,eAAP;AACD,SApBgB;AAJsB,OAAzC;AA0BA,WAAK,EAAL,CAAQ,SAAR,CAAkB,KAAK,yBAAL,CAA+B,QAA/B,CAAlB,EAA4D,IAAI,CAAC,SAAL,CAAe,QAAf,CAA5D;AACD,KArCD;;AAuCQ,IAAA,kBAAA,CAAA,SAAA,CAAA,yBAAA,GAAR,UAAkC,QAAlC,EAA0D;AACxD,aAAO,KAAK,EAAL,CAAQ,OAAR,CAAgB,QAAhB,EAA0B,4BAA1B,CAAP;AACD,KAFO;;AAIA,IAAA,kBAAA,CAAA,SAAA,CAAA,mBAAA,GAAR,UAA4B,QAA5B,EAAoD;;;AAClD,UAAM,SAAS,GAAG,KAAK,EAAL,CAAQ,OAAR,CAAgB,QAAhB,CAAlB;;;AACA,aAA2B,IAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,CAAC,WAAD,EAAc,mBAAd,CAAA,CAAA,EAAkC,EAAA,GAAA,EAAA,CAAA,IAAA,EAA7D,EAA6D,CAAA,EAAA,CAAA,IAA7D,EAA6D,EAAA,GAAA,EAAA,CAAA,IAAA,EAA7D,EAA+D;AAA1D,cAAM,YAAY,GAAA,EAAA,CAAA,KAAlB;AACH,cAAM,YAAY,GAAG,KAAK,EAAL,CAAQ,OAAR,CAAgB,SAAhB,EAA2B,YAA3B,CAArB;;AACA,cAAI,KAAK,EAAL,CAAQ,MAAR,CAAe,YAAf,CAAJ,EAAkC;AAChC,gBAAM,gBAAgB,GAAG,KAAK,EAAL,CAAQ,QAAR,CAAiB,YAAjB,CAAzB;AACA,mBAAO,QAAA,CAAA,UAAA,CAAW,KAAX,EAAkB,MAAlB,CAAyB,gBAAzB,EAA2C,MAA3C,CAAkD,KAAlD,CAAP;AACD;AACF;;;;;;;;;;;;;AACD,aAAO,IAAP;AACD,KAVO;;AAWV,WAAA,kBAAA;AAAC,GA9ID,EAAA;;AAAa,EAAA,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAgJb;;;;;;;AAOG;;AACH,MAAA,8BAAA;AAAA;AAAA,YAAA,MAAA,EAAA;AAAoD,IAAA,OAAA,CAAA,SAAA,CAAA,8BAAA,EAAA,MAAA;;AAApD,aAAA,8BAAA,GAAA;;AAIC;;AAHC,IAAA,8BAAA,CAAA,SAAA,CAAA,4BAAA,GAAA,UAA6B,SAA7B,EAAsD;AACpD,aAAO,IAAP;AACD,KAFD;;AAGF,WAAA,8BAAA;AAAC,GAJD,CAAoD,kBAApD,CAAA;;AAAa,EAAA,OAAA,CAAA,8BAAA,GAAA,8BAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {createHash} from 'crypto';\n\nimport {AbsoluteFsPath, FileSystem, PathSegment} from '../../../src/ngtsc/file_system';\nimport {Logger} from '../../../src/ngtsc/logging';\nimport {EntryPointWithDependencies} from '../dependencies/dependency_host';\n\nimport {NGCC_VERSION} from './build_marker';\nimport {NgccConfiguration} from './configuration';\nimport {getEntryPointInfo, isEntryPoint, PackageJsonFormatProperties} from './entry_point';\n\n/**\n * Manages reading and writing a manifest file that contains a list of all the entry-points that\n * were found below a given basePath.\n *\n * This is a super-set of the entry-points that are actually processed for a given run of ngcc,\n * since some may already be processed, or excluded if they do not have the required format.\n */\nexport class EntryPointManifest {\n  constructor(private fs: FileSystem, private config: NgccConfiguration, private logger: Logger) {}\n\n  /**\n   * Try to get the entry-point info from a manifest file for the given `basePath` if it exists and\n   * is not out of date.\n   *\n   * Reasons for the manifest to be out of date are:\n   *\n   * * the file does not exist\n   * * the ngcc version has changed\n   * * the package lock-file (i.e. yarn.lock or package-lock.json) has changed\n   * * the project configuration has changed\n   * * one or more entry-points in the manifest are not valid\n   *\n   * @param basePath The path that would contain the entry-points and the manifest file.\n   * @returns an array of entry-point information for all entry-points found below the given\n   * `basePath` or `null` if the manifest was out of date.\n   */\n  readEntryPointsUsingManifest(basePath: AbsoluteFsPath): EntryPointWithDependencies[]|null {\n    try {\n      if (this.fs.basename(basePath) !== 'node_modules') {\n        return null;\n      }\n\n      const manifestPath = this.getEntryPointManifestPath(basePath);\n      if (!this.fs.exists(manifestPath)) {\n        return null;\n      }\n\n      const computedLockFileHash = this.computeLockFileHash(basePath);\n      if (computedLockFileHash === null) {\n        return null;\n      }\n\n      const {ngccVersion, configFileHash, lockFileHash, entryPointPaths} =\n          JSON.parse(this.fs.readFile(manifestPath)) as EntryPointManifestFile;\n      if (ngccVersion !== NGCC_VERSION || configFileHash !== this.config.hash ||\n          lockFileHash !== computedLockFileHash) {\n        return null;\n      }\n\n      this.logger.debug(`Entry-point manifest found for ${\n          basePath} so loading entry-point information directly.`);\n      const startTime = Date.now();\n\n      const entryPoints: EntryPointWithDependencies[] = [];\n      for (const\n               [packagePath, entryPointPath, dependencyPaths = [], missingPaths = [],\n                                             deepImportPaths = []] of entryPointPaths) {\n        const result = getEntryPointInfo(\n            this.fs, this.config, this.logger, this.fs.resolve(basePath, packagePath),\n            this.fs.resolve(basePath, entryPointPath));\n        if (!isEntryPoint(result)) {\n          throw new Error(`The entry-point manifest at ${\n              manifestPath} contained an invalid pair of package paths: [${packagePath}, ${\n              entryPointPath}]`);\n        } else {\n          entryPoints.push({\n            entryPoint: result,\n            depInfo: {\n              dependencies: new Set(dependencyPaths),\n              missing: new Set(missingPaths),\n              deepImports: new Set(deepImportPaths),\n            }\n          });\n        }\n      }\n      const duration = Math.round((Date.now() - startTime) / 100) / 10;\n      this.logger.debug(`Reading entry-points using the manifest entries took ${duration}s.`);\n      return entryPoints;\n    } catch (e) {\n      this.logger.warn(\n          `Unable to read the entry-point manifest for ${basePath}:\\n`, e.stack || e.toString());\n      return null;\n    }\n  }\n\n  /**\n   * Write a manifest file at the given `basePath`.\n   *\n   * The manifest includes the current ngcc version and hashes of the package lock-file and current\n   * project config. These will be used to check whether the manifest file is out of date. See\n   * `readEntryPointsUsingManifest()`.\n   *\n   * @param basePath The path where the manifest file is to be written.\n   * @param entryPoints A collection of entry-points to record in the manifest.\n   */\n  writeEntryPointManifest(basePath: AbsoluteFsPath, entryPoints: EntryPointWithDependencies[]):\n      void {\n    if (this.fs.basename(basePath) !== 'node_modules') {\n      return;\n    }\n\n    const lockFileHash = this.computeLockFileHash(basePath);\n    if (lockFileHash === null) {\n      return;\n    }\n    const manifest: EntryPointManifestFile = {\n      ngccVersion: NGCC_VERSION,\n      configFileHash: this.config.hash,\n      lockFileHash: lockFileHash,\n      entryPointPaths: entryPoints.map(e => {\n        const entryPointPaths: EntryPointPaths = [\n          this.fs.relative(basePath, e.entryPoint.packagePath),\n          this.fs.relative(basePath, e.entryPoint.path),\n        ];\n        // Only add depInfo arrays if needed.\n        if (e.depInfo.dependencies.size > 0) {\n          entryPointPaths[2] = Array.from(e.depInfo.dependencies);\n        } else if (e.depInfo.missing.size > 0 || e.depInfo.deepImports.size > 0) {\n          entryPointPaths[2] = [];\n        }\n        if (e.depInfo.missing.size > 0) {\n          entryPointPaths[3] = Array.from(e.depInfo.missing);\n        } else if (e.depInfo.deepImports.size > 0) {\n          entryPointPaths[3] = [];\n        }\n        if (e.depInfo.deepImports.size > 0) {\n          entryPointPaths[4] = Array.from(e.depInfo.deepImports);\n        }\n        return entryPointPaths;\n      }),\n    };\n    this.fs.writeFile(this.getEntryPointManifestPath(basePath), JSON.stringify(manifest));\n  }\n\n  private getEntryPointManifestPath(basePath: AbsoluteFsPath) {\n    return this.fs.resolve(basePath, '__ngcc_entry_points__.json');\n  }\n\n  private computeLockFileHash(basePath: AbsoluteFsPath): string|null {\n    const directory = this.fs.dirname(basePath);\n    for (const lockFileName of ['yarn.lock', 'package-lock.json']) {\n      const lockFilePath = this.fs.resolve(directory, lockFileName);\n      if (this.fs.exists(lockFilePath)) {\n        const lockFileContents = this.fs.readFile(lockFilePath);\n        return createHash('md5').update(lockFileContents).digest('hex');\n      }\n    }\n    return null;\n  }\n}\n\n/**\n * A specialized implementation of the `EntryPointManifest` that can be used to invalidate the\n * current manifest file.\n *\n * It always returns `null` from the `readEntryPointsUsingManifest()` method, which forces a new\n * manifest to be created, which will overwrite the current file when `writeEntryPointManifest()`\n * is called.\n */\nexport class InvalidatingEntryPointManifest extends EntryPointManifest {\n  readEntryPointsUsingManifest(_basePath: AbsoluteFsPath): EntryPointWithDependencies[]|null {\n    return null;\n  }\n}\n\nexport type EntryPointPaths = [\n  string,\n  string,\n  Array<AbsoluteFsPath>?,\n  Array<AbsoluteFsPath|PathSegment>?,\n  Array<AbsoluteFsPath>?,\n];\n\n/**\n * The JSON format of the manifest file that is written to disk.\n */\nexport interface EntryPointManifestFile {\n  ngccVersion: string;\n  configFileHash: string;\n  lockFileHash: string;\n  entryPointPaths: EntryPointPaths[];\n}\n\n\n/** The JSON format of the entrypoint properties. */\nexport type NewEntryPointPropertiesMap = {\n  [Property in PackageJsonFormatProperties as `${Property}_ivy_ngcc`]?: string;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}