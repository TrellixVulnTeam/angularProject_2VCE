{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/compiler_util/expression_converter\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/expression_parser/ast\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/parse_util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.BuiltinFunctionCall = exports.temporaryDeclaration = exports.convertUpdateArguments = exports.convertPropertyBinding = exports.BindingForm = exports.ConvertPropertyBindingResult = exports.convertPropertyBindingBuiltins = exports.convertActionBinding = exports.ConvertActionBindingResult = exports.EventHandlerVars = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var cdAst = require(\"@angular/compiler/src/expression_parser/ast\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var parse_util_1 = require(\"@angular/compiler/src/parse_util\");\n\n  var EventHandlerVars =\n  /** @class */\n  function () {\n    function EventHandlerVars() {}\n\n    EventHandlerVars.event = o.variable('$event');\n    return EventHandlerVars;\n  }();\n\n  exports.EventHandlerVars = EventHandlerVars;\n\n  var ConvertActionBindingResult =\n  /** @class */\n  function () {\n    function ConvertActionBindingResult(\n    /**\n     * Render2 compatible statements,\n     */\n    stmts,\n    /**\n     * Variable name used with render2 compatible statements.\n     */\n    allowDefault) {\n      this.stmts = stmts;\n      this.allowDefault = allowDefault;\n      /**\n       * This is bit of a hack. It converts statements which render2 expects to statements which are\n       * expected by render3.\n       *\n       * Example: `<div click=\"doSomething($event)\">` will generate:\n       *\n       * Render3:\n       * ```\n       * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n       * return pd_b;\n       * ```\n       *\n       * but render2 expects:\n       * ```\n       * return ctx.doSomething($event);\n       * ```\n       */\n      // TODO(misko): remove this hack once we no longer support ViewEngine.\n\n      this.render3Stmts = stmts.map(function (statement) {\n        if (statement instanceof o.DeclareVarStmt && statement.name == allowDefault.name && statement.value instanceof o.BinaryOperatorExpr) {\n          var lhs = statement.value.lhs;\n          return new o.ReturnStatement(lhs.value);\n        }\n\n        return statement;\n      });\n    }\n\n    return ConvertActionBindingResult;\n  }();\n\n  exports.ConvertActionBindingResult = ConvertActionBindingResult;\n  /**\n   * Converts the given expression AST into an executable output AST, assuming the expression is\n   * used in an action binding (e.g. an event handler).\n   */\n\n  function convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses, globals) {\n    if (!localResolver) {\n      localResolver = new DefaultLocalResolver(globals);\n    }\n\n    var actionWithoutBuiltins = convertPropertyBindingBuiltins({\n      createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {\n        // Note: no caching for literal arrays in actions.\n        return function (args) {\n          return o.literalArr(args);\n        };\n      },\n      createLiteralMapConverter: function createLiteralMapConverter(keys) {\n        // Note: no caching for literal maps in actions.\n        return function (values) {\n          var entries = keys.map(function (k, i) {\n            return {\n              key: k.key,\n              value: values[i],\n              quoted: k.quoted\n            };\n          });\n          return o.literalMap(entries);\n        };\n      },\n      createPipeConverter: function createPipeConverter(name) {\n        throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \" + name);\n      }\n    }, action);\n    var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);\n    var actionStmts = [];\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n    if (visitor.usesImplicitReceiver) {\n      localResolver.notifyImplicitReceiverUse();\n    }\n\n    var lastIndex = actionStmts.length - 1;\n    var preventDefaultVar = null;\n\n    if (lastIndex >= 0) {\n      var lastStatement = actionStmts[lastIndex];\n      var returnExpr = convertStmtIntoExpression(lastStatement);\n\n      if (returnExpr) {\n        // Note: We need to cast the result of the method call to dynamic,\n        // as it might be a void method!\n        preventDefaultVar = createPreventDefaultVar(bindingId);\n        actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false))).toDeclStmt(null, [o.StmtModifier.Final]);\n      }\n    }\n\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n  }\n\n  exports.convertActionBinding = convertActionBinding;\n\n  function convertPropertyBindingBuiltins(converterFactory, ast) {\n    return convertBuiltins(converterFactory, ast);\n  }\n\n  exports.convertPropertyBindingBuiltins = convertPropertyBindingBuiltins;\n\n  var ConvertPropertyBindingResult =\n  /** @class */\n  function () {\n    function ConvertPropertyBindingResult(stmts, currValExpr) {\n      this.stmts = stmts;\n      this.currValExpr = currValExpr;\n    }\n\n    return ConvertPropertyBindingResult;\n  }();\n\n  exports.ConvertPropertyBindingResult = ConvertPropertyBindingResult;\n  var BindingForm;\n\n  (function (BindingForm) {\n    // The general form of binding expression, supports all expressions.\n    BindingForm[BindingForm[\"General\"] = 0] = \"General\"; // Try to generate a simple binding (no temporaries or statements)\n    // otherwise generate a general binding\n\n    BindingForm[BindingForm[\"TrySimple\"] = 1] = \"TrySimple\"; // Inlines assignment of temporaries into the generated expression. The result may still\n    // have statements attached for declarations of temporary variables.\n    // This is the only relevant form for Ivy, the other forms are only used in ViewEngine.\n\n    BindingForm[BindingForm[\"Expression\"] = 2] = \"Expression\";\n  })(BindingForm = exports.BindingForm || (exports.BindingForm = {}));\n  /**\n   * Converts the given expression AST into an executable output AST, assuming the expression\n   * is used in property binding. The expression has to be preprocessed via\n   * `convertPropertyBindingBuiltins`.\n   */\n\n\n  function convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {\n    if (!localResolver) {\n      localResolver = new DefaultLocalResolver();\n    }\n\n    var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n    var outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n    var stmts = getStatementsFromVisitor(visitor, bindingId);\n\n    if (visitor.usesImplicitReceiver) {\n      localResolver.notifyImplicitReceiverUse();\n    }\n\n    if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\n      return new ConvertPropertyBindingResult([], outputExpr);\n    } else if (form === BindingForm.Expression) {\n      return new ConvertPropertyBindingResult(stmts, outputExpr);\n    }\n\n    var currValExpr = createCurrValueExpr(bindingId);\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Final]));\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\n  }\n\n  exports.convertPropertyBinding = convertPropertyBinding;\n  /**\n   * Given some expression, such as a binding or interpolation expression, and a context expression to\n   * look values up on, visit each facet of the given expression resolving values from the context\n   * expression such that a list of arguments can be derived from the found values that can be used as\n   * arguments to an external update instruction.\n   *\n   * @param localResolver The resolver to use to look up expressions by name appropriately\n   * @param contextVariableExpression The expression representing the context variable used to create\n   * the final argument expressions\n   * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n   * be resolved and what arguments list to build.\n   * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n   * arguments generated\n   * @returns An array of expressions that can be passed as arguments to instruction expressions like\n   * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n   */\n\n  function convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\n    var visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\n    var outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\n\n    if (visitor.usesImplicitReceiver) {\n      localResolver.notifyImplicitReceiverUse();\n    }\n\n    var stmts = getStatementsFromVisitor(visitor, bindingId); // Removing the first argument, because it was a length for ViewEngine, not Ivy.\n\n    var args = outputExpr.args.slice(1);\n\n    if (expressionWithArgumentsToExtract instanceof cdAst.Interpolation) {\n      // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n      // args returned to just the value, because we're going to pass it to a special instruction.\n      var strings = expressionWithArgumentsToExtract.strings;\n\n      if (args.length === 3 && strings[0] === '' && strings[1] === '') {\n        // Single argument interpolate instructions.\n        args = [args[1]];\n      } else if (args.length >= 19) {\n        // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n        // an array of arguments\n        args = [o.literalArr(args)];\n      }\n    }\n\n    return {\n      stmts: stmts,\n      args: args\n    };\n  }\n\n  exports.convertUpdateArguments = convertUpdateArguments;\n\n  function getStatementsFromVisitor(visitor, bindingId) {\n    var stmts = [];\n\n    for (var i = 0; i < visitor.temporaryCount; i++) {\n      stmts.push(temporaryDeclaration(bindingId, i));\n    }\n\n    return stmts;\n  }\n\n  function convertBuiltins(converterFactory, ast) {\n    var visitor = new _BuiltinAstConverter(converterFactory);\n    return ast.visit(visitor);\n  }\n\n  function temporaryName(bindingId, temporaryNumber) {\n    return \"tmp_\" + bindingId + \"_\" + temporaryNumber;\n  }\n\n  function temporaryDeclaration(bindingId, temporaryNumber) {\n    return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n  }\n\n  exports.temporaryDeclaration = temporaryDeclaration;\n\n  function prependTemporaryDecls(temporaryCount, bindingId, statements) {\n    for (var i = temporaryCount - 1; i >= 0; i--) {\n      statements.unshift(temporaryDeclaration(bindingId, i));\n    }\n  }\n\n  var _Mode;\n\n  (function (_Mode) {\n    _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n    _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n  })(_Mode || (_Mode = {}));\n\n  function ensureStatementMode(mode, ast) {\n    if (mode !== _Mode.Statement) {\n      throw new Error(\"Expected a statement, but saw \" + ast);\n    }\n  }\n\n  function ensureExpressionMode(mode, ast) {\n    if (mode !== _Mode.Expression) {\n      throw new Error(\"Expected an expression, but saw \" + ast);\n    }\n  }\n\n  function convertToStatementIfNeeded(mode, expr) {\n    if (mode === _Mode.Statement) {\n      return expr.toStmt();\n    } else {\n      return expr;\n    }\n  }\n\n  var _BuiltinAstConverter =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(_BuiltinAstConverter, _super);\n\n    function _BuiltinAstConverter(_converterFactory) {\n      var _this = _super.call(this) || this;\n\n      _this._converterFactory = _converterFactory;\n      return _this;\n    }\n\n    _BuiltinAstConverter.prototype.visitPipe = function (ast, context) {\n      var _this = this;\n\n      var args = tslib_1.__spread([ast.exp], ast.args).map(function (ast) {\n        return ast.visit(_this, context);\n      });\n\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    };\n\n    _BuiltinAstConverter.prototype.visitLiteralArray = function (ast, context) {\n      var _this = this;\n\n      var args = ast.expressions.map(function (ast) {\n        return ast.visit(_this, context);\n      });\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    };\n\n    _BuiltinAstConverter.prototype.visitLiteralMap = function (ast, context) {\n      var _this = this;\n\n      var args = ast.values.map(function (ast) {\n        return ast.visit(_this, context);\n      });\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    };\n\n    return _BuiltinAstConverter;\n  }(cdAst.AstTransformer);\n\n  var _AstToIrVisitor =\n  /** @class */\n  function () {\n    function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {\n      this._localResolver = _localResolver;\n      this._implicitReceiver = _implicitReceiver;\n      this.bindingId = bindingId;\n      this.interpolationFunction = interpolationFunction;\n      this.baseSourceSpan = baseSourceSpan;\n      this.implicitReceiverAccesses = implicitReceiverAccesses;\n      this._nodeMap = new Map();\n      this._resultMap = new Map();\n      this._currentTemporary = 0;\n      this.temporaryCount = 0;\n      this.usesImplicitReceiver = false;\n    }\n\n    _AstToIrVisitor.prototype.visitUnary = function (ast, mode) {\n      var op;\n\n      switch (ast.operator) {\n        case '+':\n          op = o.UnaryOperator.Plus;\n          break;\n\n        case '-':\n          op = o.UnaryOperator.Minus;\n          break;\n\n        default:\n          throw new Error(\"Unsupported operator \" + ast.operator);\n      }\n\n      return convertToStatementIfNeeded(mode, new o.UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    };\n\n    _AstToIrVisitor.prototype.visitBinary = function (ast, mode) {\n      var op;\n\n      switch (ast.operation) {\n        case '+':\n          op = o.BinaryOperator.Plus;\n          break;\n\n        case '-':\n          op = o.BinaryOperator.Minus;\n          break;\n\n        case '*':\n          op = o.BinaryOperator.Multiply;\n          break;\n\n        case '/':\n          op = o.BinaryOperator.Divide;\n          break;\n\n        case '%':\n          op = o.BinaryOperator.Modulo;\n          break;\n\n        case '&&':\n          op = o.BinaryOperator.And;\n          break;\n\n        case '||':\n          op = o.BinaryOperator.Or;\n          break;\n\n        case '==':\n          op = o.BinaryOperator.Equals;\n          break;\n\n        case '!=':\n          op = o.BinaryOperator.NotEquals;\n          break;\n\n        case '===':\n          op = o.BinaryOperator.Identical;\n          break;\n\n        case '!==':\n          op = o.BinaryOperator.NotIdentical;\n          break;\n\n        case '<':\n          op = o.BinaryOperator.Lower;\n          break;\n\n        case '>':\n          op = o.BinaryOperator.Bigger;\n          break;\n\n        case '<=':\n          op = o.BinaryOperator.LowerEquals;\n          break;\n\n        case '>=':\n          op = o.BinaryOperator.BiggerEquals;\n          break;\n\n        default:\n          throw new Error(\"Unsupported operation \" + ast.operation);\n      }\n\n      return convertToStatementIfNeeded(mode, new o.BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    };\n\n    _AstToIrVisitor.prototype.visitChain = function (ast, mode) {\n      ensureStatementMode(mode, ast);\n      return this.visitAll(ast.expressions, mode);\n    };\n\n    _AstToIrVisitor.prototype.visitConditional = function (ast, mode) {\n      var value = this._visit(ast.condition, _Mode.Expression);\n\n      return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n    };\n\n    _AstToIrVisitor.prototype.visitPipe = function (ast, mode) {\n      throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \" + ast.name);\n    };\n\n    _AstToIrVisitor.prototype.visitFunctionCall = function (ast, mode) {\n      var convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n      var fnResult;\n\n      if (ast instanceof BuiltinFunctionCall) {\n        fnResult = ast.converter(convertedArgs);\n      } else {\n        fnResult = this._visit(ast.target, _Mode.Expression).callFn(convertedArgs, this.convertSourceSpan(ast.span));\n      }\n\n      return convertToStatementIfNeeded(mode, fnResult);\n    };\n\n    _AstToIrVisitor.prototype.visitImplicitReceiver = function (ast, mode) {\n      ensureExpressionMode(mode, ast);\n      this.usesImplicitReceiver = true;\n      return this._implicitReceiver;\n    };\n\n    _AstToIrVisitor.prototype.visitThisReceiver = function (ast, mode) {\n      return this.visitImplicitReceiver(ast, mode);\n    };\n\n    _AstToIrVisitor.prototype.visitInterpolation = function (ast, mode) {\n      ensureExpressionMode(mode, ast);\n      var args = [o.literal(ast.expressions.length)];\n\n      for (var i = 0; i < ast.strings.length - 1; i++) {\n        args.push(o.literal(ast.strings[i]));\n        args.push(this._visit(ast.expressions[i], _Mode.Expression));\n      }\n\n      args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n      if (this.interpolationFunction) {\n        return this.interpolationFunction(args);\n      }\n\n      return ast.expressions.length <= 9 ? o.importExpr(identifiers_1.Identifiers.inlineInterpolate).callFn(args) : o.importExpr(identifiers_1.Identifiers.interpolate).callFn([args[0], o.literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))]);\n    };\n\n    _AstToIrVisitor.prototype.visitKeyedRead = function (ast, mode) {\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n      }\n    };\n\n    _AstToIrVisitor.prototype.visitKeyedWrite = function (ast, mode) {\n      var obj = this._visit(ast.obj, _Mode.Expression);\n\n      var key = this._visit(ast.key, _Mode.Expression);\n\n      var value = this._visit(ast.value, _Mode.Expression);\n\n      return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    };\n\n    _AstToIrVisitor.prototype.visitLiteralArray = function (ast, mode) {\n      throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    };\n\n    _AstToIrVisitor.prototype.visitLiteralMap = function (ast, mode) {\n      throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    };\n\n    _AstToIrVisitor.prototype.visitLiteralPrimitive = function (ast, mode) {\n      // For literal values of null, undefined, true, or false allow type interference\n      // to infer the type.\n      var type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ? o.INFERRED_TYPE : undefined;\n      return convertToStatementIfNeeded(mode, o.literal(ast.value, type, this.convertSourceSpan(ast.span)));\n    };\n\n    _AstToIrVisitor.prototype._getLocal = function (name, receiver) {\n      var _a;\n\n      if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof cdAst.ThisReceiver) {\n        return null;\n      }\n\n      return this._localResolver.getLocal(name);\n    };\n\n    _AstToIrVisitor.prototype.visitMethodCall = function (ast, mode) {\n      if (ast.receiver instanceof cdAst.ImplicitReceiver && !(ast.receiver instanceof cdAst.ThisReceiver) && ast.name === '$any') {\n        var args = this.visitAll(ast.args, _Mode.Expression);\n\n        if (args.length != 1) {\n          throw new Error(\"Invalid call to $any, expected 1 argument but received \" + (args.length || 'none'));\n        }\n\n        return args[0].cast(o.DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n      }\n\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        var args = this.visitAll(ast.args, _Mode.Expression);\n        var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n        var result = null;\n\n        var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n        if (receiver === this._implicitReceiver) {\n          var varExpr = this._getLocal(ast.name, ast.receiver);\n\n          if (varExpr) {\n            // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n            result = varExpr.callFn(args);\n            this.addImplicitReceiverAccess(ast.name);\n          }\n        }\n\n        if (result == null) {\n          result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));\n        }\n\n        return convertToStatementIfNeeded(mode, result);\n      }\n    };\n\n    _AstToIrVisitor.prototype.visitPrefixNot = function (ast, mode) {\n      return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n    };\n\n    _AstToIrVisitor.prototype.visitNonNullAssert = function (ast, mode) {\n      return convertToStatementIfNeeded(mode, o.assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n    };\n\n    _AstToIrVisitor.prototype.visitPropertyRead = function (ast, mode) {\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        var result = null;\n        var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n        var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n        if (receiver === this._implicitReceiver) {\n          result = this._getLocal(ast.name, ast.receiver);\n\n          if (result) {\n            // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n            this.addImplicitReceiverAccess(ast.name);\n          }\n        }\n\n        if (result == null) {\n          result = receiver.prop(ast.name);\n        }\n\n        return convertToStatementIfNeeded(mode, result);\n      }\n    };\n\n    _AstToIrVisitor.prototype.visitPropertyWrite = function (ast, mode) {\n      var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n      var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      var varExpr = null;\n\n      if (receiver === this._implicitReceiver) {\n        var localExpr = this._getLocal(ast.name, ast.receiver);\n\n        if (localExpr) {\n          if (localExpr instanceof o.ReadPropExpr) {\n            // If the local variable is a property read expression, it's a reference\n            // to a 'context.property' value and will be used as the target of the\n            // write expression.\n            varExpr = localExpr; // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n            this.addImplicitReceiverAccess(ast.name);\n          } else {\n            // Otherwise it's an error.\n            var receiver_1 = ast.name;\n            var value = ast.value instanceof cdAst.PropertyRead ? ast.value.name : undefined;\n            throw new Error(\"Cannot assign value \\\"\" + value + \"\\\" to template variable \\\"\" + receiver_1 + \"\\\". Template variables are read-only.\");\n          }\n        }\n      } // If no local expression could be produced, use the original receiver's\n      // property as the target.\n\n\n      if (varExpr === null) {\n        varExpr = receiver.prop(ast.name);\n      }\n\n      return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n    };\n\n    _AstToIrVisitor.prototype.visitSafePropertyRead = function (ast, mode) {\n      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n\n    _AstToIrVisitor.prototype.visitSafeMethodCall = function (ast, mode) {\n      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    };\n\n    _AstToIrVisitor.prototype.visitAll = function (asts, mode) {\n      var _this = this;\n\n      return asts.map(function (ast) {\n        return _this._visit(ast, mode);\n      });\n    };\n\n    _AstToIrVisitor.prototype.visitQuote = function (ast, mode) {\n      throw new Error(\"Quotes are not supported for evaluation!\\n        Statement: \" + ast.uninterpretedExpression + \" located at \" + ast.location);\n    };\n\n    _AstToIrVisitor.prototype._visit = function (ast, mode) {\n      var result = this._resultMap.get(ast);\n\n      if (result) return result;\n      return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    };\n\n    _AstToIrVisitor.prototype.convertSafeAccess = function (ast, leftMostSafe, mode) {\n      // If the expression contains a safe access node on the left it needs to be converted to\n      // an expression that guards the access to the member by checking the receiver for blank. As\n      // execution proceeds from left to right, the left most part of the expression must be guarded\n      // first but, because member access is left associative, the right side of the expression is at\n      // the top of the AST. The desired result requires lifting a copy of the left part of the\n      // expression up to test it for blank before generating the unguarded version.\n      // Consider, for example the following expression: a?.b.c?.d.e\n      // This results in the ast:\n      //         .\n      //        / \\\n      //       ?.   e\n      //      /  \\\n      //     .    d\n      //    / \\\n      //   ?.  c\n      //  /  \\\n      // a    b\n      // The following tree should be generated:\n      //\n      //        /---- ? ----\\\n      //       /      |      \\\n      //     a   /--- ? ---\\  null\n      //        /     |     \\\n      //       .      .     null\n      //      / \\    / \\\n      //     .  c   .   e\n      //    / \\    / \\\n      //   a   b  .   d\n      //         / \\\n      //        .   c\n      //       / \\\n      //      a   b\n      //\n      // Notice that the first guard condition is the left hand of the left most safe access node\n      // which comes in as leftMostSafe to this routine.\n      var guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n\n      var temporary = undefined;\n\n      if (this.needsTemporary(leftMostSafe.receiver)) {\n        // If the expression has method calls or pipes then we need to save the result into a\n        // temporary variable to avoid calling stateful or impure code more than once.\n        temporary = this.allocateTemporary(); // Preserve the result in the temporary variable\n\n        guardedExpression = temporary.set(guardedExpression); // Ensure all further references to the guarded expression refer to the temporary instead.\n\n        this._resultMap.set(leftMostSafe.receiver, temporary);\n      }\n\n      var condition = guardedExpression.isBlank(); // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n      // leftMostNode with its unguarded version in the call to `this.visit()`.\n\n      if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n        this._nodeMap.set(leftMostSafe, new cdAst.MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n      } else {\n        this._nodeMap.set(leftMostSafe, new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));\n      } // Recursively convert the node now without the guarded member access.\n\n\n      var access = this._visit(ast, _Mode.Expression); // Remove the mapping. This is not strictly required as the converter only traverses each node\n      // once but is safer if the conversion is changed to traverse the nodes more than once.\n\n\n      this._nodeMap.delete(leftMostSafe); // If we allocated a temporary, release it.\n\n\n      if (temporary) {\n        this.releaseTemporary(temporary);\n      } // Produce the conditional\n\n\n      return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n    }; // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n    // safe method call as this needs to be transformed initially to:\n    //   a == null ? null : a.c.b.c?.d.e\n    // then to:\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n\n\n    _AstToIrVisitor.prototype.leftMostSafeNode = function (ast) {\n      var _this = this;\n\n      var visit = function visit(visitor, ast) {\n        return (_this._nodeMap.get(ast) || ast).visit(visitor);\n      };\n\n      return ast.visit({\n        visitUnary: function visitUnary(ast) {\n          return null;\n        },\n        visitBinary: function visitBinary(ast) {\n          return null;\n        },\n        visitChain: function visitChain(ast) {\n          return null;\n        },\n        visitConditional: function visitConditional(ast) {\n          return null;\n        },\n        visitFunctionCall: function visitFunctionCall(ast) {\n          return null;\n        },\n        visitImplicitReceiver: function visitImplicitReceiver(ast) {\n          return null;\n        },\n        visitThisReceiver: function visitThisReceiver(ast) {\n          return null;\n        },\n        visitInterpolation: function visitInterpolation(ast) {\n          return null;\n        },\n        visitKeyedRead: function visitKeyedRead(ast) {\n          return visit(this, ast.obj);\n        },\n        visitKeyedWrite: function visitKeyedWrite(ast) {\n          return null;\n        },\n        visitLiteralArray: function visitLiteralArray(ast) {\n          return null;\n        },\n        visitLiteralMap: function visitLiteralMap(ast) {\n          return null;\n        },\n        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {\n          return null;\n        },\n        visitMethodCall: function visitMethodCall(ast) {\n          return visit(this, ast.receiver);\n        },\n        visitPipe: function visitPipe(ast) {\n          return null;\n        },\n        visitPrefixNot: function visitPrefixNot(ast) {\n          return null;\n        },\n        visitNonNullAssert: function visitNonNullAssert(ast) {\n          return null;\n        },\n        visitPropertyRead: function visitPropertyRead(ast) {\n          return visit(this, ast.receiver);\n        },\n        visitPropertyWrite: function visitPropertyWrite(ast) {\n          return null;\n        },\n        visitQuote: function visitQuote(ast) {\n          return null;\n        },\n        visitSafeMethodCall: function visitSafeMethodCall(ast) {\n          return visit(this, ast.receiver) || ast;\n        },\n        visitSafePropertyRead: function visitSafePropertyRead(ast) {\n          return visit(this, ast.receiver) || ast;\n        }\n      });\n    }; // Returns true of the AST includes a method or a pipe indicating that, if the\n    // expression is used as the target of a safe property or method access then\n    // the expression should be stored into a temporary variable.\n\n\n    _AstToIrVisitor.prototype.needsTemporary = function (ast) {\n      var _this = this;\n\n      var visit = function visit(visitor, ast) {\n        return ast && (_this._nodeMap.get(ast) || ast).visit(visitor);\n      };\n\n      var visitSome = function visitSome(visitor, ast) {\n        return ast.some(function (ast) {\n          return visit(visitor, ast);\n        });\n      };\n\n      return ast.visit({\n        visitUnary: function visitUnary(ast) {\n          return visit(this, ast.expr);\n        },\n        visitBinary: function visitBinary(ast) {\n          return visit(this, ast.left) || visit(this, ast.right);\n        },\n        visitChain: function visitChain(ast) {\n          return false;\n        },\n        visitConditional: function visitConditional(ast) {\n          return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n        },\n        visitFunctionCall: function visitFunctionCall(ast) {\n          return true;\n        },\n        visitImplicitReceiver: function visitImplicitReceiver(ast) {\n          return false;\n        },\n        visitThisReceiver: function visitThisReceiver(ast) {\n          return false;\n        },\n        visitInterpolation: function visitInterpolation(ast) {\n          return visitSome(this, ast.expressions);\n        },\n        visitKeyedRead: function visitKeyedRead(ast) {\n          return false;\n        },\n        visitKeyedWrite: function visitKeyedWrite(ast) {\n          return false;\n        },\n        visitLiteralArray: function visitLiteralArray(ast) {\n          return true;\n        },\n        visitLiteralMap: function visitLiteralMap(ast) {\n          return true;\n        },\n        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {\n          return false;\n        },\n        visitMethodCall: function visitMethodCall(ast) {\n          return true;\n        },\n        visitPipe: function visitPipe(ast) {\n          return true;\n        },\n        visitPrefixNot: function visitPrefixNot(ast) {\n          return visit(this, ast.expression);\n        },\n        visitNonNullAssert: function visitNonNullAssert(ast) {\n          return visit(this, ast.expression);\n        },\n        visitPropertyRead: function visitPropertyRead(ast) {\n          return false;\n        },\n        visitPropertyWrite: function visitPropertyWrite(ast) {\n          return false;\n        },\n        visitQuote: function visitQuote(ast) {\n          return false;\n        },\n        visitSafeMethodCall: function visitSafeMethodCall(ast) {\n          return true;\n        },\n        visitSafePropertyRead: function visitSafePropertyRead(ast) {\n          return false;\n        }\n      });\n    };\n\n    _AstToIrVisitor.prototype.allocateTemporary = function () {\n      var tempNumber = this._currentTemporary++;\n      this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n      return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    };\n\n    _AstToIrVisitor.prototype.releaseTemporary = function (temporary) {\n      this._currentTemporary--;\n\n      if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n        throw new Error(\"Temporary \" + temporary.name + \" released out of order\");\n      }\n    };\n    /**\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n     *\n     * `ParseSpan` objects are relative to the start of the expression.\n     * This method converts these to full `ParseSourceSpan` objects that\n     * show where the span is within the overall source file.\n     *\n     * @param span the relative span to convert.\n     * @returns a `ParseSourceSpan` for the given span or null if no\n     * `baseSourceSpan` was provided to this class.\n     */\n\n\n    _AstToIrVisitor.prototype.convertSourceSpan = function (span) {\n      if (this.baseSourceSpan) {\n        var start = this.baseSourceSpan.start.moveBy(span.start);\n        var end = this.baseSourceSpan.start.moveBy(span.end);\n        var fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n        return new parse_util_1.ParseSourceSpan(start, end, fullStart);\n      } else {\n        return null;\n      }\n    };\n    /** Adds the name of an AST to the list of implicit receiver accesses. */\n\n\n    _AstToIrVisitor.prototype.addImplicitReceiverAccess = function (name) {\n      if (this.implicitReceiverAccesses) {\n        this.implicitReceiverAccesses.add(name);\n      }\n    };\n\n    return _AstToIrVisitor;\n  }();\n\n  function flattenStatements(arg, output) {\n    if (Array.isArray(arg)) {\n      arg.forEach(function (entry) {\n        return flattenStatements(entry, output);\n      });\n    } else {\n      output.push(arg);\n    }\n  }\n\n  var DefaultLocalResolver =\n  /** @class */\n  function () {\n    function DefaultLocalResolver(globals) {\n      this.globals = globals;\n    }\n\n    DefaultLocalResolver.prototype.notifyImplicitReceiverUse = function () {};\n\n    DefaultLocalResolver.prototype.getLocal = function (name) {\n      if (name === EventHandlerVars.event.name) {\n        return EventHandlerVars.event;\n      }\n\n      return null;\n    };\n\n    return DefaultLocalResolver;\n  }();\n\n  function createCurrValueExpr(bindingId) {\n    return o.variable(\"currVal_\" + bindingId); // fix syntax highlighting: `\n  }\n\n  function createPreventDefaultVar(bindingId) {\n    return o.variable(\"pd_\" + bindingId);\n  }\n\n  function convertStmtIntoExpression(stmt) {\n    if (stmt instanceof o.ExpressionStatement) {\n      return stmt.expr;\n    } else if (stmt instanceof o.ReturnStatement) {\n      return stmt.value;\n    }\n\n    return null;\n  }\n\n  var BuiltinFunctionCall =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(BuiltinFunctionCall, _super);\n\n    function BuiltinFunctionCall(span, sourceSpan, args, converter) {\n      var _this = _super.call(this, span, sourceSpan, null, args) || this;\n\n      _this.args = args;\n      _this.converter = converter;\n      return _this;\n    }\n\n    return BuiltinFunctionCall;\n  }(cdAst.FunctionCall);\n\n  exports.BuiltinFunctionCall = BuiltinFunctionCall;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/compiler_util/expression_converter.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class EventHandlerVars {\n  static event = o.variable('$event');\n}\n\nexport interface LocalResolver {\n  getLocal(name: string): o.Expression|null;\n  notifyImplicitReceiverUse(): void;\n  globals?: Set<string>;\n}\n\nexport class ConvertActionBindingResult {\n  /**\n   * Store statements which are render3 compatible.\n   */\n  render3Stmts: o.Statement[];\n  constructor(\n      /**\n       * Render2 compatible statements,\n       */\n      public stmts: o.Statement[],\n      /**\n       * Variable name used with render2 compatible statements.\n       */\n      public allowDefault: o.ReadVarExpr) {\n    /**\n     * This is bit of a hack. It converts statements which render2 expects to statements which are\n     * expected by render3.\n     *\n     * Example: `<div click=\"doSomething($event)\">` will generate:\n     *\n     * Render3:\n     * ```\n     * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n     * return pd_b;\n     * ```\n     *\n     * but render2 expects:\n     * ```\n     * return ctx.doSomething($event);\n     * ```\n     */\n    // TODO(misko): remove this hack once we no longer support ViewEngine.\n    this.render3Stmts = stmts.map((statement: o.Statement) => {\n      if (statement instanceof o.DeclareVarStmt && statement.name == allowDefault.name &&\n          statement.value instanceof o.BinaryOperatorExpr) {\n        const lhs = statement.value.lhs as o.CastExpr;\n        return new o.ReturnStatement(lhs.value);\n      }\n      return statement;\n    });\n  }\n}\n\nexport type InterpolationFunction = (args: o.Expression[]) => o.Expression;\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, interpolationFunction?: InterpolationFunction,\n    baseSourceSpan?: ParseSourceSpan, implicitReceiverAccesses?: Set<string>,\n    globals?: Set<string>): ConvertActionBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver(globals);\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan,\n      implicitReceiverAccesses);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const lastIndex = actionStmts.length - 1;\n  let preventDefaultVar: o.ReadVarExpr = null!;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    const returnExpr = convertStmtIntoExpression(lastStatement);\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] =\n          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n              .toDeclStmt(null, [o.StmtModifier.Final]);\n    }\n  }\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n\nexport interface BuiltinConverter {\n  (args: o.Expression[]): o.Expression;\n}\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\nexport enum BindingForm {\n  // The general form of binding expression, supports all expressions.\n  General,\n\n  // Try to generate a simple binding (no temporaries or statements)\n  // otherwise generate a general binding\n  TrySimple,\n\n  // Inlines assignment of temporaries into the generated expression. The result may still\n  // have statements attached for declarations of temporary variables.\n  // This is the only relevant form for Ivy, the other forms are only used in ViewEngine.\n  Expression,\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string, form: BindingForm,\n    interpolationFunction?: InterpolationFunction): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const visitor =\n      new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n  const stmts: o.Statement[] = getStatementsFromVisitor(visitor, bindingId);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\n    return new ConvertPropertyBindingResult([], outputExpr);\n  } else if (form === BindingForm.Expression) {\n    return new ConvertPropertyBindingResult(stmts, outputExpr);\n  }\n\n  const currValExpr = createCurrValueExpr(bindingId);\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nexport function convertUpdateArguments(\n    localResolver: LocalResolver, contextVariableExpression: o.Expression,\n    expressionWithArgumentsToExtract: cdAst.AST, bindingId: string) {\n  const visitor =\n      new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\n  const outputExpr: o.InvokeFunctionExpr =\n      expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const stmts = getStatementsFromVisitor(visitor, bindingId);\n\n  // Removing the first argument, because it was a length for ViewEngine, not Ivy.\n  let args = outputExpr.args.slice(1);\n  if (expressionWithArgumentsToExtract instanceof cdAst.Interpolation) {\n    // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n    // args returned to just the value, because we're going to pass it to a special instruction.\n    const strings = expressionWithArgumentsToExtract.strings;\n    if (args.length === 3 && strings[0] === '' && strings[1] === '') {\n      // Single argument interpolate instructions.\n      args = [args[1]];\n    } else if (args.length >= 19) {\n      // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n      // an array of arguments\n      args = [o.literalArr(args)];\n    }\n  }\n  return {stmts, args};\n}\n\nfunction getStatementsFromVisitor(visitor: _AstToIrVisitor, bindingId: string) {\n  const stmts: o.Statement[] = [];\n  for (let i = 0; i < visitor.temporaryCount; i++) {\n    stmts.push(temporaryDeclaration(bindingId, i));\n  }\n  return stmts;\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nexport function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) {\n    super();\n  }\n  visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n  public usesImplicitReceiver: boolean = false;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private interpolationFunction: InterpolationFunction|undefined,\n      private baseSourceSpan?: ParseSourceSpan, private implicitReceiverAccesses?: Set<string>) {}\n\n  visitUnary(ast: cdAst.Unary, mode: _Mode): any {\n    let op: o.UnaryOperator;\n    switch (ast.operator) {\n      case '+':\n        op = o.UnaryOperator.Plus;\n        break;\n      case '-':\n        op = o.UnaryOperator.Minus;\n        break;\n      default:\n        throw new Error(`Unsupported operator ${ast.operator}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.UnaryOperatorExpr(\n            op, this._visit(ast.expr, _Mode.Expression), undefined,\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression),\n            undefined, this.convertSourceSpan(ast.span)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode,\n        value.conditional(\n            this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression),\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n    let fnResult: o.Expression;\n    if (ast instanceof BuiltinFunctionCall) {\n      fnResult = ast.converter(convertedArgs);\n    } else {\n      fnResult = this._visit(ast.target!, _Mode.Expression)\n                     .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n    }\n    return convertToStatementIfNeeded(mode, fnResult);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    this.usesImplicitReceiver = true;\n    return this._implicitReceiver;\n  }\n\n  visitThisReceiver(ast: cdAst.ThisReceiver, mode: _Mode): any {\n    return this.visitImplicitReceiver(ast, mode);\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const args = [o.literal(ast.expressions.length)];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    if (this.interpolationFunction) {\n      return this.interpolationFunction(args);\n    }\n    return ast.expressions.length <= 9 ?\n        o.importExpr(Identifiers.inlineInterpolate).callFn(args) :\n        o.importExpr(Identifiers.interpolate).callFn([\n          args[0], o.literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))\n        ]);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.obj, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(\n        mode, o.literal(ast.value, type, this.convertSourceSpan(ast.span)));\n  }\n\n  private _getLocal(name: string, receiver: cdAst.AST): o.Expression|null {\n    if (this._localResolver.globals?.has(name) && receiver instanceof cdAst.ThisReceiver) {\n      return null;\n    }\n\n    return this._localResolver.getLocal(name);\n  }\n\n  visitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    if (ast.receiver instanceof cdAst.ImplicitReceiver &&\n        !(ast.receiver instanceof cdAst.ThisReceiver) && ast.name === '$any') {\n      const args = this.visitAll(ast.args, _Mode.Expression) as any[];\n      if (args.length != 1) {\n        throw new Error(\n            `Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);\n      }\n      return (args[0] as o.Expression).cast(o.DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n    }\n\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const args = this.visitAll(ast.args, _Mode.Expression);\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      let result: any = null;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        const varExpr = this._getLocal(ast.name, ast.receiver);\n        if (varExpr) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          result = varExpr.callFn(args);\n          this.addImplicitReceiverAccess(ast.name);\n        }\n      }\n      if (result == null) {\n        result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode, o.assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name, ast.receiver);\n        if (result) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        }\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n    let varExpr: o.ReadPropExpr|null = null;\n    if (receiver === this._implicitReceiver) {\n      const localExpr = this._getLocal(ast.name, ast.receiver);\n      if (localExpr) {\n        if (localExpr instanceof o.ReadPropExpr) {\n          // If the local variable is a property read expression, it's a reference\n          // to a 'context.property' value and will be used as the target of the\n          // write expression.\n          varExpr = localExpr;\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        } else {\n          // Otherwise it's an error.\n          const receiver = ast.name;\n          const value = (ast.value instanceof cdAst.PropertyRead) ? ast.value.name : undefined;\n          throw new Error(`Cannot assign value \"${value}\" to template variable \"${\n              receiver}\". Template variables are read-only.`);\n        }\n      }\n    }\n    // If no local expression could be produced, use the original receiver's\n    // property as the target.\n    if (varExpr === null) {\n      varExpr = receiver.prop(ast.name);\n    }\n    return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any {\n    return asts.map(ast => this._visit(ast, mode));\n  }\n\n  visitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  .   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr = undefined!;\n    if (this.needsTemporary(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.MethodCall(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan,\n              leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan,\n              leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n  }\n\n  // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs to be transformed initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary) {\n        return null;\n      },\n      visitBinary(ast: cdAst.Binary) {\n        return null;\n      },\n      visitChain(ast: cdAst.Chain) {\n        return null;\n      },\n      visitConditional(ast: cdAst.Conditional) {\n        return null;\n      },\n      visitFunctionCall(ast: cdAst.FunctionCall) {\n        return null;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return null;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return null;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return null;\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return visit(this, ast.obj);\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return null;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return null;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return null;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return null;\n      },\n      visitMethodCall(ast: cdAst.MethodCall) {\n        return visit(this, ast.receiver);\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return null;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return null;\n      },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) {\n        return null;\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return visit(this, ast.receiver);\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return null;\n      },\n      visitQuote(ast: cdAst.Quote) {\n        return null;\n      },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporary(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary): boolean {\n        return visit(this, ast.expr);\n      },\n      visitBinary(ast: cdAst.Binary): boolean {\n        return visit(this, ast.left) || visit(this, ast.right);\n      },\n      visitChain(ast: cdAst.Chain) {\n        return false;\n      },\n      visitConditional(ast: cdAst.Conditional): boolean {\n        return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n      },\n      visitFunctionCall(ast: cdAst.FunctionCall) {\n        return true;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return false;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return false;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return visitSome(this, ast.expressions);\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return false;\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return false;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return true;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return true;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return false;\n      },\n      visitMethodCall(ast: cdAst.MethodCall) {\n        return true;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return true;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitNonNullAssert(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return false;\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return false;\n      },\n      visitQuote(ast: cdAst.Quote) {\n        return false;\n      },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) {\n        return true;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return false;\n      }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n\n  /**\n   * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n   *\n   * `ParseSpan` objects are relative to the start of the expression.\n   * This method converts these to full `ParseSourceSpan` objects that\n   * show where the span is within the overall source file.\n   *\n   * @param span the relative span to convert.\n   * @returns a `ParseSourceSpan` for the given span or null if no\n   * `baseSourceSpan` was provided to this class.\n   */\n  private convertSourceSpan(span: cdAst.ParseSpan) {\n    if (this.baseSourceSpan) {\n      const start = this.baseSourceSpan.start.moveBy(span.start);\n      const end = this.baseSourceSpan.start.moveBy(span.end);\n      const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n      return new ParseSourceSpan(start, end, fullStart);\n    } else {\n      return null;\n    }\n  }\n\n  /** Adds the name of an AST to the list of implicit receiver accesses. */\n  private addImplicitReceiverAccess(name: string) {\n    if (this.implicitReceiverAccesses) {\n      this.implicitReceiverAccesses.add(name);\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  constructor(public globals?: Set<string>) {}\n  notifyImplicitReceiverUse(): void {}\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nfunction createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n  return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n}\n\nfunction createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n  return o.variable(`pd_${bindingId}`);\n}\n\nfunction convertStmtIntoExpression(stmt: o.Statement): o.Expression|null {\n  if (stmt instanceof o.ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof o.ReturnStatement) {\n    return stmt.value;\n  }\n  return null;\n}\n\nexport class BuiltinFunctionCall extends cdAst.FunctionCall {\n  constructor(\n      span: cdAst.ParseSpan, sourceSpan: cdAst.AbsoluteSourceSpan, public args: cdAst.AST[],\n      public converter: BuiltinConverter) {\n    super(span, sourceSpan, null, args);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}