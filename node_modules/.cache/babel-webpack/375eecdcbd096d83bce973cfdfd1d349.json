{"ast":null,"code":"var path = require(\"path\");\n\nvar _require = require(\"ts-pnp\"),\n    resolveModuleName = _require.resolveModuleName;\n\nfunction nothing() {// ¯\\_(ツ)_/¯\n}\n\nfunction getModuleLocator(module) {\n  var pnp = require(\"pnpapi\");\n\n  var moduleLocation = typeof module === \"string\" ? module : module.filename;\n  if (!moduleLocation) throw new Error(\"The specified module doesn't seem to exist on the filesystem\");\n  var moduleLocator = pnp.findPackageLocator(moduleLocation);\n  if (!moduleLocator) throw new Error(\"the specified module doesn't seem to be part of the dependency tree\");\n  return moduleLocator;\n}\n\nfunction getDependencyLocator(sourceLocator, name) {\n  var pnp = require(\"pnpapi\");\n\n  var _pnp$getPackageInform = pnp.getPackageInformation(sourceLocator),\n      packageDependencies = _pnp$getPackageInform.packageDependencies;\n\n  var reference = packageDependencies.get(name);\n  return {\n    name: name,\n    reference: reference\n  };\n}\n\nfunction getSourceLocation(sourceLocator) {\n  if (!sourceLocator) return null;\n\n  var pnp = require(\"pnpapi\");\n\n  var sourceInformation = pnp.getPackageInformation(sourceLocator);\n  if (!sourceInformation) throw new Error(\"Couldn't find the package to use as resolution source\");\n  if (!sourceInformation.packageLocation) throw new Error(\"The package to use as resolution source seem to not have been installed - maybe it's a devDependency not installed in prod?\");\n  return sourceInformation.packageLocation.replace(/\\/?$/, \"/\");\n}\n\nfunction makeResolver(sourceLocator, filter) {\n  var sourceLocation = getSourceLocation(sourceLocator);\n  return function (resolver) {\n    var BACKWARD_PATH = /^\\.\\.([\\\\\\/]|$)/;\n    var resolvedHook = resolver.ensureHook(\"resolve\"); // Prevents the SymlinkPlugin from kicking in. We need the symlinks to be preserved because that's how we deal with peer dependencies ambiguities.\n\n    resolver.getHook(\"file\").intercept({\n      register: function register(tapInfo) {\n        return tapInfo.name !== \"SymlinkPlugin\" ? tapInfo : Object.assign({}, tapInfo, {\n          fn: function fn(request, resolveContext, callback) {\n            callback();\n          }\n        });\n      }\n    });\n    resolver.getHook(\"after-module\").tapAsync(\"PnpResolver\", function (request, resolveContext, callback) {\n      // rethrow pnp errors if we have any for this request\n      return callback(resolveContext.pnpErrors && resolveContext.pnpErrors.get(request.context.issuer));\n    }); // Register a plugin that will resolve bare imports into the package location on the filesystem before leaving the rest of the resolution to Webpack\n\n    resolver.getHook(\"before-module\").tapAsync(\"PnpResolver\", function (requestContext, resolveContext, callback) {\n      var pnp = require(\"pnpapi\");\n\n      var request = requestContext.request;\n      var issuer = requestContext.context.issuer; // When using require.context, issuer seems to be false (cf https://github.com/webpack/webpack-dev-server/blob/d0725c98fb752d8c0b1e8c9067e526e22b5f5134/client-src/default/index.js#L94)\n\n      if (!issuer) {\n        issuer = \"\".concat(requestContext.path, \"/\"); // We only support issuer when they're absolute paths. I'm not sure the opposite can ever happen, but better check here.\n      } else if (!path.isAbsolute(issuer)) {\n        throw new Error(\"Cannot successfully resolve this dependency - issuer not supported (\".concat(issuer, \")\"));\n      }\n\n      if (filter) {\n        var relative = path.relative(filter, issuer);\n\n        if (path.isAbsolute(relative) || BACKWARD_PATH.test(relative)) {\n          return callback(null);\n        }\n      }\n\n      var resolutionIssuer = sourceLocation || issuer;\n      var resolution;\n\n      try {\n        resolution = pnp.resolveToUnqualified(request, resolutionIssuer, {\n          considerBuiltins: false\n        });\n      } catch (error) {\n        if (resolveContext.missingDependencies) resolveContext.missingDependencies.add(requestContext.path);\n        if (resolveContext.log) resolveContext.log(error.message);\n        resolveContext.pnpErrors = resolveContext.pnpErrors || new Map();\n        resolveContext.pnpErrors.set(issuer, error);\n        return callback();\n      }\n\n      resolver.doResolve(resolvedHook, Object.assign({}, requestContext, {\n        request: resolution\n      }), null, resolveContext, callback);\n    });\n  };\n}\n\nmodule.exports = process.versions.pnp ? {\n  apply: makeResolver(null)\n} : {\n  apply: nothing\n};\n\nmodule.exports.makePlugin = function (locator, filter) {\n  return process.versions.pnp ? {\n    apply: makeResolver(locator, filter)\n  } : {\n    apply: nothing\n  };\n};\n\nmodule.exports.moduleLoader = function (module) {\n  return process.versions.pnp ? {\n    apply: makeResolver(getModuleLocator(module))\n  } : {\n    apply: nothing\n  };\n};\n\nmodule.exports.topLevelLoader = process.versions.pnp ? {\n  apply: makeResolver({\n    name: null,\n    reference: null\n  })\n} : {\n  apply: nothing\n};\n\nmodule.exports.bind = function (filter, module, dependency) {\n  return process.versions.pnp ? {\n    apply: makeResolver(dependency ? getDependencyLocator(getModuleLocator(module), dependency) : getModuleLocator(module), filter)\n  } : {\n    apply: nothing\n  };\n};\n\nmodule.exports.tsLoaderOptions = function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return process.versions.pnp ? Object.assign({}, options, {\n    resolveModuleName: resolveModuleName,\n    resolveTypeReferenceDirective: resolveModuleName\n  }) : options;\n};\n\nmodule.exports.forkTsCheckerOptions = function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return process.versions.pnp ? Object.assign({}, options, {\n    resolveModuleNameModule: require.resolve(\"./ts\"),\n    resolveTypeReferenceDirectiveModule: require.resolve(\"./ts\")\n  }) : options;\n};","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/pnp-webpack-plugin/index.js"],"names":["path","require","resolveModuleName","nothing","getModuleLocator","module","pnp","moduleLocation","filename","Error","moduleLocator","findPackageLocator","getDependencyLocator","sourceLocator","name","getPackageInformation","packageDependencies","reference","get","getSourceLocation","sourceInformation","packageLocation","replace","makeResolver","filter","sourceLocation","resolver","BACKWARD_PATH","resolvedHook","ensureHook","getHook","intercept","register","tapInfo","Object","assign","fn","request","resolveContext","callback","tapAsync","pnpErrors","context","issuer","requestContext","isAbsolute","relative","test","resolutionIssuer","resolution","resolveToUnqualified","considerBuiltins","error","missingDependencies","add","log","message","Map","set","doResolve","exports","process","versions","apply","makePlugin","locator","moduleLoader","topLevelLoader","bind","dependency","tsLoaderOptions","options","resolveTypeReferenceDirective","forkTsCheckerOptions","resolveModuleNameModule","resolve","resolveTypeReferenceDirectiveModule"],"mappings":"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","sourcesContent":["const path = require(`path`);\nconst {resolveModuleName} = require(`ts-pnp`);\n\nfunction nothing() {\n  // ¯\\_(ツ)_/¯\n}\n\nfunction getModuleLocator(module) {\n  const pnp = require(`pnpapi`);\n\n  const moduleLocation = typeof module === `string`\n    ? module\n    : module.filename;\n\n  if (!moduleLocation)\n    throw new Error(`The specified module doesn't seem to exist on the filesystem`);\n\n  const moduleLocator = pnp.findPackageLocator(moduleLocation);\n\n  if (!moduleLocator)\n    throw new Error(`the specified module doesn't seem to be part of the dependency tree`);\n\n  return moduleLocator;\n}\n\nfunction getDependencyLocator(sourceLocator, name) {\n  const pnp = require(`pnpapi`);\n\n  const {packageDependencies} = pnp.getPackageInformation(sourceLocator);\n  const reference = packageDependencies.get(name);\n\n  return {name, reference};\n}\n\nfunction getSourceLocation(sourceLocator) {\n  if (!sourceLocator)\n    return null;\n\n  const pnp = require(`pnpapi`);\n\n  const sourceInformation = pnp.getPackageInformation(sourceLocator);\n\n  if (!sourceInformation)\n    throw new Error(`Couldn't find the package to use as resolution source`);\n\n  if (!sourceInformation.packageLocation)\n    throw new Error(`The package to use as resolution source seem to not have been installed - maybe it's a devDependency not installed in prod?`);\n\n  return sourceInformation.packageLocation.replace(/\\/?$/, `/`);\n}\n\nfunction makeResolver(sourceLocator, filter) {\n  const sourceLocation = getSourceLocation(sourceLocator);\n\n  return resolver => {\n    const BACKWARD_PATH = /^\\.\\.([\\\\\\/]|$)/;\n\n    const resolvedHook = resolver.ensureHook(`resolve`);\n\n    // Prevents the SymlinkPlugin from kicking in. We need the symlinks to be preserved because that's how we deal with peer dependencies ambiguities.\n    resolver.getHook(`file`).intercept({\n      register: tapInfo => {\n        return tapInfo.name !== `SymlinkPlugin` ? tapInfo : Object.assign({}, tapInfo, {fn: (request, resolveContext, callback) => {\n          callback();\n        }});\n      }\n    });\n\n    resolver.getHook(`after-module`).tapAsync(`PnpResolver`, (request, resolveContext, callback) => {\n      // rethrow pnp errors if we have any for this request\n      return callback(resolveContext.pnpErrors && resolveContext.pnpErrors.get(request.context.issuer));\n    });\n\n    // Register a plugin that will resolve bare imports into the package location on the filesystem before leaving the rest of the resolution to Webpack\n    resolver.getHook(`before-module`).tapAsync(`PnpResolver`, (requestContext, resolveContext, callback) => {\n      const pnp = require(`pnpapi`);\n\n      let request = requestContext.request;\n      let issuer = requestContext.context.issuer;\n\n      // When using require.context, issuer seems to be false (cf https://github.com/webpack/webpack-dev-server/blob/d0725c98fb752d8c0b1e8c9067e526e22b5f5134/client-src/default/index.js#L94)\n      if (!issuer) {\n        issuer = `${requestContext.path}/`;\n      // We only support issuer when they're absolute paths. I'm not sure the opposite can ever happen, but better check here.\n      } else if (!path.isAbsolute(issuer)) {\n        throw new Error(`Cannot successfully resolve this dependency - issuer not supported (${issuer})`);\n      }\n\n      if (filter) {\n        const relative = path.relative(filter, issuer);\n        if (path.isAbsolute(relative) || BACKWARD_PATH.test(relative)) {\n          return callback(null);\n        }\n      }\n\n      let resolutionIssuer = sourceLocation || issuer;\n      let resolution;\n\n      try {\n        resolution = pnp.resolveToUnqualified(request, resolutionIssuer, {considerBuiltins: false});\n      } catch (error) {\n        if (resolveContext.missingDependencies)\n          resolveContext.missingDependencies.add(requestContext.path);\n\n        if (resolveContext.log)\n          resolveContext.log(error.message);\n\n        resolveContext.pnpErrors = resolveContext.pnpErrors || new Map();\n        resolveContext.pnpErrors.set(issuer, error);\n\n        return callback();\n      }\n\n      resolver.doResolve(\n        resolvedHook,\n        Object.assign({}, requestContext, {\n          request: resolution,\n        }),\n        null,\n        resolveContext,\n        callback\n      );\n    });\n  };\n}\n\nmodule.exports = process.versions.pnp ? {\n  apply: makeResolver(null),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.makePlugin = (locator, filter) => process.versions.pnp ? {\n  apply: makeResolver(locator, filter),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.moduleLoader = module => process.versions.pnp ? {\n  apply: makeResolver(getModuleLocator(module)),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.topLevelLoader = process.versions.pnp ? {\n  apply: makeResolver({name: null, reference: null}),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.bind = (filter, module, dependency) => process.versions.pnp ? {\n  apply: makeResolver(dependency ? getDependencyLocator(getModuleLocator(module), dependency) : getModuleLocator(module), filter),\n} : {\n  apply: nothing,\n};\n\nmodule.exports.tsLoaderOptions = (options = {}) => process.versions.pnp ? Object.assign({}, options, {\n  resolveModuleName: resolveModuleName,\n  resolveTypeReferenceDirective: resolveModuleName,\n}) : options;\n\nmodule.exports.forkTsCheckerOptions = (options = {}) => process.versions.pnp ? Object.assign({}, options, {\n  resolveModuleNameModule: require.resolve(`./ts`),\n  resolveTypeReferenceDirectiveModule: require.resolve(`./ts`),\n}) : options;\n"]},"metadata":{},"sourceType":"script"}