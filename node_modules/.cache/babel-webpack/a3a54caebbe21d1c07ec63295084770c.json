{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importFactory = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar path_1 = require(\"path\");\n\nvar ts = require(\"typescript\");\n\nvar utils_1 = require(\"../utils\"); // Check if a ts.Symbol is an alias.\n\n\nvar isAlias = function isAlias(symbol) {\n  return symbol.flags & ts.SymbolFlags.Alias;\n};\n/**\n * Given this original source code:\n *\n * import { NgModule } from '@angular/core';\n * import { Routes, RouterModule } from '@angular/router';\n *\n * const routes: Routes = [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy/lazy.module').then(m => m.LazyModule).\n * }];\n *\n * @NgModule({\n *   imports: [RouterModule.forRoot(routes)],\n *   exports: [RouterModule]\n * })\n * export class AppRoutingModule { }\n *\n * NGC (View Engine) will process it into:\n *\n * import { Routes } from '@angular/router';\n * const ɵ0 = () => import('./lazy/lazy.module').then(m => m.LazyModule);\n * const routes: Routes = [{\n *         path: 'lazy',\n *         loadChildren: ɵ0\n *     }];\n * export class AppRoutingModule {\n * }\n * export { ɵ0 };\n *\n * The importFactory transformation will only see the AST after it is process by NGC.\n * You can confirm this with the code below:\n *\n * const res = ts.createPrinter().printNode(ts.EmitHint.Unspecified, sourceFile, sourceFile);\n * console.log(`### Original source: \\n${sourceFile.text}\\n###`);\n * console.log(`### Current source: \\n${currentText}\\n###`);\n *\n * At this point it doesn't yet matter what the target (ES5/ES2015/etc) is, so the original\n * constructs, like `class` and arrow functions, still remain.\n *\n */\n\n\nfunction importFactory(warningCb, getTypeChecker) {\n  return function (context) {\n    // TODO(filipesilva): change the link to https://angular.io/guide/ivy once it is out.\n    return function (sourceFile) {\n      var warning = \"\\nFound 'loadChildren' with a non-string syntax in \".concat(sourceFile.fileName, \" but could not transform it.\\nMake sure it matches the format below:\\n\\nloadChildren: () => import('IMPORT_STRING').then(M => M.EXPORT_NAME)\\n\\nPlease note that only IMPORT_STRING, M, and EXPORT_NAME can be replaced in this format.\\n\\nVisit https://v8.angular.io/guide/ivy for more information on using Ivy.\\n\");\n\n      var emitWarning = function emitWarning() {\n        return warningCb(warning);\n      };\n\n      var visitVariableStatement = function visitVariableStatement(node) {\n        if (ts.isVariableDeclaration(node)) {\n          return replaceImport(node, context, emitWarning, sourceFile.fileName, getTypeChecker());\n        }\n\n        return ts.visitEachChild(node, visitVariableStatement, context);\n      };\n\n      var visitToplevelNodes = function visitToplevelNodes(node) {\n        // We only care about finding variable declarations, which are found in this structure:\n        // VariableStatement -> VariableDeclarationList -> VariableDeclaration\n        if (ts.isVariableStatement(node)) {\n          return ts.visitEachChild(node, visitVariableStatement, context);\n        } // There's no point in recursing into anything but variable statements, so return the node.\n\n\n        return node;\n      };\n\n      return ts.visitEachChild(sourceFile, visitToplevelNodes, context);\n    };\n  };\n}\n\nexports.importFactory = importFactory;\n\nfunction replaceImport(node, context, emitWarning, fileName, typeChecker) {\n  // This ONLY matches the original source code format below:\n  // loadChildren: () => import('IMPORT_STRING').then(M => M.EXPORT_NAME)\n  // And expects that source code to be transformed by NGC (see comment for importFactory).\n  // It will not match nor alter variations, for instance:\n  // - not using arrow functions\n  // - using `await` instead of `then`\n  // - using a default export (https://github.com/angular/angular/issues/11402)\n  // The only parts that can change are the ones in caps: IMPORT_STRING, M and EXPORT_NAME.\n  // Exit early if the structure is not what we expect.\n  // ɵ0 = something\n  var name = node.name;\n\n  if (!(ts.isIdentifier(name) && /ɵ\\d+/.test(name.text))) {\n    return node;\n  }\n\n  var initializer = node.initializer;\n\n  if (initializer === undefined) {\n    return node;\n  } // ɵ0 = () => something\n\n\n  if (!(ts.isArrowFunction(initializer) && initializer.parameters.length === 0)) {\n    return node;\n  } // ɵ0 = () => something.then(something)\n\n\n  var topArrowFnBody = initializer.body;\n\n  if (!ts.isCallExpression(topArrowFnBody)) {\n    return node;\n  }\n\n  var topArrowFnBodyExpr = topArrowFnBody.expression;\n\n  if (!(ts.isPropertyAccessExpression(topArrowFnBodyExpr) && ts.isIdentifier(topArrowFnBodyExpr.name))) {\n    return node;\n  }\n\n  if (topArrowFnBodyExpr.name.text != 'then') {\n    return node;\n  } // ɵ0 = () => import('IMPORT_STRING').then(something)\n\n\n  var importCall = topArrowFnBodyExpr.expression;\n\n  if (!(ts.isCallExpression(importCall) && importCall.expression.kind === ts.SyntaxKind.ImportKeyword && importCall.arguments.length === 1 && ts.isStringLiteral(importCall.arguments[0]))) {\n    return node;\n  } // Now that we know it's both `ɵ0` (generated by NGC) and a `import()`, start emitting a warning\n  // if the structure isn't as expected to help users identify unusable syntax.\n\n\n  var warnAndBail = function warnAndBail() {\n    emitWarning();\n    return node;\n  }; // ɵ0 = () => import('IMPORT_STRING').then(m => m.EXPORT_NAME)\n\n\n  if (!(topArrowFnBody.arguments.length === 1 && ts.isArrowFunction(topArrowFnBody.arguments[0]))) {\n    return warnAndBail();\n  }\n\n  var thenArrowFn = topArrowFnBody.arguments[0];\n\n  if (!(thenArrowFn.parameters.length === 1 && ts.isPropertyAccessExpression(thenArrowFn.body) && ts.isIdentifier(thenArrowFn.body.name))) {\n    return warnAndBail();\n  } // At this point we know what are the nodes we need to replace.\n\n\n  var exportNameId = thenArrowFn.body.name;\n  var importStringLit = importCall.arguments[0]; // Try to resolve the import. It might be a reexport from somewhere and the ngfactory will only\n  // be present next to the original module.\n\n  var exportedSymbol = typeChecker.getSymbolAtLocation(exportNameId);\n\n  if (!exportedSymbol) {\n    return warnAndBail();\n  } // Named exports are also a declaration in the re-exporting module so we have to follow the\n  // re-exports to find the original symbol.\n\n\n  if (isAlias(exportedSymbol)) {\n    exportedSymbol = typeChecker.getAliasedSymbol(exportedSymbol);\n\n    if (!exportedSymbol) {\n      return warnAndBail();\n    }\n  } // Find declarations of the original symbol so we can get their source file name.\n\n\n  var exportedSymbolDecl = exportedSymbol.getDeclarations();\n\n  if (!exportedSymbolDecl || exportedSymbolDecl.length === 0) {\n    return warnAndBail();\n  } // Let's guess the first declaration is the one we want, because we don't have a better criteria.\n  // Get the relative path from the containing module to the imported module.\n\n\n  var relativePath = path_1.relative(path_1.dirname(fileName), exportedSymbolDecl[0].getSourceFile().fileName); // node's `relative` call doesn't actually add `./` so we add it here.\n  // Also replace the 'ts' extension with just 'ngfactory'.\n\n  var newImportString = \"./\".concat(utils_1.forwardSlashPath(relativePath)).replace(/ts$/, 'ngfactory'); // The easiest way to alter them is with a simple visitor.\n\n  var replacementVisitor = function replacementVisitor(node) {\n    if (node === importStringLit) {\n      // Transform the import string.\n      return ts.createStringLiteral(newImportString);\n    } else if (node === exportNameId) {\n      // Transform the export name.\n      return ts.createIdentifier(exportNameId.text + 'NgFactory');\n    }\n\n    return ts.visitEachChild(node, replacementVisitor, context);\n  };\n\n  return ts.visitEachChild(node, replacementVisitor, context);\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/transformers/import_factory.js"],"names":["Object","defineProperty","exports","value","importFactory","path_1","require","ts","utils_1","isAlias","symbol","flags","SymbolFlags","Alias","warningCb","getTypeChecker","context","sourceFile","warning","fileName","emitWarning","visitVariableStatement","node","isVariableDeclaration","replaceImport","visitEachChild","visitToplevelNodes","isVariableStatement","typeChecker","name","isIdentifier","test","text","initializer","undefined","isArrowFunction","parameters","length","topArrowFnBody","body","isCallExpression","topArrowFnBodyExpr","expression","isPropertyAccessExpression","importCall","kind","SyntaxKind","ImportKeyword","arguments","isStringLiteral","warnAndBail","thenArrowFn","exportNameId","importStringLit","exportedSymbol","getSymbolAtLocation","getAliasedSymbol","exportedSymbolDecl","getDeclarations","relativePath","relative","dirname","getSourceFile","newImportString","forwardSlashPath","replace","replacementVisitor","createStringLiteral","createIdentifier"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.importFactory = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst path_1 = require(\"path\");\nconst ts = require(\"typescript\");\nconst utils_1 = require(\"../utils\");\n// Check if a ts.Symbol is an alias.\nconst isAlias = (symbol) => symbol.flags & ts.SymbolFlags.Alias;\n/**\n * Given this original source code:\n *\n * import { NgModule } from '@angular/core';\n * import { Routes, RouterModule } from '@angular/router';\n *\n * const routes: Routes = [{\n *   path: 'lazy',\n *   loadChildren: () => import('./lazy/lazy.module').then(m => m.LazyModule).\n * }];\n *\n * @NgModule({\n *   imports: [RouterModule.forRoot(routes)],\n *   exports: [RouterModule]\n * })\n * export class AppRoutingModule { }\n *\n * NGC (View Engine) will process it into:\n *\n * import { Routes } from '@angular/router';\n * const ɵ0 = () => import('./lazy/lazy.module').then(m => m.LazyModule);\n * const routes: Routes = [{\n *         path: 'lazy',\n *         loadChildren: ɵ0\n *     }];\n * export class AppRoutingModule {\n * }\n * export { ɵ0 };\n *\n * The importFactory transformation will only see the AST after it is process by NGC.\n * You can confirm this with the code below:\n *\n * const res = ts.createPrinter().printNode(ts.EmitHint.Unspecified, sourceFile, sourceFile);\n * console.log(`### Original source: \\n${sourceFile.text}\\n###`);\n * console.log(`### Current source: \\n${currentText}\\n###`);\n *\n * At this point it doesn't yet matter what the target (ES5/ES2015/etc) is, so the original\n * constructs, like `class` and arrow functions, still remain.\n *\n */\nfunction importFactory(warningCb, getTypeChecker) {\n    return (context) => {\n        // TODO(filipesilva): change the link to https://angular.io/guide/ivy once it is out.\n        return (sourceFile) => {\n            const warning = `\nFound 'loadChildren' with a non-string syntax in ${sourceFile.fileName} but could not transform it.\nMake sure it matches the format below:\n\nloadChildren: () => import('IMPORT_STRING').then(M => M.EXPORT_NAME)\n\nPlease note that only IMPORT_STRING, M, and EXPORT_NAME can be replaced in this format.\n\nVisit https://v8.angular.io/guide/ivy for more information on using Ivy.\n`;\n            const emitWarning = () => warningCb(warning);\n            const visitVariableStatement = (node) => {\n                if (ts.isVariableDeclaration(node)) {\n                    return replaceImport(node, context, emitWarning, sourceFile.fileName, getTypeChecker());\n                }\n                return ts.visitEachChild(node, visitVariableStatement, context);\n            };\n            const visitToplevelNodes = (node) => {\n                // We only care about finding variable declarations, which are found in this structure:\n                // VariableStatement -> VariableDeclarationList -> VariableDeclaration\n                if (ts.isVariableStatement(node)) {\n                    return ts.visitEachChild(node, visitVariableStatement, context);\n                }\n                // There's no point in recursing into anything but variable statements, so return the node.\n                return node;\n            };\n            return ts.visitEachChild(sourceFile, visitToplevelNodes, context);\n        };\n    };\n}\nexports.importFactory = importFactory;\nfunction replaceImport(node, context, emitWarning, fileName, typeChecker) {\n    // This ONLY matches the original source code format below:\n    // loadChildren: () => import('IMPORT_STRING').then(M => M.EXPORT_NAME)\n    // And expects that source code to be transformed by NGC (see comment for importFactory).\n    // It will not match nor alter variations, for instance:\n    // - not using arrow functions\n    // - using `await` instead of `then`\n    // - using a default export (https://github.com/angular/angular/issues/11402)\n    // The only parts that can change are the ones in caps: IMPORT_STRING, M and EXPORT_NAME.\n    // Exit early if the structure is not what we expect.\n    // ɵ0 = something\n    const name = node.name;\n    if (!(ts.isIdentifier(name)\n        && /ɵ\\d+/.test(name.text))) {\n        return node;\n    }\n    const initializer = node.initializer;\n    if (initializer === undefined) {\n        return node;\n    }\n    // ɵ0 = () => something\n    if (!(ts.isArrowFunction(initializer)\n        && initializer.parameters.length === 0)) {\n        return node;\n    }\n    // ɵ0 = () => something.then(something)\n    const topArrowFnBody = initializer.body;\n    if (!ts.isCallExpression(topArrowFnBody)) {\n        return node;\n    }\n    const topArrowFnBodyExpr = topArrowFnBody.expression;\n    if (!(ts.isPropertyAccessExpression(topArrowFnBodyExpr)\n        && ts.isIdentifier(topArrowFnBodyExpr.name))) {\n        return node;\n    }\n    if (topArrowFnBodyExpr.name.text != 'then') {\n        return node;\n    }\n    // ɵ0 = () => import('IMPORT_STRING').then(something)\n    const importCall = topArrowFnBodyExpr.expression;\n    if (!(ts.isCallExpression(importCall)\n        && importCall.expression.kind === ts.SyntaxKind.ImportKeyword\n        && importCall.arguments.length === 1\n        && ts.isStringLiteral(importCall.arguments[0]))) {\n        return node;\n    }\n    // Now that we know it's both `ɵ0` (generated by NGC) and a `import()`, start emitting a warning\n    // if the structure isn't as expected to help users identify unusable syntax.\n    const warnAndBail = () => {\n        emitWarning();\n        return node;\n    };\n    // ɵ0 = () => import('IMPORT_STRING').then(m => m.EXPORT_NAME)\n    if (!(topArrowFnBody.arguments.length === 1\n        && ts.isArrowFunction(topArrowFnBody.arguments[0]))) {\n        return warnAndBail();\n    }\n    const thenArrowFn = topArrowFnBody.arguments[0];\n    if (!(thenArrowFn.parameters.length === 1\n        && ts.isPropertyAccessExpression(thenArrowFn.body)\n        && ts.isIdentifier(thenArrowFn.body.name))) {\n        return warnAndBail();\n    }\n    // At this point we know what are the nodes we need to replace.\n    const exportNameId = thenArrowFn.body.name;\n    const importStringLit = importCall.arguments[0];\n    // Try to resolve the import. It might be a reexport from somewhere and the ngfactory will only\n    // be present next to the original module.\n    let exportedSymbol = typeChecker.getSymbolAtLocation(exportNameId);\n    if (!exportedSymbol) {\n        return warnAndBail();\n    }\n    // Named exports are also a declaration in the re-exporting module so we have to follow the\n    // re-exports to find the original symbol.\n    if (isAlias(exportedSymbol)) {\n        exportedSymbol = typeChecker.getAliasedSymbol(exportedSymbol);\n        if (!exportedSymbol) {\n            return warnAndBail();\n        }\n    }\n    // Find declarations of the original symbol so we can get their source file name.\n    const exportedSymbolDecl = exportedSymbol.getDeclarations();\n    if (!exportedSymbolDecl || exportedSymbolDecl.length === 0) {\n        return warnAndBail();\n    }\n    // Let's guess the first declaration is the one we want, because we don't have a better criteria.\n    // Get the relative path from the containing module to the imported module.\n    const relativePath = path_1.relative(path_1.dirname(fileName), exportedSymbolDecl[0].getSourceFile().fileName);\n    // node's `relative` call doesn't actually add `./` so we add it here.\n    // Also replace the 'ts' extension with just 'ngfactory'.\n    const newImportString = `./${utils_1.forwardSlashPath(relativePath)}`.replace(/ts$/, 'ngfactory');\n    // The easiest way to alter them is with a simple visitor.\n    const replacementVisitor = (node) => {\n        if (node === importStringLit) {\n            // Transform the import string.\n            return ts.createStringLiteral(newImportString);\n        }\n        else if (node === exportNameId) {\n            // Transform the export name.\n            return ts.createIdentifier(exportNameId.text + 'NgFactory');\n        }\n        return ts.visitEachChild(node, replacementVisitor, context);\n    };\n    return ts.visitEachChild(node, replacementVisitor, context);\n}\n"]},"metadata":{},"sourceType":"script"}