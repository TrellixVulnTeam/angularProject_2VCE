{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/annotations/src/component\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\", \"@angular/compiler-cli/src/ngtsc/metadata\", \"@angular/compiler-cli/src/ngtsc/partial_evaluator\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/transform\", \"@angular/compiler-cli/src/ngtsc/util/src/ts_source_map_bug_29300\", \"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\", \"@angular/compiler-cli/src/ngtsc/annotations/src/directive\", \"@angular/compiler-cli/src/ngtsc/annotations/src/factory\", \"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\", \"@angular/compiler-cli/src/ngtsc/annotations/src/ng_module\", \"@angular/compiler-cli/src/ngtsc/annotations/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ComponentDecoratorHandler = exports.ComponentSymbol = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var semantic_graph_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/ngtsc/metadata\");\n\n  var partial_evaluator_1 = require(\"@angular/compiler-cli/src/ngtsc/partial_evaluator\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var transform_1 = require(\"@angular/compiler-cli/src/ngtsc/transform\");\n\n  var ts_source_map_bug_29300_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/ts_source_map_bug_29300\");\n\n  var diagnostics_2 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\");\n\n  var directive_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/directive\");\n\n  var factory_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/factory\");\n\n  var metadata_2 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\");\n\n  var ng_module_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/ng_module\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/util\");\n\n  var EMPTY_MAP = new Map();\n  var EMPTY_ARRAY = [];\n  /**\n   * Represents an Angular component.\n   */\n\n  var ComponentSymbol =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ComponentSymbol, _super);\n\n    function ComponentSymbol() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.usedDirectives = [];\n      _this.usedPipes = [];\n      _this.isRemotelyScoped = false;\n      return _this;\n    }\n\n    ComponentSymbol.prototype.isEmitAffected = function (previousSymbol, publicApiAffected) {\n      if (!(previousSymbol instanceof ComponentSymbol)) {\n        return true;\n      } // Create an equality function that considers symbols equal if they represent the same\n      // declaration, but only if the symbol in the current compilation does not have its public API\n      // affected.\n\n\n      var isSymbolUnaffected = function isSymbolUnaffected(current, previous) {\n        return semantic_graph_1.isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);\n      }; // The emit of a component is affected if either of the following is true:\n      //  1. The component used to be remotely scoped but no longer is, or vice versa.\n      //  2. The list of used directives has changed or any of those directives have had their public\n      //     API changed. If the used directives have been reordered but not otherwise affected then\n      //     the component must still be re-emitted, as this may affect directive instantiation order.\n      //  3. The list of used pipes has changed, or any of those pipes have had their public API\n      //     changed.\n\n\n      return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped || !semantic_graph_1.isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) || !semantic_graph_1.isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);\n    };\n\n    ComponentSymbol.prototype.isTypeCheckBlockAffected = function (previousSymbol, typeCheckApiAffected) {\n      if (!(previousSymbol instanceof ComponentSymbol)) {\n        return true;\n      } // To verify that a used directive is not affected we need to verify that its full inheritance\n      // chain is not present in `typeCheckApiAffected`.\n\n\n      var isInheritanceChainAffected = function isInheritanceChainAffected(symbol) {\n        var currentSymbol = symbol;\n\n        while (currentSymbol instanceof directive_1.DirectiveSymbol) {\n          if (typeCheckApiAffected.has(currentSymbol)) {\n            return true;\n          }\n\n          currentSymbol = currentSymbol.baseClass;\n        }\n\n        return false;\n      }; // Create an equality function that considers directives equal if they represent the same\n      // declaration and if the symbol and all symbols it inherits from in the current compilation\n      // do not have their type-check API affected.\n\n\n      var isDirectiveUnaffected = function isDirectiveUnaffected(current, previous) {\n        return semantic_graph_1.isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);\n      }; // Create an equality function that considers pipes equal if they represent the same\n      // declaration and if the symbol in the current compilation does not have its type-check\n      // API affected.\n\n\n      var isPipeUnaffected = function isPipeUnaffected(current, previous) {\n        return semantic_graph_1.isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);\n      }; // The emit of a type-check block of a component is affected if either of the following is true:\n      //  1. The list of used directives has changed or any of those directives have had their\n      //     type-check API changed.\n      //  2. The list of used pipes has changed, or any of those pipes have had their type-check API\n      //     changed.\n\n\n      return !semantic_graph_1.isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) || !semantic_graph_1.isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);\n    };\n\n    return ComponentSymbol;\n  }(directive_1.DirectiveSymbol);\n\n  exports.ComponentSymbol = ComponentSymbol;\n  /**\n   * `DecoratorHandler` which handles the `@Component` annotation.\n   */\n\n  var ComponentDecoratorHandler =\n  /** @class */\n  function () {\n    function ComponentDecoratorHandler(reflector, evaluator, metaRegistry, metaReader, scopeReader, scopeRegistry, typeCheckScopeRegistry, resourceRegistry, isCore, resourceLoader, rootDirs, defaultPreserveWhitespaces, i18nUseExternalIds, enableI18nLegacyMessageIdFormat, usePoisonedData, i18nNormalizeLineEndingsInICUs, moduleResolver, cycleAnalyzer, cycleHandlingStrategy, refEmitter, depTracker, injectableRegistry, semanticDepGraphUpdater, annotateForClosureCompiler, perf) {\n      this.reflector = reflector;\n      this.evaluator = evaluator;\n      this.metaRegistry = metaRegistry;\n      this.metaReader = metaReader;\n      this.scopeReader = scopeReader;\n      this.scopeRegistry = scopeRegistry;\n      this.typeCheckScopeRegistry = typeCheckScopeRegistry;\n      this.resourceRegistry = resourceRegistry;\n      this.isCore = isCore;\n      this.resourceLoader = resourceLoader;\n      this.rootDirs = rootDirs;\n      this.defaultPreserveWhitespaces = defaultPreserveWhitespaces;\n      this.i18nUseExternalIds = i18nUseExternalIds;\n      this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\n      this.usePoisonedData = usePoisonedData;\n      this.i18nNormalizeLineEndingsInICUs = i18nNormalizeLineEndingsInICUs;\n      this.moduleResolver = moduleResolver;\n      this.cycleAnalyzer = cycleAnalyzer;\n      this.cycleHandlingStrategy = cycleHandlingStrategy;\n      this.refEmitter = refEmitter;\n      this.depTracker = depTracker;\n      this.injectableRegistry = injectableRegistry;\n      this.semanticDepGraphUpdater = semanticDepGraphUpdater;\n      this.annotateForClosureCompiler = annotateForClosureCompiler;\n      this.perf = perf;\n      this.literalCache = new Map();\n      this.elementSchemaRegistry = new compiler_1.DomElementSchemaRegistry();\n      /**\n       * During the asynchronous preanalyze phase, it's necessary to parse the template to extract\n       * any potential <link> tags which might need to be loaded. This cache ensures that work is not\n       * thrown away, and the parsed template is reused during the analyze phase.\n       */\n\n      this.preanalyzeTemplateCache = new Map();\n      this.precedence = transform_1.HandlerPrecedence.PRIMARY;\n      this.name = ComponentDecoratorHandler.name;\n    }\n\n    ComponentDecoratorHandler.prototype.detect = function (node, decorators) {\n      if (!decorators) {\n        return undefined;\n      }\n\n      var decorator = util_1.findAngularDecorator(decorators, 'Component', this.isCore);\n\n      if (decorator !== undefined) {\n        return {\n          trigger: decorator.node,\n          decorator: decorator,\n          metadata: decorator\n        };\n      } else {\n        return undefined;\n      }\n    };\n\n    ComponentDecoratorHandler.prototype.preanalyze = function (node, decorator) {\n      // In preanalyze, resource URLs associated with the component are asynchronously preloaded via\n      // the resourceLoader. This is the only time async operations are allowed for a component.\n      // These resources are:\n      //\n      // - the templateUrl, if there is one\n      // - any styleUrls if present\n      // - any stylesheets referenced from <link> tags in the template itself\n      //\n      // As a result of the last one, the template must be parsed as part of preanalysis to extract\n      // <link> tags, which may involve waiting for the templateUrl to be resolved first.\n      var _this = this; // If preloading isn't possible, then skip this step.\n\n\n      if (!this.resourceLoader.canPreload) {\n        return undefined;\n      }\n\n      var meta = this._resolveLiteral(decorator);\n\n      var component = reflection_1.reflectObjectLiteral(meta);\n      var containingFile = node.getSourceFile().fileName;\n\n      var resolveStyleUrl = function resolveStyleUrl(styleUrl) {\n        try {\n          var resourceUrl = _this.resourceLoader.resolve(styleUrl, containingFile);\n\n          return _this.resourceLoader.preload(resourceUrl);\n        } catch (_a) {\n          // Don't worry about failures to preload. We can handle this problem during analysis by\n          // producing a diagnostic.\n          return undefined;\n        }\n      }; // A Promise that waits for the template and all <link>ed styles within it to be preloaded.\n\n\n      var templateAndTemplateStyleResources = this._preloadAndParseTemplate(node, decorator, component, containingFile).then(function (template) {\n        if (template === null) {\n          return undefined;\n        }\n\n        return Promise.all(template.styleUrls.map(function (styleUrl) {\n          return resolveStyleUrl(styleUrl);\n        })).then(function () {\n          return undefined;\n        });\n      }); // Extract all the styleUrls in the decorator.\n\n\n      var componentStyleUrls = this._extractComponentStyleUrls(component);\n\n      if (componentStyleUrls === null) {\n        // A fast path exists if there are no styleUrls, to just wait for\n        // templateAndTemplateStyleResources.\n        return templateAndTemplateStyleResources;\n      } else {\n        // Wait for both the template and all styleUrl resources to resolve.\n        return Promise.all(tslib_1.__spread([templateAndTemplateStyleResources], componentStyleUrls.map(function (styleUrl) {\n          return resolveStyleUrl(styleUrl.url);\n        }))).then(function () {\n          return undefined;\n        });\n      }\n    };\n\n    ComponentDecoratorHandler.prototype.analyze = function (node, decorator, flags) {\n      var e_1, _a;\n\n      var _b;\n\n      if (flags === void 0) {\n        flags = transform_1.HandlerFlags.NONE;\n      }\n\n      this.perf.eventCount(perf_1.PerfEvent.AnalyzeComponent);\n      var containingFile = node.getSourceFile().fileName;\n      this.literalCache.delete(decorator);\n      var diagnostics;\n      var isPoisoned = false; // @Component inherits @Directive, so begin by extracting the @Directive metadata and building\n      // on it.\n\n      var directiveResult = directive_1.extractDirectiveMetadata(node, decorator, this.reflector, this.evaluator, this.isCore, flags, this.annotateForClosureCompiler, this.elementSchemaRegistry.getDefaultComponentElementName());\n\n      if (directiveResult === undefined) {\n        // `extractDirectiveMetadata` returns undefined when the @Directive has `jit: true`. In this\n        // case, compilation of the decorator is skipped. Returning an empty object signifies\n        // that no analysis was produced.\n        return {};\n      } // Next, read the `@Component`-specific fields.\n\n\n      var component = directiveResult.decorator,\n          metadata = directiveResult.metadata,\n          inputs = directiveResult.inputs,\n          outputs = directiveResult.outputs; // Go through the root directories for this project, and select the one with the smallest\n      // relative path representation.\n\n      var relativeContextFilePath = this.rootDirs.reduce(function (previous, rootDir) {\n        var candidate = file_system_1.relative(file_system_1.absoluteFrom(rootDir), file_system_1.absoluteFrom(containingFile));\n\n        if (previous === undefined || candidate.length < previous.length) {\n          return candidate;\n        } else {\n          return previous;\n        }\n      }, undefined); // Note that we could technically combine the `viewProvidersRequiringFactory` and\n      // `providersRequiringFactory` into a single set, but we keep the separate so that\n      // we can distinguish where an error is coming from when logging the diagnostics in `resolve`.\n\n      var viewProvidersRequiringFactory = null;\n      var providersRequiringFactory = null;\n      var wrappedViewProviders = null;\n\n      if (component.has('viewProviders')) {\n        var viewProviders = component.get('viewProviders');\n        viewProvidersRequiringFactory = util_1.resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);\n        wrappedViewProviders = new compiler_1.WrappedNodeExpr(this.annotateForClosureCompiler ? util_1.wrapFunctionExpressionsInParens(viewProviders) : viewProviders);\n      }\n\n      if (component.has('providers')) {\n        providersRequiringFactory = util_1.resolveProvidersRequiringFactory(component.get('providers'), this.reflector, this.evaluator);\n      } // Parse the template.\n      // If a preanalyze phase was executed, the template may already exist in parsed form, so check\n      // the preanalyzeTemplateCache.\n      // Extract a closure of the template parsing code so that it can be reparsed with different\n      // options if needed, like in the indexing pipeline.\n\n\n      var template;\n\n      if (this.preanalyzeTemplateCache.has(node)) {\n        // The template was parsed in preanalyze. Use it and delete it to save memory.\n        var preanalyzed = this.preanalyzeTemplateCache.get(node);\n        this.preanalyzeTemplateCache.delete(node);\n        template = preanalyzed;\n      } else {\n        var templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n        template = this.extractTemplate(node, templateDecl);\n      }\n\n      var templateResource = template.isInline ? {\n        path: null,\n        expression: component.get('template')\n      } : {\n        path: file_system_1.absoluteFrom(template.declaration.resolvedTemplateUrl),\n        expression: template.sourceMapping.node\n      }; // Figure out the set of styles. The ordering here is important: external resources (styleUrls)\n      // precede inline styles, and styles defined in the template override styles defined in the\n      // component.\n\n      var styles = [];\n\n      var styleResources = this._extractStyleResources(component, containingFile);\n\n      var styleUrls = tslib_1.__spread(this._extractComponentStyleUrls(component), this._extractTemplateStyleUrls(template));\n\n      try {\n        for (var styleUrls_1 = tslib_1.__values(styleUrls), styleUrls_1_1 = styleUrls_1.next(); !styleUrls_1_1.done; styleUrls_1_1 = styleUrls_1.next()) {\n          var styleUrl = styleUrls_1_1.value;\n\n          try {\n            var resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n            var resourceStr = this.resourceLoader.load(resourceUrl);\n            styles.push(resourceStr);\n\n            if (this.depTracker !== null) {\n              this.depTracker.addResourceDependency(node.getSourceFile(), file_system_1.absoluteFrom(resourceUrl));\n            }\n          } catch (_c) {\n            if (diagnostics === undefined) {\n              diagnostics = [];\n            }\n\n            var resourceType = styleUrl.source === 2\n            /* StylesheetFromDecorator */\n            ? 2\n            /* StylesheetFromDecorator */\n            : 1\n            /* StylesheetFromTemplate */\n            ;\n            diagnostics.push(this.makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType).toDiagnostic());\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (styleUrls_1_1 && !styleUrls_1_1.done && (_a = styleUrls_1.return)) _a.call(styleUrls_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var inlineStyles = null;\n\n      if (component.has('styles')) {\n        var litStyles = directive_1.parseFieldArrayValue(component, 'styles', this.evaluator);\n\n        if (litStyles !== null) {\n          inlineStyles = tslib_1.__spread(litStyles);\n          styles.push.apply(styles, tslib_1.__spread(litStyles));\n        }\n      }\n\n      if (template.styles.length > 0) {\n        styles.push.apply(styles, tslib_1.__spread(template.styles));\n      }\n\n      var encapsulation = this._resolveEnumValue(component, 'encapsulation', 'ViewEncapsulation') || 0;\n\n      var changeDetection = this._resolveEnumValue(component, 'changeDetection', 'ChangeDetectionStrategy');\n\n      var animations = null;\n\n      if (component.has('animations')) {\n        animations = new compiler_1.WrappedNodeExpr(component.get('animations'));\n      }\n\n      var output = {\n        analysis: {\n          baseClass: util_1.readBaseClass(node, this.reflector, this.evaluator),\n          inputs: inputs,\n          outputs: outputs,\n          meta: tslib_1.__assign(tslib_1.__assign({}, metadata), {\n            template: {\n              nodes: template.nodes,\n              ngContentSelectors: template.ngContentSelectors\n            },\n            encapsulation: encapsulation,\n            interpolation: (_b = template.interpolationConfig) !== null && _b !== void 0 ? _b : compiler_1.DEFAULT_INTERPOLATION_CONFIG,\n            styles: styles,\n            // These will be replaced during the compilation step, after all `NgModule`s have been\n            // analyzed and the full compilation scope for the component can be realized.\n            animations: animations,\n            viewProviders: wrappedViewProviders,\n            i18nUseExternalIds: this.i18nUseExternalIds,\n            relativeContextFilePath: relativeContextFilePath\n          }),\n          typeCheckMeta: metadata_1.extractDirectiveTypeCheckMeta(node, inputs, this.reflector),\n          metadataStmt: metadata_2.generateSetClassMetadataCall(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n          template: template,\n          providersRequiringFactory: providersRequiringFactory,\n          viewProvidersRequiringFactory: viewProvidersRequiringFactory,\n          inlineStyles: inlineStyles,\n          styleUrls: styleUrls,\n          resources: {\n            styles: styleResources,\n            template: templateResource\n          },\n          isPoisoned: isPoisoned\n        },\n        diagnostics: diagnostics\n      };\n\n      if (changeDetection !== null) {\n        output.analysis.meta.changeDetection = changeDetection;\n      }\n\n      return output;\n    };\n\n    ComponentDecoratorHandler.prototype.symbol = function (node, analysis) {\n      var typeParameters = semantic_graph_1.extractSemanticTypeParameters(node);\n      return new ComponentSymbol(node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs, analysis.typeCheckMeta, typeParameters);\n    };\n\n    ComponentDecoratorHandler.prototype.register = function (node, analysis) {\n      // Register this component's information with the `MetadataRegistry`. This ensures that\n      // the information about the component is available during the compile() phase.\n      var ref = new imports_1.Reference(node);\n      this.metaRegistry.registerDirectiveMetadata(tslib_1.__assign(tslib_1.__assign({\n        ref: ref,\n        name: node.name.text,\n        selector: analysis.meta.selector,\n        exportAs: analysis.meta.exportAs,\n        inputs: analysis.inputs,\n        outputs: analysis.outputs,\n        queries: analysis.meta.queries.map(function (query) {\n          return query.propertyName;\n        }),\n        isComponent: true,\n        baseClass: analysis.baseClass\n      }, analysis.typeCheckMeta), {\n        isPoisoned: analysis.isPoisoned,\n        isStructural: false\n      }));\n      this.resourceRegistry.registerResources(analysis.resources, node);\n      this.injectableRegistry.registerInjectable(node);\n    };\n\n    ComponentDecoratorHandler.prototype.index = function (context, node, analysis) {\n      var e_2, _a;\n\n      if (analysis.isPoisoned && !this.usePoisonedData) {\n        return null;\n      }\n\n      var scope = this.scopeReader.getScopeForComponent(node);\n      var selector = analysis.meta.selector;\n      var matcher = new compiler_1.SelectorMatcher();\n\n      if (scope !== null) {\n        if ((scope.compilation.isPoisoned || scope.exported.isPoisoned) && !this.usePoisonedData) {\n          // Don't bother indexing components which had erroneous scopes, unless specifically\n          // requested.\n          return null;\n        }\n\n        try {\n          for (var _b = tslib_1.__values(scope.compilation.directives), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var directive = _c.value;\n\n            if (directive.selector !== null) {\n              matcher.addSelectables(compiler_1.CssSelector.parse(directive.selector), directive);\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n\n      var binder = new compiler_1.R3TargetBinder(matcher);\n      var boundTemplate = binder.bind({\n        template: analysis.template.diagNodes\n      });\n      context.addComponent({\n        declaration: node,\n        selector: selector,\n        boundTemplate: boundTemplate,\n        templateMeta: {\n          isInline: analysis.template.isInline,\n          file: analysis.template.file\n        }\n      });\n    };\n\n    ComponentDecoratorHandler.prototype.typeCheck = function (ctx, node, meta) {\n      if (this.typeCheckScopeRegistry === null || !ts.isClassDeclaration(node)) {\n        return;\n      }\n\n      if (meta.isPoisoned && !this.usePoisonedData) {\n        return;\n      }\n\n      var scope = this.typeCheckScopeRegistry.getTypeCheckScope(node);\n\n      if (scope.isPoisoned && !this.usePoisonedData) {\n        // Don't type-check components that had errors in their scopes, unless requested.\n        return;\n      }\n\n      var binder = new compiler_1.R3TargetBinder(scope.matcher);\n      ctx.addTemplate(new imports_1.Reference(node), binder, meta.template.diagNodes, scope.pipes, scope.schemas, meta.template.sourceMapping, meta.template.file, meta.template.errors);\n    };\n\n    ComponentDecoratorHandler.prototype.resolve = function (node, analysis, symbol) {\n      var e_3, _a, e_4, _b, e_5, _c, e_6, _d, e_7, _e, e_8, _f, e_9, _g, e_10, _h, e_11, _j;\n\n      var _this = this;\n\n      if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof imports_1.Reference) {\n        symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n      }\n\n      if (analysis.isPoisoned && !this.usePoisonedData) {\n        return {};\n      }\n\n      var context = node.getSourceFile(); // Check whether this component was registered with an NgModule. If so, it should be compiled\n      // under that module's compilation scope.\n\n      var scope = this.scopeReader.getScopeForComponent(node);\n      var metadata = analysis.meta;\n      var data = {\n        directives: EMPTY_ARRAY,\n        pipes: EMPTY_MAP,\n        declarationListEmitMode: 0\n        /* Direct */\n\n      };\n\n      if (scope !== null && (!scope.compilation.isPoisoned || this.usePoisonedData)) {\n        var matcher = new compiler_1.SelectorMatcher();\n\n        try {\n          for (var _k = tslib_1.__values(scope.compilation.directives), _l = _k.next(); !_l.done; _l = _k.next()) {\n            var dir = _l.value;\n\n            if (dir.selector !== null) {\n              matcher.addSelectables(compiler_1.CssSelector.parse(dir.selector), dir);\n            }\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_l && !_l.done && (_a = _k.return)) _a.call(_k);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n\n        var pipes = new Map();\n\n        try {\n          for (var _m = tslib_1.__values(scope.compilation.pipes), _o = _m.next(); !_o.done; _o = _m.next()) {\n            var pipe = _o.value;\n            pipes.set(pipe.name, pipe.ref);\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (_o && !_o.done && (_b = _m.return)) _b.call(_m);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        } // Next, the component template AST is bound using the R3TargetBinder. This produces a\n        // BoundTarget, which is similar to a ts.TypeChecker.\n\n\n        var binder = new compiler_1.R3TargetBinder(matcher);\n        var bound = binder.bind({\n          template: metadata.template.nodes\n        });\n        var usedDirectives = bound.getUsedDirectives().map(function (directive) {\n          var type = _this.refEmitter.emit(directive.ref, context);\n\n          return {\n            ref: directive.ref,\n            type: type.expression,\n            importedFile: type.importedFile,\n            selector: directive.selector,\n            inputs: directive.inputs.propertyNames,\n            outputs: directive.outputs.propertyNames,\n            exportAs: directive.exportAs,\n            isComponent: directive.isComponent\n          };\n        });\n        var usedPipes = [];\n\n        try {\n          for (var _p = tslib_1.__values(bound.getUsedPipes()), _q = _p.next(); !_q.done; _q = _p.next()) {\n            var pipeName = _q.value;\n\n            if (!pipes.has(pipeName)) {\n              continue;\n            }\n\n            var pipe = pipes.get(pipeName);\n            var type = this.refEmitter.emit(pipe, context);\n            usedPipes.push({\n              ref: pipe,\n              pipeName: pipeName,\n              expression: type.expression,\n              importedFile: type.importedFile\n            });\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (_q && !_q.done && (_c = _p.return)) _c.call(_p);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n\n        if (this.semanticDepGraphUpdater !== null) {\n          symbol.usedDirectives = usedDirectives.map(function (dir) {\n            return _this.semanticDepGraphUpdater.getSemanticReference(dir.ref.node, dir.type);\n          });\n          symbol.usedPipes = usedPipes.map(function (pipe) {\n            return _this.semanticDepGraphUpdater.getSemanticReference(pipe.ref.node, pipe.expression);\n          });\n        } // Scan through the directives/pipes actually used in the template and check whether any\n        // import which needs to be generated would create a cycle.\n\n\n        var cyclesFromDirectives = new Map();\n\n        try {\n          for (var usedDirectives_1 = tslib_1.__values(usedDirectives), usedDirectives_1_1 = usedDirectives_1.next(); !usedDirectives_1_1.done; usedDirectives_1_1 = usedDirectives_1.next()) {\n            var usedDirective = usedDirectives_1_1.value;\n\n            var cycle = this._checkForCyclicImport(usedDirective.importedFile, usedDirective.type, context);\n\n            if (cycle !== null) {\n              cyclesFromDirectives.set(usedDirective, cycle);\n            }\n          }\n        } catch (e_6_1) {\n          e_6 = {\n            error: e_6_1\n          };\n        } finally {\n          try {\n            if (usedDirectives_1_1 && !usedDirectives_1_1.done && (_d = usedDirectives_1.return)) _d.call(usedDirectives_1);\n          } finally {\n            if (e_6) throw e_6.error;\n          }\n        }\n\n        var cyclesFromPipes = new Map();\n\n        try {\n          for (var usedPipes_1 = tslib_1.__values(usedPipes), usedPipes_1_1 = usedPipes_1.next(); !usedPipes_1_1.done; usedPipes_1_1 = usedPipes_1.next()) {\n            var usedPipe = usedPipes_1_1.value;\n\n            var cycle = this._checkForCyclicImport(usedPipe.importedFile, usedPipe.expression, context);\n\n            if (cycle !== null) {\n              cyclesFromPipes.set(usedPipe, cycle);\n            }\n          }\n        } catch (e_7_1) {\n          e_7 = {\n            error: e_7_1\n          };\n        } finally {\n          try {\n            if (usedPipes_1_1 && !usedPipes_1_1.done && (_e = usedPipes_1.return)) _e.call(usedPipes_1);\n          } finally {\n            if (e_7) throw e_7.error;\n          }\n        }\n\n        var cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;\n\n        if (!cycleDetected) {\n          try {\n            // No cycle was detected. Record the imports that need to be created in the cycle detector\n            // so that future cyclic import checks consider their production.\n            for (var usedDirectives_2 = tslib_1.__values(usedDirectives), usedDirectives_2_1 = usedDirectives_2.next(); !usedDirectives_2_1.done; usedDirectives_2_1 = usedDirectives_2.next()) {\n              var _r = usedDirectives_2_1.value,\n                  type = _r.type,\n                  importedFile = _r.importedFile;\n\n              this._recordSyntheticImport(importedFile, type, context);\n            }\n          } catch (e_8_1) {\n            e_8 = {\n              error: e_8_1\n            };\n          } finally {\n            try {\n              if (usedDirectives_2_1 && !usedDirectives_2_1.done && (_f = usedDirectives_2.return)) _f.call(usedDirectives_2);\n            } finally {\n              if (e_8) throw e_8.error;\n            }\n          }\n\n          try {\n            for (var usedPipes_2 = tslib_1.__values(usedPipes), usedPipes_2_1 = usedPipes_2.next(); !usedPipes_2_1.done; usedPipes_2_1 = usedPipes_2.next()) {\n              var _s = usedPipes_2_1.value,\n                  expression = _s.expression,\n                  importedFile = _s.importedFile;\n\n              this._recordSyntheticImport(importedFile, expression, context);\n            }\n          } catch (e_9_1) {\n            e_9 = {\n              error: e_9_1\n            };\n          } finally {\n            try {\n              if (usedPipes_2_1 && !usedPipes_2_1.done && (_g = usedPipes_2.return)) _g.call(usedPipes_2);\n            } finally {\n              if (e_9) throw e_9.error;\n            }\n          } // Check whether the directive/pipe arrays in ɵcmp need to be wrapped in closures.\n          // This is required if any directive/pipe reference is to a declaration in the same file\n          // but declared after this component.\n\n\n          var wrapDirectivesAndPipesInClosure = usedDirectives.some(function (dir) {\n            return util_1.isExpressionForwardReference(dir.type, node.name, context);\n          }) || usedPipes.some(function (pipe) {\n            return util_1.isExpressionForwardReference(pipe.expression, node.name, context);\n          });\n          data.directives = usedDirectives;\n          data.pipes = new Map(usedPipes.map(function (pipe) {\n            return [pipe.pipeName, pipe.expression];\n          }));\n          data.declarationListEmitMode = wrapDirectivesAndPipesInClosure ? 1\n          /* Closure */\n          : 0\n          /* Direct */\n          ;\n        } else {\n          if (this.cycleHandlingStrategy === 0\n          /* UseRemoteScoping */\n          ) {\n              // Declaring the directiveDefs/pipeDefs arrays directly would require imports that would\n              // create a cycle. Instead, mark this component as requiring remote scoping, so that the\n              // NgModule file will take care of setting the directives for the component.\n              this.scopeRegistry.setComponentRemoteScope(node, usedDirectives.map(function (dir) {\n                return dir.ref;\n              }), usedPipes.map(function (pipe) {\n                return pipe.ref;\n              }));\n              symbol.isRemotelyScoped = true; // If a semantic graph is being tracked, record the fact that this component is remotely\n              // scoped with the declaring NgModule symbol as the NgModule's emit becomes dependent on\n              // the directive/pipe usages of this component.\n\n              if (this.semanticDepGraphUpdater !== null) {\n                var moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);\n\n                if (!(moduleSymbol instanceof ng_module_1.NgModuleSymbol)) {\n                  throw new Error(\"AssertionError: Expected \" + scope.ngModule.name + \" to be an NgModuleSymbol.\");\n                }\n\n                moduleSymbol.addRemotelyScopedComponent(symbol, symbol.usedDirectives, symbol.usedPipes);\n              }\n            } else {\n            // We are not able to handle this cycle so throw an error.\n            var relatedMessages = [];\n\n            try {\n              for (var cyclesFromDirectives_1 = tslib_1.__values(cyclesFromDirectives), cyclesFromDirectives_1_1 = cyclesFromDirectives_1.next(); !cyclesFromDirectives_1_1.done; cyclesFromDirectives_1_1 = cyclesFromDirectives_1.next()) {\n                var _t = tslib_1.__read(cyclesFromDirectives_1_1.value, 2),\n                    dir = _t[0],\n                    cycle = _t[1];\n\n                relatedMessages.push(makeCyclicImportInfo(dir.ref, dir.isComponent ? 'component' : 'directive', cycle));\n              }\n            } catch (e_10_1) {\n              e_10 = {\n                error: e_10_1\n              };\n            } finally {\n              try {\n                if (cyclesFromDirectives_1_1 && !cyclesFromDirectives_1_1.done && (_h = cyclesFromDirectives_1.return)) _h.call(cyclesFromDirectives_1);\n              } finally {\n                if (e_10) throw e_10.error;\n              }\n            }\n\n            try {\n              for (var cyclesFromPipes_1 = tslib_1.__values(cyclesFromPipes), cyclesFromPipes_1_1 = cyclesFromPipes_1.next(); !cyclesFromPipes_1_1.done; cyclesFromPipes_1_1 = cyclesFromPipes_1.next()) {\n                var _u = tslib_1.__read(cyclesFromPipes_1_1.value, 2),\n                    pipe = _u[0],\n                    cycle = _u[1];\n\n                relatedMessages.push(makeCyclicImportInfo(pipe.ref, 'pipe', cycle));\n              }\n            } catch (e_11_1) {\n              e_11 = {\n                error: e_11_1\n              };\n            } finally {\n              try {\n                if (cyclesFromPipes_1_1 && !cyclesFromPipes_1_1.done && (_j = cyclesFromPipes_1.return)) _j.call(cyclesFromPipes_1);\n              } finally {\n                if (e_11) throw e_11.error;\n              }\n            }\n\n            throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.IMPORT_CYCLE_DETECTED, node, 'One or more import cycles would need to be created to compile this component, ' + 'which is not supported by the current compiler configuration.', relatedMessages);\n          }\n        }\n      }\n\n      var diagnostics = [];\n\n      if (analysis.providersRequiringFactory !== null && analysis.meta.providers instanceof compiler_1.WrappedNodeExpr) {\n        var providerDiagnostics = diagnostics_2.getProviderDiagnostics(analysis.providersRequiringFactory, analysis.meta.providers.node, this.injectableRegistry);\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(providerDiagnostics));\n      }\n\n      if (analysis.viewProvidersRequiringFactory !== null && analysis.meta.viewProviders instanceof compiler_1.WrappedNodeExpr) {\n        var viewProviderDiagnostics = diagnostics_2.getProviderDiagnostics(analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders.node, this.injectableRegistry);\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(viewProviderDiagnostics));\n      }\n\n      var directiveDiagnostics = diagnostics_2.getDirectiveDiagnostics(node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, 'Component');\n\n      if (directiveDiagnostics !== null) {\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(directiveDiagnostics));\n      }\n\n      if (diagnostics.length > 0) {\n        return {\n          diagnostics: diagnostics\n        };\n      }\n\n      return {\n        data: data\n      };\n    };\n\n    ComponentDecoratorHandler.prototype.updateResources = function (node, analysis) {\n      var e_12, _a, e_13, _b, e_14, _c;\n\n      var containingFile = node.getSourceFile().fileName; // If the template is external, re-parse it.\n\n      var templateDecl = analysis.template.declaration;\n\n      if (!templateDecl.isInline) {\n        analysis.template = this.extractTemplate(node, templateDecl);\n      } // Update any external stylesheets and rebuild the combined 'styles' list.\n      // TODO(alxhub): write tests for styles when the primary compiler uses the updateResources path\n\n\n      var styles = [];\n\n      if (analysis.styleUrls !== null) {\n        try {\n          for (var _d = tslib_1.__values(analysis.styleUrls), _e = _d.next(); !_e.done; _e = _d.next()) {\n            var styleUrl = _e.value;\n\n            try {\n              var resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n              var styleText = this.resourceLoader.load(resolvedStyleUrl);\n              styles.push(styleText);\n            } catch (e) {// Resource resolve failures should already be in the diagnostics list from the analyze\n              // stage. We do not need to do anything with them when updating resources.\n            }\n          }\n        } catch (e_12_1) {\n          e_12 = {\n            error: e_12_1\n          };\n        } finally {\n          try {\n            if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n          } finally {\n            if (e_12) throw e_12.error;\n          }\n        }\n      }\n\n      if (analysis.inlineStyles !== null) {\n        try {\n          for (var _f = tslib_1.__values(analysis.inlineStyles), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var styleText = _g.value;\n            styles.push(styleText);\n          }\n        } catch (e_13_1) {\n          e_13 = {\n            error: e_13_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_13) throw e_13.error;\n          }\n        }\n      }\n\n      try {\n        for (var _h = tslib_1.__values(analysis.template.styles), _j = _h.next(); !_j.done; _j = _h.next()) {\n          var styleText = _j.value;\n          styles.push(styleText);\n        }\n      } catch (e_14_1) {\n        e_14 = {\n          error: e_14_1\n        };\n      } finally {\n        try {\n          if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\n        } finally {\n          if (e_14) throw e_14.error;\n        }\n      }\n\n      analysis.meta.styles = styles;\n    };\n\n    ComponentDecoratorHandler.prototype.compileFull = function (node, analysis, resolution, pool) {\n      if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n        return [];\n      }\n\n      var meta = tslib_1.__assign(tslib_1.__assign({}, analysis.meta), resolution);\n\n      var def = compiler_1.compileComponentFromMetadata(meta, pool, compiler_1.makeBindingParser());\n      return this.compileComponent(analysis, def);\n    };\n\n    ComponentDecoratorHandler.prototype.compilePartial = function (node, analysis, resolution) {\n      if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n        return [];\n      }\n\n      var meta = tslib_1.__assign(tslib_1.__assign({}, analysis.meta), resolution);\n\n      var def = compiler_1.compileDeclareComponentFromMetadata(meta, analysis.template);\n      return this.compileComponent(analysis, def);\n    };\n\n    ComponentDecoratorHandler.prototype.compileComponent = function (analysis, _a) {\n      var initializer = _a.expression,\n          type = _a.type;\n      var factoryRes = factory_1.compileNgFactoryDefField(tslib_1.__assign(tslib_1.__assign({}, analysis.meta), {\n        injectFn: compiler_1.Identifiers.directiveInject,\n        target: compiler_1.R3FactoryTarget.Component\n      }));\n\n      if (analysis.metadataStmt !== null) {\n        factoryRes.statements.push(analysis.metadataStmt);\n      }\n\n      return [factoryRes, {\n        name: 'ɵcmp',\n        initializer: initializer,\n        statements: [],\n        type: type\n      }];\n    };\n\n    ComponentDecoratorHandler.prototype._resolveLiteral = function (decorator) {\n      if (this.literalCache.has(decorator)) {\n        return this.literalCache.get(decorator);\n      }\n\n      if (decorator.args === null || decorator.args.length !== 1) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, reflection_1.Decorator.nodeForError(decorator), \"Incorrect number of arguments to @Component decorator\");\n      }\n\n      var meta = util_1.unwrapExpression(decorator.args[0]);\n\n      if (!ts.isObjectLiteralExpression(meta)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, \"Decorator argument must be literal.\");\n      }\n\n      this.literalCache.set(decorator, meta);\n      return meta;\n    };\n\n    ComponentDecoratorHandler.prototype._resolveEnumValue = function (component, field, enumSymbolName) {\n      var resolved = null;\n\n      if (component.has(field)) {\n        var expr = component.get(field);\n        var value = this.evaluator.evaluate(expr);\n\n        if (value instanceof partial_evaluator_1.EnumValue && util_1.isAngularCoreReference(value.enumRef, enumSymbolName)) {\n          resolved = value.resolved;\n        } else {\n          throw diagnostics_2.createValueHasWrongTypeError(expr, value, field + \" must be a member of \" + enumSymbolName + \" enum from @angular/core\");\n        }\n      }\n\n      return resolved;\n    };\n\n    ComponentDecoratorHandler.prototype._extractComponentStyleUrls = function (component) {\n      if (!component.has('styleUrls')) {\n        return [];\n      }\n\n      return this._extractStyleUrlsFromExpression(component.get('styleUrls'));\n    };\n\n    ComponentDecoratorHandler.prototype._extractStyleUrlsFromExpression = function (styleUrlsExpr) {\n      var e_15, _a, e_16, _b;\n\n      var styleUrls = [];\n\n      if (ts.isArrayLiteralExpression(styleUrlsExpr)) {\n        try {\n          for (var _c = tslib_1.__values(styleUrlsExpr.elements), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var styleUrlExpr = _d.value;\n\n            if (ts.isSpreadElement(styleUrlExpr)) {\n              styleUrls.push.apply(styleUrls, tslib_1.__spread(this._extractStyleUrlsFromExpression(styleUrlExpr.expression)));\n            } else {\n              var styleUrl = this.evaluator.evaluate(styleUrlExpr);\n\n              if (typeof styleUrl !== 'string') {\n                throw diagnostics_2.createValueHasWrongTypeError(styleUrlExpr, styleUrl, 'styleUrl must be a string');\n              }\n\n              styleUrls.push({\n                url: styleUrl,\n                source: 2\n                /* StylesheetFromDecorator */\n                ,\n                nodeForError: styleUrlExpr\n              });\n            }\n          }\n        } catch (e_15_1) {\n          e_15 = {\n            error: e_15_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_15) throw e_15.error;\n          }\n        }\n      } else {\n        var evaluatedStyleUrls = this.evaluator.evaluate(styleUrlsExpr);\n\n        if (!isStringArray(evaluatedStyleUrls)) {\n          throw diagnostics_2.createValueHasWrongTypeError(styleUrlsExpr, evaluatedStyleUrls, 'styleUrls must be an array of strings');\n        }\n\n        try {\n          for (var evaluatedStyleUrls_1 = tslib_1.__values(evaluatedStyleUrls), evaluatedStyleUrls_1_1 = evaluatedStyleUrls_1.next(); !evaluatedStyleUrls_1_1.done; evaluatedStyleUrls_1_1 = evaluatedStyleUrls_1.next()) {\n            var styleUrl = evaluatedStyleUrls_1_1.value;\n            styleUrls.push({\n              url: styleUrl,\n              source: 2\n              /* StylesheetFromDecorator */\n              ,\n              nodeForError: styleUrlsExpr\n            });\n          }\n        } catch (e_16_1) {\n          e_16 = {\n            error: e_16_1\n          };\n        } finally {\n          try {\n            if (evaluatedStyleUrls_1_1 && !evaluatedStyleUrls_1_1.done && (_b = evaluatedStyleUrls_1.return)) _b.call(evaluatedStyleUrls_1);\n          } finally {\n            if (e_16) throw e_16.error;\n          }\n        }\n      }\n\n      return styleUrls;\n    };\n\n    ComponentDecoratorHandler.prototype._extractStyleResources = function (component, containingFile) {\n      var e_17, _a, e_18, _b;\n\n      var styles = new Set();\n\n      function stringLiteralElements(array) {\n        return array.elements.filter(function (e) {\n          return ts.isStringLiteralLike(e);\n        });\n      } // If styleUrls is a literal array, process each resource url individually and\n      // register ones that are string literals.\n\n\n      var styleUrlsExpr = component.get('styleUrls');\n\n      if (styleUrlsExpr !== undefined && ts.isArrayLiteralExpression(styleUrlsExpr)) {\n        try {\n          for (var _c = tslib_1.__values(stringLiteralElements(styleUrlsExpr)), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var expression = _d.value;\n\n            try {\n              var resourceUrl = this.resourceLoader.resolve(expression.text, containingFile);\n              styles.add({\n                path: file_system_1.absoluteFrom(resourceUrl),\n                expression: expression\n              });\n            } catch (_e) {// Errors in style resource extraction do not need to be handled here. We will produce\n              // diagnostics for each one that fails in the analysis, after we evaluate the `styleUrls`\n              // expression to determine _all_ style resources, not just the string literals.\n            }\n          }\n        } catch (e_17_1) {\n          e_17 = {\n            error: e_17_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_17) throw e_17.error;\n          }\n        }\n      }\n\n      var stylesExpr = component.get('styles');\n\n      if (stylesExpr !== undefined && ts.isArrayLiteralExpression(stylesExpr)) {\n        try {\n          for (var _f = tslib_1.__values(stringLiteralElements(stylesExpr)), _g = _f.next(); !_g.done; _g = _f.next()) {\n            var expression = _g.value;\n            styles.add({\n              path: null,\n              expression: expression\n            });\n          }\n        } catch (e_18_1) {\n          e_18 = {\n            error: e_18_1\n          };\n        } finally {\n          try {\n            if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n          } finally {\n            if (e_18) throw e_18.error;\n          }\n        }\n      }\n\n      return styles;\n    };\n\n    ComponentDecoratorHandler.prototype._preloadAndParseTemplate = function (node, decorator, component, containingFile) {\n      var _this = this;\n\n      if (component.has('templateUrl')) {\n        // Extract the templateUrl and preload it.\n        var templateUrlExpr = component.get('templateUrl');\n        var templateUrl = this.evaluator.evaluate(templateUrlExpr);\n\n        if (typeof templateUrl !== 'string') {\n          throw diagnostics_2.createValueHasWrongTypeError(templateUrlExpr, templateUrl, 'templateUrl must be a string');\n        }\n\n        try {\n          var resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n          var templatePromise = this.resourceLoader.preload(resourceUrl); // If the preload worked, then actually load and parse the template, and wait for any style\n          // URLs to resolve.\n\n          if (templatePromise !== undefined) {\n            return templatePromise.then(function () {\n              var templateDecl = _this.parseTemplateDeclaration(decorator, component, containingFile);\n\n              var template = _this.extractTemplate(node, templateDecl);\n\n              _this.preanalyzeTemplateCache.set(node, template);\n\n              return template;\n            });\n          } else {\n            return Promise.resolve(null);\n          }\n        } catch (e) {\n          throw this.makeResourceNotFoundError(templateUrl, templateUrlExpr, 0\n          /* Template */\n          );\n        }\n      } else {\n        var templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n        var template = this.extractTemplate(node, templateDecl);\n        this.preanalyzeTemplateCache.set(node, template);\n        return Promise.resolve(template);\n      }\n    };\n\n    ComponentDecoratorHandler.prototype.extractTemplate = function (node, template) {\n      if (template.isInline) {\n        var templateStr = void 0;\n        var templateLiteral = null;\n        var templateUrl = '';\n        var templateRange = null;\n        var sourceMapping = void 0;\n        var escapedString = false; // We only support SourceMaps for inline templates that are simple string literals.\n\n        if (ts.isStringLiteral(template.expression) || ts.isNoSubstitutionTemplateLiteral(template.expression)) {\n          // the start and end of the `templateExpr` node includes the quotation marks, which we must\n          // strip\n          templateRange = getTemplateRange(template.expression);\n          templateStr = template.expression.getSourceFile().text;\n          templateLiteral = template.expression;\n          templateUrl = template.templateUrl;\n          escapedString = true;\n          sourceMapping = {\n            type: 'direct',\n            node: template.expression\n          };\n        } else {\n          var resolvedTemplate = this.evaluator.evaluate(template.expression);\n\n          if (typeof resolvedTemplate !== 'string') {\n            throw diagnostics_2.createValueHasWrongTypeError(template.expression, resolvedTemplate, 'template must be a string');\n          }\n\n          templateStr = resolvedTemplate;\n          sourceMapping = {\n            type: 'indirect',\n            node: template.expression,\n            componentClass: node,\n            template: templateStr\n          };\n        }\n\n        return tslib_1.__assign(tslib_1.__assign({}, this._parseTemplate(template, templateStr, templateRange, escapedString)), {\n          sourceMapping: sourceMapping,\n          declaration: template\n        });\n      } else {\n        var templateStr = this.resourceLoader.load(template.resolvedTemplateUrl);\n\n        if (this.depTracker !== null) {\n          this.depTracker.addResourceDependency(node.getSourceFile(), file_system_1.absoluteFrom(template.resolvedTemplateUrl));\n        }\n\n        return tslib_1.__assign(tslib_1.__assign({}, this._parseTemplate(template, templateStr,\n        /* templateRange */\n        null,\n        /* escapedString */\n        false)), {\n          sourceMapping: {\n            type: 'external',\n            componentClass: node,\n            // TODO(alxhub): TS in g3 is unable to make this inference on its own, so cast it here\n            // until g3 is able to figure this out.\n            node: template.templateUrlExpression,\n            template: templateStr,\n            templateUrl: template.resolvedTemplateUrl\n          },\n          declaration: template\n        });\n      }\n    };\n\n    ComponentDecoratorHandler.prototype._parseTemplate = function (template, templateStr, templateRange, escapedString) {\n      // We always normalize line endings if the template has been escaped (i.e. is inline).\n      var i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;\n      var parsedTemplate = compiler_1.parseTemplate(templateStr, template.sourceMapUrl, {\n        preserveWhitespaces: template.preserveWhitespaces,\n        interpolationConfig: template.interpolationConfig,\n        range: templateRange !== null && templateRange !== void 0 ? templateRange : undefined,\n        escapedString: escapedString,\n        enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n        i18nNormalizeLineEndingsInICUs: i18nNormalizeLineEndingsInICUs,\n        isInline: template.isInline,\n        alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData\n      }); // Unfortunately, the primary parse of the template above may not contain accurate source map\n      // information. If used directly, it would result in incorrect code locations in template\n      // errors, etc. There are three main problems:\n      //\n      // 1. `preserveWhitespaces: false` annihilates the correctness of template source mapping, as\n      //    the whitespace transformation changes the contents of HTML text nodes before they're\n      //    parsed into Angular expressions.\n      // 2. `preserveLineEndings: false` causes growing misalignments in templates that use '\\r\\n'\n      //    line endings, by normalizing them to '\\n'.\n      // 3. By default, the template parser strips leading trivia characters (like spaces, tabs, and\n      //    newlines). This also destroys source mapping information.\n      //\n      // In order to guarantee the correctness of diagnostics, templates are parsed a second time\n      // with the above options set to preserve source mappings.\n\n      var diagNodes = compiler_1.parseTemplate(templateStr, template.sourceMapUrl, {\n        preserveWhitespaces: true,\n        preserveLineEndings: true,\n        interpolationConfig: template.interpolationConfig,\n        range: templateRange !== null && templateRange !== void 0 ? templateRange : undefined,\n        escapedString: escapedString,\n        enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n        i18nNormalizeLineEndingsInICUs: i18nNormalizeLineEndingsInICUs,\n        leadingTriviaChars: [],\n        isInline: template.isInline,\n        alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData\n      }).nodes;\n      return tslib_1.__assign(tslib_1.__assign({}, parsedTemplate), {\n        diagNodes: diagNodes,\n        template: template.isInline ? new compiler_1.WrappedNodeExpr(template.expression) : templateStr,\n        templateUrl: template.resolvedTemplateUrl,\n        isInline: template.isInline,\n        file: new compiler_1.ParseSourceFile(templateStr, template.resolvedTemplateUrl)\n      });\n    };\n\n    ComponentDecoratorHandler.prototype.parseTemplateDeclaration = function (decorator, component, containingFile) {\n      var preserveWhitespaces = this.defaultPreserveWhitespaces;\n\n      if (component.has('preserveWhitespaces')) {\n        var expr = component.get('preserveWhitespaces');\n        var value = this.evaluator.evaluate(expr);\n\n        if (typeof value !== 'boolean') {\n          throw diagnostics_2.createValueHasWrongTypeError(expr, value, 'preserveWhitespaces must be a boolean');\n        }\n\n        preserveWhitespaces = value;\n      }\n\n      var interpolationConfig = compiler_1.DEFAULT_INTERPOLATION_CONFIG;\n\n      if (component.has('interpolation')) {\n        var expr = component.get('interpolation');\n        var value = this.evaluator.evaluate(expr);\n\n        if (!Array.isArray(value) || value.length !== 2 || !value.every(function (element) {\n          return typeof element === 'string';\n        })) {\n          throw diagnostics_2.createValueHasWrongTypeError(expr, value, 'interpolation must be an array with 2 elements of string type');\n        }\n\n        interpolationConfig = compiler_1.InterpolationConfig.fromArray(value);\n      }\n\n      if (component.has('templateUrl')) {\n        var templateUrlExpr = component.get('templateUrl');\n        var templateUrl = this.evaluator.evaluate(templateUrlExpr);\n\n        if (typeof templateUrl !== 'string') {\n          throw diagnostics_2.createValueHasWrongTypeError(templateUrlExpr, templateUrl, 'templateUrl must be a string');\n        }\n\n        try {\n          var resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n          return {\n            isInline: false,\n            interpolationConfig: interpolationConfig,\n            preserveWhitespaces: preserveWhitespaces,\n            templateUrl: templateUrl,\n            templateUrlExpression: templateUrlExpr,\n            resolvedTemplateUrl: resourceUrl,\n            sourceMapUrl: sourceMapUrl(resourceUrl)\n          };\n        } catch (e) {\n          throw this.makeResourceNotFoundError(templateUrl, templateUrlExpr, 0\n          /* Template */\n          );\n        }\n      } else if (component.has('template')) {\n        return {\n          isInline: true,\n          interpolationConfig: interpolationConfig,\n          preserveWhitespaces: preserveWhitespaces,\n          expression: component.get('template'),\n          templateUrl: containingFile,\n          resolvedTemplateUrl: containingFile,\n          sourceMapUrl: containingFile\n        };\n      } else {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.COMPONENT_MISSING_TEMPLATE, reflection_1.Decorator.nodeForError(decorator), 'component is missing a template');\n      }\n    };\n\n    ComponentDecoratorHandler.prototype._resolveImportedFile = function (importedFile, expr, origin) {\n      // If `importedFile` is not 'unknown' then it accurately reflects the source file that is\n      // being imported.\n      if (importedFile !== 'unknown') {\n        return importedFile;\n      } // Otherwise `expr` has to be inspected to determine the file that is being imported. If `expr`\n      // is not an `ExternalExpr` then it does not correspond with an import, so return null in that\n      // case.\n\n\n      if (!(expr instanceof compiler_1.ExternalExpr)) {\n        return null;\n      } // Figure out what file is being imported.\n\n\n      return this.moduleResolver.resolveModule(expr.value.moduleName, origin.fileName);\n    };\n    /**\n     * Check whether adding an import from `origin` to the source-file corresponding to `expr` would\n     * create a cyclic import.\n     *\n     * @returns a `Cycle` object if a cycle would be created, otherwise `null`.\n     */\n\n\n    ComponentDecoratorHandler.prototype._checkForCyclicImport = function (importedFile, expr, origin) {\n      var imported = this._resolveImportedFile(importedFile, expr, origin);\n\n      if (imported === null) {\n        return null;\n      } // Check whether the import is legal.\n\n\n      return this.cycleAnalyzer.wouldCreateCycle(origin, imported);\n    };\n\n    ComponentDecoratorHandler.prototype._recordSyntheticImport = function (importedFile, expr, origin) {\n      var imported = this._resolveImportedFile(importedFile, expr, origin);\n\n      if (imported === null) {\n        return;\n      }\n\n      this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n    };\n\n    ComponentDecoratorHandler.prototype.makeResourceNotFoundError = function (file, nodeForError, resourceType) {\n      var errorText;\n\n      switch (resourceType) {\n        case 0\n        /* Template */\n        :\n          errorText = \"Could not find template file '\" + file + \"'.\";\n          break;\n\n        case 1\n        /* StylesheetFromTemplate */\n        :\n          errorText = \"Could not find stylesheet file '\" + file + \"' linked from the template.\";\n          break;\n\n        case 2\n        /* StylesheetFromDecorator */\n        :\n          errorText = \"Could not find stylesheet file '\" + file + \"'.\";\n          break;\n      }\n\n      return new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n    };\n\n    ComponentDecoratorHandler.prototype._extractTemplateStyleUrls = function (template) {\n      if (template.styleUrls === null) {\n        return [];\n      }\n\n      var nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n      return template.styleUrls.map(function (url) {\n        return {\n          url: url,\n          source: 1\n          /* StylesheetFromTemplate */\n          ,\n          nodeForError: nodeForError\n        };\n      });\n    };\n\n    return ComponentDecoratorHandler;\n  }();\n\n  exports.ComponentDecoratorHandler = ComponentDecoratorHandler;\n\n  function getTemplateRange(templateExpr) {\n    var startPos = templateExpr.getStart() + 1;\n\n    var _a = ts.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos),\n        line = _a.line,\n        character = _a.character;\n\n    return {\n      startPos: startPos,\n      startLine: line,\n      startCol: character,\n      endPos: templateExpr.getEnd() - 1\n    };\n  }\n\n  function sourceMapUrl(resourceUrl) {\n    if (!ts_source_map_bug_29300_1.tsSourceMapBug29300Fixed()) {\n      // By removing the template URL we are telling the translator not to try to\n      // map the external source file to the generated code, since the version\n      // of TS that is running does not support it.\n      return '';\n    } else {\n      return resourceUrl;\n    }\n  }\n  /** Determines if the result of an evaluation is a string array. */\n\n\n  function isStringArray(resolvedValue) {\n    return Array.isArray(resolvedValue) && resolvedValue.every(function (elem) {\n      return typeof elem === 'string';\n    });\n  }\n  /** Determines the node to use for debugging purposes for the given TemplateDeclaration. */\n\n\n  function getTemplateDeclarationNodeForError(declaration) {\n    // TODO(zarend): Change this to if/else when that is compatible with g3. This uses a switch\n    // because if/else fails to compile on g3. That is because g3 compiles this in non-strict mode\n    // where type inference does not work correctly.\n    switch (declaration.isInline) {\n      case true:\n        return declaration.expression;\n\n      case false:\n        return declaration.templateUrlExpression;\n    }\n  }\n  /**\n   * Generate a diagnostic related information object that describes a potential cyclic import path.\n   */\n\n\n  function makeCyclicImportInfo(ref, type, cycle) {\n    var name = ref.debugName || '(unknown)';\n    var path = cycle.getPath().map(function (sf) {\n      return sf.fileName;\n    }).join(' -> ');\n    var message = \"The \" + type + \" '\" + name + \"' is used in the template but importing it would create a cycle: \";\n    return diagnostics_1.makeRelatedInformation(ref.node, message + path);\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/component.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileComponentFromMetadata, compileDeclareComponentFromMetadata, ConstantPool, CssSelector, DeclarationListEmitMode, DEFAULT_INTERPOLATION_CONFIG, DomElementSchemaRegistry, Expression, ExternalExpr, Identifiers, InterpolationConfig, LexerRange, makeBindingParser, ParsedTemplate, ParseSourceFile, parseTemplate, R3ComponentDef, R3ComponentMetadata, R3FactoryTarget, R3TargetBinder, R3UsedDirectiveMetadata, SelectorMatcher, Statement, TmplAstNode, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {Cycle, CycleAnalyzer, CycleHandlingStrategy} from '../../cycles';\nimport {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\nimport {absoluteFrom, relative} from '../../file_system';\nimport {ImportedFile, ModuleResolver, Reference, ReferenceEmitter} from '../../imports';\nimport {DependencyTracker} from '../../incremental/api';\nimport {extractSemanticTypeParameters, isArrayEqual, isReferenceEqual, SemanticDepGraphUpdater, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\nimport {IndexingContext} from '../../indexer';\nimport {ClassPropertyMapping, ComponentResources, DirectiveMeta, DirectiveTypeCheckMeta, extractDirectiveTypeCheckMeta, InjectableClassRegistry, MetadataReader, MetadataRegistry, Resource, ResourceRegistry} from '../../metadata';\nimport {EnumValue, PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, DeclarationNode, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\nimport {ComponentScopeReader, LocalModuleScopeRegistry, TypeCheckScopeRegistry} from '../../scope';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerFlags, HandlerPrecedence, ResolveResult} from '../../transform';\nimport {TemplateSourceMapping, TypeCheckContext} from '../../typecheck/api';\nimport {tsSourceMapBug29300Fixed} from '../../util/src/ts_source_map_bug_29300';\nimport {SubsetOfKeys} from '../../util/src/typescript';\n\nimport {ResourceLoader} from './api';\nimport {createValueHasWrongTypeError, getDirectiveDiagnostics, getProviderDiagnostics} from './diagnostics';\nimport {DirectiveSymbol, extractDirectiveMetadata, parseFieldArrayValue} from './directive';\nimport {compileNgFactoryDefField} from './factory';\nimport {generateSetClassMetadataCall} from './metadata';\nimport {NgModuleSymbol} from './ng_module';\nimport {findAngularDecorator, isAngularCoreReference, isExpressionForwardReference, readBaseClass, resolveProvidersRequiringFactory, unwrapExpression, wrapFunctionExpressionsInParens} from './util';\n\nconst EMPTY_MAP = new Map<string, Expression>();\nconst EMPTY_ARRAY: any[] = [];\n\n/**\n * These fields of `R3ComponentMetadata` are updated in the `resolve` phase.\n *\n * The `keyof R3ComponentMetadata &` condition ensures that only fields of `R3ComponentMetadata` can\n * be included here.\n */\nexport type ComponentMetadataResolvedFields =\n    SubsetOfKeys<R3ComponentMetadata, 'directives'|'pipes'|'declarationListEmitMode'>;\n\nexport interface ComponentAnalysisData {\n  /**\n   * `meta` includes those fields of `R3ComponentMetadata` which are calculated at `analyze` time\n   * (not during resolve).\n   */\n  meta: Omit<R3ComponentMetadata, ComponentMetadataResolvedFields>;\n  baseClass: Reference<ClassDeclaration>|'dynamic'|null;\n  typeCheckMeta: DirectiveTypeCheckMeta;\n  template: ParsedTemplateWithSource;\n  metadataStmt: Statement|null;\n\n  inputs: ClassPropertyMapping;\n  outputs: ClassPropertyMapping;\n\n  /**\n   * Providers extracted from the `providers` field of the component annotation which will require\n   * an Angular factory definition at runtime.\n   */\n  providersRequiringFactory: Set<Reference<ClassDeclaration>>|null;\n\n  /**\n   * Providers extracted from the `viewProviders` field of the component annotation which will\n   * require an Angular factory definition at runtime.\n   */\n  viewProvidersRequiringFactory: Set<Reference<ClassDeclaration>>|null;\n\n  resources: ComponentResources;\n\n  /**\n   * `styleUrls` extracted from the decorator, if present.\n   */\n  styleUrls: StyleUrlMeta[]|null;\n\n  /**\n   * Inline stylesheets extracted from the decorator, if present.\n   */\n  inlineStyles: string[]|null;\n\n  isPoisoned: boolean;\n}\n\nexport type ComponentResolutionData = Pick<R3ComponentMetadata, ComponentMetadataResolvedFields>;\n\n/**\n * The literal style url extracted from the decorator, along with metadata for diagnostics.\n */\nexport interface StyleUrlMeta {\n  url: string;\n  nodeForError: ts.Node;\n  source: ResourceTypeForDiagnostics.StylesheetFromTemplate|\n      ResourceTypeForDiagnostics.StylesheetFromDecorator;\n}\n\n/**\n * Information about the origin of a resource in the application code. This is used for creating\n * diagnostics, so we can point to the root cause of an error in the application code.\n *\n * A template resource comes from the `templateUrl` property on the component decorator.\n *\n * Stylesheets resources can come from either the `styleUrls` property on the component decorator,\n * or from inline `style` tags and style links on the external template.\n */\nexport const enum ResourceTypeForDiagnostics {\n  Template,\n  StylesheetFromTemplate,\n  StylesheetFromDecorator,\n}\n\n/**\n * Represents an Angular component.\n */\nexport class ComponentSymbol extends DirectiveSymbol {\n  usedDirectives: SemanticReference[] = [];\n  usedPipes: SemanticReference[] = [];\n  isRemotelyScoped = false;\n\n  isEmitAffected(previousSymbol: SemanticSymbol, publicApiAffected: Set<SemanticSymbol>): boolean {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n\n    // Create an equality function that considers symbols equal if they represent the same\n    // declaration, but only if the symbol in the current compilation does not have its public API\n    // affected.\n    const isSymbolUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n        isReferenceEqual(current, previous) && !publicApiAffected.has(current.symbol);\n\n    // The emit of a component is affected if either of the following is true:\n    //  1. The component used to be remotely scoped but no longer is, or vice versa.\n    //  2. The list of used directives has changed or any of those directives have had their public\n    //     API changed. If the used directives have been reordered but not otherwise affected then\n    //     the component must still be re-emitted, as this may affect directive instantiation order.\n    //  3. The list of used pipes has changed, or any of those pipes have had their public API\n    //     changed.\n    return this.isRemotelyScoped !== previousSymbol.isRemotelyScoped ||\n        !isArrayEqual(this.usedDirectives, previousSymbol.usedDirectives, isSymbolUnaffected) ||\n        !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isSymbolUnaffected);\n  }\n\n  isTypeCheckBlockAffected(\n      previousSymbol: SemanticSymbol, typeCheckApiAffected: Set<SemanticSymbol>): boolean {\n    if (!(previousSymbol instanceof ComponentSymbol)) {\n      return true;\n    }\n\n    // To verify that a used directive is not affected we need to verify that its full inheritance\n    // chain is not present in `typeCheckApiAffected`.\n    const isInheritanceChainAffected = (symbol: SemanticSymbol): boolean => {\n      let currentSymbol: SemanticSymbol|null = symbol;\n      while (currentSymbol instanceof DirectiveSymbol) {\n        if (typeCheckApiAffected.has(currentSymbol)) {\n          return true;\n        }\n        currentSymbol = currentSymbol.baseClass;\n      }\n\n      return false;\n    };\n\n    // Create an equality function that considers directives equal if they represent the same\n    // declaration and if the symbol and all symbols it inherits from in the current compilation\n    // do not have their type-check API affected.\n    const isDirectiveUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n        isReferenceEqual(current, previous) && !isInheritanceChainAffected(current.symbol);\n\n    // Create an equality function that considers pipes equal if they represent the same\n    // declaration and if the symbol in the current compilation does not have its type-check\n    // API affected.\n    const isPipeUnaffected = (current: SemanticReference, previous: SemanticReference) =>\n        isReferenceEqual(current, previous) && !typeCheckApiAffected.has(current.symbol);\n\n    // The emit of a type-check block of a component is affected if either of the following is true:\n    //  1. The list of used directives has changed or any of those directives have had their\n    //     type-check API changed.\n    //  2. The list of used pipes has changed, or any of those pipes have had their type-check API\n    //     changed.\n    return !isArrayEqual(\n               this.usedDirectives, previousSymbol.usedDirectives, isDirectiveUnaffected) ||\n        !isArrayEqual(this.usedPipes, previousSymbol.usedPipes, isPipeUnaffected);\n  }\n}\n\n/**\n * `DecoratorHandler` which handles the `@Component` annotation.\n */\nexport class ComponentDecoratorHandler implements\n    DecoratorHandler<Decorator, ComponentAnalysisData, ComponentSymbol, ComponentResolutionData> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private metaRegistry: MetadataRegistry, private metaReader: MetadataReader,\n      private scopeReader: ComponentScopeReader, private scopeRegistry: LocalModuleScopeRegistry,\n      private typeCheckScopeRegistry: TypeCheckScopeRegistry,\n      private resourceRegistry: ResourceRegistry, private isCore: boolean,\n      private resourceLoader: ResourceLoader, private rootDirs: ReadonlyArray<string>,\n      private defaultPreserveWhitespaces: boolean, private i18nUseExternalIds: boolean,\n      private enableI18nLegacyMessageIdFormat: boolean, private usePoisonedData: boolean,\n      private i18nNormalizeLineEndingsInICUs: boolean|undefined,\n      private moduleResolver: ModuleResolver, private cycleAnalyzer: CycleAnalyzer,\n      private cycleHandlingStrategy: CycleHandlingStrategy, private refEmitter: ReferenceEmitter,\n      private depTracker: DependencyTracker|null,\n      private injectableRegistry: InjectableClassRegistry,\n      private semanticDepGraphUpdater: SemanticDepGraphUpdater|null,\n      private annotateForClosureCompiler: boolean, private perf: PerfRecorder) {}\n\n  private literalCache = new Map<Decorator, ts.ObjectLiteralExpression>();\n  private elementSchemaRegistry = new DomElementSchemaRegistry();\n\n  /**\n   * During the asynchronous preanalyze phase, it's necessary to parse the template to extract\n   * any potential <link> tags which might need to be loaded. This cache ensures that work is not\n   * thrown away, and the parsed template is reused during the analyze phase.\n   */\n  private preanalyzeTemplateCache = new Map<DeclarationNode, ParsedTemplateWithSource>();\n\n  readonly precedence = HandlerPrecedence.PRIMARY;\n  readonly name = ComponentDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<Decorator>|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    const decorator = findAngularDecorator(decorators, 'Component', this.isCore);\n    if (decorator !== undefined) {\n      return {\n        trigger: decorator.node,\n        decorator,\n        metadata: decorator,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  preanalyze(node: ClassDeclaration, decorator: Readonly<Decorator>): Promise<void>|undefined {\n    // In preanalyze, resource URLs associated with the component are asynchronously preloaded via\n    // the resourceLoader. This is the only time async operations are allowed for a component.\n    // These resources are:\n    //\n    // - the templateUrl, if there is one\n    // - any styleUrls if present\n    // - any stylesheets referenced from <link> tags in the template itself\n    //\n    // As a result of the last one, the template must be parsed as part of preanalysis to extract\n    // <link> tags, which may involve waiting for the templateUrl to be resolved first.\n\n    // If preloading isn't possible, then skip this step.\n    if (!this.resourceLoader.canPreload) {\n      return undefined;\n    }\n\n    const meta = this._resolveLiteral(decorator);\n    const component = reflectObjectLiteral(meta);\n    const containingFile = node.getSourceFile().fileName;\n\n    const resolveStyleUrl = (styleUrl: string): Promise<void>|undefined => {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl, containingFile);\n        return this.resourceLoader.preload(resourceUrl);\n      } catch {\n        // Don't worry about failures to preload. We can handle this problem during analysis by\n        // producing a diagnostic.\n        return undefined;\n      }\n    };\n\n    // A Promise that waits for the template and all <link>ed styles within it to be preloaded.\n    const templateAndTemplateStyleResources =\n        this._preloadAndParseTemplate(node, decorator, component, containingFile)\n            .then((template: ParsedTemplateWithSource|null): Promise<void>|undefined => {\n              if (template === null) {\n                return undefined;\n              }\n\n              return Promise.all(template.styleUrls.map(styleUrl => resolveStyleUrl(styleUrl)))\n                  .then(() => undefined);\n            });\n\n    // Extract all the styleUrls in the decorator.\n    const componentStyleUrls = this._extractComponentStyleUrls(component);\n\n    if (componentStyleUrls === null) {\n      // A fast path exists if there are no styleUrls, to just wait for\n      // templateAndTemplateStyleResources.\n      return templateAndTemplateStyleResources;\n    } else {\n      // Wait for both the template and all styleUrl resources to resolve.\n      return Promise\n          .all([\n            templateAndTemplateStyleResources,\n            ...componentStyleUrls.map(styleUrl => resolveStyleUrl(styleUrl.url))\n          ])\n          .then(() => undefined);\n    }\n  }\n\n  analyze(\n      node: ClassDeclaration, decorator: Readonly<Decorator>,\n      flags: HandlerFlags = HandlerFlags.NONE): AnalysisOutput<ComponentAnalysisData> {\n    this.perf.eventCount(PerfEvent.AnalyzeComponent);\n    const containingFile = node.getSourceFile().fileName;\n    this.literalCache.delete(decorator);\n\n    let diagnostics: ts.Diagnostic[]|undefined;\n    let isPoisoned = false;\n    // @Component inherits @Directive, so begin by extracting the @Directive metadata and building\n    // on it.\n    const directiveResult = extractDirectiveMetadata(\n        node, decorator, this.reflector, this.evaluator, this.isCore, flags,\n        this.annotateForClosureCompiler,\n        this.elementSchemaRegistry.getDefaultComponentElementName());\n    if (directiveResult === undefined) {\n      // `extractDirectiveMetadata` returns undefined when the @Directive has `jit: true`. In this\n      // case, compilation of the decorator is skipped. Returning an empty object signifies\n      // that no analysis was produced.\n      return {};\n    }\n\n    // Next, read the `@Component`-specific fields.\n    const {decorator: component, metadata, inputs, outputs} = directiveResult;\n\n    // Go through the root directories for this project, and select the one with the smallest\n    // relative path representation.\n    const relativeContextFilePath = this.rootDirs.reduce<string|undefined>((previous, rootDir) => {\n      const candidate = relative(absoluteFrom(rootDir), absoluteFrom(containingFile));\n      if (previous === undefined || candidate.length < previous.length) {\n        return candidate;\n      } else {\n        return previous;\n      }\n    }, undefined)!;\n\n\n    // Note that we could technically combine the `viewProvidersRequiringFactory` and\n    // `providersRequiringFactory` into a single set, but we keep the separate so that\n    // we can distinguish where an error is coming from when logging the diagnostics in `resolve`.\n    let viewProvidersRequiringFactory: Set<Reference<ClassDeclaration>>|null = null;\n    let providersRequiringFactory: Set<Reference<ClassDeclaration>>|null = null;\n    let wrappedViewProviders: Expression|null = null;\n\n    if (component.has('viewProviders')) {\n      const viewProviders = component.get('viewProviders')!;\n      viewProvidersRequiringFactory =\n          resolveProvidersRequiringFactory(viewProviders, this.reflector, this.evaluator);\n      wrappedViewProviders = new WrappedNodeExpr(\n          this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(viewProviders) :\n                                            viewProviders);\n    }\n\n    if (component.has('providers')) {\n      providersRequiringFactory = resolveProvidersRequiringFactory(\n          component.get('providers')!, this.reflector, this.evaluator);\n    }\n\n    // Parse the template.\n    // If a preanalyze phase was executed, the template may already exist in parsed form, so check\n    // the preanalyzeTemplateCache.\n    // Extract a closure of the template parsing code so that it can be reparsed with different\n    // options if needed, like in the indexing pipeline.\n    let template: ParsedTemplateWithSource;\n    if (this.preanalyzeTemplateCache.has(node)) {\n      // The template was parsed in preanalyze. Use it and delete it to save memory.\n      const preanalyzed = this.preanalyzeTemplateCache.get(node)!;\n      this.preanalyzeTemplateCache.delete(node);\n\n      template = preanalyzed;\n    } else {\n      const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n      template = this.extractTemplate(node, templateDecl);\n    }\n    const templateResource =\n        template.isInline ? {path: null, expression: component.get('template')!} : {\n          path: absoluteFrom(template.declaration.resolvedTemplateUrl),\n          expression: template.sourceMapping.node\n        };\n\n    // Figure out the set of styles. The ordering here is important: external resources (styleUrls)\n    // precede inline styles, and styles defined in the template override styles defined in the\n    // component.\n    let styles: string[] = [];\n\n    const styleResources = this._extractStyleResources(component, containingFile);\n    const styleUrls: StyleUrlMeta[] = [\n      ...this._extractComponentStyleUrls(component), ...this._extractTemplateStyleUrls(template)\n    ];\n\n    for (const styleUrl of styleUrls) {\n      try {\n        const resourceUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n        const resourceStr = this.resourceLoader.load(resourceUrl);\n        styles.push(resourceStr);\n        if (this.depTracker !== null) {\n          this.depTracker.addResourceDependency(node.getSourceFile(), absoluteFrom(resourceUrl));\n        }\n      } catch {\n        if (diagnostics === undefined) {\n          diagnostics = [];\n        }\n        const resourceType =\n            styleUrl.source === ResourceTypeForDiagnostics.StylesheetFromDecorator ?\n            ResourceTypeForDiagnostics.StylesheetFromDecorator :\n            ResourceTypeForDiagnostics.StylesheetFromTemplate;\n        diagnostics.push(\n            this.makeResourceNotFoundError(styleUrl.url, styleUrl.nodeForError, resourceType)\n                .toDiagnostic());\n      }\n    }\n\n    let inlineStyles: string[]|null = null;\n    if (component.has('styles')) {\n      const litStyles = parseFieldArrayValue(component, 'styles', this.evaluator);\n      if (litStyles !== null) {\n        inlineStyles = [...litStyles];\n        styles.push(...litStyles);\n      }\n    }\n    if (template.styles.length > 0) {\n      styles.push(...template.styles);\n    }\n\n    const encapsulation: number =\n        this._resolveEnumValue(component, 'encapsulation', 'ViewEncapsulation') || 0;\n\n    const changeDetection: number|null =\n        this._resolveEnumValue(component, 'changeDetection', 'ChangeDetectionStrategy');\n\n    let animations: Expression|null = null;\n    if (component.has('animations')) {\n      animations = new WrappedNodeExpr(component.get('animations')!);\n    }\n\n    const output: AnalysisOutput<ComponentAnalysisData> = {\n      analysis: {\n        baseClass: readBaseClass(node, this.reflector, this.evaluator),\n        inputs,\n        outputs,\n        meta: {\n          ...metadata,\n          template: {\n            nodes: template.nodes,\n            ngContentSelectors: template.ngContentSelectors,\n          },\n          encapsulation,\n          interpolation: template.interpolationConfig ?? DEFAULT_INTERPOLATION_CONFIG,\n          styles,\n\n          // These will be replaced during the compilation step, after all `NgModule`s have been\n          // analyzed and the full compilation scope for the component can be realized.\n          animations,\n          viewProviders: wrappedViewProviders,\n          i18nUseExternalIds: this.i18nUseExternalIds,\n          relativeContextFilePath,\n        },\n        typeCheckMeta: extractDirectiveTypeCheckMeta(node, inputs, this.reflector),\n        metadataStmt: generateSetClassMetadataCall(\n            node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        template,\n        providersRequiringFactory,\n        viewProvidersRequiringFactory,\n        inlineStyles,\n        styleUrls,\n        resources: {\n          styles: styleResources,\n          template: templateResource,\n        },\n        isPoisoned,\n      },\n      diagnostics,\n    };\n    if (changeDetection !== null) {\n      output.analysis!.meta.changeDetection = changeDetection;\n    }\n    return output;\n  }\n\n  symbol(node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>): ComponentSymbol {\n    const typeParameters = extractSemanticTypeParameters(node);\n\n    return new ComponentSymbol(\n        node, analysis.meta.selector, analysis.inputs, analysis.outputs, analysis.meta.exportAs,\n        analysis.typeCheckMeta, typeParameters);\n  }\n\n  register(node: ClassDeclaration, analysis: ComponentAnalysisData): void {\n    // Register this component's information with the `MetadataRegistry`. This ensures that\n    // the information about the component is available during the compile() phase.\n    const ref = new Reference(node);\n    this.metaRegistry.registerDirectiveMetadata({\n      ref,\n      name: node.name.text,\n      selector: analysis.meta.selector,\n      exportAs: analysis.meta.exportAs,\n      inputs: analysis.inputs,\n      outputs: analysis.outputs,\n      queries: analysis.meta.queries.map(query => query.propertyName),\n      isComponent: true,\n      baseClass: analysis.baseClass,\n      ...analysis.typeCheckMeta,\n      isPoisoned: analysis.isPoisoned,\n      isStructural: false,\n    });\n\n    this.resourceRegistry.registerResources(analysis.resources, node);\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  index(\n      context: IndexingContext, node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>) {\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return null;\n    }\n    const scope = this.scopeReader.getScopeForComponent(node);\n    const selector = analysis.meta.selector;\n    const matcher = new SelectorMatcher<DirectiveMeta>();\n    if (scope !== null) {\n      if ((scope.compilation.isPoisoned || scope.exported.isPoisoned) && !this.usePoisonedData) {\n        // Don't bother indexing components which had erroneous scopes, unless specifically\n        // requested.\n        return null;\n      }\n\n      for (const directive of scope.compilation.directives) {\n        if (directive.selector !== null) {\n          matcher.addSelectables(CssSelector.parse(directive.selector), directive);\n        }\n      }\n    }\n    const binder = new R3TargetBinder(matcher);\n    const boundTemplate = binder.bind({template: analysis.template.diagNodes});\n\n    context.addComponent({\n      declaration: node,\n      selector,\n      boundTemplate,\n      templateMeta: {\n        isInline: analysis.template.isInline,\n        file: analysis.template.file,\n      },\n    });\n  }\n\n  typeCheck(ctx: TypeCheckContext, node: ClassDeclaration, meta: Readonly<ComponentAnalysisData>):\n      void {\n    if (this.typeCheckScopeRegistry === null || !ts.isClassDeclaration(node)) {\n      return;\n    }\n\n    if (meta.isPoisoned && !this.usePoisonedData) {\n      return;\n    }\n    const scope = this.typeCheckScopeRegistry.getTypeCheckScope(node);\n    if (scope.isPoisoned && !this.usePoisonedData) {\n      // Don't type-check components that had errors in their scopes, unless requested.\n      return;\n    }\n\n    const binder = new R3TargetBinder(scope.matcher);\n    ctx.addTemplate(\n        new Reference(node), binder, meta.template.diagNodes, scope.pipes, scope.schemas,\n        meta.template.sourceMapping, meta.template.file, meta.template.errors);\n  }\n\n  resolve(\n      node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>,\n      symbol: ComponentSymbol): ResolveResult<ComponentResolutionData> {\n    if (this.semanticDepGraphUpdater !== null && analysis.baseClass instanceof Reference) {\n      symbol.baseClass = this.semanticDepGraphUpdater.getSymbol(analysis.baseClass.node);\n    }\n\n    if (analysis.isPoisoned && !this.usePoisonedData) {\n      return {};\n    }\n\n    const context = node.getSourceFile();\n    // Check whether this component was registered with an NgModule. If so, it should be compiled\n    // under that module's compilation scope.\n    const scope = this.scopeReader.getScopeForComponent(node);\n    let metadata = analysis.meta as Readonly<R3ComponentMetadata>;\n\n    const data: ComponentResolutionData = {\n      directives: EMPTY_ARRAY,\n      pipes: EMPTY_MAP,\n      declarationListEmitMode: DeclarationListEmitMode.Direct,\n    };\n\n    if (scope !== null && (!scope.compilation.isPoisoned || this.usePoisonedData)) {\n      // Replace the empty components and directives from the analyze() step with a fully expanded\n      // scope. This is possible now because during resolve() the whole compilation unit has been\n      // fully analyzed.\n      //\n      // First it needs to be determined if actually importing the directives/pipes used in the\n      // template would create a cycle. Currently ngtsc refuses to generate cycles, so an option\n      // known as \"remote scoping\" is used if a cycle would be created. In remote scoping, the\n      // module file sets the directives/pipes on the ɵcmp of the component, without\n      // requiring new imports (but also in a way that breaks tree shaking).\n      //\n      // Determining this is challenging, because the TemplateDefinitionBuilder is responsible for\n      // matching directives and pipes in the template; however, that doesn't run until the actual\n      // compile() step. It's not possible to run template compilation sooner as it requires the\n      // ConstantPool for the overall file being compiled (which isn't available until the\n      // transform step).\n      //\n      // Instead, directives/pipes are matched independently here, using the R3TargetBinder. This\n      // is an alternative implementation of template matching which is used for template\n      // type-checking and will eventually replace matching in the TemplateDefinitionBuilder.\n\n\n      // Set up the R3TargetBinder, as well as a 'directives' array and a 'pipes' map that are\n      // later fed to the TemplateDefinitionBuilder. First, a SelectorMatcher is constructed to\n      // match directives that are in scope.\n      type MatchedDirective = DirectiveMeta&{selector: string};\n      const matcher = new SelectorMatcher<MatchedDirective>();\n\n      for (const dir of scope.compilation.directives) {\n        if (dir.selector !== null) {\n          matcher.addSelectables(CssSelector.parse(dir.selector), dir as MatchedDirective);\n        }\n      }\n      const pipes = new Map<string, Reference<ClassDeclaration>>();\n      for (const pipe of scope.compilation.pipes) {\n        pipes.set(pipe.name, pipe.ref);\n      }\n\n      // Next, the component template AST is bound using the R3TargetBinder. This produces a\n      // BoundTarget, which is similar to a ts.TypeChecker.\n      const binder = new R3TargetBinder(matcher);\n      const bound = binder.bind({template: metadata.template.nodes});\n\n      // The BoundTarget knows which directives and pipes matched the template.\n      type UsedDirective =\n          R3UsedDirectiveMetadata&{ref: Reference<ClassDeclaration>, importedFile: ImportedFile};\n      const usedDirectives: UsedDirective[] = bound.getUsedDirectives().map(directive => {\n        const type = this.refEmitter.emit(directive.ref, context);\n        return {\n          ref: directive.ref,\n          type: type.expression,\n          importedFile: type.importedFile,\n          selector: directive.selector,\n          inputs: directive.inputs.propertyNames,\n          outputs: directive.outputs.propertyNames,\n          exportAs: directive.exportAs,\n          isComponent: directive.isComponent,\n        };\n      });\n\n      type UsedPipe = {\n        ref: Reference<ClassDeclaration>,\n        pipeName: string,\n        expression: Expression,\n        importedFile: ImportedFile,\n      };\n      const usedPipes: UsedPipe[] = [];\n      for (const pipeName of bound.getUsedPipes()) {\n        if (!pipes.has(pipeName)) {\n          continue;\n        }\n        const pipe = pipes.get(pipeName)!;\n        const type = this.refEmitter.emit(pipe, context);\n        usedPipes.push({\n          ref: pipe,\n          pipeName,\n          expression: type.expression,\n          importedFile: type.importedFile,\n        });\n      }\n      if (this.semanticDepGraphUpdater !== null) {\n        symbol.usedDirectives = usedDirectives.map(\n            dir => this.semanticDepGraphUpdater!.getSemanticReference(dir.ref.node, dir.type));\n        symbol.usedPipes = usedPipes.map(\n            pipe =>\n                this.semanticDepGraphUpdater!.getSemanticReference(pipe.ref.node, pipe.expression));\n      }\n\n      // Scan through the directives/pipes actually used in the template and check whether any\n      // import which needs to be generated would create a cycle.\n      const cyclesFromDirectives = new Map<UsedDirective, Cycle>();\n      for (const usedDirective of usedDirectives) {\n        const cycle =\n            this._checkForCyclicImport(usedDirective.importedFile, usedDirective.type, context);\n        if (cycle !== null) {\n          cyclesFromDirectives.set(usedDirective, cycle);\n        }\n      }\n      const cyclesFromPipes = new Map<UsedPipe, Cycle>();\n      for (const usedPipe of usedPipes) {\n        const cycle =\n            this._checkForCyclicImport(usedPipe.importedFile, usedPipe.expression, context);\n        if (cycle !== null) {\n          cyclesFromPipes.set(usedPipe, cycle);\n        }\n      }\n\n      const cycleDetected = cyclesFromDirectives.size !== 0 || cyclesFromPipes.size !== 0;\n      if (!cycleDetected) {\n        // No cycle was detected. Record the imports that need to be created in the cycle detector\n        // so that future cyclic import checks consider their production.\n        for (const {type, importedFile} of usedDirectives) {\n          this._recordSyntheticImport(importedFile, type, context);\n        }\n        for (const {expression, importedFile} of usedPipes) {\n          this._recordSyntheticImport(importedFile, expression, context);\n        }\n\n        // Check whether the directive/pipe arrays in ɵcmp need to be wrapped in closures.\n        // This is required if any directive/pipe reference is to a declaration in the same file\n        // but declared after this component.\n        const wrapDirectivesAndPipesInClosure =\n            usedDirectives.some(\n                dir => isExpressionForwardReference(dir.type, node.name, context)) ||\n            usedPipes.some(\n                pipe => isExpressionForwardReference(pipe.expression, node.name, context));\n\n        data.directives = usedDirectives;\n        data.pipes = new Map(usedPipes.map(pipe => [pipe.pipeName, pipe.expression]));\n        data.declarationListEmitMode = wrapDirectivesAndPipesInClosure ?\n            DeclarationListEmitMode.Closure :\n            DeclarationListEmitMode.Direct;\n      } else {\n        if (this.cycleHandlingStrategy === CycleHandlingStrategy.UseRemoteScoping) {\n          // Declaring the directiveDefs/pipeDefs arrays directly would require imports that would\n          // create a cycle. Instead, mark this component as requiring remote scoping, so that the\n          // NgModule file will take care of setting the directives for the component.\n          this.scopeRegistry.setComponentRemoteScope(\n              node, usedDirectives.map(dir => dir.ref), usedPipes.map(pipe => pipe.ref));\n          symbol.isRemotelyScoped = true;\n\n          // If a semantic graph is being tracked, record the fact that this component is remotely\n          // scoped with the declaring NgModule symbol as the NgModule's emit becomes dependent on\n          // the directive/pipe usages of this component.\n          if (this.semanticDepGraphUpdater !== null) {\n            const moduleSymbol = this.semanticDepGraphUpdater.getSymbol(scope.ngModule);\n            if (!(moduleSymbol instanceof NgModuleSymbol)) {\n              throw new Error(\n                  `AssertionError: Expected ${scope.ngModule.name} to be an NgModuleSymbol.`);\n            }\n\n            moduleSymbol.addRemotelyScopedComponent(\n                symbol, symbol.usedDirectives, symbol.usedPipes);\n          }\n        } else {\n          // We are not able to handle this cycle so throw an error.\n          const relatedMessages: ts.DiagnosticRelatedInformation[] = [];\n          for (const [dir, cycle] of cyclesFromDirectives) {\n            relatedMessages.push(\n                makeCyclicImportInfo(dir.ref, dir.isComponent ? 'component' : 'directive', cycle));\n          }\n          for (const [pipe, cycle] of cyclesFromPipes) {\n            relatedMessages.push(makeCyclicImportInfo(pipe.ref, 'pipe', cycle));\n          }\n          throw new FatalDiagnosticError(\n              ErrorCode.IMPORT_CYCLE_DETECTED, node,\n              'One or more import cycles would need to be created to compile this component, ' +\n                  'which is not supported by the current compiler configuration.',\n              relatedMessages);\n        }\n      }\n    }\n\n    const diagnostics: ts.Diagnostic[] = [];\n\n    if (analysis.providersRequiringFactory !== null &&\n        analysis.meta.providers instanceof WrappedNodeExpr) {\n      const providerDiagnostics = getProviderDiagnostics(\n          analysis.providersRequiringFactory, analysis.meta.providers!.node,\n          this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    if (analysis.viewProvidersRequiringFactory !== null &&\n        analysis.meta.viewProviders instanceof WrappedNodeExpr) {\n      const viewProviderDiagnostics = getProviderDiagnostics(\n          analysis.viewProvidersRequiringFactory, analysis.meta.viewProviders!.node,\n          this.injectableRegistry);\n      diagnostics.push(...viewProviderDiagnostics);\n    }\n\n    const directiveDiagnostics = getDirectiveDiagnostics(\n        node, this.metaReader, this.evaluator, this.reflector, this.scopeRegistry, 'Component');\n    if (directiveDiagnostics !== null) {\n      diagnostics.push(...directiveDiagnostics);\n    }\n\n    if (diagnostics.length > 0) {\n      return {diagnostics};\n    }\n\n    return {data};\n  }\n\n  updateResources(node: ClassDeclaration, analysis: ComponentAnalysisData): void {\n    const containingFile = node.getSourceFile().fileName;\n\n    // If the template is external, re-parse it.\n    const templateDecl = analysis.template.declaration;\n    if (!templateDecl.isInline) {\n      analysis.template = this.extractTemplate(node, templateDecl);\n    }\n\n    // Update any external stylesheets and rebuild the combined 'styles' list.\n    // TODO(alxhub): write tests for styles when the primary compiler uses the updateResources path\n    let styles: string[] = [];\n    if (analysis.styleUrls !== null) {\n      for (const styleUrl of analysis.styleUrls) {\n        try {\n          const resolvedStyleUrl = this.resourceLoader.resolve(styleUrl.url, containingFile);\n          const styleText = this.resourceLoader.load(resolvedStyleUrl);\n          styles.push(styleText);\n        } catch (e) {\n          // Resource resolve failures should already be in the diagnostics list from the analyze\n          // stage. We do not need to do anything with them when updating resources.\n        }\n      }\n    }\n    if (analysis.inlineStyles !== null) {\n      for (const styleText of analysis.inlineStyles) {\n        styles.push(styleText);\n      }\n    }\n    for (const styleText of analysis.template.styles) {\n      styles.push(styleText);\n    }\n\n    analysis.meta.styles = styles;\n  }\n\n  compileFull(\n      node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>,\n      resolution: Readonly<ComponentResolutionData>, pool: ConstantPool): CompileResult[] {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const meta: R3ComponentMetadata = {...analysis.meta, ...resolution};\n    const def = compileComponentFromMetadata(meta, pool, makeBindingParser());\n    return this.compileComponent(analysis, def);\n  }\n\n  compilePartial(\n      node: ClassDeclaration, analysis: Readonly<ComponentAnalysisData>,\n      resolution: Readonly<ComponentResolutionData>): CompileResult[] {\n    if (analysis.template.errors !== null && analysis.template.errors.length > 0) {\n      return [];\n    }\n    const meta: R3ComponentMetadata = {...analysis.meta, ...resolution};\n    const def = compileDeclareComponentFromMetadata(meta, analysis.template);\n    return this.compileComponent(analysis, def);\n  }\n\n  private compileComponent(\n      analysis: Readonly<ComponentAnalysisData>,\n      {expression: initializer, type}: R3ComponentDef): CompileResult[] {\n    const factoryRes = compileNgFactoryDefField({\n      ...analysis.meta,\n      injectFn: Identifiers.directiveInject,\n      target: R3FactoryTarget.Component,\n    });\n    if (analysis.metadataStmt !== null) {\n      factoryRes.statements.push(analysis.metadataStmt);\n    }\n    return [\n      factoryRes, {\n        name: 'ɵcmp',\n        initializer,\n        statements: [],\n        type,\n      }\n    ];\n  }\n\n  private _resolveLiteral(decorator: Decorator): ts.ObjectLiteralExpression {\n    if (this.literalCache.has(decorator)) {\n      return this.literalCache.get(decorator)!;\n    }\n    if (decorator.args === null || decorator.args.length !== 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator),\n          `Incorrect number of arguments to @Component decorator`);\n    }\n    const meta = unwrapExpression(decorator.args[0]);\n\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, `Decorator argument must be literal.`);\n    }\n\n    this.literalCache.set(decorator, meta);\n    return meta;\n  }\n\n  private _resolveEnumValue(\n      component: Map<string, ts.Expression>, field: string, enumSymbolName: string): number|null {\n    let resolved: number|null = null;\n    if (component.has(field)) {\n      const expr = component.get(field)!;\n      const value = this.evaluator.evaluate(expr) as any;\n      if (value instanceof EnumValue && isAngularCoreReference(value.enumRef, enumSymbolName)) {\n        resolved = value.resolved as number;\n      } else {\n        throw createValueHasWrongTypeError(\n            expr, value, `${field} must be a member of ${enumSymbolName} enum from @angular/core`);\n      }\n    }\n    return resolved;\n  }\n\n  private _extractComponentStyleUrls(\n      component: Map<string, ts.Expression>,\n      ): StyleUrlMeta[] {\n    if (!component.has('styleUrls')) {\n      return [];\n    }\n\n    return this._extractStyleUrlsFromExpression(component.get('styleUrls')!);\n  }\n\n  private _extractStyleUrlsFromExpression(styleUrlsExpr: ts.Expression): StyleUrlMeta[] {\n    const styleUrls: StyleUrlMeta[] = [];\n\n    if (ts.isArrayLiteralExpression(styleUrlsExpr)) {\n      for (const styleUrlExpr of styleUrlsExpr.elements) {\n        if (ts.isSpreadElement(styleUrlExpr)) {\n          styleUrls.push(...this._extractStyleUrlsFromExpression(styleUrlExpr.expression));\n        } else {\n          const styleUrl = this.evaluator.evaluate(styleUrlExpr);\n\n          if (typeof styleUrl !== 'string') {\n            throw createValueHasWrongTypeError(styleUrlExpr, styleUrl, 'styleUrl must be a string');\n          }\n\n          styleUrls.push({\n            url: styleUrl,\n            source: ResourceTypeForDiagnostics.StylesheetFromDecorator,\n            nodeForError: styleUrlExpr,\n          });\n        }\n      }\n    } else {\n      const evaluatedStyleUrls = this.evaluator.evaluate(styleUrlsExpr);\n      if (!isStringArray(evaluatedStyleUrls)) {\n        throw createValueHasWrongTypeError(\n            styleUrlsExpr, evaluatedStyleUrls, 'styleUrls must be an array of strings');\n      }\n\n      for (const styleUrl of evaluatedStyleUrls) {\n        styleUrls.push({\n          url: styleUrl,\n          source: ResourceTypeForDiagnostics.StylesheetFromDecorator,\n          nodeForError: styleUrlsExpr,\n        });\n      }\n    }\n\n    return styleUrls;\n  }\n\n  private _extractStyleResources(component: Map<string, ts.Expression>, containingFile: string):\n      ReadonlySet<Resource> {\n    const styles = new Set<Resource>();\n    function stringLiteralElements(array: ts.ArrayLiteralExpression): ts.StringLiteralLike[] {\n      return array.elements.filter(\n          (e: ts.Expression): e is ts.StringLiteralLike => ts.isStringLiteralLike(e));\n    }\n\n    // If styleUrls is a literal array, process each resource url individually and\n    // register ones that are string literals.\n    const styleUrlsExpr = component.get('styleUrls');\n    if (styleUrlsExpr !== undefined && ts.isArrayLiteralExpression(styleUrlsExpr)) {\n      for (const expression of stringLiteralElements(styleUrlsExpr)) {\n        try {\n          const resourceUrl = this.resourceLoader.resolve(expression.text, containingFile);\n          styles.add({path: absoluteFrom(resourceUrl), expression});\n        } catch {\n          // Errors in style resource extraction do not need to be handled here. We will produce\n          // diagnostics for each one that fails in the analysis, after we evaluate the `styleUrls`\n          // expression to determine _all_ style resources, not just the string literals.\n        }\n      }\n    }\n\n    const stylesExpr = component.get('styles');\n    if (stylesExpr !== undefined && ts.isArrayLiteralExpression(stylesExpr)) {\n      for (const expression of stringLiteralElements(stylesExpr)) {\n        styles.add({path: null, expression});\n      }\n    }\n\n    return styles;\n  }\n\n  private _preloadAndParseTemplate(\n      node: ClassDeclaration, decorator: Decorator, component: Map<string, ts.Expression>,\n      containingFile: string): Promise<ParsedTemplateWithSource|null> {\n    if (component.has('templateUrl')) {\n      // Extract the templateUrl and preload it.\n      const templateUrlExpr = component.get('templateUrl')!;\n      const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n      if (typeof templateUrl !== 'string') {\n        throw createValueHasWrongTypeError(\n            templateUrlExpr, templateUrl, 'templateUrl must be a string');\n      }\n      try {\n        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n        const templatePromise = this.resourceLoader.preload(resourceUrl);\n\n        // If the preload worked, then actually load and parse the template, and wait for any style\n        // URLs to resolve.\n        if (templatePromise !== undefined) {\n          return templatePromise.then(() => {\n            const templateDecl =\n                this.parseTemplateDeclaration(decorator, component, containingFile);\n            const template = this.extractTemplate(node, templateDecl);\n            this.preanalyzeTemplateCache.set(node, template);\n            return template;\n          });\n        } else {\n          return Promise.resolve(null);\n        }\n      } catch (e) {\n        throw this.makeResourceNotFoundError(\n            templateUrl, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n      }\n    } else {\n      const templateDecl = this.parseTemplateDeclaration(decorator, component, containingFile);\n      const template = this.extractTemplate(node, templateDecl);\n      this.preanalyzeTemplateCache.set(node, template);\n      return Promise.resolve(template);\n    }\n  }\n\n  private extractTemplate(node: ClassDeclaration, template: TemplateDeclaration):\n      ParsedTemplateWithSource {\n    if (template.isInline) {\n      let templateStr: string;\n      let templateLiteral: ts.Node|null = null;\n      let templateUrl: string = '';\n      let templateRange: LexerRange|null = null;\n      let sourceMapping: TemplateSourceMapping;\n      let escapedString = false;\n      // We only support SourceMaps for inline templates that are simple string literals.\n      if (ts.isStringLiteral(template.expression) ||\n          ts.isNoSubstitutionTemplateLiteral(template.expression)) {\n        // the start and end of the `templateExpr` node includes the quotation marks, which we must\n        // strip\n        templateRange = getTemplateRange(template.expression);\n        templateStr = template.expression.getSourceFile().text;\n        templateLiteral = template.expression;\n        templateUrl = template.templateUrl;\n        escapedString = true;\n        sourceMapping = {\n          type: 'direct',\n          node: template.expression,\n        };\n      } else {\n        const resolvedTemplate = this.evaluator.evaluate(template.expression);\n        if (typeof resolvedTemplate !== 'string') {\n          throw createValueHasWrongTypeError(\n              template.expression, resolvedTemplate, 'template must be a string');\n        }\n        templateStr = resolvedTemplate;\n        sourceMapping = {\n          type: 'indirect',\n          node: template.expression,\n          componentClass: node,\n          template: templateStr,\n        };\n      }\n\n      return {\n        ...this._parseTemplate(template, templateStr, templateRange, escapedString),\n        sourceMapping,\n        declaration: template,\n      };\n    } else {\n      const templateStr = this.resourceLoader.load(template.resolvedTemplateUrl);\n      if (this.depTracker !== null) {\n        this.depTracker.addResourceDependency(\n            node.getSourceFile(), absoluteFrom(template.resolvedTemplateUrl));\n      }\n\n      return {\n        ...this._parseTemplate(\n            template, templateStr, /* templateRange */ null,\n            /* escapedString */ false),\n        sourceMapping: {\n          type: 'external',\n          componentClass: node,\n          // TODO(alxhub): TS in g3 is unable to make this inference on its own, so cast it here\n          // until g3 is able to figure this out.\n          node: (template as ExternalTemplateDeclaration).templateUrlExpression,\n          template: templateStr,\n          templateUrl: template.resolvedTemplateUrl,\n        },\n        declaration: template,\n      };\n    }\n  }\n\n  private _parseTemplate(\n      template: TemplateDeclaration, templateStr: string, templateRange: LexerRange|null,\n      escapedString: boolean): ParsedComponentTemplate {\n    // We always normalize line endings if the template has been escaped (i.e. is inline).\n    const i18nNormalizeLineEndingsInICUs = escapedString || this.i18nNormalizeLineEndingsInICUs;\n\n    const parsedTemplate = parseTemplate(templateStr, template.sourceMapUrl, {\n      preserveWhitespaces: template.preserveWhitespaces,\n      interpolationConfig: template.interpolationConfig,\n      range: templateRange ?? undefined,\n      escapedString,\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs,\n      isInline: template.isInline,\n      alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData,\n    });\n\n    // Unfortunately, the primary parse of the template above may not contain accurate source map\n    // information. If used directly, it would result in incorrect code locations in template\n    // errors, etc. There are three main problems:\n    //\n    // 1. `preserveWhitespaces: false` annihilates the correctness of template source mapping, as\n    //    the whitespace transformation changes the contents of HTML text nodes before they're\n    //    parsed into Angular expressions.\n    // 2. `preserveLineEndings: false` causes growing misalignments in templates that use '\\r\\n'\n    //    line endings, by normalizing them to '\\n'.\n    // 3. By default, the template parser strips leading trivia characters (like spaces, tabs, and\n    //    newlines). This also destroys source mapping information.\n    //\n    // In order to guarantee the correctness of diagnostics, templates are parsed a second time\n    // with the above options set to preserve source mappings.\n\n    const {nodes: diagNodes} = parseTemplate(templateStr, template.sourceMapUrl, {\n      preserveWhitespaces: true,\n      preserveLineEndings: true,\n      interpolationConfig: template.interpolationConfig,\n      range: templateRange ?? undefined,\n      escapedString,\n      enableI18nLegacyMessageIdFormat: this.enableI18nLegacyMessageIdFormat,\n      i18nNormalizeLineEndingsInICUs,\n      leadingTriviaChars: [],\n      isInline: template.isInline,\n      alwaysAttemptHtmlToR3AstConversion: this.usePoisonedData,\n    });\n\n    return {\n      ...parsedTemplate,\n      diagNodes,\n      template: template.isInline ? new WrappedNodeExpr(template.expression) : templateStr,\n      templateUrl: template.resolvedTemplateUrl,\n      isInline: template.isInline,\n      file: new ParseSourceFile(templateStr, template.resolvedTemplateUrl),\n    };\n  }\n\n  private parseTemplateDeclaration(\n      decorator: Decorator, component: Map<string, ts.Expression>,\n      containingFile: string): TemplateDeclaration {\n    let preserveWhitespaces: boolean = this.defaultPreserveWhitespaces;\n    if (component.has('preserveWhitespaces')) {\n      const expr = component.get('preserveWhitespaces')!;\n      const value = this.evaluator.evaluate(expr);\n      if (typeof value !== 'boolean') {\n        throw createValueHasWrongTypeError(expr, value, 'preserveWhitespaces must be a boolean');\n      }\n      preserveWhitespaces = value;\n    }\n\n    let interpolationConfig = DEFAULT_INTERPOLATION_CONFIG;\n    if (component.has('interpolation')) {\n      const expr = component.get('interpolation')!;\n      const value = this.evaluator.evaluate(expr);\n      if (!Array.isArray(value) || value.length !== 2 ||\n          !value.every(element => typeof element === 'string')) {\n        throw createValueHasWrongTypeError(\n            expr, value, 'interpolation must be an array with 2 elements of string type');\n      }\n      interpolationConfig = InterpolationConfig.fromArray(value as [string, string]);\n    }\n\n    if (component.has('templateUrl')) {\n      const templateUrlExpr = component.get('templateUrl')!;\n      const templateUrl = this.evaluator.evaluate(templateUrlExpr);\n      if (typeof templateUrl !== 'string') {\n        throw createValueHasWrongTypeError(\n            templateUrlExpr, templateUrl, 'templateUrl must be a string');\n      }\n      try {\n        const resourceUrl = this.resourceLoader.resolve(templateUrl, containingFile);\n        return {\n          isInline: false,\n          interpolationConfig,\n          preserveWhitespaces,\n          templateUrl,\n          templateUrlExpression: templateUrlExpr,\n          resolvedTemplateUrl: resourceUrl,\n          sourceMapUrl: sourceMapUrl(resourceUrl),\n        };\n      } catch (e) {\n        throw this.makeResourceNotFoundError(\n            templateUrl, templateUrlExpr, ResourceTypeForDiagnostics.Template);\n      }\n    } else if (component.has('template')) {\n      return {\n        isInline: true,\n        interpolationConfig,\n        preserveWhitespaces,\n        expression: component.get('template')!,\n        templateUrl: containingFile,\n        resolvedTemplateUrl: containingFile,\n        sourceMapUrl: containingFile,\n      };\n    } else {\n      throw new FatalDiagnosticError(\n          ErrorCode.COMPONENT_MISSING_TEMPLATE, Decorator.nodeForError(decorator),\n          'component is missing a template');\n    }\n  }\n\n  private _resolveImportedFile(importedFile: ImportedFile, expr: Expression, origin: ts.SourceFile):\n      ts.SourceFile|null {\n    // If `importedFile` is not 'unknown' then it accurately reflects the source file that is\n    // being imported.\n    if (importedFile !== 'unknown') {\n      return importedFile;\n    }\n\n    // Otherwise `expr` has to be inspected to determine the file that is being imported. If `expr`\n    // is not an `ExternalExpr` then it does not correspond with an import, so return null in that\n    // case.\n    if (!(expr instanceof ExternalExpr)) {\n      return null;\n    }\n\n    // Figure out what file is being imported.\n    return this.moduleResolver.resolveModule(expr.value.moduleName!, origin.fileName);\n  }\n\n  /**\n   * Check whether adding an import from `origin` to the source-file corresponding to `expr` would\n   * create a cyclic import.\n   *\n   * @returns a `Cycle` object if a cycle would be created, otherwise `null`.\n   */\n  private _checkForCyclicImport(\n      importedFile: ImportedFile, expr: Expression, origin: ts.SourceFile): Cycle|null {\n    const imported = this._resolveImportedFile(importedFile, expr, origin);\n    if (imported === null) {\n      return null;\n    }\n    // Check whether the import is legal.\n    return this.cycleAnalyzer.wouldCreateCycle(origin, imported);\n  }\n\n  private _recordSyntheticImport(\n      importedFile: ImportedFile, expr: Expression, origin: ts.SourceFile): void {\n    const imported = this._resolveImportedFile(importedFile, expr, origin);\n    if (imported === null) {\n      return;\n    }\n\n    this.cycleAnalyzer.recordSyntheticImport(origin, imported);\n  }\n\n  private makeResourceNotFoundError(\n      file: string, nodeForError: ts.Node,\n      resourceType: ResourceTypeForDiagnostics): FatalDiagnosticError {\n    let errorText: string;\n    switch (resourceType) {\n      case ResourceTypeForDiagnostics.Template:\n        errorText = `Could not find template file '${file}'.`;\n        break;\n      case ResourceTypeForDiagnostics.StylesheetFromTemplate:\n        errorText = `Could not find stylesheet file '${file}' linked from the template.`;\n        break;\n      case ResourceTypeForDiagnostics.StylesheetFromDecorator:\n        errorText = `Could not find stylesheet file '${file}'.`;\n        break;\n    }\n\n    return new FatalDiagnosticError(\n        ErrorCode.COMPONENT_RESOURCE_NOT_FOUND, nodeForError, errorText);\n  }\n\n  private _extractTemplateStyleUrls(template: ParsedTemplateWithSource): StyleUrlMeta[] {\n    if (template.styleUrls === null) {\n      return [];\n    }\n\n    const nodeForError = getTemplateDeclarationNodeForError(template.declaration);\n    return template.styleUrls.map(\n        url => ({url, source: ResourceTypeForDiagnostics.StylesheetFromTemplate, nodeForError}));\n  }\n}\n\nfunction getTemplateRange(templateExpr: ts.Expression) {\n  const startPos = templateExpr.getStart() + 1;\n  const {line, character} =\n      ts.getLineAndCharacterOfPosition(templateExpr.getSourceFile(), startPos);\n  return {\n    startPos,\n    startLine: line,\n    startCol: character,\n    endPos: templateExpr.getEnd() - 1,\n  };\n}\n\nfunction sourceMapUrl(resourceUrl: string): string {\n  if (!tsSourceMapBug29300Fixed()) {\n    // By removing the template URL we are telling the translator not to try to\n    // map the external source file to the generated code, since the version\n    // of TS that is running does not support it.\n    return '';\n  } else {\n    return resourceUrl;\n  }\n}\n\n/** Determines if the result of an evaluation is a string array. */\nfunction isStringArray(resolvedValue: ResolvedValue): resolvedValue is string[] {\n  return Array.isArray(resolvedValue) && resolvedValue.every(elem => typeof elem === 'string');\n}\n\n/** Determines the node to use for debugging purposes for the given TemplateDeclaration. */\nfunction getTemplateDeclarationNodeForError(declaration: TemplateDeclaration): ts.Node {\n  // TODO(zarend): Change this to if/else when that is compatible with g3. This uses a switch\n  // because if/else fails to compile on g3. That is because g3 compiles this in non-strict mode\n  // where type inference does not work correctly.\n  switch (declaration.isInline) {\n    case true:\n      return declaration.expression;\n    case false:\n      return declaration.templateUrlExpression;\n  }\n}\n\n/**\n * Information about the template which was extracted during parsing.\n *\n * This contains the actual parsed template as well as any metadata collected during its parsing,\n * some of which might be useful for re-parsing the template with different options.\n */\nexport interface ParsedComponentTemplate extends ParsedTemplate {\n  /**\n   * True if the original template was stored inline;\n   * False if the template was in an external file.\n   */\n  isInline: boolean;\n\n  /**\n   * The template AST, parsed in a manner which preserves source map information for diagnostics.\n   *\n   * Not useful for emit.\n   */\n  diagNodes: TmplAstNode[];\n\n  /**\n   * The `ParseSourceFile` for the template.\n   */\n  file: ParseSourceFile;\n}\n\nexport interface ParsedTemplateWithSource extends ParsedComponentTemplate {\n  sourceMapping: TemplateSourceMapping;\n  declaration: TemplateDeclaration;\n}\n\n/**\n * Common fields extracted from the declaration of a template.\n */\ninterface CommonTemplateDeclaration {\n  preserveWhitespaces: boolean;\n  interpolationConfig: InterpolationConfig;\n  templateUrl: string;\n  resolvedTemplateUrl: string;\n  sourceMapUrl: string;\n}\n\n/**\n * Information extracted from the declaration of an inline template.\n */\ninterface InlineTemplateDeclaration extends CommonTemplateDeclaration {\n  isInline: true;\n  expression: ts.Expression;\n}\n\n/**\n * Information extracted from the declaration of an external template.\n */\ninterface ExternalTemplateDeclaration extends CommonTemplateDeclaration {\n  isInline: false;\n  templateUrlExpression: ts.Expression;\n}\n\n/**\n * The declaration of a template extracted from a component decorator.\n *\n * This data is extracted and stored separately to faciliate re-interpreting the template\n * declaration whenever the compiler is notified of a change to a template file. With this\n * information, `ComponentDecoratorHandler` is able to re-read the template and update the component\n * record without needing to parse the original decorator again.\n */\ntype TemplateDeclaration = InlineTemplateDeclaration|ExternalTemplateDeclaration;\n\n/**\n * Generate a diagnostic related information object that describes a potential cyclic import path.\n */\nfunction makeCyclicImportInfo(\n    ref: Reference, type: string, cycle: Cycle): ts.DiagnosticRelatedInformation {\n  const name = ref.debugName || '(unknown)';\n  const path = cycle.getPath().map(sf => sf.fileName).join(' -> ');\n  const message =\n      `The ${type} '${name}' is used in the template but importing it would create a cycle: `;\n  return makeRelatedInformation(ref.node, message + path);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}