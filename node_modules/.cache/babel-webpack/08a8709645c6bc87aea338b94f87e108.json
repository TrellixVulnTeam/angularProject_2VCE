{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertImport = exports.insertStarImport = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar ts = require(\"typescript\");\n\nvar ast_helpers_1 = require(\"./ast_helpers\");\n\nvar interfaces_1 = require(\"./interfaces\");\n\nfunction insertStarImport(sourceFile, identifier, modulePath, target) {\n  var before = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var ops = [];\n  var allImports = ast_helpers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.ImportDeclaration); // We don't need to verify if the symbol is already imported, star imports should be unique.\n  // Create the new import node.\n\n  var namespaceImport = ts.createNamespaceImport(identifier);\n  var importClause = ts.createImportClause(undefined, namespaceImport);\n  var newImport = ts.createImportDeclaration(undefined, undefined, importClause, ts.createLiteral(modulePath));\n\n  if (target) {\n    ops.push(new interfaces_1.AddNodeOperation(sourceFile, target, before ? newImport : undefined, before ? undefined : newImport));\n  } else if (allImports.length > 0) {\n    // Find the last import and insert after.\n    ops.push(new interfaces_1.AddNodeOperation(sourceFile, allImports[allImports.length - 1], undefined, newImport));\n  } else {\n    var firstNode = ast_helpers_1.getFirstNode(sourceFile);\n\n    if (firstNode) {\n      // Insert before the first node.\n      ops.push(new interfaces_1.AddNodeOperation(sourceFile, firstNode, newImport));\n    }\n  }\n\n  return ops;\n}\n\nexports.insertStarImport = insertStarImport;\n\nfunction insertImport(sourceFile, symbolName, modulePath) {\n  var ops = []; // Find all imports.\n\n  var allImports = ast_helpers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.ImportDeclaration);\n  var maybeImports = allImports.filter(ts.isImportDeclaration).filter(function (node) {\n    // Filter all imports that do not match the modulePath.\n    return node.moduleSpecifier.kind == ts.SyntaxKind.StringLiteral && node.moduleSpecifier.text == modulePath;\n  }).filter(function (node) {\n    // Filter out import statements that are either `import 'XYZ'` or `import * as X from 'XYZ'`.\n    var clause = node.importClause;\n\n    if (!clause || clause.name || !clause.namedBindings) {\n      return false;\n    }\n\n    return clause.namedBindings.kind == ts.SyntaxKind.NamedImports;\n  }).map(function (node) {\n    // Return the `{ ... }` list of the named import.\n    return node.importClause.namedBindings;\n  });\n\n  if (maybeImports.length) {\n    // There's an `import {A, B, C} from 'modulePath'`.\n    // Find if it's in either imports. If so, just return; nothing to do.\n    var hasImportAlready = maybeImports.some(function (node) {\n      return node.elements.some(function (element) {\n        return element.name.text == symbolName;\n      });\n    });\n\n    if (hasImportAlready) {\n      return ops;\n    } // Just pick the first one and insert at the end of its identifier list.\n\n\n    ops.push(new interfaces_1.AddNodeOperation(sourceFile, maybeImports[0].elements[maybeImports[0].elements.length - 1], undefined, ts.createImportSpecifier(undefined, ts.createIdentifier(symbolName))));\n  } else {\n    // Create the new import node.\n    var namedImports = ts.createNamedImports([ts.createImportSpecifier(undefined, ts.createIdentifier(symbolName))]);\n    var importClause = ts.createImportClause(undefined, namedImports);\n    var newImport = ts.createImportDeclaration(undefined, undefined, importClause, ts.createLiteral(modulePath));\n\n    if (allImports.length > 0) {\n      // Find the last import and insert after.\n      ops.push(new interfaces_1.AddNodeOperation(sourceFile, allImports[allImports.length - 1], undefined, newImport));\n    } else {\n      var firstNode = ast_helpers_1.getFirstNode(sourceFile);\n\n      if (firstNode) {\n        // Insert before the first node.\n        ops.push(new interfaces_1.AddNodeOperation(sourceFile, firstNode, newImport));\n      }\n    }\n  }\n\n  return ops;\n}\n\nexports.insertImport = insertImport;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/transformers/insert_import.js"],"names":["Object","defineProperty","exports","value","insertImport","insertStarImport","ts","require","ast_helpers_1","interfaces_1","sourceFile","identifier","modulePath","target","before","ops","allImports","collectDeepNodes","SyntaxKind","ImportDeclaration","namespaceImport","createNamespaceImport","importClause","createImportClause","undefined","newImport","createImportDeclaration","createLiteral","push","AddNodeOperation","length","firstNode","getFirstNode","symbolName","maybeImports","filter","isImportDeclaration","node","moduleSpecifier","kind","StringLiteral","text","clause","name","namedBindings","NamedImports","map","hasImportAlready","some","elements","element","createImportSpecifier","createIdentifier","namedImports","createNamedImports"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuBF,OAAO,CAACG,gBAAR,GAA2B,KAAK,CAAvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,EAAE,GAAGC,OAAO,CAAC,YAAD,CAAlB;;AACA,IAAMC,aAAa,GAAGD,OAAO,CAAC,eAAD,CAA7B;;AACA,IAAME,YAAY,GAAGF,OAAO,CAAC,cAAD,CAA5B;;AACA,SAASF,gBAAT,CAA0BK,UAA1B,EAAsCC,UAAtC,EAAkDC,UAAlD,EAA8DC,MAA9D,EAAsF;AAAA,MAAhBC,MAAgB,uEAAP,KAAO;AAClF,MAAMC,GAAG,GAAG,EAAZ;AACA,MAAMC,UAAU,GAAGR,aAAa,CAACS,gBAAd,CAA+BP,UAA/B,EAA2CJ,EAAE,CAACY,UAAH,CAAcC,iBAAzD,CAAnB,CAFkF,CAGlF;AACA;;AACA,MAAMC,eAAe,GAAGd,EAAE,CAACe,qBAAH,CAAyBV,UAAzB,CAAxB;AACA,MAAMW,YAAY,GAAGhB,EAAE,CAACiB,kBAAH,CAAsBC,SAAtB,EAAiCJ,eAAjC,CAArB;AACA,MAAMK,SAAS,GAAGnB,EAAE,CAACoB,uBAAH,CAA2BF,SAA3B,EAAsCA,SAAtC,EAAiDF,YAAjD,EAA+DhB,EAAE,CAACqB,aAAH,CAAiBf,UAAjB,CAA/D,CAAlB;;AACA,MAAIC,MAAJ,EAAY;AACRE,IAAAA,GAAG,CAACa,IAAJ,CAAS,IAAInB,YAAY,CAACoB,gBAAjB,CAAkCnB,UAAlC,EAA8CG,MAA9C,EAAsDC,MAAM,GAAGW,SAAH,GAAeD,SAA3E,EAAsFV,MAAM,GAAGU,SAAH,GAAeC,SAA3G,CAAT;AACH,GAFD,MAGK,IAAIT,UAAU,CAACc,MAAX,GAAoB,CAAxB,EAA2B;AAC5B;AACAf,IAAAA,GAAG,CAACa,IAAJ,CAAS,IAAInB,YAAY,CAACoB,gBAAjB,CAAkCnB,UAAlC,EAA8CM,UAAU,CAACA,UAAU,CAACc,MAAX,GAAoB,CAArB,CAAxD,EAAiFN,SAAjF,EAA4FC,SAA5F,CAAT;AACH,GAHI,MAIA;AACD,QAAMM,SAAS,GAAGvB,aAAa,CAACwB,YAAd,CAA2BtB,UAA3B,CAAlB;;AACA,QAAIqB,SAAJ,EAAe;AACX;AACAhB,MAAAA,GAAG,CAACa,IAAJ,CAAS,IAAInB,YAAY,CAACoB,gBAAjB,CAAkCnB,UAAlC,EAA8CqB,SAA9C,EAAyDN,SAAzD,CAAT;AACH;AACJ;;AACD,SAAOV,GAAP;AACH;;AACDb,OAAO,CAACG,gBAAR,GAA2BA,gBAA3B;;AACA,SAASD,YAAT,CAAsBM,UAAtB,EAAkCuB,UAAlC,EAA8CrB,UAA9C,EAA0D;AACtD,MAAMG,GAAG,GAAG,EAAZ,CADsD,CAEtD;;AACA,MAAMC,UAAU,GAAGR,aAAa,CAACS,gBAAd,CAA+BP,UAA/B,EAA2CJ,EAAE,CAACY,UAAH,CAAcC,iBAAzD,CAAnB;AACA,MAAMe,YAAY,GAAGlB,UAAU,CAC1BmB,MADgB,CACT7B,EAAE,CAAC8B,mBADM,EAEhBD,MAFgB,CAET,UAACE,IAAD,EAAU;AAClB;AACA,WAAOA,IAAI,CAACC,eAAL,CAAqBC,IAArB,IAA6BjC,EAAE,CAACY,UAAH,CAAcsB,aAA3C,IACAH,IAAI,CAACC,eAAL,CAAqBG,IAArB,IAA6B7B,UADpC;AAEH,GANoB,EAOhBuB,MAPgB,CAOT,UAACE,IAAD,EAAU;AAClB;AACA,QAAMK,MAAM,GAAGL,IAAI,CAACf,YAApB;;AACA,QAAI,CAACoB,MAAD,IAAWA,MAAM,CAACC,IAAlB,IAA0B,CAACD,MAAM,CAACE,aAAtC,EAAqD;AACjD,aAAO,KAAP;AACH;;AACD,WAAOF,MAAM,CAACE,aAAP,CAAqBL,IAArB,IAA6BjC,EAAE,CAACY,UAAH,CAAc2B,YAAlD;AACH,GAdoB,EAehBC,GAfgB,CAeZ,UAACT,IAAD,EAAU;AACf;AACA,WAAOA,IAAI,CAACf,YAAL,CAAkBsB,aAAzB;AACH,GAlBoB,CAArB;;AAmBA,MAAIV,YAAY,CAACJ,MAAjB,EAAyB;AACrB;AACA;AACA,QAAMiB,gBAAgB,GAAGb,YAAY,CAACc,IAAb,CAAkB,UAACX,IAAD,EAAU;AACjD,aAAOA,IAAI,CAACY,QAAL,CAAcD,IAAd,CAAmB,UAACE,OAAD,EAAa;AACnC,eAAOA,OAAO,CAACP,IAAR,CAAaF,IAAb,IAAqBR,UAA5B;AACH,OAFM,CAAP;AAGH,KAJwB,CAAzB;;AAKA,QAAIc,gBAAJ,EAAsB;AAClB,aAAOhC,GAAP;AACH,KAVoB,CAWrB;;;AACAA,IAAAA,GAAG,CAACa,IAAJ,CAAS,IAAInB,YAAY,CAACoB,gBAAjB,CAAkCnB,UAAlC,EAA8CwB,YAAY,CAAC,CAAD,CAAZ,CAAgBe,QAAhB,CAAyBf,YAAY,CAAC,CAAD,CAAZ,CAAgBe,QAAhB,CAAyBnB,MAAzB,GAAkC,CAA3D,CAA9C,EAA6GN,SAA7G,EAAwHlB,EAAE,CAAC6C,qBAAH,CAAyB3B,SAAzB,EAAoClB,EAAE,CAAC8C,gBAAH,CAAoBnB,UAApB,CAApC,CAAxH,CAAT;AACH,GAbD,MAcK;AACD;AACA,QAAMoB,YAAY,GAAG/C,EAAE,CAACgD,kBAAH,CAAsB,CAAChD,EAAE,CAAC6C,qBAAH,CAAyB3B,SAAzB,EAAoClB,EAAE,CAAC8C,gBAAH,CAAoBnB,UAApB,CAApC,CAAD,CAAtB,CAArB;AACA,QAAMX,YAAY,GAAGhB,EAAE,CAACiB,kBAAH,CAAsBC,SAAtB,EAAiC6B,YAAjC,CAArB;AACA,QAAM5B,SAAS,GAAGnB,EAAE,CAACoB,uBAAH,CAA2BF,SAA3B,EAAsCA,SAAtC,EAAiDF,YAAjD,EAA+DhB,EAAE,CAACqB,aAAH,CAAiBf,UAAjB,CAA/D,CAAlB;;AACA,QAAII,UAAU,CAACc,MAAX,GAAoB,CAAxB,EAA2B;AACvB;AACAf,MAAAA,GAAG,CAACa,IAAJ,CAAS,IAAInB,YAAY,CAACoB,gBAAjB,CAAkCnB,UAAlC,EAA8CM,UAAU,CAACA,UAAU,CAACc,MAAX,GAAoB,CAArB,CAAxD,EAAiFN,SAAjF,EAA4FC,SAA5F,CAAT;AACH,KAHD,MAIK;AACD,UAAMM,SAAS,GAAGvB,aAAa,CAACwB,YAAd,CAA2BtB,UAA3B,CAAlB;;AACA,UAAIqB,SAAJ,EAAe;AACX;AACAhB,QAAAA,GAAG,CAACa,IAAJ,CAAS,IAAInB,YAAY,CAACoB,gBAAjB,CAAkCnB,UAAlC,EAA8CqB,SAA9C,EAAyDN,SAAzD,CAAT;AACH;AACJ;AACJ;;AACD,SAAOV,GAAP;AACH;;AACDb,OAAO,CAACE,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.insertImport = exports.insertStarImport = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst ts = require(\"typescript\");\nconst ast_helpers_1 = require(\"./ast_helpers\");\nconst interfaces_1 = require(\"./interfaces\");\nfunction insertStarImport(sourceFile, identifier, modulePath, target, before = false) {\n    const ops = [];\n    const allImports = ast_helpers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.ImportDeclaration);\n    // We don't need to verify if the symbol is already imported, star imports should be unique.\n    // Create the new import node.\n    const namespaceImport = ts.createNamespaceImport(identifier);\n    const importClause = ts.createImportClause(undefined, namespaceImport);\n    const newImport = ts.createImportDeclaration(undefined, undefined, importClause, ts.createLiteral(modulePath));\n    if (target) {\n        ops.push(new interfaces_1.AddNodeOperation(sourceFile, target, before ? newImport : undefined, before ? undefined : newImport));\n    }\n    else if (allImports.length > 0) {\n        // Find the last import and insert after.\n        ops.push(new interfaces_1.AddNodeOperation(sourceFile, allImports[allImports.length - 1], undefined, newImport));\n    }\n    else {\n        const firstNode = ast_helpers_1.getFirstNode(sourceFile);\n        if (firstNode) {\n            // Insert before the first node.\n            ops.push(new interfaces_1.AddNodeOperation(sourceFile, firstNode, newImport));\n        }\n    }\n    return ops;\n}\nexports.insertStarImport = insertStarImport;\nfunction insertImport(sourceFile, symbolName, modulePath) {\n    const ops = [];\n    // Find all imports.\n    const allImports = ast_helpers_1.collectDeepNodes(sourceFile, ts.SyntaxKind.ImportDeclaration);\n    const maybeImports = allImports\n        .filter(ts.isImportDeclaration)\n        .filter((node) => {\n        // Filter all imports that do not match the modulePath.\n        return node.moduleSpecifier.kind == ts.SyntaxKind.StringLiteral\n            && node.moduleSpecifier.text == modulePath;\n    })\n        .filter((node) => {\n        // Filter out import statements that are either `import 'XYZ'` or `import * as X from 'XYZ'`.\n        const clause = node.importClause;\n        if (!clause || clause.name || !clause.namedBindings) {\n            return false;\n        }\n        return clause.namedBindings.kind == ts.SyntaxKind.NamedImports;\n    })\n        .map((node) => {\n        // Return the `{ ... }` list of the named import.\n        return node.importClause.namedBindings;\n    });\n    if (maybeImports.length) {\n        // There's an `import {A, B, C} from 'modulePath'`.\n        // Find if it's in either imports. If so, just return; nothing to do.\n        const hasImportAlready = maybeImports.some((node) => {\n            return node.elements.some((element) => {\n                return element.name.text == symbolName;\n            });\n        });\n        if (hasImportAlready) {\n            return ops;\n        }\n        // Just pick the first one and insert at the end of its identifier list.\n        ops.push(new interfaces_1.AddNodeOperation(sourceFile, maybeImports[0].elements[maybeImports[0].elements.length - 1], undefined, ts.createImportSpecifier(undefined, ts.createIdentifier(symbolName))));\n    }\n    else {\n        // Create the new import node.\n        const namedImports = ts.createNamedImports([ts.createImportSpecifier(undefined, ts.createIdentifier(symbolName))]);\n        const importClause = ts.createImportClause(undefined, namedImports);\n        const newImport = ts.createImportDeclaration(undefined, undefined, importClause, ts.createLiteral(modulePath));\n        if (allImports.length > 0) {\n            // Find the last import and insert after.\n            ops.push(new interfaces_1.AddNodeOperation(sourceFile, allImports[allImports.length - 1], undefined, newImport));\n        }\n        else {\n            const firstNode = ast_helpers_1.getFirstNode(sourceFile);\n            if (firstNode) {\n                // Insert before the first node.\n                ops.push(new interfaces_1.AddNodeOperation(sourceFile, firstNode, newImport));\n            }\n        }\n    }\n    return ops;\n}\nexports.insertImport = insertImport;\n"]},"metadata":{},"sourceType":"script"}