{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _core = require(\"@babel/core\");\n\nvar _schema = require(\"@istanbuljs/schema\");\n\nvar _sourceCoverage = require(\"./source-coverage\");\n\nvar _constants = require(\"./constants\"); // pattern for istanbul to ignore a section\n\n\nvar COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/; // pattern for istanbul to ignore the whole file\n\nvar COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/; // source map URL pattern\n\nvar SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m; // generate a variable name from hashing the supplied file path\n\nfunction genVar(filename) {\n  var hash = (0, _crypto.createHash)(_constants.SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n} // VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\n\n\nvar VisitState = /*#__PURE__*/function () {\n  function VisitState(types, sourceFilePath, inputSourceMap) {\n    var ignoreClassMethods = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    _classCallCheck(this, VisitState);\n\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);\n\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n  } // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n\n\n  _createClass(VisitState, [{\n    key: \"shouldIgnore\",\n    value: function shouldIgnore(path) {\n      return this.nextIgnore || !path.node.loc;\n    } // extract the ignore comment hint (next|if|else) or null\n\n  }, {\n    key: \"hintFor\",\n    value: function hintFor(node) {\n      var hint = null;\n\n      if (node.leadingComments) {\n        node.leadingComments.forEach(function (c) {\n          var v = (c.value ||\n          /* istanbul ignore next: paranoid check */\n          '').trim();\n          var groups = v.match(COMMENT_RE);\n\n          if (groups) {\n            hint = groups[1];\n          }\n        });\n      }\n\n      return hint;\n    } // extract a source map URL from comments and keep track of it\n\n  }, {\n    key: \"maybeAssignSourceMapURL\",\n    value: function maybeAssignSourceMapURL(node) {\n      var _this = this;\n\n      var extractURL = function extractURL(comments) {\n        if (!comments) {\n          return;\n        }\n\n        comments.forEach(function (c) {\n          var v = (c.value ||\n          /* istanbul ignore next: paranoid check */\n          '').trim();\n          var groups = v.match(SOURCE_MAP_RE);\n\n          if (groups) {\n            _this.sourceMappingURL = groups[1];\n          }\n        });\n      };\n\n      extractURL(node.leadingComments);\n      extractURL(node.trailingComments);\n    } // for these expressions the statement counter needs to be hoisted, so\n    // function name inference can be preserved\n\n  }, {\n    key: \"counterNeedsHoisting\",\n    value: function counterNeedsHoisting(path) {\n      return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n    } // all the generic stuff that needs to be done on enter for every node\n\n  }, {\n    key: \"onEnter\",\n    value: function onEnter(path) {\n      var n = path.node;\n      this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do\n\n      if (this.nextIgnore !== null) {\n        return;\n      } // check hint to see if ignore should be turned on\n\n\n      var hint = this.hintFor(n);\n\n      if (hint === 'next') {\n        this.nextIgnore = n;\n        return;\n      } // else check custom node attribute set by a prior visitor\n\n\n      if (this.getAttr(path.node, 'skip-all') !== null) {\n        this.nextIgnore = n;\n      } // else check for ignored class methods\n\n\n      if (path.isFunctionExpression() && this.ignoreClassMethods.some(function (name) {\n        return path.node.id && name === path.node.id.name;\n      })) {\n        this.nextIgnore = n;\n        return;\n      }\n\n      if (path.isClassMethod() && this.ignoreClassMethods.some(function (name) {\n        return name === path.node.key.name;\n      })) {\n        this.nextIgnore = n;\n        return;\n      }\n    } // all the generic stuff on exit of a node,\n    // including reseting ignores and custom node attrs\n\n  }, {\n    key: \"onExit\",\n    value: function onExit(path) {\n      // restore ignore status, if needed\n      if (path.node === this.nextIgnore) {\n        this.nextIgnore = null;\n      } // nuke all attributes for the node\n\n\n      delete path.node.__cov__;\n    } // set a node attribute for the supplied node\n\n  }, {\n    key: \"setAttr\",\n    value: function setAttr(node, name, value) {\n      node.__cov__ = node.__cov__ || {};\n      node.__cov__[name] = value;\n    } // retrieve a node attribute for the supplied node or null\n\n  }, {\n    key: \"getAttr\",\n    value: function getAttr(node, name) {\n      var c = node.__cov__;\n\n      if (!c) {\n        return null;\n      }\n\n      return c[name];\n    } //\n\n  }, {\n    key: \"increase\",\n    value: function increase(type, id, index) {\n      var T = this.types;\n      var wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.\n      function (x) {\n        return T.memberExpression(x, T.numericLiteral(index), true);\n      } : function (x) {\n        return x;\n      };\n      return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(type)), T.numericLiteral(id), true)));\n    }\n  }, {\n    key: \"insertCounter\",\n    value: function insertCounter(path, increment) {\n      var T = this.types;\n\n      if (path.isBlockStatement()) {\n        path.node.body.unshift(T.expressionStatement(increment));\n      } else if (path.isStatement()) {\n        path.insertBefore(T.expressionStatement(increment));\n      } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n        // make an attempt to hoist the statement counter, so that\n        // function names are maintained.\n        var parent = path.parentPath.parentPath;\n\n        if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n          parent.parentPath.insertBefore(T.expressionStatement(increment));\n        } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n          parent.insertBefore(T.expressionStatement(increment));\n        } else {\n          path.replaceWith(T.sequenceExpression([increment, path.node]));\n        }\n      }\n      /* istanbul ignore else: not expected */\n      else if (path.isExpression()) {\n          path.replaceWith(T.sequenceExpression([increment, path.node]));\n        } else {\n          console.error('Unable to insert counter for node type:', path.node.type);\n        }\n    }\n  }, {\n    key: \"insertStatementCounter\",\n    value: function insertStatementCounter(path) {\n      /* istanbul ignore if: paranoid check */\n      if (!(path.node && path.node.loc)) {\n        return;\n      }\n\n      var index = this.cov.newStatement(path.node.loc);\n      var increment = this.increase('s', index, null);\n      this.insertCounter(path, increment);\n    }\n  }, {\n    key: \"insertFunctionCounter\",\n    value: function insertFunctionCounter(path) {\n      var T = this.types;\n      /* istanbul ignore if: paranoid check */\n\n      if (!(path.node && path.node.loc)) {\n        return;\n      }\n\n      var n = path.node;\n      var dloc = null; // get location for declaration\n\n      switch (n.type) {\n        case 'FunctionDeclaration':\n          /* istanbul ignore else: paranoid check */\n          if (n.id) {\n            dloc = n.id.loc;\n          }\n\n          break;\n\n        case 'FunctionExpression':\n          if (n.id) {\n            dloc = n.id.loc;\n          }\n\n          break;\n      }\n\n      if (!dloc) {\n        dloc = {\n          start: n.loc.start,\n          end: {\n            line: n.loc.start.line,\n            column: n.loc.start.column + 1\n          }\n        };\n      }\n\n      var name = path.node.id ? path.node.id.name : path.node.name;\n      var index = this.cov.newFunction(name, dloc, path.node.body.loc);\n      var increment = this.increase('f', index, null);\n      var body = path.get('body');\n      /* istanbul ignore else: not expected */\n\n      if (body.isBlockStatement()) {\n        body.node.body.unshift(T.expressionStatement(increment));\n      } else {\n        console.error('Unable to process function body node type:', path.node.type);\n      }\n    }\n  }, {\n    key: \"getBranchIncrement\",\n    value: function getBranchIncrement(branchName, loc) {\n      var index = this.cov.addBranchPath(branchName, loc);\n      return this.increase('b', branchName, index);\n    }\n  }, {\n    key: \"insertBranchCounter\",\n    value: function insertBranchCounter(path, branchName, loc) {\n      var increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n      this.insertCounter(path, increment);\n    }\n  }, {\n    key: \"findLeaves\",\n    value: function findLeaves(node, accumulator, parent, property) {\n      if (!node) {\n        return;\n      }\n\n      if (node.type === 'LogicalExpression') {\n        var hint = this.hintFor(node);\n\n        if (hint !== 'next') {\n          this.findLeaves(node.left, accumulator, node, 'left');\n          this.findLeaves(node.right, accumulator, node, 'right');\n        }\n      } else {\n        accumulator.push({\n          node: node,\n          parent: parent,\n          property: property\n        });\n      }\n    }\n  }]);\n\n  return VisitState;\n}(); // generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\n\n\nfunction entries() {\n  for (var _len = arguments.length, enter = new Array(_len), _key = 0; _key < _len; _key++) {\n    enter[_key] = arguments[_key];\n  }\n\n  // the enter function\n  var wrappedEntry = function wrappedEntry(path, node) {\n    var _this2 = this;\n\n    this.onEnter(path);\n\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n\n    enter.forEach(function (e) {\n      e.call(_this2, path, node);\n    });\n  };\n\n  var exit = function exit(path, node) {\n    this.onExit(path, node);\n  };\n\n  return {\n    enter: wrappedEntry,\n    exit: exit\n  };\n}\n\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n/* istanbul ignore next: no node.js support */\n\n\nfunction coverAssignmentPattern(path) {\n  var n = path.node;\n  var b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n  var T = this.types;\n\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n    path.node.body[0].leadingComments = path.node.leadingComments;\n    path.node.leadingComments = undefined;\n  }\n}\n\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  var T = this.types;\n\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\n\nfunction convertArrowExpression(path) {\n  var n = path.node;\n  var T = this.types;\n\n  if (!T.isBlockStatement(n.body)) {\n    var bloc = n.body.loc;\n\n    if (n.expression === true) {\n      n.expression = false;\n    }\n\n    n.body = T.blockStatement([T.returnStatement(n.body)]); // restore body location\n\n    n.body.loc = bloc; // set up the location for the return statement so it gets\n    // instrumented\n\n    n.body.body[0].loc = bloc;\n  }\n}\n\nfunction coverIfBranches(path) {\n  var n = path.node;\n  var hint = this.hintFor(n);\n  var ignoreIf = hint === 'if';\n  var ignoreElse = hint === 'else';\n  var branch = this.cov.newBranch('if', n.loc);\n\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch, n.loc);\n  }\n}\n\nfunction createSwitchBranch(path) {\n  var b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n  var T = this.types;\n  var b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n\n  var increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n  var n = path.node;\n  var branch = this.cov.newBranch('cond-expr', path.node.loc);\n  var cHint = this.hintFor(n.consequent);\n  var aHint = this.hintFor(n.alternate);\n\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction coverLogicalExpression(path) {\n  var T = this.types;\n\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  var leaves = [];\n  this.findLeaves(path.node, leaves);\n  var b = this.cov.newBranch('binary-expr', path.node.loc);\n\n  for (var i = 0; i < leaves.length; i += 1) {\n    var leaf = leaves[i];\n    var hint = this.hintFor(leaf.node);\n\n    if (hint === 'next') {\n      continue;\n    }\n\n    var increment = this.getBranchIncrement(b, leaf.node.loc);\n\n    if (!increment) {\n      continue;\n    }\n\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\n\nvar codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nvar globalTemplateAlteredFunction = (0, _core.template)(\"\\n        var Function = (function(){}).constructor;\\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\\n\");\nvar globalTemplateFunction = (0, _core.template)(\"\\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\\n\");\nvar globalTemplateVariable = (0, _core.template)(\"\\n        var global = GLOBAL_COVERAGE_SCOPE;\\n\"); // the template to insert at the top of the program.\n\nvar coverageTemplate = (0, _core.template)(\"\\n    function COVERAGE_FUNCTION () {\\n        var path = PATH;\\n        var hash = HASH;\\n        GLOBAL_COVERAGE_TEMPLATE\\n        var gcv = GLOBAL_COVERAGE_VAR;\\n        var coverageData = INITIAL;\\n        var coverage = global[gcv] || (global[gcv] = {});\\n        if (!coverage[path] || coverage[path].hash !== hash) {\\n            coverage[path] = coverageData;\\n        }\\n\\n        var actualCoverage = coverage[path];\\n        {\\n            // @ts-ignore\\n            COVERAGE_FUNCTION = function () {\\n                return actualCoverage;\\n            }\\n        }\\n\\n        return actualCoverage;\\n    }\\n\", {\n  preserveComments: true\n}); // the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\n\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\n\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(function (c) {\n    return COMMENT_FILE_RE.test(c.value);\n  });\n}\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types\n * @param {string} sourceFilePath - the path to source file\n * @param {Object} opts - additional options\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\n\n\nfunction programVisitor(types) {\n  var sourceFilePath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'unknown.js';\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var T = types;\n  opts = _objectSpread(_objectSpread({}, _schema.defaults.instrumentVisitor), opts);\n  var visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods);\n  return {\n    enter: function enter(path) {\n      if (shouldIgnoreFile(path.find(function (p) {\n        return p.isProgram();\n      }))) {\n        return;\n      }\n\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      path.traverse(codeVisitor, visitState);\n    },\n    exit: function exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      visitState.cov.freeze();\n      var coverageData = visitState.cov.toJSON();\n\n      if (shouldIgnoreFile(path.find(function (p) {\n        return p.isProgram();\n      }))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n\n      coverageData[_constants.MAGIC_KEY] = _constants.MAGIC_VALUE;\n      var hash = (0, _crypto.createHash)(_constants.SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      var coverageNode = T.valueToNode(coverageData);\n      delete coverageData[_constants.MAGIC_KEY];\n      delete coverageData.hash;\n      var gvTemplate;\n\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n\n      var cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_FUNCTION: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      }); // explicitly call this.varName to ensure coverage is always initialized\n\n      path.node.body.unshift(T.expressionStatement(T.callExpression(T.identifier(visitState.varName), [])));\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n  };\n}\n\nvar _default = programVisitor;\nexports.default = _default;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/istanbul-lib-instrument/dist/visitor.js"],"names":["Object","defineProperty","exports","value","default","_crypto","require","_core","_schema","_sourceCoverage","_constants","COMMENT_RE","COMMENT_FILE_RE","SOURCE_MAP_RE","genVar","filename","hash","createHash","SHA","update","parseInt","digest","substr","toString","VisitState","types","sourceFilePath","inputSourceMap","ignoreClassMethods","varName","attrs","nextIgnore","cov","SourceCoverage","sourceMappingURL","path","node","loc","hint","leadingComments","forEach","c","v","trim","groups","match","extractURL","comments","trailingComments","isFunctionExpression","isArrowFunctionExpression","isClassExpression","n","maybeAssignSourceMapURL","hintFor","getAttr","some","name","id","isClassMethod","key","__cov__","type","index","T","wrap","x","memberExpression","numericLiteral","updateExpression","callExpression","identifier","increment","isBlockStatement","body","unshift","expressionStatement","isStatement","insertBefore","counterNeedsHoisting","isVariableDeclarator","parentPath","parent","isExportNamedDeclaration","isProgram","replaceWith","sequenceExpression","isExpression","console","error","newStatement","increase","insertCounter","dloc","start","end","line","column","newFunction","get","branchName","addBranchPath","getBranchIncrement","accumulator","property","findLeaves","left","right","push","entries","enter","wrappedEntry","onEnter","shouldIgnore","e","call","exit","onExit","coverStatement","insertStatementCounter","coverAssignmentPattern","b","newBranch","insertBranchCounter","coverFunction","insertFunctionCounter","coverVariableDeclarator","coverClassPropDeclarator","makeBlock","blockStatement","undefined","blockProp","prop","makeParenthesizedExpressionForNonIdentifier","isIdentifier","parenthesizedExpression","parenthesizedExpressionProp","convertArrowExpression","bloc","expression","returnStatement","coverIfBranches","ignoreIf","ignoreElse","branch","setAttr","consequent","alternate","createSwitchBranch","coverSwitchCase","Error","coverTernary","cHint","aHint","coverLogicalExpression","leaves","i","length","leaf","codeVisitor","ArrowFunctionExpression","AssignmentPattern","BlockStatement","ExportDefaultDeclaration","ExportNamedDeclaration","ClassMethod","ClassDeclaration","ClassProperty","ClassPrivateProperty","ObjectMethod","ExpressionStatement","BreakStatement","ContinueStatement","DebuggerStatement","ReturnStatement","ThrowStatement","TryStatement","VariableDeclaration","VariableDeclarator","IfStatement","ForStatement","ForInStatement","ForOfStatement","WhileStatement","DoWhileStatement","SwitchStatement","SwitchCase","WithStatement","FunctionDeclaration","FunctionExpression","LabeledStatement","ConditionalExpression","LogicalExpression","globalTemplateAlteredFunction","template","globalTemplateFunction","globalTemplateVariable","coverageTemplate","preserveComments","alreadyInstrumented","visitState","scope","hasBinding","shouldIgnoreFile","programNode","test","programVisitor","opts","defaults","instrumentVisitor","find","p","traverse","freeze","coverageData","toJSON","fileCoverage","MAGIC_KEY","MAGIC_VALUE","JSON","stringify","coverageNode","valueToNode","gvTemplate","coverageGlobalScopeFunc","getBinding","GLOBAL_COVERAGE_SCOPE","stringLiteral","coverageGlobalScope","cv","GLOBAL_COVERAGE_VAR","coverageVariable","GLOBAL_COVERAGE_TEMPLATE","COVERAGE_FUNCTION","PATH","INITIAL","HASH","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = require(\"crypto\");\n\nvar _core = require(\"@babel/core\");\n\nvar _schema = require(\"@istanbuljs/schema\");\n\nvar _sourceCoverage = require(\"./source-coverage\");\n\nvar _constants = require(\"./constants\");\n\n// pattern for istanbul to ignore a section\nconst COMMENT_RE = /^\\s*istanbul\\s+ignore\\s+(if|else|next)(?=\\W|$)/; // pattern for istanbul to ignore the whole file\n\nconst COMMENT_FILE_RE = /^\\s*istanbul\\s+ignore\\s+(file)(?=\\W|$)/; // source map URL pattern\n\nconst SOURCE_MAP_RE = /[#@]\\s*sourceMappingURL=(.*)\\s*$/m; // generate a variable name from hashing the supplied file path\n\nfunction genVar(filename) {\n  const hash = (0, _crypto.createHash)(_constants.SHA);\n  hash.update(filename);\n  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);\n} // VisitState holds the state of the visitor, provides helper functions\n// and is the `this` for the individual coverage visitors.\n\n\nclass VisitState {\n  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = []) {\n    this.varName = genVar(sourceFilePath);\n    this.attrs = {};\n    this.nextIgnore = null;\n    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);\n\n    if (typeof inputSourceMap !== 'undefined') {\n      this.cov.inputSourceMap(inputSourceMap);\n    }\n\n    this.ignoreClassMethods = ignoreClassMethods;\n    this.types = types;\n    this.sourceMappingURL = null;\n  } // should we ignore the node? Yes, if specifically ignoring\n  // or if the node is generated.\n\n\n  shouldIgnore(path) {\n    return this.nextIgnore || !path.node.loc;\n  } // extract the ignore comment hint (next|if|else) or null\n\n\n  hintFor(node) {\n    let hint = null;\n\n    if (node.leadingComments) {\n      node.leadingComments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(COMMENT_RE);\n\n        if (groups) {\n          hint = groups[1];\n        }\n      });\n    }\n\n    return hint;\n  } // extract a source map URL from comments and keep track of it\n\n\n  maybeAssignSourceMapURL(node) {\n    const extractURL = comments => {\n      if (!comments) {\n        return;\n      }\n\n      comments.forEach(c => {\n        const v = (c.value ||\n        /* istanbul ignore next: paranoid check */\n        '').trim();\n        const groups = v.match(SOURCE_MAP_RE);\n\n        if (groups) {\n          this.sourceMappingURL = groups[1];\n        }\n      });\n    };\n\n    extractURL(node.leadingComments);\n    extractURL(node.trailingComments);\n  } // for these expressions the statement counter needs to be hoisted, so\n  // function name inference can be preserved\n\n\n  counterNeedsHoisting(path) {\n    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();\n  } // all the generic stuff that needs to be done on enter for every node\n\n\n  onEnter(path) {\n    const n = path.node;\n    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do\n\n    if (this.nextIgnore !== null) {\n      return;\n    } // check hint to see if ignore should be turned on\n\n\n    const hint = this.hintFor(n);\n\n    if (hint === 'next') {\n      this.nextIgnore = n;\n      return;\n    } // else check custom node attribute set by a prior visitor\n\n\n    if (this.getAttr(path.node, 'skip-all') !== null) {\n      this.nextIgnore = n;\n    } // else check for ignored class methods\n\n\n    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n\n    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {\n      this.nextIgnore = n;\n      return;\n    }\n  } // all the generic stuff on exit of a node,\n  // including reseting ignores and custom node attrs\n\n\n  onExit(path) {\n    // restore ignore status, if needed\n    if (path.node === this.nextIgnore) {\n      this.nextIgnore = null;\n    } // nuke all attributes for the node\n\n\n    delete path.node.__cov__;\n  } // set a node attribute for the supplied node\n\n\n  setAttr(node, name, value) {\n    node.__cov__ = node.__cov__ || {};\n    node.__cov__[name] = value;\n  } // retrieve a node attribute for the supplied node or null\n\n\n  getAttr(node, name) {\n    const c = node.__cov__;\n\n    if (!c) {\n      return null;\n    }\n\n    return c[name];\n  } //\n\n\n  increase(type, id, index) {\n    const T = this.types;\n    const wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.\n    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;\n    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.callExpression(T.identifier(this.varName), []), T.identifier(type)), T.numericLiteral(id), true)));\n  }\n\n  insertCounter(path, increment) {\n    const T = this.types;\n\n    if (path.isBlockStatement()) {\n      path.node.body.unshift(T.expressionStatement(increment));\n    } else if (path.isStatement()) {\n      path.insertBefore(T.expressionStatement(increment));\n    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {\n      // make an attempt to hoist the statement counter, so that\n      // function names are maintained.\n      const parent = path.parentPath.parentPath;\n\n      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {\n        parent.parentPath.insertBefore(T.expressionStatement(increment));\n      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {\n        parent.insertBefore(T.expressionStatement(increment));\n      } else {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      }\n    }\n    /* istanbul ignore else: not expected */\n    else if (path.isExpression()) {\n        path.replaceWith(T.sequenceExpression([increment, path.node]));\n      } else {\n        console.error('Unable to insert counter for node type:', path.node.type);\n      }\n  }\n\n  insertStatementCounter(path) {\n    /* istanbul ignore if: paranoid check */\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const index = this.cov.newStatement(path.node.loc);\n    const increment = this.increase('s', index, null);\n    this.insertCounter(path, increment);\n  }\n\n  insertFunctionCounter(path) {\n    const T = this.types;\n    /* istanbul ignore if: paranoid check */\n\n    if (!(path.node && path.node.loc)) {\n      return;\n    }\n\n    const n = path.node;\n    let dloc = null; // get location for declaration\n\n    switch (n.type) {\n      case 'FunctionDeclaration':\n        /* istanbul ignore else: paranoid check */\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n\n      case 'FunctionExpression':\n        if (n.id) {\n          dloc = n.id.loc;\n        }\n\n        break;\n    }\n\n    if (!dloc) {\n      dloc = {\n        start: n.loc.start,\n        end: {\n          line: n.loc.start.line,\n          column: n.loc.start.column + 1\n        }\n      };\n    }\n\n    const name = path.node.id ? path.node.id.name : path.node.name;\n    const index = this.cov.newFunction(name, dloc, path.node.body.loc);\n    const increment = this.increase('f', index, null);\n    const body = path.get('body');\n    /* istanbul ignore else: not expected */\n\n    if (body.isBlockStatement()) {\n      body.node.body.unshift(T.expressionStatement(increment));\n    } else {\n      console.error('Unable to process function body node type:', path.node.type);\n    }\n  }\n\n  getBranchIncrement(branchName, loc) {\n    const index = this.cov.addBranchPath(branchName, loc);\n    return this.increase('b', branchName, index);\n  }\n\n  insertBranchCounter(path, branchName, loc) {\n    const increment = this.getBranchIncrement(branchName, loc || path.node.loc);\n    this.insertCounter(path, increment);\n  }\n\n  findLeaves(node, accumulator, parent, property) {\n    if (!node) {\n      return;\n    }\n\n    if (node.type === 'LogicalExpression') {\n      const hint = this.hintFor(node);\n\n      if (hint !== 'next') {\n        this.findLeaves(node.left, accumulator, node, 'left');\n        this.findLeaves(node.right, accumulator, node, 'right');\n      }\n    } else {\n      accumulator.push({\n        node,\n        parent,\n        property\n      });\n    }\n  }\n\n} // generic function that takes a set of visitor methods and\n// returns a visitor object with `enter` and `exit` properties,\n// such that:\n//\n// * standard entry processing is done\n// * the supplied visitors are called only when ignore is not in effect\n//   This relieves them from worrying about ignore states and generated nodes.\n// * standard exit processing is done\n//\n\n\nfunction entries(...enter) {\n  // the enter function\n  const wrappedEntry = function (path, node) {\n    this.onEnter(path);\n\n    if (this.shouldIgnore(path)) {\n      return;\n    }\n\n    enter.forEach(e => {\n      e.call(this, path, node);\n    });\n  };\n\n  const exit = function (path, node) {\n    this.onExit(path, node);\n  };\n\n  return {\n    enter: wrappedEntry,\n    exit\n  };\n}\n\nfunction coverStatement(path) {\n  this.insertStatementCounter(path);\n}\n/* istanbul ignore next: no node.js support */\n\n\nfunction coverAssignmentPattern(path) {\n  const n = path.node;\n  const b = this.cov.newBranch('default-arg', n.loc);\n  this.insertBranchCounter(path.get('right'), b);\n}\n\nfunction coverFunction(path) {\n  this.insertFunctionCounter(path);\n}\n\nfunction coverVariableDeclarator(path) {\n  this.insertStatementCounter(path.get('init'));\n}\n\nfunction coverClassPropDeclarator(path) {\n  this.insertStatementCounter(path.get('value'));\n}\n\nfunction makeBlock(path) {\n  const T = this.types;\n\n  if (!path.node) {\n    path.replaceWith(T.blockStatement([]));\n  }\n\n  if (!path.isBlockStatement()) {\n    path.replaceWith(T.blockStatement([path.node]));\n    path.node.loc = path.node.body[0].loc;\n    path.node.body[0].leadingComments = path.node.leadingComments;\n    path.node.leadingComments = undefined;\n  }\n}\n\nfunction blockProp(prop) {\n  return function (path) {\n    makeBlock.call(this, path.get(prop));\n  };\n}\n\nfunction makeParenthesizedExpressionForNonIdentifier(path) {\n  const T = this.types;\n\n  if (path.node && !path.isIdentifier()) {\n    path.replaceWith(T.parenthesizedExpression(path.node));\n  }\n}\n\nfunction parenthesizedExpressionProp(prop) {\n  return function (path) {\n    makeParenthesizedExpressionForNonIdentifier.call(this, path.get(prop));\n  };\n}\n\nfunction convertArrowExpression(path) {\n  const n = path.node;\n  const T = this.types;\n\n  if (!T.isBlockStatement(n.body)) {\n    const bloc = n.body.loc;\n\n    if (n.expression === true) {\n      n.expression = false;\n    }\n\n    n.body = T.blockStatement([T.returnStatement(n.body)]); // restore body location\n\n    n.body.loc = bloc; // set up the location for the return statement so it gets\n    // instrumented\n\n    n.body.body[0].loc = bloc;\n  }\n}\n\nfunction coverIfBranches(path) {\n  const n = path.node;\n  const hint = this.hintFor(n);\n  const ignoreIf = hint === 'if';\n  const ignoreElse = hint === 'else';\n  const branch = this.cov.newBranch('if', n.loc);\n\n  if (ignoreIf) {\n    this.setAttr(n.consequent, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('consequent'), branch, n.loc);\n  }\n\n  if (ignoreElse) {\n    this.setAttr(n.alternate, 'skip-all', true);\n  } else {\n    this.insertBranchCounter(path.get('alternate'), branch, n.loc);\n  }\n}\n\nfunction createSwitchBranch(path) {\n  const b = this.cov.newBranch('switch', path.node.loc);\n  this.setAttr(path.node, 'branchName', b);\n}\n\nfunction coverSwitchCase(path) {\n  const T = this.types;\n  const b = this.getAttr(path.parentPath.node, 'branchName');\n  /* istanbul ignore if: paranoid check */\n\n  if (b === null) {\n    throw new Error('Unable to get switch branch name');\n  }\n\n  const increment = this.getBranchIncrement(b, path.node.loc);\n  path.node.consequent.unshift(T.expressionStatement(increment));\n}\n\nfunction coverTernary(path) {\n  const n = path.node;\n  const branch = this.cov.newBranch('cond-expr', path.node.loc);\n  const cHint = this.hintFor(n.consequent);\n  const aHint = this.hintFor(n.alternate);\n\n  if (cHint !== 'next') {\n    this.insertBranchCounter(path.get('consequent'), branch);\n  }\n\n  if (aHint !== 'next') {\n    this.insertBranchCounter(path.get('alternate'), branch);\n  }\n}\n\nfunction coverLogicalExpression(path) {\n  const T = this.types;\n\n  if (path.parentPath.node.type === 'LogicalExpression') {\n    return; // already processed\n  }\n\n  const leaves = [];\n  this.findLeaves(path.node, leaves);\n  const b = this.cov.newBranch('binary-expr', path.node.loc);\n\n  for (let i = 0; i < leaves.length; i += 1) {\n    const leaf = leaves[i];\n    const hint = this.hintFor(leaf.node);\n\n    if (hint === 'next') {\n      continue;\n    }\n\n    const increment = this.getBranchIncrement(b, leaf.node.loc);\n\n    if (!increment) {\n      continue;\n    }\n\n    leaf.parent[leaf.property] = T.sequenceExpression([increment, leaf.node]);\n  }\n}\n\nconst codeVisitor = {\n  ArrowFunctionExpression: entries(convertArrowExpression, coverFunction),\n  AssignmentPattern: entries(coverAssignmentPattern),\n  BlockStatement: entries(),\n  // ignore processing only\n  ExportDefaultDeclaration: entries(),\n  // ignore processing only\n  ExportNamedDeclaration: entries(),\n  // ignore processing only\n  ClassMethod: entries(coverFunction),\n  ClassDeclaration: entries(parenthesizedExpressionProp('superClass')),\n  ClassProperty: entries(coverClassPropDeclarator),\n  ClassPrivateProperty: entries(coverClassPropDeclarator),\n  ObjectMethod: entries(coverFunction),\n  ExpressionStatement: entries(coverStatement),\n  BreakStatement: entries(coverStatement),\n  ContinueStatement: entries(coverStatement),\n  DebuggerStatement: entries(coverStatement),\n  ReturnStatement: entries(coverStatement),\n  ThrowStatement: entries(coverStatement),\n  TryStatement: entries(coverStatement),\n  VariableDeclaration: entries(),\n  // ignore processing only\n  VariableDeclarator: entries(coverVariableDeclarator),\n  IfStatement: entries(blockProp('consequent'), blockProp('alternate'), coverStatement, coverIfBranches),\n  ForStatement: entries(blockProp('body'), coverStatement),\n  ForInStatement: entries(blockProp('body'), coverStatement),\n  ForOfStatement: entries(blockProp('body'), coverStatement),\n  WhileStatement: entries(blockProp('body'), coverStatement),\n  DoWhileStatement: entries(blockProp('body'), coverStatement),\n  SwitchStatement: entries(createSwitchBranch, coverStatement),\n  SwitchCase: entries(coverSwitchCase),\n  WithStatement: entries(blockProp('body'), coverStatement),\n  FunctionDeclaration: entries(coverFunction),\n  FunctionExpression: entries(coverFunction),\n  LabeledStatement: entries(coverStatement),\n  ConditionalExpression: entries(coverTernary),\n  LogicalExpression: entries(coverLogicalExpression)\n};\nconst globalTemplateAlteredFunction = (0, _core.template)(`\n        var Function = (function(){}).constructor;\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateFunction = (0, _core.template)(`\n        var global = (new Function(GLOBAL_COVERAGE_SCOPE))();\n`);\nconst globalTemplateVariable = (0, _core.template)(`\n        var global = GLOBAL_COVERAGE_SCOPE;\n`); // the template to insert at the top of the program.\n\nconst coverageTemplate = (0, _core.template)(`\n    function COVERAGE_FUNCTION () {\n        var path = PATH;\n        var hash = HASH;\n        GLOBAL_COVERAGE_TEMPLATE\n        var gcv = GLOBAL_COVERAGE_VAR;\n        var coverageData = INITIAL;\n        var coverage = global[gcv] || (global[gcv] = {});\n        if (!coverage[path] || coverage[path].hash !== hash) {\n            coverage[path] = coverageData;\n        }\n\n        var actualCoverage = coverage[path];\n        {\n            // @ts-ignore\n            COVERAGE_FUNCTION = function () {\n                return actualCoverage;\n            }\n        }\n\n        return actualCoverage;\n    }\n`, {\n  preserveComments: true\n}); // the rewire plugin (and potentially other babel middleware)\n// may cause files to be instrumented twice, see:\n// https://github.com/istanbuljs/babel-plugin-istanbul/issues/94\n// we should only instrument code for coverage the first time\n// it's run through istanbul-lib-instrument.\n\nfunction alreadyInstrumented(path, visitState) {\n  return path.scope.hasBinding(visitState.varName);\n}\n\nfunction shouldIgnoreFile(programNode) {\n  return programNode.parent && programNode.parent.comments.some(c => COMMENT_FILE_RE.test(c.value));\n}\n/**\n * programVisitor is a `babel` adaptor for instrumentation.\n * It returns an object with two methods `enter` and `exit`.\n * These should be assigned to or called from `Program` entry and exit functions\n * in a babel visitor.\n * These functions do not make assumptions about the state set by Babel and thus\n * can be used in a context other than a Babel plugin.\n *\n * The exit function returns an object that currently has the following keys:\n *\n * `fileCoverage` - the file coverage object created for the source file.\n * `sourceMappingURL` - any source mapping URL found when processing the file.\n *\n * @param {Object} types - an instance of babel-types\n * @param {string} sourceFilePath - the path to source file\n * @param {Object} opts - additional options\n * @param {string} [opts.coverageVariable=__coverage__] the global coverage variable name.\n * @param {string} [opts.coverageGlobalScope=this] the global coverage variable scope.\n * @param {boolean} [opts.coverageGlobalScopeFunc=true] use an evaluated function to find coverageGlobalScope.\n * @param {Array} [opts.ignoreClassMethods=[]] names of methods to ignore by default on classes.\n * @param {object} [opts.inputSourceMap=undefined] the input source map, that maps the uninstrumented code back to the\n * original code.\n */\n\n\nfunction programVisitor(types, sourceFilePath = 'unknown.js', opts = {}) {\n  const T = types;\n  opts = { ..._schema.defaults.instrumentVisitor,\n    ...opts\n  };\n  const visitState = new VisitState(types, sourceFilePath, opts.inputSourceMap, opts.ignoreClassMethods);\n  return {\n    enter(path) {\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return;\n      }\n\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      path.traverse(codeVisitor, visitState);\n    },\n\n    exit(path) {\n      if (alreadyInstrumented(path, visitState)) {\n        return;\n      }\n\n      visitState.cov.freeze();\n      const coverageData = visitState.cov.toJSON();\n\n      if (shouldIgnoreFile(path.find(p => p.isProgram()))) {\n        return {\n          fileCoverage: coverageData,\n          sourceMappingURL: visitState.sourceMappingURL\n        };\n      }\n\n      coverageData[_constants.MAGIC_KEY] = _constants.MAGIC_VALUE;\n      const hash = (0, _crypto.createHash)(_constants.SHA).update(JSON.stringify(coverageData)).digest('hex');\n      coverageData.hash = hash;\n      const coverageNode = T.valueToNode(coverageData);\n      delete coverageData[_constants.MAGIC_KEY];\n      delete coverageData.hash;\n      let gvTemplate;\n\n      if (opts.coverageGlobalScopeFunc) {\n        if (path.scope.getBinding('Function')) {\n          gvTemplate = globalTemplateAlteredFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        } else {\n          gvTemplate = globalTemplateFunction({\n            GLOBAL_COVERAGE_SCOPE: T.stringLiteral('return ' + opts.coverageGlobalScope)\n          });\n        }\n      } else {\n        gvTemplate = globalTemplateVariable({\n          GLOBAL_COVERAGE_SCOPE: opts.coverageGlobalScope\n        });\n      }\n\n      const cv = coverageTemplate({\n        GLOBAL_COVERAGE_VAR: T.stringLiteral(opts.coverageVariable),\n        GLOBAL_COVERAGE_TEMPLATE: gvTemplate,\n        COVERAGE_FUNCTION: T.identifier(visitState.varName),\n        PATH: T.stringLiteral(sourceFilePath),\n        INITIAL: coverageNode,\n        HASH: T.stringLiteral(hash)\n      }); // explicitly call this.varName to ensure coverage is always initialized\n\n      path.node.body.unshift(T.expressionStatement(T.callExpression(T.identifier(visitState.varName), [])));\n      path.node.body.unshift(cv);\n      return {\n        fileCoverage: coverageData,\n        sourceMappingURL: visitState.sourceMappingURL\n      };\n    }\n\n  };\n}\n\nvar _default = programVisitor;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}