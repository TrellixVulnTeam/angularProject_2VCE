{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/host\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/src/ngtsc/shims\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.TypeCheckProgramHost = exports.DelegatingCompilerHost = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var shims_1 = require(\"@angular/compiler-cli/src/ngtsc/shims\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n  /**\n   * Delegates all methods of `ts.CompilerHost` to a delegate, with the exception of\n   * `getSourceFile`, `fileExists` and `writeFile` which are implemented in `TypeCheckProgramHost`.\n   *\n   * If a new method is added to `ts.CompilerHost` which is not delegated, a type error will be\n   * generated for this class.\n   */\n\n\n  var DelegatingCompilerHost =\n  /** @class */\n  function () {\n    function DelegatingCompilerHost(delegate) {\n      this.delegate = delegate; // Excluded are 'getSourceFile', 'fileExists' and 'writeFile', which are actually implemented by\n      // `TypeCheckProgramHost` below.\n\n      this.createHash = this.delegateMethod('createHash');\n      this.directoryExists = this.delegateMethod('directoryExists');\n      this.getCancellationToken = this.delegateMethod('getCancellationToken');\n      this.getCanonicalFileName = this.delegateMethod('getCanonicalFileName');\n      this.getCurrentDirectory = this.delegateMethod('getCurrentDirectory');\n      this.getDefaultLibFileName = this.delegateMethod('getDefaultLibFileName');\n      this.getDefaultLibLocation = this.delegateMethod('getDefaultLibLocation');\n      this.getDirectories = this.delegateMethod('getDirectories');\n      this.getEnvironmentVariable = this.delegateMethod('getEnvironmentVariable');\n      this.getNewLine = this.delegateMethod('getNewLine');\n      this.getParsedCommandLine = this.delegateMethod('getParsedCommandLine');\n      this.getSourceFileByPath = this.delegateMethod('getSourceFileByPath');\n      this.readDirectory = this.delegateMethod('readDirectory');\n      this.readFile = this.delegateMethod('readFile');\n      this.realpath = this.delegateMethod('realpath');\n      this.resolveModuleNames = this.delegateMethod('resolveModuleNames');\n      this.resolveTypeReferenceDirectives = this.delegateMethod('resolveTypeReferenceDirectives');\n      this.trace = this.delegateMethod('trace');\n      this.useCaseSensitiveFileNames = this.delegateMethod('useCaseSensitiveFileNames');\n    }\n\n    DelegatingCompilerHost.prototype.delegateMethod = function (name) {\n      return this.delegate[name] !== undefined ? this.delegate[name].bind(this.delegate) : undefined;\n    };\n\n    return DelegatingCompilerHost;\n  }();\n\n  exports.DelegatingCompilerHost = DelegatingCompilerHost;\n  /**\n   * A `ts.CompilerHost` which augments source files with type checking code from a\n   * `TypeCheckContext`.\n   */\n\n  var TypeCheckProgramHost =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TypeCheckProgramHost, _super);\n\n    function TypeCheckProgramHost(sfMap, originalProgram, delegate, shimExtensionPrefixes) {\n      var _this = _super.call(this, delegate) || this;\n\n      _this.originalProgram = originalProgram;\n      _this.shimExtensionPrefixes = shimExtensionPrefixes;\n      /**\n       * The `ShimReferenceTagger` responsible for tagging `ts.SourceFile`s loaded via this host.\n       *\n       * The `TypeCheckProgramHost` is used in the creation of a new `ts.Program`. Even though this new\n       * program is based on a prior one, TypeScript will still start from the root files and enumerate\n       * all source files to include in the new program.  This means that just like during the original\n       * program's creation, these source files must be tagged with references to per-file shims in\n       * order for those shims to be loaded, and then cleaned up afterwards. Thus the\n       * `TypeCheckProgramHost` has its own `ShimReferenceTagger` to perform this function.\n       */\n\n      _this.shimTagger = new shims_1.ShimReferenceTagger(_this.shimExtensionPrefixes);\n      _this.sfMap = sfMap;\n      return _this;\n    }\n\n    TypeCheckProgramHost.prototype.getSourceFile = function (fileName, languageVersion, onError, shouldCreateNewSourceFile) {\n      // Try to use the same `ts.SourceFile` as the original program, if possible. This guarantees\n      // that program reuse will be as efficient as possible.\n      var delegateSf = this.originalProgram.getSourceFile(fileName);\n\n      if (delegateSf === undefined) {\n        // Something went wrong and a source file is being requested that's not in the original\n        // program. Just in case, try to retrieve it from the delegate.\n        delegateSf = this.delegate.getSourceFile(fileName, languageVersion, onError, shouldCreateNewSourceFile);\n      }\n\n      if (delegateSf === undefined) {\n        return undefined;\n      } // Look for replacements.\n\n\n      var sf;\n\n      if (this.sfMap.has(fileName)) {\n        sf = this.sfMap.get(fileName);\n        shims_1.copyFileShimData(delegateSf, sf);\n      } else {\n        sf = delegateSf;\n      } // TypeScript doesn't allow returning redirect source files. To avoid unforeseen errors we\n      // return the original source file instead of the redirect target.\n\n\n      sf = typescript_1.toUnredirectedSourceFile(sf);\n      this.shimTagger.tag(sf);\n      return sf;\n    };\n\n    TypeCheckProgramHost.prototype.postProgramCreationCleanup = function () {\n      this.shimTagger.finalize();\n    };\n\n    TypeCheckProgramHost.prototype.writeFile = function () {\n      throw new Error(\"TypeCheckProgramHost should never write files\");\n    };\n\n    TypeCheckProgramHost.prototype.fileExists = function (fileName) {\n      return this.sfMap.has(fileName) || this.delegate.fileExists(fileName);\n    };\n\n    return TypeCheckProgramHost;\n  }(DelegatingCompilerHost);\n\n  exports.TypeCheckProgramHost = TypeCheckProgramHost;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/host.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {copyFileShimData, ShimReferenceTagger} from '../../shims';\nimport {RequiredDelegations, toUnredirectedSourceFile} from '../../util/src/typescript';\n\n/**\n * Delegates all methods of `ts.CompilerHost` to a delegate, with the exception of\n * `getSourceFile`, `fileExists` and `writeFile` which are implemented in `TypeCheckProgramHost`.\n *\n * If a new method is added to `ts.CompilerHost` which is not delegated, a type error will be\n * generated for this class.\n */\nexport class DelegatingCompilerHost implements\n    Omit<RequiredDelegations<ts.CompilerHost>, 'getSourceFile'|'fileExists'|'writeFile'> {\n  constructor(protected delegate: ts.CompilerHost) {}\n\n  private delegateMethod<M extends keyof ts.CompilerHost>(name: M): ts.CompilerHost[M] {\n    return this.delegate[name] !== undefined ? (this.delegate[name] as any).bind(this.delegate) :\n                                               undefined;\n  }\n\n  // Excluded are 'getSourceFile', 'fileExists' and 'writeFile', which are actually implemented by\n  // `TypeCheckProgramHost` below.\n  createHash = this.delegateMethod('createHash');\n  directoryExists = this.delegateMethod('directoryExists');\n  getCancellationToken = this.delegateMethod('getCancellationToken');\n  getCanonicalFileName = this.delegateMethod('getCanonicalFileName');\n  getCurrentDirectory = this.delegateMethod('getCurrentDirectory');\n  getDefaultLibFileName = this.delegateMethod('getDefaultLibFileName');\n  getDefaultLibLocation = this.delegateMethod('getDefaultLibLocation');\n  getDirectories = this.delegateMethod('getDirectories');\n  getEnvironmentVariable = this.delegateMethod('getEnvironmentVariable');\n  getNewLine = this.delegateMethod('getNewLine');\n  getParsedCommandLine = this.delegateMethod('getParsedCommandLine');\n  getSourceFileByPath = this.delegateMethod('getSourceFileByPath');\n  readDirectory = this.delegateMethod('readDirectory');\n  readFile = this.delegateMethod('readFile');\n  realpath = this.delegateMethod('realpath');\n  resolveModuleNames = this.delegateMethod('resolveModuleNames');\n  resolveTypeReferenceDirectives = this.delegateMethod('resolveTypeReferenceDirectives');\n  trace = this.delegateMethod('trace');\n  useCaseSensitiveFileNames = this.delegateMethod('useCaseSensitiveFileNames');\n}\n\n/**\n * A `ts.CompilerHost` which augments source files with type checking code from a\n * `TypeCheckContext`.\n */\nexport class TypeCheckProgramHost extends DelegatingCompilerHost {\n  /**\n   * Map of source file names to `ts.SourceFile` instances.\n   */\n  private sfMap: Map<string, ts.SourceFile>;\n\n  /**\n   * The `ShimReferenceTagger` responsible for tagging `ts.SourceFile`s loaded via this host.\n   *\n   * The `TypeCheckProgramHost` is used in the creation of a new `ts.Program`. Even though this new\n   * program is based on a prior one, TypeScript will still start from the root files and enumerate\n   * all source files to include in the new program.  This means that just like during the original\n   * program's creation, these source files must be tagged with references to per-file shims in\n   * order for those shims to be loaded, and then cleaned up afterwards. Thus the\n   * `TypeCheckProgramHost` has its own `ShimReferenceTagger` to perform this function.\n   */\n  private shimTagger = new ShimReferenceTagger(this.shimExtensionPrefixes);\n\n  constructor(\n      sfMap: Map<string, ts.SourceFile>, private originalProgram: ts.Program,\n      delegate: ts.CompilerHost, private shimExtensionPrefixes: string[]) {\n    super(delegate);\n    this.sfMap = sfMap;\n  }\n\n  getSourceFile(\n      fileName: string, languageVersion: ts.ScriptTarget,\n      onError?: ((message: string) => void)|undefined,\n      shouldCreateNewSourceFile?: boolean|undefined): ts.SourceFile|undefined {\n    // Try to use the same `ts.SourceFile` as the original program, if possible. This guarantees\n    // that program reuse will be as efficient as possible.\n    let delegateSf: ts.SourceFile|undefined = this.originalProgram.getSourceFile(fileName);\n    if (delegateSf === undefined) {\n      // Something went wrong and a source file is being requested that's not in the original\n      // program. Just in case, try to retrieve it from the delegate.\n      delegateSf = this.delegate.getSourceFile(\n          fileName, languageVersion, onError, shouldCreateNewSourceFile)!;\n    }\n    if (delegateSf === undefined) {\n      return undefined;\n    }\n\n    // Look for replacements.\n    let sf: ts.SourceFile;\n    if (this.sfMap.has(fileName)) {\n      sf = this.sfMap.get(fileName)!;\n      copyFileShimData(delegateSf, sf);\n    } else {\n      sf = delegateSf;\n    }\n    // TypeScript doesn't allow returning redirect source files. To avoid unforeseen errors we\n    // return the original source file instead of the redirect target.\n    sf = toUnredirectedSourceFile(sf);\n\n    this.shimTagger.tag(sf);\n    return sf;\n  }\n\n  postProgramCreationCleanup(): void {\n    this.shimTagger.finalize();\n  }\n\n  writeFile(): never {\n    throw new Error(`TypeCheckProgramHost should never write files`);\n  }\n\n  fileExists(fileName: string): boolean {\n    return this.sfMap.has(fileName) || this.delegate.fileExists(fileName);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}