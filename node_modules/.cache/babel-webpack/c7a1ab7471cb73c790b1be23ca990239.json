{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/annotations/src/ng_module\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/imports\", \"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/transform\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\", \"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\", \"@angular/compiler-cli/src/ngtsc/annotations/src/factory\", \"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\", \"@angular/compiler-cli/src/ngtsc/annotations/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.NgModuleDecoratorHandler = exports.NgModuleSymbol = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var imports_1 = require(\"@angular/compiler-cli/src/ngtsc/imports\");\n\n  var semantic_graph_1 = require(\"@angular/compiler-cli/src/ngtsc/incremental/semantic_graph\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var transform_1 = require(\"@angular/compiler-cli/src/ngtsc/transform\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var diagnostics_2 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/diagnostics\");\n\n  var factory_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/factory\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/util\");\n  /**\n   * Represents an Angular NgModule.\n   */\n\n\n  var NgModuleSymbol =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(NgModuleSymbol, _super);\n\n    function NgModuleSymbol() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.remotelyScopedComponents = [];\n      return _this;\n    }\n\n    NgModuleSymbol.prototype.isPublicApiAffected = function (previousSymbol) {\n      if (!(previousSymbol instanceof NgModuleSymbol)) {\n        return true;\n      } // NgModules don't have a public API that could affect emit of Angular decorated classes.\n\n\n      return false;\n    };\n\n    NgModuleSymbol.prototype.isEmitAffected = function (previousSymbol) {\n      var e_1, _a;\n\n      if (!(previousSymbol instanceof NgModuleSymbol)) {\n        return true;\n      } // compare our remotelyScopedComponents to the previous symbol\n\n\n      if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {\n        return true;\n      }\n\n      var _loop_1 = function _loop_1(currEntry) {\n        var prevEntry = previousSymbol.remotelyScopedComponents.find(function (prevEntry) {\n          return semantic_graph_1.isSymbolEqual(prevEntry.component, currEntry.component);\n        });\n\n        if (prevEntry === undefined) {\n          return {\n            value: true\n          };\n        }\n\n        if (!semantic_graph_1.isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, semantic_graph_1.isReferenceEqual)) {\n          return {\n            value: true\n          };\n        }\n\n        if (!semantic_graph_1.isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, semantic_graph_1.isReferenceEqual)) {\n          return {\n            value: true\n          };\n        }\n      };\n\n      try {\n        for (var _b = tslib_1.__values(this.remotelyScopedComponents), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var currEntry = _c.value;\n\n          var state_1 = _loop_1(currEntry);\n\n          if (typeof state_1 === \"object\") return state_1.value;\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return false;\n    };\n\n    NgModuleSymbol.prototype.isTypeCheckApiAffected = function (previousSymbol) {\n      if (!(previousSymbol instanceof NgModuleSymbol)) {\n        return true;\n      }\n\n      return false;\n    };\n\n    NgModuleSymbol.prototype.addRemotelyScopedComponent = function (component, usedDirectives, usedPipes) {\n      this.remotelyScopedComponents.push({\n        component: component,\n        usedDirectives: usedDirectives,\n        usedPipes: usedPipes\n      });\n    };\n\n    return NgModuleSymbol;\n  }(semantic_graph_1.SemanticSymbol);\n\n  exports.NgModuleSymbol = NgModuleSymbol;\n  /**\n   * Compiles @NgModule annotations to ngModuleDef fields.\n   */\n\n  var NgModuleDecoratorHandler =\n  /** @class */\n  function () {\n    function NgModuleDecoratorHandler(reflector, evaluator, metaReader, metaRegistry, scopeRegistry, referencesRegistry, isCore, routeAnalyzer, refEmitter, factoryTracker, annotateForClosureCompiler, injectableRegistry, perf, localeId) {\n      this.reflector = reflector;\n      this.evaluator = evaluator;\n      this.metaReader = metaReader;\n      this.metaRegistry = metaRegistry;\n      this.scopeRegistry = scopeRegistry;\n      this.referencesRegistry = referencesRegistry;\n      this.isCore = isCore;\n      this.routeAnalyzer = routeAnalyzer;\n      this.refEmitter = refEmitter;\n      this.factoryTracker = factoryTracker;\n      this.annotateForClosureCompiler = annotateForClosureCompiler;\n      this.injectableRegistry = injectableRegistry;\n      this.perf = perf;\n      this.localeId = localeId;\n      this.precedence = transform_1.HandlerPrecedence.PRIMARY;\n      this.name = NgModuleDecoratorHandler.name;\n    }\n\n    NgModuleDecoratorHandler.prototype.detect = function (node, decorators) {\n      if (!decorators) {\n        return undefined;\n      }\n\n      var decorator = util_1.findAngularDecorator(decorators, 'NgModule', this.isCore);\n\n      if (decorator !== undefined) {\n        return {\n          trigger: decorator.node,\n          decorator: decorator,\n          metadata: decorator\n        };\n      } else {\n        return undefined;\n      }\n    };\n\n    NgModuleDecoratorHandler.prototype.analyze = function (node, decorator) {\n      var e_2, _a, _b, e_3, _c;\n\n      var _this = this;\n\n      this.perf.eventCount(perf_1.PerfEvent.AnalyzeNgModule);\n      var name = node.name.text;\n\n      if (decorator.args === null || decorator.args.length > 1) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, reflection_1.Decorator.nodeForError(decorator), \"Incorrect number of arguments to @NgModule decorator\");\n      } // @NgModule can be invoked without arguments. In case it is, pretend as if a blank object\n      // literal was specified. This simplifies the code below.\n\n\n      var meta = decorator.args.length === 1 ? util_1.unwrapExpression(decorator.args[0]) : ts.createObjectLiteral([]);\n\n      if (!ts.isObjectLiteralExpression(meta)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta, '@NgModule argument must be an object literal');\n      }\n\n      var ngModule = reflection_1.reflectObjectLiteral(meta);\n\n      if (ngModule.has('jit')) {\n        // The only allowed value is true, so there's no need to expand further.\n        return {};\n      }\n\n      var moduleResolvers = util_1.combineResolvers([function (ref) {\n        return _this._extractModuleFromModuleWithProvidersFn(ref.node);\n      }, util_1.forwardRefResolver]);\n      var diagnostics = []; // Extract the module declarations, imports, and exports.\n\n      var declarationRefs = [];\n      var rawDeclarations = null;\n\n      if (ngModule.has('declarations')) {\n        rawDeclarations = ngModule.get('declarations');\n        var declarationMeta = this.evaluator.evaluate(rawDeclarations, util_1.forwardRefResolver);\n        declarationRefs = this.resolveTypeList(rawDeclarations, declarationMeta, name, 'declarations');\n\n        try {\n          // Look through the declarations to make sure they're all a part of the current compilation.\n          for (var declarationRefs_1 = tslib_1.__values(declarationRefs), declarationRefs_1_1 = declarationRefs_1.next(); !declarationRefs_1_1.done; declarationRefs_1_1 = declarationRefs_1.next()) {\n            var ref = declarationRefs_1_1.value;\n\n            if (ref.node.getSourceFile().isDeclarationFile) {\n              var errorNode = ref.getOriginForDiagnostics(rawDeclarations);\n              diagnostics.push(diagnostics_1.makeDiagnostic(diagnostics_1.ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode, \"Cannot declare '\" + ref.node.name.text + \"' in an NgModule as it's not a part of the current compilation.\", [diagnostics_1.makeRelatedInformation(ref.node.name, \"'\" + ref.node.name.text + \"' is declared here.\")]));\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (declarationRefs_1_1 && !declarationRefs_1_1.done && (_a = declarationRefs_1.return)) _a.call(declarationRefs_1);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      }\n\n      if (diagnostics.length > 0) {\n        return {\n          diagnostics: diagnostics\n        };\n      }\n\n      var importRefs = [];\n      var rawImports = null;\n\n      if (ngModule.has('imports')) {\n        rawImports = ngModule.get('imports');\n        var importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);\n        importRefs = this.resolveTypeList(rawImports, importsMeta, name, 'imports');\n      }\n\n      var exportRefs = [];\n      var rawExports = null;\n\n      if (ngModule.has('exports')) {\n        rawExports = ngModule.get('exports');\n        var exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);\n        exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, 'exports');\n\n        (_b = this.referencesRegistry).add.apply(_b, tslib_1.__spread([node], exportRefs));\n      }\n\n      var bootstrapRefs = [];\n\n      if (ngModule.has('bootstrap')) {\n        var expr = ngModule.get('bootstrap');\n        var bootstrapMeta = this.evaluator.evaluate(expr, util_1.forwardRefResolver);\n        bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, 'bootstrap');\n      }\n\n      var schemas = [];\n\n      if (ngModule.has('schemas')) {\n        var rawExpr = ngModule.get('schemas');\n        var result = this.evaluator.evaluate(rawExpr);\n\n        if (!Array.isArray(result)) {\n          throw diagnostics_2.createValueHasWrongTypeError(rawExpr, result, \"NgModule.schemas must be an array\");\n        }\n\n        try {\n          for (var result_1 = tslib_1.__values(result), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {\n            var schemaRef = result_1_1.value;\n\n            if (!(schemaRef instanceof imports_1.Reference)) {\n              throw diagnostics_2.createValueHasWrongTypeError(rawExpr, result, 'NgModule.schemas must be an array of schemas');\n            }\n\n            var id_1 = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());\n\n            if (id_1 === null || schemaRef.ownedByModuleGuess !== '@angular/core') {\n              throw diagnostics_2.createValueHasWrongTypeError(rawExpr, result, 'NgModule.schemas must be an array of schemas');\n            } // Since `id` is the `ts.Identifer` within the schema ref's declaration file, it's safe to\n            // use `id.text` here to figure out which schema is in use. Even if the actual reference was\n            // renamed when the user imported it, these names will match.\n\n\n            switch (id_1.text) {\n              case 'CUSTOM_ELEMENTS_SCHEMA':\n                schemas.push(compiler_1.CUSTOM_ELEMENTS_SCHEMA);\n                break;\n\n              case 'NO_ERRORS_SCHEMA':\n                schemas.push(compiler_1.NO_ERRORS_SCHEMA);\n                break;\n\n              default:\n                throw diagnostics_2.createValueHasWrongTypeError(rawExpr, schemaRef, \"'\" + schemaRef.debugName + \"' is not a valid NgModule schema\");\n            }\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (result_1_1 && !result_1_1.done && (_c = result_1.return)) _c.call(result_1);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n      }\n\n      var id = ngModule.has('id') ? new compiler_1.WrappedNodeExpr(ngModule.get('id')) : null;\n      var valueContext = node.getSourceFile();\n      var typeContext = valueContext;\n      var typeNode = this.reflector.getDtsDeclaration(node);\n\n      if (typeNode !== null) {\n        typeContext = typeNode.getSourceFile();\n      }\n\n      var bootstrap = bootstrapRefs.map(function (bootstrap) {\n        return _this._toR3Reference(bootstrap, valueContext, typeContext);\n      });\n      var declarations = declarationRefs.map(function (decl) {\n        return _this._toR3Reference(decl, valueContext, typeContext);\n      });\n      var imports = importRefs.map(function (imp) {\n        return _this._toR3Reference(imp, valueContext, typeContext);\n      });\n      var exports = exportRefs.map(function (exp) {\n        return _this._toR3Reference(exp, valueContext, typeContext);\n      });\n\n      var isForwardReference = function isForwardReference(ref) {\n        return util_1.isExpressionForwardReference(ref.value, node.name, valueContext);\n      };\n\n      var containsForwardDecls = bootstrap.some(isForwardReference) || declarations.some(isForwardReference) || imports.some(isForwardReference) || exports.some(isForwardReference);\n      var type = util_1.wrapTypeReference(this.reflector, node);\n      var internalType = new compiler_1.WrappedNodeExpr(this.reflector.getInternalNameOfClass(node));\n      var adjacentType = new compiler_1.WrappedNodeExpr(this.reflector.getAdjacentNameOfClass(node));\n      var ngModuleDef = {\n        type: type,\n        internalType: internalType,\n        adjacentType: adjacentType,\n        bootstrap: bootstrap,\n        declarations: declarations,\n        exports: exports,\n        imports: imports,\n        containsForwardDecls: containsForwardDecls,\n        id: id,\n        emitInline: false,\n        // TODO: to be implemented as a part of FW-1004.\n        schemas: []\n      };\n      var rawProviders = ngModule.has('providers') ? ngModule.get('providers') : null;\n      var wrapperProviders = rawProviders !== null ? new compiler_1.WrappedNodeExpr(this.annotateForClosureCompiler ? util_1.wrapFunctionExpressionsInParens(rawProviders) : rawProviders) : null; // At this point, only add the module's imports as the injectors' imports. Any exported modules\n      // are added during `resolve`, as we need scope information to be able to filter out directives\n      // and pipes from the module exports.\n\n      var injectorImports = [];\n\n      if (ngModule.has('imports')) {\n        injectorImports.push(new compiler_1.WrappedNodeExpr(ngModule.get('imports')));\n      }\n\n      if (this.routeAnalyzer !== null) {\n        this.routeAnalyzer.add(node.getSourceFile(), name, rawImports, rawExports, rawProviders);\n      }\n\n      var ngInjectorDef = {\n        name: name,\n        type: type,\n        internalType: internalType,\n        providers: wrapperProviders,\n        imports: injectorImports\n      };\n      return {\n        analysis: {\n          id: id,\n          schemas: schemas,\n          mod: ngModuleDef,\n          inj: ngInjectorDef,\n          deps: util_1.getValidConstructorDependencies(node, this.reflector, this.isCore),\n          declarations: declarationRefs,\n          rawDeclarations: rawDeclarations,\n          imports: importRefs,\n          exports: exportRefs,\n          providers: rawProviders,\n          providersRequiringFactory: rawProviders ? util_1.resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) : null,\n          metadataStmt: metadata_1.generateSetClassMetadataCall(node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n          factorySymbolName: node.name.text\n        }\n      };\n    };\n\n    NgModuleDecoratorHandler.prototype.symbol = function (node) {\n      return new NgModuleSymbol(node);\n    };\n\n    NgModuleDecoratorHandler.prototype.register = function (node, analysis) {\n      // Register this module's information with the LocalModuleScopeRegistry. This ensures that\n      // during the compile() phase, the module's metadata is available for selector scope\n      // computation.\n      this.metaRegistry.registerNgModuleMetadata({\n        ref: new imports_1.Reference(node),\n        schemas: analysis.schemas,\n        declarations: analysis.declarations,\n        imports: analysis.imports,\n        exports: analysis.exports,\n        rawDeclarations: analysis.rawDeclarations\n      });\n\n      if (this.factoryTracker !== null) {\n        this.factoryTracker.track(node.getSourceFile(), {\n          name: analysis.factorySymbolName,\n          hasId: analysis.id !== null\n        });\n      }\n\n      this.injectableRegistry.registerInjectable(node);\n    };\n\n    NgModuleDecoratorHandler.prototype.resolve = function (node, analysis) {\n      var e_4, _a, e_5, _b;\n\n      var scope = this.scopeRegistry.getScopeOfModule(node);\n      var diagnostics = [];\n      var scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);\n\n      if (scopeDiagnostics !== null) {\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(scopeDiagnostics));\n      }\n\n      if (analysis.providersRequiringFactory !== null) {\n        var providerDiagnostics = diagnostics_2.getProviderDiagnostics(analysis.providersRequiringFactory, analysis.providers, this.injectableRegistry);\n        diagnostics.push.apply(diagnostics, tslib_1.__spread(providerDiagnostics));\n      }\n\n      var data = {\n        injectorImports: []\n      };\n\n      if (scope !== null && !scope.compilation.isPoisoned) {\n        // Using the scope information, extend the injector's imports using the modules that are\n        // specified as module exports.\n        var context = typescript_1.getSourceFile(node);\n\n        try {\n          for (var _c = tslib_1.__values(analysis.exports), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var exportRef = _d.value;\n\n            if (isNgModule(exportRef.node, scope.compilation)) {\n              data.injectorImports.push(this.refEmitter.emit(exportRef, context).expression);\n            }\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n\n        try {\n          for (var _e = tslib_1.__values(analysis.declarations), _f = _e.next(); !_f.done; _f = _e.next()) {\n            var decl = _f.value;\n            var metadata = this.metaReader.getDirectiveMetadata(decl);\n\n            if (metadata !== null && metadata.selector === null) {\n              throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node, \"Directive \" + decl.node.name.text + \" has no selector, please add it!\");\n            }\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n      }\n\n      if (diagnostics.length > 0) {\n        return {\n          diagnostics: diagnostics\n        };\n      }\n\n      if (scope === null || scope.compilation.isPoisoned || scope.exported.isPoisoned || scope.reexports === null) {\n        return {\n          data: data\n        };\n      } else {\n        return {\n          data: data,\n          reexports: scope.reexports\n        };\n      }\n    };\n\n    NgModuleDecoratorHandler.prototype.compileFull = function (node, _a, resolution) {\n      var e_6, _b;\n\n      var _this = this;\n\n      var inj = _a.inj,\n          mod = _a.mod,\n          deps = _a.deps,\n          metadataStmt = _a.metadataStmt,\n          declarations = _a.declarations; //  Merge the injector imports (which are 'exports' that were later found to be NgModules)\n      //  computed during resolution with the ones from analysis.\n\n      var ngInjectorDef = compiler_1.compileInjector(tslib_1.__assign(tslib_1.__assign({}, inj), {\n        imports: tslib_1.__spread(inj.imports, resolution.injectorImports)\n      }));\n      var ngModuleDef = compiler_1.compileNgModule(mod);\n      var ngModuleStatements = ngModuleDef.additionalStatements;\n\n      if (metadataStmt !== null) {\n        ngModuleStatements.push(metadataStmt);\n      }\n\n      var context = typescript_1.getSourceFile(node);\n\n      try {\n        for (var declarations_1 = tslib_1.__values(declarations), declarations_1_1 = declarations_1.next(); !declarations_1_1.done; declarations_1_1 = declarations_1.next()) {\n          var decl = declarations_1_1.value;\n          var remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n\n          if (remoteScope !== null) {\n            var directives = remoteScope.directives.map(function (directive) {\n              return _this.refEmitter.emit(directive, context).expression;\n            });\n            var pipes = remoteScope.pipes.map(function (pipe) {\n              return _this.refEmitter.emit(pipe, context).expression;\n            });\n            var directiveArray = new compiler_1.LiteralArrayExpr(directives);\n            var pipesArray = new compiler_1.LiteralArrayExpr(pipes);\n            var declExpr = this.refEmitter.emit(decl, context).expression;\n            var setComponentScope = new compiler_1.ExternalExpr(compiler_1.R3Identifiers.setComponentScope);\n            var callExpr = new compiler_1.InvokeFunctionExpr(setComponentScope, [declExpr, directiveArray, pipesArray]);\n            ngModuleStatements.push(callExpr.toStmt());\n          }\n        }\n      } catch (e_6_1) {\n        e_6 = {\n          error: e_6_1\n        };\n      } finally {\n        try {\n          if (declarations_1_1 && !declarations_1_1.done && (_b = declarations_1.return)) _b.call(declarations_1);\n        } finally {\n          if (e_6) throw e_6.error;\n        }\n      }\n\n      var res = [factory_1.compileNgFactoryDefField({\n        name: inj.name,\n        type: inj.type,\n        internalType: inj.internalType,\n        typeArgumentCount: 0,\n        deps: deps,\n        injectFn: compiler_1.Identifiers.inject,\n        target: compiler_1.R3FactoryTarget.NgModule\n      }), {\n        name: 'ɵmod',\n        initializer: ngModuleDef.expression,\n        statements: ngModuleStatements,\n        type: ngModuleDef.type\n      }, {\n        name: 'ɵinj',\n        initializer: ngInjectorDef.expression,\n        statements: [],\n        type: ngInjectorDef.type\n      }];\n\n      if (this.localeId) {\n        res.push({\n          name: 'ɵloc',\n          initializer: new compiler_1.LiteralExpr(this.localeId),\n          statements: [],\n          type: compiler_1.STRING_TYPE\n        });\n      }\n\n      return res;\n    };\n\n    NgModuleDecoratorHandler.prototype._toR3Reference = function (valueRef, valueContext, typeContext) {\n      if (valueRef.hasOwningModuleGuess) {\n        return util_1.toR3Reference(valueRef, valueRef, valueContext, valueContext, this.refEmitter);\n      } else {\n        var typeRef = valueRef;\n        var typeNode = this.reflector.getDtsDeclaration(typeRef.node);\n\n        if (typeNode !== null && reflection_1.isNamedClassDeclaration(typeNode)) {\n          typeRef = new imports_1.Reference(typeNode);\n        }\n\n        return util_1.toR3Reference(valueRef, typeRef, valueContext, typeContext, this.refEmitter);\n      }\n    };\n    /**\n     * Given a `FunctionDeclaration`, `MethodDeclaration` or `FunctionExpression`, check if it is\n     * typed as a `ModuleWithProviders` and return an expression referencing the module if available.\n     */\n\n\n    NgModuleDecoratorHandler.prototype._extractModuleFromModuleWithProvidersFn = function (node) {\n      var type = node.type || null;\n      return type && (this._reflectModuleFromTypeParam(type, node) || this._reflectModuleFromLiteralType(type));\n    };\n    /**\n     * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:\n     * `ModuleWithProviders<T>`\n     * @param type The type to reflect on.\n     * @returns the identifier of the NgModule type if found, or null otherwise.\n     */\n\n\n    NgModuleDecoratorHandler.prototype._reflectModuleFromTypeParam = function (type, node) {\n      // Examine the type of the function to see if it's a ModuleWithProviders reference.\n      if (!ts.isTypeReferenceNode(type)) {\n        return null;\n      }\n\n      var typeName = type && (ts.isIdentifier(type.typeName) && type.typeName || ts.isQualifiedName(type.typeName) && type.typeName.right) || null;\n\n      if (typeName === null) {\n        return null;\n      } // Look at the type itself to see where it comes from.\n\n\n      var id = this.reflector.getImportOfIdentifier(typeName); // If it's not named ModuleWithProviders, bail.\n\n      if (id === null || id.name !== 'ModuleWithProviders') {\n        return null;\n      } // If it's not from @angular/core, bail.\n\n\n      if (!this.isCore && id.from !== '@angular/core') {\n        return null;\n      } // If there's no type parameter specified, bail.\n\n\n      if (type.typeArguments === undefined || type.typeArguments.length !== 1) {\n        var parent_1 = ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) ? node.parent : null;\n        var symbolName = (parent_1 && parent_1.name ? parent_1.name.getText() + '.' : '') + (node.name ? node.name.getText() : 'anonymous');\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type, symbolName + \" returns a ModuleWithProviders type without a generic type argument. \" + \"Please add a generic type argument to the ModuleWithProviders type. If this \" + \"occurrence is in library code you don't control, please contact the library authors.\");\n      }\n\n      var arg = type.typeArguments[0];\n      return reflection_1.typeNodeToValueExpr(arg);\n    };\n    /**\n     * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:\n     * `A|B|{ngModule: T}|C`.\n     * @param type The type to reflect on.\n     * @returns the identifier of the NgModule type if found, or null otherwise.\n     */\n\n\n    NgModuleDecoratorHandler.prototype._reflectModuleFromLiteralType = function (type) {\n      var e_7, _a, e_8, _b;\n\n      if (!ts.isIntersectionTypeNode(type)) {\n        return null;\n      }\n\n      try {\n        for (var _c = tslib_1.__values(type.types), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var t = _d.value;\n\n          if (ts.isTypeLiteralNode(t)) {\n            try {\n              for (var _e = (e_8 = void 0, tslib_1.__values(t.members)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var m = _f.value;\n                var ngModuleType = ts.isPropertySignature(m) && ts.isIdentifier(m.name) && m.name.text === 'ngModule' && m.type || null;\n                var ngModuleExpression = ngModuleType && reflection_1.typeNodeToValueExpr(ngModuleType);\n\n                if (ngModuleExpression) {\n                  return ngModuleExpression;\n                }\n              }\n            } catch (e_8_1) {\n              e_8 = {\n                error: e_8_1\n              };\n            } finally {\n              try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n              } finally {\n                if (e_8) throw e_8.error;\n              }\n            }\n          }\n        }\n      } catch (e_7_1) {\n        e_7 = {\n          error: e_7_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_7) throw e_7.error;\n        }\n      }\n\n      return null;\n    }; // Verify that a \"Declaration\" reference is a `ClassDeclaration` reference.\n\n\n    NgModuleDecoratorHandler.prototype.isClassDeclarationReference = function (ref) {\n      return this.reflector.isClass(ref.node);\n    };\n    /**\n     * Compute a list of `Reference`s from a resolved metadata value.\n     */\n\n\n    NgModuleDecoratorHandler.prototype.resolveTypeList = function (expr, resolvedList, className, arrayName) {\n      var _this = this;\n\n      var refList = [];\n\n      if (!Array.isArray(resolvedList)) {\n        throw diagnostics_2.createValueHasWrongTypeError(expr, resolvedList, \"Expected array when reading the NgModule.\" + arrayName + \" of \" + className);\n      }\n\n      resolvedList.forEach(function (entry, idx) {\n        // Unwrap ModuleWithProviders for modules that are locally declared (and thus static\n        // resolution was able to descend into the function and return an object literal, a Map).\n        if (entry instanceof Map && entry.has('ngModule')) {\n          entry = entry.get('ngModule');\n        }\n\n        if (Array.isArray(entry)) {\n          // Recurse into nested arrays.\n          refList.push.apply(refList, tslib_1.__spread(_this.resolveTypeList(expr, entry, className, arrayName)));\n        } else if (entry instanceof imports_1.Reference) {\n          if (!_this.isClassDeclarationReference(entry)) {\n            throw diagnostics_2.createValueHasWrongTypeError(entry.node, entry, \"Value at position \" + idx + \" in the NgModule.\" + arrayName + \" of \" + className + \" is not a class\");\n          }\n\n          refList.push(entry);\n        } else {\n          // TODO(alxhub): Produce a better diagnostic here - the array index may be an inner array.\n          throw diagnostics_2.createValueHasWrongTypeError(expr, entry, \"Value at position \" + idx + \" in the NgModule.\" + arrayName + \" of \" + className + \" is not a reference\");\n        }\n      });\n      return refList;\n    };\n\n    return NgModuleDecoratorHandler;\n  }();\n\n  exports.NgModuleDecoratorHandler = NgModuleDecoratorHandler;\n\n  function isNgModule(node, compilation) {\n    return !compilation.directives.some(function (directive) {\n      return directive.ref.node === node;\n    }) && !compilation.pipes.some(function (pipe) {\n      return pipe.ref.node === node;\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/ng_module.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileInjector, compileNgModule, CUSTOM_ELEMENTS_SCHEMA, Expression, ExternalExpr, Identifiers as R3, InvokeFunctionExpr, LiteralArrayExpr, LiteralExpr, NO_ERRORS_SCHEMA, R3DependencyMetadata, R3FactoryTarget, R3Identifiers, R3InjectorMetadata, R3NgModuleMetadata, R3Reference, SchemaMetadata, Statement, STRING_TYPE, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError, makeDiagnostic, makeRelatedInformation} from '../../diagnostics';\nimport {Reference, ReferenceEmitter} from '../../imports';\nimport {isArrayEqual, isReferenceEqual, isSymbolEqual, SemanticReference, SemanticSymbol} from '../../incremental/semantic_graph';\nimport {InjectableClassRegistry, MetadataReader, MetadataRegistry} from '../../metadata';\nimport {PartialEvaluator, ResolvedValue} from '../../partial_evaluator';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, Decorator, isNamedClassDeclaration, ReflectionHost, reflectObjectLiteral, typeNodeToValueExpr} from '../../reflection';\nimport {NgModuleRouteAnalyzer} from '../../routing';\nimport {LocalModuleScopeRegistry, ScopeData} from '../../scope';\nimport {FactoryTracker} from '../../shims/api';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence, ResolveResult} from '../../transform';\nimport {getSourceFile} from '../../util/src/typescript';\n\nimport {createValueHasWrongTypeError, getProviderDiagnostics} from './diagnostics';\nimport {compileNgFactoryDefField} from './factory';\nimport {generateSetClassMetadataCall} from './metadata';\nimport {ReferencesRegistry} from './references_registry';\nimport {combineResolvers, findAngularDecorator, forwardRefResolver, getValidConstructorDependencies, isExpressionForwardReference, resolveProvidersRequiringFactory, toR3Reference, unwrapExpression, wrapFunctionExpressionsInParens, wrapTypeReference} from './util';\n\nexport interface NgModuleAnalysis {\n  mod: R3NgModuleMetadata;\n  inj: R3InjectorMetadata;\n  deps: R3DependencyMetadata[]|null;\n  metadataStmt: Statement|null;\n  declarations: Reference<ClassDeclaration>[];\n  rawDeclarations: ts.Expression|null;\n  schemas: SchemaMetadata[];\n  imports: Reference<ClassDeclaration>[];\n  exports: Reference<ClassDeclaration>[];\n  id: Expression|null;\n  factorySymbolName: string;\n  providersRequiringFactory: Set<Reference<ClassDeclaration>>|null;\n  providers: ts.Expression|null;\n}\n\nexport interface NgModuleResolution {\n  injectorImports: Expression[];\n}\n\n/**\n * Represents an Angular NgModule.\n */\nexport class NgModuleSymbol extends SemanticSymbol {\n  private remotelyScopedComponents: {\n    component: SemanticSymbol,\n    usedDirectives: SemanticReference[],\n    usedPipes: SemanticReference[]\n  }[] = [];\n\n  isPublicApiAffected(previousSymbol: SemanticSymbol): boolean {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    // NgModules don't have a public API that could affect emit of Angular decorated classes.\n    return false;\n  }\n\n  isEmitAffected(previousSymbol: SemanticSymbol): boolean {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    // compare our remotelyScopedComponents to the previous symbol\n    if (previousSymbol.remotelyScopedComponents.length !== this.remotelyScopedComponents.length) {\n      return true;\n    }\n\n    for (const currEntry of this.remotelyScopedComponents) {\n      const prevEntry = previousSymbol.remotelyScopedComponents.find(prevEntry => {\n        return isSymbolEqual(prevEntry.component, currEntry.component);\n      });\n\n      if (prevEntry === undefined) {\n        // No previous entry was found, which means that this component became remotely scoped and\n        // hence this NgModule needs to be re-emitted.\n        return true;\n      }\n\n      if (!isArrayEqual(currEntry.usedDirectives, prevEntry.usedDirectives, isReferenceEqual)) {\n        // The list of used directives or their order has changed. Since this NgModule emits\n        // references to the list of used directives, it should be re-emitted to update this list.\n        // Note: the NgModule does not have to be re-emitted when any of the directives has had\n        // their public API changed, as the NgModule only emits a reference to the symbol by its\n        // name. Therefore, testing for symbol equality is sufficient.\n        return true;\n      }\n\n      if (!isArrayEqual(currEntry.usedPipes, prevEntry.usedPipes, isReferenceEqual)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  isTypeCheckApiAffected(previousSymbol: SemanticSymbol): boolean {\n    if (!(previousSymbol instanceof NgModuleSymbol)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  addRemotelyScopedComponent(\n      component: SemanticSymbol, usedDirectives: SemanticReference[],\n      usedPipes: SemanticReference[]): void {\n    this.remotelyScopedComponents.push({component, usedDirectives, usedPipes});\n  }\n}\n\n/**\n * Compiles @NgModule annotations to ngModuleDef fields.\n */\nexport class NgModuleDecoratorHandler implements\n    DecoratorHandler<Decorator, NgModuleAnalysis, NgModuleSymbol, NgModuleResolution> {\n  constructor(\n      private reflector: ReflectionHost, private evaluator: PartialEvaluator,\n      private metaReader: MetadataReader, private metaRegistry: MetadataRegistry,\n      private scopeRegistry: LocalModuleScopeRegistry,\n      private referencesRegistry: ReferencesRegistry, private isCore: boolean,\n      private routeAnalyzer: NgModuleRouteAnalyzer|null, private refEmitter: ReferenceEmitter,\n      private factoryTracker: FactoryTracker|null, private annotateForClosureCompiler: boolean,\n      private injectableRegistry: InjectableClassRegistry, private perf: PerfRecorder,\n      private localeId?: string) {}\n\n  readonly precedence = HandlerPrecedence.PRIMARY;\n  readonly name = NgModuleDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<Decorator>|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    const decorator = findAngularDecorator(decorators, 'NgModule', this.isCore);\n    if (decorator !== undefined) {\n      return {\n        trigger: decorator.node,\n        decorator: decorator,\n        metadata: decorator,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  analyze(node: ClassDeclaration, decorator: Readonly<Decorator>):\n      AnalysisOutput<NgModuleAnalysis> {\n    this.perf.eventCount(PerfEvent.AnalyzeNgModule);\n\n    const name = node.name.text;\n    if (decorator.args === null || decorator.args.length > 1) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARITY_WRONG, Decorator.nodeForError(decorator),\n          `Incorrect number of arguments to @NgModule decorator`);\n    }\n\n    // @NgModule can be invoked without arguments. In case it is, pretend as if a blank object\n    // literal was specified. This simplifies the code below.\n    const meta = decorator.args.length === 1 ? unwrapExpression(decorator.args[0]) :\n                                               ts.createObjectLiteral([]);\n\n    if (!ts.isObjectLiteralExpression(meta)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, meta,\n          '@NgModule argument must be an object literal');\n    }\n    const ngModule = reflectObjectLiteral(meta);\n\n    if (ngModule.has('jit')) {\n      // The only allowed value is true, so there's no need to expand further.\n      return {};\n    }\n\n    const moduleResolvers = combineResolvers([\n      ref => this._extractModuleFromModuleWithProvidersFn(ref.node),\n      forwardRefResolver,\n    ]);\n\n    const diagnostics: ts.Diagnostic[] = [];\n\n    // Extract the module declarations, imports, and exports.\n    let declarationRefs: Reference<ClassDeclaration>[] = [];\n    let rawDeclarations: ts.Expression|null = null;\n    if (ngModule.has('declarations')) {\n      rawDeclarations = ngModule.get('declarations')!;\n      const declarationMeta = this.evaluator.evaluate(rawDeclarations, forwardRefResolver);\n      declarationRefs =\n          this.resolveTypeList(rawDeclarations, declarationMeta, name, 'declarations');\n\n      // Look through the declarations to make sure they're all a part of the current compilation.\n      for (const ref of declarationRefs) {\n        if (ref.node.getSourceFile().isDeclarationFile) {\n          const errorNode: ts.Expression = ref.getOriginForDiagnostics(rawDeclarations);\n\n          diagnostics.push(makeDiagnostic(\n              ErrorCode.NGMODULE_INVALID_DECLARATION, errorNode,\n              `Cannot declare '${\n                  ref.node.name\n                      .text}' in an NgModule as it's not a part of the current compilation.`,\n              [makeRelatedInformation(\n                  ref.node.name, `'${ref.node.name.text}' is declared here.`)]));\n        }\n      }\n    }\n\n    if (diagnostics.length > 0) {\n      return {diagnostics};\n    }\n\n    let importRefs: Reference<ClassDeclaration>[] = [];\n    let rawImports: ts.Expression|null = null;\n    if (ngModule.has('imports')) {\n      rawImports = ngModule.get('imports')!;\n      const importsMeta = this.evaluator.evaluate(rawImports, moduleResolvers);\n      importRefs = this.resolveTypeList(rawImports, importsMeta, name, 'imports');\n    }\n    let exportRefs: Reference<ClassDeclaration>[] = [];\n    let rawExports: ts.Expression|null = null;\n    if (ngModule.has('exports')) {\n      rawExports = ngModule.get('exports')!;\n      const exportsMeta = this.evaluator.evaluate(rawExports, moduleResolvers);\n      exportRefs = this.resolveTypeList(rawExports, exportsMeta, name, 'exports');\n      this.referencesRegistry.add(node, ...exportRefs);\n    }\n    let bootstrapRefs: Reference<ClassDeclaration>[] = [];\n    if (ngModule.has('bootstrap')) {\n      const expr = ngModule.get('bootstrap')!;\n      const bootstrapMeta = this.evaluator.evaluate(expr, forwardRefResolver);\n      bootstrapRefs = this.resolveTypeList(expr, bootstrapMeta, name, 'bootstrap');\n    }\n\n    const schemas: SchemaMetadata[] = [];\n    if (ngModule.has('schemas')) {\n      const rawExpr = ngModule.get('schemas')!;\n      const result = this.evaluator.evaluate(rawExpr);\n      if (!Array.isArray(result)) {\n        throw createValueHasWrongTypeError(rawExpr, result, `NgModule.schemas must be an array`);\n      }\n\n      for (const schemaRef of result) {\n        if (!(schemaRef instanceof Reference)) {\n          throw createValueHasWrongTypeError(\n              rawExpr, result, 'NgModule.schemas must be an array of schemas');\n        }\n        const id = schemaRef.getIdentityIn(schemaRef.node.getSourceFile());\n        if (id === null || schemaRef.ownedByModuleGuess !== '@angular/core') {\n          throw createValueHasWrongTypeError(\n              rawExpr, result, 'NgModule.schemas must be an array of schemas');\n        }\n        // Since `id` is the `ts.Identifer` within the schema ref's declaration file, it's safe to\n        // use `id.text` here to figure out which schema is in use. Even if the actual reference was\n        // renamed when the user imported it, these names will match.\n        switch (id.text) {\n          case 'CUSTOM_ELEMENTS_SCHEMA':\n            schemas.push(CUSTOM_ELEMENTS_SCHEMA);\n            break;\n          case 'NO_ERRORS_SCHEMA':\n            schemas.push(NO_ERRORS_SCHEMA);\n            break;\n          default:\n            throw createValueHasWrongTypeError(\n                rawExpr, schemaRef, `'${schemaRef.debugName}' is not a valid NgModule schema`);\n        }\n      }\n    }\n\n    const id: Expression|null =\n        ngModule.has('id') ? new WrappedNodeExpr(ngModule.get('id')!) : null;\n    const valueContext = node.getSourceFile();\n\n    let typeContext = valueContext;\n    const typeNode = this.reflector.getDtsDeclaration(node);\n    if (typeNode !== null) {\n      typeContext = typeNode.getSourceFile();\n    }\n\n    const bootstrap =\n        bootstrapRefs.map(bootstrap => this._toR3Reference(bootstrap, valueContext, typeContext));\n    const declarations =\n        declarationRefs.map(decl => this._toR3Reference(decl, valueContext, typeContext));\n    const imports = importRefs.map(imp => this._toR3Reference(imp, valueContext, typeContext));\n    const exports = exportRefs.map(exp => this._toR3Reference(exp, valueContext, typeContext));\n\n    const isForwardReference = (ref: R3Reference) =>\n        isExpressionForwardReference(ref.value, node.name!, valueContext);\n    const containsForwardDecls = bootstrap.some(isForwardReference) ||\n        declarations.some(isForwardReference) || imports.some(isForwardReference) ||\n        exports.some(isForwardReference);\n\n    const type = wrapTypeReference(this.reflector, node);\n    const internalType = new WrappedNodeExpr(this.reflector.getInternalNameOfClass(node));\n    const adjacentType = new WrappedNodeExpr(this.reflector.getAdjacentNameOfClass(node));\n\n    const ngModuleDef: R3NgModuleMetadata = {\n      type,\n      internalType,\n      adjacentType,\n      bootstrap,\n      declarations,\n      exports,\n      imports,\n      containsForwardDecls,\n      id,\n      emitInline: false,\n      // TODO: to be implemented as a part of FW-1004.\n      schemas: [],\n    };\n\n    const rawProviders = ngModule.has('providers') ? ngModule.get('providers')! : null;\n    const wrapperProviders = rawProviders !== null ?\n        new WrappedNodeExpr(\n            this.annotateForClosureCompiler ? wrapFunctionExpressionsInParens(rawProviders) :\n                                              rawProviders) :\n        null;\n\n    // At this point, only add the module's imports as the injectors' imports. Any exported modules\n    // are added during `resolve`, as we need scope information to be able to filter out directives\n    // and pipes from the module exports.\n    const injectorImports: WrappedNodeExpr<ts.Expression>[] = [];\n    if (ngModule.has('imports')) {\n      injectorImports.push(new WrappedNodeExpr(ngModule.get('imports')!));\n    }\n\n    if (this.routeAnalyzer !== null) {\n      this.routeAnalyzer.add(node.getSourceFile(), name, rawImports, rawExports, rawProviders);\n    }\n\n    const ngInjectorDef: R3InjectorMetadata = {\n      name,\n      type,\n      internalType,\n      providers: wrapperProviders,\n      imports: injectorImports,\n    };\n\n    return {\n      analysis: {\n        id,\n        schemas: schemas,\n        mod: ngModuleDef,\n        inj: ngInjectorDef,\n        deps: getValidConstructorDependencies(node, this.reflector, this.isCore),\n        declarations: declarationRefs,\n        rawDeclarations,\n        imports: importRefs,\n        exports: exportRefs,\n        providers: rawProviders,\n        providersRequiringFactory: rawProviders ?\n            resolveProvidersRequiringFactory(rawProviders, this.reflector, this.evaluator) :\n            null,\n        metadataStmt: generateSetClassMetadataCall(\n            node, this.reflector, this.isCore, this.annotateForClosureCompiler),\n        factorySymbolName: node.name.text,\n      },\n    };\n  }\n\n  symbol(node: ClassDeclaration): NgModuleSymbol {\n    return new NgModuleSymbol(node);\n  }\n\n  register(node: ClassDeclaration, analysis: NgModuleAnalysis): void {\n    // Register this module's information with the LocalModuleScopeRegistry. This ensures that\n    // during the compile() phase, the module's metadata is available for selector scope\n    // computation.\n    this.metaRegistry.registerNgModuleMetadata({\n      ref: new Reference(node),\n      schemas: analysis.schemas,\n      declarations: analysis.declarations,\n      imports: analysis.imports,\n      exports: analysis.exports,\n      rawDeclarations: analysis.rawDeclarations,\n    });\n\n    if (this.factoryTracker !== null) {\n      this.factoryTracker.track(node.getSourceFile(), {\n        name: analysis.factorySymbolName,\n        hasId: analysis.id !== null,\n      });\n    }\n\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  resolve(node: ClassDeclaration, analysis: Readonly<NgModuleAnalysis>):\n      ResolveResult<NgModuleResolution> {\n    const scope = this.scopeRegistry.getScopeOfModule(node);\n    const diagnostics: ts.Diagnostic[] = [];\n\n    const scopeDiagnostics = this.scopeRegistry.getDiagnosticsOfModule(node);\n    if (scopeDiagnostics !== null) {\n      diagnostics.push(...scopeDiagnostics);\n    }\n\n    if (analysis.providersRequiringFactory !== null) {\n      const providerDiagnostics = getProviderDiagnostics(\n          analysis.providersRequiringFactory, analysis.providers!, this.injectableRegistry);\n      diagnostics.push(...providerDiagnostics);\n    }\n\n    const data: NgModuleResolution = {\n      injectorImports: [],\n    };\n\n    if (scope !== null && !scope.compilation.isPoisoned) {\n      // Using the scope information, extend the injector's imports using the modules that are\n      // specified as module exports.\n      const context = getSourceFile(node);\n      for (const exportRef of analysis.exports) {\n        if (isNgModule(exportRef.node, scope.compilation)) {\n          data.injectorImports.push(this.refEmitter.emit(exportRef, context).expression);\n        }\n      }\n\n      for (const decl of analysis.declarations) {\n        const metadata = this.metaReader.getDirectiveMetadata(decl);\n\n        if (metadata !== null && metadata.selector === null) {\n          throw new FatalDiagnosticError(\n              ErrorCode.DIRECTIVE_MISSING_SELECTOR, decl.node,\n              `Directive ${decl.node.name.text} has no selector, please add it!`);\n        }\n      }\n    }\n\n    if (diagnostics.length > 0) {\n      return {diagnostics};\n    }\n\n    if (scope === null || scope.compilation.isPoisoned || scope.exported.isPoisoned ||\n        scope.reexports === null) {\n      return {data};\n    } else {\n      return {\n        data,\n        reexports: scope.reexports,\n      };\n    }\n  }\n\n  compileFull(\n      node: ClassDeclaration,\n      {inj, mod, deps, metadataStmt, declarations}: Readonly<NgModuleAnalysis>,\n      resolution: Readonly<NgModuleResolution>): CompileResult[] {\n    //  Merge the injector imports (which are 'exports' that were later found to be NgModules)\n    //  computed during resolution with the ones from analysis.\n    const ngInjectorDef =\n        compileInjector({...inj, imports: [...inj.imports, ...resolution.injectorImports]});\n    const ngModuleDef = compileNgModule(mod);\n    const ngModuleStatements = ngModuleDef.additionalStatements;\n    if (metadataStmt !== null) {\n      ngModuleStatements.push(metadataStmt);\n    }\n    const context = getSourceFile(node);\n    for (const decl of declarations) {\n      const remoteScope = this.scopeRegistry.getRemoteScope(decl.node);\n      if (remoteScope !== null) {\n        const directives = remoteScope.directives.map(\n            directive => this.refEmitter.emit(directive, context).expression);\n        const pipes = remoteScope.pipes.map(pipe => this.refEmitter.emit(pipe, context).expression);\n        const directiveArray = new LiteralArrayExpr(directives);\n        const pipesArray = new LiteralArrayExpr(pipes);\n        const declExpr = this.refEmitter.emit(decl, context).expression;\n        const setComponentScope = new ExternalExpr(R3Identifiers.setComponentScope);\n        const callExpr =\n            new InvokeFunctionExpr(setComponentScope, [declExpr, directiveArray, pipesArray]);\n\n        ngModuleStatements.push(callExpr.toStmt());\n      }\n    }\n    const res: CompileResult[] = [\n      compileNgFactoryDefField({\n        name: inj.name,\n        type: inj.type,\n        internalType: inj.internalType,\n        typeArgumentCount: 0,\n        deps,\n        injectFn: R3.inject,\n        target: R3FactoryTarget.NgModule,\n      }),\n      {\n        name: 'ɵmod',\n        initializer: ngModuleDef.expression,\n        statements: ngModuleStatements,\n        type: ngModuleDef.type,\n      },\n      {\n        name: 'ɵinj',\n        initializer: ngInjectorDef.expression,\n        statements: [],\n        type: ngInjectorDef.type,\n      },\n    ];\n\n    if (this.localeId) {\n      res.push({\n        name: 'ɵloc',\n        initializer: new LiteralExpr(this.localeId),\n        statements: [],\n        type: STRING_TYPE\n      });\n    }\n\n    return res;\n  }\n\n  private _toR3Reference(\n      valueRef: Reference<ClassDeclaration>, valueContext: ts.SourceFile,\n      typeContext: ts.SourceFile): R3Reference {\n    if (valueRef.hasOwningModuleGuess) {\n      return toR3Reference(valueRef, valueRef, valueContext, valueContext, this.refEmitter);\n    } else {\n      let typeRef = valueRef;\n      let typeNode = this.reflector.getDtsDeclaration(typeRef.node);\n      if (typeNode !== null && isNamedClassDeclaration(typeNode)) {\n        typeRef = new Reference(typeNode);\n      }\n      return toR3Reference(valueRef, typeRef, valueContext, typeContext, this.refEmitter);\n    }\n  }\n\n  /**\n   * Given a `FunctionDeclaration`, `MethodDeclaration` or `FunctionExpression`, check if it is\n   * typed as a `ModuleWithProviders` and return an expression referencing the module if available.\n   */\n  private _extractModuleFromModuleWithProvidersFn(node: ts.FunctionDeclaration|\n                                                  ts.MethodDeclaration|\n                                                  ts.FunctionExpression): ts.Expression|null {\n    const type = node.type || null;\n    return type &&\n        (this._reflectModuleFromTypeParam(type, node) || this._reflectModuleFromLiteralType(type));\n  }\n\n  /**\n   * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:\n   * `ModuleWithProviders<T>`\n   * @param type The type to reflect on.\n   * @returns the identifier of the NgModule type if found, or null otherwise.\n   */\n  private _reflectModuleFromTypeParam(\n      type: ts.TypeNode,\n      node: ts.FunctionDeclaration|ts.MethodDeclaration|ts.FunctionExpression): ts.Expression|null {\n    // Examine the type of the function to see if it's a ModuleWithProviders reference.\n    if (!ts.isTypeReferenceNode(type)) {\n      return null;\n    }\n\n    const typeName = type &&\n            (ts.isIdentifier(type.typeName) && type.typeName ||\n             ts.isQualifiedName(type.typeName) && type.typeName.right) ||\n        null;\n    if (typeName === null) {\n      return null;\n    }\n\n    // Look at the type itself to see where it comes from.\n    const id = this.reflector.getImportOfIdentifier(typeName);\n\n    // If it's not named ModuleWithProviders, bail.\n    if (id === null || id.name !== 'ModuleWithProviders') {\n      return null;\n    }\n\n    // If it's not from @angular/core, bail.\n    if (!this.isCore && id.from !== '@angular/core') {\n      return null;\n    }\n\n    // If there's no type parameter specified, bail.\n    if (type.typeArguments === undefined || type.typeArguments.length !== 1) {\n      const parent =\n          ts.isMethodDeclaration(node) && ts.isClassDeclaration(node.parent) ? node.parent : null;\n      const symbolName = (parent && parent.name ? parent.name.getText() + '.' : '') +\n          (node.name ? node.name.getText() : 'anonymous');\n      throw new FatalDiagnosticError(\n          ErrorCode.NGMODULE_MODULE_WITH_PROVIDERS_MISSING_GENERIC, type,\n          `${symbolName} returns a ModuleWithProviders type without a generic type argument. ` +\n              `Please add a generic type argument to the ModuleWithProviders type. If this ` +\n              `occurrence is in library code you don't control, please contact the library authors.`);\n    }\n\n    const arg = type.typeArguments[0];\n\n    return typeNodeToValueExpr(arg);\n  }\n\n  /**\n   * Retrieve an `NgModule` identifier (T) from the specified `type`, if it is of the form:\n   * `A|B|{ngModule: T}|C`.\n   * @param type The type to reflect on.\n   * @returns the identifier of the NgModule type if found, or null otherwise.\n   */\n  private _reflectModuleFromLiteralType(type: ts.TypeNode): ts.Expression|null {\n    if (!ts.isIntersectionTypeNode(type)) {\n      return null;\n    }\n    for (const t of type.types) {\n      if (ts.isTypeLiteralNode(t)) {\n        for (const m of t.members) {\n          const ngModuleType = ts.isPropertySignature(m) && ts.isIdentifier(m.name) &&\n                  m.name.text === 'ngModule' && m.type ||\n              null;\n          const ngModuleExpression = ngModuleType && typeNodeToValueExpr(ngModuleType);\n          if (ngModuleExpression) {\n            return ngModuleExpression;\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  // Verify that a \"Declaration\" reference is a `ClassDeclaration` reference.\n  private isClassDeclarationReference(ref: Reference): ref is Reference<ClassDeclaration> {\n    return this.reflector.isClass(ref.node);\n  }\n\n  /**\n   * Compute a list of `Reference`s from a resolved metadata value.\n   */\n  private resolveTypeList(\n      expr: ts.Node, resolvedList: ResolvedValue, className: string,\n      arrayName: string): Reference<ClassDeclaration>[] {\n    const refList: Reference<ClassDeclaration>[] = [];\n    if (!Array.isArray(resolvedList)) {\n      throw createValueHasWrongTypeError(\n          expr, resolvedList,\n          `Expected array when reading the NgModule.${arrayName} of ${className}`);\n    }\n\n    resolvedList.forEach((entry, idx) => {\n      // Unwrap ModuleWithProviders for modules that are locally declared (and thus static\n      // resolution was able to descend into the function and return an object literal, a Map).\n      if (entry instanceof Map && entry.has('ngModule')) {\n        entry = entry.get('ngModule')!;\n      }\n\n      if (Array.isArray(entry)) {\n        // Recurse into nested arrays.\n        refList.push(...this.resolveTypeList(expr, entry, className, arrayName));\n      } else if (entry instanceof Reference) {\n        if (!this.isClassDeclarationReference(entry)) {\n          throw createValueHasWrongTypeError(\n              entry.node, entry,\n              `Value at position ${idx} in the NgModule.${arrayName} of ${\n                  className} is not a class`);\n        }\n        refList.push(entry);\n      } else {\n        // TODO(alxhub): Produce a better diagnostic here - the array index may be an inner array.\n        throw createValueHasWrongTypeError(\n            expr, entry,\n            `Value at position ${idx} in the NgModule.${arrayName} of ${\n                className} is not a reference`);\n      }\n    });\n\n    return refList;\n  }\n}\n\nfunction isNgModule(node: ClassDeclaration, compilation: ScopeData): boolean {\n  return !compilation.directives.some(directive => directive.ref.node === node) &&\n      !compilation.pipes.some(pipe => pipe.ref.node === node);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}