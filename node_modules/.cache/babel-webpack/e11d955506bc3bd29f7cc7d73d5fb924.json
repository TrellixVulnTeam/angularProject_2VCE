{"ast":null,"code":"'use strict';\n/* eslint-disable\n  class-methods-use-this\n*/\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar ws = require('ws');\n\nvar BaseServer = require('./BaseServer');\n\nmodule.exports = /*#__PURE__*/function (_BaseServer) {\n  _inherits(WebsocketServer, _BaseServer);\n\n  var _super = _createSuper(WebsocketServer);\n\n  function WebsocketServer(server) {\n    var _this;\n\n    _classCallCheck(this, WebsocketServer);\n\n    _this = _super.call(this, server);\n    _this.wsServer = new ws.Server({\n      noServer: true,\n      path: _this.server.sockPath\n    });\n\n    _this.server.listeningApp.on('upgrade', function (req, sock, head) {\n      if (!_this.wsServer.shouldHandle(req)) {\n        return;\n      }\n\n      _this.wsServer.handleUpgrade(req, sock, head, function (connection) {\n        _this.wsServer.emit('connection', connection, req);\n      });\n    });\n\n    _this.wsServer.on('error', function (err) {\n      _this.server.log.error(err.message);\n    });\n\n    var noop = function noop() {};\n\n    setInterval(function () {\n      _this.wsServer.clients.forEach(function (socket) {\n        if (socket.isAlive === false) {\n          return socket.terminate();\n        }\n\n        socket.isAlive = false;\n        socket.ping(noop);\n      });\n    }, _this.server.heartbeatInterval);\n    return _this;\n  }\n\n  _createClass(WebsocketServer, [{\n    key: \"send\",\n    value: function send(connection, message) {\n      // prevent cases where the server is trying to send data while connection is closing\n      if (connection.readyState !== 1) {\n        return;\n      }\n\n      connection.send(message);\n    }\n  }, {\n    key: \"close\",\n    value: function close(connection) {\n      connection.close();\n    } // f should be passed the resulting connection and the connection headers\n\n  }, {\n    key: \"onConnection\",\n    value: function onConnection(f) {\n      this.wsServer.on('connection', function (connection, req) {\n        connection.isAlive = true;\n        connection.on('pong', function () {\n          connection.isAlive = true;\n        });\n        f(connection, req.headers);\n      });\n    }\n  }, {\n    key: \"onConnectionClose\",\n    value: function onConnectionClose(connection, f) {\n      connection.on('close', f);\n    }\n  }]);\n\n  return WebsocketServer;\n}(BaseServer);","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/webpack-dev-server/lib/servers/WebsocketServer.js"],"names":["ws","require","BaseServer","module","exports","server","wsServer","Server","noServer","path","sockPath","listeningApp","on","req","sock","head","shouldHandle","handleUpgrade","connection","emit","err","log","error","message","noop","setInterval","clients","forEach","socket","isAlive","terminate","ping","heartbeatInterval","readyState","send","close","f","headers"],"mappings":"AAAA;AAEA;AACA;AACA;;;;;;;;;;AACA,IAAMA,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,IAAMC,UAAU,GAAGD,OAAO,CAAC,cAAD,CAA1B;;AAEAE,MAAM,CAACC,OAAP;AAAA;;AAAA;;AACE,2BAAYC,MAAZ,EAAoB;AAAA;;AAAA;;AAClB,8BAAMA,MAAN;AACA,UAAKC,QAAL,GAAgB,IAAIN,EAAE,CAACO,MAAP,CAAc;AAC5BC,MAAAA,QAAQ,EAAE,IADkB;AAE5BC,MAAAA,IAAI,EAAE,MAAKJ,MAAL,CAAYK;AAFU,KAAd,CAAhB;;AAKA,UAAKL,MAAL,CAAYM,YAAZ,CAAyBC,EAAzB,CAA4B,SAA5B,EAAuC,UAACC,GAAD,EAAMC,IAAN,EAAYC,IAAZ,EAAqB;AAC1D,UAAI,CAAC,MAAKT,QAAL,CAAcU,YAAd,CAA2BH,GAA3B,CAAL,EAAsC;AACpC;AACD;;AAED,YAAKP,QAAL,CAAcW,aAAd,CAA4BJ,GAA5B,EAAiCC,IAAjC,EAAuCC,IAAvC,EAA6C,UAACG,UAAD,EAAgB;AAC3D,cAAKZ,QAAL,CAAca,IAAd,CAAmB,YAAnB,EAAiCD,UAAjC,EAA6CL,GAA7C;AACD,OAFD;AAGD,KARD;;AAUA,UAAKP,QAAL,CAAcM,EAAd,CAAiB,OAAjB,EAA0B,UAACQ,GAAD,EAAS;AACjC,YAAKf,MAAL,CAAYgB,GAAZ,CAAgBC,KAAhB,CAAsBF,GAAG,CAACG,OAA1B;AACD,KAFD;;AAIA,QAAMC,IAAI,GAAG,SAAPA,IAAO,GAAM,CAAE,CAArB;;AAEAC,IAAAA,WAAW,CAAC,YAAM;AAChB,YAAKnB,QAAL,CAAcoB,OAAd,CAAsBC,OAAtB,CAA8B,UAACC,MAAD,EAAY;AACxC,YAAIA,MAAM,CAACC,OAAP,KAAmB,KAAvB,EAA8B;AAC5B,iBAAOD,MAAM,CAACE,SAAP,EAAP;AACD;;AAEDF,QAAAA,MAAM,CAACC,OAAP,GAAiB,KAAjB;AACAD,QAAAA,MAAM,CAACG,IAAP,CAAYP,IAAZ;AACD,OAPD;AAQD,KATU,EASR,MAAKnB,MAAL,CAAY2B,iBATJ,CAAX;AAvBkB;AAiCnB;;AAlCH;AAAA;AAAA,WAoCE,cAAKd,UAAL,EAAiBK,OAAjB,EAA0B;AACxB;AACA,UAAIL,UAAU,CAACe,UAAX,KAA0B,CAA9B,EAAiC;AAC/B;AACD;;AAEDf,MAAAA,UAAU,CAACgB,IAAX,CAAgBX,OAAhB;AACD;AA3CH;AAAA;AAAA,WA6CE,eAAML,UAAN,EAAkB;AAChBA,MAAAA,UAAU,CAACiB,KAAX;AACD,KA/CH,CAiDE;;AAjDF;AAAA;AAAA,WAkDE,sBAAaC,CAAb,EAAgB;AACd,WAAK9B,QAAL,CAAcM,EAAd,CAAiB,YAAjB,EAA+B,UAACM,UAAD,EAAaL,GAAb,EAAqB;AAClDK,QAAAA,UAAU,CAACW,OAAX,GAAqB,IAArB;AACAX,QAAAA,UAAU,CAACN,EAAX,CAAc,MAAd,EAAsB,YAAM;AAC1BM,UAAAA,UAAU,CAACW,OAAX,GAAqB,IAArB;AACD,SAFD;AAGAO,QAAAA,CAAC,CAAClB,UAAD,EAAaL,GAAG,CAACwB,OAAjB,CAAD;AACD,OAND;AAOD;AA1DH;AAAA;AAAA,WA4DE,2BAAkBnB,UAAlB,EAA8BkB,CAA9B,EAAiC;AAC/BlB,MAAAA,UAAU,CAACN,EAAX,CAAc,OAAd,EAAuBwB,CAAvB;AACD;AA9DH;;AAAA;AAAA,EAA+ClC,UAA/C","sourcesContent":["'use strict';\n\n/* eslint-disable\n  class-methods-use-this\n*/\nconst ws = require('ws');\nconst BaseServer = require('./BaseServer');\n\nmodule.exports = class WebsocketServer extends BaseServer {\n  constructor(server) {\n    super(server);\n    this.wsServer = new ws.Server({\n      noServer: true,\n      path: this.server.sockPath,\n    });\n\n    this.server.listeningApp.on('upgrade', (req, sock, head) => {\n      if (!this.wsServer.shouldHandle(req)) {\n        return;\n      }\n\n      this.wsServer.handleUpgrade(req, sock, head, (connection) => {\n        this.wsServer.emit('connection', connection, req);\n      });\n    });\n\n    this.wsServer.on('error', (err) => {\n      this.server.log.error(err.message);\n    });\n\n    const noop = () => {};\n\n    setInterval(() => {\n      this.wsServer.clients.forEach((socket) => {\n        if (socket.isAlive === false) {\n          return socket.terminate();\n        }\n\n        socket.isAlive = false;\n        socket.ping(noop);\n      });\n    }, this.server.heartbeatInterval);\n  }\n\n  send(connection, message) {\n    // prevent cases where the server is trying to send data while connection is closing\n    if (connection.readyState !== 1) {\n      return;\n    }\n\n    connection.send(message);\n  }\n\n  close(connection) {\n    connection.close();\n  }\n\n  // f should be passed the resulting connection and the connection headers\n  onConnection(f) {\n    this.wsServer.on('connection', (connection, req) => {\n      connection.isAlive = true;\n      connection.on('pong', () => {\n        connection.isAlive = true;\n      });\n      f(connection, req.headers);\n    });\n  }\n\n  onConnectionClose(connection, f) {\n    connection.on('close', f);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}