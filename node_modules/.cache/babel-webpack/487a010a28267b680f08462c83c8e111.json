{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/imports/src/default\", [\"require\", \"exports\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/util/src/typescript\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.DefaultImportTracker = exports.getDefaultImportDeclaration = exports.attachDefaultImportDeclaration = void 0;\n\n  var ts = require(\"typescript\");\n\n  var typescript_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/typescript\");\n\n  var DefaultImportDeclaration = Symbol('DefaultImportDeclaration');\n  /**\n   * Attaches a default import declaration to `expr` to indicate the dependency of `expr` on the\n   * default import.\n   */\n\n  function attachDefaultImportDeclaration(expr, importDecl) {\n    expr[DefaultImportDeclaration] = importDecl;\n  }\n\n  exports.attachDefaultImportDeclaration = attachDefaultImportDeclaration;\n  /**\n   * Obtains the default import declaration that `expr` depends on, or `null` if there is no such\n   * dependency.\n   */\n\n  function getDefaultImportDeclaration(expr) {\n    var _a;\n\n    return (_a = expr[DefaultImportDeclaration]) !== null && _a !== void 0 ? _a : null;\n  }\n\n  exports.getDefaultImportDeclaration = getDefaultImportDeclaration;\n  /**\n   * TypeScript has trouble with generating default imports inside of transformers for some module\n   * formats. The issue is that for the statement:\n   *\n   * import X from 'some/module';\n   * console.log(X);\n   *\n   * TypeScript will not use the \"X\" name in generated code. For normal user code, this is fine\n   * because references to X will also be renamed. However, if both the import and any references are\n   * added in a transformer, TypeScript does not associate the two, and will leave the \"X\" references\n   * dangling while renaming the import variable. The generated code looks something like:\n   *\n   * const module_1 = require('some/module');\n   * console.log(X); // now X is a dangling reference.\n   *\n   * Therefore, we cannot synthetically add default imports, and must reuse the imports that users\n   * include. Doing this poses a challenge for imports that are only consumed in the type position in\n   * the user's code. If Angular reuses the imported symbol in a value position (for example, we\n   * see a constructor parameter of type Foo and try to write \"inject(Foo)\") we will also end up with\n   * a dangling reference, as TS will elide the import because it was only used in the type position\n   * originally.\n   *\n   * To avoid this, the compiler must \"touch\" the imports with `ts.getMutableClone`, and should\n   * only do this for imports which are actually consumed. The `DefaultImportTracker` keeps track of\n   * these imports as they're encountered and emitted, and implements a transform which can correctly\n   * flag the imports as required.\n   *\n   * This problem does not exist for non-default imports as the compiler can easily insert\n   * \"import * as X\" style imports for those, and the \"X\" identifier survives transformation.\n   */\n\n  var DefaultImportTracker =\n  /** @class */\n  function () {\n    function DefaultImportTracker() {\n      /**\n       * A `Map` which tracks the `Set` of `ts.ImportDeclaration`s for default imports that were used in\n       * a given `ts.SourceFile` and need to be preserved.\n       */\n      this.sourceFileToUsedImports = new Map();\n    }\n\n    DefaultImportTracker.prototype.recordUsedImport = function (importDecl) {\n      var sf = typescript_1.getSourceFile(importDecl); // Add the default import declaration to the set of used import declarations for the file.\n\n      if (!this.sourceFileToUsedImports.has(sf)) {\n        this.sourceFileToUsedImports.set(sf, new Set());\n      }\n\n      this.sourceFileToUsedImports.get(sf).add(importDecl);\n    };\n    /**\n     * Get a `ts.TransformerFactory` which will preserve default imports that were previously marked\n     * as used.\n     *\n     * This transformer must run after any other transformers which call `recordUsedImport`.\n     */\n\n\n    DefaultImportTracker.prototype.importPreservingTransformer = function () {\n      var _this = this;\n\n      return function (context) {\n        return function (sf) {\n          return _this.transformSourceFile(sf);\n        };\n      };\n    };\n    /**\n     * Process a `ts.SourceFile` and replace any `ts.ImportDeclaration`s.\n     */\n\n\n    DefaultImportTracker.prototype.transformSourceFile = function (sf) {\n      var originalSf = ts.getOriginalNode(sf); // Take a fast path if no import declarations need to be preserved in the file.\n\n      if (!this.sourceFileToUsedImports.has(originalSf)) {\n        return sf;\n      } // There are declarations that need to be preserved.\n\n\n      var importsToPreserve = this.sourceFileToUsedImports.get(originalSf); // Generate a new statement list which preserves any imports present in `importsToPreserve`.\n\n      var statements = sf.statements.map(function (stmt) {\n        if (ts.isImportDeclaration(stmt) && importsToPreserve.has(stmt)) {\n          // Preserving an import that's marked as unreferenced (type-only) is tricky in TypeScript.\n          //\n          // Various approaches have been tried, with mixed success:\n          //\n          // 1. Using `ts.updateImportDeclaration` does not cause the import to be retained.\n          //\n          // 2. Using `ts.createImportDeclaration` with the same `ts.ImportClause` causes the import\n          //    to correctly be retained, but when emitting CommonJS module format code, references\n          //    to the imported value will not match the import variable.\n          //\n          // 3. Emitting \"import * as\" imports instead generates the correct import variable, but\n          //    references are missing the \".default\" access. This happens to work for tsickle code\n          //    with goog.module transformations as tsickle strips the \".default\" anyway.\n          //\n          // 4. It's possible to trick TypeScript by setting `ts.NodeFlag.Synthesized` on the import\n          //    declaration. This causes the import to be correctly retained and generated, but can\n          //    violate invariants elsewhere in the compiler and cause crashes.\n          //\n          // 5. Using `ts.getMutableClone` seems to correctly preserve the import and correctly\n          //    generate references to the import variable across all module types.\n          //\n          // Therefore, option 5 is the one used here. It seems to be implemented as the correct way\n          // to perform option 4, which preserves all the compiler's invariants.\n          //\n          // TODO(alxhub): discuss with the TypeScript team and determine if there's a better way to\n          // deal with this issue.\n          stmt = ts.getMutableClone(stmt);\n        }\n\n        return stmt;\n      }); // Save memory - there's no need to keep these around once the transform has run for the given\n      // file.\n\n      this.sourceFileToUsedImports.delete(originalSf);\n      return ts.updateSourceFileNode(sf, statements);\n    };\n\n    return DefaultImportTracker;\n  }();\n\n  exports.DefaultImportTracker = DefaultImportTracker;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/imports/src/default.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {getSourceFile} from '../../util/src/typescript';\n\nconst DefaultImportDeclaration = Symbol('DefaultImportDeclaration');\n\ninterface WithDefaultImportDeclaration {\n  [DefaultImportDeclaration]?: ts.ImportDeclaration;\n}\n\n/**\n * Attaches a default import declaration to `expr` to indicate the dependency of `expr` on the\n * default import.\n */\nexport function attachDefaultImportDeclaration(\n    expr: WrappedNodeExpr<unknown>, importDecl: ts.ImportDeclaration): void {\n  (expr as WithDefaultImportDeclaration)[DefaultImportDeclaration] = importDecl;\n}\n\n/**\n * Obtains the default import declaration that `expr` depends on, or `null` if there is no such\n * dependency.\n */\nexport function getDefaultImportDeclaration(expr: WrappedNodeExpr<unknown>): ts.ImportDeclaration|\n    null {\n  return (expr as WithDefaultImportDeclaration)[DefaultImportDeclaration] ?? null;\n}\n\n/**\n * TypeScript has trouble with generating default imports inside of transformers for some module\n * formats. The issue is that for the statement:\n *\n * import X from 'some/module';\n * console.log(X);\n *\n * TypeScript will not use the \"X\" name in generated code. For normal user code, this is fine\n * because references to X will also be renamed. However, if both the import and any references are\n * added in a transformer, TypeScript does not associate the two, and will leave the \"X\" references\n * dangling while renaming the import variable. The generated code looks something like:\n *\n * const module_1 = require('some/module');\n * console.log(X); // now X is a dangling reference.\n *\n * Therefore, we cannot synthetically add default imports, and must reuse the imports that users\n * include. Doing this poses a challenge for imports that are only consumed in the type position in\n * the user's code. If Angular reuses the imported symbol in a value position (for example, we\n * see a constructor parameter of type Foo and try to write \"inject(Foo)\") we will also end up with\n * a dangling reference, as TS will elide the import because it was only used in the type position\n * originally.\n *\n * To avoid this, the compiler must \"touch\" the imports with `ts.getMutableClone`, and should\n * only do this for imports which are actually consumed. The `DefaultImportTracker` keeps track of\n * these imports as they're encountered and emitted, and implements a transform which can correctly\n * flag the imports as required.\n *\n * This problem does not exist for non-default imports as the compiler can easily insert\n * \"import * as X\" style imports for those, and the \"X\" identifier survives transformation.\n */\nexport class DefaultImportTracker {\n  /**\n   * A `Map` which tracks the `Set` of `ts.ImportDeclaration`s for default imports that were used in\n   * a given `ts.SourceFile` and need to be preserved.\n   */\n  private sourceFileToUsedImports = new Map<ts.SourceFile, Set<ts.ImportDeclaration>>();\n\n  recordUsedImport(importDecl: ts.ImportDeclaration): void {\n    const sf = getSourceFile(importDecl);\n\n    // Add the default import declaration to the set of used import declarations for the file.\n    if (!this.sourceFileToUsedImports.has(sf)) {\n      this.sourceFileToUsedImports.set(sf, new Set<ts.ImportDeclaration>());\n    }\n    this.sourceFileToUsedImports.get(sf)!.add(importDecl);\n  }\n\n  /**\n   * Get a `ts.TransformerFactory` which will preserve default imports that were previously marked\n   * as used.\n   *\n   * This transformer must run after any other transformers which call `recordUsedImport`.\n   */\n  importPreservingTransformer(): ts.TransformerFactory<ts.SourceFile> {\n    return (context: ts.TransformationContext) => {\n      return (sf: ts.SourceFile) => {\n        return this.transformSourceFile(sf);\n      };\n    };\n  }\n\n  /**\n   * Process a `ts.SourceFile` and replace any `ts.ImportDeclaration`s.\n   */\n  private transformSourceFile(sf: ts.SourceFile): ts.SourceFile {\n    const originalSf = ts.getOriginalNode(sf) as ts.SourceFile;\n    // Take a fast path if no import declarations need to be preserved in the file.\n    if (!this.sourceFileToUsedImports.has(originalSf)) {\n      return sf;\n    }\n\n    // There are declarations that need to be preserved.\n    const importsToPreserve = this.sourceFileToUsedImports.get(originalSf)!;\n\n    // Generate a new statement list which preserves any imports present in `importsToPreserve`.\n    const statements = sf.statements.map(stmt => {\n      if (ts.isImportDeclaration(stmt) && importsToPreserve.has(stmt)) {\n        // Preserving an import that's marked as unreferenced (type-only) is tricky in TypeScript.\n        //\n        // Various approaches have been tried, with mixed success:\n        //\n        // 1. Using `ts.updateImportDeclaration` does not cause the import to be retained.\n        //\n        // 2. Using `ts.createImportDeclaration` with the same `ts.ImportClause` causes the import\n        //    to correctly be retained, but when emitting CommonJS module format code, references\n        //    to the imported value will not match the import variable.\n        //\n        // 3. Emitting \"import * as\" imports instead generates the correct import variable, but\n        //    references are missing the \".default\" access. This happens to work for tsickle code\n        //    with goog.module transformations as tsickle strips the \".default\" anyway.\n        //\n        // 4. It's possible to trick TypeScript by setting `ts.NodeFlag.Synthesized` on the import\n        //    declaration. This causes the import to be correctly retained and generated, but can\n        //    violate invariants elsewhere in the compiler and cause crashes.\n        //\n        // 5. Using `ts.getMutableClone` seems to correctly preserve the import and correctly\n        //    generate references to the import variable across all module types.\n        //\n        // Therefore, option 5 is the one used here. It seems to be implemented as the correct way\n        // to perform option 4, which preserves all the compiler's invariants.\n        //\n        // TODO(alxhub): discuss with the TypeScript team and determine if there's a better way to\n        // deal with this issue.\n        stmt = ts.getMutableClone(stmt);\n      }\n      return stmt;\n    });\n\n    // Save memory - there's no need to keep these around once the transform has run for the given\n    // file.\n    this.sourceFileToUsedImports.delete(originalSf);\n\n    return ts.updateSourceFileNode(sf, statements);\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}