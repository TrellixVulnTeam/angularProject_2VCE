{"ast":null,"code":"\"use strict\"; // external tooling\n\nvar valueParser = require(\"postcss-value-parser\"); // extended tooling\n\n\nvar stringify = valueParser.stringify;\n\nfunction split(params, start) {\n  var list = [];\n  var last = params.reduce(function (item, node, index) {\n    if (index < start) return \"\";\n\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item);\n      return \"\";\n    }\n\n    return item + stringify(node);\n  }, \"\");\n  list.push(last);\n  return list;\n}\n\nmodule.exports = function (result, styles) {\n  var statements = [];\n  var nodes = [];\n  styles.each(function (node) {\n    var stmt;\n\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node);else if (node.name === \"media\") stmt = parseMedia(result, node);\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes: nodes,\n          media: []\n        });\n        nodes = [];\n      }\n\n      statements.push(stmt);\n    } else nodes.push(node);\n  });\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes: nodes,\n      media: []\n    });\n  }\n\n  return statements;\n};\n\nfunction parseMedia(result, atRule) {\n  var params = valueParser(atRule.params).nodes;\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0)\n  };\n}\n\nfunction parseImport(result, atRule) {\n  var prev = getPrev(atRule);\n\n  if (prev) {\n    do {\n      if (prev.type !== \"atrule\" || prev.name !== \"import\" && prev.name !== \"charset\") {\n        return result.warn(\"@import must precede all other statements (besides @charset)\", {\n          node: atRule\n        });\n      } else prev = getPrev(prev);\n    } while (prev);\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\"It looks like you didn't end your @import statement correctly. \" + \"Child nodes are attached to it.\", {\n      node: atRule\n    });\n  }\n\n  var params = valueParser(atRule.params).nodes;\n  var stmt = {\n    type: \"import\",\n    node: atRule,\n    media: []\n  }; // prettier-ignore\n\n  if (!params.length || (params[0].type !== \"string\" || !params[0].value) && (params[0].type !== \"function\" || params[0].value !== \"url\" || !params[0].nodes.length || !params[0].nodes[0].value)) {\n    return result.warn(\"Unable to find uri in '\".concat(atRule.toString(), \"'\"), {\n      node: atRule\n    });\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value;else stmt.uri = params[0].nodes[0].value;\n  stmt.fullUri = stringify(params[0]);\n\n  if (params.length > 2) {\n    if (params[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", {\n        node: atRule\n      });\n    }\n\n    stmt.media = split(params, 2);\n  }\n\n  return stmt;\n}\n\nfunction getPrev(item) {\n  var prev = item.prev();\n\n  while (prev && prev.type === \"comment\") {\n    prev = prev.prev();\n  }\n\n  return prev;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/postcss-import/lib/parse-statements.js"],"names":["valueParser","require","stringify","split","params","start","list","last","reduce","item","node","index","type","value","push","module","exports","result","styles","statements","nodes","each","stmt","name","parseImport","parseMedia","length","media","atRule","prev","getPrev","warn","toString","uri","fullUri"],"mappings":"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","sourcesContent":["\"use strict\"\n\n// external tooling\nconst valueParser = require(\"postcss-value-parser\")\n\n// extended tooling\nconst stringify = valueParser.stringify\n\nfunction split(params, start) {\n  const list = []\n  const last = params.reduce((item, node, index) => {\n    if (index < start) return \"\"\n    if (node.type === \"div\" && node.value === \",\") {\n      list.push(item)\n      return \"\"\n    }\n    return item + stringify(node)\n  }, \"\")\n  list.push(last)\n  return list\n}\n\nmodule.exports = function(result, styles) {\n  const statements = []\n  let nodes = []\n\n  styles.each(node => {\n    let stmt\n    if (node.type === \"atrule\") {\n      if (node.name === \"import\") stmt = parseImport(result, node)\n      else if (node.name === \"media\") stmt = parseMedia(result, node)\n    }\n\n    if (stmt) {\n      if (nodes.length) {\n        statements.push({\n          type: \"nodes\",\n          nodes: nodes,\n          media: [],\n        })\n        nodes = []\n      }\n      statements.push(stmt)\n    } else nodes.push(node)\n  })\n\n  if (nodes.length) {\n    statements.push({\n      type: \"nodes\",\n      nodes: nodes,\n      media: [],\n    })\n  }\n\n  return statements\n}\n\nfunction parseMedia(result, atRule) {\n  const params = valueParser(atRule.params).nodes\n  return {\n    type: \"media\",\n    node: atRule,\n    media: split(params, 0),\n  }\n}\n\nfunction parseImport(result, atRule) {\n  let prev = getPrev(atRule)\n  if (prev) {\n    do {\n      if (\n        prev.type !== \"atrule\" ||\n        (prev.name !== \"import\" && prev.name !== \"charset\")\n      ) {\n        return result.warn(\n          \"@import must precede all other statements (besides @charset)\",\n          { node: atRule }\n        )\n      } else prev = getPrev(prev)\n    } while (prev)\n  }\n\n  if (atRule.nodes) {\n    return result.warn(\n      \"It looks like you didn't end your @import statement correctly. \" +\n        \"Child nodes are attached to it.\",\n      { node: atRule }\n    )\n  }\n\n  const params = valueParser(atRule.params).nodes\n  const stmt = {\n    type: \"import\",\n    node: atRule,\n    media: [],\n  }\n\n  // prettier-ignore\n  if (\n    !params.length ||\n    (\n      params[0].type !== \"string\" ||\n      !params[0].value\n    ) &&\n    (\n      params[0].type !== \"function\" ||\n      params[0].value !== \"url\" ||\n      !params[0].nodes.length ||\n      !params[0].nodes[0].value\n    )\n  ) {\n    return result.warn(`Unable to find uri in '${  atRule.toString()  }'`, {\n      node: atRule,\n    })\n  }\n\n  if (params[0].type === \"string\") stmt.uri = params[0].value\n  else stmt.uri = params[0].nodes[0].value\n  stmt.fullUri = stringify(params[0])\n\n  if (params.length > 2) {\n    if (params[1].type !== \"space\") {\n      return result.warn(\"Invalid import media statement\", { node: atRule })\n    }\n    stmt.media = split(params, 2)\n  }\n\n  return stmt\n}\n\nfunction getPrev(item) {\n  let prev = item.prev()\n  while (prev && prev.type === \"comment\") {\n    prev = prev.prev()\n  }\n  return prev\n}\n"]},"metadata":{},"sourceType":"script"}