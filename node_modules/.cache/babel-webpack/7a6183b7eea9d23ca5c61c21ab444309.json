{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/render3/r3_factory\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/aot/static_symbol\", \"@angular/compiler/src/compile_metadata\", \"@angular/compiler/src/identifiers\", \"@angular/compiler/src/output/output_ast\", \"@angular/compiler/src/render3/r3_identifiers\", \"@angular/compiler/src/render3/util\", \"@angular/compiler/src/render3/view/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.dependenciesFromGlobalMetadata = exports.compileFactoryFunction = exports.R3ResolvedDependencyType = exports.R3FactoryTarget = exports.R3FactoryDelegateType = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var static_symbol_1 = require(\"@angular/compiler/src/aot/static_symbol\");\n\n  var compile_metadata_1 = require(\"@angular/compiler/src/compile_metadata\");\n\n  var identifiers_1 = require(\"@angular/compiler/src/identifiers\");\n\n  var o = require(\"@angular/compiler/src/output/output_ast\");\n\n  var r3_identifiers_1 = require(\"@angular/compiler/src/render3/r3_identifiers\");\n\n  var util_1 = require(\"@angular/compiler/src/render3/util\");\n\n  var util_2 = require(\"@angular/compiler/src/render3/view/util\");\n\n  var R3FactoryDelegateType;\n\n  (function (R3FactoryDelegateType) {\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n  })(R3FactoryDelegateType = exports.R3FactoryDelegateType || (exports.R3FactoryDelegateType = {}));\n\n  var R3FactoryTarget;\n\n  (function (R3FactoryTarget) {\n    R3FactoryTarget[R3FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n    R3FactoryTarget[R3FactoryTarget[\"Component\"] = 1] = \"Component\";\n    R3FactoryTarget[R3FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n    R3FactoryTarget[R3FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n    R3FactoryTarget[R3FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n  })(R3FactoryTarget = exports.R3FactoryTarget || (exports.R3FactoryTarget = {}));\n  /**\n   * Resolved type of a dependency.\n   *\n   * Occasionally, dependencies will have special significance which is known statically. In that\n   * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n   * should be generated specially (usually by calling a special injection function instead of the\n   * standard one).\n   */\n\n\n  var R3ResolvedDependencyType;\n\n  (function (R3ResolvedDependencyType) {\n    /**\n     * A normal token dependency.\n     */\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"Token\"] = 0] = \"Token\";\n    /**\n     * The dependency is for an attribute.\n     *\n     * The token expression is a string representing the attribute name.\n     */\n\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"Attribute\"] = 1] = \"Attribute\";\n    /**\n     * Injecting the `ChangeDetectorRef` token. Needs special handling when injected into a pipe.\n     */\n\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"ChangeDetectorRef\"] = 2] = \"ChangeDetectorRef\";\n    /**\n     * An invalid dependency (no token could be determined). An error should be thrown at runtime.\n     */\n\n    R3ResolvedDependencyType[R3ResolvedDependencyType[\"Invalid\"] = 3] = \"Invalid\";\n  })(R3ResolvedDependencyType = exports.R3ResolvedDependencyType || (exports.R3ResolvedDependencyType = {}));\n  /**\n   * Construct a factory function expression for the given `R3FactoryMetadata`.\n   */\n\n\n  function compileFactoryFunction(meta) {\n    var t = o.variable('t');\n    var statements = [];\n    var ctorDepsType = o.NONE_TYPE; // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n    // this type is always created by constructor invocation, then this is the type-to-create\n    // parameter provided by the user (t) if specified, or the current type if not. If there is a\n    // delegated factory (which is used to create the current type) then this is only the type-to-\n    // create parameter (t).\n\n    var typeForCtor = !isDelegatedMetadata(meta) ? new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.internalType) : t;\n    var ctorExpr = null;\n\n    if (meta.deps !== null) {\n      // There is a constructor (either explicitly or implicitly defined).\n      if (meta.deps !== 'invalid') {\n        ctorExpr = new o.InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.injectFn, meta.target === R3FactoryTarget.Pipe));\n        ctorDepsType = createCtorDepsType(meta.deps);\n      }\n    } else {\n      var baseFactory = o.variable(\"\\u0275\" + meta.name + \"_BaseFactory\");\n      var getInheritedFactory = o.importExpr(r3_identifiers_1.Identifiers.getInheritedFactory);\n      var baseFactoryStmt = baseFactory.set(getInheritedFactory.callFn([meta.internalType],\n      /* sourceSpan */\n      undefined,\n      /* pure */\n      true)).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Exported, o.StmtModifier.Final]);\n      statements.push(baseFactoryStmt); // There is no constructor, use the base class' factory to construct typeForCtor.\n\n      ctorExpr = baseFactory.callFn([typeForCtor]);\n    }\n\n    var ctorExprFinal = ctorExpr;\n    var body = [];\n    var retExpr = null;\n\n    function makeConditionalFactory(nonCtorExpr) {\n      var r = o.variable('r');\n      body.push(r.set(o.NULL_EXPR).toDeclStmt());\n      var ctorStmt = null;\n\n      if (ctorExprFinal !== null) {\n        ctorStmt = r.set(ctorExprFinal).toStmt();\n      } else {\n        ctorStmt = o.importExpr(r3_identifiers_1.Identifiers.invalidFactory).callFn([]).toStmt();\n      }\n\n      body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n      return r;\n    }\n\n    if (isDelegatedMetadata(meta)) {\n      // This type is created with a delegated factory. If a type parameter is not specified, call\n      // the factory instead.\n      var delegateArgs = injectDependencies(meta.delegateDeps, meta.injectFn, meta.target === R3FactoryTarget.Pipe); // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n\n      var factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? o.InstantiateExpr : o.InvokeFunctionExpr)(meta.delegate, delegateArgs);\n      retExpr = makeConditionalFactory(factoryExpr);\n    } else if (isExpressionFactoryMetadata(meta)) {\n      // TODO(alxhub): decide whether to lower the value here or in the caller\n      retExpr = makeConditionalFactory(meta.expression);\n    } else {\n      retExpr = ctorExpr;\n    }\n\n    if (retExpr !== null) {\n      body.push(new o.ReturnStatement(retExpr));\n    } else {\n      body.push(o.importExpr(r3_identifiers_1.Identifiers.invalidFactory).callFn([]).toStmt());\n    }\n\n    return {\n      factory: o.fn([new o.FnParam('t', o.DYNAMIC_TYPE)], body, o.INFERRED_TYPE, undefined, meta.name + \"_Factory\"),\n      statements: statements,\n      type: o.expressionType(o.importExpr(r3_identifiers_1.Identifiers.FactoryDef, [util_1.typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]))\n    };\n  }\n\n  exports.compileFactoryFunction = compileFactoryFunction;\n\n  function injectDependencies(deps, injectFn, isPipe) {\n    return deps.map(function (dep, index) {\n      return compileInjectDependency(dep, injectFn, isPipe, index);\n    });\n  }\n\n  function compileInjectDependency(dep, injectFn, isPipe, index) {\n    // Interpret the dependency according to its resolved type.\n    switch (dep.resolved) {\n      case R3ResolvedDependencyType.Token:\n      case R3ResolvedDependencyType.ChangeDetectorRef:\n        // Build up the injection flags according to the metadata.\n        var flags = 0\n        /* Default */\n        | (dep.self ? 2\n        /* Self */\n        : 0) | (dep.skipSelf ? 4\n        /* SkipSelf */\n        : 0) | (dep.host ? 1\n        /* Host */\n        : 0) | (dep.optional ? 8\n        /* Optional */\n        : 0); // If this dependency is optional or otherwise has non-default flags, then additional\n        // parameters describing how to inject the dependency must be passed to the inject function\n        // that's being used.\n\n        var flagsParam = flags !== 0\n        /* Default */\n        || dep.optional ? o.literal(flags) : null; // We have a separate instruction for injecting ChangeDetectorRef into a pipe.\n\n        if (isPipe && dep.resolved === R3ResolvedDependencyType.ChangeDetectorRef) {\n          return o.importExpr(r3_identifiers_1.Identifiers.injectPipeChangeDetectorRef).callFn(flagsParam ? [flagsParam] : []);\n        } // Build up the arguments to the injectFn call.\n\n\n        var injectArgs = [dep.token];\n\n        if (flagsParam) {\n          injectArgs.push(flagsParam);\n        }\n\n        return o.importExpr(injectFn).callFn(injectArgs);\n\n      case R3ResolvedDependencyType.Attribute:\n        // In the case of attributes, the attribute name in question is given as the token.\n        return o.importExpr(r3_identifiers_1.Identifiers.injectAttribute).callFn([dep.token]);\n\n      case R3ResolvedDependencyType.Invalid:\n        return o.importExpr(r3_identifiers_1.Identifiers.invalidFactoryDep).callFn([o.literal(index)]);\n\n      default:\n        return util_2.unsupported(\"Unknown R3ResolvedDependencyType: \" + R3ResolvedDependencyType[dep.resolved]);\n    }\n  }\n\n  function createCtorDepsType(deps) {\n    var hasTypes = false;\n    var attributeTypes = deps.map(function (dep) {\n      var type = createCtorDepType(dep);\n\n      if (type !== null) {\n        hasTypes = true;\n        return type;\n      } else {\n        return o.literal(null);\n      }\n    });\n\n    if (hasTypes) {\n      return o.expressionType(o.literalArr(attributeTypes));\n    } else {\n      return o.NONE_TYPE;\n    }\n  }\n\n  function createCtorDepType(dep) {\n    var entries = [];\n\n    if (dep.resolved === R3ResolvedDependencyType.Attribute) {\n      if (dep.attribute !== null) {\n        entries.push({\n          key: 'attribute',\n          value: dep.attribute,\n          quoted: false\n        });\n      }\n    }\n\n    if (dep.optional) {\n      entries.push({\n        key: 'optional',\n        value: o.literal(true),\n        quoted: false\n      });\n    }\n\n    if (dep.host) {\n      entries.push({\n        key: 'host',\n        value: o.literal(true),\n        quoted: false\n      });\n    }\n\n    if (dep.self) {\n      entries.push({\n        key: 'self',\n        value: o.literal(true),\n        quoted: false\n      });\n    }\n\n    if (dep.skipSelf) {\n      entries.push({\n        key: 'skipSelf',\n        value: o.literal(true),\n        quoted: false\n      });\n    }\n\n    return entries.length > 0 ? o.literalMap(entries) : null;\n  }\n  /**\n   * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n   * `CompileTypeMetadata` instance.\n   */\n\n\n  function dependenciesFromGlobalMetadata(type, outputCtx, reflector) {\n    var e_1, _a; // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n    // be compared with the token to statically determine whether the token has significance to\n    // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n\n\n    var injectorRef = reflector.resolveExternalReference(identifiers_1.Identifiers.Injector); // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n\n    var deps = [];\n\n    try {\n      for (var _b = tslib_1.__values(type.diDeps), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var dependency = _c.value;\n\n        if (dependency.token) {\n          var tokenRef = compile_metadata_1.tokenReference(dependency.token);\n          var resolved = dependency.isAttribute ? R3ResolvedDependencyType.Attribute : R3ResolvedDependencyType.Token; // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n          // however, it can be a string, in the case of older Angular code or @Attribute injection.\n\n          var token = tokenRef instanceof static_symbol_1.StaticSymbol ? outputCtx.importExpr(tokenRef) : o.literal(tokenRef); // Construct the dependency.\n\n          deps.push({\n            token: token,\n            attribute: null,\n            resolved: resolved,\n            host: !!dependency.isHost,\n            optional: !!dependency.isOptional,\n            self: !!dependency.isSelf,\n            skipSelf: !!dependency.isSkipSelf\n          });\n        } else {\n          util_2.unsupported('dependency without a token');\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return deps;\n  }\n\n  exports.dependenciesFromGlobalMetadata = dependenciesFromGlobalMetadata;\n\n  function isDelegatedMetadata(meta) {\n    return meta.delegateType !== undefined;\n  }\n\n  function isExpressionFactoryMetadata(meta) {\n    return meta.expression !== undefined;\n  }\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/render3/r3_factory.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileTypeMetadata, tokenReference} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {InjectFlags} from '../core';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\nimport {OutputContext} from '../util';\n\nimport {R3Reference, typeWithParameters} from './util';\nimport {unsupported} from './view/util';\n\n\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the interface type being constructed.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the constructor type, intended for use within a class definition\n   * itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /** Number of arguments for the `type`. */\n  typeArgumentCount: number;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type. If this is `'invalid'`,\n   * then one or more of the parameters wasn't resolvable and any attempt to use these deps will\n   * result in a runtime error.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * An expression for the function which will be used to inject dependencies. The API of this\n   * function could be different, and other options control how it will be invoked.\n   */\n  injectFn: o.ExternalReference;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: R3FactoryTarget;\n}\n\nexport enum R3FactoryDelegateType {\n  Class,\n  Function,\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType.Class|R3FactoryDelegateType.Function;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata =\n    R3ConstructorFactoryMetadata|R3DelegatedFnOrClassMetadata|R3ExpressionFactoryMetadata;\n\nexport enum R3FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\nexport enum R3ResolvedDependencyType {\n  /**\n   * A normal token dependency.\n   */\n  Token = 0,\n\n  /**\n   * The dependency is for an attribute.\n   *\n   * The token expression is a string representing the attribute name.\n   */\n  Attribute = 1,\n\n  /**\n   * Injecting the `ChangeDetectorRef` token. Needs special handling when injected into a pipe.\n   */\n  ChangeDetectorRef = 2,\n\n  /**\n   * An invalid dependency (no token could be determined). An error should be thrown at runtime.\n   */\n  Invalid = 3,\n}\n\n/**\n * Metadata representing a single dependency to be injected into a constructor or function call.\n */\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   */\n  token: o.Expression;\n\n  /**\n   * If an @Attribute decorator is present, this is the literal type of the attribute name, or\n   * the unknown type if no literal type is available (e.g. the attribute name is an expression).\n   * Will be null otherwise.\n   */\n  attribute: o.Expression|null;\n\n  /**\n   * An enum indicating whether this dependency has special meaning to Angular and needs to be\n   * injected specially.\n   */\n  resolved: R3ResolvedDependencyType;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\nexport interface R3FactoryFn {\n  factory: o.Expression;\n  statements: o.Statement[];\n  type: o.ExpressionType;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): R3FactoryFn {\n  const t = o.variable('t');\n  const statements: o.Statement[] = [];\n  let ctorDepsType: o.Type = o.NONE_TYPE;\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor = !isDelegatedMetadata(meta) ?\n      new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.internalType) :\n      t;\n\n  let ctorExpr: o.Expression|null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new o.InstantiateExpr(\n          typeForCtor,\n          injectDependencies(meta.deps, meta.injectFn, meta.target === R3FactoryTarget.Pipe));\n\n      ctorDepsType = createCtorDepsType(meta.deps);\n    }\n  } else {\n    const baseFactory = o.variable(`ɵ${meta.name}_BaseFactory`);\n    const getInheritedFactory = o.importExpr(R3.getInheritedFactory);\n    const baseFactoryStmt =\n        baseFactory\n            .set(getInheritedFactory.callFn(\n                [meta.internalType], /* sourceSpan */ undefined, /* pure */ true))\n            .toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Exported, o.StmtModifier.Final]);\n    statements.push(baseFactoryStmt);\n\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    ctorExpr = baseFactory.callFn([typeForCtor]);\n  }\n  const ctorExprFinal = ctorExpr;\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression|null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('r');\n    body.push(r.set(o.NULL_EXPR).toDeclStmt());\n    let ctorStmt: o.Statement|null = null;\n    if (ctorExprFinal !== null) {\n      ctorStmt = r.set(ctorExprFinal).toStmt();\n    } else {\n      ctorStmt = o.importExpr(R3.invalidFactory).callFn([]).toStmt();\n    }\n    body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs =\n        injectDependencies(meta.delegateDeps, meta.injectFn, meta.target === R3FactoryTarget.Pipe);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n    const factoryExpr = new (\n        meta.delegateType === R3FactoryDelegateType.Class ?\n            o.InstantiateExpr :\n            o.InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n  if (retExpr !== null) {\n    body.push(new o.ReturnStatement(retExpr));\n  } else {\n    body.push(o.importExpr(R3.invalidFactory).callFn([]).toStmt());\n  }\n\n  return {\n    factory: o.fn(\n        [new o.FnParam('t', o.DYNAMIC_TYPE)], body, o.INFERRED_TYPE, undefined,\n        `${meta.name}_Factory`),\n    statements,\n    type: o.expressionType(o.importExpr(\n        R3.FactoryDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]))\n  };\n}\n\nfunction injectDependencies(\n    deps: R3DependencyMetadata[], injectFn: o.ExternalReference, isPipe: boolean): o.Expression[] {\n  return deps.map((dep, index) => compileInjectDependency(dep, injectFn, isPipe, index));\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, injectFn: o.ExternalReference, isPipe: boolean,\n    index: number): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  switch (dep.resolved) {\n    case R3ResolvedDependencyType.Token:\n    case R3ResolvedDependencyType.ChangeDetectorRef:\n      // Build up the injection flags according to the metadata.\n      const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n          (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n          (dep.optional ? InjectFlags.Optional : 0);\n\n      // If this dependency is optional or otherwise has non-default flags, then additional\n      // parameters describing how to inject the dependency must be passed to the inject function\n      // that's being used.\n      let flagsParam: o.LiteralExpr|null =\n          (flags !== InjectFlags.Default || dep.optional) ? o.literal(flags) : null;\n\n      // We have a separate instruction for injecting ChangeDetectorRef into a pipe.\n      if (isPipe && dep.resolved === R3ResolvedDependencyType.ChangeDetectorRef) {\n        return o.importExpr(R3.injectPipeChangeDetectorRef).callFn(flagsParam ? [flagsParam] : []);\n      }\n\n      // Build up the arguments to the injectFn call.\n      const injectArgs = [dep.token];\n      if (flagsParam) {\n        injectArgs.push(flagsParam);\n      }\n      return o.importExpr(injectFn).callFn(injectArgs);\n    case R3ResolvedDependencyType.Attribute:\n      // In the case of attributes, the attribute name in question is given as the token.\n      return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n    case R3ResolvedDependencyType.Invalid:\n      return o.importExpr(R3.invalidFactoryDep).callFn([o.literal(index)]);\n    default:\n      return unsupported(\n          `Unknown R3ResolvedDependencyType: ${R3ResolvedDependencyType[dep.resolved]}`);\n  }\n}\n\nfunction createCtorDepsType(deps: R3DependencyMetadata[]): o.Type {\n  let hasTypes = false;\n  const attributeTypes = deps.map(dep => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return o.literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return o.expressionType(o.literalArr(attributeTypes));\n  } else {\n    return o.NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep: R3DependencyMetadata): o.LiteralMapExpr|null {\n  const entries: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  if (dep.resolved === R3ResolvedDependencyType.Attribute) {\n    if (dep.attribute !== null) {\n      entries.push({key: 'attribute', value: dep.attribute, quoted: false});\n    }\n  }\n  if (dep.optional) {\n    entries.push({key: 'optional', value: o.literal(true), quoted: false});\n  }\n  if (dep.host) {\n    entries.push({key: 'host', value: o.literal(true), quoted: false});\n  }\n  if (dep.self) {\n    entries.push({key: 'self', value: o.literal(true), quoted: false});\n  }\n  if (dep.skipSelf) {\n    entries.push({key: 'skipSelf', value: o.literal(true), quoted: false});\n  }\n\n  return entries.length > 0 ? o.literalMap(entries) : null;\n}\n\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\nexport function dependenciesFromGlobalMetadata(\n    type: CompileTypeMetadata, outputCtx: OutputContext,\n    reflector: CompileReflector): R3DependencyMetadata[] {\n  // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n  // be compared with the token to statically determine whether the token has significance to\n  // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n  const injectorRef = reflector.resolveExternalReference(Identifiers.Injector);\n\n  // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n  const deps: R3DependencyMetadata[] = [];\n  for (let dependency of type.diDeps) {\n    if (dependency.token) {\n      const tokenRef = tokenReference(dependency.token);\n      let resolved: R3ResolvedDependencyType = dependency.isAttribute ?\n          R3ResolvedDependencyType.Attribute :\n          R3ResolvedDependencyType.Token;\n\n      // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n      // however, it can be a string, in the case of older Angular code or @Attribute injection.\n      const token =\n          tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : o.literal(tokenRef);\n\n      // Construct the dependency.\n      deps.push({\n        token,\n        attribute: null,\n        resolved,\n        host: !!dependency.isHost,\n        optional: !!dependency.isOptional,\n        self: !!dependency.isSelf,\n        skipSelf: !!dependency.isSkipSelf,\n      });\n    } else {\n      unsupported('dependency without a token');\n    }\n  }\n\n  return deps;\n}\n\nfunction isDelegatedMetadata(meta: R3FactoryMetadata): meta is R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nfunction isExpressionFactoryMetadata(meta: R3FactoryMetadata): meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}