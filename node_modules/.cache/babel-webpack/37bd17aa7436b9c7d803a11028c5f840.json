{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeScriptFileRefactor = exports.resolve = exports.findAstNodes = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar path = require(\"path\");\n\nvar ts = require(\"typescript\");\n\nvar utils_1 = require(\"./utils\");\n\nfunction _findAstNodes(node, sourceFile, kindOrGuard) {\n  var recursive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var max = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;\n\n  // TODO: refactor operations that only need `refactor.findAstNodes()` to use this instead.\n  if (max == 0) {\n    return [];\n  }\n\n  if (!node) {\n    node = sourceFile;\n  }\n\n  var test = typeof kindOrGuard === 'function' ? kindOrGuard : function (node) {\n    return node.kind === kindOrGuard;\n  };\n  var arr = [];\n\n  if (test(node)) {\n    // If we're not recursively looking for children, stop here.\n    if (!recursive) {\n      return [node];\n    }\n\n    arr.push(node);\n    max--;\n  }\n\n  if (max > 0) {\n    var _iterator = _createForOfIteratorHelper(node.getChildren(sourceFile)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var child = _step.value;\n\n        _findAstNodes(child, sourceFile, test, recursive, max).forEach(function (node) {\n          if (max > 0) {\n            arr.push(node);\n          }\n\n          max--;\n        });\n\n        if (max <= 0) {\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return arr;\n}\n\nexports.findAstNodes = _findAstNodes;\n\nfunction resolve(filePath, _host, compilerOptions) {\n  if (path.isAbsolute(filePath)) {\n    return filePath;\n  }\n\n  var basePath = compilerOptions.baseUrl || compilerOptions.rootDir;\n\n  if (!basePath) {\n    throw new Error(\"Trying to resolve '\".concat(filePath, \"' without a basePath.\"));\n  }\n\n  return path.join(basePath, filePath);\n}\n\nexports.resolve = resolve;\n\nvar TypeScriptFileRefactor = /*#__PURE__*/function () {\n  function TypeScriptFileRefactor(fileName, _host, _program, source) {\n    _classCallCheck(this, TypeScriptFileRefactor);\n\n    var sourceFile = null;\n\n    if (_program) {\n      fileName = utils_1.forwardSlashPath(resolve(fileName, _host, _program.getCompilerOptions()));\n\n      if (source) {\n        sourceFile = ts.createSourceFile(fileName, source, ts.ScriptTarget.Latest, true);\n      } else {\n        sourceFile = _program.getSourceFile(fileName) || null;\n      }\n    }\n\n    if (!sourceFile) {\n      var maybeContent = source || _host.readFile(fileName);\n\n      if (maybeContent) {\n        sourceFile = ts.createSourceFile(fileName, maybeContent, ts.ScriptTarget.Latest, true);\n      }\n    }\n\n    if (!sourceFile) {\n      throw new Error('Must have a source file to refactor.');\n    }\n\n    this._fileName = fileName;\n    this._sourceFile = sourceFile;\n  }\n\n  _createClass(TypeScriptFileRefactor, [{\n    key: \"fileName\",\n    get: function get() {\n      return this._fileName;\n    }\n  }, {\n    key: \"sourceFile\",\n    get: function get() {\n      return this._sourceFile;\n    }\n    /**\n     * Find all nodes from the AST in the subtree of node of SyntaxKind kind.\n     * @param node The root node to check, or null if the whole tree should be searched.\n     * @param kind The kind of nodes to find.\n     * @param recursive Whether to go in matched nodes to keep matching.\n     * @param max The maximum number of items to return.\n     * @return all nodes of kind, or [] if none is found\n     */\n\n  }, {\n    key: \"findAstNodes\",\n    value: function findAstNodes(node, kind) {\n      var recursive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var max = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      return _findAstNodes(node, this._sourceFile, kind, recursive, max);\n    }\n  }]);\n\n  return TypeScriptFileRefactor;\n}();\n\nexports.TypeScriptFileRefactor = TypeScriptFileRefactor;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@ngtools/webpack/src/refactor.js"],"names":["Object","defineProperty","exports","value","TypeScriptFileRefactor","resolve","findAstNodes","path","require","ts","utils_1","node","sourceFile","kindOrGuard","recursive","max","Infinity","test","kind","arr","push","getChildren","child","forEach","filePath","_host","compilerOptions","isAbsolute","basePath","baseUrl","rootDir","Error","join","fileName","_program","source","forwardSlashPath","getCompilerOptions","createSourceFile","ScriptTarget","Latest","getSourceFile","maybeContent","readFile","_fileName","_sourceFile"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeScriptFileRefactor = exports.resolve = exports.findAstNodes = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst path = require(\"path\");\nconst ts = require(\"typescript\");\nconst utils_1 = require(\"./utils\");\nfunction findAstNodes(node, sourceFile, kindOrGuard, recursive = false, max = Infinity) {\n    // TODO: refactor operations that only need `refactor.findAstNodes()` to use this instead.\n    if (max == 0) {\n        return [];\n    }\n    if (!node) {\n        node = sourceFile;\n    }\n    const test = typeof kindOrGuard === 'function'\n        ? kindOrGuard\n        : (node) => node.kind === kindOrGuard;\n    const arr = [];\n    if (test(node)) {\n        // If we're not recursively looking for children, stop here.\n        if (!recursive) {\n            return [node];\n        }\n        arr.push(node);\n        max--;\n    }\n    if (max > 0) {\n        for (const child of node.getChildren(sourceFile)) {\n            findAstNodes(child, sourceFile, test, recursive, max)\n                .forEach((node) => {\n                if (max > 0) {\n                    arr.push(node);\n                }\n                max--;\n            });\n            if (max <= 0) {\n                break;\n            }\n        }\n    }\n    return arr;\n}\nexports.findAstNodes = findAstNodes;\nfunction resolve(filePath, _host, compilerOptions) {\n    if (path.isAbsolute(filePath)) {\n        return filePath;\n    }\n    const basePath = compilerOptions.baseUrl || compilerOptions.rootDir;\n    if (!basePath) {\n        throw new Error(`Trying to resolve '${filePath}' without a basePath.`);\n    }\n    return path.join(basePath, filePath);\n}\nexports.resolve = resolve;\nclass TypeScriptFileRefactor {\n    constructor(fileName, _host, _program, source) {\n        let sourceFile = null;\n        if (_program) {\n            fileName = utils_1.forwardSlashPath(resolve(fileName, _host, _program.getCompilerOptions()));\n            if (source) {\n                sourceFile = ts.createSourceFile(fileName, source, ts.ScriptTarget.Latest, true);\n            }\n            else {\n                sourceFile = _program.getSourceFile(fileName) || null;\n            }\n        }\n        if (!sourceFile) {\n            const maybeContent = source || _host.readFile(fileName);\n            if (maybeContent) {\n                sourceFile = ts.createSourceFile(fileName, maybeContent, ts.ScriptTarget.Latest, true);\n            }\n        }\n        if (!sourceFile) {\n            throw new Error('Must have a source file to refactor.');\n        }\n        this._fileName = fileName;\n        this._sourceFile = sourceFile;\n    }\n    get fileName() { return this._fileName; }\n    get sourceFile() { return this._sourceFile; }\n    /**\n     * Find all nodes from the AST in the subtree of node of SyntaxKind kind.\n     * @param node The root node to check, or null if the whole tree should be searched.\n     * @param kind The kind of nodes to find.\n     * @param recursive Whether to go in matched nodes to keep matching.\n     * @param max The maximum number of items to return.\n     * @return all nodes of kind, or [] if none is found\n     */\n    findAstNodes(node, kind, recursive = false, max = Infinity) {\n        return findAstNodes(node, this._sourceFile, kind, recursive, max);\n    }\n}\nexports.TypeScriptFileRefactor = TypeScriptFileRefactor;\n"]},"metadata":{},"sourceType":"script"}