{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/metadata/bundle_index_host\", [\"require\", \"exports\", \"tslib\", \"path\", \"typescript\", \"@angular/compiler-cli/src/metadata/bundler\", \"@angular/compiler-cli/src/metadata/index_writer\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.createBundleIndexHost = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var path = require(\"path\");\n\n  var ts = require(\"typescript\");\n\n  var bundler_1 = require(\"@angular/compiler-cli/src/metadata/bundler\");\n\n  var index_writer_1 = require(\"@angular/compiler-cli/src/metadata/index_writer\");\n\n  var DTS = /\\.d\\.ts$/;\n  var JS_EXT = /(\\.js|)$/;\n\n  function createSyntheticIndexHost(delegate, syntheticIndex) {\n    var normalSyntheticIndexName = path.normalize(syntheticIndex.name);\n    var newHost = Object.create(delegate);\n\n    newHost.fileExists = function (fileName) {\n      return path.normalize(fileName) == normalSyntheticIndexName || delegate.fileExists(fileName);\n    };\n\n    newHost.readFile = function (fileName) {\n      return path.normalize(fileName) == normalSyntheticIndexName ? syntheticIndex.content : delegate.readFile(fileName);\n    };\n\n    newHost.getSourceFile = function (fileName, languageVersion, onError) {\n      if (path.normalize(fileName) == normalSyntheticIndexName) {\n        var sf = ts.createSourceFile(fileName, syntheticIndex.content, languageVersion, true);\n\n        if (delegate.fileNameToModuleName) {\n          sf.moduleName = delegate.fileNameToModuleName(fileName);\n        }\n\n        return sf;\n      }\n\n      return delegate.getSourceFile(fileName, languageVersion, onError);\n    };\n\n    newHost.writeFile = function (fileName, data, writeByteOrderMark, onError, sourceFiles) {\n      delegate.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n\n      if (fileName.match(DTS) && sourceFiles && sourceFiles.length == 1 && path.normalize(sourceFiles[0].fileName) === normalSyntheticIndexName) {\n        // If we are writing the synthetic index, write the metadata along side.\n        var metadataName = fileName.replace(DTS, '.metadata.json');\n        var indexMetadata = syntheticIndex.getMetadata();\n        delegate.writeFile(metadataName, indexMetadata, writeByteOrderMark, onError, []);\n      }\n    };\n\n    return newHost;\n  }\n\n  function createBundleIndexHost(ngOptions, rootFiles, host, getMetadataCache) {\n    var e_1, _a;\n\n    var files = rootFiles.filter(function (f) {\n      return !DTS.test(f);\n    });\n    var indexFile;\n\n    if (files.length === 1) {\n      indexFile = files[0];\n    } else {\n      try {\n        for (var files_1 = tslib_1.__values(files), files_1_1 = files_1.next(); !files_1_1.done; files_1_1 = files_1.next()) {\n          var f = files_1_1.value; // Assume the shortest file path called index.ts is the entry point. Note that we\n          // need to use the posix path delimiter here because TypeScript internally only\n          // passes posix paths.\n\n          if (f.endsWith('/index.ts')) {\n            if (!indexFile || indexFile.length > f.length) {\n              indexFile = f;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (files_1_1 && !files_1_1.done && (_a = files_1.return)) _a.call(files_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n\n    if (!indexFile) {\n      return {\n        host: host,\n        errors: [{\n          file: null,\n          start: null,\n          length: null,\n          messageText: 'Angular compiler option \"flatModuleIndex\" requires one and only one .ts file in the \"files\" field.',\n          category: ts.DiagnosticCategory.Error,\n          code: 0\n        }]\n      };\n    }\n\n    var indexModule = indexFile.replace(/\\.ts$/, ''); // The operation of producing a metadata bundle happens twice - once during setup and once during\n    // the emit phase. The first time, the bundle is produced without a metadata cache, to compute the\n    // contents of the flat module index. The bundle produced during emit does use the metadata cache\n    // with associated transforms, so the metadata will have lowered expressions, resource inlining,\n    // etc.\n\n    var getMetadataBundle = function getMetadataBundle(cache) {\n      var bundler = new bundler_1.MetadataBundler(indexModule, ngOptions.flatModuleId, new bundler_1.CompilerHostAdapter(host, cache, ngOptions), ngOptions.flatModulePrivateSymbolPrefix);\n      return bundler.getMetadataBundle();\n    }; // First, produce the bundle with no MetadataCache.\n\n\n    var metadataBundle = getMetadataBundle(\n    /* MetadataCache */\n    null);\n    var name = path.join(path.dirname(indexModule), ngOptions.flatModuleOutFile.replace(JS_EXT, '.ts'));\n    var libraryIndex = \"./\" + path.basename(indexModule);\n    var content = index_writer_1.privateEntriesToIndex(libraryIndex, metadataBundle.privates);\n    host = createSyntheticIndexHost(host, {\n      name: name,\n      content: content,\n      getMetadata: function getMetadata() {\n        // The second metadata bundle production happens on-demand, and uses the getMetadataCache\n        // closure to retrieve an up-to-date MetadataCache which is configured with whatever metadata\n        // transforms were used to produce the JS output.\n        var metadataBundle = getMetadataBundle(getMetadataCache());\n        return JSON.stringify(metadataBundle.metadata);\n      }\n    });\n    return {\n      host: host,\n      indexName: name\n    };\n  }\n\n  exports.createBundleIndexHost = createBundleIndexHost;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/src/metadata/bundle_index_host.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;;;AAGH,MAAA,IAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,MAAA,EAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AAKA,MAAA,SAAA,GAAA,OAAA,CAAA,4CAAA,CAAA;;AACA,MAAA,cAAA,GAAA,OAAA,CAAA,iDAAA,CAAA;;AAEA,MAAM,GAAG,GAAG,UAAZ;AACA,MAAM,MAAM,GAAG,UAAf;;AAEA,WAAS,wBAAT,CACI,QADJ,EACiB,cADjB,EAC2F;AACzF,QAAM,wBAAwB,GAAG,IAAI,CAAC,SAAL,CAAe,cAAc,CAAC,IAA9B,CAAjC;AAEA,QAAM,OAAO,GAAG,MAAM,CAAC,MAAP,CAAc,QAAd,CAAhB;;AACA,IAAA,OAAO,CAAC,UAAR,GAAqB,UAAC,QAAD,EAAiB;AACpC,aAAO,IAAI,CAAC,SAAL,CAAe,QAAf,KAA4B,wBAA5B,IAAwD,QAAQ,CAAC,UAAT,CAAoB,QAApB,CAA/D;AACD,KAFD;;AAIA,IAAA,OAAO,CAAC,QAAR,GAAmB,UAAC,QAAD,EAAiB;AAClC,aAAO,IAAI,CAAC,SAAL,CAAe,QAAf,KAA4B,wBAA5B,GAAuD,cAAc,CAAC,OAAtE,GACuD,QAAQ,CAAC,QAAT,CAAkB,QAAlB,CAD9D;AAED,KAHD;;AAKA,IAAA,OAAO,CAAC,aAAR,GACI,UAAC,QAAD,EAAmB,eAAnB,EAAqD,OAArD,EAAwF;AACtF,UAAI,IAAI,CAAC,SAAL,CAAe,QAAf,KAA4B,wBAAhC,EAA0D;AACxD,YAAM,EAAE,GAAG,EAAE,CAAC,gBAAH,CAAoB,QAApB,EAA8B,cAAc,CAAC,OAA7C,EAAsD,eAAtD,EAAuE,IAAvE,CAAX;;AACA,YAAK,QAAgB,CAAC,oBAAtB,EAA4C;AAC1C,UAAA,EAAE,CAAC,UAAH,GAAiB,QAAgB,CAAC,oBAAjB,CAAsC,QAAtC,CAAjB;AACD;;AACD,eAAO,EAAP;AACD;;AACD,aAAO,QAAQ,CAAC,aAAT,CAAuB,QAAvB,EAAiC,eAAjC,EAAkD,OAAlD,CAAP;AACD,KAVL;;AAYA,IAAA,OAAO,CAAC,SAAR,GACI,UAAC,QAAD,EAAmB,IAAnB,EAAiC,kBAAjC,EACC,OADD,EACiD,WADjD,EACuF;AACrF,MAAA,QAAQ,CAAC,SAAT,CAAmB,QAAnB,EAA6B,IAA7B,EAAmC,kBAAnC,EAAuD,OAAvD,EAAgE,WAAhE;;AACA,UAAI,QAAQ,CAAC,KAAT,CAAe,GAAf,KAAuB,WAAvB,IAAsC,WAAW,CAAC,MAAZ,IAAsB,CAA5D,IACA,IAAI,CAAC,SAAL,CAAe,WAAW,CAAC,CAAD,CAAX,CAAe,QAA9B,MAA4C,wBADhD,EAC0E;AACxE;AACA,YAAM,YAAY,GAAG,QAAQ,CAAC,OAAT,CAAiB,GAAjB,EAAsB,gBAAtB,CAArB;AACA,YAAM,aAAa,GAAG,cAAc,CAAC,WAAf,EAAtB;AACA,QAAA,QAAQ,CAAC,SAAT,CAAmB,YAAnB,EAAiC,aAAjC,EAAgD,kBAAhD,EAAoE,OAApE,EAA6E,EAA7E;AACD;AACF,KAXL;;AAYA,WAAO,OAAP;AACD;;AAED,WAAgB,qBAAhB,CACI,SADJ,EACgC,SADhC,EACkE,IADlE,EAEI,gBAFJ,EAGqB;;;AACnB,QAAM,KAAK,GAAG,SAAS,CAAC,MAAV,CAAiB,UAAA,CAAA,EAAC;AAAI,aAAA,CAAC,GAAG,CAAC,IAAJ,CAAD,CAAC,CAAD;AAAY,KAAlC,CAAd;AACA,QAAI,SAAJ;;AACA,QAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACtB,MAAA,SAAS,GAAG,KAAK,CAAC,CAAD,CAAjB;AACD,KAFD,MAEO;;AACL,aAAgB,IAAA,OAAA,GAAA,OAAA,CAAA,QAAA,CAAA,KAAA,CAAA,EAAK,SAAA,GAAA,OAAA,CAAA,IAAA,EAArB,EAAqB,CAAA,SAAA,CAAA,IAArB,EAAqB,SAAA,GAAA,OAAA,CAAA,IAAA,EAArB,EAAuB;AAAlB,cAAM,CAAC,GAAA,SAAA,CAAA,KAAP,CAAkB,CACrB;AACA;AACA;;AACA,cAAI,CAAC,CAAC,QAAF,CAAW,WAAX,CAAJ,EAA6B;AAC3B,gBAAI,CAAC,SAAD,IAAc,SAAS,CAAC,MAAV,GAAmB,CAAC,CAAC,MAAvC,EAA+C;AAC7C,cAAA,SAAS,GAAG,CAAZ;AACD;AACF;AACF;;;;;;;;;;;;AACF;;AACD,QAAI,CAAC,SAAL,EAAgB;AACd,aAAO;AACL,QAAA,IAAI,EAAA,IADC;AAEL,QAAA,MAAM,EAAE,CAAC;AACP,UAAA,IAAI,EAAE,IADC;AAEP,UAAA,KAAK,EAAE,IAFA;AAGP,UAAA,MAAM,EAAE,IAHD;AAIP,UAAA,WAAW,EACP,oGALG;AAMP,UAAA,QAAQ,EAAE,EAAE,CAAC,kBAAH,CAAsB,KANzB;AAOP,UAAA,IAAI,EAAE;AAPC,SAAD;AAFH,OAAP;AAYD;;AAED,QAAM,WAAW,GAAG,SAAS,CAAC,OAAV,CAAkB,OAAlB,EAA2B,EAA3B,CAApB,CAhCmB,CAkCnB;AACA;AACA;AACA;AACA;;AACA,QAAM,iBAAiB,GAAG,SAApB,iBAAoB,CAAC,KAAD,EAA0B;AAClD,UAAM,OAAO,GAAG,IAAI,SAAA,CAAA,eAAJ,CACZ,WADY,EACC,SAAS,CAAC,YADX,EACyB,IAAI,SAAA,CAAA,mBAAJ,CAAwB,IAAxB,EAA8B,KAA9B,EAAqC,SAArC,CADzB,EAEZ,SAAS,CAAC,6BAFE,CAAhB;AAGA,aAAO,OAAO,CAAC,iBAAR,EAAP;AACD,KALD,CAvCmB,CA8CnB;;;AACA,QAAM,cAAc,GAAG,iBAAiB;AAAC;AAAoB,QAArB,CAAxC;AACA,QAAM,IAAI,GACN,IAAI,CAAC,IAAL,CAAU,IAAI,CAAC,OAAL,CAAa,WAAb,CAAV,EAAqC,SAAS,CAAC,iBAAV,CAA6B,OAA7B,CAAqC,MAArC,EAA6C,KAA7C,CAArC,CADJ;AAEA,QAAM,YAAY,GAAG,OAAK,IAAI,CAAC,QAAL,CAAc,WAAd,CAA1B;AACA,QAAM,OAAO,GAAG,cAAA,CAAA,qBAAA,CAAsB,YAAtB,EAAoC,cAAc,CAAC,QAAnD,CAAhB;AAEA,IAAA,IAAI,GAAG,wBAAwB,CAAC,IAAD,EAAO;AACpC,MAAA,IAAI,EAAA,IADgC;AAEpC,MAAA,OAAO,EAAA,OAF6B;AAGpC,MAAA,WAAW,EAAE,uBAAA;AACX;AACA;AACA;AACA,YAAM,cAAc,GAAG,iBAAiB,CAAC,gBAAgB,EAAjB,CAAxC;AACA,eAAO,IAAI,CAAC,SAAL,CAAe,cAAc,CAAC,QAA9B,CAAP;AACD;AATmC,KAAP,CAA/B;AAWA,WAAO;AAAC,MAAA,IAAI,EAAA,IAAL;AAAO,MAAA,SAAS,EAAE;AAAlB,KAAP;AACD;;AApED,EAAA,OAAA,CAAA,qBAAA,GAAA,qBAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport * as ts from 'typescript';\n\nimport {CompilerOptions} from '../transformers/api';\nimport {MetadataCache} from '../transformers/metadata_cache';\n\nimport {CompilerHostAdapter, MetadataBundler} from './bundler';\nimport {privateEntriesToIndex} from './index_writer';\n\nconst DTS = /\\.d\\.ts$/;\nconst JS_EXT = /(\\.js|)$/;\n\nfunction createSyntheticIndexHost<H extends ts.CompilerHost>(\n    delegate: H, syntheticIndex: {name: string, content: string, getMetadata: () => string}): H {\n  const normalSyntheticIndexName = path.normalize(syntheticIndex.name);\n\n  const newHost = Object.create(delegate);\n  newHost.fileExists = (fileName: string): boolean => {\n    return path.normalize(fileName) == normalSyntheticIndexName || delegate.fileExists(fileName);\n  };\n\n  newHost.readFile = (fileName: string) => {\n    return path.normalize(fileName) == normalSyntheticIndexName ? syntheticIndex.content :\n                                                                  delegate.readFile(fileName);\n  };\n\n  newHost.getSourceFile =\n      (fileName: string, languageVersion: ts.ScriptTarget, onError?: (message: string) => void) => {\n        if (path.normalize(fileName) == normalSyntheticIndexName) {\n          const sf = ts.createSourceFile(fileName, syntheticIndex.content, languageVersion, true);\n          if ((delegate as any).fileNameToModuleName) {\n            sf.moduleName = (delegate as any).fileNameToModuleName(fileName);\n          }\n          return sf;\n        }\n        return delegate.getSourceFile(fileName, languageVersion, onError);\n      };\n\n  newHost.writeFile =\n      (fileName: string, data: string, writeByteOrderMark: boolean,\n       onError: ((message: string) => void)|undefined, sourceFiles: Readonly<ts.SourceFile>[]) => {\n        delegate.writeFile(fileName, data, writeByteOrderMark, onError, sourceFiles);\n        if (fileName.match(DTS) && sourceFiles && sourceFiles.length == 1 &&\n            path.normalize(sourceFiles[0].fileName) === normalSyntheticIndexName) {\n          // If we are writing the synthetic index, write the metadata along side.\n          const metadataName = fileName.replace(DTS, '.metadata.json');\n          const indexMetadata = syntheticIndex.getMetadata();\n          delegate.writeFile(metadataName, indexMetadata, writeByteOrderMark, onError, []);\n        }\n      };\n  return newHost;\n}\n\nexport function createBundleIndexHost<H extends ts.CompilerHost>(\n    ngOptions: CompilerOptions, rootFiles: ReadonlyArray<string>, host: H,\n    getMetadataCache: () =>\n        MetadataCache): {host: H, indexName?: string, errors?: ts.Diagnostic[]} {\n  const files = rootFiles.filter(f => !DTS.test(f));\n  let indexFile: string|undefined;\n  if (files.length === 1) {\n    indexFile = files[0];\n  } else {\n    for (const f of files) {\n      // Assume the shortest file path called index.ts is the entry point. Note that we\n      // need to use the posix path delimiter here because TypeScript internally only\n      // passes posix paths.\n      if (f.endsWith('/index.ts')) {\n        if (!indexFile || indexFile.length > f.length) {\n          indexFile = f;\n        }\n      }\n    }\n  }\n  if (!indexFile) {\n    return {\n      host,\n      errors: [{\n        file: null as any as ts.SourceFile,\n        start: null as any as number,\n        length: null as any as number,\n        messageText:\n            'Angular compiler option \"flatModuleIndex\" requires one and only one .ts file in the \"files\" field.',\n        category: ts.DiagnosticCategory.Error,\n        code: 0\n      }]\n    };\n  }\n\n  const indexModule = indexFile.replace(/\\.ts$/, '');\n\n  // The operation of producing a metadata bundle happens twice - once during setup and once during\n  // the emit phase. The first time, the bundle is produced without a metadata cache, to compute the\n  // contents of the flat module index. The bundle produced during emit does use the metadata cache\n  // with associated transforms, so the metadata will have lowered expressions, resource inlining,\n  // etc.\n  const getMetadataBundle = (cache: MetadataCache|null) => {\n    const bundler = new MetadataBundler(\n        indexModule, ngOptions.flatModuleId, new CompilerHostAdapter(host, cache, ngOptions),\n        ngOptions.flatModulePrivateSymbolPrefix);\n    return bundler.getMetadataBundle();\n  };\n\n  // First, produce the bundle with no MetadataCache.\n  const metadataBundle = getMetadataBundle(/* MetadataCache */ null);\n  const name =\n      path.join(path.dirname(indexModule), ngOptions.flatModuleOutFile!.replace(JS_EXT, '.ts'));\n  const libraryIndex = `./${path.basename(indexModule)}`;\n  const content = privateEntriesToIndex(libraryIndex, metadataBundle.privates);\n\n  host = createSyntheticIndexHost(host, {\n    name,\n    content,\n    getMetadata: () => {\n      // The second metadata bundle production happens on-demand, and uses the getMetadataCache\n      // closure to retrieve an up-to-date MetadataCache which is configured with whatever metadata\n      // transforms were used to produce the JS output.\n      const metadataBundle = getMetadataBundle(getMetadataCache());\n      return JSON.stringify(metadataBundle.metadata);\n    }\n  });\n  return {host, indexName: name};\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}