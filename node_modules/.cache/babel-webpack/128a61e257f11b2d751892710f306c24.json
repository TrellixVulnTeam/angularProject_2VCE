{"ast":null,"code":"var _classCallCheck = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createClass\");\n\nvar idInc = 0;\n\nvar genWrappedFunc = function genWrappedFunc(_ref) {\n  var func = _ref.func,\n      smp = _ref.smp,\n      context = _ref.context,\n      timeEventName = _ref.timeEventName,\n      pluginName = _ref.pluginName,\n      endType = _ref.endType;\n  return function () {\n    var id = idInc++; // we don't know if there's going to be a callback applied to a particular\n    // call, so we just set it multiple times, letting each one override the last\n\n    var addEndEvent = function addEndEvent() {\n      return smp.addTimeEvent(\"plugins\", timeEventName, \"end\", {\n        id: id,\n        // we need to allow failure, since webpack can finish compilation and\n        // cause our callbacks to fall on deaf ears\n        allowFailure: true\n      });\n    };\n\n    smp.addTimeEvent(\"plugins\", timeEventName, \"start\", {\n      id: id,\n      name: pluginName\n    }); // invoke an end event immediately in case the callback here causes webpack\n    // to complete compilation. If this gets invoked and not the subsequent\n    // call, then our data will be inaccurate, sadly\n\n    addEndEvent();\n\n    var normalArgMap = function normalArgMap(a) {\n      return wrap(a, pluginName, smp);\n    };\n\n    var ret;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (endType === \"wrapDone\") ret = func.apply(context, args.map(function (a) {\n      return wrap(a, pluginName, smp, addEndEvent);\n    }));else if (endType === \"async\") {\n      var argsButLast = args.slice(0, args.length - 1);\n      var callback = args[args.length - 1];\n      ret = func.apply(context, argsButLast.map(normalArgMap).concat(function () {\n        addEndEvent();\n        callback.apply(void 0, arguments);\n      }));\n    } else if (endType === \"promise\") ret = func.apply(context, args.map(normalArgMap)).then(function (promiseArg) {\n      addEndEvent();\n      return promiseArg;\n    });else ret = func.apply(context, args.map(normalArgMap));\n    addEndEvent();\n    return ret;\n  };\n};\n\nvar genPluginMethod = function genPluginMethod(orig, pluginName, smp, type) {\n  return function (method, func) {\n    var timeEventName = pluginName + \"/\" + type + \"/\" + method;\n    var wrappedFunc = genWrappedFunc({\n      func: func,\n      smp: smp,\n      context: this,\n      timeEventName: timeEventName,\n      pluginName: pluginName,\n      endType: \"wrapDone\"\n    });\n    return orig.plugin(method, wrappedFunc);\n  };\n};\n\nvar wrapTap = function wrapTap(tap, pluginName, smp, type, method) {\n  return function (id, func) {\n    var timeEventName = pluginName + \"/\" + type + \"/\" + method;\n    var wrappedFunc = genWrappedFunc({\n      func: func,\n      smp: smp,\n      context: this,\n      timeEventName: timeEventName,\n      pluginName: pluginName\n    });\n    return tap.call(this, id, wrappedFunc);\n  };\n};\n\nvar wrapTapAsync = function wrapTapAsync(tapAsync, pluginName, smp, type, method) {\n  return function (id, func) {\n    var timeEventName = pluginName + \"/\" + type + \"/\" + method;\n    var wrappedFunc = genWrappedFunc({\n      func: func,\n      smp: smp,\n      context: this,\n      timeEventName: timeEventName,\n      pluginName: pluginName,\n      endType: \"async\"\n    });\n    return tapAsync.call(this, id, wrappedFunc);\n  };\n};\n\nvar wrapTapPromise = function wrapTapPromise(tapPromise, pluginName, smp, type, method) {\n  return function (id, func) {\n    var timeEventName = pluginName + \"/\" + type + \"/\" + method;\n    var wrappedFunc = genWrappedFunc({\n      func: func,\n      smp: smp,\n      context: this,\n      timeEventName: timeEventName,\n      pluginName: pluginName,\n      endType: \"promise\"\n    });\n    return tapPromise.call(this, id, wrappedFunc);\n  };\n};\n\nvar wrappedHooks = [];\n\nvar wrapHooks = function wrapHooks(orig, pluginName, smp, type) {\n  var hooks = orig.hooks;\n  if (!hooks) return hooks;\n  var prevWrapped = wrappedHooks.find(function (w) {\n    return w.pluginName === pluginName && (w.orig === hooks || w.wrapped === hooks);\n  });\n  if (prevWrapped) return prevWrapped.wrapped;\n\n  var genProxy = function genProxy(method) {\n    var proxy = new Proxy(hooks[method], {\n      get: function get(target, property) {\n        var raw = Reflect.get(target, property);\n        if (property === \"tap\" && typeof raw === \"function\") return wrapTap(raw, pluginName, smp, type, method).bind(proxy);\n        if (property === \"tapAsync\" && typeof raw === \"function\") return wrapTapAsync(raw, pluginName, smp, type, method).bind(proxy);\n        if (property === \"tapPromise\" && typeof raw === \"function\") return wrapTapPromise(raw, pluginName, smp, type, method).bind(proxy);\n        return raw;\n      },\n      set: function set(target, property, value) {\n        return Reflect.set(target, property, value);\n      },\n      deleteProperty: function deleteProperty(target, property) {\n        return Reflect.deleteProperty(target, property);\n      }\n    });\n    return proxy;\n  };\n\n  var wrapped = Object.keys(hooks).reduce(function (acc, method) {\n    acc[method] = genProxy(method);\n    return acc;\n  }, {});\n  wrappedHooks.push({\n    orig: hooks,\n    wrapped: wrapped,\n    pluginName: pluginName\n  });\n  return wrapped;\n};\n\nvar construcNamesToWrap = [\"Compiler\", \"Compilation\", \"MainTemplate\", \"Parser\", \"NormalModuleFactory\", \"ContextModuleFactory\"];\nvar wrappedObjs = [];\n\nvar findWrappedObj = function findWrappedObj(orig, pluginName) {\n  var prevWrapped = wrappedObjs.find(function (w) {\n    return w.pluginName === pluginName && (w.orig === orig || w.wrapped === orig);\n  });\n  if (prevWrapped) return prevWrapped.wrapped;\n};\n\nvar wrap = function wrap(orig, pluginName, smp, addEndEvent) {\n  if (!orig) return orig;\n  var prevWrapped = findWrappedObj(orig, pluginName);\n  if (prevWrapped) return prevWrapped;\n\n  var getOrigConstrucName = function getOrigConstrucName(target) {\n    return target && target.constructor && target.constructor.name;\n  };\n\n  var getShouldWrap = function getShouldWrap(target) {\n    var origConstrucName = getOrigConstrucName(target);\n    return construcNamesToWrap.includes(origConstrucName);\n  };\n\n  var shouldWrap = getShouldWrap(orig);\n  var shouldSoftWrap = Object.keys(orig).map(function (k) {\n    return orig[k];\n  }).some(getShouldWrap);\n  var wrappedReturn;\n\n  if (!shouldWrap && !shouldSoftWrap) {\n    var vanillaFunc = orig.name === \"next\";\n    wrappedReturn = vanillaFunc && addEndEvent ? function () {\n      // do this before calling the callback, since the callback can start\n      // the next plugin step\n      addEndEvent();\n      return orig.apply(this, arguments);\n    } : orig;\n  } else {\n    var proxy = new Proxy(orig, {\n      get: function get(target, property) {\n        var raw = Reflect.get(target, property);\n        if (shouldWrap && property === \"plugin\") return genPluginMethod(target, pluginName, smp, getOrigConstrucName(target)).bind(proxy);\n        if (shouldWrap && property === \"hooks\") return wrapHooks(target, pluginName, smp, getOrigConstrucName(target));\n\n        if (shouldWrap && property === \"compiler\") {\n          var _prevWrapped = findWrappedObj(raw, pluginName);\n\n          if (_prevWrapped) {\n            return _prevWrapped;\n          }\n        }\n\n        if (typeof raw === \"function\") {\n          var ret = raw.bind(proxy);\n          if (property === \"constructor\") Object.defineProperty(ret, \"name\", {\n            value: raw.name\n          });\n          return ret;\n        }\n\n        return raw;\n      },\n      set: function set(target, property, value) {\n        return Reflect.set(target, property, value);\n      },\n      deleteProperty: function deleteProperty(target, property) {\n        return Reflect.deleteProperty(target, property);\n      }\n    });\n    wrappedReturn = proxy;\n  }\n\n  wrappedObjs.push({\n    pluginName: pluginName,\n    orig: orig,\n    wrapped: wrappedReturn\n  });\n  return wrappedReturn;\n};\n\nmodule.exports.clear = function () {\n  wrappedObjs.length = 0;\n  wrappedHooks.length = 0;\n};\n\nmodule.exports.WrappedPlugin = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function WrappedPlugin(plugin, pluginName, smp) {\n    _classCallCheck(this, WrappedPlugin);\n\n    this._smp_plugin = plugin;\n    this._smp_pluginName = pluginName;\n    this._smp = smp;\n    this.apply = this.apply.bind(this);\n    var wp = this;\n    return new Proxy(plugin, {\n      get: function get(target, property) {\n        if (property === \"apply\") {\n          return wp.apply;\n        }\n\n        return target[property];\n      },\n      set: function set(target, property, value) {\n        return Reflect.set(target, property, value);\n      },\n      deleteProperty: function deleteProperty(target, property) {\n        return Reflect.deleteProperty(target, property);\n      }\n    });\n  }\n\n  _createClass(WrappedPlugin, [{\n    key: \"apply\",\n    value: function apply(compiler) {\n      return this._smp_plugin.apply(wrap(compiler, this._smp_pluginName, this._smp));\n    }\n  }]);\n\n  return WrappedPlugin;\n}();","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/speed-measure-webpack-plugin/WrappedPlugin/index.js"],"names":["idInc","genWrappedFunc","func","smp","context","timeEventName","pluginName","endType","id","addEndEvent","addTimeEvent","allowFailure","name","normalArgMap","a","wrap","ret","args","apply","map","argsButLast","slice","length","callback","concat","then","promiseArg","genPluginMethod","orig","type","method","wrappedFunc","plugin","wrapTap","tap","call","wrapTapAsync","tapAsync","wrapTapPromise","tapPromise","wrappedHooks","wrapHooks","hooks","prevWrapped","find","w","wrapped","genProxy","proxy","Proxy","get","target","property","raw","Reflect","bind","set","value","deleteProperty","Object","keys","reduce","acc","push","construcNamesToWrap","wrappedObjs","findWrappedObj","getOrigConstrucName","constructor","getShouldWrap","origConstrucName","includes","shouldWrap","shouldSoftWrap","k","some","wrappedReturn","vanillaFunc","arguments","defineProperty","module","exports","clear","WrappedPlugin","_smp_plugin","_smp_pluginName","_smp","wp","compiler"],"mappings":"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","sourcesContent":["let idInc = 0;\n\nconst genWrappedFunc = ({\n  func,\n  smp,\n  context,\n  timeEventName,\n  pluginName,\n  endType,\n}) => (...args) => {\n  const id = idInc++;\n  // we don't know if there's going to be a callback applied to a particular\n  // call, so we just set it multiple times, letting each one override the last\n  const addEndEvent = () =>\n    smp.addTimeEvent(\"plugins\", timeEventName, \"end\", {\n      id,\n      // we need to allow failure, since webpack can finish compilation and\n      // cause our callbacks to fall on deaf ears\n      allowFailure: true,\n    });\n\n  smp.addTimeEvent(\"plugins\", timeEventName, \"start\", {\n    id,\n    name: pluginName,\n  });\n  // invoke an end event immediately in case the callback here causes webpack\n  // to complete compilation. If this gets invoked and not the subsequent\n  // call, then our data will be inaccurate, sadly\n  addEndEvent();\n  const normalArgMap = a => wrap(a, pluginName, smp);\n  let ret;\n  if (endType === \"wrapDone\")\n    ret = func.apply(\n      context,\n      args.map(a => wrap(a, pluginName, smp, addEndEvent))\n    );\n  else if (endType === \"async\") {\n    const argsButLast = args.slice(0, args.length - 1);\n    const callback = args[args.length - 1];\n    ret = func.apply(\n      context,\n      argsButLast.map(normalArgMap).concat((...callbackArgs) => {\n        addEndEvent();\n        callback(...callbackArgs);\n      })\n    );\n  } else if (endType === \"promise\")\n    ret = func.apply(context, args.map(normalArgMap)).then(promiseArg => {\n      addEndEvent();\n      return promiseArg;\n    });\n  else ret = func.apply(context, args.map(normalArgMap));\n  addEndEvent();\n\n  return ret;\n};\n\nconst genPluginMethod = (orig, pluginName, smp, type) =>\n  function(method, func) {\n    const timeEventName = pluginName + \"/\" + type + \"/\" + method;\n    const wrappedFunc = genWrappedFunc({\n      func,\n      smp,\n      context: this,\n      timeEventName,\n      pluginName,\n      endType: \"wrapDone\",\n    });\n    return orig.plugin(method, wrappedFunc);\n  };\n\nconst wrapTap = (tap, pluginName, smp, type, method) =>\n  function(id, func) {\n    const timeEventName = pluginName + \"/\" + type + \"/\" + method;\n    const wrappedFunc = genWrappedFunc({\n      func,\n      smp,\n      context: this,\n      timeEventName,\n      pluginName,\n    });\n    return tap.call(this, id, wrappedFunc);\n  };\n\nconst wrapTapAsync = (tapAsync, pluginName, smp, type, method) =>\n  function(id, func) {\n    const timeEventName = pluginName + \"/\" + type + \"/\" + method;\n    const wrappedFunc = genWrappedFunc({\n      func,\n      smp,\n      context: this,\n      timeEventName,\n      pluginName,\n      endType: \"async\",\n    });\n    return tapAsync.call(this, id, wrappedFunc);\n  };\n\nconst wrapTapPromise = (tapPromise, pluginName, smp, type, method) =>\n  function(id, func) {\n    const timeEventName = pluginName + \"/\" + type + \"/\" + method;\n    const wrappedFunc = genWrappedFunc({\n      func,\n      smp,\n      context: this,\n      timeEventName,\n      pluginName,\n      endType: \"promise\",\n    });\n    return tapPromise.call(this, id, wrappedFunc);\n  };\n\nconst wrappedHooks = [];\nconst wrapHooks = (orig, pluginName, smp, type) => {\n  const hooks = orig.hooks;\n  if (!hooks) return hooks;\n  const prevWrapped = wrappedHooks.find(\n    w =>\n      w.pluginName === pluginName && (w.orig === hooks || w.wrapped === hooks)\n  );\n  if (prevWrapped) return prevWrapped.wrapped;\n\n  const genProxy = method => {\n    const proxy = new Proxy(hooks[method], {\n      get: (target, property) => {\n        const raw = Reflect.get(target, property);\n\n        if (property === \"tap\" && typeof raw === \"function\")\n          return wrapTap(raw, pluginName, smp, type, method).bind(proxy);\n        if (property === \"tapAsync\" && typeof raw === \"function\")\n          return wrapTapAsync(raw, pluginName, smp, type, method).bind(proxy);\n        if (property === \"tapPromise\" && typeof raw === \"function\")\n          return wrapTapPromise(raw, pluginName, smp, type, method).bind(proxy);\n\n        return raw;\n      },\n      set: (target, property, value) => {\n        return Reflect.set(target, property, value);\n      },\n      deleteProperty: (target, property) => {\n        return Reflect.deleteProperty(target, property);\n      },\n    });\n    return proxy;\n  };\n\n  const wrapped = Object.keys(hooks).reduce((acc, method) => {\n    acc[method] = genProxy(method);\n    return acc;\n  }, {});\n\n  wrappedHooks.push({ orig: hooks, wrapped, pluginName });\n\n  return wrapped;\n};\n\nconst construcNamesToWrap = [\n  \"Compiler\",\n  \"Compilation\",\n  \"MainTemplate\",\n  \"Parser\",\n  \"NormalModuleFactory\",\n  \"ContextModuleFactory\",\n];\n\nconst wrappedObjs = [];\nconst findWrappedObj = (orig, pluginName) => {\n  const prevWrapped = wrappedObjs.find(\n    w => w.pluginName === pluginName && (w.orig === orig || w.wrapped === orig)\n  );\n  if (prevWrapped) return prevWrapped.wrapped;\n};\nconst wrap = (orig, pluginName, smp, addEndEvent) => {\n  if (!orig) return orig;\n  const prevWrapped = findWrappedObj(orig, pluginName);\n  if (prevWrapped) return prevWrapped;\n\n  const getOrigConstrucName = target =>\n    target && target.constructor && target.constructor.name;\n  const getShouldWrap = target => {\n    const origConstrucName = getOrigConstrucName(target);\n    return construcNamesToWrap.includes(origConstrucName);\n  };\n  const shouldWrap = getShouldWrap(orig);\n  const shouldSoftWrap = Object.keys(orig)\n    .map(k => orig[k])\n    .some(getShouldWrap);\n\n  let wrappedReturn;\n\n  if (!shouldWrap && !shouldSoftWrap) {\n    const vanillaFunc = orig.name === \"next\";\n    wrappedReturn =\n      vanillaFunc && addEndEvent\n        ? function() {\n            // do this before calling the callback, since the callback can start\n            // the next plugin step\n            addEndEvent();\n\n            return orig.apply(this, arguments);\n          }\n        : orig;\n  } else {\n    const proxy = new Proxy(orig, {\n      get: (target, property) => {\n        const raw = Reflect.get(target, property);\n\n        if (shouldWrap && property === \"plugin\")\n          return genPluginMethod(\n            target,\n            pluginName,\n            smp,\n            getOrigConstrucName(target)\n          ).bind(proxy);\n\n        if (shouldWrap && property === \"hooks\")\n          return wrapHooks(\n            target,\n            pluginName,\n            smp,\n            getOrigConstrucName(target)\n          );\n\n        if (shouldWrap && property === \"compiler\") {\n          const prevWrapped = findWrappedObj(raw, pluginName);\n          if (prevWrapped) {\n            return prevWrapped;\n          }\n        }\n\n        if (typeof raw === \"function\") {\n          const ret = raw.bind(proxy);\n          if (property === \"constructor\")\n            Object.defineProperty(ret, \"name\", {\n              value: raw.name,\n            });\n          return ret;\n        }\n\n        return raw;\n      },\n      set: (target, property, value) => {\n        return Reflect.set(target, property, value);\n      },\n      deleteProperty: (target, property) => {\n        return Reflect.deleteProperty(target, property);\n      },\n    });\n\n    wrappedReturn = proxy;\n  }\n\n  wrappedObjs.push({ pluginName, orig, wrapped: wrappedReturn });\n  return wrappedReturn;\n};\n\nmodule.exports.clear = () => {\n  wrappedObjs.length = 0;\n  wrappedHooks.length = 0;\n};\n\nmodule.exports.WrappedPlugin = class WrappedPlugin {\n  constructor(plugin, pluginName, smp) {\n    this._smp_plugin = plugin;\n    this._smp_pluginName = pluginName;\n    this._smp = smp;\n\n    this.apply = this.apply.bind(this);\n\n    const wp = this;\n    return new Proxy(plugin, {\n      get(target, property) {\n        if (property === \"apply\") {\n          return wp.apply;\n        }\n        return target[property];\n      },\n      set: (target, property, value) => {\n        return Reflect.set(target, property, value);\n      },\n      deleteProperty: (target, property) => {\n        return Reflect.deleteProperty(target, property);\n      },\n    });\n  }\n\n  apply(compiler) {\n    return this._smp_plugin.apply(\n      wrap(compiler, this._smp_pluginName, this._smp)\n    );\n  }\n};\n"]},"metadata":{},"sourceType":"script"}