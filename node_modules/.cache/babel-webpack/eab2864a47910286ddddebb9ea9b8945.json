{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/typecheck/src/line_mappings\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.computeLineStartsMap = exports.getLineAndCharacterFromPosition = void 0;\n  var LF_CHAR = 10;\n  var CR_CHAR = 13;\n  var LINE_SEP_CHAR = 8232;\n  var PARAGRAPH_CHAR = 8233;\n  /** Gets the line and character for the given position from the line starts map. */\n\n  function getLineAndCharacterFromPosition(lineStartsMap, position) {\n    var lineIndex = findClosestLineStartPosition(lineStartsMap, position);\n    return {\n      character: position - lineStartsMap[lineIndex],\n      line: lineIndex\n    };\n  }\n\n  exports.getLineAndCharacterFromPosition = getLineAndCharacterFromPosition;\n  /**\n   * Computes the line start map of the given text. This can be used in order to\n   * retrieve the line and character of a given text position index.\n   */\n\n  function computeLineStartsMap(text) {\n    var result = [0];\n    var pos = 0;\n\n    while (pos < text.length) {\n      var char = text.charCodeAt(pos++); // Handles the \"CRLF\" line break. In that case we peek the character\n      // after the \"CR\" and check if it is a line feed.\n\n      if (char === CR_CHAR) {\n        if (text.charCodeAt(pos) === LF_CHAR) {\n          pos++;\n        }\n\n        result.push(pos);\n      } else if (char === LF_CHAR || char === LINE_SEP_CHAR || char === PARAGRAPH_CHAR) {\n        result.push(pos);\n      }\n    }\n\n    result.push(pos);\n    return result;\n  }\n\n  exports.computeLineStartsMap = computeLineStartsMap;\n  /** Finds the closest line start for the given position. */\n\n  function findClosestLineStartPosition(linesMap, position, low, high) {\n    if (low === void 0) {\n      low = 0;\n    }\n\n    if (high === void 0) {\n      high = linesMap.length - 1;\n    }\n\n    while (low <= high) {\n      var pivotIdx = Math.floor((low + high) / 2);\n      var pivotEl = linesMap[pivotIdx];\n\n      if (pivotEl === position) {\n        return pivotIdx;\n      } else if (position > pivotEl) {\n        low = pivotIdx + 1;\n      } else {\n        high = pivotIdx - 1;\n      }\n    } // In case there was no exact match, return the closest \"lower\" line index. We also\n    // subtract the index by one because want the index of the previous line start.\n\n\n    return low - 1;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/typecheck/src/line_mappings.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;AAEH,MAAM,OAAO,GAAG,EAAhB;AACA,MAAM,OAAO,GAAG,EAAhB;AACA,MAAM,aAAa,GAAG,IAAtB;AACA,MAAM,cAAc,GAAG,IAAvB;AAEA;;AACA,WAAgB,+BAAhB,CAAgD,aAAhD,EAAyE,QAAzE,EAAyF;AACvF,QAAM,SAAS,GAAG,4BAA4B,CAAC,aAAD,EAAgB,QAAhB,CAA9C;AACA,WAAO;AAAC,MAAA,SAAS,EAAE,QAAQ,GAAG,aAAa,CAAC,SAAD,CAApC;AAAiD,MAAA,IAAI,EAAE;AAAvD,KAAP;AACD;;AAHD,EAAA,OAAA,CAAA,+BAAA,GAAA,+BAAA;AAKA;;;AAGG;;AACH,WAAgB,oBAAhB,CAAqC,IAArC,EAAiD;AAC/C,QAAM,MAAM,GAAa,CAAC,CAAD,CAAzB;AACA,QAAI,GAAG,GAAG,CAAV;;AACA,WAAO,GAAG,GAAG,IAAI,CAAC,MAAlB,EAA0B;AACxB,UAAM,IAAI,GAAG,IAAI,CAAC,UAAL,CAAgB,GAAG,EAAnB,CAAb,CADwB,CAExB;AACA;;AACA,UAAI,IAAI,KAAK,OAAb,EAAsB;AACpB,YAAI,IAAI,CAAC,UAAL,CAAgB,GAAhB,MAAyB,OAA7B,EAAsC;AACpC,UAAA,GAAG;AACJ;;AACD,QAAA,MAAM,CAAC,IAAP,CAAY,GAAZ;AACD,OALD,MAKO,IAAI,IAAI,KAAK,OAAT,IAAoB,IAAI,KAAK,aAA7B,IAA8C,IAAI,KAAK,cAA3D,EAA2E;AAChF,QAAA,MAAM,CAAC,IAAP,CAAY,GAAZ;AACD;AACF;;AACD,IAAA,MAAM,CAAC,IAAP,CAAY,GAAZ;AACA,WAAO,MAAP;AACD;;AAlBD,EAAA,OAAA,CAAA,oBAAA,GAAA,oBAAA;AAoBA;;AACA,WAAS,4BAAT,CACI,QADJ,EACmB,QADnB,EACgC,GADhC,EACyC,IADzC,EACmE;AAAnC,QAAA,GAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,GAAA,GAAA,CAAA;AAAO;;AAAE,QAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,MAAA,IAAA,GAAO,QAAQ,CAAC,MAAT,GAAkB,CAAzB;AAA0B;;AACjE,WAAO,GAAG,IAAI,IAAd,EAAoB;AAClB,UAAM,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,CAAC,GAAG,GAAG,IAAP,IAAe,CAA1B,CAAjB;AACA,UAAM,OAAO,GAAG,QAAQ,CAAC,QAAD,CAAxB;;AAEA,UAAI,OAAO,KAAK,QAAhB,EAA0B;AACxB,eAAO,QAAP;AACD,OAFD,MAEO,IAAI,QAAQ,GAAG,OAAf,EAAwB;AAC7B,QAAA,GAAG,GAAG,QAAQ,GAAG,CAAjB;AACD,OAFM,MAEA;AACL,QAAA,IAAI,GAAG,QAAQ,GAAG,CAAlB;AACD;AACF,KAZgE,CAcjE;AACA;;;AACA,WAAO,GAAG,GAAG,CAAb;AACD","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst LF_CHAR = 10;\nconst CR_CHAR = 13;\nconst LINE_SEP_CHAR = 8232;\nconst PARAGRAPH_CHAR = 8233;\n\n/** Gets the line and character for the given position from the line starts map. */\nexport function getLineAndCharacterFromPosition(lineStartsMap: number[], position: number) {\n  const lineIndex = findClosestLineStartPosition(lineStartsMap, position);\n  return {character: position - lineStartsMap[lineIndex], line: lineIndex};\n}\n\n/**\n * Computes the line start map of the given text. This can be used in order to\n * retrieve the line and character of a given text position index.\n */\nexport function computeLineStartsMap(text: string): number[] {\n  const result: number[] = [0];\n  let pos = 0;\n  while (pos < text.length) {\n    const char = text.charCodeAt(pos++);\n    // Handles the \"CRLF\" line break. In that case we peek the character\n    // after the \"CR\" and check if it is a line feed.\n    if (char === CR_CHAR) {\n      if (text.charCodeAt(pos) === LF_CHAR) {\n        pos++;\n      }\n      result.push(pos);\n    } else if (char === LF_CHAR || char === LINE_SEP_CHAR || char === PARAGRAPH_CHAR) {\n      result.push(pos);\n    }\n  }\n  result.push(pos);\n  return result;\n}\n\n/** Finds the closest line start for the given position. */\nfunction findClosestLineStartPosition<T>(\n    linesMap: T[], position: T, low = 0, high = linesMap.length - 1) {\n  while (low <= high) {\n    const pivotIdx = Math.floor((low + high) / 2);\n    const pivotEl = linesMap[pivotIdx];\n\n    if (pivotEl === position) {\n      return pivotIdx;\n    } else if (position > pivotEl) {\n      low = pivotIdx + 1;\n    } else {\n      high = pivotIdx - 1;\n    }\n  }\n\n  // In case there was no exact match, return the closest \"lower\" line index. We also\n  // subtract the index by one because want the index of the previous line start.\n  return low - 1;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}