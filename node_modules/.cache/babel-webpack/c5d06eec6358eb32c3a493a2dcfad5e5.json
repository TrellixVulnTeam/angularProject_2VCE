{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/indexer/src/template\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"@angular/compiler-cli/src/ngtsc/indexer/src/api\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getTemplateIdentifiers = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var api_1 = require(\"@angular/compiler-cli/src/ngtsc/indexer/src/api\");\n  /**\n   * Visits the AST of an Angular template syntax expression, finding interesting\n   * entities (variable references, etc.). Creates an array of Entities found in\n   * the expression, with the location of the Entities being relative to the\n   * expression.\n   *\n   * Visiting `text {{prop}}` will return\n   * `[TopLevelIdentifier {name: 'prop', span: {start: 7, end: 11}}]`.\n   */\n\n\n  var ExpressionVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(ExpressionVisitor, _super);\n\n    function ExpressionVisitor(expressionStr, absoluteOffset, boundTemplate, targetToIdentifier) {\n      var _this = _super.call(this) || this;\n\n      _this.expressionStr = expressionStr;\n      _this.absoluteOffset = absoluteOffset;\n      _this.boundTemplate = boundTemplate;\n      _this.targetToIdentifier = targetToIdentifier;\n      _this.identifiers = [];\n      return _this;\n    }\n    /**\n     * Returns identifiers discovered in an expression.\n     *\n     * @param ast expression AST to visit\n     * @param source expression AST source code\n     * @param absoluteOffset absolute byte offset from start of the file to the start of the AST\n     * source code.\n     * @param boundTemplate bound target of the entire template, which can be used to query for the\n     * entities expressions target.\n     * @param targetToIdentifier closure converting a template target node to its identifier.\n     */\n\n\n    ExpressionVisitor.getIdentifiers = function (ast, source, absoluteOffset, boundTemplate, targetToIdentifier) {\n      var visitor = new ExpressionVisitor(source, absoluteOffset, boundTemplate, targetToIdentifier);\n      visitor.visit(ast);\n      return visitor.identifiers;\n    };\n\n    ExpressionVisitor.prototype.visit = function (ast) {\n      ast.visit(this);\n    };\n\n    ExpressionVisitor.prototype.visitMethodCall = function (ast, context) {\n      this.visitIdentifier(ast, api_1.IdentifierKind.Method);\n\n      _super.prototype.visitMethodCall.call(this, ast, context);\n    };\n\n    ExpressionVisitor.prototype.visitPropertyRead = function (ast, context) {\n      this.visitIdentifier(ast, api_1.IdentifierKind.Property);\n\n      _super.prototype.visitPropertyRead.call(this, ast, context);\n    };\n\n    ExpressionVisitor.prototype.visitPropertyWrite = function (ast, context) {\n      this.visitIdentifier(ast, api_1.IdentifierKind.Property);\n\n      _super.prototype.visitPropertyWrite.call(this, ast, context);\n    };\n    /**\n     * Visits an identifier, adding it to the identifier store if it is useful for indexing.\n     *\n     * @param ast expression AST the identifier is in\n     * @param kind identifier kind\n     */\n\n\n    ExpressionVisitor.prototype.visitIdentifier = function (ast, kind) {\n      // The definition of a non-top-level property such as `bar` in `{{foo.bar}}` is currently\n      // impossible to determine by an indexer and unsupported by the indexing module.\n      // The indexing module also does not currently support references to identifiers declared in the\n      // template itself, which have a non-null expression target.\n      if (!(ast.receiver instanceof compiler_1.ImplicitReceiver)) {\n        return;\n      } // The source span of the requested AST starts at a location that is offset from the expression.\n\n\n      var identifierStart = ast.sourceSpan.start - this.absoluteOffset;\n\n      if (!this.expressionStr.substring(identifierStart).startsWith(ast.name)) {\n        throw new Error(\"Impossible state: \\\"\" + ast.name + \"\\\" not found in \\\"\" + this.expressionStr + \"\\\" at location \" + identifierStart);\n      } // Join the relative position of the expression within a node with the absolute position\n      // of the node to get the absolute position of the expression in the source code.\n\n\n      var absoluteStart = this.absoluteOffset + identifierStart;\n      var span = new api_1.AbsoluteSourceSpan(absoluteStart, absoluteStart + ast.name.length);\n      var targetAst = this.boundTemplate.getExpressionTarget(ast);\n      var target = targetAst ? this.targetToIdentifier(targetAst) : null;\n      var identifier = {\n        name: ast.name,\n        span: span,\n        kind: kind,\n        target: target\n      };\n      this.identifiers.push(identifier);\n    };\n\n    return ExpressionVisitor;\n  }(compiler_1.RecursiveAstVisitor);\n  /**\n   * Visits the AST of a parsed Angular template. Discovers and stores\n   * identifiers of interest, deferring to an `ExpressionVisitor` as needed.\n   */\n\n\n  var TemplateVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(TemplateVisitor, _super);\n    /**\n     * Creates a template visitor for a bound template target. The bound target can be used when\n     * deferred to the expression visitor to get information about the target of an expression.\n     *\n     * @param boundTemplate bound template target\n     */\n\n\n    function TemplateVisitor(boundTemplate) {\n      var _this = _super.call(this) || this;\n\n      _this.boundTemplate = boundTemplate; // Identifiers of interest found in the template.\n\n      _this.identifiers = new Set(); // Map of targets in a template to their identifiers.\n\n      _this.targetIdentifierCache = new Map(); // Map of elements and templates to their identifiers.\n\n      _this.elementAndTemplateIdentifierCache = new Map();\n      return _this;\n    }\n    /**\n     * Visits a node in the template.\n     *\n     * @param node node to visit\n     */\n\n\n    TemplateVisitor.prototype.visit = function (node) {\n      node.visit(this);\n    };\n\n    TemplateVisitor.prototype.visitAll = function (nodes) {\n      var _this = this;\n\n      nodes.forEach(function (node) {\n        return _this.visit(node);\n      });\n    };\n    /**\n     * Add an identifier for an HTML element and visit its children recursively.\n     *\n     * @param element\n     */\n\n\n    TemplateVisitor.prototype.visitElement = function (element) {\n      var elementIdentifier = this.elementOrTemplateToIdentifier(element);\n      this.identifiers.add(elementIdentifier);\n      this.visitAll(element.references);\n      this.visitAll(element.inputs);\n      this.visitAll(element.attributes);\n      this.visitAll(element.children);\n      this.visitAll(element.outputs);\n    };\n\n    TemplateVisitor.prototype.visitTemplate = function (template) {\n      var templateIdentifier = this.elementOrTemplateToIdentifier(template);\n      this.identifiers.add(templateIdentifier);\n      this.visitAll(template.variables);\n      this.visitAll(template.attributes);\n      this.visitAll(template.templateAttrs);\n      this.visitAll(template.children);\n      this.visitAll(template.references);\n    };\n\n    TemplateVisitor.prototype.visitBoundAttribute = function (attribute) {\n      var _this = this; // If the bound attribute has no value, it cannot have any identifiers in the value expression.\n\n\n      if (attribute.valueSpan === undefined) {\n        return;\n      }\n\n      var identifiers = ExpressionVisitor.getIdentifiers(attribute.value, attribute.valueSpan.toString(), attribute.valueSpan.start.offset, this.boundTemplate, this.targetToIdentifier.bind(this));\n      identifiers.forEach(function (id) {\n        return _this.identifiers.add(id);\n      });\n    };\n\n    TemplateVisitor.prototype.visitBoundEvent = function (attribute) {\n      this.visitExpression(attribute.handler);\n    };\n\n    TemplateVisitor.prototype.visitBoundText = function (text) {\n      this.visitExpression(text.value);\n    };\n\n    TemplateVisitor.prototype.visitReference = function (reference) {\n      var referenceIdentifer = this.targetToIdentifier(reference);\n      this.identifiers.add(referenceIdentifer);\n    };\n\n    TemplateVisitor.prototype.visitVariable = function (variable) {\n      var variableIdentifier = this.targetToIdentifier(variable);\n      this.identifiers.add(variableIdentifier);\n    };\n    /** Creates an identifier for a template element or template node. */\n\n\n    TemplateVisitor.prototype.elementOrTemplateToIdentifier = function (node) {\n      // If this node has already been seen, return the cached result.\n      if (this.elementAndTemplateIdentifierCache.has(node)) {\n        return this.elementAndTemplateIdentifierCache.get(node);\n      }\n\n      var name;\n      var kind;\n\n      if (node instanceof compiler_1.TmplAstTemplate) {\n        name = node.tagName;\n        kind = api_1.IdentifierKind.Template;\n      } else {\n        name = node.name;\n        kind = api_1.IdentifierKind.Element;\n      }\n\n      var sourceSpan = node.startSourceSpan; // An element's or template's source span can be of the form `<element>`, `<element />`, or\n      // `<element></element>`. Only the selector is interesting to the indexer, so the source is\n      // searched for the first occurrence of the element (selector) name.\n\n      var start = this.getStartLocation(name, sourceSpan);\n      var absoluteSpan = new api_1.AbsoluteSourceSpan(start, start + name.length); // Record the nodes's attributes, which an indexer can later traverse to see if any of them\n      // specify a used directive on the node.\n\n      var attributes = node.attributes.map(function (_a) {\n        var name = _a.name,\n            sourceSpan = _a.sourceSpan;\n        return {\n          name: name,\n          span: new api_1.AbsoluteSourceSpan(sourceSpan.start.offset, sourceSpan.end.offset),\n          kind: api_1.IdentifierKind.Attribute\n        };\n      });\n      var usedDirectives = this.boundTemplate.getDirectivesOfNode(node) || [];\n      var identifier = {\n        name: name,\n        span: absoluteSpan,\n        kind: kind,\n        attributes: new Set(attributes),\n        usedDirectives: new Set(usedDirectives.map(function (dir) {\n          return {\n            node: dir.ref.node,\n            selector: dir.selector\n          };\n        }))\n      };\n      this.elementAndTemplateIdentifierCache.set(node, identifier);\n      return identifier;\n    };\n    /** Creates an identifier for a template reference or template variable target. */\n\n\n    TemplateVisitor.prototype.targetToIdentifier = function (node) {\n      // If this node has already been seen, return the cached result.\n      if (this.targetIdentifierCache.has(node)) {\n        return this.targetIdentifierCache.get(node);\n      }\n\n      var name = node.name,\n          sourceSpan = node.sourceSpan;\n      var start = this.getStartLocation(name, sourceSpan);\n      var span = new api_1.AbsoluteSourceSpan(start, start + name.length);\n      var identifier;\n\n      if (node instanceof compiler_1.TmplAstReference) {\n        // If the node is a reference, we care about its target. The target can be an element, a\n        // template, a directive applied on a template or element (in which case the directive field\n        // is non-null), or nothing at all.\n        var refTarget = this.boundTemplate.getReferenceTarget(node);\n        var target = null;\n\n        if (refTarget) {\n          if (refTarget instanceof compiler_1.TmplAstElement || refTarget instanceof compiler_1.TmplAstTemplate) {\n            target = {\n              node: this.elementOrTemplateToIdentifier(refTarget),\n              directive: null\n            };\n          } else {\n            target = {\n              node: this.elementOrTemplateToIdentifier(refTarget.node),\n              directive: refTarget.directive.ref.node\n            };\n          }\n        }\n\n        identifier = {\n          name: name,\n          span: span,\n          kind: api_1.IdentifierKind.Reference,\n          target: target\n        };\n      } else {\n        identifier = {\n          name: name,\n          span: span,\n          kind: api_1.IdentifierKind.Variable\n        };\n      }\n\n      this.targetIdentifierCache.set(node, identifier);\n      return identifier;\n    };\n    /** Gets the start location of a string in a SourceSpan */\n\n\n    TemplateVisitor.prototype.getStartLocation = function (name, context) {\n      var localStr = context.toString();\n\n      if (!localStr.includes(name)) {\n        throw new Error(\"Impossible state: \\\"\" + name + \"\\\" not found in \\\"\" + localStr + \"\\\"\");\n      }\n\n      return context.start.offset + localStr.indexOf(name);\n    };\n    /**\n     * Visits a node's expression and adds its identifiers, if any, to the visitor's state.\n     * Only ASTs with information about the expression source and its location are visited.\n     *\n     * @param node node whose expression to visit\n     */\n\n\n    TemplateVisitor.prototype.visitExpression = function (ast) {\n      var _this = this; // Only include ASTs that have information about their source and absolute source spans.\n\n\n      if (ast instanceof compiler_1.ASTWithSource && ast.source !== null) {\n        // Make target to identifier mapping closure stateful to this visitor instance.\n        var targetToIdentifier = this.targetToIdentifier.bind(this);\n        var absoluteOffset = ast.sourceSpan.start;\n        var identifiers = ExpressionVisitor.getIdentifiers(ast, ast.source, absoluteOffset, this.boundTemplate, targetToIdentifier);\n        identifiers.forEach(function (id) {\n          return _this.identifiers.add(id);\n        });\n      }\n    };\n\n    return TemplateVisitor;\n  }(compiler_1.TmplAstRecursiveVisitor);\n  /**\n   * Traverses a template AST and builds identifiers discovered in it.\n   *\n   * @param boundTemplate bound template target, which can be used for querying expression targets.\n   * @return identifiers in template\n   */\n\n\n  function getTemplateIdentifiers(boundTemplate) {\n    var visitor = new TemplateVisitor(boundTemplate);\n\n    if (boundTemplate.target.template !== undefined) {\n      visitor.visitAll(boundTemplate.target.template);\n    }\n\n    return visitor.identifiers;\n  }\n\n  exports.getTemplateIdentifiers = getTemplateIdentifiers;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/indexer/src/template.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AST, ASTWithSource, BoundTarget, ImplicitReceiver, MethodCall, ParseSourceSpan, PropertyRead, PropertyWrite, RecursiveAstVisitor, TmplAstBoundAttribute, TmplAstBoundEvent, TmplAstBoundText, TmplAstElement, TmplAstNode, TmplAstRecursiveVisitor, TmplAstReference, TmplAstTemplate, TmplAstVariable} from '@angular/compiler';\nimport {AbsoluteSourceSpan, AttributeIdentifier, ElementIdentifier, IdentifierKind, MethodIdentifier, PropertyIdentifier, ReferenceIdentifier, TemplateNodeIdentifier, TopLevelIdentifier, VariableIdentifier} from './api';\nimport {ComponentMeta} from './context';\n\n/**\n * A parsed node in a template, which may have a name (if it is a selector) or\n * be anonymous (like a text span).\n */\ninterface HTMLNode extends TmplAstNode {\n  tagName?: string;\n  name?: string;\n}\n\ntype ExpressionIdentifier = PropertyIdentifier|MethodIdentifier;\ntype TmplTarget = TmplAstReference|TmplAstVariable;\ntype TargetIdentifier = ReferenceIdentifier|VariableIdentifier;\ntype TargetIdentifierMap = Map<TmplTarget, TargetIdentifier>;\n\n/**\n * Visits the AST of an Angular template syntax expression, finding interesting\n * entities (variable references, etc.). Creates an array of Entities found in\n * the expression, with the location of the Entities being relative to the\n * expression.\n *\n * Visiting `text {{prop}}` will return\n * `[TopLevelIdentifier {name: 'prop', span: {start: 7, end: 11}}]`.\n */\nclass ExpressionVisitor extends RecursiveAstVisitor {\n  readonly identifiers: ExpressionIdentifier[] = [];\n\n  private constructor(\n      private readonly expressionStr: string, private readonly absoluteOffset: number,\n      private readonly boundTemplate: BoundTarget<ComponentMeta>,\n      private readonly targetToIdentifier: (target: TmplTarget) => TargetIdentifier) {\n    super();\n  }\n\n  /**\n   * Returns identifiers discovered in an expression.\n   *\n   * @param ast expression AST to visit\n   * @param source expression AST source code\n   * @param absoluteOffset absolute byte offset from start of the file to the start of the AST\n   * source code.\n   * @param boundTemplate bound target of the entire template, which can be used to query for the\n   * entities expressions target.\n   * @param targetToIdentifier closure converting a template target node to its identifier.\n   */\n  static getIdentifiers(\n      ast: AST, source: string, absoluteOffset: number, boundTemplate: BoundTarget<ComponentMeta>,\n      targetToIdentifier: (target: TmplTarget) => TargetIdentifier): TopLevelIdentifier[] {\n    const visitor =\n        new ExpressionVisitor(source, absoluteOffset, boundTemplate, targetToIdentifier);\n    visitor.visit(ast);\n    return visitor.identifiers;\n  }\n\n  visit(ast: AST) {\n    ast.visit(this);\n  }\n\n  visitMethodCall(ast: MethodCall, context: {}) {\n    this.visitIdentifier(ast, IdentifierKind.Method);\n    super.visitMethodCall(ast, context);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: {}) {\n    this.visitIdentifier(ast, IdentifierKind.Property);\n    super.visitPropertyRead(ast, context);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: {}) {\n    this.visitIdentifier(ast, IdentifierKind.Property);\n    super.visitPropertyWrite(ast, context);\n  }\n\n  /**\n   * Visits an identifier, adding it to the identifier store if it is useful for indexing.\n   *\n   * @param ast expression AST the identifier is in\n   * @param kind identifier kind\n   */\n  private visitIdentifier(\n      ast: AST&{name: string, receiver: AST}, kind: ExpressionIdentifier['kind']) {\n    // The definition of a non-top-level property such as `bar` in `{{foo.bar}}` is currently\n    // impossible to determine by an indexer and unsupported by the indexing module.\n    // The indexing module also does not currently support references to identifiers declared in the\n    // template itself, which have a non-null expression target.\n    if (!(ast.receiver instanceof ImplicitReceiver)) {\n      return;\n    }\n\n    // The source span of the requested AST starts at a location that is offset from the expression.\n    const identifierStart = ast.sourceSpan.start - this.absoluteOffset;\n    if (!this.expressionStr.substring(identifierStart).startsWith(ast.name)) {\n      throw new Error(`Impossible state: \"${ast.name}\" not found in \"${\n          this.expressionStr}\" at location ${identifierStart}`);\n    }\n\n    // Join the relative position of the expression within a node with the absolute position\n    // of the node to get the absolute position of the expression in the source code.\n    const absoluteStart = this.absoluteOffset + identifierStart;\n    const span = new AbsoluteSourceSpan(absoluteStart, absoluteStart + ast.name.length);\n\n    const targetAst = this.boundTemplate.getExpressionTarget(ast);\n    const target = targetAst ? this.targetToIdentifier(targetAst) : null;\n    const identifier = {\n      name: ast.name,\n      span,\n      kind,\n      target,\n    } as ExpressionIdentifier;\n\n    this.identifiers.push(identifier);\n  }\n}\n\n/**\n * Visits the AST of a parsed Angular template. Discovers and stores\n * identifiers of interest, deferring to an `ExpressionVisitor` as needed.\n */\nclass TemplateVisitor extends TmplAstRecursiveVisitor {\n  // Identifiers of interest found in the template.\n  readonly identifiers = new Set<TopLevelIdentifier>();\n\n  // Map of targets in a template to their identifiers.\n  private readonly targetIdentifierCache: TargetIdentifierMap = new Map();\n\n  // Map of elements and templates to their identifiers.\n  private readonly elementAndTemplateIdentifierCache =\n      new Map<TmplAstElement|TmplAstTemplate, ElementIdentifier|TemplateNodeIdentifier>();\n\n  /**\n   * Creates a template visitor for a bound template target. The bound target can be used when\n   * deferred to the expression visitor to get information about the target of an expression.\n   *\n   * @param boundTemplate bound template target\n   */\n  constructor(private boundTemplate: BoundTarget<ComponentMeta>) {\n    super();\n  }\n\n  /**\n   * Visits a node in the template.\n   *\n   * @param node node to visit\n   */\n  visit(node: HTMLNode) {\n    node.visit(this);\n  }\n\n  visitAll(nodes: TmplAstNode[]) {\n    nodes.forEach(node => this.visit(node));\n  }\n\n  /**\n   * Add an identifier for an HTML element and visit its children recursively.\n   *\n   * @param element\n   */\n  visitElement(element: TmplAstElement) {\n    const elementIdentifier = this.elementOrTemplateToIdentifier(element);\n\n    this.identifiers.add(elementIdentifier);\n\n    this.visitAll(element.references);\n    this.visitAll(element.inputs);\n    this.visitAll(element.attributes);\n    this.visitAll(element.children);\n    this.visitAll(element.outputs);\n  }\n  visitTemplate(template: TmplAstTemplate) {\n    const templateIdentifier = this.elementOrTemplateToIdentifier(template);\n\n    this.identifiers.add(templateIdentifier);\n\n    this.visitAll(template.variables);\n    this.visitAll(template.attributes);\n    this.visitAll(template.templateAttrs);\n    this.visitAll(template.children);\n    this.visitAll(template.references);\n  }\n  visitBoundAttribute(attribute: TmplAstBoundAttribute) {\n    // If the bound attribute has no value, it cannot have any identifiers in the value expression.\n    if (attribute.valueSpan === undefined) {\n      return;\n    }\n\n    const identifiers = ExpressionVisitor.getIdentifiers(\n        attribute.value, attribute.valueSpan.toString(), attribute.valueSpan.start.offset,\n        this.boundTemplate, this.targetToIdentifier.bind(this));\n    identifiers.forEach(id => this.identifiers.add(id));\n  }\n  visitBoundEvent(attribute: TmplAstBoundEvent) {\n    this.visitExpression(attribute.handler);\n  }\n  visitBoundText(text: TmplAstBoundText) {\n    this.visitExpression(text.value);\n  }\n  visitReference(reference: TmplAstReference) {\n    const referenceIdentifer = this.targetToIdentifier(reference);\n\n    this.identifiers.add(referenceIdentifer);\n  }\n  visitVariable(variable: TmplAstVariable) {\n    const variableIdentifier = this.targetToIdentifier(variable);\n\n    this.identifiers.add(variableIdentifier);\n  }\n\n  /** Creates an identifier for a template element or template node. */\n  private elementOrTemplateToIdentifier(node: TmplAstElement|TmplAstTemplate): ElementIdentifier\n      |TemplateNodeIdentifier {\n    // If this node has already been seen, return the cached result.\n    if (this.elementAndTemplateIdentifierCache.has(node)) {\n      return this.elementAndTemplateIdentifierCache.get(node)!;\n    }\n\n    let name: string;\n    let kind: IdentifierKind.Element|IdentifierKind.Template;\n    if (node instanceof TmplAstTemplate) {\n      name = node.tagName;\n      kind = IdentifierKind.Template;\n    } else {\n      name = node.name;\n      kind = IdentifierKind.Element;\n    }\n    const sourceSpan = node.startSourceSpan;\n    // An element's or template's source span can be of the form `<element>`, `<element />`, or\n    // `<element></element>`. Only the selector is interesting to the indexer, so the source is\n    // searched for the first occurrence of the element (selector) name.\n    const start = this.getStartLocation(name, sourceSpan);\n    const absoluteSpan = new AbsoluteSourceSpan(start, start + name.length);\n\n    // Record the nodes's attributes, which an indexer can later traverse to see if any of them\n    // specify a used directive on the node.\n    const attributes = node.attributes.map(({name, sourceSpan}): AttributeIdentifier => {\n      return {\n        name,\n        span: new AbsoluteSourceSpan(sourceSpan.start.offset, sourceSpan.end.offset),\n        kind: IdentifierKind.Attribute,\n      };\n    });\n    const usedDirectives = this.boundTemplate.getDirectivesOfNode(node) || [];\n\n    const identifier = {\n      name,\n      span: absoluteSpan,\n      kind,\n      attributes: new Set(attributes),\n      usedDirectives: new Set(usedDirectives.map(dir => {\n        return {\n          node: dir.ref.node,\n          selector: dir.selector,\n        };\n      })),\n      // cast b/c pre-TypeScript 3.5 unions aren't well discriminated\n    } as ElementIdentifier |\n        TemplateNodeIdentifier;\n\n    this.elementAndTemplateIdentifierCache.set(node, identifier);\n    return identifier;\n  }\n\n  /** Creates an identifier for a template reference or template variable target. */\n  private targetToIdentifier(node: TmplAstReference|TmplAstVariable): TargetIdentifier {\n    // If this node has already been seen, return the cached result.\n    if (this.targetIdentifierCache.has(node)) {\n      return this.targetIdentifierCache.get(node)!;\n    }\n\n    const {name, sourceSpan} = node;\n    const start = this.getStartLocation(name, sourceSpan);\n    const span = new AbsoluteSourceSpan(start, start + name.length);\n    let identifier: ReferenceIdentifier|VariableIdentifier;\n    if (node instanceof TmplAstReference) {\n      // If the node is a reference, we care about its target. The target can be an element, a\n      // template, a directive applied on a template or element (in which case the directive field\n      // is non-null), or nothing at all.\n      const refTarget = this.boundTemplate.getReferenceTarget(node);\n      let target = null;\n      if (refTarget) {\n        if (refTarget instanceof TmplAstElement || refTarget instanceof TmplAstTemplate) {\n          target = {\n            node: this.elementOrTemplateToIdentifier(refTarget),\n            directive: null,\n          };\n        } else {\n          target = {\n            node: this.elementOrTemplateToIdentifier(refTarget.node),\n            directive: refTarget.directive.ref.node,\n          };\n        }\n      }\n\n      identifier = {\n        name,\n        span,\n        kind: IdentifierKind.Reference,\n        target,\n      };\n    } else {\n      identifier = {\n        name,\n        span,\n        kind: IdentifierKind.Variable,\n      };\n    }\n\n    this.targetIdentifierCache.set(node, identifier);\n    return identifier;\n  }\n\n  /** Gets the start location of a string in a SourceSpan */\n  private getStartLocation(name: string, context: ParseSourceSpan): number {\n    const localStr = context.toString();\n    if (!localStr.includes(name)) {\n      throw new Error(`Impossible state: \"${name}\" not found in \"${localStr}\"`);\n    }\n    return context.start.offset + localStr.indexOf(name);\n  }\n\n  /**\n   * Visits a node's expression and adds its identifiers, if any, to the visitor's state.\n   * Only ASTs with information about the expression source and its location are visited.\n   *\n   * @param node node whose expression to visit\n   */\n  private visitExpression(ast: AST) {\n    // Only include ASTs that have information about their source and absolute source spans.\n    if (ast instanceof ASTWithSource && ast.source !== null) {\n      // Make target to identifier mapping closure stateful to this visitor instance.\n      const targetToIdentifier = this.targetToIdentifier.bind(this);\n      const absoluteOffset = ast.sourceSpan.start;\n      const identifiers = ExpressionVisitor.getIdentifiers(\n          ast, ast.source, absoluteOffset, this.boundTemplate, targetToIdentifier);\n      identifiers.forEach(id => this.identifiers.add(id));\n    }\n  }\n}\n\n/**\n * Traverses a template AST and builds identifiers discovered in it.\n *\n * @param boundTemplate bound template target, which can be used for querying expression targets.\n * @return identifiers in template\n */\nexport function getTemplateIdentifiers(boundTemplate: BoundTarget<ComponentMeta>):\n    Set<TopLevelIdentifier> {\n  const visitor = new TemplateVisitor(boundTemplate);\n  if (boundTemplate.target.template !== undefined) {\n    visitor.visitAll(boundTemplate.target.template);\n  }\n  return visitor.identifiers;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}