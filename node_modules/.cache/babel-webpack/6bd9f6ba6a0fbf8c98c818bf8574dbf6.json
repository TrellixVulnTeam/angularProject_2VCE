{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/scope/src/dependency\", [\"require\", \"exports\", \"tslib\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.MetadataDtsModuleScopeResolver = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * Reads Angular metadata from classes declared in .d.ts files and computes an `ExportScope`.\n   *\n   * Given an NgModule declared in a .d.ts file, this resolver can produce a transitive `ExportScope`\n   * of all of the directives/pipes it exports. It does this by reading metadata off of Ivy static\n   * fields on directives, components, pipes, and NgModules.\n   */\n\n\n  var MetadataDtsModuleScopeResolver =\n  /** @class */\n  function () {\n    /**\n     * @param dtsMetaReader a `MetadataReader` which can read metadata from `.d.ts` files.\n     */\n    function MetadataDtsModuleScopeResolver(dtsMetaReader, aliasingHost) {\n      this.dtsMetaReader = dtsMetaReader;\n      this.aliasingHost = aliasingHost;\n      /**\n       * Cache which holds fully resolved scopes for NgModule classes from .d.ts files.\n       */\n\n      this.cache = new Map();\n    }\n    /**\n     * Resolve a `Reference`'d NgModule from a .d.ts file and produce a transitive `ExportScope`\n     * listing the directives and pipes which that NgModule exports to others.\n     *\n     * This operation relies on a `Reference` instead of a direct TypeScrpt node as the `Reference`s\n     * produced depend on how the original NgModule was imported.\n     */\n\n\n    MetadataDtsModuleScopeResolver.prototype.resolve = function (ref) {\n      var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;\n\n      var clazz = ref.node;\n      var sourceFile = clazz.getSourceFile();\n\n      if (!sourceFile.isDeclarationFile) {\n        throw new Error(\"Debug error: DtsModuleScopeResolver.read(\" + ref.debugName + \" from \" + sourceFile.fileName + \"), but not a .d.ts file\");\n      }\n\n      if (this.cache.has(clazz)) {\n        return this.cache.get(clazz);\n      } // Build up the export scope - those directives and pipes made visible by this module.\n\n\n      var directives = [];\n      var pipes = [];\n      var ngModules = new Set([clazz]);\n      var meta = this.dtsMetaReader.getNgModuleMetadata(ref);\n\n      if (meta === null) {\n        this.cache.set(clazz, null);\n        return null;\n      }\n\n      var declarations = new Set();\n\n      try {\n        for (var _f = tslib_1.__values(meta.declarations), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var declRef = _g.value;\n          declarations.add(declRef.node);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_a = _f.return)) _a.call(_f);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      try {\n        // Only the 'exports' field of the NgModule's metadata is important. Imports and declarations\n        // don't affect the export scope.\n        for (var _h = tslib_1.__values(meta.exports), _j = _h.next(); !_j.done; _j = _h.next()) {\n          var exportRef = _j.value; // Attempt to process the export as a directive.\n\n          var directive = this.dtsMetaReader.getDirectiveMetadata(exportRef);\n\n          if (directive !== null) {\n            var isReExport = !declarations.has(exportRef.node);\n            directives.push(this.maybeAlias(directive, sourceFile, isReExport));\n            continue;\n          } // Attempt to process the export as a pipe.\n\n\n          var pipe = this.dtsMetaReader.getPipeMetadata(exportRef);\n\n          if (pipe !== null) {\n            var isReExport = !declarations.has(exportRef.node);\n            pipes.push(this.maybeAlias(pipe, sourceFile, isReExport));\n            continue;\n          } // Attempt to process the export as a module.\n\n\n          var exportScope_1 = this.resolve(exportRef);\n\n          if (exportScope_1 !== null) {\n            // It is a module. Add exported directives and pipes to the current scope. This might\n            // involve rewriting the `Reference`s to those types to have an alias expression if one is\n            // required.\n            if (this.aliasingHost === null) {\n              // Fast path when aliases aren't required.\n              directives.push.apply(directives, tslib_1.__spread(exportScope_1.exported.directives));\n              pipes.push.apply(pipes, tslib_1.__spread(exportScope_1.exported.pipes));\n            } else {\n              try {\n                // It's necessary to rewrite the `Reference`s to add alias expressions. This way, imports\n                // generated to these directives and pipes will use a shallow import to `sourceFile`\n                // instead of a deep import directly to the directive or pipe class.\n                //\n                // One important check here is whether the directive/pipe is declared in the same\n                // source file as the re-exporting NgModule. This can happen if both a directive, its\n                // NgModule, and the re-exporting NgModule are all in the same file. In this case,\n                // no import alias is needed as it would go to the same file anyway.\n                for (var _k = (e_3 = void 0, tslib_1.__values(exportScope_1.exported.directives)), _l = _k.next(); !_l.done; _l = _k.next()) {\n                  var directive_1 = _l.value;\n                  directives.push(this.maybeAlias(directive_1, sourceFile,\n                  /* isReExport */\n                  true));\n                }\n              } catch (e_3_1) {\n                e_3 = {\n                  error: e_3_1\n                };\n              } finally {\n                try {\n                  if (_l && !_l.done && (_c = _k.return)) _c.call(_k);\n                } finally {\n                  if (e_3) throw e_3.error;\n                }\n              }\n\n              try {\n                for (var _m = (e_4 = void 0, tslib_1.__values(exportScope_1.exported.pipes)), _o = _m.next(); !_o.done; _o = _m.next()) {\n                  var pipe_1 = _o.value;\n                  pipes.push(this.maybeAlias(pipe_1, sourceFile,\n                  /* isReExport */\n                  true));\n                }\n              } catch (e_4_1) {\n                e_4 = {\n                  error: e_4_1\n                };\n              } finally {\n                try {\n                  if (_o && !_o.done && (_d = _m.return)) _d.call(_m);\n                } finally {\n                  if (e_4) throw e_4.error;\n                }\n              }\n\n              try {\n                for (var _p = (e_5 = void 0, tslib_1.__values(exportScope_1.exported.ngModules)), _q = _p.next(); !_q.done; _q = _p.next()) {\n                  var ngModule = _q.value;\n                  ngModules.add(ngModule);\n                }\n              } catch (e_5_1) {\n                e_5 = {\n                  error: e_5_1\n                };\n              } finally {\n                try {\n                  if (_q && !_q.done && (_e = _p.return)) _e.call(_p);\n                } finally {\n                  if (e_5) throw e_5.error;\n                }\n              }\n            }\n          }\n\n          continue; // The export was not a directive, a pipe, or a module. This is an error.\n          // TODO(alxhub): produce a ts.Diagnostic\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_j && !_j.done && (_b = _h.return)) _b.call(_h);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      var exportScope = {\n        exported: {\n          directives: directives,\n          pipes: pipes,\n          ngModules: Array.from(ngModules),\n          isPoisoned: false\n        }\n      };\n      this.cache.set(clazz, exportScope);\n      return exportScope;\n    };\n\n    MetadataDtsModuleScopeResolver.prototype.maybeAlias = function (dirOrPipe, maybeAliasFrom, isReExport) {\n      var ref = dirOrPipe.ref;\n\n      if (this.aliasingHost === null || ref.node.getSourceFile() === maybeAliasFrom) {\n        return dirOrPipe;\n      }\n\n      var alias = this.aliasingHost.getAliasIn(ref.node, maybeAliasFrom, isReExport);\n\n      if (alias === null) {\n        return dirOrPipe;\n      }\n\n      return tslib_1.__assign(tslib_1.__assign({}, dirOrPipe), {\n        ref: ref.cloneWithAlias(alias)\n      });\n    };\n\n    return MetadataDtsModuleScopeResolver;\n  }();\n\n  exports.MetadataDtsModuleScopeResolver = MetadataDtsModuleScopeResolver;\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/scope/src/dependency.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {AliasingHost, Reference} from '../../imports';\nimport {DirectiveMeta, MetadataReader, PipeMeta} from '../../metadata';\nimport {ClassDeclaration} from '../../reflection';\n\nimport {ExportScope} from './api';\n\nexport interface DtsModuleScopeResolver {\n  resolve(ref: Reference<ClassDeclaration>): ExportScope|null;\n}\n\n/**\n * Reads Angular metadata from classes declared in .d.ts files and computes an `ExportScope`.\n *\n * Given an NgModule declared in a .d.ts file, this resolver can produce a transitive `ExportScope`\n * of all of the directives/pipes it exports. It does this by reading metadata off of Ivy static\n * fields on directives, components, pipes, and NgModules.\n */\nexport class MetadataDtsModuleScopeResolver implements DtsModuleScopeResolver {\n  /**\n   * Cache which holds fully resolved scopes for NgModule classes from .d.ts files.\n   */\n  private cache = new Map<ClassDeclaration, ExportScope|null>();\n\n  /**\n   * @param dtsMetaReader a `MetadataReader` which can read metadata from `.d.ts` files.\n   */\n  constructor(private dtsMetaReader: MetadataReader, private aliasingHost: AliasingHost|null) {}\n\n  /**\n   * Resolve a `Reference`'d NgModule from a .d.ts file and produce a transitive `ExportScope`\n   * listing the directives and pipes which that NgModule exports to others.\n   *\n   * This operation relies on a `Reference` instead of a direct TypeScrpt node as the `Reference`s\n   * produced depend on how the original NgModule was imported.\n   */\n  resolve(ref: Reference<ClassDeclaration>): ExportScope|null {\n    const clazz = ref.node;\n    const sourceFile = clazz.getSourceFile();\n    if (!sourceFile.isDeclarationFile) {\n      throw new Error(`Debug error: DtsModuleScopeResolver.read(${ref.debugName} from ${\n          sourceFile.fileName}), but not a .d.ts file`);\n    }\n\n    if (this.cache.has(clazz)) {\n      return this.cache.get(clazz)!;\n    }\n\n    // Build up the export scope - those directives and pipes made visible by this module.\n    const directives: DirectiveMeta[] = [];\n    const pipes: PipeMeta[] = [];\n    const ngModules = new Set<ClassDeclaration>([clazz]);\n\n    const meta = this.dtsMetaReader.getNgModuleMetadata(ref);\n    if (meta === null) {\n      this.cache.set(clazz, null);\n      return null;\n    }\n\n    const declarations = new Set<ClassDeclaration>();\n    for (const declRef of meta.declarations) {\n      declarations.add(declRef.node);\n    }\n\n    // Only the 'exports' field of the NgModule's metadata is important. Imports and declarations\n    // don't affect the export scope.\n    for (const exportRef of meta.exports) {\n      // Attempt to process the export as a directive.\n      const directive = this.dtsMetaReader.getDirectiveMetadata(exportRef);\n      if (directive !== null) {\n        const isReExport = !declarations.has(exportRef.node);\n        directives.push(this.maybeAlias(directive, sourceFile, isReExport));\n        continue;\n      }\n\n      // Attempt to process the export as a pipe.\n      const pipe = this.dtsMetaReader.getPipeMetadata(exportRef);\n      if (pipe !== null) {\n        const isReExport = !declarations.has(exportRef.node);\n        pipes.push(this.maybeAlias(pipe, sourceFile, isReExport));\n        continue;\n      }\n\n      // Attempt to process the export as a module.\n      const exportScope = this.resolve(exportRef);\n      if (exportScope !== null) {\n        // It is a module. Add exported directives and pipes to the current scope. This might\n        // involve rewriting the `Reference`s to those types to have an alias expression if one is\n        // required.\n        if (this.aliasingHost === null) {\n          // Fast path when aliases aren't required.\n          directives.push(...exportScope.exported.directives);\n          pipes.push(...exportScope.exported.pipes);\n        } else {\n          // It's necessary to rewrite the `Reference`s to add alias expressions. This way, imports\n          // generated to these directives and pipes will use a shallow import to `sourceFile`\n          // instead of a deep import directly to the directive or pipe class.\n          //\n          // One important check here is whether the directive/pipe is declared in the same\n          // source file as the re-exporting NgModule. This can happen if both a directive, its\n          // NgModule, and the re-exporting NgModule are all in the same file. In this case,\n          // no import alias is needed as it would go to the same file anyway.\n          for (const directive of exportScope.exported.directives) {\n            directives.push(this.maybeAlias(directive, sourceFile, /* isReExport */ true));\n          }\n          for (const pipe of exportScope.exported.pipes) {\n            pipes.push(this.maybeAlias(pipe, sourceFile, /* isReExport */ true));\n          }\n          for (const ngModule of exportScope.exported.ngModules) {\n            ngModules.add(ngModule);\n          }\n        }\n      }\n      continue;\n\n      // The export was not a directive, a pipe, or a module. This is an error.\n      // TODO(alxhub): produce a ts.Diagnostic\n    }\n\n    const exportScope: ExportScope = {\n      exported: {\n        directives,\n        pipes,\n        ngModules: Array.from(ngModules),\n        isPoisoned: false,\n      },\n    };\n    this.cache.set(clazz, exportScope);\n    return exportScope;\n  }\n\n  private maybeAlias<T extends DirectiveMeta|PipeMeta>(\n      dirOrPipe: T, maybeAliasFrom: ts.SourceFile, isReExport: boolean): T {\n    const ref = dirOrPipe.ref;\n    if (this.aliasingHost === null || ref.node.getSourceFile() === maybeAliasFrom) {\n      return dirOrPipe;\n    }\n\n    const alias = this.aliasingHost.getAliasIn(ref.node, maybeAliasFrom, isReExport);\n    if (alias === null) {\n      return dirOrPipe;\n    }\n\n    return {\n      ...dirOrPipe,\n      ref: ref.cloneWithAlias(alias),\n    };\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}