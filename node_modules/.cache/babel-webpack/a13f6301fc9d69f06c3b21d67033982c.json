{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/cycles/src/imports\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/perf\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ImportGraph = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n  /**\n   * A cached graph of imports in the `ts.Program`.\n   *\n   * The `ImportGraph` keeps track of dependencies (imports) of individual `ts.SourceFile`s. Only\n   * dependencies within the same program are tracked; imports into packages on NPM are not.\n   */\n\n\n  var ImportGraph =\n  /** @class */\n  function () {\n    function ImportGraph(checker, perf) {\n      this.checker = checker;\n      this.perf = perf;\n      this.map = new Map();\n    }\n    /**\n     * List the direct (not transitive) imports of a given `ts.SourceFile`.\n     *\n     * This operation is cached.\n     */\n\n\n    ImportGraph.prototype.importsOf = function (sf) {\n      if (!this.map.has(sf)) {\n        this.map.set(sf, this.scanImports(sf));\n      }\n\n      return this.map.get(sf);\n    };\n    /**\n     * Lists the transitive imports of a given `ts.SourceFile`.\n     */\n\n\n    ImportGraph.prototype.transitiveImportsOf = function (sf) {\n      var imports = new Set();\n      this.transitiveImportsOfHelper(sf, imports);\n      return imports;\n    };\n\n    ImportGraph.prototype.transitiveImportsOfHelper = function (sf, results) {\n      var _this = this;\n\n      if (results.has(sf)) {\n        return;\n      }\n\n      results.add(sf);\n      this.importsOf(sf).forEach(function (imported) {\n        _this.transitiveImportsOfHelper(imported, results);\n      });\n    };\n    /**\n     * Find an import path from the `start` SourceFile to the `end` SourceFile.\n     *\n     * This function implements a breadth first search that results in finding the\n     * shortest path between the `start` and `end` points.\n     *\n     * @param start the starting point of the path.\n     * @param end the ending point of the path.\n     * @returns an array of source files that connect the `start` and `end` source files, or `null` if\n     *     no path could be found.\n     */\n\n\n    ImportGraph.prototype.findPath = function (start, end) {\n      var e_1, _a;\n\n      if (start === end) {\n        // Escape early for the case where `start` and `end` are the same.\n        return [start];\n      }\n\n      var found = new Set([start]);\n      var queue = [new Found(start, null)];\n\n      while (queue.length > 0) {\n        var current = queue.shift();\n        var imports = this.importsOf(current.sourceFile);\n\n        try {\n          for (var imports_1 = (e_1 = void 0, tslib_1.__values(imports)), imports_1_1 = imports_1.next(); !imports_1_1.done; imports_1_1 = imports_1.next()) {\n            var importedFile = imports_1_1.value;\n\n            if (!found.has(importedFile)) {\n              var next = new Found(importedFile, current);\n\n              if (next.sourceFile === end) {\n                // We have hit the target `end` path so we can stop here.\n                return next.toPath();\n              }\n\n              found.add(importedFile);\n              queue.push(next);\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (imports_1_1 && !imports_1_1.done && (_a = imports_1.return)) _a.call(imports_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Add a record of an import from `sf` to `imported`, that's not present in the original\n     * `ts.Program` but will be remembered by the `ImportGraph`.\n     */\n\n\n    ImportGraph.prototype.addSyntheticImport = function (sf, imported) {\n      if (isLocalFile(imported)) {\n        this.importsOf(sf).add(imported);\n      }\n    };\n\n    ImportGraph.prototype.scanImports = function (sf) {\n      var _this = this;\n\n      return this.perf.inPhase(perf_1.PerfPhase.CycleDetection, function () {\n        var e_2, _a;\n\n        var imports = new Set();\n\n        try {\n          // Look through the source file for import and export statements.\n          for (var _b = tslib_1.__values(sf.statements), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var stmt = _c.value;\n\n            if (!ts.isImportDeclaration(stmt) && !ts.isExportDeclaration(stmt) || stmt.moduleSpecifier === undefined) {\n              continue;\n            }\n\n            var symbol = _this.checker.getSymbolAtLocation(stmt.moduleSpecifier);\n\n            if (symbol === undefined || symbol.valueDeclaration === undefined) {\n              // No symbol could be found to skip over this import/export.\n              continue;\n            }\n\n            var moduleFile = symbol.valueDeclaration;\n\n            if (ts.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {\n              // Record this local import.\n              imports.add(moduleFile);\n            }\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n\n        return imports;\n      });\n    };\n\n    return ImportGraph;\n  }();\n\n  exports.ImportGraph = ImportGraph;\n\n  function isLocalFile(sf) {\n    return !sf.isDeclarationFile;\n  }\n  /**\n   * A helper class to track which SourceFiles are being processed when searching for a path in\n   * `getPath()` above.\n   */\n\n\n  var Found =\n  /** @class */\n  function () {\n    function Found(sourceFile, parent) {\n      this.sourceFile = sourceFile;\n      this.parent = parent;\n    }\n    /**\n     * Back track through this found SourceFile and its ancestors to generate an array of\n     * SourceFiles that form am import path between two SourceFiles.\n     */\n\n\n    Found.prototype.toPath = function () {\n      var array = [];\n      var current = this;\n\n      while (current !== null) {\n        array.push(current.sourceFile);\n        current = current.parent;\n      } // Pushing and then reversing, O(n), rather than unshifting repeatedly, O(n^2), avoids\n      // manipulating the array on every iteration: https://stackoverflow.com/a/26370620\n\n\n      return array.reverse();\n    };\n\n    return Found;\n  }();\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/cycles/src/imports.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {PerfPhase, PerfRecorder} from '../../perf';\n\n/**\n * A cached graph of imports in the `ts.Program`.\n *\n * The `ImportGraph` keeps track of dependencies (imports) of individual `ts.SourceFile`s. Only\n * dependencies within the same program are tracked; imports into packages on NPM are not.\n */\nexport class ImportGraph {\n  private map = new Map<ts.SourceFile, Set<ts.SourceFile>>();\n\n  constructor(private checker: ts.TypeChecker, private perf: PerfRecorder) {}\n\n  /**\n   * List the direct (not transitive) imports of a given `ts.SourceFile`.\n   *\n   * This operation is cached.\n   */\n  importsOf(sf: ts.SourceFile): Set<ts.SourceFile> {\n    if (!this.map.has(sf)) {\n      this.map.set(sf, this.scanImports(sf));\n    }\n    return this.map.get(sf)!;\n  }\n\n  /**\n   * Lists the transitive imports of a given `ts.SourceFile`.\n   */\n  transitiveImportsOf(sf: ts.SourceFile): Set<ts.SourceFile> {\n    const imports = new Set<ts.SourceFile>();\n    this.transitiveImportsOfHelper(sf, imports);\n    return imports;\n  }\n\n  private transitiveImportsOfHelper(sf: ts.SourceFile, results: Set<ts.SourceFile>): void {\n    if (results.has(sf)) {\n      return;\n    }\n    results.add(sf);\n    this.importsOf(sf).forEach(imported => {\n      this.transitiveImportsOfHelper(imported, results);\n    });\n  }\n\n  /**\n   * Find an import path from the `start` SourceFile to the `end` SourceFile.\n   *\n   * This function implements a breadth first search that results in finding the\n   * shortest path between the `start` and `end` points.\n   *\n   * @param start the starting point of the path.\n   * @param end the ending point of the path.\n   * @returns an array of source files that connect the `start` and `end` source files, or `null` if\n   *     no path could be found.\n   */\n  findPath(start: ts.SourceFile, end: ts.SourceFile): ts.SourceFile[]|null {\n    if (start === end) {\n      // Escape early for the case where `start` and `end` are the same.\n      return [start];\n    }\n\n    const found = new Set<ts.SourceFile>([start]);\n    const queue: Found[] = [new Found(start, null)];\n\n    while (queue.length > 0) {\n      const current = queue.shift()!;\n      const imports = this.importsOf(current.sourceFile);\n      for (const importedFile of imports) {\n        if (!found.has(importedFile)) {\n          const next = new Found(importedFile, current);\n          if (next.sourceFile === end) {\n            // We have hit the target `end` path so we can stop here.\n            return next.toPath();\n          }\n          found.add(importedFile);\n          queue.push(next);\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Add a record of an import from `sf` to `imported`, that's not present in the original\n   * `ts.Program` but will be remembered by the `ImportGraph`.\n   */\n  addSyntheticImport(sf: ts.SourceFile, imported: ts.SourceFile): void {\n    if (isLocalFile(imported)) {\n      this.importsOf(sf).add(imported);\n    }\n  }\n\n  private scanImports(sf: ts.SourceFile): Set<ts.SourceFile> {\n    return this.perf.inPhase(PerfPhase.CycleDetection, () => {\n      const imports = new Set<ts.SourceFile>();\n      // Look through the source file for import and export statements.\n      for (const stmt of sf.statements) {\n        if ((!ts.isImportDeclaration(stmt) && !ts.isExportDeclaration(stmt)) ||\n            stmt.moduleSpecifier === undefined) {\n          continue;\n        }\n\n        const symbol = this.checker.getSymbolAtLocation(stmt.moduleSpecifier);\n        if (symbol === undefined || symbol.valueDeclaration === undefined) {\n          // No symbol could be found to skip over this import/export.\n          continue;\n        }\n        const moduleFile = symbol.valueDeclaration;\n        if (ts.isSourceFile(moduleFile) && isLocalFile(moduleFile)) {\n          // Record this local import.\n          imports.add(moduleFile);\n        }\n      }\n      return imports;\n    });\n  }\n}\n\nfunction isLocalFile(sf: ts.SourceFile): boolean {\n  return !sf.isDeclarationFile;\n}\n\n/**\n * A helper class to track which SourceFiles are being processed when searching for a path in\n * `getPath()` above.\n */\nclass Found {\n  constructor(readonly sourceFile: ts.SourceFile, readonly parent: Found|null) {}\n\n  /**\n   * Back track through this found SourceFile and its ancestors to generate an array of\n   * SourceFiles that form am import path between two SourceFiles.\n   */\n  toPath(): ts.SourceFile[] {\n    const array: ts.SourceFile[] = [];\n    let current: Found|null = this;\n    while (current !== null) {\n      array.push(current.sourceFile);\n      current = current.parent;\n    }\n    // Pushing and then reversing, O(n), rather than unshifting repeatedly, O(n^2), avoids\n    // manipulating the array on every iteration: https://stackoverflow.com/a/26370620\n    return array.reverse();\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}