{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/i18n/big_integer\", [\"require\", \"exports\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.BigIntExponentiation = exports.BigIntForMultiplication = exports.BigInteger = void 0;\n  /**\n   * Represents a big integer using a buffer of its individual digits, with the least significant\n   * digit stored at the beginning of the array (little endian).\n   *\n   * For performance reasons, each instance is mutable. The addition operation can be done in-place\n   * to reduce memory pressure of allocation for the digits array.\n   */\n\n  var BigInteger =\n  /** @class */\n  function () {\n    /**\n     * Creates a big integer using its individual digits in little endian storage.\n     */\n    function BigInteger(digits) {\n      this.digits = digits;\n    }\n\n    BigInteger.zero = function () {\n      return new BigInteger([0]);\n    };\n\n    BigInteger.one = function () {\n      return new BigInteger([1]);\n    };\n    /**\n     * Creates a clone of this instance.\n     */\n\n\n    BigInteger.prototype.clone = function () {\n      return new BigInteger(this.digits.slice());\n    };\n    /**\n     * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n     * `this` but instead returns a new instance, unlike `addToSelf`.\n     */\n\n\n    BigInteger.prototype.add = function (other) {\n      var result = this.clone();\n      result.addToSelf(other);\n      return result;\n    };\n    /**\n     * Adds `other` to the instance itself, thereby mutating its value.\n     */\n\n\n    BigInteger.prototype.addToSelf = function (other) {\n      var maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n      var carry = 0;\n\n      for (var i = 0; i < maxNrOfDigits; i++) {\n        var digitSum = carry;\n\n        if (i < this.digits.length) {\n          digitSum += this.digits[i];\n        }\n\n        if (i < other.digits.length) {\n          digitSum += other.digits[i];\n        }\n\n        if (digitSum >= 10) {\n          this.digits[i] = digitSum - 10;\n          carry = 1;\n        } else {\n          this.digits[i] = digitSum;\n          carry = 0;\n        }\n      } // Apply a remaining carry if needed.\n\n\n      if (carry > 0) {\n        this.digits[maxNrOfDigits] = 1;\n      }\n    };\n    /**\n     * Builds the decimal string representation of the big integer. As this is stored in\n     * little endian, the digits are concatenated in reverse order.\n     */\n\n\n    BigInteger.prototype.toString = function () {\n      var res = '';\n\n      for (var i = this.digits.length - 1; i >= 0; i--) {\n        res += this.digits[i];\n      }\n\n      return res;\n    };\n\n    return BigInteger;\n  }();\n\n  exports.BigInteger = BigInteger;\n  /**\n   * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n   * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n   */\n\n  var BigIntForMultiplication =\n  /** @class */\n  function () {\n    function BigIntForMultiplication(value) {\n      this.powerOfTwos = [value];\n    }\n    /**\n     * Returns the big integer itself.\n     */\n\n\n    BigIntForMultiplication.prototype.getValue = function () {\n      return this.powerOfTwos[0];\n    };\n    /**\n     * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n     * value for `b` is represented by a storage model that is optimized for this computation.\n     *\n     * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n     * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n     * used as exponent into the power-of-two multiplication of `b`.\n     *\n     * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n     * algorithm unrolls into the following iterations:\n     *\n     *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n     * -----------|------------|------|------------|------|--------\n     *  0         | 0b00101010 | 0    | 1337       | No   | 0\n     *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n     *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n     *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n     *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n     *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n     *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n     *\n     * The computed product of 56154 is indeed the correct result.\n     *\n     * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n     * power-of-two values to reduce the workload in computing those values.\n     */\n\n\n    BigIntForMultiplication.prototype.multiplyBy = function (num) {\n      var product = BigInteger.zero();\n      this.multiplyByAndAddTo(num, product);\n      return product;\n    };\n    /**\n     * See `multiplyBy()` for details. This function allows for the computed product to be added\n     * directly to the provided result big integer.\n     */\n\n\n    BigIntForMultiplication.prototype.multiplyByAndAddTo = function (num, result) {\n      for (var exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n        if (num & 1) {\n          var value = this.getMultipliedByPowerOfTwo(exponent);\n          result.addToSelf(value);\n        }\n      }\n    };\n    /**\n     * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n     */\n\n\n    BigIntForMultiplication.prototype.getMultipliedByPowerOfTwo = function (exponent) {\n      // Compute the powers up until the requested exponent, where each value is computed from its\n      // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n      // added to itself) to reach `this.number * 2^exponent`.\n      for (var i = this.powerOfTwos.length; i <= exponent; i++) {\n        var previousPower = this.powerOfTwos[i - 1];\n        this.powerOfTwos[i] = previousPower.add(previousPower);\n      }\n\n      return this.powerOfTwos[exponent];\n    };\n\n    return BigIntForMultiplication;\n  }();\n\n  exports.BigIntForMultiplication = BigIntForMultiplication;\n  /**\n   * Represents an exponentiation operation for the provided base, of which exponents are computed and\n   * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n   * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n   * representation that is lazily computed upon request.\n   */\n\n  var BigIntExponentiation =\n  /** @class */\n  function () {\n    function BigIntExponentiation(base) {\n      this.base = base;\n      this.exponents = [new BigIntForMultiplication(BigInteger.one())];\n    }\n    /**\n     * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n     * further multiplication operations.\n     */\n\n\n    BigIntExponentiation.prototype.toThePowerOf = function (exponent) {\n      // Compute the results up until the requested exponent, where every value is computed from its\n      // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n      // to reach `this.base^exponent`.\n      for (var i = this.exponents.length; i <= exponent; i++) {\n        var value = this.exponents[i - 1].multiplyBy(this.base);\n        this.exponents[i] = new BigIntForMultiplication(value);\n      }\n\n      return this.exponents[exponent];\n    };\n\n    return BigIntExponentiation;\n  }();\n\n  exports.BigIntExponentiation = BigIntExponentiation;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/i18n/big_integer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nexport class BigInteger {\n  static zero(): BigInteger {\n    return new BigInteger([0]);\n  }\n\n  static one(): BigInteger {\n    return new BigInteger([1]);\n  }\n\n  /**\n   * Creates a big integer using its individual digits in little endian storage.\n   */\n  private constructor(private readonly digits: number[]) {}\n\n  /**\n   * Creates a clone of this instance.\n   */\n  clone(): BigInteger {\n    return new BigInteger(this.digits.slice());\n  }\n\n  /**\n   * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n   * `this` but instead returns a new instance, unlike `addToSelf`.\n   */\n  add(other: BigInteger): BigInteger {\n    const result = this.clone();\n    result.addToSelf(other);\n    return result;\n  }\n\n  /**\n   * Adds `other` to the instance itself, thereby mutating its value.\n   */\n  addToSelf(other: BigInteger): void {\n    const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n    let carry = 0;\n    for (let i = 0; i < maxNrOfDigits; i++) {\n      let digitSum = carry;\n      if (i < this.digits.length) {\n        digitSum += this.digits[i];\n      }\n      if (i < other.digits.length) {\n        digitSum += other.digits[i];\n      }\n\n      if (digitSum >= 10) {\n        this.digits[i] = digitSum - 10;\n        carry = 1;\n      } else {\n        this.digits[i] = digitSum;\n        carry = 0;\n      }\n    }\n\n    // Apply a remaining carry if needed.\n    if (carry > 0) {\n      this.digits[maxNrOfDigits] = 1;\n    }\n  }\n\n  /**\n   * Builds the decimal string representation of the big integer. As this is stored in\n   * little endian, the digits are concatenated in reverse order.\n   */\n  toString(): string {\n    let res = '';\n    for (let i = this.digits.length - 1; i >= 0; i--) {\n      res += this.digits[i];\n    }\n    return res;\n  }\n}\n\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nexport class BigIntForMultiplication {\n  /**\n   * Stores all memoized power-of-twos, where each index represents `this.number * 2^index`.\n   */\n  private readonly powerOfTwos: BigInteger[];\n\n  constructor(value: BigInteger) {\n    this.powerOfTwos = [value];\n  }\n\n  /**\n   * Returns the big integer itself.\n   */\n  getValue(): BigInteger {\n    return this.powerOfTwos[0];\n  }\n\n  /**\n   * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n   * value for `b` is represented by a storage model that is optimized for this computation.\n   *\n   * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n   * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n   * used as exponent into the power-of-two multiplication of `b`.\n   *\n   * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n   * algorithm unrolls into the following iterations:\n   *\n   *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n   * -----------|------------|------|------------|------|--------\n   *  0         | 0b00101010 | 0    | 1337       | No   | 0\n   *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n   *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n   *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n   *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n   *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n   *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n   *\n   * The computed product of 56154 is indeed the correct result.\n   *\n   * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n   * power-of-two values to reduce the workload in computing those values.\n   */\n  multiplyBy(num: number): BigInteger {\n    const product = BigInteger.zero();\n    this.multiplyByAndAddTo(num, product);\n    return product;\n  }\n\n  /**\n   * See `multiplyBy()` for details. This function allows for the computed product to be added\n   * directly to the provided result big integer.\n   */\n  multiplyByAndAddTo(num: number, result: BigInteger): void {\n    for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n      if (num & 1) {\n        const value = this.getMultipliedByPowerOfTwo(exponent);\n        result.addToSelf(value);\n      }\n    }\n  }\n\n  /**\n   * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n   */\n  private getMultipliedByPowerOfTwo(exponent: number): BigInteger {\n    // Compute the powers up until the requested exponent, where each value is computed from its\n    // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n    // added to itself) to reach `this.number * 2^exponent`.\n    for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n      const previousPower = this.powerOfTwos[i - 1];\n      this.powerOfTwos[i] = previousPower.add(previousPower);\n    }\n    return this.powerOfTwos[exponent];\n  }\n}\n\n/**\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n * representation that is lazily computed upon request.\n */\nexport class BigIntExponentiation {\n  private readonly exponents = [new BigIntForMultiplication(BigInteger.one())];\n\n  constructor(private readonly base: number) {}\n\n  /**\n   * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n   * further multiplication operations.\n   */\n  toThePowerOf(exponent: number): BigIntForMultiplication {\n    // Compute the results up until the requested exponent, where every value is computed from its\n    // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n    // to reach `this.base^exponent`.\n    for (let i = this.exponents.length; i <= exponent; i++) {\n      const value = this.exponents[i - 1].multiplyBy(this.base);\n      this.exponents[i] = new BigIntForMultiplication(value);\n    }\n    return this.exponents[exponent];\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}