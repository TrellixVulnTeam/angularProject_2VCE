{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/shims/src/summary_generator\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/shims/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.SummaryGenerator = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var ts = require(\"typescript\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/shims/src/util\");\n\n  var SummaryGenerator =\n  /** @class */\n  function () {\n    function SummaryGenerator() {\n      this.shouldEmit = true;\n      this.extensionPrefix = 'ngsummary';\n    }\n\n    SummaryGenerator.prototype.generateShimForFile = function (sf, genFilePath) {\n      var e_1, _a, e_2, _b; // Collect a list of classes that need to have factory types emitted for them. This list is\n      // overly broad as at this point the ts.TypeChecker has not been created and so it can't be used\n      // to semantically understand which decorators are Angular decorators. It's okay to output an\n      // overly broad set of summary exports as the exports are no-ops anyway, and summaries are a\n      // compatibility layer which will be removed after Ivy is enabled.\n\n\n      var symbolNames = [];\n\n      try {\n        for (var _c = tslib_1.__values(sf.statements), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var stmt = _d.value;\n\n          if (ts.isClassDeclaration(stmt)) {\n            // If the class isn't exported, or if it's not decorated, then skip it.\n            if (!isExported(stmt) || stmt.decorators === undefined || stmt.name === undefined) {\n              continue;\n            }\n\n            symbolNames.push(stmt.name.text);\n          } else if (ts.isExportDeclaration(stmt)) {\n            // Look for an export statement of the form \"export {...};\". If it doesn't match that, then\n            // skip it.\n            if (stmt.exportClause === undefined || stmt.moduleSpecifier !== undefined || !ts.isNamedExports(stmt.exportClause)) {\n              continue;\n            }\n\n            try {\n              for (var _e = (e_2 = void 0, tslib_1.__values(stmt.exportClause.elements)), _f = _e.next(); !_f.done; _f = _e.next()) {\n                var specifier = _f.value; // At this point, there is no guarantee that specifier here refers to a class declaration,\n                // but that's okay.\n                // Use specifier.name as that's guaranteed to be the exported name, regardless of whether\n                // specifier.propertyName is set.\n\n                symbolNames.push(specifier.name.text);\n              }\n            } catch (e_2_1) {\n              e_2 = {\n                error: e_2_1\n              };\n            } finally {\n              try {\n                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n              } finally {\n                if (e_2) throw e_2.error;\n              }\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      var varLines = symbolNames.map(function (name) {\n        return \"export const \" + name + \"NgSummary: any = null;\";\n      });\n\n      if (varLines.length === 0) {\n        // In the event there are no other exports, add an empty export to ensure the generated\n        // summary file is still an ES module.\n        varLines.push(\"export const \\u0275empty = null;\");\n      }\n\n      var sourceText = varLines.join('\\n');\n      var genFile = ts.createSourceFile(genFilePath, sourceText, sf.languageVersion, true, ts.ScriptKind.TS);\n\n      if (sf.moduleName !== undefined) {\n        genFile.moduleName = util_1.generatedModuleName(sf.moduleName, sf.fileName, '.ngsummary');\n      }\n\n      return genFile;\n    };\n\n    return SummaryGenerator;\n  }();\n\n  exports.SummaryGenerator = SummaryGenerator;\n\n  function isExported(decl) {\n    return decl.modifiers !== undefined && decl.modifiers.some(function (mod) {\n      return mod.kind == ts.SyntaxKind.ExportKeyword;\n    });\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/shims/src/summary_generator.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ts from 'typescript';\n\nimport {AbsoluteFsPath} from '../../file_system';\nimport {PerFileShimGenerator} from '../api';\n\nimport {generatedModuleName} from './util';\n\nexport class SummaryGenerator implements PerFileShimGenerator {\n  readonly shouldEmit = true;\n  readonly extensionPrefix = 'ngsummary';\n\n  generateShimForFile(sf: ts.SourceFile, genFilePath: AbsoluteFsPath): ts.SourceFile {\n    // Collect a list of classes that need to have factory types emitted for them. This list is\n    // overly broad as at this point the ts.TypeChecker has not been created and so it can't be used\n    // to semantically understand which decorators are Angular decorators. It's okay to output an\n    // overly broad set of summary exports as the exports are no-ops anyway, and summaries are a\n    // compatibility layer which will be removed after Ivy is enabled.\n    const symbolNames: string[] = [];\n    for (const stmt of sf.statements) {\n      if (ts.isClassDeclaration(stmt)) {\n        // If the class isn't exported, or if it's not decorated, then skip it.\n        if (!isExported(stmt) || stmt.decorators === undefined || stmt.name === undefined) {\n          continue;\n        }\n        symbolNames.push(stmt.name.text);\n      } else if (ts.isExportDeclaration(stmt)) {\n        // Look for an export statement of the form \"export {...};\". If it doesn't match that, then\n        // skip it.\n        if (stmt.exportClause === undefined || stmt.moduleSpecifier !== undefined ||\n            !ts.isNamedExports(stmt.exportClause)) {\n          continue;\n        }\n\n        for (const specifier of stmt.exportClause.elements) {\n          // At this point, there is no guarantee that specifier here refers to a class declaration,\n          // but that's okay.\n\n          // Use specifier.name as that's guaranteed to be the exported name, regardless of whether\n          // specifier.propertyName is set.\n          symbolNames.push(specifier.name.text);\n        }\n      }\n    }\n\n    const varLines = symbolNames.map(name => `export const ${name}NgSummary: any = null;`);\n\n    if (varLines.length === 0) {\n      // In the event there are no other exports, add an empty export to ensure the generated\n      // summary file is still an ES module.\n      varLines.push(`export const Éµempty = null;`);\n    }\n    const sourceText = varLines.join('\\n');\n    const genFile =\n        ts.createSourceFile(genFilePath, sourceText, sf.languageVersion, true, ts.ScriptKind.TS);\n    if (sf.moduleName !== undefined) {\n      genFile.moduleName = generatedModuleName(sf.moduleName, sf.fileName, '.ngsummary');\n    }\n    return genFile;\n  }\n}\n\nfunction isExported(decl: ts.Declaration): boolean {\n  return decl.modifiers !== undefined &&\n      decl.modifiers.some(mod => mod.kind == ts.SyntaxKind.ExportKeyword);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}