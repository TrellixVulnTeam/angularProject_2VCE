{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar index = require('./lib/entry-index');\n\nvar memo = require('./lib/memoization');\n\nvar write = require('./lib/content/write');\n\nvar Flush = require('minipass-flush');\n\nvar _require = require('minipass-collect'),\n    PassThrough = _require.PassThrough;\n\nvar Pipeline = require('minipass-pipeline');\n\nvar putOpts = function putOpts(opts) {\n  return _objectSpread({\n    algorithms: ['sha512']\n  }, opts);\n};\n\nmodule.exports = putData;\n\nfunction putData(cache, key, data) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _opts = opts,\n      memoize = _opts.memoize;\n  opts = putOpts(opts);\n  return write(cache, data, opts).then(function (res) {\n    return index.insert(cache, key, res.integrity, _objectSpread(_objectSpread({}, opts), {}, {\n      size: res.size\n    })).then(function (entry) {\n      if (memoize) memo.put(cache, entry, data, opts);\n      return res.integrity;\n    });\n  });\n}\n\nmodule.exports.stream = putStream;\n\nfunction putStream(cache, key) {\n  var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _opts2 = opts,\n      memoize = _opts2.memoize;\n  opts = putOpts(opts);\n  var integrity;\n  var size;\n  var memoData;\n  var pipeline = new Pipeline(); // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n\n  if (memoize) {\n    var memoizer = new PassThrough().on('collect', function (data) {\n      memoData = data;\n    });\n    pipeline.push(memoizer);\n  } // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n\n\n  var contentStream = write.stream(cache, opts).on('integrity', function (int) {\n    integrity = int;\n  }).on('size', function (s) {\n    size = s;\n  });\n  pipeline.push(contentStream); // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n\n  pipeline.push(new Flush({\n    flush: function flush() {\n      return index.insert(cache, key, integrity, _objectSpread(_objectSpread({}, opts), {}, {\n        size: size\n      })).then(function (entry) {\n        if (memoize && memoData) memo.put(cache, entry, memoData, opts);\n        if (integrity) pipeline.emit('integrity', integrity);\n        if (size) pipeline.emit('size', size);\n      });\n    }\n  }));\n  return pipeline;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/cacache/put.js"],"names":["index","require","memo","write","Flush","PassThrough","Pipeline","putOpts","opts","algorithms","module","exports","putData","cache","key","data","memoize","then","res","insert","integrity","size","entry","put","stream","putStream","memoData","pipeline","memoizer","on","push","contentStream","int","s","flush","emit"],"mappings":"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","sourcesContent":["'use strict'\n\nconst index = require('./lib/entry-index')\nconst memo = require('./lib/memoization')\nconst write = require('./lib/content/write')\nconst Flush = require('minipass-flush')\nconst { PassThrough } = require('minipass-collect')\nconst Pipeline = require('minipass-pipeline')\n\nconst putOpts = (opts) => ({\n  algorithms: ['sha512'],\n  ...opts,\n})\n\nmodule.exports = putData\n\nfunction putData (cache, key, data, opts = {}) {\n  const { memoize } = opts\n  opts = putOpts(opts)\n  return write(cache, data, opts).then((res) => {\n    return index\n      .insert(cache, key, res.integrity, { ...opts, size: res.size })\n      .then((entry) => {\n        if (memoize)\n          memo.put(cache, entry, data, opts)\n\n        return res.integrity\n      })\n  })\n}\n\nmodule.exports.stream = putStream\n\nfunction putStream (cache, key, opts = {}) {\n  const { memoize } = opts\n  opts = putOpts(opts)\n  let integrity\n  let size\n\n  let memoData\n  const pipeline = new Pipeline()\n  // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n  if (memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data\n    })\n    pipeline.push(memoizer)\n  }\n\n  // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n  const contentStream = write.stream(cache, opts)\n    .on('integrity', (int) => {\n      integrity = int\n    })\n    .on('size', (s) => {\n      size = s\n    })\n\n  pipeline.push(contentStream)\n\n  // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n  pipeline.push(new Flush({\n    flush () {\n      return index\n        .insert(cache, key, integrity, { ...opts, size })\n        .then((entry) => {\n          if (memoize && memoData)\n            memo.put(cache, entry, memoData, opts)\n\n          if (integrity)\n            pipeline.emit('integrity', integrity)\n\n          if (size)\n            pipeline.emit('size', size)\n        })\n    },\n  }))\n\n  return pipeline\n}\n"]},"metadata":{},"sourceType":"script"}