{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/transform/src/transform\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/imports/src/default\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/translator\", \"@angular/compiler-cli/src/ngtsc/util/src/visitor\", \"@angular/compiler-cli/src/ngtsc/transform/src/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ivyTransformFactory = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var default_1 = require(\"@angular/compiler-cli/src/ngtsc/imports/src/default\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var translator_1 = require(\"@angular/compiler-cli/src/ngtsc/translator\");\n\n  var visitor_1 = require(\"@angular/compiler-cli/src/ngtsc/util/src/visitor\");\n\n  var utils_1 = require(\"@angular/compiler-cli/src/ngtsc/transform/src/utils\");\n\n  var NO_DECORATORS = new Set();\n  var CLOSURE_FILE_OVERVIEW_REGEXP = /\\s+@fileoverview\\s+/i;\n\n  function ivyTransformFactory(compilation, reflector, importRewriter, defaultImportTracker, perf, isCore, isClosureCompilerEnabled) {\n    var recordWrappedNode = createRecorderFn(defaultImportTracker);\n    return function (context) {\n      return function (file) {\n        return perf.inPhase(perf_1.PerfPhase.Compile, function () {\n          return transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode);\n        });\n      };\n    };\n  }\n\n  exports.ivyTransformFactory = ivyTransformFactory;\n  /**\n   * Visits all classes, performs Ivy compilation where Angular decorators are present and collects\n   * result in a Map that associates a ts.ClassDeclaration with Ivy compilation results. This visitor\n   * does NOT perform any TS transformations.\n   */\n\n  var IvyCompilationVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(IvyCompilationVisitor, _super);\n\n    function IvyCompilationVisitor(compilation, constantPool) {\n      var _this = _super.call(this) || this;\n\n      _this.compilation = compilation;\n      _this.constantPool = constantPool;\n      _this.classCompilationMap = new Map();\n      return _this;\n    }\n\n    IvyCompilationVisitor.prototype.visitClassDeclaration = function (node) {\n      // Determine if this class has an Ivy field that needs to be added, and compile the field\n      // to an expression if so.\n      var result = this.compilation.compile(node, this.constantPool);\n\n      if (result !== null) {\n        this.classCompilationMap.set(node, result);\n      }\n\n      return {\n        node: node\n      };\n    };\n\n    return IvyCompilationVisitor;\n  }(visitor_1.Visitor);\n  /**\n   * Visits all classes and performs transformation of corresponding TS nodes based on the Ivy\n   * compilation results (provided as an argument).\n   */\n\n\n  var IvyTransformationVisitor =\n  /** @class */\n  function (_super) {\n    tslib_1.__extends(IvyTransformationVisitor, _super);\n\n    function IvyTransformationVisitor(compilation, classCompilationMap, reflector, importManager, recordWrappedNode, isClosureCompilerEnabled, isCore) {\n      var _this = _super.call(this) || this;\n\n      _this.compilation = compilation;\n      _this.classCompilationMap = classCompilationMap;\n      _this.reflector = reflector;\n      _this.importManager = importManager;\n      _this.recordWrappedNode = recordWrappedNode;\n      _this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n      _this.isCore = isCore;\n      return _this;\n    }\n\n    IvyTransformationVisitor.prototype.visitClassDeclaration = function (node) {\n      var e_1, _a;\n\n      var _this = this; // If this class is not registered in the map, it means that it doesn't have Angular decorators,\n      // thus no further processing is required.\n\n\n      if (!this.classCompilationMap.has(node)) {\n        return {\n          node: node\n        };\n      } // There is at least one field to add.\n\n\n      var statements = [];\n\n      var members = tslib_1.__spread(node.members);\n\n      try {\n        for (var _b = tslib_1.__values(this.classCompilationMap.get(node)), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var field = _c.value; // Translate the initializer for the field into TS nodes.\n\n          var exprNode = translator_1.translateExpression(field.initializer, this.importManager, {\n            recordWrappedNode: this.recordWrappedNode\n          }); // Create a static property declaration for the new field.\n\n          var property = ts.createProperty(undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], field.name, undefined, undefined, exprNode);\n\n          if (this.isClosureCompilerEnabled) {\n            // Closure compiler transforms the form `Service.ɵprov = X` into `Service$ɵprov = X`. To\n            // prevent this transformation, such assignments need to be annotated with @nocollapse.\n            // Note that tsickle is typically responsible for adding such annotations, however it\n            // doesn't yet handle synthetic fields added during other transformations.\n            ts.addSyntheticLeadingComment(property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ',\n            /* hasTrailingNewLine */\n            false);\n          }\n\n          field.statements.map(function (stmt) {\n            return translator_1.translateStatement(stmt, _this.importManager, {\n              recordWrappedNode: _this.recordWrappedNode\n            });\n          }).forEach(function (stmt) {\n            return statements.push(stmt);\n          });\n          members.push(property);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      } // Replace the class declaration with an updated version.\n\n\n      node = ts.updateClassDeclaration(node, // Remove the decorator which triggered this compilation, leaving the others alone.\n      maybeFilterDecorator(node.decorators, this.compilation.decoratorsFor(node)), node.modifiers, node.name, node.typeParameters, node.heritageClauses || [], // Map over the class members and remove any Angular decorators from them.\n      members.map(function (member) {\n        return _this._stripAngularDecorators(member);\n      }));\n      return {\n        node: node,\n        after: statements\n      };\n    };\n    /**\n     * Return all decorators on a `Declaration` which are from @angular/core, or an empty set if none\n     * are.\n     */\n\n\n    IvyTransformationVisitor.prototype._angularCoreDecorators = function (decl) {\n      var _this = this;\n\n      var decorators = this.reflector.getDecoratorsOfDeclaration(decl);\n\n      if (decorators === null) {\n        return NO_DECORATORS;\n      }\n\n      var coreDecorators = decorators.filter(function (dec) {\n        return _this.isCore || isFromAngularCore(dec);\n      }).map(function (dec) {\n        return dec.node;\n      });\n\n      if (coreDecorators.length > 0) {\n        return new Set(coreDecorators);\n      } else {\n        return NO_DECORATORS;\n      }\n    };\n    /**\n     * Given a `ts.Node`, filter the decorators array and return a version containing only non-Angular\n     * decorators.\n     *\n     * If all decorators are removed (or none existed in the first place), this method returns\n     * `undefined`.\n     */\n\n\n    IvyTransformationVisitor.prototype._nonCoreDecoratorsOnly = function (node) {\n      // Shortcut if the node has no decorators.\n      if (node.decorators === undefined) {\n        return undefined;\n      } // Build a Set of the decorators on this node from @angular/core.\n\n\n      var coreDecorators = this._angularCoreDecorators(node);\n\n      if (coreDecorators.size === node.decorators.length) {\n        // If all decorators are to be removed, return `undefined`.\n        return undefined;\n      } else if (coreDecorators.size === 0) {\n        // If no decorators need to be removed, return the original decorators array.\n        return node.decorators;\n      } // Filter out the core decorators.\n\n\n      var filtered = node.decorators.filter(function (dec) {\n        return !coreDecorators.has(dec);\n      }); // If no decorators survive, return `undefined`. This can only happen if a core decorator is\n      // repeated on the node.\n\n      if (filtered.length === 0) {\n        return undefined;\n      } // Create a new `NodeArray` with the filtered decorators that sourcemaps back to the original.\n\n\n      var array = ts.createNodeArray(filtered);\n      array.pos = node.decorators.pos;\n      array.end = node.decorators.end;\n      return array;\n    };\n    /**\n     * Remove Angular decorators from a `ts.Node` in a shallow manner.\n     *\n     * This will remove decorators from class elements (getters, setters, properties, methods) as well\n     * as parameters of constructors.\n     */\n\n\n    IvyTransformationVisitor.prototype._stripAngularDecorators = function (node) {\n      var _this = this;\n\n      if (ts.isParameter(node)) {\n        // Strip decorators from parameters (probably of the constructor).\n        node = ts.updateParameter(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer);\n      } else if (ts.isMethodDeclaration(node) && node.decorators !== undefined) {\n        // Strip decorators of methods.\n        node = ts.updateMethod(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body);\n      } else if (ts.isPropertyDeclaration(node) && node.decorators !== undefined) {\n        // Strip decorators of properties.\n        node = ts.updateProperty(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.questionToken, node.type, node.initializer);\n      } else if (ts.isGetAccessor(node)) {\n        // Strip decorators of getters.\n        node = ts.updateGetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.type, node.body);\n      } else if (ts.isSetAccessor(node)) {\n        // Strip decorators of setters.\n        node = ts.updateSetAccessor(node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name, node.parameters, node.body);\n      } else if (ts.isConstructorDeclaration(node)) {\n        // For constructors, strip decorators of the parameters.\n        var parameters = node.parameters.map(function (param) {\n          return _this._stripAngularDecorators(param);\n        });\n        node = ts.updateConstructor(node, node.decorators, node.modifiers, parameters, node.body);\n      }\n\n      return node;\n    };\n\n    return IvyTransformationVisitor;\n  }(visitor_1.Visitor);\n  /**\n   * A transformer which operates on ts.SourceFiles and applies changes from an `IvyCompilation`.\n   */\n\n\n  function transformIvySourceFile(compilation, context, reflector, importRewriter, file, isCore, isClosureCompilerEnabled, recordWrappedNode) {\n    var constantPool = new compiler_1.ConstantPool(isClosureCompilerEnabled);\n    var importManager = new translator_1.ImportManager(importRewriter); // The transformation process consists of 2 steps:\n    //\n    //  1. Visit all classes, perform compilation and collect the results.\n    //  2. Perform actual transformation of required TS nodes using compilation results from the first\n    //     step.\n    //\n    // This is needed to have all `o.Expression`s generated before any TS transforms happen. This\n    // allows `ConstantPool` to properly identify expressions that can be shared across multiple\n    // components declared in the same file.\n    // Step 1. Go though all classes in AST, perform compilation and collect the results.\n\n    var compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);\n    visitor_1.visit(file, compilationVisitor, context); // Step 2. Scan through the AST again and perform transformations based on Ivy compilation\n    // results obtained at Step 1.\n\n    var transformationVisitor = new IvyTransformationVisitor(compilation, compilationVisitor.classCompilationMap, reflector, importManager, recordWrappedNode, isClosureCompilerEnabled, isCore);\n    var sf = visitor_1.visit(file, transformationVisitor, context); // Generate the constant statements first, as they may involve adding additional imports\n    // to the ImportManager.\n\n    var downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts.ScriptTarget.ES2015;\n    var constants = constantPool.statements.map(function (stmt) {\n      return translator_1.translateStatement(stmt, importManager, {\n        recordWrappedNode: recordWrappedNode,\n        downlevelTaggedTemplates: downlevelTranslatedCode,\n        downlevelVariableDeclarations: downlevelTranslatedCode\n      });\n    }); // Preserve @fileoverview comments required by Closure, since the location might change as a\n    // result of adding extra imports and constant pool statements.\n\n    var fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null; // Add new imports for this file.\n\n    sf = utils_1.addImports(importManager, sf, constants);\n\n    if (fileOverviewMeta !== null) {\n      setFileOverviewComment(sf, fileOverviewMeta);\n    }\n\n    return sf;\n  }\n  /**\n   * Compute the correct target output for `$localize` messages generated by Angular\n   *\n   * In some versions of TypeScript, the transformation of synthetic `$localize` tagged template\n   * literals is broken. See https://github.com/microsoft/TypeScript/issues/38485\n   *\n   * Here we compute what the expected final output target of the compilation will\n   * be so that we can generate ES5 compliant `$localize` calls instead of relying upon TS to do the\n   * downleveling for us.\n   */\n\n\n  function getLocalizeCompileTarget(context) {\n    var target = context.getCompilerOptions().target || ts.ScriptTarget.ES2015;\n    return target !== ts.ScriptTarget.JSON ? target : ts.ScriptTarget.ES2015;\n  }\n\n  function getFileOverviewComment(statements) {\n    if (statements.length > 0) {\n      var host = statements[0];\n      var trailing = false;\n      var comments = ts.getSyntheticLeadingComments(host); // If @fileoverview tag is not found in source file, tsickle produces fake node with trailing\n      // comment and inject it at the very beginning of the generated file. So we need to check for\n      // leading as well as trailing comments.\n\n      if (!comments || comments.length === 0) {\n        trailing = true;\n        comments = ts.getSyntheticTrailingComments(host);\n      }\n\n      if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {\n        return {\n          comments: comments,\n          host: host,\n          trailing: trailing\n        };\n      }\n    }\n\n    return null;\n  }\n\n  function setFileOverviewComment(sf, fileoverview) {\n    var comments = fileoverview.comments,\n        host = fileoverview.host,\n        trailing = fileoverview.trailing; // If host statement is no longer the first one, it means that extra statements were added at the\n    // very beginning, so we need to relocate @fileoverview comment and cleanup the original statement\n    // that hosted it.\n\n    if (sf.statements.length > 0 && host !== sf.statements[0]) {\n      if (trailing) {\n        ts.setSyntheticTrailingComments(host, undefined);\n      } else {\n        ts.setSyntheticLeadingComments(host, undefined);\n      }\n\n      ts.setSyntheticLeadingComments(sf.statements[0], comments);\n    }\n  }\n\n  function maybeFilterDecorator(decorators, toRemove) {\n    if (decorators === undefined) {\n      return undefined;\n    }\n\n    var filtered = decorators.filter(function (dec) {\n      return toRemove.find(function (decToRemove) {\n        return ts.getOriginalNode(dec) === decToRemove;\n      }) === undefined;\n    });\n\n    if (filtered.length === 0) {\n      return undefined;\n    }\n\n    return ts.createNodeArray(filtered);\n  }\n\n  function isFromAngularCore(decorator) {\n    return decorator.import !== null && decorator.import.from === '@angular/core';\n  }\n\n  function createRecorderFn(defaultImportTracker) {\n    return function (node) {\n      var importDecl = default_1.getDefaultImportDeclaration(node);\n\n      if (importDecl !== null) {\n        defaultImportTracker.recordUsedImport(importDecl);\n      }\n    };\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/transform/src/transform.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {DefaultImportTracker, ImportRewriter} from '../../imports';\nimport {getDefaultImportDeclaration} from '../../imports/src/default';\nimport {PerfPhase, PerfRecorder} from '../../perf';\nimport {Decorator, ReflectionHost} from '../../reflection';\nimport {ImportManager, RecordWrappedNodeFn, translateExpression, translateStatement} from '../../translator';\nimport {visit, VisitListEntryResult, Visitor} from '../../util/src/visitor';\n\nimport {CompileResult} from './api';\nimport {TraitCompiler} from './compilation';\nimport {addImports} from './utils';\n\nconst NO_DECORATORS = new Set<ts.Decorator>();\n\nconst CLOSURE_FILE_OVERVIEW_REGEXP = /\\s+@fileoverview\\s+/i;\n\n/**\n * Metadata to support @fileoverview blocks (Closure annotations) extracting/restoring.\n */\ninterface FileOverviewMeta {\n  comments: ts.SynthesizedComment[];\n  host: ts.Statement;\n  trailing: boolean;\n}\n\nexport function ivyTransformFactory(\n    compilation: TraitCompiler, reflector: ReflectionHost, importRewriter: ImportRewriter,\n    defaultImportTracker: DefaultImportTracker, perf: PerfRecorder, isCore: boolean,\n    isClosureCompilerEnabled: boolean): ts.TransformerFactory<ts.SourceFile> {\n  const recordWrappedNode = createRecorderFn(defaultImportTracker);\n  return (context: ts.TransformationContext): ts.Transformer<ts.SourceFile> => {\n    return (file: ts.SourceFile): ts.SourceFile => {\n      return perf.inPhase(\n          PerfPhase.Compile,\n          () => transformIvySourceFile(\n              compilation, context, reflector, importRewriter, file, isCore,\n              isClosureCompilerEnabled, recordWrappedNode));\n    };\n  };\n}\n\n/**\n * Visits all classes, performs Ivy compilation where Angular decorators are present and collects\n * result in a Map that associates a ts.ClassDeclaration with Ivy compilation results. This visitor\n * does NOT perform any TS transformations.\n */\nclass IvyCompilationVisitor extends Visitor {\n  public classCompilationMap = new Map<ts.ClassDeclaration, CompileResult[]>();\n\n  constructor(private compilation: TraitCompiler, private constantPool: ConstantPool) {\n    super();\n  }\n\n  visitClassDeclaration(node: ts.ClassDeclaration):\n      VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n    // Determine if this class has an Ivy field that needs to be added, and compile the field\n    // to an expression if so.\n    const result = this.compilation.compile(node, this.constantPool);\n    if (result !== null) {\n      this.classCompilationMap.set(node, result);\n    }\n    return {node};\n  }\n}\n\n/**\n * Visits all classes and performs transformation of corresponding TS nodes based on the Ivy\n * compilation results (provided as an argument).\n */\nclass IvyTransformationVisitor extends Visitor {\n  constructor(\n      private compilation: TraitCompiler,\n      private classCompilationMap: Map<ts.ClassDeclaration, CompileResult[]>,\n      private reflector: ReflectionHost, private importManager: ImportManager,\n      private recordWrappedNode: RecordWrappedNodeFn<ts.Expression>,\n      private isClosureCompilerEnabled: boolean, private isCore: boolean) {\n    super();\n  }\n\n  visitClassDeclaration(node: ts.ClassDeclaration):\n      VisitListEntryResult<ts.Statement, ts.ClassDeclaration> {\n    // If this class is not registered in the map, it means that it doesn't have Angular decorators,\n    // thus no further processing is required.\n    if (!this.classCompilationMap.has(node)) {\n      return {node};\n    }\n\n    // There is at least one field to add.\n    const statements: ts.Statement[] = [];\n    const members = [...node.members];\n\n    for (const field of this.classCompilationMap.get(node)!) {\n      // Translate the initializer for the field into TS nodes.\n      const exprNode = translateExpression(\n          field.initializer, this.importManager, {recordWrappedNode: this.recordWrappedNode});\n\n      // Create a static property declaration for the new field.\n      const property = ts.createProperty(\n          undefined, [ts.createToken(ts.SyntaxKind.StaticKeyword)], field.name, undefined,\n          undefined, exprNode);\n\n      if (this.isClosureCompilerEnabled) {\n        // Closure compiler transforms the form `Service.ɵprov = X` into `Service$ɵprov = X`. To\n        // prevent this transformation, such assignments need to be annotated with @nocollapse.\n        // Note that tsickle is typically responsible for adding such annotations, however it\n        // doesn't yet handle synthetic fields added during other transformations.\n        ts.addSyntheticLeadingComment(\n            property, ts.SyntaxKind.MultiLineCommentTrivia, '* @nocollapse ',\n            /* hasTrailingNewLine */ false);\n      }\n\n      field.statements\n          .map(\n              stmt => translateStatement(\n                  stmt, this.importManager, {recordWrappedNode: this.recordWrappedNode}))\n          .forEach(stmt => statements.push(stmt));\n\n      members.push(property);\n    }\n\n    // Replace the class declaration with an updated version.\n    node = ts.updateClassDeclaration(\n        node,\n        // Remove the decorator which triggered this compilation, leaving the others alone.\n        maybeFilterDecorator(node.decorators, this.compilation.decoratorsFor(node)), node.modifiers,\n        node.name, node.typeParameters, node.heritageClauses || [],\n        // Map over the class members and remove any Angular decorators from them.\n        members.map(member => this._stripAngularDecorators(member)));\n    return {node, after: statements};\n  }\n\n  /**\n   * Return all decorators on a `Declaration` which are from @angular/core, or an empty set if none\n   * are.\n   */\n  private _angularCoreDecorators(decl: ts.Declaration): Set<ts.Decorator> {\n    const decorators = this.reflector.getDecoratorsOfDeclaration(decl);\n    if (decorators === null) {\n      return NO_DECORATORS;\n    }\n    const coreDecorators = decorators.filter(dec => this.isCore || isFromAngularCore(dec))\n                               .map(dec => dec.node as ts.Decorator);\n    if (coreDecorators.length > 0) {\n      return new Set<ts.Decorator>(coreDecorators);\n    } else {\n      return NO_DECORATORS;\n    }\n  }\n\n  /**\n   * Given a `ts.Node`, filter the decorators array and return a version containing only non-Angular\n   * decorators.\n   *\n   * If all decorators are removed (or none existed in the first place), this method returns\n   * `undefined`.\n   */\n  private _nonCoreDecoratorsOnly(node: ts.Declaration): ts.NodeArray<ts.Decorator>|undefined {\n    // Shortcut if the node has no decorators.\n    if (node.decorators === undefined) {\n      return undefined;\n    }\n    // Build a Set of the decorators on this node from @angular/core.\n    const coreDecorators = this._angularCoreDecorators(node);\n\n    if (coreDecorators.size === node.decorators.length) {\n      // If all decorators are to be removed, return `undefined`.\n      return undefined;\n    } else if (coreDecorators.size === 0) {\n      // If no decorators need to be removed, return the original decorators array.\n      return node.decorators;\n    }\n\n    // Filter out the core decorators.\n    const filtered = node.decorators.filter(dec => !coreDecorators.has(dec));\n\n    // If no decorators survive, return `undefined`. This can only happen if a core decorator is\n    // repeated on the node.\n    if (filtered.length === 0) {\n      return undefined;\n    }\n\n    // Create a new `NodeArray` with the filtered decorators that sourcemaps back to the original.\n    const array = ts.createNodeArray(filtered);\n    (array.pos as number) = node.decorators.pos;\n    (array.end as number) = node.decorators.end;\n    return array;\n  }\n\n  /**\n   * Remove Angular decorators from a `ts.Node` in a shallow manner.\n   *\n   * This will remove decorators from class elements (getters, setters, properties, methods) as well\n   * as parameters of constructors.\n   */\n  private _stripAngularDecorators<T extends ts.Node>(node: T): T {\n    if (ts.isParameter(node)) {\n      // Strip decorators from parameters (probably of the constructor).\n      node = ts.updateParameter(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.dotDotDotToken,\n                 node.name, node.questionToken, node.type, node.initializer) as T &\n          ts.ParameterDeclaration;\n    } else if (ts.isMethodDeclaration(node) && node.decorators !== undefined) {\n      // Strip decorators of methods.\n      node = ts.updateMethod(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.asteriskToken,\n                 node.name, node.questionToken, node.typeParameters, node.parameters, node.type,\n                 node.body) as T &\n          ts.MethodDeclaration;\n    } else if (ts.isPropertyDeclaration(node) && node.decorators !== undefined) {\n      // Strip decorators of properties.\n      node = ts.updateProperty(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name,\n                 node.questionToken, node.type, node.initializer) as T &\n          ts.PropertyDeclaration;\n    } else if (ts.isGetAccessor(node)) {\n      // Strip decorators of getters.\n      node = ts.updateGetAccessor(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name,\n                 node.parameters, node.type, node.body) as T &\n          ts.GetAccessorDeclaration;\n    } else if (ts.isSetAccessor(node)) {\n      // Strip decorators of setters.\n      node = ts.updateSetAccessor(\n                 node, this._nonCoreDecoratorsOnly(node), node.modifiers, node.name,\n                 node.parameters, node.body) as T &\n          ts.SetAccessorDeclaration;\n    } else if (ts.isConstructorDeclaration(node)) {\n      // For constructors, strip decorators of the parameters.\n      const parameters = node.parameters.map(param => this._stripAngularDecorators(param));\n      node =\n          ts.updateConstructor(node, node.decorators, node.modifiers, parameters, node.body) as T &\n          ts.ConstructorDeclaration;\n    }\n    return node;\n  }\n}\n\n/**\n * A transformer which operates on ts.SourceFiles and applies changes from an `IvyCompilation`.\n */\nfunction transformIvySourceFile(\n    compilation: TraitCompiler, context: ts.TransformationContext, reflector: ReflectionHost,\n    importRewriter: ImportRewriter, file: ts.SourceFile, isCore: boolean,\n    isClosureCompilerEnabled: boolean,\n    recordWrappedNode: RecordWrappedNodeFn<ts.Expression>): ts.SourceFile {\n  const constantPool = new ConstantPool(isClosureCompilerEnabled);\n  const importManager = new ImportManager(importRewriter);\n\n  // The transformation process consists of 2 steps:\n  //\n  //  1. Visit all classes, perform compilation and collect the results.\n  //  2. Perform actual transformation of required TS nodes using compilation results from the first\n  //     step.\n  //\n  // This is needed to have all `o.Expression`s generated before any TS transforms happen. This\n  // allows `ConstantPool` to properly identify expressions that can be shared across multiple\n  // components declared in the same file.\n\n  // Step 1. Go though all classes in AST, perform compilation and collect the results.\n  const compilationVisitor = new IvyCompilationVisitor(compilation, constantPool);\n  visit(file, compilationVisitor, context);\n\n  // Step 2. Scan through the AST again and perform transformations based on Ivy compilation\n  // results obtained at Step 1.\n  const transformationVisitor = new IvyTransformationVisitor(\n      compilation, compilationVisitor.classCompilationMap, reflector, importManager,\n      recordWrappedNode, isClosureCompilerEnabled, isCore);\n  let sf = visit(file, transformationVisitor, context);\n\n  // Generate the constant statements first, as they may involve adding additional imports\n  // to the ImportManager.\n  const downlevelTranslatedCode = getLocalizeCompileTarget(context) < ts.ScriptTarget.ES2015;\n  const constants =\n      constantPool.statements.map(stmt => translateStatement(stmt, importManager, {\n                                    recordWrappedNode,\n                                    downlevelTaggedTemplates: downlevelTranslatedCode,\n                                    downlevelVariableDeclarations: downlevelTranslatedCode,\n                                  }));\n\n  // Preserve @fileoverview comments required by Closure, since the location might change as a\n  // result of adding extra imports and constant pool statements.\n  const fileOverviewMeta = isClosureCompilerEnabled ? getFileOverviewComment(sf.statements) : null;\n\n  // Add new imports for this file.\n  sf = addImports(importManager, sf, constants);\n\n  if (fileOverviewMeta !== null) {\n    setFileOverviewComment(sf, fileOverviewMeta);\n  }\n\n  return sf;\n}\n\n/**\n * Compute the correct target output for `$localize` messages generated by Angular\n *\n * In some versions of TypeScript, the transformation of synthetic `$localize` tagged template\n * literals is broken. See https://github.com/microsoft/TypeScript/issues/38485\n *\n * Here we compute what the expected final output target of the compilation will\n * be so that we can generate ES5 compliant `$localize` calls instead of relying upon TS to do the\n * downleveling for us.\n */\nfunction getLocalizeCompileTarget(context: ts.TransformationContext):\n    Exclude<ts.ScriptTarget, ts.ScriptTarget.JSON> {\n  const target = context.getCompilerOptions().target || ts.ScriptTarget.ES2015;\n  return target !== ts.ScriptTarget.JSON ? target : ts.ScriptTarget.ES2015;\n}\n\nfunction getFileOverviewComment(statements: ts.NodeArray<ts.Statement>): FileOverviewMeta|null {\n  if (statements.length > 0) {\n    const host = statements[0];\n    let trailing = false;\n    let comments = ts.getSyntheticLeadingComments(host);\n    // If @fileoverview tag is not found in source file, tsickle produces fake node with trailing\n    // comment and inject it at the very beginning of the generated file. So we need to check for\n    // leading as well as trailing comments.\n    if (!comments || comments.length === 0) {\n      trailing = true;\n      comments = ts.getSyntheticTrailingComments(host);\n    }\n    if (comments && comments.length > 0 && CLOSURE_FILE_OVERVIEW_REGEXP.test(comments[0].text)) {\n      return {comments, host, trailing};\n    }\n  }\n  return null;\n}\n\nfunction setFileOverviewComment(sf: ts.SourceFile, fileoverview: FileOverviewMeta): void {\n  const {comments, host, trailing} = fileoverview;\n  // If host statement is no longer the first one, it means that extra statements were added at the\n  // very beginning, so we need to relocate @fileoverview comment and cleanup the original statement\n  // that hosted it.\n  if (sf.statements.length > 0 && host !== sf.statements[0]) {\n    if (trailing) {\n      ts.setSyntheticTrailingComments(host, undefined);\n    } else {\n      ts.setSyntheticLeadingComments(host, undefined);\n    }\n    ts.setSyntheticLeadingComments(sf.statements[0], comments);\n  }\n}\n\nfunction maybeFilterDecorator(\n    decorators: ts.NodeArray<ts.Decorator>|undefined,\n    toRemove: ts.Decorator[]): ts.NodeArray<ts.Decorator>|undefined {\n  if (decorators === undefined) {\n    return undefined;\n  }\n  const filtered = decorators.filter(\n      dec => toRemove.find(decToRemove => ts.getOriginalNode(dec) === decToRemove) === undefined);\n  if (filtered.length === 0) {\n    return undefined;\n  }\n  return ts.createNodeArray(filtered);\n}\n\nfunction isFromAngularCore(decorator: Decorator): boolean {\n  return decorator.import !== null && decorator.import.from === '@angular/core';\n}\n\nfunction createRecorderFn(defaultImportTracker: DefaultImportTracker):\n    RecordWrappedNodeFn<ts.Expression> {\n  return node => {\n    const importDecl = getDefaultImportDeclaration(node);\n    if (importDecl !== null) {\n      defaultImportTracker.recordUsedImport(importDecl);\n    }\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}