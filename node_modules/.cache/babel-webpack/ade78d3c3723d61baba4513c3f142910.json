{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/aot/static_symbol_resolver\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler/src/util\", \"@angular/compiler/src/aot/static_symbol\", \"@angular/compiler/src/aot/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.unwrapResolvedMetadata = exports.unescapeIdentifier = exports.StaticSymbolResolver = exports.ResolvedStaticSymbol = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n\n  var static_symbol_1 = require(\"@angular/compiler/src/aot/static_symbol\");\n\n  var util_2 = require(\"@angular/compiler/src/aot/util\");\n\n  var TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\n\n  var ResolvedStaticSymbol =\n  /** @class */\n  function () {\n    function ResolvedStaticSymbol(symbol, metadata) {\n      this.symbol = symbol;\n      this.metadata = metadata;\n    }\n\n    return ResolvedStaticSymbol;\n  }();\n\n  exports.ResolvedStaticSymbol = ResolvedStaticSymbol;\n  var SUPPORTED_SCHEMA_VERSION = 4;\n  /**\n   * This class is responsible for loading metadata per symbol,\n   * and normalizing references between symbols.\n   *\n   * Internally, it only uses symbols without members,\n   * and deduces the values for symbols with members based\n   * on these symbols.\n   */\n\n  var StaticSymbolResolver =\n  /** @class */\n  function () {\n    function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {\n      this.host = host;\n      this.staticSymbolCache = staticSymbolCache;\n      this.summaryResolver = summaryResolver;\n      this.errorRecorder = errorRecorder;\n      this.metadataCache = new Map(); // Note: this will only contain StaticSymbols without members!\n\n      this.resolvedSymbols = new Map(); // Note: this will only contain StaticSymbols without members!\n\n      this.importAs = new Map();\n      this.symbolResourcePaths = new Map();\n      this.symbolFromFile = new Map();\n      this.knownFileNameToModuleNames = new Map();\n    }\n\n    StaticSymbolResolver.prototype.resolveSymbol = function (staticSymbol) {\n      if (staticSymbol.members.length > 0) {\n        return this._resolveSymbolMembers(staticSymbol);\n      } // Note: always ask for a summary first,\n      // as we might have read shallow metadata via a .d.ts file\n      // for the symbol.\n\n\n      var resultFromSummary = this._resolveSymbolFromSummary(staticSymbol);\n\n      if (resultFromSummary) {\n        return resultFromSummary;\n      }\n\n      var resultFromCache = this.resolvedSymbols.get(staticSymbol);\n\n      if (resultFromCache) {\n        return resultFromCache;\n      } // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n      // have summaries, only .d.ts files. So we always need to check both, the summary\n      // and metadata.\n\n\n      this._createSymbolsOf(staticSymbol.filePath);\n\n      return this.resolvedSymbols.get(staticSymbol);\n    };\n    /**\n     * getImportAs produces a symbol that can be used to import the given symbol.\n     * The import might be different than the symbol if the symbol is exported from\n     * a library with a summary; in which case we want to import the symbol from the\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\n     * on an otherwise indirect dependency.\n     *\n     * @param staticSymbol the symbol for which to generate a import symbol\n     */\n\n\n    StaticSymbolResolver.prototype.getImportAs = function (staticSymbol, useSummaries) {\n      if (useSummaries === void 0) {\n        useSummaries = true;\n      }\n\n      if (staticSymbol.members.length) {\n        var baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n        var baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n        return baseImportAs ? this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) : null;\n      }\n\n      var summarizedFileName = util_2.stripSummaryForJitFileSuffix(staticSymbol.filePath);\n\n      if (summarizedFileName !== staticSymbol.filePath) {\n        var summarizedName = util_2.stripSummaryForJitNameSuffix(staticSymbol.name);\n        var baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n        var baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n        return baseImportAs ? this.getStaticSymbol(util_2.summaryForJitFileName(baseImportAs.filePath), util_2.summaryForJitName(baseImportAs.name), baseSymbol.members) : null;\n      }\n\n      var result = useSummaries && this.summaryResolver.getImportAs(staticSymbol) || null;\n\n      if (!result) {\n        result = this.importAs.get(staticSymbol);\n      }\n\n      return result;\n    };\n    /**\n     * getResourcePath produces the path to the original location of the symbol and should\n     * be used to determine the relative location of resource references recorded in\n     * symbol metadata.\n     */\n\n\n    StaticSymbolResolver.prototype.getResourcePath = function (staticSymbol) {\n      return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    };\n    /**\n     * getTypeArity returns the number of generic type parameters the given symbol\n     * has. If the symbol is not a type the result is null.\n     */\n\n\n    StaticSymbolResolver.prototype.getTypeArity = function (staticSymbol) {\n      // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n      // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n      // All references to generated classes must include the correct arity whenever\n      // generating code.\n      if (util_2.isGeneratedFile(staticSymbol.filePath)) {\n        return null;\n      }\n\n      var resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n\n      while (resolvedSymbol && resolvedSymbol.metadata instanceof static_symbol_1.StaticSymbol) {\n        resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n      }\n\n      return resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity || null;\n    };\n\n    StaticSymbolResolver.prototype.getKnownModuleName = function (filePath) {\n      return this.knownFileNameToModuleNames.get(filePath) || null;\n    };\n\n    StaticSymbolResolver.prototype.recordImportAs = function (sourceSymbol, targetSymbol) {\n      sourceSymbol.assertNoMembers();\n      targetSymbol.assertNoMembers();\n      this.importAs.set(sourceSymbol, targetSymbol);\n    };\n\n    StaticSymbolResolver.prototype.recordModuleNameForFileName = function (fileName, moduleName) {\n      this.knownFileNameToModuleNames.set(fileName, moduleName);\n    };\n    /**\n     * Invalidate all information derived from the given file and return the\n     * static symbols contained in the file.\n     *\n     * @param fileName the file to invalidate\n     */\n\n\n    StaticSymbolResolver.prototype.invalidateFile = function (fileName) {\n      var e_1, _a;\n\n      this.metadataCache.delete(fileName);\n      var symbols = this.symbolFromFile.get(fileName);\n\n      if (!symbols) {\n        return [];\n      }\n\n      this.symbolFromFile.delete(fileName);\n\n      try {\n        for (var symbols_1 = tslib_1.__values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n          var symbol = symbols_1_1.value;\n          this.resolvedSymbols.delete(symbol);\n          this.importAs.delete(symbol);\n          this.symbolResourcePaths.delete(symbol);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return symbols;\n    };\n    /** @internal */\n\n\n    StaticSymbolResolver.prototype.ignoreErrorsFor = function (cb) {\n      var recorder = this.errorRecorder;\n\n      this.errorRecorder = function () {};\n\n      try {\n        return cb();\n      } finally {\n        this.errorRecorder = recorder;\n      }\n    };\n\n    StaticSymbolResolver.prototype._resolveSymbolMembers = function (staticSymbol) {\n      var members = staticSymbol.members;\n      var baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n\n      if (!baseResolvedSymbol) {\n        return null;\n      }\n\n      var baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n\n      if (baseMetadata instanceof static_symbol_1.StaticSymbol) {\n        return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n      } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n        if (baseMetadata.statics && members.length === 1) {\n          return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n        }\n      } else {\n        var value = baseMetadata;\n\n        for (var i = 0; i < members.length && value; i++) {\n          value = value[members[i]];\n        }\n\n        return new ResolvedStaticSymbol(staticSymbol, value);\n      }\n\n      return null;\n    };\n\n    StaticSymbolResolver.prototype._resolveSymbolFromSummary = function (staticSymbol) {\n      var summary = this.summaryResolver.resolveSummary(staticSymbol);\n      return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    };\n    /**\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\n     *\n     * @param declarationFile the absolute path of the file where the symbol is declared\n     * @param name the name of the type.\n     * @param members a symbol for a static member of the named type\n     */\n\n\n    StaticSymbolResolver.prototype.getStaticSymbol = function (declarationFile, name, members) {\n      return this.staticSymbolCache.get(declarationFile, name, members);\n    };\n    /**\n     * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\n     * metadata.\n     *\n     * @param filePath the absolute path to examine for decorators.\n     * @returns true if any class in the file has a decorator.\n     */\n\n\n    StaticSymbolResolver.prototype.hasDecorators = function (filePath) {\n      var metadata = this.getModuleMetadata(filePath);\n\n      if (metadata['metadata']) {\n        return Object.keys(metadata['metadata']).some(function (metadataKey) {\n          var entry = metadata['metadata'][metadataKey];\n          return entry && entry.__symbolic === 'class' && entry.decorators;\n        });\n      }\n\n      return false;\n    };\n\n    StaticSymbolResolver.prototype.getSymbolsOf = function (filePath) {\n      var summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n\n      if (summarySymbols) {\n        return summarySymbols;\n      } // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n      // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n\n\n      this._createSymbolsOf(filePath);\n\n      return this.symbolFromFile.get(filePath) || [];\n    };\n\n    StaticSymbolResolver.prototype._createSymbolsOf = function (filePath) {\n      var e_2, _a, e_3, _b;\n\n      var _this = this;\n\n      if (this.symbolFromFile.has(filePath)) {\n        return;\n      }\n\n      var resolvedSymbols = [];\n      var metadata = this.getModuleMetadata(filePath);\n\n      if (metadata['importAs']) {\n        // Index bundle indices should use the importAs module name defined\n        // in the bundle.\n        this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n      } // handle the symbols in one of the re-export location\n\n\n      if (metadata['exports']) {\n        var _loop_1 = function _loop_1(moduleExport) {\n          // handle the symbols in the list of explicitly re-exported symbols.\n          if (moduleExport.export) {\n            moduleExport.export.forEach(function (exportSymbol) {\n              var symbolName;\n\n              if (typeof exportSymbol === 'string') {\n                symbolName = exportSymbol;\n              } else {\n                symbolName = exportSymbol.as;\n              }\n\n              symbolName = unescapeIdentifier(symbolName);\n              var symName = symbolName;\n\n              if (typeof exportSymbol !== 'string') {\n                symName = unescapeIdentifier(exportSymbol.name);\n              }\n\n              var resolvedModule = _this.resolveModule(moduleExport.from, filePath);\n\n              if (resolvedModule) {\n                var targetSymbol = _this.getStaticSymbol(resolvedModule, symName);\n\n                var sourceSymbol = _this.getStaticSymbol(filePath, symbolName);\n\n                resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n              }\n            });\n          } else {\n            // Handle the symbols loaded by 'export *' directives.\n            var resolvedModule = this_1.resolveModule(moduleExport.from, filePath);\n\n            if (resolvedModule && resolvedModule !== filePath) {\n              var nestedExports = this_1.getSymbolsOf(resolvedModule);\n              nestedExports.forEach(function (targetSymbol) {\n                var sourceSymbol = _this.getStaticSymbol(filePath, targetSymbol.name);\n\n                resolvedSymbols.push(_this.createExport(sourceSymbol, targetSymbol));\n              });\n            }\n          }\n        };\n\n        var this_1 = this;\n\n        try {\n          for (var _c = tslib_1.__values(metadata['exports']), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var moduleExport = _d.value;\n\n            _loop_1(moduleExport);\n          }\n        } catch (e_2_1) {\n          e_2 = {\n            error: e_2_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n          } finally {\n            if (e_2) throw e_2.error;\n          }\n        }\n      } // handle the actual metadata. Has to be after the exports\n      // as there might be collisions in the names, and we want the symbols\n      // of the current module to win ofter reexports.\n\n\n      if (metadata['metadata']) {\n        // handle direct declarations of the symbol\n        var topLevelSymbolNames_1 = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n        var origins_1 = metadata['origins'] || {};\n        Object.keys(metadata['metadata']).forEach(function (metadataKey) {\n          var symbolMeta = metadata['metadata'][metadataKey];\n          var name = unescapeIdentifier(metadataKey);\n\n          var symbol = _this.getStaticSymbol(filePath, name);\n\n          var origin = origins_1.hasOwnProperty(metadataKey) && origins_1[metadataKey];\n\n          if (origin) {\n            // If the symbol is from a bundled index, use the declaration location of the\n            // symbol so relative references (such as './my.html') will be calculated\n            // correctly.\n            var originFilePath = _this.resolveModule(origin, filePath);\n\n            if (!originFilePath) {\n              _this.reportError(new Error(\"Couldn't resolve original symbol for \" + origin + \" from \" + _this.host.getOutputName(filePath)));\n            } else {\n              _this.symbolResourcePaths.set(symbol, originFilePath);\n            }\n          }\n\n          resolvedSymbols.push(_this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames_1, symbolMeta));\n        });\n      }\n\n      var uniqueSymbols = new Set();\n\n      try {\n        for (var resolvedSymbols_1 = tslib_1.__values(resolvedSymbols), resolvedSymbols_1_1 = resolvedSymbols_1.next(); !resolvedSymbols_1_1.done; resolvedSymbols_1_1 = resolvedSymbols_1.next()) {\n          var resolvedSymbol = resolvedSymbols_1_1.value;\n          this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);\n          uniqueSymbols.add(resolvedSymbol.symbol);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (resolvedSymbols_1_1 && !resolvedSymbols_1_1.done && (_b = resolvedSymbols_1.return)) _b.call(resolvedSymbols_1);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      this.symbolFromFile.set(filePath, Array.from(uniqueSymbols));\n    };\n\n    StaticSymbolResolver.prototype.createResolvedSymbol = function (sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n      var _this = this; // For classes that don't have Angular summaries / metadata,\n      // we only keep their arity, but nothing else\n      // (e.g. their constructor parameters).\n      // We do this to prevent introducing deep imports\n      // as we didn't generate .ngfactory.ts files with proper reexports.\n\n\n      var isTsFile = TS.test(sourceSymbol.filePath);\n\n      if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata && metadata['__symbolic'] === 'class') {\n        var transformedMeta_1 = {\n          __symbolic: 'class',\n          arity: metadata.arity\n        };\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta_1);\n      }\n\n      var _originalFileMemo;\n\n      var getOriginalName = function getOriginalName() {\n        if (!_originalFileMemo) {\n          // Guess what the original file name is from the reference. If it has a `.d.ts` extension\n          // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n          // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n          // location as it is not important to finding the file.\n          _originalFileMemo = _this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts').replace(/^.*node_modules[/\\\\]/, ''));\n        }\n\n        return _originalFileMemo;\n      };\n\n      var self = this;\n\n      var ReferenceTransformer =\n      /** @class */\n      function (_super) {\n        tslib_1.__extends(ReferenceTransformer, _super);\n\n        function ReferenceTransformer() {\n          return _super !== null && _super.apply(this, arguments) || this;\n        }\n\n        ReferenceTransformer.prototype.visitStringMap = function (map, functionParams) {\n          var symbolic = map['__symbolic'];\n\n          if (symbolic === 'function') {\n            var oldLen = functionParams.length;\n            functionParams.push.apply(functionParams, tslib_1.__spread(map['parameters'] || []));\n\n            var result = _super.prototype.visitStringMap.call(this, map, functionParams);\n\n            functionParams.length = oldLen;\n            return result;\n          } else if (symbolic === 'reference') {\n            var module = map['module'];\n            var name_1 = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n\n            if (!name_1) {\n              return null;\n            }\n\n            var filePath = void 0;\n\n            if (module) {\n              filePath = self.resolveModule(module, sourceSymbol.filePath);\n\n              if (!filePath) {\n                return {\n                  __symbolic: 'error',\n                  message: \"Could not resolve \" + module + \" relative to \" + self.host.getMetadataFor(sourceSymbol.filePath) + \".\",\n                  line: map['line'],\n                  character: map['character'],\n                  fileName: getOriginalName()\n                };\n              }\n\n              return {\n                __symbolic: 'resolved',\n                symbol: self.getStaticSymbol(filePath, name_1),\n                line: map['line'],\n                character: map['character'],\n                fileName: getOriginalName()\n              };\n            } else if (functionParams.indexOf(name_1) >= 0) {\n              // reference to a function parameter\n              return {\n                __symbolic: 'reference',\n                name: name_1\n              };\n            } else {\n              if (topLevelSymbolNames.has(name_1)) {\n                return self.getStaticSymbol(topLevelPath, name_1);\n              } // ambient value\n\n\n              null;\n            }\n          } else if (symbolic === 'error') {\n            return tslib_1.__assign(tslib_1.__assign({}, map), {\n              fileName: getOriginalName()\n            });\n          } else {\n            return _super.prototype.visitStringMap.call(this, map, functionParams);\n          }\n        };\n\n        return ReferenceTransformer;\n      }(util_1.ValueTransformer);\n\n      var transformedMeta = util_1.visitValue(metadata, new ReferenceTransformer(), []);\n      var unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n\n      if (unwrappedTransformedMeta instanceof static_symbol_1.StaticSymbol) {\n        return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n      }\n\n      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    };\n\n    StaticSymbolResolver.prototype.createExport = function (sourceSymbol, targetSymbol) {\n      sourceSymbol.assertNoMembers();\n      targetSymbol.assertNoMembers();\n\n      if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n        // This case is for an ng library importing symbols from a plain ts library\n        // transitively.\n        // Note: We rely on the fact that we discover symbols in the direction\n        // from source files to library files\n        this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n      }\n\n      return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    };\n\n    StaticSymbolResolver.prototype.reportError = function (error, context, path) {\n      if (this.errorRecorder) {\n        this.errorRecorder(error, context && context.filePath || path);\n      } else {\n        throw error;\n      }\n    };\n    /**\n     * @param module an absolute path to a module file.\n     */\n\n\n    StaticSymbolResolver.prototype.getModuleMetadata = function (module) {\n      var moduleMetadata = this.metadataCache.get(module);\n\n      if (!moduleMetadata) {\n        var moduleMetadatas = this.host.getMetadataFor(module);\n\n        if (moduleMetadatas) {\n          var maxVersion_1 = -1;\n          moduleMetadatas.forEach(function (md) {\n            if (md && md['version'] > maxVersion_1) {\n              maxVersion_1 = md['version'];\n              moduleMetadata = md;\n            }\n          });\n        }\n\n        if (!moduleMetadata) {\n          moduleMetadata = {\n            __symbolic: 'module',\n            version: SUPPORTED_SCHEMA_VERSION,\n            module: module,\n            metadata: {}\n          };\n        }\n\n        if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n          var errorMessage = moduleMetadata['version'] == 2 ? \"Unsupported metadata version \" + moduleMetadata['version'] + \" for module \" + module + \". This module should be compiled with a newer version of ngc\" : \"Metadata version mismatch for module \" + this.host.getOutputName(module) + \", found version \" + moduleMetadata['version'] + \", expected \" + SUPPORTED_SCHEMA_VERSION;\n          this.reportError(new Error(errorMessage));\n        }\n\n        this.metadataCache.set(module, moduleMetadata);\n      }\n\n      return moduleMetadata;\n    };\n\n    StaticSymbolResolver.prototype.getSymbolByModule = function (module, symbolName, containingFile) {\n      var filePath = this.resolveModule(module, containingFile);\n\n      if (!filePath) {\n        this.reportError(new Error(\"Could not resolve module \" + module + (containingFile ? ' relative to ' + this.host.getOutputName(containingFile) : '')));\n        return this.getStaticSymbol(\"ERROR:\" + module, symbolName);\n      }\n\n      return this.getStaticSymbol(filePath, symbolName);\n    };\n\n    StaticSymbolResolver.prototype.resolveModule = function (module, containingFile) {\n      try {\n        return this.host.moduleNameToFileName(module, containingFile);\n      } catch (e) {\n        console.error(\"Could not resolve module '\" + module + \"' relative to file \" + containingFile);\n        this.reportError(e, undefined, containingFile);\n      }\n\n      return null;\n    };\n\n    return StaticSymbolResolver;\n  }();\n\n  exports.StaticSymbolResolver = StaticSymbolResolver; // Remove extra underscore from escaped identifier.\n  // See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\n\n  function unescapeIdentifier(identifier) {\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n  }\n\n  exports.unescapeIdentifier = unescapeIdentifier;\n\n  function unwrapResolvedMetadata(metadata) {\n    if (metadata && metadata.__symbolic === 'resolved') {\n      return metadata.symbol;\n    }\n\n    return metadata;\n  }\n\n  exports.unwrapResolvedMetadata = unwrapResolvedMetadata;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler/src/aot/static_symbol_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SummaryResolver} from '../summary_resolver';\nimport {ValueTransformer, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {isGeneratedFile, stripSummaryForJitFileSuffix, stripSummaryForJitNameSuffix, summaryForJitFileName, summaryForJitName} from './util';\n\nconst TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\n\nexport class ResolvedStaticSymbol {\n  constructor(public symbol: StaticSymbol, public metadata: any) {}\n}\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n */\nexport interface StaticSymbolResolverHost {\n  /**\n   * Return a ModuleMetadata for the given module.\n   * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n   * produced and the module has exported variables or classes with decorators. Module metadata can\n   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n   *\n   * @param modulePath is a string identifier for a module as an absolute path.\n   * @returns the metadata for the given module.\n   */\n  getMetadataFor(modulePath: string): {[key: string]: any}[]|undefined;\n\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e.\n   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile?: string): string|null;\n\n  /**\n   * Get a file suitable for display to the user that should be relative to the project directory\n   * or the current directory.\n   */\n  getOutputName(filePath: string): string;\n}\n\nconst SUPPORTED_SCHEMA_VERSION = 4;\n\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n *\n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nexport class StaticSymbolResolver {\n  private metadataCache = new Map<string, {[key: string]: any}>();\n  // Note: this will only contain StaticSymbols without members!\n  private resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\n  // Note: this will only contain StaticSymbols without members!\n  private importAs = new Map<StaticSymbol, StaticSymbol>();\n  private symbolResourcePaths = new Map<StaticSymbol, string>();\n  private symbolFromFile = new Map<string, StaticSymbol[]>();\n  private knownFileNameToModuleNames = new Map<string, string>();\n\n  constructor(\n      private host: StaticSymbolResolverHost, private staticSymbolCache: StaticSymbolCache,\n      private summaryResolver: SummaryResolver<StaticSymbol>,\n      private errorRecorder?: (error: any, fileName?: string) => void) {}\n\n  resolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    if (staticSymbol.members.length > 0) {\n      return this._resolveSymbolMembers(staticSymbol)!;\n    }\n    // Note: always ask for a summary first,\n    // as we might have read shallow metadata via a .d.ts file\n    // for the symbol.\n    const resultFromSummary = this._resolveSymbolFromSummary(staticSymbol)!;\n    if (resultFromSummary) {\n      return resultFromSummary;\n    }\n    const resultFromCache = this.resolvedSymbols.get(staticSymbol);\n    if (resultFromCache) {\n      return resultFromCache;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    this._createSymbolsOf(staticSymbol.filePath);\n    return this.resolvedSymbols.get(staticSymbol)!;\n  }\n\n  /**\n   * getImportAs produces a symbol that can be used to import the given symbol.\n   * The import might be different than the symbol if the symbol is exported from\n   * a library with a summary; in which case we want to import the symbol from the\n   * ngfactory re-export instead of directly to avoid introducing a direct dependency\n   * on an otherwise indirect dependency.\n   *\n   * @param staticSymbol the symbol for which to generate a import symbol\n   */\n  getImportAs(staticSymbol: StaticSymbol, useSummaries: boolean = true): StaticSymbol|null {\n    if (staticSymbol.members.length) {\n      const baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n      return baseImportAs ?\n          this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n          null;\n    }\n    const summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n    if (summarizedFileName !== staticSymbol.filePath) {\n      const summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n      const baseSymbol =\n          this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n      const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n      return baseImportAs ? this.getStaticSymbol(\n                                summaryForJitFileName(baseImportAs.filePath),\n                                summaryForJitName(baseImportAs.name), baseSymbol.members) :\n                            null;\n    }\n    let result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;\n    if (!result) {\n      result = this.importAs.get(staticSymbol)!;\n    }\n    return result;\n  }\n\n  /**\n   * getResourcePath produces the path to the original location of the symbol and should\n   * be used to determine the relative location of resource references recorded in\n   * symbol metadata.\n   */\n  getResourcePath(staticSymbol: StaticSymbol): string {\n    return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n  }\n\n  /**\n   * getTypeArity returns the number of generic type parameters the given symbol\n   * has. If the symbol is not a type the result is null.\n   */\n  getTypeArity(staticSymbol: StaticSymbol): number|null {\n    // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n    // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n    // All references to generated classes must include the correct arity whenever\n    // generating code.\n    if (isGeneratedFile(staticSymbol.filePath)) {\n      return null;\n    }\n    let resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n    while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n      resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n    }\n    return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n  }\n\n  getKnownModuleName(filePath: string): string|null {\n    return this.knownFileNameToModuleNames.get(filePath) || null;\n  }\n\n  recordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol) {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    this.importAs.set(sourceSymbol, targetSymbol);\n  }\n\n  recordModuleNameForFileName(fileName: string, moduleName: string) {\n    this.knownFileNameToModuleNames.set(fileName, moduleName);\n  }\n\n  /**\n   * Invalidate all information derived from the given file and return the\n   * static symbols contained in the file.\n   *\n   * @param fileName the file to invalidate\n   */\n  invalidateFile(fileName: string): StaticSymbol[] {\n    this.metadataCache.delete(fileName);\n    const symbols = this.symbolFromFile.get(fileName);\n    if (!symbols) {\n      return [];\n    }\n    this.symbolFromFile.delete(fileName);\n    for (const symbol of symbols) {\n      this.resolvedSymbols.delete(symbol);\n      this.importAs.delete(symbol);\n      this.symbolResourcePaths.delete(symbol);\n    }\n    return symbols;\n  }\n\n  /** @internal */\n  ignoreErrorsFor<T>(cb: () => T) {\n    const recorder = this.errorRecorder;\n    this.errorRecorder = () => {};\n    try {\n      return cb();\n    } finally {\n      this.errorRecorder = recorder;\n    }\n  }\n\n  private _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const members = staticSymbol.members;\n    const baseResolvedSymbol =\n        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n    if (!baseResolvedSymbol) {\n      return null;\n    }\n    let baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n    if (baseMetadata instanceof StaticSymbol) {\n      return new ResolvedStaticSymbol(\n          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n      if (baseMetadata.statics && members.length === 1) {\n        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n      }\n    } else {\n      let value = baseMetadata;\n      for (let i = 0; i < members.length && value; i++) {\n        value = value[members[i]];\n      }\n      return new ResolvedStaticSymbol(staticSymbol, value);\n    }\n    return null;\n  }\n\n  private _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const summary = this.summaryResolver.resolveSummary(staticSymbol);\n    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n  }\n\n  /**\n   * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n   * All types passed to the StaticResolver should be pseudo-types returned by this method.\n   *\n   * @param declarationFile the absolute path of the file where the symbol is declared\n   * @param name the name of the type.\n   * @param members a symbol for a static member of the named type\n   */\n  getStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.staticSymbolCache.get(declarationFile, name, members);\n  }\n\n  /**\n   * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\n   * metadata.\n   *\n   * @param filePath the absolute path to examine for decorators.\n   * @returns true if any class in the file has a decorator.\n   */\n  hasDecorators(filePath: string): boolean {\n    const metadata = this.getModuleMetadata(filePath);\n    if (metadata['metadata']) {\n      return Object.keys(metadata['metadata']).some((metadataKey) => {\n        const entry = metadata['metadata'][metadataKey];\n        return entry && entry.__symbolic === 'class' && entry.decorators;\n      });\n    }\n    return false;\n  }\n\n  getSymbolsOf(filePath: string): StaticSymbol[] {\n    const summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n    if (summarySymbols) {\n      return summarySymbols;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n    this._createSymbolsOf(filePath);\n    return this.symbolFromFile.get(filePath) || [];\n  }\n\n  private _createSymbolsOf(filePath: string) {\n    if (this.symbolFromFile.has(filePath)) {\n      return;\n    }\n    const resolvedSymbols: ResolvedStaticSymbol[] = [];\n    const metadata = this.getModuleMetadata(filePath);\n    if (metadata['importAs']) {\n      // Index bundle indices should use the importAs module name defined\n      // in the bundle.\n      this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n    }\n    // handle the symbols in one of the re-export location\n    if (metadata['exports']) {\n      for (const moduleExport of metadata['exports']) {\n        // handle the symbols in the list of explicitly re-exported symbols.\n        if (moduleExport.export) {\n          moduleExport.export.forEach((exportSymbol: any) => {\n            let symbolName: string;\n            if (typeof exportSymbol === 'string') {\n              symbolName = exportSymbol;\n            } else {\n              symbolName = exportSymbol.as;\n            }\n            symbolName = unescapeIdentifier(symbolName);\n            let symName = symbolName;\n            if (typeof exportSymbol !== 'string') {\n              symName = unescapeIdentifier(exportSymbol.name);\n            }\n            const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n            if (resolvedModule) {\n              const targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n              const sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            }\n          });\n        } else {\n          // Handle the symbols loaded by 'export *' directives.\n          const resolvedModule = this.resolveModule(moduleExport.from, filePath);\n          if (resolvedModule && resolvedModule !== filePath) {\n            const nestedExports = this.getSymbolsOf(resolvedModule);\n            nestedExports.forEach((targetSymbol) => {\n              const sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            });\n          }\n        }\n      }\n    }\n\n    // handle the actual metadata. Has to be after the exports\n    // as there might be collisions in the names, and we want the symbols\n    // of the current module to win ofter reexports.\n    if (metadata['metadata']) {\n      // handle direct declarations of the symbol\n      const topLevelSymbolNames =\n          new Set<string>(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n      const origins: {[index: string]: string} = metadata['origins'] || {};\n      Object.keys(metadata['metadata']).forEach((metadataKey) => {\n        const symbolMeta = metadata['metadata'][metadataKey];\n        const name = unescapeIdentifier(metadataKey);\n\n        const symbol = this.getStaticSymbol(filePath, name);\n\n        const origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\n        if (origin) {\n          // If the symbol is from a bundled index, use the declaration location of the\n          // symbol so relative references (such as './my.html') will be calculated\n          // correctly.\n          const originFilePath = this.resolveModule(origin, filePath);\n          if (!originFilePath) {\n            this.reportError(new Error(`Couldn't resolve original symbol for ${origin} from ${\n                this.host.getOutputName(filePath)}`));\n          } else {\n            this.symbolResourcePaths.set(symbol, originFilePath);\n          }\n        }\n        resolvedSymbols.push(\n            this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\n      });\n    }\n    const uniqueSymbols = new Set<StaticSymbol>();\n    for (const resolvedSymbol of resolvedSymbols) {\n      this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);\n      uniqueSymbols.add(resolvedSymbol.symbol);\n    }\n    this.symbolFromFile.set(filePath, Array.from(uniqueSymbols));\n  }\n\n  private createResolvedSymbol(\n      sourceSymbol: StaticSymbol, topLevelPath: string, topLevelSymbolNames: Set<string>,\n      metadata: any): ResolvedStaticSymbol {\n    // For classes that don't have Angular summaries / metadata,\n    // we only keep their arity, but nothing else\n    // (e.g. their constructor parameters).\n    // We do this to prevent introducing deep imports\n    // as we didn't generate .ngfactory.ts files with proper reexports.\n    const isTsFile = TS.test(sourceSymbol.filePath);\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&\n        metadata['__symbolic'] === 'class') {\n      const transformedMeta = {__symbolic: 'class', arity: metadata.arity};\n      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    }\n\n    let _originalFileMemo: string|undefined;\n    const getOriginalName: () => string = () => {\n      if (!_originalFileMemo) {\n        // Guess what the original file name is from the reference. If it has a `.d.ts` extension\n        // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n        // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n        // location as it is not important to finding the file.\n        _originalFileMemo =\n            this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts')\n                                        .replace(/^.*node_modules[/\\\\]/, ''));\n      }\n      return _originalFileMemo;\n    };\n\n    const self = this;\n\n    class ReferenceTransformer extends ValueTransformer {\n      visitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n        const symbolic = map['__symbolic'];\n        if (symbolic === 'function') {\n          const oldLen = functionParams.length;\n          functionParams.push(...(map['parameters'] || []));\n          const result = super.visitStringMap(map, functionParams);\n          functionParams.length = oldLen;\n          return result;\n        } else if (symbolic === 'reference') {\n          const module = map['module'];\n          const name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n          if (!name) {\n            return null;\n          }\n          let filePath: string;\n          if (module) {\n            filePath = self.resolveModule(module, sourceSymbol.filePath)!;\n            if (!filePath) {\n              return {\n                __symbolic: 'error',\n                message: `Could not resolve ${module} relative to ${\n                    self.host.getMetadataFor(sourceSymbol.filePath)}.`,\n                line: map['line'],\n                character: map['character'],\n                fileName: getOriginalName()\n              };\n            }\n            return {\n              __symbolic: 'resolved',\n              symbol: self.getStaticSymbol(filePath, name),\n              line: map['line'],\n              character: map['character'],\n              fileName: getOriginalName()\n            };\n          } else if (functionParams.indexOf(name) >= 0) {\n            // reference to a function parameter\n            return {__symbolic: 'reference', name: name};\n          } else {\n            if (topLevelSymbolNames.has(name)) {\n              return self.getStaticSymbol(topLevelPath, name);\n            }\n            // ambient value\n            null;\n          }\n        } else if (symbolic === 'error') {\n          return {...map, fileName: getOriginalName()};\n        } else {\n          return super.visitStringMap(map, functionParams);\n        }\n      }\n    }\n    const transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n    let unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n    if (unwrappedTransformedMeta instanceof StaticSymbol) {\n      return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n  }\n\n  private createExport(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol):\n      ResolvedStaticSymbol {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\n        this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n      // This case is for an ng library importing symbols from a plain ts library\n      // transitively.\n      // Note: We rely on the fact that we discover symbols in the direction\n      // from source files to library files\n      this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n  }\n\n  private reportError(error: Error, context?: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(error, (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n\n  /**\n   * @param module an absolute path to a module file.\n   */\n  private getModuleMetadata(module: string): {[key: string]: any} {\n    let moduleMetadata = this.metadataCache.get(module);\n    if (!moduleMetadata) {\n      const moduleMetadatas = this.host.getMetadataFor(module);\n      if (moduleMetadatas) {\n        let maxVersion = -1;\n        moduleMetadatas.forEach((md) => {\n          if (md && md['version'] > maxVersion) {\n            maxVersion = md['version'];\n            moduleMetadata = md;\n          }\n        });\n      }\n      if (!moduleMetadata) {\n        moduleMetadata =\n            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n      }\n      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n        const errorMessage = moduleMetadata['version'] == 2 ?\n            `Unsupported metadata version ${moduleMetadata['version']} for module ${\n                module}. This module should be compiled with a newer version of ngc` :\n            `Metadata version mismatch for module ${\n                this.host.getOutputName(module)}, found version ${\n                moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n        this.reportError(new Error(errorMessage));\n      }\n      this.metadataCache.set(module, moduleMetadata);\n    }\n    return moduleMetadata;\n  }\n\n\n  getSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n    const filePath = this.resolveModule(module, containingFile);\n    if (!filePath) {\n      this.reportError(new Error(`Could not resolve module ${module}${\n          containingFile ? ' relative to ' + this.host.getOutputName(containingFile) : ''}`));\n      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n    }\n    return this.getStaticSymbol(filePath, symbolName);\n  }\n\n  private resolveModule(module: string, containingFile?: string): string|null {\n    try {\n      return this.host.moduleNameToFileName(module, containingFile);\n    } catch (e) {\n      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n      this.reportError(e, undefined, containingFile);\n    }\n    return null;\n  }\n}\n\n// Remove extra underscore from escaped identifier.\n// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\nexport function unescapeIdentifier(identifier: string): string {\n  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n\nexport function unwrapResolvedMetadata(metadata: any): any {\n  if (metadata && metadata.__symbolic === 'resolved') {\n    return metadata.symbol;\n  }\n  return metadata;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}