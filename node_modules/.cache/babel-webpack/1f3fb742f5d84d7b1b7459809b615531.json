{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findTests = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar fs_1 = require(\"fs\");\n\nvar glob = require(\"glob\");\n\nvar path_1 = require(\"path\");\n\nvar is_directory_1 = require(\"../utils/is-directory\"); // go through all patterns and find unique list of files\n\n\nfunction findTests(patterns, cwd, workspaceRoot) {\n  return patterns.reduce(function (files, pattern) {\n    var relativePathToMain = cwd.replace(workspaceRoot, '').substr(1); // remove leading slash\n\n    var tests = findMatchingTests(pattern, cwd, relativePathToMain);\n    tests.forEach(function (file) {\n      if (!files.includes(file)) {\n        files.push(file);\n      }\n    });\n    return files;\n  }, []);\n}\n\nexports.findTests = findTests;\n\nfunction findMatchingTests(pattern, cwd, relativePathToMain) {\n  // normalize pattern, glob lib only accepts forward slashes\n  pattern = pattern.replace(/\\\\/g, '/');\n  relativePathToMain = relativePathToMain.replace(/\\\\/g, '/'); // remove relativePathToMain to support relative paths from root\n  // such paths are easy to get when running scripts via IDEs\n\n  if (pattern.startsWith(relativePathToMain + '/')) {\n    pattern = pattern.substr(relativePathToMain.length + 1); // +1 to include slash\n  } // special logic when pattern does not look like a glob\n\n\n  if (!glob.hasMagic(pattern)) {\n    if (is_directory_1.isDirectory(path_1.join(cwd, pattern))) {\n      pattern = \"\".concat(pattern, \"/**/*.spec.@(ts|tsx)\");\n    } else {\n      // see if matching spec file exists\n      var extension = path_1.extname(pattern);\n      var matchingSpec = \"\".concat(path_1.basename(pattern, extension), \".spec\").concat(extension);\n\n      if (fs_1.existsSync(path_1.join(cwd, path_1.dirname(pattern), matchingSpec))) {\n        pattern = path_1.join(path_1.dirname(pattern), matchingSpec).replace(/\\\\/g, '/');\n      }\n    }\n  }\n\n  var files = glob.sync(pattern, {\n    cwd: cwd\n  });\n  return files;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/src/karma/find-tests.js"],"names":["Object","defineProperty","exports","value","findTests","fs_1","require","glob","path_1","is_directory_1","patterns","cwd","workspaceRoot","reduce","files","pattern","relativePathToMain","replace","substr","tests","findMatchingTests","forEach","file","includes","push","startsWith","length","hasMagic","isDirectory","join","extension","extname","matchingSpec","basename","existsSync","dirname","sync"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findTests = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst fs_1 = require(\"fs\");\nconst glob = require(\"glob\");\nconst path_1 = require(\"path\");\nconst is_directory_1 = require(\"../utils/is-directory\");\n// go through all patterns and find unique list of files\nfunction findTests(patterns, cwd, workspaceRoot) {\n    return patterns.reduce((files, pattern) => {\n        const relativePathToMain = cwd.replace(workspaceRoot, '').substr(1); // remove leading slash\n        const tests = findMatchingTests(pattern, cwd, relativePathToMain);\n        tests.forEach(file => {\n            if (!files.includes(file)) {\n                files.push(file);\n            }\n        });\n        return files;\n    }, []);\n}\nexports.findTests = findTests;\nfunction findMatchingTests(pattern, cwd, relativePathToMain) {\n    // normalize pattern, glob lib only accepts forward slashes\n    pattern = pattern.replace(/\\\\/g, '/');\n    relativePathToMain = relativePathToMain.replace(/\\\\/g, '/');\n    // remove relativePathToMain to support relative paths from root\n    // such paths are easy to get when running scripts via IDEs\n    if (pattern.startsWith(relativePathToMain + '/')) {\n        pattern = pattern.substr(relativePathToMain.length + 1); // +1 to include slash\n    }\n    // special logic when pattern does not look like a glob\n    if (!glob.hasMagic(pattern)) {\n        if (is_directory_1.isDirectory(path_1.join(cwd, pattern))) {\n            pattern = `${pattern}/**/*.spec.@(ts|tsx)`;\n        }\n        else {\n            // see if matching spec file exists\n            const extension = path_1.extname(pattern);\n            const matchingSpec = `${path_1.basename(pattern, extension)}.spec${extension}`;\n            if (fs_1.existsSync(path_1.join(cwd, path_1.dirname(pattern), matchingSpec))) {\n                pattern = path_1.join(path_1.dirname(pattern), matchingSpec).replace(/\\\\/g, '/');\n            }\n        }\n    }\n    const files = glob.sync(pattern, {\n        cwd,\n    });\n    return files;\n}\n"]},"metadata":{},"sourceType":"script"}