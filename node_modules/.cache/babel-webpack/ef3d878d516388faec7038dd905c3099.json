{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _defineProperty = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readJsonWorkspace = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar json_1 = require(\"../../json\");\n\nvar definitions_1 = require(\"../definitions\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar utilities_1 = require(\"./utilities\");\n\nfunction readJsonWorkspace(_x, _x2) {\n  return _readJsonWorkspace.apply(this, arguments);\n}\n\nfunction _readJsonWorkspace() {\n  _readJsonWorkspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, host) {\n    var raw, ast, versionNode, formatVersion, context, workspace;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return host.readFile(path);\n\n          case 2:\n            raw = _context.sent;\n\n            if (!(raw === undefined)) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new Error('Unable to read workspace file.');\n\n          case 5:\n            ast = json_1.parseJsonAst(raw, json_1.JsonParseMode.Loose);\n\n            if (!(ast.kind !== 'object')) {\n              _context.next = 8;\n              break;\n            }\n\n            throw new Error('Invalid workspace file - expected JSON object.');\n\n          case 8:\n            // Version check\n            versionNode = ast.properties.find(function (pair) {\n              return pair.key.value === 'version';\n            });\n\n            if (versionNode) {\n              _context.next = 11;\n              break;\n            }\n\n            throw new Error('Unknown format - version specifier not found.');\n\n          case 11:\n            formatVersion = versionNode.value.value;\n\n            if (!(formatVersion !== 1)) {\n              _context.next = 14;\n              break;\n            }\n\n            throw new Error(\"Invalid format version detected - Expected:[ 1 ] Found: [ \".concat(formatVersion, \" ]\"));\n\n          case 14:\n            context = {\n              host: host,\n              metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n              trackChanges: true,\n              error: function error(message, _node) {\n                // TODO: Diagnostic reporting support\n                throw new Error(message);\n              },\n              warn: function warn(_message, _node) {// TODO: Diagnostic reporting support\n              }\n            };\n            workspace = parseWorkspace(ast, context);\n            return _context.abrupt(\"return\", workspace);\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _readJsonWorkspace.apply(this, arguments);\n}\n\nexports.readJsonWorkspace = readJsonWorkspace;\nvar specialWorkspaceExtensions = ['cli', 'defaultProject', 'newProjectRoot', 'schematics'];\nvar specialProjectExtensions = ['cli', 'schematics', 'projectType'];\n\nfunction parseWorkspace(workspaceNode, context) {\n  var _ref;\n\n  var jsonMetadata = context.metadata;\n  var projects;\n  var projectsNode;\n  var extensions;\n\n  if (!context.trackChanges) {\n    extensions = Object.create(null);\n  }\n\n  var _iterator = _createForOfIteratorHelper(workspaceNode.properties),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _step.value,\n          key = _step$value.key,\n          value = _step$value.value;\n      var name = key.value;\n\n      if (name === '$schema' || name === 'version') {// skip\n      } else if (name === 'projects') {\n        if (value.kind !== 'object') {\n          context.error('Invalid \"projects\" field found; expected an object.', value);\n          continue;\n        }\n\n        projectsNode = value;\n        projects = parseProjectsObject(value, context);\n      } else {\n        if (!specialWorkspaceExtensions.includes(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n          context.warn(\"Project extension with invalid name found.\", key);\n        }\n\n        if (extensions) {\n          extensions[name] = value.value;\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var collectionListener;\n\n  if (context.trackChanges && projectsNode) {\n    var parentNode = projectsNode;\n\n    collectionListener = function collectionListener(name, action, newValue) {\n      jsonMetadata.addChange(action, \"/projects/\".concat(utilities_1.escapeKey(name)), parentNode, newValue, 'project');\n    };\n  }\n\n  var projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n  return _ref = {}, _defineProperty(_ref, metadata_1.JsonWorkspaceSymbol, jsonMetadata), _defineProperty(_ref, \"projects\", projectCollection), _defineProperty(_ref, \"extensions\", extensions || utilities_1.createVirtualAstObject(workspaceNode, {\n    exclude: ['$schema', 'version', 'projects'],\n    listener: function listener(op, path, node, value) {\n      jsonMetadata.addChange(op, path, node, value);\n    }\n  })), _ref;\n}\n\nfunction parseProjectsObject(projectsNode, context) {\n  var projects = Object.create(null);\n\n  var _iterator2 = _createForOfIteratorHelper(projectsNode.properties),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _step2.value,\n          key = _step2$value.key,\n          value = _step2$value.value;\n\n      if (value.kind !== 'object') {\n        context.warn('Skipping invalid project value; expected an object.', value);\n        continue;\n      }\n\n      var name = key.value;\n      projects[name] = parseProject(name, value, context);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return projects;\n}\n\nfunction parseProject(projectName, projectNode, context) {\n  var jsonMetadata = context.metadata;\n  var targets;\n  var targetsNode;\n  var extensions;\n  var properties;\n\n  if (!context.trackChanges) {\n    // If not tracking changes, the parser will store the values directly in standard objects\n    extensions = Object.create(null);\n    properties = Object.create(null);\n  }\n\n  var _iterator3 = _createForOfIteratorHelper(projectNode.properties),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _step3.value,\n          key = _step3$value.key,\n          value = _step3$value.value;\n      var name = key.value;\n\n      switch (name) {\n        case 'targets':\n        case 'architect':\n          if (value.kind !== 'object') {\n            context.error(\"Invalid \\\"\".concat(name, \"\\\" field found; expected an object.\"), value);\n            break;\n          }\n\n          targetsNode = value;\n          targets = parseTargetsObject(projectName, value, context);\n          break;\n\n        case 'prefix':\n        case 'root':\n        case 'sourceRoot':\n          if (value.kind !== 'string') {\n            context.warn(\"Project property \\\"\".concat(name, \"\\\" should be a string.\"), value);\n          }\n\n          if (properties) {\n            properties[name] = value.value;\n          }\n\n          break;\n\n        default:\n          if (!specialProjectExtensions.includes(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n            context.warn(\"Project extension with invalid name found.\", key);\n          }\n\n          if (extensions) {\n            extensions[name] = value.value;\n          }\n\n          break;\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var collectionListener;\n\n  if (context.trackChanges) {\n    if (targetsNode) {\n      var parentNode = targetsNode;\n\n      collectionListener = function collectionListener(name, action, newValue) {\n        jsonMetadata.addChange(action, \"/projects/\".concat(projectName, \"/targets/\").concat(utilities_1.escapeKey(name)), parentNode, newValue, 'target');\n      };\n    } else {\n      var added = false;\n\n      collectionListener = function collectionListener(_name, action, _new, _old, collection) {\n        if (added || action !== 'add') {\n          return;\n        }\n\n        jsonMetadata.addChange('add', \"/projects/\".concat(projectName, \"/targets\"), projectNode, collection, 'targetcollection');\n        added = true;\n      };\n    }\n  }\n\n  var base = {\n    targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions || utilities_1.createVirtualAstObject(projectNode, {\n      exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n      listener: function listener(op, path, node, value) {\n        jsonMetadata.addChange(op, \"/projects/\".concat(projectName).concat(path), node, value);\n      }\n    })\n  };\n  var project;\n\n  if (context.trackChanges) {\n    project = utilities_1.createVirtualAstObject(projectNode, {\n      base: base,\n      include: ['prefix', 'root', 'sourceRoot'],\n      listener: function listener(op, path, node, value) {\n        jsonMetadata.addChange(op, \"/projects/\".concat(projectName).concat(path), node, value);\n      }\n    });\n  } else {\n    project = _objectSpread(_objectSpread({}, base), properties);\n  }\n\n  return project;\n}\n\nfunction parseTargetsObject(projectName, targetsNode, context) {\n  var jsonMetadata = context.metadata;\n  var targets = Object.create(null);\n\n  var _iterator4 = _createForOfIteratorHelper(targetsNode.properties),\n      _step4;\n\n  try {\n    var _loop = function _loop() {\n      var _step4$value = _step4.value,\n          key = _step4$value.key,\n          value = _step4$value.value;\n\n      if (value.kind !== 'object') {\n        context.warn('Skipping invalid target value; expected an object.', value);\n        return \"continue\";\n      }\n\n      var name = key.value;\n\n      if (context.trackChanges) {\n        targets[name] = utilities_1.createVirtualAstObject(value, {\n          include: ['builder', 'options', 'configurations'],\n          listener: function listener(op, path, node, value) {\n            jsonMetadata.addChange(op, \"/projects/\".concat(projectName, \"/targets/\").concat(name).concat(path), node, value);\n          }\n        });\n      } else {\n        targets[name] = value.value;\n      }\n    };\n\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var _ret = _loop();\n\n      if (_ret === \"continue\") continue;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return targets;\n}","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/workspace/json/reader.js"],"names":["Object","defineProperty","exports","value","readJsonWorkspace","json_1","require","definitions_1","metadata_1","utilities_1","path","host","readFile","raw","undefined","Error","ast","parseJsonAst","JsonParseMode","Loose","kind","versionNode","properties","find","pair","key","formatVersion","context","metadata","JsonWorkspaceMetadata","trackChanges","error","message","_node","warn","_message","workspace","parseWorkspace","specialWorkspaceExtensions","specialProjectExtensions","workspaceNode","jsonMetadata","projects","projectsNode","extensions","create","name","parseProjectsObject","includes","test","collectionListener","parentNode","action","newValue","addChange","escapeKey","projectCollection","ProjectDefinitionCollection","JsonWorkspaceSymbol","createVirtualAstObject","exclude","listener","op","node","parseProject","projectName","projectNode","targets","targetsNode","parseTargetsObject","added","_name","_new","_old","collection","base","TargetDefinitionCollection","project","include"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readJsonWorkspace = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst json_1 = require(\"../../json\");\nconst definitions_1 = require(\"../definitions\");\nconst metadata_1 = require(\"./metadata\");\nconst utilities_1 = require(\"./utilities\");\nasync function readJsonWorkspace(path, host) {\n    const raw = await host.readFile(path);\n    if (raw === undefined) {\n        throw new Error('Unable to read workspace file.');\n    }\n    const ast = json_1.parseJsonAst(raw, json_1.JsonParseMode.Loose);\n    if (ast.kind !== 'object') {\n        throw new Error('Invalid workspace file - expected JSON object.');\n    }\n    // Version check\n    const versionNode = ast.properties.find(pair => pair.key.value === 'version');\n    if (!versionNode) {\n        throw new Error('Unknown format - version specifier not found.');\n    }\n    const formatVersion = versionNode.value.value;\n    if (formatVersion !== 1) {\n        throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${formatVersion} ]`);\n    }\n    const context = {\n        host,\n        metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n        trackChanges: true,\n        error(message, _node) {\n            // TODO: Diagnostic reporting support\n            throw new Error(message);\n        },\n        warn(_message, _node) {\n            // TODO: Diagnostic reporting support\n        },\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n}\nexports.readJsonWorkspace = readJsonWorkspace;\nconst specialWorkspaceExtensions = ['cli', 'defaultProject', 'newProjectRoot', 'schematics'];\nconst specialProjectExtensions = ['cli', 'schematics', 'projectType'];\nfunction parseWorkspace(workspaceNode, context) {\n    const jsonMetadata = context.metadata;\n    let projects;\n    let projectsNode;\n    let extensions;\n    if (!context.trackChanges) {\n        extensions = Object.create(null);\n    }\n    for (const { key, value } of workspaceNode.properties) {\n        const name = key.value;\n        if (name === '$schema' || name === 'version') {\n            // skip\n        }\n        else if (name === 'projects') {\n            if (value.kind !== 'object') {\n                context.error('Invalid \"projects\" field found; expected an object.', value);\n                continue;\n            }\n            projectsNode = value;\n            projects = parseProjectsObject(value, context);\n        }\n        else {\n            if (!specialWorkspaceExtensions.includes(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                context.warn(`Project extension with invalid name found.`, key);\n            }\n            if (extensions) {\n                extensions[name] = value.value;\n            }\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges && projectsNode) {\n        const parentNode = projectsNode;\n        collectionListener = (name, action, newValue) => {\n            jsonMetadata.addChange(action, `/projects/${utilities_1.escapeKey(name)}`, parentNode, newValue, 'project');\n        };\n    }\n    const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n    return {\n        [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n        projects: projectCollection,\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions ||\n            utilities_1.createVirtualAstObject(workspaceNode, {\n                exclude: ['$schema', 'version', 'projects'],\n                listener(op, path, node, value) {\n                    jsonMetadata.addChange(op, path, node, value);\n                },\n            }),\n    };\n}\nfunction parseProjectsObject(projectsNode, context) {\n    const projects = Object.create(null);\n    for (const { key, value } of projectsNode.properties) {\n        if (value.kind !== 'object') {\n            context.warn('Skipping invalid project value; expected an object.', value);\n            continue;\n        }\n        const name = key.value;\n        projects[name] = parseProject(name, value, context);\n    }\n    return projects;\n}\nfunction parseProject(projectName, projectNode, context) {\n    const jsonMetadata = context.metadata;\n    let targets;\n    let targetsNode;\n    let extensions;\n    let properties;\n    if (!context.trackChanges) {\n        // If not tracking changes, the parser will store the values directly in standard objects\n        extensions = Object.create(null);\n        properties = Object.create(null);\n    }\n    for (const { key, value } of projectNode.properties) {\n        const name = key.value;\n        switch (name) {\n            case 'targets':\n            case 'architect':\n                if (value.kind !== 'object') {\n                    context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n                    break;\n                }\n                targetsNode = value;\n                targets = parseTargetsObject(projectName, value, context);\n                break;\n            case 'prefix':\n            case 'root':\n            case 'sourceRoot':\n                if (value.kind !== 'string') {\n                    context.warn(`Project property \"${name}\" should be a string.`, value);\n                }\n                if (properties) {\n                    properties[name] = value.value;\n                }\n                break;\n            default:\n                if (!specialProjectExtensions.includes(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n                    context.warn(`Project extension with invalid name found.`, key);\n                }\n                if (extensions) {\n                    extensions[name] = value.value;\n                }\n                break;\n        }\n    }\n    let collectionListener;\n    if (context.trackChanges) {\n        if (targetsNode) {\n            const parentNode = targetsNode;\n            collectionListener = (name, action, newValue) => {\n                jsonMetadata.addChange(action, `/projects/${projectName}/targets/${utilities_1.escapeKey(name)}`, parentNode, newValue, 'target');\n            };\n        }\n        else {\n            let added = false;\n            collectionListener = (_name, action, _new, _old, collection) => {\n                if (added || action !== 'add') {\n                    return;\n                }\n                jsonMetadata.addChange('add', `/projects/${projectName}/targets`, projectNode, collection, 'targetcollection');\n                added = true;\n            };\n        }\n    }\n    const base = {\n        targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n        // If not tracking changes the `extensions` variable will contain the parsed\n        // values.  Otherwise the extensions are tracked via a virtual AST object.\n        extensions: extensions ||\n            utilities_1.createVirtualAstObject(projectNode, {\n                exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n                listener(op, path, node, value) {\n                    jsonMetadata.addChange(op, `/projects/${projectName}${path}`, node, value);\n                },\n            }),\n    };\n    let project;\n    if (context.trackChanges) {\n        project = utilities_1.createVirtualAstObject(projectNode, {\n            base,\n            include: ['prefix', 'root', 'sourceRoot'],\n            listener(op, path, node, value) {\n                jsonMetadata.addChange(op, `/projects/${projectName}${path}`, node, value);\n            },\n        });\n    }\n    else {\n        project = {\n            ...base,\n            ...properties,\n        };\n    }\n    return project;\n}\nfunction parseTargetsObject(projectName, targetsNode, context) {\n    const jsonMetadata = context.metadata;\n    const targets = Object.create(null);\n    for (const { key, value } of targetsNode.properties) {\n        if (value.kind !== 'object') {\n            context.warn('Skipping invalid target value; expected an object.', value);\n            continue;\n        }\n        const name = key.value;\n        if (context.trackChanges) {\n            targets[name] = utilities_1.createVirtualAstObject(value, {\n                include: ['builder', 'options', 'configurations'],\n                listener(op, path, node, value) {\n                    jsonMetadata.addChange(op, `/projects/${projectName}/targets/${name}${path}`, node, value);\n                },\n            });\n        }\n        else {\n            targets[name] = value.value;\n        }\n    }\n    return targets;\n}\n"]},"metadata":{},"sourceType":"script"}