{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeSchemas = exports.isJsonSchema = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar utils_1 = require(\"../../utils\");\n\nvar interface_1 = require(\"../interface\");\n\nfunction isJsonSchema(value) {\n  return interface_1.isJsonObject(value) || value === false || value === true;\n}\n\nexports.isJsonSchema = isJsonSchema;\n/**\n * Return a schema that is the merge of all subschemas, ie. it should validate all the schemas\n * that were passed in. It is possible to make an invalid schema this way, e.g. by using\n * `mergeSchemas({ type: 'number' }, { type: 'string' })`, which will never validate.\n * @param schemas All schemas to be merged.\n */\n\nfunction mergeSchemas() {\n  for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n    schemas[_key] = arguments[_key];\n  }\n\n  return utils_1.clean(schemas).reduce(function (prev, curr) {\n    if (prev === false || curr === false) {\n      return false;\n    } else if (prev === true) {\n      return curr;\n    } else if (curr === true) {\n      return prev;\n    } else if (Array.isArray(prev.allOf)) {\n      if (Array.isArray(curr.allOf)) {\n        return _objectSpread(_objectSpread({}, prev), {}, {\n          allOf: [].concat(_toConsumableArray(prev.allOf), _toConsumableArray(curr.allOf))\n        });\n      } else {\n        return _objectSpread(_objectSpread({}, prev), {}, {\n          allOf: [].concat(_toConsumableArray(prev.allOf), [curr])\n        });\n      }\n    } else if (Array.isArray(curr.allOf)) {\n      return _objectSpread(_objectSpread({}, prev), {}, {\n        allOf: [prev].concat(_toConsumableArray(curr.allOf))\n      });\n    } else {\n      return _objectSpread(_objectSpread({}, prev), {}, {\n        allOf: [prev, curr]\n      });\n    }\n  }, true);\n}\n\nexports.mergeSchemas = mergeSchemas;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@angular-devkit/build-angular/node_modules/@angular-devkit/core/src/json/schema/schema.js"],"names":["Object","defineProperty","exports","value","mergeSchemas","isJsonSchema","utils_1","require","interface_1","isJsonObject","schemas","clean","reduce","prev","curr","Array","isArray","allOf"],"mappings":"AAAA;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,YAAR,GAAuBF,OAAO,CAACG,YAAR,GAAuB,KAAK,CAAnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,OAAO,GAAGC,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAMC,WAAW,GAAGD,OAAO,CAAC,cAAD,CAA3B;;AACA,SAASF,YAAT,CAAsBF,KAAtB,EAA6B;AACzB,SAAOK,WAAW,CAACC,YAAZ,CAAyBN,KAAzB,KAAmCA,KAAK,KAAK,KAA7C,IAAsDA,KAAK,KAAK,IAAvE;AACH;;AACDD,OAAO,CAACG,YAAR,GAAuBA,YAAvB;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASD,YAAT,GAAkC;AAAA,oCAATM,OAAS;AAATA,IAAAA,OAAS;AAAA;;AAC9B,SAAOJ,OAAO,CAACK,KAAR,CAAcD,OAAd,EAAuBE,MAAvB,CAA8B,UAACC,IAAD,EAAOC,IAAP,EAAgB;AACjD,QAAID,IAAI,KAAK,KAAT,IAAkBC,IAAI,KAAK,KAA/B,EAAsC;AAClC,aAAO,KAAP;AACH,KAFD,MAGK,IAAID,IAAI,KAAK,IAAb,EAAmB;AACpB,aAAOC,IAAP;AACH,KAFI,MAGA,IAAIA,IAAI,KAAK,IAAb,EAAmB;AACpB,aAAOD,IAAP;AACH,KAFI,MAGA,IAAIE,KAAK,CAACC,OAAN,CAAcH,IAAI,CAACI,KAAnB,CAAJ,EAA+B;AAChC,UAAIF,KAAK,CAACC,OAAN,CAAcF,IAAI,CAACG,KAAnB,CAAJ,EAA+B;AAC3B,+CAAYJ,IAAZ;AAAkBI,UAAAA,KAAK,+BAAMJ,IAAI,CAACI,KAAX,sBAAqBH,IAAI,CAACG,KAA1B;AAAvB;AACH,OAFD,MAGK;AACD,+CAAYJ,IAAZ;AAAkBI,UAAAA,KAAK,+BAAMJ,IAAI,CAACI,KAAX,IAAkBH,IAAlB;AAAvB;AACH;AACJ,KAPI,MAQA,IAAIC,KAAK,CAACC,OAAN,CAAcF,IAAI,CAACG,KAAnB,CAAJ,EAA+B;AAChC,6CAAYJ,IAAZ;AAAkBI,QAAAA,KAAK,GAAGJ,IAAH,4BAAYC,IAAI,CAACG,KAAjB;AAAvB;AACH,KAFI,MAGA;AACD,6CAAYJ,IAAZ;AAAkBI,QAAAA,KAAK,EAAE,CAACJ,IAAD,EAAOC,IAAP;AAAzB;AACH;AACJ,GAxBM,EAwBJ,IAxBI,CAAP;AAyBH;;AACDZ,OAAO,CAACE,YAAR,GAAuBA,YAAvB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mergeSchemas = exports.isJsonSchema = void 0;\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst utils_1 = require(\"../../utils\");\nconst interface_1 = require(\"../interface\");\nfunction isJsonSchema(value) {\n    return interface_1.isJsonObject(value) || value === false || value === true;\n}\nexports.isJsonSchema = isJsonSchema;\n/**\n * Return a schema that is the merge of all subschemas, ie. it should validate all the schemas\n * that were passed in. It is possible to make an invalid schema this way, e.g. by using\n * `mergeSchemas({ type: 'number' }, { type: 'string' })`, which will never validate.\n * @param schemas All schemas to be merged.\n */\nfunction mergeSchemas(...schemas) {\n    return utils_1.clean(schemas).reduce((prev, curr) => {\n        if (prev === false || curr === false) {\n            return false;\n        }\n        else if (prev === true) {\n            return curr;\n        }\n        else if (curr === true) {\n            return prev;\n        }\n        else if (Array.isArray(prev.allOf)) {\n            if (Array.isArray(curr.allOf)) {\n                return { ...prev, allOf: [...prev.allOf, ...curr.allOf] };\n            }\n            else {\n                return { ...prev, allOf: [...prev.allOf, curr] };\n            }\n        }\n        else if (Array.isArray(curr.allOf)) {\n            return { ...prev, allOf: [prev, ...curr.allOf] };\n        }\n        else {\n            return { ...prev, allOf: [prev, curr] };\n        }\n    }, true);\n}\nexports.mergeSchemas = mergeSchemas;\n"]},"metadata":{},"sourceType":"script"}