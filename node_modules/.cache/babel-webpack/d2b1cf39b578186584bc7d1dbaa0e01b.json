{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler/src/pipe_resolver\", [\"require\", \"exports\", \"@angular/compiler/src/core\", \"@angular/compiler/src/directive_resolver\", \"@angular/compiler/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.PipeResolver = void 0;\n\n  var core_1 = require(\"@angular/compiler/src/core\");\n\n  var directive_resolver_1 = require(\"@angular/compiler/src/directive_resolver\");\n\n  var util_1 = require(\"@angular/compiler/src/util\");\n  /**\n   * Resolve a `Type` for {@link Pipe}.\n   *\n   * This interface can be overridden by the application developer to create custom behavior.\n   *\n   * See {@link Compiler}\n   */\n\n\n  var PipeResolver =\n  /** @class */\n  function () {\n    function PipeResolver(_reflector) {\n      this._reflector = _reflector;\n    }\n\n    PipeResolver.prototype.isPipe = function (type) {\n      var typeMetadata = this._reflector.annotations(util_1.resolveForwardRef(type));\n\n      return typeMetadata && typeMetadata.some(core_1.createPipe.isTypeOf);\n    };\n    /**\n     * Return {@link Pipe} for a given `Type`.\n     */\n\n\n    PipeResolver.prototype.resolve = function (type, throwIfNotFound) {\n      if (throwIfNotFound === void 0) {\n        throwIfNotFound = true;\n      }\n\n      var metas = this._reflector.annotations(util_1.resolveForwardRef(type));\n\n      if (metas) {\n        var annotation = directive_resolver_1.findLast(metas, core_1.createPipe.isTypeOf);\n\n        if (annotation) {\n          return annotation;\n        }\n      }\n\n      if (throwIfNotFound) {\n        throw new Error(\"No Pipe decorator found on \" + util_1.stringify(type));\n      }\n\n      return null;\n    };\n\n    return PipeResolver;\n  }();\n\n  exports.PipeResolver = PipeResolver;\n});","map":{"version":3,"sources":["../../../../../../packages/compiler/src/pipe_resolver.ts"],"names":[],"mappings":"AAAA;;;;;;AAMG;;;;;;;;;;;;;;;;AAGH,MAAA,MAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AACA,MAAA,oBAAA,GAAA,OAAA,CAAA,0CAAA,CAAA;;AACA,MAAA,MAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;AAEA;;;;;;AAMG;;;AACH,MAAA,YAAA;AAAA;AAAA,cAAA;AACE,aAAA,YAAA,CAAoB,UAApB,EAAgD;AAA5B,WAAA,UAAA,GAAA,UAAA;AAAgC;;AAEpD,IAAA,YAAA,CAAA,SAAA,CAAA,MAAA,GAAA,UAAO,IAAP,EAAiB;AACf,UAAM,YAAY,GAAG,KAAK,UAAL,CAAgB,WAAhB,CAA4B,MAAA,CAAA,iBAAA,CAAkB,IAAlB,CAA5B,CAArB;;AACA,aAAO,YAAY,IAAI,YAAY,CAAC,IAAb,CAAkB,MAAA,CAAA,UAAA,CAAW,QAA7B,CAAvB;AACD,KAHD;AAKA;;AAEG;;;AACH,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,GAAA,UAAQ,IAAR,EAAoB,eAApB,EAA0C;AAAtB,UAAA,eAAA,KAAA,KAAA,CAAA,EAAA;AAAA,QAAA,eAAA,GAAA,IAAA;AAAsB;;AACxC,UAAM,KAAK,GAAG,KAAK,UAAL,CAAgB,WAAhB,CAA4B,MAAA,CAAA,iBAAA,CAAkB,IAAlB,CAA5B,CAAd;;AACA,UAAI,KAAJ,EAAW;AACT,YAAM,UAAU,GAAG,oBAAA,CAAA,QAAA,CAAS,KAAT,EAAgB,MAAA,CAAA,UAAA,CAAW,QAA3B,CAAnB;;AACA,YAAI,UAAJ,EAAgB;AACd,iBAAO,UAAP;AACD;AACF;;AACD,UAAI,eAAJ,EAAqB;AACnB,cAAM,IAAI,KAAJ,CAAU,gCAA8B,MAAA,CAAA,SAAA,CAAU,IAAV,CAAxC,CAAN;AACD;;AACD,aAAO,IAAP;AACD,KAZD;;AAaF,WAAA,YAAA;AAAC,GAxBD,EAAA;;AAAa,EAAA,OAAA,CAAA,YAAA,GAAA,YAAA","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileReflector} from './compile_reflector';\nimport {createPipe, Pipe, Type} from './core';\nimport {findLast} from './directive_resolver';\nimport {resolveForwardRef, stringify} from './util';\n\n/**\n * Resolve a `Type` for {@link Pipe}.\n *\n * This interface can be overridden by the application developer to create custom behavior.\n *\n * See {@link Compiler}\n */\nexport class PipeResolver {\n  constructor(private _reflector: CompileReflector) {}\n\n  isPipe(type: Type) {\n    const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n    return typeMetadata && typeMetadata.some(createPipe.isTypeOf);\n  }\n\n  /**\n   * Return {@link Pipe} for a given `Type`.\n   */\n  resolve(type: Type, throwIfNotFound = true): Pipe|null {\n    const metas = this._reflector.annotations(resolveForwardRef(type));\n    if (metas) {\n      const annotation = findLast(metas, createPipe.isTypeOf);\n      if (annotation) {\n        return annotation;\n      }\n    }\n    if (throwIfNotFound) {\n      throw new Error(`No Pipe decorator found on ${stringify(type)}`);\n    }\n    return null;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}