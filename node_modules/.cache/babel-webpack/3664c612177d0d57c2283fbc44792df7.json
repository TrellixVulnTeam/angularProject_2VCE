{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/dependencies/module_resolver\", [\"require\", \"exports\", \"tslib\", \"@angular/compiler-cli/ngcc/src/utils\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.ResolvedDeepImport = exports.ResolvedRelativeModule = exports.ResolvedExternalModule = exports.ModuleResolver = void 0;\n\n  var tslib_1 = require(\"tslib\");\n\n  var utils_1 = require(\"@angular/compiler-cli/ngcc/src/utils\");\n  /**\n   * This is a very cut-down implementation of the TypeScript module resolution strategy.\n   *\n   * It is specific to the needs of ngcc and is not intended to be a drop-in replacement\n   * for the TS module resolver. It is used to compute the dependencies between entry-points\n   * that may be compiled by ngcc.\n   *\n   * The algorithm only finds `.js` files for internal/relative imports and paths to\n   * the folder containing the `package.json` of the entry-point for external imports.\n   *\n   * It can cope with nested `node_modules` folders and also supports `paths`/`baseUrl`\n   * configuration properties, as provided in a `ts.CompilerOptions` object.\n   */\n\n\n  var ModuleResolver =\n  /** @class */\n  function () {\n    function ModuleResolver(fs, pathMappings, relativeExtensions) {\n      if (relativeExtensions === void 0) {\n        relativeExtensions = ['', '.js', '/index.js'];\n      }\n\n      this.fs = fs;\n      this.relativeExtensions = relativeExtensions;\n      this.pathMappings = pathMappings ? this.processPathMappings(pathMappings) : [];\n    }\n    /**\n     * Resolve an absolute path for the `moduleName` imported into a file at `fromPath`.\n     * @param moduleName The name of the import to resolve.\n     * @param fromPath The path to the file containing the import.\n     * @returns A path to the resolved module or null if missing.\n     * Specifically:\n     *  * the absolute path to the package.json of an external module\n     *  * a JavaScript file of an internal module\n     *  * null if none exists.\n     */\n\n\n    ModuleResolver.prototype.resolveModuleImport = function (moduleName, fromPath) {\n      if (utils_1.isRelativePath(moduleName)) {\n        return this.resolveAsRelativePath(moduleName, fromPath);\n      } else {\n        return this.pathMappings.length && this.resolveByPathMappings(moduleName, fromPath) || this.resolveAsEntryPoint(moduleName, fromPath);\n      }\n    };\n    /**\n     * Convert the `pathMappings` into a collection of `PathMapper` functions.\n     */\n\n\n    ModuleResolver.prototype.processPathMappings = function (pathMappings) {\n      var baseUrl = this.fs.resolve(pathMappings.baseUrl);\n      return Object.keys(pathMappings.paths).map(function (pathPattern) {\n        var matcher = splitOnStar(pathPattern);\n        var templates = pathMappings.paths[pathPattern].map(splitOnStar);\n        return {\n          matcher: matcher,\n          templates: templates,\n          baseUrl: baseUrl\n        };\n      });\n    };\n    /**\n     * Try to resolve a module name, as a relative path, from the `fromPath`.\n     *\n     * As it is relative, it only looks for files that end in one of the `relativeExtensions`.\n     * For example: `${moduleName}.js` or `${moduleName}/index.js`.\n     * If neither of these files exist then the method returns `null`.\n     */\n\n\n    ModuleResolver.prototype.resolveAsRelativePath = function (moduleName, fromPath) {\n      var resolvedPath = utils_1.resolveFileWithPostfixes(this.fs, this.fs.resolve(this.fs.dirname(fromPath), moduleName), this.relativeExtensions);\n      return resolvedPath && new ResolvedRelativeModule(resolvedPath);\n    };\n    /**\n     * Try to resolve the `moduleName`, by applying the computed `pathMappings` and\n     * then trying to resolve the mapped path as a relative or external import.\n     *\n     * Whether the mapped path is relative is defined as it being \"below the `fromPath`\" and not\n     * containing `node_modules`.\n     *\n     * If the mapped path is not relative but does not resolve to an external entry-point, then we\n     * check whether it would have resolved to a relative path, in which case it is marked as a\n     * \"deep-import\".\n     */\n\n\n    ModuleResolver.prototype.resolveByPathMappings = function (moduleName, fromPath) {\n      var e_1, _a;\n\n      var mappedPaths = this.findMappedPaths(moduleName);\n\n      if (mappedPaths.length > 0) {\n        var packagePath = this.findPackagePath(fromPath);\n\n        if (packagePath !== null) {\n          try {\n            for (var mappedPaths_1 = tslib_1.__values(mappedPaths), mappedPaths_1_1 = mappedPaths_1.next(); !mappedPaths_1_1.done; mappedPaths_1_1 = mappedPaths_1.next()) {\n              var mappedPath = mappedPaths_1_1.value;\n\n              if (this.isEntryPoint(mappedPath)) {\n                return new ResolvedExternalModule(mappedPath);\n              }\n\n              var nonEntryPointImport = this.resolveAsRelativePath(mappedPath, fromPath);\n\n              if (nonEntryPointImport !== null) {\n                return isRelativeImport(packagePath, mappedPath) ? nonEntryPointImport : new ResolvedDeepImport(mappedPath);\n              }\n            }\n          } catch (e_1_1) {\n            e_1 = {\n              error: e_1_1\n            };\n          } finally {\n            try {\n              if (mappedPaths_1_1 && !mappedPaths_1_1.done && (_a = mappedPaths_1.return)) _a.call(mappedPaths_1);\n            } finally {\n              if (e_1) throw e_1.error;\n            }\n          }\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Try to resolve the `moduleName` as an external entry-point by searching the `node_modules`\n     * folders up the tree for a matching `.../node_modules/${moduleName}`.\n     *\n     * If a folder is found but the path does not contain a `package.json` then it is marked as a\n     * \"deep-import\".\n     */\n\n\n    ModuleResolver.prototype.resolveAsEntryPoint = function (moduleName, fromPath) {\n      var folder = fromPath;\n\n      while (!this.fs.isRoot(folder)) {\n        folder = this.fs.dirname(folder);\n\n        if (folder.endsWith('node_modules')) {\n          // Skip up if the folder already ends in node_modules\n          folder = this.fs.dirname(folder);\n        }\n\n        var modulePath = this.fs.resolve(folder, 'node_modules', moduleName);\n\n        if (this.isEntryPoint(modulePath)) {\n          return new ResolvedExternalModule(modulePath);\n        } else if (this.resolveAsRelativePath(modulePath, fromPath)) {\n          return new ResolvedDeepImport(modulePath);\n        }\n      }\n\n      return null;\n    };\n    /**\n     * Can we consider the given path as an entry-point to a package?\n     *\n     * This is achieved by checking for the existence of `${modulePath}/package.json`.\n     */\n\n\n    ModuleResolver.prototype.isEntryPoint = function (modulePath) {\n      return this.fs.exists(this.fs.join(modulePath, 'package.json'));\n    };\n    /**\n     * Apply the `pathMappers` to the `moduleName` and return all the possible\n     * paths that match.\n     *\n     * The mapped path is computed for each template in `mapping.templates` by\n     * replacing the `matcher.prefix` and `matcher.postfix` strings in `path with the\n     * `template.prefix` and `template.postfix` strings.\n     */\n\n\n    ModuleResolver.prototype.findMappedPaths = function (moduleName) {\n      var _this = this;\n\n      var matches = this.pathMappings.map(function (mapping) {\n        return _this.matchMapping(moduleName, mapping);\n      });\n      var bestMapping;\n      var bestMatch;\n\n      for (var index = 0; index < this.pathMappings.length; index++) {\n        var mapping = this.pathMappings[index];\n        var match = matches[index];\n\n        if (match !== null) {\n          // If this mapping had no wildcard then this must be a complete match.\n          if (!mapping.matcher.hasWildcard) {\n            bestMatch = match;\n            bestMapping = mapping;\n            break;\n          } // The best matched mapping is the one with the longest prefix.\n\n\n          if (!bestMapping || mapping.matcher.prefix > bestMapping.matcher.prefix) {\n            bestMatch = match;\n            bestMapping = mapping;\n          }\n        }\n      }\n\n      return bestMapping !== undefined && bestMatch !== undefined ? this.computeMappedTemplates(bestMapping, bestMatch) : [];\n    };\n    /**\n     * Attempt to find a mapped path for the given `path` and a `mapping`.\n     *\n     * The `path` matches the `mapping` if if it starts with `matcher.prefix` and ends with\n     * `matcher.postfix`.\n     *\n     * @returns the wildcard segment of a matched `path`, or `null` if no match.\n     */\n\n\n    ModuleResolver.prototype.matchMapping = function (path, mapping) {\n      var _a = mapping.matcher,\n          prefix = _a.prefix,\n          postfix = _a.postfix,\n          hasWildcard = _a.hasWildcard;\n\n      if (hasWildcard) {\n        return path.startsWith(prefix) && path.endsWith(postfix) ? path.substring(prefix.length, path.length - postfix.length) : null;\n      } else {\n        return path === prefix ? '' : null;\n      }\n    };\n    /**\n     * Compute the candidate paths from the given mapping's templates using the matched\n     * string.\n     */\n\n\n    ModuleResolver.prototype.computeMappedTemplates = function (mapping, match) {\n      var _this = this;\n\n      return mapping.templates.map(function (template) {\n        return _this.fs.resolve(mapping.baseUrl, template.prefix + match + template.postfix);\n      });\n    };\n    /**\n     * Search up the folder tree for the first folder that contains `package.json`\n     * or `null` if none is found.\n     */\n\n\n    ModuleResolver.prototype.findPackagePath = function (path) {\n      var folder = path;\n\n      while (!this.fs.isRoot(folder)) {\n        folder = this.fs.dirname(folder);\n\n        if (this.fs.exists(this.fs.join(folder, 'package.json'))) {\n          return folder;\n        }\n      }\n\n      return null;\n    };\n\n    return ModuleResolver;\n  }();\n\n  exports.ModuleResolver = ModuleResolver;\n  /**\n   * A module that is external to the package doing the importing.\n   * In this case we capture the folder containing the entry-point.\n   */\n\n  var ResolvedExternalModule =\n  /** @class */\n  function () {\n    function ResolvedExternalModule(entryPointPath) {\n      this.entryPointPath = entryPointPath;\n    }\n\n    return ResolvedExternalModule;\n  }();\n\n  exports.ResolvedExternalModule = ResolvedExternalModule;\n  /**\n   * A module that is relative to the module doing the importing, and so internal to the\n   * source module's package.\n   */\n\n  var ResolvedRelativeModule =\n  /** @class */\n  function () {\n    function ResolvedRelativeModule(modulePath) {\n      this.modulePath = modulePath;\n    }\n\n    return ResolvedRelativeModule;\n  }();\n\n  exports.ResolvedRelativeModule = ResolvedRelativeModule;\n  /**\n   * A module that is external to the package doing the importing but pointing to a\n   * module that is deep inside a package, rather than to an entry-point of the package.\n   */\n\n  var ResolvedDeepImport =\n  /** @class */\n  function () {\n    function ResolvedDeepImport(importPath) {\n      this.importPath = importPath;\n    }\n\n    return ResolvedDeepImport;\n  }();\n\n  exports.ResolvedDeepImport = ResolvedDeepImport;\n\n  function splitOnStar(str) {\n    var _a = tslib_1.__read(str.split('*', 2), 2),\n        prefix = _a[0],\n        postfix = _a[1];\n\n    return {\n      prefix: prefix,\n      postfix: postfix || '',\n      hasWildcard: postfix !== undefined\n    };\n  }\n\n  function isRelativeImport(from, to) {\n    return to.startsWith(from) && !to.includes('node_modules');\n  }\n});","map":{"version":3,"sources":["../../../../../../../../packages/compiler-cli/ngcc/src/dependencies/module_resolver.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AbsoluteFsPath, ReadonlyFileSystem} from '../../../src/ngtsc/file_system';\nimport {PathMappings} from '../path_mappings';\nimport {isRelativePath, resolveFileWithPostfixes} from '../utils';\n\n/**\n * This is a very cut-down implementation of the TypeScript module resolution strategy.\n *\n * It is specific to the needs of ngcc and is not intended to be a drop-in replacement\n * for the TS module resolver. It is used to compute the dependencies between entry-points\n * that may be compiled by ngcc.\n *\n * The algorithm only finds `.js` files for internal/relative imports and paths to\n * the folder containing the `package.json` of the entry-point for external imports.\n *\n * It can cope with nested `node_modules` folders and also supports `paths`/`baseUrl`\n * configuration properties, as provided in a `ts.CompilerOptions` object.\n */\nexport class ModuleResolver {\n  private pathMappings: ProcessedPathMapping[];\n\n  constructor(\n      private fs: ReadonlyFileSystem, pathMappings?: PathMappings,\n      readonly relativeExtensions = ['', '.js', '/index.js']) {\n    this.pathMappings = pathMappings ? this.processPathMappings(pathMappings) : [];\n  }\n\n  /**\n   * Resolve an absolute path for the `moduleName` imported into a file at `fromPath`.\n   * @param moduleName The name of the import to resolve.\n   * @param fromPath The path to the file containing the import.\n   * @returns A path to the resolved module or null if missing.\n   * Specifically:\n   *  * the absolute path to the package.json of an external module\n   *  * a JavaScript file of an internal module\n   *  * null if none exists.\n   */\n  resolveModuleImport(moduleName: string, fromPath: AbsoluteFsPath): ResolvedModule|null {\n    if (isRelativePath(moduleName)) {\n      return this.resolveAsRelativePath(moduleName, fromPath);\n    } else {\n      return this.pathMappings.length && this.resolveByPathMappings(moduleName, fromPath) ||\n          this.resolveAsEntryPoint(moduleName, fromPath);\n    }\n  }\n\n  /**\n   * Convert the `pathMappings` into a collection of `PathMapper` functions.\n   */\n  private processPathMappings(pathMappings: PathMappings): ProcessedPathMapping[] {\n    const baseUrl = this.fs.resolve(pathMappings.baseUrl);\n    return Object.keys(pathMappings.paths).map(pathPattern => {\n      const matcher = splitOnStar(pathPattern);\n      const templates = pathMappings.paths[pathPattern].map(splitOnStar);\n      return {matcher, templates, baseUrl};\n    });\n  }\n\n  /**\n   * Try to resolve a module name, as a relative path, from the `fromPath`.\n   *\n   * As it is relative, it only looks for files that end in one of the `relativeExtensions`.\n   * For example: `${moduleName}.js` or `${moduleName}/index.js`.\n   * If neither of these files exist then the method returns `null`.\n   */\n  private resolveAsRelativePath(moduleName: string, fromPath: AbsoluteFsPath): ResolvedModule|null {\n    const resolvedPath = resolveFileWithPostfixes(\n        this.fs, this.fs.resolve(this.fs.dirname(fromPath), moduleName), this.relativeExtensions);\n    return resolvedPath && new ResolvedRelativeModule(resolvedPath);\n  }\n\n  /**\n   * Try to resolve the `moduleName`, by applying the computed `pathMappings` and\n   * then trying to resolve the mapped path as a relative or external import.\n   *\n   * Whether the mapped path is relative is defined as it being \"below the `fromPath`\" and not\n   * containing `node_modules`.\n   *\n   * If the mapped path is not relative but does not resolve to an external entry-point, then we\n   * check whether it would have resolved to a relative path, in which case it is marked as a\n   * \"deep-import\".\n   */\n  private resolveByPathMappings(moduleName: string, fromPath: AbsoluteFsPath): ResolvedModule|null {\n    const mappedPaths = this.findMappedPaths(moduleName);\n    if (mappedPaths.length > 0) {\n      const packagePath = this.findPackagePath(fromPath);\n      if (packagePath !== null) {\n        for (const mappedPath of mappedPaths) {\n          if (this.isEntryPoint(mappedPath)) {\n            return new ResolvedExternalModule(mappedPath);\n          }\n          const nonEntryPointImport = this.resolveAsRelativePath(mappedPath, fromPath);\n          if (nonEntryPointImport !== null) {\n            return isRelativeImport(packagePath, mappedPath) ? nonEntryPointImport :\n                                                               new ResolvedDeepImport(mappedPath);\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Try to resolve the `moduleName` as an external entry-point by searching the `node_modules`\n   * folders up the tree for a matching `.../node_modules/${moduleName}`.\n   *\n   * If a folder is found but the path does not contain a `package.json` then it is marked as a\n   * \"deep-import\".\n   */\n  private resolveAsEntryPoint(moduleName: string, fromPath: AbsoluteFsPath): ResolvedModule|null {\n    let folder = fromPath;\n    while (!this.fs.isRoot(folder)) {\n      folder = this.fs.dirname(folder);\n      if (folder.endsWith('node_modules')) {\n        // Skip up if the folder already ends in node_modules\n        folder = this.fs.dirname(folder);\n      }\n      const modulePath = this.fs.resolve(folder, 'node_modules', moduleName);\n      if (this.isEntryPoint(modulePath)) {\n        return new ResolvedExternalModule(modulePath);\n      } else if (this.resolveAsRelativePath(modulePath, fromPath)) {\n        return new ResolvedDeepImport(modulePath);\n      }\n    }\n    return null;\n  }\n\n\n  /**\n   * Can we consider the given path as an entry-point to a package?\n   *\n   * This is achieved by checking for the existence of `${modulePath}/package.json`.\n   */\n  private isEntryPoint(modulePath: AbsoluteFsPath): boolean {\n    return this.fs.exists(this.fs.join(modulePath, 'package.json'));\n  }\n\n  /**\n   * Apply the `pathMappers` to the `moduleName` and return all the possible\n   * paths that match.\n   *\n   * The mapped path is computed for each template in `mapping.templates` by\n   * replacing the `matcher.prefix` and `matcher.postfix` strings in `path with the\n   * `template.prefix` and `template.postfix` strings.\n   */\n  private findMappedPaths(moduleName: string): AbsoluteFsPath[] {\n    const matches = this.pathMappings.map(mapping => this.matchMapping(moduleName, mapping));\n\n    let bestMapping: ProcessedPathMapping|undefined;\n    let bestMatch: string|undefined;\n\n    for (let index = 0; index < this.pathMappings.length; index++) {\n      const mapping = this.pathMappings[index];\n      const match = matches[index];\n      if (match !== null) {\n        // If this mapping had no wildcard then this must be a complete match.\n        if (!mapping.matcher.hasWildcard) {\n          bestMatch = match;\n          bestMapping = mapping;\n          break;\n        }\n        // The best matched mapping is the one with the longest prefix.\n        if (!bestMapping || mapping.matcher.prefix > bestMapping.matcher.prefix) {\n          bestMatch = match;\n          bestMapping = mapping;\n        }\n      }\n    }\n\n    return (bestMapping !== undefined && bestMatch !== undefined) ?\n        this.computeMappedTemplates(bestMapping, bestMatch) :\n        [];\n  }\n\n  /**\n   * Attempt to find a mapped path for the given `path` and a `mapping`.\n   *\n   * The `path` matches the `mapping` if if it starts with `matcher.prefix` and ends with\n   * `matcher.postfix`.\n   *\n   * @returns the wildcard segment of a matched `path`, or `null` if no match.\n   */\n  private matchMapping(path: string, mapping: ProcessedPathMapping): string|null {\n    const {prefix, postfix, hasWildcard} = mapping.matcher;\n    if (hasWildcard) {\n      return (path.startsWith(prefix) && path.endsWith(postfix)) ?\n          path.substring(prefix.length, path.length - postfix.length) :\n          null;\n    } else {\n      return (path === prefix) ? '' : null;\n    }\n  }\n\n  /**\n   * Compute the candidate paths from the given mapping's templates using the matched\n   * string.\n   */\n  private computeMappedTemplates(mapping: ProcessedPathMapping, match: string) {\n    return mapping.templates.map(\n        template => this.fs.resolve(mapping.baseUrl, template.prefix + match + template.postfix));\n  }\n\n  /**\n   * Search up the folder tree for the first folder that contains `package.json`\n   * or `null` if none is found.\n   */\n  private findPackagePath(path: AbsoluteFsPath): AbsoluteFsPath|null {\n    let folder = path;\n    while (!this.fs.isRoot(folder)) {\n      folder = this.fs.dirname(folder);\n      if (this.fs.exists(this.fs.join(folder, 'package.json'))) {\n        return folder;\n      }\n    }\n    return null;\n  }\n}\n\n/** The result of resolving an import to a module. */\nexport type ResolvedModule = ResolvedExternalModule|ResolvedRelativeModule|ResolvedDeepImport;\n\n/**\n * A module that is external to the package doing the importing.\n * In this case we capture the folder containing the entry-point.\n */\nexport class ResolvedExternalModule {\n  constructor(public entryPointPath: AbsoluteFsPath) {}\n}\n\n/**\n * A module that is relative to the module doing the importing, and so internal to the\n * source module's package.\n */\nexport class ResolvedRelativeModule {\n  constructor(public modulePath: AbsoluteFsPath) {}\n}\n\n/**\n * A module that is external to the package doing the importing but pointing to a\n * module that is deep inside a package, rather than to an entry-point of the package.\n */\nexport class ResolvedDeepImport {\n  constructor(public importPath: AbsoluteFsPath) {}\n}\n\nfunction splitOnStar(str: string): PathMappingPattern {\n  const [prefix, postfix] = str.split('*', 2);\n  return {prefix, postfix: postfix || '', hasWildcard: postfix !== undefined};\n}\n\ninterface ProcessedPathMapping {\n  baseUrl: AbsoluteFsPath;\n  matcher: PathMappingPattern;\n  templates: PathMappingPattern[];\n}\n\ninterface PathMappingPattern {\n  prefix: string;\n  postfix: string;\n  hasWildcard: boolean;\n}\n\nfunction isRelativeImport(from: AbsoluteFsPath, to: AbsoluteFsPath) {\n  return to.startsWith(from) && !to.includes('node_modules');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}