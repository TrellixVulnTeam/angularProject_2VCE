{"ast":null,"code":"/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/src/ngtsc/annotations/src/injectable\", [\"require\", \"exports\", \"@angular/compiler\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/diagnostics\", \"@angular/compiler-cli/src/ngtsc/perf\", \"@angular/compiler-cli/src/ngtsc/reflection\", \"@angular/compiler-cli/src/ngtsc/transform\", \"@angular/compiler-cli/src/ngtsc/annotations/src/factory\", \"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\", \"@angular/compiler-cli/src/ngtsc/annotations/src/util\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.InjectableDecoratorHandler = void 0;\n\n  var compiler_1 = require(\"@angular/compiler\");\n\n  var ts = require(\"typescript\");\n\n  var diagnostics_1 = require(\"@angular/compiler-cli/src/ngtsc/diagnostics\");\n\n  var perf_1 = require(\"@angular/compiler-cli/src/ngtsc/perf\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  var transform_1 = require(\"@angular/compiler-cli/src/ngtsc/transform\");\n\n  var factory_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/factory\");\n\n  var metadata_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/metadata\");\n\n  var util_1 = require(\"@angular/compiler-cli/src/ngtsc/annotations/src/util\");\n  /**\n   * Adapts the `compileIvyInjectable` compiler for `@Injectable` decorators to the Ivy compiler.\n   */\n\n\n  var InjectableDecoratorHandler =\n  /** @class */\n  function () {\n    function InjectableDecoratorHandler(reflector, isCore, strictCtorDeps, injectableRegistry, perf,\n    /**\n     * What to do if the injectable already contains a ɵprov property.\n     *\n     * If true then an error diagnostic is reported.\n     * If false then there is no error and a new ɵprov property is not added.\n     */\n    errorOnDuplicateProv) {\n      if (errorOnDuplicateProv === void 0) {\n        errorOnDuplicateProv = true;\n      }\n\n      this.reflector = reflector;\n      this.isCore = isCore;\n      this.strictCtorDeps = strictCtorDeps;\n      this.injectableRegistry = injectableRegistry;\n      this.perf = perf;\n      this.errorOnDuplicateProv = errorOnDuplicateProv;\n      this.precedence = transform_1.HandlerPrecedence.SHARED;\n      this.name = InjectableDecoratorHandler.name;\n    }\n\n    InjectableDecoratorHandler.prototype.detect = function (node, decorators) {\n      if (!decorators) {\n        return undefined;\n      }\n\n      var decorator = util_1.findAngularDecorator(decorators, 'Injectable', this.isCore);\n\n      if (decorator !== undefined) {\n        return {\n          trigger: decorator.node,\n          decorator: decorator,\n          metadata: decorator\n        };\n      } else {\n        return undefined;\n      }\n    };\n\n    InjectableDecoratorHandler.prototype.analyze = function (node, decorator) {\n      this.perf.eventCount(perf_1.PerfEvent.AnalyzeInjectable);\n      var meta = extractInjectableMetadata(node, decorator, this.reflector);\n      var decorators = this.reflector.getDecoratorsOfDeclaration(node);\n      return {\n        analysis: {\n          meta: meta,\n          ctorDeps: extractInjectableCtorDeps(node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),\n          metadataStmt: metadata_1.generateSetClassMetadataCall(node, this.reflector, this.isCore),\n          // Avoid generating multiple factories if a class has\n          // more Angular decorators, apart from Injectable.\n          needsFactory: !decorators || decorators.every(function (current) {\n            return !util_1.isAngularCore(current) || current.name === 'Injectable';\n          })\n        }\n      };\n    };\n\n    InjectableDecoratorHandler.prototype.symbol = function () {\n      return null;\n    };\n\n    InjectableDecoratorHandler.prototype.register = function (node) {\n      this.injectableRegistry.registerInjectable(node);\n    };\n\n    InjectableDecoratorHandler.prototype.compileFull = function (node, analysis) {\n      var res = compiler_1.compileInjectable(analysis.meta);\n      var statements = res.statements;\n      var results = [];\n\n      if (analysis.needsFactory) {\n        var meta = analysis.meta;\n        var factoryRes = factory_1.compileNgFactoryDefField({\n          name: meta.name,\n          type: meta.type,\n          internalType: meta.internalType,\n          typeArgumentCount: meta.typeArgumentCount,\n          deps: analysis.ctorDeps,\n          injectFn: compiler_1.Identifiers.inject,\n          target: compiler_1.R3FactoryTarget.Injectable\n        });\n\n        if (analysis.metadataStmt !== null) {\n          factoryRes.statements.push(analysis.metadataStmt);\n        }\n\n        results.push(factoryRes);\n      }\n\n      var ɵprov = this.reflector.getMembersOfClass(node).find(function (member) {\n        return member.name === 'ɵprov';\n      });\n\n      if (ɵprov !== undefined && this.errorOnDuplicateProv) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.INJECTABLE_DUPLICATE_PROV, ɵprov.nameNode || ɵprov.node || node, 'Injectables cannot contain a static ɵprov property, because the compiler is going to generate one.');\n      }\n\n      if (ɵprov === undefined) {\n        // Only add a new ɵprov if there is not one already\n        results.push({\n          name: 'ɵprov',\n          initializer: res.expression,\n          statements: statements,\n          type: res.type\n        });\n      }\n\n      return results;\n    };\n\n    return InjectableDecoratorHandler;\n  }();\n\n  exports.InjectableDecoratorHandler = InjectableDecoratorHandler;\n  /**\n   * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the\n   * input metadata needed to run `compileIvyInjectable`.\n   *\n   * A `null` return value indicates this is @Injectable has invalid data.\n   */\n\n  function extractInjectableMetadata(clazz, decorator, reflector) {\n    var name = clazz.name.text;\n    var type = util_1.wrapTypeReference(reflector, clazz);\n    var internalType = new compiler_1.WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));\n    var typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;\n\n    if (decorator.args === null) {\n      throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_NOT_CALLED, reflection_1.Decorator.nodeForError(decorator), '@Injectable must be called');\n    }\n\n    if (decorator.args.length === 0) {\n      return {\n        name: name,\n        type: type,\n        typeArgumentCount: typeArgumentCount,\n        internalType: internalType,\n        providedIn: new compiler_1.LiteralExpr(null)\n      };\n    } else if (decorator.args.length === 1) {\n      var metaNode = decorator.args[0]; // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to\n      // transport references from one location to another. This is the problem that lowering\n      // used to solve - if this restriction proves too undesirable we can re-implement lowering.\n\n      if (!ts.isObjectLiteralExpression(metaNode)) {\n        throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode, \"@Injectable argument must be an object literal\");\n      } // Resolve the fields of the literal into a map of field name to expression.\n\n\n      var meta = reflection_1.reflectObjectLiteral(metaNode);\n      var providedIn = new compiler_1.LiteralExpr(null);\n\n      if (meta.has('providedIn')) {\n        providedIn = new compiler_1.WrappedNodeExpr(meta.get('providedIn'));\n      }\n\n      var userDeps = undefined;\n\n      if ((meta.has('useClass') || meta.has('useFactory')) && meta.has('deps')) {\n        var depsExpr = meta.get('deps');\n\n        if (!ts.isArrayLiteralExpression(depsExpr)) {\n          throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.VALUE_NOT_LITERAL, depsExpr, \"@Injectable deps metadata must be an inline array\");\n        }\n\n        userDeps = depsExpr.elements.map(function (dep) {\n          return getDep(dep, reflector);\n        });\n      }\n\n      if (meta.has('useValue')) {\n        return {\n          name: name,\n          type: type,\n          typeArgumentCount: typeArgumentCount,\n          internalType: internalType,\n          providedIn: providedIn,\n          useValue: new compiler_1.WrappedNodeExpr(util_1.unwrapForwardRef(meta.get('useValue'), reflector))\n        };\n      } else if (meta.has('useExisting')) {\n        return {\n          name: name,\n          type: type,\n          typeArgumentCount: typeArgumentCount,\n          internalType: internalType,\n          providedIn: providedIn,\n          useExisting: new compiler_1.WrappedNodeExpr(util_1.unwrapForwardRef(meta.get('useExisting'), reflector))\n        };\n      } else if (meta.has('useClass')) {\n        return {\n          name: name,\n          type: type,\n          typeArgumentCount: typeArgumentCount,\n          internalType: internalType,\n          providedIn: providedIn,\n          useClass: new compiler_1.WrappedNodeExpr(util_1.unwrapForwardRef(meta.get('useClass'), reflector)),\n          userDeps: userDeps\n        };\n      } else if (meta.has('useFactory')) {\n        // useFactory is special - the 'deps' property must be analyzed.\n        var factory = new compiler_1.WrappedNodeExpr(meta.get('useFactory'));\n        return {\n          name: name,\n          type: type,\n          typeArgumentCount: typeArgumentCount,\n          internalType: internalType,\n          providedIn: providedIn,\n          useFactory: factory,\n          userDeps: userDeps\n        };\n      } else {\n        return {\n          name: name,\n          type: type,\n          typeArgumentCount: typeArgumentCount,\n          internalType: internalType,\n          providedIn: providedIn\n        };\n      }\n    } else {\n      throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], 'Too many arguments to @Injectable');\n    }\n  }\n\n  function extractInjectableCtorDeps(clazz, meta, decorator, reflector, isCore, strictCtorDeps) {\n    if (decorator.args === null) {\n      throw new diagnostics_1.FatalDiagnosticError(diagnostics_1.ErrorCode.DECORATOR_NOT_CALLED, reflection_1.Decorator.nodeForError(decorator), '@Injectable must be called');\n    }\n\n    var ctorDeps = null;\n\n    if (decorator.args.length === 0) {\n      // Ideally, using @Injectable() would have the same effect as using @Injectable({...}), and be\n      // subject to the same validation. However, existing Angular code abuses @Injectable, applying\n      // it to things like abstract classes with constructors that were never meant for use with\n      // Angular's DI.\n      //\n      // To deal with this, @Injectable() without an argument is more lenient, and if the\n      // constructor signature does not work for DI then a factory definition (ɵfac) that throws is\n      // generated.\n      if (strictCtorDeps) {\n        ctorDeps = util_1.getValidConstructorDependencies(clazz, reflector, isCore);\n      } else {\n        ctorDeps = util_1.unwrapConstructorDependencies(util_1.getConstructorDependencies(clazz, reflector, isCore));\n      }\n\n      return ctorDeps;\n    } else if (decorator.args.length === 1) {\n      var rawCtorDeps = util_1.getConstructorDependencies(clazz, reflector, isCore);\n\n      if (strictCtorDeps && meta.useValue === undefined && meta.useExisting === undefined && meta.useClass === undefined && meta.useFactory === undefined) {\n        // Since use* was not provided, validate the deps according to strictCtorDeps.\n        ctorDeps = util_1.validateConstructorDependencies(clazz, rawCtorDeps);\n      } else {\n        ctorDeps = util_1.unwrapConstructorDependencies(rawCtorDeps);\n      }\n    }\n\n    return ctorDeps;\n  }\n\n  function getDep(dep, reflector) {\n    var meta = {\n      token: new compiler_1.WrappedNodeExpr(dep),\n      attribute: null,\n      host: false,\n      resolved: compiler_1.R3ResolvedDependencyType.Token,\n      optional: false,\n      self: false,\n      skipSelf: false\n    };\n\n    function maybeUpdateDecorator(dec, reflector, token) {\n      var source = reflector.getImportOfIdentifier(dec);\n\n      if (source === null || source.from !== '@angular/core') {\n        return;\n      }\n\n      switch (source.name) {\n        case 'Inject':\n          if (token !== undefined) {\n            meta.token = new compiler_1.WrappedNodeExpr(token);\n          }\n\n          break;\n\n        case 'Optional':\n          meta.optional = true;\n          break;\n\n        case 'SkipSelf':\n          meta.skipSelf = true;\n          break;\n\n        case 'Self':\n          meta.self = true;\n          break;\n      }\n    }\n\n    if (ts.isArrayLiteralExpression(dep)) {\n      dep.elements.forEach(function (el) {\n        if (ts.isIdentifier(el)) {\n          maybeUpdateDecorator(el, reflector);\n        } else if (ts.isNewExpression(el) && ts.isIdentifier(el.expression)) {\n          var token = el.arguments && el.arguments.length > 0 && el.arguments[0] || undefined;\n          maybeUpdateDecorator(el.expression, reflector, token);\n        }\n      });\n    }\n\n    return meta;\n  }\n});","map":{"version":3,"sources":["../../../../../../../../../packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {compileInjectable as compileIvyInjectable, Expression, Identifiers, LiteralExpr, R3DependencyMetadata, R3FactoryTarget, R3InjectableMetadata, R3ResolvedDependencyType, Statement, WrappedNodeExpr} from '@angular/compiler';\nimport * as ts from 'typescript';\n\nimport {ErrorCode, FatalDiagnosticError} from '../../diagnostics';\nimport {InjectableClassRegistry} from '../../metadata';\nimport {PerfEvent, PerfRecorder} from '../../perf';\nimport {ClassDeclaration, Decorator, ReflectionHost, reflectObjectLiteral} from '../../reflection';\nimport {AnalysisOutput, CompileResult, DecoratorHandler, DetectResult, HandlerPrecedence} from '../../transform';\n\nimport {compileNgFactoryDefField} from './factory';\nimport {generateSetClassMetadataCall} from './metadata';\nimport {findAngularDecorator, getConstructorDependencies, getValidConstructorDependencies, isAngularCore, unwrapConstructorDependencies, unwrapForwardRef, validateConstructorDependencies, wrapTypeReference} from './util';\n\nexport interface InjectableHandlerData {\n  meta: R3InjectableMetadata;\n  metadataStmt: Statement|null;\n  ctorDeps: R3DependencyMetadata[]|'invalid'|null;\n  needsFactory: boolean;\n}\n\n/**\n * Adapts the `compileIvyInjectable` compiler for `@Injectable` decorators to the Ivy compiler.\n */\nexport class InjectableDecoratorHandler implements\n    DecoratorHandler<Decorator, InjectableHandlerData, null, unknown> {\n  constructor(\n      private reflector: ReflectionHost, private isCore: boolean, private strictCtorDeps: boolean,\n      private injectableRegistry: InjectableClassRegistry, private perf: PerfRecorder,\n      /**\n       * What to do if the injectable already contains a ɵprov property.\n       *\n       * If true then an error diagnostic is reported.\n       * If false then there is no error and a new ɵprov property is not added.\n       */\n      private errorOnDuplicateProv = true) {}\n\n  readonly precedence = HandlerPrecedence.SHARED;\n  readonly name = InjectableDecoratorHandler.name;\n\n  detect(node: ClassDeclaration, decorators: Decorator[]|null): DetectResult<Decorator>|undefined {\n    if (!decorators) {\n      return undefined;\n    }\n    const decorator = findAngularDecorator(decorators, 'Injectable', this.isCore);\n    if (decorator !== undefined) {\n      return {\n        trigger: decorator.node,\n        decorator: decorator,\n        metadata: decorator,\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n  analyze(node: ClassDeclaration, decorator: Readonly<Decorator>):\n      AnalysisOutput<InjectableHandlerData> {\n    this.perf.eventCount(PerfEvent.AnalyzeInjectable);\n\n    const meta = extractInjectableMetadata(node, decorator, this.reflector);\n    const decorators = this.reflector.getDecoratorsOfDeclaration(node);\n\n    return {\n      analysis: {\n        meta,\n        ctorDeps: extractInjectableCtorDeps(\n            node, meta, decorator, this.reflector, this.isCore, this.strictCtorDeps),\n        metadataStmt: generateSetClassMetadataCall(node, this.reflector, this.isCore),\n        // Avoid generating multiple factories if a class has\n        // more Angular decorators, apart from Injectable.\n        needsFactory: !decorators ||\n            decorators.every(current => !isAngularCore(current) || current.name === 'Injectable')\n      },\n    };\n  }\n\n  symbol(): null {\n    return null;\n  }\n\n  register(node: ClassDeclaration): void {\n    this.injectableRegistry.registerInjectable(node);\n  }\n\n  compileFull(node: ClassDeclaration, analysis: Readonly<InjectableHandlerData>): CompileResult[] {\n    const res = compileIvyInjectable(analysis.meta);\n    const statements = res.statements;\n    const results: CompileResult[] = [];\n\n    if (analysis.needsFactory) {\n      const meta = analysis.meta;\n      const factoryRes = compileNgFactoryDefField({\n        name: meta.name,\n        type: meta.type,\n        internalType: meta.internalType,\n        typeArgumentCount: meta.typeArgumentCount,\n        deps: analysis.ctorDeps,\n        injectFn: Identifiers.inject,\n        target: R3FactoryTarget.Injectable,\n      });\n      if (analysis.metadataStmt !== null) {\n        factoryRes.statements.push(analysis.metadataStmt);\n      }\n      results.push(factoryRes);\n    }\n\n    const ɵprov = this.reflector.getMembersOfClass(node).find(member => member.name === 'ɵprov');\n    if (ɵprov !== undefined && this.errorOnDuplicateProv) {\n      throw new FatalDiagnosticError(\n          ErrorCode.INJECTABLE_DUPLICATE_PROV, ɵprov.nameNode || ɵprov.node || node,\n          'Injectables cannot contain a static ɵprov property, because the compiler is going to generate one.');\n    }\n\n    if (ɵprov === undefined) {\n      // Only add a new ɵprov if there is not one already\n      results.push({name: 'ɵprov', initializer: res.expression, statements, type: res.type});\n    }\n\n\n    return results;\n  }\n}\n\n/**\n * Read metadata from the `@Injectable` decorator and produce the `IvyInjectableMetadata`, the\n * input metadata needed to run `compileIvyInjectable`.\n *\n * A `null` return value indicates this is @Injectable has invalid data.\n */\nfunction extractInjectableMetadata(\n    clazz: ClassDeclaration, decorator: Decorator,\n    reflector: ReflectionHost): R3InjectableMetadata {\n  const name = clazz.name.text;\n  const type = wrapTypeReference(reflector, clazz);\n  const internalType = new WrappedNodeExpr(reflector.getInternalNameOfClass(clazz));\n  const typeArgumentCount = reflector.getGenericArityOfClass(clazz) || 0;\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator),\n        '@Injectable must be called');\n  }\n  if (decorator.args.length === 0) {\n    return {\n      name,\n      type,\n      typeArgumentCount,\n      internalType,\n      providedIn: new LiteralExpr(null),\n    };\n  } else if (decorator.args.length === 1) {\n    const metaNode = decorator.args[0];\n    // Firstly make sure the decorator argument is an inline literal - if not, it's illegal to\n    // transport references from one location to another. This is the problem that lowering\n    // used to solve - if this restriction proves too undesirable we can re-implement lowering.\n    if (!ts.isObjectLiteralExpression(metaNode)) {\n      throw new FatalDiagnosticError(\n          ErrorCode.DECORATOR_ARG_NOT_LITERAL, metaNode,\n          `@Injectable argument must be an object literal`);\n    }\n\n    // Resolve the fields of the literal into a map of field name to expression.\n    const meta = reflectObjectLiteral(metaNode);\n    let providedIn: Expression = new LiteralExpr(null);\n    if (meta.has('providedIn')) {\n      providedIn = new WrappedNodeExpr(meta.get('providedIn')!);\n    }\n\n    let userDeps: R3DependencyMetadata[]|undefined = undefined;\n    if ((meta.has('useClass') || meta.has('useFactory')) && meta.has('deps')) {\n      const depsExpr = meta.get('deps')!;\n      if (!ts.isArrayLiteralExpression(depsExpr)) {\n        throw new FatalDiagnosticError(\n            ErrorCode.VALUE_NOT_LITERAL, depsExpr,\n            `@Injectable deps metadata must be an inline array`);\n      }\n      userDeps = depsExpr.elements.map(dep => getDep(dep, reflector));\n    }\n\n    if (meta.has('useValue')) {\n      return {\n        name,\n        type,\n        typeArgumentCount,\n        internalType,\n        providedIn,\n        useValue: new WrappedNodeExpr(unwrapForwardRef(meta.get('useValue')!, reflector)),\n      };\n    } else if (meta.has('useExisting')) {\n      return {\n        name,\n        type,\n        typeArgumentCount,\n        internalType,\n        providedIn,\n        useExisting: new WrappedNodeExpr(unwrapForwardRef(meta.get('useExisting')!, reflector)),\n      };\n    } else if (meta.has('useClass')) {\n      return {\n        name,\n        type,\n        typeArgumentCount,\n        internalType,\n        providedIn,\n        useClass: new WrappedNodeExpr(unwrapForwardRef(meta.get('useClass')!, reflector)),\n        userDeps,\n      };\n    } else if (meta.has('useFactory')) {\n      // useFactory is special - the 'deps' property must be analyzed.\n      const factory = new WrappedNodeExpr(meta.get('useFactory')!);\n      return {\n        name,\n        type,\n        typeArgumentCount,\n        internalType,\n        providedIn,\n        useFactory: factory,\n        userDeps,\n      };\n    } else {\n      return {name, type, typeArgumentCount, internalType, providedIn};\n    }\n  } else {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_ARITY_WRONG, decorator.args[2], 'Too many arguments to @Injectable');\n  }\n}\n\nfunction extractInjectableCtorDeps(\n    clazz: ClassDeclaration, meta: R3InjectableMetadata, decorator: Decorator,\n    reflector: ReflectionHost, isCore: boolean, strictCtorDeps: boolean) {\n  if (decorator.args === null) {\n    throw new FatalDiagnosticError(\n        ErrorCode.DECORATOR_NOT_CALLED, Decorator.nodeForError(decorator),\n        '@Injectable must be called');\n  }\n\n  let ctorDeps: R3DependencyMetadata[]|'invalid'|null = null;\n\n  if (decorator.args.length === 0) {\n    // Ideally, using @Injectable() would have the same effect as using @Injectable({...}), and be\n    // subject to the same validation. However, existing Angular code abuses @Injectable, applying\n    // it to things like abstract classes with constructors that were never meant for use with\n    // Angular's DI.\n    //\n    // To deal with this, @Injectable() without an argument is more lenient, and if the\n    // constructor signature does not work for DI then a factory definition (ɵfac) that throws is\n    // generated.\n    if (strictCtorDeps) {\n      ctorDeps = getValidConstructorDependencies(clazz, reflector, isCore);\n    } else {\n      ctorDeps =\n          unwrapConstructorDependencies(getConstructorDependencies(clazz, reflector, isCore));\n    }\n\n    return ctorDeps;\n  } else if (decorator.args.length === 1) {\n    const rawCtorDeps = getConstructorDependencies(clazz, reflector, isCore);\n\n    if (strictCtorDeps && meta.useValue === undefined && meta.useExisting === undefined &&\n        meta.useClass === undefined && meta.useFactory === undefined) {\n      // Since use* was not provided, validate the deps according to strictCtorDeps.\n      ctorDeps = validateConstructorDependencies(clazz, rawCtorDeps);\n    } else {\n      ctorDeps = unwrapConstructorDependencies(rawCtorDeps);\n    }\n  }\n\n  return ctorDeps;\n}\n\nfunction getDep(dep: ts.Expression, reflector: ReflectionHost): R3DependencyMetadata {\n  const meta: R3DependencyMetadata = {\n    token: new WrappedNodeExpr(dep),\n    attribute: null,\n    host: false,\n    resolved: R3ResolvedDependencyType.Token,\n    optional: false,\n    self: false,\n    skipSelf: false,\n  };\n\n  function maybeUpdateDecorator(\n      dec: ts.Identifier, reflector: ReflectionHost, token?: ts.Expression): void {\n    const source = reflector.getImportOfIdentifier(dec);\n    if (source === null || source.from !== '@angular/core') {\n      return;\n    }\n    switch (source.name) {\n      case 'Inject':\n        if (token !== undefined) {\n          meta.token = new WrappedNodeExpr(token);\n        }\n        break;\n      case 'Optional':\n        meta.optional = true;\n        break;\n      case 'SkipSelf':\n        meta.skipSelf = true;\n        break;\n      case 'Self':\n        meta.self = true;\n        break;\n    }\n  }\n\n  if (ts.isArrayLiteralExpression(dep)) {\n    dep.elements.forEach(el => {\n      if (ts.isIdentifier(el)) {\n        maybeUpdateDecorator(el, reflector);\n      } else if (ts.isNewExpression(el) && ts.isIdentifier(el.expression)) {\n        const token = el.arguments && el.arguments.length > 0 && el.arguments[0] || undefined;\n        maybeUpdateDecorator(el.expression, reflector, token);\n      }\n    });\n  }\n  return meta;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}