{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _require = require('terser'),\n    terserMinify = _require.minify;\n\nvar buildTerserOptions = function buildTerserOptions() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      ecma = _ref.ecma,\n      _ref$parse = _ref.parse,\n      parse = _ref$parse === void 0 ? {} : _ref$parse,\n      _ref$compress = _ref.compress,\n      compress = _ref$compress === void 0 ? {} : _ref$compress,\n      mangle = _ref.mangle,\n      module = _ref.module,\n      output = _ref.output,\n      toplevel = _ref.toplevel,\n      nameCache = _ref.nameCache,\n      ie8 = _ref.ie8,\n      keep_classnames = _ref.keep_classnames,\n      keep_fnames = _ref.keep_fnames,\n      safari10 = _ref.safari10;\n\n  return {\n    parse: _objectSpread({}, parse),\n    compress: typeof compress === 'boolean' ? compress : _objectSpread({}, compress),\n    // eslint-disable-next-line no-nested-ternary\n    mangle: mangle == null ? true : typeof mangle === 'boolean' ? mangle : _objectSpread({}, mangle),\n    output: _objectSpread({\n      beautify: false\n    }, output),\n    // Ignoring sourceMap from options\n    sourceMap: null,\n    ecma: ecma,\n    keep_classnames: keep_classnames,\n    keep_fnames: keep_fnames,\n    ie8: ie8,\n    module: module,\n    nameCache: nameCache,\n    safari10: safari10,\n    toplevel: toplevel\n  };\n};\n\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type === 'object' || type === 'function');\n}\n\nvar buildComments = function buildComments(extractComments, terserOptions, extractedComments) {\n  var condition = {};\n  var comments = terserOptions.output.comments;\n  condition.preserve = typeof comments !== 'undefined' ? comments : false;\n\n  if (typeof extractComments === 'boolean' && extractComments) {\n    condition.extract = 'some';\n  } else if (typeof extractComments === 'string' || extractComments instanceof RegExp) {\n    condition.extract = extractComments;\n  } else if (typeof extractComments === 'function') {\n    condition.extract = extractComments;\n  } else if (isObject(extractComments)) {\n    condition.extract = typeof extractComments.condition === 'boolean' && extractComments.condition ? 'some' : typeof extractComments.condition !== 'undefined' ? extractComments.condition : 'some';\n  } else {\n    // No extract\n    // Preserve using \"commentsOpts\" or \"some\"\n    condition.preserve = typeof comments !== 'undefined' ? comments : 'some';\n    condition.extract = false;\n  } // Ensure that both conditions are functions\n\n\n  ['preserve', 'extract'].forEach(function (key) {\n    var regexStr;\n    var regex;\n\n    switch (typeof condition[key]) {\n      case 'boolean':\n        condition[key] = condition[key] ? function () {\n          return true;\n        } : function () {\n          return false;\n        };\n        break;\n\n      case 'function':\n        break;\n\n      case 'string':\n        if (condition[key] === 'all') {\n          condition[key] = function () {\n            return true;\n          };\n\n          break;\n        }\n\n        if (condition[key] === 'some') {\n          condition[key] = function (astNode, comment) {\n            return (comment.type === 'comment2' || comment.type === 'comment1') && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n          };\n\n          break;\n        }\n\n        regexStr = condition[key];\n\n        condition[key] = function (astNode, comment) {\n          return new RegExp(regexStr).test(comment.value);\n        };\n\n        break;\n\n      default:\n        regex = condition[key];\n\n        condition[key] = function (astNode, comment) {\n          return regex.test(comment.value);\n        };\n\n    }\n  }); // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n\n  return function (astNode, comment) {\n    if (condition.extract(astNode, comment)) {\n      var commentText = comment.type === 'comment2' ? \"/*\".concat(comment.value, \"*/\") : \"//\".concat(comment.value); // Don't include duplicate comments\n\n      if (!extractedComments.includes(commentText)) {\n        extractedComments.push(commentText);\n      }\n    }\n\n    return condition.preserve(astNode, comment);\n  };\n};\n\nfunction minify(_x) {\n  return _minify.apply(this, arguments);\n}\n\nfunction _minify() {\n  _minify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n    var name, input, inputSourceMap, minifyFn, minimizerOptions, terserOptions, extractedComments, extractComments, result;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            name = options.name, input = options.input, inputSourceMap = options.inputSourceMap, minifyFn = options.minify, minimizerOptions = options.minimizerOptions;\n\n            if (!minifyFn) {\n              _context.next = 3;\n              break;\n            }\n\n            return _context.abrupt(\"return\", minifyFn(_defineProperty({}, name, input), inputSourceMap, minimizerOptions));\n\n          case 3:\n            // Copy terser options\n            terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\n\n            if (inputSourceMap) {\n              terserOptions.sourceMap = {\n                asObject: true\n              };\n            }\n\n            extractedComments = [];\n            extractComments = options.extractComments;\n            terserOptions.output.comments = buildComments(extractComments, terserOptions, extractedComments);\n            _context.next = 10;\n            return terserMinify(_defineProperty({}, name, input), terserOptions);\n\n          case 10:\n            result = _context.sent;\n            return _context.abrupt(\"return\", _objectSpread(_objectSpread({}, result), {}, {\n              extractedComments: extractedComments\n            }));\n\n          case 12:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _minify.apply(this, arguments);\n}\n\nfunction transform(options) {\n  // 'use strict' => this === undefined (Clean Scope)\n  // Safer for possible security issues, albeit not critical at all here\n  // eslint-disable-next-line no-new-func, no-param-reassign\n  options = new Function('exports', 'require', 'module', '__filename', '__dirname', \"'use strict'\\nreturn \".concat(options))(exports, require, module, __filename, __dirname);\n  return minify(options);\n}\n\nmodule.exports.minify = minify;\nmodule.exports.transform = transform;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/terser-webpack-plugin/dist/minify.js"],"names":["require","terserMinify","minify","buildTerserOptions","ecma","parse","compress","mangle","module","output","toplevel","nameCache","ie8","keep_classnames","keep_fnames","safari10","beautify","sourceMap","isObject","value","type","buildComments","extractComments","terserOptions","extractedComments","condition","comments","preserve","extract","RegExp","forEach","key","regexStr","regex","astNode","comment","test","commentText","includes","push","options","name","input","inputSourceMap","minifyFn","minimizerOptions","asObject","result","transform","Function","exports","__filename","__dirname"],"mappings":"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","sourcesContent":["\"use strict\";\n\nconst {\n  minify: terserMinify\n} = require('terser');\n\nconst buildTerserOptions = ({\n  ecma,\n  parse = {},\n  compress = {},\n  mangle,\n  module,\n  output,\n  toplevel,\n  nameCache,\n  ie8,\n\n  /* eslint-disable camelcase */\n  keep_classnames,\n  keep_fnames,\n\n  /* eslint-enable camelcase */\n  safari10\n} = {}) => ({\n  parse: { ...parse\n  },\n  compress: typeof compress === 'boolean' ? compress : { ...compress\n  },\n  // eslint-disable-next-line no-nested-ternary\n  mangle: mangle == null ? true : typeof mangle === 'boolean' ? mangle : { ...mangle\n  },\n  output: {\n    beautify: false,\n    ...output\n  },\n  // Ignoring sourceMap from options\n  sourceMap: null,\n  ecma,\n  keep_classnames,\n  keep_fnames,\n  ie8,\n  module,\n  nameCache,\n  safari10,\n  toplevel\n});\n\nfunction isObject(value) {\n  const type = typeof value;\n  return value != null && (type === 'object' || type === 'function');\n}\n\nconst buildComments = (extractComments, terserOptions, extractedComments) => {\n  const condition = {};\n  const {\n    comments\n  } = terserOptions.output;\n  condition.preserve = typeof comments !== 'undefined' ? comments : false;\n\n  if (typeof extractComments === 'boolean' && extractComments) {\n    condition.extract = 'some';\n  } else if (typeof extractComments === 'string' || extractComments instanceof RegExp) {\n    condition.extract = extractComments;\n  } else if (typeof extractComments === 'function') {\n    condition.extract = extractComments;\n  } else if (isObject(extractComments)) {\n    condition.extract = typeof extractComments.condition === 'boolean' && extractComments.condition ? 'some' : typeof extractComments.condition !== 'undefined' ? extractComments.condition : 'some';\n  } else {\n    // No extract\n    // Preserve using \"commentsOpts\" or \"some\"\n    condition.preserve = typeof comments !== 'undefined' ? comments : 'some';\n    condition.extract = false;\n  } // Ensure that both conditions are functions\n\n\n  ['preserve', 'extract'].forEach(key => {\n    let regexStr;\n    let regex;\n\n    switch (typeof condition[key]) {\n      case 'boolean':\n        condition[key] = condition[key] ? () => true : () => false;\n        break;\n\n      case 'function':\n        break;\n\n      case 'string':\n        if (condition[key] === 'all') {\n          condition[key] = () => true;\n\n          break;\n        }\n\n        if (condition[key] === 'some') {\n          condition[key] = (astNode, comment) => {\n            return (comment.type === 'comment2' || comment.type === 'comment1') && /@preserve|@lic|@cc_on|^\\**!/i.test(comment.value);\n          };\n\n          break;\n        }\n\n        regexStr = condition[key];\n\n        condition[key] = (astNode, comment) => {\n          return new RegExp(regexStr).test(comment.value);\n        };\n\n        break;\n\n      default:\n        regex = condition[key];\n\n        condition[key] = (astNode, comment) => regex.test(comment.value);\n\n    }\n  }); // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n\n  return (astNode, comment) => {\n    if (condition.extract(astNode, comment)) {\n      const commentText = comment.type === 'comment2' ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n      if (!extractedComments.includes(commentText)) {\n        extractedComments.push(commentText);\n      }\n    }\n\n    return condition.preserve(astNode, comment);\n  };\n};\n\nasync function minify(options) {\n  const {\n    name,\n    input,\n    inputSourceMap,\n    minify: minifyFn,\n    minimizerOptions\n  } = options;\n\n  if (minifyFn) {\n    return minifyFn({\n      [name]: input\n    }, inputSourceMap, minimizerOptions);\n  } // Copy terser options\n\n\n  const terserOptions = buildTerserOptions(minimizerOptions); // Let terser generate a SourceMap\n\n  if (inputSourceMap) {\n    terserOptions.sourceMap = {\n      asObject: true\n    };\n  }\n\n  const extractedComments = [];\n  const {\n    extractComments\n  } = options;\n  terserOptions.output.comments = buildComments(extractComments, terserOptions, extractedComments);\n  const result = await terserMinify({\n    [name]: input\n  }, terserOptions);\n  return { ...result,\n    extractedComments\n  };\n}\n\nfunction transform(options) {\n  // 'use strict' => this === undefined (Clean Scope)\n  // Safer for possible security issues, albeit not critical at all here\n  // eslint-disable-next-line no-new-func, no-param-reassign\n  options = new Function('exports', 'require', 'module', '__filename', '__dirname', `'use strict'\\nreturn ${options}`)(exports, require, module, __filename, __dirname);\n  return minify(options);\n}\n\nmodule.exports.minify = minify;\nmodule.exports.transform = transform;"]},"metadata":{},"sourceType":"script"}