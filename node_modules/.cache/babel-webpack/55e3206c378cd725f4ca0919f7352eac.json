{"ast":null,"code":"(function (factory) {\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    var v = factory(require, exports);\n    if (v !== undefined) module.exports = v;\n  } else if (typeof define === \"function\" && define.amd) {\n    define(\"@angular/compiler-cli/ngcc/src/utils\", [\"require\", \"exports\", \"tslib\", \"typescript\", \"@angular/compiler-cli/src/ngtsc/file_system\", \"@angular/compiler-cli/src/ngtsc/reflection\"], factory);\n  }\n})(function (require, exports) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.stripExtension = exports.stripDollarSuffix = exports.getTsHelperFnFromIdentifier = exports.getTsHelperFnFromDeclaration = exports.resolveFileWithPostfixes = exports.FactoryMap = exports.isRelativePath = exports.hasNameIdentifier = exports.findAll = exports.getNameText = exports.isDefined = exports.getOriginalSymbol = void 0;\n\n  var tslib_1 = require(\"tslib\");\n  /**\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.io/license\n   */\n\n\n  var ts = require(\"typescript\");\n\n  var file_system_1 = require(\"@angular/compiler-cli/src/ngtsc/file_system\");\n\n  var reflection_1 = require(\"@angular/compiler-cli/src/ngtsc/reflection\");\n\n  function getOriginalSymbol(checker) {\n    return function (symbol) {\n      return ts.SymbolFlags.Alias & symbol.flags ? checker.getAliasedSymbol(symbol) : symbol;\n    };\n  }\n\n  exports.getOriginalSymbol = getOriginalSymbol;\n\n  function isDefined(value) {\n    return value !== undefined && value !== null;\n  }\n\n  exports.isDefined = isDefined;\n\n  function getNameText(name) {\n    return ts.isIdentifier(name) || ts.isLiteralExpression(name) ? name.text : name.getText();\n  }\n\n  exports.getNameText = getNameText;\n  /**\n   * Parse down the AST and capture all the nodes that satisfy the test.\n   * @param node The start node.\n   * @param test The function that tests whether a node should be included.\n   * @returns a collection of nodes that satisfy the test.\n   */\n\n  function findAll(node, test) {\n    var nodes = [];\n    findAllVisitor(node);\n    return nodes;\n\n    function findAllVisitor(n) {\n      if (test(n)) {\n        nodes.push(n);\n      } else {\n        n.forEachChild(function (child) {\n          return findAllVisitor(child);\n        });\n      }\n    }\n  }\n\n  exports.findAll = findAll;\n  /**\n   * Does the given declaration have a name which is an identifier?\n   * @param declaration The declaration to test.\n   * @returns true if the declaration has an identifier for a name.\n   */\n\n  function hasNameIdentifier(declaration) {\n    var namedDeclaration = declaration;\n    return namedDeclaration.name !== undefined && ts.isIdentifier(namedDeclaration.name);\n  }\n\n  exports.hasNameIdentifier = hasNameIdentifier;\n  /**\n   * Test whether a path is \"relative\".\n   *\n   * Relative paths start with `/`, `./` or `../` (or the Windows equivalents); or are simply `.` or\n   * `..`.\n   */\n\n  function isRelativePath(path) {\n    return file_system_1.isRooted(path) || /^\\.\\.?(\\/|\\\\|$)/.test(path);\n  }\n\n  exports.isRelativePath = isRelativePath;\n  /**\n   * A `Map`-like object that can compute and memoize a missing value for any key.\n   *\n   * The computed values are memoized, so the factory function is not called more than once per key.\n   * This is useful for storing values that are expensive to compute and may be used multiple times.\n   */\n  // NOTE:\n  // Ideally, this class should extend `Map`, but that causes errors in ES5 transpiled code:\n  // `TypeError: Constructor Map requires 'new'`\n\n  var FactoryMap =\n  /** @class */\n  function () {\n    function FactoryMap(factory, entries) {\n      this.factory = factory;\n      this.internalMap = new Map(entries);\n    }\n\n    FactoryMap.prototype.get = function (key) {\n      if (!this.internalMap.has(key)) {\n        this.internalMap.set(key, this.factory(key));\n      }\n\n      return this.internalMap.get(key);\n    };\n\n    FactoryMap.prototype.set = function (key, value) {\n      this.internalMap.set(key, value);\n    };\n\n    return FactoryMap;\n  }();\n\n  exports.FactoryMap = FactoryMap;\n  /**\n   * Attempt to resolve a `path` to a file by appending the provided `postFixes`\n   * to the `path` and checking if the file exists on disk.\n   * @returns An absolute path to the first matching existing file, or `null` if none exist.\n   */\n\n  function resolveFileWithPostfixes(fs, path, postFixes) {\n    var e_1, _a;\n\n    try {\n      for (var postFixes_1 = tslib_1.__values(postFixes), postFixes_1_1 = postFixes_1.next(); !postFixes_1_1.done; postFixes_1_1 = postFixes_1.next()) {\n        var postFix = postFixes_1_1.value;\n        var testPath = file_system_1.absoluteFrom(path + postFix);\n\n        if (fs.exists(testPath) && fs.stat(testPath).isFile()) {\n          return testPath;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (postFixes_1_1 && !postFixes_1_1.done && (_a = postFixes_1.return)) _a.call(postFixes_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return null;\n  }\n\n  exports.resolveFileWithPostfixes = resolveFileWithPostfixes;\n  /**\n   * Determine whether a function declaration corresponds with a TypeScript helper function, returning\n   * its kind if so or null if the declaration does not seem to correspond with such a helper.\n   */\n\n  function getTsHelperFnFromDeclaration(decl) {\n    if (!ts.isFunctionDeclaration(decl) && !ts.isVariableDeclaration(decl)) {\n      return null;\n    }\n\n    if (decl.name === undefined || !ts.isIdentifier(decl.name)) {\n      return null;\n    }\n\n    return getTsHelperFnFromIdentifier(decl.name);\n  }\n\n  exports.getTsHelperFnFromDeclaration = getTsHelperFnFromDeclaration;\n  /**\n   * Determine whether an identifier corresponds with a TypeScript helper function (based on its\n   * name), returning its kind if so or null if the identifier does not seem to correspond with such a\n   * helper.\n   */\n\n  function getTsHelperFnFromIdentifier(id) {\n    switch (stripDollarSuffix(id.text)) {\n      case '__assign':\n        return reflection_1.KnownDeclaration.TsHelperAssign;\n\n      case '__spread':\n        return reflection_1.KnownDeclaration.TsHelperSpread;\n\n      case '__spreadArrays':\n        return reflection_1.KnownDeclaration.TsHelperSpreadArrays;\n\n      default:\n        return null;\n    }\n  }\n\n  exports.getTsHelperFnFromIdentifier = getTsHelperFnFromIdentifier;\n  /**\n   * An identifier may become repeated when bundling multiple source files into a single bundle, so\n   * bundlers have a strategy of suffixing non-unique identifiers with a suffix like $2. This function\n   * strips off such suffixes, so that ngcc deals with the canonical name of an identifier.\n   * @param value The value to strip any suffix of, if applicable.\n   * @returns The canonical representation of the value, without any suffix.\n   */\n\n  function stripDollarSuffix(value) {\n    return value.replace(/\\$\\d+$/, '');\n  }\n\n  exports.stripDollarSuffix = stripDollarSuffix;\n\n  function stripExtension(fileName) {\n    return fileName.replace(/\\..+$/, '');\n  }\n\n  exports.stripExtension = stripExtension;\n});","map":{"version":3,"sources":["../../../../../../../packages/compiler-cli/ngcc/src/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as ts from 'typescript';\n\nimport {absoluteFrom, AbsoluteFsPath, isRooted, ReadonlyFileSystem} from '../../src/ngtsc/file_system';\nimport {DeclarationNode, KnownDeclaration} from '../../src/ngtsc/reflection';\n\n/**\n * A list (`Array`) of partially ordered `T` items.\n *\n * The items in the list are partially ordered in the sense that any element has either the same or\n * higher precedence than any element which appears later in the list. What \"higher precedence\"\n * means and how it is determined is implementation-dependent.\n *\n * See [PartiallyOrderedSet](https://en.wikipedia.org/wiki/Partially_ordered_set) for more details.\n * (Refraining from using the term \"set\" here, to avoid confusion with JavaScript's\n * [Set](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Set).)\n *\n * NOTE: A plain `Array<T>` is not assignable to a `PartiallyOrderedList<T>`, but a\n *       `PartiallyOrderedList<T>` is assignable to an `Array<T>`.\n */\nexport interface PartiallyOrderedList<T> extends Array<T> {\n  _partiallyOrdered: true;\n\n  map<U>(callbackfn: (value: T, index: number, array: PartiallyOrderedList<T>) => U, thisArg?: any):\n      PartiallyOrderedList<U>;\n  slice(...args: Parameters<Array<T>['slice']>): PartiallyOrderedList<T>;\n}\n\nexport function getOriginalSymbol(checker: ts.TypeChecker): (symbol: ts.Symbol) => ts.Symbol {\n  return function(symbol: ts.Symbol) {\n    return ts.SymbolFlags.Alias & symbol.flags ? checker.getAliasedSymbol(symbol) : symbol;\n  };\n}\n\nexport function isDefined<T>(value: T|undefined|null): value is T {\n  return (value !== undefined) && (value !== null);\n}\n\nexport function getNameText(name: ts.PropertyName|ts.BindingName): string {\n  return ts.isIdentifier(name) || ts.isLiteralExpression(name) ? name.text : name.getText();\n}\n\n/**\n * Parse down the AST and capture all the nodes that satisfy the test.\n * @param node The start node.\n * @param test The function that tests whether a node should be included.\n * @returns a collection of nodes that satisfy the test.\n */\nexport function findAll<T>(node: ts.Node, test: (node: ts.Node) => node is ts.Node & T): T[] {\n  const nodes: T[] = [];\n  findAllVisitor(node);\n  return nodes;\n\n  function findAllVisitor(n: ts.Node) {\n    if (test(n)) {\n      nodes.push(n);\n    } else {\n      n.forEachChild(child => findAllVisitor(child));\n    }\n  }\n}\n\n/**\n * Does the given declaration have a name which is an identifier?\n * @param declaration The declaration to test.\n * @returns true if the declaration has an identifier for a name.\n */\nexport function hasNameIdentifier(declaration: ts.Node): declaration is DeclarationNode&\n    {name: ts.Identifier} {\n  const namedDeclaration: ts.Node&{name?: ts.Node} = declaration;\n  return namedDeclaration.name !== undefined && ts.isIdentifier(namedDeclaration.name);\n}\n\n/**\n * Test whether a path is \"relative\".\n *\n * Relative paths start with `/`, `./` or `../` (or the Windows equivalents); or are simply `.` or\n * `..`.\n */\nexport function isRelativePath(path: string): boolean {\n  return isRooted(path) || /^\\.\\.?(\\/|\\\\|$)/.test(path);\n}\n\n/**\n * A `Map`-like object that can compute and memoize a missing value for any key.\n *\n * The computed values are memoized, so the factory function is not called more than once per key.\n * This is useful for storing values that are expensive to compute and may be used multiple times.\n */\n// NOTE:\n// Ideally, this class should extend `Map`, but that causes errors in ES5 transpiled code:\n// `TypeError: Constructor Map requires 'new'`\nexport class FactoryMap<K, V> {\n  private internalMap: Map<K, V>;\n\n  constructor(private factory: (key: K) => V, entries?: readonly(readonly[K, V])[]|null) {\n    this.internalMap = new Map(entries);\n  }\n\n  get(key: K): V {\n    if (!this.internalMap.has(key)) {\n      this.internalMap.set(key, this.factory(key));\n    }\n\n    return this.internalMap.get(key)!;\n  }\n\n  set(key: K, value: V): void {\n    this.internalMap.set(key, value);\n  }\n}\n\n/**\n * Attempt to resolve a `path` to a file by appending the provided `postFixes`\n * to the `path` and checking if the file exists on disk.\n * @returns An absolute path to the first matching existing file, or `null` if none exist.\n */\nexport function resolveFileWithPostfixes(\n    fs: ReadonlyFileSystem, path: AbsoluteFsPath, postFixes: string[]): AbsoluteFsPath|null {\n  for (const postFix of postFixes) {\n    const testPath = absoluteFrom(path + postFix);\n    if (fs.exists(testPath) && fs.stat(testPath).isFile()) {\n      return testPath;\n    }\n  }\n  return null;\n}\n\n/**\n * Determine whether a function declaration corresponds with a TypeScript helper function, returning\n * its kind if so or null if the declaration does not seem to correspond with such a helper.\n */\nexport function getTsHelperFnFromDeclaration(decl: DeclarationNode): KnownDeclaration|null {\n  if (!ts.isFunctionDeclaration(decl) && !ts.isVariableDeclaration(decl)) {\n    return null;\n  }\n\n  if (decl.name === undefined || !ts.isIdentifier(decl.name)) {\n    return null;\n  }\n\n  return getTsHelperFnFromIdentifier(decl.name);\n}\n\n/**\n * Determine whether an identifier corresponds with a TypeScript helper function (based on its\n * name), returning its kind if so or null if the identifier does not seem to correspond with such a\n * helper.\n */\nexport function getTsHelperFnFromIdentifier(id: ts.Identifier): KnownDeclaration|null {\n  switch (stripDollarSuffix(id.text)) {\n    case '__assign':\n      return KnownDeclaration.TsHelperAssign;\n    case '__spread':\n      return KnownDeclaration.TsHelperSpread;\n    case '__spreadArrays':\n      return KnownDeclaration.TsHelperSpreadArrays;\n    default:\n      return null;\n  }\n}\n\n/**\n * An identifier may become repeated when bundling multiple source files into a single bundle, so\n * bundlers have a strategy of suffixing non-unique identifiers with a suffix like $2. This function\n * strips off such suffixes, so that ngcc deals with the canonical name of an identifier.\n * @param value The value to strip any suffix of, if applicable.\n * @returns The canonical representation of the value, without any suffix.\n */\nexport function stripDollarSuffix(value: string): string {\n  return value.replace(/\\$\\d+$/, '');\n}\n\nexport function stripExtension(fileName: string): string {\n  return fileName.replace(/\\..+$/, '');\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"script"}