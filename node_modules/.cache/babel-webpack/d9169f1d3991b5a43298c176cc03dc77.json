{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _objectSpread = require(\"/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar fs = require('fs');\n\nvar arrayUnion = require('array-union');\n\nvar merge2 = require('merge2');\n\nvar fastGlob = require('fast-glob');\n\nvar dirGlob = require('dir-glob');\n\nvar gitignore = require('./gitignore');\n\nvar _require = require('./stream-utils'),\n    FilterStream = _require.FilterStream,\n    UniqueStream = _require.UniqueStream;\n\nvar DEFAULT_FILTER = function DEFAULT_FILTER() {\n  return false;\n};\n\nvar isNegative = function isNegative(pattern) {\n  return pattern[0] === '!';\n};\n\nvar assertPatternsInput = function assertPatternsInput(patterns) {\n  if (!patterns.every(function (pattern) {\n    return typeof pattern === 'string';\n  })) {\n    throw new TypeError('Patterns must be a string or an array of strings');\n  }\n};\n\nvar checkCwdOption = function checkCwdOption() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!options.cwd) {\n    return;\n  }\n\n  var stat;\n\n  try {\n    stat = fs.statSync(options.cwd);\n  } catch (_unused) {\n    return;\n  }\n\n  if (!stat.isDirectory()) {\n    throw new Error('The `cwd` option must be a path to a directory');\n  }\n};\n\nvar getPathString = function getPathString(p) {\n  return p.stats instanceof fs.Stats ? p.path : p;\n};\n\nvar generateGlobTasks = function generateGlobTasks(patterns, taskOptions) {\n  patterns = arrayUnion([].concat(patterns));\n  assertPatternsInput(patterns);\n  checkCwdOption(taskOptions);\n  var globTasks = [];\n  taskOptions = _objectSpread({\n    ignore: [],\n    expandDirectories: true\n  }, taskOptions);\n\n  var _iterator = _createForOfIteratorHelper(patterns.entries()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          index = _step$value[0],\n          pattern = _step$value[1];\n\n      if (isNegative(pattern)) {\n        continue;\n      }\n\n      var ignore = patterns.slice(index).filter(function (pattern) {\n        return isNegative(pattern);\n      }).map(function (pattern) {\n        return pattern.slice(1);\n      });\n\n      var options = _objectSpread(_objectSpread({}, taskOptions), {}, {\n        ignore: taskOptions.ignore.concat(ignore)\n      });\n\n      globTasks.push({\n        pattern: pattern,\n        options: options\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return globTasks;\n};\n\nvar globDirs = function globDirs(task, fn) {\n  var options = {};\n\n  if (task.options.cwd) {\n    options.cwd = task.options.cwd;\n  }\n\n  if (Array.isArray(task.options.expandDirectories)) {\n    options = _objectSpread(_objectSpread({}, options), {}, {\n      files: task.options.expandDirectories\n    });\n  } else if (typeof task.options.expandDirectories === 'object') {\n    options = _objectSpread(_objectSpread({}, options), task.options.expandDirectories);\n  }\n\n  return fn(task.pattern, options);\n};\n\nvar getPattern = function getPattern(task, fn) {\n  return task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];\n};\n\nvar getFilterSync = function getFilterSync(options) {\n  return options && options.gitignore ? gitignore.sync({\n    cwd: options.cwd,\n    ignore: options.ignore\n  }) : DEFAULT_FILTER;\n};\n\nvar globToTask = function globToTask(task) {\n  return function (glob) {\n    var options = task.options;\n\n    if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n      options.ignore = dirGlob.sync(options.ignore);\n    }\n\n    return {\n      pattern: glob,\n      options: options\n    };\n  };\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(patterns, options) {\n    var globTasks, getFilter, getTasks, _yield$Promise$all, _yield$Promise$all2, filter, tasks, paths;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            globTasks = generateGlobTasks(patterns, options);\n\n            getFilter = /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        return _context.abrupt(\"return\", options && options.gitignore ? gitignore({\n                          cwd: options.cwd,\n                          ignore: options.ignore\n                        }) : DEFAULT_FILTER);\n\n                      case 1:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function getFilter() {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n\n            getTasks = /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                var tasks;\n                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return Promise.all(globTasks.map( /*#__PURE__*/function () {\n                          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(task) {\n                            var globs;\n                            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                              while (1) {\n                                switch (_context2.prev = _context2.next) {\n                                  case 0:\n                                    _context2.next = 2;\n                                    return getPattern(task, dirGlob);\n\n                                  case 2:\n                                    globs = _context2.sent;\n                                    return _context2.abrupt(\"return\", Promise.all(globs.map(globToTask(task))));\n\n                                  case 4:\n                                  case \"end\":\n                                    return _context2.stop();\n                                }\n                              }\n                            }, _callee2);\n                          }));\n\n                          return function (_x3) {\n                            return _ref4.apply(this, arguments);\n                          };\n                        }()));\n\n                      case 2:\n                        tasks = _context3.sent;\n                        return _context3.abrupt(\"return\", arrayUnion.apply(void 0, _toConsumableArray(tasks)));\n\n                      case 4:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n\n              return function getTasks() {\n                return _ref3.apply(this, arguments);\n              };\n            }();\n\n            _context4.next = 5;\n            return Promise.all([getFilter(), getTasks()]);\n\n          case 5:\n            _yield$Promise$all = _context4.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n            filter = _yield$Promise$all2[0];\n            tasks = _yield$Promise$all2[1];\n            _context4.next = 11;\n            return Promise.all(tasks.map(function (task) {\n              return fastGlob(task.pattern, task.options);\n            }));\n\n          case 11:\n            paths = _context4.sent;\n            return _context4.abrupt(\"return\", arrayUnion.apply(void 0, _toConsumableArray(paths)).filter(function (path_) {\n              return !filter(getPathString(path_));\n            }));\n\n          case 13:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports.sync = function (patterns, options) {\n  var globTasks = generateGlobTasks(patterns, options);\n  var tasks = [];\n\n  var _iterator2 = _createForOfIteratorHelper(globTasks),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _task = _step2.value;\n      var newTask = getPattern(_task, dirGlob.sync).map(globToTask(_task));\n      tasks.push.apply(tasks, _toConsumableArray(newTask));\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var filter = getFilterSync(options);\n  var matches = [];\n\n  for (var _i = 0, _tasks = tasks; _i < _tasks.length; _i++) {\n    var task = _tasks[_i];\n    matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));\n  }\n\n  return matches.filter(function (path_) {\n    return !filter(path_);\n  });\n};\n\nmodule.exports.stream = function (patterns, options) {\n  var globTasks = generateGlobTasks(patterns, options);\n  var tasks = [];\n\n  var _iterator3 = _createForOfIteratorHelper(globTasks),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var task = _step3.value;\n      var newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n      tasks.push.apply(tasks, _toConsumableArray(newTask));\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  var filter = getFilterSync(options);\n  var filterStream = new FilterStream(function (p) {\n    return !filter(p);\n  });\n  var uniqueStream = new UniqueStream();\n  return merge2(tasks.map(function (task) {\n    return fastGlob.stream(task.pattern, task.options);\n  })).pipe(filterStream).pipe(uniqueStream);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = function (patterns, options) {\n  return [].concat(patterns).some(function (pattern) {\n    return fastGlob.isDynamicPattern(pattern, options);\n  });\n};\n\nmodule.exports.gitignore = gitignore;","map":{"version":3,"sources":["/Users/abdillahihussein/Documents/GitHub/angularProject/node_modules/globby/index.js"],"names":["fs","require","arrayUnion","merge2","fastGlob","dirGlob","gitignore","FilterStream","UniqueStream","DEFAULT_FILTER","isNegative","pattern","assertPatternsInput","patterns","every","TypeError","checkCwdOption","options","cwd","stat","statSync","isDirectory","Error","getPathString","p","stats","Stats","path","generateGlobTasks","taskOptions","concat","globTasks","ignore","expandDirectories","entries","index","slice","filter","map","push","globDirs","task","fn","Array","isArray","files","getPattern","getFilterSync","sync","globToTask","glob","module","exports","getFilter","getTasks","Promise","all","globs","tasks","paths","path_","newTask","matches","stream","filterStream","uniqueStream","pipe","hasMagic","some","isDynamicPattern"],"mappings":"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","sourcesContent":["'use strict';\nconst fs = require('fs');\nconst arrayUnion = require('array-union');\nconst merge2 = require('merge2');\nconst fastGlob = require('fast-glob');\nconst dirGlob = require('dir-glob');\nconst gitignore = require('./gitignore');\nconst {FilterStream, UniqueStream} = require('./stream-utils');\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n\tif (!patterns.every(pattern => typeof pattern === 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst checkCwdOption = (options = {}) => {\n\tif (!options.cwd) {\n\t\treturn;\n\t}\n\n\tlet stat;\n\ttry {\n\t\tstat = fs.statSync(options.cwd);\n\t} catch {\n\t\treturn;\n\t}\n\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error('The `cwd` option must be a path to a directory');\n\t}\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nconst generateGlobTasks = (patterns, taskOptions) => {\n\tpatterns = arrayUnion([].concat(patterns));\n\tassertPatternsInput(patterns);\n\tcheckCwdOption(taskOptions);\n\n\tconst globTasks = [];\n\n\ttaskOptions = {\n\t\tignore: [],\n\t\texpandDirectories: true,\n\t\t...taskOptions\n\t};\n\n\tfor (const [index, pattern] of patterns.entries()) {\n\t\tif (isNegative(pattern)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ignore = patterns\n\t\t\t.slice(index)\n\t\t\t.filter(pattern => isNegative(pattern))\n\t\t\t.map(pattern => pattern.slice(1));\n\n\t\tconst options = {\n\t\t\t...taskOptions,\n\t\t\tignore: taskOptions.ignore.concat(ignore)\n\t\t};\n\n\t\tglobTasks.push({pattern, options});\n\t}\n\n\treturn globTasks;\n};\n\nconst globDirs = (task, fn) => {\n\tlet options = {};\n\tif (task.options.cwd) {\n\t\toptions.cwd = task.options.cwd;\n\t}\n\n\tif (Array.isArray(task.options.expandDirectories)) {\n\t\toptions = {\n\t\t\t...options,\n\t\t\tfiles: task.options.expandDirectories\n\t\t};\n\t} else if (typeof task.options.expandDirectories === 'object') {\n\t\toptions = {\n\t\t\t...options,\n\t\t\t...task.options.expandDirectories\n\t\t};\n\t}\n\n\treturn fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];\n\nconst getFilterSync = options => {\n\treturn options && options.gitignore ?\n\t\tgitignore.sync({cwd: options.cwd, ignore: options.ignore}) :\n\t\tDEFAULT_FILTER;\n};\n\nconst globToTask = task => glob => {\n\tconst {options} = task;\n\tif (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n\t\toptions.ignore = dirGlob.sync(options.ignore);\n\t}\n\n\treturn {\n\t\tpattern: glob,\n\t\toptions\n\t};\n};\n\nmodule.exports = async (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst getFilter = async () => {\n\t\treturn options && options.gitignore ?\n\t\t\tgitignore({cwd: options.cwd, ignore: options.ignore}) :\n\t\t\tDEFAULT_FILTER;\n\t};\n\n\tconst getTasks = async () => {\n\t\tconst tasks = await Promise.all(globTasks.map(async task => {\n\t\t\tconst globs = await getPattern(task, dirGlob);\n\t\t\treturn Promise.all(globs.map(globToTask(task)));\n\t\t}));\n\n\t\treturn arrayUnion(...tasks);\n\t};\n\n\tconst [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n\tconst paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n\n\treturn arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\n\nmodule.exports.sync = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = [];\n\tfor (const task of globTasks) {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\ttasks.push(...newTask);\n\t}\n\n\tconst filter = getFilterSync(options);\n\n\tlet matches = [];\n\tfor (const task of tasks) {\n\t\tmatches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));\n\t}\n\n\treturn matches.filter(path_ => !filter(path_));\n};\n\nmodule.exports.stream = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = [];\n\tfor (const task of globTasks) {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\ttasks.push(...newTask);\n\t}\n\n\tconst filter = getFilterSync(options);\n\tconst filterStream = new FilterStream(p => !filter(p));\n\tconst uniqueStream = new UniqueStream();\n\n\treturn merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))\n\t\t.pipe(filterStream)\n\t\t.pipe(uniqueStream);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = (patterns, options) => []\n\t.concat(patterns)\n\t.some(pattern => fastGlob.isDynamicPattern(pattern, options));\n\nmodule.exports.gitignore = gitignore;\n"]},"metadata":{},"sourceType":"script"}